status" >&5
  test $ac_status = 0; }; }; then :
  rc=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5
 rc=1


fi
	rm -Rf build


	if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

	else
		if test "x$enable_linux_builtin" != xyes; then

	grep -q -E '[[:space:]]mount_nodev[[:space:]]' \
		$LINUX_OBJ/$LINUX_SYMBOLS 2>/dev/null
	rc=$?
	if test $rc -ne 0; then
		export=0
		for file in fs/super.c; do
			grep -q -E "EXPORT_SYMBOL.*(mount_nodev)" \
				"$LINUX/$file" 2>/dev/null
			rc=$?
			if test $rc -eq 0; then
				export=1
				break;
			fi
		done
		if test $export -eq 0; then :
			rc=1
		else :
			rc=0
		fi
	else :
		rc=0
	fi

		fi
		if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

		else :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_MOUNT_NODEV 1" >>confdefs.h


		fi
	fi



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether super_block has s_shrink" >&5
$as_echo_n "checking whether super_block has s_shrink... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

		int shrink(struct shrinker *s, struct shrink_control *sc)
		    { return 0; }

		static const struct super_block
		    sb __attribute__ ((unused)) = {
			.s_shrink.shrink = shrink,
			.s_shrink.seeks = DEFAULT_SEEKS,
			.s_shrink.batch = 0,
		};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_SHRINK 1" >>confdefs.h



else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether shrink_control has nid" >&5
$as_echo_n "checking whether shrink_control has nid... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

int
main (void)
{

		struct shrink_control sc __attribute__ ((unused));
		unsigned long scnidsize __attribute__ ((unused)) =
		    sizeof(sc.nid);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define SHRINK_CONTROL_HAS_NID 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether super_block has s_instances list_head" >&5
$as_echo_n "checking whether super_block has s_instances list_head... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

int
main (void)
{

		struct super_block sb __attribute__ ((unused));

		INIT_LIST_HEAD(&sb.s_instances);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_S_INSTANCES_LIST_HEAD 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether super_block has s_d_op" >&5
$as_echo_n "checking whether super_block has s_d_op... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

int
main (void)
{

		struct super_block sb __attribute__ ((unused));
		sb.s_d_op = NULL;

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_S_D_OP 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether bdi_setup_and_register() wants 2 args" >&5
$as_echo_n "checking whether bdi_setup_and_register() wants 2 args... " >&6; }



cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/backing-dev.h>
		struct backing_dev_info bdi;

int
main (void)
{

		char *name = "bdi";
		int error __attribute__((unused)) =
		    bdi_setup_and_register(&bdi, name);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :
  rc=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5
 rc=1


fi
	rm -Rf build


	if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether bdi_setup_and_register() wants 3 args" >&5
$as_echo_n "checking whether bdi_setup_and_register() wants 3 args... " >&6; }



cat confdefs.h - <<_ACEOF >conftest.c


			#include <linux/backing-dev.h>
			struct backing_dev_info bdi;

int
main (void)
{

			char *name = "bdi";
			unsigned int cap = BDI_CAP_MAP_COPY;
			int error __attribute__((unused)) =
			    bdi_setup_and_register(&bdi, name, cap);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :
  rc=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5
 rc=1


fi
	rm -Rf build


	if test $rc -ne 0; then :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

	else
		if test "x$enable_linux_builtin" != xyes; then

	grep -q -E '[[:space:]]bdi_setup_and_register[[:space:]]' \
		$LINUX_OBJ/$LINUX_SYMBOLS 2>/dev/null
	rc=$?
	if test $rc -ne 0; then
		export=0
		for file in mm/backing-dev.c; do
			grep -q -E "EXPORT_SYMBOL.*(bdi_setup_and_register)" \
				"$LINUX/$file" 2>/dev/null
			rc=$?
			if test $rc -eq 0; then
				export=1
				break;
			fi
		done
		if test $export -eq 0; then :
			rc=1
		else :
			rc=0
		fi
	else :
		rc=0
	fi

		fi
		if test $rc -ne 0; then :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

		else :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_3ARGS_BDI_SETUP_AND_REGISTER 1" >>confdefs.h


		fi
	fi


	else
		if test "x$enable_linux_builtin" != xyes; then

	grep -q -E '[[:space:]]bdi_setup_and_register[[:space:]]' \
		$LINUX_OBJ/$LINUX_SYMBOLS 2>/dev/null
	rc=$?
	if test $rc -ne 0; then
		export=0
		for file in mm/backing-dev.c; do
			grep -q -E "EXPORT_SYMBOL.*(bdi_setup_and_register)" \
				"$LINUX/$file" 2>/dev/null
			rc=$?
			if test $rc -eq 0; then
				export=1
				break;
			fi
		done
		if test $export -eq 0; then :
			rc=1
		else :
			rc=0
		fi
	else :
		rc=0
	fi

		fi
		if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether bdi_setup_and_register() wants 3 args" >&5
$as_echo_n "checking whether bdi_setup_and_register() wants 3 args... " >&6; }



cat confdefs.h - <<_ACEOF >conftest.c


			#include <linux/backing-dev.h>
			struct backing_dev_info bdi;

int
main (void)
{

			char *name = "bdi";
			unsigned int cap = BDI_CAP_MAP_COPY;
			int error __attribute__((unused)) =
			    bdi_setup_and_register(&bdi, name, cap);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :
  rc=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5
 rc=1


fi
	rm -Rf build


	if test $rc -ne 0; then :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

	else
		if test "x$enable_linux_builtin" != xyes; then

	grep -q -E '[[:space:]]bdi_setup_and_register[[:space:]]' \
		$LINUX_OBJ/$LINUX_SYMBOLS 2>/dev/null
	rc=$?
	if test $rc -ne 0; then
		export=0
		for file in mm/backing-dev.c; do
			grep -q -E "EXPORT_SYMBOL.*(bdi_setup_and_register)" \
				"$LINUX/$file" 2>/dev/null
			rc=$?
			if test $rc -eq 0; then
				export=1
				break;
			fi
		done
		if test $export -eq 0; then :
			rc=1
		else :
			rc=0
		fi
	else :
		rc=0
	fi

		fi
		if test $rc -ne 0; then :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

		else :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_3ARGS_BDI_SETUP_AND_REGISTER 1" >>confdefs.h


		fi
	fi


		else :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_2ARGS_BDI_SETUP_AND_REGISTER 1" >>confdefs.h


		fi
	fi



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether set_nlink() is available" >&5
$as_echo_n "checking whether set_nlink() is available... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

int
main (void)
{

		struct inode node;
		unsigned int link = 0;
		(void) set_nlink(&node, link);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_SET_NLINK 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether elevator_change() is available" >&5
$as_echo_n "checking whether elevator_change() is available... " >&6; }
	tmp_flags="$EXTRA_KCFLAGS"
	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/blkdev.h>
		#include <linux/elevator.h>

int
main (void)
{

		int ret;
		struct request_queue *q = NULL;
		char *elevator = NULL;
		ret = elevator_change(q, elevator);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_ELEVATOR_CHANGE 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build


	EXTRA_KCFLAGS="$tmp_flags"

	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether sget() wants 5 args" >&5
$as_echo_n "checking whether sget() wants 5 args... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

int
main (void)
{

		struct file_system_type *type = NULL;
		int (*test)(struct super_block *,void *) = NULL;
		int (*set)(struct super_block *,void *) = NULL;
		int flags = 0;
		void *data = NULL;
		(void) sget(type, test, set, flags, data);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_5ARG_SGET 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lseek_execute() is available" >&5
$as_echo_n "checking whether lseek_execute() is available... " >&6; }



cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

int
main (void)
{

		struct file *fp __attribute__ ((unused)) = NULL;
		struct inode *ip __attribute__ ((unused)) = NULL;
		loff_t offset __attribute__ ((unused)) = 0;
		loff_t maxsize __attribute__ ((unused)) = 0;

		lseek_execute(fp, ip, offset, maxsize);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :
  rc=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5
 rc=1


fi
	rm -Rf build


	if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

	else
		if test "x$enable_linux_builtin" != xyes; then

	grep -q -E '[[:space:]]lseek_exclusive[[:space:]]' \
		$LINUX_OBJ/$LINUX_SYMBOLS 2>/dev/null
	rc=$?
	if test $rc -ne 0; then
		export=0
		for file in fs/read_write.c; do
			grep -q -E "EXPORT_SYMBOL.*(lseek_exclusive)" \
				"$LINUX/$file" 2>/dev/null
			rc=$?
			if test $rc -eq 0; then
				export=1
				break;
			fi
		done
		if test $export -eq 0; then :
			rc=1
		else :
			rc=0
		fi
	else :
		rc=0
	fi

		fi
		if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

		else :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_LSEEK_EXECUTE 1" >>confdefs.h


		fi
	fi



				{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether fops->iterate_shared() is available" >&5
$as_echo_n "checking whether fops->iterate_shared() is available... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>
		int iterate(struct file *filp, struct dir_context * context)
		    { return 0; }

		static const struct file_operations fops
		    __attribute__ ((unused)) = {
			.iterate_shared	 = iterate,
		};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_VFS_ITERATE_SHARED 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

								{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether fops->iterate() is available" >&5
$as_echo_n "checking whether fops->iterate() is available... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


			#include <linux/fs.h>
			int iterate(struct file *filp, struct dir_context * context)
			    { return 0; }

			static const struct file_operations fops
			    __attribute__ ((unused)) = {
				.iterate	 = iterate,
			};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_VFS_ITERATE 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether fops->readdir() is available" >&5
$as_echo_n "checking whether fops->readdir() is available... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


				#include <linux/fs.h>
				int readdir(struct file *filp, void *entry, filldir_t func)
				    { return 0; }

				static const struct file_operations fops
				    __attribute__ ((unused)) = {
					.readdir = readdir,
				};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_VFS_READDIR 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

				as_fn_error $? "no; file a bug report with ZFSOnLinux" "$LINENO" 5



fi
	rm -Rf build





fi
	rm -Rf build





fi
	rm -Rf build



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether fops->read/write_iter() are available" >&5
$as_echo_n "checking whether fops->read/write_iter() are available... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>

		ssize_t test_read(struct kiocb *kiocb, struct iov_iter *to)
		    { return 0; }
		ssize_t test_write(struct kiocb *kiocb, struct iov_iter *from)
		    { return 0; }

		static const struct file_operations
		    fops __attribute__ ((unused)) = {
		    .read_iter = test_read,
		    .write_iter = test_write,
		};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_VFS_RW_ITERATE 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether generic_write_checks() takes kiocb" >&5
$as_echo_n "checking whether generic_write_checks() takes kiocb... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>


int
main (void)
{

		struct kiocb *iocb = NULL;
		struct iov_iter *iov = NULL;
		generic_write_checks(iocb, iov);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_GENERIC_WRITE_CHECKS_KIOCB 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether kmap_atomic wants 1 args" >&5
$as_echo_n "checking whether kmap_atomic wants 1 args... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/pagemap.h>

int
main (void)
{

		struct page page;
		kmap_atomic(&page);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_1ARG_KMAP_ATOMIC 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether follow_down_one() is available" >&5
$as_echo_n "checking whether follow_down_one() is available... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/namei.h>

int
main (void)
{

		struct path *p = NULL;
		follow_down_one(p);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_FOLLOW_DOWN_ONE 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether make_request_fn() returns int" >&5
$as_echo_n "checking whether make_request_fn() returns int... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/blkdev.h>

		int make_request(struct request_queue *q, struct bio *bio)
		{
			return (0);
		}

int
main (void)
{

		blk_queue_make_request(NULL, &make_request);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define MAKE_REQUEST_FN_RET int" >>confdefs.h


$as_echo "#define HAVE_MAKE_REQUEST_FN_RET_INT 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether make_request_fn() returns void" >&5
$as_echo_n "checking whether make_request_fn() returns void... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


			#include <linux/blkdev.h>

			void make_request(struct request_queue *q, struct bio *bio)
			{
				return;
			}

int
main (void)
{

			blk_queue_make_request(NULL, &make_request);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define MAKE_REQUEST_FN_RET void" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether make_request_fn() returns blk_qc_t" >&5
$as_echo_n "checking whether make_request_fn() returns blk_qc_t... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


				#include <linux/blkdev.h>

				blk_qc_t make_request(struct request_queue *q, struct bio *bio)
				{
					return (BLK_QC_T_NONE);
				}

int
main (void)
{

				blk_queue_make_request(NULL, &make_request);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define MAKE_REQUEST_FN_RET blk_qc_t" >>confdefs.h


$as_echo "#define HAVE_MAKE_REQUEST_FN_RET_QC 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

				as_fn_error $? "no - Please file a bug report at
				    https://github.com/zfsonlinux/zfs/issues/new" "$LINENO" 5



fi
	rm -Rf build





fi
	rm -Rf build





fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether generic IO accounting symbols are avaliable" >&5
$as_echo_n "checking whether generic IO accounting symbols are avaliable... " >&6; }



cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/bio.h>

		void (*generic_start_io_acct_f)(int, unsigned long,
		    struct hd_struct *) = &generic_start_io_acct;
		void (*generic_end_io_acct_f)(int, struct hd_struct *,
		    unsigned long) = &generic_end_io_acct;

int
main (void)
{

		generic_start_io_acct(0, 0, NULL);
		generic_end_io_acct(0, NULL, 0);

  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :
  rc=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5
 rc=1


fi
	rm -Rf build


	if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

	else
		if test "x$enable_linux_builtin" != xyes; then

	grep -q -E '[[:space:]]generic_start_io_acct[[:space:]]' \
		$LINUX_OBJ/$LINUX_SYMBOLS 2>/dev/null
	rc=$?
	if test $rc -ne 0; then
		export=0
		for file in block/bio.c; do
			grep -q -E "EXPORT_SYMBOL.*(generic_start_io_acct)" \
				"$LINUX/$file" 2>/dev/null
			rc=$?
			if test $rc -eq 0; then
				export=1
				break;
			fi
		done
		if test $export -eq 0; then :
			rc=1
		else :
			rc=0
		fi
	else :
		rc=0
	fi

		fi
		if test $rc -ne 0; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }

		else :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_GENERIC_IO_ACCT 1" >>confdefs.h


		fi
	fi



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether iops->rename() wants flags" >&5
$as_echo_n "checking whether iops->rename() wants flags... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>
		int rename_fn(struct inode *sip, struct dentry *sdp,
			struct inode *tip, struct dentry *tdp,
			unsigned int flags) { return 0; }

		static const struct inode_operations
		    iops __attribute__ ((unused)) = {
			.rename = rename_fn,
		};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_RENAME_WANTS_FLAGS 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether generic_setxattr() exists" >&5
$as_echo_n "checking whether generic_setxattr() exists... " >&6; }


cat confdefs.h - <<_ACEOF >conftest.c


		#include <linux/fs.h>
		#include <linux/xattr.h>

		static const struct inode_operations
		    iops __attribute__ ((unused)) = {
			.setxattr = generic_setxattr
		};

int
main (void)
{


  ;
  return 0;
}

_ACEOF



cat - <<_ACEOF >conftest.h

_ACEOF


	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
	echo "obj-m := conftest.o" >build/Makefile
	modpost_flag=''
	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
	if { ac_try='cp conftest.c conftest.h build && make modules -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; } >/dev/null && { ac_try='test -s build/conftest.o'
  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
  (eval $ac_try) 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }

$as_echo "#define HAVE_GENERIC_SETXATTR 1" >>confdefs.h


else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }



fi
	rm -Rf build




	if test "$LINUX_OBJ" != "$LINUX"; then :

		KERNELMAKE_PARAMS="$KERNELMAKE_PARAMS O=$LINUX_OBJ"

fi



			KERNELCPPFLAGS="$KERNELCPPFLAGS $NO_UNUSED_BUT_SET_VARIABLE"
	KERNELCPPFLAGS="$KERNELCPPFLAGS $NO_BOOL_COMPARE"
	KERNELCPPFLAGS="$KERNELCPPFLAGS -DHAVE_SPL -D_KERNEL"
	KERNELCPPFLAGS="$KERNELCPPFLAGS -DTEXT_DOMAIN=\\\"zfs-linux-kernel\\\""


 ;;
		srpm)                        ;;
		*)
		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Error!" >&5
$as_echo "Error!" >&6; }
		as_fn_error $? "Bad value \"$ZFS_CONFIG\" for --with-config,
		              user kernel|user|all|srpm" "$LINENO" 5 ;;
	esac

	 if test "$ZFS_CONFIG" = user -o "$ZFS_CONFIG" = all; then
  CONFIG_USER_TRUE=
  CONFIG_USER_FALSE='#'
else
  CONFIG_USER_TRUE='#'
  CONFIG_USER_FALSE=
fi

	 if test "$ZFS_CONFIG" = kernel -o "$ZFS_CONFIG" = all &&
		       test "x$enable_linux_builtin" != xyes ; then
  CONFIG_KERNEL_TRUE=
  CONFIG_KERNEL_FALSE='#'
else
  CONFIG_KERNEL_TRUE='#'
  CONFIG_KERNEL_FALSE=
fi



	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether debugging is enabled" >&5
$as_echo_n "checking whether debugging is enabled... " >&6; }
	# Check whether --enable-debug was given.
if test "${enable_debug+set}" = set; then :
  enableval=$enable_debug;
else
  enable_debug=no
fi


	if test "x$enable_debug" = xyes; then :

		KERNELCPPFLAGS="${KERNELCPPFLAGS} -DDEBUG -Werror"
		HOSTCFLAGS="${HOSTCFLAGS} -DDEBUG -Werror"
		DEBUG_CFLAGS="-DDEBUG -Werror"
		DEBUG_STACKFLAGS="-fstack-check"
		DEBUG_ZFS="_with_debug"

$as_echo "#define ZFS_DEBUG 1" >>confdefs.h


else

		KERNELCPPFLAGS="${KERNELCPPFLAGS} -DNDEBUG "
		HOSTCFLAGS="${HOSTCFLAGS} -DNDEBUG "
		DEBUG_CFLAGS="-DNDEBUG"
		DEBUG_STACKFLAGS=""
		DEBUG_ZFS="_without_debug"

fi




	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_debug" >&5
$as_echo "$enable_debug" >&6; }


	# Check whether --enable-debug-dmu-tx was given.
if test "${enable_debug_dmu_tx+set}" = set; then :
  enableval=$enable_debug_dmu_tx;
else
  enable_debug_dmu_tx=no
fi


	if test "x$enable_debug_dmu_tx" = xyes; then :

		KERNELCPPFLAGS="${KERNELCPPFLAGS} -DDEBUG_DMU_TX"
		DEBUG_DMU_TX="_with_debug_dmu_tx"

$as_echo "#define DEBUG_DMU_TX 1" >>confdefs.h


else

		DEBUG_DMU_TX="_without_debug_dmu_tx"

fi


	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether dmu tx validation is enabled" >&5
$as_echo_n "checking whether dmu tx validation is enabled... " >&6; }
	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_debug_dmu_tx" >&5
$as_echo "$enable_debug_dmu_tx" >&6; }


ac_config_files="$ac_config_files Makefile udev/Makefile udev/rules.d/Makefile etc/Makefile etc/init.d/Makefile etc/zfs/Makefile etc/systemd/Makefile etc/systemd/system/Makefile etc/modules-load.d/Makefile man/Makefile man/man1/Makefile man/man5/Makefile man/man8/Makefile lib/Makefile lib/libspl/Makefile lib/libspl/asm-generic/Makefile lib/libspl/asm-i386/Makefile lib/libspl/asm-x86_64/Makefile lib/libspl/include/Makefile lib/libspl/include/ia32/Makefile lib/libspl/include/ia32/sys/Makefile lib/libspl/include/rpc/Makefile lib/libspl/include/sys/Makefile lib/libspl/include/sys/sysevent/Makefile lib/libspl/include/sys/dktp/Makefile lib/libspl/include/util/Makefile lib/libavl/Makefile lib/libefi/Makefile lib/libnvpair/Makefile lib/libunicode/Makefile lib/libuutil/Makefile lib/libzpool/Makefile lib/libzfs/libzfs.pc lib/libzfs/libzfs_core.pc lib/libzfs/Makefile lib/libzfs_core/Makefile lib/libshare/Makefile cmd/Makefile cmd/zdb/Makefile cmd/zhack/Makefile cmd/zfs/Makefile cmd/zinject/Makefile cmd/zpool/Makefile cmd/zstreamdump/Makefile cmd/ztest/Makefile cmd/zpios/Makefile cmd/mount_zfs/Makefile cmd/fsck_zfs/Makefile cmd/zvol_id/Makefile cmd/vdev_id/Makefile cmd/arcstat/Makefile cmd/dbufstat/Makefile cmd/arc_summary/Makefile cmd/zed/Makefile contrib/Makefile contrib/bash_completion.d/Makefile contrib/dracut/Makefile contrib/dracut/90zfs/Makefile contrib/initramfs/Makefile module/Makefile module/avl/Makefile module/nvpair/Makefile module/unicode/Makefile module/zcommon/Makefile module/zfs/Makefile module/zpios/Makefile include/Makefile include/linux/Makefile include/sys/Makefile include/sys/fs/Makefile include/sys/fm/Makefile include/sys/fm/fs/Makefile scripts/Makefile scripts/zpios-profile/Makefile scripts/zpios-test/Makefile scripts/zpool-config/Makefile scripts/common.sh rpm/Makefile rpm/redhat/Makefile rpm/redhat/zfs.spec rpm/redhat/zfs-kmod.spec rpm/redhat/zfs-dkms.spec rpm/generic/Makefile rpm/generic/zfs.spec rpm/generic/zfs-kmod.spec rpm/generic/zfs-dkms.spec zfs-script-config.sh zfs.release"


cat >confcache <<\_ACEOF
# This file is a shell script that caches the results of configure
# tests run on this system so they can be shared between configure
# scripts and configure runs, see configure's option --config-cache.
# It is not useful on other systems.  If it contains results you don't
# want to keep, you may remove or edit it.
#
# config.status only pays attention to the cache file if you give it
# the --recheck option to rerun configure.
#
# `ac_cv_env_foo' variables (set or unset) will be overridden when
# loading this file, other *unset* `ac_cv_foo' will be assigned the
# following values.

_ACEOF

# The following way of writing the cache mishandles newlines in values,
# but we know of no workaround that is simple, portable, and efficient.
# So, we kill variables containing newlines.
# Ultrix sh set writes to stderr and can't be redirected directly,
# and sets the high bit in the cache file unless we assign to the vars.
(
  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
    eval ac_val=\$$ac_var
    case $ac_val in #(
    *${as_nl}*)
      case $ac_var in #(
      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      esac
      case $ac_var in #(
      _ | IFS | as_nl) ;; #(
      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
      *) { eval $ac_var=; unset $ac_var;} ;;
      esac ;;
    esac
  done

  (set) 2>&1 |
    case $as_nl`(ac_space=' '; set) 2>&1` in #(
    *${as_nl}ac_space=\ *)
      # `set' does not quote correctly, so add quotes: double-quote
      # substitution turns \\\\ into \\, and sed turns \\ into \.
      sed -n \
	"s/'/'\\\\''/g;
	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
      ;; #(
    *)
      # `set' quotes correctly as required by POSIX, so do not add quotes.
      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
      ;;
    esac |
    sort
) |
  sed '
     /^ac_cv_env_/b end
     t clear
     :clear
     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
     t end
     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
     :end' >>confcache
if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
  if test -w "$cache_file"; then
    if test "x$cache_file" != "x/dev/null"; then
      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
$as_echo "$as_me: updating cache $cache_file" >&6;}
      if test ! -f "$cache_file" || test -h "$cache_file"; then
	cat confcache >"$cache_file"
      else
        case $cache_file in #(
        */* | ?:*)
	  mv -f confcache "$cache_file"$$ &&
	  mv -f "$cache_file"$$ "$cache_file" ;; #(
        *)
	  mv -f confcache "$cache_file" ;;
	esac
      fi
    fi
  else
    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
  fi
fi
rm -f confcache

test "x$prefix" = xNONE && prefix=$ac_default_prefix
# Let make expand exec_prefix.
test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'

DEFS=-DHAVE_CONFIG_H

ac_libobjs=
ac_ltlibobjs=
U=
for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
  # 1. Remove the extension, and $U if already installed.
  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
  #    will be set to the directory where LIBOBJS objects are built.
  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
done
LIBOBJS=$ac_libobjs

LTLIBOBJS=$ac_ltlibobjs


if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
$as_echo_n "checking that generated files are newer than configure... " >&6; }
   if test -n "$am_sleep_pid"; then
     # Hide warnings about reused PIDs.
     wait $am_sleep_pid 2>/dev/null
   fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
$as_echo "done" >&6; }
 if test -n "$EXEEXT"; then
  am__EXEEXT_TRUE=
  am__EXEEXT_FALSE='#'
else
  am__EXEEXT_TRUE='#'
  am__EXEEXT_FALSE=
fi

if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
  as_fn_error $? "conditional \"AMDEP\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
if test -z "${am__fastdepCCAS_TRUE}" && test -z "${am__fastdepCCAS_FALSE}"; then
  as_fn_error $? "conditional \"am__fastdepCCAS\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
if test -z "${CONFIG_USER_TRUE}" && test -z "${CONFIG_USER_FALSE}"; then
  as_fn_error $? "conditional \"CONFIG_USER\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi
if test -z "${CONFIG_KERNEL_TRUE}" && test -z "${CONFIG_KERNEL_FALSE}"; then
  as_fn_error $? "conditional \"CONFIG_KERNEL\" was never defined.
Usually this means the macro was only invoked conditionally." "$LINENO" 5
fi

: "${CONFIG_STATUS=./config.status}"
ac_write_fail=0
ac_clean_files_save=$ac_clean_files
ac_clean_files="$ac_clean_files $CONFIG_STATUS"
{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
as_write_fail=0
cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
#! $SHELL
# Generated by $as_me.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.

debug=false
ac_cs_recheck=false
ac_cs_silent=false

SHELL=\${CONFIG_SHELL-$SHELL}
export SHELL
_ASEOF
cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error


# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -pR'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -pR'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -pR'
  fi
else
  as_ln_s='cp -pR'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null


# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p
if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi


# as_fn_executable_p FILE
# -----------------------
# Test if FILE is an executable regular file.
as_fn_executable_p ()
{
  test -f "$1" && test -x "$1"
} # as_fn_executable_p
as_test_x='test -x'
as_executable_p=as_fn_executable_p

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"


exec 6>&1
## ----------------------------------- ##
## Main body of $CONFIG_STATUS script. ##
## ----------------------------------- ##
_ASEOF
test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# Save the log message, to keep $0 and so on meaningful, and to
# report actual input values of CONFIG_FILES etc. instead of their
# values after options handling.
ac_log="
This file was extended by zfs $as_me 0.6.5.9, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  CONFIG_FILES    = $CONFIG_FILES
  CONFIG_HEADERS  = $CONFIG_HEADERS
  CONFIG_LINKS    = $CONFIG_LINKS
  CONFIG_COMMANDS = $CONFIG_COMMANDS
  $ $0 $@

on `(hostname || uname -n) 2>/dev/null | sed 1q`
"

_ACEOF

case $ac_config_files in *"
"*) set x $ac_config_files; shift; ac_config_files=$*;;
esac

case $ac_config_headers in *"
"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
esac


cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
# Files that config.status was made for.
config_files="$ac_config_files"
config_headers="$ac_config_headers"
config_commands="$ac_config_commands"

_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
ac_cs_usage="\
\`$as_me' instantiates files and other configuration actions
from templates according to the current configuration.  Unless the files
and actions are specified as TAGs, all are instantiated by default.

Usage: $0 [OPTION]... [TAG]...

  -h, --help       print this help, then exit
  -V, --version    print version number and configuration settings, then exit
      --config     print configuration, then exit
  -q, --quiet, --silent
                   do not print progress messages
  -d, --debug      don't remove temporary files
      --recheck    update $as_me by reconfiguring in the same conditions
      --file=FILE[:TEMPLATE]
                   instantiate the configuration file FILE
      --header=FILE[:TEMPLATE]
                   instantiate the configuration header FILE

Configuration files:
$config_files

Configuration headers:
$config_headers

Configuration commands:
$config_commands

Report bugs to the package provider."

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
ac_cs_version="\\
zfs config.status 0.6.5.9
configured by $0, generated by GNU Autoconf 2.69,
  with options \\"\$ac_cs_config\\"

Copyright (C) 2012 Free Software Foundation, Inc.
This config.status script is free software; the Free Software Foundation
gives unlimited permission to copy, distribute and modify it."

ac_pwd='$ac_pwd'
srcdir='$srcdir'
INSTALL='$INSTALL'
MKDIR_P='$MKDIR_P'
AWK='$AWK'
test -n "\$AWK" || AWK=awk
_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# The default lists apply if the user does not specify any file.
ac_need_defaults=:
while test $# != 0
do
  case $1 in
  --*=?*)
    ac_option=`expr "X$1" : 'X\([^=]*\)='`
    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
    ac_shift=:
    ;;
  --*=)
    ac_option=`expr "X$1" : 'X\([^=]*\)='`
    ac_optarg=
    ac_shift=:
    ;;
  *)
    ac_option=$1
    ac_optarg=$2
    ac_shift=shift
    ;;
  esac

  case $ac_option in
  # Handling of the options.
  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
    ac_cs_recheck=: ;;
  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
    $as_echo "$ac_cs_version"; exit ;;
  --config | --confi | --conf | --con | --co | --c )
    $as_echo "$ac_cs_config"; exit ;;
  --debug | --debu | --deb | --de | --d | -d )
    debug=: ;;
  --file | --fil | --fi | --f )
    $ac_shift
    case $ac_optarg in
    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
    '') as_fn_error $? "missing file argument" ;;
    esac
    as_fn_append CONFIG_FILES " '$ac_optarg'"
    ac_need_defaults=false;;
  --header | --heade | --head | --hea )
    $ac_shift
    case $ac_optarg in
    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
    esac
    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
    ac_need_defaults=false;;
  --he | --h)
    # Conflict between --help and --header
    as_fn_error $? "ambiguous option: \`$1'
Try \`$0 --help' for more information.";;
  --help | --hel | -h )
    $as_echo "$ac_cs_usage"; exit ;;
  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
  | -silent | --silent | --silen | --sile | --sil | --si | --s)
    ac_cs_silent=: ;;

  # This is an error.
  -*) as_fn_error $? "unrecognized option: \`$1'
Try \`$0 --help' for more information." ;;

  *) as_fn_append ac_config_targets " $1"
     ac_need_defaults=false ;;

  esac
  shift
done

ac_configure_extra_args=

if $ac_cs_silent; then
  exec 6>/dev/null
  ac_configure_extra_args="$ac_configure_extra_args --silent"
fi

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
if \$ac_cs_recheck; then
  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
  shift
  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
  CONFIG_SHELL='$SHELL'
  export CONFIG_SHELL
  exec "\$@"
fi

_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
exec 5>>config.log
{
  echo
  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## Running $as_me. ##
_ASBOX
  $as_echo "$ac_log"
} >&5

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
#
# INIT-COMMANDS
#
AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"


# The HP-UX ksh and POSIX shell print the target directory to stdout
# if CDPATH is set.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

sed_quote_subst='$sed_quote_subst'
double_quote_subst='$double_quote_subst'
delay_variable_subst='$delay_variable_subst'
macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
PATH_SEPARATOR='`$ECHO "$PATH_SEPARATOR" | $SED "$delay_single_quote_subst"`'
host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
lt_cv_to_host_file_cmd='`$ECHO "$lt_cv_to_host_file_cmd" | $SED "$delay_single_quote_subst"`'
lt_cv_to_tool_file_cmd='`$ECHO "$lt_cv_to_tool_file_cmd" | $SED "$delay_single_quote_subst"`'
reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
file_magic_glob='`$ECHO "$file_magic_glob" | $SED "$delay_single_quote_subst"`'
want_nocaseglob='`$ECHO "$want_nocaseglob" | $SED "$delay_single_quote_subst"`'
DLLTOOL='`$ECHO "$DLLTOOL" | $SED "$delay_single_quote_subst"`'
sharedlib_from_linklib_cmd='`$ECHO "$sharedlib_from_linklib_cmd" | $SED "$delay_single_quote_subst"`'
AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
archiver_list_spec='`$ECHO "$archiver_list_spec" | $SED "$delay_single_quote_subst"`'
STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
nm_file_list_spec='`$ECHO "$nm_file_list_spec" | $SED "$delay_single_quote_subst"`'
lt_sysroot='`$ECHO "$lt_sysroot" | $SED "$delay_single_quote_subst"`'
objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
MANIFEST_TOOL='`$ECHO "$MANIFEST_TOOL" | $SED "$delay_single_quote_subst"`'
DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
postlink_cmds='`$ECHO "$postlink_cmds" | $SED "$delay_single_quote_subst"`'
file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'

LTCC='$LTCC'
LTCFLAGS='$LTCFLAGS'
compiler='$compiler_DEFAULT'

# A function that is used when there is no print builtin or printf.
func_fallback_echo ()
{
  eval 'cat <<_LTECHO_EOF
\$1
_LTECHO_EOF'
}

# Quote evaled strings.
for var in SHELL \
ECHO \
PATH_SEPARATOR \
SED \
GREP \
EGREP \
FGREP \
LD \
NM \
LN_S \
lt_SP2NL \
lt_NL2SP \
reload_flag \
OBJDUMP \
deplibs_check_method \
file_magic_cmd \
file_magic_glob \
want_nocaseglob \
DLLTOOL \
sharedlib_from_linklib_cmd \
AR \
AR_FLAGS \
archiver_list_spec \
STRIP \
RANLIB \
CC \
CFLAGS \
compiler \
lt_cv_sys_global_symbol_pipe \
lt_cv_sys_global_symbol_to_cdecl \
lt_cv_sys_global_symbol_to_c_name_address \
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
nm_file_list_spec \
lt_prog_compiler_no_builtin_flag \
lt_prog_compiler_pic \
lt_prog_compiler_wl \
lt_prog_compiler_static \
lt_cv_prog_compiler_c_o \
need_locks \
MANIFEST_TOOL \
DSYMUTIL \
NMEDIT \
LIPO \
OTOOL \
OTOOL64 \
shrext_cmds \
export_dynamic_flag_spec \
whole_archive_flag_spec \
compiler_needs_object \
with_gnu_ld \
allow_undefined_flag \
no_undefined_flag \
hardcode_libdir_flag_spec \
hardcode_libdir_separator \
exclude_expsyms \
include_expsyms \
file_list_spec \
variables_saved_for_relink \
libname_spec \
library_names_spec \
soname_spec \
install_override_mode \
finish_eval \
old_striplib \
striplib; do
    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
    *[\\\\\\\`\\"\\\$]*)
      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
      ;;
    *)
      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
      ;;
    esac
done

# Double-quote double-evaled strings.
for var in reload_cmds \
old_postinstall_cmds \
old_postuninstall_cmds \
old_archive_cmds \
extract_expsyms_cmds \
old_archive_from_new_cmds \
old_archive_from_expsyms_cmds \
archive_cmds \
archive_expsym_cmds \
module_cmds \
module_expsym_cmds \
export_symbols_cmds \
prelink_cmds \
postlink_cmds \
postinstall_cmds \
postuninstall_cmds \
finish_cmds \
sys_lib_search_path_spec \
sys_lib_dlsearch_path_spec; do
    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
    *[\\\\\\\`\\"\\\$]*)
      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
      ;;
    *)
      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
      ;;
    esac
done

ac_aux_dir='$ac_aux_dir'
xsi_shell='$xsi_shell'
lt_shell_append='$lt_shell_append'

# See if we are running on zsh, and set the options which allow our
# commands through without removal of \ escapes INIT.
if test -n "\${ZSH_VERSION+set}" ; then
   setopt NO_GLOB_SUBST
fi


    PACKAGE='$PACKAGE'
    VERSION='$VERSION'
    TIMESTAMP='$TIMESTAMP'
    RM='$RM'
    ofile='$ofile'




_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1

# Handling of arguments.
for ac_config_target in $ac_config_targets
do
  case $ac_config_target in
    "zfs_config.h") CONFIG_HEADERS="$CONFIG_HEADERS zfs_config.h" ;;
    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
    "udev/Makefile") CONFIG_FILES="$CONFIG_FILES udev/Makefile" ;;
    "udev/rules.d/Makefile") CONFIG_FILES="$CONFIG_FILES udev/rules.d/Makefile" ;;
    "etc/Makefile") CONFIG_FILES="$CONFIG_FILES etc/Makefile" ;;
    "etc/init.d/Makefile") CONFIG_FILES="$CONFIG_FILES etc/init.d/Makefile" ;;
    "etc/zfs/Makefile") CONFIG_FILES="$CONFIG_FILES etc/zfs/Makefile" ;;
    "etc/systemd/Makefile") CONFIG_FILES="$CONFIG_FILES etc/systemd/Makefile" ;;
    "etc/systemd/system/Makefile") CONFIG_FILES="$CONFIG_FILES etc/systemd/system/Makefile" ;;
    "etc/modules-load.d/Makefile") CONFIG_FILES="$CONFIG_FILES etc/modules-load.d/Makefile" ;;
    "man/Makefile") CONFIG_FILES="$CONFIG_FILES man/Makefile" ;;
    "man/man1/Makefile") CONFIG_FILES="$CONFIG_FILES man/man1/Makefile" ;;
    "man/man5/Makefile") CONFIG_FILES="$CONFIG_FILES man/man5/Makefile" ;;
    "man/man8/Makefile") CONFIG_FILES="$CONFIG_FILES man/man8/Makefile" ;;
    "lib/Makefile") CONFIG_FILES="$CONFIG_FILES lib/Makefile" ;;
    "lib/libspl/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/Makefile" ;;
    "lib/libspl/asm-generic/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/asm-generic/Makefile" ;;
    "lib/libspl/asm-i386/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/asm-i386/Makefile" ;;
    "lib/libspl/asm-x86_64/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/asm-x86_64/Makefile" ;;
    "lib/libspl/include/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/Makefile" ;;
    "lib/libspl/include/ia32/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/ia32/Makefile" ;;
    "lib/libspl/include/ia32/sys/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/ia32/sys/Makefile" ;;
    "lib/libspl/include/rpc/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/rpc/Makefile" ;;
    "lib/libspl/include/sys/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/sys/Makefile" ;;
    "lib/libspl/include/sys/sysevent/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/sys/sysevent/Makefile" ;;
    "lib/libspl/include/sys/dktp/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/sys/dktp/Makefile" ;;
    "lib/libspl/include/util/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libspl/include/util/Makefile" ;;
    "lib/libavl/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libavl/Makefile" ;;
    "lib/libefi/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libefi/Makefile" ;;
    "lib/libnvpair/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libnvpair/Makefile" ;;
    "lib/libunicode/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libunicode/Makefile" ;;
    "lib/libuutil/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libuutil/Makefile" ;;
    "lib/libzpool/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libzpool/Makefile" ;;
    "lib/libzfs/libzfs.pc") CONFIG_FILES="$CONFIG_FILES lib/libzfs/libzfs.pc" ;;
    "lib/libzfs/libzfs_core.pc") CONFIG_FILES="$CONFIG_FILES lib/libzfs/libzfs_core.pc" ;;
    "lib/libzfs/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libzfs/Makefile" ;;
    "lib/libzfs_core/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libzfs_core/Makefile" ;;
    "lib/libshare/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libshare/Makefile" ;;
    "cmd/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/Makefile" ;;
    "cmd/zdb/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zdb/Makefile" ;;
    "cmd/zhack/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zhack/Makefile" ;;
    "cmd/zfs/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zfs/Makefile" ;;
    "cmd/zinject/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zinject/Makefile" ;;
    "cmd/zpool/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zpool/Makefile" ;;
    "cmd/zstreamdump/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zstreamdump/Makefile" ;;
    "cmd/ztest/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/ztest/Makefile" ;;
    "cmd/zpios/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zpios/Makefile" ;;
    "cmd/mount_zfs/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/mount_zfs/Makefile" ;;
    "cmd/fsck_zfs/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/fsck_zfs/Makefile" ;;
    "cmd/zvol_id/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zvol_id/Makefile" ;;
    "cmd/vdev_id/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/vdev_id/Makefile" ;;
    "cmd/arcstat/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/arcstat/Makefile" ;;
    "cmd/dbufstat/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/dbufstat/Makefile" ;;
    "cmd/arc_summary/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/arc_summary/Makefile" ;;
    "cmd/zed/Makefile") CONFIG_FILES="$CONFIG_FILES cmd/zed/Makefile" ;;
    "contrib/Makefile") CONFIG_FILES="$CONFIG_FILES contrib/Makefile" ;;
    "contrib/bash_completion.d/Makefile") CONFIG_FILES="$CONFIG_FILES contrib/bash_completion.d/Makefile" ;;
    "contrib/dracut/Makefile") CONFIG_FILES="$CONFIG_FILES contrib/dracut/Makefile" ;;
    "contrib/dracut/90zfs/Makefile") CONFIG_FILES="$CONFIG_FILES contrib/dracut/90zfs/Makefile" ;;
    "contrib/initramfs/Makefile") CONFIG_FILES="$CONFIG_FILES contrib/initramfs/Makefile" ;;
    "module/Makefile") CONFIG_FILES="$CONFIG_FILES module/Makefile" ;;
    "module/avl/Makefile") CONFIG_FILES="$CONFIG_FILES module/avl/Makefile" ;;
    "module/nvpair/Makefile") CONFIG_FILES="$CONFIG_FILES module/nvpair/Makefile" ;;
    "module/unicode/Makefile") CONFIG_FILES="$CONFIG_FILES module/unicode/Makefile" ;;
    "module/zcommon/Makefile") CONFIG_FILES="$CONFIG_FILES module/zcommon/Makefile" ;;
    "module/zfs/Makefile") CONFIG_FILES="$CONFIG_FILES module/zfs/Makefile" ;;
    "module/zpios/Makefile") CONFIG_FILES="$CONFIG_FILES module/zpios/Makefile" ;;
    "include/Makefile") CONFIG_FILES="$CONFIG_FILES include/Makefile" ;;
    "include/linux/Makefile") CONFIG_FILES="$CONFIG_FILES include/linux/Makefile" ;;
    "include/sys/Makefile") CONFIG_FILES="$CONFIG_FILES include/sys/Makefile" ;;
    "include/sys/fs/Makefile") CONFIG_FILES="$CONFIG_FILES include/sys/fs/Makefile" ;;
    "include/sys/fm/Makefile") CONFIG_FILES="$CONFIG_FILES include/sys/fm/Makefile" ;;
    "include/sys/fm/fs/Makefile") CONFIG_FILES="$CONFIG_FILES include/sys/fm/fs/Makefile" ;;
    "scripts/Makefile") CONFIG_FILES="$CONFIG_FILES scripts/Makefile" ;;
    "scripts/zpios-profile/Makefile") CONFIG_FILES="$CONFIG_FILES scripts/zpios-profile/Makefile" ;;
    "scripts/zpios-test/Makefile") CONFIG_FILES="$CONFIG_FILES scripts/zpios-test/Makefile" ;;
    "scripts/zpool-config/Makefile") CONFIG_FILES="$CONFIG_FILES scripts/zpool-config/Makefile" ;;
    "scripts/common.sh") CONFIG_FILES="$CONFIG_FILES scripts/common.sh" ;;
    "rpm/Makefile") CONFIG_FILES="$CONFIG_FILES rpm/Makefile" ;;
    "rpm/redhat/Makefile") CONFIG_FILES="$CONFIG_FILES rpm/redhat/Makefile" ;;
    "rpm/redhat/zfs.spec") CONFIG_FILES="$CONFIG_FILES rpm/redhat/zfs.spec" ;;
    "rpm/redhat/zfs-kmod.spec") CONFIG_FILES="$CONFIG_FILES rpm/redhat/zfs-kmod.spec" ;;
    "rpm/redhat/zfs-dkms.spec") CONFIG_FILES="$CONFIG_FILES rpm/redhat/zfs-dkms.spec" ;;
    "rpm/generic/Makefile") CONFIG_FILES="$CONFIG_FILES rpm/generic/Makefile" ;;
    "rpm/generic/zfs.spec") CONFIG_FILES="$CONFIG_FILES rpm/generic/zfs.spec" ;;
    "rpm/generic/zfs-kmod.spec") CONFIG_FILES="$CONFIG_FILES rpm/generic/zfs-kmod.spec" ;;
    "rpm/generic/zfs-dkms.spec") CONFIG_FILES="$CONFIG_FILES rpm/generic/zfs-dkms.spec" ;;
    "zfs-script-config.sh") CONFIG_FILES="$CONFIG_FILES zfs-script-config.sh" ;;
    "zfs.release") CONFIG_FILES="$CONFIG_FILES zfs.release" ;;

  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
  esac
done


# If the user did not use the arguments to specify the items to instantiate,
# then the envvar interface is used.  Set only those that are not.
# We use the long form for the default assignment because of an extremely
# bizarre bug on SunOS 4.1.3.
if $ac_need_defaults; then
  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
fi

# Have a temporary directory for convenience.  Make it in the build tree
# simply because there is no reason against having it here, and in addition,
# creating and moving files from /tmp can sometimes cause problems.
# Hook for its removal unless debugging.
# Note that there is a small window in which the directory will not be cleaned:
# after its creation but before its name has been assigned to `$tmp'.
$debug ||
{
  tmp= ac_tmp=
  trap 'exit_status=$?
  : "${ac_tmp:=$tmp}"
  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
' 0
  trap 'as_fn_exit 1' 1 2 13 15
}
# Create a (secure) tmp directory for tmp files.

{
  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
  test -d "$tmp"
}  ||
{
  tmp=./conf$$-$RANDOM
  (umask 077 && mkdir "$tmp")
} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
ac_tmp=$tmp

# Set up the scripts for CONFIG_FILES section.
# No need to generate them if there are no CONFIG_FILES.
# This happens for instance with `./config.status config.h'.
if test -n "$CONFIG_FILES"; then


ac_cr=`echo X | tr X '\015'`
# On cygwin, bash can eat \r inside `` if the user requested igncr.
# But we know of no other shell where ac_cr would be empty at this
# point, so we can use a bashism as a fallback.
if test "x$ac_cr" = x; then
  eval ac_cr=\$\'\\r\'
fi
ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
  ac_cs_awk_cr='\\r'
else
  ac_cs_awk_cr=$ac_cr
fi

echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
_ACEOF


{
  echo "cat >conf$$subs.awk <<_ACEOF" &&
  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
  echo "_ACEOF"
} >conf$$subs.sh ||
  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
ac_delim='%!_!# '
for ac_last_try in false false false false false :; do
  . ./conf$$subs.sh ||
    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5

  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
  if test $ac_delim_n = $ac_delim_num; then
    break
  elif $ac_last_try; then
    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
  else
    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
  fi
done
rm -f conf$$subs.sh

cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
_ACEOF
sed -n '
h
s/^/S["/; s/!.*/"]=/
p
g
s/^[^!]*!//
:repl
t repl
s/'"$ac_delim"'$//
t delim
:nl
h
s/\(.\{148\}\)..*/\1/
t more1
s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
p
n
b repl
:more1
s/["\\]/\\&/g; s/^/"/; s/$/"\\/
p
g
s/.\{148\}//
t nl
:delim
h
s/\(.\{148\}\)..*/\1/
t more2
s/["\\]/\\&/g; s/^/"/; s/$/"/
p
b
:more2
s/["\\]/\\&/g; s/^/"/; s/$/"\\/
p
g
s/.\{148\}//
t delim
' <conf$$subs.awk | sed '
/^[^""]/{
  N
  s/\n//
}
' >>$CONFIG_STATUS || ac_write_fail=1
rm -f conf$$subs.awk
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
_ACAWK
cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
  for (key in S) S_is_set[key] = 1
  FS = ""

}
{
  line = $ 0
  nfields = split(line, field, "@")
  substed = 0
  len = length(field[1])
  for (i = 2; i < nfields; i++) {
    key = field[i]
    keylen = length(key)
    if (S_is_set[key]) {
      value = S[key]
      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
      len += length(value) + length(field[++i])
      substed = 1
    } else
      len += 1 + keylen
  }

  print line
}

_ACAWK
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
else
  cat
fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
_ACEOF

# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
# trailing colons and then remove the whole line if VPATH becomes empty
# (actually we leave an empty line to preserve line numbers).
if test "x$srcdir" = x.; then
  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
h
s///
s/^/:/
s/[	 ]*$/:/
s/:\$(srcdir):/:/g
s/:\${srcdir}:/:/g
s/:@srcdir@:/:/g
s/^:*//
s/:*$//
x
s/\(=[	 ]*\).*/\1/
G
s/\n//
s/^[^=]*=[	 ]*$//
}'
fi

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
fi # test -n "$CONFIG_FILES"

# Set up the scripts for CONFIG_HEADERS section.
# No need to generate them if there are no CONFIG_HEADERS.
# This happens for instance with `./config.status Makefile'.
if test -n "$CONFIG_HEADERS"; then
cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
BEGIN {
_ACEOF

# Transform confdefs.h into an awk script `defines.awk', embedded as
# here-document in config.status, that substitutes the proper values into
# config.h.in to produce config.h.

# Create a delimiter string that does not exist in confdefs.h, to ease
# handling of long lines.
ac_delim='%!_!# '
for ac_last_try in false false :; do
  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
  if test -z "$ac_tt"; then
    break
  elif $ac_last_try; then
    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
  else
    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
  fi
done

# For the awk script, D is an array of macro values keyed by name,
# likewise P contains macro parameters if any.  Preserve backslash
# newline sequences.

ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
sed -n '
s/.\{148\}/&'"$ac_delim"'/g
t rset
:rset
s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
t def
d
:def
s/\\$//
t bsnl
s/["\\]/\\&/g
s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
D["\1"]=" \3"/p
s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
d
:bsnl
s/["\\]/\\&/g
s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
D["\1"]=" \3\\\\\\n"\\/p
t cont
s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
t cont
d
:cont
n
s/.\{148\}/&'"$ac_delim"'/g
t clear
:clear
s/\\$//
t bsnlc
s/["\\]/\\&/g; s/^/"/; s/$/"/p
d
:bsnlc
s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
b cont
' <confdefs.h | sed '
s/'"$ac_delim"'/"\\\
"/g' >>$CONFIG_STATUS || ac_write_fail=1

cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  for (key in D) D_is_set[key] = 1
  FS = ""
}
/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
  line = \$ 0
  split(line, arg, " ")
  if (arg[1] == "#") {
    defundef = arg[2]
    mac1 = arg[3]
  } else {
    defundef = substr(arg[1], 2)
    mac1 = arg[2]
  }
  split(mac1, mac2, "(") #)
  macro = mac2[1]
  prefix = substr(line, 1, index(line, defundef) - 1)
  if (D_is_set[macro]) {
    # Preserve the white space surrounding the "#".
    print prefix "define", macro P[macro] D[macro]
    next
  } else {
    # Replace #undef with comments.  This is necessary, for example,
    # in the case of _POSIX_SOURCE, which is predefined and required
    # on some systems where configure will not decide to define it.
    if (defundef == "undef") {
      print "/*", prefix defundef, macro, "*/"
      next
    }
  }
}
{ print }
_ACAWK
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
fi # test -n "$CONFIG_HEADERS"


eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
shift
for ac_tag
do
  case $ac_tag in
  :[FHLC]) ac_mode=$ac_tag; continue;;
  esac
  case $ac_mode$ac_tag in
  :[FHL]*:*);;
  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
  :[FH]-) ac_tag=-:-;;
  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
  esac
  ac_save_IFS=$IFS
  IFS=:
  set x $ac_tag
  IFS=$ac_save_IFS
  shift
  ac_file=$1
  shift

  case $ac_mode in
  :L) ac_source=$1;;
  :[FH])
    ac_file_inputs=
    for ac_f
    do
      case $ac_f in
      -) ac_f="$ac_tmp/stdin";;
      *) # Look for the file first in the build tree, then in the source tree
	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
	 # because $ac_f cannot contain `:'.
	 test -f "$ac_f" ||
	   case $ac_f in
	   [\\/$]*) false;;
	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
	   esac ||
	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
      esac
      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
      as_fn_append ac_file_inputs " '$ac_f'"
    done

    # Let's still pretend it is `configure' which instantiates (i.e., don't
    # use $as_me), people would be surprised to read:
    #    /* config.h.  Generated by config.status.  */
    configure_input='Generated from '`
	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
	`' by configure.'
    if test x"$ac_file" != x-; then
      configure_input="$ac_file.  $configure_input"
      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
$as_echo "$as_me: creating $ac_file" >&6;}
    fi
    # Neutralize special characters interpreted by sed in replacement strings.
    case $configure_input in #(
    *\&* | *\|* | *\\* )
       ac_sed_conf_input=`$as_echo "$configure_input" |
       sed 's/[\\\\&|]/\\\\&/g'`;; #(
    *) ac_sed_conf_input=$configure_input;;
    esac

    case $ac_tag in
    *:-:* | *:-) cat >"$ac_tmp/stdin" \
      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
    esac
    ;;
  esac

  ac_dir=`$as_dirname -- "$ac_file" ||
$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$ac_file" : 'X\(//\)[^/]' \| \
	 X"$ac_file" : 'X\(//\)$' \| \
	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$ac_file" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
  as_dir="$ac_dir"; as_fn_mkdir_p
  ac_builddir=.

case "$ac_dir" in
.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
*)
  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
  # A ".." for each directory in $ac_dir_suffix.
  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
  case $ac_top_builddir_sub in
  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
  esac ;;
esac
ac_abs_top_builddir=$ac_pwd
ac_abs_builddir=$ac_pwd$ac_dir_suffix
# for backward compatibility:
ac_top_builddir=$ac_top_build_prefix

case $srcdir in
  .)  # We are building in place.
    ac_srcdir=.
    ac_top_srcdir=$ac_top_builddir_sub
    ac_abs_top_srcdir=$ac_pwd ;;
  [\\/]* | ?:[\\/]* )  # Absolute name.
    ac_srcdir=$srcdir$ac_dir_suffix;
    ac_top_srcdir=$srcdir
    ac_abs_top_srcdir=$srcdir ;;
  *) # Relative name.
    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
    ac_top_srcdir=$ac_top_build_prefix$srcdir
    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
esac
ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix


  case $ac_mode in
  :F)
  #
  # CONFIG_FILE
  #

  case $INSTALL in
  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
  esac
  ac_MKDIR_P=$MKDIR_P
  case $MKDIR_P in
  [\\/$]* | ?:[\\/]* ) ;;
  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
  esac
_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# If the template does not know about datarootdir, expand it.
# FIXME: This hack should be removed a few years after 2.60.
ac_datarootdir_hack=; ac_datarootdir_seen=
ac_sed_dataroot='
/datarootdir/ {
  p
  q
}
/@datadir@/p
/@docdir@/p
/@infodir@/p
/@localedir@/p
/@mandir@/p'
case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
*datarootdir*) ac_datarootdir_seen=yes;;
*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  ac_datarootdir_hack='
  s&@datadir@&$datadir&g
  s&@docdir@&$docdir&g
  s&@infodir@&$infodir&g
  s&@localedir@&$localedir&g
  s&@mandir@&$mandir&g
  s&\\\${datarootdir}&$datarootdir&g' ;;
esac
_ACEOF

# Neutralize VPATH when `$srcdir' = `.'.
# Shell code in configure.ac might set extrasub.
# FIXME: do we really want to maintain this feature?
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
ac_sed_extra="$ac_vpsub
$extrasub
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
:t
/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
s|@configure_input@|$ac_sed_conf_input|;t t
s&@top_builddir@&$ac_top_builddir_sub&;t t
s&@top_build_prefix@&$ac_top_build_prefix&;t t
s&@srcdir@&$ac_srcdir&;t t
s&@abs_srcdir@&$ac_abs_srcdir&;t t
s&@top_srcdir@&$ac_top_srcdir&;t t
s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
s&@builddir@&$ac_builddir&;t t
s&@abs_builddir@&$ac_abs_builddir&;t t
s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
s&@INSTALL@&$ac_INSTALL&;t t
s&@MKDIR_P@&$ac_MKDIR_P&;t t
$ac_datarootdir_hack
"
eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5

test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
      "$ac_tmp/out"`; test -z "$ac_out"; } &&
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
which seems to be undefined.  Please make sure it is defined" >&5
$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
which seems to be undefined.  Please make sure it is defined" >&2;}

  rm -f "$ac_tmp/stdin"
  case $ac_file in
  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
  esac \
  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 ;;
  :H)
  #
  # CONFIG_HEADER
  #
  if test x"$ac_file" != x-; then
    {
      $as_echo "/* $configure_input  */" \
      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
    } >"$ac_tmp/config.h" \
      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
$as_echo "$as_me: $ac_file is unchanged" >&6;}
    else
      rm -f "$ac_file"
      mv "$ac_tmp/config.h" "$ac_file" \
	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
    fi
  else
    $as_echo "/* $configure_input  */" \
      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
      || as_fn_error $? "could not create -" "$LINENO" 5
  fi
# Compute "$ac_file"'s index in $config_headers.
_am_arg="$ac_file"
_am_stamp_count=1
for _am_header in $config_headers :; do
  case $_am_header in
    $_am_arg | $_am_arg:* )
      break ;;
    * )
      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
  esac
done
echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$_am_arg" : 'X\(//\)[^/]' \| \
	 X"$_am_arg" : 'X\(//\)$' \| \
	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$_am_arg" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`/stamp-h$_am_stamp_count
 ;;

  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
$as_echo "$as_me: executing $ac_file commands" >&6;}
 ;;
  esac


  case $ac_file$ac_mode in
    "zfs_config.h":H)
	(mv zfs_config.h zfs_config.h.tmp &&
	awk -f ${ac_srcdir}/config/config.awk zfs_config.h.tmp >zfs_config.h &&
	rm zfs_config.h.tmp) || exit 1 ;;
    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
  # Older Autoconf quotes --file arguments for eval, but not when files
  # are listed without --file.  Let's play safe and only enable the eval
  # if we detect the quoting.
  case $CONFIG_FILES in
  *\'*) eval set x "$CONFIG_FILES" ;;
  *)   set x $CONFIG_FILES ;;
  esac
  shift
  for mf
  do
    # Strip MF so we end up with the name of the file.
    mf=`echo "$mf" | sed -e 's/:.*$//'`
    # Check whether this is an Automake generated Makefile or not.
    # We used to match only the files named 'Makefile.in', but
    # some people rename them; so instead we look at the file content.
    # Grep'ing the first line is not enough: some people post-process
    # each Makefile.in and add a new line on top of each file to say so.
    # Grep'ing the whole file is not good either: AIX grep has a line
    # limit of 2048, but all sed's we know have understand at least 4000.
    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
      dirpart=`$as_dirname -- "$mf" ||
$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$mf" : 'X\(//\)[^/]' \| \
	 X"$mf" : 'X\(//\)$' \| \
	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$mf" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
    else
      continue
    fi
    # Extract the definition of DEPDIR, am__include, and am__quote
    # from the Makefile without running 'make'.
    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
    test -z "$DEPDIR" && continue
    am__include=`sed -n 's/^am__include = //p' < "$mf"`
    test -z "$am__include" && continue
    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
    # Find all dependency output files, they are included files with
    # $(DEPDIR) in their names.  We invoke sed twice because it is the
    # simplest approach to changing $(DEPDIR) to its actual value in the
    # expansion.
    for file in `sed -n "
      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
      # Make sure the directory exists.
      test -f "$dirpart/$file" && continue
      fdir=`$as_dirname -- "$file" ||
$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$file" : 'X\(//\)[^/]' \| \
	 X"$file" : 'X\(//\)$' \| \
	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$file" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      as_dir=$dirpart/$fdir; as_fn_mkdir_p
      # echo "creating $dirpart/$file"
      echo '# dummy' > "$dirpart/$file"
    done
  done
}
 ;;
    "libtool":C)

    # See if we are running on zsh, and set the options which allow our
    # commands through without removal of \ escapes.
    if test -n "${ZSH_VERSION+set}" ; then
      setopt NO_GLOB_SUBST
    fi

    cfgfile="${ofile}T"
    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
    $RM "$cfgfile"

    cat <<_LT_EOF >> "$cfgfile"
#! $SHELL

# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
# NOTE: Changes made to this file will be lost: look at ltmain.sh.
#
#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
#                 Foundation, Inc.
#   Written by Gordon Matzigkeit, 1996
#
#   This file is part of GNU Libtool.
#
# GNU Libtool is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# As a special exception to the GNU General Public License,
# if you distribute this file as part of a program or library that
# is built using GNU Libtool, you may include this file under the
# same distribution terms that you use for the rest of that program.
#
# GNU Libtool is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Libtool; see the file COPYING.  If not, a copy
# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
# obtained by writing to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.


# The names of the tagged configurations supported by this script.
available_tags=""

# ### BEGIN LIBTOOL CONFIG

# Which release of libtool.m4 was used?
macro_version=$macro_version
macro_revision=$macro_revision

# Whether or not to build shared libraries.
build_libtool_libs=$enable_shared

# Whether or not to build static libraries.
build_old_libs=$enable_static

# What type of objects to build.
pic_mode=$pic_mode

# Whether or not to optimize for fast installation.
fast_install=$enable_fast_install

# Shell to use when invoking shell scripts.
SHELL=$lt_SHELL

# An echo program that protects backslashes.
ECHO=$lt_ECHO

# The PATH separator for the build system.
PATH_SEPARATOR=$lt_PATH_SEPARATOR

# The host system.
host_alias=$host_alias
host=$host
host_os=$host_os

# The build system.
build_alias=$build_alias
build=$build
build_os=$build_os

# A sed program that does not truncate output.
SED=$lt_SED

# Sed that helps us avoid accidentally triggering echo(1) options like -n.
Xsed="\$SED -e 1s/^X//"

# A grep program that handles long lines.
GREP=$lt_GREP

# An ERE matcher.
EGREP=$lt_EGREP

# A literal string matcher.
FGREP=$lt_FGREP

# A BSD- or MS-compatible name lister.
NM=$lt_NM

# Whether we need soft or hard links.
LN_S=$lt_LN_S

# What is the maximum length of a command?
max_cmd_len=$max_cmd_len

# Object file suffix (normally "o").
objext=$ac_objext

# Executable file suffix (normally "").
exeext=$exeext

# whether the shell understands "unset".
lt_unset=$lt_unset

# turn spaces into newlines.
SP2NL=$lt_lt_SP2NL

# turn newlines into spaces.
NL2SP=$lt_lt_NL2SP

# convert \$build file names to \$host format.
to_host_file_cmd=$lt_cv_to_host_file_cmd

# convert \$build files to toolchain format.
to_tool_file_cmd=$lt_cv_to_tool_file_cmd

# An object symbol dumper.
OBJDUMP=$lt_OBJDUMP

# Method to check whether dependent libraries are shared objects.
deplibs_check_method=$lt_deplibs_check_method

# Command to use when deplibs_check_method = "file_magic".
file_magic_cmd=$lt_file_magic_cmd

# How to find potential files when deplibs_check_method = "file_magic".
file_magic_glob=$lt_file_magic_glob

# Find potential files using nocaseglob when deplibs_check_method = "file_magic".
want_nocaseglob=$lt_want_nocaseglob

# DLL creation program.
DLLTOOL=$lt_DLLTOOL

# Command to associate shared and link libraries.
sharedlib_from_linklib_cmd=$lt_sharedlib_from_linklib_cmd

# The archiver.
AR=$lt_AR

# Flags to create an archive.
AR_FLAGS=$lt_AR_FLAGS

# How to feed a file listing to the archiver.
archiver_list_spec=$lt_archiver_list_spec

# A symbol stripping program.
STRIP=$lt_STRIP

# Commands used to install an old-style archive.
RANLIB=$lt_RANLIB
old_postinstall_cmds=$lt_old_postinstall_cmds
old_postuninstall_cmds=$lt_old_postuninstall_cmds

# Whether to use a lock for old archive extraction.
lock_old_archive_extraction=$lock_old_archive_extraction

# A C compiler.
LTCC=$lt_CC

# LTCC compiler flags.
LTCFLAGS=$lt_CFLAGS

# Take the output of nm and produce a listing of raw symbols and C names.
global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe

# Transform the output of nm in a proper C declaration.
global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl

# Transform the output of nm in a C name address pair.
global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address

# Transform the output of nm in a C name address pair when lib prefix is needed.
global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix

# Specify filename containing input files for \$NM.
nm_file_list_spec=$lt_nm_file_list_spec

# The root where to search for dependent libraries,and in which our libraries should be installed.
lt_sysroot=$lt_sysroot

# The name of the directory that contains temporary libtool files.
objdir=$objdir

# Used to examine libraries when file_magic_cmd begins with "file".
MAGIC_CMD=$MAGIC_CMD

# Must we lock files when doing compilation?
need_locks=$lt_need_locks

# Manifest tool.
MANIFEST_TOOL=$lt_MANIFEST_TOOL

# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
DSYMUTIL=$lt_DSYMUTIL

# Tool to change global to local symbols on Mac OS X.
NMEDIT=$lt_NMEDIT

# Tool to manipulate fat objects and archives on Mac OS X.
LIPO=$lt_LIPO

# ldd/readelf like tool for Mach-O binaries on Mac OS X.
OTOOL=$lt_OTOOL

# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
OTOOL64=$lt_OTOOL64

# Old archive suffix (normally "a").
libext=$libext

# Shared library suffix (normally ".so").
shrext_cmds=$lt_shrext_cmds

# The commands to extract the exported symbol list from a shared archive.
extract_expsyms_cmds=$lt_extract_expsyms_cmds

# Variables whose values should be saved in libtool wrapper scripts and
# restored at link time.
variables_saved_for_relink=$lt_variables_saved_for_relink

# Do we need the "lib" prefix for modules?
need_lib_prefix=$need_lib_prefix

# Do we need a version for libraries?
need_version=$need_version

# Library versioning type.
version_type=$version_type

# Shared library runtime path variable.
runpath_var=$runpath_var

# Shared library path variable.
shlibpath_var=$shlibpath_var

# Is shlibpath searched before the hard-coded library search path?
shlibpath_overrides_runpath=$shlibpath_overrides_runpath

# Format of library name prefix.
libname_spec=$lt_libname_spec

# List of archive names.  First name is the real one, the rest are links.
# The last name is the one that the linker finds with -lNAME
library_names_spec=$lt_library_names_spec

# The coded name of the library, if different from the real name.
soname_spec=$lt_soname_spec

# Permission mode override for installation of shared libraries.
install_override_mode=$lt_install_override_mode

# Command to use after installation of a shared archive.
postinstall_cmds=$lt_postinstall_cmds

# Command to use after uninstallation of a shared archive.
postuninstall_cmds=$lt_postuninstall_cmds

# Commands used to finish a libtool library installation in a directory.
finish_cmds=$lt_finish_cmds

# As "finish_cmds", except a single script fragment to be evaled but
# not shown.
finish_eval=$lt_finish_eval

# Whether we should hardcode library paths into libraries.
hardcode_into_libs=$hardcode_into_libs

# Compile-time system search path for libraries.
sys_lib_search_path_spec=$lt_sys_lib_search_path_spec

# Run-time system search path for libraries.
sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec

# Whether dlopen is supported.
dlopen_support=$enable_dlopen

# Whether dlopen of programs is supported.
dlopen_self=$enable_dlopen_self

# Whether dlopen of statically linked programs is supported.
dlopen_self_static=$enable_dlopen_self_static

# Commands to strip libraries.
old_striplib=$lt_old_striplib
striplib=$lt_striplib


# The linker used to build libraries.
LD=$lt_LD

# How to create reloadable object files.
reload_flag=$lt_reload_flag
reload_cmds=$lt_reload_cmds

# Commands used to build an old-style archive.
old_archive_cmds=$lt_old_archive_cmds

# A language specific compiler.
CC=$lt_compiler

# Is the compiler the GNU compiler?
with_gcc=$GCC

# Compiler flag to turn off builtin functions.
no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag

# Additional compiler flags for building library objects.
pic_flag=$lt_lt_prog_compiler_pic

# How to pass a linker flag through the compiler.
wl=$lt_lt_prog_compiler_wl

# Compiler flag to prevent dynamic linking.
link_static_flag=$lt_lt_prog_compiler_static

# Does compiler simultaneously support -c and -o options?
compiler_c_o=$lt_lt_cv_prog_compiler_c_o

# Whether or not to add -lc for building shared libraries.
build_libtool_need_lc=$archive_cmds_need_lc

# Whether or not to disallow shared libs when runtime libs are static.
allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes

# Compiler flag to allow reflexive dlopens.
export_dynamic_flag_spec=$lt_export_dynamic_flag_spec

# Compiler flag to generate shared objects directly from archives.
whole_archive_flag_spec=$lt_whole_archive_flag_spec

# Whether the compiler copes with passing no objects directly.
compiler_needs_object=$lt_compiler_needs_object

# Create an old-style archive from a shared archive.
old_archive_from_new_cmds=$lt_old_archive_from_new_cmds

# Create a temporary old-style archive to link instead of a shared archive.
old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds

# Commands used to build a shared archive.
archive_cmds=$lt_archive_cmds
archive_expsym_cmds=$lt_archive_expsym_cmds

# Commands used to build a loadable module if different from building
# a shared archive.
module_cmds=$lt_module_cmds
module_expsym_cmds=$lt_module_expsym_cmds

# Whether we are building with GNU ld or not.
with_gnu_ld=$lt_with_gnu_ld

# Flag that allows shared libraries with undefined symbols to be built.
allow_undefined_flag=$lt_allow_undefined_flag

# Flag that enforces no undefined symbols.
no_undefined_flag=$lt_no_undefined_flag

# Flag to hardcode \$libdir into a binary during linking.
# This must work even if \$libdir does not exist
hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec

# Whether we need a single "-rpath" flag with a separated argument.
hardcode_libdir_separator=$lt_hardcode_libdir_separator

# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
# DIR into the resulting binary.
hardcode_direct=$hardcode_direct

# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
# DIR into the resulting binary and the resulting library dependency is
# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
# library is relocated.
hardcode_direct_absolute=$hardcode_direct_absolute

# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
# into the resulting binary.
hardcode_minus_L=$hardcode_minus_L

# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
# into the resulting binary.
hardcode_shlibpath_var=$hardcode_shlibpath_var

# Set to "yes" if building a shared library automatically hardcodes DIR
# into the library and all subsequent libraries and executables linked
# against it.
hardcode_automatic=$hardcode_automatic

# Set to yes if linker adds runtime paths of dependent libraries
# to runtime path list.
inherit_rpath=$inherit_rpath

# Whether libtool must link a program against all its dependency libraries.
link_all_deplibs=$link_all_deplibs

# Set to "yes" if exported symbols are required.
always_export_symbols=$always_export_symbols

# The commands to list exported symbols.
export_symbols_cmds=$lt_export_symbols_cmds

# Symbols that should not be listed in the preloaded symbols.
exclude_expsyms=$lt_exclude_expsyms

# Symbols that must always be exported.
include_expsyms=$lt_include_expsyms

# Commands necessary for linking programs (against libraries) with templates.
prelink_cmds=$lt_prelink_cmds

# Commands necessary for finishing linking programs.
postlink_cmds=$lt_postlink_cmds

# Specify filename containing input files.
file_list_spec=$lt_file_list_spec

# How to hardcode a shared library path into an executable.
hardcode_action=$hardcode_action

# ### END LIBTOOL CONFIG

_LT_EOF

  case $host_os in
  aix3*)
    cat <<\_LT_EOF >> "$cfgfile"
# AIX sometimes has problems with the GCC collect2 program.  For some
# reason, if we set the COLLECT_NAMES environment variable, the problems
# vanish in a puff of smoke.
if test "X${COLLECT_NAMES+set}" != Xset; then
  COLLECT_NAMES=
  export COLLECT_NAMES
fi
_LT_EOF
    ;;
  esac


ltmain="$ac_aux_dir/ltmain.sh"


  # We use sed instead of cat because bash on DJGPP gets confused if
  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
  # text mode, it properly converts lines to CR/LF.  This bash problem
  # is reportedly fixed, but why not run on old versions too?
  sed '$q' "$ltmain" >> "$cfgfile" \
     || (rm -f "$cfgfile"; exit 1)

  if test x"$xsi_shell" = xyes; then
  sed -e '/^func_dirname ()$/,/^} # func_dirname /c\
func_dirname ()\
{\
\    case ${1} in\
\      */*) func_dirname_result="${1%/*}${2}" ;;\
\      *  ) func_dirname_result="${3}" ;;\
\    esac\
} # Extended-shell func_dirname implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_basename ()$/,/^} # func_basename /c\
func_basename ()\
{\
\    func_basename_result="${1##*/}"\
} # Extended-shell func_basename implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_dirname_and_basename ()$/,/^} # func_dirname_and_basename /c\
func_dirname_and_basename ()\
{\
\    case ${1} in\
\      */*) func_dirname_result="${1%/*}${2}" ;;\
\      *  ) func_dirname_result="${3}" ;;\
\    esac\
\    func_basename_result="${1##*/}"\
} # Extended-shell func_dirname_and_basename implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_stripname ()$/,/^} # func_stripname /c\
func_stripname ()\
{\
\    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\
\    # positional parameters, so assign one to ordinary parameter first.\
\    func_stripname_result=${3}\
\    func_stripname_result=${func_stripname_result#"${1}"}\
\    func_stripname_result=${func_stripname_result%"${2}"}\
} # Extended-shell func_stripname implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_split_long_opt ()$/,/^} # func_split_long_opt /c\
func_split_long_opt ()\
{\
\    func_split_long_opt_name=${1%%=*}\
\    func_split_long_opt_arg=${1#*=}\
} # Extended-shell func_split_long_opt implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_split_short_opt ()$/,/^} # func_split_short_opt /c\
func_split_short_opt ()\
{\
\    func_split_short_opt_arg=${1#??}\
\    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}\
} # Extended-shell func_split_short_opt implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_lo2o ()$/,/^} # func_lo2o /c\
func_lo2o ()\
{\
\    case ${1} in\
\      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\
\      *)    func_lo2o_result=${1} ;;\
\    esac\
} # Extended-shell func_lo2o implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_xform ()$/,/^} # func_xform /c\
func_xform ()\
{\
    func_xform_result=${1%.*}.lo\
} # Extended-shell func_xform implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_arith ()$/,/^} # func_arith /c\
func_arith ()\
{\
    func_arith_result=$(( $* ))\
} # Extended-shell func_arith implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_len ()$/,/^} # func_len /c\
func_len ()\
{\
    func_len_result=${#1}\
} # Extended-shell func_len implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:

fi

if test x"$lt_shell_append" = xyes; then
  sed -e '/^func_append ()$/,/^} # func_append /c\
func_append ()\
{\
    eval "${1}+=\\${2}"\
} # Extended-shell func_append implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  sed -e '/^func_append_quoted ()$/,/^} # func_append_quoted /c\
func_append_quoted ()\
{\
\    func_quote_for_eval "${2}"\
\    eval "${1}+=\\\\ \\$func_quote_for_eval_result"\
} # Extended-shell func_append_quoted implementation' "$cfgfile" > $cfgfile.tmp \
  && mv -f "$cfgfile.tmp" "$cfgfile" \
    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
test 0 -eq $? || _lt_function_replace_fail=:


  # Save a `func_append' function call where possible by direct use of '+='
  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
    && mv -f "$cfgfile.tmp" "$cfgfile" \
      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
  test 0 -eq $? || _lt_function_replace_fail=:
else
  # Save a `func_append' function call even when '+=' is not available
  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
    && mv -f "$cfgfile.tmp" "$cfgfile" \
      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
  test 0 -eq $? || _lt_function_replace_fail=:
fi

if test x"$_lt_function_replace_fail" = x":"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to substitute extended shell functions in $ofile" >&5
$as_echo "$as_me: WARNING: Unable to substitute extended shell functions in $ofile" >&2;}
fi


   mv -f "$cfgfile" "$ofile" ||
    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
  chmod +x "$ofile"

 ;;

  esac
done # for ac_tag


as_fn_exit 0
_ACEOF
ac_clean_files=$ac_clean_files_save

test $ac_write_fail = 0 ||
  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5


# configure is writing to config.log, and then calls config.status.
# config.status does its own redirection, appending to config.log.
# Unfortunately, on DOS this fails, as config.log is still kept open
# by configure, so config.status won't be able to write to it; its
# output is simply discarded.  So we exec the FD to /dev/null,
# effectively closing config.log, so it can be properly (re)opened and
# appended to by config.status.  When coming back to configure, we
# need to make the FD available again.
if test "$no_create" != yes; then
  ac_cs_success=:
  ac_config_status_args=
  test "$silent" = yes &&
    ac_config_status_args="$ac_config_status_args --quiet"
  exec 5>/dev/null
  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
  exec 5>>config.log
  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
  # would make configure fail if this is the last instruction.
  $ac_cs_success || as_fn_exit 1
fi
if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
fi

                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/configure.ac                                                                    0100644 0000000 0000000 00000007544 13045171016 014560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * This file is part of the ZFS Linux port.
 *
 * Copyright (c) 2009 Lawrence Livermore National Security, LLC.
 * Produced at Lawrence Livermore National Laboratory
 * Written by:
 *         Brian Behlendorf <behlendorf1@llnl.gov>,
 *         Herb Wartens <wartens2@llnl.gov>,
 *         Jim Garlick <garlick@llnl.gov>
 * LLNL-CODE-403049
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

AC_INIT(m4_esyscmd(grep Name META | cut -d ':' -f 2 | tr -d ' \n'),
	m4_esyscmd(grep Version META | cut -d ':' -f 2 | tr -d ' \n'))
AC_LANG(C)
ZFS_AC_META
AC_CONFIG_AUX_DIR([config])
AC_CONFIG_MACRO_DIR([config])
AC_CANONICAL_SYSTEM
AM_MAINTAINER_MODE
m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS([zfs_config.h], [
	(mv zfs_config.h zfs_config.h.tmp &&
	awk -f ${ac_srcdir}/config/config.awk zfs_config.h.tmp >zfs_config.h &&
	rm zfs_config.h.tmp) || exit 1])

AC_PROG_INSTALL
AC_PROG_CC
AC_PROG_LIBTOOL
AM_PROG_AS

ZFS_AC_LICENSE
ZFS_AC_PACKAGE
ZFS_AC_CONFIG
ZFS_AC_DEBUG
ZFS_AC_DEBUG_DMU_TX

AC_CONFIG_FILES([ 
	Makefile
	udev/Makefile
	udev/rules.d/Makefile
	etc/Makefile
	etc/init.d/Makefile
	etc/zfs/Makefile
	etc/systemd/Makefile
	etc/systemd/system/Makefile
	etc/modules-load.d/Makefile
	man/Makefile
	man/man1/Makefile
	man/man5/Makefile
	man/man8/Makefile
	lib/Makefile
	lib/libspl/Makefile
	lib/libspl/asm-generic/Makefile
	lib/libspl/asm-i386/Makefile
	lib/libspl/asm-x86_64/Makefile
	lib/libspl/include/Makefile
	lib/libspl/include/ia32/Makefile
	lib/libspl/include/ia32/sys/Makefile
	lib/libspl/include/rpc/Makefile
	lib/libspl/include/sys/Makefile
	lib/libspl/include/sys/sysevent/Makefile
	lib/libspl/include/sys/dktp/Makefile
	lib/libspl/include/util/Makefile
	lib/libavl/Makefile
	lib/libefi/Makefile
	lib/libnvpair/Makefile
	lib/libunicode/Makefile
	lib/libuutil/Makefile
	lib/libzpool/Makefile
	lib/libzfs/libzfs.pc
	lib/libzfs/libzfs_core.pc
	lib/libzfs/Makefile
	lib/libzfs_core/Makefile
	lib/libshare/Makefile
	cmd/Makefile
	cmd/zdb/Makefile
	cmd/zhack/Makefile
	cmd/zfs/Makefile
	cmd/zinject/Makefile
	cmd/zpool/Makefile
	cmd/zstreamdump/Makefile
	cmd/ztest/Makefile
	cmd/zpios/Makefile
	cmd/mount_zfs/Makefile
	cmd/fsck_zfs/Makefile
	cmd/zvol_id/Makefile
	cmd/vdev_id/Makefile
	cmd/arcstat/Makefile
	cmd/dbufstat/Makefile
	cmd/arc_summary/Makefile
	cmd/zed/Makefile
	contrib/Makefile
	contrib/bash_completion.d/Makefile
	contrib/dracut/Makefile
	contrib/dracut/90zfs/Makefile
	contrib/initramfs/Makefile
	module/Makefile
	module/avl/Makefile
	module/nvpair/Makefile
	module/unicode/Makefile
	module/zcommon/Makefile
	module/zfs/Makefile
	module/zpios/Makefile
	include/Makefile
	include/linux/Makefile
	include/sys/Makefile
	include/sys/fs/Makefile
	include/sys/fm/Makefile
	include/sys/fm/fs/Makefile
	scripts/Makefile
	scripts/zpios-profile/Makefile
	scripts/zpios-test/Makefile
	scripts/zpool-config/Makefile
	scripts/common.sh
	rpm/Makefile
	rpm/redhat/Makefile
	rpm/redhat/zfs.spec
	rpm/redhat/zfs-kmod.spec
	rpm/redhat/zfs-dkms.spec
	rpm/generic/Makefile
	rpm/generic/zfs.spec
	rpm/generic/zfs-kmod.spec
	rpm/generic/zfs-dkms.spec
	zfs-script-config.sh
	zfs.release
])

AC_OUTPUT
                                                                                                                                                            usr/src/zfs-0.6.5.9/contrib/                                                                        0040755 0000000 0000000 00000000000 13077704276 013742  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/Makefile.am                                                             0100644 0000000 0000000 00000000137 13045171016 015755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = bash_completion.d dracut initramfs
DIST_SUBDIRS = bash_completion.d dracut initramfs
                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/contrib/Makefile.in                                                             0100644 0000000 0000000 00000060542 13045370525 016002  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@
VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = contrib
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
SUBDIRS = bash_completion.d dracut initramfs
DIST_SUBDIRS = bash_completion.d dracut initramfs
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu contrib/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu contrib/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                              usr/src/zfs-0.6.5.9/contrib/bash_completion.d/                                                      0040755 0000000 0000000 00000000000 13077704276 017332  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/bash_completion.d/Makefile.am                                           0100644 0000000 0000000 00000000144 13045171016 021343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        bashcompletiondir = $(sysconfdir)/bash_completion.d

noinst_DATA = zfs

EXTRA_DIST = $(noinst_DATA)
                                                                                                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/contrib/bash_completion.d/Makefile.in                                           0100644 0000000 0000000 00000044347 13045370525 021377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = contrib/bash_completion.d
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
DATA = $(noinst_DATA)
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
bashcompletiondir = $(sysconfdir)/bash_completion.d
noinst_DATA = zfs
EXTRA_DIST = $(noinst_DATA)
all: all-am

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu contrib/bash_completion.d/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu contrib/bash_completion.d/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
tags TAGS:

ctags CTAGS:

cscope cscopelist:


distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(DATA)
installdirs:
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-generic

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am:

.MAKE: install-am install-strip

.PHONY: all all-am check check-am clean clean-generic clean-libtool \
	cscopelist-am ctags-am distclean distclean-generic \
	distclean-libtool distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	maintainer-clean maintainer-clean-generic mostlyclean \
	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
	tags-am uninstall uninstall-am


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                         usr/src/zfs-0.6.5.9/contrib/bash_completion.d/zfs                                                   0100644 0000000 0000000 00000026051 13045171016 020041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2013, Aneurin Price <aneurin.price@gmail.com>

# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

if [[ -w /dev/zfs ]]; then
    __ZFS_CMD="zfs"
    __ZPOOL_CMD="zpool"
else
    __ZFS_CMD="sudo zfs"
    __ZPOOL_CMD="sudo zpool"
fi

__zfs_get_commands()
{
    $__ZFS_CMD 2>&1 | awk '/^\t[a-z]/ {print $1}' | cut -f1 -d '|' | uniq
}

__zfs_get_properties()
{
    $__ZFS_CMD get 2>&1 | awk '$2 == "YES" || $2 == "NO" {print $1}'; echo all name space
}

__zfs_get_editable_properties()
{
    $__ZFS_CMD get 2>&1 | awk '$2 == "YES" {print $1"="}'
}

__zfs_get_inheritable_properties()
{
    $__ZFS_CMD get 2>&1 | awk '$3 == "YES" {print $1}'
}

__zfs_list_datasets()
{
    $__ZFS_CMD list -H -o name -t filesystem,volume
}

__zfs_list_filesystems()
{
    $__ZFS_CMD list -H -o name -t filesystem
}

__zfs_match_snapshot()
{
    local base_dataset=${cur%@*}
    if [[ $base_dataset != $cur ]]
    then
        $__ZFS_CMD list -H -o name -t snapshot -d 1 $base_dataset
    else
        $__ZFS_CMD list -H -o name -t filesystem,volume | awk '{print $1"@"}'
    fi
}

__zfs_match_explicit_snapshot()
{
    local base_dataset=${cur%@*}
    if [[ $base_dataset != $cur ]]
    then
        $__ZFS_CMD list -H -o name -t snapshot -d 1 $base_dataset
    fi
}

__zfs_match_multiple_snapshots()
{
    local existing_opts=$(expr "$cur" : '\(.*\)[%,]')
    if [[ $existing_opts ]]
    then
        local base_dataset=${cur%@*}
        if [[ $base_dataset != $cur ]]
        then
            local cur=${cur##*,}
            if [[ $cur =~ ^%|%.*% ]]
            then
                # correct range syntax is start%end
                return 1
            fi
            local range_start=$(expr "$cur" : '\(.*%\)')
            $__ZFS_CMD list -H -o name -t snapshot -d 1 $base_dataset | sed 's$.*@$'$range_start'$g'
        fi
    else
        __zfs_match_explicit_snapshot; __zfs_list_datasets
    fi
}

__zfs_list_volumes()
{
    $__ZFS_CMD list -H -o name -t volume
}

__zfs_argument_chosen()
{
    local word property
    for word in $(seq $((COMP_CWORD-1)) -1 2)
    do
        local prev="${COMP_WORDS[$word]}"
        if [[ ${COMP_WORDS[$word-1]} != -[tos] ]]
        then
            if [[ "$prev" == [^,]*,* ]] || [[ "$prev" == *[@:]* ]]
            then
                return 0
            fi
            for property in $@
            do
                if [[ $prev == "$property" ]]
                then
                    return 0
                fi
            done
        fi
    done
    return 1
}

__zfs_complete_ordered_arguments()
{
    local list1=$1
    local list2=$2
    local cur=$3
    local extra=$4
    if __zfs_argument_chosen $list1
    then
        COMPREPLY=($(compgen -W "$list2 $extra" -- "$cur"))
    else
        COMPREPLY=($(compgen -W "$list1 $extra" -- "$cur"))
    fi
}

__zfs_complete_multiple_options()
{
    local options=$1
    local cur=$2

    COMPREPLY=($(compgen -W "$options" -- "${cur##*,}"))
    local existing_opts=$(expr "$cur" : '\(.*,\)')
    if [[ $existing_opts ]] 
    then
        COMPREPLY=( "${COMPREPLY[@]/#/${existing_opts}}" )
    fi
}

__zfs_complete_switch()
{
    local options=$1
    if [[ ${cur:0:1} == - ]]
    then
        COMPREPLY=($(compgen -W "-{$options}" -- "$cur"))
        return 0
    else
        return 1
    fi
}

__zfs_complete()
{
    local cur prev cmd cmds
    COMPREPLY=()
    # Don't split on colon
    _get_comp_words_by_ref -n : -c cur -p prev -w COMP_WORDS -i COMP_CWORD
    cmd="${COMP_WORDS[1]}"

    if [[ ${prev##*/} == zfs ]]
    then
        cmds=$(__zfs_get_commands)
        COMPREPLY=($(compgen -W "$cmds -?" -- "$cur"))
        return 0
    fi

    case "${cmd}" in
        clone)
            case "${prev}" in
                -o)
                    COMPREPLY=($(compgen -W "$(__zfs_get_editable_properties)" -- "$cur"))
                    ;;
                *)
                    if ! __zfs_complete_switch "o,p"
                    then
                        if __zfs_argument_chosen
                        then
                            COMPREPLY=($(compgen -W "$(__zfs_list_datasets)" -- "$cur"))
                        else
                            COMPREPLY=($(compgen -W "$(__zfs_match_snapshot)" -- "$cur"))
                        fi
                    fi
                    ;;
            esac
            ;;
        get)
            case "${prev}" in
                -d)
                    COMPREPLY=($(compgen -W "" -- "$cur"))
                    ;;
                -t)
                    __zfs_complete_multiple_options "filesystem volume snapshot all" "$cur"
                    ;;
                -s)
                    __zfs_complete_multiple_options "local default inherited temporary none" "$cur"
                    ;;
                -o)
                    __zfs_complete_multiple_options "name property value source received all" "$cur"
                    ;;
                *)
                    if ! __zfs_complete_switch "H,r,p,d,o,t,s"
                    then
                        if __zfs_argument_chosen $(__zfs_get_properties)
                        then
                            COMPREPLY=($(compgen -W "$(__zfs_match_explicit_snapshot) $(__zfs_list_datasets)" -- "$cur"))
                        else
                            __zfs_complete_multiple_options "$(__zfs_get_properties)" "$cur"
                        fi
                    fi
                    ;;
            esac
            ;;
        inherit)
            if ! __zfs_complete_switch "r"
            then
                __zfs_complete_ordered_arguments "$(__zfs_get_inheritable_properties)" "$(__zfs_match_explicit_snapshot) $(__zfs_list_datasets)" $cur
            fi
            ;;
        list)
            case "${prev}" in
                -d)
                    COMPREPLY=($(compgen -W "" -- "$cur"))
                    ;;
                -t)
                    __zfs_complete_multiple_options "filesystem volume snapshot all" "$cur"
                    ;;
                -o)
                    __zfs_complete_multiple_options "$(__zfs_get_properties)" "$cur"
                    ;;
                -s|-S)
                    COMPREPLY=($(compgen -W "$(__zfs_get_properties)" -- "$cur"))
                    ;;
                *)
                    if ! __zfs_complete_switch "H,r,d,o,t,s,S"
                    then
                        COMPREPLY=($(compgen -W "$(__zfs_match_explicit_snapshot) $(__zfs_list_datasets)" -- "$cur"))
                    fi
                    ;;
            esac
            ;;
        promote)
            COMPREPLY=($(compgen -W "$(__zfs_list_filesystems)" -- "$cur"))
            ;;
        rollback)
            if ! __zfs_complete_switch "r,R,f"
            then
                COMPREPLY=($(compgen -W "$(__zfs_match_snapshot)" -- "$cur"))
            fi
            ;;
        send)
            if ! __zfs_complete_switch "d,n,P,p,R,v,i,I"
            then
                COMPREPLY=($(compgen -W "$(__zfs_match_snapshot)" -- "$cur"))
            fi
            ;;
        snapshot)
            case "${prev}" in
                -o)
                    COMPREPLY=($(compgen -W "$(__zfs_get_editable_properties)" -- "$cur"))
                    ;;
                *)
                    if ! __zfs_complete_switch "o,r"
                    then
                        COMPREPLY=($(compgen -W "$(__zfs_list_datasets | awk '{print $1"@"}')" -- "$cur"))
                    fi
                    ;;
            esac
            ;;
        set)
            __zfs_complete_ordered_arguments "$(__zfs_get_editable_properties)" "$(__zfs_match_explicit_snapshot) $(__zfs_list_datasets)" $cur
            ;;
        upgrade)
            case "${prev}" in
                -a|-V|-v)
                    COMPREPLY=($(compgen -W "" -- "$cur"))
                    ;;
                *)
                    if ! __zfs_complete_switch "a,V,v,r"
                    then
                        COMPREPLY=($(compgen -W "$(__zfs_list_filesystems)" -- "$cur"))
                    fi
                    ;;
            esac
            ;;
        destroy)
            if ! __zfs_complete_switch "d,f,n,p,R,r,v"
            then
                __zfs_complete_multiple_options "$(__zfs_match_multiple_snapshots)" $cur
            fi
            ;;
        *)
            COMPREPLY=($(compgen -W "$(__zfs_match_explicit_snapshot) $(__zfs_list_datasets)" -- "$cur"))
            ;;
    esac
    __ltrim_colon_completions "$cur"
    return 0
}

__zpool_get_commands()
{
    $__ZPOOL_CMD 2>&1 | awk '/^\t[a-z]/ {print $1}' | uniq
}

__zpool_get_properties()
{
    $__ZPOOL_CMD get 2>&1 | awk '$2 == "YES" || $2 == "NO" {print $1}'; echo all
}

__zpool_get_editable_properties()
{
    $__ZPOOL_CMD get 2>&1 | awk '$2 == "YES" {print $1"="}'
}

__zpool_list_pools()
{
    $__ZPOOL_CMD list -H -o name
}

__zpool_complete()
{
    local cur prev cmd cmds
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd="${COMP_WORDS[1]}"

    if [[ ${prev##*/} == zpool ]]
    then
        cmds=$(__zpool_get_commands)
        COMPREPLY=($(compgen -W "$cmds" -- "$cur"))
        return 0
    fi

    case "${cmd}" in
        get)
            __zfs_complete_ordered_arguments "$(__zpool_get_properties)" "$(__zpool_list_pools)" $cur
            return 0
            ;;
        import)
            if [[ $prev == -d ]]
            then
                _filedir -d
            else
                COMPREPLY=($(compgen -W "$(__zpool_list_pools) -d" -- "$cur"))
            fi
            return 0
            ;;
        set)
            __zfs_complete_ordered_arguments "$(__zpool_get_editable_properties)" "$(__zpool_list_pools)" $cur
            return 0
            ;;
        add|attach|clear|create|detach|offline|online|remove|replace)
            local pools="$(__zpool_list_pools)"
            if __zfs_argument_chosen $pools
            then
                _filedir
            else
                COMPREPLY=($(compgen -W "$pools" -- "$cur"))
            fi
            return 0
            ;;
        *)
            COMPREPLY=($(compgen -W "$(__zpool_list_pools)" -- "$cur"))
            return 0
            ;;
    esac

}

complete -F __zfs_complete zfs
complete -F __zpool_complete zpool
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/src/zfs-0.6.5.9/contrib/dracut/                                                                 0040755 0000000 0000000 00000000000 13077704276 015224  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/                                                           0040755 0000000 0000000 00000000000 13077704276 016177  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/Makefile.am                                                0100644 0000000 0000000 00000001354 13045171016 020214  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        pkgdracutdir = $(dracutdir)/modules.d/90zfs
pkgdracut_SCRIPTS = \
	export-zfs.sh \
	module-setup.sh \
	mount-zfs.sh \
	parse-zfs.sh \
	zfs-lib.sh

EXTRA_DIST = \
	$(top_srcdir)/contrib/dracut/90zfs/export-zfs.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/module-setup.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/mount-zfs.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/parse-zfs.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/zfs-lib.sh.in

$(pkgdracut_SCRIPTS):
	-$(SED) -e 's,@bindir\@,$(bindir),g' \
		-e 's,@sbindir\@,$(sbindir),g' \
		-e 's,@udevdir\@,$(udevdir),g' \
		-e 's,@udevruledir\@,$(udevruledir),g' \
		-e 's,@sysconfdir\@,$(sysconfdir),g' \
		"$(top_srcdir)/contrib/dracut/90zfs/$@.in" >'$@'

distclean-local::
	-$(RM) $(pkgdracut_SCRIPTS)
                                                                                                                                                                                                                                                                                    usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/Makefile.in                                                0100644 0000000 0000000 00000053417 13045370526 020243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = contrib/dracut/90zfs
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(pkgdracutdir)"
SCRIPTS = $(pkgdracut_SCRIPTS)
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
pkgdracutdir = $(dracutdir)/modules.d/90zfs
pkgdracut_SCRIPTS = \
	export-zfs.sh \
	module-setup.sh \
	mount-zfs.sh \
	parse-zfs.sh \
	zfs-lib.sh

EXTRA_DIST = \
	$(top_srcdir)/contrib/dracut/90zfs/export-zfs.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/module-setup.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/mount-zfs.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/parse-zfs.sh.in \
	$(top_srcdir)/contrib/dracut/90zfs/zfs-lib.sh.in

all: all-am

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu contrib/dracut/90zfs/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu contrib/dracut/90zfs/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-pkgdracutSCRIPTS: $(pkgdracut_SCRIPTS)
	@$(NORMAL_INSTALL)
	@list='$(pkgdracut_SCRIPTS)'; test -n "$(pkgdracutdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(pkgdracutdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(pkgdracutdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  if test -f "$$d$$p"; then echo "$$d$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n' \
	    -e 'h;s|.*|.|' \
	    -e 'p;x;s,.*/,,;$(transform)' | sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1; } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) { files[d] = files[d] " " $$1; \
	      if (++n[d] == $(am__install_max)) { \
		print "f", d, files[d]; n[d] = 0; files[d] = "" } } \
	    else { print "f", d "/" $$4, $$1 } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	     if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	     test -z "$$files" || { \
	       echo " $(INSTALL_SCRIPT) $$files '$(DESTDIR)$(pkgdracutdir)$$dir'"; \
	       $(INSTALL_SCRIPT) $$files "$(DESTDIR)$(pkgdracutdir)$$dir" || exit $$?; \
	     } \
	; done

uninstall-pkgdracutSCRIPTS:
	@$(NORMAL_UNINSTALL)
	@list='$(pkgdracut_SCRIPTS)'; test -n "$(pkgdracutdir)" || exit 0; \
	files=`for p in $$list; do echo "$$p"; done | \
	       sed -e 's,.*/,,;$(transform)'`; \
	dir='$(DESTDIR)$(pkgdracutdir)'; $(am__uninstall_files_from_dir)

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
tags TAGS:

ctags CTAGS:

cscope cscopelist:


distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(SCRIPTS)
installdirs:
	for dir in "$(DESTDIR)$(pkgdracutdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-local

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am: install-pkgdracutSCRIPTS

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-pkgdracutSCRIPTS

.MAKE: install-am install-strip

.PHONY: all all-am check check-am clean clean-generic clean-libtool \
	cscopelist-am ctags-am distclean distclean-generic \
	distclean-libtool distclean-local distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-html install-html-am install-info \
	install-info-am install-man install-pdf install-pdf-am \
	install-pkgdracutSCRIPTS install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	maintainer-clean maintainer-clean-generic mostlyclean \
	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
	tags-am uninstall uninstall-am uninstall-pkgdracutSCRIPTS


$(pkgdracut_SCRIPTS):
	-$(SED) -e 's,@bindir\@,$(bindir),g' \
		-e 's,@sbindir\@,$(sbindir),g' \
		-e 's,@udevdir\@,$(udevdir),g' \
		-e 's,@udevruledir\@,$(udevruledir),g' \
		-e 's,@sysconfdir\@,$(sysconfdir),g' \
		"$(top_srcdir)/contrib/dracut/90zfs/$@.in" >'$@'

distclean-local::
	-$(RM) $(pkgdracut_SCRIPTS)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/export-zfs.sh.in                                           0100755 0000000 0000000 00000000620 13045171016 021240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

. /lib/dracut-zfs-lib.sh

_do_zpool_export() {
	local ret=0
	local final="${1}"
	local opts=""

	if [ "x${final}" != "x" ]; then
		opts="-f"
	fi

	info "Exporting ZFS storage pools."
	export_all ${opts} || ret=$?

	if [ "x${final}" != "x" ]; then
		info "zpool list"
		zpool list 2>&1 | vinfo
	fi

	return ${ret}
}

if command -v zpool >/dev/null; then
	_do_zpool_export "${1}"
else
	:
fi
                                                                                                                usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/module-setup.sh.in                                         0100755 0000000 0000000 00000002527 13045171016 021552  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

check() {
	# We depend on udev-rules being loaded
	[ "${1}" = "-d" ] && return 0

	# Verify the zfs tool chain
	which zpool >/dev/null 2>&1 || return 1
	which zfs >/dev/null 2>&1 || return 1

	return 0
}

depends() {
	echo udev-rules
	return 0
}

installkernel() {
	instmods zfs
	instmods zcommon
	instmods znvpair
	instmods zavl
	instmods zunicode
	instmods spl
	instmods zlib_deflate
	instmods zlib_inflate
}

install() {
	inst_rules @udevruledir@/90-zfs.rules
	inst_rules @udevruledir@/69-vdev.rules
	inst_rules @udevruledir@/60-zvol.rules
	dracut_install @sbindir@/zfs
	dracut_install @sbindir@/zpool
	dracut_install @udevdir@/vdev_id
	dracut_install @udevdir@/zvol_id
	dracut_install mount.zfs
	dracut_install hostid
	dracut_install awk
	dracut_install head
	inst_hook cmdline 95 "${moddir}/parse-zfs.sh"
	inst_hook mount 98 "${moddir}/mount-zfs.sh"
	inst_hook shutdown 30 "${moddir}/export-zfs.sh"

	inst_simple "${moddir}/zfs-lib.sh" "/lib/dracut-zfs-lib.sh"
	if [ -e @sysconfdir@/zfs/zpool.cache ]; then
		inst @sysconfdir@/zfs/zpool.cache
	fi

	if [ -e @sysconfdir@/zfs/vdev_id.conf ]; then
		inst @sysconfdir@/zfs/vdev_id.conf
	fi

	# Synchronize initramfs and system hostid
	AA=`hostid | cut -b 1,2`
	BB=`hostid | cut -b 3,4`
	CC=`hostid | cut -b 5,6`
	DD=`hostid | cut -b 7,8`
	printf "\x${DD}\x${CC}\x${BB}\x${AA}" > "${initdir}/etc/hostid"
}
                                                                                                                                                                         usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/mount-zfs.sh.in                                            0100755 0000000 0000000 00000001454 13045171016 021067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

. /lib/dracut-zfs-lib.sh

ZFS_DATASET=""
ZFS_POOL=""

case "${root}" in
	zfs:*) ;;
	*) return ;;
esac

# Delay until all required block devices are present.
udevadm settle

if [ "${root}" = "zfs:AUTO" ] ; then
	ZFS_DATASET="$(find_bootfs)"
	if [ $? -ne 0 ] ; then
		zpool import -N -a ${ZPOOL_IMPORT_OPTS}
		ZFS_DATASET="$(find_bootfs)"
		if [ $? -ne 0 ] ; then
			warn "ZFS: No bootfs attribute found in importable pools."
			export_all || export_all "-f"

			rootok=0
			return 1
		fi
	fi
	info "ZFS: Using ${ZFS_DATASET} as root."
fi

ZFS_DATASET="${ZFS_DATASET:-${root#zfs:}}"
ZFS_POOL="${ZFS_DATASET%%/*}"

if import_pool "${ZFS_POOL}" ; then
	info "ZFS: Mounting dataset ${ZFS_DATASET}..."
	if mount_dataset "${ZFS_DATASET}" ; then
		ROOTFS_MOUNTED=yes
		return 0
	fi
fi

rootok=0
need_shutdown
                                                                                                                                                                                                                    usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/parse-zfs.sh.in                                            0100755 0000000 0000000 00000003253 13045171016 021036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

. /lib/dracut-lib.sh

# Let the command line override our host id.
spl_hostid=`getarg spl_hostid=`
if [ -n "${spl_hostid}" ] ; then
	info "ZFS: Using hostid from command line: ${spl_hostid}"
	AA=`echo ${spl_hostid} | cut -b 1,2`
	BB=`echo ${spl_hostid} | cut -b 3,4`
	CC=`echo ${spl_hostid} | cut -b 5,6`
	DD=`echo ${spl_hostid} | cut -b 7,8`
	printf "\x${DD}\x${CC}\x${BB}\x${AA}" >/etc/hostid
elif [ -f "/etc/hostid" ] ; then
	info "ZFS: Using hostid from /etc/hostid: `hostid`"
else
	warn "ZFS: No hostid found on kernel command line or /etc/hostid."
	warn "ZFS: Pools may not import correctly."
fi

wait_for_zfs=0
case "${root}" in
	""|zfs|zfs:)
		# We'll take root unset, root=zfs, or root=zfs:
		# No root set, so we want to read the bootfs attribute.  We
		# can't do that until udev settles so we'll set dummy values
		# and hope for the best later on.
		root="zfs:AUTO"
		rootok=1
		wait_for_zfs=1

		info "ZFS: Enabling autodetection of bootfs after udev settles."
		;;

	ZFS\=*|zfs:*|zfs:FILESYSTEM\=*|FILESYSTEM\=*)
		# root is explicit ZFS root.  Parse it now.  We can handle
		# a root=... param in any of the following formats:
		# root=ZFS=rpool/ROOT
		# root=zfs:rpool/ROOT
		# root=zfs:FILESYSTEM=rpool/ROOT
		# root=FILESYSTEM=rpool/ROOT

		# Strip down to just the pool/fs
		root="${root#zfs:}"
		root="${root#FILESYSTEM=}"
		root="zfs:${root#ZFS=}"
		rootok=1
		wait_for_zfs=1

		info "ZFS: Set ${root} as bootfs."
		;;
esac

# Make sure Dracut is happy that we have a root and will wait for ZFS
# modules to settle before mounting.
if [ ${wait_for_zfs} -eq 1 ]; then
	ln -s /dev/null /dev/root 2>/dev/null
	echo '[ -e /dev/zfs ]' > "${hookdir}/initqueue/finished/zfs.sh"
fi
                                                                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/contrib/dracut/90zfs/zfs-lib.sh.in                                              0100755 0000000 0000000 00000003254 13045171016 020473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

command -v getarg >/dev/null || . /lib/dracut-lib.sh

OLDIFS="${IFS}"
NEWLINE="
"

ZPOOL_IMPORT_OPTS=""
if getargbool 0 zfs_force -y zfs.force -y zfsforce ; then
	warn "ZFS: Will force-import pools if necessary."
	ZPOOL_IMPORT_OPTS="${ZPOOL_IMPORT_OPTS} -f"
fi

# find_bootfs
#   returns the first dataset with the bootfs attribute.
find_bootfs() {
	IFS="${NEWLINE}"
	for dataset in $(zpool list -H -o bootfs); do
		case "${dataset}" in
			"" | "-")
				continue
				;;
			"no pools available")
				IFS="${OLDIFS}"
				return 1
				;;
			*)
				IFS="${OLDIFS}"
				echo "${dataset}"
				return 0
				;;
		esac
	done

	IFS="${OLDIFS}"
	return 1
}

# import_pool POOL
#   imports the given zfs pool if it isn't imported already.
import_pool() {
	local pool="${1}"

	if ! zpool list -H "${pool}" 2>&1 > /dev/null ; then
		info "ZFS: Importing pool ${pool}..."
		if ! zpool import -N ${ZPOOL_IMPORT_OPTS} "${pool}" ; then
			warn "ZFS: Unable to import pool ${pool}"
			return 1
		fi
	fi

	return 0
}

# mount_dataset DATASET
#   mounts the given zfs dataset.
mount_dataset() {
	local dataset="${1}"
	local mountpoint="$(zfs get -H -o value mountpoint "${dataset}")"

	# We need zfsutil for non-legacy mounts and not for legacy mounts.
	if [ "${mountpoint}" = "legacy" ] ; then
		mount -t zfs "${dataset}" "${NEWROOT}"
	else
		mount -o zfsutil -t zfs "${dataset}" "${NEWROOT}"
	fi

	return $?
}

# export_all OPTS
#   exports all imported zfs pools.
export_all() {
	local opts="${1}"
	local ret=0

	IFS="${NEWLINE}"
	for pool in `zpool list -H -o name` ; do
		if zpool list -H "${pool}" 2>&1 > /dev/null ; then
			zpool export "${pool}" ${opts} || ret=$?
		fi
	done
	IFS="${OLDIFS}"

	return ${ret}
}
                                                                                                                                                                                                                                                                                                                                                    usr/src/zfs-0.6.5.9/contrib/dracut/Makefile.am                                                      0100644 0000000 0000000 00000000065 13045171016 017237  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = 90zfs

EXTRA_DIST = README.dracut.markdown
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/src/zfs-0.6.5.9/contrib/dracut/Makefile.in                                                      0100644 0000000 0000000 00000060546 13045370526 017271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@
VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = contrib/dracut
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
SUBDIRS = 90zfs
EXTRA_DIST = README.dracut.markdown
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu contrib/dracut/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu contrib/dracut/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                          usr/src/zfs-0.6.5.9/contrib/dracut/README.dracut.markdown                                           0100644 0000000 0000000 00000023415 13045171016 021171  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        How to setup a zfs root filesystem using dracut
-----------------------------------------------

1) Install the zfs-dracut package.  This package adds a zfs dracut module
to the /usr/share/dracut/modules.d/ directory which allows dracut to
create an initramfs which is zfs aware.

2) Set the bootfs property for the bootable dataset in the pool.  Then set
the dataset mountpoint property to '/'.

    $ zpool set bootfs=pool/dataset pool
    $ zfs set mountpoint=/ pool/dataset

It is also possible to set the bootfs property for an entire pool, just in
case you are not using a dedicated dataset for '/'.

    $ zpool set bootfs=pool pool
    $ zfs set mountpoint=/ pool

Alternately, legacy mountpoints can be used by setting the 'root=' option
on the kernel line of your grub.conf/menu.lst configuration file.  Then
set the dataset mountpoint property to 'legacy'.

    $ grub.conf/menu.lst: kernel ... root=ZFS=pool/dataset
    $ zfs set mountpoint=legacy pool/dataset

3) To set zfs module options put them in /etc/modprobe.d/zfs.conf file.
The complete list of zfs module options is available by running the
_modinfo zfs_ command.  Commonly set options include: zfs_arc_min,
zfs_arc_max, zfs_prefetch_disable, and zfs_vdev_max_pending.

4) Finally, create your new initramfs by running dracut.

    $ dracut --force /path/to/initramfs kernel_version

Kernel Command Line
-------------------

The initramfs' behavior is influenced by the following kernel command line
parameters passed in from the boot loader:

* `root=...`: If not set, importable pools are searched for a bootfs
attribute.  If an explicitly set root is desired, you may use
`root=ZFS:pool/dataset`

* `zfs_force=0`: If set to 1, the initramfs will run `zpool import -f` when
attempting to import pools if the required pool isn't automatically imported
by the zfs module.  This can save you a trip to a bootcd if hostid has
changed, but is dangerous and can lead to zpool corruption, particularly in
cases where storage is on a shared fabric such as iSCSI where multiple hosts
can access storage devices concurrently.  _Please understand the implications
of force-importing a pool before enabling this option!_

* `spl_hostid`: By default, the hostid used by the SPL module is read from
/etc/hostid inside the initramfs.  This file is placed there from the host
system when the initramfs is built which effectively ties the ramdisk to the
host which builds it.  If a different hostid is desired, one may be set in
this attribute and will override any file present in the ramdisk.  The
format should be hex exactly as found in the `/etc/hostid` file, IE
`spl_hostid=0x00bab10c`.

Note that changing the hostid between boots will most likely lead to an
un-importable pool since the last importing hostid won't match.  In order
to recover from this, you may use the `zfs_force` option or boot from a
different filesystem and `zpool import -f` then `zpool export` the pool
before rebooting with the new hostid.

How it Works
============

The Dracut module consists of the following files (less Makefile's):

* `module-setup.sh`: Script run by the initramfs builder to create the
ramdisk.  Contains instructions on which files are required by the modules
and z* programs.  Also triggers inclusion of `/etc/hostid` and the zpool
cache.  This file is not included in the initramfs.

* `90-zfs.rules`: udev rules which trigger loading of the ZFS modules at boot.

* `zfs-lib.sh`: Utility functions used by the other files.

* `parse-zfs.sh`: Run early in the initramfs boot process to parse kernel
command line and determine if ZFS is the active root filesystem.

* `mount-zfs.sh`: Run later in initramfs boot process after udev has settled
to mount the root dataset.

* `export-zfs.sh`: Run on shutdown after dracut has restored the initramfs
and pivoted to it, allowing for a clean unmount and export of the ZFS root.

`zfs-lib.sh`
------------

This file provides a few handy functions for working with ZFS. Those
functions are used by the `mount-zfs.sh` and `export-zfs.sh` files.
However, they could be used by any other file as well, as long as the file
sources `/lib/dracut-zfs-lib.sh`.

`module-setup.sh`
-----------------

This file is run by the Dracut script within the live system, not at boot
time.  It's not included in the final initramfs.  Functions in this script
describe which files are needed by ZFS at boot time.

Currently all the various z* and spl modules are included, a dependency is
asserted on udev-rules, and the various zfs, zpool, etc. helpers are included.
Dracut provides library functions which automatically gather the shared libs
necessary to run each of these binaries, so statically built binaries are
not required.

The zpool and zvol udev rules files are copied from where they are
installed by the ZFS build.  __PACKAGERS TAKE NOTE__: If you move
`/etc/udev/rules/60-z*.rules`, you'll need to update this file to match.

Currently this file also includes `/etc/hostid` and `/etc/zfs/zpool.cache`
which means the generated ramdisk is specific to the host system which built
it.  If a generic initramfs is required, it may be preferable to omit these
files and specify the `spl_hostid` from the boot loader instead.

`parse-zfs.sh`
--------------

Run during the cmdline phase of the initramfs boot process, this script
performs some basic sanity checks on kernel command line parameters to
determine if booting from ZFS is likely to be what is desired.  Dracut
requires this script to adjust the `root` variable if required and to set
`rootok=1` if a mountable root filesystem is available.  Unfortunately this
script must run before udev is settled and kernel modules are known to be
loaded, so accessing the zpool and zfs commands is unsafe.

If the root=ZFS... parameter is set on the command line, then it's at least
certain that ZFS is what is desired, though this script is unable to
determine if ZFS is in fact available.  This script will alter the `root`
parameter to replace several historical forms of specifying the pool and
dataset name with the canonical form of `zfs:pool/dataset`.

If no root= parameter is set, the best this script can do is guess that
ZFS is desired.  At present, no other known filesystems will work with no
root= parameter, though this might possibly interfere with using the
compiled-in default root in the kernel image.  It's considered unlikely
that would ever be the case when an initramfs is in use, so this script
sets `root=zfs:AUTO` and hopes for the best.

Once the root=... (or lack thereof) parameter is parsed, a dummy symlink
is created from `/dev/root` -> `/dev/null` to satisfy parts of the Dracut
process which check for presence of a single root device node.

Finally, an initqueue/finished hook is registered which causes the initqueue
phase of Dracut to wait for `/dev/zfs` to become available before attempting
to mount anything.

`mount-zfs.sh`
--------------

This script is run after udev has settled and all tasks in the initqueue
have succeeded.  This ensures that `/dev/zfs` is available and that the
various ZFS modules are successfully loaded.  As it is now safe to call
zpool and friends, we can proceed to find the bootfs attribute if necessary.

If the root parameter was explicitly set on the command line, no parsing is
necessary.  The list of imported pools is checked to see if the desired pool
is already imported.  If it's not, and attempt is made to import the pool
explicitly, though no force is attempted.  Finally the specified dataset
is mounted on `$NEWROOT`, first using the `-o zfsutil` option to handle
non-legacy mounts, then if that fails, without zfsutil to handle legacy
mount points.

If no root parameter was specified, this script attempts to find a pool with
its bootfs attribute set.  First, already-imported pools are scanned and if
an appropriate pool is found, no additional pools are imported.  If no pool
with bootfs is found, any additional pools in the system are imported with
`zpool import -N -a`, and the scan for bootfs is tried again.  If no bootfs
is found with all pools imported, all pools are re-exported, and boot fails.
Assuming a bootfs is found, an attempt is made to mount it to `$NEWROOT`,
first with, then without the zfsutil option as above.

Ordinarily pools are imported _without_ the force option which may cause
boot to fail if the hostid has changed or a pool has been physically moved
between servers.  The `zfs_force` kernel parameter is provided which when
set to `1` causes `zpool import` to be run with the `-f` flag.  Forcing pool
import can lead to serious data corruption and loss of pools, so this option
should be used with extreme caution.  Note that even with this flag set, if
the required zpool was auto-imported by the kernel module, no additional
`zpool import` commands are run, so nothing is forced.

`export-zfs.sh`
---------------

Normally the zpool containing the root dataset cannot be exported on
shutdown as it is still in use by the init process. To work around this,
Dracut is able to restore the initramfs on shutdown and pivot to it.
All remaining process are then running from a ramdisk, allowing for a
clean unmount and export of the ZFS root. The theory of operation is
described in detail in the [Dracut manual](https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html#_dracut_on_shutdown).

This script will try to export all remaining zpools after Dracut has
pivoted to the initramfs. If an initial regular export is not successful,
Dracut will call this script once more with the `final` option,
in which case a forceful export is attempted.

Other Dracut modules include similar shutdown scripts and Dracut
invokes these scripts round-robin until they succeed. In particular,
the `90dm` module installs a script which tries to close and remove
all device mapper targets. Thus, if there are ZVOLs containing
dm-crypt volumes or if the zpool itself is backed by a dm-crypt
volume, the shutdown scripts will try to untangle this.
                                                                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/contrib/initramfs/                                                              0040755 0000000 0000000 00000000000 13077704276 015736  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/initramfs/Makefile.am                                                   0100644 0000000 0000000 00000001277 13045171016 017757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        initrddir = $(datarootdir)/initramfs-tools

initrd_SCRIPTS = conf-hooks.d/zfs hooks/zfs scripts/zfs

EXTRA_DIST = \
	$(top_srcdir)/contrib/initramfs/conf-hooks.d/zfs \
	$(top_srcdir)/contrib/initramfs/hooks/zfs \
	$(top_srcdir)/contrib/initramfs/scripts/zfs \
	$(top_srcdir)/contrib/initramfs/README.initramfs.markdown

install-initrdSCRIPTS: $(EXTRA_DIST)
	for d in conf-hooks.d hooks scripts; do \
	  $(MKDIR_P) $(DESTDIR)$(initrddir)/$$d; \
	  cp $(top_srcdir)/contrib/initramfs/$$d/zfs \
	    $(DESTDIR)$(initrddir)/$$d/; \
	done
	if [ -f etc/init.d/zfs ]; then \
	  $(MKDIR_P) $(DESTDIR)$(DEFAULT_INITCONF_DIR); \
	  cp $(top_srcdir)/etc/init.d/zfs \
	    $(DESTDIR)$(DEFAULT_INITCONF_DIR)/; \
	fi
                                                                                                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/contrib/initramfs/Makefile.in                                                   0100644 0000000 0000000 00000050721 13045370526 017775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = contrib/initramfs
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(initrddir)"
SCRIPTS = $(initrd_SCRIPTS)
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
initrddir = $(datarootdir)/initramfs-tools
initrd_SCRIPTS = conf-hooks.d/zfs hooks/zfs scripts/zfs
EXTRA_DIST = \
	$(top_srcdir)/contrib/initramfs/conf-hooks.d/zfs \
	$(top_srcdir)/contrib/initramfs/hooks/zfs \
	$(top_srcdir)/contrib/initramfs/scripts/zfs \
	$(top_srcdir)/contrib/initramfs/README.initramfs.markdown

all: all-am

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu contrib/initramfs/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu contrib/initramfs/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

uninstall-initrdSCRIPTS:
	@$(NORMAL_UNINSTALL)
	@list='$(initrd_SCRIPTS)'; test -n "$(initrddir)" || exit 0; \
	files=`for p in $$list; do echo "$$p"; done | \
	       sed -e 's,.*/,,;$(transform)'`; \
	dir='$(DESTDIR)$(initrddir)'; $(am__uninstall_files_from_dir)

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
tags TAGS:

ctags CTAGS:

cscope cscopelist:


distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(SCRIPTS)
installdirs:
	for dir in "$(DESTDIR)$(initrddir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-generic

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am: install-initrdSCRIPTS

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-initrdSCRIPTS

.MAKE: install-am install-strip

.PHONY: all all-am check check-am clean clean-generic clean-libtool \
	cscopelist-am ctags-am distclean distclean-generic \
	distclean-libtool distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am \
	install-initrdSCRIPTS install-man install-pdf install-pdf-am \
	install-ps install-ps-am install-strip installcheck \
	installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags-am uninstall \
	uninstall-am uninstall-initrdSCRIPTS


install-initrdSCRIPTS: $(EXTRA_DIST)
	for d in conf-hooks.d hooks scripts; do \
	  $(MKDIR_P) $(DESTDIR)$(initrddir)/$$d; \
	  cp $(top_srcdir)/contrib/initramfs/$$d/zfs \
	    $(DESTDIR)$(initrddir)/$$d/; \
	done
	if [ -f etc/init.d/zfs ]; then \
	  $(MKDIR_P) $(DESTDIR)$(DEFAULT_INITCONF_DIR); \
	  cp $(top_srcdir)/etc/init.d/zfs \
	    $(DESTDIR)$(DEFAULT_INITCONF_DIR)/; \
	fi

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                               usr/src/zfs-0.6.5.9/contrib/initramfs/README.initramfs.markdown                                     0100644 0000000 0000000 00000010734 13045171016 022415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        DESCRIPTION
  These scripts is intended to be used with initramfs-tools, which is a similar
  software product to "dracut" (which is more used in RedHat based distributions,
  and is mainly used by Debian GNU/Linux and derivates to create a initramfs so
  that the system can be booted of a ZFS filesystem. If you have no need or
  interest for this, then it can safely be ignored.

  These script were written with the primary intention of being portable and
  usable on as many systems as possible.

  This is, in practice, usually not possible. But the intention is there.
  And it is a good one.

  They have been tested successfully on:

    * Debian GNU/Linux Wheezy
    * Debian GNU/Linux Jessie

  It uses some functionality common with the SYSV init scripts, primarily
  the "/etc/zfs/zfs-functions" script.

FUNCTIONALITY
  * Supports booting of a ZFS snapshot.
    Do this by cloning the snapshot into a dataset. If this, the resulting
    dataset, already exists, destroy it. Then mount it as the root filesystem.
    * If snapshot does not exist, use base dataset (the part before '@')
      as boot filesystem instead.
    * Clone with 'mountpoint=none' and 'canmount=noauto' - we mount manually
      and explicitly.
    * Allow rollback of snapshots instead of clone it and boot from the clone.
    * If no snapshot is specified on the 'root=' kernel command line, but
      there is an '@', then get a list of snapshots below that filesystem
      and ask the user which to use.

  * Support all currently used kernel command line arguments
    * Core options:
      All the different distributions have their own standard on what to specify
      on the kernel command line to boot of a ZFS filesystem.

      Supports the following kernel command line argument combinations
      (in this order - first match win):
      * rpool=<pool>			(tries to finds bootfs automatically)
      * bootfs=<pool>/<dataset>		(uses this for rpool - first part)
      * rpool=<pool> bootfs=<pool>/<dataset>
      * -B zfs-bootfs=<pool>/<fs>	(uses this for rpool - first part)
      * rpool=rpool			(default if none of the above is used)
      * root=<pool>/<dataset>		(uses this for rpool - first part)
      * root=ZFS=<pool>/<dataset>	(uses this for rpool - first part, without 'ZFS=')
      * root=zfs:AUTO			(tries to detect both pool and rootfs
      * root=zfs:<pool>/<dataset>	(uses this for rpool - first part, without 'zfs:')

      Option <dataset> could also be <snapshot>
    * Extra (control) options:
      * zfsdebug=(on,yes,1)   Show extra debugging information
      * zfsforce=(on,yes,1)   Force import the pool
      * rollback=(on,yes,1)   Rollback (instead of clone) the snapshot

  * 'Smarter' way to import pools. Don't just try cache file or /dev.
    * Try to use /dev/disk/by-vdev (if /etc/zfs/vdev_id.conf exists),
    * Try /dev/mapper (to be able to use LUKS backed pools as well as
      multi-path devices).
    * /dev/disk/by-id and any other /dev/disk/by-* directory that may exist.
    * Use /dev as a last ditch attempt.
    * Fallback to using the cache file if that exist if nothing else worked.
    * Only try to import pool if it haven't already been imported
      * This will negate the need to force import a pool that have not been
        exported cleanly.
      * Support exclusion of pools to import by setting ZFS_POOL_EXCEPTIONS
         in /etc/default/zfs.

    Controlling in which order devices is searched for is controlled by
    ZPOOL_IMPORT_PATH variable set in /etc/defaults/zfs.

  * Support additional configuration variable ZFS_INITRD_ADDITIONAL_DATASETS
    to mount additional filesystems not located under your root dataset.

    For example, if the root fs is specified as 'rpool/ROOT/rootfs', it will
    automatically and without specific configuration mount any filesystems
    below this on the mount point specified in the 'mountpoint' property.
    Such as 'rpool/root/rootfs/var', 'rpool/root/rootfs/usr' etc)

    However, if one prefer to have separate filesystems, not located below
    the root fs (such as 'rpool/var', 'rpool/ROOT/opt' etc), special
    configuration needs to be done. This is what the variable, set in
    /etc/defaults/zfs file, needs to be configured. The 'mountpoint'
    property needs to be correct for this to work though.

  * Allows mounting a rootfs with mountpoint=legacy set.

  * Include /etc/modprobe.d/{zfs,spl}.conf in the initrd if it/they exist.

  * Include the udev rule to use by-vdev for pool imports.

  * Include the /etc/default/zfs file to the initrd.
                                    usr/src/zfs-0.6.5.9/contrib/initramfs/conf-hooks.d/                                                 0040755 0000000 0000000 00000000000 13077704276 020226  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/initramfs/conf-hooks.d/zfs                                              0100644 0000000 0000000 00000000075 13045171016 020733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Force the inclusion of Busybox in the initramfs.
BUSYBOX=y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/contrib/initramfs/hooks/                                                        0040755 0000000 0000000 00000000000 13077704276 017061  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/initramfs/hooks/zfs                                                     0100755 0000000 0000000 00000005051 13045171016 017570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh
#
# Add ZoL filesystem capabilities to an initrd, usually for a native ZFS root.
#

# This hook installs udev rules for ZoL.
PREREQ="zdev"

# These prerequisites are provided by the zfsutils package. The zdb utility is
# not strictly required, but it can be useful at the initramfs recovery prompt.
COPY_EXEC_LIST="/sbin/zdb /sbin/zpool /sbin/zfs /sbin/mount.zfs"
COPY_EXEC_LIST="$COPY_EXEC_LIST /usr/bin/dirname /lib/udev/vdev_id"
COPY_FILE_LIST="/etc/hostid /etc/zfs/zpool.cache /etc/default/zfs"
COPY_FILE_LIST="$COPY_FILE_LIST /etc/zfs/zfs-functions /etc/zfs/vdev_id.conf"
COPY_FILE_LIST="$COPY_FILE_LIST /lib/udev/rules.d/69-vdev.rules"

# These prerequisites are provided by the base system.
COPY_EXEC_LIST="$COPY_EXEC_LIST /bin/hostname /sbin/blkid"

# Explicitly specify all kernel modules because automatic dependency resolution
# is unreliable on many systems.
BASE_MODULES="zlib_deflate spl zavl zcommon znvpair zunicode zfs"
CRPT_MODULES="sun-ccm sun-gcm sun-ctr"
MANUAL_ADD_MODULES_LIST="$BASE_MODULES"

# Generic result code.
RC=0

case $1 in
prereqs)
	echo "$PREREQ"
	exit 0
	;;
esac

for ii in $COPY_EXEC_LIST
do
	if [ ! -x "$ii" ]
	then
		echo "Error: $ii is not executable."
		RC=2
	fi
done

if [ "$RC" -ne 0 ]
then
	exit "$RC"
fi

. /usr/share/initramfs-tools/hook-functions

mkdir -p "$DESTDIR/etc/"

# ZDB uses pthreads for some functions, but the library dependency is not
# automatically detected. The `find` utility and extended `cp` options are
# used here because libgcc_s.so could be in a subdirectory of /lib for
# multi-arch installations.
cp --target-directory="$DESTDIR" --parents $(find /lib -type f -name libgcc_s.so.1)

for ii in $COPY_EXEC_LIST
do
	copy_exec "$ii"
done

for ii in $COPY_FILE_LIST
do
	dir=$(dirname "$ii")
	[ -d "$dir" ] && mkdir -p "$DESTDIR/$dir"
	[ -f "$ii" ] && cp -p "$ii" "$DESTDIR/$ii"
done

for ii in $MANUAL_ADD_MODULES_LIST
do
	manual_add_modules "$ii"
done

if [ -f "/etc/hostname" ]
then
	cp -p "/etc/hostname" "$DESTDIR/etc/"
else
	hostname >"$DESTDIR/etc/hostname"
fi

for ii in zfs zfs.conf spl spl.conf
do  
	if [ -f "/etc/modprobe.d/$ii" ]; then
		if [ ! -d "$DESTDIR/etc/modprobe.d" ]; then
			mkdir -p $DESTDIR/etc/modprobe.d
		fi
		cp -p "/etc/modprobe.d/$ii" $DESTDIR/etc/modprobe.d/
	fi
done

# With pull request #1476 (not yet merged) comes a verbose warning
# if /usr/bin/net doesn't exist or isn't executable. Just create
# a dummy...
[ ! -d "$DESTDIR/usr/bin" ] && mkdir -p "$DESTDIR/usr/bin"
if [ ! -x "$DESTDIR/usr/bin/net" ]; then
    touch "$DESTDIR/usr/bin/net"
    chmod +x "$DESTDIR/usr/bin/net"
fi

exit 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/src/zfs-0.6.5.9/contrib/initramfs/scripts/                                                      0040755 0000000 0000000 00000000000 13077704276 017425  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/contrib/initramfs/scripts/zfs                                                   0100644 0000000 0000000 00000062333 13045171016 020137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # ZFS boot stub for initramfs-tools.
#
# In the initramfs environment, the /init script sources this stub to
# override the default functions in the /scripts/local script.
#
# Enable this by passing boot=zfs on the kernel command line.
#

# Source the common init script
. /etc/zfs/zfs-functions

# Paths to what we need - in the initrd, these paths are hardcoded,
# so override the defines in zfs-functions.
ZFS="/sbin/zfs"
ZPOOL="/sbin/zpool"
ZPOOL_CACHE="/etc/zfs/zpool.cache"
export ZFS ZPOOL ZPOOL_CACHE

# This runs any scripts that should run before we start importing
# pools and mounting any filesystems.
pre_mountroot()
{
	if type run_scripts > /dev/null 2>&1 && \
	    [ -f "/scripts/local-top" -o -d "/scripts/local-top" ]
	then
		[ "$quiet" != "y" ] && \
		    zfs_log_begin_msg "Running /scripts/local-top"
		run_scripts /scripts/local-top
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	if type run_scripts > /dev/null 2>&1 && \
	    [ -f "/scripts/local-premount" -o -d "/scripts/local-premount" ]
	then
		[ "$quiet" != "y" ] && \
		    zfs_log_begin_msg "Running /scripts/local-premount"
		run_scripts /scripts/local-premount
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi
}

# If plymouth is availible, hide the splash image.
disable_plymouth()
{
	if [ -x /bin/plymouth ] && /bin/plymouth --ping
	then
		/bin/plymouth hide-splash >/dev/null 2>&1
	fi
}

# Get a ZFS filesystem property value.
get_fs_value()
{
	local fs="$1"
	local value=$2

	"${ZFS}" get -H -ovalue $value "$fs" 2> /dev/null
}

# Find the 'bootfs' property on pool $1.
# If the property does not contain '/', then ignore this
# pool by exporting it again.
find_rootfs()
{
	local pool="$1"

	# If 'POOL_IMPORTED' isn't set, no pool imported and therefor
	# we won't be able to find a root fs.
	[ -z "${POOL_IMPORTED}" ] && return 1

	# If it's already specified, just keep it mounted and exit
	# User (kernel command line) must be correct.
	[ -n "${ZFS_BOOTFS}" ] && return 0

	# Not set, try to find it in the 'bootfs' property of the pool.
	# NOTE: zpool does not support 'get -H -ovalue bootfs'...
	ZFS_BOOTFS=$("${ZPOOL}" list -H -obootfs "$pool")

	# Make sure it's not '-' and that it starts with /.
	if [ "${ZFS_BOOTFS}" != "-" ] && \
		$(get_fs_value "${ZFS_BOOTFS}" mountpoint | grep -q '^/$')
	then
		# Keep it mounted
		POOL_IMPORTED=1
		return 0
	fi

	# Not boot fs here, export it and later try again..
	"${ZPOOL}" export "$pool"
	POOL_IMPORTED=""

	return 1
}

# Support function to get a list of all pools, separated with ';'
find_pools()
{
	local CMD="$*"
	local pools pool

	pools=$($CMD 2> /dev/null | \
		grep -E "pool:|^[a-zA-Z0-9]" | \
		sed 's@.*: @@' | \
		while read pool; do \
		    echo -n "$pool;"
		done)

	echo "${pools%%;}" # Return without the last ';'.
}

# Get a list of all availible pools
get_pools()
{
	local available_pools npools

	if [ -n "${ZFS_POOL_IMPORT}" ]; then
		echo "$ZFS_POOL_IMPORT"
		return 0
	fi

	# Get the base list of availible pools.
	available_pools=$(find_pools "$ZPOOL" import)

	# Just in case - seen it happen (that a pool isn't visable/found
	# with a simple "zpool import" but only when using the "-d"
	# option or setting ZPOOL_IMPORT_PATH).
	if [ -d "/dev/disk/by-id" ]
	then
		npools=$(find_pools "$ZPOOL" import -d /dev/disk/by-id)
		if [ -n "$npools" ]
		then
			# Because we have found extra pool(s) here, which wasn't
			# found 'normaly', we need to force USE_DISK_BY_ID to
			# make sure we're able to actually import it/them later.
			USE_DISK_BY_ID='yes'

			if [ -n "$available_pools" ]
			then
				# Filter out duplicates (pools found with the simple
				# "zpool import" but which is also found with the
				# "zpool import -d ...").
				npools=$(echo "$npools" | sed "s,$available_pools,,")

				# Add the list to the existing list of
				# available pools
				available_pools="$available_pools;$npools"
			else
				available_pools="$npools"
			fi
		fi
	fi

        # Filter out any exceptions...
	if [ -n "$ZFS_POOL_EXCEPTIONS" ]
	then
		local found=""
		local apools=""
		local pool exception
		OLD_IFS="$IFS" ; IFS=";"

		for pool in $available_pools
		do
			for exception in $ZFS_POOL_EXCEPTIONS
			do
				[ "$pool" = "$exception" ] && continue 2
				found="$pool"
			done

			if [ -n "$found" ]
			then
				if [ -n "$apools" ]
				then
					apools="$apools;$pool"
				else
					apools="$pool"
				fi
			fi
		done

		IFS="$OLD_IFS"
		available_pools="$apools"
	fi

	# Return list of availible pools.
	echo "$available_pools"
}

# Import given pool $1
import_pool()
{
	local pool="$1"
	local dirs dir

	# Verify that the pool isn't already imported
	# Make as sure as we can to not require '-f' to import.
	"${ZPOOL}" status "$pool" > /dev/null 2>&1 && return 0

	# For backwards compability, make sure that ZPOOL_IMPORT_PATH is set
	# to something we can use later with the real import(s). We want to
	# make sure we find all by* dirs, BUT by-vdev should be first (if it
	# exists).
	if [ -n "$USE_DISK_BY_ID" -a -z "$ZPOOL_IMPORT_PATH" ]
	then
		dirs="$(for dir in $(echo /dev/disk/by-*)
		do
			# Ignore by-vdev here - we want it first!
			echo "$dir" | grep -q /by-vdev && continue
			[ ! -d "$dir" ] && continue

			echo -n "$dir:"
		done | sed 's,:$,,g')"

		if [ -d "/dev/disk/by-vdev" ]
		then
			# Add by-vdev at the beginning.
			ZPOOL_IMPORT_PATH="/dev/disk/by-vdev:"
		fi

		# ... and /dev at the very end, just for good measure.
		ZPOOL_IMPORT_PATH="$ZPOOL_IMPORT_PATH$dirs:/dev"
	fi

	# Needs to be exported for "zpool" to catch it.
	[ -n "$ZPOOL_IMPORT_PATH" ] && export ZPOOL_IMPORT_PATH


	[ "$quiet" != "y" ] && zfs_log_begin_msg \
		"Importing pool '${pool}' using defaults"

	ZFS_CMD="${ZPOOL} import -N ${ZPOOL_FORCE} ${ZPOOL_IMPORT_OPTS}"
	ZFS_STDERR="$($ZFS_CMD "$pool" 2>&1)"
	ZFS_ERROR="$?"
	if [ "${ZFS_ERROR}" != 0 ]
	then
		[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

		if [ -f "${ZPOOL_CACHE}" ]
		then
			[ "$quiet" != "y" ] && zfs_log_begin_msg \
				"Importing pool '${pool}' using cachefile."

			ZFS_CMD="${ZPOOL} import -c ${ZPOOL_CACHE} -N ${ZPOOL_FORCE} ${ZPOOL_IMPORT_OPTS}"
			ZFS_STDERR="$($ZFS_CMD "$pool" 2>&1)"
			ZFS_ERROR="$?"
		fi

		if [ "${ZFS_ERROR}" != 0 ]
		then
			[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

			disable_plymouth
			echo ""
			echo "Command: ${ZFS_CMD} '$pool'"
			echo "Message: $ZFS_STDERR"
			echo "Error: $ZFS_ERROR"
			echo ""
			echo "Failed to import pool '$pool'."
			echo "Manually import the pool and exit."
			/bin/sh
		fi
	fi

	[ "$quiet" != "y" ] && zfs_log_end_msg

	POOL_IMPORTED=1
	return 0
}

# Load ZFS modules
# Loading a module in a initrd require a slightly different approach,
# with more logging etc.
load_module_initrd()
{
	if [ "$ZFS_INITRD_PRE_MOUNTROOT_SLEEP" > 0 ]
	then
		if [ "$quiet" != "y" ]; then
			zfs_log_begin_msg "Sleeping for" \
				"$ZFS_INITRD_PRE_MOUNTROOT_SLEEP seconds..."
		fi
		sleep "$ZFS_INITRD_PRE_MOUNTROOT_SLEEP"
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	# Wait for all of the /dev/{hd,sd}[a-z] device nodes to appear.
	if type wait_for_udev > /dev/null 2>&1 ; then
		wait_for_udev 10
	elif type wait_for_dev > /dev/null 2>&1 ; then
		wait_for_dev
	fi

	# zpool import refuse to import without a valid mtab
	[ ! -f /proc/mounts ] && mount proc /proc
	[ ! -f /etc/mtab ] && cat /proc/mounts > /etc/mtab

	# Load the module
	load_module "zfs" || return 1

	if [ "$ZFS_INITRD_POST_MODPROBE_SLEEP" > 0 ]
	then
		if [ "$quiet" != "y" ]; then
			zfs_log_begin_msg "Sleeping for" \
				"$ZFS_INITRD_POST_MODPROBE_SLEEP seconds..."
		fi
		sleep "$ZFS_INITRD_POST_MODPROBE_SLEEP"
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	return 0
}

# Mount a given filesystem
mount_fs()
{
	local fs="$1"
	local mountpoint

	# Check that the filesystem exists
	"${ZFS}" list -oname -tfilesystem -H "${fs}" > /dev/null 2>&1
	[ "$?" -ne 0 ] && return 1

	# Need the _original_ datasets mountpoint!
	mountpoint=$(get_fs_value "$fs" mountpoint)
	if [ "$mountpoint" = "legacy" -o "$mountpoint" = "none" ]; then
		# Can't use the mountpoint property. Might be one of our
		# clones. Check the 'org.zol:mountpoint' property set in
		# clone_snap() if that's usable.
		mountpoint=$(get_fs_value "$fs" org.zol:mountpoint)
		if [ "$mountpoint" = "legacy" -o \
		    "$mountpoint" = "none" -o \
		    "$mountpoint" = "-" ]
		then
			if [ "$fs" != "${ZFS_BOOTFS}" ]; then
				# We don't have a proper mountpoint, this
				# isn't the root fs. So extract the root fs
				# value from the filesystem, and we should
				# (hopefully!) have a mountpoint we can use.
				mountpoint="${fs##$ZFS_BOOTFS}"
			else
				# Last hail-mary: Hope 'rootmnt' is set!
				mountpoint=""
			fi
		fi

		if [ "$mountpoint" = "legacy" ]; then
			ZFS_CMD="mount -t zfs"
		else
			# If it's not a legacy filesystem, it can only be a
			# native one...
			ZFS_CMD="mount -o zfsutil -t zfs"
		fi
	else
		ZFS_CMD="mount -o zfsutil -t zfs"
	fi

	# Possibly decrypt a filesystem using native encryption.
	decrypt_fs "$fs"

	[ "$quiet" != "y" ] && \
	    zfs_log_begin_msg "Mounting '${fs}' on '${rootmnt}/${mountpoint}'"
	[ -n "${ZFS_DEBUG}" ] && \
	    zfs_log_begin_msg "CMD: '$ZFS_CMD ${fs} ${rootmnt}/${mountpoint}'"

	ZFS_STDERR=$(${ZFS_CMD} "${fs}" "${rootmnt}/${mountpoint}" 2>&1)
	ZFS_ERROR=$?
	if [ "${ZFS_ERROR}" != 0 ]
	then
		[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

		disable_plymouth
		echo ""
		echo "Command: ${ZFS_CMD} ${fs} ${rootmnt}/${mountpoint}"
		echo "Message: $ZFS_STDERR"
		echo "Error: $ZFS_ERROR"
		echo ""
		echo "Failed to mount ${fs} on ${rootmnt}/${mountpoint}."
		echo "Manually mount the filesystem and exit."
		/bin/sh
	else
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	return 0
}

# Unlock a ZFS native crypted filesystem.
decrypt_fs()
{
	local fs="$1"

	# If the 'zfs key' command isn't availible, exit right here.
	"${ZFS}" 2>&1 | grep -q 'key -l ' || return 0

	# Check if filesystem is encrypted. If not, exit right here.
	[ "$(get_fs_value "$fs" encryption)" != "off" ] || return 0

	[ "$quiet" != "y" ] && \
	    zfs_log_begin_msg "Loading crypto wrapper key for $fs"

	# Just make sure that ALL crypto modules module is loaded.
	# Simplest just to load all...
	for mod in sun-ccm sun-gcm sun-ctr
	do
		[ "$quiet" != "y" ] && zfs_log_progress_msg "${mod} "

		ZFS_CMD="load_module $mod"
		ZFS_STDERR="$(${ZFS_CMD} 2>&1)"
		ZFS_ERROR="$?"

		if [ "${ZFS_ERROR}" != 0 ]
		then
			[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

			disable_plymouth
			echo ""
			echo "Command: $ZFS_CMD"
			echo "Message: $ZFS_STDERR"
			echo "Error: $ZFS_ERROR"
			echo ""
			echo "Failed to load $mod module."
			echo "Please verify that it is availible on the initrd image"
			echo "(without it it won't be possible to unlock the filesystem)"
			echo "and rerun:  $ZFS_CMD"
			/bin/sh
		else
			[ "$quiet" != "y" ] && zfs_log_end_msg
		fi
	done

	# If the key isn't availible, then this will fail!
	ZFS_CMD="${ZFS} key -l -r $fs"
	ZFS_STDERR="$(${ZFS_CMD} 2>&1)"
	ZFS_ERROR="$?"

	if [ "${ZFS_ERROR}" != 0 ]
	then
		[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

		disable_plymouth
		echo ""
		echo "Command: $ZFS_CMD"
		echo "Message: $ZFS_STDERR"
		echo "Error: $ZFS_ERROR"
		echo ""
		echo "Failed to load zfs encryption wrapper key (s)."
		echo "Please verify dataset property 'keysource' for datasets"
		echo "and rerun:  $ZFS_CMD"
		/bin/sh
	else
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	return 0
}

# Destroy a given filesystem.
destroy_fs()
{
	local fs="$1"

	[ "$quiet" != "y" ] && \
	    zfs_log_begin_msg "Destroying '$fs'"

	ZFS_CMD="${ZFS} destroy $fs"
	ZFS_STDERR="$(${ZFS_CMD} 2>&1)"
	ZFS_ERROR="$?"
	if [ "${ZFS_ERROR}" != 0 ]
	then
		[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

		disable_plymouth
		echo ""
		echo "Command: $ZFS_CMD"
		echo "Message: $ZFS_STDERR"
		echo "Error: $ZFS_ERROR"
		echo ""
		echo "Failed to destroy '$fs'. Please make sure that '$fs' is not availible."
		echo "Hint: Try:  zfs destroy -Rfn $fs"
		echo "If this dryrun looks good, then remove the 'n' from '-Rfn' and try again."
		/bin/sh
	else
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	return 0
}

# Clone snapshot $1 to destination filesystem $2
# Set 'canmount=noauto' and 'mountpoint=none' so that we get to keep
# manual controll over it's mounting (i.e., make sure it's not automatically
# mounted with a 'zfs mount -a' in the init/systemd scripts).
clone_snap()
{
	local snap="$1"
	local destfs="$2"
	local mountpoint="$3"

	[ "$quiet" != "y" ] && zfs_log_begin_msg "Cloning '$snap' to '$destfs'"

	# Clone the snapshot into a dataset we can boot from
	# + We don't want this filesystem to be automatically mounted, we
	#   want controll over this here and nowhere else.
	# + We don't need any mountpoint set for the same reason.
	# We use the 'org.zol:mountpoint' property to remember the mountpoint.
	ZFS_CMD="${ZFS} clone -o canmount=noauto -o mountpoint=none"
	ZFS_CMD="${ZFS_CMD} -o org.zol:mountpoint=${mountpoint}"
	ZFS_CMD="${ZFS_CMD} $snap $destfs"
	ZFS_STDERR="$(${ZFS_CMD} 2>&1)"
	ZFS_ERROR="$?"
	if [ "${ZFS_ERROR}" != 0 ]
	then
		[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

		disable_plymouth
		echo ""
		echo "Command: $ZFS_CMD"
		echo "Message: $ZFS_STDERR"
		echo "Error: $ZFS_ERROR"
		echo ""
		echo "Failed to clone snapshot."
		echo "Make sure that the any problems are corrected and then make sure"
		echo "that the dataset '$destfs' exists and is bootable."
		/bin/sh
	else
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	return 0
}

# Rollback a given snapshot.
rollback_snap()
{
	local snap="$1"

	[ "$quiet" != "y" ] && zfs_log_begin_msg "Rollback $snap"

	ZFS_CMD="${ZFS} rollback -Rf $snap"
	ZFS_STDERR="$(${ZFS_CMD} 2>&1)"
	ZFS_ERROR="$?"
	if [ "${ZFS_ERROR}" != 0 ]
	then
		[ "$quiet" != "y" ] && zfs_log_failure_msg "${ZFS_ERROR}"

		disable_plymouth
		echo ""
		echo "Command: $ZFS_CMD"
		echo "Message: $ZFS_STDERR"
		echo "Error: $ZFS_ERROR"
		echo ""
		echo "Failed to rollback snapshot."
		/bin/sh
	else
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	return 0
}

# Get a list of snapshots, give them as a numbered list
# to the user to choose from.
ask_user_snap()
{
	local fs="$1"
	local i=1
	local SNAP snapnr snap debug

	# We need to temporarily disable debugging. Set 'debug' so we
	# remember to enabled it again.
	if [ -n "${ZFS_DEBUG}" ]; then
		unset ZFS_DEBUG
		set +x
		debug=1
	fi

	# Because we need the resulting snapshot, which is sent on
	# stdout to the caller, we use stderr for our questions.
	echo "What snapshot do you want to boot from?" > /dev/stderr
	while read snap; do
	    echo "  $i: ${snap}" > /dev/stderr
	    eval `echo SNAP_$i=$snap`
	    i=$((i + 1))
	done <<EOT
$("${ZFS}" list -H -oname -tsnapshot "${fs}")
EOT

	echo -n "  Snap nr [0-$((i-1))]? " > /dev/stderr
	read snapnr

	# Reenable debugging.
	if [ -n "${debug}" ]; then
		ZFS_DEBUG=1
		set -x
	fi

	echo "$(eval echo "$"SNAP_$snapnr)"
}

setup_snapshot_booting()
{
	local snap="$1"
	local s destfs subfs mountpoint retval=0 filesystems fs

	# Make sure that the snapshot specified actually exist.
	if [ ! $(get_fs_value "${snap}" type) ]
	then
		# Snapshot does not exist (...@<null> ?)
		# ask the user for a snapshot to use.
		snap="$(ask_user_snap "${snap%%@*}")"
	fi

	# Separate the full snapshot ('$snap') into it's filesystem and
	# snapshot names. Would have been nice with a split() function..
	rootfs="${snap%%@*}"
	snapname="${snap##*@}"	
	ZFS_BOOTFS="${rootfs}_${snapname}"

	if ! grep -qiE '(^|[^\\](\\\\)* )(rollback)=(on|yes|1)( |$)' /proc/cmdline
	then
		# If the destination dataset for the clone
		# already exists, destroy it. Recursivly
		if [ $(get_fs_value "${rootfs}_${snapname}" type) ]; then
			filesystems=$("${ZFS}" list -oname -tfilesystem -H \
			    -r -Sname "${ZFS_BOOTFS}")
			for fs in $filesystems; do
				destroy_fs "${fs}"
			done
		fi
	fi

	# Get all snapshots, recursivly (might need to clone /usr, /var etc
	# as well).
	for s in $("${ZFS}" list -H -oname -tsnapshot -r "${rootfs}" | \
	    grep "${snapname}")
	do
		if grep -qiE '(^|[^\\](\\\\)* )(rollback)=(on|yes|1)( |$)' /proc/cmdline
		then
			# Rollback snapshot
			rollback_snap "$s" || retval=$((retval + 1))
		else
			# Setup a destination filesystem name.
			# Ex: Called with 'rpool/ROOT/debian@snap2'
			#       rpool/ROOT/debian@snap2		=> rpool/ROOT/debian_snap2
			#       rpool/ROOT/debian/boot@snap2	=> rpool/ROOT/debian_snap2/boot
			#       rpool/ROOT/debian/usr@snap2	=> rpool/ROOT/debian_snap2/usr
			#       rpool/ROOT/debian/var@snap2	=> rpool/ROOT/debian_snap2/var
			subfs="${s##$rootfs}"
			subfs="${subfs%%@$snapname}"

			destfs="${rootfs}_${snapname}" # base fs.
			[ -n "$subfs" ] && destfs="${destfs}$subfs" # + sub fs.

			# Get the mountpoint of the filesystem, to be used
			# with clone_snap(). If legacy or none, then use
			# the sub fs value.
			mountpoint=$(get_fs_value "${s%%@*}" mountpoint)
			if [ "$mountpoint" = "legacy" -o \
			    "$mountpoint" = "none" ]
			then
				if [ -n "${subfs}" ]; then
					mountpoint="${subfs}"
				else
					mountpoint="/"
				fi
			fi

			# Clone the snapshot into its own
			# filesystem
			clone_snap "$s" "${destfs}" "${mountpoint}" || \
			    retval=$((retval + 1))
		fi
	done

	# If we haven't return yet, we have a problem...
	return "${retval}"
}

# ================================================================

# This is the main function.
mountroot()
{
	local snaporig snapsub destfs pool POOLS

	# ----------------------------------------------------------------
	# I N I T I A L   S E T U P

	# ------------
	# Run the pre-mount scripts from /scripts/local-top.
	pre_mountroot

	# ------------
	# Source the default setup variables.
	[ -r '/etc/default/zfs' ] && . /etc/default/zfs

	# ------------
	# Support debug option
	if grep -qiE '(^|[^\\](\\\\)* )(zfs_debug|zfs\.debug|zfsdebug)=(on|yes|1)( |$)' /proc/cmdline
	then
		ZFS_DEBUG=1
		mkdir /var/log
		#exec 2> /var/log/boot.debug
		set -x
	fi

	# ------------
	# Load ZFS module etc.
	if ! load_module_initrd; then
		disable_plymouth
		echo ""
		echo "Failed to load ZFS modules."
		echo "Manually load the modules and exit."
		/bin/sh
	fi

	# ------------
	# Look for the cache file (if any).
	[ ! -f ${ZPOOL_CACHE} ] && unset ZPOOL_CACHE

	# ------------
	# Compatibility: 'ROOT' is for Debian GNU/Linux (etc),
	#		 'root' is for Redhat/Fedora (etc),
	#		 'REAL_ROOT' is for Gentoo
	if [ -z "$ROOT" ]
	then
		[ -n "$root" ] && ROOT=${root}

		[ -n "$REAL_ROOT" ] && ROOT=${REAL_ROOT}
	fi

	# ------------
	# Where to mount the root fs in the initrd - set outside this script
	# Compatibility: 'rootmnt' is for Debian GNU/Linux (etc),
	#		 'NEWROOT' is for RedHat/Fedora (etc),
	#		 'NEW_ROOT' is for Gentoo
	if [ -z "$rootmnt" ]
	then
		[ -n "$NEWROOT" ] && rootmnt=${NEWROOT}

		[ -n "$NEW_ROOT" ] && rootmnt=${NEW_ROOT}
	fi

	# ------------
	# No longer set in the defaults file, but it could have been set in
	# get_pools() in some circumstances. If it's something, but not 'yes',
	# it's no good to us.
	[ -n "$USE_DISK_BY_ID" -a "$USE_DISK_BY_ID" != 'yes' ] && \
	    unset USE_DISK_BY_ID

	# ----------------------------------------------------------------
	# P A R S E   C O M M A N D   L I N E   O P T I O N S

	# This part is the really ugly part - there's so many options and permutations
	# 'out there', and if we should make this the 'primary' source for ZFS initrd
	# scripting, we need/should support them all.
	#
	# Supports the following kernel command line argument combinations
	# (in this order - first match win):
	#
	#	rpool=<pool>			(tries to finds bootfs automatically)
	#	bootfs=<pool>/<dataset>		(uses this for rpool - first part)
	#	rpool=<pool> bootfs=<pool>/<dataset>
	#	-B zfs-bootfs=<pool>/<fs>	(uses this for rpool - first part)
	#	rpool=rpool			(default if none of the above is used)
	#	root=<pool>/<dataset>		(uses this for rpool - first part)
	#	root=ZFS=<pool>/<dataset>	(uses this for rpool - first part, without 'ZFS=')
	#	root=zfs:AUTO			(tries to detect both pool and rootfs
	#	root=zfs:<pool>/<dataset>	(uses this for rpool - first part, without 'zfs:')
	#
	# Option <dataset> could also be <snapshot>

	# ------------
	# Support force option
	# In addition, setting one of zfs_force, zfs.force or zfsforce to
	# 'yes', 'on' or '1' will make sure we force import the pool.
	# This should (almost) never be needed, but it's here for
	# completeness.
	ZPOOL_FORCE=""
	if grep -qiE '(^|[^\\](\\\\)* )(zfs_force|zfs\.force|zfsforce)=(on|yes|1)( |$)' /proc/cmdline
	then
		ZPOOL_FORCE="-f"
	fi

	# ------------
	# Look for 'rpool' and 'bootfs' parameter
	[ -n "$rpool" ] && ZFS_RPOOL="${rpool#rpool=}"
	[ -n "$bootfs" ] && ZFS_BOOTFS="${bootfs#bootfs=}"

	# ------------
	# If we have 'ROOT' (see above), but not 'ZFS_BOOTFS', then use
	# 'ROOT'
	[ -n "$ROOT" -a -z "${ZFS_BOOTFS}" ] && ZFS_BOOTFS="$ROOT"

	# ------------
	# Check for the `-B zfs-bootfs=%s/%u,...` kind of parameter.
	# NOTE: Only use the pool name and dataset. The rest is not
	#       supported by ZoL (whatever it's for).
	if [ -z "$ZFS_RPOOL" ]
	then
		# The ${zfs-bootfs} variable is set at the kernel commmand
		# line, usually by GRUB, but it cannot be referenced here
		# directly because bourne variable names cannot contain a
		# hyphen.
		#
		# Reassign the variable by dumping the environment and
		# stripping the zfs-bootfs= prefix.  Let the shell handle
		# quoting through the eval command.
		eval ZFS_RPOOL=$(set | sed -n -e 's,^zfs-bootfs=,,p')
	fi

	# ------------
	# No root fs or pool specified - do auto detect.
	if [ -z "$ZFS_RPOOL" -a -z "${ZFS_BOOTFS}" ]
	then
		# Do auto detect. Do this by 'cheating' - set 'root=zfs:AUTO'
		# which will be caught later
		ROOT=zfs:AUTO
	fi

	# ----------------------------------------------------------------
	# F I N D   A N D   I M P O R T   C O R R E C T   P O O L

	# ------------
	if [ "$ROOT" = "zfs:AUTO" ]
	then
		# Try to detect both pool and root fs.

		[ "$quiet" != "y" ] && \
		    zfs_log_begin_msg "Attempting to import additional pools."

		# Get a list of pools available for import
		if [ -n "$ZFS_RPOOL" ]
		then
			# We've specified a pool - check only that
			POOLS=$ZFS_RPOOL
		else
			POOLS=$(get_pools)
		fi

		OLD_IFS="$IFS" ; IFS=";"
		for pool in $POOLS
		do
			[ -z "$pool" ] && continue

			import_pool "$pool"
			find_rootfs "$pool"
		done
		IFS="$OLD_IFS"

		[ "$quiet" != "y" ] && zfs_log_end_msg $ZFS_ERROR
	else
		# No auto - use value from the command line option.

		# Strip 'zfs:' and 'ZFS='.
		ZFS_BOOTFS="${ROOT#*[:=]}"

		# Stip everything after the first slash.
		ZFS_RPOOL="${ZFS_BOOTFS%%/*}"
	fi

	# Import the pool (if not already done so in the AUTO check above).
	if [ -n "$ZFS_RPOOL" -a -z "${POOL_IMPORTED}" ]
	then
		[ "$quiet" != "y" ] && \
		    zfs_log_begin_msg "Importing ZFS root pool '$ZFS_RPOOL'"

		import_pool "${ZFS_RPOOL}"
		find_rootfs "${ZFS_RPOOL}"

		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi

	if [ -z "${POOL_IMPORTED}" ]
	then
		# No pool imported, this is serious!
		disable_plymouth
		echo ""
		echo "Command: $ZFS_CMD"
		echo "Message: $ZFS_STDERR"
		echo "Error: $ZFS_ERROR"
		echo ""
		echo "No pool imported. Manually import the root pool"
		echo "at the command prompt and then exit."
		echo "Hint: Try:  zpool import -R ${rootmnt} -N ${ZFS_RPOOL}"
		/bin/sh
	fi

	# ----------------------------------------------------------------
	# P R E P A R E   R O O T   F I L E S Y S T E M

	if [ -n "${ZFS_BOOTFS}" ]
	then
		# Booting from a snapshot?
		# Will overwrite the ZFS_BOOTFS variable like so:
		#   rpool/ROOT/debian@snap2 => rpool/ROOT/debian_snap2
		echo "${ZFS_BOOTFS}" | grep -q '@' && \
		    setup_snapshot_booting "${ZFS_BOOTFS}"
	fi

	if [ -z "${ZFS_BOOTFS}" ]
	then
		# Still nothing! Let the user sort this out.
		disable_plymouth
		echo ""
		echo "Error: Unknown root filesystem - no 'bootfs' pool property and"
		echo "       not specified on the kernel command line."
		echo ""
		echo "Manually mount the root filesystem on $rootmnt and then exit."
		echo "Hint: Try:  mount -o zfsutil -t zfs ${ZFS_RPOOL-rpool}/ROOT/system $rootmnt"
		/bin/sh
	fi

	# ----------------------------------------------------------------
	# M O U N T   F I L E S Y S T E M S

	# * Ideally, the root filesystem would be mounted like this:
	#
	#     zpool import -R "$rootmnt" -N "$ZFS_RPOOL"
	#     zfs mount -o mountpoint=/ "${ZFS_BOOTFS}"
	#
	#   but the MOUNTPOINT prefix is preserved on descendent filesystem
	#   after the pivot into the regular root, which later breaks things
	#   like `zfs mount -a` and the /etc/mtab refresh.
	#
	# * Mount additional filesystems required
	#   Such as /usr, /var, /usr/local etc.
	#   NOTE: Mounted in the order specified in the
	#         ZFS_INITRD_ADDITIONAL_DATASETS variable so take care!

	# Go through the complete list (recursivly) of all filesystems below
	# the real root dataset
	filesystems=$("${ZFS}" list -oname -tfilesystem -H -r "${ZFS_BOOTFS}")
	for fs in $filesystems $ZFS_INITRD_ADDITIONAL_DATASETS
	do
		mount_fs "$fs"
	done

	# ------------
	# Debugging information
	if [ -n "${ZFS_DEBUG}" ]
	then
		#exec 2>&1-

		echo "DEBUG: imported pools:"
		"${ZPOOL}" list -H
		echo

		echo "DEBUG: mounted ZFS filesystems:"
		mount | grep zfs
		echo

		echo "=> waiting for ENTER before continuing because of 'zfsdebug=1'. "
		echo -n "   'c' for shell, 'r' for reboot, 'ENTER' to continue. "
		read b

		[ "$b" = "c" ] && /bin/sh
		[ "$b" = "r" ] && reboot -f

		set +x
	fi

	# ------------
	# Run local bottom script
	if type run_scripts > /dev/null 2>&1 && \
	    [ -f "/scripts/local-bottom" -o -d "/scripts/local-bottom" ]
	then
		[ "$quiet" != "y" ] && \
		    zfs_log_begin_msg "Running /scripts/local-bottom"
		run_scripts /scripts/local-bottom
		[ "$quiet" != "y" ] && zfs_log_end_msg
	fi
}
                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/copy-builtin                                                                    0100755 0000000 0000000 00000005113 13045171016 014624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/bash

set -e

usage()
{
	echo "usage: $0 <kernel source tree>" >&2
	exit 1
}

[ "$#" -eq 1 ] || usage
KERNEL_DIR="$(readlink --canonicalize-existing "$1")"

MODULES=()
for MODULE_DIR in module/*
do
	[ -d "$MODULE_DIR" ] || continue
	MODULES+=("${MODULE_DIR##*/}")
done

if ! [ -e 'zfs_config.h' ]
then
	echo >&2
	echo "    $0: you did not run configure, or you're not in the ZFS source directory." >&2
	echo "    $0: run configure with --with-linux=$KERNEL_DIR and --enable-linux-builtin." >&2
	echo >&2
	exit 1
fi

make clean || true

rm -rf "$KERNEL_DIR/include/zfs" "$KERNEL_DIR/fs/zfs"
cp --recursive include "$KERNEL_DIR/include/zfs"
cp --recursive module "$KERNEL_DIR/fs/zfs"
cp zfs_config.h "$KERNEL_DIR/"

adjust_obj_paths()
{
	local FILE="$1"
	local LINE OBJPATH

	while IFS='' read -r LINE
	do
		OBJPATH="${LINE#\$(MODULE)-objs += }"
		if [ "$OBJPATH" = "$LINE" ]
		then
			echo "$LINE"
		else
			echo "\$(MODULE)-objs += ${OBJPATH##*/}"
		fi
	done < "$FILE" > "$FILE.new"
	mv "$FILE.new" "$FILE"
}

for MODULE in "${MODULES[@]}"
do
	adjust_obj_paths "$KERNEL_DIR/fs/zfs/$MODULE/Makefile"
	sed -i.bak '/obj =/d' "$KERNEL_DIR/fs/zfs/$MODULE/Makefile"
	sed -i.bak '/src =/d' "$KERNEL_DIR/fs/zfs/$MODULE/Makefile"
done

cat > "$KERNEL_DIR/fs/zfs/Kconfig" <<"EOF"
config ZFS
	tristate "ZFS filesystem support"
	depends on SPL
	depends on EFI_PARTITION
	select ZLIB_INFLATE
	select ZLIB_DEFLATE
	help
	  This is the ZFS filesystem from the ZFS On Linux project.

	  See http://zfsonlinux.org/

	  To compile this file system support as a module, choose M here.

	  If unsure, say N.
EOF

{
	cat <<-"EOF"
	ZFS_MODULE_CFLAGS  = -I$(srctree)/include/zfs -I$(srctree)/include/spl 
	ZFS_MODULE_CFLAGS += -include $(srctree)/spl_config.h -include $(srctree)/zfs_config.h
	export ZFS_MODULE_CFLAGS

	obj-$(CONFIG_ZFS) :=
	EOF

	for MODULE in "${MODULES[@]}"
	do
		echo 'obj-$(CONFIG_ZFS) += ' "$MODULE/"
	done
} > "$KERNEL_DIR/fs/zfs/Kbuild"

add_after()
{
	local FILE="$1"
	local MARKER="$2"
	local NEW="$3"
	local LINE

	while IFS='' read -r LINE
	do
		echo "$LINE"

		if [ -n "$MARKER" -a "$LINE" = "$MARKER" ]
		then
			echo "$NEW"
			MARKER=''
			if IFS='' read -r LINE
			then
				[ "$LINE" != "$NEW" ] && echo "$LINE"
			fi
		fi
	done < "$FILE" > "$FILE.new"

	mv "$FILE.new" "$FILE"
}

add_after "$KERNEL_DIR/fs/Kconfig" 'if BLOCK' 'source "fs/zfs/Kconfig"'
add_after "$KERNEL_DIR/fs/Makefile" 'endif' 'obj-$(CONFIG_ZFS) += zfs/'

echo >&2
echo "    $0: done." >&2
echo "    $0: now you can build the kernel with ZFS support." >&2
echo "    $0: make sure you enable ZFS support (CONFIG_ZFS) before building." >&2
echo >&2
                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/cp                                                                              0100755 0000000 0000000 00000000022 13045370710 012604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh
cp "$@"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/dkms.conf                                                                       0100644 0000000 0000000 00000004553 13045370712 014100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        BUILD_DEPENDS[0]="spl"
AUTOINSTALL="yes"
PACKAGE_NAME="zfs"
PACKAGE_VERSION="0.6.5.9"
PRE_BUILD="configure
  --prefix=/usr
  --with-config=kernel
  --with-linux=$(
    case `lsb_release -is` in
      (Debian)
        if [[ -e ${kernel_source_dir/%build/source} ]]
        then
          echo ${kernel_source_dir/%build/source}
        else
          # A kpkg exception for Proxmox 2.0
          echo ${kernel_source_dir}
        fi
      ;;
      (*)
        echo ${kernel_source_dir}
      ;;
    esac
  )
  --with-linux-obj=${kernel_source_dir}
  --with-spl=${source_tree}/spl-${PACKAGE_VERSION}
  --with-spl-obj=${dkms_tree}/spl/${PACKAGE_VERSION}/${kernelver}/${arch}
  $(
    [[ -r /etc/default/zfs ]] \
    && source /etc/default/zfs \
    && shopt -q -s extglob \
    && \
    {
      if [[ ${ZFS_DKMS_ENABLE_DEBUG,,} == @(y|yes) ]]
      then
        echo --enable-debug
      fi
      if [[ ${ZFS_DKMS_ENABLE_DEBUG_DMU_TX,,} == @(y|yes) ]]
      then
        echo --enable-debug-dmu-tx
      fi
    }
  )
"
POST_BUILD="cp
  ${dkms_tree}/${PACKAGE_NAME}/${PACKAGE_VERSION}/build/zfs_config.h
  ${dkms_tree}/${PACKAGE_NAME}/${PACKAGE_VERSION}/build/module/Module.symvers
  ${dkms_tree}/${PACKAGE_NAME}/${PACKAGE_VERSION}/${kernelver}/${arch}/
"
REMAKE_INITRD="$(
  if [ -e /usr/share/initramfs-tools/hooks/zfs \
       -o -e /usr/share/dracut/modules.d/90zfs ]
  then
    echo -n yes
  else
    echo -n no
  fi
)"
MAKE[0]="make"
STRIP[0]="$(
  [[ -r /etc/default/zfs ]] \
  && source /etc/default/zfs \
  && shopt -q -s extglob \
  && [[ ${ZFS_DKMS_DISABLE_STRIP,,} == @(y|yes) ]] \
  && echo -n no
)"
STRIP[1]="${STRIP[0]}"
STRIP[2]="${STRIP[0]}"
STRIP[3]="${STRIP[0]}"
STRIP[4]="${STRIP[0]}"
STRIP[5]="${STRIP[0]}"
BUILT_MODULE_NAME[0]="zavl"
BUILT_MODULE_LOCATION[0]="module/avl/"
DEST_MODULE_LOCATION[0]="/extra/zfs/zavl"
BUILT_MODULE_NAME[1]="zcommon"
BUILT_MODULE_LOCATION[1]="module/zcommon/"
DEST_MODULE_LOCATION[1]="/extra/zfs/zcommon"
BUILT_MODULE_NAME[2]="znvpair"
BUILT_MODULE_LOCATION[2]="module/nvpair/"
DEST_MODULE_LOCATION[2]="/extra/zfs/znvpair"
BUILT_MODULE_NAME[3]="zpios"
BUILT_MODULE_LOCATION[3]="module/zpios/"
DEST_MODULE_LOCATION[3]="/extra/zfs/zpios"
BUILT_MODULE_NAME[4]="zunicode"
BUILT_MODULE_LOCATION[4]="module/unicode/"
DEST_MODULE_LOCATION[4]="/extra/zfs/zunicode"
BUILT_MODULE_NAME[5]="zfs"
BUILT_MODULE_LOCATION[5]="module/zfs/"
DEST_MODULE_LOCATION[5]="/extra/zfs/zfs"
                                                                                                                                                     usr/src/zfs-0.6.5.9/etc/                                                                            0040755 0000000 0000000 00000000000 13077704276 013055  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/etc/Makefile.in                                                                 0100644 0000000 0000000 00000000006 13045370707 015104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/                                                                     0040755 0000000 0000000 00000000000 13077704276 014242  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/etc/init.d/Makefile.in                                                          0100644 0000000 0000000 00000000006 13045370707 016271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/zfs-functions.in                                                     0100644 0000000 0000000 00000000006 13045370707 017364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/zfs-import.in                                                        0100644 0000000 0000000 00000000006 13045370707 016666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/zfs-mount.in                                                         0100644 0000000 0000000 00000000006 13045370707 016516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/zfs-share.in                                                         0100644 0000000 0000000 00000000006 13045370707 016456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/zfs-zed.in                                                           0100644 0000000 0000000 00000000006 13045370707 016136  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/init.d/zfs.in                                                               0100644 0000000 0000000 00000000006 13045370707 015356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/modules-load.d/                                                             0040755 0000000 0000000 00000000000 13077704276 015664  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/etc/modules-load.d/Makefile.in                                                  0100644 0000000 0000000 00000000006 13045370707 017713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/modules-load.d/zfs.conf.in                                                  0100644 0000000 0000000 00000000006 13045370707 017724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/                                                                    0040755 0000000 0000000 00000000000 13077704276 014545  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/etc/systemd/Makefile.in                                                         0100644 0000000 0000000 00000000006 13045370707 016574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/                                                             0040755 0000000 0000000 00000000000 13077704276 016071  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/etc/systemd/system/50-zfs.preset.in                                             0100644 0000000 0000000 00000000006 13045370707 020730  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/Makefile.in                                                  0100644 0000000 0000000 00000000006 13045370707 020120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/zfs-import-cache.service.in                                  0100644 0000000 0000000 00000000006 13045370707 023215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/zfs-import-scan.service.in                                   0100644 0000000 0000000 00000000006 13045370707 023076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/zfs-mount.service.in                                         0100644 0000000 0000000 00000000006 13045370707 022004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/zfs-share.service.in                                         0100644 0000000 0000000 00000000006 13045370707 021744  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/zfs-zed.service.in                                           0100644 0000000 0000000 00000000006 13045370707 021424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/systemd/system/zfs.target.in                                                0100644 0000000 0000000 00000000006 13045370707 020472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/etc/zfs/                                                                        0040755 0000000 0000000 00000000000 13077704276 013657  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/etc/zfs/Makefile.in                                                             0100644 0000000 0000000 00000000006 13045370707 015706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/                                                                        0040755 0000000 0000000 00000000000 13077704276 013725  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/Makefile.am                                                             0100644 0000000 0000000 00000001575 13045171016 015747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = linux sys

COMMON_H = \
	$(top_srcdir)/include/zfeature_common.h \
	$(top_srcdir)/include/zfs_comutil.h \
	$(top_srcdir)/include/zfs_deleg.h \
	$(top_srcdir)/include/zfs_fletcher.h \
	$(top_srcdir)/include/zfs_namecheck.h \
	$(top_srcdir)/include/zfs_prop.h \
	$(top_srcdir)/include/zpios-ctl.h

KERNEL_H = \
	$(top_srcdir)/include/zpios-internal.h

USER_H = \
	$(top_srcdir)/include/libnvpair.h \
	$(top_srcdir)/include/libuutil_common.h \
	$(top_srcdir)/include/libuutil.h \
	$(top_srcdir)/include/libuutil_impl.h \
	$(top_srcdir)/include/libzfs.h \
	$(top_srcdir)/include/libzfs_core.h \
	$(top_srcdir)/include/libzfs_impl.h

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)

if CONFIG_USER
libzfsdir = $(includedir)/libzfs
libzfs_HEADERS = $(COMMON_H) $(USER_H)
endif

if CONFIG_KERNEL
kerneldir = @prefix@/src/zfs-$(VERSION)/include
kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
endif
                                                                                                                                   usr/src/zfs-0.6.5.9/include/Makefile.in                                                             0100644 0000000 0000000 00000072415 13045370526 015770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = include
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
	$(am__kernel_HEADERS_DIST) $(am__libzfs_HEADERS_DIST)
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__kernel_HEADERS_DIST = $(top_srcdir)/include/zfeature_common.h \
	$(top_srcdir)/include/zfs_comutil.h \
	$(top_srcdir)/include/zfs_deleg.h \
	$(top_srcdir)/include/zfs_fletcher.h \
	$(top_srcdir)/include/zfs_namecheck.h \
	$(top_srcdir)/include/zfs_prop.h \
	$(top_srcdir)/include/zpios-ctl.h \
	$(top_srcdir)/include/zpios-internal.h
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"
am__libzfs_HEADERS_DIST = $(top_srcdir)/include/zfeature_common.h \
	$(top_srcdir)/include/zfs_comutil.h \
	$(top_srcdir)/include/zfs_deleg.h \
	$(top_srcdir)/include/zfs_fletcher.h \
	$(top_srcdir)/include/zfs_namecheck.h \
	$(top_srcdir)/include/zfs_prop.h \
	$(top_srcdir)/include/zpios-ctl.h \
	$(top_srcdir)/include/libnvpair.h \
	$(top_srcdir)/include/libuutil_common.h \
	$(top_srcdir)/include/libuutil.h \
	$(top_srcdir)/include/libuutil_impl.h \
	$(top_srcdir)/include/libzfs.h \
	$(top_srcdir)/include/libzfs_core.h \
	$(top_srcdir)/include/libzfs_impl.h
HEADERS = $(kernel_HEADERS) $(libzfs_HEADERS)
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
SUBDIRS = linux sys
COMMON_H = \
	$(top_srcdir)/include/zfeature_common.h \
	$(top_srcdir)/include/zfs_comutil.h \
	$(top_srcdir)/include/zfs_deleg.h \
	$(top_srcdir)/include/zfs_fletcher.h \
	$(top_srcdir)/include/zfs_namecheck.h \
	$(top_srcdir)/include/zfs_prop.h \
	$(top_srcdir)/include/zpios-ctl.h

KERNEL_H = \
	$(top_srcdir)/include/zpios-internal.h

USER_H = \
	$(top_srcdir)/include/libnvpair.h \
	$(top_srcdir)/include/libuutil_common.h \
	$(top_srcdir)/include/libuutil.h \
	$(top_srcdir)/include/libuutil_impl.h \
	$(top_srcdir)/include/libzfs.h \
	$(top_srcdir)/include/libzfs_core.h \
	$(top_srcdir)/include/libzfs_impl.h

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)
@CONFIG_USER_TRUE@libzfsdir = $(includedir)/libzfs
@CONFIG_USER_TRUE@libzfs_HEADERS = $(COMMON_H) $(USER_H)
@CONFIG_KERNEL_TRUE@kerneldir = @prefix@/src/zfs-$(VERSION)/include
@CONFIG_KERNEL_TRUE@kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu include/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
install-kernelHEADERS: $(kernel_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(kerneldir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(kerneldir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(kerneldir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(kerneldir)" || exit $$?; \
	done

uninstall-kernelHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(kerneldir)'; $(am__uninstall_files_from_dir)
install-libzfsHEADERS: $(libzfs_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libzfsdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libzfsdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libzfsdir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libzfsdir)" || exit $$?; \
	done

uninstall-libzfsHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(libzfsdir)'; $(am__uninstall_files_from_dir)

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile $(HEADERS)
installdirs: installdirs-recursive
installdirs-am:
	for dir in "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am: install-kernelHEADERS install-libzfsHEADERS

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am: uninstall-kernelHEADERS uninstall-libzfsHEADERS

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am \
	install-kernelHEADERS install-libzfsHEADERS install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am \
	uninstall-kernelHEADERS uninstall-libzfsHEADERS


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/libnvpair.h                                                             0100644 0000000 0000000 00000016324 13045171016 016050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_LIBNVPAIR_H
#define	_LIBNVPAIR_H

#include <sys/nvpair.h>
#include <stdlib.h>
#include <stdio.h>
#include <regex.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * All interfaces described in this file are private to Solaris, and
 * are subject to change at any time and without notice.  The public
 * nvlist/nvpair interfaces, as documented in manpage sections 3NVPAIR,
 * are all imported from <sys/nvpair.h> included above.
 */

extern int nvpair_value_match(nvpair_t *, int, char *, char **);
extern int nvpair_value_match_regex(nvpair_t *, int, char *, regex_t *,
    char **);

extern void nvlist_print(FILE *, nvlist_t *);
extern void dump_nvlist(nvlist_t *, int);

/*
 * Private nvlist printing interface that allows the caller some control
 * over output rendering (as opposed to nvlist_print and dump_nvlist).
 *
 * Obtain an opaque nvlist_prtctl_t cookie using nvlist_prtctl_alloc
 * (NULL on failure);  on return the cookie is set up for default formatting
 * and rendering.  Quote the cookie in subsequent customisation functions and
 * then pass the cookie to nvlist_prt to render the nvlist.  Finally,
 * use nvlist_prtctl_free to release the cookie.
 *
 * For all nvlist_lookup_xxx and nvlist_lookup_xxx_array functions
 * we have a corresponding brace of functions that appoint replacement
 * rendering functions:
 *
 *	extern void nvlist_prtctl_xxx(nvlist_prtctl_t,
 *	    void (*)(nvlist_prtctl_t ctl, void *private, const char *name,
 *	    xxxtype value))
 *
 *	and
 *
 *	extern void nvlist_prtctl_xxx_array(nvlist_prtctl_t,
 *	    void (*)(nvlist_prtctl_t ctl, void *private, const char *name,
 *	    xxxtype value, uint_t count))
 *
 * where xxxtype is the C datatype corresponding to xxx, eg int8_t for "int8"
 * and char * for "string".  The function that is appointed to render the
 * specified datatype receives as arguments the cookie, the nvlist
 * member name, the value of that member (or a pointer for array function),
 * and (for array rendering functions) a count of the number of elements.
 */

typedef struct nvlist_prtctl *nvlist_prtctl_t;	/* opaque */

enum nvlist_indent_mode {
	NVLIST_INDENT_ABS,	/* Absolute indentation */
	NVLIST_INDENT_TABBED	/* Indent with tabstops */
};

extern nvlist_prtctl_t nvlist_prtctl_alloc(void);
extern void nvlist_prtctl_free(nvlist_prtctl_t);
extern void nvlist_prt(nvlist_t *, nvlist_prtctl_t);

/* Output stream */
extern void nvlist_prtctl_setdest(nvlist_prtctl_t, FILE *);
extern FILE *nvlist_prtctl_getdest(nvlist_prtctl_t);

/* Indentation mode, start indent, indent increment; default tabbed/0/1 */
extern void nvlist_prtctl_setindent(nvlist_prtctl_t, enum nvlist_indent_mode,
    int, int);
extern void nvlist_prtctl_doindent(nvlist_prtctl_t, int);

enum nvlist_prtctl_fmt {
	NVLIST_FMT_MEMBER_NAME,		/* name fmt; default "%s = " */
	NVLIST_FMT_MEMBER_POSTAMBLE,	/* after nvlist member; default "\n" */
	NVLIST_FMT_BTWN_ARRAY		/* between array members; default " " */
};

extern void nvlist_prtctl_setfmt(nvlist_prtctl_t, enum nvlist_prtctl_fmt,
    const char *);
extern void nvlist_prtctl_dofmt(nvlist_prtctl_t, enum nvlist_prtctl_fmt, ...);

/*
 * Function prototypes for interfaces that appoint a new rendering function
 * for single-valued nvlist members.
 *
 * A replacement function receives arguments as follows:
 *
 *	nvlist_prtctl_t	Print control structure; do not change preferences
 *			for this object from a print callback function.
 *
 *	void *		The function-private cookie argument registered
 *			when the replacement function was appointed.
 *
 *	nvlist_t *	The full nvlist that is being processed.  The
 *			rendering function is called to render a single
 *			member (name and value passed as below) but it may
 *			want to reference or incorporate other aspects of
 *			the full nvlist.
 *
 *	const char *	Member name to render
 *
 *	valtype		Value of the member to render
 *
 * The function must return non-zero if it has rendered output for this
 * member, or 0 if it wants to default to standard rendering for this
 * one member.
 */

#define	NVLIST_PRINTCTL_SVDECL(funcname, valtype) \
    extern void funcname(nvlist_prtctl_t, \
    int (*)(nvlist_prtctl_t, void *, nvlist_t *, const char *, valtype), \
    void *)

NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_boolean, int);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_boolean_value, boolean_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_byte, uchar_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_int8, int8_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_uint8, uint8_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_int16, int16_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_uint16, uint16_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_int32, int32_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_uint32, uint32_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_int64, int64_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_uint64, uint64_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_double, double);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_string, char *);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_hrtime, hrtime_t);
NVLIST_PRINTCTL_SVDECL(nvlist_prtctlop_nvlist, nvlist_t *);

#undef	NVLIST_PRINTCTL_SVDECL	/* was just for "clarity" above */

/*
 * Function prototypes for interfaces that appoint a new rendering function
 * for array-valued nvlist members.
 *
 * One additional argument is taken: uint_t for the number of array elements
 *
 * Return values as above.
 */
#define	NVLIST_PRINTCTL_AVDECL(funcname, vtype) \
    extern void funcname(nvlist_prtctl_t, \
    int (*)(nvlist_prtctl_t, void *, nvlist_t *, const char *, vtype, uint_t), \
    void *)

NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_boolean_array, boolean_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_byte_array, uchar_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_int8_array, int8_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_uint8_array, uint8_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_int16_array, int16_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_uint16_array, uint16_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_int32_array, int32_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_uint32_array, uint32_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_int64_array, int64_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_uint64_array, uint64_t *);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_string_array, char **);
NVLIST_PRINTCTL_AVDECL(nvlist_prtctlop_nvlist_array, nvlist_t **);

#undef	NVLIST_PRINTCTL_AVDECL	/* was just for "clarity" above */

#ifdef	__cplusplus
}
#endif

#endif	/* _LIBNVPAIR_H */
                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/libuutil.h                                                              0100644 0000000 0000000 00000023777 13045171016 015725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_LIBUUTIL_H
#define	_LIBUUTIL_H

#include <sys/types.h>
#include <stdarg.h>
#include <stdio.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Standard flags codes.
 */
#define	UU_DEFAULT		0

/*
 * Standard error codes.
 */
#define	UU_ERROR_NONE		0	/* no error */
#define	UU_ERROR_INVALID_ARGUMENT 1	/* invalid argument */
#define	UU_ERROR_UNKNOWN_FLAG	2	/* passed flag invalid */
#define	UU_ERROR_NO_MEMORY	3	/* out of memory */
#define	UU_ERROR_CALLBACK_FAILED 4	/* callback-initiated error */
#define	UU_ERROR_NOT_SUPPORTED	5	/* operation not supported */
#define	UU_ERROR_EMPTY		6	/* no value provided */
#define	UU_ERROR_UNDERFLOW	7	/* value is too small */
#define	UU_ERROR_OVERFLOW	8	/* value is too value */
#define	UU_ERROR_INVALID_CHAR	9	/* value contains unexpected char */
#define	UU_ERROR_INVALID_DIGIT	10	/* value contains digit not in base */

#define	UU_ERROR_SYSTEM		99	/* underlying system error */
#define	UU_ERROR_UNKNOWN	100	/* error status not known */

/*
 * Standard program exit codes.
 */
#define	UU_EXIT_OK	(*(uu_exit_ok()))
#define	UU_EXIT_FATAL	(*(uu_exit_fatal()))
#define	UU_EXIT_USAGE	(*(uu_exit_usage()))

/*
 * Exit status profiles.
 */
#define	UU_PROFILE_DEFAULT	0
#define	UU_PROFILE_LAUNCHER	1

/*
 * Error reporting functions.
 */
uint32_t uu_error(void);
const char *uu_strerror(uint32_t);

/*
 * Program notification functions.
 */
extern void uu_alt_exit(int);
extern const char *uu_setpname(char *);
extern const char *uu_getpname(void);
/*PRINTFLIKE1*/
extern void uu_warn(const char *, ...);
extern void uu_vwarn(const char *, va_list);
/*PRINTFLIKE1*/
extern void uu_die(const char *, ...) __NORETURN;
extern void uu_vdie(const char *, va_list) __NORETURN;
/*PRINTFLIKE2*/
extern void uu_xdie(int, const char *, ...) __NORETURN;
extern void uu_vxdie(int, const char *, va_list) __NORETURN;

/*
 * Exit status functions (not to be used directly)
 */
extern int *uu_exit_ok(void);
extern int *uu_exit_fatal(void);
extern int *uu_exit_usage(void);

/*
 * string->number conversions
 */
extern int uu_strtoint(const char *, void *, size_t, int, int64_t, int64_t);
extern int uu_strtouint(const char *, void *, size_t, int, uint64_t, uint64_t);

/*
 * Debug print facility functions.
 */
typedef struct uu_dprintf uu_dprintf_t;

typedef enum {
	UU_DPRINTF_SILENT,
	UU_DPRINTF_FATAL,
	UU_DPRINTF_WARNING,
	UU_DPRINTF_NOTICE,
	UU_DPRINTF_INFO,
	UU_DPRINTF_DEBUG
} uu_dprintf_severity_t;

extern uu_dprintf_t *uu_dprintf_create(const char *, uu_dprintf_severity_t,
    uint_t);
/*PRINTFLIKE3*/
extern void uu_dprintf(uu_dprintf_t *, uu_dprintf_severity_t,
    const char *, ...);
extern void uu_dprintf_destroy(uu_dprintf_t *);
extern const char *uu_dprintf_getname(uu_dprintf_t *);

/*
 * Identifier test flags and function.
 */
#define	UU_NAME_DOMAIN		0x1	/* allow SUNW, or com.sun, prefix */
#define	UU_NAME_PATH		0x2	/* allow '/'-delimited paths */

int uu_check_name(const char *, uint_t);

/*
 * File creation functions.
 */
extern int uu_open_tmp(const char *dir, uint_t uflags);

/*
 * Convenience functions.
 */
#define	UU_NELEM(a)	(sizeof (a) / sizeof ((a)[0]))

/*PRINTFLIKE1*/
extern char *uu_msprintf(const char *format, ...);
extern void *uu_zalloc(size_t);
extern char *uu_strdup(const char *);
extern void uu_free(void *);

extern boolean_t uu_strcaseeq(const char *a, const char *b);
extern boolean_t uu_streq(const char *a, const char *b);
extern char *uu_strndup(const char *s, size_t n);
extern boolean_t uu_strbw(const char *a, const char *b);
extern void *uu_memdup(const void *buf, size_t sz);
extern void uu_dump(FILE *out, const char *prefix, const void *buf, size_t len);

/*
 * Comparison function type definition.
 *   Developers should be careful in their use of the _private argument. If you
 *   break interface guarantees, you get undefined behavior.
 */
typedef int uu_compare_fn_t(const void *__left, const void *__right,
    void *__private);

/*
 * Walk variant flags.
 *   A data structure need not provide support for all variants and
 *   combinations.  Refer to the appropriate documentation.
 */
#define	UU_WALK_ROBUST		0x00000001	/* walk can survive removes */
#define	UU_WALK_REVERSE		0x00000002	/* reverse walk order */

#define	UU_WALK_PREORDER	0x00000010	/* walk tree in pre-order */
#define	UU_WALK_POSTORDER	0x00000020	/* walk tree in post-order */

/*
 * Walk callback function return codes.
 */
#define	UU_WALK_ERROR		-1
#define	UU_WALK_NEXT		0
#define	UU_WALK_DONE		1

/*
 * Walk callback function type definition.
 */
typedef int uu_walk_fn_t(void *_elem, void *_private);

/*
 * lists: opaque structures
 */
typedef struct uu_list_pool uu_list_pool_t;
typedef struct uu_list uu_list_t;

typedef struct uu_list_node {
	uintptr_t uln_opaque[2];
} uu_list_node_t;

typedef struct uu_list_walk uu_list_walk_t;

typedef uintptr_t uu_list_index_t;

/*
 * lists: interface
 *
 * basic usage:
 *	typedef struct foo {
 *		...
 *		uu_list_node_t foo_node;
 *		...
 *	} foo_t;
 *
 *	static int
 *	foo_compare(void *l_arg, void *r_arg, void *private)
 *	{
 *		foo_t *l = l_arg;
 *		foo_t *r = r_arg;
 *
 *		if (... l greater than r ...)
 *			return (1);
 *		if (... l less than r ...)
 *			return (-1);
 *		return (0);
 *	}
 *
 *	...
 *		// at initialization time
 *		foo_pool = uu_list_pool_create("foo_pool",
 *		    sizeof (foo_t), offsetof(foo_t, foo_node), foo_compare,
 *		    debugging? 0 : UU_AVL_POOL_DEBUG);
 *	...
 */
uu_list_pool_t *uu_list_pool_create(const char *, size_t, size_t,
    uu_compare_fn_t *, uint32_t);
#define	UU_LIST_POOL_DEBUG	0x00000001

void uu_list_pool_destroy(uu_list_pool_t *);

/*
 * usage:
 *
 *	foo_t *a;
 *	a = malloc(sizeof(*a));
 *	uu_list_node_init(a, &a->foo_list, pool);
 *	...
 *	uu_list_node_fini(a, &a->foo_list, pool);
 *	free(a);
 */
void uu_list_node_init(void *, uu_list_node_t *, uu_list_pool_t *);
void uu_list_node_fini(void *, uu_list_node_t *, uu_list_pool_t *);

uu_list_t *uu_list_create(uu_list_pool_t *, void *_parent, uint32_t);
#define	UU_LIST_DEBUG	0x00000001
#define	UU_LIST_SORTED	0x00000002	/* list is sorted */

void uu_list_destroy(uu_list_t *);	/* list must be empty */

size_t uu_list_numnodes(uu_list_t *);

void *uu_list_first(uu_list_t *);
void *uu_list_last(uu_list_t *);

void *uu_list_next(uu_list_t *, void *);
void *uu_list_prev(uu_list_t *, void *);

int uu_list_walk(uu_list_t *, uu_walk_fn_t *, void *, uint32_t);

uu_list_walk_t *uu_list_walk_start(uu_list_t *, uint32_t);
void *uu_list_walk_next(uu_list_walk_t *);
void uu_list_walk_end(uu_list_walk_t *);

void *uu_list_find(uu_list_t *, void *, void *, uu_list_index_t *);
void uu_list_insert(uu_list_t *, void *, uu_list_index_t);

void *uu_list_nearest_next(uu_list_t *, uu_list_index_t);
void *uu_list_nearest_prev(uu_list_t *, uu_list_index_t);

void *uu_list_teardown(uu_list_t *, void **);

void uu_list_remove(uu_list_t *, void *);

/*
 * lists: interfaces for non-sorted lists only
 */
int uu_list_insert_before(uu_list_t *, void *_target, void *_elem);
int uu_list_insert_after(uu_list_t *, void *_target, void *_elem);

/*
 * avl trees: opaque structures
 */
typedef struct uu_avl_pool uu_avl_pool_t;
typedef struct uu_avl uu_avl_t;

typedef struct uu_avl_node {
#ifdef _LP64
	uintptr_t uan_opaque[3];
#else
	uintptr_t uan_opaque[4];
#endif
} uu_avl_node_t;

typedef struct uu_avl_walk uu_avl_walk_t;

typedef uintptr_t uu_avl_index_t;

/*
 * avl trees: interface
 *
 * basic usage:
 *	typedef struct foo {
 *		...
 *		uu_avl_node_t foo_node;
 *		...
 *	} foo_t;
 *
 *	static int
 *	foo_compare(void *l_arg, void *r_arg, void *private)
 *	{
 *		foo_t *l = l_arg;
 *		foo_t *r = r_arg;
 *
 *		if (... l greater than r ...)
 *			return (1);
 *		if (... l less than r ...)
 *			return (-1);
 *		return (0);
 *	}
 *
 *	...
 *		// at initialization time
 *		foo_pool = uu_avl_pool_create("foo_pool",
 *		    sizeof (foo_t), offsetof(foo_t, foo_node), foo_compare,
 *		    debugging? 0 : UU_AVL_POOL_DEBUG);
 *	...
 */
uu_avl_pool_t *uu_avl_pool_create(const char *, size_t, size_t,
    uu_compare_fn_t *, uint32_t);
#define	UU_AVL_POOL_DEBUG	0x00000001

void uu_avl_pool_destroy(uu_avl_pool_t *);

/*
 * usage:
 *
 *	foo_t *a;
 *	a = malloc(sizeof(*a));
 *	uu_avl_node_init(a, &a->foo_avl, pool);
 *	...
 *	uu_avl_node_fini(a, &a->foo_avl, pool);
 *	free(a);
 */
void uu_avl_node_init(void *, uu_avl_node_t *, uu_avl_pool_t *);
void uu_avl_node_fini(void *, uu_avl_node_t *, uu_avl_pool_t *);

uu_avl_t *uu_avl_create(uu_avl_pool_t *, void *_parent, uint32_t);
#define	UU_AVL_DEBUG	0x00000001

void uu_avl_destroy(uu_avl_t *);	/* list must be empty */

size_t uu_avl_numnodes(uu_avl_t *);

void *uu_avl_first(uu_avl_t *);
void *uu_avl_last(uu_avl_t *);

void *uu_avl_next(uu_avl_t *, void *);
void *uu_avl_prev(uu_avl_t *, void *);

int uu_avl_walk(uu_avl_t *, uu_walk_fn_t *, void *, uint32_t);

uu_avl_walk_t *uu_avl_walk_start(uu_avl_t *, uint32_t);
void *uu_avl_walk_next(uu_avl_walk_t *);
void uu_avl_walk_end(uu_avl_walk_t *);

void *uu_avl_find(uu_avl_t *, void *, void *, uu_avl_index_t *);
void uu_avl_insert(uu_avl_t *, void *, uu_avl_index_t);

void *uu_avl_nearest_next(uu_avl_t *, uu_avl_index_t);
void *uu_avl_nearest_prev(uu_avl_t *, uu_avl_index_t);

void *uu_avl_teardown(uu_avl_t *, void **);

void uu_avl_remove(uu_avl_t *, void *);

#ifdef	__cplusplus
}
#endif

#endif	/* _LIBUUTIL_H */
 usr/src/zfs-0.6.5.9/include/libuutil_common.h                                                       0100644 0000000 0000000 00000002053 13045171016 017255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_LIBUUTIL_COMMON_H
#define	_LIBUUTIL_COMMON_H



#include <libuutil.h>
#include <libuutil_impl.h>

#endif	/* _LIBUUTIL_COMMON_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/include/libuutil_impl.h                                                         0100644 0000000 0000000 00000010026 13045171016 016725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_LIBUUTIL_IMPL_H
#define	_LIBUUTIL_IMPL_H



#include <libuutil.h>
#include <pthread.h>

#include <sys/avl_impl.h>
#include <sys/byteorder.h>

#ifdef	__cplusplus
extern "C" {
#endif

void uu_set_error(uint_t);


/*PRINTFLIKE1*/
void uu_panic(const char *format, ...);


struct uu_dprintf {
	char	*uud_name;
	uu_dprintf_severity_t uud_severity;
	uint_t	uud_flags;
};

/*
 * For debugging purposes, libuutil keeps around linked lists of all uu_lists
 * and uu_avls, along with pointers to their parents.  These can cause false
 * negatives when looking for memory leaks, so we encode the pointers by
 * storing them with swapped endianness;  this is not perfect, but it's about
 * the best we can do without wasting a lot of space.
 */
#ifdef _LP64
#define	UU_PTR_ENCODE(ptr)		BSWAP_64((uintptr_t)(void *)(ptr))
#else
#define	UU_PTR_ENCODE(ptr)		BSWAP_32((uintptr_t)(void *)(ptr))
#endif

#define	UU_PTR_DECODE(ptr)		((void *)UU_PTR_ENCODE(ptr))

/*
 * uu_list structures
 */
typedef struct uu_list_node_impl {
	struct uu_list_node_impl *uln_next;
	struct uu_list_node_impl *uln_prev;
} uu_list_node_impl_t;

struct uu_list_walk {
	uu_list_walk_t	*ulw_next;
	uu_list_walk_t	*ulw_prev;

	uu_list_t	*ulw_list;
	int8_t		ulw_dir;
	uint8_t		ulw_robust;
	uu_list_node_impl_t *ulw_next_result;
};

struct uu_list {
	uintptr_t	ul_next_enc;
	uintptr_t	ul_prev_enc;

	uu_list_pool_t	*ul_pool;
	uintptr_t	ul_parent_enc;	/* encoded parent pointer */
	size_t		ul_offset;
	size_t		ul_numnodes;
	uint8_t		ul_debug;
	uint8_t		ul_sorted;
	uint8_t		ul_index;	/* mark for uu_list_index_ts */

	uu_list_node_impl_t ul_null_node;
	uu_list_walk_t	ul_null_walk;	/* for robust walkers */
};

#define	UU_LIST_PTR(ptr)		((uu_list_t *)UU_PTR_DECODE(ptr))

#define	UU_LIST_POOL_MAXNAME	64

struct uu_list_pool {
	uu_list_pool_t	*ulp_next;
	uu_list_pool_t	*ulp_prev;

	char		ulp_name[UU_LIST_POOL_MAXNAME];
	size_t		ulp_nodeoffset;
	size_t		ulp_objsize;
	uu_compare_fn_t	*ulp_cmp;
	uint8_t		ulp_debug;
	uint8_t		ulp_last_index;
	pthread_mutex_t	ulp_lock;		/* protects null_list */
	uu_list_t	ulp_null_list;
};

/*
 * uu_avl structures
 */
typedef struct avl_node		uu_avl_node_impl_t;

struct uu_avl_walk {
	uu_avl_walk_t	*uaw_next;
	uu_avl_walk_t	*uaw_prev;

	uu_avl_t	*uaw_avl;
	void		*uaw_next_result;
	int8_t		uaw_dir;
	uint8_t		uaw_robust;
};

struct uu_avl {
	uintptr_t	ua_next_enc;
	uintptr_t	ua_prev_enc;

	uu_avl_pool_t	*ua_pool;
	uintptr_t	ua_parent_enc;
	uint8_t		ua_debug;
	uint8_t		ua_index;	/* mark for uu_avl_index_ts */

	struct avl_tree	ua_tree;
	uu_avl_walk_t	ua_null_walk;
};

#define	UU_AVL_PTR(x)		((uu_avl_t *)UU_PTR_DECODE(x))

#define	UU_AVL_POOL_MAXNAME	64

struct uu_avl_pool {
	uu_avl_pool_t	*uap_next;
	uu_avl_pool_t	*uap_prev;

	char		uap_name[UU_AVL_POOL_MAXNAME];
	size_t		uap_nodeoffset;
	size_t		uap_objsize;
	uu_compare_fn_t	*uap_cmp;
	uint8_t		uap_debug;
	uint8_t		uap_last_index;
	pthread_mutex_t	uap_lock;		/* protects null_avl */
	uu_avl_t	uap_null_avl;
};

/*
 * atfork() handlers
 */
void uu_avl_lockup(void);
void uu_avl_release(void);

void uu_list_lockup(void);
void uu_list_release(void);

#ifdef	__cplusplus
}
#endif

#endif	/* _LIBUUTIL_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/libzfs.h                                                                0100644 0000000 0000000 00000070144 13045171016 015353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 * Copyright (c) 2013 Steven Hartland. All rights reserved.
 * Copyright 2013 Nexenta Systems, Inc. All rights reserved.
 */

#ifndef	_LIBZFS_H
#define	_LIBZFS_H

#include <assert.h>
#include <libnvpair.h>
#include <sys/mnttab.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/varargs.h>
#include <sys/fs/zfs.h>
#include <sys/avl.h>
#include <ucred.h>
#include <libzfs_core.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Miscellaneous ZFS constants
 */
#define	ZFS_MAXNAMELEN		MAXNAMELEN
#define	ZPOOL_MAXNAMELEN	MAXNAMELEN
#define	ZFS_MAXPROPLEN		MAXPATHLEN
#define	ZPOOL_MAXPROPLEN	MAXPATHLEN

/*
 * Default device paths
 */
#define	DISK_ROOT		"/dev"
#define	UDISK_ROOT		"/dev/disk"

/*
 * Default wait time for a device name to be created.
 */
#define	DISK_LABEL_WAIT		(30 * 1000)  /* 30 seconds */

#define	DEFAULT_IMPORT_PATH_SIZE	7
extern char *zpool_default_import_path[DEFAULT_IMPORT_PATH_SIZE];

/*
 * libzfs errors
 */
typedef enum zfs_error {
	EZFS_SUCCESS = 0,	/* no error -- success */
	EZFS_NOMEM = 2000,	/* out of memory */
	EZFS_BADPROP,		/* invalid property value */
	EZFS_PROPREADONLY,	/* cannot set readonly property */
	EZFS_PROPTYPE,		/* property does not apply to dataset type */
	EZFS_PROPNONINHERIT,	/* property is not inheritable */
	EZFS_PROPSPACE,		/* bad quota or reservation */
	EZFS_BADTYPE,		/* dataset is not of appropriate type */
	EZFS_BUSY,		/* pool or dataset is busy */
	EZFS_EXISTS,		/* pool or dataset already exists */
	EZFS_NOENT,		/* no such pool or dataset */
	EZFS_BADSTREAM,		/* bad backup stream */
	EZFS_DSREADONLY,	/* dataset is readonly */
	EZFS_VOLTOOBIG,		/* volume is too large for 32-bit system */
	EZFS_INVALIDNAME,	/* invalid dataset name */
	EZFS_BADRESTORE,	/* unable to restore to destination */
	EZFS_BADBACKUP,		/* backup failed */
	EZFS_BADTARGET,		/* bad attach/detach/replace target */
	EZFS_NODEVICE,		/* no such device in pool */
	EZFS_BADDEV,		/* invalid device to add */
	EZFS_NOREPLICAS,	/* no valid replicas */
	EZFS_RESILVERING,	/* currently resilvering */
	EZFS_BADVERSION,	/* unsupported version */
	EZFS_POOLUNAVAIL,	/* pool is currently unavailable */
	EZFS_DEVOVERFLOW,	/* too many devices in one vdev */
	EZFS_BADPATH,		/* must be an absolute path */
	EZFS_CROSSTARGET,	/* rename or clone across pool or dataset */
	EZFS_ZONED,		/* used improperly in local zone */
	EZFS_MOUNTFAILED,	/* failed to mount dataset */
	EZFS_UMOUNTFAILED,	/* failed to unmount dataset */
	EZFS_UNSHARENFSFAILED,	/* unshare(1M) failed */
	EZFS_SHARENFSFAILED,	/* share(1M) failed */
	EZFS_PERM,		/* permission denied */
	EZFS_NOSPC,		/* out of space */
	EZFS_FAULT,		/* bad address */
	EZFS_IO,		/* I/O error */
	EZFS_INTR,		/* signal received */
	EZFS_ISSPARE,		/* device is a hot spare */
	EZFS_INVALCONFIG,	/* invalid vdev configuration */
	EZFS_RECURSIVE,		/* recursive dependency */
	EZFS_NOHISTORY,		/* no history object */
	EZFS_POOLPROPS,		/* couldn't retrieve pool props */
	EZFS_POOL_NOTSUP,	/* ops not supported for this type of pool */
	EZFS_POOL_INVALARG,	/* invalid argument for this pool operation */
	EZFS_NAMETOOLONG,	/* dataset name is too long */
	EZFS_OPENFAILED,	/* open of device failed */
	EZFS_NOCAP,		/* couldn't get capacity */
	EZFS_LABELFAILED,	/* write of label failed */
	EZFS_BADWHO,		/* invalid permission who */
	EZFS_BADPERM,		/* invalid permission */
	EZFS_BADPERMSET,	/* invalid permission set name */
	EZFS_NODELEGATION,	/* delegated administration is disabled */
	EZFS_UNSHARESMBFAILED,	/* failed to unshare over smb */
	EZFS_SHARESMBFAILED,	/* failed to share over smb */
	EZFS_BADCACHE,		/* bad cache file */
	EZFS_ISL2CACHE,		/* device is for the level 2 ARC */
	EZFS_VDEVNOTSUP,	/* unsupported vdev type */
	EZFS_NOTSUP,		/* ops not supported on this dataset */
	EZFS_ACTIVE_SPARE,	/* pool has active shared spare devices */
	EZFS_UNPLAYED_LOGS,	/* log device has unplayed logs */
	EZFS_REFTAG_RELE,	/* snapshot release: tag not found */
	EZFS_REFTAG_HOLD,	/* snapshot hold: tag already exists */
	EZFS_TAGTOOLONG,	/* snapshot hold/rele: tag too long */
	EZFS_PIPEFAILED,	/* pipe create failed */
	EZFS_THREADCREATEFAILED, /* thread create failed */
	EZFS_POSTSPLIT_ONLINE,	/* onlining a disk after splitting it */
	EZFS_SCRUBBING,		/* currently scrubbing */
	EZFS_NO_SCRUB,		/* no active scrub */
	EZFS_DIFF,		/* general failure of zfs diff */
	EZFS_DIFFDATA,		/* bad zfs diff data */
	EZFS_POOLREADONLY,	/* pool is in read-only mode */
	EZFS_UNKNOWN
} zfs_error_t;

/*
 * The following data structures are all part
 * of the zfs_allow_t data structure which is
 * used for printing 'allow' permissions.
 * It is a linked list of zfs_allow_t's which
 * then contain avl tree's for user/group/sets/...
 * and each one of the entries in those trees have
 * avl tree's for the permissions they belong to and
 * whether they are local,descendent or local+descendent
 * permissions.  The AVL trees are used primarily for
 * sorting purposes, but also so that we can quickly find
 * a given user and or permission.
 */
typedef struct zfs_perm_node {
	avl_node_t z_node;
	char z_pname[MAXPATHLEN];
} zfs_perm_node_t;

typedef struct zfs_allow_node {
	avl_node_t z_node;
	char z_key[MAXPATHLEN];		/* name, such as joe */
	avl_tree_t z_localdescend;	/* local+descendent perms */
	avl_tree_t z_local;		/* local permissions */
	avl_tree_t z_descend;		/* descendent permissions */
} zfs_allow_node_t;

typedef struct zfs_allow {
	struct zfs_allow *z_next;
	char z_setpoint[MAXPATHLEN];
	avl_tree_t z_sets;
	avl_tree_t z_crperms;
	avl_tree_t z_user;
	avl_tree_t z_group;
	avl_tree_t z_everyone;
} zfs_allow_t;

/*
 * Basic handle types
 */
typedef struct zfs_handle zfs_handle_t;
typedef struct zpool_handle zpool_handle_t;
typedef struct libzfs_handle libzfs_handle_t;

/*
 * Library initialization
 */
extern libzfs_handle_t *libzfs_init(void);
extern void libzfs_fini(libzfs_handle_t *);

extern libzfs_handle_t *zpool_get_handle(zpool_handle_t *);
extern libzfs_handle_t *zfs_get_handle(zfs_handle_t *);

extern void libzfs_print_on_error(libzfs_handle_t *, boolean_t);

extern void zfs_save_arguments(int argc, char **, char *, int);
extern int zpool_log_history(libzfs_handle_t *, const char *);

extern int libzfs_errno(libzfs_handle_t *);
extern const char *libzfs_error_init(int);
extern const char *libzfs_error_action(libzfs_handle_t *);
extern const char *libzfs_error_description(libzfs_handle_t *);
extern int zfs_standard_error(libzfs_handle_t *, int, const char *);
extern void libzfs_mnttab_init(libzfs_handle_t *);
extern void libzfs_mnttab_fini(libzfs_handle_t *);
extern void libzfs_mnttab_cache(libzfs_handle_t *, boolean_t);
extern int libzfs_mnttab_find(libzfs_handle_t *, const char *,
    struct mnttab *);
extern void libzfs_mnttab_add(libzfs_handle_t *, const char *,
    const char *, const char *);
extern void libzfs_mnttab_remove(libzfs_handle_t *, const char *);

/*
 * Basic handle functions
 */
extern zpool_handle_t *zpool_open(libzfs_handle_t *, const char *);
extern zpool_handle_t *zpool_open_canfail(libzfs_handle_t *, const char *);
extern void zpool_close(zpool_handle_t *);
extern const char *zpool_get_name(zpool_handle_t *);
extern int zpool_get_state(zpool_handle_t *);
extern char *zpool_state_to_name(vdev_state_t, vdev_aux_t);
extern const char *zpool_pool_state_to_name(pool_state_t);
extern void zpool_free_handles(libzfs_handle_t *);

/*
 * Iterate over all active pools in the system.
 */
typedef int (*zpool_iter_f)(zpool_handle_t *, void *);
extern int zpool_iter(libzfs_handle_t *, zpool_iter_f, void *);

/*
 * Functions to create and destroy pools
 */
extern int zpool_create(libzfs_handle_t *, const char *, nvlist_t *,
    nvlist_t *, nvlist_t *);
extern int zpool_destroy(zpool_handle_t *, const char *);
extern int zpool_add(zpool_handle_t *, nvlist_t *);

typedef struct splitflags {
	/* do not split, but return the config that would be split off */
	int dryrun : 1;

	/* after splitting, import the pool */
	int import : 1;
	int name_flags;
} splitflags_t;

/*
 * Functions to manipulate pool and vdev state
 */
extern int zpool_scan(zpool_handle_t *, pool_scan_func_t);
extern int zpool_clear(zpool_handle_t *, const char *, nvlist_t *);
extern int zpool_reguid(zpool_handle_t *);
extern int zpool_reopen(zpool_handle_t *);

extern int zpool_vdev_online(zpool_handle_t *, const char *, int,
    vdev_state_t *);
extern int zpool_vdev_offline(zpool_handle_t *, const char *, boolean_t);
extern int zpool_vdev_attach(zpool_handle_t *, const char *,
    const char *, nvlist_t *, int);
extern int zpool_vdev_detach(zpool_handle_t *, const char *);
extern int zpool_vdev_remove(zpool_handle_t *, const char *);
extern int zpool_vdev_split(zpool_handle_t *, char *, nvlist_t **, nvlist_t *,
    splitflags_t);

extern int zpool_vdev_fault(zpool_handle_t *, uint64_t, vdev_aux_t);
extern int zpool_vdev_degrade(zpool_handle_t *, uint64_t, vdev_aux_t);
extern int zpool_vdev_clear(zpool_handle_t *, uint64_t);

extern nvlist_t *zpool_find_vdev(zpool_handle_t *, const char *, boolean_t *,
    boolean_t *, boolean_t *);
extern nvlist_t *zpool_find_vdev_by_physpath(zpool_handle_t *, const char *,
    boolean_t *, boolean_t *, boolean_t *);
extern int zpool_label_disk_wait(char *, int);
extern int zpool_label_disk(libzfs_handle_t *, zpool_handle_t *, char *);

/*
 * Functions to manage pool properties
 */
extern int zpool_set_prop(zpool_handle_t *, const char *, const char *);
extern int zpool_get_prop(zpool_handle_t *, zpool_prop_t, char *,
    size_t proplen, zprop_source_t *);
extern int zpool_get_prop_literal(zpool_handle_t *, zpool_prop_t, char *,
    size_t proplen, zprop_source_t *, boolean_t literal);
extern uint64_t zpool_get_prop_int(zpool_handle_t *, zpool_prop_t,
    zprop_source_t *);

extern const char *zpool_prop_to_name(zpool_prop_t);
extern const char *zpool_prop_values(zpool_prop_t);

/*
 * Pool health statistics.
 */
typedef enum {
	/*
	 * The following correspond to faults as defined in the (fault.fs.zfs.*)
	 * event namespace.  Each is associated with a corresponding message ID.
	 */
	ZPOOL_STATUS_CORRUPT_CACHE,	/* corrupt /kernel/drv/zpool.cache */
	ZPOOL_STATUS_MISSING_DEV_R,	/* missing device with replicas */
	ZPOOL_STATUS_MISSING_DEV_NR,	/* missing device with no replicas */
	ZPOOL_STATUS_CORRUPT_LABEL_R,	/* bad device label with replicas */
	ZPOOL_STATUS_CORRUPT_LABEL_NR,	/* bad device label with no replicas */
	ZPOOL_STATUS_BAD_GUID_SUM,	/* sum of device guids didn't match */
	ZPOOL_STATUS_CORRUPT_POOL,	/* pool metadata is corrupted */
	ZPOOL_STATUS_CORRUPT_DATA,	/* data errors in user (meta)data */
	ZPOOL_STATUS_FAILING_DEV,	/* device experiencing errors */
	ZPOOL_STATUS_VERSION_NEWER,	/* newer on-disk version */
	ZPOOL_STATUS_HOSTID_MISMATCH,	/* last accessed by another system */
	ZPOOL_STATUS_IO_FAILURE_WAIT,	/* failed I/O, failmode 'wait' */
	ZPOOL_STATUS_IO_FAILURE_CONTINUE, /* failed I/O, failmode 'continue' */
	ZPOOL_STATUS_BAD_LOG,		/* cannot read log chain(s) */
	ZPOOL_STATUS_ERRATA,		/* informational errata available */

	/*
	 * If the pool has unsupported features but can still be opened in
	 * read-only mode, its status is ZPOOL_STATUS_UNSUP_FEAT_WRITE. If the
	 * pool has unsupported features but cannot be opened at all, its
	 * status is ZPOOL_STATUS_UNSUP_FEAT_READ.
	 */
	ZPOOL_STATUS_UNSUP_FEAT_READ,	/* unsupported features for read */
	ZPOOL_STATUS_UNSUP_FEAT_WRITE,	/* unsupported features for write */

	/*
	 * These faults have no corresponding message ID.  At the time we are
	 * checking the status, the original reason for the FMA fault (I/O or
	 * checksum errors) has been lost.
	 */
	ZPOOL_STATUS_FAULTED_DEV_R,	/* faulted device with replicas */
	ZPOOL_STATUS_FAULTED_DEV_NR,	/* faulted device with no replicas */

	/*
	 * The following are not faults per se, but still an error possibly
	 * requiring administrative attention.  There is no corresponding
	 * message ID.
	 */
	ZPOOL_STATUS_VERSION_OLDER,	/* older legacy on-disk version */
	ZPOOL_STATUS_FEAT_DISABLED,	/* supported features are disabled */
	ZPOOL_STATUS_RESILVERING,	/* device being resilvered */
	ZPOOL_STATUS_OFFLINE_DEV,	/* device online */
	ZPOOL_STATUS_REMOVED_DEV,	/* removed device */

	/*
	 * Finally, the following indicates a healthy pool.
	 */
	ZPOOL_STATUS_OK
} zpool_status_t;

extern unsigned long get_system_hostid(void);
extern zpool_status_t zpool_get_status(zpool_handle_t *, char **,
    zpool_errata_t *);
extern zpool_status_t zpool_import_status(nvlist_t *, char **,
    zpool_errata_t *);
extern void zpool_dump_ddt(const ddt_stat_t *dds, const ddt_histogram_t *ddh);

/*
 * Statistics and configuration functions.
 */
extern nvlist_t *zpool_get_config(zpool_handle_t *, nvlist_t **);
extern nvlist_t *zpool_get_features(zpool_handle_t *);
extern int zpool_refresh_stats(zpool_handle_t *, boolean_t *);
extern int zpool_get_errlog(zpool_handle_t *, nvlist_t **);

/*
 * Import and export functions
 */
extern int zpool_export(zpool_handle_t *, boolean_t, const char *);
extern int zpool_export_force(zpool_handle_t *, const char *);
extern int zpool_import(libzfs_handle_t *, nvlist_t *, const char *,
    char *altroot);
extern int zpool_import_props(libzfs_handle_t *, nvlist_t *, const char *,
    nvlist_t *, int);
extern void zpool_print_unsup_feat(nvlist_t *config);

/*
 * Search for pools to import
 */

typedef struct importargs {
	char **path;		/* a list of paths to search		*/
	int paths;		/* number of paths to search		*/
	char *poolname;		/* name of a pool to find		*/
	uint64_t guid;		/* guid of a pool to find		*/
	char *cachefile;	/* cachefile to use for import		*/
	int can_be_active : 1;	/* can the pool be active?		*/
	int unique : 1;		/* does 'poolname' already exist?	*/
	int exists : 1;		/* set on return if pool already exists	*/
} importargs_t;

extern nvlist_t *zpool_search_import(libzfs_handle_t *, importargs_t *);

/* legacy pool search routines */
extern nvlist_t *zpool_find_import(libzfs_handle_t *, int, char **);
extern nvlist_t *zpool_find_import_cached(libzfs_handle_t *, const char *,
    char *, uint64_t);

/*
 * Miscellaneous pool functions
 */
struct zfs_cmd;

extern const char *zfs_history_event_names[];

typedef enum {
	VDEV_NAME_PATH		= 1 << 0,
	VDEV_NAME_GUID		= 1 << 1,
	VDEV_NAME_FOLLOW_LINKS	= 1 << 2,
	VDEV_NAME_TYPE_ID	= 1 << 3,
} vdev_name_t;

extern char *zpool_vdev_name(libzfs_handle_t *, zpool_handle_t *, nvlist_t *,
    int name_flags);
extern int zpool_upgrade(zpool_handle_t *, uint64_t);
extern int zpool_get_history(zpool_handle_t *, nvlist_t **);
extern int zpool_history_unpack(char *, uint64_t, uint64_t *,
    nvlist_t ***, uint_t *);
extern int zpool_events_next(libzfs_handle_t *, nvlist_t **, int *, unsigned,
    int);
extern int zpool_events_clear(libzfs_handle_t *, int *);
extern int zpool_events_seek(libzfs_handle_t *, uint64_t, int);
extern void zpool_obj_to_path(zpool_handle_t *, uint64_t, uint64_t, char *,
    size_t len);
extern int zfs_ioctl(libzfs_handle_t *, int, struct zfs_cmd *);
extern int zpool_get_physpath(zpool_handle_t *, char *, size_t);
extern void zpool_explain_recover(libzfs_handle_t *, const char *, int,
    nvlist_t *);

/*
 * Basic handle manipulations.  These functions do not create or destroy the
 * underlying datasets, only the references to them.
 */
extern zfs_handle_t *zfs_open(libzfs_handle_t *, const char *, int);
extern zfs_handle_t *zfs_handle_dup(zfs_handle_t *);
extern void zfs_close(zfs_handle_t *);
extern zfs_type_t zfs_get_type(const zfs_handle_t *);
extern const char *zfs_get_name(const zfs_handle_t *);
extern zpool_handle_t *zfs_get_pool_handle(const zfs_handle_t *);

/*
 * Property management functions.  Some functions are shared with the kernel,
 * and are found in sys/fs/zfs.h.
 */

/*
 * zfs dataset property management
 */
extern const char *zfs_prop_default_string(zfs_prop_t);
extern uint64_t zfs_prop_default_numeric(zfs_prop_t);
extern const char *zfs_prop_column_name(zfs_prop_t);
extern boolean_t zfs_prop_align_right(zfs_prop_t);

extern nvlist_t *zfs_valid_proplist(libzfs_handle_t *, zfs_type_t,
    nvlist_t *, uint64_t, zfs_handle_t *, const char *);

extern const char *zfs_prop_to_name(zfs_prop_t);
extern int zfs_prop_set(zfs_handle_t *, const char *, const char *);
extern int zfs_prop_get(zfs_handle_t *, zfs_prop_t, char *, size_t,
    zprop_source_t *, char *, size_t, boolean_t);
extern int zfs_prop_get_recvd(zfs_handle_t *, const char *, char *, size_t,
    boolean_t);
extern int zfs_prop_get_numeric(zfs_handle_t *, zfs_prop_t, uint64_t *,
    zprop_source_t *, char *, size_t);
extern int zfs_prop_get_userquota_int(zfs_handle_t *zhp, const char *propname,
    uint64_t *propvalue);
extern int zfs_prop_get_userquota(zfs_handle_t *zhp, const char *propname,
    char *propbuf, int proplen, boolean_t literal);
extern int zfs_prop_get_written_int(zfs_handle_t *zhp, const char *propname,
    uint64_t *propvalue);
extern int zfs_prop_get_written(zfs_handle_t *zhp, const char *propname,
    char *propbuf, int proplen, boolean_t literal);
extern int zfs_prop_get_feature(zfs_handle_t *zhp, const char *propname,
    char *buf, size_t len);
extern uint64_t getprop_uint64(zfs_handle_t *, zfs_prop_t, char **);
extern uint64_t zfs_prop_get_int(zfs_handle_t *, zfs_prop_t);
extern int zfs_prop_inherit(zfs_handle_t *, const char *, boolean_t);
extern const char *zfs_prop_values(zfs_prop_t);
extern int zfs_prop_is_string(zfs_prop_t prop);
extern nvlist_t *zfs_get_user_props(zfs_handle_t *);
extern nvlist_t *zfs_get_recvd_props(zfs_handle_t *);
extern nvlist_t *zfs_get_clones_nvl(zfs_handle_t *);

typedef struct zprop_list {
	int		pl_prop;
	char		*pl_user_prop;
	struct zprop_list *pl_next;
	boolean_t	pl_all;
	size_t		pl_width;
	size_t		pl_recvd_width;
	boolean_t	pl_fixed;
} zprop_list_t;

extern int zfs_expand_proplist(zfs_handle_t *, zprop_list_t **, boolean_t,
    boolean_t);
extern void zfs_prune_proplist(zfs_handle_t *, uint8_t *);

#define	ZFS_MOUNTPOINT_NONE	"none"
#define	ZFS_MOUNTPOINT_LEGACY	"legacy"

#define	ZFS_FEATURE_DISABLED	"disabled"
#define	ZFS_FEATURE_ENABLED	"enabled"
#define	ZFS_FEATURE_ACTIVE	"active"

#define	ZFS_UNSUPPORTED_INACTIVE	"inactive"
#define	ZFS_UNSUPPORTED_READONLY	"readonly"

/*
 * zpool property management
 */
extern int zpool_expand_proplist(zpool_handle_t *, zprop_list_t **);
extern int zpool_prop_get_feature(zpool_handle_t *, const char *, char *,
    size_t);
extern const char *zpool_prop_default_string(zpool_prop_t);
extern uint64_t zpool_prop_default_numeric(zpool_prop_t);
extern const char *zpool_prop_column_name(zpool_prop_t);
extern boolean_t zpool_prop_align_right(zpool_prop_t);

/*
 * Functions shared by zfs and zpool property management.
 */
extern int zprop_iter(zprop_func func, void *cb, boolean_t show_all,
    boolean_t ordered, zfs_type_t type);
extern int zprop_get_list(libzfs_handle_t *, char *, zprop_list_t **,
    zfs_type_t);
extern void zprop_free_list(zprop_list_t *);

#define	ZFS_GET_NCOLS	5

typedef enum {
	GET_COL_NONE,
	GET_COL_NAME,
	GET_COL_PROPERTY,
	GET_COL_VALUE,
	GET_COL_RECVD,
	GET_COL_SOURCE
} zfs_get_column_t;

/*
 * Functions for printing zfs or zpool properties
 */
typedef struct zprop_get_cbdata {
	int cb_sources;
	zfs_get_column_t cb_columns[ZFS_GET_NCOLS];
	int cb_colwidths[ZFS_GET_NCOLS + 1];
	boolean_t cb_scripted;
	boolean_t cb_literal;
	boolean_t cb_first;
	zprop_list_t *cb_proplist;
	zfs_type_t cb_type;
} zprop_get_cbdata_t;

void zprop_print_one_property(const char *, zprop_get_cbdata_t *,
    const char *, const char *, zprop_source_t, const char *,
    const char *);

/*
 * Iterator functions.
 */
typedef int (*zfs_iter_f)(zfs_handle_t *, void *);
extern int zfs_iter_root(libzfs_handle_t *, zfs_iter_f, void *);
extern int zfs_iter_children(zfs_handle_t *, zfs_iter_f, void *);
extern int zfs_iter_dependents(zfs_handle_t *, boolean_t, zfs_iter_f, void *);
extern int zfs_iter_filesystems(zfs_handle_t *, zfs_iter_f, void *);
extern int zfs_iter_snapshots(zfs_handle_t *, boolean_t, zfs_iter_f, void *);
extern int zfs_iter_snapshots_sorted(zfs_handle_t *, zfs_iter_f, void *);
extern int zfs_iter_snapspec(zfs_handle_t *, const char *, zfs_iter_f, void *);
extern int zfs_iter_bookmarks(zfs_handle_t *, zfs_iter_f, void *);

typedef struct get_all_cb {
	zfs_handle_t	**cb_handles;
	size_t		cb_alloc;
	size_t		cb_used;
	boolean_t	cb_verbose;
	int		(*cb_getone)(zfs_handle_t *, void *);
} get_all_cb_t;

void libzfs_add_handle(get_all_cb_t *, zfs_handle_t *);
int libzfs_dataset_cmp(const void *, const void *);

/*
 * Functions to create and destroy datasets.
 */
extern int zfs_create(libzfs_handle_t *, const char *, zfs_type_t,
    nvlist_t *);
extern int zfs_create_ancestors(libzfs_handle_t *, const char *);
extern int zfs_destroy(zfs_handle_t *, boolean_t);
extern int zfs_destroy_snaps(zfs_handle_t *, char *, boolean_t);
extern int zfs_destroy_snaps_nvl(libzfs_handle_t *, nvlist_t *, boolean_t);
extern int zfs_clone(zfs_handle_t *, const char *, nvlist_t *);
extern int zfs_snapshot(libzfs_handle_t *, const char *, boolean_t, nvlist_t *);
extern int zfs_snapshot_nvl(libzfs_handle_t *hdl, nvlist_t *snaps,
    nvlist_t *props);
extern int zfs_rollback(zfs_handle_t *, zfs_handle_t *, boolean_t);
extern int zfs_rename(zfs_handle_t *, const char *, boolean_t, boolean_t);

typedef struct sendflags {
	/* print informational messages (ie, -v was specified) */
	boolean_t verbose;

	/* recursive send  (ie, -R) */
	boolean_t replicate;

	/* for incrementals, do all intermediate snapshots */
	boolean_t doall;

	/* if dataset is a clone, do incremental from its origin */
	boolean_t fromorigin;

	/* do deduplication */
	boolean_t dedup;

	/* send properties (ie, -p) */
	boolean_t props;

	/* do not send (no-op, ie. -n) */
	boolean_t dryrun;

	/* parsable verbose output (ie. -P) */
	boolean_t parsable;

	/* show progress (ie. -v) */
	boolean_t progress;

	/* large blocks (>128K) are permitted */
	boolean_t largeblock;

	/* WRITE_EMBEDDED records of type DATA are permitted */
	boolean_t embed_data;
} sendflags_t;

typedef boolean_t (snapfilter_cb_t)(zfs_handle_t *, void *);

extern int zfs_send(zfs_handle_t *, const char *, const char *,
    sendflags_t *, int, snapfilter_cb_t, void *, nvlist_t **);
extern int zfs_send_one(zfs_handle_t *, const char *, int, enum lzc_send_flags);

extern int zfs_promote(zfs_handle_t *);
extern int zfs_hold(zfs_handle_t *, const char *, const char *,
    boolean_t, int);
extern int zfs_hold_nvl(zfs_handle_t *, int, nvlist_t *);
extern int zfs_release(zfs_handle_t *, const char *, const char *, boolean_t);
extern int zfs_get_holds(zfs_handle_t *, nvlist_t **);
extern uint64_t zvol_volsize_to_reservation(uint64_t, nvlist_t *);

typedef int (*zfs_userspace_cb_t)(void *arg, const char *domain,
    uid_t rid, uint64_t space);

extern int zfs_userspace(zfs_handle_t *, zfs_userquota_prop_t,
    zfs_userspace_cb_t, void *);

extern int zfs_get_fsacl(zfs_handle_t *, nvlist_t **);
extern int zfs_set_fsacl(zfs_handle_t *, boolean_t, nvlist_t *);

typedef struct recvflags {
	/* print informational messages (ie, -v was specified) */
	boolean_t verbose;

	/* the destination is a prefix, not the exact fs (ie, -d) */
	boolean_t isprefix;

	/*
	 * Only the tail of the sent snapshot path is appended to the
	 * destination to determine the received snapshot name (ie, -e).
	 */
	boolean_t istail;

	/* do not actually do the recv, just check if it would work (ie, -n) */
	boolean_t dryrun;

	/* rollback/destroy filesystems as necessary (eg, -F) */
	boolean_t force;

	/* set "canmount=off" on all modified filesystems */
	boolean_t canmountoff;

	/* byteswap flag is used internally; callers need not specify */
	boolean_t byteswap;

	/* do not mount file systems as they are extracted (private) */
	boolean_t nomount;
} recvflags_t;

extern int zfs_receive(libzfs_handle_t *, const char *, recvflags_t *,
    int, avl_tree_t *);

typedef enum diff_flags {
	ZFS_DIFF_PARSEABLE = 0x1,
	ZFS_DIFF_TIMESTAMP = 0x2,
	ZFS_DIFF_CLASSIFY = 0x4
} diff_flags_t;

extern int zfs_show_diffs(zfs_handle_t *, int, const char *, const char *,
    int);

/*
 * Miscellaneous functions.
 */
extern const char *zfs_type_to_name(zfs_type_t);
extern void zfs_refresh_properties(zfs_handle_t *);
extern int zfs_name_valid(const char *, zfs_type_t);
extern zfs_handle_t *zfs_path_to_zhandle(libzfs_handle_t *, char *, zfs_type_t);
extern boolean_t zfs_dataset_exists(libzfs_handle_t *, const char *,
    zfs_type_t);
extern int zfs_spa_version(zfs_handle_t *, int *);
extern boolean_t zfs_bookmark_exists(const char *path);
extern int zfs_append_partition(char *path, size_t max_len);
extern int zfs_resolve_shortname(const char *name, char *path, size_t pathlen);
extern int zfs_strcmp_pathname(char *name, char *cmp_name, int wholedisk);

/*
 * Mount support functions.
 */
extern boolean_t is_mounted(libzfs_handle_t *, const char *special, char **);
extern boolean_t zfs_is_mounted(zfs_handle_t *, char **);
extern int zfs_mount(zfs_handle_t *, const char *, int);
extern int zfs_unmount(zfs_handle_t *, const char *, int);
extern int zfs_unmountall(zfs_handle_t *, int);

/*
 * Share support functions.
 */
extern boolean_t zfs_is_shared(zfs_handle_t *);
extern int zfs_share(zfs_handle_t *);
extern int zfs_unshare(zfs_handle_t *);

/*
 * Protocol-specific share support functions.
 */
extern boolean_t zfs_is_shared_nfs(zfs_handle_t *, char **);
extern boolean_t zfs_is_shared_smb(zfs_handle_t *, char **);
extern int zfs_share_nfs(zfs_handle_t *);
extern int zfs_share_smb(zfs_handle_t *);
extern int zfs_shareall(zfs_handle_t *);
extern int zfs_unshare_nfs(zfs_handle_t *, const char *);
extern int zfs_unshare_smb(zfs_handle_t *, const char *);
extern int zfs_unshareall_nfs(zfs_handle_t *);
extern int zfs_unshareall_smb(zfs_handle_t *);
extern int zfs_unshareall_bypath(zfs_handle_t *, const char *);
extern int zfs_unshareall(zfs_handle_t *);
extern int zfs_deleg_share_nfs(libzfs_handle_t *, char *, char *, char *,
    void *, void *, int, zfs_share_op_t);

/*
 * Utility function to convert a number to a human-readable form.
 */
extern void zfs_nicenum(uint64_t, char *, size_t);
extern int zfs_nicestrtonum(libzfs_handle_t *, const char *, uint64_t *);

/*
 * Utility functions to run an external process.
 */
#define	STDOUT_VERBOSE	0x01
#define	STDERR_VERBOSE	0x02

int libzfs_run_process(const char *, char **, int flags);

/*
 * Given a device or file, determine if it is part of a pool.
 */
extern int zpool_in_use(libzfs_handle_t *, int, pool_state_t *, char **,
    boolean_t *);

/*
 * Label manipulation.
 */
extern int zpool_read_label(int, nvlist_t **, int *);
extern int zpool_clear_label(int);

/*
 * Management interfaces for SMB ACL files
 */

int zfs_smb_acl_add(libzfs_handle_t *, char *, char *, char *);
int zfs_smb_acl_remove(libzfs_handle_t *, char *, char *, char *);
int zfs_smb_acl_purge(libzfs_handle_t *, char *, char *);
int zfs_smb_acl_rename(libzfs_handle_t *, char *, char *, char *, char *);

/*
 * Enable and disable datasets within a pool by mounting/unmounting and
 * sharing/unsharing them.
 */
extern int zpool_enable_datasets(zpool_handle_t *, const char *, int);
extern int zpool_disable_datasets(zpool_handle_t *, boolean_t);

/*
 * Mappings between vdev and FRU.
 */
extern void libzfs_fru_refresh(libzfs_handle_t *);
extern const char *libzfs_fru_lookup(libzfs_handle_t *, const char *);
extern const char *libzfs_fru_devpath(libzfs_handle_t *, const char *);
extern boolean_t libzfs_fru_compare(libzfs_handle_t *, const char *,
    const char *);
extern boolean_t libzfs_fru_notself(libzfs_handle_t *, const char *);
extern int zpool_fru_set(zpool_handle_t *, uint64_t, const char *);

#ifdef	__cplusplus
}
#endif

#endif	/* _LIBZFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/libzfs_core.h                                                           0100644 0000000 0000000 00000004146 13045171016 016362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_LIBZFS_CORE_H
#define	_LIBZFS_CORE_H

#include <libnvpair.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/fs/zfs.h>

#ifdef	__cplusplus
extern "C" {
#endif

int libzfs_core_init(void);
void libzfs_core_fini(void);

int lzc_snapshot(nvlist_t *, nvlist_t *, nvlist_t **);
int lzc_create(const char *, dmu_objset_type_t, nvlist_t *);
int lzc_clone(const char *, const char *, nvlist_t *);
int lzc_destroy_snaps(nvlist_t *, boolean_t, nvlist_t **);
int lzc_bookmark(nvlist_t *, nvlist_t **);
int lzc_get_bookmarks(const char *, nvlist_t *, nvlist_t **);
int lzc_destroy_bookmarks(nvlist_t *, nvlist_t **);

int lzc_snaprange_space(const char *, const char *, uint64_t *);

int lzc_hold(nvlist_t *, int, nvlist_t **);
int lzc_release(nvlist_t *, nvlist_t **);
int lzc_get_holds(const char *, nvlist_t **);

enum lzc_send_flags {
	LZC_SEND_FLAG_EMBED_DATA = 1 << 0,
	LZC_SEND_FLAG_LARGE_BLOCK = 1 << 1
};

int lzc_send(const char *, const char *, int, enum lzc_send_flags);
int lzc_receive(const char *, nvlist_t *, const char *, boolean_t, int);
int lzc_send_space(const char *, const char *, uint64_t *);

boolean_t lzc_exists(const char *);

int lzc_rollback(const char *, char *, int);

#ifdef	__cplusplus
}
#endif

#endif	/* _LIBZFS_CORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/libzfs_impl.h                                                           0100644 0000000 0000000 00000015060 13045171016 016370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER SART
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_LIBZFS_IMPL_H
#define	_LIBZFS_IMPL_H

#include <sys/dmu.h>
#include <sys/fs/zfs.h>
#include <sys/zfs_ioctl.h>
#include <sys/spa.h>
#include <sys/nvpair.h>

#include <libuutil.h>
#include <libzfs.h>
#include <libshare.h>
#include <libzfs_core.h>

#if defined(HAVE_LIBTOPO)
#include <fm/libtopo.h>
#endif /* HAVE_LIBTOPO */

#ifdef	__cplusplus
extern "C" {
#endif

#ifdef	VERIFY
#undef	VERIFY
#endif
#define	VERIFY	verify

typedef struct libzfs_fru {
	char *zf_device;
	char *zf_fru;
	struct libzfs_fru *zf_chain;
	struct libzfs_fru *zf_next;
} libzfs_fru_t;

struct libzfs_handle {
	int libzfs_error;
	int libzfs_fd;
	FILE *libzfs_mnttab;
	FILE *libzfs_sharetab;
	zpool_handle_t *libzfs_pool_handles;
	uu_avl_pool_t *libzfs_ns_avlpool;
	uu_avl_t *libzfs_ns_avl;
	uint64_t libzfs_ns_gen;
	int libzfs_desc_active;
	char libzfs_action[1024];
	char libzfs_desc[1024];
	int libzfs_printerr;
	int libzfs_storeerr; /* stuff error messages into buffer */
	void *libzfs_sharehdl; /* libshare handle */
	uint_t libzfs_shareflags;
	boolean_t libzfs_mnttab_enable;
	avl_tree_t libzfs_mnttab_cache;
	int libzfs_pool_iter;
#if defined(HAVE_LIBTOPO)
	topo_hdl_t *libzfs_topo_hdl;
	libzfs_fru_t **libzfs_fru_hash;
	libzfs_fru_t *libzfs_fru_list;
#endif /* HAVE_LIBTOPO */
	char libzfs_chassis_id[256];
};

#define	ZFSSHARE_MISS	0x01	/* Didn't find entry in cache */

struct zfs_handle {
	libzfs_handle_t *zfs_hdl;
	zpool_handle_t *zpool_hdl;
	char zfs_name[ZFS_MAXNAMELEN];
	zfs_type_t zfs_type; /* type including snapshot */
	zfs_type_t zfs_head_type; /* type excluding snapshot */
	dmu_objset_stats_t zfs_dmustats;
	nvlist_t *zfs_props;
	nvlist_t *zfs_user_props;
	nvlist_t *zfs_recvd_props;
	boolean_t zfs_mntcheck;
	char *zfs_mntopts;
	uint8_t *zfs_props_table;
};

/*
 * This is different from checking zfs_type, because it will also catch
 * snapshots of volumes.
 */
#define	ZFS_IS_VOLUME(zhp) ((zhp)->zfs_head_type == ZFS_TYPE_VOLUME)

struct zpool_handle {
	libzfs_handle_t *zpool_hdl;
	zpool_handle_t *zpool_next;
	char zpool_name[ZPOOL_MAXNAMELEN];
	int zpool_state;
	size_t zpool_config_size;
	nvlist_t *zpool_config;
	nvlist_t *zpool_old_config;
	nvlist_t *zpool_props;
	diskaddr_t zpool_start_block;
};

typedef enum {
	PROTO_NFS = 0,
	PROTO_SMB = 1,
	PROTO_END = 2
} zfs_share_proto_t;

/*
 * The following can be used as a bitmask and any new values
 * added must preserve that capability.
 */
typedef enum {
	SHARED_NOT_SHARED = 0x0,
	SHARED_NFS = 0x2,
	SHARED_SMB = 0x4
} zfs_share_type_t;

int zfs_error(libzfs_handle_t *, int, const char *);
int zfs_error_fmt(libzfs_handle_t *, int, const char *, ...);
void zfs_error_aux(libzfs_handle_t *, const char *, ...);
void *zfs_alloc(libzfs_handle_t *, size_t);
void *zfs_realloc(libzfs_handle_t *, void *, size_t, size_t);
char *zfs_asprintf(libzfs_handle_t *, const char *, ...);
char *zfs_strdup(libzfs_handle_t *, const char *);
int no_memory(libzfs_handle_t *);

int zfs_standard_error(libzfs_handle_t *, int, const char *);
int zfs_standard_error_fmt(libzfs_handle_t *, int, const char *, ...);
int zpool_standard_error(libzfs_handle_t *, int, const char *);
int zpool_standard_error_fmt(libzfs_handle_t *, int, const char *, ...);

int get_dependents(libzfs_handle_t *, boolean_t, const char *, char ***,
    size_t *);
zfs_handle_t *make_dataset_handle_zc(libzfs_handle_t *, zfs_cmd_t *);
zfs_handle_t *make_dataset_simple_handle_zc(zfs_handle_t *, zfs_cmd_t *);

int zprop_parse_value(libzfs_handle_t *, nvpair_t *, int, zfs_type_t,
    nvlist_t *, char **, uint64_t *, const char *);
int zprop_expand_list(libzfs_handle_t *hdl, zprop_list_t **plp,
    zfs_type_t type);

/*
 * Use this changelist_gather() flag to force attempting mounts
 * on each change node regardless of whether or not it is currently
 * mounted.
 */
#define	CL_GATHER_MOUNT_ALWAYS	1

typedef struct prop_changelist prop_changelist_t;

int zcmd_alloc_dst_nvlist(libzfs_handle_t *, zfs_cmd_t *, size_t);
int zcmd_write_src_nvlist(libzfs_handle_t *, zfs_cmd_t *, nvlist_t *);
int zcmd_write_conf_nvlist(libzfs_handle_t *, zfs_cmd_t *, nvlist_t *);
int zcmd_expand_dst_nvlist(libzfs_handle_t *, zfs_cmd_t *);
int zcmd_read_dst_nvlist(libzfs_handle_t *, zfs_cmd_t *, nvlist_t **);
void zcmd_free_nvlists(zfs_cmd_t *);

int changelist_prefix(prop_changelist_t *);
int changelist_postfix(prop_changelist_t *);
void changelist_rename(prop_changelist_t *, const char *, const char *);
void changelist_remove(prop_changelist_t *, const char *);
void changelist_free(prop_changelist_t *);
prop_changelist_t *changelist_gather(zfs_handle_t *, zfs_prop_t, int, int);
int changelist_unshare(prop_changelist_t *, zfs_share_proto_t *);
int changelist_haszonedchild(prop_changelist_t *);

void remove_mountpoint(zfs_handle_t *);
int create_parents(libzfs_handle_t *, char *, int);
boolean_t isa_child_of(const char *dataset, const char *parent);

zfs_handle_t *make_dataset_handle(libzfs_handle_t *, const char *);
zfs_handle_t *make_bookmark_handle(zfs_handle_t *, const char *,
    nvlist_t *props);

int zpool_open_silent(libzfs_handle_t *, const char *, zpool_handle_t **);

boolean_t zpool_name_valid(libzfs_handle_t *, boolean_t, const char *);

int zfs_validate_name(libzfs_handle_t *hdl, const char *path, int type,
    boolean_t modifying);

void namespace_clear(libzfs_handle_t *);

/*
 * libshare (sharemgr) interfaces used internally.
 */

extern int zfs_init_libshare(libzfs_handle_t *, int);
extern void zfs_uninit_libshare(libzfs_handle_t *);
extern int zfs_parse_options(char *, zfs_share_proto_t);

extern int zfs_unshare_proto(zfs_handle_t *,
    const char *, zfs_share_proto_t *);

extern void libzfs_fru_clear(libzfs_handle_t *, boolean_t);

#ifdef	__cplusplus
}
#endif

#endif	/* _LIBZFS_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/src/zfs-0.6.5.9/include/linux/                                                                  0040755 0000000 0000000 00000000000 13077704276 015064  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/linux/Makefile.am                                                       0100644 0000000 0000000 00000001101 13045171016 017067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        COMMON_H =

KERNEL_H = \
	$(top_srcdir)/include/linux/dcache_compat.h \
	$(top_srcdir)/include/linux/xattr_compat.h \
	$(top_srcdir)/include/linux/vfs_compat.h \
	$(top_srcdir)/include/linux/blkdev_compat.h \
	$(top_srcdir)/include/linux/utsname_compat.h \
	$(top_srcdir)/include/linux/kmap_compat.h

USER_H =

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)

if CONFIG_USER
libzfsdir = $(includedir)/libzfs/linux
libzfs_HEADERS = $(COMMON_H) $(USER_H)
endif

if CONFIG_KERNEL
kerneldir = @prefix@/src/zfs-$(VERSION)/include/linux
kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/src/zfs-0.6.5.9/include/linux/Makefile.in                                                       0100644 0000000 0000000 00000060225 13045370526 017123  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = include/linux
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
	$(am__kernel_HEADERS_DIST) $(libzfs_HEADERS)
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__kernel_HEADERS_DIST = $(top_srcdir)/include/linux/dcache_compat.h \
	$(top_srcdir)/include/linux/xattr_compat.h \
	$(top_srcdir)/include/linux/vfs_compat.h \
	$(top_srcdir)/include/linux/blkdev_compat.h \
	$(top_srcdir)/include/linux/utsname_compat.h \
	$(top_srcdir)/include/linux/kmap_compat.h
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"
HEADERS = $(kernel_HEADERS) $(libzfs_HEADERS)
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
COMMON_H = 
KERNEL_H = \
	$(top_srcdir)/include/linux/dcache_compat.h \
	$(top_srcdir)/include/linux/xattr_compat.h \
	$(top_srcdir)/include/linux/vfs_compat.h \
	$(top_srcdir)/include/linux/blkdev_compat.h \
	$(top_srcdir)/include/linux/utsname_compat.h \
	$(top_srcdir)/include/linux/kmap_compat.h

USER_H = 
EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)
@CONFIG_USER_TRUE@libzfsdir = $(includedir)/libzfs/linux
@CONFIG_USER_TRUE@libzfs_HEADERS = $(COMMON_H) $(USER_H)
@CONFIG_KERNEL_TRUE@kerneldir = @prefix@/src/zfs-$(VERSION)/include/linux
@CONFIG_KERNEL_TRUE@kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
all: all-am

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/linux/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu include/linux/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
install-kernelHEADERS: $(kernel_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(kerneldir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(kerneldir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(kerneldir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(kerneldir)" || exit $$?; \
	done

uninstall-kernelHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(kerneldir)'; $(am__uninstall_files_from_dir)
install-libzfsHEADERS: $(libzfs_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libzfsdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libzfsdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libzfsdir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libzfsdir)" || exit $$?; \
	done

uninstall-libzfsHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(libzfsdir)'; $(am__uninstall_files_from_dir)

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(HEADERS)
installdirs:
	for dir in "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am: install-kernelHEADERS install-libzfsHEADERS

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-kernelHEADERS uninstall-libzfsHEADERS

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libtool cscopelist-am ctags ctags-am distclean \
	distclean-generic distclean-libtool distclean-tags distdir dvi \
	dvi-am html html-am info info-am install install-am \
	install-data install-data-am install-dvi install-dvi-am \
	install-exec install-exec-am install-html install-html-am \
	install-info install-info-am install-kernelHEADERS \
	install-libzfsHEADERS install-man install-pdf install-pdf-am \
	install-ps install-ps-am install-strip installcheck \
	installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-kernelHEADERS uninstall-libzfsHEADERS


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                                                           usr/src/zfs-0.6.5.9/include/linux/blkdev_compat.h                                                   0100644 0000000 0000000 00000037264 13045171016 020041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (C) 2011 Lawrence Livermore National Security, LLC.
 * Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 * Written by Brian Behlendorf <behlendorf1@llnl.gov>.
 * LLNL-CODE-403049.
 */

#ifndef _ZFS_BLKDEV_H
#define	_ZFS_BLKDEV_H

#include <linux/blkdev.h>
#include <linux/elevator.h>

#ifndef HAVE_FMODE_T
typedef unsigned __bitwise__ fmode_t;
#endif /* HAVE_FMODE_T */

/*
 * 4.7 - 4.x API,
 * The blk_queue_write_cache() interface has replaced blk_queue_flush()
 * interface.  However, the new interface is GPL-only thus we implement
 * our own trivial wrapper when the GPL-only version is detected.
 *
 * 2.6.36 - 4.6 API,
 * The blk_queue_flush() interface has replaced blk_queue_ordered()
 * interface.  However, while the old interface was available to all the
 * new one is GPL-only.   Thus if the GPL-only version is detected we
 * implement our own trivial helper.
 *
 * 2.6.x - 2.6.35
 * Legacy blk_queue_ordered() interface.
 */
static inline void
blk_queue_set_write_cache(struct request_queue *q, bool wc, bool fua)
{
#if defined(HAVE_BLK_QUEUE_WRITE_CACHE_GPL_ONLY)
	spin_lock_irq(q->queue_lock);
	if (wc)
		queue_flag_set(QUEUE_FLAG_WC, q);
	else
		queue_flag_clear(QUEUE_FLAG_WC, q);
	if (fua)
		queue_flag_set(QUEUE_FLAG_FUA, q);
	else
		queue_flag_clear(QUEUE_FLAG_FUA, q);
	spin_unlock_irq(q->queue_lock);
#elif defined(HAVE_BLK_QUEUE_WRITE_CACHE)
	blk_queue_write_cache(q, wc, fua);
#elif defined(HAVE_BLK_QUEUE_FLUSH_GPL_ONLY)
	if (wc)
		q->flush_flags |= REQ_FLUSH;
	if (fua)
		q->flush_flags |= REQ_FUA;
#elif defined(HAVE_BLK_QUEUE_FLUSH)
	blk_queue_flush(q, (wc ? REQ_FLUSH : 0) | (fua ? REQ_FUA : 0));
#else
	blk_queue_ordered(q, QUEUE_ORDERED_DRAIN, NULL);
#endif
}

/*
 * Most of the blk_* macros were removed in 2.6.36.  Ostensibly this was
 * done to improve readability and allow easier grepping.  However, from
 * a portability stand point the macros are helpful.  Therefore the needed
 * macros are redefined here if they are missing from the kernel.
 */
#ifndef blk_fs_request
#define	blk_fs_request(rq)	((rq)->cmd_type == REQ_TYPE_FS)
#endif

/*
 * 2.6.27 API change,
 * The blk_queue_stackable() queue flag was added in 2.6.27 to handle dm
 * stacking drivers.  Prior to this request stacking drivers were detected
 * by checking (q->request_fn == NULL), for earlier kernels we revert to
 * this legacy behavior.
 */
#ifndef blk_queue_stackable
#define	blk_queue_stackable(q)	((q)->request_fn == NULL)
#endif

/*
 * 2.6.34 API change,
 * The blk_queue_max_hw_sectors() function replaces blk_queue_max_sectors().
 */
#ifndef HAVE_BLK_QUEUE_MAX_HW_SECTORS
#define	blk_queue_max_hw_sectors __blk_queue_max_hw_sectors
static inline void
__blk_queue_max_hw_sectors(struct request_queue *q, unsigned int max_hw_sectors)
{
	blk_queue_max_sectors(q, max_hw_sectors);
}
#endif

/*
 * 2.6.34 API change,
 * The blk_queue_max_segments() function consolidates
 * blk_queue_max_hw_segments() and blk_queue_max_phys_segments().
 */
#ifndef HAVE_BLK_QUEUE_MAX_SEGMENTS
#define	blk_queue_max_segments __blk_queue_max_segments
static inline void
__blk_queue_max_segments(struct request_queue *q, unsigned short max_segments)
{
	blk_queue_max_phys_segments(q, max_segments);
	blk_queue_max_hw_segments(q, max_segments);
}
#endif

#ifndef HAVE_GET_DISK_RO
static inline int
get_disk_ro(struct gendisk *disk)
{
	int policy = 0;

	if (disk->part[0])
		policy = disk->part[0]->policy;

	return (policy);
}
#endif /* HAVE_GET_DISK_RO */

#ifdef HAVE_BIO_BVEC_ITER
#define	BIO_BI_SECTOR(bio)	(bio)->bi_iter.bi_sector
#define	BIO_BI_SIZE(bio)	(bio)->bi_iter.bi_size
#define	BIO_BI_IDX(bio)		(bio)->bi_iter.bi_idx
#define	bio_for_each_segment4(bv, bvp, b, i)	\
	bio_for_each_segment((bv), (b), (i))
typedef struct bvec_iter bvec_iterator_t;
#else
#define	BIO_BI_SECTOR(bio)	(bio)->bi_sector
#define	BIO_BI_SIZE(bio)	(bio)->bi_size
#define	BIO_BI_IDX(bio)		(bio)->bi_idx
#define	bio_for_each_segment4(bv, bvp, b, i)	\
	bio_for_each_segment((bvp), (b), (i))
typedef int bvec_iterator_t;
#endif

/*
 * Portable helper for correctly setting the FAILFAST flags.  The
 * correct usage has changed 3 times from 2.6.12 to 2.6.38.
 */
static inline void
bio_set_flags_failfast(struct block_device *bdev, int *flags)
{
#ifdef CONFIG_BUG
	/*
	 * Disable FAILFAST for loopback devices because of the
	 * following incorrect BUG_ON() in loop_make_request().
	 * This support is also disabled for md devices because the
	 * test suite layers md devices on top of loopback devices.
	 * This may be removed when the loopback driver is fixed.
	 *
	 *   BUG_ON(!lo || (rw != READ && rw != WRITE));
	 */
	if ((MAJOR(bdev->bd_dev) == LOOP_MAJOR) ||
	    (MAJOR(bdev->bd_dev) == MD_MAJOR))
		return;

#ifdef BLOCK_EXT_MAJOR
	if (MAJOR(bdev->bd_dev) == BLOCK_EXT_MAJOR)
		return;
#endif /* BLOCK_EXT_MAJOR */
#endif /* CONFIG_BUG */

#if defined(HAVE_BIO_RW_FAILFAST_DTD)
	/* BIO_RW_FAILFAST_* preferred interface from 2.6.28 - 2.6.35 */
	*flags |= (
	    (1 << BIO_RW_FAILFAST_DEV) |
	    (1 << BIO_RW_FAILFAST_TRANSPORT) |
	    (1 << BIO_RW_FAILFAST_DRIVER));
#elif defined(HAVE_REQ_FAILFAST_MASK)
	/*
	 * REQ_FAILFAST_* preferred interface from 2.6.36 - 2.6.xx,
	 * the BIO_* and REQ_* flags were unified under REQ_* flags.
	 */
	*flags |= REQ_FAILFAST_MASK;
#else
#error "Undefined block IO FAILFAST interface."
#endif
}

/*
 * Maximum disk label length, it may be undefined for some kernels.
 */
#ifndef DISK_NAME_LEN
#define	DISK_NAME_LEN	32
#endif /* DISK_NAME_LEN */

/*
 * 4.3 API change
 * The bio_endio() prototype changed slightly.  These are helper
 * macro's to ensure the prototype and invocation are handled.
 */
#ifdef HAVE_1ARG_BIO_END_IO_T
#define	BIO_END_IO_PROTO(fn, x, z)	static void fn(struct bio *x)
#define	BIO_END_IO(bio, error)		bio->bi_error = error; bio_endio(bio);
#else
#define	BIO_END_IO_PROTO(fn, x, z)	static void fn(struct bio *x, int z)
#define	BIO_END_IO(bio, error)		bio_endio(bio, error);
#endif /* HAVE_1ARG_BIO_END_IO_T */

/*
 * 2.6.38 - 2.6.x API,
 *   blkdev_get_by_path()
 *   blkdev_put()
 *
 * 2.6.28 - 2.6.37 API,
 *   open_bdev_exclusive()
 *   close_bdev_exclusive()
 *
 * 2.6.12 - 2.6.27 API,
 *   open_bdev_excl()
 *   close_bdev_excl()
 *
 * Used to exclusively open a block device from within the kernel.
 */
#if defined(HAVE_BLKDEV_GET_BY_PATH)
#define	vdev_bdev_open(path, md, hld)	blkdev_get_by_path(path, \
					    (md) | FMODE_EXCL, hld)
#define	vdev_bdev_close(bdev, md)	blkdev_put(bdev, (md) | FMODE_EXCL)
#elif defined(HAVE_OPEN_BDEV_EXCLUSIVE)
#define	vdev_bdev_open(path, md, hld)	open_bdev_exclusive(path, md, hld)
#define	vdev_bdev_close(bdev, md)	close_bdev_exclusive(bdev, md)
#else
#define	vdev_bdev_open(path, md, hld)	open_bdev_excl(path, md, hld)
#define	vdev_bdev_close(bdev, md)	close_bdev_excl(bdev)
#endif /* HAVE_BLKDEV_GET_BY_PATH | HAVE_OPEN_BDEV_EXCLUSIVE */

/*
 * 2.6.22 API change
 * The function invalidate_bdev() lost it's second argument because
 * it was unused.
 */
#ifdef HAVE_1ARG_INVALIDATE_BDEV
#define	vdev_bdev_invalidate(bdev)	invalidate_bdev(bdev)
#else
#define	vdev_bdev_invalidate(bdev)	invalidate_bdev(bdev, 1)
#endif /* HAVE_1ARG_INVALIDATE_BDEV */

/*
 * 2.6.27 API change
 * The function was exported for use, prior to this it existed but the
 * symbol was not exported.
 *
 * 4.4.0-6.21 API change for Ubuntu
 * lookup_bdev() gained a second argument, FMODE_*, to check inode permissions.
 */
#ifdef HAVE_1ARG_LOOKUP_BDEV
#define	vdev_lookup_bdev(path)	lookup_bdev(path)
#else
#ifdef HAVE_2ARGS_LOOKUP_BDEV
#define	vdev_lookup_bdev(path)	lookup_bdev(path, 0)
#else
#define	vdev_lookup_bdev(path)	ERR_PTR(-ENOTSUP)
#endif /* HAVE_2ARGS_LOOKUP_BDEV */
#endif /* HAVE_1ARG_LOOKUP_BDEV */

/*
 * 2.6.30 API change
 * To ensure good performance preferentially use the physical block size
 * for proper alignment.  The physical size is supposed to be the internal
 * sector size used by the device.  This is often 4096 byte for AF devices,
 * while a smaller 512 byte logical size is supported for compatibility.
 *
 * Unfortunately, many drives still misreport their physical sector size.
 * For devices which are known to lie you may need to manually set this
 * at pool creation time with 'zpool create -o ashift=12 ...'.
 *
 * When the physical block size interface isn't available, we fall back to
 * the logical block size interface and then the older hard sector size.
 */
#ifdef HAVE_BDEV_PHYSICAL_BLOCK_SIZE
#define	vdev_bdev_block_size(bdev)	bdev_physical_block_size(bdev)
#else
#ifdef HAVE_BDEV_LOGICAL_BLOCK_SIZE
#define	vdev_bdev_block_size(bdev)	bdev_logical_block_size(bdev)
#else
#define	vdev_bdev_block_size(bdev)	bdev_hardsect_size(bdev)
#endif /* HAVE_BDEV_LOGICAL_BLOCK_SIZE */
#endif /* HAVE_BDEV_PHYSICAL_BLOCK_SIZE */

#ifndef HAVE_BIO_SET_OP_ATTRS
/*
 * Kernels without bio_set_op_attrs use bi_rw for the bio flags.
 */
static inline void
bio_set_op_attrs(struct bio *bio, unsigned rw, unsigned flags)
{
	bio->bi_rw |= rw | flags;
}
#endif

/*
 * bio_set_flush - Set the appropriate flags in a bio to guarantee
 * data are on non-volatile media on completion.
 *
 * 2.6.X - 2.6.36 API,
 *   WRITE_BARRIER - Tells the block layer to commit all previously submitted
 *   writes to stable storage before this one is started and that the current
 *   write is on stable storage upon completion.  Also prevents reordering
 *   on both sides of the current operation.
 *
 * 2.6.37 - 4.8 API,
 *   Introduce  WRITE_FLUSH, WRITE_FUA, and WRITE_FLUSH_FUA flags as a
 *   replacement for WRITE_BARRIER to allow expressing richer semantics
 *   to the block layer.  It's up to the block layer to implement the
 *   semantics correctly. Use the WRITE_FLUSH_FUA flag combination.
 *
 * 4.8 - 4.9 API,
 *   REQ_FLUSH was renamed to REQ_PREFLUSH.  For consistency with previous
 *   ZoL releases, prefer the WRITE_FLUSH_FUA flag set if it's available.
 *
 * 4.10 API,
 *   The read/write flags and their modifiers, including WRITE_FLUSH,
 *   WRITE_FUA and WRITE_FLUSH_FUA were removed from fs.h in
 *   torvalds/linux@70fd7614 and replaced by direct flag modification
 *   of the REQ_ flags in bio->bi_opf.  Use REQ_PREFLUSH.
 */
static inline void
bio_set_flush(struct bio *bio)
{
#if defined(WRITE_BARRIER)	/* < 2.6.37 */
	bio_set_op_attrs(bio, 0, WRITE_BARRIER);
#elif defined(WRITE_FLUSH_FUA)	/* >= 2.6.37 and <= 4.9 */
	bio_set_op_attrs(bio, 0, WRITE_FLUSH_FUA);
#elif defined(REQ_PREFLUSH)	/* >= 4.10 */
	bio_set_op_attrs(bio, 0, REQ_PREFLUSH);
#else
#error	"Allowing the build will cause bio_set_flush requests to be ignored."
	"Please file an issue report at: "
	"https://github.com/zfsonlinux/zfs/issues/new"
#endif
}

/*
 * 4.8 - 4.x API,
 *   REQ_OP_FLUSH
 *
 * 4.8-rc0 - 4.8-rc1,
 *   REQ_PREFLUSH
 *
 * 2.6.36 - 4.7 API,
 *   REQ_FLUSH
 *
 * 2.6.x - 2.6.35 API,
 *   HAVE_BIO_RW_BARRIER
 *
 * Used to determine if a cache flush has been requested.  This check has
 * been left intentionally broad in order to cover both a legacy flush
 * and the new preflush behavior introduced in Linux 4.8.  This is correct
 * in all cases but may have a performance impact for some kernels.  It
 * has the advantage of minimizing kernel specific changes in the zvol code.
 *
 * Note that 2.6.32 era kernels provide both BIO_RW_BARRIER and REQ_FLUSH,
 * where BIO_RW_BARRIER is the correct interface.  Therefore, it is important
 * that the HAVE_BIO_RW_BARRIER check occur before the REQ_FLUSH check.
 */
static inline boolean_t
bio_is_flush(struct bio *bio)
{
#if defined(HAVE_REQ_OP_FLUSH) && defined(HAVE_BIO_BI_OPF)
	return ((bio_op(bio) == REQ_OP_FLUSH) || (bio->bi_opf & REQ_PREFLUSH));
#elif defined(REQ_PREFLUSH) && defined(HAVE_BIO_BI_OPF)
	return (bio->bi_opf & REQ_PREFLUSH);
#elif defined(REQ_PREFLUSH) && !defined(HAVE_BIO_BI_OPF)
	return (bio->bi_rw & REQ_PREFLUSH);
#elif defined(HAVE_BIO_RW_BARRIER)
	return (bio->bi_rw & (1 << BIO_RW_BARRIER));
#elif defined(REQ_FLUSH)
	return (bio->bi_rw & REQ_FLUSH);
#else
#error	"Allowing the build will cause flush requests to be ignored. Please "
	"file an issue report at: https://github.com/zfsonlinux/zfs/issues/new"
#endif
}

/*
 * 4.8 - 4.x API,
 *   REQ_FUA flag moved to bio->bi_opf
 *
 * 2.6.x - 4.7 API,
 *   REQ_FUA
 */
static inline boolean_t
bio_is_fua(struct bio *bio)
{
#if defined(HAVE_BIO_BI_OPF)
	return (bio->bi_opf & REQ_FUA);
#elif defined(REQ_FUA)
	return (bio->bi_rw & REQ_FUA);
#else
#error	"Allowing the build will cause fua requests to be ignored. Please "
	"file an issue report at: https://github.com/zfsonlinux/zfs/issues/new"
#endif
}

/*
 * 4.8 - 4.x API,
 *   REQ_OP_DISCARD
 *
 * 2.6.36 - 4.7 API,
 *   REQ_DISCARD
 *
 * 2.6.28 - 2.6.35 API,
 *   BIO_RW_DISCARD
 *
 * In all cases the normal I/O path is used for discards.  The only
 * difference is how the kernel tags individual I/Os as discards.
 *
 * Note that 2.6.32 era kernels provide both BIO_RW_DISCARD and REQ_DISCARD,
 * where BIO_RW_DISCARD is the correct interface.  Therefore, it is important
 * that the HAVE_BIO_RW_DISCARD check occur before the REQ_DISCARD check.
 */
static inline boolean_t
bio_is_discard(struct bio *bio)
{
#if defined(HAVE_REQ_OP_DISCARD)
	return (bio_op(bio) == REQ_OP_DISCARD);
#elif defined(HAVE_BIO_RW_DISCARD)
	return (bio->bi_rw & (1 << BIO_RW_DISCARD));
#elif defined(REQ_DISCARD)
	return (bio->bi_rw & REQ_DISCARD);
#else
#error	"Allowing the build will cause discard requests to become writes "
	"potentially triggering the DMU_MAX_ACCESS assertion. Please file "
	"an issue report at: https://github.com/zfsonlinux/zfs/issues/new"
#endif
}

/*
 * 4.8 - 4.x API,
 *   REQ_OP_SECURE_ERASE
 *
 * 2.6.36 - 4.7 API,
 *   REQ_SECURE
 *
 * 2.6.x - 2.6.35 API,
 *   Unsupported by kernel
 */
static inline boolean_t
bio_is_secure_erase(struct bio *bio)
{
#if defined(HAVE_REQ_OP_SECURE_ERASE)
	return (bio_op(bio) == REQ_OP_SECURE_ERASE);
#elif defined(REQ_SECURE)
	return (bio->bi_rw & REQ_SECURE);
#else
	return (0);
#endif
}

/*
 * 2.6.33 API change
 * Discard granularity and alignment restrictions may now be set.  For
 * older kernels which do not support this it is safe to skip it.
 */
#ifdef HAVE_DISCARD_GRANULARITY
static inline void
blk_queue_discard_granularity(struct request_queue *q, unsigned int dg)
{
	q->limits.discard_granularity = dg;
}
#else
#define	blk_queue_discard_granularity(x, dg)	((void)0)
#endif /* HAVE_DISCARD_GRANULARITY */

/*
 * Default Linux IO Scheduler,
 * Setting the scheduler to noop will allow the Linux IO scheduler to
 * still perform front and back merging, while leaving the request
 * ordering and prioritization to the ZFS IO scheduler.
 */
#define	VDEV_SCHEDULER			"noop"

/*
 * A common holder for vdev_bdev_open() is used to relax the exclusive open
 * semantics slightly.  Internal vdev disk callers may pass VDEV_HOLDER to
 * allow them to open the device multiple times.  Other kernel callers and
 * user space processes which don't pass this value will get EBUSY.  This is
 * currently required for the correct operation of hot spares.
 */
#define	VDEV_HOLDER			((void *)0x2401de7)

#ifndef HAVE_GENERIC_IO_ACCT
#define	generic_start_io_acct(rw, slen, part)		((void)0)
#define	generic_end_io_acct(rw, part, start_jiffies)	((void)0)
#endif

#endif /* _ZFS_BLKDEV_H */
                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/linux/dcache_compat.h                                                   0100644 0000000 0000000 00000004772 13045171016 017777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (C) 2011 Lawrence Livermore National Security, LLC.
 */

#ifndef _ZFS_DCACHE_H
#define	_ZFS_DCACHE_H

#include <linux/dcache.h>

#define	dname(dentry)	((char *)((dentry)->d_name.name))
#define	dlen(dentry)	((int)((dentry)->d_name.len))

#ifndef HAVE_D_MAKE_ROOT
#define	d_make_root(inode)	d_alloc_root(inode)
#endif /* HAVE_D_MAKE_ROOT */

/*
 * 2.6.30 API change,
 * The const keyword was added to the 'struct dentry_operations' in
 * the dentry structure.  To handle this we define an appropriate
 * dentry_operations_t typedef which can be used.
 */
#ifdef HAVE_CONST_DENTRY_OPERATIONS
typedef const struct dentry_operations	dentry_operations_t;
#else
typedef struct dentry_operations	dentry_operations_t;
#endif

/*
 * 2.6.38 API change,
 * Added d_set_d_op() helper function which sets some flags in
 * dentry->d_flags based on which operations are defined.
 */
#ifndef HAVE_D_SET_D_OP
static inline void
d_set_d_op(struct dentry *dentry, dentry_operations_t *op)
{
	dentry->d_op = op;
}
#endif /* HAVE_D_SET_D_OP */

/*
 * 2.6.38 API addition,
 * Added d_clear_d_op() helper function which clears some flags and the
 * registered dentry->d_op table.  This is required because d_set_d_op()
 * issues a warning when the dentry operations table is already set.
 * For the .zfs control directory to work properly we must be able to
 * override the default operations table and register custom .d_automount
 * and .d_revalidate callbacks.
 */
static inline void
d_clear_d_op(struct dentry *dentry)
{
#ifdef HAVE_D_SET_D_OP
	dentry->d_op = NULL;
	dentry->d_flags &= ~(
	    DCACHE_OP_HASH | DCACHE_OP_COMPARE |
	    DCACHE_OP_REVALIDATE | DCACHE_OP_DELETE);
#endif /* HAVE_D_SET_D_OP */
}

#endif /* _ZFS_DCACHE_H */
      usr/src/zfs-0.6.5.9/include/linux/kmap_compat.h                                                     0100644 0000000 0000000 00000002432 13045171016 017507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2015 by Chunwei Chen. All rights reserved.
 */

#ifndef _ZFS_KMAP_H
#define	_ZFS_KMAP_H

#include <linux/highmem.h>

#ifdef HAVE_1ARG_KMAP_ATOMIC
/* 2.6.37 API change */
#define	zfs_kmap_atomic(page, km_type)		kmap_atomic(page)
#define	zfs_kunmap_atomic(addr, km_type)	kunmap_atomic(addr)
#else
#define	zfs_kmap_atomic(page, km_type)		kmap_atomic(page, km_type)
#define	zfs_kunmap_atomic(addr, km_type)	kunmap_atomic(addr, km_type)
#endif

#endif	/* _ZFS_KMAP_H */
                                                                                                                                                                                                                                      usr/src/zfs-0.6.5.9/include/linux/utsname_compat.h                                                  0100644 0000000 0000000 00000001703 13045171016 020233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

#ifndef	_ZFS_UTSNAME_H
#define	_ZFS_UTSNAME_H

#include <linux/utsname.h>

typedef struct new_utsname	utsname_t;

#endif	/* _ZFS_UTSNAME_H */
                                                             usr/src/zfs-0.6.5.9/include/linux/vfs_compat.h                                                      0100644 0000000 0000000 00000022773 13045171016 017367  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (C) 2011 Lawrence Livermore National Security, LLC.
 * Copyright (C) 2015 Jrg Thalheim.
 */

#ifndef _ZFS_VFS_H
#define	_ZFS_VFS_H

#include <sys/taskq.h>
#include <linux/backing-dev.h>

/*
 * 2.6.28 API change,
 * Added insert_inode_locked() helper function, prior to this most callers
 * used insert_inode_hash().  The older method doesn't check for collisions
 * in the inode_hashtable but it still acceptible for use.
 */
#ifndef HAVE_INSERT_INODE_LOCKED
static inline int
insert_inode_locked(struct inode *ip)
{
	insert_inode_hash(ip);
	return (0);
}
#endif /* HAVE_INSERT_INODE_LOCKED */

/*
 * 2.6.35 API change,
 * Add truncate_setsize() if it is not exported by the Linux kernel.
 *
 * Truncate the inode and pages associated with the inode. The pages are
 * unmapped and removed from cache.
 */
#ifndef HAVE_TRUNCATE_SETSIZE
static inline void
truncate_setsize(struct inode *ip, loff_t new)
{
	struct address_space *mapping = ip->i_mapping;

	i_size_write(ip, new);

	unmap_mapping_range(mapping, new + PAGE_SIZE - 1, 0, 1);
	truncate_inode_pages(mapping, new);
	unmap_mapping_range(mapping, new + PAGE_SIZE - 1, 0, 1);
}
#endif /* HAVE_TRUNCATE_SETSIZE */

/*
 * 2.6.32 - 2.6.33, bdi_setup_and_register() is not available.
 * 2.6.34 - 3.19, bdi_setup_and_register() takes 3 arguments.
 * 4.0 - x.y, bdi_setup_and_register() takes 2 arguments.
 */
#if defined(HAVE_2ARGS_BDI_SETUP_AND_REGISTER)
static inline int
zpl_bdi_setup_and_register(struct backing_dev_info *bdi, char *name)
{
	return (bdi_setup_and_register(bdi, name));
}
#elif defined(HAVE_3ARGS_BDI_SETUP_AND_REGISTER)
static inline int
zpl_bdi_setup_and_register(struct backing_dev_info *bdi, char *name)
{
	return (bdi_setup_and_register(bdi, name, BDI_CAP_MAP_COPY));
}
#else
extern atomic_long_t zfs_bdi_seq;

static inline int
zpl_bdi_setup_and_register(struct backing_dev_info *bdi, char *name)
{
	char tmp[32];
	int error;

	bdi->name = name;
	bdi->capabilities = BDI_CAP_MAP_COPY;

	error = bdi_init(bdi);
	if (error)
		return (error);

	sprintf(tmp, "%.28s%s", name, "-%d");
	error = bdi_register(bdi, NULL, tmp,
	    atomic_long_inc_return(&zfs_bdi_seq));
	if (error) {
		bdi_destroy(bdi);
		return (error);
	}

	return (error);
}
#endif

/*
 * 2.6.38 API change,
 * LOOKUP_RCU flag introduced to distinguish rcu-walk from ref-walk cases.
 */
#ifndef LOOKUP_RCU
#define	LOOKUP_RCU	0x0
#endif /* LOOKUP_RCU */

/*
 * 3.2-rc1 API change,
 * Add set_nlink() if it is not exported by the Linux kernel.
 *
 * i_nlink is read-only in Linux 3.2, but it can be set directly in
 * earlier kernels.
 */
#ifndef HAVE_SET_NLINK
static inline void
set_nlink(struct inode *inode, unsigned int nlink)
{
	inode->i_nlink = nlink;
}
#endif /* HAVE_SET_NLINK */

/*
 * 3.3 API change,
 * The VFS .create, .mkdir and .mknod callbacks were updated to take a
 * umode_t type rather than an int.  To cleanly handle both definitions
 * the zpl_umode_t type is introduced and set accordingly.
 */
#ifdef HAVE_MKDIR_UMODE_T
typedef	umode_t		zpl_umode_t;
#else
typedef	int		zpl_umode_t;
#endif

/*
 * 3.5 API change,
 * The clear_inode() function replaces end_writeback() and introduces an
 * ordering change regarding when the inode_sync_wait() occurs.  See the
 * configure check in config/kernel-clear-inode.m4 for full details.
 */
#if defined(HAVE_EVICT_INODE) && !defined(HAVE_CLEAR_INODE)
#define	clear_inode(ip)		end_writeback(ip)
#endif /* HAVE_EVICT_INODE && !HAVE_CLEAR_INODE */

/*
 * 3.6 API change,
 * The sget() helper function now takes the mount flags as an argument.
 */
#ifdef HAVE_5ARG_SGET
#define	zpl_sget(type, cmp, set, fl, mtd)	sget(type, cmp, set, fl, mtd)
#else
#define	zpl_sget(type, cmp, set, fl, mtd)	sget(type, cmp, set, mtd)
#endif /* HAVE_5ARG_SGET */

#if defined(SEEK_HOLE) && defined(SEEK_DATA) && !defined(HAVE_LSEEK_EXECUTE)
static inline loff_t
lseek_execute(
	struct file *filp,
	struct inode *inode,
	loff_t offset,
	loff_t maxsize)
{
	if (offset < 0 && !(filp->f_mode & FMODE_UNSIGNED_OFFSET))
		return (-EINVAL);

	if (offset > maxsize)
		return (-EINVAL);

	if (offset != filp->f_pos) {
		spin_lock(&filp->f_lock);
		filp->f_pos = offset;
		filp->f_version = 0;
		spin_unlock(&filp->f_lock);
	}

	return (offset);
}
#endif /* SEEK_HOLE && SEEK_DATA && !HAVE_LSEEK_EXECUTE */

#if defined(CONFIG_FS_POSIX_ACL)
/*
 * These functions safely approximates the behavior of posix_acl_release()
 * which cannot be used because it calls the GPL-only symbol kfree_rcu().
 * The in-kernel version, which can access the RCU, frees the ACLs after
 * the grace period expires.  Because we're unsure how long that grace
 * period may be this implementation conservatively delays for 60 seconds.
 * This is several orders of magnitude larger than expected grace period.
 * At 60 seconds the kernel will also begin issuing RCU stall warnings.
 */
#include <linux/posix_acl.h>

#if defined(HAVE_POSIX_ACL_RELEASE) && !defined(HAVE_POSIX_ACL_RELEASE_GPL_ONLY)
#define	zpl_posix_acl_release(arg)		posix_acl_release(arg)
#else
void zpl_posix_acl_release_impl(struct posix_acl *);

static inline void
zpl_posix_acl_release(struct posix_acl *acl)
{
	if ((acl == NULL) || (acl == ACL_NOT_CACHED))
		return;

	if (atomic_dec_and_test(&acl->a_refcount))
		zpl_posix_acl_release_impl(acl);
}
#endif /* HAVE_POSIX_ACL_RELEASE */

#ifdef HAVE_SET_CACHED_ACL_USABLE
#define	zpl_set_cached_acl(ip, ty, n)		set_cached_acl(ip, ty, n)
#define	zpl_forget_cached_acl(ip, ty)		forget_cached_acl(ip, ty)
#else
static inline void
zpl_set_cached_acl(struct inode *ip, int type, struct posix_acl *newer) {
	struct posix_acl *older = NULL;

	spin_lock(&ip->i_lock);

	if ((newer != ACL_NOT_CACHED) && (newer != NULL))
		posix_acl_dup(newer);

	switch (type) {
	case ACL_TYPE_ACCESS:
		older = ip->i_acl;
		rcu_assign_pointer(ip->i_acl, newer);
		break;
	case ACL_TYPE_DEFAULT:
		older = ip->i_default_acl;
		rcu_assign_pointer(ip->i_default_acl, newer);
		break;
	}

	spin_unlock(&ip->i_lock);

	zpl_posix_acl_release(older);
}

static inline void
zpl_forget_cached_acl(struct inode *ip, int type) {
	zpl_set_cached_acl(ip, type, (struct posix_acl *)ACL_NOT_CACHED);
}
#endif /* HAVE_SET_CACHED_ACL_USABLE */

#ifndef HAVE___POSIX_ACL_CHMOD
#ifdef HAVE_POSIX_ACL_CHMOD
#define	__posix_acl_chmod(acl, gfp, mode)	posix_acl_chmod(acl, gfp, mode)
#define	__posix_acl_create(acl, gfp, mode)	posix_acl_create(acl, gfp, mode)
#else
static inline int
__posix_acl_chmod(struct posix_acl **acl, int flags, umode_t umode) {
	struct posix_acl *oldacl = *acl;
	mode_t mode = umode;
	int error;

	*acl = posix_acl_clone(*acl, flags);
	zpl_posix_acl_release(oldacl);

	if (!(*acl))
		return (-ENOMEM);

	error = posix_acl_chmod_masq(*acl, mode);
	if (error) {
		zpl_posix_acl_release(*acl);
		*acl = NULL;
	}

	return (error);
}

static inline int
__posix_acl_create(struct posix_acl **acl, int flags, umode_t *umodep) {
	struct posix_acl *oldacl = *acl;
	mode_t mode = *umodep;
	int error;

	*acl = posix_acl_clone(*acl, flags);
	zpl_posix_acl_release(oldacl);

	if (!(*acl))
		return (-ENOMEM);

	error = posix_acl_create_masq(*acl, &mode);
	*umodep = mode;

	if (error < 0) {
		zpl_posix_acl_release(*acl);
		*acl = NULL;
	}

	return (error);
}
#endif /* HAVE_POSIX_ACL_CHMOD */
#endif /* HAVE___POSIX_ACL_CHMOD */

#ifdef HAVE_POSIX_ACL_EQUIV_MODE_UMODE_T
typedef umode_t zpl_equivmode_t;
#else
typedef mode_t zpl_equivmode_t;
#endif /* HAVE_POSIX_ACL_EQUIV_MODE_UMODE_T */

/*
 * 4.8 API change,
 * posix_acl_valid() now must be passed a namespace, the namespace from
 * from super block associated with the given inode is used for this purpose.
 */
#ifdef HAVE_POSIX_ACL_VALID_WITH_NS
#define	zpl_posix_acl_valid(ip, acl)  posix_acl_valid(ip->i_sb->s_user_ns, acl)
#else
#define	zpl_posix_acl_valid(ip, acl)  posix_acl_valid(acl)
#endif

#endif /* CONFIG_FS_POSIX_ACL */

/*
 * 2.6.38 API change,
 * The is_owner_or_cap() function was renamed to inode_owner_or_capable().
 */
#ifdef HAVE_INODE_OWNER_OR_CAPABLE
#define	zpl_inode_owner_or_capable(ip)		inode_owner_or_capable(ip)
#else
#define	zpl_inode_owner_or_capable(ip)		is_owner_or_cap(ip)
#endif /* HAVE_INODE_OWNER_OR_CAPABLE */

/*
 * 3.19 API change
 * struct access f->f_dentry->d_inode was replaced by accessor function
 * file_inode(f)
 */
#ifndef HAVE_FILE_INODE
static inline struct inode *file_inode(const struct file *f)
{
	return (f->f_dentry->d_inode);
}
#endif /* HAVE_FILE_INODE */

/*
 * 2.6.38 API change
 */
#ifdef HAVE_FOLLOW_DOWN_ONE
#define	zpl_follow_down_one(path)		follow_down_one(path)
#define	zpl_follow_up(path)			follow_up(path)
#else
#define	zpl_follow_down_one(path)		follow_down(path)
#define	zpl_follow_up(path)			follow_up(path)
#endif

/*
 * 4.9 API change
 */
#ifndef HAVE_SETATTR_PREPARE
static inline int
setattr_prepare(struct dentry *dentry, struct iattr *ia)
{
	return (inode_change_ok(dentry->d_inode, ia));
}
#endif

#endif /* _ZFS_VFS_H */
     usr/src/zfs-0.6.5.9/include/linux/xattr_compat.h                                                    0100644 0000000 0000000 00000016765 13045171016 017737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (C) 2011 Lawrence Livermore National Security, LLC.
 */

#ifndef _ZFS_XATTR_H
#define	_ZFS_XATTR_H

#include <linux/posix_acl_xattr.h>

/*
 * 2.6.35 API change,
 * The const keyword was added to the 'struct xattr_handler' in the
 * generic Linux super_block structure.  To handle this we define an
 * appropriate xattr_handler_t typedef which can be used.  This was
 * the preferred solution because it keeps the code clean and readable.
 */
#ifdef HAVE_CONST_XATTR_HANDLER
typedef const struct xattr_handler	xattr_handler_t;
#else
typedef struct xattr_handler		xattr_handler_t;
#endif

/*
 * 3.7 API change,
 * Preferred XATTR_NAME_* definitions introduced, these are mapped to
 * the previous definitions for older kernels.
 */
#ifndef XATTR_NAME_POSIX_ACL_DEFAULT
#define	XATTR_NAME_POSIX_ACL_DEFAULT	POSIX_ACL_XATTR_DEFAULT
#endif

#ifndef XATTR_NAME_POSIX_ACL_ACCESS
#define	XATTR_NAME_POSIX_ACL_ACCESS	POSIX_ACL_XATTR_ACCESS
#endif

/*
 * 4.5 API change,
 */
#if defined(HAVE_XATTR_LIST_SIMPLE)
#define	ZPL_XATTR_LIST_WRAPPER(fn)					\
static bool								\
fn(struct dentry *dentry)						\
{									\
	return (!!__ ## fn(dentry->d_inode, NULL, 0, NULL, 0));		\
}
/*
 * 4.4 API change,
 */
#elif defined(HAVE_XATTR_LIST_DENTRY)
#define	ZPL_XATTR_LIST_WRAPPER(fn)					\
static size_t								\
fn(struct dentry *dentry, char *list, size_t list_size,			\
    const char *name, size_t name_len, int type)			\
{									\
	return (__ ## fn(dentry->d_inode,				\
	    list, list_size, name, name_len));				\
}
/*
 * 2.6.33 API change,
 */
#elif defined(HAVE_XATTR_LIST_HANDLER)
#define	ZPL_XATTR_LIST_WRAPPER(fn)					\
static size_t								\
fn(const struct xattr_handler *handler, struct dentry *dentry,		\
    char *list, size_t list_size, const char *name, size_t name_len)	\
{									\
	return (__ ## fn(dentry->d_inode,				\
	    list, list_size, name, name_len));				\
}
/*
 * 2.6.32 API
 */
#elif defined(HAVE_XATTR_LIST_INODE)
#define	ZPL_XATTR_LIST_WRAPPER(fn)					\
static size_t								\
fn(struct inode *ip, char *list, size_t list_size,			\
    const char *name, size_t name_len)					\
{									\
	return (__ ## fn(ip, list, list_size, name, name_len));		\
}
#endif

/*
 * 4.7 API change,
 * The xattr_handler->get() callback was changed to take a both dentry and
 * inode, because the dentry might not be attached to an inode yet.
 */
#if defined(HAVE_XATTR_GET_DENTRY_INODE)
#define	ZPL_XATTR_GET_WRAPPER(fn)					\
static int								\
fn(const struct xattr_handler *handler, struct dentry *dentry,		\
    struct inode *inode, const char *name, void *buffer, size_t size)	\
{									\
	return (__ ## fn(inode, name, buffer, size));			\
}
/*
 * 4.4 API change,
 * The xattr_handler->get() callback was changed to take a xattr_handler,
 * and handler_flags argument was removed and should be accessed by
 * handler->flags.
 */
#elif defined(HAVE_XATTR_GET_HANDLER)
#define	ZPL_XATTR_GET_WRAPPER(fn)					\
static int								\
fn(const struct xattr_handler *handler, struct dentry *dentry,		\
    const char *name, void *buffer, size_t size)			\
{									\
	return (__ ## fn(dentry->d_inode, name, buffer, size));		\
}
/*
 * 2.6.33 API change,
 * The xattr_handler->get() callback was changed to take a dentry
 * instead of an inode, and a handler_flags argument was added.
 */
#elif defined(HAVE_XATTR_GET_DENTRY)
#define	ZPL_XATTR_GET_WRAPPER(fn)					\
static int								\
fn(struct dentry *dentry, const char *name, void *buffer, size_t size,	\
    int unused_handler_flags)						\
{									\
	return (__ ## fn(dentry->d_inode, name, buffer, size));		\
}
/*
 * 2.6.32 API
 */
#elif defined(HAVE_XATTR_GET_INODE)
#define	ZPL_XATTR_GET_WRAPPER(fn)					\
static int								\
fn(struct inode *ip, const char *name, void *buffer, size_t size)	\
{									\
	return (__ ## fn(ip, name, buffer, size));			\
}
#endif

/*
 * 4.7 API change,
 * The xattr_handler->set() callback was changed to take a both dentry and
 * inode, because the dentry might not be attached to an inode yet.
 */
#if defined(HAVE_XATTR_SET_DENTRY_INODE)
#define	ZPL_XATTR_SET_WRAPPER(fn)					\
static int								\
fn(const struct xattr_handler *handler, struct dentry *dentry,		\
    struct inode *inode, const char *name, const void *buffer,		\
    size_t size, int flags)						\
{									\
	return (__ ## fn(inode, name, buffer, size, flags));		\
}
/*
 * 4.4 API change,
 * The xattr_handler->set() callback was changed to take a xattr_handler,
 * and handler_flags argument was removed and should be accessed by
 * handler->flags.
 */
#elif defined(HAVE_XATTR_SET_HANDLER)
#define	ZPL_XATTR_SET_WRAPPER(fn)					\
static int								\
fn(const struct xattr_handler *handler, struct dentry *dentry,		\
    const char *name, const void *buffer, size_t size, int flags)	\
{									\
	return (__ ## fn(dentry->d_inode, name, buffer, size, flags));	\
}
/*
 * 2.6.33 API change,
 * The xattr_handler->set() callback was changed to take a dentry
 * instead of an inode, and a handler_flags argument was added.
 */
#elif defined(HAVE_XATTR_SET_DENTRY)
#define	ZPL_XATTR_SET_WRAPPER(fn)					\
static int								\
fn(struct dentry *dentry, const char *name, const void *buffer,		\
    size_t size, int flags, int unused_handler_flags)			\
{									\
	return (__ ## fn(dentry->d_inode, name, buffer, size, flags));	\
}
/*
 * 2.6.32 API
 */
#elif defined(HAVE_XATTR_SET_INODE)
#define	ZPL_XATTR_SET_WRAPPER(fn)					\
static int								\
fn(struct inode *ip, const char *name, const void *buffer,		\
    size_t size, int flags)						\
{									\
	return (__ ## fn(ip, name, buffer, size, flags));		\
}
#endif

#ifdef HAVE_6ARGS_SECURITY_INODE_INIT_SECURITY
#define	zpl_security_inode_init_security(ip, dip, qstr, nm, val, len)	\
	security_inode_init_security(ip, dip, qstr, nm, val, len)
#else
#define	zpl_security_inode_init_security(ip, dip, qstr, nm, val, len)	\
	security_inode_init_security(ip, dip, nm, val, len)
#endif /* HAVE_6ARGS_SECURITY_INODE_INIT_SECURITY */

/*
 * Linux 3.7 API change. posix_acl_{from,to}_xattr gained the user_ns
 * parameter.  All callers are expected to pass the &init_user_ns which
 * is available through the init credential (kcred).
 */
#ifdef HAVE_POSIX_ACL_FROM_XATTR_USERNS
static inline struct posix_acl *
zpl_acl_from_xattr(const void *value, int size)
{
	return (posix_acl_from_xattr(kcred->user_ns, value, size));
}

static inline int
zpl_acl_to_xattr(struct posix_acl *acl, void *value, int size)
{
	return (posix_acl_to_xattr(kcred->user_ns, acl, value, size));
}

#else

static inline struct posix_acl *
zpl_acl_from_xattr(const void *value, int size)
{
	return (posix_acl_from_xattr(value, size));
}

static inline int
zpl_acl_to_xattr(struct posix_acl *acl, void *value, int size)
{
	return (posix_acl_to_xattr(acl, value, size));
}
#endif /* HAVE_POSIX_ACL_FROM_XATTR_USERNS */

#endif /* _ZFS_XATTR_H */
           usr/src/zfs-0.6.5.9/include/sys/                                                                    0040755 0000000 0000000 00000000000 13077704276 014543  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/Makefile.am                                                         0100644 0000000 0000000 00000010344 13045171016 016557  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = fm fs

COMMON_H = \
	$(top_srcdir)/include/sys/arc.h \
	$(top_srcdir)/include/sys/arc_impl.h \
	$(top_srcdir)/include/sys/avl.h \
	$(top_srcdir)/include/sys/avl_impl.h \
	$(top_srcdir)/include/sys/blkptr.h \
	$(top_srcdir)/include/sys/bplist.h \
	$(top_srcdir)/include/sys/bpobj.h \
	$(top_srcdir)/include/sys/bptree.h \
	$(top_srcdir)/include/sys/dbuf.h \
	$(top_srcdir)/include/sys/ddt.h \
	$(top_srcdir)/include/sys/dmu.h \
	$(top_srcdir)/include/sys/dmu_impl.h \
	$(top_srcdir)/include/sys/dmu_objset.h \
	$(top_srcdir)/include/sys/dmu_send.h \
	$(top_srcdir)/include/sys/dmu_traverse.h \
	$(top_srcdir)/include/sys/dmu_tx.h \
	$(top_srcdir)/include/sys/dmu_zfetch.h \
	$(top_srcdir)/include/sys/dnode.h \
	$(top_srcdir)/include/sys/dsl_bookmark.h \
	$(top_srcdir)/include/sys/dsl_dataset.h \
	$(top_srcdir)/include/sys/dsl_deadlist.h \
	$(top_srcdir)/include/sys/dsl_deleg.h \
	$(top_srcdir)/include/sys/dsl_destroy.h \
	$(top_srcdir)/include/sys/dsl_dir.h \
	$(top_srcdir)/include/sys/dsl_pool.h \
	$(top_srcdir)/include/sys/dsl_prop.h \
	$(top_srcdir)/include/sys/dsl_scan.h \
	$(top_srcdir)/include/sys/dsl_synctask.h \
	$(top_srcdir)/include/sys/dsl_userhold.h \
	$(top_srcdir)/include/sys/efi_partition.h \
	$(top_srcdir)/include/sys/metaslab.h \
	$(top_srcdir)/include/sys/metaslab_impl.h \
	$(top_srcdir)/include/sys/mntent.h \
	$(top_srcdir)/include/sys/multilist.h \
	$(top_srcdir)/include/sys/nvpair.h \
	$(top_srcdir)/include/sys/nvpair_impl.h \
	$(top_srcdir)/include/sys/range_tree.h \
	$(top_srcdir)/include/sys/refcount.h \
	$(top_srcdir)/include/sys/rrwlock.h \
	$(top_srcdir)/include/sys/sa.h \
	$(top_srcdir)/include/sys/sa_impl.h \
	$(top_srcdir)/include/sys/sdt.h \
	$(top_srcdir)/include/sys/spa_boot.h \
	$(top_srcdir)/include/sys/space_map.h \
	$(top_srcdir)/include/sys/space_reftree.h \
	$(top_srcdir)/include/sys/spa.h \
	$(top_srcdir)/include/sys/spa_impl.h \
	$(top_srcdir)/include/sys/trace.h \
	$(top_srcdir)/include/sys/trace_acl.h \
	$(top_srcdir)/include/sys/trace_arc.h \
	$(top_srcdir)/include/sys/trace_dbgmsg.h \
	$(top_srcdir)/include/sys/trace_dbuf.h \
	$(top_srcdir)/include/sys/trace_dmu.h \
	$(top_srcdir)/include/sys/trace_dnode.h \
	$(top_srcdir)/include/sys/trace_multilist.h \
	$(top_srcdir)/include/sys/trace_txg.h \
	$(top_srcdir)/include/sys/trace_zil.h \
	$(top_srcdir)/include/sys/trace_zrlock.h \
	$(top_srcdir)/include/sys/txg.h \
	$(top_srcdir)/include/sys/txg_impl.h \
	$(top_srcdir)/include/sys/u8_textprep_data.h \
	$(top_srcdir)/include/sys/u8_textprep.h \
	$(top_srcdir)/include/sys/uberblock.h \
	$(top_srcdir)/include/sys/uberblock_impl.h \
	$(top_srcdir)/include/sys/uio_impl.h \
	$(top_srcdir)/include/sys/unique.h \
	$(top_srcdir)/include/sys/uuid.h \
	$(top_srcdir)/include/sys/vdev_disk.h \
	$(top_srcdir)/include/sys/vdev_file.h \
	$(top_srcdir)/include/sys/vdev.h \
	$(top_srcdir)/include/sys/vdev_impl.h \
	$(top_srcdir)/include/sys/xvattr.h \
	$(top_srcdir)/include/sys/zap.h \
	$(top_srcdir)/include/sys/zap_impl.h \
	$(top_srcdir)/include/sys/zap_leaf.h \
	$(top_srcdir)/include/sys/zfeature.h \
	$(top_srcdir)/include/sys/zfs_acl.h \
	$(top_srcdir)/include/sys/zfs_context.h \
	$(top_srcdir)/include/sys/zfs_ctldir.h \
	$(top_srcdir)/include/sys/zfs_debug.h \
	$(top_srcdir)/include/sys/zfs_delay.h \
	$(top_srcdir)/include/sys/zfs_dir.h \
	$(top_srcdir)/include/sys/zfs_fuid.h \
	$(top_srcdir)/include/sys/zfs_rlock.h \
	$(top_srcdir)/include/sys/zfs_sa.h \
	$(top_srcdir)/include/sys/zfs_stat.h \
	$(top_srcdir)/include/sys/zfs_vfsops.h \
	$(top_srcdir)/include/sys/zfs_vnops.h \
	$(top_srcdir)/include/sys/zfs_znode.h \
	$(top_srcdir)/include/sys/zil.h \
	$(top_srcdir)/include/sys/zil_impl.h \
	$(top_srcdir)/include/sys/zio_checksum.h \
	$(top_srcdir)/include/sys/zio_compress.h \
	$(top_srcdir)/include/sys/zio.h \
	$(top_srcdir)/include/sys/zio_impl.h \
	$(top_srcdir)/include/sys/zrlock.h

KERNEL_H = \
	$(top_srcdir)/include/sys/zfs_ioctl.h \
	$(top_srcdir)/include/sys/zfs_onexit.h \
	${top_srcdir}/include/sys/zpl.h \
	$(top_srcdir)/include/sys/zvol.h

USER_H =

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)

if CONFIG_USER
libzfsdir = $(includedir)/libzfs/sys
libzfs_HEADERS = $(COMMON_H) $(USER_H)
endif

if CONFIG_KERNEL
kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys
kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
endif
                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/Makefile.in                                                         0100644 0000000 0000000 00000116743 13045370526 016611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = include/sys
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
	$(am__kernel_HEADERS_DIST) $(am__libzfs_HEADERS_DIST)
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__kernel_HEADERS_DIST = $(top_srcdir)/include/sys/arc.h \
	$(top_srcdir)/include/sys/arc_impl.h \
	$(top_srcdir)/include/sys/avl.h \
	$(top_srcdir)/include/sys/avl_impl.h \
	$(top_srcdir)/include/sys/blkptr.h \
	$(top_srcdir)/include/sys/bplist.h \
	$(top_srcdir)/include/sys/bpobj.h \
	$(top_srcdir)/include/sys/bptree.h \
	$(top_srcdir)/include/sys/dbuf.h \
	$(top_srcdir)/include/sys/ddt.h \
	$(top_srcdir)/include/sys/dmu.h \
	$(top_srcdir)/include/sys/dmu_impl.h \
	$(top_srcdir)/include/sys/dmu_objset.h \
	$(top_srcdir)/include/sys/dmu_send.h \
	$(top_srcdir)/include/sys/dmu_traverse.h \
	$(top_srcdir)/include/sys/dmu_tx.h \
	$(top_srcdir)/include/sys/dmu_zfetch.h \
	$(top_srcdir)/include/sys/dnode.h \
	$(top_srcdir)/include/sys/dsl_bookmark.h \
	$(top_srcdir)/include/sys/dsl_dataset.h \
	$(top_srcdir)/include/sys/dsl_deadlist.h \
	$(top_srcdir)/include/sys/dsl_deleg.h \
	$(top_srcdir)/include/sys/dsl_destroy.h \
	$(top_srcdir)/include/sys/dsl_dir.h \
	$(top_srcdir)/include/sys/dsl_pool.h \
	$(top_srcdir)/include/sys/dsl_prop.h \
	$(top_srcdir)/include/sys/dsl_scan.h \
	$(top_srcdir)/include/sys/dsl_synctask.h \
	$(top_srcdir)/include/sys/dsl_userhold.h \
	$(top_srcdir)/include/sys/efi_partition.h \
	$(top_srcdir)/include/sys/metaslab.h \
	$(top_srcdir)/include/sys/metaslab_impl.h \
	$(top_srcdir)/include/sys/mntent.h \
	$(top_srcdir)/include/sys/multilist.h \
	$(top_srcdir)/include/sys/nvpair.h \
	$(top_srcdir)/include/sys/nvpair_impl.h \
	$(top_srcdir)/include/sys/range_tree.h \
	$(top_srcdir)/include/sys/refcount.h \
	$(top_srcdir)/include/sys/rrwlock.h \
	$(top_srcdir)/include/sys/sa.h \
	$(top_srcdir)/include/sys/sa_impl.h \
	$(top_srcdir)/include/sys/sdt.h \
	$(top_srcdir)/include/sys/spa_boot.h \
	$(top_srcdir)/include/sys/space_map.h \
	$(top_srcdir)/include/sys/space_reftree.h \
	$(top_srcdir)/include/sys/spa.h \
	$(top_srcdir)/include/sys/spa_impl.h \
	$(top_srcdir)/include/sys/trace.h \
	$(top_srcdir)/include/sys/trace_acl.h \
	$(top_srcdir)/include/sys/trace_arc.h \
	$(top_srcdir)/include/sys/trace_dbgmsg.h \
	$(top_srcdir)/include/sys/trace_dbuf.h \
	$(top_srcdir)/include/sys/trace_dmu.h \
	$(top_srcdir)/include/sys/trace_dnode.h \
	$(top_srcdir)/include/sys/trace_multilist.h \
	$(top_srcdir)/include/sys/trace_txg.h \
	$(top_srcdir)/include/sys/trace_zil.h \
	$(top_srcdir)/include/sys/trace_zrlock.h \
	$(top_srcdir)/include/sys/txg.h \
	$(top_srcdir)/include/sys/txg_impl.h \
	$(top_srcdir)/include/sys/u8_textprep_data.h \
	$(top_srcdir)/include/sys/u8_textprep.h \
	$(top_srcdir)/include/sys/uberblock.h \
	$(top_srcdir)/include/sys/uberblock_impl.h \
	$(top_srcdir)/include/sys/uio_impl.h \
	$(top_srcdir)/include/sys/unique.h \
	$(top_srcdir)/include/sys/uuid.h \
	$(top_srcdir)/include/sys/vdev_disk.h \
	$(top_srcdir)/include/sys/vdev_file.h \
	$(top_srcdir)/include/sys/vdev.h \
	$(top_srcdir)/include/sys/vdev_impl.h \
	$(top_srcdir)/include/sys/xvattr.h \
	$(top_srcdir)/include/sys/zap.h \
	$(top_srcdir)/include/sys/zap_impl.h \
	$(top_srcdir)/include/sys/zap_leaf.h \
	$(top_srcdir)/include/sys/zfeature.h \
	$(top_srcdir)/include/sys/zfs_acl.h \
	$(top_srcdir)/include/sys/zfs_context.h \
	$(top_srcdir)/include/sys/zfs_ctldir.h \
	$(top_srcdir)/include/sys/zfs_debug.h \
	$(top_srcdir)/include/sys/zfs_delay.h \
	$(top_srcdir)/include/sys/zfs_dir.h \
	$(top_srcdir)/include/sys/zfs_fuid.h \
	$(top_srcdir)/include/sys/zfs_rlock.h \
	$(top_srcdir)/include/sys/zfs_sa.h \
	$(top_srcdir)/include/sys/zfs_stat.h \
	$(top_srcdir)/include/sys/zfs_vfsops.h \
	$(top_srcdir)/include/sys/zfs_vnops.h \
	$(top_srcdir)/include/sys/zfs_znode.h \
	$(top_srcdir)/include/sys/zil.h \
	$(top_srcdir)/include/sys/zil_impl.h \
	$(top_srcdir)/include/sys/zio_checksum.h \
	$(top_srcdir)/include/sys/zio_compress.h \
	$(top_srcdir)/include/sys/zio.h \
	$(top_srcdir)/include/sys/zio_impl.h \
	$(top_srcdir)/include/sys/zrlock.h \
	$(top_srcdir)/include/sys/zfs_ioctl.h \
	$(top_srcdir)/include/sys/zfs_onexit.h \
	${top_srcdir}/include/sys/zpl.h \
	$(top_srcdir)/include/sys/zvol.h
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"
am__libzfs_HEADERS_DIST = $(top_srcdir)/include/sys/arc.h \
	$(top_srcdir)/include/sys/arc_impl.h \
	$(top_srcdir)/include/sys/avl.h \
	$(top_srcdir)/include/sys/avl_impl.h \
	$(top_srcdir)/include/sys/blkptr.h \
	$(top_srcdir)/include/sys/bplist.h \
	$(top_srcdir)/include/sys/bpobj.h \
	$(top_srcdir)/include/sys/bptree.h \
	$(top_srcdir)/include/sys/dbuf.h \
	$(top_srcdir)/include/sys/ddt.h \
	$(top_srcdir)/include/sys/dmu.h \
	$(top_srcdir)/include/sys/dmu_impl.h \
	$(top_srcdir)/include/sys/dmu_objset.h \
	$(top_srcdir)/include/sys/dmu_send.h \
	$(top_srcdir)/include/sys/dmu_traverse.h \
	$(top_srcdir)/include/sys/dmu_tx.h \
	$(top_srcdir)/include/sys/dmu_zfetch.h \
	$(top_srcdir)/include/sys/dnode.h \
	$(top_srcdir)/include/sys/dsl_bookmark.h \
	$(top_srcdir)/include/sys/dsl_dataset.h \
	$(top_srcdir)/include/sys/dsl_deadlist.h \
	$(top_srcdir)/include/sys/dsl_deleg.h \
	$(top_srcdir)/include/sys/dsl_destroy.h \
	$(top_srcdir)/include/sys/dsl_dir.h \
	$(top_srcdir)/include/sys/dsl_pool.h \
	$(top_srcdir)/include/sys/dsl_prop.h \
	$(top_srcdir)/include/sys/dsl_scan.h \
	$(top_srcdir)/include/sys/dsl_synctask.h \
	$(top_srcdir)/include/sys/dsl_userhold.h \
	$(top_srcdir)/include/sys/efi_partition.h \
	$(top_srcdir)/include/sys/metaslab.h \
	$(top_srcdir)/include/sys/metaslab_impl.h \
	$(top_srcdir)/include/sys/mntent.h \
	$(top_srcdir)/include/sys/multilist.h \
	$(top_srcdir)/include/sys/nvpair.h \
	$(top_srcdir)/include/sys/nvpair_impl.h \
	$(top_srcdir)/include/sys/range_tree.h \
	$(top_srcdir)/include/sys/refcount.h \
	$(top_srcdir)/include/sys/rrwlock.h \
	$(top_srcdir)/include/sys/sa.h \
	$(top_srcdir)/include/sys/sa_impl.h \
	$(top_srcdir)/include/sys/sdt.h \
	$(top_srcdir)/include/sys/spa_boot.h \
	$(top_srcdir)/include/sys/space_map.h \
	$(top_srcdir)/include/sys/space_reftree.h \
	$(top_srcdir)/include/sys/spa.h \
	$(top_srcdir)/include/sys/spa_impl.h \
	$(top_srcdir)/include/sys/trace.h \
	$(top_srcdir)/include/sys/trace_acl.h \
	$(top_srcdir)/include/sys/trace_arc.h \
	$(top_srcdir)/include/sys/trace_dbgmsg.h \
	$(top_srcdir)/include/sys/trace_dbuf.h \
	$(top_srcdir)/include/sys/trace_dmu.h \
	$(top_srcdir)/include/sys/trace_dnode.h \
	$(top_srcdir)/include/sys/trace_multilist.h \
	$(top_srcdir)/include/sys/trace_txg.h \
	$(top_srcdir)/include/sys/trace_zil.h \
	$(top_srcdir)/include/sys/trace_zrlock.h \
	$(top_srcdir)/include/sys/txg.h \
	$(top_srcdir)/include/sys/txg_impl.h \
	$(top_srcdir)/include/sys/u8_textprep_data.h \
	$(top_srcdir)/include/sys/u8_textprep.h \
	$(top_srcdir)/include/sys/uberblock.h \
	$(top_srcdir)/include/sys/uberblock_impl.h \
	$(top_srcdir)/include/sys/uio_impl.h \
	$(top_srcdir)/include/sys/unique.h \
	$(top_srcdir)/include/sys/uuid.h \
	$(top_srcdir)/include/sys/vdev_disk.h \
	$(top_srcdir)/include/sys/vdev_file.h \
	$(top_srcdir)/include/sys/vdev.h \
	$(top_srcdir)/include/sys/vdev_impl.h \
	$(top_srcdir)/include/sys/xvattr.h \
	$(top_srcdir)/include/sys/zap.h \
	$(top_srcdir)/include/sys/zap_impl.h \
	$(top_srcdir)/include/sys/zap_leaf.h \
	$(top_srcdir)/include/sys/zfeature.h \
	$(top_srcdir)/include/sys/zfs_acl.h \
	$(top_srcdir)/include/sys/zfs_context.h \
	$(top_srcdir)/include/sys/zfs_ctldir.h \
	$(top_srcdir)/include/sys/zfs_debug.h \
	$(top_srcdir)/include/sys/zfs_delay.h \
	$(top_srcdir)/include/sys/zfs_dir.h \
	$(top_srcdir)/include/sys/zfs_fuid.h \
	$(top_srcdir)/include/sys/zfs_rlock.h \
	$(top_srcdir)/include/sys/zfs_sa.h \
	$(top_srcdir)/include/sys/zfs_stat.h \
	$(top_srcdir)/include/sys/zfs_vfsops.h \
	$(top_srcdir)/include/sys/zfs_vnops.h \
	$(top_srcdir)/include/sys/zfs_znode.h \
	$(top_srcdir)/include/sys/zil.h \
	$(top_srcdir)/include/sys/zil_impl.h \
	$(top_srcdir)/include/sys/zio_checksum.h \
	$(top_srcdir)/include/sys/zio_compress.h \
	$(top_srcdir)/include/sys/zio.h \
	$(top_srcdir)/include/sys/zio_impl.h \
	$(top_srcdir)/include/sys/zrlock.h
HEADERS = $(kernel_HEADERS) $(libzfs_HEADERS)
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
SUBDIRS = fm fs
COMMON_H = \
	$(top_srcdir)/include/sys/arc.h \
	$(top_srcdir)/include/sys/arc_impl.h \
	$(top_srcdir)/include/sys/avl.h \
	$(top_srcdir)/include/sys/avl_impl.h \
	$(top_srcdir)/include/sys/blkptr.h \
	$(top_srcdir)/include/sys/bplist.h \
	$(top_srcdir)/include/sys/bpobj.h \
	$(top_srcdir)/include/sys/bptree.h \
	$(top_srcdir)/include/sys/dbuf.h \
	$(top_srcdir)/include/sys/ddt.h \
	$(top_srcdir)/include/sys/dmu.h \
	$(top_srcdir)/include/sys/dmu_impl.h \
	$(top_srcdir)/include/sys/dmu_objset.h \
	$(top_srcdir)/include/sys/dmu_send.h \
	$(top_srcdir)/include/sys/dmu_traverse.h \
	$(top_srcdir)/include/sys/dmu_tx.h \
	$(top_srcdir)/include/sys/dmu_zfetch.h \
	$(top_srcdir)/include/sys/dnode.h \
	$(top_srcdir)/include/sys/dsl_bookmark.h \
	$(top_srcdir)/include/sys/dsl_dataset.h \
	$(top_srcdir)/include/sys/dsl_deadlist.h \
	$(top_srcdir)/include/sys/dsl_deleg.h \
	$(top_srcdir)/include/sys/dsl_destroy.h \
	$(top_srcdir)/include/sys/dsl_dir.h \
	$(top_srcdir)/include/sys/dsl_pool.h \
	$(top_srcdir)/include/sys/dsl_prop.h \
	$(top_srcdir)/include/sys/dsl_scan.h \
	$(top_srcdir)/include/sys/dsl_synctask.h \
	$(top_srcdir)/include/sys/dsl_userhold.h \
	$(top_srcdir)/include/sys/efi_partition.h \
	$(top_srcdir)/include/sys/metaslab.h \
	$(top_srcdir)/include/sys/metaslab_impl.h \
	$(top_srcdir)/include/sys/mntent.h \
	$(top_srcdir)/include/sys/multilist.h \
	$(top_srcdir)/include/sys/nvpair.h \
	$(top_srcdir)/include/sys/nvpair_impl.h \
	$(top_srcdir)/include/sys/range_tree.h \
	$(top_srcdir)/include/sys/refcount.h \
	$(top_srcdir)/include/sys/rrwlock.h \
	$(top_srcdir)/include/sys/sa.h \
	$(top_srcdir)/include/sys/sa_impl.h \
	$(top_srcdir)/include/sys/sdt.h \
	$(top_srcdir)/include/sys/spa_boot.h \
	$(top_srcdir)/include/sys/space_map.h \
	$(top_srcdir)/include/sys/space_reftree.h \
	$(top_srcdir)/include/sys/spa.h \
	$(top_srcdir)/include/sys/spa_impl.h \
	$(top_srcdir)/include/sys/trace.h \
	$(top_srcdir)/include/sys/trace_acl.h \
	$(top_srcdir)/include/sys/trace_arc.h \
	$(top_srcdir)/include/sys/trace_dbgmsg.h \
	$(top_srcdir)/include/sys/trace_dbuf.h \
	$(top_srcdir)/include/sys/trace_dmu.h \
	$(top_srcdir)/include/sys/trace_dnode.h \
	$(top_srcdir)/include/sys/trace_multilist.h \
	$(top_srcdir)/include/sys/trace_txg.h \
	$(top_srcdir)/include/sys/trace_zil.h \
	$(top_srcdir)/include/sys/trace_zrlock.h \
	$(top_srcdir)/include/sys/txg.h \
	$(top_srcdir)/include/sys/txg_impl.h \
	$(top_srcdir)/include/sys/u8_textprep_data.h \
	$(top_srcdir)/include/sys/u8_textprep.h \
	$(top_srcdir)/include/sys/uberblock.h \
	$(top_srcdir)/include/sys/uberblock_impl.h \
	$(top_srcdir)/include/sys/uio_impl.h \
	$(top_srcdir)/include/sys/unique.h \
	$(top_srcdir)/include/sys/uuid.h \
	$(top_srcdir)/include/sys/vdev_disk.h \
	$(top_srcdir)/include/sys/vdev_file.h \
	$(top_srcdir)/include/sys/vdev.h \
	$(top_srcdir)/include/sys/vdev_impl.h \
	$(top_srcdir)/include/sys/xvattr.h \
	$(top_srcdir)/include/sys/zap.h \
	$(top_srcdir)/include/sys/zap_impl.h \
	$(top_srcdir)/include/sys/zap_leaf.h \
	$(top_srcdir)/include/sys/zfeature.h \
	$(top_srcdir)/include/sys/zfs_acl.h \
	$(top_srcdir)/include/sys/zfs_context.h \
	$(top_srcdir)/include/sys/zfs_ctldir.h \
	$(top_srcdir)/include/sys/zfs_debug.h \
	$(top_srcdir)/include/sys/zfs_delay.h \
	$(top_srcdir)/include/sys/zfs_dir.h \
	$(top_srcdir)/include/sys/zfs_fuid.h \
	$(top_srcdir)/include/sys/zfs_rlock.h \
	$(top_srcdir)/include/sys/zfs_sa.h \
	$(top_srcdir)/include/sys/zfs_stat.h \
	$(top_srcdir)/include/sys/zfs_vfsops.h \
	$(top_srcdir)/include/sys/zfs_vnops.h \
	$(top_srcdir)/include/sys/zfs_znode.h \
	$(top_srcdir)/include/sys/zil.h \
	$(top_srcdir)/include/sys/zil_impl.h \
	$(top_srcdir)/include/sys/zio_checksum.h \
	$(top_srcdir)/include/sys/zio_compress.h \
	$(top_srcdir)/include/sys/zio.h \
	$(top_srcdir)/include/sys/zio_impl.h \
	$(top_srcdir)/include/sys/zrlock.h

KERNEL_H = \
	$(top_srcdir)/include/sys/zfs_ioctl.h \
	$(top_srcdir)/include/sys/zfs_onexit.h \
	${top_srcdir}/include/sys/zpl.h \
	$(top_srcdir)/include/sys/zvol.h

USER_H = 
EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)
@CONFIG_USER_TRUE@libzfsdir = $(includedir)/libzfs/sys
@CONFIG_USER_TRUE@libzfs_HEADERS = $(COMMON_H) $(USER_H)
@CONFIG_KERNEL_TRUE@kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys
@CONFIG_KERNEL_TRUE@kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/sys/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu include/sys/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
install-kernelHEADERS: $(kernel_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(kerneldir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(kerneldir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(kerneldir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(kerneldir)" || exit $$?; \
	done

uninstall-kernelHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(kerneldir)'; $(am__uninstall_files_from_dir)
install-libzfsHEADERS: $(libzfs_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libzfsdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libzfsdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libzfsdir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libzfsdir)" || exit $$?; \
	done

uninstall-libzfsHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(libzfsdir)'; $(am__uninstall_files_from_dir)

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile $(HEADERS)
installdirs: installdirs-recursive
installdirs-am:
	for dir in "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am: install-kernelHEADERS install-libzfsHEADERS

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am: uninstall-kernelHEADERS uninstall-libzfsHEADERS

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am \
	install-kernelHEADERS install-libzfsHEADERS install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am \
	uninstall-kernelHEADERS uninstall-libzfsHEADERS


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                             usr/src/zfs-0.6.5.9/include/sys/arc.h                                                               0100644 0000000 0000000 00000015771 13045171016 015452  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 */

#ifndef	_SYS_ARC_H
#define	_SYS_ARC_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

#include <sys/zio.h>
#include <sys/dmu.h>
#include <sys/spa.h>
#include <sys/refcount.h>

/*
 * Used by arc_flush() to inform arc_evict_state() that it should evict
 * all available buffers from the arc state being passed in.
 */
#define	ARC_EVICT_ALL	-1ULL

typedef struct arc_buf_hdr arc_buf_hdr_t;
typedef struct arc_buf arc_buf_t;
typedef struct arc_prune arc_prune_t;
typedef void arc_done_func_t(zio_t *zio, arc_buf_t *buf, void *private);
typedef void arc_prune_func_t(int64_t bytes, void *private);
typedef int arc_evict_func_t(void *private);

/* Shared module parameters */
extern int zfs_arc_average_blocksize;

/* generic arc_done_func_t's which you can use */
arc_done_func_t arc_bcopy_func;
arc_done_func_t arc_getbuf_func;

/* generic arc_prune_func_t wrapper for callbacks */
struct arc_prune {
	arc_prune_func_t	*p_pfunc;
	void			*p_private;
	uint64_t		p_adjust;
	list_node_t		p_node;
	refcount_t		p_refcnt;
};

typedef enum arc_strategy {
	ARC_STRATEGY_META_ONLY		= 0, /* Evict only meta data buffers */
	ARC_STRATEGY_META_BALANCED	= 1, /* Evict data buffers if needed */
} arc_strategy_t;

typedef enum arc_flags
{
	/*
	 * Public flags that can be passed into the ARC by external consumers.
	 */
	ARC_FLAG_NONE			= 1 << 0,	/* No flags set */
	ARC_FLAG_WAIT			= 1 << 1,	/* perform sync I/O */
	ARC_FLAG_NOWAIT			= 1 << 2,	/* perform async I/O */
	ARC_FLAG_PREFETCH		= 1 << 3,	/* I/O is a prefetch */
	ARC_FLAG_CACHED			= 1 << 4,	/* I/O was in cache */
	ARC_FLAG_L2CACHE		= 1 << 5,	/* cache in L2ARC */
	ARC_FLAG_L2COMPRESS		= 1 << 6,	/* compress in L2ARC */

	/*
	 * Private ARC flags.  These flags are private ARC only flags that
	 * will show up in b_flags in the arc_hdr_buf_t. These flags should
	 * only be set by ARC code.
	 */
	ARC_FLAG_IN_HASH_TABLE		= 1 << 7,	/* buffer is hashed */
	ARC_FLAG_IO_IN_PROGRESS		= 1 << 8,	/* I/O in progress */
	ARC_FLAG_IO_ERROR		= 1 << 9,	/* I/O failed for buf */
	ARC_FLAG_FREED_IN_READ		= 1 << 10,	/* freed during read */
	ARC_FLAG_BUF_AVAILABLE		= 1 << 11,	/* block not in use */
	ARC_FLAG_INDIRECT		= 1 << 12,	/* indirect block */
	ARC_FLAG_L2_WRITING		= 1 << 13,	/* write in progress */
	ARC_FLAG_L2_EVICTED		= 1 << 14,	/* evicted during I/O */
	ARC_FLAG_L2_WRITE_HEAD		= 1 << 15,	/* head of write list */
	/* indicates that the buffer contains metadata (otherwise, data) */
	ARC_FLAG_BUFC_METADATA		= 1 << 16,

	/* Flags specifying whether optional hdr struct fields are defined */
	ARC_FLAG_HAS_L1HDR		= 1 << 17,
	ARC_FLAG_HAS_L2HDR		= 1 << 18,
} arc_flags_t;

struct arc_buf {
	arc_buf_hdr_t		*b_hdr;
	arc_buf_t		*b_next;
	kmutex_t		b_evict_lock;
	void			*b_data;
	arc_evict_func_t	*b_efunc;
	void			*b_private;
};

typedef enum arc_buf_contents {
	ARC_BUFC_DATA,				/* buffer contains data */
	ARC_BUFC_METADATA,			/* buffer contains metadata */
	ARC_BUFC_NUMTYPES
} arc_buf_contents_t;

/*
 * The following breakdows of arc_size exist for kstat only.
 */
typedef enum arc_space_type {
	ARC_SPACE_DATA,
	ARC_SPACE_META,
	ARC_SPACE_HDRS,
	ARC_SPACE_L2HDRS,
	ARC_SPACE_OTHER,
	ARC_SPACE_NUMTYPES
} arc_space_type_t;

typedef enum arc_state_type {
	ARC_STATE_ANON,
	ARC_STATE_MRU,
	ARC_STATE_MRU_GHOST,
	ARC_STATE_MFU,
	ARC_STATE_MFU_GHOST,
	ARC_STATE_L2C_ONLY,
	ARC_STATE_NUMTYPES
} arc_state_type_t;

typedef struct arc_buf_info {
	arc_state_type_t	abi_state_type;
	arc_buf_contents_t	abi_state_contents;
	uint32_t		abi_flags;
	uint32_t		abi_datacnt;
	uint64_t		abi_size;
	uint64_t		abi_spa;
	uint64_t		abi_access;
	uint32_t		abi_mru_hits;
	uint32_t		abi_mru_ghost_hits;
	uint32_t		abi_mfu_hits;
	uint32_t		abi_mfu_ghost_hits;
	uint32_t		abi_l2arc_hits;
	uint32_t		abi_holds;
	uint64_t		abi_l2arc_dattr;
	uint64_t		abi_l2arc_asize;
	enum zio_compress	abi_l2arc_compress;
} arc_buf_info_t;

void arc_space_consume(uint64_t space, arc_space_type_t type);
void arc_space_return(uint64_t space, arc_space_type_t type);
arc_buf_t *arc_buf_alloc(spa_t *spa, uint64_t size, void *tag,
    arc_buf_contents_t type);
arc_buf_t *arc_loan_buf(spa_t *spa, uint64_t size);
void arc_return_buf(arc_buf_t *buf, void *tag);
void arc_loan_inuse_buf(arc_buf_t *buf, void *tag);
void arc_buf_add_ref(arc_buf_t *buf, void *tag);
boolean_t arc_buf_remove_ref(arc_buf_t *buf, void *tag);
void arc_buf_info(arc_buf_t *buf, arc_buf_info_t *abi, int state_index);
uint64_t arc_buf_size(arc_buf_t *buf);
void arc_release(arc_buf_t *buf, void *tag);
int arc_released(arc_buf_t *buf);
void arc_buf_sigsegv(int sig, siginfo_t *si, void *unused);
void arc_buf_freeze(arc_buf_t *buf);
void arc_buf_thaw(arc_buf_t *buf);
boolean_t arc_buf_eviction_needed(arc_buf_t *buf);
#ifdef ZFS_DEBUG
int arc_referenced(arc_buf_t *buf);
#endif

int arc_read(zio_t *pio, spa_t *spa, const blkptr_t *bp,
    arc_done_func_t *done, void *private, zio_priority_t priority, int flags,
    arc_flags_t *arc_flags, const zbookmark_phys_t *zb);
zio_t *arc_write(zio_t *pio, spa_t *spa, uint64_t txg,
    blkptr_t *bp, arc_buf_t *buf, boolean_t l2arc, boolean_t l2arc_compress,
    const zio_prop_t *zp, arc_done_func_t *ready, arc_done_func_t *physdone,
    arc_done_func_t *done, void *private, zio_priority_t priority,
    int zio_flags, const zbookmark_phys_t *zb);

arc_prune_t *arc_add_prune_callback(arc_prune_func_t *func, void *private);
void arc_remove_prune_callback(arc_prune_t *p);
void arc_freed(spa_t *spa, const blkptr_t *bp);

void arc_set_callback(arc_buf_t *buf, arc_evict_func_t *func, void *private);
boolean_t arc_clear_callback(arc_buf_t *buf);

void arc_flush(spa_t *spa, boolean_t retry);
void arc_tempreserve_clear(uint64_t reserve);
int arc_tempreserve_space(uint64_t reserve, uint64_t txg);

void arc_init(void);
void arc_fini(void);

/*
 * Level 2 ARC
 */

void l2arc_add_vdev(spa_t *spa, vdev_t *vd);
void l2arc_remove_vdev(vdev_t *vd);
boolean_t l2arc_vdev_present(vdev_t *vd);
void l2arc_init(void);
void l2arc_fini(void);
void l2arc_start(void);
void l2arc_stop(void);

#ifndef _KERNEL
extern boolean_t arc_watch;
#endif

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_ARC_H */
       usr/src/zfs-0.6.5.9/include/sys/arc_impl.h                                                          0100644 0000000 0000000 00000017022 13045171016 016462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
 */

#ifndef _SYS_ARC_IMPL_H
#define	_SYS_ARC_IMPL_H

#include <sys/arc.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Note that buffers can be in one of 6 states:
 *	ARC_anon	- anonymous (discussed below)
 *	ARC_mru		- recently used, currently cached
 *	ARC_mru_ghost	- recentely used, no longer in cache
 *	ARC_mfu		- frequently used, currently cached
 *	ARC_mfu_ghost	- frequently used, no longer in cache
 *	ARC_l2c_only	- exists in L2ARC but not other states
 * When there are no active references to the buffer, they are
 * are linked onto a list in one of these arc states.  These are
 * the only buffers that can be evicted or deleted.  Within each
 * state there are multiple lists, one for meta-data and one for
 * non-meta-data.  Meta-data (indirect blocks, blocks of dnodes,
 * etc.) is tracked separately so that it can be managed more
 * explicitly: favored over data, limited explicitly.
 *
 * Anonymous buffers are buffers that are not associated with
 * a DVA.  These are buffers that hold dirty block copies
 * before they are written to stable storage.  By definition,
 * they are "ref'd" and are considered part of arc_mru
 * that cannot be freed.  Generally, they will aquire a DVA
 * as they are written and migrate onto the arc_mru list.
 *
 * The ARC_l2c_only state is for buffers that are in the second
 * level ARC but no longer in any of the ARC_m* lists.  The second
 * level ARC itself may also contain buffers that are in any of
 * the ARC_m* states - meaning that a buffer can exist in two
 * places.  The reason for the ARC_l2c_only state is to keep the
 * buffer header in the hash table, so that reads that hit the
 * second level ARC benefit from these fast lookups.
 */

typedef struct arc_state {
	/*
	 * list of evictable buffers
	 */
	multilist_t arcs_list[ARC_BUFC_NUMTYPES];
	/*
	 * total amount of evictable data in this state
	 */
	uint64_t arcs_lsize[ARC_BUFC_NUMTYPES];
	/*
	 * total amount of data in this state; this includes: evictable,
	 * non-evictable, ARC_BUFC_DATA, and ARC_BUFC_METADATA.
	 */
	refcount_t arcs_size;
	/*
	 * supports the "dbufs" kstat
	 */
	arc_state_type_t arcs_state;
} arc_state_t;

typedef struct arc_callback arc_callback_t;

struct arc_callback {
	void			*acb_private;
	arc_done_func_t		*acb_done;
	arc_buf_t		*acb_buf;
	zio_t			*acb_zio_dummy;
	arc_callback_t		*acb_next;
};

typedef struct arc_write_callback arc_write_callback_t;

struct arc_write_callback {
	void		*awcb_private;
	arc_done_func_t	*awcb_ready;
	arc_done_func_t	*awcb_physdone;
	arc_done_func_t	*awcb_done;
	arc_buf_t	*awcb_buf;
};

/*
 * ARC buffers are separated into multiple structs as a memory saving measure:
 *   - Common fields struct, always defined, and embedded within it:
 *       - L2-only fields, always allocated but undefined when not in L2ARC
 *       - L1-only fields, only allocated when in L1ARC
 *
 *           Buffer in L1                     Buffer only in L2
 *    +------------------------+          +------------------------+
 *    | arc_buf_hdr_t          |          | arc_buf_hdr_t          |
 *    |                        |          |                        |
 *    |                        |          |                        |
 *    |                        |          |                        |
 *    +------------------------+          +------------------------+
 *    | l2arc_buf_hdr_t        |          | l2arc_buf_hdr_t        |
 *    | (undefined if L1-only) |          |                        |
 *    +------------------------+          +------------------------+
 *    | l1arc_buf_hdr_t        |
 *    |                        |
 *    |                        |
 *    |                        |
 *    |                        |
 *    +------------------------+
 *
 * Because it's possible for the L2ARC to become extremely large, we can wind
 * up eating a lot of memory in L2ARC buffer headers, so the size of a header
 * is minimized by only allocating the fields necessary for an L1-cached buffer
 * when a header is actually in the L1 cache. The sub-headers (l1arc_buf_hdr and
 * l2arc_buf_hdr) are embedded rather than allocated separately to save a couple
 * words in pointers. arc_hdr_realloc() is used to switch a header between
 * these two allocation states.
 */
typedef struct l1arc_buf_hdr {
	kmutex_t		b_freeze_lock;

	arc_buf_t		*b_buf;
	uint32_t		b_datacnt;
	/* for waiting on writes to complete */
	kcondvar_t		b_cv;


	/* protected by arc state mutex */
	arc_state_t		*b_state;
	multilist_node_t	b_arc_node;

	/* updated atomically */
	clock_t			b_arc_access;
	uint32_t		b_mru_hits;
	uint32_t		b_mru_ghost_hits;
	uint32_t		b_mfu_hits;
	uint32_t		b_mfu_ghost_hits;
	uint32_t		b_l2_hits;

	/* self protecting */
	refcount_t		b_refcnt;

	arc_callback_t		*b_acb;
	/* temporary buffer holder for in-flight compressed data */
	void			*b_tmp_cdata;
} l1arc_buf_hdr_t;

typedef struct l2arc_dev {
	vdev_t			*l2ad_vdev;	/* vdev */
	spa_t			*l2ad_spa;	/* spa */
	uint64_t		l2ad_hand;	/* next write location */
	uint64_t		l2ad_start;	/* first addr on device */
	uint64_t		l2ad_end;	/* last addr on device */
	boolean_t		l2ad_first;	/* first sweep through */
	boolean_t		l2ad_writing;	/* currently writing */
	kmutex_t		l2ad_mtx;	/* lock for buffer list */
	list_t			l2ad_buflist;	/* buffer list */
	list_node_t		l2ad_node;	/* device list node */
	refcount_t		l2ad_alloc;	/* allocated bytes */
} l2arc_dev_t;

typedef struct l2arc_buf_hdr {
	/* protected by arc_buf_hdr mutex */
	l2arc_dev_t		*b_dev;		/* L2ARC device */
	uint64_t		b_daddr;	/* disk address, offset byte */
	/* real alloc'd buffer size depending on b_compress applied */
	uint32_t		b_hits;
	int32_t			b_asize;
	uint8_t			b_compress;

	list_node_t		b_l2node;
} l2arc_buf_hdr_t;

typedef struct l2arc_write_callback {
	l2arc_dev_t	*l2wcb_dev;		/* device info */
	arc_buf_hdr_t	*l2wcb_head;		/* head of write buflist */
} l2arc_write_callback_t;

struct arc_buf_hdr {
	/* protected by hash lock */
	dva_t			b_dva;
	uint64_t		b_birth;
	/*
	 * Even though this checksum is only set/verified when a buffer is in
	 * the L1 cache, it needs to be in the set of common fields because it
	 * must be preserved from the time before a buffer is written out to
	 * L2ARC until after it is read back in.
	 */
	zio_cksum_t		*b_freeze_cksum;

	arc_buf_hdr_t		*b_hash_next;
	arc_flags_t		b_flags;

	/* immutable */
	int32_t			b_size;
	uint64_t		b_spa;

	/* L2ARC fields. Undefined when not in L2ARC. */
	l2arc_buf_hdr_t		b_l2hdr;
	/* L1ARC fields. Undefined when in l2arc_only state */
	l1arc_buf_hdr_t		b_l1hdr;
};
#ifdef __cplusplus
}
#endif

#endif /* _SYS_ARC_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/avl.h                                                               0100644 0000000 0000000 00000021677 13045171016 015471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 2014 by Delphix. All rights reserved.
 */

#ifndef	_AVL_H
#define	_AVL_H

/*
 * This is a private header file.  Applications should not directly include
 * this file.
 */

#ifdef	__cplusplus
extern "C" {
#endif

#include <sys/types.h>
#include <sys/avl_impl.h>

/*
 * This is a generic implementation of AVL trees for use in the Solaris kernel.
 * The interfaces provide an efficient way of implementing an ordered set of
 * data structures.
 *
 * AVL trees provide an alternative to using an ordered linked list. Using AVL
 * trees will usually be faster, however they requires more storage. An ordered
 * linked list in general requires 2 pointers in each data structure. The
 * AVL tree implementation uses 3 pointers. The following chart gives the
 * approximate performance of operations with the different approaches:
 *
 *	Operation	 Link List	AVL tree
 *	---------	 --------	--------
 *	lookup		   O(n)		O(log(n))
 *
 *	insert 1 node	 constant	constant
 *
 *	delete 1 node	 constant	between constant and O(log(n))
 *
 *	delete all nodes   O(n)		O(n)
 *
 *	visit the next
 *	or prev node	 constant	between constant and O(log(n))
 *
 *
 * The data structure nodes are anchored at an "avl_tree_t" (the equivalent
 * of a list header) and the individual nodes will have a field of
 * type "avl_node_t" (corresponding to list pointers).
 *
 * The type "avl_index_t" is used to indicate a position in the list for
 * certain calls.
 *
 * The usage scenario is generally:
 *
 * 1. Create the list/tree with: avl_create()
 *
 * followed by any mixture of:
 *
 * 2a. Insert nodes with: avl_add(), or avl_find() and avl_insert()
 *
 * 2b. Visited elements with:
 *	 avl_first() - returns the lowest valued node
 *	 avl_last() - returns the highest valued node
 *	 AVL_NEXT() - given a node go to next higher one
 *	 AVL_PREV() - given a node go to previous lower one
 *
 * 2c.  Find the node with the closest value either less than or greater
 *	than a given value with avl_nearest().
 *
 * 2d. Remove individual nodes from the list/tree with avl_remove().
 *
 * and finally when the list is being destroyed
 *
 * 3. Use avl_destroy_nodes() to quickly process/free up any remaining nodes.
 *    Note that once you use avl_destroy_nodes(), you can no longer
 *    use any routine except avl_destroy_nodes() and avl_destoy().
 *
 * 4. Use avl_destroy() to destroy the AVL tree itself.
 *
 * Any locking for multiple thread access is up to the user to provide, just
 * as is needed for any linked list implementation.
 */


/*
 * Type used for the root of the AVL tree.
 */
typedef struct avl_tree avl_tree_t;

/*
 * The data nodes in the AVL tree must have a field of this type.
 */
typedef struct avl_node avl_node_t;

/*
 * An opaque type used to locate a position in the tree where a node
 * would be inserted.
 */
typedef uintptr_t avl_index_t;


/*
 * Direction constants used for avl_nearest().
 */
#define	AVL_BEFORE	(0)
#define	AVL_AFTER	(1)


/*
 * Prototypes
 *
 * Where not otherwise mentioned, "void *" arguments are a pointer to the
 * user data structure which must contain a field of type avl_node_t.
 *
 * Also assume the user data structures looks like:
 *	stuct my_type {
 *		...
 *		avl_node_t	my_link;
 *		...
 *	};
 */

/*
 * Initialize an AVL tree. Arguments are:
 *
 * tree   - the tree to be initialized
 * compar - function to compare two nodes, it must return exactly: -1, 0, or +1
 *          -1 for <, 0 for ==, and +1 for >
 * size   - the value of sizeof(struct my_type)
 * offset - the value of OFFSETOF(struct my_type, my_link)
 */
extern void avl_create(avl_tree_t *tree,
	int (*compar) (const void *, const void *), size_t size, size_t offset);


/*
 * Find a node with a matching value in the tree. Returns the matching node
 * found. If not found, it returns NULL and then if "where" is not NULL it sets
 * "where" for use with avl_insert() or avl_nearest().
 *
 * node   - node that has the value being looked for
 * where  - position for use with avl_nearest() or avl_insert(), may be NULL
 */
extern void *avl_find(avl_tree_t *tree, const void *node, avl_index_t *where);

/*
 * Insert a node into the tree.
 *
 * node   - the node to insert
 * where  - position as returned from avl_find()
 */
extern void avl_insert(avl_tree_t *tree, void *node, avl_index_t where);

/*
 * Insert "new_data" in "tree" in the given "direction" either after
 * or before the data "here".
 *
 * This might be useful for avl clients caching recently accessed
 * data to avoid doing avl_find() again for insertion.
 *
 * new_data	- new data to insert
 * here		- existing node in "tree"
 * direction	- either AVL_AFTER or AVL_BEFORE the data "here".
 */
extern void avl_insert_here(avl_tree_t *tree, void *new_data, void *here,
    int direction);


/*
 * Return the first or last valued node in the tree. Will return NULL
 * if the tree is empty.
 *
 */
extern void *avl_first(avl_tree_t *tree);
extern void *avl_last(avl_tree_t *tree);


/*
 * Return the next or previous valued node in the tree.
 * AVL_NEXT() will return NULL if at the last node.
 * AVL_PREV() will return NULL if at the first node.
 *
 * node   - the node from which the next or previous node is found
 */
#define	AVL_NEXT(tree, node)	avl_walk(tree, node, AVL_AFTER)
#define	AVL_PREV(tree, node)	avl_walk(tree, node, AVL_BEFORE)


/*
 * Find the node with the nearest value either greater or less than
 * the value from a previous avl_find(). Returns the node or NULL if
 * there isn't a matching one.
 *
 * where     - position as returned from avl_find()
 * direction - either AVL_BEFORE or AVL_AFTER
 *
 * EXAMPLE get the greatest node that is less than a given value:
 *
 *	avl_tree_t *tree;
 *	struct my_data look_for_value = {....};
 *	struct my_data *node;
 *	struct my_data *less;
 *	avl_index_t where;
 *
 *	node = avl_find(tree, &look_for_value, &where);
 *	if (node != NULL)
 *		less = AVL_PREV(tree, node);
 *	else
 *		less = avl_nearest(tree, where, AVL_BEFORE);
 */
extern void *avl_nearest(avl_tree_t *tree, avl_index_t where, int direction);


/*
 * Add a single node to the tree.
 * The node must not be in the tree, and it must not
 * compare equal to any other node already in the tree.
 *
 * node   - the node to add
 */
extern void avl_add(avl_tree_t *tree, void *node);


/*
 * Remove a single node from the tree.  The node must be in the tree.
 *
 * node   - the node to remove
 */
extern void avl_remove(avl_tree_t *tree, void *node);

/*
 * Reinsert a node only if its order has changed relative to its nearest
 * neighbors. To optimize performance avl_update_lt() checks only the previous
 * node and avl_update_gt() checks only the next node. Use avl_update_lt() and
 * avl_update_gt() only if you know the direction in which the order of the
 * node may change.
 */
extern boolean_t avl_update(avl_tree_t *, void *);
extern boolean_t avl_update_lt(avl_tree_t *, void *);
extern boolean_t avl_update_gt(avl_tree_t *, void *);

/*
 * Swaps the contents of the two trees.
 */
extern void avl_swap(avl_tree_t *tree1, avl_tree_t *tree2);

/*
 * Return the number of nodes in the tree
 */
extern ulong_t avl_numnodes(avl_tree_t *tree);

/*
 * Return B_TRUE if there are zero nodes in the tree, B_FALSE otherwise.
 */
extern boolean_t avl_is_empty(avl_tree_t *tree);

/*
 * Used to destroy any remaining nodes in a tree. The cookie argument should
 * be initialized to NULL before the first call. Returns a node that has been
 * removed from the tree and may be free()'d. Returns NULL when the tree is
 * empty.
 *
 * Once you call avl_destroy_nodes(), you can only continuing calling it and
 * finally avl_destroy(). No other AVL routines will be valid.
 *
 * cookie - a "void *" used to save state between calls to avl_destroy_nodes()
 *
 * EXAMPLE:
 *	avl_tree_t *tree;
 *	struct my_data *node;
 *	void *cookie;
 *
 *	cookie = NULL;
 *	while ((node = avl_destroy_nodes(tree, &cookie)) != NULL)
 *		free(node);
 *	avl_destroy(tree);
 */
extern void *avl_destroy_nodes(avl_tree_t *tree, void **cookie);


/*
 * Final destroy of an AVL tree. Arguments are:
 *
 * tree   - the empty tree to destroy
 */
extern void avl_destroy(avl_tree_t *tree);



#ifdef	__cplusplus
}
#endif

#endif	/* _AVL_H */
                                                                 usr/src/zfs-0.6.5.9/include/sys/avl_impl.h                                                          0100644 0000000 0000000 00000011460 13045171016 016477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_AVL_IMPL_H
#define	_AVL_IMPL_H



/*
 * This is a private header file.  Applications should not directly include
 * this file.
 */

#include <sys/types.h>

#ifdef	__cplusplus
extern "C" {
#endif


/*
 * generic AVL tree implementation for kernel use
 *
 * There are 5 pieces of information stored for each node in an AVL tree
 *
 * 	pointer to less than child
 * 	pointer to greater than child
 * 	a pointer to the parent of this node
 *	an indication  [0/1]  of which child I am of my parent
 * 	a "balance" (-1, 0, +1)  indicating which child tree is taller
 *
 * Since they only need 3 bits, the last two fields are packed into the
 * bottom bits of the parent pointer on 64 bit machines to save on space.
 */

#ifndef _LP64

struct avl_node {
	struct avl_node *avl_child[2];	/* left/right children */
	struct avl_node *avl_parent;	/* this node's parent */
	unsigned short avl_child_index;	/* my index in parent's avl_child[] */
	short avl_balance;		/* balance value: -1, 0, +1 */
};

#define	AVL_XPARENT(n)		((n)->avl_parent)
#define	AVL_SETPARENT(n, p)	((n)->avl_parent = (p))

#define	AVL_XCHILD(n)		((n)->avl_child_index)
#define	AVL_SETCHILD(n, c)	((n)->avl_child_index = (unsigned short)(c))

#define	AVL_XBALANCE(n)		((n)->avl_balance)
#define	AVL_SETBALANCE(n, b)	((n)->avl_balance = (short)(b))

#else /* _LP64 */

/*
 * for 64 bit machines, avl_pcb contains parent pointer, balance and child_index
 * values packed in the following manner:
 *
 * |63                                  3|        2        |1          0 |
 * |-------------------------------------|-----------------|-------------|
 * |      avl_parent hi order bits       | avl_child_index | avl_balance |
 * |                                     |                 |     + 1     |
 * |-------------------------------------|-----------------|-------------|
 *
 */
struct avl_node {
	struct avl_node *avl_child[2];	/* left/right children nodes */
	uintptr_t avl_pcb;		/* parent, child_index, balance */
};

/*
 * macros to extract/set fields in avl_pcb
 *
 * pointer to the parent of the current node is the high order bits
 */
#define	AVL_XPARENT(n)		((struct avl_node *)((n)->avl_pcb & ~7))
#define	AVL_SETPARENT(n, p)						\
	((n)->avl_pcb = (((n)->avl_pcb & 7) | (uintptr_t)(p)))

/*
 * index of this node in its parent's avl_child[]: bit #2
 */
#define	AVL_XCHILD(n)		(((n)->avl_pcb >> 2) & 1)
#define	AVL_SETCHILD(n, c)						\
	((n)->avl_pcb = (uintptr_t)(((n)->avl_pcb & ~4) | ((c) << 2)))

/*
 * balance indication for a node, lowest 2 bits. A valid balance is
 * -1, 0, or +1, and is encoded by adding 1 to the value to get the
 * unsigned values of 0, 1, 2.
 */
#define	AVL_XBALANCE(n)		((int)(((n)->avl_pcb & 3) - 1))
#define	AVL_SETBALANCE(n, b)						\
	((n)->avl_pcb = (uintptr_t)((((n)->avl_pcb & ~3) | ((b) + 1))))

#endif /* _LP64 */



/*
 * switch between a node and data pointer for a given tree
 * the value of "o" is tree->avl_offset
 */
#define	AVL_NODE2DATA(n, o)	((void *)((uintptr_t)(n) - (o)))
#define	AVL_DATA2NODE(d, o)	((struct avl_node *)((uintptr_t)(d) + (o)))



/*
 * macros used to create/access an avl_index_t
 */
#define	AVL_INDEX2NODE(x)	((avl_node_t *)((x) & ~1))
#define	AVL_INDEX2CHILD(x)	((x) & 1)
#define	AVL_MKINDEX(n, c)	((avl_index_t)(n) | (c))


/*
 * The tree structure. The fields avl_root, avl_compar, and avl_offset come
 * first since they are needed for avl_find().  We want them to fit into
 * a single 64 byte cache line to make avl_find() as fast as possible.
 */
struct avl_tree {
	struct avl_node *avl_root;	/* root node in tree */
	int (*avl_compar)(const void *, const void *);
	size_t avl_offset;		/* offsetof(type, avl_link_t field) */
	ulong_t avl_numnodes;		/* number of nodes in the tree */
	size_t avl_size;		/* sizeof user type struct */
};


/*
 * This will only by used via AVL_NEXT() or AVL_PREV()
 */
extern void *avl_walk(struct avl_tree *, void *, int);

#ifdef	__cplusplus
}
#endif

#endif	/* _AVL_IMPL_H */
                                                                                                                                                                                                                usr/src/zfs-0.6.5.9/include/sys/blkptr.h                                                            0100644 0000000 0000000 00000001533 13045171016 016172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * This file and its contents are supplied under the terms of the
 * Common Development and Distribution License ("CDDL"), version 1.0.
 * You may only use this file in accordance with the terms of version
 * 1.0 of the CDDL.
 *
 * A full copy of the text of the CDDL should have accompanied this
 * source.  A copy of the CDDL is also available via the Internet at
 * http://www.illumos.org/license/CDDL.
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef _SYS_BLKPTR_H
#define	_SYS_BLKPTR_H

#include <sys/spa.h>
#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

void encode_embedded_bp_compressed(blkptr_t *, void *,
    enum zio_compress, int, int);
void decode_embedded_bp_compressed(const blkptr_t *, void *);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_BLKPTR_H */
                                                                                                                                                                     usr/src/zfs-0.6.5.9/include/sys/bplist.h                                                            0100644 0000000 0000000 00000003021 13045171016 016163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_BPLIST_H
#define	_SYS_BPLIST_H

#include <sys/zfs_context.h>
#include <sys/spa.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct bplist_entry {
	blkptr_t	bpe_blk;
	list_node_t	bpe_node;
} bplist_entry_t;

typedef struct bplist {
	kmutex_t	bpl_lock;
	list_t		bpl_list;
} bplist_t;

typedef int bplist_itor_t(void *arg, const blkptr_t *bp, dmu_tx_t *tx);

void bplist_create(bplist_t *bpl);
void bplist_destroy(bplist_t *bpl);
void bplist_append(bplist_t *bpl, const blkptr_t *bp);
void bplist_iterate(bplist_t *bpl, bplist_itor_t *func,
    void *arg, dmu_tx_t *tx);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_BPLIST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/src/zfs-0.6.5.9/include/sys/bpobj.h                                                             0100644 0000000 0000000 00000005426 13045171016 015775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef	_SYS_BPOBJ_H
#define	_SYS_BPOBJ_H

#include <sys/dmu.h>
#include <sys/spa.h>
#include <sys/txg.h>
#include <sys/zio.h>
#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct bpobj_phys {
	/*
	 * This is the bonus buffer for the dead lists.  The object's
	 * contents is an array of bpo_entries blkptr_t's, representing
	 * a total of bpo_bytes physical space.
	 */
	uint64_t	bpo_num_blkptrs;
	uint64_t	bpo_bytes;
	uint64_t	bpo_comp;
	uint64_t	bpo_uncomp;
	uint64_t	bpo_subobjs;
	uint64_t	bpo_num_subobjs;
} bpobj_phys_t;

#define	BPOBJ_SIZE_V0	(2 * sizeof (uint64_t))
#define	BPOBJ_SIZE_V1	(4 * sizeof (uint64_t))

typedef struct bpobj {
	kmutex_t	bpo_lock;
	objset_t	*bpo_os;
	uint64_t	bpo_object;
	int		bpo_epb;
	uint8_t		bpo_havecomp;
	uint8_t		bpo_havesubobj;
	bpobj_phys_t	*bpo_phys;
	dmu_buf_t	*bpo_dbuf;
	dmu_buf_t	*bpo_cached_dbuf;
} bpobj_t;

typedef int bpobj_itor_t(void *arg, const blkptr_t *bp, dmu_tx_t *tx);

uint64_t bpobj_alloc(objset_t *mos, int blocksize, dmu_tx_t *tx);
uint64_t bpobj_alloc_empty(objset_t *os, int blocksize, dmu_tx_t *tx);
void bpobj_free(objset_t *os, uint64_t obj, dmu_tx_t *tx);
void bpobj_decr_empty(objset_t *os, dmu_tx_t *tx);

int bpobj_open(bpobj_t *bpo, objset_t *mos, uint64_t object);
void bpobj_close(bpobj_t *bpo);

int bpobj_iterate(bpobj_t *bpo, bpobj_itor_t func, void *arg, dmu_tx_t *tx);
int bpobj_iterate_nofree(bpobj_t *bpo, bpobj_itor_t func, void *, dmu_tx_t *);

void bpobj_enqueue_subobj(bpobj_t *bpo, uint64_t subobj, dmu_tx_t *tx);
void bpobj_enqueue(bpobj_t *bpo, const blkptr_t *bp, dmu_tx_t *tx);

int bpobj_space(bpobj_t *bpo,
    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp);
int bpobj_space_range(bpobj_t *bpo, uint64_t mintxg, uint64_t maxtxg,
    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_BPOBJ_H */
                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/sys/bptree.h                                                            0100644 0000000 0000000 00000003614 13045171016 016157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef	_SYS_BPTREE_H
#define	_SYS_BPTREE_H

#include <sys/spa.h>
#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct bptree_phys {
	uint64_t bt_begin;
	uint64_t bt_end;
	uint64_t bt_bytes;
	uint64_t bt_comp;
	uint64_t bt_uncomp;
} bptree_phys_t;

typedef struct bptree_entry_phys {
	blkptr_t be_bp;
	uint64_t be_birth_txg; /* only delete blocks born after this txg */
	zbookmark_phys_t be_zb; /* holds traversal resume point if needed */
} bptree_entry_phys_t;

typedef int bptree_itor_t(void *arg, const blkptr_t *bp, dmu_tx_t *tx);

uint64_t bptree_alloc(objset_t *os, dmu_tx_t *tx);
int bptree_free(objset_t *os, uint64_t obj, dmu_tx_t *tx);
boolean_t bptree_is_empty(objset_t *os, uint64_t obj);

void bptree_add(objset_t *os, uint64_t obj, blkptr_t *bp, uint64_t birth_txg,
    uint64_t bytes, uint64_t comp, uint64_t uncomp, dmu_tx_t *tx);

int bptree_iterate(objset_t *os, uint64_t obj, boolean_t free,
    bptree_itor_t func, void *arg, dmu_tx_t *tx);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_BPTREE_H */
                                                                                                                    usr/src/zfs-0.6.5.9/include/sys/dbuf.h                                                              0100644 0000000 0000000 00000024712 13045171016 015620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2015 by Delphix. All rights reserved.
 * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_DBUF_H
#define	_SYS_DBUF_H

#include <sys/dmu.h>
#include <sys/spa.h>
#include <sys/txg.h>
#include <sys/zio.h>
#include <sys/arc.h>
#include <sys/zfs_context.h>
#include <sys/refcount.h>
#include <sys/zrlock.h>

#ifdef	__cplusplus
extern "C" {
#endif

#define	IN_DMU_SYNC 2

/*
 * define flags for dbuf_read
 */

#define	DB_RF_MUST_SUCCEED	(1 << 0)
#define	DB_RF_CANFAIL		(1 << 1)
#define	DB_RF_HAVESTRUCT	(1 << 2)
#define	DB_RF_NOPREFETCH	(1 << 3)
#define	DB_RF_NEVERWAIT		(1 << 4)
#define	DB_RF_CACHED		(1 << 5)

/*
 * The simplified state transition diagram for dbufs looks like:
 *
 *		+----> READ ----+
 *		|		|
 *		|		V
 *  (alloc)-->UNCACHED	     CACHED-->EVICTING-->(free)
 *		|		^	 ^
 *		|		|	 |
 *		+----> FILL ----+	 |
 *		|			 |
 *		|			 |
 *		+--------> NOFILL -------+
 *
 * DB_SEARCH is an invalid state for a dbuf. It is used by dbuf_free_range
 * to find all dbufs in a range of a dnode and must be less than any other
 * dbuf_states_t (see comment on dn_dbufs in dnode.h).
 */
typedef enum dbuf_states {
	DB_SEARCH = -1,
	DB_UNCACHED,
	DB_FILL,
	DB_NOFILL,
	DB_READ,
	DB_CACHED,
	DB_EVICTING
} dbuf_states_t;

struct dnode;
struct dmu_tx;

/*
 * level = 0 means the user data
 * level = 1 means the single indirect block
 * etc.
 */

struct dmu_buf_impl;

typedef enum override_states {
	DR_NOT_OVERRIDDEN,
	DR_IN_DMU_SYNC,
	DR_OVERRIDDEN
} override_states_t;

typedef struct dbuf_dirty_record {
	/* link on our parents dirty list */
	list_node_t dr_dirty_node;

	/* transaction group this data will sync in */
	uint64_t dr_txg;

	/* zio of outstanding write IO */
	zio_t *dr_zio;

	/* pointer back to our dbuf */
	struct dmu_buf_impl *dr_dbuf;

	/* pointer to next dirty record */
	struct dbuf_dirty_record *dr_next;

	/* pointer to parent dirty record */
	struct dbuf_dirty_record *dr_parent;

	/* How much space was changed to dsl_pool_dirty_space() for this? */
	unsigned int dr_accounted;

	union dirty_types {
		struct dirty_indirect {

			/* protect access to list */
			kmutex_t dr_mtx;

			/* Our list of dirty children */
			list_t dr_children;
		} di;
		struct dirty_leaf {

			/*
			 * dr_data is set when we dirty the buffer
			 * so that we can retain the pointer even if it
			 * gets COW'd in a subsequent transaction group.
			 */
			arc_buf_t *dr_data;
			blkptr_t dr_overridden_by;
			override_states_t dr_override_state;
			uint8_t dr_copies;
			boolean_t dr_nopwrite;
		} dl;
	} dt;
} dbuf_dirty_record_t;

typedef struct dmu_buf_impl {
	/*
	 * The following members are immutable, with the exception of
	 * db.db_data, which is protected by db_mtx.
	 */

	/* the publicly visible structure */
	dmu_buf_t db;

	/* the objset we belong to */
	struct objset *db_objset;

	/*
	 * handle to safely access the dnode we belong to (NULL when evicted)
	 */
	struct dnode_handle *db_dnode_handle;

	/*
	 * our parent buffer; if the dnode points to us directly,
	 * db_parent == db_dnode_handle->dnh_dnode->dn_dbuf
	 * only accessed by sync thread ???
	 * (NULL when evicted)
	 * May change from NULL to non-NULL under the protection of db_mtx
	 * (see dbuf_check_blkptr())
	 */
	struct dmu_buf_impl *db_parent;

	/*
	 * link for hash table of all dmu_buf_impl_t's
	 */
	struct dmu_buf_impl *db_hash_next;

	/* our block number */
	uint64_t db_blkid;

	/*
	 * Pointer to the blkptr_t which points to us. May be NULL if we
	 * don't have one yet. (NULL when evicted)
	 */
	blkptr_t *db_blkptr;

	/*
	 * Our indirection level.  Data buffers have db_level==0.
	 * Indirect buffers which point to data buffers have
	 * db_level==1. etc.  Buffers which contain dnodes have
	 * db_level==0, since the dnodes are stored in a file.
	 */
	uint8_t db_level;

	/* db_mtx protects the members below */
	kmutex_t db_mtx;

	/*
	 * Current state of the buffer
	 */
	dbuf_states_t db_state;

	/*
	 * Refcount accessed by dmu_buf_{hold,rele}.
	 * If nonzero, the buffer can't be destroyed.
	 * Protected by db_mtx.
	 */
	refcount_t db_holds;

	/* buffer holding our data */
	arc_buf_t *db_buf;

	kcondvar_t db_changed;
	dbuf_dirty_record_t *db_data_pending;

	/* pointer to most recent dirty record for this buffer */
	dbuf_dirty_record_t *db_last_dirty;

	/*
	 * Our link on the owner dnodes's dn_dbufs list.
	 * Protected by its dn_dbufs_mtx.
	 */
	avl_node_t db_link;

	/* Data which is unique to data (leaf) blocks: */

	/* User callback information. */
	dmu_buf_user_t *db_user;

	/*
	 * Evict user data as soon as the dirty and reference
	 * counts are equal.
	 */
	uint8_t db_user_immediate_evict;

	/*
	 * This block was freed while a read or write was
	 * active.
	 */
	uint8_t db_freed_in_flight;

	/*
	 * dnode_evict_dbufs() or dnode_evict_bonus() tried to
	 * evict this dbuf, but couldn't due to outstanding
	 * references.  Evict once the refcount drops to 0.
	 */
	uint8_t db_pending_evict;

	uint8_t db_dirtycnt;
} dmu_buf_impl_t;

/* Note: the dbuf hash table is exposed only for the mdb module */
#define	DBUF_MUTEXES 8192
#define	DBUF_HASH_MUTEX(h, idx) (&(h)->hash_mutexes[(idx) & (DBUF_MUTEXES-1)])
typedef struct dbuf_hash_table {
	uint64_t hash_table_mask;
	dmu_buf_impl_t **hash_table;
	kmutex_t hash_mutexes[DBUF_MUTEXES];
} dbuf_hash_table_t;


uint64_t dbuf_whichblock(struct dnode *di, uint64_t offset);

void dbuf_create_bonus(struct dnode *dn);
int dbuf_spill_set_blksz(dmu_buf_t *db, uint64_t blksz, dmu_tx_t *tx);

void dbuf_rm_spill(struct dnode *dn, dmu_tx_t *tx);

dmu_buf_impl_t *dbuf_hold(struct dnode *dn, uint64_t blkid, void *tag);
dmu_buf_impl_t *dbuf_hold_level(struct dnode *dn, int level, uint64_t blkid,
    void *tag);
int dbuf_hold_impl(struct dnode *dn, uint8_t level, uint64_t blkid, int create,
    void *tag, dmu_buf_impl_t **dbp);

void dbuf_prefetch(struct dnode *dn, uint64_t blkid, zio_priority_t prio);

void dbuf_add_ref(dmu_buf_impl_t *db, void *tag);
boolean_t dbuf_try_add_ref(dmu_buf_t *db, objset_t *os, uint64_t obj,
    uint64_t blkid, void *tag);
uint64_t dbuf_refcount(dmu_buf_impl_t *db);

void dbuf_rele(dmu_buf_impl_t *db, void *tag);
void dbuf_rele_and_unlock(dmu_buf_impl_t *db, void *tag);

dmu_buf_impl_t *dbuf_find(struct objset *os, uint64_t object, uint8_t level,
    uint64_t blkid);

int dbuf_read(dmu_buf_impl_t *db, zio_t *zio, uint32_t flags);
void dmu_buf_will_not_fill(dmu_buf_t *db, dmu_tx_t *tx);
void dmu_buf_will_fill(dmu_buf_t *db, dmu_tx_t *tx);
void dmu_buf_fill_done(dmu_buf_t *db, dmu_tx_t *tx);
void dbuf_assign_arcbuf(dmu_buf_impl_t *db, arc_buf_t *buf, dmu_tx_t *tx);
dbuf_dirty_record_t *dbuf_dirty(dmu_buf_impl_t *db, dmu_tx_t *tx);
arc_buf_t *dbuf_loan_arcbuf(dmu_buf_impl_t *db);
void dmu_buf_write_embedded(dmu_buf_t *dbuf, void *data,
    bp_embedded_type_t etype, enum zio_compress comp,
    int uncompressed_size, int compressed_size, int byteorder, dmu_tx_t *tx);

void dbuf_clear(dmu_buf_impl_t *db);
void dbuf_evict(dmu_buf_impl_t *db);

void dbuf_unoverride(dbuf_dirty_record_t *dr);
void dbuf_sync_list(list_t *list, int level, dmu_tx_t *tx);
void dbuf_release_bp(dmu_buf_impl_t *db);

void dbuf_free_range(struct dnode *dn, uint64_t start, uint64_t end,
    struct dmu_tx *);

void dbuf_new_size(dmu_buf_impl_t *db, int size, dmu_tx_t *tx);

void dbuf_stats_init(dbuf_hash_table_t *hash);
void dbuf_stats_destroy(void);

#define	DB_DNODE(_db)		((_db)->db_dnode_handle->dnh_dnode)
#define	DB_DNODE_LOCK(_db)	((_db)->db_dnode_handle->dnh_zrlock)
#define	DB_DNODE_ENTER(_db)	(zrl_add(&DB_DNODE_LOCK(_db)))
#define	DB_DNODE_EXIT(_db)	(zrl_remove(&DB_DNODE_LOCK(_db)))
#define	DB_DNODE_HELD(_db)	(!zrl_is_zero(&DB_DNODE_LOCK(_db)))

void dbuf_init(void);
void dbuf_fini(void);

boolean_t dbuf_is_metadata(dmu_buf_impl_t *db);

#define	DBUF_GET_BUFC_TYPE(_db)	\
	(dbuf_is_metadata(_db) ? ARC_BUFC_METADATA : ARC_BUFC_DATA)

#define	DBUF_IS_CACHEABLE(_db)						\
	((_db)->db_objset->os_primary_cache == ZFS_CACHE_ALL ||		\
	(dbuf_is_metadata(_db) &&					\
	((_db)->db_objset->os_primary_cache == ZFS_CACHE_METADATA)))

#define	DBUF_IS_L2CACHEABLE(_db)					\
	((_db)->db_objset->os_secondary_cache == ZFS_CACHE_ALL ||	\
	(dbuf_is_metadata(_db) &&					\
	((_db)->db_objset->os_secondary_cache == ZFS_CACHE_METADATA)))

#define	DBUF_IS_L2COMPRESSIBLE(_db)					\
	((_db)->db_objset->os_compress != ZIO_COMPRESS_OFF ||		\
	(dbuf_is_metadata(_db) && zfs_mdcomp_disable == B_FALSE))

#ifdef ZFS_DEBUG

/*
 * There should be a ## between the string literal and fmt, to make it
 * clear that we're joining two strings together, but gcc does not
 * support that preprocessor token.
 */
#define	dprintf_dbuf(dbuf, fmt, ...) do { \
	if (zfs_flags & ZFS_DEBUG_DPRINTF) { \
	char __db_buf[32]; \
	uint64_t __db_obj = (dbuf)->db.db_object; \
	if (__db_obj == DMU_META_DNODE_OBJECT) \
		(void) strcpy(__db_buf, "mdn"); \
	else \
		(void) snprintf(__db_buf, sizeof (__db_buf), "%lld", \
		    (u_longlong_t)__db_obj); \
	dprintf_ds((dbuf)->db_objset->os_dsl_dataset, \
	    "obj=%s lvl=%u blkid=%lld " fmt, \
	    __db_buf, (dbuf)->db_level, \
	    (u_longlong_t)(dbuf)->db_blkid, __VA_ARGS__); \
	} \
_NOTE(CONSTCOND) } while (0)

#define	dprintf_dbuf_bp(db, bp, fmt, ...) do {			\
	if (zfs_flags & ZFS_DEBUG_DPRINTF) {			\
	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\
	snprintf_blkptr(__blkbuf, BP_SPRINTF_LEN, bp);		\
	dprintf_dbuf(db, fmt " %s\n", __VA_ARGS__, __blkbuf);	\
	kmem_free(__blkbuf, BP_SPRINTF_LEN);			\
	}							\
_NOTE(CONSTCOND) } while (0)

#define	DBUF_VERIFY(db)	dbuf_verify(db)

#else

#define	dprintf_dbuf(db, fmt, ...)
#define	dprintf_dbuf_bp(db, bp, fmt, ...)
#define	DBUF_VERIFY(db)

#endif


#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DBUF_H */
                                                      usr/src/zfs-0.6.5.9/include/sys/ddt.h                                                               0100644 0000000 0000000 00000017240 13045171016 015451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef _SYS_DDT_H
#define	_SYS_DDT_H

#include <sys/sysmacros.h>
#include <sys/types.h>
#include <sys/fs/zfs.h>
#include <sys/zio.h>
#include <sys/dmu.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * On-disk DDT formats, in the desired search order (newest version first).
 */
enum ddt_type {
	DDT_TYPE_ZAP = 0,
	DDT_TYPES
};

/*
 * DDT classes, in the desired search order (highest replication level first).
 */
enum ddt_class {
	DDT_CLASS_DITTO = 0,
	DDT_CLASS_DUPLICATE,
	DDT_CLASS_UNIQUE,
	DDT_CLASSES
};

#define	DDT_TYPE_CURRENT		0

#define	DDT_COMPRESS_BYTEORDER_MASK	0x80
#define	DDT_COMPRESS_FUNCTION_MASK	0x7f

/*
 * On-disk ddt entry:  key (name) and physical storage (value).
 */
typedef struct ddt_key {
	zio_cksum_t	ddk_cksum;	/* 256-bit block checksum */
	/*
	 * Encoded with logical & physical size, and compression, as follows:
	 *   +-------+-------+-------+-------+-------+-------+-------+-------+
	 *   |   0   |   0   |   0   | comp  |     PSIZE     |     LSIZE     |
	 *   +-------+-------+-------+-------+-------+-------+-------+-------+
	 */
	uint64_t	ddk_prop;
} ddt_key_t;

#define	DDK_GET_LSIZE(ddk)	\
	BF64_GET_SB((ddk)->ddk_prop, 0, 16, SPA_MINBLOCKSHIFT, 1)
#define	DDK_SET_LSIZE(ddk, x)	\
	BF64_SET_SB((ddk)->ddk_prop, 0, 16, SPA_MINBLOCKSHIFT, 1, x)

#define	DDK_GET_PSIZE(ddk)	\
	BF64_GET_SB((ddk)->ddk_prop, 16, 16, SPA_MINBLOCKSHIFT, 1)
#define	DDK_SET_PSIZE(ddk, x)	\
	BF64_SET_SB((ddk)->ddk_prop, 16, 16, SPA_MINBLOCKSHIFT, 1, x)

#define	DDK_GET_COMPRESS(ddk)		BF64_GET((ddk)->ddk_prop, 32, 8)
#define	DDK_SET_COMPRESS(ddk, x)	BF64_SET((ddk)->ddk_prop, 32, 8, x)

#define	DDT_KEY_WORDS	(sizeof (ddt_key_t) / sizeof (uint64_t))

typedef struct ddt_phys {
	dva_t		ddp_dva[SPA_DVAS_PER_BP];
	uint64_t	ddp_refcnt;
	uint64_t	ddp_phys_birth;
} ddt_phys_t;

enum ddt_phys_type {
	DDT_PHYS_DITTO = 0,
	DDT_PHYS_SINGLE = 1,
	DDT_PHYS_DOUBLE = 2,
	DDT_PHYS_TRIPLE = 3,
	DDT_PHYS_TYPES
};

/*
 * In-core ddt entry
 */
struct ddt_entry {
	ddt_key_t	dde_key;
	ddt_phys_t	dde_phys[DDT_PHYS_TYPES];
	zio_t		*dde_lead_zio[DDT_PHYS_TYPES];
	void		*dde_repair_data;
	enum ddt_type	dde_type;
	enum ddt_class	dde_class;
	uint8_t		dde_loading;
	uint8_t		dde_loaded;
	kcondvar_t	dde_cv;
	avl_node_t	dde_node;
};

/*
 * In-core ddt
 */
struct ddt {
	kmutex_t	ddt_lock;
	avl_tree_t	ddt_tree;
	avl_tree_t	ddt_repair_tree;
	enum zio_checksum ddt_checksum;
	spa_t		*ddt_spa;
	objset_t	*ddt_os;
	uint64_t	ddt_stat_object;
	uint64_t	ddt_object[DDT_TYPES][DDT_CLASSES];
	ddt_histogram_t	ddt_histogram[DDT_TYPES][DDT_CLASSES];
	ddt_histogram_t	ddt_histogram_cache[DDT_TYPES][DDT_CLASSES];
	ddt_object_t	ddt_object_stats[DDT_TYPES][DDT_CLASSES];
	avl_node_t	ddt_node;
};

/*
 * In-core and on-disk bookmark for DDT walks
 */
typedef struct ddt_bookmark {
	uint64_t	ddb_class;
	uint64_t	ddb_type;
	uint64_t	ddb_checksum;
	uint64_t	ddb_cursor;
} ddt_bookmark_t;

/*
 * Ops vector to access a specific DDT object type.
 */
typedef struct ddt_ops {
	char ddt_op_name[32];
	int (*ddt_op_create)(objset_t *os, uint64_t *object, dmu_tx_t *tx,
	    boolean_t prehash);
	int (*ddt_op_destroy)(objset_t *os, uint64_t object, dmu_tx_t *tx);
	int (*ddt_op_lookup)(objset_t *os, uint64_t object, ddt_entry_t *dde);
	void (*ddt_op_prefetch)(objset_t *os, uint64_t object,
	    ddt_entry_t *dde);
	int (*ddt_op_update)(objset_t *os, uint64_t object, ddt_entry_t *dde,
	    dmu_tx_t *tx);
	int (*ddt_op_remove)(objset_t *os, uint64_t object, ddt_entry_t *dde,
	    dmu_tx_t *tx);
	int (*ddt_op_walk)(objset_t *os, uint64_t object, ddt_entry_t *dde,
	    uint64_t *walk);
	int (*ddt_op_count)(objset_t *os, uint64_t object, uint64_t *count);
} ddt_ops_t;

#define	DDT_NAMELEN	80

extern void ddt_object_name(ddt_t *ddt, enum ddt_type type,
    enum ddt_class class, char *name);
extern int ddt_object_walk(ddt_t *ddt, enum ddt_type type,
    enum ddt_class class, uint64_t *walk, ddt_entry_t *dde);
extern int ddt_object_count(ddt_t *ddt, enum ddt_type type,
    enum ddt_class class, uint64_t *count);
extern int ddt_object_info(ddt_t *ddt, enum ddt_type type,
    enum ddt_class class, dmu_object_info_t *);
extern boolean_t ddt_object_exists(ddt_t *ddt, enum ddt_type type,
    enum ddt_class class);

extern void ddt_bp_fill(const ddt_phys_t *ddp, blkptr_t *bp,
    uint64_t txg);
extern void ddt_bp_create(enum zio_checksum checksum, const ddt_key_t *ddk,
    const ddt_phys_t *ddp, blkptr_t *bp);

extern void ddt_key_fill(ddt_key_t *ddk, const blkptr_t *bp);

extern void ddt_phys_fill(ddt_phys_t *ddp, const blkptr_t *bp);
extern void ddt_phys_clear(ddt_phys_t *ddp);
extern void ddt_phys_addref(ddt_phys_t *ddp);
extern void ddt_phys_decref(ddt_phys_t *ddp);
extern void ddt_phys_free(ddt_t *ddt, ddt_key_t *ddk, ddt_phys_t *ddp,
    uint64_t txg);
extern ddt_phys_t *ddt_phys_select(const ddt_entry_t *dde, const blkptr_t *bp);
extern uint64_t ddt_phys_total_refcnt(const ddt_entry_t *dde);

extern void ddt_stat_add(ddt_stat_t *dst, const ddt_stat_t *src, uint64_t neg);

extern void ddt_histogram_add(ddt_histogram_t *dst, const ddt_histogram_t *src);
extern void ddt_histogram_stat(ddt_stat_t *dds, const ddt_histogram_t *ddh);
extern boolean_t ddt_histogram_empty(const ddt_histogram_t *ddh);
extern void ddt_get_dedup_object_stats(spa_t *spa, ddt_object_t *ddo);
extern void ddt_get_dedup_histogram(spa_t *spa, ddt_histogram_t *ddh);
extern void ddt_get_dedup_stats(spa_t *spa, ddt_stat_t *dds_total);

extern uint64_t ddt_get_dedup_dspace(spa_t *spa);
extern uint64_t ddt_get_pool_dedup_ratio(spa_t *spa);

extern int ddt_ditto_copies_needed(ddt_t *ddt, ddt_entry_t *dde,
    ddt_phys_t *ddp_willref);
extern int ddt_ditto_copies_present(ddt_entry_t *dde);

extern size_t ddt_compress(void *src, uchar_t *dst, size_t s_len, size_t d_len);
extern void ddt_decompress(uchar_t *src, void *dst, size_t s_len, size_t d_len);

extern ddt_t *ddt_select(spa_t *spa, const blkptr_t *bp);
extern void ddt_enter(ddt_t *ddt);
extern void ddt_exit(ddt_t *ddt);
extern void ddt_init(void);
extern void ddt_fini(void);
extern ddt_entry_t *ddt_lookup(ddt_t *ddt, const blkptr_t *bp, boolean_t add);
extern void ddt_prefetch(spa_t *spa, const blkptr_t *bp);
extern void ddt_remove(ddt_t *ddt, ddt_entry_t *dde);

extern boolean_t ddt_class_contains(spa_t *spa, enum ddt_class max_class,
    const blkptr_t *bp);

extern ddt_entry_t *ddt_repair_start(ddt_t *ddt, const blkptr_t *bp);
extern void ddt_repair_done(ddt_t *ddt, ddt_entry_t *dde);

extern int ddt_entry_compare(const void *x1, const void *x2);

extern void ddt_create(spa_t *spa);
extern int ddt_load(spa_t *spa);
extern void ddt_unload(spa_t *spa);
extern void ddt_sync(spa_t *spa, uint64_t txg);
extern int ddt_walk(spa_t *spa, ddt_bookmark_t *ddb, ddt_entry_t *dde);
extern int ddt_object_update(ddt_t *ddt, enum ddt_type type,
    enum ddt_class class, ddt_entry_t *dde, dmu_tx_t *tx);

extern const ddt_ops_t ddt_zap_ops;

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DDT_H */
                                                                                                                                                                                                                                                                                                                                                                usr/src/zfs-0.6.5.9/include/sys/dmu.h                                                               0100644 0000000 0000000 00000101246 13045171016 015463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 * Copyright 2014 HybridCluster. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

/* Portions Copyright 2010 Robert Milkowski */

#ifndef	_SYS_DMU_H
#define	_SYS_DMU_H

/*
 * This file describes the interface that the DMU provides for its
 * consumers.
 *
 * The DMU also interacts with the SPA.  That interface is described in
 * dmu_spa.h.
 */

#include <sys/zfs_context.h>
#include <sys/inttypes.h>
#include <sys/cred.h>
#include <sys/fs/zfs.h>
#include <sys/uio.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct page;
struct vnode;
struct spa;
struct zilog;
struct zio;
struct blkptr;
struct zap_cursor;
struct dsl_dataset;
struct dsl_pool;
struct dnode;
struct drr_begin;
struct drr_end;
struct zbookmark_phys;
struct spa;
struct nvlist;
struct arc_buf;
struct zio_prop;
struct sa_handle;

typedef struct objset objset_t;
typedef struct dmu_tx dmu_tx_t;
typedef struct dsl_dir dsl_dir_t;

typedef enum dmu_object_byteswap {
	DMU_BSWAP_UINT8,
	DMU_BSWAP_UINT16,
	DMU_BSWAP_UINT32,
	DMU_BSWAP_UINT64,
	DMU_BSWAP_ZAP,
	DMU_BSWAP_DNODE,
	DMU_BSWAP_OBJSET,
	DMU_BSWAP_ZNODE,
	DMU_BSWAP_OLDACL,
	DMU_BSWAP_ACL,
	/*
	 * Allocating a new byteswap type number makes the on-disk format
	 * incompatible with any other format that uses the same number.
	 *
	 * Data can usually be structured to work with one of the
	 * DMU_BSWAP_UINT* or DMU_BSWAP_ZAP types.
	 */
	DMU_BSWAP_NUMFUNCS
} dmu_object_byteswap_t;

#define	DMU_OT_NEWTYPE 0x80
#define	DMU_OT_METADATA 0x40
#define	DMU_OT_BYTESWAP_MASK 0x3f

/*
 * Defines a uint8_t object type. Object types specify if the data
 * in the object is metadata (boolean) and how to byteswap the data
 * (dmu_object_byteswap_t).
 */
#define	DMU_OT(byteswap, metadata) \
	(DMU_OT_NEWTYPE | \
	((metadata) ? DMU_OT_METADATA : 0) | \
	((byteswap) & DMU_OT_BYTESWAP_MASK))

#define	DMU_OT_IS_VALID(ot) (((ot) & DMU_OT_NEWTYPE) ? \
	((ot) & DMU_OT_BYTESWAP_MASK) < DMU_BSWAP_NUMFUNCS : \
	(ot) < DMU_OT_NUMTYPES)

#define	DMU_OT_IS_METADATA(ot) (((ot) & DMU_OT_NEWTYPE) ? \
	((ot) & DMU_OT_METADATA) : \
	dmu_ot[(int)(ot)].ot_metadata)

/*
 * These object types use bp_fill != 1 for their L0 bp's. Therefore they can't
 * have their data embedded (i.e. use a BP_IS_EMBEDDED() bp), because bp_fill
 * is repurposed for embedded BPs.
 */
#define	DMU_OT_HAS_FILL(ot) \
	((ot) == DMU_OT_DNODE || (ot) == DMU_OT_OBJSET)

#define	DMU_OT_BYTESWAP(ot) (((ot) & DMU_OT_NEWTYPE) ? \
	((ot) & DMU_OT_BYTESWAP_MASK) : \
	dmu_ot[(int)(ot)].ot_byteswap)

typedef enum dmu_object_type {
	DMU_OT_NONE,
	/* general: */
	DMU_OT_OBJECT_DIRECTORY,	/* ZAP */
	DMU_OT_OBJECT_ARRAY,		/* UINT64 */
	DMU_OT_PACKED_NVLIST,		/* UINT8 (XDR by nvlist_pack/unpack) */
	DMU_OT_PACKED_NVLIST_SIZE,	/* UINT64 */
	DMU_OT_BPOBJ,			/* UINT64 */
	DMU_OT_BPOBJ_HDR,		/* UINT64 */
	/* spa: */
	DMU_OT_SPACE_MAP_HEADER,	/* UINT64 */
	DMU_OT_SPACE_MAP,		/* UINT64 */
	/* zil: */
	DMU_OT_INTENT_LOG,		/* UINT64 */
	/* dmu: */
	DMU_OT_DNODE,			/* DNODE */
	DMU_OT_OBJSET,			/* OBJSET */
	/* dsl: */
	DMU_OT_DSL_DIR,			/* UINT64 */
	DMU_OT_DSL_DIR_CHILD_MAP,	/* ZAP */
	DMU_OT_DSL_DS_SNAP_MAP,		/* ZAP */
	DMU_OT_DSL_PROPS,		/* ZAP */
	DMU_OT_DSL_DATASET,		/* UINT64 */
	/* zpl: */
	DMU_OT_ZNODE,			/* ZNODE */
	DMU_OT_OLDACL,			/* Old ACL */
	DMU_OT_PLAIN_FILE_CONTENTS,	/* UINT8 */
	DMU_OT_DIRECTORY_CONTENTS,	/* ZAP */
	DMU_OT_MASTER_NODE,		/* ZAP */
	DMU_OT_UNLINKED_SET,		/* ZAP */
	/* zvol: */
	DMU_OT_ZVOL,			/* UINT8 */
	DMU_OT_ZVOL_PROP,		/* ZAP */
	/* other; for testing only! */
	DMU_OT_PLAIN_OTHER,		/* UINT8 */
	DMU_OT_UINT64_OTHER,		/* UINT64 */
	DMU_OT_ZAP_OTHER,		/* ZAP */
	/* new object types: */
	DMU_OT_ERROR_LOG,		/* ZAP */
	DMU_OT_SPA_HISTORY,		/* UINT8 */
	DMU_OT_SPA_HISTORY_OFFSETS,	/* spa_his_phys_t */
	DMU_OT_POOL_PROPS,		/* ZAP */
	DMU_OT_DSL_PERMS,		/* ZAP */
	DMU_OT_ACL,			/* ACL */
	DMU_OT_SYSACL,			/* SYSACL */
	DMU_OT_FUID,			/* FUID table (Packed NVLIST UINT8) */
	DMU_OT_FUID_SIZE,		/* FUID table size UINT64 */
	DMU_OT_NEXT_CLONES,		/* ZAP */
	DMU_OT_SCAN_QUEUE,		/* ZAP */
	DMU_OT_USERGROUP_USED,		/* ZAP */
	DMU_OT_USERGROUP_QUOTA,		/* ZAP */
	DMU_OT_USERREFS,		/* ZAP */
	DMU_OT_DDT_ZAP,			/* ZAP */
	DMU_OT_DDT_STATS,		/* ZAP */
	DMU_OT_SA,			/* System attr */
	DMU_OT_SA_MASTER_NODE,		/* ZAP */
	DMU_OT_SA_ATTR_REGISTRATION,	/* ZAP */
	DMU_OT_SA_ATTR_LAYOUTS,		/* ZAP */
	DMU_OT_SCAN_XLATE,		/* ZAP */
	DMU_OT_DEDUP,			/* fake dedup BP from ddt_bp_create() */
	DMU_OT_DEADLIST,		/* ZAP */
	DMU_OT_DEADLIST_HDR,		/* UINT64 */
	DMU_OT_DSL_CLONES,		/* ZAP */
	DMU_OT_BPOBJ_SUBOBJ,		/* UINT64 */
	/*
	 * Do not allocate new object types here. Doing so makes the on-disk
	 * format incompatible with any other format that uses the same object
	 * type number.
	 *
	 * When creating an object which does not have one of the above types
	 * use the DMU_OTN_* type with the correct byteswap and metadata
	 * values.
	 *
	 * The DMU_OTN_* types do not have entries in the dmu_ot table,
	 * use the DMU_OT_IS_METDATA() and DMU_OT_BYTESWAP() macros instead
	 * of indexing into dmu_ot directly (this works for both DMU_OT_* types
	 * and DMU_OTN_* types).
	 */
	DMU_OT_NUMTYPES,

	/*
	 * Names for valid types declared with DMU_OT().
	 */
	DMU_OTN_UINT8_DATA = DMU_OT(DMU_BSWAP_UINT8, B_FALSE),
	DMU_OTN_UINT8_METADATA = DMU_OT(DMU_BSWAP_UINT8, B_TRUE),
	DMU_OTN_UINT16_DATA = DMU_OT(DMU_BSWAP_UINT16, B_FALSE),
	DMU_OTN_UINT16_METADATA = DMU_OT(DMU_BSWAP_UINT16, B_TRUE),
	DMU_OTN_UINT32_DATA = DMU_OT(DMU_BSWAP_UINT32, B_FALSE),
	DMU_OTN_UINT32_METADATA = DMU_OT(DMU_BSWAP_UINT32, B_TRUE),
	DMU_OTN_UINT64_DATA = DMU_OT(DMU_BSWAP_UINT64, B_FALSE),
	DMU_OTN_UINT64_METADATA = DMU_OT(DMU_BSWAP_UINT64, B_TRUE),
	DMU_OTN_ZAP_DATA = DMU_OT(DMU_BSWAP_ZAP, B_FALSE),
	DMU_OTN_ZAP_METADATA = DMU_OT(DMU_BSWAP_ZAP, B_TRUE),
} dmu_object_type_t;

typedef enum txg_how {
	TXG_WAIT = 1,
	TXG_NOWAIT,
	TXG_WAITED,
} txg_how_t;

void byteswap_uint64_array(void *buf, size_t size);
void byteswap_uint32_array(void *buf, size_t size);
void byteswap_uint16_array(void *buf, size_t size);
void byteswap_uint8_array(void *buf, size_t size);
void zap_byteswap(void *buf, size_t size);
void zfs_oldacl_byteswap(void *buf, size_t size);
void zfs_acl_byteswap(void *buf, size_t size);
void zfs_znode_byteswap(void *buf, size_t size);

#define	DS_FIND_SNAPSHOTS	(1<<0)
#define	DS_FIND_CHILDREN	(1<<1)
#define	DS_FIND_SERIALIZE	(1<<2)

/*
 * The maximum number of bytes that can be accessed as part of one
 * operation, including metadata.
 */
#define	DMU_MAX_ACCESS (64 * 1024 * 1024) /* 64MB */
#define	DMU_MAX_DELETEBLKCNT (20480) /* ~5MB of indirect blocks */

#define	DMU_USERUSED_OBJECT	(-1ULL)
#define	DMU_GROUPUSED_OBJECT	(-2ULL)

/*
 * artificial blkids for bonus buffer and spill blocks
 */
#define	DMU_BONUS_BLKID		(-1ULL)
#define	DMU_SPILL_BLKID		(-2ULL)
/*
 * Public routines to create, destroy, open, and close objsets.
 */
int dmu_objset_hold(const char *name, void *tag, objset_t **osp);
int dmu_objset_own(const char *name, dmu_objset_type_t type,
    boolean_t readonly, void *tag, objset_t **osp);
void dmu_objset_rele(objset_t *os, void *tag);
void dmu_objset_disown(objset_t *os, void *tag);
int dmu_objset_open_ds(struct dsl_dataset *ds, objset_t **osp);

void dmu_objset_evict_dbufs(objset_t *os);
int dmu_objset_create(const char *name, dmu_objset_type_t type, uint64_t flags,
    void (*func)(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx), void *arg);
int dmu_objset_clone(const char *name, const char *origin);
int dsl_destroy_snapshots_nvl(struct nvlist *snaps, boolean_t defer,
    struct nvlist *errlist);
int dmu_objset_snapshot_one(const char *fsname, const char *snapname);
int dmu_objset_snapshot_tmp(const char *, const char *, int);
int dmu_objset_find(char *name, int func(const char *, void *), void *arg,
    int flags);
void dmu_objset_byteswap(void *buf, size_t size);
int dsl_dataset_rename_snapshot(const char *fsname,
    const char *oldsnapname, const char *newsnapname, boolean_t recursive);

typedef struct dmu_buf {
	uint64_t db_object;		/* object that this buffer is part of */
	uint64_t db_offset;		/* byte offset in this object */
	uint64_t db_size;		/* size of buffer in bytes */
	void *db_data;			/* data in buffer */
} dmu_buf_t;

/*
 * The names of zap entries in the DIRECTORY_OBJECT of the MOS.
 */
#define	DMU_POOL_DIRECTORY_OBJECT	1
#define	DMU_POOL_CONFIG			"config"
#define	DMU_POOL_FEATURES_FOR_WRITE	"features_for_write"
#define	DMU_POOL_FEATURES_FOR_READ	"features_for_read"
#define	DMU_POOL_FEATURE_DESCRIPTIONS	"feature_descriptions"
#define	DMU_POOL_FEATURE_ENABLED_TXG	"feature_enabled_txg"
#define	DMU_POOL_ROOT_DATASET		"root_dataset"
#define	DMU_POOL_SYNC_BPOBJ		"sync_bplist"
#define	DMU_POOL_ERRLOG_SCRUB		"errlog_scrub"
#define	DMU_POOL_ERRLOG_LAST		"errlog_last"
#define	DMU_POOL_SPARES			"spares"
#define	DMU_POOL_DEFLATE		"deflate"
#define	DMU_POOL_HISTORY		"history"
#define	DMU_POOL_PROPS			"pool_props"
#define	DMU_POOL_L2CACHE		"l2cache"
#define	DMU_POOL_TMP_USERREFS		"tmp_userrefs"
#define	DMU_POOL_DDT			"DDT-%s-%s-%s"
#define	DMU_POOL_DDT_STATS		"DDT-statistics"
#define	DMU_POOL_CREATION_VERSION	"creation_version"
#define	DMU_POOL_SCAN			"scan"
#define	DMU_POOL_FREE_BPOBJ		"free_bpobj"
#define	DMU_POOL_BPTREE_OBJ		"bptree_obj"
#define	DMU_POOL_EMPTY_BPOBJ		"empty_bpobj"

/*
 * Allocate an object from this objset.  The range of object numbers
 * available is (0, DN_MAX_OBJECT).  Object 0 is the meta-dnode.
 *
 * The transaction must be assigned to a txg.  The newly allocated
 * object will be "held" in the transaction (ie. you can modify the
 * newly allocated object in this transaction).
 *
 * dmu_object_alloc() chooses an object and returns it in *objectp.
 *
 * dmu_object_claim() allocates a specific object number.  If that
 * number is already allocated, it fails and returns EEXIST.
 *
 * Return 0 on success, or ENOSPC or EEXIST as specified above.
 */
uint64_t dmu_object_alloc(objset_t *os, dmu_object_type_t ot,
    int blocksize, dmu_object_type_t bonus_type, int bonus_len, dmu_tx_t *tx);
int dmu_object_claim(objset_t *os, uint64_t object, dmu_object_type_t ot,
    int blocksize, dmu_object_type_t bonus_type, int bonus_len, dmu_tx_t *tx);
int dmu_object_reclaim(objset_t *os, uint64_t object, dmu_object_type_t ot,
    int blocksize, dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *txp);

/*
 * Free an object from this objset.
 *
 * The object's data will be freed as well (ie. you don't need to call
 * dmu_free(object, 0, -1, tx)).
 *
 * The object need not be held in the transaction.
 *
 * If there are any holds on this object's buffers (via dmu_buf_hold()),
 * or tx holds on the object (via dmu_tx_hold_object()), you can not
 * free it; it fails and returns EBUSY.
 *
 * If the object is not allocated, it fails and returns ENOENT.
 *
 * Return 0 on success, or EBUSY or ENOENT as specified above.
 */
int dmu_object_free(objset_t *os, uint64_t object, dmu_tx_t *tx);

/*
 * Find the next allocated or free object.
 *
 * The objectp parameter is in-out.  It will be updated to be the next
 * object which is allocated.  Ignore objects which have not been
 * modified since txg.
 *
 * XXX Can only be called on a objset with no dirty data.
 *
 * Returns 0 on success, or ENOENT if there are no more objects.
 */
int dmu_object_next(objset_t *os, uint64_t *objectp,
    boolean_t hole, uint64_t txg);

/*
 * Set the data blocksize for an object.
 *
 * The object cannot have any blocks allcated beyond the first.  If
 * the first block is allocated already, the new size must be greater
 * than the current block size.  If these conditions are not met,
 * ENOTSUP will be returned.
 *
 * Returns 0 on success, or EBUSY if there are any holds on the object
 * contents, or ENOTSUP as described above.
 */
int dmu_object_set_blocksize(objset_t *os, uint64_t object, uint64_t size,
    int ibs, dmu_tx_t *tx);

/*
 * Set the checksum property on a dnode.  The new checksum algorithm will
 * apply to all newly written blocks; existing blocks will not be affected.
 */
void dmu_object_set_checksum(objset_t *os, uint64_t object, uint8_t checksum,
    dmu_tx_t *tx);

/*
 * Set the compress property on a dnode.  The new compression algorithm will
 * apply to all newly written blocks; existing blocks will not be affected.
 */
void dmu_object_set_compress(objset_t *os, uint64_t object, uint8_t compress,
    dmu_tx_t *tx);

void
dmu_write_embedded(objset_t *os, uint64_t object, uint64_t offset,
    void *data, uint8_t etype, uint8_t comp, int uncompressed_size,
    int compressed_size, int byteorder, dmu_tx_t *tx);

/*
 * Decide how to write a block: checksum, compression, number of copies, etc.
 */
#define	WP_NOFILL	0x1
#define	WP_DMU_SYNC	0x2
#define	WP_SPILL	0x4

void dmu_write_policy(objset_t *os, struct dnode *dn, int level, int wp,
    struct zio_prop *zp);
/*
 * The bonus data is accessed more or less like a regular buffer.
 * You must dmu_bonus_hold() to get the buffer, which will give you a
 * dmu_buf_t with db_offset==-1ULL, and db_size = the size of the bonus
 * data.  As with any normal buffer, you must call dmu_buf_read() to
 * read db_data, dmu_buf_will_dirty() before modifying it, and the
 * object must be held in an assigned transaction before calling
 * dmu_buf_will_dirty.  You may use dmu_buf_set_user() on the bonus
 * buffer as well.  You must release what you hold with dmu_buf_rele().
 *
 * Returns ENOENT, EIO, or 0.
 */
int dmu_bonus_hold(objset_t *os, uint64_t object, void *tag, dmu_buf_t **);
int dmu_bonus_max(void);
int dmu_set_bonus(dmu_buf_t *, int, dmu_tx_t *);
int dmu_set_bonustype(dmu_buf_t *, dmu_object_type_t, dmu_tx_t *);
dmu_object_type_t dmu_get_bonustype(dmu_buf_t *);
int dmu_rm_spill(objset_t *, uint64_t, dmu_tx_t *);

/*
 * Special spill buffer support used by "SA" framework
 */

int dmu_spill_hold_by_bonus(dmu_buf_t *bonus, void *tag, dmu_buf_t **dbp);
int dmu_spill_hold_by_dnode(struct dnode *dn, uint32_t flags,
    void *tag, dmu_buf_t **dbp);
int dmu_spill_hold_existing(dmu_buf_t *bonus, void *tag, dmu_buf_t **dbp);

/*
 * Obtain the DMU buffer from the specified object which contains the
 * specified offset.  dmu_buf_hold() puts a "hold" on the buffer, so
 * that it will remain in memory.  You must release the hold with
 * dmu_buf_rele().  You must not access the dmu_buf_t after releasing
 * what you hold.  You must have a hold on any dmu_buf_t* you pass to the DMU.
 *
 * You must call dmu_buf_read, dmu_buf_will_dirty, or dmu_buf_will_fill
 * on the returned buffer before reading or writing the buffer's
 * db_data.  The comments for those routines describe what particular
 * operations are valid after calling them.
 *
 * The object number must be a valid, allocated object number.
 */
int dmu_buf_hold(objset_t *os, uint64_t object, uint64_t offset,
    void *tag, dmu_buf_t **, int flags);

/*
 * Add a reference to a dmu buffer that has already been held via
 * dmu_buf_hold() in the current context.
 */
void dmu_buf_add_ref(dmu_buf_t *db, void* tag);

/*
 * Attempt to add a reference to a dmu buffer that is in an unknown state,
 * using a pointer that may have been invalidated by eviction processing.
 * The request will succeed if the passed in dbuf still represents the
 * same os/object/blkid, is ineligible for eviction, and has at least
 * one hold by a user other than the syncer.
 */
boolean_t dmu_buf_try_add_ref(dmu_buf_t *, objset_t *os, uint64_t object,
    uint64_t blkid, void *tag);

void dmu_buf_rele(dmu_buf_t *db, void *tag);
uint64_t dmu_buf_refcount(dmu_buf_t *db);

/*
 * dmu_buf_hold_array holds the DMU buffers which contain all bytes in a
 * range of an object.  A pointer to an array of dmu_buf_t*'s is
 * returned (in *dbpp).
 *
 * dmu_buf_rele_array releases the hold on an array of dmu_buf_t*'s, and
 * frees the array.  The hold on the array of buffers MUST be released
 * with dmu_buf_rele_array.  You can NOT release the hold on each buffer
 * individually with dmu_buf_rele.
 */
int dmu_buf_hold_array_by_bonus(dmu_buf_t *db, uint64_t offset,
    uint64_t length, int read, void *tag, int *numbufsp, dmu_buf_t ***dbpp);
void dmu_buf_rele_array(dmu_buf_t **, int numbufs, void *tag);

typedef void dmu_buf_evict_func_t(void *user_ptr);

/*
 * A DMU buffer user object may be associated with a dbuf for the
 * duration of its lifetime.  This allows the user of a dbuf (client)
 * to attach private data to a dbuf (e.g. in-core only data such as a
 * dnode_children_t, zap_t, or zap_leaf_t) and be optionally notified
 * when that dbuf has been evicted.  Clients typically respond to the
 * eviction notification by freeing their private data, thus ensuring
 * the same lifetime for both dbuf and private data.
 *
 * The mapping from a dmu_buf_user_t to any client private data is the
 * client's responsibility.  All current consumers of the API with private
 * data embed a dmu_buf_user_t as the first member of the structure for
 * their private data.  This allows conversions between the two types
 * with a simple cast.  Since the DMU buf user API never needs access
 * to the private data, other strategies can be employed if necessary
 * or convenient for the client (e.g. using container_of() to do the
 * conversion for private data that cannot have the dmu_buf_user_t as
 * its first member).
 *
 * Eviction callbacks are executed without the dbuf mutex held or any
 * other type of mechanism to guarantee that the dbuf is still available.
 * For this reason, users must assume the dbuf has already been freed
 * and not reference the dbuf from the callback context.
 *
 * Users requesting "immediate eviction" are notified as soon as the dbuf
 * is only referenced by dirty records (dirties == holds).  Otherwise the
 * notification occurs after eviction processing for the dbuf begins.
 */
typedef struct dmu_buf_user {
	/*
	 * Asynchronous user eviction callback state.
	 */
	taskq_ent_t	dbu_tqent;

	/* This instance's eviction function pointer. */
	dmu_buf_evict_func_t *dbu_evict_func;
#ifdef ZFS_DEBUG
	/*
	 * Pointer to user's dbuf pointer.  NULL for clients that do
	 * not associate a dbuf with their user data.
	 *
	 * The dbuf pointer is cleared upon eviction so as to catch
	 * use-after-evict bugs in clients.
	 */
	dmu_buf_t **dbu_clear_on_evict_dbufp;
#endif
} dmu_buf_user_t;

/*
 * Initialize the given dmu_buf_user_t instance with the eviction function
 * evict_func, to be called when the user is evicted.
 *
 * NOTE: This function should only be called once on a given dmu_buf_user_t.
 *       To allow enforcement of this, dbu must already be zeroed on entry.
 */
#ifdef __lint
/* Very ugly, but it beats issuing suppression directives in many Makefiles. */
extern void
dmu_buf_init_user(dmu_buf_user_t *dbu, dmu_buf_evict_func_t *evict_func,
    dmu_buf_t **clear_on_evict_dbufp);
#else /* __lint */
static inline void
dmu_buf_init_user(dmu_buf_user_t *dbu, dmu_buf_evict_func_t *evict_func,
    dmu_buf_t **clear_on_evict_dbufp)
{
	ASSERT(dbu->dbu_evict_func == NULL);
	ASSERT(evict_func != NULL);
	dbu->dbu_evict_func = evict_func;
	taskq_init_ent(&dbu->dbu_tqent);
#ifdef ZFS_DEBUG
	dbu->dbu_clear_on_evict_dbufp = clear_on_evict_dbufp;
#endif
}
#endif /* __lint */

/*
 * Attach user data to a dbuf and mark it for normal (when the dbuf's
 * data is cleared or its reference count goes to zero) eviction processing.
 *
 * Returns NULL on success, or the existing user if another user currently
 * owns the buffer.
 */
void *dmu_buf_set_user(dmu_buf_t *db, dmu_buf_user_t *user);

/*
 * Attach user data to a dbuf and mark it for immediate (its dirty and
 * reference counts are equal) eviction processing.
 *
 * Returns NULL on success, or the existing user if another user currently
 * owns the buffer.
 */
void *dmu_buf_set_user_ie(dmu_buf_t *db, dmu_buf_user_t *user);

/*
 * Replace the current user of a dbuf.
 *
 * If given the current user of a dbuf, replaces the dbuf's user with
 * "new_user" and returns the user data pointer that was replaced.
 * Otherwise returns the current, and unmodified, dbuf user pointer.
 */
void *dmu_buf_replace_user(dmu_buf_t *db,
    dmu_buf_user_t *old_user, dmu_buf_user_t *new_user);

/*
 * Remove the specified user data for a DMU buffer.
 *
 * Returns the user that was removed on success, or the current user if
 * another user currently owns the buffer.
 */
void *dmu_buf_remove_user(dmu_buf_t *db, dmu_buf_user_t *user);

/*
 * Returns the user data (dmu_buf_user_t *) associated with this dbuf.
 */
void *dmu_buf_get_user(dmu_buf_t *db);

/* Block until any in-progress dmu buf user evictions complete. */
void dmu_buf_user_evict_wait(void);

/*
 * Returns the blkptr associated with this dbuf, or NULL if not set.
 */
struct blkptr *dmu_buf_get_blkptr(dmu_buf_t *db);

/*
 * Indicate that you are going to modify the buffer's data (db_data).
 *
 * The transaction (tx) must be assigned to a txg (ie. you've called
 * dmu_tx_assign()).  The buffer's object must be held in the tx
 * (ie. you've called dmu_tx_hold_object(tx, db->db_object)).
 */
void dmu_buf_will_dirty(dmu_buf_t *db, dmu_tx_t *tx);

/*
 * Tells if the given dbuf is freeable.
 */
boolean_t dmu_buf_freeable(dmu_buf_t *);

/*
 * You must create a transaction, then hold the objects which you will
 * (or might) modify as part of this transaction.  Then you must assign
 * the transaction to a transaction group.  Once the transaction has
 * been assigned, you can modify buffers which belong to held objects as
 * part of this transaction.  You can't modify buffers before the
 * transaction has been assigned; you can't modify buffers which don't
 * belong to objects which this transaction holds; you can't hold
 * objects once the transaction has been assigned.  You may hold an
 * object which you are going to free (with dmu_object_free()), but you
 * don't have to.
 *
 * You can abort the transaction before it has been assigned.
 *
 * Note that you may hold buffers (with dmu_buf_hold) at any time,
 * regardless of transaction state.
 */

#define	DMU_NEW_OBJECT	(-1ULL)
#define	DMU_OBJECT_END	(-1ULL)

dmu_tx_t *dmu_tx_create(objset_t *os);
void dmu_tx_hold_write(dmu_tx_t *tx, uint64_t object, uint64_t off, int len);
void dmu_tx_hold_free(dmu_tx_t *tx, uint64_t object, uint64_t off,
    uint64_t len);
void dmu_tx_hold_zap(dmu_tx_t *tx, uint64_t object, int add, const char *name);
void dmu_tx_hold_bonus(dmu_tx_t *tx, uint64_t object);
void dmu_tx_hold_spill(dmu_tx_t *tx, uint64_t object);
void dmu_tx_hold_sa(dmu_tx_t *tx, struct sa_handle *hdl, boolean_t may_grow);
void dmu_tx_hold_sa_create(dmu_tx_t *tx, int total_size);
void dmu_tx_abort(dmu_tx_t *tx);
int dmu_tx_assign(dmu_tx_t *tx, enum txg_how txg_how);
void dmu_tx_wait(dmu_tx_t *tx);
void dmu_tx_commit(dmu_tx_t *tx);

/*
 * To register a commit callback, dmu_tx_callback_register() must be called.
 *
 * dcb_data is a pointer to caller private data that is passed on as a
 * callback parameter. The caller is responsible for properly allocating and
 * freeing it.
 *
 * When registering a callback, the transaction must be already created, but
 * it cannot be committed or aborted. It can be assigned to a txg or not.
 *
 * The callback will be called after the transaction has been safely written
 * to stable storage and will also be called if the dmu_tx is aborted.
 * If there is any error which prevents the transaction from being committed to
 * disk, the callback will be called with a value of error != 0.
 */
typedef void dmu_tx_callback_func_t(void *dcb_data, int error);

void dmu_tx_callback_register(dmu_tx_t *tx, dmu_tx_callback_func_t *dcb_func,
    void *dcb_data);

/*
 * Free up the data blocks for a defined range of a file.  If size is
 * -1, the range from offset to end-of-file is freed.
 */
int dmu_free_range(objset_t *os, uint64_t object, uint64_t offset,
	uint64_t size, dmu_tx_t *tx);
int dmu_free_long_range(objset_t *os, uint64_t object, uint64_t offset,
	uint64_t size);
int dmu_free_long_object(objset_t *os, uint64_t object);

/*
 * Convenience functions.
 *
 * Canfail routines will return 0 on success, or an errno if there is a
 * nonrecoverable I/O error.
 */
#define	DMU_READ_PREFETCH	0 /* prefetch */
#define	DMU_READ_NO_PREFETCH	1 /* don't prefetch */
int dmu_read(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
	void *buf, uint32_t flags);
void dmu_write(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
	const void *buf, dmu_tx_t *tx);
void dmu_prealloc(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
	dmu_tx_t *tx);
#ifdef _KERNEL
#include <linux/blkdev_compat.h>
int dmu_read_bio(objset_t *os, uint64_t object, struct bio *bio);
int dmu_write_bio(objset_t *os, uint64_t object, struct bio *bio,
	dmu_tx_t *tx);
int dmu_read_uio(objset_t *os, uint64_t object, struct uio *uio, uint64_t size);
int dmu_read_uio_dbuf(dmu_buf_t *zdb, struct uio *uio, uint64_t size);
int dmu_write_uio(objset_t *os, uint64_t object, struct uio *uio, uint64_t size,
	dmu_tx_t *tx);
int dmu_write_uio_dbuf(dmu_buf_t *zdb, struct uio *uio, uint64_t size,
	dmu_tx_t *tx);
#endif
struct arc_buf *dmu_request_arcbuf(dmu_buf_t *handle, int size);
void dmu_return_arcbuf(struct arc_buf *buf);
void dmu_assign_arcbuf(dmu_buf_t *handle, uint64_t offset, struct arc_buf *buf,
    dmu_tx_t *tx);
int dmu_xuio_init(struct xuio *uio, int niov);
void dmu_xuio_fini(struct xuio *uio);
int dmu_xuio_add(struct xuio *uio, struct arc_buf *abuf, offset_t off,
    size_t n);
int dmu_xuio_cnt(struct xuio *uio);
struct arc_buf *dmu_xuio_arcbuf(struct xuio *uio, int i);
void dmu_xuio_clear(struct xuio *uio, int i);
void xuio_stat_wbuf_copied(void);
void xuio_stat_wbuf_nocopy(void);

extern int zfs_prefetch_disable;
extern int zfs_max_recordsize;

/*
 * Asynchronously try to read in the data.
 */
void dmu_prefetch(objset_t *os, uint64_t object, uint64_t offset,
    uint64_t len);

typedef struct dmu_object_info {
	/* All sizes are in bytes unless otherwise indicated. */
	uint32_t doi_data_block_size;
	uint32_t doi_metadata_block_size;
	dmu_object_type_t doi_type;
	dmu_object_type_t doi_bonus_type;
	uint64_t doi_bonus_size;
	uint8_t doi_indirection;		/* 2 = dnode->indirect->data */
	uint8_t doi_checksum;
	uint8_t doi_compress;
	uint8_t doi_nblkptr;
	uint8_t doi_pad[4];
	uint64_t doi_physical_blocks_512;	/* data + metadata, 512b blks */
	uint64_t doi_max_offset;
	uint64_t doi_fill_count;		/* number of non-empty blocks */
} dmu_object_info_t;

typedef void (*const arc_byteswap_func_t)(void *buf, size_t size);

typedef struct dmu_object_type_info {
	dmu_object_byteswap_t	ot_byteswap;
	boolean_t		ot_metadata;
	char			*ot_name;
} dmu_object_type_info_t;

typedef const struct dmu_object_byteswap_info {
	arc_byteswap_func_t	 ob_func;
	char			*ob_name;
} dmu_object_byteswap_info_t;

extern const dmu_object_type_info_t dmu_ot[DMU_OT_NUMTYPES];
extern const dmu_object_byteswap_info_t dmu_ot_byteswap[DMU_BSWAP_NUMFUNCS];

/*
 * Get information on a DMU object.
 *
 * Return 0 on success or ENOENT if object is not allocated.
 *
 * If doi is NULL, just indicates whether the object exists.
 */
int dmu_object_info(objset_t *os, uint64_t object, dmu_object_info_t *doi);
void __dmu_object_info_from_dnode(struct dnode *dn, dmu_object_info_t *doi);
/* Like dmu_object_info, but faster if you have a held dnode in hand. */
void dmu_object_info_from_dnode(struct dnode *dn, dmu_object_info_t *doi);
/* Like dmu_object_info, but faster if you have a held dbuf in hand. */
void dmu_object_info_from_db(dmu_buf_t *db, dmu_object_info_t *doi);
/*
 * Like dmu_object_info_from_db, but faster still when you only care about
 * the size.  This is specifically optimized for zfs_getattr().
 */
void dmu_object_size_from_db(dmu_buf_t *db, uint32_t *blksize,
    u_longlong_t *nblk512);

typedef struct dmu_objset_stats {
	uint64_t dds_num_clones; /* number of clones of this */
	uint64_t dds_creation_txg;
	uint64_t dds_guid;
	dmu_objset_type_t dds_type;
	uint8_t dds_is_snapshot;
	uint8_t dds_inconsistent;
	char dds_origin[MAXNAMELEN];
} dmu_objset_stats_t;

/*
 * Get stats on a dataset.
 */
void dmu_objset_fast_stat(objset_t *os, dmu_objset_stats_t *stat);

/*
 * Add entries to the nvlist for all the objset's properties.  See
 * zfs_prop_table[] and zfs(1m) for details on the properties.
 */
void dmu_objset_stats(objset_t *os, struct nvlist *nv);

/*
 * Get the space usage statistics for statvfs().
 *
 * refdbytes is the amount of space "referenced" by this objset.
 * availbytes is the amount of space available to this objset, taking
 * into account quotas & reservations, assuming that no other objsets
 * use the space first.  These values correspond to the 'referenced' and
 * 'available' properties, described in the zfs(1m) manpage.
 *
 * usedobjs and availobjs are the number of objects currently allocated,
 * and available.
 */
void dmu_objset_space(objset_t *os, uint64_t *refdbytesp, uint64_t *availbytesp,
    uint64_t *usedobjsp, uint64_t *availobjsp);

/*
 * The fsid_guid is a 56-bit ID that can change to avoid collisions.
 * (Contrast with the ds_guid which is a 64-bit ID that will never
 * change, so there is a small probability that it will collide.)
 */
uint64_t dmu_objset_fsid_guid(objset_t *os);

/*
 * Get the [cm]time for an objset's snapshot dir
 */
timestruc_t dmu_objset_snap_cmtime(objset_t *os);

int dmu_objset_is_snapshot(objset_t *os);

extern struct spa *dmu_objset_spa(objset_t *os);
extern struct zilog *dmu_objset_zil(objset_t *os);
extern struct dsl_pool *dmu_objset_pool(objset_t *os);
extern struct dsl_dataset *dmu_objset_ds(objset_t *os);
extern void dmu_objset_name(objset_t *os, char *buf);
extern dmu_objset_type_t dmu_objset_type(objset_t *os);
extern uint64_t dmu_objset_id(objset_t *os);
extern zfs_sync_type_t dmu_objset_syncprop(objset_t *os);
extern zfs_logbias_op_t dmu_objset_logbias(objset_t *os);
extern int dmu_snapshot_list_next(objset_t *os, int namelen, char *name,
    uint64_t *id, uint64_t *offp, boolean_t *case_conflict);
extern int dmu_snapshot_lookup(objset_t *os, const char *name, uint64_t *val);
extern int dmu_snapshot_realname(objset_t *os, char *name, char *real,
    int maxlen, boolean_t *conflict);
extern int dmu_dir_list_next(objset_t *os, int namelen, char *name,
    uint64_t *idp, uint64_t *offp);

typedef int objset_used_cb_t(dmu_object_type_t bonustype,
    void *bonus, uint64_t *userp, uint64_t *groupp);
extern void dmu_objset_register_type(dmu_objset_type_t ost,
    objset_used_cb_t *cb);
extern void dmu_objset_set_user(objset_t *os, void *user_ptr);
extern void *dmu_objset_get_user(objset_t *os);

/*
 * Return the txg number for the given assigned transaction.
 */
uint64_t dmu_tx_get_txg(dmu_tx_t *tx);

/*
 * Synchronous write.
 * If a parent zio is provided this function initiates a write on the
 * provided buffer as a child of the parent zio.
 * In the absence of a parent zio, the write is completed synchronously.
 * At write completion, blk is filled with the bp of the written block.
 * Note that while the data covered by this function will be on stable
 * storage when the write completes this new data does not become a
 * permanent part of the file until the associated transaction commits.
 */

/*
 * {zfs,zvol,ztest}_get_done() args
 */
typedef struct zgd {
	struct zilog	*zgd_zilog;
	struct blkptr	*zgd_bp;
	dmu_buf_t	*zgd_db;
	struct rl	*zgd_rl;
	void		*zgd_private;
} zgd_t;

typedef void dmu_sync_cb_t(zgd_t *arg, int error);
int dmu_sync(struct zio *zio, uint64_t txg, dmu_sync_cb_t *done, zgd_t *zgd);

/*
 * Find the next hole or data block in file starting at *off
 * Return found offset in *off. Return ESRCH for end of file.
 */
int dmu_offset_next(objset_t *os, uint64_t object, boolean_t hole,
    uint64_t *off);

/*
 * Initial setup and final teardown.
 */
extern void dmu_init(void);
extern void dmu_fini(void);

typedef void (*dmu_traverse_cb_t)(objset_t *os, void *arg, struct blkptr *bp,
    uint64_t object, uint64_t offset, int len);
void dmu_traverse_objset(objset_t *os, uint64_t txg_start,
    dmu_traverse_cb_t cb, void *arg);

int dmu_diff(const char *tosnap_name, const char *fromsnap_name,
    struct vnode *vp, offset_t *offp);

/* CRC64 table */
#define	ZFS_CRC64_POLY	0xC96C5795D7870F42ULL	/* ECMA-182, reflected form */
extern uint64_t zfs_crc64_table[256];

extern int zfs_mdcomp_disable;

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DMU_H */
                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/sys/dmu_impl.h                                                          0100644 0000000 0000000 00000017114 13045171016 016504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef _SYS_DMU_IMPL_H
#define	_SYS_DMU_IMPL_H

#include <sys/txg_impl.h>
#include <sys/zio.h>
#include <sys/dnode.h>
#include <sys/zfs_context.h>
#include <sys/zfs_ioctl.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * This is the locking strategy for the DMU.  Numbers in parenthesis are
 * cases that use that lock order, referenced below:
 *
 * ARC is self-contained
 * bplist is self-contained
 * refcount is self-contained
 * txg is self-contained (hopefully!)
 * zst_lock
 * zf_rwlock
 *
 * XXX try to improve evicting path?
 *
 * dp_config_rwlock > os_obj_lock > dn_struct_rwlock >
 * 	dn_dbufs_mtx > hash_mutexes > db_mtx > dd_lock > leafs
 *
 * dp_config_rwlock
 *    must be held before: everything
 *    protects dd namespace changes
 *    protects property changes globally
 *    held from:
 *    	dsl_dir_open/r:
 *    	dsl_dir_create_sync/w:
 *    	dsl_dir_sync_destroy/w:
 *    	dsl_dir_rename_sync/w:
 *    	dsl_prop_changed_notify/r:
 *
 * os_obj_lock
 *   must be held before:
 *   	everything except dp_config_rwlock
 *   protects os_obj_next
 *   held from:
 *   	dmu_object_alloc: dn_dbufs_mtx, db_mtx, hash_mutexes, dn_struct_rwlock
 *
 * dn_struct_rwlock
 *   must be held before:
 *   	everything except dp_config_rwlock and os_obj_lock
 *   protects structure of dnode (eg. nlevels)
 *   	db_blkptr can change when syncing out change to nlevels
 *   	dn_maxblkid
 *   	dn_nlevels
 *   	dn_*blksz*
 *   	phys nlevels, maxblkid, physical blkptr_t's (?)
 *   held from:
 *   	callers of dbuf_read_impl, dbuf_hold[_impl], dbuf_prefetch
 *   	dmu_object_info_from_dnode: dn_dirty_mtx (dn_datablksz)
 *   	dmu_tx_count_free:
 *   	dbuf_read_impl: db_mtx, dmu_zfetch()
 *   	dmu_zfetch: zf_rwlock/r, zst_lock, dbuf_prefetch()
 *   	dbuf_new_size: db_mtx
 *   	dbuf_dirty: db_mtx
 *	dbuf_findbp: (callers, phys? - the real need)
 *	dbuf_create: dn_dbufs_mtx, hash_mutexes, db_mtx (phys?)
 *	dbuf_prefetch: dn_dirty_mtx, hash_mutexes, db_mtx, dn_dbufs_mtx
 *	dbuf_hold_impl: hash_mutexes, db_mtx, dn_dbufs_mtx, dbuf_findbp()
 *	dnode_sync/w (increase_indirection): db_mtx (phys)
 *	dnode_set_blksz/w: dn_dbufs_mtx (dn_*blksz*)
 *	dnode_new_blkid/w: (dn_maxblkid)
 *	dnode_free_range/w: dn_dirty_mtx (dn_maxblkid)
 *	dnode_next_offset: (phys)
 *
 * dn_dbufs_mtx
 *    must be held before:
 *    	db_mtx, hash_mutexes
 *    protects:
 *    	dn_dbufs
 *    	dn_evicted
 *    held from:
 *    	dmu_evict_user: db_mtx (dn_dbufs)
 *    	dbuf_free_range: db_mtx (dn_dbufs)
 *    	dbuf_remove_ref: db_mtx, callees:
 *    		dbuf_hash_remove: hash_mutexes, db_mtx
 *    	dbuf_create: hash_mutexes, db_mtx (dn_dbufs)
 *    	dnode_set_blksz: (dn_dbufs)
 *
 * hash_mutexes (global)
 *   must be held before:
 *   	db_mtx
 *   protects dbuf_hash_table (global) and db_hash_next
 *   held from:
 *   	dbuf_find: db_mtx
 *   	dbuf_hash_insert: db_mtx
 *   	dbuf_hash_remove: db_mtx
 *
 * db_mtx (meta-leaf)
 *   must be held before:
 *   	dn_mtx, dn_dirty_mtx, dd_lock (leaf mutexes)
 *   protects:
 *   	db_state
 * 	db_holds
 * 	db_buf
 * 	db_changed
 * 	db_data_pending
 * 	db_dirtied
 * 	db_link
 * 	db_dirty_node (??)
 * 	db_dirtycnt
 * 	db_d.*
 * 	db.*
 *   held from:
 * 	dbuf_dirty: dn_mtx, dn_dirty_mtx
 * 	dbuf_dirty->dsl_dir_willuse_space: dd_lock
 * 	dbuf_dirty->dbuf_new_block->dsl_dataset_block_freeable: dd_lock
 * 	dbuf_undirty: dn_dirty_mtx (db_d)
 * 	dbuf_write_done: dn_dirty_mtx (db_state)
 * 	dbuf_*
 * 	dmu_buf_update_user: none (db_d)
 * 	dmu_evict_user: none (db_d) (maybe can eliminate)
 *   	dbuf_find: none (db_holds)
 *   	dbuf_hash_insert: none (db_holds)
 *   	dmu_buf_read_array_impl: none (db_state, db_changed)
 *   	dmu_sync: none (db_dirty_node, db_d)
 *   	dnode_reallocate: none (db)
 *
 * dn_mtx (leaf)
 *   protects:
 *   	dn_dirty_dbufs
 *   	dn_ranges
 *   	phys accounting
 * 	dn_allocated_txg
 * 	dn_free_txg
 * 	dn_assigned_txg
 * 	dd_assigned_tx
 * 	dn_notxholds
 * 	dn_dirtyctx
 * 	dn_dirtyctx_firstset
 * 	(dn_phys copy fields?)
 * 	(dn_phys contents?)
 *   held from:
 *   	dnode_*
 *   	dbuf_dirty: none
 *   	dbuf_sync: none (phys accounting)
 *   	dbuf_undirty: none (dn_ranges, dn_dirty_dbufs)
 *   	dbuf_write_done: none (phys accounting)
 *   	dmu_object_info_from_dnode: none (accounting)
 *   	dmu_tx_commit: none
 *   	dmu_tx_hold_object_impl: none
 *   	dmu_tx_try_assign: dn_notxholds(cv)
 *   	dmu_tx_unassign: none
 *
 * dd_lock
 *    must be held before:
 *      ds_lock
 *      ancestors' dd_lock
 *    protects:
 *    	dd_prop_cbs
 *    	dd_sync_*
 *    	dd_used_bytes
 *    	dd_tempreserved
 *    	dd_space_towrite
 *    	dd_myname
 *    	dd_phys accounting?
 *    held from:
 *    	dsl_dir_*
 *    	dsl_prop_changed_notify: none (dd_prop_cbs)
 *    	dsl_prop_register: none (dd_prop_cbs)
 *    	dsl_prop_unregister: none (dd_prop_cbs)
 *    	dsl_dataset_block_freeable: none (dd_sync_*)
 *
 * os_lock (leaf)
 *   protects:
 *   	os_dirty_dnodes
 *   	os_free_dnodes
 *   	os_dnodes
 *   	os_downgraded_dbufs
 *   	dn_dirtyblksz
 *   	dn_dirty_link
 *   held from:
 *   	dnode_create: none (os_dnodes)
 *   	dnode_destroy: none (os_dnodes)
 *   	dnode_setdirty: none (dn_dirtyblksz, os_*_dnodes)
 *   	dnode_free: none (dn_dirtyblksz, os_*_dnodes)
 *
 * ds_lock
 *    protects:
 *    	ds_objset
 *    	ds_open_refcount
 *    	ds_snapname
 *    	ds_phys accounting
 *	ds_phys userrefs zapobj
 *	ds_reserved
 *    held from:
 *    	dsl_dataset_*
 *
 * dr_mtx (leaf)
 *    protects:
 *	dr_children
 *    held from:
 *	dbuf_dirty
 *	dbuf_undirty
 *	dbuf_sync_indirect
 *	dnode_new_blkid
 */

struct objset;
struct dmu_pool;

typedef struct dmu_xuio {
	int next;
	int cnt;
	struct arc_buf **bufs;
	iovec_t *iovp;
} dmu_xuio_t;

/*
 * The list of data whose inclusion in a send stream can be pending from
 * one call to backup_cb to another.  Multiple calls to dump_free() and
 * dump_freeobjects() can be aggregated into a single DRR_FREE or
 * DRR_FREEOBJECTS replay record.
 */
typedef enum {
	PENDING_NONE,
	PENDING_FREE,
	PENDING_FREEOBJECTS
} dmu_pendop_t;

typedef struct dmu_sendarg {
	list_node_t dsa_link;
	dmu_replay_record_t *dsa_drr;
	vnode_t *dsa_vp;
	int dsa_outfd;
	proc_t *dsa_proc;
	offset_t *dsa_off;
	objset_t *dsa_os;
	zio_cksum_t dsa_zc;
	uint64_t dsa_toguid;
	int dsa_err;
	dmu_pendop_t dsa_pending_op;
	boolean_t dsa_incremental;
	uint64_t dsa_featureflags;
	uint64_t dsa_last_data_object;
	uint64_t dsa_last_data_offset;
} dmu_sendarg_t;

void dmu_object_zapify(objset_t *, uint64_t, dmu_object_type_t, dmu_tx_t *);
void dmu_object_free_zapified(objset_t *, uint64_t, dmu_tx_t *);
int dmu_buf_hold_noread(objset_t *, uint64_t, uint64_t,
    void *, dmu_buf_t **);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DMU_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/src/zfs-0.6.5.9/include/sys/dmu_objset.h                                                        0100644 0000000 0000000 00000013607 13045171016 017034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

/* Portions Copyright 2010 Robert Milkowski */

#ifndef	_SYS_DMU_OBJSET_H
#define	_SYS_DMU_OBJSET_H

#include <sys/spa.h>
#include <sys/arc.h>
#include <sys/txg.h>
#include <sys/zfs_context.h>
#include <sys/dnode.h>
#include <sys/zio.h>
#include <sys/zil.h>
#include <sys/sa.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern krwlock_t os_lock;

struct dsl_pool;
struct dsl_dataset;
struct dmu_tx;

#define	OBJSET_PHYS_SIZE 2048
#define	OBJSET_OLD_PHYS_SIZE 1024

#define	OBJSET_BUF_HAS_USERUSED(buf) \
	(arc_buf_size(buf) > OBJSET_OLD_PHYS_SIZE)

#define	OBJSET_FLAG_USERACCOUNTING_COMPLETE	(1ULL<<0)

typedef struct objset_phys {
	dnode_phys_t os_meta_dnode;
	zil_header_t os_zil_header;
	uint64_t os_type;
	uint64_t os_flags;
	char os_pad[OBJSET_PHYS_SIZE - sizeof (dnode_phys_t)*3 -
	    sizeof (zil_header_t) - sizeof (uint64_t)*2];
	dnode_phys_t os_userused_dnode;
	dnode_phys_t os_groupused_dnode;
} objset_phys_t;

struct objset {
	/* Immutable: */
	struct dsl_dataset *os_dsl_dataset;
	spa_t *os_spa;
	arc_buf_t *os_phys_buf;
	objset_phys_t *os_phys;
	/*
	 * The following "special" dnodes have no parent, are exempt
	 * from dnode_move(), and are not recorded in os_dnodes, but they
	 * root their descendents in this objset using handles anyway, so
	 * that all access to dnodes from dbufs consistently uses handles.
	 */
	dnode_handle_t os_meta_dnode;
	dnode_handle_t os_userused_dnode;
	dnode_handle_t os_groupused_dnode;
	zilog_t *os_zil;

	list_node_t os_evicting_node;

	/* can change, under dsl_dir's locks: */
	enum zio_checksum os_checksum;
	enum zio_compress os_compress;
	uint8_t os_copies;
	enum zio_checksum os_dedup_checksum;
	boolean_t os_dedup_verify;
	zfs_logbias_op_t os_logbias;
	zfs_cache_type_t os_primary_cache;
	zfs_cache_type_t os_secondary_cache;
	zfs_sync_type_t os_sync;
	zfs_redundant_metadata_type_t os_redundant_metadata;
	int os_recordsize;

	/* no lock needed: */
	struct dmu_tx *os_synctx; /* XXX sketchy */
	blkptr_t *os_rootbp;
	zil_header_t os_zil_header;
	list_t os_synced_dnodes;
	uint64_t os_flags;

	/* Protected by os_obj_lock */
	kmutex_t os_obj_lock;
	uint64_t os_obj_next;

	/* Protected by os_lock */
	kmutex_t os_lock;
	list_t os_dirty_dnodes[TXG_SIZE];
	list_t os_free_dnodes[TXG_SIZE];
	list_t os_dnodes;
	list_t os_downgraded_dbufs;

	/* stuff we store for the user */
	kmutex_t os_user_ptr_lock;
	void *os_user_ptr;
	sa_os_t *os_sa;
};

#define	DMU_META_OBJSET		0
#define	DMU_META_DNODE_OBJECT	0
#define	DMU_OBJECT_IS_SPECIAL(obj) ((int64_t)(obj) <= 0)
#define	DMU_META_DNODE(os)	((os)->os_meta_dnode.dnh_dnode)
#define	DMU_USERUSED_DNODE(os)	((os)->os_userused_dnode.dnh_dnode)
#define	DMU_GROUPUSED_DNODE(os)	((os)->os_groupused_dnode.dnh_dnode)

#define	DMU_OS_IS_L2CACHEABLE(os)				\
	((os)->os_secondary_cache == ZFS_CACHE_ALL ||		\
	(os)->os_secondary_cache == ZFS_CACHE_METADATA)

#define	DMU_OS_IS_L2COMPRESSIBLE(os)	(zfs_mdcomp_disable == B_FALSE)

/* called from zpl */
int dmu_objset_hold(const char *name, void *tag, objset_t **osp);
int dmu_objset_own(const char *name, dmu_objset_type_t type,
    boolean_t readonly, void *tag, objset_t **osp);
int dmu_objset_own_obj(struct dsl_pool *dp, uint64_t obj,
    dmu_objset_type_t type, boolean_t readonly, void *tag, objset_t **osp);
void dmu_objset_refresh_ownership(objset_t *os, void *tag);
void dmu_objset_rele(objset_t *os, void *tag);
void dmu_objset_disown(objset_t *os, void *tag);
int dmu_objset_from_ds(struct dsl_dataset *ds, objset_t **osp);

void dmu_objset_stats(objset_t *os, nvlist_t *nv);
void dmu_objset_fast_stat(objset_t *os, dmu_objset_stats_t *stat);
void dmu_objset_space(objset_t *os, uint64_t *refdbytesp, uint64_t *availbytesp,
    uint64_t *usedobjsp, uint64_t *availobjsp);
uint64_t dmu_objset_fsid_guid(objset_t *os);
int dmu_objset_find_dp(struct dsl_pool *dp, uint64_t ddobj,
    int func(struct dsl_pool *, struct dsl_dataset *, void *),
    void *arg, int flags);
void dmu_objset_evict_dbufs(objset_t *os);
timestruc_t dmu_objset_snap_cmtime(objset_t *os);

/* called from dsl */
void dmu_objset_sync(objset_t *os, zio_t *zio, dmu_tx_t *tx);
boolean_t dmu_objset_is_dirty(objset_t *os, uint64_t txg);
objset_t *dmu_objset_create_impl(spa_t *spa, struct dsl_dataset *ds,
    blkptr_t *bp, dmu_objset_type_t type, dmu_tx_t *tx);
int dmu_objset_open_impl(spa_t *spa, struct dsl_dataset *ds, blkptr_t *bp,
    objset_t **osp);
void dmu_objset_evict(objset_t *os);
void dmu_objset_do_userquota_updates(objset_t *os, dmu_tx_t *tx);
void dmu_objset_userquota_get_ids(dnode_t *dn, boolean_t before, dmu_tx_t *tx);
boolean_t dmu_objset_userused_enabled(objset_t *os);
int dmu_objset_userspace_upgrade(objset_t *os);
boolean_t dmu_objset_userspace_present(objset_t *os);
int dmu_fsname(const char *snapname, char *buf);

void dmu_objset_evict_done(objset_t *os);

void dmu_objset_init(void);
void dmu_objset_fini(void);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DMU_OBJSET_H */
                                                                                                                         usr/src/zfs-0.6.5.9/include/sys/dmu_send.h                                                          0100644 0000000 0000000 00000004705 13045171016 016476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 */

#ifndef _DMU_SEND_H
#define	_DMU_SEND_H

#include <sys/inttypes.h>
#include <sys/spa.h>

struct vnode;
struct dsl_dataset;
struct drr_begin;
struct avl_tree;

int dmu_send(const char *tosnap, const char *fromsnap,
    boolean_t embedok, boolean_t large_block_ok,
    int outfd, struct vnode *vp, offset_t *off);
int dmu_send_estimate(struct dsl_dataset *ds, struct dsl_dataset *fromds,
    uint64_t *sizep);
int dmu_send_estimate_from_txg(struct dsl_dataset *ds, uint64_t fromtxg,
    uint64_t *sizep);
int dmu_send_obj(const char *pool, uint64_t tosnap, uint64_t fromsnap,
    boolean_t embedok, boolean_t large_block_ok,
    int outfd, struct vnode *vp, offset_t *off);

typedef struct dmu_recv_cookie {
	struct dsl_dataset *drc_ds;
	struct drr_begin *drc_drrb;
	const char *drc_tofs;
	const char *drc_tosnap;
	boolean_t drc_newfs;
	boolean_t drc_byteswap;
	boolean_t drc_force;
	struct avl_tree *drc_guid_to_ds_map;
	zio_cksum_t drc_cksum;
	uint64_t drc_newsnapobj;
	void *drc_owner;
	cred_t *drc_cred;
} dmu_recv_cookie_t;

int dmu_recv_begin(char *tofs, char *tosnap, struct drr_begin *drrb,
    boolean_t force, char *origin, dmu_recv_cookie_t *drc);
int dmu_recv_stream(dmu_recv_cookie_t *drc, struct vnode *vp, offset_t *voffp,
    int cleanup_fd, uint64_t *action_handlep);
int dmu_recv_end(dmu_recv_cookie_t *drc, void *owner);
boolean_t dmu_objset_is_receiving(objset_t *os);

#endif /* _DMU_SEND_H */
                                                           usr/src/zfs-0.6.5.9/include/sys/dmu_traverse.h                                                      0100644 0000000 0000000 00000004145 13045171016 017376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DMU_TRAVERSE_H
#define	_SYS_DMU_TRAVERSE_H

#include <sys/zfs_context.h>
#include <sys/spa.h>
#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dnode_phys;
struct dsl_dataset;
struct zilog;
struct arc_buf;

typedef int (blkptr_cb_t)(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
    const zbookmark_phys_t *zb, const struct dnode_phys *dnp, void *arg);

#define	TRAVERSE_PRE			(1<<0)
#define	TRAVERSE_POST			(1<<1)
#define	TRAVERSE_PREFETCH_METADATA	(1<<2)
#define	TRAVERSE_PREFETCH_DATA		(1<<3)
#define	TRAVERSE_PREFETCH (TRAVERSE_PREFETCH_METADATA | TRAVERSE_PREFETCH_DATA)
#define	TRAVERSE_HARD			(1<<4)

/* Special traverse error return value to indicate skipping of children */
#define	TRAVERSE_VISIT_NO_CHILDREN	-1

int traverse_dataset(struct dsl_dataset *ds,
    uint64_t txg_start, int flags, blkptr_cb_t func, void *arg);
int traverse_dataset_destroyed(spa_t *spa, blkptr_t *blkptr,
    uint64_t txg_start, zbookmark_phys_t *resume, int flags,
    blkptr_cb_t func, void *arg);
int traverse_pool(spa_t *spa,
    uint64_t txg_start, int flags, blkptr_cb_t func, void *arg);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DMU_TRAVERSE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                           usr/src/zfs-0.6.5.9/include/sys/dmu_tx.h                                                            0100644 0000000 0000000 00000011613 13045171016 016174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DMU_TX_H
#define	_SYS_DMU_TX_H

#include <sys/inttypes.h>
#include <sys/dmu.h>
#include <sys/txg.h>
#include <sys/refcount.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dmu_buf_impl;
struct dmu_tx_hold;
struct dnode_link;
struct dsl_pool;
struct dnode;
struct dsl_dir;

struct dmu_tx {
	/*
	 * No synchronization is needed because a tx can only be handled
	 * by one thread.
	 */
	list_t tx_holds; /* list of dmu_tx_hold_t */
	objset_t *tx_objset;
	struct dsl_dir *tx_dir;
	struct dsl_pool *tx_pool;
	uint64_t tx_txg;
	uint64_t tx_lastsnap_txg;
	uint64_t tx_lasttried_txg;
	txg_handle_t tx_txgh;
	void *tx_tempreserve_cookie;
	struct dmu_tx_hold *tx_needassign_txh;

	/* list of dmu_tx_callback_t on this dmu_tx */
	list_t tx_callbacks;

	/* placeholder for syncing context, doesn't need specific holds */
	boolean_t tx_anyobj;

	/* has this transaction already been delayed? */
	boolean_t tx_waited;

	/* time this transaction was created */
	hrtime_t tx_start;

	/* need to wait for sufficient dirty space */
	boolean_t tx_wait_dirty;

	int tx_err;
#ifdef DEBUG_DMU_TX
	uint64_t tx_space_towrite;
	uint64_t tx_space_tofree;
	uint64_t tx_space_tooverwrite;
	uint64_t tx_space_tounref;
	refcount_t tx_space_written;
	refcount_t tx_space_freed;
#endif
};

enum dmu_tx_hold_type {
	THT_NEWOBJECT,
	THT_WRITE,
	THT_BONUS,
	THT_FREE,
	THT_ZAP,
	THT_SPACE,
	THT_SPILL,
	THT_NUMTYPES
};

typedef struct dmu_tx_hold {
	dmu_tx_t *txh_tx;
	list_node_t txh_node;
	struct dnode *txh_dnode;
	uint64_t txh_space_towrite;
	uint64_t txh_space_tofree;
	uint64_t txh_space_tooverwrite;
	uint64_t txh_space_tounref;
	uint64_t txh_memory_tohold;
	uint64_t txh_fudge;
#ifdef DEBUG_DMU_TX
	enum dmu_tx_hold_type txh_type;
	uint64_t txh_arg1;
	uint64_t txh_arg2;
#endif
} dmu_tx_hold_t;

typedef struct dmu_tx_callback {
	list_node_t		dcb_node;    /* linked to tx_callbacks list */
	dmu_tx_callback_func_t	*dcb_func;   /* caller function pointer */
	void			*dcb_data;   /* caller private data */
} dmu_tx_callback_t;

/*
 * Used for dmu tx kstat.
 */
typedef struct dmu_tx_stats {
	kstat_named_t dmu_tx_assigned;
	kstat_named_t dmu_tx_delay;
	kstat_named_t dmu_tx_error;
	kstat_named_t dmu_tx_suspended;
	kstat_named_t dmu_tx_group;
	kstat_named_t dmu_tx_memory_reserve;
	kstat_named_t dmu_tx_memory_reclaim;
	kstat_named_t dmu_tx_dirty_throttle;
	kstat_named_t dmu_tx_dirty_delay;
	kstat_named_t dmu_tx_dirty_over_max;
	kstat_named_t dmu_tx_quota;
} dmu_tx_stats_t;

extern dmu_tx_stats_t dmu_tx_stats;

#define	DMU_TX_STAT_INCR(stat, val) \
    atomic_add_64(&dmu_tx_stats.stat.value.ui64, (val));
#define	DMU_TX_STAT_BUMP(stat) \
    DMU_TX_STAT_INCR(stat, 1);

/*
 * These routines are defined in dmu.h, and are called by the user.
 */
dmu_tx_t *dmu_tx_create(objset_t *dd);
int dmu_tx_assign(dmu_tx_t *tx, txg_how_t txg_how);
void dmu_tx_commit(dmu_tx_t *tx);
void dmu_tx_abort(dmu_tx_t *tx);
uint64_t dmu_tx_get_txg(dmu_tx_t *tx);
struct dsl_pool *dmu_tx_pool(dmu_tx_t *tx);
void dmu_tx_wait(dmu_tx_t *tx);

void dmu_tx_callback_register(dmu_tx_t *tx, dmu_tx_callback_func_t *dcb_func,
    void *dcb_data);
void dmu_tx_do_callbacks(list_t *cb_list, int error);

/*
 * These routines are defined in dmu_spa.h, and are called by the SPA.
 */
extern dmu_tx_t *dmu_tx_create_assigned(struct dsl_pool *dp, uint64_t txg);

/*
 * These routines are only called by the DMU.
 */
dmu_tx_t *dmu_tx_create_dd(dsl_dir_t *dd);
int dmu_tx_is_syncing(dmu_tx_t *tx);
int dmu_tx_private_ok(dmu_tx_t *tx);
void dmu_tx_add_new_object(dmu_tx_t *tx, objset_t *os, uint64_t object);
void dmu_tx_willuse_space(dmu_tx_t *tx, int64_t delta);
void dmu_tx_dirty_buf(dmu_tx_t *tx, struct dmu_buf_impl *db);
int dmu_tx_holds(dmu_tx_t *tx, uint64_t object);
void dmu_tx_hold_space(dmu_tx_t *tx, uint64_t space);

#ifdef DEBUG_DMU_TX
#define	DMU_TX_DIRTY_BUF(tx, db)	dmu_tx_dirty_buf(tx, db)
#else
#define	DMU_TX_DIRTY_BUF(tx, db)
#endif

void dmu_tx_init(void);
void dmu_tx_fini(void);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DMU_TX_H */
                                                                                                                     usr/src/zfs-0.6.5.9/include/sys/dmu_zfetch.h                                                        0100644 0000000 0000000 00000004513 13045171016 017025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_DFETCH_H
#define	_DFETCH_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern unsigned long	zfetch_array_rd_sz;

struct dnode;				/* so we can reference dnode */

typedef enum zfetch_dirn {
	ZFETCH_FORWARD = 1,		/* prefetch increasing block numbers */
	ZFETCH_BACKWARD	= -1		/* prefetch decreasing block numbers */
} zfetch_dirn_t;

typedef struct zstream {
	uint64_t	zst_offset;	/* offset of starting block in range */
	uint64_t	zst_len;	/* length of range, in blocks */
	zfetch_dirn_t	zst_direction;	/* direction of prefetch */
	uint64_t	zst_stride;	/* length of stride, in blocks */
	uint64_t	zst_ph_offset;	/* prefetch offset, in blocks */
	uint64_t	zst_cap;	/* prefetch limit (cap), in blocks */
	kmutex_t	zst_lock;	/* protects stream */
	clock_t		zst_last;	/* lbolt of last prefetch */
	list_node_t	zst_node;	/* next zstream here */
} zstream_t;

typedef struct zfetch {
	krwlock_t	zf_rwlock;	/* protects zfetch structure */
	list_t		zf_stream;	/* AVL tree of zstream_t's */
	struct dnode	*zf_dnode;	/* dnode that owns this zfetch */
	uint32_t	zf_stream_cnt;	/* # of active streams */
	uint64_t	zf_alloc_fail;	/* # of failed attempts to alloc strm */
} zfetch_t;

void		zfetch_init(void);
void		zfetch_fini(void);

void		dmu_zfetch_init(zfetch_t *, struct dnode *);
void		dmu_zfetch_rele(zfetch_t *);
void		dmu_zfetch(zfetch_t *, uint64_t, uint64_t, int);


#ifdef	__cplusplus
}
#endif

#endif	/* _DFETCH_H */
                                                                                                                                                                                     usr/src/zfs-0.6.5.9/include/sys/dnode.h                                                             0100644 0000000 0000000 00000027611 13045171016 015772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_DNODE_H
#define	_SYS_DNODE_H

#include <sys/zfs_context.h>
#include <sys/avl.h>
#include <sys/spa.h>
#include <sys/txg.h>
#include <sys/zio.h>
#include <sys/refcount.h>
#include <sys/dmu_zfetch.h>
#include <sys/zrlock.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * dnode_hold() flags.
 */
#define	DNODE_MUST_BE_ALLOCATED	1
#define	DNODE_MUST_BE_FREE	2

/*
 * dnode_next_offset() flags.
 */
#define	DNODE_FIND_HOLE		1
#define	DNODE_FIND_BACKWARDS	2
#define	DNODE_FIND_HAVELOCK	4

/*
 * Fixed constants.
 */
#define	DNODE_SHIFT		9	/* 512 bytes */
#define	DN_MIN_INDBLKSHIFT	10	/* 1k */
#define	DN_MAX_INDBLKSHIFT	14	/* 16k */
#define	DNODE_BLOCK_SHIFT	14	/* 16k */
#define	DNODE_CORE_SIZE		64	/* 64 bytes for dnode sans blkptrs */
#define	DN_MAX_OBJECT_SHIFT	48	/* 256 trillion (zfs_fid_t limit) */
#define	DN_MAX_OFFSET_SHIFT	64	/* 2^64 bytes in a dnode */

/*
 * dnode id flags
 *
 * Note: a file will never ever have its
 * ids moved from bonus->spill
 * and only in a crypto environment would it be on spill
 */
#define	DN_ID_CHKED_BONUS	0x1
#define	DN_ID_CHKED_SPILL	0x2
#define	DN_ID_OLD_EXIST		0x4
#define	DN_ID_NEW_EXIST		0x8

/*
 * Derived constants.
 */
#define	DNODE_SIZE	(1 << DNODE_SHIFT)
#define	DN_MAX_NBLKPTR	((DNODE_SIZE - DNODE_CORE_SIZE) >> SPA_BLKPTRSHIFT)
#define	DN_MAX_BONUSLEN	(DNODE_SIZE - DNODE_CORE_SIZE - (1 << SPA_BLKPTRSHIFT))
#define	DN_MAX_OBJECT	(1ULL << DN_MAX_OBJECT_SHIFT)
#define	DN_ZERO_BONUSLEN	(DN_MAX_BONUSLEN + 1)
#define	DN_KILL_SPILLBLK (1)

#define	DNODES_PER_BLOCK_SHIFT	(DNODE_BLOCK_SHIFT - DNODE_SHIFT)
#define	DNODES_PER_BLOCK	(1ULL << DNODES_PER_BLOCK_SHIFT)
#define	DNODES_PER_LEVEL_SHIFT	(DN_MAX_INDBLKSHIFT - SPA_BLKPTRSHIFT)
#define	DNODES_PER_LEVEL	(1ULL << DNODES_PER_LEVEL_SHIFT)

/* The +2 here is a cheesy way to round up */
#define	DN_MAX_LEVELS	(2 + ((DN_MAX_OFFSET_SHIFT - SPA_MINBLOCKSHIFT) / \
	(DN_MIN_INDBLKSHIFT - SPA_BLKPTRSHIFT)))

#define	DN_BONUS(dnp)	((void*)((dnp)->dn_bonus + \
	(((dnp)->dn_nblkptr - 1) * sizeof (blkptr_t))))

#define	DN_USED_BYTES(dnp) (((dnp)->dn_flags & DNODE_FLAG_USED_BYTES) ? \
	(dnp)->dn_used : (dnp)->dn_used << SPA_MINBLOCKSHIFT)

#define	EPB(blkshift, typeshift)	(1 << (blkshift - typeshift))

struct dmu_buf_impl;
struct objset;
struct zio;

enum dnode_dirtycontext {
	DN_UNDIRTIED,
	DN_DIRTY_OPEN,
	DN_DIRTY_SYNC
};

/* Is dn_used in bytes?  if not, it's in multiples of SPA_MINBLOCKSIZE */
#define	DNODE_FLAG_USED_BYTES		(1<<0)
#define	DNODE_FLAG_USERUSED_ACCOUNTED	(1<<1)

/* Does dnode have a SA spill blkptr in bonus? */
#define	DNODE_FLAG_SPILL_BLKPTR	(1<<2)

typedef struct dnode_phys {
	uint8_t dn_type;		/* dmu_object_type_t */
	uint8_t dn_indblkshift;		/* ln2(indirect block size) */
	uint8_t dn_nlevels;		/* 1=dn_blkptr->data blocks */
	uint8_t dn_nblkptr;		/* length of dn_blkptr */
	uint8_t dn_bonustype;		/* type of data in bonus buffer */
	uint8_t	dn_checksum;		/* ZIO_CHECKSUM type */
	uint8_t	dn_compress;		/* ZIO_COMPRESS type */
	uint8_t dn_flags;		/* DNODE_FLAG_* */
	uint16_t dn_datablkszsec;	/* data block size in 512b sectors */
	uint16_t dn_bonuslen;		/* length of dn_bonus */
	uint8_t dn_pad2[4];

	/* accounting is protected by dn_dirty_mtx */
	uint64_t dn_maxblkid;		/* largest allocated block ID */
	uint64_t dn_used;		/* bytes (or sectors) of disk space */

	uint64_t dn_pad3[4];

	/*
	 * The tail region is 448 bytes, and there are three ways to
	 * look at it.
	 *
	 * 0       64      128     192     256     320     384     448 (offset)
	 * +---------------+---------------+---------------+-------+
	 * | dn_blkptr[0]  | dn_blkptr[1]  | dn_blkptr[2]  | /     |
	 * +---------------+---------------+---------------+-------+
	 * | dn_blkptr[0]  | dn_bonus[0..319]                      |
	 * +---------------+-----------------------+---------------+
	 * | dn_blkptr[0]  | /                     | dn_spill      |
	 * +---------------+-----------------------+---------------+
	 */
	union {
		blkptr_t dn_blkptr[1+DN_MAX_BONUSLEN/sizeof (blkptr_t)];
		struct {
			blkptr_t __dn_ignore1;
			uint8_t dn_bonus[DN_MAX_BONUSLEN];
		};
		struct {
			blkptr_t __dn_ignore2;
			uint8_t __dn_ignore3[DN_MAX_BONUSLEN-sizeof (blkptr_t)];
			blkptr_t dn_spill;
		};
	};
} dnode_phys_t;

typedef struct dnode {
	/*
	 * Protects the structure of the dnode, including the number of levels
	 * of indirection (dn_nlevels), dn_maxblkid, and dn_next_*
	 */
	krwlock_t dn_struct_rwlock;

	/* Our link on dn_objset->os_dnodes list; protected by os_lock.  */
	list_node_t dn_link;

	/* immutable: */
	struct objset *dn_objset;
	uint64_t dn_object;
	struct dmu_buf_impl *dn_dbuf;
	struct dnode_handle *dn_handle;
	dnode_phys_t *dn_phys; /* pointer into dn->dn_dbuf->db.db_data */

	/*
	 * Copies of stuff in dn_phys.  They're valid in the open
	 * context (eg. even before the dnode is first synced).
	 * Where necessary, these are protected by dn_struct_rwlock.
	 */
	dmu_object_type_t dn_type;	/* object type */
	uint16_t dn_bonuslen;		/* bonus length */
	uint8_t dn_bonustype;		/* bonus type */
	uint8_t dn_nblkptr;		/* number of blkptrs (immutable) */
	uint8_t dn_checksum;		/* ZIO_CHECKSUM type */
	uint8_t dn_compress;		/* ZIO_COMPRESS type */
	uint8_t dn_nlevels;
	uint8_t dn_indblkshift;
	uint8_t dn_datablkshift;	/* zero if blksz not power of 2! */
	uint8_t dn_moved;		/* Has this dnode been moved? */
	uint16_t dn_datablkszsec;	/* in 512b sectors */
	uint32_t dn_datablksz;		/* in bytes */
	uint64_t dn_maxblkid;
	uint8_t dn_next_type[TXG_SIZE];
	uint8_t dn_next_nblkptr[TXG_SIZE];
	uint8_t dn_next_nlevels[TXG_SIZE];
	uint8_t dn_next_indblkshift[TXG_SIZE];
	uint8_t dn_next_bonustype[TXG_SIZE];
	uint8_t dn_rm_spillblk[TXG_SIZE];	/* for removing spill blk */
	uint16_t dn_next_bonuslen[TXG_SIZE];
	uint32_t dn_next_blksz[TXG_SIZE];	/* next block size in bytes */

	/* protected by dn_dbufs_mtx; declared here to fill 32-bit hole */
	uint32_t dn_dbufs_count;	/* count of dn_dbufs */
	/* There are no level-0 blocks of this blkid or higher in dn_dbufs */
	uint64_t dn_unlisted_l0_blkid;

	/* protected by os_lock: */
	list_node_t dn_dirty_link[TXG_SIZE];	/* next on dataset's dirty */

	/* protected by dn_mtx: */
	kmutex_t dn_mtx;
	list_t dn_dirty_records[TXG_SIZE];
	struct range_tree *dn_free_ranges[TXG_SIZE];
	uint64_t dn_allocated_txg;
	uint64_t dn_free_txg;
	uint64_t dn_assigned_txg;
	kcondvar_t dn_notxholds;
	enum dnode_dirtycontext dn_dirtyctx;
	uint8_t *dn_dirtyctx_firstset;		/* dbg: contents meaningless */

	/* protected by own devices */
	refcount_t dn_tx_holds;
	refcount_t dn_holds;

	kmutex_t dn_dbufs_mtx;
	/*
	 * Descendent dbufs, ordered by dbuf_compare. Note that dn_dbufs
	 * can contain multiple dbufs of the same (level, blkid) when a
	 * dbuf is marked DB_EVICTING without being removed from
	 * dn_dbufs. To maintain the avl invariant that there cannot be
	 * duplicate entries, we order the dbufs by an arbitrary value -
	 * their address in memory. This means that dn_dbufs cannot be used to
	 * directly look up a dbuf. Instead, callers must use avl_walk, have
	 * a reference to the dbuf, or look up a non-existant node with
	 * db_state = DB_SEARCH (see dbuf_free_range for an example).
	 */
	avl_tree_t dn_dbufs;

	/* protected by dn_struct_rwlock */
	struct dmu_buf_impl *dn_bonus;	/* bonus buffer dbuf */

	boolean_t dn_have_spill;	/* have spill or are spilling */

	/* parent IO for current sync write */
	zio_t *dn_zio;

	/* used in syncing context */
	uint64_t dn_oldused;	/* old phys used bytes */
	uint64_t dn_oldflags;	/* old phys dn_flags */
	uint64_t dn_olduid, dn_oldgid;
	uint64_t dn_newuid, dn_newgid;
	int dn_id_flags;

	/* holds prefetch structure */
	struct zfetch	dn_zfetch;
} dnode_t;

/*
 * Adds a level of indirection between the dbuf and the dnode to avoid
 * iterating descendent dbufs in dnode_move(). Handles are not allocated
 * individually, but as an array of child dnodes in dnode_hold_impl().
 */
typedef struct dnode_handle {
	/* Protects dnh_dnode from modification by dnode_move(). */
	zrlock_t dnh_zrlock;
	dnode_t *dnh_dnode;
} dnode_handle_t;

typedef struct dnode_children {
	dmu_buf_user_t dnc_dbu;		/* User evict data */
	size_t dnc_count;		/* number of children */
	dnode_handle_t dnc_children[];	/* sized dynamically */
} dnode_children_t;

typedef struct free_range {
	avl_node_t fr_node;
	uint64_t fr_blkid;
	uint64_t fr_nblks;
} free_range_t;

void dnode_special_open(struct objset *dd, dnode_phys_t *dnp,
    uint64_t object, dnode_handle_t *dnh);
void dnode_special_close(dnode_handle_t *dnh);

void dnode_setbonuslen(dnode_t *dn, int newsize, dmu_tx_t *tx);
void dnode_setbonus_type(dnode_t *dn, dmu_object_type_t, dmu_tx_t *tx);
void dnode_rm_spill(dnode_t *dn, dmu_tx_t *tx);

int dnode_hold(struct objset *dd, uint64_t object,
    void *ref, dnode_t **dnp);
int dnode_hold_impl(struct objset *dd, uint64_t object, int flag,
    void *ref, dnode_t **dnp);
boolean_t dnode_add_ref(dnode_t *dn, void *ref);
void dnode_rele(dnode_t *dn, void *ref);
void dnode_rele_and_unlock(dnode_t *dn, void *tag);
void dnode_setdirty(dnode_t *dn, dmu_tx_t *tx);
void dnode_sync(dnode_t *dn, dmu_tx_t *tx);
void dnode_allocate(dnode_t *dn, dmu_object_type_t ot, int blocksize, int ibs,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);
void dnode_reallocate(dnode_t *dn, dmu_object_type_t ot, int blocksize,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);
void dnode_free(dnode_t *dn, dmu_tx_t *tx);
void dnode_byteswap(dnode_phys_t *dnp);
void dnode_buf_byteswap(void *buf, size_t size);
void dnode_verify(dnode_t *dn);
int dnode_set_blksz(dnode_t *dn, uint64_t size, int ibs, dmu_tx_t *tx);
void dnode_free_range(dnode_t *dn, uint64_t off, uint64_t len, dmu_tx_t *tx);
void dnode_diduse_space(dnode_t *dn, int64_t space);
void dnode_willuse_space(dnode_t *dn, int64_t space, dmu_tx_t *tx);
void dnode_new_blkid(dnode_t *dn, uint64_t blkid, dmu_tx_t *tx, boolean_t);
uint64_t dnode_block_freed(dnode_t *dn, uint64_t blkid);
void dnode_init(void);
void dnode_fini(void);
int dnode_next_offset(dnode_t *dn, int flags, uint64_t *off,
    int minlvl, uint64_t blkfill, uint64_t txg);
void dnode_evict_dbufs(dnode_t *dn);
void dnode_evict_bonus(dnode_t *dn);

#ifdef ZFS_DEBUG

/*
 * There should be a ## between the string literal and fmt, to make it
 * clear that we're joining two strings together, but that piece of shit
 * gcc doesn't support that preprocessor token.
 */
#define	dprintf_dnode(dn, fmt, ...) do { \
	if (zfs_flags & ZFS_DEBUG_DPRINTF) { \
	char __db_buf[32]; \
	uint64_t __db_obj = (dn)->dn_object; \
	if (__db_obj == DMU_META_DNODE_OBJECT) \
		(void) strcpy(__db_buf, "mdn"); \
	else \
		(void) snprintf(__db_buf, sizeof (__db_buf), "%lld", \
		    (u_longlong_t)__db_obj);\
	dprintf_ds((dn)->dn_objset->os_dsl_dataset, "obj=%s " fmt, \
	    __db_buf, __VA_ARGS__); \
	} \
_NOTE(CONSTCOND) } while (0)

#define	DNODE_VERIFY(dn)		dnode_verify(dn)
#define	FREE_VERIFY(db, start, end, tx)	free_verify(db, start, end, tx)

#else

#define	dprintf_dnode(db, fmt, ...)
#define	DNODE_VERIFY(dn)
#define	FREE_VERIFY(db, start, end, tx)

#endif

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DNODE_H */
                                                                                                                       usr/src/zfs-0.6.5.9/include/sys/dsl_bookmark.h                                                      0100644 0000000 0000000 00000002501 13045171016 017337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * This file and its contents are supplied under the terms of the
 * Common Development and Distribution License ("CDDL"), version 1.0.
 * You may only use this file in accordance with the terms of version
 * 1.0 of the CDDL.
 *
 * A full copy of the text of the CDDL should have accompanied this
 * source.  A copy of the CDDL is also available via the Internet at
 * http://www.illumos.org/license/CDDL.
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DSL_BOOKMARK_H
#define	_SYS_DSL_BOOKMARK_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_pool;
struct dsl_dataset;

/*
 * On disk zap object.
 */
typedef struct zfs_bookmark_phys {
	uint64_t zbm_guid;		/* guid of bookmarked dataset */
	uint64_t zbm_creation_txg;	/* birth transaction group */
	uint64_t zbm_creation_time;	/* bookmark creation time */
} zfs_bookmark_phys_t;

int dsl_bookmark_create(nvlist_t *, nvlist_t *);
int dsl_get_bookmarks(const char *, nvlist_t *, nvlist_t *);
int dsl_get_bookmarks_impl(dsl_dataset_t *, nvlist_t *, nvlist_t *);
int dsl_bookmark_destroy(nvlist_t *, nvlist_t *);
int dsl_bookmark_lookup(struct dsl_pool *, const char *,
    struct dsl_dataset *, zfs_bookmark_phys_t *);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_BOOKMARK_H */
                                                                                                                                                                                               usr/src/zfs-0.6.5.9/include/sys/dsl_dataset.h                                                       0100644 0000000 0000000 00000026554 13045171016 017175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 * Copyright (c) 2013 Steven Hartland. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_DSL_DATASET_H
#define	_SYS_DSL_DATASET_H

#include <sys/dmu.h>
#include <sys/spa.h>
#include <sys/txg.h>
#include <sys/zio.h>
#include <sys/bplist.h>
#include <sys/dsl_synctask.h>
#include <sys/zfs_context.h>
#include <sys/dsl_deadlist.h>
#include <sys/refcount.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_dataset;
struct dsl_dir;
struct dsl_pool;

#define	DS_FLAG_INCONSISTENT	(1ULL<<0)
#define	DS_IS_INCONSISTENT(ds)	\
	(dsl_dataset_phys(ds)->ds_flags & DS_FLAG_INCONSISTENT)

/*
 * Do not allow this dataset to be promoted.
 */
#define	DS_FLAG_NOPROMOTE	(1ULL<<1)

/*
 * DS_FLAG_UNIQUE_ACCURATE is set if ds_unique_bytes has been correctly
 * calculated for head datasets (starting with SPA_VERSION_UNIQUE_ACCURATE,
 * refquota/refreservations).
 */
#define	DS_FLAG_UNIQUE_ACCURATE	(1ULL<<2)

/*
 * DS_FLAG_DEFER_DESTROY is set after 'zfs destroy -d' has been called
 * on a dataset. This allows the dataset to be destroyed using 'zfs release'.
 */
#define	DS_FLAG_DEFER_DESTROY	(1ULL<<3)
#define	DS_IS_DEFER_DESTROY(ds)	\
	(dsl_dataset_phys(ds)->ds_flags & DS_FLAG_DEFER_DESTROY)

/*
 * DS_FIELD_* are strings that are used in the "extensified" dataset zap object.
 * They should be of the format <reverse-dns>:<field>.
 */

/*
 * This field's value is the object ID of a zap object which contains the
 * bookmarks of this dataset.  If it is present, then this dataset is counted
 * in the refcount of the SPA_FEATURES_BOOKMARKS feature.
 */
#define	DS_FIELD_BOOKMARK_NAMES "com.delphix:bookmarks"

/*
 * This field is present (with value=0) if this dataset may contain large
 * blocks (>128KB).  If it is present, then this dataset
 * is counted in the refcount of the SPA_FEATURE_LARGE_BLOCKS feature.
 */
#define	DS_FIELD_LARGE_BLOCKS "org.open-zfs:large_blocks"

/*
 * DS_FLAG_CI_DATASET is set if the dataset contains a file system whose
 * name lookups should be performed case-insensitively.
 */
#define	DS_FLAG_CI_DATASET	(1ULL<<16)

#define	DS_CREATE_FLAG_NODIRTY	(1ULL<<24)

typedef struct dsl_dataset_phys {
	uint64_t ds_dir_obj;		/* DMU_OT_DSL_DIR */
	uint64_t ds_prev_snap_obj;	/* DMU_OT_DSL_DATASET */
	uint64_t ds_prev_snap_txg;
	uint64_t ds_next_snap_obj;	/* DMU_OT_DSL_DATASET */
	uint64_t ds_snapnames_zapobj;	/* DMU_OT_DSL_DS_SNAP_MAP 0 for snaps */
	uint64_t ds_num_children;	/* clone/snap children; ==0 for head */
	uint64_t ds_creation_time;	/* seconds since 1970 */
	uint64_t ds_creation_txg;
	uint64_t ds_deadlist_obj;	/* DMU_OT_DEADLIST */
	/*
	 * ds_referenced_bytes, ds_compressed_bytes, and ds_uncompressed_bytes
	 * include all blocks referenced by this dataset, including those
	 * shared with any other datasets.
	 */
	uint64_t ds_referenced_bytes;
	uint64_t ds_compressed_bytes;
	uint64_t ds_uncompressed_bytes;
	uint64_t ds_unique_bytes;	/* only relevant to snapshots */
	/*
	 * The ds_fsid_guid is a 56-bit ID that can change to avoid
	 * collisions.  The ds_guid is a 64-bit ID that will never
	 * change, so there is a small probability that it will collide.
	 */
	uint64_t ds_fsid_guid;
	uint64_t ds_guid;
	uint64_t ds_flags;		/* DS_FLAG_* */
	blkptr_t ds_bp;
	uint64_t ds_next_clones_obj;	/* DMU_OT_DSL_CLONES */
	uint64_t ds_props_obj;		/* DMU_OT_DSL_PROPS for snaps */
	uint64_t ds_userrefs_obj;	/* DMU_OT_USERREFS */
	uint64_t ds_pad[5]; /* pad out to 320 bytes for good measure */
} dsl_dataset_phys_t;

typedef struct dsl_dataset {
	dmu_buf_user_t ds_dbu;

	/* Immutable: */
	struct dsl_dir *ds_dir;
	dmu_buf_t *ds_dbuf;
	uint64_t ds_object;
	uint64_t ds_fsid_guid;
	boolean_t ds_is_snapshot;

	/* only used in syncing context, only valid for non-snapshots: */
	struct dsl_dataset *ds_prev;
	uint64_t ds_bookmarks;  /* DMU_OTN_ZAP_METADATA */
	boolean_t ds_large_blocks;
	boolean_t ds_need_large_blocks;

	/* has internal locking: */
	dsl_deadlist_t ds_deadlist;
	bplist_t ds_pending_deadlist;

	/* protected by lock on pool's dp_dirty_datasets list */
	txg_node_t ds_dirty_link;
	list_node_t ds_synced_link;

	/*
	 * ds_phys->ds_<accounting> is also protected by ds_lock.
	 * Protected by ds_lock:
	 */
	kmutex_t ds_lock;
	objset_t *ds_objset;
	uint64_t ds_userrefs;
	void *ds_owner;

	/*
	 * Long holds prevent the ds from being destroyed; they allow the
	 * ds to remain held even after dropping the dp_config_rwlock.
	 * Owning counts as a long hold.  See the comments above
	 * dsl_pool_hold() for details.
	 */
	refcount_t ds_longholds;

	/* no locking; only for making guesses */
	uint64_t ds_trysnap_txg;

	/* for objset_open() */
	kmutex_t ds_opening_lock;

	uint64_t ds_reserved;	/* cached refreservation */
	uint64_t ds_quota;	/* cached refquota */

	kmutex_t ds_sendstream_lock;
	list_t ds_sendstreams;

	/* Protected by ds_lock; keep at end of struct for better locality */
	char ds_snapname[MAXNAMELEN];
} dsl_dataset_t;

static inline dsl_dataset_phys_t *
dsl_dataset_phys(dsl_dataset_t *ds)
{
	return (ds->ds_dbuf->db_data);
}

/*
 * The max length of a temporary tag prefix is the number of hex digits
 * required to express UINT64_MAX plus one for the hyphen.
 */
#define	MAX_TAG_PREFIX_LEN	17

#define	dsl_dataset_is_snapshot(ds) \
	(dsl_dataset_phys(ds)->ds_num_children != 0)

#define	DS_UNIQUE_IS_ACCURATE(ds)	\
	((dsl_dataset_phys(ds)->ds_flags & DS_FLAG_UNIQUE_ACCURATE) != 0)

int dsl_dataset_hold(struct dsl_pool *dp, const char *name, void *tag,
    dsl_dataset_t **dsp);
boolean_t dsl_dataset_try_add_ref(struct dsl_pool *dp, dsl_dataset_t *ds,
    void *tag);
int dsl_dataset_hold_obj(struct dsl_pool *dp, uint64_t dsobj, void *tag,
    dsl_dataset_t **);
void dsl_dataset_rele(dsl_dataset_t *ds, void *tag);
int dsl_dataset_own(struct dsl_pool *dp, const char *name,
    void *tag, dsl_dataset_t **dsp);
int dsl_dataset_own_obj(struct dsl_pool *dp, uint64_t dsobj,
    void *tag, dsl_dataset_t **dsp);
void dsl_dataset_disown(dsl_dataset_t *ds, void *tag);
void dsl_dataset_name(dsl_dataset_t *ds, char *name);
boolean_t dsl_dataset_tryown(dsl_dataset_t *ds, void *tag);
int dsl_dataset_namelen(dsl_dataset_t *ds);
uint64_t dsl_dataset_create_sync(dsl_dir_t *pds, const char *lastname,
    dsl_dataset_t *origin, uint64_t flags, cred_t *, dmu_tx_t *);
uint64_t dsl_dataset_create_sync_dd(dsl_dir_t *dd, dsl_dataset_t *origin,
    uint64_t flags, dmu_tx_t *tx);
int dsl_dataset_snapshot(nvlist_t *snaps, nvlist_t *props, nvlist_t *errors);
int dsl_dataset_promote(const char *name, char *conflsnap);
int dsl_dataset_rename_snapshot(const char *fsname,
    const char *oldsnapname, const char *newsnapname, boolean_t recursive);
int dsl_dataset_snapshot_tmp(const char *fsname, const char *snapname,
    minor_t cleanup_minor, const char *htag);

blkptr_t *dsl_dataset_get_blkptr(dsl_dataset_t *ds);
void dsl_dataset_set_blkptr(dsl_dataset_t *ds, blkptr_t *bp, dmu_tx_t *tx);

spa_t *dsl_dataset_get_spa(dsl_dataset_t *ds);

boolean_t dsl_dataset_modified_since_snap(dsl_dataset_t *ds,
    dsl_dataset_t *snap);

void dsl_dataset_sync(dsl_dataset_t *os, zio_t *zio, dmu_tx_t *tx);

void dsl_dataset_block_born(dsl_dataset_t *ds, const blkptr_t *bp,
    dmu_tx_t *tx);
int dsl_dataset_block_kill(dsl_dataset_t *ds, const blkptr_t *bp,
    dmu_tx_t *tx, boolean_t async);
boolean_t dsl_dataset_block_freeable(dsl_dataset_t *ds, const blkptr_t *bp,
    uint64_t blk_birth);
uint64_t dsl_dataset_prev_snap_txg(dsl_dataset_t *ds);
int dsl_dataset_snap_lookup(dsl_dataset_t *ds, const char *name,
    uint64_t *value);

void dsl_dataset_dirty(dsl_dataset_t *ds, dmu_tx_t *tx);
void dsl_dataset_stats(dsl_dataset_t *os, nvlist_t *nv);
void dsl_dataset_fast_stat(dsl_dataset_t *ds, dmu_objset_stats_t *stat);
void dsl_dataset_space(dsl_dataset_t *ds,
    uint64_t *refdbytesp, uint64_t *availbytesp,
    uint64_t *usedobjsp, uint64_t *availobjsp);
uint64_t dsl_dataset_fsid_guid(dsl_dataset_t *ds);
int dsl_dataset_space_written(dsl_dataset_t *oldsnap, dsl_dataset_t *new,
    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp);
int dsl_dataset_space_wouldfree(dsl_dataset_t *firstsnap, dsl_dataset_t *last,
    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp);
boolean_t dsl_dataset_is_dirty(dsl_dataset_t *ds);
int dsl_dataset_activate_large_blocks(const char *dsname);
void dsl_dataset_activate_large_blocks_sync_impl(uint64_t dsobj, dmu_tx_t *tx);

int dsl_dsobj_to_dsname(char *pname, uint64_t obj, char *buf);

int dsl_dataset_check_quota(dsl_dataset_t *ds, boolean_t check_quota,
    uint64_t asize, uint64_t inflight, uint64_t *used,
    uint64_t *ref_rsrv);
int dsl_dataset_set_refquota(const char *dsname, zprop_source_t source,
    uint64_t quota);
int dsl_dataset_set_refreservation(const char *dsname, zprop_source_t source,
    uint64_t reservation);

boolean_t dsl_dataset_is_before(dsl_dataset_t *later, dsl_dataset_t *earlier,
    uint64_t earlier_txg);
void dsl_dataset_long_hold(dsl_dataset_t *ds, void *tag);
void dsl_dataset_long_rele(dsl_dataset_t *ds, void *tag);
boolean_t dsl_dataset_long_held(dsl_dataset_t *ds);

int dsl_dataset_clone_swap_check_impl(dsl_dataset_t *clone,
    dsl_dataset_t *origin_head, boolean_t force, void *owner, dmu_tx_t *tx);
void dsl_dataset_clone_swap_sync_impl(dsl_dataset_t *clone,
    dsl_dataset_t *origin_head, dmu_tx_t *tx);
int dsl_dataset_snapshot_check_impl(dsl_dataset_t *ds, const char *snapname,
    dmu_tx_t *tx, boolean_t recv, uint64_t cnt, cred_t *cr);
void dsl_dataset_snapshot_sync_impl(dsl_dataset_t *ds, const char *snapname,
    dmu_tx_t *tx);

void dsl_dataset_remove_from_next_clones(dsl_dataset_t *ds, uint64_t obj,
    dmu_tx_t *tx);
void dsl_dataset_recalc_head_uniq(dsl_dataset_t *ds);
int dsl_dataset_get_snapname(dsl_dataset_t *ds);
int dsl_dataset_snap_lookup(dsl_dataset_t *ds, const char *name,
    uint64_t *value);
int dsl_dataset_snap_remove(dsl_dataset_t *ds, const char *name, dmu_tx_t *tx,
    boolean_t adj_cnt);
void dsl_dataset_set_refreservation_sync_impl(dsl_dataset_t *ds,
    zprop_source_t source, uint64_t value, dmu_tx_t *tx);
void dsl_dataset_zapify(dsl_dataset_t *ds, dmu_tx_t *tx);
int dsl_dataset_rollback(const char *fsname, void *owner, nvlist_t *result);

#ifdef ZFS_DEBUG
#define	dprintf_ds(ds, fmt, ...) do { \
	if (zfs_flags & ZFS_DEBUG_DPRINTF) { \
	char *__ds_name = kmem_alloc(MAXNAMELEN, KM_SLEEP); \
	dsl_dataset_name(ds, __ds_name); \
	dprintf("ds=%s " fmt, __ds_name, __VA_ARGS__); \
	kmem_free(__ds_name, MAXNAMELEN); \
	} \
_NOTE(CONSTCOND) } while (0)
#else
#define	dprintf_ds(dd, fmt, ...)
#endif

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_DATASET_H */
                                                                                                                                                    usr/src/zfs-0.6.5.9/include/sys/dsl_deadlist.h                                                      0100644 0000000 0000000 00000005304 13045171016 017327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_DSL_DEADLIST_H
#define	_SYS_DSL_DEADLIST_H

#include <sys/bpobj.h>
#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dmu_buf;
struct dsl_dataset;

typedef struct dsl_deadlist_phys {
	uint64_t dl_used;
	uint64_t dl_comp;
	uint64_t dl_uncomp;
	uint64_t dl_pad[37]; /* pad out to 320b for future expansion */
} dsl_deadlist_phys_t;

typedef struct dsl_deadlist {
	objset_t *dl_os;
	uint64_t dl_object;
	avl_tree_t dl_tree;
	boolean_t dl_havetree;
	struct dmu_buf *dl_dbuf;
	dsl_deadlist_phys_t *dl_phys;
	kmutex_t dl_lock;

	/* if it's the old on-disk format: */
	bpobj_t dl_bpobj;
	boolean_t dl_oldfmt;
} dsl_deadlist_t;

typedef struct dsl_deadlist_entry {
	avl_node_t dle_node;
	uint64_t dle_mintxg;
	bpobj_t dle_bpobj;
} dsl_deadlist_entry_t;

void dsl_deadlist_open(dsl_deadlist_t *dl, objset_t *os, uint64_t object);
void dsl_deadlist_close(dsl_deadlist_t *dl);
uint64_t dsl_deadlist_alloc(objset_t *os, dmu_tx_t *tx);
void dsl_deadlist_free(objset_t *os, uint64_t dlobj, dmu_tx_t *tx);
void dsl_deadlist_insert(dsl_deadlist_t *dl, const blkptr_t *bp, dmu_tx_t *tx);
void dsl_deadlist_add_key(dsl_deadlist_t *dl, uint64_t mintxg, dmu_tx_t *tx);
void dsl_deadlist_remove_key(dsl_deadlist_t *dl, uint64_t mintxg, dmu_tx_t *tx);
uint64_t dsl_deadlist_clone(dsl_deadlist_t *dl, uint64_t maxtxg,
    uint64_t mrs_obj, dmu_tx_t *tx);
void dsl_deadlist_space(dsl_deadlist_t *dl,
    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp);
void dsl_deadlist_space_range(dsl_deadlist_t *dl,
    uint64_t mintxg, uint64_t maxtxg,
    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp);
void dsl_deadlist_merge(dsl_deadlist_t *dl, uint64_t obj, dmu_tx_t *tx);
void dsl_deadlist_move_bpobj(dsl_deadlist_t *dl, bpobj_t *bpo, uint64_t mintxg,
    dmu_tx_t *tx);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_DEADLIST_H */
                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/dsl_deleg.h                                                         0100644 0000000 0000000 00000005422 13045171016 016617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DSL_DELEG_H
#define	_SYS_DSL_DELEG_H

#include <sys/dmu.h>
#include <sys/dsl_pool.h>
#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

#define	ZFS_DELEG_PERM_NONE		""
#define	ZFS_DELEG_PERM_CREATE		"create"
#define	ZFS_DELEG_PERM_DESTROY		"destroy"
#define	ZFS_DELEG_PERM_SNAPSHOT		"snapshot"
#define	ZFS_DELEG_PERM_ROLLBACK		"rollback"
#define	ZFS_DELEG_PERM_CLONE		"clone"
#define	ZFS_DELEG_PERM_PROMOTE		"promote"
#define	ZFS_DELEG_PERM_RENAME		"rename"
#define	ZFS_DELEG_PERM_MOUNT		"mount"
#define	ZFS_DELEG_PERM_SHARE		"share"
#define	ZFS_DELEG_PERM_SEND		"send"
#define	ZFS_DELEG_PERM_RECEIVE		"receive"
#define	ZFS_DELEG_PERM_ALLOW		"allow"
#define	ZFS_DELEG_PERM_USERPROP		"userprop"
#define	ZFS_DELEG_PERM_VSCAN		"vscan"
#define	ZFS_DELEG_PERM_USERQUOTA	"userquota"
#define	ZFS_DELEG_PERM_GROUPQUOTA	"groupquota"
#define	ZFS_DELEG_PERM_USERUSED		"userused"
#define	ZFS_DELEG_PERM_GROUPUSED	"groupused"
#define	ZFS_DELEG_PERM_HOLD		"hold"
#define	ZFS_DELEG_PERM_RELEASE		"release"
#define	ZFS_DELEG_PERM_DIFF		"diff"
#define	ZFS_DELEG_PERM_BOOKMARK		"bookmark"

/*
 * Note: the names of properties that are marked delegatable are also
 * valid delegated permissions
 */

int dsl_deleg_get(const char *ddname, nvlist_t **nvp);
int dsl_deleg_set(const char *ddname, nvlist_t *nvp, boolean_t unset);
int dsl_deleg_access(const char *ddname, const char *perm, cred_t *cr);
int dsl_deleg_access_impl(struct dsl_dataset *ds, const char *perm, cred_t *cr);
void dsl_deleg_set_create_perms(dsl_dir_t *dd, dmu_tx_t *tx, cred_t *cr);
int dsl_deleg_can_allow(char *ddname, nvlist_t *nvp, cred_t *cr);
int dsl_deleg_can_unallow(char *ddname, nvlist_t *nvp, cred_t *cr);
int dsl_deleg_destroy(objset_t *os, uint64_t zapobj, dmu_tx_t *tx);
boolean_t dsl_delegation_on(objset_t *os);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DSL_DELEG_H */
                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/dsl_destroy.h                                                       0100644 0000000 0000000 00000003314 13045171016 017226  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 */

#ifndef	_SYS_DSL_DESTROY_H
#define	_SYS_DSL_DESTROY_H

#ifdef	__cplusplus
extern "C" {
#endif

struct nvlist;
struct dsl_dataset;
struct dmu_tx;

int dsl_destroy_snapshots_nvl(struct nvlist *, boolean_t,
    struct nvlist *);
int dsl_destroy_snapshot(const char *, boolean_t);
int dsl_destroy_head(const char *);
int dsl_destroy_head_check_impl(struct dsl_dataset *, int);
void dsl_destroy_head_sync_impl(struct dsl_dataset *, struct dmu_tx *);
int dsl_destroy_inconsistent(const char *, void *);
int dsl_destroy_snapshot_check_impl(struct dsl_dataset *, boolean_t);
void dsl_destroy_snapshot_sync_impl(struct dsl_dataset *,
    boolean_t, struct dmu_tx *);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_DESTROY_H */
                                                                                                                                                                                                                                                                                                                    usr/src/zfs-0.6.5.9/include/sys/dsl_dir.h                                                           0100644 0000000 0000000 00000014522 13045171016 016316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_DSL_DIR_H
#define	_SYS_DSL_DIR_H

#include <sys/dmu.h>
#include <sys/dsl_pool.h>
#include <sys/dsl_synctask.h>
#include <sys/refcount.h>
#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_dataset;

/*
 * DD_FIELD_* are strings that are used in the "extensified" dsl_dir zap object.
 * They should be of the format <reverse-dns>:<field>.
 */

#define	DD_FIELD_FILESYSTEM_COUNT	"com.joyent:filesystem_count"
#define	DD_FIELD_SNAPSHOT_COUNT		"com.joyent:snapshot_count"

typedef enum dd_used {
	DD_USED_HEAD,
	DD_USED_SNAP,
	DD_USED_CHILD,
	DD_USED_CHILD_RSRV,
	DD_USED_REFRSRV,
	DD_USED_NUM
} dd_used_t;

#define	DD_FLAG_USED_BREAKDOWN (1<<0)

typedef struct dsl_dir_phys {
	uint64_t dd_creation_time; /* not actually used */
	uint64_t dd_head_dataset_obj;
	uint64_t dd_parent_obj;
	uint64_t dd_origin_obj;
	uint64_t dd_child_dir_zapobj;
	/*
	 * how much space our children are accounting for; for leaf
	 * datasets, == physical space used by fs + snaps
	 */
	uint64_t dd_used_bytes;
	uint64_t dd_compressed_bytes;
	uint64_t dd_uncompressed_bytes;
	/* Administrative quota setting */
	uint64_t dd_quota;
	/* Administrative reservation setting */
	uint64_t dd_reserved;
	uint64_t dd_props_zapobj;
	uint64_t dd_deleg_zapobj; /* dataset delegation permissions */
	uint64_t dd_flags;
	uint64_t dd_used_breakdown[DD_USED_NUM];
	uint64_t dd_clones; /* dsl_dir objects */
	uint64_t dd_pad[13]; /* pad out to 256 bytes for good measure */
} dsl_dir_phys_t;

struct dsl_dir {
	dmu_buf_user_t dd_dbu;

	/* These are immutable; no lock needed: */
	uint64_t dd_object;
	dsl_pool_t *dd_pool;

	/* Stable until user eviction; no lock needed: */
	dmu_buf_t *dd_dbuf;

	/* protected by lock on pool's dp_dirty_dirs list */
	txg_node_t dd_dirty_link;

	/* protected by dp_config_rwlock */
	dsl_dir_t *dd_parent;

	/* Protected by dd_lock */
	kmutex_t dd_lock;
	list_t dd_prop_cbs; /* list of dsl_prop_cb_record_t's */
	timestruc_t dd_snap_cmtime; /* last time snapshot namespace changed */
	uint64_t dd_origin_txg;

	/* gross estimate of space used by in-flight tx's */
	uint64_t dd_tempreserved[TXG_SIZE];
	/* amount of space we expect to write; == amount of dirty data */
	int64_t dd_space_towrite[TXG_SIZE];

	/* protected by dd_lock; keep at end of struct for better locality */
	char dd_myname[MAXNAMELEN];
};

static inline dsl_dir_phys_t *
dsl_dir_phys(dsl_dir_t *dd)
{
	return (dd->dd_dbuf->db_data);
}

void dsl_dir_rele(dsl_dir_t *dd, void *tag);
void dsl_dir_async_rele(dsl_dir_t *dd, void *tag);
int dsl_dir_hold(dsl_pool_t *dp, const char *name, void *tag,
    dsl_dir_t **, const char **tail);
int dsl_dir_hold_obj(dsl_pool_t *dp, uint64_t ddobj,
    const char *tail, void *tag, dsl_dir_t **);
void dsl_dir_name(dsl_dir_t *dd, char *buf);
int dsl_dir_namelen(dsl_dir_t *dd);
uint64_t dsl_dir_create_sync(dsl_pool_t *dp, dsl_dir_t *pds,
    const char *name, dmu_tx_t *tx);
void dsl_dir_stats(dsl_dir_t *dd, nvlist_t *nv);
uint64_t dsl_dir_space_available(dsl_dir_t *dd,
    dsl_dir_t *ancestor, int64_t delta, int ondiskonly);
void dsl_dir_dirty(dsl_dir_t *dd, dmu_tx_t *tx);
void dsl_dir_sync(dsl_dir_t *dd, dmu_tx_t *tx);
int dsl_dir_tempreserve_space(dsl_dir_t *dd, uint64_t mem,
    uint64_t asize, uint64_t fsize, uint64_t usize, void **tr_cookiep,
    dmu_tx_t *tx);
void dsl_dir_tempreserve_clear(void *tr_cookie, dmu_tx_t *tx);
void dsl_dir_willuse_space(dsl_dir_t *dd, int64_t space, dmu_tx_t *tx);
void dsl_dir_diduse_space(dsl_dir_t *dd, dd_used_t type,
    int64_t used, int64_t compressed, int64_t uncompressed, dmu_tx_t *tx);
void dsl_dir_transfer_space(dsl_dir_t *dd, int64_t delta,
    dd_used_t oldtype, dd_used_t newtype, dmu_tx_t *tx);
int dsl_dir_set_quota(const char *ddname, zprop_source_t source,
    uint64_t quota);
int dsl_dir_set_reservation(const char *ddname, zprop_source_t source,
    uint64_t reservation);
int dsl_dir_activate_fs_ss_limit(const char *);
int dsl_fs_ss_limit_check(dsl_dir_t *, uint64_t, zfs_prop_t, dsl_dir_t *,
    cred_t *);
void dsl_fs_ss_count_adjust(dsl_dir_t *, int64_t, const char *, dmu_tx_t *);
int dsl_dir_rename(const char *oldname, const char *newname);
int dsl_dir_transfer_possible(dsl_dir_t *sdd, dsl_dir_t *tdd,
    uint64_t fs_cnt, uint64_t ss_cnt, uint64_t space, cred_t *);
boolean_t dsl_dir_is_clone(dsl_dir_t *dd);
void dsl_dir_new_refreservation(dsl_dir_t *dd, struct dsl_dataset *ds,
    uint64_t reservation, cred_t *cr, dmu_tx_t *tx);
void dsl_dir_snap_cmtime_update(dsl_dir_t *dd);
timestruc_t dsl_dir_snap_cmtime(dsl_dir_t *dd);
void dsl_dir_set_reservation_sync_impl(dsl_dir_t *dd, uint64_t value,
    dmu_tx_t *tx);
void dsl_dir_zapify(dsl_dir_t *dd, dmu_tx_t *tx);
boolean_t dsl_dir_is_zapified(dsl_dir_t *dd);

/* internal reserved dir name */
#define	MOS_DIR_NAME "$MOS"
#define	ORIGIN_DIR_NAME "$ORIGIN"
#define	XLATION_DIR_NAME "$XLATION"
#define	FREE_DIR_NAME "$FREE"
#define	LEAK_DIR_NAME "$LEAK"

#ifdef ZFS_DEBUG
#define	dprintf_dd(dd, fmt, ...) do { \
	if (zfs_flags & ZFS_DEBUG_DPRINTF) { \
	char *__ds_name = kmem_alloc(MAXNAMELEN + strlen(MOS_DIR_NAME) + 1, \
	    KM_SLEEP); \
	dsl_dir_name(dd, __ds_name); \
	dprintf("dd=%s " fmt, __ds_name, __VA_ARGS__); \
	kmem_free(__ds_name, MAXNAMELEN + strlen(MOS_DIR_NAME) + 1); \
	} \
_NOTE(CONSTCOND) } while (0)
#else
#define	dprintf_dd(dd, fmt, ...)
#endif

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_DIR_H */
                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/dsl_pool.h                                                          0100644 0000000 0000000 00000013002 13045171016 016501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DSL_POOL_H
#define	_SYS_DSL_POOL_H

#include <sys/spa.h>
#include <sys/txg.h>
#include <sys/txg_impl.h>
#include <sys/zfs_context.h>
#include <sys/zio.h>
#include <sys/dnode.h>
#include <sys/ddt.h>
#include <sys/arc.h>
#include <sys/bpobj.h>
#include <sys/bptree.h>
#include <sys/rrwlock.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern int zfs_txg_synctime_ms;

struct objset;
struct dsl_dir;
struct dsl_dataset;
struct dsl_pool;
struct dmu_tx;
struct dsl_scan;

extern unsigned long zfs_dirty_data_max;
extern unsigned long zfs_dirty_data_max_max;
extern unsigned long zfs_dirty_data_sync;
extern int zfs_dirty_data_max_percent;
extern int zfs_dirty_data_max_max_percent;
extern int zfs_delay_min_dirty_percent;
extern unsigned long zfs_delay_scale;

/* These macros are for indexing into the zfs_all_blkstats_t. */
#define	DMU_OT_DEFERRED	DMU_OT_NONE
#define	DMU_OT_OTHER	DMU_OT_NUMTYPES /* place holder for DMU_OT() types */
#define	DMU_OT_TOTAL	(DMU_OT_NUMTYPES + 1)

typedef struct zfs_blkstat {
	uint64_t	zb_count;
	uint64_t	zb_asize;
	uint64_t	zb_lsize;
	uint64_t	zb_psize;
	uint64_t	zb_gangs;
	uint64_t	zb_ditto_2_of_2_samevdev;
	uint64_t	zb_ditto_2_of_3_samevdev;
	uint64_t	zb_ditto_3_of_3_samevdev;
} zfs_blkstat_t;

typedef struct zfs_all_blkstats {
	zfs_blkstat_t	zab_type[DN_MAX_LEVELS + 1][DMU_OT_TOTAL + 1];
} zfs_all_blkstats_t;


typedef struct dsl_pool {
	/* Immutable */
	spa_t *dp_spa;
	struct objset *dp_meta_objset;
	struct dsl_dir *dp_root_dir;
	struct dsl_dir *dp_mos_dir;
	struct dsl_dir *dp_free_dir;
	struct dsl_dir *dp_leak_dir;
	struct dsl_dataset *dp_origin_snap;
	uint64_t dp_root_dir_obj;
	struct taskq *dp_iput_taskq;

	/* No lock needed - sync context only */
	blkptr_t dp_meta_rootbp;
	uint64_t dp_tmp_userrefs_obj;
	bpobj_t dp_free_bpobj;
	uint64_t dp_bptree_obj;
	uint64_t dp_empty_bpobj;

	struct dsl_scan *dp_scan;

	/* Uses dp_lock */
	kmutex_t dp_lock;
	kcondvar_t dp_spaceavail_cv;
	uint64_t dp_dirty_pertxg[TXG_SIZE];
	uint64_t dp_dirty_total;
	uint64_t dp_mos_used_delta;
	uint64_t dp_mos_compressed_delta;
	uint64_t dp_mos_uncompressed_delta;

	/*
	 * Time of most recently scheduled (furthest in the future)
	 * wakeup for delayed transactions.
	 */
	hrtime_t dp_last_wakeup;

	/* Has its own locking */
	tx_state_t dp_tx;
	txg_list_t dp_dirty_datasets;
	txg_list_t dp_dirty_zilogs;
	txg_list_t dp_dirty_dirs;
	txg_list_t dp_sync_tasks;

	/*
	 * Protects administrative changes (properties, namespace)
	 *
	 * It is only held for write in syncing context.  Therefore
	 * syncing context does not need to ever have it for read, since
	 * nobody else could possibly have it for write.
	 */
	rrwlock_t dp_config_rwlock;

	zfs_all_blkstats_t *dp_blkstats;
} dsl_pool_t;

int dsl_pool_init(spa_t *spa, uint64_t txg, dsl_pool_t **dpp);
int dsl_pool_open(dsl_pool_t *dp);
void dsl_pool_close(dsl_pool_t *dp);
dsl_pool_t *dsl_pool_create(spa_t *spa, nvlist_t *zplprops, uint64_t txg);
void dsl_pool_sync(dsl_pool_t *dp, uint64_t txg);
void dsl_pool_sync_done(dsl_pool_t *dp, uint64_t txg);
int dsl_pool_sync_context(dsl_pool_t *dp);
uint64_t dsl_pool_adjustedsize(dsl_pool_t *dp, boolean_t netfree);
uint64_t dsl_pool_adjustedfree(dsl_pool_t *dp, boolean_t netfree);
void dsl_pool_dirty_space(dsl_pool_t *dp, int64_t space, dmu_tx_t *tx);
void dsl_pool_undirty_space(dsl_pool_t *dp, int64_t space, uint64_t txg);
void dsl_free(dsl_pool_t *dp, uint64_t txg, const blkptr_t *bpp);
void dsl_free_sync(zio_t *pio, dsl_pool_t *dp, uint64_t txg,
    const blkptr_t *bpp);
void dsl_pool_create_origin(dsl_pool_t *dp, dmu_tx_t *tx);
void dsl_pool_upgrade_clones(dsl_pool_t *dp, dmu_tx_t *tx);
void dsl_pool_upgrade_dir_clones(dsl_pool_t *dp, dmu_tx_t *tx);
void dsl_pool_mos_diduse_space(dsl_pool_t *dp,
    int64_t used, int64_t comp, int64_t uncomp);
boolean_t dsl_pool_need_dirty_delay(dsl_pool_t *dp);
void dsl_pool_config_enter(dsl_pool_t *dp, void *tag);
void dsl_pool_config_enter_prio(dsl_pool_t *dp, void *tag);
void dsl_pool_config_exit(dsl_pool_t *dp, void *tag);
boolean_t dsl_pool_config_held(dsl_pool_t *dp);
boolean_t dsl_pool_config_held_writer(dsl_pool_t *dp);

taskq_t *dsl_pool_iput_taskq(dsl_pool_t *dp);

int dsl_pool_user_hold(dsl_pool_t *dp, uint64_t dsobj,
    const char *tag, uint64_t now, dmu_tx_t *tx);
int dsl_pool_user_release(dsl_pool_t *dp, uint64_t dsobj,
    const char *tag, dmu_tx_t *tx);
void dsl_pool_clean_tmp_userrefs(dsl_pool_t *dp);
int dsl_pool_open_special_dir(dsl_pool_t *dp, const char *name, dsl_dir_t **);
int dsl_pool_hold(const char *name, void *tag, dsl_pool_t **dp);
void dsl_pool_rele(dsl_pool_t *dp, void *tag);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_POOL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/dsl_prop.h                                                          0100644 0000000 0000000 00000007463 13045171016 016526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DSL_PROP_H
#define	_SYS_DSL_PROP_H

#include <sys/dmu.h>
#include <sys/dsl_pool.h>
#include <sys/zfs_context.h>
#include <sys/dsl_synctask.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_dataset;
struct dsl_dir;

/* The callback func may not call into the DMU or DSL! */
typedef void (dsl_prop_changed_cb_t)(void *arg, uint64_t newval);

typedef struct dsl_prop_cb_record {
	list_node_t cbr_node; /* link on dd_prop_cbs */
	struct dsl_dataset *cbr_ds;
	const char *cbr_propname;
	dsl_prop_changed_cb_t *cbr_func;
	void *cbr_arg;
} dsl_prop_cb_record_t;

typedef struct dsl_props_arg {
	nvlist_t *pa_props;
	zprop_source_t pa_source;
} dsl_props_arg_t;

int dsl_prop_register(struct dsl_dataset *ds, const char *propname,
    dsl_prop_changed_cb_t *callback, void *cbarg);
int dsl_prop_unregister(struct dsl_dataset *ds, const char *propname,
    dsl_prop_changed_cb_t *callback, void *cbarg);
void dsl_prop_notify_all(struct dsl_dir *dd);
boolean_t dsl_prop_hascb(struct dsl_dataset *ds);

int dsl_prop_get(const char *ddname, const char *propname,
    int intsz, int numints, void *buf, char *setpoint);
int dsl_prop_get_integer(const char *ddname, const char *propname,
    uint64_t *valuep, char *setpoint);
int dsl_prop_get_all(objset_t *os, nvlist_t **nvp);
int dsl_prop_get_received(const char *dsname, nvlist_t **nvp);
int dsl_prop_get_ds(struct dsl_dataset *ds, const char *propname,
    int intsz, int numints, void *buf, char *setpoint);
int dsl_prop_get_int_ds(struct dsl_dataset *ds, const char *propname,
    uint64_t *valuep);
int dsl_prop_get_dd(struct dsl_dir *dd, const char *propname,
    int intsz, int numints, void *buf, char *setpoint,
    boolean_t snapshot);

void dsl_props_set_sync_impl(struct dsl_dataset *ds, zprop_source_t source,
    nvlist_t *props, dmu_tx_t *tx);
void dsl_prop_set_sync_impl(struct dsl_dataset *ds, const char *propname,
    zprop_source_t source, int intsz, int numints, const void *value,
    dmu_tx_t *tx);
int dsl_props_set(const char *dsname, zprop_source_t source, nvlist_t *nvl);
int dsl_prop_set_int(const char *dsname, const char *propname,
    zprop_source_t source, uint64_t value);
int dsl_prop_set_string(const char *dsname, const char *propname,
    zprop_source_t source, const char *value);
int dsl_prop_inherit(const char *dsname, const char *propname,
    zprop_source_t source);

int dsl_prop_predict(dsl_dir_t *dd, const char *propname,
    zprop_source_t source, uint64_t value, uint64_t *newvalp);

/* flag first receive on or after SPA_VERSION_RECVD_PROPS */
boolean_t dsl_prop_get_hasrecvd(const char *dsname);
int dsl_prop_set_hasrecvd(const char *dsname);
void dsl_prop_unset_hasrecvd(const char *dsname);

void dsl_prop_nvlist_add_uint64(nvlist_t *nv, zfs_prop_t prop, uint64_t value);
void dsl_prop_nvlist_add_string(nvlist_t *nv,
    zfs_prop_t prop, const char *value);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_DSL_PROP_H */
                                                                                                                                                                                                             usr/src/zfs-0.6.5.9/include/sys/dsl_scan.h                                                          0100644 0000000 0000000 00000011566 13045171016 016471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DSL_SCAN_H
#define	_SYS_DSL_SCAN_H

#include <sys/zfs_context.h>
#include <sys/zio.h>
#include <sys/ddt.h>
#include <sys/bplist.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct objset;
struct dsl_dir;
struct dsl_dataset;
struct dsl_pool;
struct dmu_tx;

/*
 * All members of this structure must be uint64_t, for byteswap
 * purposes.
 */
typedef struct dsl_scan_phys {
	uint64_t scn_func; /* pool_scan_func_t */
	uint64_t scn_state; /* dsl_scan_state_t */
	uint64_t scn_queue_obj;
	uint64_t scn_min_txg;
	uint64_t scn_max_txg;
	uint64_t scn_cur_min_txg;
	uint64_t scn_cur_max_txg;
	uint64_t scn_start_time;
	uint64_t scn_end_time;
	uint64_t scn_to_examine; /* total bytes to be scanned */
	uint64_t scn_examined; /* bytes scanned so far */
	uint64_t scn_to_process;
	uint64_t scn_processed;
	uint64_t scn_errors;	/* scan I/O error count */
	uint64_t scn_ddt_class_max;
	ddt_bookmark_t scn_ddt_bookmark;
	zbookmark_phys_t scn_bookmark;
	uint64_t scn_flags; /* dsl_scan_flags_t */
} dsl_scan_phys_t;

#define	SCAN_PHYS_NUMINTS (sizeof (dsl_scan_phys_t) / sizeof (uint64_t))

typedef enum dsl_scan_flags {
	DSF_VISIT_DS_AGAIN = 1<<0,
} dsl_scan_flags_t;

#define	DSL_SCAN_FLAGS_MASK (DSF_VISIT_DS_AGAIN)

/*
 * Every pool will have one dsl_scan_t and this structure will contain
 * in-memory information about the scan and a pointer to the on-disk
 * representation (i.e. dsl_scan_phys_t). Most of the state of the scan
 * is contained on-disk to allow the scan to resume in the event of a reboot
 * or panic. This structure maintains information about the behavior of a
 * running scan, some caching information, and how it should traverse the pool.
 *
 * The following members of this structure direct the behavior of the scan:
 *
 * scn_pausing -	a scan that cannot be completed in a single txg or
 *			has exceeded its allotted time will need to pause.
 *			When this flag is set the scanner will stop traversing
 *			the pool and write out the current state to disk.
 *
 * scn_restart_txg -	directs the scanner to either restart or start a
 *			a scan at the specified txg value.
 *
 * scn_done_txg -	when a scan completes its traversal it will set
 *			the completion txg to the next txg. This is necessary
 *			to ensure that any blocks that were freed during
 *			the scan but have not yet been processed (i.e deferred
 *			frees) are accounted for.
 *
 * This structure also maintains information about deferred frees which are
 * a special kind of traversal. Deferred free can exist in either a bptree or
 * a bpobj structure. The scn_is_bptree flag will indicate the type of
 * deferred free that is in progress. If the deferred free is part of an
 * asynchronous destroy then the scn_async_destroying flag will be set.
 */
typedef struct dsl_scan {
	struct dsl_pool *scn_dp;

	boolean_t scn_pausing;
	uint64_t scn_restart_txg;
	uint64_t scn_done_txg;
	uint64_t scn_sync_start_time;
	zio_t *scn_zio_root;

	/* for freeing blocks */
	boolean_t scn_is_bptree;
	boolean_t scn_async_destroying;
	boolean_t scn_async_stalled;

	/* for debugging / information */
	uint64_t scn_visited_this_txg;

	dsl_scan_phys_t scn_phys;
} dsl_scan_t;

int dsl_scan_init(struct dsl_pool *dp, uint64_t txg);
void dsl_scan_fini(struct dsl_pool *dp);
void dsl_scan_sync(struct dsl_pool *, dmu_tx_t *);
int dsl_scan_cancel(struct dsl_pool *);
int dsl_scan(struct dsl_pool *, pool_scan_func_t);
void dsl_resilver_restart(struct dsl_pool *, uint64_t txg);
boolean_t dsl_scan_resilvering(struct dsl_pool *dp);
boolean_t dsl_dataset_unstable(struct dsl_dataset *ds);
void dsl_scan_ddt_entry(dsl_scan_t *scn, enum zio_checksum checksum,
    ddt_entry_t *dde, dmu_tx_t *tx);
void dsl_scan_ds_destroyed(struct dsl_dataset *ds, struct dmu_tx *tx);
void dsl_scan_ds_snapshotted(struct dsl_dataset *ds, struct dmu_tx *tx);
void dsl_scan_ds_clone_swapped(struct dsl_dataset *ds1, struct dsl_dataset *ds2,
    struct dmu_tx *tx);
boolean_t dsl_scan_active(dsl_scan_t *scn);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_SCAN_H */
                                                                                                                                          usr/src/zfs-0.6.5.9/include/sys/dsl_synctask.h                                                      0100644 0000000 0000000 00000005555 13045171016 017405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef	_SYS_DSL_SYNCTASK_H
#define	_SYS_DSL_SYNCTASK_H

#include <sys/txg.h>
#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_pool;

typedef int (dsl_checkfunc_t)(void *, dmu_tx_t *);
typedef void (dsl_syncfunc_t)(void *, dmu_tx_t *);

typedef enum zfs_space_check {
	/*
	 * Normal space check: if there is less than 3.2% free space,
	 * the operation will fail.  Operations which are logically
	 * creating things should use this (e.g. "zfs create", "zfs snapshot").
	 * User writes (via the ZPL / ZVOL) also fail at this point.
	 */
	ZFS_SPACE_CHECK_NORMAL,

	/*
	 * Space check allows use of half the slop space.  If there
	 * is less than 1.6% free space, the operation will fail.  Most
	 * operations should use this (e.g. "zfs set", "zfs rename"),
	 * because we want them to succeed even after user writes are failing,
	 * so that they can be used as part of the space recovery process.
	 */
	ZFS_SPACE_CHECK_RESERVED,

	/*
	 * No space check is performed.  Only operations which we expect to
	 * result in a net reduction in space should use this
	 * (e.g. "zfs destroy". Setting quotas & reservations also uses
	 * this because it needs to circumvent the quota/reservation checks).
	 *
	 * See also the comments above spa_slop_shift.
	 */
	ZFS_SPACE_CHECK_NONE,
} zfs_space_check_t;

typedef struct dsl_sync_task {
	txg_node_t dst_node;
	struct dsl_pool *dst_pool;
	uint64_t dst_txg;
	int dst_space;
	zfs_space_check_t dst_space_check;
	dsl_checkfunc_t *dst_checkfunc;
	dsl_syncfunc_t *dst_syncfunc;
	void *dst_arg;
	int dst_error;
	boolean_t dst_nowaiter;
} dsl_sync_task_t;

void dsl_sync_task_sync(dsl_sync_task_t *, dmu_tx_t *);
int dsl_sync_task(const char *, dsl_checkfunc_t *,
    dsl_syncfunc_t *, void *, int, zfs_space_check_t);
void dsl_sync_task_nowait(struct dsl_pool *, dsl_syncfunc_t *,
    void *, int, zfs_space_check_t, dmu_tx_t *);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_SYNCTASK_H */
                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/dsl_userhold.h                                                      0100644 0000000 0000000 00000003536 13045171016 017370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 * Copyright (c) 2013 Steven Hartland. All rights reserved.
 */

#ifndef	_SYS_DSL_USERHOLD_H
#define	_SYS_DSL_USERHOLD_H

#include <sys/nvpair.h>
#include <sys/types.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_pool;
struct dsl_dataset;
struct dmu_tx;

int dsl_dataset_user_hold(nvlist_t *holds, minor_t cleanup_minor,
    nvlist_t *errlist);
int dsl_dataset_user_release(nvlist_t *holds, nvlist_t *errlist);
int dsl_dataset_get_holds(const char *dsname, nvlist_t *nvl);
void dsl_dataset_user_release_tmp(struct dsl_pool *dp, nvlist_t *holds);
int dsl_dataset_user_hold_check_one(struct dsl_dataset *ds, const char *htag,
    boolean_t temphold, struct dmu_tx *tx);
void dsl_dataset_user_hold_sync_one(struct dsl_dataset *ds, const char *htag,
    minor_t minor, uint64_t now, struct dmu_tx *tx);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_DSL_USERHOLD_H */
                                                                                                                                                                  usr/src/zfs-0.6.5.9/include/sys/efi_partition.h                                                     0100644 0000000 0000000 00000021202 13045171016 017523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_EFI_PARTITION_H
#define	_SYS_EFI_PARTITION_H

#include <sys/uuid.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * GUID Partition Table Header
 */

#define	EFI_MIN_LABEL_SIZE 92
#define	EFI_LABEL_SIZE	512
#define	LEN_EFI_PAD	(EFI_LABEL_SIZE - \
			    ((5 * sizeof (diskaddr_t)) + \
			    (7 * sizeof (uint_t)) + \
			    (8 * sizeof (char)) + \
			    (1 * (sizeof (struct uuid)))))

#define	EFI_SIGNATURE	0x5452415020494645ULL

/* EFI Guid Partition Table Header -- little endian on-disk format */
typedef struct efi_gpt {
	uint64_t	efi_gpt_Signature;
	uint_t		efi_gpt_Revision;
	uint_t		efi_gpt_HeaderSize;
	uint_t		efi_gpt_HeaderCRC32;
	uint_t		efi_gpt_Reserved1;
	diskaddr_t	efi_gpt_MyLBA;
	diskaddr_t	efi_gpt_AlternateLBA;
	diskaddr_t	efi_gpt_FirstUsableLBA;
	diskaddr_t	efi_gpt_LastUsableLBA;
	struct uuid	efi_gpt_DiskGUID;
	diskaddr_t	efi_gpt_PartitionEntryLBA;
	uint_t		efi_gpt_NumberOfPartitionEntries;
	uint_t		efi_gpt_SizeOfPartitionEntry;
	uint_t		efi_gpt_PartitionEntryArrayCRC32;
	char		efi_gpt_Reserved2[LEN_EFI_PAD];
} efi_gpt_t;

/* EFI Guid Partition Entry Attributes -- little endian format */
typedef struct efi_gpe_Attrs {
	uint32_t	PartitionAttrs		:16,
			Reserved2		:16;
	uint32_t	Reserved1		:31,
			RequiredPartition	:1;
} efi_gpe_Attrs_t;

/*
 * 6a96237f-1dd2-11b2-99a6-080020736631	V_UNASSIGNED (not used as such)
 * 6a82cb45-1dd2-11b2-99a6-080020736631	V_BOOT
 * 6a85cf4d-1dd2-11b2-99a6-080020736631	V_ROOT
 * 6a87c46f-1dd2-11b2-99a6-080020736631	V_SWAP
 * 6a898cc3-1dd2-11b2-99a6-080020736631	V_USR
 * 6a8b642b-1dd2-11b2-99a6-080020736631	V_BACKUP
 * 6a8d2ac7-1dd2-11b2-99a6-080020736631	V_STAND (not used)
 * 6a8ef2e9-1dd2-11b2-99a6-080020736631	V_VAR
 * 6a90ba39-1dd2-11b2-99a6-080020736631	V_HOME
 * 6a9283a5-1dd2-11b2-99a6-080020736631	V_ALTSCTR
 * 6a945a3b-1dd2-11b2-99a6-080020736631	V_CACHE
 */

#define	EFI_UNUSED	{ 0x00000000, 0x0000, 0x0000, 0x00, 0x00, \
			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }
#define	EFI_RESV1	{ 0x6a96237f, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_BOOT	{ 0x6a82cb45, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_ROOT	{ 0x6a85cf4d, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_SWAP	{ 0x6a87c46f, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_USR		{ 0x6a898cc3, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_BACKUP	{ 0x6a8b642b, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_RESV2	{ 0x6a8d2ac7, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_VAR		{ 0x6a8ef2e9, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_HOME	{ 0x6a90ba39, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_ALTSCTR	{ 0x6a9283a5, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_RESERVED	{ 0x6a945a3b, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_SYSTEM	{ 0xC12A7328, 0xF81F, 0x11d2, 0xBA, 0x4B, \
			    { 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B } }
#define	EFI_LEGACY_MBR	{ 0x024DEE41, 0x33E7, 0x11d3, 0x9D, 0x69, \
			    { 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F } }
#define	EFI_SYMC_PUB	{ 0x6a9630d1, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_SYMC_CDS	{ 0x6a980767, 0x1dd2, 0x11b2, 0x99, 0xa6, \
			    { 0x08, 0x00, 0x20, 0x73, 0x66, 0x31 } }
#define	EFI_MSFT_RESV	{ 0xE3C9E316, 0x0B5C, 0x4DB8, 0x81, 0x7D, \
			    { 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE } }
#define	EFI_DELL_BASIC	{ 0xebd0a0a2, 0xb9e5, 0x4433, 0x87, 0xc0, \
			    { 0x68, 0xb6, 0xb7, 0x26, 0x99, 0xc7 } }
#define	EFI_DELL_RAID	{ 0xa19d880f, 0x05fc, 0x4d3b, 0xa0, 0x06, \
			    { 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e } }
#define	EFI_DELL_SWAP	{ 0x0657fd6d, 0xa4ab, 0x43c4, 0x84, 0xe5, \
			    { 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f } }
#define	EFI_DELL_LVM	{ 0xe6d6d379, 0xf507, 0x44c2, 0xa2, 0x3c, \
			    { 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28 } }
#define	EFI_DELL_RESV	{ 0x8da63339, 0x0007, 0x60c0, 0xc4, 0x36, \
			    { 0x08, 0x3a, 0xc8, 0x23, 0x09, 0x08 } }
#define	EFI_AAPL_HFS	{ 0x48465300, 0x0000, 0x11aa, 0xaa, 0x11, \
			    { 0x00, 0x30, 0x65, 0x43, 0xec, 0xac } }
#define	EFI_AAPL_UFS	{ 0x55465300, 0x0000, 0x11aa, 0xaa, 0x11, \
			    { 0x00, 0x30, 0x65, 0x43, 0xec, 0xac } }

/* minimum # of bytes for partition table entires, per EFI spec */
#define	EFI_MIN_ARRAY_SIZE	(16 * 1024)

#define	EFI_PART_NAME_LEN	36

/* size of the "reserved" partition, in blocks */
#define	EFI_MIN_RESV_SIZE	(16 * 1024)

/* EFI Guid Partition Entry */
typedef struct efi_gpe {
	struct uuid	efi_gpe_PartitionTypeGUID;
	struct uuid	efi_gpe_UniquePartitionGUID;
	diskaddr_t	efi_gpe_StartingLBA;
	diskaddr_t	efi_gpe_EndingLBA;
	efi_gpe_Attrs_t	efi_gpe_Attributes;
	ushort_t	efi_gpe_PartitionName[EFI_PART_NAME_LEN];
} efi_gpe_t;

/*
 * passed to the useful (we hope) routines (efi_alloc_and_read and
 * efi_write) that take this VTOC-like struct.  These routines handle
 * converting this struct into the EFI struct, generate UUIDs and
 * checksums, and perform any necessary byte-swapping to the on-disk
 * format.
 */
/* Solaris library abstraction for EFI partitons */
typedef struct dk_part	{
	diskaddr_t	p_start;	/* starting LBA */
	diskaddr_t	p_size;		/* size in blocks */
	struct uuid	p_guid;		/* partion type GUID */
	ushort_t	p_tag;		/* converted to part'n type GUID */
	ushort_t	p_flag;		/* attributes */
	char		p_name[EFI_PART_NAME_LEN]; /* partition name */
	struct uuid	p_uguid;	/* unique partition GUID */
	uint_t		p_resv[8];	/* future use - set to zero */
} dk_part_t;

/* Solaris library abstraction for an EFI GPT */
#define	EFI_VERSION102		0x00010002
#define	EFI_VERSION100		0x00010000
#define	EFI_VERSION_CURRENT	EFI_VERSION100
typedef struct dk_gpt {
	uint_t		efi_version;	/* set to EFI_VERSION_CURRENT */
	uint_t		efi_nparts;	/* number of partitions below */
	uint_t		efi_part_size;	/* size of each partition entry */
					/* efi_part_size is unused */
	uint_t		efi_lbasize;	/* size of block in bytes */
	diskaddr_t	efi_last_lba;	/* last block on the disk */
	diskaddr_t	efi_first_u_lba; /* first block after labels */
	diskaddr_t	efi_last_u_lba;	/* last block before backup labels */
	struct uuid	efi_disk_uguid;	/* unique disk GUID */
	uint_t		efi_flags;
	uint_t		efi_reserved1;	/* future use - set to zero */
	diskaddr_t	efi_altern_lba;	/* lba of alternate GPT header */
	uint_t		efi_reserved[12]; /* future use - set to zero */
	struct dk_part	efi_parts[1];	/* array of partitions */
} dk_gpt_t;

/* possible values for "efi_flags" */
#define	EFI_GPT_PRIMARY_CORRUPT	0x1	/* primary label corrupt */

/* the private ioctl between libefi and the driver */
typedef struct dk_efi {
	diskaddr_t	 dki_lba;	/* starting block */
	len_t		 dki_length;	/* length in bytes */
	union {
		efi_gpt_t 	*_dki_data;
		uint64_t	_dki_data_64;
	} dki_un;
#define	dki_data	dki_un._dki_data
#define	dki_data_64	dki_un._dki_data_64
} dk_efi_t;

struct partition64 {
	struct uuid	p_type;
	uint_t		p_partno;
	uint_t		p_resv1;
	diskaddr_t	p_start;
	diskaddr_t	p_size;
};

/*
 * Number of EFI partitions
 */
#if defined(__linux__)
#define	EFI_NUMPAR	128 /* Expected by parted-1.8.1 */
#else
#define	EFI_NUMPAR	9
#endif

#ifndef _KERNEL
extern	int	efi_alloc_and_init(int, uint32_t, struct dk_gpt **);
extern	int	efi_alloc_and_read(int, struct dk_gpt **);
extern	int	efi_write(int, struct dk_gpt *);
extern	int	efi_rescan(int);
extern	void	efi_free(struct dk_gpt *);
extern	int	efi_type(int);
extern	void	efi_err_check(struct dk_gpt *);
extern	int	efi_auto_sense(int fd, struct dk_gpt **);
extern	int	efi_use_whole_disk(int fd);
#endif

#ifdef __cplusplus
}
#endif

#endif /* _SYS_EFI_PARTITION_H */
                                                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/fm/                                                                 0040755 0000000 0000000 00000000000 13077704276 015145  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/fm/Makefile.am                                                      0100644 0000000 0000000 00000000616 13045171016 017162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = fs

COMMON_H = \
	$(top_srcdir)/include/sys/fm/protocol.h \
	$(top_srcdir)/include/sys/fm/util.h

KERNEL_H =

USER_H =

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)

if CONFIG_USER
libzfsdir = $(includedir)/libzfs/sys/fm
libzfs_HEADERS = $(COMMON_H) $(USER_H)
endif

if CONFIG_KERNEL
kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys/fm
kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
endif
                                                                                                                  usr/src/zfs-0.6.5.9/include/sys/fm/Makefile.in                                                      0100644 0000000 0000000 00000070176 13045370526 017212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = include/sys/fm
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
	$(am__kernel_HEADERS_DIST) $(am__libzfs_HEADERS_DIST)
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__kernel_HEADERS_DIST = $(top_srcdir)/include/sys/fm/protocol.h \
	$(top_srcdir)/include/sys/fm/util.h
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"
am__libzfs_HEADERS_DIST = $(top_srcdir)/include/sys/fm/protocol.h \
	$(top_srcdir)/include/sys/fm/util.h
HEADERS = $(kernel_HEADERS) $(libzfs_HEADERS)
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
SUBDIRS = fs
COMMON_H = \
	$(top_srcdir)/include/sys/fm/protocol.h \
	$(top_srcdir)/include/sys/fm/util.h

KERNEL_H = 
USER_H = 
EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)
@CONFIG_USER_TRUE@libzfsdir = $(includedir)/libzfs/sys/fm
@CONFIG_USER_TRUE@libzfs_HEADERS = $(COMMON_H) $(USER_H)
@CONFIG_KERNEL_TRUE@kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys/fm
@CONFIG_KERNEL_TRUE@kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/sys/fm/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu include/sys/fm/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
install-kernelHEADERS: $(kernel_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(kerneldir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(kerneldir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(kerneldir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(kerneldir)" || exit $$?; \
	done

uninstall-kernelHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(kerneldir)'; $(am__uninstall_files_from_dir)
install-libzfsHEADERS: $(libzfs_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libzfsdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libzfsdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libzfsdir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libzfsdir)" || exit $$?; \
	done

uninstall-libzfsHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(libzfsdir)'; $(am__uninstall_files_from_dir)

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile $(HEADERS)
installdirs: installdirs-recursive
installdirs-am:
	for dir in "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am: install-kernelHEADERS install-libzfsHEADERS

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am: uninstall-kernelHEADERS uninstall-libzfsHEADERS

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am \
	install-kernelHEADERS install-libzfsHEADERS install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am \
	uninstall-kernelHEADERS uninstall-libzfsHEADERS


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                                                                                  usr/src/zfs-0.6.5.9/include/sys/fm/fs/                                                              0040755 0000000 0000000 00000000000 13077704276 015555  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/fm/fs/Makefile.am                                                   0100644 0000000 0000000 00000000535 13045171016 017572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        COMMON_H = \
	$(top_srcdir)/include/sys/fm/fs/zfs.h

KERNEL_H =

USER_H =

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)

if CONFIG_USER
libzfsdir = $(includedir)/libzfs/sys/fm/fs
libzfs_HEADERS = $(COMMON_H) $(USER_H)
endif

if CONFIG_KERNEL
kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys/fm/fs
kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
endif
                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/fm/fs/Makefile.in                                                   0100644 0000000 0000000 00000057432 13045370526 017622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = include/sys/fm/fs
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
	$(am__kernel_HEADERS_DIST) $(am__libzfs_HEADERS_DIST)
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__kernel_HEADERS_DIST = $(top_srcdir)/include/sys/fm/fs/zfs.h
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"
am__libzfs_HEADERS_DIST = $(top_srcdir)/include/sys/fm/fs/zfs.h
HEADERS = $(kernel_HEADERS) $(libzfs_HEADERS)
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
COMMON_H = \
	$(top_srcdir)/include/sys/fm/fs/zfs.h

KERNEL_H = 
USER_H = 
EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)
@CONFIG_USER_TRUE@libzfsdir = $(includedir)/libzfs/sys/fm/fs
@CONFIG_USER_TRUE@libzfs_HEADERS = $(COMMON_H) $(USER_H)
@CONFIG_KERNEL_TRUE@kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys/fm/fs
@CONFIG_KERNEL_TRUE@kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
all: all-am

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/sys/fm/fs/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu include/sys/fm/fs/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
install-kernelHEADERS: $(kernel_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(kerneldir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(kerneldir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(kerneldir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(kerneldir)" || exit $$?; \
	done

uninstall-kernelHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(kerneldir)'; $(am__uninstall_files_from_dir)
install-libzfsHEADERS: $(libzfs_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libzfsdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libzfsdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libzfsdir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libzfsdir)" || exit $$?; \
	done

uninstall-libzfsHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(libzfsdir)'; $(am__uninstall_files_from_dir)

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(HEADERS)
installdirs:
	for dir in "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am: install-kernelHEADERS install-libzfsHEADERS

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-kernelHEADERS uninstall-libzfsHEADERS

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libtool cscopelist-am ctags ctags-am distclean \
	distclean-generic distclean-libtool distclean-tags distdir dvi \
	dvi-am html html-am info info-am install install-am \
	install-data install-data-am install-dvi install-dvi-am \
	install-exec install-exec-am install-html install-html-am \
	install-info install-info-am install-kernelHEADERS \
	install-libzfsHEADERS install-man install-pdf install-pdf-am \
	install-ps install-ps-am install-strip installcheck \
	installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-kernelHEADERS uninstall-libzfsHEADERS


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                      usr/src/zfs-0.6.5.9/include/sys/fm/fs/zfs.h                                                         0100644 0000000 0000000 00000013164 13045171016 016513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_FM_FS_ZFS_H
#define	_SYS_FM_FS_ZFS_H

#ifdef	__cplusplus
extern "C" {
#endif

#define	ZFS_ERROR_CLASS				"fs.zfs"

#define	FM_EREPORT_ZFS_CHECKSUM			"checksum"
#define	FM_EREPORT_ZFS_IO			"io"
#define	FM_EREPORT_ZFS_DATA			"data"
#define	FM_EREPORT_ZFS_DELAY			"delay"
#define	FM_EREPORT_ZFS_CONFIG_SYNC		"config.sync"
#define	FM_EREPORT_ZFS_POOL			"zpool"
#define	FM_EREPORT_ZFS_POOL_DESTROY		"zpool.destroy"
#define	FM_EREPORT_ZFS_POOL_REGUID		"zpool.reguid"
#define	FM_EREPORT_ZFS_DEVICE_UNKNOWN		"vdev.unknown"
#define	FM_EREPORT_ZFS_DEVICE_OPEN_FAILED	"vdev.open_failed"
#define	FM_EREPORT_ZFS_DEVICE_CORRUPT_DATA	"vdev.corrupt_data"
#define	FM_EREPORT_ZFS_DEVICE_NO_REPLICAS	"vdev.no_replicas"
#define	FM_EREPORT_ZFS_DEVICE_BAD_GUID_SUM	"vdev.bad_guid_sum"
#define	FM_EREPORT_ZFS_DEVICE_TOO_SMALL		"vdev.too_small"
#define	FM_EREPORT_ZFS_DEVICE_BAD_LABEL		"vdev.bad_label"
#define	FM_EREPORT_ZFS_DEVICE_BAD_ASHIFT	"vdev.bad_ashift"
#define	FM_EREPORT_ZFS_DEVICE_REMOVE		"vdev.remove"
#define	FM_EREPORT_ZFS_DEVICE_CLEAR		"vdev.clear"
#define	FM_EREPORT_ZFS_DEVICE_CHECK		"vdev.check"
#define	FM_EREPORT_ZFS_DEVICE_SPARE		"vdev.spare"
#define	FM_EREPORT_ZFS_DEVICE_AUTOEXPAND	"vdev.autoexpand"
#define	FM_EREPORT_ZFS_IO_FAILURE		"io_failure"
#define	FM_EREPORT_ZFS_PROBE_FAILURE		"probe_failure"
#define	FM_EREPORT_ZFS_LOG_REPLAY		"log_replay"
#define	FM_EREPORT_ZFS_RESILVER_START		"resilver.start"
#define	FM_EREPORT_ZFS_RESILVER_FINISH		"resilver.finish"
#define	FM_EREPORT_ZFS_SCRUB_START		"scrub.start"
#define	FM_EREPORT_ZFS_SCRUB_FINISH		"scrub.finish"
#define	FM_EREPORT_ZFS_BOOTFS_VDEV_ATTACH	"bootfs.vdev.attach"

#define	FM_EREPORT_PAYLOAD_ZFS_POOL		"pool"
#define	FM_EREPORT_PAYLOAD_ZFS_POOL_FAILMODE	"pool_failmode"
#define	FM_EREPORT_PAYLOAD_ZFS_POOL_GUID	"pool_guid"
#define	FM_EREPORT_PAYLOAD_ZFS_POOL_CONTEXT	"pool_context"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID	"vdev_guid"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE	"vdev_type"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_PATH	"vdev_path"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_DEVID	"vdev_devid"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_FRU		"vdev_fru"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_STATE	"vdev_state"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_ASHIFT	"vdev_ashift"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_COMP_TS	"vdev_complete_ts"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_DELTA_TS	"vdev_delta_ts"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_SPARE_PATHS	"vdev_spare_paths"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_SPARE_GUIDS	"vdev_spare_guids"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_READ_ERRORS	"vdev_read_errors"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_WRITE_ERRORS "vdev_write_errors"
#define	FM_EREPORT_PAYLOAD_ZFS_VDEV_CKSUM_ERRORS "vdev_cksum_errors"
#define	FM_EREPORT_PAYLOAD_ZFS_PARENT_GUID	"parent_guid"
#define	FM_EREPORT_PAYLOAD_ZFS_PARENT_TYPE	"parent_type"
#define	FM_EREPORT_PAYLOAD_ZFS_PARENT_PATH	"parent_path"
#define	FM_EREPORT_PAYLOAD_ZFS_PARENT_DEVID	"parent_devid"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_OBJSET	"zio_objset"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_OBJECT	"zio_object"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_LEVEL	"zio_level"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_BLKID	"zio_blkid"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_ERR		"zio_err"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_OFFSET	"zio_offset"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_SIZE		"zio_size"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_FLAGS	"zio_flags"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_STAGE	"zio_stage"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_PIPELINE	"zio_pipeline"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_DELAY	"zio_delay"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_TIMESTAMP	"zio_timestamp"
#define	FM_EREPORT_PAYLOAD_ZFS_ZIO_DELTA	"zio_delta"
#define	FM_EREPORT_PAYLOAD_ZFS_PREV_STATE	"prev_state"
#define	FM_EREPORT_PAYLOAD_ZFS_CKSUM_EXPECTED	"cksum_expected"
#define	FM_EREPORT_PAYLOAD_ZFS_CKSUM_ACTUAL	"cksum_actual"
#define	FM_EREPORT_PAYLOAD_ZFS_CKSUM_ALGO	"cksum_algorithm"
#define	FM_EREPORT_PAYLOAD_ZFS_CKSUM_BYTESWAP	"cksum_byteswap"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_OFFSET_RANGES "bad_ranges"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_MIN_GAP "bad_ranges_min_gap"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_SETS	"bad_range_sets"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_CLEARS	"bad_range_clears"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_SET_BITS	"bad_set_bits"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_CLEARED_BITS	"bad_cleared_bits"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_SET_HISTOGRAM "bad_set_histogram"
#define	FM_EREPORT_PAYLOAD_ZFS_BAD_CLEARED_HISTOGRAM "bad_cleared_histogram"

#define	FM_EREPORT_FAILMODE_WAIT		"wait"
#define	FM_EREPORT_FAILMODE_CONTINUE		"continue"
#define	FM_EREPORT_FAILMODE_PANIC		"panic"

#define	FM_EREPORT_RESOURCE_REMOVED		"removed"
#define	FM_EREPORT_RESOURCE_AUTOREPLACE		"autoreplace"
#define	FM_EREPORT_RESOURCE_STATECHANGE		"statechange"

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FM_FS_ZFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/fm/protocol.h                                                       0100644 0000000 0000000 00000027564 13045171016 017153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_FM_PROTOCOL_H
#define	_SYS_FM_PROTOCOL_H

#ifdef	__cplusplus
extern "C" {
#endif

#ifdef _KERNEL
#include <sys/varargs.h>
#include <sys/nvpair.h>
#else
#include <libnvpair.h>
#include <stdarg.h>
#endif
#include <sys/processor.h>

/* FM common member names */
#define	FM_CLASS			"class"
#define	FM_VERSION			"version"

/* FM protocol category 1 class names */
#define	FM_EREPORT_CLASS		"ereport"
#define	FM_FAULT_CLASS			"fault"
#define	FM_DEFECT_CLASS			"defect"
#define	FM_RSRC_CLASS			"resource"
#define	FM_LIST_EVENT			"list"
#define	FM_IREPORT_CLASS		"ireport"

/* FM list.* event class values */
#define	FM_LIST_SUSPECT_CLASS		FM_LIST_EVENT ".suspect"
#define	FM_LIST_ISOLATED_CLASS		FM_LIST_EVENT ".isolated"
#define	FM_LIST_REPAIRED_CLASS		FM_LIST_EVENT ".repaired"
#define	FM_LIST_UPDATED_CLASS		FM_LIST_EVENT ".updated"
#define	FM_LIST_RESOLVED_CLASS		FM_LIST_EVENT ".resolved"

/* ereport class subcategory values */
#define	FM_ERROR_CPU			"cpu"
#define	FM_ERROR_IO			"io"

/* ereport version and payload member names */
#define	FM_EREPORT_VERS0		0
#define	FM_EREPORT_VERSION		FM_EREPORT_VERS0

/* ereport payload member names */
#define	FM_EREPORT_DETECTOR		"detector"
#define	FM_EREPORT_ENA			"ena"
#define	FM_EREPORT_TIME			"time"
#define	FM_EREPORT_EID			"eid"

/* list.* event payload member names */
#define	FM_LIST_EVENT_SIZE		"list-sz"

/* ireport.* event payload member names */
#define	FM_IREPORT_DETECTOR		"detector"
#define	FM_IREPORT_UUID			"uuid"
#define	FM_IREPORT_PRIORITY		"pri"
#define	FM_IREPORT_ATTRIBUTES		"attr"

/*
 * list.suspect, isolated, updated, repaired and resolved
 * versions/payload member names.
 */
#define	FM_SUSPECT_UUID			"uuid"
#define	FM_SUSPECT_DIAG_CODE		"code"
#define	FM_SUSPECT_DIAG_TIME		"diag-time"
#define	FM_SUSPECT_DE			"de"
#define	FM_SUSPECT_FAULT_LIST		"fault-list"
#define	FM_SUSPECT_FAULT_SZ		"fault-list-sz"
#define	FM_SUSPECT_FAULT_STATUS		"fault-status"
#define	FM_SUSPECT_INJECTED		"__injected"
#define	FM_SUSPECT_MESSAGE		"message"
#define	FM_SUSPECT_RETIRE		"retire"
#define	FM_SUSPECT_RESPONSE		"response"
#define	FM_SUSPECT_SEVERITY		"severity"

#define	FM_SUSPECT_VERS0		0
#define	FM_SUSPECT_VERSION		FM_SUSPECT_VERS0

#define	FM_SUSPECT_FAULTY		0x1
#define	FM_SUSPECT_UNUSABLE		0x2
#define	FM_SUSPECT_NOT_PRESENT		0x4
#define	FM_SUSPECT_DEGRADED		0x8
#define	FM_SUSPECT_REPAIRED		0x10
#define	FM_SUSPECT_REPLACED		0x20
#define	FM_SUSPECT_ACQUITTED		0x40

/* fault event versions and payload member names */
#define	FM_FAULT_VERS0			0
#define	FM_FAULT_VERSION		FM_FAULT_VERS0

#define	FM_FAULT_ASRU			"asru"
#define	FM_FAULT_FRU			"fru"
#define	FM_FAULT_FRU_LABEL		"fru-label"
#define	FM_FAULT_CERTAINTY		"certainty"
#define	FM_FAULT_RESOURCE		"resource"
#define	FM_FAULT_LOCATION		"location"

/* resource event versions and payload member names */
#define	FM_RSRC_VERS0			0
#define	FM_RSRC_VERSION			FM_RSRC_VERS0
#define	FM_RSRC_RESOURCE		"resource"

/* resource.fm.asru.* payload member names */
#define	FM_RSRC_ASRU_UUID		"uuid"
#define	FM_RSRC_ASRU_CODE		"code"
#define	FM_RSRC_ASRU_FAULTY		"faulty"
#define	FM_RSRC_ASRU_REPAIRED		"repaired"
#define	FM_RSRC_ASRU_REPLACED		"replaced"
#define	FM_RSRC_ASRU_ACQUITTED		"acquitted"
#define	FM_RSRC_ASRU_RESOLVED		"resolved"
#define	FM_RSRC_ASRU_UNUSABLE		"unusable"
#define	FM_RSRC_ASRU_EVENT		"event"

/* resource.fm.xprt.* versions and payload member names */
#define	FM_RSRC_XPRT_VERS0		0
#define	FM_RSRC_XPRT_VERSION		FM_RSRC_XPRT_VERS0
#define	FM_RSRC_XPRT_UUID		"uuid"
#define	FM_RSRC_XPRT_SUBCLASS		"subclass"
#define	FM_RSRC_XPRT_FAULT_STATUS	"fault-status"
#define	FM_RSRC_XPRT_FAULT_HAS_ASRU	"fault-has-asru"

/*
 * FM ENA Format Macros
 */
#define	ENA_FORMAT_MASK			0x3
#define	ENA_FORMAT(ena)			((ena) & ENA_FORMAT_MASK)

/* ENA format types */
#define	FM_ENA_FMT0			0
#define	FM_ENA_FMT1			1
#define	FM_ENA_FMT2			2

/* Format 1 */
#define	ENA_FMT1_GEN_MASK		0x00000000000003FCull
#define	ENA_FMT1_ID_MASK		0xFFFFFFFFFFFFFC00ull
#define	ENA_FMT1_CPUID_MASK		0x00000000000FFC00ull
#define	ENA_FMT1_TIME_MASK		0xFFFFFFFFFFF00000ull
#define	ENA_FMT1_GEN_SHFT		2
#define	ENA_FMT1_ID_SHFT		10
#define	ENA_FMT1_CPUID_SHFT		ENA_FMT1_ID_SHFT
#define	ENA_FMT1_TIME_SHFT		20

/* Format 2 */
#define	ENA_FMT2_GEN_MASK		0x00000000000003FCull
#define	ENA_FMT2_ID_MASK		0xFFFFFFFFFFFFFC00ull
#define	ENA_FMT2_TIME_MASK		ENA_FMT2_ID_MASK
#define	ENA_FMT2_GEN_SHFT		2
#define	ENA_FMT2_ID_SHFT		10
#define	ENA_FMT2_TIME_SHFT		ENA_FMT2_ID_SHFT

/* Common FMRI type names */
#define	FM_FMRI_AUTHORITY		"authority"
#define	FM_FMRI_SCHEME			"scheme"
#define	FM_FMRI_SVC_AUTHORITY		"svc-authority"
#define	FM_FMRI_FACILITY		"facility"

/* FMRI authority-type member names */
#define	FM_FMRI_AUTH_CHASSIS		"chassis-id"
#define	FM_FMRI_AUTH_PRODUCT_SN		"product-sn"
#define	FM_FMRI_AUTH_PRODUCT		"product-id"
#define	FM_FMRI_AUTH_DOMAIN		"domain-id"
#define	FM_FMRI_AUTH_SERVER		"server-id"
#define	FM_FMRI_AUTH_HOST		"host-id"

#define	FM_AUTH_VERS0			0
#define	FM_FMRI_AUTH_VERSION		FM_AUTH_VERS0

/* scheme name values */
#define	FM_FMRI_SCHEME_FMD		"fmd"
#define	FM_FMRI_SCHEME_DEV		"dev"
#define	FM_FMRI_SCHEME_HC		"hc"
#define	FM_FMRI_SCHEME_SVC		"svc"
#define	FM_FMRI_SCHEME_CPU		"cpu"
#define	FM_FMRI_SCHEME_MEM		"mem"
#define	FM_FMRI_SCHEME_MOD		"mod"
#define	FM_FMRI_SCHEME_PKG		"pkg"
#define	FM_FMRI_SCHEME_LEGACY		"legacy-hc"
#define	FM_FMRI_SCHEME_ZFS		"zfs"
#define	FM_FMRI_SCHEME_SW		"sw"

/* Scheme versions */
#define	FMD_SCHEME_VERSION0		0
#define	FM_FMD_SCHEME_VERSION		FMD_SCHEME_VERSION0
#define	DEV_SCHEME_VERSION0		0
#define	FM_DEV_SCHEME_VERSION		DEV_SCHEME_VERSION0
#define	FM_HC_VERS0			0
#define	FM_HC_SCHEME_VERSION		FM_HC_VERS0
#define	CPU_SCHEME_VERSION0		0
#define	CPU_SCHEME_VERSION1		1
#define	FM_CPU_SCHEME_VERSION		CPU_SCHEME_VERSION1
#define	MEM_SCHEME_VERSION0		0
#define	FM_MEM_SCHEME_VERSION		MEM_SCHEME_VERSION0
#define	MOD_SCHEME_VERSION0		0
#define	FM_MOD_SCHEME_VERSION		MOD_SCHEME_VERSION0
#define	PKG_SCHEME_VERSION0		0
#define	FM_PKG_SCHEME_VERSION		PKG_SCHEME_VERSION0
#define	LEGACY_SCHEME_VERSION0		0
#define	FM_LEGACY_SCHEME_VERSION	LEGACY_SCHEME_VERSION0
#define	SVC_SCHEME_VERSION0		0
#define	FM_SVC_SCHEME_VERSION		SVC_SCHEME_VERSION0
#define	ZFS_SCHEME_VERSION0		0
#define	FM_ZFS_SCHEME_VERSION		ZFS_SCHEME_VERSION0
#define	SW_SCHEME_VERSION0		0
#define	FM_SW_SCHEME_VERSION		SW_SCHEME_VERSION0

/* hc scheme member names */
#define	FM_FMRI_HC_SERIAL_ID		"serial"
#define	FM_FMRI_HC_PART			"part"
#define	FM_FMRI_HC_REVISION		"revision"
#define	FM_FMRI_HC_ROOT			"hc-root"
#define	FM_FMRI_HC_LIST_SZ		"hc-list-sz"
#define	FM_FMRI_HC_LIST			"hc-list"
#define	FM_FMRI_HC_SPECIFIC		"hc-specific"

/* facility member names */
#define	FM_FMRI_FACILITY_NAME		"facility-name"
#define	FM_FMRI_FACILITY_TYPE		"facility-type"

/* hc-list version and member names */
#define	FM_FMRI_HC_NAME			"hc-name"
#define	FM_FMRI_HC_ID			"hc-id"

#define	HC_LIST_VERSION0		0
#define	FM_HC_LIST_VERSION		HC_LIST_VERSION0

/* hc-specific member names */
#define	FM_FMRI_HC_SPECIFIC_OFFSET	"offset"
#define	FM_FMRI_HC_SPECIFIC_PHYSADDR	"physaddr"

/* fmd module scheme member names */
#define	FM_FMRI_FMD_NAME		"mod-name"
#define	FM_FMRI_FMD_VERSION		"mod-version"

/* dev scheme member names */
#define	FM_FMRI_DEV_ID			"devid"
#define	FM_FMRI_DEV_TGTPTLUN0		"target-port-l0id"
#define	FM_FMRI_DEV_PATH		"device-path"

/* pkg scheme member names */
#define	FM_FMRI_PKG_BASEDIR		"pkg-basedir"
#define	FM_FMRI_PKG_INST		"pkg-inst"
#define	FM_FMRI_PKG_VERSION		"pkg-version"

/* svc scheme member names */
#define	FM_FMRI_SVC_NAME		"svc-name"
#define	FM_FMRI_SVC_INSTANCE		"svc-instance"
#define	FM_FMRI_SVC_CONTRACT_ID		"svc-contract-id"

/* svc-authority member names */
#define	FM_FMRI_SVC_AUTH_SCOPE		"scope"
#define	FM_FMRI_SVC_AUTH_SYSTEM_FQN	"system-fqn"

/* cpu scheme member names */
#define	FM_FMRI_CPU_ID			"cpuid"
#define	FM_FMRI_CPU_SERIAL_ID		"serial"
#define	FM_FMRI_CPU_MASK		"cpumask"
#define	FM_FMRI_CPU_VID			"cpuvid"
#define	FM_FMRI_CPU_CPUFRU		"cpufru"
#define	FM_FMRI_CPU_CACHE_INDEX		"cacheindex"
#define	FM_FMRI_CPU_CACHE_WAY		"cacheway"
#define	FM_FMRI_CPU_CACHE_BIT		"cachebit"
#define	FM_FMRI_CPU_CACHE_TYPE		"cachetype"

#define	FM_FMRI_CPU_CACHE_TYPE_L2	0
#define	FM_FMRI_CPU_CACHE_TYPE_L3	1

/* legacy-hc scheme member names */
#define	FM_FMRI_LEGACY_HC		"component"
#define	FM_FMRI_LEGACY_HC_PREFIX	FM_FMRI_SCHEME_HC":///" \
    FM_FMRI_LEGACY_HC"="

/* mem scheme member names */
#define	FM_FMRI_MEM_UNUM		"unum"
#define	FM_FMRI_MEM_SERIAL_ID		"serial"
#define	FM_FMRI_MEM_PHYSADDR		"physaddr"
#define	FM_FMRI_MEM_MEMCONFIG		"memconfig"
#define	FM_FMRI_MEM_OFFSET		"offset"

/* mod scheme member names */
#define	FM_FMRI_MOD_PKG			"mod-pkg"
#define	FM_FMRI_MOD_NAME		"mod-name"
#define	FM_FMRI_MOD_ID			"mod-id"
#define	FM_FMRI_MOD_DESC		"mod-desc"

/* zfs scheme member names */
#define	FM_FMRI_ZFS_POOL		"pool"
#define	FM_FMRI_ZFS_VDEV		"vdev"

/* sw scheme member names - extra indentation for members of an nvlist */
#define	FM_FMRI_SW_OBJ			"object"
#define	FM_FMRI_SW_OBJ_PATH			"path"
#define	FM_FMRI_SW_OBJ_ROOT			"root"
#define	FM_FMRI_SW_OBJ_PKG			"pkg"
#define	FM_FMRI_SW_SITE			"site"
#define	FM_FMRI_SW_SITE_TOKEN			"token"
#define	FM_FMRI_SW_SITE_MODULE			"module"
#define	FM_FMRI_SW_SITE_FILE			"file"
#define	FM_FMRI_SW_SITE_LINE			"line"
#define	FM_FMRI_SW_SITE_FUNC			"func"
#define	FM_FMRI_SW_CTXT			"context"
#define	FM_FMRI_SW_CTXT_ORIGIN			"origin"
#define	FM_FMRI_SW_CTXT_EXECNAME		"execname"
#define	FM_FMRI_SW_CTXT_PID			"pid"
#define	FM_FMRI_SW_CTXT_ZONE			"zone"
#define	FM_FMRI_SW_CTXT_CTID			"ctid"
#define	FM_FMRI_SW_CTXT_STACK			"stack"
#define	FM_NVA_FREE		0	/* free allocator on nvlist_destroy */
#define	FM_NVA_RETAIN		1	/* keep allocator on nvlist_destroy */

extern nv_alloc_t *fm_nva_xcreate(char *, size_t);
extern void fm_nva_xdestroy(nv_alloc_t *);
extern nvlist_t *fm_nvlist_create(nv_alloc_t *);
extern void fm_nvlist_destroy(nvlist_t *, int);
extern void fm_ereport_set(nvlist_t *, int, const char *, uint64_t,
    const nvlist_t *, ...);
extern void fm_payload_set(nvlist_t *, ...);
extern int i_fm_payload_set(nvlist_t *, const char *, va_list);
extern void fm_fmri_hc_set(nvlist_t *, int, const nvlist_t *, nvlist_t *,
    int, ...);
extern void fm_fmri_dev_set(nvlist_t *, int, const nvlist_t *, const char *,
    const char *, const char *);
extern void fm_fmri_de_set(nvlist_t *, int, const nvlist_t *, const char *);
extern void fm_fmri_cpu_set(nvlist_t *, int, const nvlist_t *, uint32_t,
    uint8_t *, const char *);
extern void fm_fmri_mem_set(nvlist_t *, int, const nvlist_t *, const char *,
    const char *, uint64_t);
extern void fm_fmri_zfs_set(nvlist_t *, int, uint64_t, uint64_t);
extern void fm_fmri_hc_create(nvlist_t *, int, const nvlist_t *, nvlist_t *,
    nvlist_t *, int, ...);

extern uint64_t fm_ena_increment(uint64_t);
extern uint64_t fm_ena_generate(uint64_t, uchar_t);
extern uint64_t fm_ena_generate_cpu(uint64_t, processorid_t, uchar_t);
extern uint64_t fm_ena_generation_get(uint64_t);
extern uchar_t fm_ena_format_get(uint64_t);
extern uint64_t fm_ena_id_get(uint64_t);
extern uint64_t fm_ena_time_get(uint64_t);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_FM_PROTOCOL_H */
                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/fm/util.h                                                           0100644 0000000 0000000 00000006757 13045171016 016270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_FM_UTIL_H
#define	_SYS_FM_UTIL_H

#ifdef	__cplusplus
extern "C" {
#endif

#include <sys/nvpair.h>

/*
 * Shared user/kernel definitions for class length, error channel name,
 * and kernel event publisher string.
 */
#define	FM_MAX_CLASS 100
#define	FM_ERROR_CHAN	"com.sun:fm:error"
#define	FM_PUB		"fm"

/*
 * ereport dump device transport support
 *
 * Ereports are written out to the dump device at a proscribed offset from the
 * end, similar to in-transit log messages.  The ereports are represented as a
 * erpt_dump_t header followed by ed_size bytes of packed native nvlist data.
 *
 * NOTE: All of these constants and the header must be defined so they have the
 * same representation for *both* 32-bit and 64-bit producers and consumers.
 */
#define	ERPT_MAGIC	0xf00d4eddU
#define	ERPT_MAX_ERRS	16
#define	ERPT_DATA_SZ	(6 * 1024)
#define	ERPT_EVCH_MAX	256
#define	ERPT_HIWAT	64

typedef struct erpt_dump {
	uint32_t ed_magic;	/* ERPT_MAGIC or zero to indicate end */
	uint32_t ed_chksum;	/* checksum32() of packed nvlist data */
	uint32_t ed_size;	/* ereport (nvl) fixed buf size */
	uint32_t ed_pad;	/* reserved for future use */
	hrtime_t ed_hrt_nsec;	/* hrtime of this ereport */
	hrtime_t ed_hrt_base;	/* hrtime sample corresponding to ed_tod_base */
	struct {
		uint64_t sec;	/* seconds since gettimeofday() Epoch */
		uint64_t nsec;	/* nanoseconds past ed_tod_base.sec */
	} ed_tod_base;
} erpt_dump_t;

#ifdef _KERNEL

#define	ZEVENT_SHUTDOWN		0x1

typedef void zevent_cb_t(nvlist_t *, nvlist_t *);

typedef struct zevent_s {
	nvlist_t	*ev_nvl;	/* protected by the zevent_lock */
	nvlist_t	*ev_detector;	/* " */
	list_t		ev_ze_list;	/* " */
	list_node_t	ev_node;	/* " */
	zevent_cb_t	*ev_cb;		/* " */
	uint64_t	ev_eid;
} zevent_t;

typedef struct zfs_zevent {
	zevent_t	*ze_zevent;	/* protected by the zevent_lock */
	list_node_t	ze_node;	/* " */
	uint64_t	ze_dropped;	/* " */
} zfs_zevent_t;

extern void fm_init(void);
extern void fm_fini(void);
extern void fm_nvprint(nvlist_t *);
extern int zfs_zevent_post(nvlist_t *, nvlist_t *, zevent_cb_t *);
extern void zfs_zevent_drain_all(int *);
extern int zfs_zevent_fd_hold(int, minor_t *, zfs_zevent_t **);
extern void zfs_zevent_fd_rele(int);
extern int zfs_zevent_next(zfs_zevent_t *, nvlist_t **, uint64_t *, uint64_t *);
extern int zfs_zevent_wait(zfs_zevent_t *);
extern int zfs_zevent_seek(zfs_zevent_t *, uint64_t);
extern void zfs_zevent_init(zfs_zevent_t **);
extern void zfs_zevent_destroy(zfs_zevent_t *);

#else

static inline void fm_init(void) { }
static inline void fm_fini(void) { }

#endif  /* _KERNEL */

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_FM_UTIL_H */
                 usr/src/zfs-0.6.5.9/include/sys/fs/                                                                 0040755 0000000 0000000 00000000000 13077704276 015153  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/fs/Makefile.am                                                      0100644 0000000 0000000 00000000524 13045171016 017166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        COMMON_H = \
	$(top_srcdir)/include/sys/fs/zfs.h

KERNEL_H =

USER_H =

EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)

if CONFIG_USER
libzfsdir = $(includedir)/libzfs/sys/fs
libzfs_HEADERS = $(COMMON_H) $(USER_H)
endif

if CONFIG_KERNEL
kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys/fs
kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
endif
                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/fs/Makefile.in                                                      0100644 0000000 0000000 00000057402 13045370526 017215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.14.1 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = include/sys/fs
DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
	$(am__kernel_HEADERS_DIST) $(am__libzfs_HEADERS_DIST)
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/config/always-no-bool-compare.m4 \
	$(top_srcdir)/config/always-no-unused-but-set-variable.m4 \
	$(top_srcdir)/config/dkms.m4 \
	$(top_srcdir)/config/kernel-acl.m4 \
	$(top_srcdir)/config/kernel-aio-fsync.m4 \
	$(top_srcdir)/config/kernel-automount.m4 \
	$(top_srcdir)/config/kernel-bdev-block-device-operations.m4 \
	$(top_srcdir)/config/kernel-bdev-logical-size.m4 \
	$(top_srcdir)/config/kernel-bdev-physical-size.m4 \
	$(top_srcdir)/config/kernel-bdi-setup-and-register.m4 \
	$(top_srcdir)/config/kernel-bio-bvec-iter.m4 \
	$(top_srcdir)/config/kernel-bio-end-io-t-args.m4 \
	$(top_srcdir)/config/kernel-bio-failfast.m4 \
	$(top_srcdir)/config/kernel-bio-op.m4 \
	$(top_srcdir)/config/kernel-bio-rw-barrier.m4 \
	$(top_srcdir)/config/kernel-bio-rw-discard.m4 \
	$(top_srcdir)/config/kernel-blk-queue-flush.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-hw-sectors.m4 \
	$(top_srcdir)/config/kernel-blk-queue-max-segments.m4 \
	$(top_srcdir)/config/kernel-blk-queue-unplug.m4 \
	$(top_srcdir)/config/kernel-blkdev-get-by-path.m4 \
	$(top_srcdir)/config/kernel-blkdev-get.m4 \
	$(top_srcdir)/config/kernel-block-device-operations-release-void.m4 \
	$(top_srcdir)/config/kernel-check-disk-size-change.m4 \
	$(top_srcdir)/config/kernel-clear-inode.m4 \
	$(top_srcdir)/config/kernel-commit-metadata.m4 \
	$(top_srcdir)/config/kernel-create-nameidata.m4 \
	$(top_srcdir)/config/kernel-current_bio_tail.m4 \
	$(top_srcdir)/config/kernel-d-make-root.m4 \
	$(top_srcdir)/config/kernel-d-obtain-alias.m4 \
	$(top_srcdir)/config/kernel-d-prune-aliases.m4 \
	$(top_srcdir)/config/kernel-declare-event-class.m4 \
	$(top_srcdir)/config/kernel-dentry-operations.m4 \
	$(top_srcdir)/config/kernel-dirty-inode.m4 \
	$(top_srcdir)/config/kernel-discard-granularity.m4 \
	$(top_srcdir)/config/kernel-elevator-change.m4 \
	$(top_srcdir)/config/kernel-encode-fh-inode.m4 \
	$(top_srcdir)/config/kernel-evict-inode.m4 \
	$(top_srcdir)/config/kernel-fallocate.m4 \
	$(top_srcdir)/config/kernel-file-inode.m4 \
	$(top_srcdir)/config/kernel-fmode-t.m4 \
	$(top_srcdir)/config/kernel-follow-down-one.m4 \
	$(top_srcdir)/config/kernel-fsync.m4 \
	$(top_srcdir)/config/kernel-generic_io_acct.m4 \
	$(top_srcdir)/config/kernel-generic_readlink.m4 \
	$(top_srcdir)/config/kernel-get-disk-ro.m4 \
	$(top_srcdir)/config/kernel-get-gendisk.m4 \
	$(top_srcdir)/config/kernel-get-link.m4 \
	$(top_srcdir)/config/kernel-insert-inode-locked.m4 \
	$(top_srcdir)/config/kernel-invalidate-bdev-args.m4 \
	$(top_srcdir)/config/kernel-is_owner_or_cap.m4 \
	$(top_srcdir)/config/kernel-kmap-atomic-args.m4 \
	$(top_srcdir)/config/kernel-kobj-name-len.m4 \
	$(top_srcdir)/config/kernel-lookup-bdev.m4 \
	$(top_srcdir)/config/kernel-lookup-nameidata.m4 \
	$(top_srcdir)/config/kernel-lseek-execute.m4 \
	$(top_srcdir)/config/kernel-mk-request-fn.m4 \
	$(top_srcdir)/config/kernel-mkdir-umode-t.m4 \
	$(top_srcdir)/config/kernel-mount-nodev.m4 \
	$(top_srcdir)/config/kernel-open-bdev-exclusive.m4 \
	$(top_srcdir)/config/kernel-put-link.m4 \
	$(top_srcdir)/config/kernel-rename.m4 \
	$(top_srcdir)/config/kernel-security-inode-init.m4 \
	$(top_srcdir)/config/kernel-set-nlink.m4 \
	$(top_srcdir)/config/kernel-setattr-prepare.m4 \
	$(top_srcdir)/config/kernel-sget-args.m4 \
	$(top_srcdir)/config/kernel-show-options.m4 \
	$(top_srcdir)/config/kernel-shrink.m4 \
	$(top_srcdir)/config/kernel-submit_bio.m4 \
	$(top_srcdir)/config/kernel-truncate-range.m4 \
	$(top_srcdir)/config/kernel-truncate-setsize.m4 \
	$(top_srcdir)/config/kernel-vfs-iterate.m4 \
	$(top_srcdir)/config/kernel-vfs-rw-iterate.m4 \
	$(top_srcdir)/config/kernel-xattr-handler.m4 \
	$(top_srcdir)/config/kernel.m4 $(top_srcdir)/config/libtool.m4 \
	$(top_srcdir)/config/ltoptions.m4 \
	$(top_srcdir)/config/ltsugar.m4 \
	$(top_srcdir)/config/ltversion.m4 \
	$(top_srcdir)/config/lt~obsolete.m4 \
	$(top_srcdir)/config/mount-helper.m4 \
	$(top_srcdir)/config/user-arch.m4 \
	$(top_srcdir)/config/user-dracut.m4 \
	$(top_srcdir)/config/user-frame-larger-than.m4 \
	$(top_srcdir)/config/user-libblkid.m4 \
	$(top_srcdir)/config/user-libuuid.m4 \
	$(top_srcdir)/config/user-runstatedir.m4 \
	$(top_srcdir)/config/user-systemd.m4 \
	$(top_srcdir)/config/user-sysvinit.m4 \
	$(top_srcdir)/config/user-udev.m4 \
	$(top_srcdir)/config/user-zlib.m4 $(top_srcdir)/config/user.m4 \
	$(top_srcdir)/config/zfs-build.m4 \
	$(top_srcdir)/config/zfs-meta.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
mkinstalldirs = $(install_sh) -d
CONFIG_HEADER = $(top_builddir)/zfs_config.h
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__kernel_HEADERS_DIST = $(top_srcdir)/include/sys/fs/zfs.h
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"
am__libzfs_HEADERS_DIST = $(top_srcdir)/include/sys/fs/zfs.h
HEADERS = $(kernel_HEADERS) $(libzfs_HEADERS)
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
ALIEN = @ALIEN@
ALIEN_VERSION = @ALIEN_VERSION@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASDEPMODE = @CCASDEPMODE@
CCASFLAGS = @CCASFLAGS@
CCDEPMODE = @CCDEPMODE@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CYGPATH_W = @CYGPATH_W@
DEBUG_CFLAGS = @DEBUG_CFLAGS@
DEBUG_DMU_TX = @DEBUG_DMU_TX@
DEBUG_STACKFLAGS = @DEBUG_STACKFLAGS@
DEBUG_ZFS = @DEBUG_ZFS@
DEFAULT_INITCONF_DIR = @DEFAULT_INITCONF_DIR@
DEFAULT_INIT_DIR = @DEFAULT_INIT_DIR@
DEFAULT_INIT_SCRIPT = @DEFAULT_INIT_SCRIPT@
DEFAULT_PACKAGE = @DEFAULT_PACKAGE@
DEFINE_INITRAMFS = @DEFINE_INITRAMFS@
DEFS = @DEFS@
DEPDIR = @DEPDIR@
DLLTOOL = @DLLTOOL@
DPKG = @DPKG@
DPKGBUILD = @DPKGBUILD@
DPKGBUILD_VERSION = @DPKGBUILD_VERSION@
DPKG_VERSION = @DPKG_VERSION@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
FRAME_LARGER_THAN = @FRAME_LARGER_THAN@
GREP = @GREP@
HAVE_ALIEN = @HAVE_ALIEN@
HAVE_DPKG = @HAVE_DPKG@
HAVE_DPKGBUILD = @HAVE_DPKGBUILD@
HAVE_RPM = @HAVE_RPM@
HAVE_RPMBUILD = @HAVE_RPMBUILD@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
KERNELCPPFLAGS = @KERNELCPPFLAGS@
KERNELMAKE_PARAMS = @KERNELMAKE_PARAMS@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBBLKID = @LIBBLKID@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIBUUID = @LIBUUID@
LINUX = @LINUX@
LINUX_OBJ = @LINUX_OBJ@
LINUX_SYMBOLS = @LINUX_SYMBOLS@
LINUX_VERSION = @LINUX_VERSION@
LIPO = @LIPO@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
NO_BOOL_COMPARE = @NO_BOOL_COMPARE@
NO_UNUSED_BUT_SET_VARIABLE = @NO_UNUSED_BUT_SET_VARIABLE@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
RANLIB = @RANLIB@
RELEASE = @RELEASE@
RPM = @RPM@
RPMBUILD = @RPMBUILD@
RPMBUILD_VERSION = @RPMBUILD_VERSION@
RPM_DEFINE_COMMON = @RPM_DEFINE_COMMON@
RPM_DEFINE_DKMS = @RPM_DEFINE_DKMS@
RPM_DEFINE_KMOD = @RPM_DEFINE_KMOD@
RPM_DEFINE_UTIL = @RPM_DEFINE_UTIL@
RPM_SPEC_DIR = @RPM_SPEC_DIR@
RPM_VERSION = @RPM_VERSION@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
SPL = @SPL@
SPL_OBJ = @SPL_OBJ@
SPL_SYMBOLS = @SPL_SYMBOLS@
SPL_VERSION = @SPL_VERSION@
SRPM_DEFINE_COMMON = @SRPM_DEFINE_COMMON@
SRPM_DEFINE_DKMS = @SRPM_DEFINE_DKMS@
SRPM_DEFINE_KMOD = @SRPM_DEFINE_KMOD@
SRPM_DEFINE_UTIL = @SRPM_DEFINE_UTIL@
STRIP = @STRIP@
TARGET_ASM_DIR = @TARGET_ASM_DIR@
VENDOR = @VENDOR@
VERSION = @VERSION@
ZFS_CONFIG = @ZFS_CONFIG@
ZFS_INIT_SYSTEMD = @ZFS_INIT_SYSTEMD@
ZFS_INIT_SYSV = @ZFS_INIT_SYSV@
ZFS_META_ALIAS = @ZFS_META_ALIAS@
ZFS_META_AUTHOR = @ZFS_META_AUTHOR@
ZFS_META_DATA = @ZFS_META_DATA@
ZFS_META_LICENSE = @ZFS_META_LICENSE@
ZFS_META_LT_AGE = @ZFS_META_LT_AGE@
ZFS_META_LT_CURRENT = @ZFS_META_LT_CURRENT@
ZFS_META_LT_REVISION = @ZFS_META_LT_REVISION@
ZFS_META_NAME = @ZFS_META_NAME@
ZFS_META_RELEASE = @ZFS_META_RELEASE@
ZFS_META_VERSION = @ZFS_META_VERSION@
ZFS_MODULE_LOAD = @ZFS_MODULE_LOAD@
ZLIB = @ZLIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
am__include = @am__include@
am__leading_dot = @am__leading_dot@
am__quote = @am__quote@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dracutdir = @dracutdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
modulesloaddir = @modulesloaddir@
mounthelperdir = @mounthelperdir@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
runstatedir = @runstatedir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
systemdpresetdir = @systemdpresetdir@
systemdunitdir = @systemdunitdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
udevdir = @udevdir@
udevruledir = @udevruledir@
COMMON_H = \
	$(top_srcdir)/include/sys/fs/zfs.h

KERNEL_H = 
USER_H = 
EXTRA_DIST = $(COMMON_H) $(KERNEL_H) $(USER_H)
@CONFIG_USER_TRUE@libzfsdir = $(includedir)/libzfs/sys/fs
@CONFIG_USER_TRUE@libzfs_HEADERS = $(COMMON_H) $(USER_H)
@CONFIG_KERNEL_TRUE@kerneldir = @prefix@/src/zfs-$(VERSION)/include/sys/fs
@CONFIG_KERNEL_TRUE@kernel_HEADERS = $(COMMON_H) $(KERNEL_H)
all: all-am

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/sys/fs/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu include/sys/fs/Makefile
.PRECIOUS: Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs
install-kernelHEADERS: $(kernel_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(kerneldir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(kerneldir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(kerneldir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(kerneldir)" || exit $$?; \
	done

uninstall-kernelHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(kernel_HEADERS)'; test -n "$(kerneldir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(kerneldir)'; $(am__uninstall_files_from_dir)
install-libzfsHEADERS: $(libzfs_HEADERS)
	@$(NORMAL_INSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libzfsdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libzfsdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libzfsdir)'"; \
	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libzfsdir)" || exit $$?; \
	done

uninstall-libzfsHEADERS:
	@$(NORMAL_UNINSTALL)
	@list='$(libzfs_HEADERS)'; test -n "$(libzfsdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(libzfsdir)'; $(am__uninstall_files_from_dir)

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(HEADERS)
installdirs:
	for dir in "$(DESTDIR)$(kerneldir)" "$(DESTDIR)$(libzfsdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am: install-kernelHEADERS install-libzfsHEADERS

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-kernelHEADERS uninstall-libzfsHEADERS

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libtool cscopelist-am ctags ctags-am distclean \
	distclean-generic distclean-libtool distclean-tags distdir dvi \
	dvi-am html html-am info info-am install install-am \
	install-data install-data-am install-dvi install-dvi-am \
	install-exec install-exec-am install-html install-html-am \
	install-info install-info-am install-kernelHEADERS \
	install-libzfsHEADERS install-man install-pdf install-pdf-am \
	install-ps install-ps-am install-strip installcheck \
	installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-kernelHEADERS uninstall-libzfsHEADERS


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/fs/zfs.h                                                            0100644 0000000 0000000 00000074304 13045171016 016114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 */

/* Portions Copyright 2010 Robert Milkowski */

#ifndef	_SYS_FS_ZFS_H
#define	_SYS_FS_ZFS_H

#include <sys/time.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Types and constants shared between userland and the kernel.
 */

/*
 * Each dataset can be one of the following types.  These constants can be
 * combined into masks that can be passed to various functions.
 */
typedef enum {
	ZFS_TYPE_FILESYSTEM	= (1 << 0),
	ZFS_TYPE_SNAPSHOT	= (1 << 1),
	ZFS_TYPE_VOLUME		= (1 << 2),
	ZFS_TYPE_POOL		= (1 << 3),
	ZFS_TYPE_BOOKMARK	= (1 << 4)
} zfs_type_t;

typedef enum dmu_objset_type {
	DMU_OST_NONE,
	DMU_OST_META,
	DMU_OST_ZFS,
	DMU_OST_ZVOL,
	DMU_OST_OTHER,			/* For testing only! */
	DMU_OST_ANY,			/* Be careful! */
	DMU_OST_NUMTYPES
} dmu_objset_type_t;

#define	ZFS_TYPE_DATASET	\
	(ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME | ZFS_TYPE_SNAPSHOT)

#define	ZAP_MAXNAMELEN 256
#define	ZAP_MAXVALUELEN (1024 * 8)
#define	ZAP_OLDMAXVALUELEN 1024
#define	ZFS_MAX_DATASET_NAME_LEN 256

/*
 * Dataset properties are identified by these constants and must be added to
 * the end of this list to ensure that external consumers are not affected
 * by the change. If you make any changes to this list, be sure to update
 * the property table in module/zcommon/zfs_prop.c.
 */
typedef enum {
	ZFS_PROP_TYPE,
	ZFS_PROP_CREATION,
	ZFS_PROP_USED,
	ZFS_PROP_AVAILABLE,
	ZFS_PROP_REFERENCED,
	ZFS_PROP_COMPRESSRATIO,
	ZFS_PROP_MOUNTED,
	ZFS_PROP_ORIGIN,
	ZFS_PROP_QUOTA,
	ZFS_PROP_RESERVATION,
	ZFS_PROP_VOLSIZE,
	ZFS_PROP_VOLBLOCKSIZE,
	ZFS_PROP_RECORDSIZE,
	ZFS_PROP_MOUNTPOINT,
	ZFS_PROP_SHARENFS,
	ZFS_PROP_CHECKSUM,
	ZFS_PROP_COMPRESSION,
	ZFS_PROP_ATIME,
	ZFS_PROP_DEVICES,
	ZFS_PROP_EXEC,
	ZFS_PROP_SETUID,
	ZFS_PROP_READONLY,
	ZFS_PROP_ZONED,
	ZFS_PROP_SNAPDIR,
	ZFS_PROP_PRIVATE,		/* not exposed to user, temporary */
	ZFS_PROP_ACLINHERIT,
	ZFS_PROP_CREATETXG,		/* not exposed to the user */
	ZFS_PROP_NAME,			/* not exposed to the user */
	ZFS_PROP_CANMOUNT,
	ZFS_PROP_ISCSIOPTIONS,		/* not exposed to the user */
	ZFS_PROP_XATTR,
	ZFS_PROP_NUMCLONES,		/* not exposed to the user */
	ZFS_PROP_COPIES,
	ZFS_PROP_VERSION,
	ZFS_PROP_UTF8ONLY,
	ZFS_PROP_NORMALIZE,
	ZFS_PROP_CASE,
	ZFS_PROP_VSCAN,
	ZFS_PROP_NBMAND,
	ZFS_PROP_SHARESMB,
	ZFS_PROP_REFQUOTA,
	ZFS_PROP_REFRESERVATION,
	ZFS_PROP_GUID,
	ZFS_PROP_PRIMARYCACHE,
	ZFS_PROP_SECONDARYCACHE,
	ZFS_PROP_USEDSNAP,
	ZFS_PROP_USEDDS,
	ZFS_PROP_USEDCHILD,
	ZFS_PROP_USEDREFRESERV,
	ZFS_PROP_USERACCOUNTING,	/* not exposed to the user */
	ZFS_PROP_STMF_SHAREINFO,	/* not exposed to the user */
	ZFS_PROP_DEFER_DESTROY,
	ZFS_PROP_USERREFS,
	ZFS_PROP_LOGBIAS,
	ZFS_PROP_UNIQUE,		/* not exposed to the user */
	ZFS_PROP_OBJSETID,		/* not exposed to the user */
	ZFS_PROP_DEDUP,
	ZFS_PROP_MLSLABEL,
	ZFS_PROP_SYNC,
	ZFS_PROP_REFRATIO,
	ZFS_PROP_WRITTEN,
	ZFS_PROP_CLONES,
	ZFS_PROP_LOGICALUSED,
	ZFS_PROP_LOGICALREFERENCED,
	ZFS_PROP_INCONSISTENT,		/* not exposed to the user */
	ZFS_PROP_FILESYSTEM_LIMIT,
	ZFS_PROP_SNAPSHOT_LIMIT,
	ZFS_PROP_FILESYSTEM_COUNT,
	ZFS_PROP_SNAPSHOT_COUNT,
	ZFS_PROP_SNAPDEV,
	ZFS_PROP_ACLTYPE,
	ZFS_PROP_SELINUX_CONTEXT,
	ZFS_PROP_SELINUX_FSCONTEXT,
	ZFS_PROP_SELINUX_DEFCONTEXT,
	ZFS_PROP_SELINUX_ROOTCONTEXT,
	ZFS_PROP_RELATIME,
	ZFS_PROP_REDUNDANT_METADATA,
	ZFS_PROP_OVERLAY,
	ZFS_NUM_PROPS
} zfs_prop_t;

typedef enum {
	ZFS_PROP_USERUSED,
	ZFS_PROP_USERQUOTA,
	ZFS_PROP_GROUPUSED,
	ZFS_PROP_GROUPQUOTA,
	ZFS_NUM_USERQUOTA_PROPS
} zfs_userquota_prop_t;

extern const char *zfs_userquota_prop_prefixes[ZFS_NUM_USERQUOTA_PROPS];

/*
 * Pool properties are identified by these constants and must be added to the
 * end of this list to ensure that external consumers are not affected
 * by the change. If you make any changes to this list, be sure to update
 * the property table in module/zcommon/zpool_prop.c.
 */
typedef enum {
	ZPOOL_PROP_NAME,
	ZPOOL_PROP_SIZE,
	ZPOOL_PROP_CAPACITY,
	ZPOOL_PROP_ALTROOT,
	ZPOOL_PROP_HEALTH,
	ZPOOL_PROP_GUID,
	ZPOOL_PROP_VERSION,
	ZPOOL_PROP_BOOTFS,
	ZPOOL_PROP_DELEGATION,
	ZPOOL_PROP_AUTOREPLACE,
	ZPOOL_PROP_CACHEFILE,
	ZPOOL_PROP_FAILUREMODE,
	ZPOOL_PROP_LISTSNAPS,
	ZPOOL_PROP_AUTOEXPAND,
	ZPOOL_PROP_DEDUPDITTO,
	ZPOOL_PROP_DEDUPRATIO,
	ZPOOL_PROP_FREE,
	ZPOOL_PROP_ALLOCATED,
	ZPOOL_PROP_READONLY,
	ZPOOL_PROP_ASHIFT,
	ZPOOL_PROP_COMMENT,
	ZPOOL_PROP_EXPANDSZ,
	ZPOOL_PROP_FREEING,
	ZPOOL_PROP_FRAGMENTATION,
	ZPOOL_PROP_LEAKED,
	ZPOOL_PROP_MAXBLOCKSIZE,
	ZPOOL_PROP_TNAME,
	ZPOOL_NUM_PROPS
} zpool_prop_t;

/* Small enough to not hog a whole line of printout in zpool(1M). */
#define	ZPROP_MAX_COMMENT	32

#define	ZPROP_CONT		-2
#define	ZPROP_INVAL		-1

#define	ZPROP_VALUE		"value"
#define	ZPROP_SOURCE		"source"

typedef enum {
	ZPROP_SRC_NONE = 0x1,
	ZPROP_SRC_DEFAULT = 0x2,
	ZPROP_SRC_TEMPORARY = 0x4,
	ZPROP_SRC_LOCAL = 0x8,
	ZPROP_SRC_INHERITED = 0x10,
	ZPROP_SRC_RECEIVED = 0x20
} zprop_source_t;

#define	ZPROP_SRC_ALL	0x3f

#define	ZPROP_SOURCE_VAL_RECVD	"$recvd"
#define	ZPROP_N_MORE_ERRORS	"N_MORE_ERRORS"
/*
 * Dataset flag implemented as a special entry in the props zap object
 * indicating that the dataset has received properties on or after
 * SPA_VERSION_RECVD_PROPS. The first such receive blows away local properties
 * just as it did in earlier versions, and thereafter, local properties are
 * preserved.
 */
#define	ZPROP_HAS_RECVD		"$hasrecvd"

typedef enum {
	ZPROP_ERR_NOCLEAR = 0x1, /* failure to clear existing props */
	ZPROP_ERR_NORESTORE = 0x2 /* failure to restore props on error */
} zprop_errflags_t;

typedef int (*zprop_func)(int, void *);

/*
 * Properties to be set on the root file system of a new pool
 * are stuffed into their own nvlist, which is then included in
 * the properties nvlist with the pool properties.
 */
#define	ZPOOL_ROOTFS_PROPS	"root-props-nvl"

/*
 * Dataset property functions shared between libzfs and kernel.
 */
const char *zfs_prop_default_string(zfs_prop_t);
uint64_t zfs_prop_default_numeric(zfs_prop_t);
boolean_t zfs_prop_readonly(zfs_prop_t);
boolean_t zfs_prop_inheritable(zfs_prop_t);
boolean_t zfs_prop_setonce(zfs_prop_t);
const char *zfs_prop_to_name(zfs_prop_t);
zfs_prop_t zfs_name_to_prop(const char *);
boolean_t zfs_prop_user(const char *);
boolean_t zfs_prop_userquota(const char *);
boolean_t zfs_prop_written(const char *);
int zfs_prop_index_to_string(zfs_prop_t, uint64_t, const char **);
int zfs_prop_string_to_index(zfs_prop_t, const char *, uint64_t *);
uint64_t zfs_prop_random_value(zfs_prop_t, uint64_t seed);
boolean_t zfs_prop_valid_for_type(int, zfs_type_t, boolean_t);

/*
 * Pool property functions shared between libzfs and kernel.
 */
zpool_prop_t zpool_name_to_prop(const char *);
const char *zpool_prop_to_name(zpool_prop_t);
const char *zpool_prop_default_string(zpool_prop_t);
uint64_t zpool_prop_default_numeric(zpool_prop_t);
boolean_t zpool_prop_readonly(zpool_prop_t);
boolean_t zpool_prop_feature(const char *);
boolean_t zpool_prop_unsupported(const char *);
int zpool_prop_index_to_string(zpool_prop_t, uint64_t, const char **);
int zpool_prop_string_to_index(zpool_prop_t, const char *, uint64_t *);
uint64_t zpool_prop_random_value(zpool_prop_t, uint64_t seed);

/*
 * Definitions for the Delegation.
 */
typedef enum {
	ZFS_DELEG_WHO_UNKNOWN = 0,
	ZFS_DELEG_USER = 'u',
	ZFS_DELEG_USER_SETS = 'U',
	ZFS_DELEG_GROUP = 'g',
	ZFS_DELEG_GROUP_SETS = 'G',
	ZFS_DELEG_EVERYONE = 'e',
	ZFS_DELEG_EVERYONE_SETS = 'E',
	ZFS_DELEG_CREATE = 'c',
	ZFS_DELEG_CREATE_SETS = 'C',
	ZFS_DELEG_NAMED_SET = 's',
	ZFS_DELEG_NAMED_SET_SETS = 'S'
} zfs_deleg_who_type_t;

typedef enum {
	ZFS_DELEG_NONE = 0,
	ZFS_DELEG_PERM_LOCAL = 1,
	ZFS_DELEG_PERM_DESCENDENT = 2,
	ZFS_DELEG_PERM_LOCALDESCENDENT = 3,
	ZFS_DELEG_PERM_CREATE = 4
} zfs_deleg_inherit_t;

#define	ZFS_DELEG_PERM_UID	"uid"
#define	ZFS_DELEG_PERM_GID	"gid"
#define	ZFS_DELEG_PERM_GROUPS	"groups"

#define	ZFS_MLSLABEL_DEFAULT	"none"

#define	ZFS_SMB_ACL_SRC		"src"
#define	ZFS_SMB_ACL_TARGET	"target"

typedef enum {
	ZFS_CANMOUNT_OFF = 0,
	ZFS_CANMOUNT_ON = 1,
	ZFS_CANMOUNT_NOAUTO = 2
} zfs_canmount_type_t;

typedef enum {
	ZFS_LOGBIAS_LATENCY = 0,
	ZFS_LOGBIAS_THROUGHPUT = 1
} zfs_logbias_op_t;

typedef enum zfs_share_op {
	ZFS_SHARE_NFS = 0,
	ZFS_UNSHARE_NFS = 1,
	ZFS_SHARE_SMB = 2,
	ZFS_UNSHARE_SMB = 3
} zfs_share_op_t;

typedef enum zfs_smb_acl_op {
	ZFS_SMB_ACL_ADD,
	ZFS_SMB_ACL_REMOVE,
	ZFS_SMB_ACL_RENAME,
	ZFS_SMB_ACL_PURGE
} zfs_smb_acl_op_t;

typedef enum zfs_cache_type {
	ZFS_CACHE_NONE = 0,
	ZFS_CACHE_METADATA = 1,
	ZFS_CACHE_ALL = 2
} zfs_cache_type_t;

typedef enum {
	ZFS_SYNC_STANDARD = 0,
	ZFS_SYNC_ALWAYS = 1,
	ZFS_SYNC_DISABLED = 2
} zfs_sync_type_t;

typedef enum {
	ZFS_XATTR_OFF = 0,
	ZFS_XATTR_DIR = 1,
	ZFS_XATTR_SA = 2
} zfs_xattr_type_t;

typedef enum {
	ZFS_REDUNDANT_METADATA_ALL,
	ZFS_REDUNDANT_METADATA_MOST
} zfs_redundant_metadata_type_t;

/*
 * On-disk version number.
 */
#define	SPA_VERSION_1			1ULL
#define	SPA_VERSION_2			2ULL
#define	SPA_VERSION_3			3ULL
#define	SPA_VERSION_4			4ULL
#define	SPA_VERSION_5			5ULL
#define	SPA_VERSION_6			6ULL
#define	SPA_VERSION_7			7ULL
#define	SPA_VERSION_8			8ULL
#define	SPA_VERSION_9			9ULL
#define	SPA_VERSION_10			10ULL
#define	SPA_VERSION_11			11ULL
#define	SPA_VERSION_12			12ULL
#define	SPA_VERSION_13			13ULL
#define	SPA_VERSION_14			14ULL
#define	SPA_VERSION_15			15ULL
#define	SPA_VERSION_16			16ULL
#define	SPA_VERSION_17			17ULL
#define	SPA_VERSION_18			18ULL
#define	SPA_VERSION_19			19ULL
#define	SPA_VERSION_20			20ULL
#define	SPA_VERSION_21			21ULL
#define	SPA_VERSION_22			22ULL
#define	SPA_VERSION_23			23ULL
#define	SPA_VERSION_24			24ULL
#define	SPA_VERSION_25			25ULL
#define	SPA_VERSION_26			26ULL
#define	SPA_VERSION_27			27ULL
#define	SPA_VERSION_28			28ULL
#define	SPA_VERSION_5000		5000ULL

/*
 * When bumping up SPA_VERSION, make sure GRUB ZFS understands the on-disk
 * format change. Go to usr/src/grub/grub-0.97/stage2/{zfs-include/, fsys_zfs*},
 * and do the appropriate changes.  Also bump the version number in
 * usr/src/grub/capability.
 */
#define	SPA_VERSION			SPA_VERSION_5000
#define	SPA_VERSION_STRING		"5000"

/*
 * Symbolic names for the changes that caused a SPA_VERSION switch.
 * Used in the code when checking for presence or absence of a feature.
 * Feel free to define multiple symbolic names for each version if there
 * were multiple changes to on-disk structures during that version.
 *
 * NOTE: When checking the current SPA_VERSION in your code, be sure
 *       to use spa_version() since it reports the version of the
 *       last synced uberblock.  Checking the in-flight version can
 *       be dangerous in some cases.
 */
#define	SPA_VERSION_INITIAL		SPA_VERSION_1
#define	SPA_VERSION_DITTO_BLOCKS	SPA_VERSION_2
#define	SPA_VERSION_SPARES		SPA_VERSION_3
#define	SPA_VERSION_RAIDZ2		SPA_VERSION_3
#define	SPA_VERSION_BPOBJ_ACCOUNT	SPA_VERSION_3
#define	SPA_VERSION_RAIDZ_DEFLATE	SPA_VERSION_3
#define	SPA_VERSION_DNODE_BYTES		SPA_VERSION_3
#define	SPA_VERSION_ZPOOL_HISTORY	SPA_VERSION_4
#define	SPA_VERSION_GZIP_COMPRESSION	SPA_VERSION_5
#define	SPA_VERSION_BOOTFS		SPA_VERSION_6
#define	SPA_VERSION_SLOGS		SPA_VERSION_7
#define	SPA_VERSION_DELEGATED_PERMS	SPA_VERSION_8
#define	SPA_VERSION_FUID		SPA_VERSION_9
#define	SPA_VERSION_REFRESERVATION	SPA_VERSION_9
#define	SPA_VERSION_REFQUOTA		SPA_VERSION_9
#define	SPA_VERSION_UNIQUE_ACCURATE	SPA_VERSION_9
#define	SPA_VERSION_L2CACHE		SPA_VERSION_10
#define	SPA_VERSION_NEXT_CLONES		SPA_VERSION_11
#define	SPA_VERSION_ORIGIN		SPA_VERSION_11
#define	SPA_VERSION_DSL_SCRUB		SPA_VERSION_11
#define	SPA_VERSION_SNAP_PROPS		SPA_VERSION_12
#define	SPA_VERSION_USED_BREAKDOWN	SPA_VERSION_13
#define	SPA_VERSION_PASSTHROUGH_X	SPA_VERSION_14
#define	SPA_VERSION_USERSPACE		SPA_VERSION_15
#define	SPA_VERSION_STMF_PROP		SPA_VERSION_16
#define	SPA_VERSION_RAIDZ3		SPA_VERSION_17
#define	SPA_VERSION_USERREFS		SPA_VERSION_18
#define	SPA_VERSION_HOLES		SPA_VERSION_19
#define	SPA_VERSION_ZLE_COMPRESSION	SPA_VERSION_20
#define	SPA_VERSION_DEDUP		SPA_VERSION_21
#define	SPA_VERSION_RECVD_PROPS		SPA_VERSION_22
#define	SPA_VERSION_SLIM_ZIL		SPA_VERSION_23
#define	SPA_VERSION_SA			SPA_VERSION_24
#define	SPA_VERSION_SCAN		SPA_VERSION_25
#define	SPA_VERSION_DIR_CLONES		SPA_VERSION_26
#define	SPA_VERSION_DEADLISTS		SPA_VERSION_26
#define	SPA_VERSION_FAST_SNAP		SPA_VERSION_27
#define	SPA_VERSION_MULTI_REPLACE	SPA_VERSION_28
#define	SPA_VERSION_BEFORE_FEATURES	SPA_VERSION_28
#define	SPA_VERSION_FEATURES		SPA_VERSION_5000

#define	SPA_VERSION_IS_SUPPORTED(v) \
	(((v) >= SPA_VERSION_INITIAL && (v) <= SPA_VERSION_BEFORE_FEATURES) || \
	((v) >= SPA_VERSION_FEATURES && (v) <= SPA_VERSION))

/*
 * ZPL version - rev'd whenever an incompatible on-disk format change
 * occurs.  This is independent of SPA/DMU/ZAP versioning.  You must
 * also update the version_table[] and help message in zfs_prop.c.
 *
 * When changing, be sure to teach GRUB how to read the new format!
 * See usr/src/grub/grub-0.97/stage2/{zfs-include/,fsys_zfs*}
 */
#define	ZPL_VERSION_1			1ULL
#define	ZPL_VERSION_2			2ULL
#define	ZPL_VERSION_3			3ULL
#define	ZPL_VERSION_4			4ULL
#define	ZPL_VERSION_5			5ULL
#define	ZPL_VERSION			ZPL_VERSION_5
#define	ZPL_VERSION_STRING		"5"

#define	ZPL_VERSION_INITIAL		ZPL_VERSION_1
#define	ZPL_VERSION_DIRENT_TYPE		ZPL_VERSION_2
#define	ZPL_VERSION_FUID		ZPL_VERSION_3
#define	ZPL_VERSION_NORMALIZATION	ZPL_VERSION_3
#define	ZPL_VERSION_SYSATTR		ZPL_VERSION_3
#define	ZPL_VERSION_USERSPACE		ZPL_VERSION_4
#define	ZPL_VERSION_SA			ZPL_VERSION_5

/* Rewind request information */
#define	ZPOOL_NO_REWIND		1  /* No policy - default behavior */
#define	ZPOOL_NEVER_REWIND	2  /* Do not search for best txg or rewind */
#define	ZPOOL_TRY_REWIND	4  /* Search for best txg, but do not rewind */
#define	ZPOOL_DO_REWIND		8  /* Rewind to best txg w/in deferred frees */
#define	ZPOOL_EXTREME_REWIND	16 /* Allow extreme measures to find best txg */
#define	ZPOOL_REWIND_MASK	28 /* All the possible rewind bits */
#define	ZPOOL_REWIND_POLICIES	31 /* All the possible policy bits */

typedef struct zpool_rewind_policy {
	uint32_t	zrp_request;	/* rewind behavior requested */
	uint64_t	zrp_maxmeta;	/* max acceptable meta-data errors */
	uint64_t	zrp_maxdata;	/* max acceptable data errors */
	uint64_t	zrp_txg;	/* specific txg to load */
} zpool_rewind_policy_t;

/*
 * The following are configuration names used in the nvlist describing a pool's
 * configuration.
 */
#define	ZPOOL_CONFIG_VERSION		"version"
#define	ZPOOL_CONFIG_POOL_NAME		"name"
#define	ZPOOL_CONFIG_POOL_STATE		"state"
#define	ZPOOL_CONFIG_POOL_TXG		"txg"
#define	ZPOOL_CONFIG_POOL_GUID		"pool_guid"
#define	ZPOOL_CONFIG_CREATE_TXG		"create_txg"
#define	ZPOOL_CONFIG_TOP_GUID		"top_guid"
#define	ZPOOL_CONFIG_VDEV_TREE		"vdev_tree"
#define	ZPOOL_CONFIG_TYPE		"type"
#define	ZPOOL_CONFIG_CHILDREN		"children"
#define	ZPOOL_CONFIG_ID			"id"
#define	ZPOOL_CONFIG_GUID		"guid"
#define	ZPOOL_CONFIG_PATH		"path"
#define	ZPOOL_CONFIG_DEVID		"devid"
#define	ZPOOL_CONFIG_METASLAB_ARRAY	"metaslab_array"
#define	ZPOOL_CONFIG_METASLAB_SHIFT	"metaslab_shift"
#define	ZPOOL_CONFIG_ASHIFT		"ashift"
#define	ZPOOL_CONFIG_ASIZE		"asize"
#define	ZPOOL_CONFIG_DTL		"DTL"
#define	ZPOOL_CONFIG_SCAN_STATS		"scan_stats"	/* not stored on disk */
#define	ZPOOL_CONFIG_VDEV_STATS		"vdev_stats"	/* not stored on disk */
#define	ZPOOL_CONFIG_WHOLE_DISK		"whole_disk"
#define	ZPOOL_CONFIG_ERRCOUNT		"error_count"
#define	ZPOOL_CONFIG_NOT_PRESENT	"not_present"
#define	ZPOOL_CONFIG_SPARES		"spares"
#define	ZPOOL_CONFIG_IS_SPARE		"is_spare"
#define	ZPOOL_CONFIG_NPARITY		"nparity"
#define	ZPOOL_CONFIG_HOSTID		"hostid"
#define	ZPOOL_CONFIG_HOSTNAME		"hostname"
#define	ZPOOL_CONFIG_LOADED_TIME	"initial_load_time"
#define	ZPOOL_CONFIG_UNSPARE		"unspare"
#define	ZPOOL_CONFIG_PHYS_PATH		"phys_path"
#define	ZPOOL_CONFIG_IS_LOG		"is_log"
#define	ZPOOL_CONFIG_L2CACHE		"l2cache"
#define	ZPOOL_CONFIG_HOLE_ARRAY		"hole_array"
#define	ZPOOL_CONFIG_VDEV_CHILDREN	"vdev_children"
#define	ZPOOL_CONFIG_IS_HOLE		"is_hole"
#define	ZPOOL_CONFIG_DDT_HISTOGRAM	"ddt_histogram"
#define	ZPOOL_CONFIG_DDT_OBJ_STATS	"ddt_object_stats"
#define	ZPOOL_CONFIG_DDT_STATS		"ddt_stats"
#define	ZPOOL_CONFIG_SPLIT		"splitcfg"
#define	ZPOOL_CONFIG_ORIG_GUID		"orig_guid"
#define	ZPOOL_CONFIG_SPLIT_GUID		"split_guid"
#define	ZPOOL_CONFIG_SPLIT_LIST		"guid_list"
#define	ZPOOL_CONFIG_REMOVING		"removing"
#define	ZPOOL_CONFIG_RESILVER_TXG	"resilver_txg"
#define	ZPOOL_CONFIG_COMMENT		"comment"
#define	ZPOOL_CONFIG_SUSPENDED		"suspended"	/* not stored on disk */
#define	ZPOOL_CONFIG_TIMESTAMP		"timestamp"	/* not stored on disk */
#define	ZPOOL_CONFIG_BOOTFS		"bootfs"	/* not stored on disk */
#define	ZPOOL_CONFIG_MISSING_DEVICES	"missing_vdevs"	/* not stored on disk */
#define	ZPOOL_CONFIG_LOAD_INFO		"load_info"	/* not stored on disk */
#define	ZPOOL_CONFIG_REWIND_INFO	"rewind_info"	/* not stored on disk */
#define	ZPOOL_CONFIG_UNSUP_FEAT		"unsup_feat"	/* not stored on disk */
#define	ZPOOL_CONFIG_ENABLED_FEAT	"enabled_feat"	/* not stored on disk */
#define	ZPOOL_CONFIG_CAN_RDONLY		"can_rdonly"	/* not stored on disk */
#define	ZPOOL_CONFIG_FEATURES_FOR_READ	"features_for_read"
#define	ZPOOL_CONFIG_FEATURE_STATS	"feature_stats"	/* not stored on disk */
#define	ZPOOL_CONFIG_ERRATA		"errata"	/* not stored on disk */
/*
 * The persistent vdev state is stored as separate values rather than a single
 * 'vdev_state' entry.  This is because a device can be in multiple states, such
 * as offline and degraded.
 */
#define	ZPOOL_CONFIG_OFFLINE		"offline"
#define	ZPOOL_CONFIG_FAULTED		"faulted"
#define	ZPOOL_CONFIG_DEGRADED		"degraded"
#define	ZPOOL_CONFIG_REMOVED		"removed"
#define	ZPOOL_CONFIG_FRU		"fru"
#define	ZPOOL_CONFIG_AUX_STATE		"aux_state"

/* Rewind policy parameters */
#define	ZPOOL_REWIND_POLICY		"rewind-policy"
#define	ZPOOL_REWIND_REQUEST		"rewind-request"
#define	ZPOOL_REWIND_REQUEST_TXG	"rewind-request-txg"
#define	ZPOOL_REWIND_META_THRESH	"rewind-meta-thresh"
#define	ZPOOL_REWIND_DATA_THRESH	"rewind-data-thresh"

/* Rewind data discovered */
#define	ZPOOL_CONFIG_LOAD_TIME		"rewind_txg_ts"
#define	ZPOOL_CONFIG_LOAD_DATA_ERRORS	"verify_data_errors"
#define	ZPOOL_CONFIG_REWIND_TIME	"seconds_of_rewind"

#define	VDEV_TYPE_ROOT			"root"
#define	VDEV_TYPE_MIRROR		"mirror"
#define	VDEV_TYPE_REPLACING		"replacing"
#define	VDEV_TYPE_RAIDZ			"raidz"
#define	VDEV_TYPE_DISK			"disk"
#define	VDEV_TYPE_FILE			"file"
#define	VDEV_TYPE_MISSING		"missing"
#define	VDEV_TYPE_HOLE			"hole"
#define	VDEV_TYPE_SPARE			"spare"
#define	VDEV_TYPE_LOG			"log"
#define	VDEV_TYPE_L2CACHE		"l2cache"

/*
 * This is needed in userland to report the minimum necessary device size.
 */
#define	SPA_MINDEVSIZE		(64ULL << 20)

/*
 * Set if the fragmentation has not yet been calculated. This can happen
 * because the space maps have not been upgraded or the histogram feature
 * is not enabled.
 */
#define	ZFS_FRAG_INVALID	UINT64_MAX

/*
 * The location of the pool configuration repository, shared between kernel and
 * userland.
 */
#define	ZPOOL_CACHE		"/etc/zfs/zpool.cache"

/*
 * vdev states are ordered from least to most healthy.
 * A vdev that's CANT_OPEN or below is considered unusable.
 */
typedef enum vdev_state {
	VDEV_STATE_UNKNOWN = 0,	/* Uninitialized vdev			*/
	VDEV_STATE_CLOSED,	/* Not currently open			*/
	VDEV_STATE_OFFLINE,	/* Not allowed to open			*/
	VDEV_STATE_REMOVED,	/* Explicitly removed from system	*/
	VDEV_STATE_CANT_OPEN,	/* Tried to open, but failed		*/
	VDEV_STATE_FAULTED,	/* External request to fault device	*/
	VDEV_STATE_DEGRADED,	/* Replicated vdev with unhealthy kids	*/
	VDEV_STATE_HEALTHY	/* Presumed good			*/
} vdev_state_t;

#define	VDEV_STATE_ONLINE	VDEV_STATE_HEALTHY

/*
 * vdev aux states.  When a vdev is in the CANT_OPEN state, the aux field
 * of the vdev stats structure uses these constants to distinguish why.
 */
typedef enum vdev_aux {
	VDEV_AUX_NONE,		/* no error				*/
	VDEV_AUX_OPEN_FAILED,	/* ldi_open_*() or vn_open() failed	*/
	VDEV_AUX_CORRUPT_DATA,	/* bad label or disk contents		*/
	VDEV_AUX_NO_REPLICAS,	/* insufficient number of replicas	*/
	VDEV_AUX_BAD_GUID_SUM,	/* vdev guid sum doesn't match		*/
	VDEV_AUX_TOO_SMALL,	/* vdev size is too small		*/
	VDEV_AUX_BAD_LABEL,	/* the label is OK but invalid		*/
	VDEV_AUX_VERSION_NEWER,	/* on-disk version is too new		*/
	VDEV_AUX_VERSION_OLDER,	/* on-disk version is too old		*/
	VDEV_AUX_UNSUP_FEAT,	/* unsupported features			*/
	VDEV_AUX_SPARED,	/* hot spare used in another pool	*/
	VDEV_AUX_ERR_EXCEEDED,	/* too many errors			*/
	VDEV_AUX_IO_FAILURE,	/* experienced I/O failure		*/
	VDEV_AUX_BAD_LOG,	/* cannot read log chain(s)		*/
	VDEV_AUX_EXTERNAL,	/* external diagnosis			*/
	VDEV_AUX_SPLIT_POOL	/* vdev was split off into another pool	*/
} vdev_aux_t;

/*
 * pool state.  The following states are written to disk as part of the normal
 * SPA lifecycle: ACTIVE, EXPORTED, DESTROYED, SPARE, L2CACHE.  The remaining
 * states are software abstractions used at various levels to communicate
 * pool state.
 */
typedef enum pool_state {
	POOL_STATE_ACTIVE = 0,		/* In active use		*/
	POOL_STATE_EXPORTED,		/* Explicitly exported		*/
	POOL_STATE_DESTROYED,		/* Explicitly destroyed		*/
	POOL_STATE_SPARE,		/* Reserved for hot spare use	*/
	POOL_STATE_L2CACHE,		/* Level 2 ARC device		*/
	POOL_STATE_UNINITIALIZED,	/* Internal spa_t state		*/
	POOL_STATE_UNAVAIL,		/* Internal libzfs state	*/
	POOL_STATE_POTENTIALLY_ACTIVE	/* Internal libzfs state	*/
} pool_state_t;

/*
 * Scan Functions.
 */
typedef enum pool_scan_func {
	POOL_SCAN_NONE,
	POOL_SCAN_SCRUB,
	POOL_SCAN_RESILVER,
	POOL_SCAN_FUNCS
} pool_scan_func_t;

/*
 * ZIO types.  Needed to interpret vdev statistics below.
 */
typedef enum zio_type {
	ZIO_TYPE_NULL = 0,
	ZIO_TYPE_READ,
	ZIO_TYPE_WRITE,
	ZIO_TYPE_FREE,
	ZIO_TYPE_CLAIM,
	ZIO_TYPE_IOCTL,
	ZIO_TYPES
} zio_type_t;

/*
 * Pool statistics.  Note: all fields should be 64-bit because this
 * is passed between kernel and userland as an nvlist uint64 array.
 */
typedef struct pool_scan_stat {
	/* values stored on disk */
	uint64_t	pss_func;	/* pool_scan_func_t */
	uint64_t	pss_state;	/* dsl_scan_state_t */
	uint64_t	pss_start_time;	/* scan start time */
	uint64_t	pss_end_time;	/* scan end time */
	uint64_t	pss_to_examine;	/* total bytes to scan */
	uint64_t	pss_examined;	/* total examined bytes	*/
	uint64_t	pss_to_process; /* total bytes to process */
	uint64_t	pss_processed;	/* total processed bytes */
	uint64_t	pss_errors;	/* scan errors	*/

	/* values not stored on disk */
	uint64_t	pss_pass_exam;	/* examined bytes per scan pass */
	uint64_t	pss_pass_start;	/* start time of a scan pass */
} pool_scan_stat_t;

typedef enum dsl_scan_state {
	DSS_NONE,
	DSS_SCANNING,
	DSS_FINISHED,
	DSS_CANCELED,
	DSS_NUM_STATES
} dsl_scan_state_t;

/*
 * Errata described by http://zfsonlinux.org/msg/ZFS-8000-ER.  The ordering
 * of this enum must be maintained to ensure the errata identifiers map to
 * the correct documentation.  New errata may only be appended to the list
 * and must contain corresponding documentation at the above link.
 */
typedef enum zpool_errata {
	ZPOOL_ERRATA_NONE,
	ZPOOL_ERRATA_ZOL_2094_SCRUB,
	ZPOOL_ERRATA_ZOL_2094_ASYNC_DESTROY,
} zpool_errata_t;

/*
 * Vdev statistics.  Note: all fields should be 64-bit because this
 * is passed between kernel and userland as an nvlist uint64 array.
 */
typedef struct vdev_stat {
	hrtime_t	vs_timestamp;		/* time since vdev load	*/
	uint64_t	vs_state;		/* vdev state		*/
	uint64_t	vs_aux;			/* see vdev_aux_t	*/
	uint64_t	vs_alloc;		/* space allocated	*/
	uint64_t	vs_space;		/* total capacity	*/
	uint64_t	vs_dspace;		/* deflated capacity	*/
	uint64_t	vs_rsize;		/* replaceable dev size */
	uint64_t	vs_esize;		/* expandable dev size */
	uint64_t	vs_ops[ZIO_TYPES];	/* operation count	*/
	uint64_t	vs_bytes[ZIO_TYPES];	/* bytes read/written	*/
	uint64_t	vs_read_errors;		/* read errors		*/
	uint64_t	vs_write_errors;	/* write errors		*/
	uint64_t	vs_checksum_errors;	/* checksum errors	*/
	uint64_t	vs_self_healed;		/* self-healed bytes	*/
	uint64_t	vs_scan_removing;	/* removing?	*/
	uint64_t	vs_scan_processed;	/* scan processed bytes	*/
	uint64_t	vs_fragmentation;	/* device fragmentation */
} vdev_stat_t;

/*
 * DDT statistics.  Note: all fields should be 64-bit because this
 * is passed between kernel and userland as an nvlist uint64 array.
 */
typedef struct ddt_object {
	uint64_t	ddo_count;	/* number of elments in ddt 	*/
	uint64_t	ddo_dspace;	/* size of ddt on disk		*/
	uint64_t	ddo_mspace;	/* size of ddt in-core		*/
} ddt_object_t;

typedef struct ddt_stat {
	uint64_t	dds_blocks;	/* blocks			*/
	uint64_t	dds_lsize;	/* logical size			*/
	uint64_t	dds_psize;	/* physical size		*/
	uint64_t	dds_dsize;	/* deflated allocated size	*/
	uint64_t	dds_ref_blocks;	/* referenced blocks		*/
	uint64_t	dds_ref_lsize;	/* referenced lsize * refcnt	*/
	uint64_t	dds_ref_psize;	/* referenced psize * refcnt	*/
	uint64_t	dds_ref_dsize;	/* referenced dsize * refcnt	*/
} ddt_stat_t;

typedef struct ddt_histogram {
	ddt_stat_t	ddh_stat[64];	/* power-of-two histogram buckets */
} ddt_histogram_t;

#define	ZVOL_DRIVER	"zvol"
#define	ZFS_DRIVER	"zfs"
#define	ZFS_DEV		"/dev/zfs"

/* general zvol path */
#define	ZVOL_DIR	"/dev"

#define	ZVOL_MAJOR		230
#define	ZVOL_MINOR_BITS		4
#define	ZVOL_MINOR_MASK		((1U << ZVOL_MINOR_BITS) - 1)
#define	ZVOL_MINORS		(1 << 4)
#define	ZVOL_DEV_NAME		"zd"

#define	ZVOL_PROP_NAME		"name"
#define	ZVOL_DEFAULT_BLOCKSIZE	8192

/*
 * /dev/zfs ioctl numbers.
 */
typedef enum zfs_ioc {
	/*
	 * Illumos - 70/128 numbers reserved.
	 */
	ZFS_IOC_FIRST =	('Z' << 8),
	ZFS_IOC = ZFS_IOC_FIRST,
	ZFS_IOC_POOL_CREATE = ZFS_IOC_FIRST,
	ZFS_IOC_POOL_DESTROY,
	ZFS_IOC_POOL_IMPORT,
	ZFS_IOC_POOL_EXPORT,
	ZFS_IOC_POOL_CONFIGS,
	ZFS_IOC_POOL_STATS,
	ZFS_IOC_POOL_TRYIMPORT,
	ZFS_IOC_POOL_SCAN,
	ZFS_IOC_POOL_FREEZE,
	ZFS_IOC_POOL_UPGRADE,
	ZFS_IOC_POOL_GET_HISTORY,
	ZFS_IOC_VDEV_ADD,
	ZFS_IOC_VDEV_REMOVE,
	ZFS_IOC_VDEV_SET_STATE,
	ZFS_IOC_VDEV_ATTACH,
	ZFS_IOC_VDEV_DETACH,
	ZFS_IOC_VDEV_SETPATH,
	ZFS_IOC_VDEV_SETFRU,
	ZFS_IOC_OBJSET_STATS,
	ZFS_IOC_OBJSET_ZPLPROPS,
	ZFS_IOC_DATASET_LIST_NEXT,
	ZFS_IOC_SNAPSHOT_LIST_NEXT,
	ZFS_IOC_SET_PROP,
	ZFS_IOC_CREATE,
	ZFS_IOC_DESTROY,
	ZFS_IOC_ROLLBACK,
	ZFS_IOC_RENAME,
	ZFS_IOC_RECV,
	ZFS_IOC_SEND,
	ZFS_IOC_INJECT_FAULT,
	ZFS_IOC_CLEAR_FAULT,
	ZFS_IOC_INJECT_LIST_NEXT,
	ZFS_IOC_ERROR_LOG,
	ZFS_IOC_CLEAR,
	ZFS_IOC_PROMOTE,
	ZFS_IOC_SNAPSHOT,
	ZFS_IOC_DSOBJ_TO_DSNAME,
	ZFS_IOC_OBJ_TO_PATH,
	ZFS_IOC_POOL_SET_PROPS,
	ZFS_IOC_POOL_GET_PROPS,
	ZFS_IOC_SET_FSACL,
	ZFS_IOC_GET_FSACL,
	ZFS_IOC_SHARE,
	ZFS_IOC_INHERIT_PROP,
	ZFS_IOC_SMB_ACL,
	ZFS_IOC_USERSPACE_ONE,
	ZFS_IOC_USERSPACE_MANY,
	ZFS_IOC_USERSPACE_UPGRADE,
	ZFS_IOC_HOLD,
	ZFS_IOC_RELEASE,
	ZFS_IOC_GET_HOLDS,
	ZFS_IOC_OBJSET_RECVD_PROPS,
	ZFS_IOC_VDEV_SPLIT,
	ZFS_IOC_NEXT_OBJ,
	ZFS_IOC_DIFF,
	ZFS_IOC_TMP_SNAPSHOT,
	ZFS_IOC_OBJ_TO_STATS,
	ZFS_IOC_SPACE_WRITTEN,
	ZFS_IOC_SPACE_SNAPS,
	ZFS_IOC_DESTROY_SNAPS,
	ZFS_IOC_POOL_REGUID,
	ZFS_IOC_POOL_REOPEN,
	ZFS_IOC_SEND_PROGRESS,
	ZFS_IOC_LOG_HISTORY,
	ZFS_IOC_SEND_NEW,
	ZFS_IOC_SEND_SPACE,
	ZFS_IOC_CLONE,
	ZFS_IOC_BOOKMARK,
	ZFS_IOC_GET_BOOKMARKS,
	ZFS_IOC_DESTROY_BOOKMARKS,

	/*
	 * Linux - 3/64 numbers reserved.
	 */
	ZFS_IOC_LINUX = ('Z' << 8) + 0x80,
	ZFS_IOC_EVENTS_NEXT,
	ZFS_IOC_EVENTS_CLEAR,
	ZFS_IOC_EVENTS_SEEK,

	/*
	 * FreeBSD - 1/64 numbers reserved.
	 */
	ZFS_IOC_FREEBSD = ('Z' << 8) + 0xC0,

	ZFS_IOC_LAST
} zfs_ioc_t;

/*
 * zvol ioctl to get dataset name
 */
#define	BLKZNAME		_IOR(0x12, 125, char[ZFS_MAXNAMELEN])

/*
 * Internal SPA load state.  Used by FMA diagnosis engine.
 */
typedef enum {
	SPA_LOAD_NONE,		/* no load in progress	*/
	SPA_LOAD_OPEN,		/* normal open		*/
	SPA_LOAD_IMPORT,	/* import in progress	*/
	SPA_LOAD_TRYIMPORT,	/* tryimport in progress */
	SPA_LOAD_RECOVER,	/* recovery requested	*/
	SPA_LOAD_ERROR		/* load failed		*/
} spa_load_state_t;

/*
 * Bookmark name values.
 */
#define	ZPOOL_ERR_LIST		"error list"
#define	ZPOOL_ERR_DATASET	"dataset"
#define	ZPOOL_ERR_OBJECT	"object"

#define	HIS_MAX_RECORD_LEN	(MAXPATHLEN + MAXPATHLEN + 1)

/*
 * The following are names used in the nvlist describing
 * the pool's history log.
 */
#define	ZPOOL_HIST_RECORD	"history record"
#define	ZPOOL_HIST_TIME		"history time"
#define	ZPOOL_HIST_CMD		"history command"
#define	ZPOOL_HIST_WHO		"history who"
#define	ZPOOL_HIST_ZONE		"history zone"
#define	ZPOOL_HIST_HOST		"history hostname"
#define	ZPOOL_HIST_TXG		"history txg"
#define	ZPOOL_HIST_INT_EVENT	"history internal event"
#define	ZPOOL_HIST_INT_STR	"history internal str"
#define	ZPOOL_HIST_INT_NAME	"internal_name"
#define	ZPOOL_HIST_IOCTL	"ioctl"
#define	ZPOOL_HIST_INPUT_NVL	"in_nvl"
#define	ZPOOL_HIST_OUTPUT_NVL	"out_nvl"
#define	ZPOOL_HIST_DSNAME	"dsname"
#define	ZPOOL_HIST_DSID		"dsid"

/*
 * Flags for ZFS_IOC_VDEV_SET_STATE
 */
#define	ZFS_ONLINE_CHECKREMOVE	0x1
#define	ZFS_ONLINE_UNSPARE	0x2
#define	ZFS_ONLINE_FORCEFAULT	0x4
#define	ZFS_ONLINE_EXPAND	0x8
#define	ZFS_OFFLINE_TEMPORARY	0x1

/*
 * Flags for ZFS_IOC_POOL_IMPORT
 */
#define	ZFS_IMPORT_NORMAL	0x0
#define	ZFS_IMPORT_VERBATIM	0x1
#define	ZFS_IMPORT_ANY_HOST	0x2
#define	ZFS_IMPORT_MISSING_LOG	0x4
#define	ZFS_IMPORT_ONLY		0x8
#define	ZFS_IMPORT_TEMP_NAME	0x10

/*
 * Sysevent payload members.  ZFS will generate the following sysevents with the
 * given payloads:
 *
 *	ESC_ZFS_RESILVER_START
 *	ESC_ZFS_RESILVER_END
 *	ESC_ZFS_POOL_DESTROY
 *	ESC_ZFS_POOL_REGUID
 *
 *		ZFS_EV_POOL_NAME	DATA_TYPE_STRING
 *		ZFS_EV_POOL_GUID	DATA_TYPE_UINT64
 *
 *	ESC_ZFS_VDEV_REMOVE
 *	ESC_ZFS_VDEV_CLEAR
 *	ESC_ZFS_VDEV_CHECK
 *
 *		ZFS_EV_POOL_NAME	DATA_TYPE_STRING
 *		ZFS_EV_POOL_GUID	DATA_TYPE_UINT64
 *		ZFS_EV_VDEV_PATH	DATA_TYPE_STRING	(optional)
 *		ZFS_EV_VDEV_GUID	DATA_TYPE_UINT64
 */
#define	ZFS_EV_POOL_NAME	"pool_name"
#define	ZFS_EV_POOL_GUID	"pool_guid"
#define	ZFS_EV_VDEV_PATH	"vdev_path"
#define	ZFS_EV_VDEV_GUID	"vdev_guid"

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_H */
                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/metaslab.h                                                          0100644 0000000 0000000 00000006711 13045171016 016467  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_METASLAB_H
#define	_SYS_METASLAB_H

#include <sys/spa.h>
#include <sys/space_map.h>
#include <sys/txg.h>
#include <sys/zio.h>
#include <sys/avl.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct metaslab_ops {
	uint64_t (*msop_alloc)(metaslab_t *msp, uint64_t size);
} metaslab_ops_t;

extern metaslab_ops_t *zfs_metaslab_ops;

int metaslab_init(metaslab_group_t *, uint64_t, uint64_t, uint64_t,
    metaslab_t **);
void metaslab_fini(metaslab_t *);

void metaslab_load_wait(metaslab_t *);
int metaslab_load(metaslab_t *);
void metaslab_unload(metaslab_t *);

void metaslab_sync(metaslab_t *, uint64_t);
void metaslab_sync_done(metaslab_t *, uint64_t);
void metaslab_sync_reassess(metaslab_group_t *);
uint64_t metaslab_block_maxsize(metaslab_t *);

#define	METASLAB_HINTBP_FAVOR	0x0
#define	METASLAB_HINTBP_AVOID	0x1
#define	METASLAB_GANG_HEADER	0x2
#define	METASLAB_GANG_CHILD	0x4
#define	METASLAB_GANG_AVOID	0x8
#define	METASLAB_FASTWRITE	0x10

int metaslab_alloc(spa_t *, metaslab_class_t *, uint64_t,
    blkptr_t *, int, uint64_t, blkptr_t *, int);
void metaslab_free(spa_t *, const blkptr_t *, uint64_t, boolean_t);
int metaslab_claim(spa_t *, const blkptr_t *, uint64_t);
void metaslab_check_free(spa_t *, const blkptr_t *);
void metaslab_fastwrite_mark(spa_t *, const blkptr_t *);
void metaslab_fastwrite_unmark(spa_t *, const blkptr_t *);

metaslab_class_t *metaslab_class_create(spa_t *, metaslab_ops_t *);
void metaslab_class_destroy(metaslab_class_t *);
int metaslab_class_validate(metaslab_class_t *);
void metaslab_class_histogram_verify(metaslab_class_t *);
uint64_t metaslab_class_fragmentation(metaslab_class_t *);
uint64_t metaslab_class_expandable_space(metaslab_class_t *);

void metaslab_class_space_update(metaslab_class_t *, int64_t, int64_t,
    int64_t, int64_t);
uint64_t metaslab_class_get_alloc(metaslab_class_t *);
uint64_t metaslab_class_get_space(metaslab_class_t *);
uint64_t metaslab_class_get_dspace(metaslab_class_t *);
uint64_t metaslab_class_get_deferred(metaslab_class_t *);

metaslab_group_t *metaslab_group_create(metaslab_class_t *, vdev_t *);
void metaslab_group_destroy(metaslab_group_t *);
void metaslab_group_activate(metaslab_group_t *);
void metaslab_group_passivate(metaslab_group_t *);
uint64_t metaslab_group_get_space(metaslab_group_t *);
void metaslab_group_histogram_verify(metaslab_group_t *);
uint64_t metaslab_group_fragmentation(metaslab_group_t *);
void metaslab_group_histogram_remove(metaslab_group_t *, metaslab_t *);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_METASLAB_H */
                                                       usr/src/zfs-0.6.5.9/include/sys/metaslab_impl.h                                                     0100644 0000000 0000000 00000017306 13045171016 017512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_METASLAB_IMPL_H
#define	_SYS_METASLAB_IMPL_H

#include <sys/metaslab.h>
#include <sys/space_map.h>
#include <sys/range_tree.h>
#include <sys/vdev.h>
#include <sys/txg.h>
#include <sys/avl.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * A metaslab class encompasses a category of allocatable top-level vdevs.
 * Each top-level vdev is associated with a metaslab group which defines
 * the allocatable region for that vdev. Examples of these categories include
 * "normal" for data block allocations (i.e. main pool allocations) or "log"
 * for allocations designated for intent log devices (i.e. slog devices).
 * When a block allocation is requested from the SPA it is associated with a
 * metaslab_class_t, and only top-level vdevs (i.e. metaslab groups) belonging
 * to the class can be used to satisfy that request. Allocations are done
 * by traversing the metaslab groups that are linked off of the mc_rotor field.
 * This rotor points to the next metaslab group where allocations will be
 * attempted. Allocating a block is a 3 step process -- select the metaslab
 * group, select the metaslab, and then allocate the block. The metaslab
 * class defines the low-level block allocator that will be used as the
 * final step in allocation. These allocators are pluggable allowing each class
 * to use a block allocator that best suits that class.
 */
struct metaslab_class {
	spa_t			*mc_spa;
	metaslab_group_t	*mc_rotor;
	metaslab_ops_t		*mc_ops;
	uint64_t		mc_aliquot;
	uint64_t		mc_alloc_groups; /* # of allocatable groups */
	uint64_t		mc_alloc;	/* total allocated space */
	uint64_t		mc_deferred;	/* total deferred frees */
	uint64_t		mc_space;	/* total space (alloc + free) */
	uint64_t		mc_dspace;	/* total deflated space */
	uint64_t		mc_histogram[RANGE_TREE_HISTOGRAM_SIZE];
	kmutex_t		mc_fastwrite_lock;
};

/*
 * Metaslab groups encapsulate all the allocatable regions (i.e. metaslabs)
 * of a top-level vdev. They are linked togther to form a circular linked
 * list and can belong to only one metaslab class. Metaslab groups may become
 * ineligible for allocations for a number of reasons such as limited free
 * space, fragmentation, or going offline. When this happens the allocator will
 * simply find the next metaslab group in the linked list and attempt
 * to allocate from that group instead.
 */
struct metaslab_group {
	kmutex_t		mg_lock;
	avl_tree_t		mg_metaslab_tree;
	uint64_t		mg_aliquot;
	boolean_t		mg_allocatable;		/* can we allocate? */
	uint64_t		mg_free_capacity;	/* percentage free */
	int64_t			mg_bias;
	int64_t			mg_activation_count;
	metaslab_class_t	*mg_class;
	vdev_t			*mg_vd;
	taskq_t			*mg_taskq;
	metaslab_group_t	*mg_prev;
	metaslab_group_t	*mg_next;
	uint64_t		mg_fragmentation;
	uint64_t		mg_histogram[RANGE_TREE_HISTOGRAM_SIZE];
};

/*
 * This value defines the number of elements in the ms_lbas array. The value
 * of 64 was chosen as it covers all power of 2 buckets up to UINT64_MAX.
 * This is the equivalent of highbit(UINT64_MAX).
 */
#define	MAX_LBAS	64

/*
 * Each metaslab maintains a set of in-core trees to track metaslab operations.
 * The in-core free tree (ms_tree) contains the current list of free segments.
 * As blocks are allocated, the allocated segment are removed from the ms_tree
 * and added to a per txg allocation tree (ms_alloctree). As blocks are freed,
 * they are added to the per txg free tree (ms_freetree). These per txg
 * trees allow us to process all allocations and frees in syncing context
 * where it is safe to update the on-disk space maps. One additional in-core
 * tree is maintained to track deferred frees (ms_defertree). Once a block
 * is freed it will move from the ms_freetree to the ms_defertree. A deferred
 * free means that a block has been freed but cannot be used by the pool
 * until TXG_DEFER_SIZE transactions groups later. For example, a block
 * that is freed in txg 50 will not be available for reallocation until
 * txg 52 (50 + TXG_DEFER_SIZE).  This provides a safety net for uberblock
 * rollback. A pool could be safely rolled back TXG_DEFERS_SIZE
 * transactions groups and ensure that no block has been reallocated.
 *
 * The simplified transition diagram looks like this:
 *
 *
 *      ALLOCATE
 *         |
 *         V
 *    free segment (ms_tree) --------> ms_alloctree ----> (write to space map)
 *         ^
 *         |
 *         |                           ms_freetree <--- FREE
 *         |                                 |
 *         |                                 |
 *         |                                 |
 *         +----------- ms_defertree <-------+---------> (write to space map)
 *
 *
 * Each metaslab's space is tracked in a single space map in the MOS,
 * which is only updated in syncing context. Each time we sync a txg,
 * we append the allocs and frees from that txg to the space map.
 * The pool space is only updated once all metaslabs have finished syncing.
 *
 * To load the in-core free tree we read the space map from disk.
 * This object contains a series of alloc and free records that are
 * combined to make up the list of all free segments in this metaslab. These
 * segments are represented in-core by the ms_tree and are stored in an
 * AVL tree.
 *
 * As the space map grows (as a result of the appends) it will
 * eventually become space-inefficient. When the metaslab's in-core free tree
 * is zfs_condense_pct/100 times the size of the minimal on-disk
 * representation, we rewrite it in its minimized form. If a metaslab
 * needs to condense then we must set the ms_condensing flag to ensure
 * that allocations are not performed on the metaslab that is being written.
 */
struct metaslab {
	kmutex_t	ms_lock;
	kcondvar_t	ms_load_cv;
	space_map_t	*ms_sm;
	metaslab_ops_t	*ms_ops;
	uint64_t	ms_id;
	uint64_t	ms_start;
	uint64_t	ms_size;
	uint64_t	ms_fragmentation;

	range_tree_t	*ms_alloctree[TXG_SIZE];
	range_tree_t	*ms_freetree[TXG_SIZE];
	range_tree_t	*ms_defertree[TXG_DEFER_SIZE];
	range_tree_t	*ms_tree;

	boolean_t	ms_condensing;	/* condensing? */
	boolean_t	ms_condense_wanted;
	boolean_t	ms_loaded;
	boolean_t	ms_loading;

	int64_t		ms_deferspace;	/* sum of ms_defermap[] space	*/
	uint64_t	ms_weight;	/* weight vs. others in group	*/
	uint64_t	ms_access_txg;

	/*
	 * The metaslab block allocators can optionally use a size-ordered
	 * range tree and/or an array of LBAs. Not all allocators use
	 * this functionality. The ms_size_tree should always contain the
	 * same number of segments as the ms_tree. The only difference
	 * is that the ms_size_tree is ordered by segment sizes.
	 */
	avl_tree_t	ms_size_tree;
	uint64_t	ms_lbas[MAX_LBAS];

	metaslab_group_t *ms_group;	/* metaslab group		*/
	avl_node_t	ms_group_node;	/* node in metaslab group tree	*/
	txg_node_t	ms_txg_node;	/* per-txg dirty metaslab links	*/
};

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_METASLAB_IMPL_H */
                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/sys/mntent.h                                                            0100644 0000000 0000000 00000012016 13045171016 016177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 *	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
 *		All Rights Reserved
 */

#ifndef _SYS_MNTENT_H
#define	_SYS_MNTENT_H

#define	MNTTYPE_ZFS	"zfs"		/* ZFS file system */

#define	MOUNT_SUCCESS	0x00		/* Success */
#define	MOUNT_USAGE	0x01		/* Invalid invocation or permissions */
#define	MOUNT_SYSERR	0x02		/* System error (ENOMEM, etc) */
#define	MOUNT_SOFTWARE	0x04		/* Internal mount bug */
#define	MOUNT_USER	0x08		/* Interrupted by user (EINTR) */
#define	MOUNT_FILEIO	0x10		/* Error updating/locking /etc/mtab */
#define	MOUNT_FAIL	0x20		/* Mount failed */
#define	MOUNT_SOMEOK	0x40		/* At least on mount succeeded */
#define	MOUNT_BUSY	0x80		/* Mount failed due to EBUSY */

#define	MNTOPT_ASYNC	"async"		/* all I/O is asynchronous */
#define	MNTOPT_ATIME	"atime"		/* update atime for files */
#define	MNTOPT_NOATIME	"noatime"	/* do not update atime for files */
#define	MNTOPT_AUTO	"auto"		/* automount */
#define	MNTOPT_NOAUTO	"noauto"	/* do not automount */
#define	MNTOPT_CONTEXT	"context"	/* selinux context */
#define	MNTOPT_FSCONTEXT "fscontext"	/* selinux fscontext */
#define	MNTOPT_DEFCONTEXT "defcontext"	/* selinux defcontext */
#define	MNTOPT_ROOTCONTEXT "rootcontext" /* selinux rootcontext */
#define	MNTOPT_DEFAULTS	"defaults"	/* defaults */
#define	MNTOPT_DEVICES	"dev"		/* device-special allowed */
#define	MNTOPT_NODEVICES "nodev"	/* device-special disallowed */
#define	MNTOPT_DIRATIME	"diratime"	/* update atime for dirs */
#define	MNTOPT_NODIRATIME "nodiratime"	/* do not update atime for dirs */
#define	MNTOPT_DIRSYNC	"dirsync"	/* do dir updates synchronously */
#define	MNTOPT_EXEC	"exec"		/* enable executables */
#define	MNTOPT_NOEXEC	"noexec"	/* disable executables */
#define	MNTOPT_GROUP	"group"		/* allow group mount */
#define	MNTOPT_NOGROUP	"nogroup"	/* do not allow group mount */
#define	MNTOPT_IVERSION	"iversion"	/* update inode version */
#define	MNTOPT_NOIVERSION "noiversion"	/* do not update inode version */
#define	MNTOPT_NBMAND	"mand"		/* allow non-blocking mandatory locks */
#define	MNTOPT_NONBMAND	"nomand"	/* deny non-blocking mandatory locks */
#define	MNTOPT_NETDEV	"_netdev"	/* network device */
#define	MNTOPT_NOFAIL	"nofail"	/* no failure */
#define	MNTOPT_RELATIME	"relatime"	/* allow relative time updates */
#define	MNTOPT_NORELATIME "norelatime"	/* do not allow relative time updates */
#define	MNTOPT_STRICTATIME "strictatime" /* strict access time updates */
#define	MNTOPT_NOSTRICTATIME "nostrictatime" /* No strict access time updates */
#define	MNTOPT_LAZYTIME "lazytime"	/* Defer access time writing */
#define	MNTOPT_SETUID	"suid"		/* Both setuid and devices allowed */
#define	MNTOPT_NOSETUID	"nosuid"	/* Neither setuid nor devices allowed */
#define	MNTOPT_OWNER	"owner"		/* allow owner mount */
#define	MNTOPT_NOOWNER	"noowner"	/* do not allow owner mount */
#define	MNTOPT_REMOUNT	"remount"	/* change mount options */
#define	MNTOPT_RO	"ro"		/* read only */
#define	MNTOPT_RW	"rw"		/* read/write */
#define	MNTOPT_SYNC	"sync"		/* all I/O is synchronous */
#define	MNTOPT_USER	"user"		/* allow user mount */
#define	MNTOPT_NOUSER	"nouser"	/* do not allow user mount */
#define	MNTOPT_USERS	"users"		/* allow user mount */
#define	MNTOPT_NOUSERS	"nousers"	/* do not allow user mount */
#define	MNTOPT_SUB	"sub"		/* allow mounts on subdirs */
#define	MNTOPT_NOSUB	"nosub"		/* do not allow mounts on subdirs */
#define	MNTOPT_QUIET	"quiet"		/* quiet mount */
#define	MNTOPT_LOUD	"loud"		/* verbose mount */
#define	MNTOPT_BIND	"bind"		/* remount part of a tree */
#define	MNTOPT_RBIND	"rbind"		/* include subtrees */
#define	MNTOPT_DIRXATTR	"dirxattr"	/* enable directory xattrs */
#define	MNTOPT_SAXATTR	"saxattr"	/* enable system-attribute xattrs */
#define	MNTOPT_XATTR	"xattr"		/* enable extended attributes */
#define	MNTOPT_NOXATTR	"noxattr"	/* disable extended attributes */
#define	MNTOPT_COMMENT	"comment"	/* comment */
#define	MNTOPT_ZFSUTIL	"zfsutil"	/* called by zfs utility */
#define	MNTOPT_ACL	"acl"		/* passed by util-linux-2.24 mount */
#define	MNTOPT_NOACL	"noacl"		/* likewise */
#define	MNTOPT_POSIXACL	"posixacl"	/* likewise */
#define	MNTOPT_MNTPOINT	"mntpoint"	/* mount point hint */

#endif	/* _SYS_MNTENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/src/zfs-0.6.5.9/include/sys/multilist.h                                                         0100644 0000000 0000000 00000006151 13045171016 016723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * This file and its contents are supplied under the terms of the
 * Common Development and Distribution License ("CDDL"), version 1.0.
 * You may only use this file in accordance with the terms of version
 * 1.0 of the CDDL.
 *
 * A full copy of the text of the CDDL should have accompanied this
 * source.  A copy of the CDDL is also available via the Internet at
 * http://www.illumos.org/license/CDDL.
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2013, 2014 by Delphix. All rights reserved.
 */

#ifndef	_SYS_MULTILIST_H
#define	_SYS_MULTILIST_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef list_node_t multilist_node_t;
typedef struct multilist multilist_t;
typedef struct multilist_sublist multilist_sublist_t;
typedef unsigned int multilist_sublist_index_func_t(multilist_t *, void *);

struct multilist_sublist {
	/*
	 * The mutex used internally to implement thread safe insertions
	 * and removals to this individual sublist. It can also be locked
	 * by a consumer using multilist_sublist_{lock,unlock}, which is
	 * useful if a consumer needs to traverse the list in a thread
	 * safe manner.
	 */
	kmutex_t	mls_lock;
	/*
	 * The actual list object containing all objects in this sublist.
	 */
	list_t		mls_list;
	/*
	 * Pad to cache line, in an effort to try and prevent cache line
	 * contention.
	 */
} ____cacheline_aligned;

struct multilist {
	/*
	 * This is used to get to the multilist_node_t structure given
	 * the void *object contained on the list.
	 */
	size_t				ml_offset;
	/*
	 * The number of sublists used internally by this multilist.
	 */
	uint64_t			ml_num_sublists;
	/*
	 * The array of pointers to the actual sublists.
	 */
	multilist_sublist_t		*ml_sublists;
	/*
	 * Pointer to function which determines the sublist to use
	 * when inserting and removing objects from this multilist.
	 * Please see the comment above multilist_create for details.
	 */
	multilist_sublist_index_func_t	*ml_index_func;
};

void multilist_destroy(multilist_t *);
void multilist_create(multilist_t *, size_t, size_t, unsigned int,
    multilist_sublist_index_func_t *);

void multilist_insert(multilist_t *, void *);
void multilist_remove(multilist_t *, void *);
int  multilist_is_empty(multilist_t *);

unsigned int multilist_get_num_sublists(multilist_t *);
unsigned int multilist_get_random_index(multilist_t *);

multilist_sublist_t *multilist_sublist_lock(multilist_t *, unsigned int);
void multilist_sublist_unlock(multilist_sublist_t *);

void multilist_sublist_insert_head(multilist_sublist_t *, void *);
void multilist_sublist_insert_tail(multilist_sublist_t *, void *);
void multilist_sublist_move_forward(multilist_sublist_t *mls, void *obj);
void multilist_sublist_remove(multilist_sublist_t *, void *);

void *multilist_sublist_head(multilist_sublist_t *);
void *multilist_sublist_tail(multilist_sublist_t *);
void *multilist_sublist_next(multilist_sublist_t *, void *);
void *multilist_sublist_prev(multilist_sublist_t *, void *);

void multilist_link_init(multilist_node_t *);
int  multilist_link_active(multilist_node_t *);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_MULTILIST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                       usr/src/zfs-0.6.5.9/include/sys/nvpair.h                                                            0100644 0000000 0000000 00000034201 13045171016 016171  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

#ifndef	_SYS_NVPAIR_H
#define	_SYS_NVPAIR_H

#include <sys/types.h>
#include <sys/time.h>
#include <sys/errno.h>
#include <sys/va_list.h>

#if defined(_KERNEL) && !defined(_BOOT)
#include <sys/kmem.h>
#endif

#ifdef	__cplusplus
extern "C" {
#endif

typedef enum {
	DATA_TYPE_UNKNOWN = 0,
	DATA_TYPE_BOOLEAN,
	DATA_TYPE_BYTE,
	DATA_TYPE_INT16,
	DATA_TYPE_UINT16,
	DATA_TYPE_INT32,
	DATA_TYPE_UINT32,
	DATA_TYPE_INT64,
	DATA_TYPE_UINT64,
	DATA_TYPE_STRING,
	DATA_TYPE_BYTE_ARRAY,
	DATA_TYPE_INT16_ARRAY,
	DATA_TYPE_UINT16_ARRAY,
	DATA_TYPE_INT32_ARRAY,
	DATA_TYPE_UINT32_ARRAY,
	DATA_TYPE_INT64_ARRAY,
	DATA_TYPE_UINT64_ARRAY,
	DATA_TYPE_STRING_ARRAY,
	DATA_TYPE_HRTIME,
	DATA_TYPE_NVLIST,
	DATA_TYPE_NVLIST_ARRAY,
	DATA_TYPE_BOOLEAN_VALUE,
	DATA_TYPE_INT8,
	DATA_TYPE_UINT8,
	DATA_TYPE_BOOLEAN_ARRAY,
	DATA_TYPE_INT8_ARRAY,
#if !defined(_KERNEL)
	DATA_TYPE_UINT8_ARRAY,
	DATA_TYPE_DOUBLE
#else
	DATA_TYPE_UINT8_ARRAY
#endif
} data_type_t;

typedef struct nvpair {
	int32_t nvp_size;	/* size of this nvpair */
	int16_t	nvp_name_sz;	/* length of name string */
	int16_t	nvp_reserve;	/* not used */
	int32_t	nvp_value_elem;	/* number of elements for array types */
	data_type_t nvp_type;	/* type of value */
	/* name string */
	/* aligned ptr array for string arrays */
	/* aligned array of data for value */
} nvpair_t;

/* nvlist header */
typedef struct nvlist {
	int32_t		nvl_version;
	uint32_t	nvl_nvflag;	/* persistent flags */
	uint64_t	nvl_priv;	/* ptr to private data if not packed */
	uint32_t	nvl_flag;
	int32_t		nvl_pad;	/* currently not used, for alignment */
} nvlist_t;

/* nvp implementation version */
#define	NV_VERSION	0

/* nvlist pack encoding */
#define	NV_ENCODE_NATIVE	0
#define	NV_ENCODE_XDR		1

/* nvlist persistent unique name flags, stored in nvl_nvflags */
#define	NV_UNIQUE_NAME		0x1
#define	NV_UNIQUE_NAME_TYPE	0x2

/* nvlist lookup pairs related flags */
#define	NV_FLAG_NOENTOK		0x1

/* convenience macros */
#define	NV_ALIGN(x)		(((ulong_t)(x) + 7ul) & ~7ul)
#define	NV_ALIGN4(x)		(((x) + 3) & ~3)

#define	NVP_SIZE(nvp)		((nvp)->nvp_size)
#define	NVP_NAME(nvp)		((char *)(nvp) + sizeof (nvpair_t))
#define	NVP_TYPE(nvp)		((nvp)->nvp_type)
#define	NVP_NELEM(nvp)		((nvp)->nvp_value_elem)
#define	NVP_VALUE(nvp)		((char *)(nvp) + NV_ALIGN(sizeof (nvpair_t) \
				+ (nvp)->nvp_name_sz))

#define	NVL_VERSION(nvl)	((nvl)->nvl_version)
#define	NVL_SIZE(nvl)		((nvl)->nvl_size)
#define	NVL_FLAG(nvl)		((nvl)->nvl_flag)

/* NV allocator framework */
typedef struct nv_alloc_ops nv_alloc_ops_t;

typedef struct nv_alloc {
	const nv_alloc_ops_t *nva_ops;
	void *nva_arg;
} nv_alloc_t;

struct nv_alloc_ops {
	int (*nv_ao_init)(nv_alloc_t *, va_list);
	void (*nv_ao_fini)(nv_alloc_t *);
	void *(*nv_ao_alloc)(nv_alloc_t *, size_t);
	void (*nv_ao_free)(nv_alloc_t *, void *, size_t);
	void (*nv_ao_reset)(nv_alloc_t *);
};

extern const nv_alloc_ops_t *nv_fixed_ops;
extern nv_alloc_t *nv_alloc_nosleep;

#if defined(_KERNEL) && !defined(_BOOT)
extern nv_alloc_t *nv_alloc_sleep;
extern nv_alloc_t *nv_alloc_pushpage;
#endif

int nv_alloc_init(nv_alloc_t *, const nv_alloc_ops_t *, /* args */ ...);
void nv_alloc_reset(nv_alloc_t *);
void nv_alloc_fini(nv_alloc_t *);

/* list management */
int nvlist_alloc(nvlist_t **, uint_t, int);
void nvlist_free(nvlist_t *);
int nvlist_size(nvlist_t *, size_t *, int);
int nvlist_pack(nvlist_t *, char **, size_t *, int, int);
int nvlist_unpack(char *, size_t, nvlist_t **, int);
int nvlist_dup(nvlist_t *, nvlist_t **, int);
int nvlist_merge(nvlist_t *, nvlist_t *, int);

uint_t nvlist_nvflag(nvlist_t *);

int nvlist_xalloc(nvlist_t **, uint_t, nv_alloc_t *);
int nvlist_xpack(nvlist_t *, char **, size_t *, int, nv_alloc_t *);
int nvlist_xunpack(char *, size_t, nvlist_t **, nv_alloc_t *);
int nvlist_xdup(nvlist_t *, nvlist_t **, nv_alloc_t *);
nv_alloc_t *nvlist_lookup_nv_alloc(nvlist_t *);

int nvlist_add_nvpair(nvlist_t *, nvpair_t *);
int nvlist_add_boolean(nvlist_t *, const char *);
int nvlist_add_boolean_value(nvlist_t *, const char *, boolean_t);
int nvlist_add_byte(nvlist_t *, const char *, uchar_t);
int nvlist_add_int8(nvlist_t *, const char *, int8_t);
int nvlist_add_uint8(nvlist_t *, const char *, uint8_t);
int nvlist_add_int16(nvlist_t *, const char *, int16_t);
int nvlist_add_uint16(nvlist_t *, const char *, uint16_t);
int nvlist_add_int32(nvlist_t *, const char *, int32_t);
int nvlist_add_uint32(nvlist_t *, const char *, uint32_t);
int nvlist_add_int64(nvlist_t *, const char *, int64_t);
int nvlist_add_uint64(nvlist_t *, const char *, uint64_t);
int nvlist_add_string(nvlist_t *, const char *, const char *);
int nvlist_add_nvlist(nvlist_t *, const char *, nvlist_t *);
int nvlist_add_boolean_array(nvlist_t *, const char *, boolean_t *, uint_t);
int nvlist_add_byte_array(nvlist_t *, const char *, uchar_t *, uint_t);
int nvlist_add_int8_array(nvlist_t *, const char *, int8_t *, uint_t);
int nvlist_add_uint8_array(nvlist_t *, const char *, uint8_t *, uint_t);
int nvlist_add_int16_array(nvlist_t *, const char *, int16_t *, uint_t);
int nvlist_add_uint16_array(nvlist_t *, const char *, uint16_t *, uint_t);
int nvlist_add_int32_array(nvlist_t *, const char *, int32_t *, uint_t);
int nvlist_add_uint32_array(nvlist_t *, const char *, uint32_t *, uint_t);
int nvlist_add_int64_array(nvlist_t *, const char *, int64_t *, uint_t);
int nvlist_add_uint64_array(nvlist_t *, const char *, uint64_t *, uint_t);
int nvlist_add_string_array(nvlist_t *, const char *, char *const *, uint_t);
int nvlist_add_nvlist_array(nvlist_t *, const char *, nvlist_t **, uint_t);
int nvlist_add_hrtime(nvlist_t *, const char *, hrtime_t);
#if !defined(_KERNEL)
int nvlist_add_double(nvlist_t *, const char *, double);
#endif

int nvlist_remove(nvlist_t *, const char *, data_type_t);
int nvlist_remove_all(nvlist_t *, const char *);
int nvlist_remove_nvpair(nvlist_t *, nvpair_t *);

int nvlist_lookup_boolean(nvlist_t *, const char *);
int nvlist_lookup_boolean_value(nvlist_t *, const char *, boolean_t *);
int nvlist_lookup_byte(nvlist_t *, const char *, uchar_t *);
int nvlist_lookup_int8(nvlist_t *, const char *, int8_t *);
int nvlist_lookup_uint8(nvlist_t *, const char *, uint8_t *);
int nvlist_lookup_int16(nvlist_t *, const char *, int16_t *);
int nvlist_lookup_uint16(nvlist_t *, const char *, uint16_t *);
int nvlist_lookup_int32(nvlist_t *, const char *, int32_t *);
int nvlist_lookup_uint32(nvlist_t *, const char *, uint32_t *);
int nvlist_lookup_int64(nvlist_t *, const char *, int64_t *);
int nvlist_lookup_uint64(nvlist_t *, const char *, uint64_t *);
int nvlist_lookup_string(nvlist_t *, const char *, char **);
int nvlist_lookup_nvlist(nvlist_t *, const char *, nvlist_t **);
int nvlist_lookup_boolean_array(nvlist_t *, const char *,
    boolean_t **, uint_t *);
int nvlist_lookup_byte_array(nvlist_t *, const char *, uchar_t **, uint_t *);
int nvlist_lookup_int8_array(nvlist_t *, const char *, int8_t **, uint_t *);
int nvlist_lookup_uint8_array(nvlist_t *, const char *, uint8_t **, uint_t *);
int nvlist_lookup_int16_array(nvlist_t *, const char *, int16_t **, uint_t *);
int nvlist_lookup_uint16_array(nvlist_t *, const char *, uint16_t **, uint_t *);
int nvlist_lookup_int32_array(nvlist_t *, const char *, int32_t **, uint_t *);
int nvlist_lookup_uint32_array(nvlist_t *, const char *, uint32_t **, uint_t *);
int nvlist_lookup_int64_array(nvlist_t *, const char *, int64_t **, uint_t *);
int nvlist_lookup_uint64_array(nvlist_t *, const char *, uint64_t **, uint_t *);
int nvlist_lookup_string_array(nvlist_t *, const char *, char ***, uint_t *);
int nvlist_lookup_nvlist_array(nvlist_t *, const char *,
    nvlist_t ***, uint_t *);
int nvlist_lookup_hrtime(nvlist_t *, const char *, hrtime_t *);
int nvlist_lookup_pairs(nvlist_t *, int, ...);
#if !defined(_KERNEL)
int nvlist_lookup_double(nvlist_t *, const char *, double *);
#endif

int nvlist_lookup_nvpair(nvlist_t *, const char *, nvpair_t **);
int nvlist_lookup_nvpair_embedded_index(nvlist_t *, const char *, nvpair_t **,
    int *, char **);
boolean_t nvlist_exists(nvlist_t *, const char *);
boolean_t nvlist_empty(nvlist_t *);

/* processing nvpair */
nvpair_t *nvlist_next_nvpair(nvlist_t *, nvpair_t *);
nvpair_t *nvlist_prev_nvpair(nvlist_t *, nvpair_t *);
char *nvpair_name(nvpair_t *);
data_type_t nvpair_type(nvpair_t *);
int nvpair_type_is_array(nvpair_t *);
int nvpair_value_boolean_value(nvpair_t *, boolean_t *);
int nvpair_value_byte(nvpair_t *, uchar_t *);
int nvpair_value_int8(nvpair_t *, int8_t *);
int nvpair_value_uint8(nvpair_t *, uint8_t *);
int nvpair_value_int16(nvpair_t *, int16_t *);
int nvpair_value_uint16(nvpair_t *, uint16_t *);
int nvpair_value_int32(nvpair_t *, int32_t *);
int nvpair_value_uint32(nvpair_t *, uint32_t *);
int nvpair_value_int64(nvpair_t *, int64_t *);
int nvpair_value_uint64(nvpair_t *, uint64_t *);
int nvpair_value_string(nvpair_t *, char **);
int nvpair_value_nvlist(nvpair_t *, nvlist_t **);
int nvpair_value_boolean_array(nvpair_t *, boolean_t **, uint_t *);
int nvpair_value_byte_array(nvpair_t *, uchar_t **, uint_t *);
int nvpair_value_int8_array(nvpair_t *, int8_t **, uint_t *);
int nvpair_value_uint8_array(nvpair_t *, uint8_t **, uint_t *);
int nvpair_value_int16_array(nvpair_t *, int16_t **, uint_t *);
int nvpair_value_uint16_array(nvpair_t *, uint16_t **, uint_t *);
int nvpair_value_int32_array(nvpair_t *, int32_t **, uint_t *);
int nvpair_value_uint32_array(nvpair_t *, uint32_t **, uint_t *);
int nvpair_value_int64_array(nvpair_t *, int64_t **, uint_t *);
int nvpair_value_uint64_array(nvpair_t *, uint64_t **, uint_t *);
int nvpair_value_string_array(nvpair_t *, char ***, uint_t *);
int nvpair_value_nvlist_array(nvpair_t *, nvlist_t ***, uint_t *);
int nvpair_value_hrtime(nvpair_t *, hrtime_t *);
#if !defined(_KERNEL)
int nvpair_value_double(nvpair_t *, double *);
#endif

nvlist_t *fnvlist_alloc(void);
void fnvlist_free(nvlist_t *);
size_t fnvlist_size(nvlist_t *);
char *fnvlist_pack(nvlist_t *, size_t *);
void fnvlist_pack_free(char *, size_t);
nvlist_t *fnvlist_unpack(char *, size_t);
nvlist_t *fnvlist_dup(nvlist_t *);
void fnvlist_merge(nvlist_t *, nvlist_t *);
size_t fnvlist_num_pairs(nvlist_t *);

void fnvlist_add_boolean(nvlist_t *, const char *);
void fnvlist_add_boolean_value(nvlist_t *, const char *, boolean_t);
void fnvlist_add_byte(nvlist_t *, const char *, uchar_t);
void fnvlist_add_int8(nvlist_t *, const char *, int8_t);
void fnvlist_add_uint8(nvlist_t *, const char *, uint8_t);
void fnvlist_add_int16(nvlist_t *, const char *, int16_t);
void fnvlist_add_uint16(nvlist_t *, const char *, uint16_t);
void fnvlist_add_int32(nvlist_t *, const char *, int32_t);
void fnvlist_add_uint32(nvlist_t *, const char *, uint32_t);
void fnvlist_add_int64(nvlist_t *, const char *, int64_t);
void fnvlist_add_uint64(nvlist_t *, const char *, uint64_t);
void fnvlist_add_string(nvlist_t *, const char *, const char *);
void fnvlist_add_nvlist(nvlist_t *, const char *, nvlist_t *);
void fnvlist_add_nvpair(nvlist_t *, nvpair_t *);
void fnvlist_add_boolean_array(nvlist_t *, const char *, boolean_t *, uint_t);
void fnvlist_add_byte_array(nvlist_t *, const char *, uchar_t *, uint_t);
void fnvlist_add_int8_array(nvlist_t *, const char *, int8_t *, uint_t);
void fnvlist_add_uint8_array(nvlist_t *, const char *, uint8_t *, uint_t);
void fnvlist_add_int16_array(nvlist_t *, const char *, int16_t *, uint_t);
void fnvlist_add_uint16_array(nvlist_t *, const char *, uint16_t *, uint_t);
void fnvlist_add_int32_array(nvlist_t *, const char *, int32_t *, uint_t);
void fnvlist_add_uint32_array(nvlist_t *, const char *, uint32_t *, uint_t);
void fnvlist_add_int64_array(nvlist_t *, const char *, int64_t *, uint_t);
void fnvlist_add_uint64_array(nvlist_t *, const char *, uint64_t *, uint_t);
void fnvlist_add_string_array(nvlist_t *, const char *, char * const *, uint_t);
void fnvlist_add_nvlist_array(nvlist_t *, const char *, nvlist_t **, uint_t);

void fnvlist_remove(nvlist_t *, const char *);
void fnvlist_remove_nvpair(nvlist_t *, nvpair_t *);

nvpair_t *fnvlist_lookup_nvpair(nvlist_t *nvl, const char *name);
boolean_t fnvlist_lookup_boolean(nvlist_t *nvl, const char *name);
boolean_t fnvlist_lookup_boolean_value(nvlist_t *nvl, const char *name);
uchar_t fnvlist_lookup_byte(nvlist_t *nvl, const char *name);
int8_t fnvlist_lookup_int8(nvlist_t *nvl, const char *name);
int16_t fnvlist_lookup_int16(nvlist_t *nvl, const char *name);
int32_t fnvlist_lookup_int32(nvlist_t *nvl, const char *name);
int64_t fnvlist_lookup_int64(nvlist_t *nvl, const char *name);
uint8_t fnvlist_lookup_uint8(nvlist_t *nvl, const char *name);
uint16_t fnvlist_lookup_uint16(nvlist_t *nvl, const char *name);
uint32_t fnvlist_lookup_uint32(nvlist_t *nvl, const char *name);
uint64_t fnvlist_lookup_uint64(nvlist_t *nvl, const char *name);
char *fnvlist_lookup_string(nvlist_t *nvl, const char *name);
nvlist_t *fnvlist_lookup_nvlist(nvlist_t *nvl, const char *name);

boolean_t fnvpair_value_boolean_value(nvpair_t *nvp);
uchar_t fnvpair_value_byte(nvpair_t *nvp);
int8_t fnvpair_value_int8(nvpair_t *nvp);
int16_t fnvpair_value_int16(nvpair_t *nvp);
int32_t fnvpair_value_int32(nvpair_t *nvp);
int64_t fnvpair_value_int64(nvpair_t *nvp);
uint8_t fnvpair_value_uint8(nvpair_t *nvp);
uint16_t fnvpair_value_uint16(nvpair_t *nvp);
uint32_t fnvpair_value_uint32(nvpair_t *nvp);
uint64_t fnvpair_value_uint64(nvpair_t *nvp);
char *fnvpair_value_string(nvpair_t *nvp);
nvlist_t *fnvpair_value_nvlist(nvpair_t *nvp);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_NVPAIR_H */
                                                                                                                                                                                                                                                                                                                                                                                               usr/src/zfs-0.6.5.9/include/sys/nvpair_impl.h                                                       0100644 0000000 0000000 00000003563 13045171016 017221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_NVPAIR_IMPL_H
#define	_NVPAIR_IMPL_H



#ifdef __cplusplus
extern "C" {
#endif

#include <sys/nvpair.h>

/*
 * The structures here provided for information and debugging purposes only
 * may be changed in the future.
 */

/*
 * implementation linked list for pre-packed data
 */
typedef struct i_nvp i_nvp_t;

struct i_nvp {
	union {
		uint64_t	_nvi_align;	/* ensure alignment */
		struct {
			i_nvp_t	*_nvi_next;	/* pointer to next nvpair */
			i_nvp_t	*_nvi_prev;	/* pointer to prev nvpair */
		} _nvi;
	} _nvi_un;
	nvpair_t nvi_nvp;			/* nvpair */
};
#define	nvi_next	_nvi_un._nvi._nvi_next
#define	nvi_prev	_nvi_un._nvi._nvi_prev

typedef struct {
	i_nvp_t		*nvp_list;	/* linked list of nvpairs */
	i_nvp_t		*nvp_last;	/* last nvpair */
	i_nvp_t		*nvp_curr;	/* current walker nvpair */
	nv_alloc_t	*nvp_nva;	/* pluggable allocator */
	uint32_t	nvp_stat;	/* internal state */
} nvpriv_t;

#ifdef	__cplusplus
}
#endif

#endif	/* _NVPAIR_IMPL_H */
                                                                                                                                             usr/src/zfs-0.6.5.9/include/sys/range_tree.h                                                        0100644 0000000 0000000 00000006313 13045171016 017010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 2013, 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_RANGE_TREE_H
#define	_SYS_RANGE_TREE_H

#include <sys/avl.h>
#include <sys/dmu.h>

#ifdef	__cplusplus
extern "C" {
#endif

#define	RANGE_TREE_HISTOGRAM_SIZE	64

typedef struct range_tree_ops range_tree_ops_t;

typedef struct range_tree {
	avl_tree_t	rt_root;	/* offset-ordered segment AVL tree */
	uint64_t	rt_space;	/* sum of all segments in the map */
	range_tree_ops_t *rt_ops;
	void		*rt_arg;

	/*
	 * The rt_histogram maintains a histogram of ranges. Each bucket,
	 * rt_histogram[i], contains the number of ranges whose size is:
	 * 2^i <= size of range in bytes < 2^(i+1)
	 */
	uint64_t	rt_histogram[RANGE_TREE_HISTOGRAM_SIZE];
	kmutex_t	*rt_lock;	/* pointer to lock that protects map */
} range_tree_t;

typedef struct range_seg {
	avl_node_t	rs_node;	/* AVL node */
	avl_node_t	rs_pp_node;	/* AVL picker-private node */
	uint64_t	rs_start;	/* starting offset of this segment */
	uint64_t	rs_end;		/* ending offset (non-inclusive) */
} range_seg_t;

struct range_tree_ops {
	void    (*rtop_create)(range_tree_t *rt, void *arg);
	void    (*rtop_destroy)(range_tree_t *rt, void *arg);
	void	(*rtop_add)(range_tree_t *rt, range_seg_t *rs, void *arg);
	void    (*rtop_remove)(range_tree_t *rt, range_seg_t *rs, void *arg);
	void	(*rtop_vacate)(range_tree_t *rt, void *arg);
};

typedef void range_tree_func_t(void *arg, uint64_t start, uint64_t size);

void range_tree_init(void);
void range_tree_fini(void);
range_tree_t *range_tree_create(range_tree_ops_t *ops, void *arg, kmutex_t *lp);
void range_tree_destroy(range_tree_t *rt);
boolean_t range_tree_contains(range_tree_t *rt, uint64_t start, uint64_t size);
uint64_t range_tree_space(range_tree_t *rt);
void range_tree_verify(range_tree_t *rt, uint64_t start, uint64_t size);
void range_tree_swap(range_tree_t **rtsrc, range_tree_t **rtdst);
void range_tree_stat_verify(range_tree_t *rt);

void range_tree_add(void *arg, uint64_t start, uint64_t size);
void range_tree_remove(void *arg, uint64_t start, uint64_t size);
void range_tree_clear(range_tree_t *rt, uint64_t start, uint64_t size);

void range_tree_vacate(range_tree_t *rt, range_tree_func_t *func, void *arg);
void range_tree_walk(range_tree_t *rt, range_tree_func_t *func, void *arg);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_RANGE_TREE_H */
                                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/include/sys/refcount.h                                                          0100644 0000000 0000000 00000006463 13045171016 016530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_REFCOUNT_H
#define	_SYS_REFCOUNT_H

#include <sys/inttypes.h>
#include <sys/list.h>
#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * If the reference is held only by the calling function and not any
 * particular object, use FTAG (which is a string) for the holder_tag.
 * Otherwise, use the object that holds the reference.
 */
#define	FTAG ((char *)__func__)

#ifdef	ZFS_DEBUG
typedef struct reference {
	list_node_t ref_link;
	void *ref_holder;
	uint64_t ref_number;
	uint8_t *ref_removed;
} reference_t;

typedef struct refcount {
	kmutex_t rc_mtx;
	boolean_t rc_tracked;
	list_t rc_list;
	list_t rc_removed;
	int64_t rc_count;
	int64_t rc_removed_count;
} refcount_t;

/* Note: refcount_t must be initialized with refcount_create[_untracked]() */

void refcount_create(refcount_t *rc);
void refcount_create_untracked(refcount_t *rc);
void refcount_destroy(refcount_t *rc);
void refcount_destroy_many(refcount_t *rc, uint64_t number);
int refcount_is_zero(refcount_t *rc);
int64_t refcount_count(refcount_t *rc);
int64_t refcount_add(refcount_t *rc, void *holder_tag);
int64_t refcount_remove(refcount_t *rc, void *holder_tag);
int64_t refcount_add_many(refcount_t *rc, uint64_t number, void *holder_tag);
int64_t refcount_remove_many(refcount_t *rc, uint64_t number, void *holder_tag);
void refcount_transfer(refcount_t *dst, refcount_t *src);

void refcount_init(void);
void refcount_fini(void);

#else	/* ZFS_DEBUG */

typedef struct refcount {
	uint64_t rc_count;
} refcount_t;

#define	refcount_create(rc) ((rc)->rc_count = 0)
#define	refcount_create_untracked(rc) ((rc)->rc_count = 0)
#define	refcount_destroy(rc) ((rc)->rc_count = 0)
#define	refcount_destroy_many(rc, number) ((rc)->rc_count = 0)
#define	refcount_is_zero(rc) ((rc)->rc_count == 0)
#define	refcount_count(rc) ((rc)->rc_count)
#define	refcount_add(rc, holder) atomic_add_64_nv(&(rc)->rc_count, 1)
#define	refcount_remove(rc, holder) atomic_add_64_nv(&(rc)->rc_count, -1)
#define	refcount_add_many(rc, number, holder) \
	atomic_add_64_nv(&(rc)->rc_count, number)
#define	refcount_remove_many(rc, number, holder) \
	atomic_add_64_nv(&(rc)->rc_count, -number)
#define	refcount_transfer(dst, src) { \
	uint64_t __tmp = (src)->rc_count; \
	atomic_add_64(&(src)->rc_count, -__tmp); \
	atomic_add_64(&(dst)->rc_count, __tmp); \
}

#define	refcount_init()
#define	refcount_fini()

#endif	/* ZFS_DEBUG */

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_REFCOUNT_H */
                                                                                                                                                                                                             usr/src/zfs-0.6.5.9/include/sys/rrwlock.h                                                           0100644 0000000 0000000 00000006766 13045171016 016374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

#ifndef	_SYS_RR_RW_LOCK_H
#define	_SYS_RR_RW_LOCK_H



#ifdef	__cplusplus
extern "C" {
#endif

#include <sys/inttypes.h>
#include <sys/zfs_context.h>
#include <sys/refcount.h>

/*
 * A reader-writer lock implementation that allows re-entrant reads, but
 * still gives writers priority on "new" reads.
 *
 * See rrwlock.c for more details about the implementation.
 *
 * Fields of the rrwlock_t structure:
 * - rr_lock: protects modification and reading of rrwlock_t fields
 * - rr_cv: cv for waking up readers or waiting writers
 * - rr_writer: thread id of the current writer
 * - rr_anon_rount: number of active anonymous readers
 * - rr_linked_rcount: total number of non-anonymous active readers
 * - rr_writer_wanted: a writer wants the lock
 */
typedef struct rrwlock {
	kmutex_t	rr_lock;
	kcondvar_t	rr_cv;
	kthread_t	*rr_writer;
	refcount_t	rr_anon_rcount;
	refcount_t	rr_linked_rcount;
	boolean_t	rr_writer_wanted;
	boolean_t	rr_track_all;
} rrwlock_t;

/*
 * 'tag' is used in reference counting tracking.  The
 * 'tag' must be the same in a rrw_enter() as in its
 * corresponding rrw_exit().
 */
void rrw_init(rrwlock_t *rrl, boolean_t track_all);
void rrw_destroy(rrwlock_t *rrl);
void rrw_enter(rrwlock_t *rrl, krw_t rw, void *tag);
void rrw_enter_read(rrwlock_t *rrl, void *tag);
void rrw_enter_read_prio(rrwlock_t *rrl, void *tag);
void rrw_enter_write(rrwlock_t *rrl);
void rrw_exit(rrwlock_t *rrl, void *tag);
boolean_t rrw_held(rrwlock_t *rrl, krw_t rw);
void rrw_tsd_destroy(void *arg);

#define	RRW_READ_HELD(x)	rrw_held(x, RW_READER)
#define	RRW_WRITE_HELD(x)	rrw_held(x, RW_WRITER)
#define	RRW_LOCK_HELD(x) \
	(rrw_held(x, RW_WRITER) || rrw_held(x, RW_READER))

/*
 * A reader-mostly lock implementation, tuning above reader-writer locks
 * for hightly parallel read acquisitions, pessimizing write acquisitions.
 *
 * This should be a prime number.  See comment in rrwlock.c near
 * RRM_TD_LOCK() for details.
 */
#define	RRM_NUM_LOCKS		17
typedef struct rrmlock {
	rrwlock_t	locks[RRM_NUM_LOCKS];
} rrmlock_t;

void rrm_init(rrmlock_t *rrl, boolean_t track_all);
void rrm_destroy(rrmlock_t *rrl);
void rrm_enter(rrmlock_t *rrl, krw_t rw, void *tag);
void rrm_enter_read(rrmlock_t *rrl, void *tag);
void rrm_enter_write(rrmlock_t *rrl);
void rrm_exit(rrmlock_t *rrl, void *tag);
boolean_t rrm_held(rrmlock_t *rrl, krw_t rw);

#define	RRM_READ_HELD(x)	rrm_held(x, RW_READER)
#define	RRM_WRITE_HELD(x)	rrm_held(x, RW_WRITER)
#define	RRM_LOCK_HELD(x) \
	(rrm_held(x, RW_WRITER) || rrm_held(x, RW_READER))

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_RR_RW_LOCK_H */
          usr/src/zfs-0.6.5.9/include/sys/sa.h                                                                0100644 0000000 0000000 00000012326 13045171016 015301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_SA_H
#define	_SYS_SA_H

#include <sys/dmu.h>

/*
 * Currently available byteswap functions.
 * If it all possible new attributes should used
 * one of the already defined byteswap functions.
 * If a new byteswap function is added then the
 * ZPL/Pool version will need to be bumped.
 */

typedef enum sa_bswap_type {
	SA_UINT64_ARRAY,
	SA_UINT32_ARRAY,
	SA_UINT16_ARRAY,
	SA_UINT8_ARRAY,
	SA_ACL,
} sa_bswap_type_t;

typedef uint16_t	sa_attr_type_t;

/*
 * Attribute to register support for.
 */
typedef struct sa_attr_reg {
	char 			*sa_name;	/* attribute name */
	uint16_t 		sa_length;
	sa_bswap_type_t		sa_byteswap;	/* bswap functon enum */
	sa_attr_type_t 		sa_attr; /* filled in during registration */
} sa_attr_reg_t;


typedef void (sa_data_locator_t)(void **, uint32_t *, uint32_t,
    boolean_t, void *userptr);

/*
 * array of attributes to store.
 *
 * This array should be treated as opaque/private data.
 * The SA_BULK_ADD_ATTR() macro should be used for manipulating
 * the array.
 *
 * When sa_replace_all_by_template() is used the attributes
 * will be stored in the order defined in the array, except that
 * the attributes may be split between the bonus and the spill buffer
 *
 */
typedef struct sa_bulk_attr {
	void			*sa_data;
	sa_data_locator_t	*sa_data_func;
	uint16_t		sa_length;
	sa_attr_type_t		sa_attr;
	/* the following are private to the sa framework */
	void 			*sa_addr;
	uint16_t		sa_buftype;
	uint16_t		sa_size;
} sa_bulk_attr_t;

/*
 * The on-disk format of sa_hdr_phys_t limits SA lengths to 16-bit values.
 */
#define	SA_ATTR_MAX_LEN UINT16_MAX

/*
 * special macro for adding entries for bulk attr support
 * bulk - sa_bulk_attr_t
 * count - integer that will be incremented during each add
 * attr - attribute to manipulate
 * func - function for accessing data.
 * data - pointer to data.
 * len - length of data
 */

#define	SA_ADD_BULK_ATTR(b, idx, attr, func, data, len) \
{ \
	ASSERT3U(len, <=, SA_ATTR_MAX_LEN); \
	b[idx].sa_attr = attr;\
	b[idx].sa_data_func = func; \
	b[idx].sa_data = data; \
	b[idx++].sa_length = len; \
}

typedef struct sa_os sa_os_t;

typedef enum sa_handle_type {
	SA_HDL_SHARED,
	SA_HDL_PRIVATE
} sa_handle_type_t;

struct sa_handle;
typedef void *sa_lookup_tab_t;
typedef struct sa_handle sa_handle_t;

typedef void (sa_update_cb_t)(sa_handle_t *, dmu_tx_t *tx);

int sa_handle_get(objset_t *, uint64_t, void *userp,
    sa_handle_type_t, sa_handle_t **);
int sa_handle_get_from_db(objset_t *, dmu_buf_t *, void *userp,
    sa_handle_type_t, sa_handle_t **);
void sa_handle_destroy(sa_handle_t *);
int sa_buf_hold(objset_t *, uint64_t, void *, dmu_buf_t **);
void sa_buf_rele(dmu_buf_t *, void *);
int sa_lookup(sa_handle_t *, sa_attr_type_t, void *buf, uint32_t buflen);
int sa_update(sa_handle_t *, sa_attr_type_t, void *buf,
    uint32_t buflen, dmu_tx_t *);
int sa_remove(sa_handle_t *, sa_attr_type_t, dmu_tx_t *);
int sa_bulk_lookup(sa_handle_t *, sa_bulk_attr_t *, int count);
int sa_bulk_lookup_locked(sa_handle_t *, sa_bulk_attr_t *, int count);
int sa_bulk_update(sa_handle_t *, sa_bulk_attr_t *, int count, dmu_tx_t *);
int sa_size(sa_handle_t *, sa_attr_type_t, int *);
int sa_update_from_cb(sa_handle_t *, sa_attr_type_t,
    uint32_t buflen, sa_data_locator_t *, void *userdata, dmu_tx_t *);
void sa_object_info(sa_handle_t *, dmu_object_info_t *);
void sa_object_size(sa_handle_t *, uint32_t *, u_longlong_t *);
void *sa_get_userdata(sa_handle_t *);
void sa_set_userp(sa_handle_t *, void *);
dmu_buf_t *sa_get_db(sa_handle_t *);
uint64_t sa_handle_object(sa_handle_t *);
boolean_t sa_attr_would_spill(sa_handle_t *, sa_attr_type_t, int size);
void sa_spill_rele(sa_handle_t *);
void sa_register_update_callback(objset_t *, sa_update_cb_t *);
int sa_setup(objset_t *, uint64_t, sa_attr_reg_t *, int, sa_attr_type_t **);
void sa_tear_down(objset_t *);
int sa_replace_all_by_template(sa_handle_t *, sa_bulk_attr_t *,
    int, dmu_tx_t *);
int sa_replace_all_by_template_locked(sa_handle_t *, sa_bulk_attr_t *,
    int, dmu_tx_t *);
boolean_t sa_enabled(objset_t *);
void sa_cache_init(void);
void sa_cache_fini(void);
int sa_set_sa_object(objset_t *, uint64_t);
int sa_hdrsize(void *);
void sa_handle_lock(sa_handle_t *);
void sa_handle_unlock(sa_handle_t *);

#ifdef _KERNEL
int sa_lookup_uio(sa_handle_t *, sa_attr_type_t, uio_t *);
#endif

#ifdef	__cplusplus
extern "C" {
#endif


#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_SA_H */
                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/sys/sa_impl.h                                                           0100644 0000000 0000000 00000020431 13045171016 016316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_SA_IMPL_H
#define	_SYS_SA_IMPL_H

#include <sys/dmu.h>
#include <sys/refcount.h>
#include <sys/list.h>

/*
 * Array of known attributes and their
 * various characteristics.
 */
typedef struct sa_attr_table {
	sa_attr_type_t	sa_attr;
	uint8_t sa_registered;
	uint16_t sa_length;
	sa_bswap_type_t sa_byteswap;
	char *sa_name;
} sa_attr_table_t;

/*
 * Zap attribute format for attribute registration
 *
 * 64      56      48      40      32      24      16      8       0
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |        unused         |      len      | bswap |   attr num    |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * Zap attribute format for layout information.
 *
 * layout information is stored as an array of attribute numbers
 * The name of the attribute is the layout number (0, 1, 2, ...)
 *
 * 16       0
 * +---- ---+
 * | attr # |
 * +--------+
 * | attr # |
 * +--- ----+
 *  ......
 *
 */

#define	ATTR_BSWAP(x)	BF32_GET(x, 16, 8)
#define	ATTR_LENGTH(x)	BF32_GET(x, 24, 16)
#define	ATTR_NUM(x)	BF32_GET(x, 0, 16)
#define	ATTR_ENCODE(x, attr, length, bswap) \
{ \
	BF64_SET(x, 24, 16, length); \
	BF64_SET(x, 16, 8, bswap); \
	BF64_SET(x, 0, 16, attr); \
}

#define	TOC_OFF(x)		BF32_GET(x, 0, 23)
#define	TOC_ATTR_PRESENT(x)	BF32_GET(x, 31, 1)
#define	TOC_LEN_IDX(x)		BF32_GET(x, 24, 4)
#define	TOC_ATTR_ENCODE(x, len_idx, offset) \
{ \
	BF32_SET(x, 31, 1, 1); \
	BF32_SET(x, 24, 7, len_idx); \
	BF32_SET(x, 0, 24, offset); \
}

#define	SA_LAYOUTS	"LAYOUTS"
#define	SA_REGISTRY	"REGISTRY"

/*
 * Each unique layout will have their own table
 * sa_lot (layout_table)
 */
typedef struct sa_lot {
	avl_node_t lot_num_node;
	avl_node_t lot_hash_node;
	uint64_t lot_num;
	uint64_t lot_hash;
	sa_attr_type_t *lot_attrs;	/* array of attr #'s */
	uint32_t lot_var_sizes;	/* how many aren't fixed size */
	uint32_t lot_attr_count;	/* total attr count */
	list_t 	lot_idx_tab;	/* should be only a couple of entries */
	int	lot_instance;	/* used with lot_hash to identify entry */
} sa_lot_t;

/* index table of offsets */
typedef struct sa_idx_tab {
	list_node_t	sa_next;
	sa_lot_t	*sa_layout;
	uint16_t	*sa_variable_lengths;
	refcount_t	sa_refcount;
	uint32_t	*sa_idx_tab;	/* array of offsets */
} sa_idx_tab_t;

/*
 * Since the offset/index information into the actual data
 * will usually be identical we can share that information with
 * all handles that have the exact same offsets.
 *
 * You would typically only have a large number of different table of
 * contents if you had a several variable sized attributes.
 *
 * Two AVL trees are used to track the attribute layout numbers.
 * one is keyed by number and will be consulted when a DMU_OT_SA
 * object is first read.  The second tree is keyed by the hash signature
 * of the attributes and will be consulted when an attribute is added
 * to determine if we already have an instance of that layout.  Both
 * of these tree's are interconnected.  The only difference is that
 * when an entry is found in the "hash" tree the list of attributes will
 * need to be compared against the list of attributes you have in hand.
 * The assumption is that typically attributes will just be updated and
 * adding a completely new attribute is a very rare operation.
 */
struct sa_os {
	kmutex_t 	sa_lock;
	boolean_t	sa_need_attr_registration;
	boolean_t	sa_force_spill;
	uint64_t	sa_master_obj;
	uint64_t	sa_reg_attr_obj;
	uint64_t	sa_layout_attr_obj;
	int		sa_num_attrs;
	sa_attr_table_t *sa_attr_table;	 /* private attr table */
	sa_update_cb_t	*sa_update_cb;
	avl_tree_t	sa_layout_num_tree;  /* keyed by layout number */
	avl_tree_t	sa_layout_hash_tree; /* keyed by layout hash value */
	int		sa_user_table_sz;
	sa_attr_type_t	*sa_user_table; /* user name->attr mapping table */
};

/*
 * header for all bonus and spill buffers.
 *
 * The header has a fixed portion with a variable number
 * of "lengths" depending on the number of variable sized
 * attributes which are determined by the "layout number"
 */

#define	SA_MAGIC	0x2F505A  /* ZFS SA */
typedef struct sa_hdr_phys {
	uint32_t sa_magic;
	/*
	 * Encoded with hdrsize and layout number as follows:
	 * 16      10       0
	 * +--------+-------+
	 * | hdrsz  |layout |
	 * +--------+-------+
	 *
	 * Bits 0-10 are the layout number
	 * Bits 11-16 are the size of the header.
	 * The hdrsize is the number * 8
	 *
	 * For example.
	 * hdrsz of 1 ==> 8 byte header
	 *          2 ==> 16 byte header
	 *
	 */
	uint16_t sa_layout_info;
	uint16_t sa_lengths[1];	/* optional sizes for variable length attrs */
	/* ... Data follows the lengths.  */
} sa_hdr_phys_t;

#define	SA_HDR_LAYOUT_NUM(hdr) BF32_GET(hdr->sa_layout_info, 0, 10)
#define	SA_HDR_SIZE(hdr) BF32_GET_SB(hdr->sa_layout_info, 10, 6, 3, 0)
#define	SA_HDR_LAYOUT_INFO_ENCODE(x, num, size) \
{ \
	BF32_SET_SB(x, 10, 6, 3, 0, size); \
	BF32_SET(x, 0, 10, num); \
}

typedef enum sa_buf_type {
	SA_BONUS = 1,
	SA_SPILL = 2
} sa_buf_type_t;

typedef enum sa_data_op {
	SA_LOOKUP,
	SA_UPDATE,
	SA_ADD,
	SA_REPLACE,
	SA_REMOVE
} sa_data_op_t;

/*
 * Opaque handle used for most sa functions
 *
 * This needs to be kept as small as possible.
 */

struct sa_handle {
	dmu_buf_user_t	sa_dbu;
	kmutex_t	sa_lock;
	dmu_buf_t	*sa_bonus;
	dmu_buf_t	*sa_spill;
	objset_t	*sa_os;
	void		*sa_userp;
	sa_idx_tab_t	*sa_bonus_tab;	 /* idx of bonus */
	sa_idx_tab_t	*sa_spill_tab; /* only present if spill activated */
};

#define	SA_GET_DB(hdl, type)	\
	(dmu_buf_impl_t *)((type == SA_BONUS) ? hdl->sa_bonus : hdl->sa_spill)

#define	SA_GET_HDR(hdl, type) \
	((sa_hdr_phys_t *)((dmu_buf_impl_t *)(SA_GET_DB(hdl, \
	type))->db.db_data))

#define	SA_IDX_TAB_GET(hdl, type) \
	(type == SA_BONUS ? hdl->sa_bonus_tab : hdl->sa_spill_tab)

#define	IS_SA_BONUSTYPE(a)	\
	((a == DMU_OT_SA) ? B_TRUE : B_FALSE)

#define	SA_BONUSTYPE_FROM_DB(db) \
	(dmu_get_bonustype((dmu_buf_t *)db))

#define	SA_BLKPTR_SPACE	(DN_MAX_BONUSLEN - sizeof (blkptr_t))

#define	SA_LAYOUT_NUM(x, type) \
	((!IS_SA_BONUSTYPE(type) ? 0 : (((IS_SA_BONUSTYPE(type)) && \
	((SA_HDR_LAYOUT_NUM(x)) == 0)) ? 1 : SA_HDR_LAYOUT_NUM(x))))


#define	SA_REGISTERED_LEN(sa, attr) sa->sa_attr_table[attr].sa_length

#define	SA_ATTR_LEN(sa, idx, attr, hdr) ((SA_REGISTERED_LEN(sa, attr) == 0) ?\
	hdr->sa_lengths[TOC_LEN_IDX(idx->sa_idx_tab[attr])] : \
	SA_REGISTERED_LEN(sa, attr))

#define	SA_SET_HDR(hdr, num, size) \
	{ \
		hdr->sa_magic = SA_MAGIC; \
		SA_HDR_LAYOUT_INFO_ENCODE(hdr->sa_layout_info, num, size); \
	}

#define	SA_ATTR_INFO(sa, idx, hdr, attr, bulk, type, hdl) \
	{ \
		bulk.sa_size = SA_ATTR_LEN(sa, idx, attr, hdr); \
		bulk.sa_buftype = type; \
		bulk.sa_addr = \
		    (void *)((uintptr_t)TOC_OFF(idx->sa_idx_tab[attr]) + \
		    (uintptr_t)hdr); \
}

#define	SA_HDR_SIZE_MATCH_LAYOUT(hdr, tb) \
	(SA_HDR_SIZE(hdr) == (sizeof (sa_hdr_phys_t) + \
	(tb->lot_var_sizes > 1 ? P2ROUNDUP((tb->lot_var_sizes - 1) * \
	sizeof (uint16_t), 8) : 0)))

int sa_add_impl(sa_handle_t *, sa_attr_type_t,
    uint32_t, sa_data_locator_t, void *, dmu_tx_t *);

void sa_register_update_callback_locked(objset_t *, sa_update_cb_t *);
int sa_size_locked(sa_handle_t *, sa_attr_type_t, int *);

void sa_default_locator(void **, uint32_t *, uint32_t, boolean_t, void *);
int sa_attr_size(sa_os_t *, sa_idx_tab_t *, sa_attr_type_t,
    uint16_t *, sa_hdr_phys_t *);

#ifdef	__cplusplus
extern "C" {
#endif

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_SA_IMPL_H */
                                                                                                                                                                                                                                       usr/src/zfs-0.6.5.9/include/sys/sdt.h                                                               0100644 0000000 0000000 00000004264 13045171016 015472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef _SYS_SDT_H
#define	_SYS_SDT_H

#ifndef _KERNEL

#define	ZFS_PROBE(a)			((void) 0)
#define	ZFS_PROBE1(a, c)		((void) 0)
#define	ZFS_PROBE2(a, c, e)		((void) 0)
#define	ZFS_PROBE3(a, c, e, g)		((void) 0)
#define	ZFS_PROBE4(a, c, e, g, i)	((void) 0)
#define	ZFS_SET_ERROR(err)		((void) 0)

#else

#if defined(HAVE_DECLARE_EVENT_CLASS)

#include <sys/trace.h>

/*
 * The set-error SDT probe is extra static, in that we declare its fake
 * function literally, rather than with the DTRACE_PROBE1() macro.  This is
 * necessary so that SET_ERROR() can evaluate to a value, which wouldn't
 * be possible if it required multiple statements (to declare the function
 * and then call it).
 *
 * SET_ERROR() uses the comma operator so that it can be used without much
 * additional code.  For example, "return (EINVAL);" becomes
 * "return (SET_ERROR(EINVAL));".  Note that the argument will be evaluated
 * twice, so it should not have side effects (e.g. something like:
 * "return (SET_ERROR(log_error(EINVAL, info)));" would log the error twice).
 */
#define	SET_ERROR(err) \
	(trace_zfs_set__error(__FILE__, __func__, __LINE__, err), err)

#else

#undef SET_ERROR
#define	SET_ERROR(err) (err)

#endif /* HAVE_DECLARE_EVENT_CLASS */

#endif /* _KERNEL */

#endif /* _SYS_SDT_H */
                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/spa.h                                                               0100644 0000000 0000000 00000103403 13045171016 015456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef _SYS_SPA_H
#define	_SYS_SPA_H

#include <sys/avl.h>
#include <sys/zfs_context.h>
#include <sys/kstat.h>
#include <sys/nvpair.h>
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <sys/fs/zfs.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Forward references that lots of things need.
 */
typedef struct spa spa_t;
typedef struct vdev vdev_t;
typedef struct metaslab metaslab_t;
typedef struct metaslab_group metaslab_group_t;
typedef struct metaslab_class metaslab_class_t;
typedef struct zio zio_t;
typedef struct zilog zilog_t;
typedef struct spa_aux_vdev spa_aux_vdev_t;
typedef struct ddt ddt_t;
typedef struct ddt_entry ddt_entry_t;
typedef struct zbookmark_phys zbookmark_phys_t;

struct dsl_pool;
struct dsl_dataset;

/*
 * General-purpose 32-bit and 64-bit bitfield encodings.
 */
#define	BF32_DECODE(x, low, len)	P2PHASE((x) >> (low), 1U << (len))
#define	BF64_DECODE(x, low, len)	P2PHASE((x) >> (low), 1ULL << (len))
#define	BF32_ENCODE(x, low, len)	(P2PHASE((x), 1U << (len)) << (low))
#define	BF64_ENCODE(x, low, len)	(P2PHASE((x), 1ULL << (len)) << (low))

#define	BF32_GET(x, low, len)		BF32_DECODE(x, low, len)
#define	BF64_GET(x, low, len)		BF64_DECODE(x, low, len)

#define	BF32_SET(x, low, len, val) do { \
	ASSERT3U(val, <, 1U << (len)); \
	ASSERT3U(low + len, <=, 32); \
	(x) ^= BF32_ENCODE((x >> low) ^ (val), low, len); \
_NOTE(CONSTCOND) } while (0)

#define	BF64_SET(x, low, len, val) do { \
	ASSERT3U(val, <, 1ULL << (len)); \
	ASSERT3U(low + len, <=, 64); \
	((x) ^= BF64_ENCODE((x >> low) ^ (val), low, len)); \
_NOTE(CONSTCOND) } while (0)

#define	BF32_GET_SB(x, low, len, shift, bias)	\
	((BF32_GET(x, low, len) + (bias)) << (shift))
#define	BF64_GET_SB(x, low, len, shift, bias)	\
	((BF64_GET(x, low, len) + (bias)) << (shift))

#define	BF32_SET_SB(x, low, len, shift, bias, val) do { \
	ASSERT(IS_P2ALIGNED(val, 1U << shift)); \
	ASSERT3S((val) >> (shift), >=, bias); \
	BF32_SET(x, low, len, ((val) >> (shift)) - (bias)); \
_NOTE(CONSTCOND) } while (0)
#define	BF64_SET_SB(x, low, len, shift, bias, val) do { \
	ASSERT(IS_P2ALIGNED(val, 1ULL << shift)); \
	ASSERT3S((val) >> (shift), >=, bias); \
	BF64_SET(x, low, len, ((val) >> (shift)) - (bias)); \
_NOTE(CONSTCOND) } while (0)

/*
 * We currently support block sizes from 512 bytes to 16MB.
 * The benefits of larger blocks, and thus larger IO, need to be weighed
 * against the cost of COWing a giant block to modify one byte, and the
 * large latency of reading or writing a large block.
 *
 * Note that although blocks up to 16MB are supported, the recordsize
 * property can not be set larger than zfs_max_recordsize (default 1MB).
 * See the comment near zfs_max_recordsize in dsl_dataset.c for details.
 *
 * Note that although the LSIZE field of the blkptr_t can store sizes up
 * to 32MB, the dnode's dn_datablkszsec can only store sizes up to
 * 32MB - 512 bytes.  Therefore, we limit SPA_MAXBLOCKSIZE to 16MB.
 */
#define	SPA_MINBLOCKSHIFT	9
#define	SPA_OLD_MAXBLOCKSHIFT	17
#define	SPA_MAXBLOCKSHIFT	24
#define	SPA_MINBLOCKSIZE	(1ULL << SPA_MINBLOCKSHIFT)
#define	SPA_OLD_MAXBLOCKSIZE	(1ULL << SPA_OLD_MAXBLOCKSHIFT)
#define	SPA_MAXBLOCKSIZE	(1ULL << SPA_MAXBLOCKSHIFT)

/*
 * Size of block to hold the configuration data (a packed nvlist)
 */
#define	SPA_CONFIG_BLOCKSIZE	(1ULL << 14)

/*
 * The DVA size encodings for LSIZE and PSIZE support blocks up to 32MB.
 * The ASIZE encoding should be at least 64 times larger (6 more bits)
 * to support up to 4-way RAID-Z mirror mode with worst-case gang block
 * overhead, three DVAs per bp, plus one more bit in case we do anything
 * else that expands the ASIZE.
 */
#define	SPA_LSIZEBITS		16	/* LSIZE up to 32M (2^16 * 512)	*/
#define	SPA_PSIZEBITS		16	/* PSIZE up to 32M (2^16 * 512)	*/
#define	SPA_ASIZEBITS		24	/* ASIZE up to 64 times larger	*/

/*
 * All SPA data is represented by 128-bit data virtual addresses (DVAs).
 * The members of the dva_t should be considered opaque outside the SPA.
 */
typedef struct dva {
	uint64_t	dva_word[2];
} dva_t;

/*
 * Each block has a 256-bit checksum -- strong enough for cryptographic hashes.
 */
typedef struct zio_cksum {
	uint64_t	zc_word[4];
} zio_cksum_t;

/*
 * Each block is described by its DVAs, time of birth, checksum, etc.
 * The word-by-word, bit-by-bit layout of the blkptr is as follows:
 *
 *	64	56	48	40	32	24	16	8	0
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 0	|		vdev1		| GRID  |	  ASIZE		|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 1	|G|			 offset1				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 2	|		vdev2		| GRID  |	  ASIZE		|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 3	|G|			 offset2				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 4	|		vdev3		| GRID  |	  ASIZE		|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 5	|G|			 offset3				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 6	|BDX|lvl| type	| cksum |E| comp|    PSIZE	|     LSIZE	|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 7	|			padding					|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 8	|			padding					|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 9	|			physical birth txg			|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * a	|			logical birth txg			|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * b	|			fill count				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * c	|			checksum[0]				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * d	|			checksum[1]				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * e	|			checksum[2]				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * f	|			checksum[3]				|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * Legend:
 *
 * vdev		virtual device ID
 * offset	offset into virtual device
 * LSIZE	logical size
 * PSIZE	physical size (after compression)
 * ASIZE	allocated size (including RAID-Z parity and gang block headers)
 * GRID		RAID-Z layout information (reserved for future use)
 * cksum	checksum function
 * comp		compression function
 * G		gang block indicator
 * B		byteorder (endianness)
 * D		dedup
 * X		encryption (on version 30, which is not supported)
 * E		blkptr_t contains embedded data (see below)
 * lvl		level of indirection
 * type		DMU object type
 * phys birth	txg of block allocation; zero if same as logical birth txg
 * log. birth	transaction group in which the block was logically born
 * fill count	number of non-zero blocks under this bp
 * checksum[4]	256-bit checksum of the data this bp describes
 */

/*
 * "Embedded" blkptr_t's don't actually point to a block, instead they
 * have a data payload embedded in the blkptr_t itself.  See the comment
 * in blkptr.c for more details.
 *
 * The blkptr_t is laid out as follows:
 *
 *	64	56	48	40	32	24	16	8	0
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 0	|      payload                                                  |
 * 1	|      payload                                                  |
 * 2	|      payload                                                  |
 * 3	|      payload                                                  |
 * 4	|      payload                                                  |
 * 5	|      payload                                                  |
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 6	|BDX|lvl| type	| etype |E| comp| PSIZE|              LSIZE	|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * 7	|      payload                                                  |
 * 8	|      payload                                                  |
 * 9	|      payload                                                  |
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * a	|			logical birth txg			|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 * b	|      payload                                                  |
 * c	|      payload                                                  |
 * d	|      payload                                                  |
 * e	|      payload                                                  |
 * f	|      payload                                                  |
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * Legend:
 *
 * payload		contains the embedded data
 * B (byteorder)	byteorder (endianness)
 * D (dedup)		padding (set to zero)
 * X			encryption (set to zero; see above)
 * E (embedded)		set to one
 * lvl			indirection level
 * type			DMU object type
 * etype		how to interpret embedded data (BP_EMBEDDED_TYPE_*)
 * comp			compression function of payload
 * PSIZE		size of payload after compression, in bytes
 * LSIZE		logical size of payload, in bytes
 *			note that 25 bits is enough to store the largest
 *			"normal" BP's LSIZE (2^16 * 2^9) in bytes
 * log. birth		transaction group in which the block was logically born
 *
 * Note that LSIZE and PSIZE are stored in bytes, whereas for non-embedded
 * bp's they are stored in units of SPA_MINBLOCKSHIFT.
 * Generally, the generic BP_GET_*() macros can be used on embedded BP's.
 * The B, D, X, lvl, type, and comp fields are stored the same as with normal
 * BP's so the BP_SET_* macros can be used with them.  etype, PSIZE, LSIZE must
 * be set with the BPE_SET_* macros.  BP_SET_EMBEDDED() should be called before
 * other macros, as they assert that they are only used on BP's of the correct
 * "embedded-ness".
 */

#define	BPE_GET_ETYPE(bp)	\
	(ASSERT(BP_IS_EMBEDDED(bp)), \
	BF64_GET((bp)->blk_prop, 40, 8))
#define	BPE_SET_ETYPE(bp, t)	do { \
	ASSERT(BP_IS_EMBEDDED(bp)); \
	BF64_SET((bp)->blk_prop, 40, 8, t); \
_NOTE(CONSTCOND) } while (0)

#define	BPE_GET_LSIZE(bp)	\
	(ASSERT(BP_IS_EMBEDDED(bp)), \
	BF64_GET_SB((bp)->blk_prop, 0, 25, 0, 1))
#define	BPE_SET_LSIZE(bp, x)	do { \
	ASSERT(BP_IS_EMBEDDED(bp)); \
	BF64_SET_SB((bp)->blk_prop, 0, 25, 0, 1, x); \
_NOTE(CONSTCOND) } while (0)

#define	BPE_GET_PSIZE(bp)	\
	(ASSERT(BP_IS_EMBEDDED(bp)), \
	BF64_GET_SB((bp)->blk_prop, 25, 7, 0, 1))
#define	BPE_SET_PSIZE(bp, x)	do { \
	ASSERT(BP_IS_EMBEDDED(bp)); \
	BF64_SET_SB((bp)->blk_prop, 25, 7, 0, 1, x); \
_NOTE(CONSTCOND) } while (0)

typedef enum bp_embedded_type {
	BP_EMBEDDED_TYPE_DATA,
	BP_EMBEDDED_TYPE_RESERVED, /* Reserved for an unintegrated feature. */
	NUM_BP_EMBEDDED_TYPES = BP_EMBEDDED_TYPE_RESERVED
} bp_embedded_type_t;

#define	BPE_NUM_WORDS 14
#define	BPE_PAYLOAD_SIZE (BPE_NUM_WORDS * sizeof (uint64_t))
#define	BPE_IS_PAYLOADWORD(bp, wp) \
	((wp) != &(bp)->blk_prop && (wp) != &(bp)->blk_birth)

#define	SPA_BLKPTRSHIFT	7		/* blkptr_t is 128 bytes	*/
#define	SPA_DVAS_PER_BP	3		/* Number of DVAs in a bp	*/

/*
 * A block is a hole when it has either 1) never been written to, or
 * 2) is zero-filled. In both cases, ZFS can return all zeroes for all reads
 * without physically allocating disk space. Holes are represented in the
 * blkptr_t structure by zeroed blk_dva. Correct checking for holes is
 * done through the BP_IS_HOLE macro. For holes, the logical size, level,
 * DMU object type, and birth times are all also stored for holes that
 * were written to at some point (i.e. were punched after having been filled).
 */
typedef struct blkptr {
	dva_t		blk_dva[SPA_DVAS_PER_BP]; /* Data Virtual Addresses */
	uint64_t	blk_prop;	/* size, compression, type, etc	    */
	uint64_t	blk_pad[2];	/* Extra space for the future	    */
	uint64_t	blk_phys_birth;	/* txg when block was allocated	    */
	uint64_t	blk_birth;	/* transaction group at birth	    */
	uint64_t	blk_fill;	/* fill count			    */
	zio_cksum_t	blk_cksum;	/* 256-bit checksum		    */
} blkptr_t;

/*
 * Macros to get and set fields in a bp or DVA.
 */
#define	DVA_GET_ASIZE(dva)	\
	BF64_GET_SB((dva)->dva_word[0], 0, SPA_ASIZEBITS, SPA_MINBLOCKSHIFT, 0)
#define	DVA_SET_ASIZE(dva, x)	\
	BF64_SET_SB((dva)->dva_word[0], 0, SPA_ASIZEBITS, \
	SPA_MINBLOCKSHIFT, 0, x)

#define	DVA_GET_GRID(dva)	BF64_GET((dva)->dva_word[0], 24, 8)
#define	DVA_SET_GRID(dva, x)	BF64_SET((dva)->dva_word[0], 24, 8, x)

#define	DVA_GET_VDEV(dva)	BF64_GET((dva)->dva_word[0], 32, 32)
#define	DVA_SET_VDEV(dva, x)	BF64_SET((dva)->dva_word[0], 32, 32, x)

#define	DVA_GET_OFFSET(dva)	\
	BF64_GET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0)
#define	DVA_SET_OFFSET(dva, x)	\
	BF64_SET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0, x)

#define	DVA_GET_GANG(dva)	BF64_GET((dva)->dva_word[1], 63, 1)
#define	DVA_SET_GANG(dva, x)	BF64_SET((dva)->dva_word[1], 63, 1, x)

#define	BP_GET_LSIZE(bp)	\
	(BP_IS_EMBEDDED(bp) ?	\
	(BPE_GET_ETYPE(bp) == BP_EMBEDDED_TYPE_DATA ? BPE_GET_LSIZE(bp) : 0): \
	BF64_GET_SB((bp)->blk_prop, 0, SPA_LSIZEBITS, SPA_MINBLOCKSHIFT, 1))
#define	BP_SET_LSIZE(bp, x)	do { \
	ASSERT(!BP_IS_EMBEDDED(bp)); \
	BF64_SET_SB((bp)->blk_prop, \
	    0, SPA_LSIZEBITS, SPA_MINBLOCKSHIFT, 1, x); \
_NOTE(CONSTCOND) } while (0)

#define	BP_GET_PSIZE(bp)	\
	(BP_IS_EMBEDDED(bp) ? 0 : \
	BF64_GET_SB((bp)->blk_prop, 16, SPA_PSIZEBITS, SPA_MINBLOCKSHIFT, 1))
#define	BP_SET_PSIZE(bp, x)	do { \
	ASSERT(!BP_IS_EMBEDDED(bp)); \
	BF64_SET_SB((bp)->blk_prop, \
	    16, SPA_PSIZEBITS, SPA_MINBLOCKSHIFT, 1, x); \
_NOTE(CONSTCOND) } while (0)

#define	BP_GET_COMPRESS(bp)		BF64_GET((bp)->blk_prop, 32, 7)
#define	BP_SET_COMPRESS(bp, x)		BF64_SET((bp)->blk_prop, 32, 7, x)

#define	BP_IS_EMBEDDED(bp)		BF64_GET((bp)->blk_prop, 39, 1)
#define	BP_SET_EMBEDDED(bp, x)		BF64_SET((bp)->blk_prop, 39, 1, x)

#define	BP_GET_CHECKSUM(bp)		\
	(BP_IS_EMBEDDED(bp) ? ZIO_CHECKSUM_OFF : \
	BF64_GET((bp)->blk_prop, 40, 8))
#define	BP_SET_CHECKSUM(bp, x)		do { \
	ASSERT(!BP_IS_EMBEDDED(bp)); \
	BF64_SET((bp)->blk_prop, 40, 8, x); \
_NOTE(CONSTCOND) } while (0)

#define	BP_GET_TYPE(bp)			BF64_GET((bp)->blk_prop, 48, 8)
#define	BP_SET_TYPE(bp, x)		BF64_SET((bp)->blk_prop, 48, 8, x)

#define	BP_GET_LEVEL(bp)		BF64_GET((bp)->blk_prop, 56, 5)
#define	BP_SET_LEVEL(bp, x)		BF64_SET((bp)->blk_prop, 56, 5, x)

#define	BP_GET_DEDUP(bp)		BF64_GET((bp)->blk_prop, 62, 1)
#define	BP_SET_DEDUP(bp, x)		BF64_SET((bp)->blk_prop, 62, 1, x)

#define	BP_GET_BYTEORDER(bp)		BF64_GET((bp)->blk_prop, 63, 1)
#define	BP_SET_BYTEORDER(bp, x)		BF64_SET((bp)->blk_prop, 63, 1, x)

#define	BP_PHYSICAL_BIRTH(bp)		\
	(BP_IS_EMBEDDED(bp) ? 0 : \
	(bp)->blk_phys_birth ? (bp)->blk_phys_birth : (bp)->blk_birth)

#define	BP_SET_BIRTH(bp, logical, physical)	\
{						\
	ASSERT(!BP_IS_EMBEDDED(bp));		\
	(bp)->blk_birth = (logical);		\
	(bp)->blk_phys_birth = ((logical) == (physical) ? 0 : (physical)); \
}

#define	BP_GET_FILL(bp) (BP_IS_EMBEDDED(bp) ? 1 : (bp)->blk_fill)

#define	BP_GET_ASIZE(bp)	\
	(BP_IS_EMBEDDED(bp) ? 0 : \
	DVA_GET_ASIZE(&(bp)->blk_dva[0]) + \
	DVA_GET_ASIZE(&(bp)->blk_dva[1]) + \
	DVA_GET_ASIZE(&(bp)->blk_dva[2]))

#define	BP_GET_UCSIZE(bp) \
	((BP_GET_LEVEL(bp) > 0 || DMU_OT_IS_METADATA(BP_GET_TYPE(bp))) ? \
	BP_GET_PSIZE(bp) : BP_GET_LSIZE(bp))

#define	BP_GET_NDVAS(bp)	\
	(BP_IS_EMBEDDED(bp) ? 0 : \
	!!DVA_GET_ASIZE(&(bp)->blk_dva[0]) + \
	!!DVA_GET_ASIZE(&(bp)->blk_dva[1]) + \
	!!DVA_GET_ASIZE(&(bp)->blk_dva[2]))

#define	BP_COUNT_GANG(bp)	\
	(BP_IS_EMBEDDED(bp) ? 0 : \
	(DVA_GET_GANG(&(bp)->blk_dva[0]) + \
	DVA_GET_GANG(&(bp)->blk_dva[1]) + \
	DVA_GET_GANG(&(bp)->blk_dva[2])))

#define	DVA_EQUAL(dva1, dva2)	\
	((dva1)->dva_word[1] == (dva2)->dva_word[1] && \
	(dva1)->dva_word[0] == (dva2)->dva_word[0])

#define	BP_EQUAL(bp1, bp2)	\
	(BP_PHYSICAL_BIRTH(bp1) == BP_PHYSICAL_BIRTH(bp2) &&	\
	(bp1)->blk_birth == (bp2)->blk_birth &&			\
	DVA_EQUAL(&(bp1)->blk_dva[0], &(bp2)->blk_dva[0]) &&	\
	DVA_EQUAL(&(bp1)->blk_dva[1], &(bp2)->blk_dva[1]) &&	\
	DVA_EQUAL(&(bp1)->blk_dva[2], &(bp2)->blk_dva[2]))

#define	ZIO_CHECKSUM_EQUAL(zc1, zc2) \
	(0 == (((zc1).zc_word[0] - (zc2).zc_word[0]) | \
	((zc1).zc_word[1] - (zc2).zc_word[1]) | \
	((zc1).zc_word[2] - (zc2).zc_word[2]) | \
	((zc1).zc_word[3] - (zc2).zc_word[3])))

#define	ZIO_CHECKSUM_IS_ZERO(zc) \
	(0 == ((zc)->zc_word[0] | (zc)->zc_word[1] | \
	(zc)->zc_word[2] | (zc)->zc_word[3]))

#define	DVA_IS_VALID(dva)	(DVA_GET_ASIZE(dva) != 0)

#define	ZIO_SET_CHECKSUM(zcp, w0, w1, w2, w3)	\
{						\
	(zcp)->zc_word[0] = w0;			\
	(zcp)->zc_word[1] = w1;			\
	(zcp)->zc_word[2] = w2;			\
	(zcp)->zc_word[3] = w3;			\
}

#define	BP_IDENTITY(bp)		(ASSERT(!BP_IS_EMBEDDED(bp)), &(bp)->blk_dva[0])
#define	BP_IS_GANG(bp)		\
	(BP_IS_EMBEDDED(bp) ? B_FALSE : DVA_GET_GANG(BP_IDENTITY(bp)))
#define	DVA_IS_EMPTY(dva)	((dva)->dva_word[0] == 0ULL &&	\
				(dva)->dva_word[1] == 0ULL)
#define	BP_IS_HOLE(bp) \
	(!BP_IS_EMBEDDED(bp) && DVA_IS_EMPTY(BP_IDENTITY(bp)))

/* BP_IS_RAIDZ(bp) assumes no block compression */
#define	BP_IS_RAIDZ(bp)		(DVA_GET_ASIZE(&(bp)->blk_dva[0]) > \
				BP_GET_PSIZE(bp))

#define	BP_ZERO(bp)				\
{						\
	(bp)->blk_dva[0].dva_word[0] = 0;	\
	(bp)->blk_dva[0].dva_word[1] = 0;	\
	(bp)->blk_dva[1].dva_word[0] = 0;	\
	(bp)->blk_dva[1].dva_word[1] = 0;	\
	(bp)->blk_dva[2].dva_word[0] = 0;	\
	(bp)->blk_dva[2].dva_word[1] = 0;	\
	(bp)->blk_prop = 0;			\
	(bp)->blk_pad[0] = 0;			\
	(bp)->blk_pad[1] = 0;			\
	(bp)->blk_phys_birth = 0;		\
	(bp)->blk_birth = 0;			\
	(bp)->blk_fill = 0;			\
	ZIO_SET_CHECKSUM(&(bp)->blk_cksum, 0, 0, 0, 0);	\
}

#ifdef _BIG_ENDIAN
#define	ZFS_HOST_BYTEORDER	(0ULL)
#else
#define	ZFS_HOST_BYTEORDER	(1ULL)
#endif

#define	BP_SHOULD_BYTESWAP(bp)	(BP_GET_BYTEORDER(bp) != ZFS_HOST_BYTEORDER)

#define	BP_SPRINTF_LEN	320

/*
 * This macro allows code sharing between zfs, libzpool, and mdb.
 * 'func' is either snprintf() or mdb_snprintf().
 * 'ws' (whitespace) can be ' ' for single-line format, '\n' for multi-line.
 */
#define	SNPRINTF_BLKPTR(func, ws, buf, size, bp, type, checksum, compress) \
{									\
	static const char *copyname[] =					\
	    { "zero", "single", "double", "triple" };			\
	int len = 0;							\
	int copies = 0;							\
	int d;								\
									\
	if (bp == NULL) {						\
		len += func(buf + len, size - len, "<NULL>");		\
	} else if (BP_IS_HOLE(bp)) {					\
		len += func(buf + len, size - len,			\
		    "HOLE [L%llu %s] "					\
		    "size=%llxL birth=%lluL",				\
		    (u_longlong_t)BP_GET_LEVEL(bp),			\
		    type,						\
		    (u_longlong_t)BP_GET_LSIZE(bp),			\
		    (u_longlong_t)bp->blk_birth);			\
	} else if (BP_IS_EMBEDDED(bp)) {				\
		len = func(buf + len, size - len,			\
		    "EMBEDDED [L%llu %s] et=%u %s "			\
		    "size=%llxL/%llxP birth=%lluL",			\
		    (u_longlong_t)BP_GET_LEVEL(bp),			\
		    type,						\
		    (int)BPE_GET_ETYPE(bp),				\
		    compress,						\
		    (u_longlong_t)BPE_GET_LSIZE(bp),			\
		    (u_longlong_t)BPE_GET_PSIZE(bp),			\
		    (u_longlong_t)bp->blk_birth);			\
	} else {							\
		for (d = 0; d < BP_GET_NDVAS(bp); d++) {		\
			const dva_t *dva = &bp->blk_dva[d];		\
			if (DVA_IS_VALID(dva))				\
				copies++;				\
			len += func(buf + len, size - len,		\
			    "DVA[%d]=<%llu:%llx:%llx>%c", d,		\
			    (u_longlong_t)DVA_GET_VDEV(dva),		\
			    (u_longlong_t)DVA_GET_OFFSET(dva),		\
			    (u_longlong_t)DVA_GET_ASIZE(dva),		\
			    ws);					\
		}							\
		if (BP_IS_GANG(bp) &&					\
		    DVA_GET_ASIZE(&bp->blk_dva[2]) <=			\
		    DVA_GET_ASIZE(&bp->blk_dva[1]) / 2)			\
			copies--;					\
		len += func(buf + len, size - len,			\
		    "[L%llu %s] %s %s %s %s %s %s%c"			\
		    "size=%llxL/%llxP birth=%lluL/%lluP fill=%llu%c"	\
		    "cksum=%llx:%llx:%llx:%llx",			\
		    (u_longlong_t)BP_GET_LEVEL(bp),			\
		    type,						\
		    checksum,						\
		    compress,						\
		    BP_GET_BYTEORDER(bp) == 0 ? "BE" : "LE",		\
		    BP_IS_GANG(bp) ? "gang" : "contiguous",		\
		    BP_GET_DEDUP(bp) ? "dedup" : "unique",		\
		    copyname[copies],					\
		    ws,							\
		    (u_longlong_t)BP_GET_LSIZE(bp),			\
		    (u_longlong_t)BP_GET_PSIZE(bp),			\
		    (u_longlong_t)bp->blk_birth,			\
		    (u_longlong_t)BP_PHYSICAL_BIRTH(bp),		\
		    (u_longlong_t)BP_GET_FILL(bp),			\
		    ws,							\
		    (u_longlong_t)bp->blk_cksum.zc_word[0],		\
		    (u_longlong_t)bp->blk_cksum.zc_word[1],		\
		    (u_longlong_t)bp->blk_cksum.zc_word[2],		\
		    (u_longlong_t)bp->blk_cksum.zc_word[3]);		\
	}								\
	ASSERT(len < size);						\
}

#include <sys/dmu.h>

#define	BP_GET_BUFC_TYPE(bp)						\
	(((BP_GET_LEVEL(bp) > 0) || (DMU_OT_IS_METADATA(BP_GET_TYPE(bp)))) ? \
	ARC_BUFC_METADATA : ARC_BUFC_DATA)

typedef enum spa_import_type {
	SPA_IMPORT_EXISTING,
	SPA_IMPORT_ASSEMBLE
} spa_import_type_t;

/* state manipulation functions */
extern int spa_open(const char *pool, spa_t **, void *tag);
extern int spa_open_rewind(const char *pool, spa_t **, void *tag,
    nvlist_t *policy, nvlist_t **config);
extern int spa_get_stats(const char *pool, nvlist_t **config, char *altroot,
    size_t buflen);
extern int spa_create(const char *pool, nvlist_t *config, nvlist_t *props,
    nvlist_t *zplprops);
extern int spa_import_rootpool(char *devpath, char *devid);
extern int spa_import(char *pool, nvlist_t *config, nvlist_t *props,
    uint64_t flags);
extern nvlist_t *spa_tryimport(nvlist_t *tryconfig);
extern int spa_destroy(char *pool);
extern int spa_export(char *pool, nvlist_t **oldconfig, boolean_t force,
    boolean_t hardforce);
extern int spa_reset(char *pool);
extern void spa_async_request(spa_t *spa, int flag);
extern void spa_async_unrequest(spa_t *spa, int flag);
extern void spa_async_suspend(spa_t *spa);
extern void spa_async_resume(spa_t *spa);
extern spa_t *spa_inject_addref(char *pool);
extern void spa_inject_delref(spa_t *spa);
extern void spa_scan_stat_init(spa_t *spa);
extern int spa_scan_get_stats(spa_t *spa, pool_scan_stat_t *ps);

#define	SPA_ASYNC_CONFIG_UPDATE	0x01
#define	SPA_ASYNC_REMOVE	0x02
#define	SPA_ASYNC_PROBE		0x04
#define	SPA_ASYNC_RESILVER_DONE	0x08
#define	SPA_ASYNC_RESILVER	0x10
#define	SPA_ASYNC_AUTOEXPAND	0x20
#define	SPA_ASYNC_REMOVE_DONE	0x40
#define	SPA_ASYNC_REMOVE_STOP	0x80

/*
 * Controls the behavior of spa_vdev_remove().
 */
#define	SPA_REMOVE_UNSPARE	0x01
#define	SPA_REMOVE_DONE		0x02

/* device manipulation */
extern int spa_vdev_add(spa_t *spa, nvlist_t *nvroot);
extern int spa_vdev_attach(spa_t *spa, uint64_t guid, nvlist_t *nvroot,
    int replacing);
extern int spa_vdev_detach(spa_t *spa, uint64_t guid, uint64_t pguid,
    int replace_done);
extern int spa_vdev_remove(spa_t *spa, uint64_t guid, boolean_t unspare);
extern boolean_t spa_vdev_remove_active(spa_t *spa);
extern int spa_vdev_setpath(spa_t *spa, uint64_t guid, const char *newpath);
extern int spa_vdev_setfru(spa_t *spa, uint64_t guid, const char *newfru);
extern int spa_vdev_split_mirror(spa_t *spa, char *newname, nvlist_t *config,
    nvlist_t *props, boolean_t exp);

/* spare state (which is global across all pools) */
extern void spa_spare_add(vdev_t *vd);
extern void spa_spare_remove(vdev_t *vd);
extern boolean_t spa_spare_exists(uint64_t guid, uint64_t *pool, int *refcnt);
extern void spa_spare_activate(vdev_t *vd);

/* L2ARC state (which is global across all pools) */
extern void spa_l2cache_add(vdev_t *vd);
extern void spa_l2cache_remove(vdev_t *vd);
extern boolean_t spa_l2cache_exists(uint64_t guid, uint64_t *pool);
extern void spa_l2cache_activate(vdev_t *vd);
extern void spa_l2cache_drop(spa_t *spa);

/* scanning */
extern int spa_scan(spa_t *spa, pool_scan_func_t func);
extern int spa_scan_stop(spa_t *spa);

/* spa syncing */
extern void spa_sync(spa_t *spa, uint64_t txg); /* only for DMU use */
extern void spa_sync_allpools(void);

extern int zfs_sync_pass_deferred_free;

/* spa namespace global mutex */
extern kmutex_t spa_namespace_lock;

/*
 * SPA configuration functions in spa_config.c
 */

#define	SPA_CONFIG_UPDATE_POOL	0
#define	SPA_CONFIG_UPDATE_VDEVS	1

extern void spa_config_sync(spa_t *, boolean_t, boolean_t);
extern void spa_config_load(void);
extern nvlist_t *spa_all_configs(uint64_t *);
extern void spa_config_set(spa_t *spa, nvlist_t *config);
extern nvlist_t *spa_config_generate(spa_t *spa, vdev_t *vd, uint64_t txg,
    int getstats);
extern void spa_config_update(spa_t *spa, int what);

/*
 * Miscellaneous SPA routines in spa_misc.c
 */

/* Namespace manipulation */
extern spa_t *spa_lookup(const char *name);
extern spa_t *spa_add(const char *name, nvlist_t *config, const char *altroot);
extern void spa_remove(spa_t *spa);
extern spa_t *spa_next(spa_t *prev);

/* Refcount functions */
extern void spa_open_ref(spa_t *spa, void *tag);
extern void spa_close(spa_t *spa, void *tag);
extern void spa_async_close(spa_t *spa, void *tag);
extern boolean_t spa_refcount_zero(spa_t *spa);

#define	SCL_NONE	0x00
#define	SCL_CONFIG	0x01
#define	SCL_STATE	0x02
#define	SCL_L2ARC	0x04		/* hack until L2ARC 2.0 */
#define	SCL_ALLOC	0x08
#define	SCL_ZIO		0x10
#define	SCL_FREE	0x20
#define	SCL_VDEV	0x40
#define	SCL_LOCKS	7
#define	SCL_ALL		((1 << SCL_LOCKS) - 1)
#define	SCL_STATE_ALL	(SCL_STATE | SCL_L2ARC | SCL_ZIO)

/* Historical pool statistics */
typedef struct spa_stats_history {
	kmutex_t		lock;
	uint64_t		count;
	uint64_t		size;
	kstat_t			*kstat;
	void			*private;
	list_t			list;
} spa_stats_history_t;

typedef struct spa_stats {
	spa_stats_history_t	read_history;
	spa_stats_history_t	txg_history;
	spa_stats_history_t	tx_assign_histogram;
	spa_stats_history_t	io_history;
} spa_stats_t;

typedef enum txg_state {
	TXG_STATE_BIRTH		= 0,
	TXG_STATE_OPEN		= 1,
	TXG_STATE_QUIESCED	= 2,
	TXG_STATE_WAIT_FOR_SYNC	= 3,
	TXG_STATE_SYNCED	= 4,
	TXG_STATE_COMMITTED	= 5,
} txg_state_t;

extern void spa_stats_init(spa_t *spa);
extern void spa_stats_destroy(spa_t *spa);
extern void spa_read_history_add(spa_t *spa, const zbookmark_phys_t *zb,
    uint32_t aflags);
extern void spa_txg_history_add(spa_t *spa, uint64_t txg, hrtime_t birth_time);
extern int spa_txg_history_set(spa_t *spa,  uint64_t txg,
    txg_state_t completed_state, hrtime_t completed_time);
extern int spa_txg_history_set_io(spa_t *spa,  uint64_t txg, uint64_t nread,
    uint64_t nwritten, uint64_t reads, uint64_t writes, uint64_t ndirty);
extern void spa_tx_assign_add_nsecs(spa_t *spa, uint64_t nsecs);

/* Pool configuration locks */
extern int spa_config_tryenter(spa_t *spa, int locks, void *tag, krw_t rw);
extern void spa_config_enter(spa_t *spa, int locks, void *tag, krw_t rw);
extern void spa_config_exit(spa_t *spa, int locks, void *tag);
extern int spa_config_held(spa_t *spa, int locks, krw_t rw);

/* Pool vdev add/remove lock */
extern uint64_t spa_vdev_enter(spa_t *spa);
extern uint64_t spa_vdev_config_enter(spa_t *spa);
extern void spa_vdev_config_exit(spa_t *spa, vdev_t *vd, uint64_t txg,
    int error, char *tag);
extern int spa_vdev_exit(spa_t *spa, vdev_t *vd, uint64_t txg, int error);

/* Pool vdev state change lock */
extern void spa_vdev_state_enter(spa_t *spa, int oplock);
extern int spa_vdev_state_exit(spa_t *spa, vdev_t *vd, int error);

/* Log state */
typedef enum spa_log_state {
	SPA_LOG_UNKNOWN = 0,	/* unknown log state */
	SPA_LOG_MISSING,	/* missing log(s) */
	SPA_LOG_CLEAR,		/* clear the log(s) */
	SPA_LOG_GOOD,		/* log(s) are good */
} spa_log_state_t;

extern spa_log_state_t spa_get_log_state(spa_t *spa);
extern void spa_set_log_state(spa_t *spa, spa_log_state_t state);
extern int spa_offline_log(spa_t *spa);

/* Log claim callback */
extern void spa_claim_notify(zio_t *zio);
extern void spa_deadman(void *);

/* Accessor functions */
extern boolean_t spa_shutting_down(spa_t *spa);
extern struct dsl_pool *spa_get_dsl(spa_t *spa);
extern boolean_t spa_is_initializing(spa_t *spa);
extern blkptr_t *spa_get_rootblkptr(spa_t *spa);
extern void spa_set_rootblkptr(spa_t *spa, const blkptr_t *bp);
extern void spa_altroot(spa_t *, char *, size_t);
extern int spa_sync_pass(spa_t *spa);
extern char *spa_name(spa_t *spa);
extern uint64_t spa_guid(spa_t *spa);
extern uint64_t spa_load_guid(spa_t *spa);
extern uint64_t spa_last_synced_txg(spa_t *spa);
extern uint64_t spa_first_txg(spa_t *spa);
extern uint64_t spa_syncing_txg(spa_t *spa);
extern uint64_t spa_version(spa_t *spa);
extern pool_state_t spa_state(spa_t *spa);
extern spa_load_state_t spa_load_state(spa_t *spa);
extern uint64_t spa_freeze_txg(spa_t *spa);
extern uint64_t spa_get_asize(spa_t *spa, uint64_t lsize);
extern uint64_t spa_get_dspace(spa_t *spa);
extern uint64_t spa_get_slop_space(spa_t *spa);
extern void spa_update_dspace(spa_t *spa);
extern uint64_t spa_version(spa_t *spa);
extern boolean_t spa_deflate(spa_t *spa);
extern metaslab_class_t *spa_normal_class(spa_t *spa);
extern metaslab_class_t *spa_log_class(spa_t *spa);
extern void spa_evicting_os_register(spa_t *, objset_t *os);
extern void spa_evicting_os_deregister(spa_t *, objset_t *os);
extern void spa_evicting_os_wait(spa_t *spa);
extern int spa_max_replication(spa_t *spa);
extern int spa_prev_software_version(spa_t *spa);
extern uint8_t spa_get_failmode(spa_t *spa);
extern boolean_t spa_suspended(spa_t *spa);
extern uint64_t spa_bootfs(spa_t *spa);
extern uint64_t spa_delegation(spa_t *spa);
extern objset_t *spa_meta_objset(spa_t *spa);
extern uint64_t spa_deadman_synctime(spa_t *spa);

/* Miscellaneous support routines */
extern void spa_activate_mos_feature(spa_t *spa, const char *feature,
    dmu_tx_t *tx);
extern void spa_deactivate_mos_feature(spa_t *spa, const char *feature);
extern int spa_rename(const char *oldname, const char *newname);
extern spa_t *spa_by_guid(uint64_t pool_guid, uint64_t device_guid);
extern boolean_t spa_guid_exists(uint64_t pool_guid, uint64_t device_guid);
extern char *spa_strdup(const char *);
extern void spa_strfree(char *);
extern uint64_t spa_get_random(uint64_t range);
extern uint64_t spa_generate_guid(spa_t *spa);
extern void snprintf_blkptr(char *buf, size_t buflen, const blkptr_t *bp);
extern void spa_freeze(spa_t *spa);
extern int spa_change_guid(spa_t *spa);
extern void spa_upgrade(spa_t *spa, uint64_t version);
extern void spa_evict_all(void);
extern vdev_t *spa_lookup_by_guid(spa_t *spa, uint64_t guid,
    boolean_t l2cache);
extern boolean_t spa_has_spare(spa_t *, uint64_t guid);
extern uint64_t dva_get_dsize_sync(spa_t *spa, const dva_t *dva);
extern uint64_t bp_get_dsize_sync(spa_t *spa, const blkptr_t *bp);
extern uint64_t bp_get_dsize(spa_t *spa, const blkptr_t *bp);
extern boolean_t spa_has_slogs(spa_t *spa);
extern boolean_t spa_is_root(spa_t *spa);
extern boolean_t spa_writeable(spa_t *spa);
extern boolean_t spa_has_pending_synctask(spa_t *spa);
extern int spa_maxblocksize(spa_t *spa);
extern void zfs_blkptr_verify(spa_t *spa, const blkptr_t *bp);

extern int spa_mode(spa_t *spa);
extern uint64_t strtonum(const char *str, char **nptr);

extern char *spa_his_ievent_table[];

extern void spa_history_create_obj(spa_t *spa, dmu_tx_t *tx);
extern int spa_history_get(spa_t *spa, uint64_t *offset, uint64_t *len_read,
    char *his_buf);
extern int spa_history_log(spa_t *spa, const char *his_buf);
extern int spa_history_log_nvl(spa_t *spa, nvlist_t *nvl);
extern void spa_history_log_version(spa_t *spa, const char *operation);
extern void spa_history_log_internal(spa_t *spa, const char *operation,
    dmu_tx_t *tx, const char *fmt, ...);
extern void spa_history_log_internal_ds(struct dsl_dataset *ds, const char *op,
    dmu_tx_t *tx, const char *fmt, ...);
extern void spa_history_log_internal_dd(dsl_dir_t *dd, const char *operation,
    dmu_tx_t *tx, const char *fmt, ...);

/* error handling */
struct zbookmark_phys;
extern void spa_log_error(spa_t *spa, zio_t *zio);
extern void zfs_ereport_post(const char *class, spa_t *spa, vdev_t *vd,
    zio_t *zio, uint64_t stateoroffset, uint64_t length);
extern void zfs_post_remove(spa_t *spa, vdev_t *vd);
extern void zfs_post_state_change(spa_t *spa, vdev_t *vd);
extern void zfs_post_autoreplace(spa_t *spa, vdev_t *vd);
extern uint64_t spa_get_errlog_size(spa_t *spa);
extern int spa_get_errlog(spa_t *spa, void *uaddr, size_t *count);
extern void spa_errlog_rotate(spa_t *spa);
extern void spa_errlog_drain(spa_t *spa);
extern void spa_errlog_sync(spa_t *spa, uint64_t txg);
extern void spa_get_errlists(spa_t *spa, avl_tree_t *last, avl_tree_t *scrub);

/* vdev cache */
extern void vdev_cache_stat_init(void);
extern void vdev_cache_stat_fini(void);

/* Initialization and termination */
extern void spa_init(int flags);
extern void spa_fini(void);
extern void spa_boot_init(void);

/* properties */
extern int spa_prop_set(spa_t *spa, nvlist_t *nvp);
extern int spa_prop_get(spa_t *spa, nvlist_t **nvp);
extern void spa_prop_clear_bootfs(spa_t *spa, uint64_t obj, dmu_tx_t *tx);
extern void spa_configfile_set(spa_t *, nvlist_t *, boolean_t);

/* asynchronous event notification */
extern void spa_event_notify(spa_t *spa, vdev_t *vdev, const char *name);

#ifdef ZFS_DEBUG
#define	dprintf_bp(bp, fmt, ...) do {				\
	if (zfs_flags & ZFS_DEBUG_DPRINTF) {			\
	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\
	snprintf_blkptr(__blkbuf, BP_SPRINTF_LEN, (bp));	\
	dprintf(fmt " %s\n", __VA_ARGS__, __blkbuf);		\
	kmem_free(__blkbuf, BP_SPRINTF_LEN);			\
	} \
_NOTE(CONSTCOND) } while (0)
#else
#define	dprintf_bp(bp, fmt, ...)
#endif

extern boolean_t spa_debug_enabled(spa_t *spa);
#define	spa_dbgmsg(spa, ...)			\
{						\
	if (spa_debug_enabled(spa))		\
		zfs_dbgmsg(__VA_ARGS__);	\
}

extern int spa_mode_global;			/* mode, e.g. FREAD | FWRITE */

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_SPA_H */
                                                                                                                                                                                                                                                             usr/src/zfs-0.6.5.9/include/sys/spa_boot.h                                                          0100644 0000000 0000000 00000002242 13045171016 016500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef _SYS_SPA_BOOT_H
#define	_SYS_SPA_BOOT_H

#include <sys/nvpair.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern char *spa_get_bootprop(char *prop);
extern void spa_free_bootprop(char *prop);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_SPA_BOOT_H */
                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/spa_impl.h                                                          0100644 0000000 0000000 00000027033 13045171016 016503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2011, 2015 by Delphix. All rights reserved.
 * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 * Copyright (c) 2016 Actifio, Inc. All rights reserved.
 */

#ifndef _SYS_SPA_IMPL_H
#define	_SYS_SPA_IMPL_H

#include <sys/spa.h>
#include <sys/vdev.h>
#include <sys/metaslab.h>
#include <sys/dmu.h>
#include <sys/dsl_pool.h>
#include <sys/uberblock_impl.h>
#include <sys/zfs_context.h>
#include <sys/avl.h>
#include <sys/refcount.h>
#include <sys/bplist.h>
#include <sys/bpobj.h>
#include <sys/zfeature.h>
#include <zfeature_common.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct spa_error_entry {
	zbookmark_phys_t	se_bookmark;
	char			*se_name;
	avl_node_t		se_avl;
} spa_error_entry_t;

typedef struct spa_history_phys {
	uint64_t sh_pool_create_len;	/* ending offset of zpool create */
	uint64_t sh_phys_max_off;	/* physical EOF */
	uint64_t sh_bof;		/* logical BOF */
	uint64_t sh_eof;		/* logical EOF */
	uint64_t sh_records_lost;	/* num of records overwritten */
} spa_history_phys_t;

struct spa_aux_vdev {
	uint64_t	sav_object;		/* MOS object for device list */
	nvlist_t	*sav_config;		/* cached device config */
	vdev_t		**sav_vdevs;		/* devices */
	int		sav_count;		/* number devices */
	boolean_t	sav_sync;		/* sync the device list */
	nvlist_t	**sav_pending;		/* pending device additions */
	uint_t		sav_npending;		/* # pending devices */
};

typedef struct spa_config_lock {
	kmutex_t	scl_lock;
	kthread_t	*scl_writer;
	int		scl_write_wanted;
	kcondvar_t	scl_cv;
	refcount_t	scl_count;
} spa_config_lock_t;

typedef struct spa_config_dirent {
	list_node_t	scd_link;
	char		*scd_path;
} spa_config_dirent_t;

typedef enum zio_taskq_type {
	ZIO_TASKQ_ISSUE = 0,
	ZIO_TASKQ_ISSUE_HIGH,
	ZIO_TASKQ_INTERRUPT,
	ZIO_TASKQ_INTERRUPT_HIGH,
	ZIO_TASKQ_TYPES
} zio_taskq_type_t;

/*
 * State machine for the zpool-poolname process.  The states transitions
 * are done as follows:
 *
 *	From		   To			Routine
 *	PROC_NONE	-> PROC_CREATED		spa_activate()
 *	PROC_CREATED	-> PROC_ACTIVE		spa_thread()
 *	PROC_ACTIVE	-> PROC_DEACTIVATE	spa_deactivate()
 *	PROC_DEACTIVATE	-> PROC_GONE		spa_thread()
 *	PROC_GONE	-> PROC_NONE		spa_deactivate()
 */
typedef enum spa_proc_state {
	SPA_PROC_NONE,		/* spa_proc = &p0, no process created */
	SPA_PROC_CREATED,	/* spa_activate() has proc, is waiting */
	SPA_PROC_ACTIVE,	/* taskqs created, spa_proc set */
	SPA_PROC_DEACTIVATE,	/* spa_deactivate() requests process exit */
	SPA_PROC_GONE		/* spa_thread() is exiting, spa_proc = &p0 */
} spa_proc_state_t;

typedef struct spa_taskqs {
	uint_t stqs_count;
	taskq_t **stqs_taskq;
} spa_taskqs_t;

struct spa {
	/*
	 * Fields protected by spa_namespace_lock.
	 */
	char		spa_name[MAXNAMELEN];	/* pool name */
	char		*spa_comment;		/* comment */
	avl_node_t	spa_avl;		/* node in spa_namespace_avl */
	nvlist_t	*spa_config;		/* last synced config */
	nvlist_t	*spa_config_syncing;	/* currently syncing config */
	nvlist_t	*spa_config_splitting;	/* config for splitting */
	nvlist_t	*spa_load_info;		/* info and errors from load */
	uint64_t	spa_config_txg;		/* txg of last config change */
	int		spa_sync_pass;		/* iterate-to-convergence */
	pool_state_t	spa_state;		/* pool state */
	int		spa_inject_ref;		/* injection references */
	uint8_t		spa_sync_on;		/* sync threads are running */
	spa_load_state_t spa_load_state;	/* current load operation */
	uint64_t	spa_import_flags;	/* import specific flags */
	spa_taskqs_t	spa_zio_taskq[ZIO_TYPES][ZIO_TASKQ_TYPES];
	dsl_pool_t	*spa_dsl_pool;
	boolean_t	spa_is_initializing;	/* true while opening pool */
	metaslab_class_t *spa_normal_class;	/* normal data class */
	metaslab_class_t *spa_log_class;	/* intent log data class */
	uint64_t	spa_first_txg;		/* first txg after spa_open() */
	uint64_t	spa_final_txg;		/* txg of export/destroy */
	uint64_t	spa_freeze_txg;		/* freeze pool at this txg */
	uint64_t	spa_load_max_txg;	/* best initial ub_txg */
	uint64_t	spa_claim_max_txg;	/* highest claimed birth txg */
	timespec_t	spa_loaded_ts;		/* 1st successful open time */
	objset_t	*spa_meta_objset;	/* copy of dp->dp_meta_objset */
	kmutex_t	spa_evicting_os_lock;	/* Evicting objset list lock */
	list_t		spa_evicting_os_list;	/* Objsets being evicted. */
	kcondvar_t	spa_evicting_os_cv;	/* Objset Eviction Completion */
	txg_list_t	spa_vdev_txg_list;	/* per-txg dirty vdev list */
	vdev_t		*spa_root_vdev;		/* top-level vdev container */
	int		spa_min_ashift;		/* of vdevs in normal class */
	int		spa_max_ashift;		/* of vdevs in normal class */
	uint64_t	spa_config_guid;	/* config pool guid */
	uint64_t	spa_load_guid;		/* spa_load initialized guid */
	uint64_t	spa_last_synced_guid;	/* last synced guid */
	list_t		spa_config_dirty_list;	/* vdevs with dirty config */
	list_t		spa_state_dirty_list;	/* vdevs with dirty state */
	spa_aux_vdev_t	spa_spares;		/* hot spares */
	spa_aux_vdev_t	spa_l2cache;		/* L2ARC cache devices */
	nvlist_t	*spa_label_features;	/* Features for reading MOS */
	uint64_t	spa_config_object;	/* MOS object for pool config */
	uint64_t	spa_config_generation;	/* config generation number */
	uint64_t	spa_syncing_txg;	/* txg currently syncing */
	bpobj_t		spa_deferred_bpobj;	/* deferred-free bplist */
	bplist_t	spa_free_bplist[TXG_SIZE]; /* bplist of stuff to free */
	uberblock_t	spa_ubsync;		/* last synced uberblock */
	uberblock_t	spa_uberblock;		/* current uberblock */
	boolean_t	spa_extreme_rewind;	/* rewind past deferred frees */
	uint64_t	spa_last_io;		/* lbolt of last non-scan I/O */
	kmutex_t	spa_scrub_lock;		/* resilver/scrub lock */
	uint64_t	spa_scrub_inflight;	/* in-flight scrub I/Os */
	kcondvar_t	spa_scrub_io_cv;	/* scrub I/O completion */
	uint8_t		spa_scrub_active;	/* active or suspended? */
	uint8_t		spa_scrub_type;		/* type of scrub we're doing */
	uint8_t		spa_scrub_finished;	/* indicator to rotate logs */
	uint8_t		spa_scrub_started;	/* started since last boot */
	uint8_t		spa_scrub_reopen;	/* scrub doing vdev_reopen */
	uint64_t	spa_scan_pass_start;	/* start time per pass/reboot */
	uint64_t	spa_scan_pass_exam;	/* examined bytes per pass */
	kmutex_t	spa_async_lock;		/* protect async state */
	kthread_t	*spa_async_thread;	/* thread doing async task */
	int		spa_async_suspended;	/* async tasks suspended */
	kcondvar_t	spa_async_cv;		/* wait for thread_exit() */
	uint16_t	spa_async_tasks;	/* async task mask */
	char		*spa_root;		/* alternate root directory */
	uint64_t	spa_ena;		/* spa-wide ereport ENA */
	int		spa_last_open_failed;	/* error if last open failed */
	uint64_t	spa_last_ubsync_txg;	/* "best" uberblock txg */
	uint64_t	spa_last_ubsync_txg_ts;	/* timestamp from that ub */
	uint64_t	spa_load_txg;		/* ub txg that loaded */
	uint64_t	spa_load_txg_ts;	/* timestamp from that ub */
	uint64_t	spa_load_meta_errors;	/* verify metadata err count */
	uint64_t	spa_load_data_errors;	/* verify data err count */
	uint64_t	spa_verify_min_txg;	/* start txg of verify scrub */
	kmutex_t	spa_errlog_lock;	/* error log lock */
	uint64_t	spa_errlog_last;	/* last error log object */
	uint64_t	spa_errlog_scrub;	/* scrub error log object */
	kmutex_t	spa_errlist_lock;	/* error list/ereport lock */
	avl_tree_t	spa_errlist_last;	/* last error list */
	avl_tree_t	spa_errlist_scrub;	/* scrub error list */
	uint64_t	spa_deflate;		/* should we deflate? */
	uint64_t	spa_history;		/* history object */
	kmutex_t	spa_history_lock;	/* history lock */
	vdev_t		*spa_pending_vdev;	/* pending vdev additions */
	kmutex_t	spa_props_lock;		/* property lock */
	uint64_t	spa_pool_props_object;	/* object for properties */
	uint64_t	spa_bootfs;		/* default boot filesystem */
	uint64_t	spa_failmode;		/* failure mode for the pool */
	uint64_t	spa_delegation;		/* delegation on/off */
	list_t		spa_config_list;	/* previous cache file(s) */
	/* per-CPU array of root of async I/O: */
	zio_t		**spa_async_zio_root;
	zio_t		*spa_suspend_zio_root;	/* root of all suspended I/O */
	kmutex_t	spa_suspend_lock;	/* protects suspend_zio_root */
	kcondvar_t	spa_suspend_cv;		/* notification of resume */
	uint8_t		spa_suspended;		/* pool is suspended */
	uint8_t		spa_claiming;		/* pool is doing zil_claim() */
	boolean_t	spa_debug;		/* debug enabled? */
	boolean_t	spa_is_root;		/* pool is root */
	int		spa_minref;		/* num refs when first opened */
	int		spa_mode;		/* FREAD | FWRITE */
	spa_log_state_t spa_log_state;		/* log state */
	uint64_t	spa_autoexpand;		/* lun expansion on/off */
	ddt_t		*spa_ddt[ZIO_CHECKSUM_FUNCTIONS]; /* in-core DDTs */
	uint64_t	spa_ddt_stat_object;	/* DDT statistics */
	uint64_t	spa_dedup_ditto;	/* dedup ditto threshold */
	uint64_t	spa_dedup_checksum;	/* default dedup checksum */
	uint64_t	spa_dspace;		/* dspace in normal class */
	kmutex_t	spa_vdev_top_lock;	/* dueling offline/remove */
	kmutex_t	spa_proc_lock;		/* protects spa_proc* */
	kcondvar_t	spa_proc_cv;		/* spa_proc_state transitions */
	spa_proc_state_t spa_proc_state;	/* see definition */
	proc_t		*spa_proc;		/* "zpool-poolname" process */
	uint64_t	spa_did;		/* if procp != p0, did of t1 */
	boolean_t	spa_autoreplace;	/* autoreplace set in open */
	int		spa_vdev_locks;		/* locks grabbed */
	uint64_t	spa_creation_version;	/* version at pool creation */
	uint64_t	spa_prev_software_version; /* See ub_software_version */
	uint64_t	spa_feat_for_write_obj;	/* required to write to pool */
	uint64_t	spa_feat_for_read_obj;	/* required to read from pool */
	uint64_t	spa_feat_desc_obj;	/* Feature descriptions */
	uint64_t	spa_feat_enabled_txg_obj; /* Feature enabled txg */
	kmutex_t	spa_feat_stats_lock;	/* protects spa_feat_stats */
	nvlist_t	*spa_feat_stats;	/* Cache of enabled features */
	/* cache feature refcounts */
	uint64_t	spa_feat_refcount_cache[SPA_FEATURES];
	taskqid_t	spa_deadman_tqid;	/* Task id */
	uint64_t	spa_deadman_calls;	/* number of deadman calls */
	hrtime_t	spa_sync_starttime;	/* starting time of spa_sync */
	uint64_t	spa_deadman_synctime;	/* deadman expiration timer */
	uint64_t	spa_errata;		/* errata issues detected */
	spa_stats_t	spa_stats;		/* assorted spa statistics */
	taskq_t		*spa_zvol_taskq;	/* Taskq for minor managment */

	/*
	 * spa_refcount & spa_config_lock must be the last elements
	 * because refcount_t changes size based on compilation options.
	 * In order for the MDB module to function correctly, the other
	 * fields must remain in the same location.
	 */
	spa_config_lock_t spa_config_lock[SCL_LOCKS]; /* config changes */
	refcount_t	spa_refcount;		/* number of opens */
};

extern char *spa_config_path;

extern void spa_taskq_dispatch_ent(spa_t *spa, zio_type_t t, zio_taskq_type_t q,
    task_func_t *func, void *arg, uint_t flags, taskq_ent_t *ent);
extern void spa_taskq_dispatch_sync(spa_t *, zio_type_t t, zio_taskq_type_t q,
    task_func_t *func, void *arg, uint_t flags);


#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_SPA_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/include/sys/space_map.h                                                         0100644 0000000 0000000 00000012673 13045171016 016633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_SPACE_MAP_H
#define	_SYS_SPACE_MAP_H

#include <sys/avl.h>
#include <sys/range_tree.h>
#include <sys/dmu.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * The size of the space map object has increased to include a histogram.
 * The SPACE_MAP_SIZE_V0 designates the original size and is used to
 * maintain backward compatibility.
 */
#define	SPACE_MAP_SIZE_V0	(3 * sizeof (uint64_t))
#define	SPACE_MAP_HISTOGRAM_SIZE	32

/*
 * The space_map_phys is the on-disk representation of the space map.
 * Consumers of space maps should never reference any of the members of this
 * structure directly. These members may only be updated in syncing context.
 *
 * Note the smp_object is no longer used but remains in the structure
 * for backward compatibility.
 */
typedef struct space_map_phys {
	uint64_t	smp_object;	/* on-disk space map object */
	uint64_t	smp_objsize;	/* size of the object */
	uint64_t	smp_alloc;	/* space allocated from the map */
	uint64_t	smp_pad[5];	/* reserved */

	/*
	 * The smp_histogram maintains a histogram of free regions. Each
	 * bucket, smp_histogram[i], contains the number of free regions
	 * whose size is:
	 * 2^(i+sm_shift) <= size of free region in bytes < 2^(i+sm_shift+1)
	 */
	uint64_t	smp_histogram[SPACE_MAP_HISTOGRAM_SIZE];
} space_map_phys_t;

/*
 * The space map object defines a region of space, its size, how much is
 * allocated, and the on-disk object that stores this information.
 * Consumers of space maps may only access the members of this structure.
 */
typedef struct space_map {
	uint64_t	sm_start;	/* start of map */
	uint64_t	sm_size;	/* size of map */
	uint8_t		sm_shift;	/* unit shift */
	uint64_t	sm_length;	/* synced length */
	uint64_t	sm_alloc;	/* synced space allocated */
	objset_t	*sm_os;		/* objset for this map */
	uint64_t	sm_object;	/* object id for this map */
	uint32_t	sm_blksz;	/* block size for space map */
	dmu_buf_t	*sm_dbuf;	/* space_map_phys_t dbuf */
	space_map_phys_t *sm_phys;	/* on-disk space map */
	kmutex_t	*sm_lock;	/* pointer to lock that protects map */
} space_map_t;

/*
 * debug entry
 *
 *    1      3         10                     50
 *  ,---+--------+------------+---------------------------------.
 *  | 1 | action |  syncpass  |        txg (lower bits)         |
 *  `---+--------+------------+---------------------------------'
 *   63  62    60 59        50 49                               0
 *
 *
 * non-debug entry
 *
 *    1               47                   1           15
 *  ,-----------------------------------------------------------.
 *  | 0 |   offset (sm_shift units)    | type |       run       |
 *  `-----------------------------------------------------------'
 *   63  62                          17   16   15               0
 */

/* All this stuff takes and returns bytes */
#define	SM_RUN_DECODE(x)	(BF64_DECODE(x, 0, 15) + 1)
#define	SM_RUN_ENCODE(x)	BF64_ENCODE((x) - 1, 0, 15)
#define	SM_TYPE_DECODE(x)	BF64_DECODE(x, 15, 1)
#define	SM_TYPE_ENCODE(x)	BF64_ENCODE(x, 15, 1)
#define	SM_OFFSET_DECODE(x)	BF64_DECODE(x, 16, 47)
#define	SM_OFFSET_ENCODE(x)	BF64_ENCODE(x, 16, 47)
#define	SM_DEBUG_DECODE(x)	BF64_DECODE(x, 63, 1)
#define	SM_DEBUG_ENCODE(x)	BF64_ENCODE(x, 63, 1)

#define	SM_DEBUG_ACTION_DECODE(x)	BF64_DECODE(x, 60, 3)
#define	SM_DEBUG_ACTION_ENCODE(x)	BF64_ENCODE(x, 60, 3)

#define	SM_DEBUG_SYNCPASS_DECODE(x)	BF64_DECODE(x, 50, 10)
#define	SM_DEBUG_SYNCPASS_ENCODE(x)	BF64_ENCODE(x, 50, 10)

#define	SM_DEBUG_TXG_DECODE(x)		BF64_DECODE(x, 0, 50)
#define	SM_DEBUG_TXG_ENCODE(x)		BF64_ENCODE(x, 0, 50)

#define	SM_RUN_MAX			SM_RUN_DECODE(~0ULL)

typedef enum {
	SM_ALLOC,
	SM_FREE
} maptype_t;

int space_map_load(space_map_t *sm, range_tree_t *rt, maptype_t maptype);

void space_map_histogram_clear(space_map_t *sm);
void space_map_histogram_add(space_map_t *sm, range_tree_t *rt,
    dmu_tx_t *tx);

void space_map_update(space_map_t *sm);

uint64_t space_map_object(space_map_t *sm);
uint64_t space_map_allocated(space_map_t *sm);
uint64_t space_map_length(space_map_t *sm);

void space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
    dmu_tx_t *tx);
void space_map_truncate(space_map_t *sm, dmu_tx_t *tx);
uint64_t space_map_alloc(objset_t *os, dmu_tx_t *tx);
void space_map_free(space_map_t *sm, dmu_tx_t *tx);

int space_map_open(space_map_t **smp, objset_t *os, uint64_t object,
    uint64_t start, uint64_t size, uint8_t shift, kmutex_t *lp);
void space_map_close(space_map_t *sm);

int64_t space_map_alloc_delta(space_map_t *sm);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_SPACE_MAP_H */
                                                                     usr/src/zfs-0.6.5.9/include/sys/space_reftree.h                                                     0100644 0000000 0000000 00000003257 13045171016 017510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        