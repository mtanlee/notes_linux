"position_column\*(R" which \fBwould
never be assigned to a row\fR during normal operation. When
a row is moved, its position is set to this value temporarily, so
that any unique constraints can not be violated. This value defaults
to 0, which should work for all cases except when your positions do
indeed start from 0.
.SS "siblings"
.IX Subsection "siblings"
.Vb 2
\&  my $rs = $item\->siblings();
\&  my @siblings = $item\->siblings();
.Ve
.PP
Returns an \fBordered\fR resultset of all other objects in the same
group excluding the one you called it on.
.PP
The ordering is a backwards-compatibility artifact \- if you need
a resultset with no ordering applied use \*(L"_siblings\*(R"
.SS "previous_siblings"
.IX Subsection "previous_siblings"
.Vb 2
\&  my $prev_rs = $item\->previous_siblings();
\&  my @prev_siblings = $item\->previous_siblings();
.Ve
.PP
Returns a resultset of all objects in the same group
positioned before the object on which this method was called.
.SS "next_siblings"
.IX Subsection "next_siblings"
.Vb 2
\&  my $next_rs = $item\->next_siblings();
\&  my @next_siblings = $item\->next_siblings();
.Ve
.PP
Returns a resultset of all objects in the same group
positioned after the object on which this method was called.
.SS "previous_sibling"
.IX Subsection "previous_sibling"
.Vb 1
\&  my $sibling = $item\->previous_sibling();
.Ve
.PP
Returns the sibling that resides one position back.  Returns 0
if the current object is the first one.
.SS "first_sibling"
.IX Subsection "first_sibling"
.Vb 1
\&  my $sibling = $item\->first_sibling();
.Ve
.PP
Returns the first sibling object, or 0 if the first sibling
is this sibling.
.SS "next_sibling"
.IX Subsection "next_sibling"
.Vb 1
\&  my $sibling = $item\->next_sibling();
.Ve
.PP
Returns the sibling that resides one position forward. Returns 0
if the current object is the last one.
.SS "last_sibling"
.IX Subsection "last_sibling"
.Vb 1
\&  my $sibling = $item\->last_sibling();
.Ve
.PP
Returns the last sibling, or 0 if the last sibling is this
sibling.
.SS "move_previous"
.IX Subsection "move_previous"
.Vb 1
\&  $item\->move_previous();
.Ve
.PP
Swaps position with the sibling in the position previous in
the list.  Returns 1 on success, and 0 if the object is
already the first one.
.SS "move_next"
.IX Subsection "move_next"
.Vb 1
\&  $item\->move_next();
.Ve
.PP
Swaps position with the sibling in the next position in the
list.  Returns 1 on success, and 0 if the object is already
the last in the list.
.SS "move_first"
.IX Subsection "move_first"
.Vb 1
\&  $item\->move_first();
.Ve
.PP
Moves the object to the first position in the list.  Returns 1
on success, and 0 if the object is already the first.
.SS "move_last"
.IX Subsection "move_last"
.Vb 1
\&  $item\->move_last();
.Ve
.PP
Moves the object to the last position in the list.  Returns 1
on success, and 0 if the object is already the last one.
.SS "move_to"
.IX Subsection "move_to"
.Vb 1
\&  $item\->move_to( $position );
.Ve
.PP
Moves the object to the specified position.  Returns 1 on
success, and 0 if the object is already at the specified
position.
.SS "move_to_group"
.IX Subsection "move_to_group"
.Vb 1
\&  $item\->move_to_group( $group, $position );
.Ve
.PP
Moves the object to the specified position of the specified
group, or to the end of the group if \f(CW$position\fR is undef.
1 is returned on success, and 0 is returned if the object is
already at the specified position of the specified group.
.PP
\&\f(CW$group\fR may be specified as a single scalar if only one
grouping column is in use, or as a hashref of column => value pairs
if multiple grouping columns are in use.
.SS "insert"
.IX Subsection "insert"
Overrides the \s-1DBIC\s0 \fIinsert()\fR method by providing a default
position number.  The default will be the number of rows in
the table +1, thus positioning the new record at the last position.
.SS "update"
.IX Subsection "update"
Overrides the \s-1DBIC\s0 \fIupdate()\fR method by checking for a change
to the position and/or group columns.  Movement within a
group or to another group is handled by repositioning
the appropriate siblings.  Position defaults to the end
of a new group if it has been changed to undef.
.SS "delete"
.IX Subsection "delete"
Overrides the \s-1DBIC\s0 \fIdelete()\fR method by first moving the object
to the last position, then deleting it, thus ensuring the
integrity of the positions.
.SH "METHODS FOR EXTENDING ORDERED"
.IX Header "METHODS FOR EXTENDING ORDERED"
You would want to override the methods below if you use sparse
(non-linear) or non-numeric position values. This can be useful
if you are working with preexisting non-normalised position data,
or if you need to work with materialized path columns.
.SS "_position_from_value"
.IX Subsection "_position_from_value"
.Vb 1
\&  my $num_pos = $item\->_position_from_value ( $pos_value )
.Ve
.PP
Returns the \fBabsolute numeric position\fR of an object with a \fBposition
value\fR set to \f(CW$pos_value\fR. By default simply returns \f(CW$pos_value\fR.
.SS "_position_value"
.IX Subsection "_position_value"
.Vb 1
\&  my $pos_value = $item\->_position_value ( $pos )
.Ve
.PP
Returns the \fBvalue\fR of \*(L"position_column\*(R" of the object at numeric
position \f(CW$pos\fR. By default simply returns \f(CW$pos\fR.
.SS "_initial_position_value"
.IX Subsection "_initial_position_value"
.Vb 1
\&  _\|_PACKAGE_\|_\->_initial_position_value(0);
.Ve
.PP
This method specifies a \fBvalue\fR of \*(L"position_column\*(R" which is assigned
to the first inserted element of a group, if no value was supplied at
insertion time. All subsequent values are derived from this one by
\&\*(L"_next_position_value\*(R" below. Defaults to 1.
.SS "_next_position_value"
.IX Subsection "_next_position_value"
.Vb 1
\&  my $new_value = $item\->_next_position_value ( $position_value )
.Ve
.PP
Returns a position \fBvalue\fR that would be considered \f(CW\*(C`next\*(C'\fR with
regards to \f(CW$position_value\fR. Can be pretty much anything, given
that \f(CW\*(C`$position_value < $new_value\*(C'\fR where \f(CW\*(C`<\*(C'\fR is the
\&\s-1SQL\s0 comparison operator (usually works fine on strings). The
default method expects \f(CW$position_value\fR to be numeric, and
returns \f(CW\*(C`$position_value + 1\*(C'\fR
.SS "_shift_siblings"
.IX Subsection "_shift_siblings"
.Vb 1
\&  $item\->_shift_siblings ($direction, @between)
.Ve
.PP
Shifts all siblings with \fBpositions values\fR in the range \f(CW@between\fR
(inclusive) by one position as specified by \f(CW$direction\fR (left if < 0,
 right if > 0). By default simply increments/decrements each
\&\*(L"position_column\*(R" value by 1, doing so in a way as to not violate
any existing constraints.
.PP
Note that if you override this method and have unique constraints
including the \*(L"position_column\*(R" the shift is not a trivial task.
Refer to the implementation source of the default method for more
information.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Resultset Methods"
.IX Subsection "Resultset Methods"
Note that all Insert/Create/Delete overrides are happening on
DBIx::Class::Row methods only. If you use the
DBIx::Class::ResultSet versions of
update or
delete, all logic present in this
module will be bypassed entirely (possibly resulting in a broken
order-tree). Instead always use the
update_all and
delete_all methods, which will
invoke the corresponding row method on every
member of the given resultset.
.SS "Race Condition on Insert"
.IX Subsection "Race Condition on Insert"
If a position is not specified for an insert, a position
will be chosen based either on \*(L"_initial_position_value\*(R" or
\&\*(L"_next_position_value\*(R", depending if there are already some
items in the current group. The space of time between the
necessary selects and insert introduces a race condition.
Having unique constraints on your position/group columns,
and using transactions (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
will prevent such race conditions going undetected.
.SS "Multiple Moves"
.IX Subsection "Multiple Moves"
Be careful when issuing move_* methods to multiple objects.  If
you've pre-loaded the objects then when you move one of the objects
the position of the other object will not reflect their new value
until you reload them from the database \- see
\&\*(L"discard_changes\*(R" in DBIx::Class::Row.
.PP
There are times when you will want to move objects as groups, such
as changing the parent of several objects at once \- this directly
conflicts with this problem.  One solution is for us to write a
ResultSet class that supports a \fIparent()\fR method, for example.  Another
solution is to somehow automagically modify the objects that exist
in the current object's result set to have the new position value.
.SS "Default Values"
.IX Subsection "Default Values"
Using a database defined default_value on one of your group columns
could result in the position not being assigned correctly.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Original code framework
\&   Aran Deltac <bluefeet@cpan.org>
\&
\& Constraints support and code generalisation
\&   Peter Rabbitson <ribasushi@cpan.org>
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Ordered5.16.3pm                 0100644 0001750 0001750 00000040505 12566242362 025250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Ordered 3"
.TH DBIx::Class::Ordered 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Ordered \- Modify the position of objects in an ordered list.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Create a table for your ordered data.
.PP
.Vb 5
\&  CREATE TABLE items (
\&    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
\&    name TEXT NOT NULL,
\&    position INTEGER NOT NULL
\&  );
.Ve
.PP
Optionally, add one or more columns to specify groupings, allowing you
to maintain independent ordered lists within one table:
.PP
.Vb 6
\&  CREATE TABLE items (
\&    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
\&    name TEXT NOT NULL,
\&    position INTEGER NOT NULL,
\&    group_id INTEGER NOT NULL
\&  );
.Ve
.PP
Or even
.PP
.Vb 7
\&  CREATE TABLE items (
\&    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
\&    name TEXT NOT NULL,
\&    position INTEGER NOT NULL,
\&    group_id INTEGER NOT NULL,
\&    other_group_id INTEGER NOT NULL
\&  );
.Ve
.PP
In your Schema or \s-1DB\s0 class add \*(L"Ordered\*(R" to the top
of the component list.
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->load_components(qw( Ordered ... ));
.Ve
.PP
Specify the column that stores the position number for
each row.
.PP
.Vb 2
\&  package My::Item;
\&  _\|_PACKAGE_\|_\->position_column(\*(Aqposition\*(Aq);
.Ve
.PP
If you are using one grouping column, specify it as follows:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->grouping_column(\*(Aqgroup_id\*(Aq);
.Ve
.PP
Or if you have multiple grouping columns:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->grouping_column([\*(Aqgroup_id\*(Aq, \*(Aqother_group_id\*(Aq]);
.Ve
.PP
That's it, now you can change the position of your objects.
.PP
.Vb 2
\&  #!/use/bin/perl
\&  use My::Item;
\&
\&  my $item = My::Item\->create({ name=>\*(AqMatt S. Trout\*(Aq });
\&  # If using grouping_column:
\&  my $item = My::Item\->create({ name=>\*(AqMatt S. Trout\*(Aq, group_id=>1 });
\&
\&  my $rs = $item\->siblings();
\&  my @siblings = $item\->siblings();
\&
\&  my $sibling;
\&  $sibling = $item\->first_sibling();
\&  $sibling = $item\->last_sibling();
\&  $sibling = $item\->previous_sibling();
\&  $sibling = $item\->next_sibling();
\&
\&  $item\->move_previous();
\&  $item\->move_next();
\&  $item\->move_first();
\&  $item\->move_last();
\&  $item\->move_to( $position );
\&  $item\->move_to_group( \*(Aqgroupname\*(Aq );
\&  $item\->move_to_group( \*(Aqgroupname\*(Aq, $position );
\&  $item\->move_to_group( {group_id=>\*(Aqgroupname\*(Aq, \*(Aqother_group_id=>\*(Aqothergroupname\*(Aq} );
\&  $item\->move_to_group( {group_id=>\*(Aqgroupname\*(Aq, \*(Aqother_group_id=>\*(Aqothergroupname\*(Aq}, $position );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a simple interface for modifying the ordered
position of DBIx::Class objects.
.SH "AUTO UPDATE"
.IX Header "AUTO UPDATE"
All of the move_* methods automatically update the rows involved in
the query.  This is not configurable and is due to the fact that if you
move a record it always causes other records in the list to be updated.
.SH "METHODS"
.IX Header "METHODS"
.SS "position_column"
.IX Subsection "position_column"
.Vb 1
\&  _\|_PACKAGE_\|_\->position_column(\*(Aqposition\*(Aq);
.Ve
.PP
Sets and retrieves the name of the column that stores the
positional value of each record.  Defaults to \*(L"position\*(R".
.SS "grouping_column"
.IX Subsection "grouping_column"
.Vb 1
\&  _\|_PACKAGE_\|_\->grouping_column(\*(Aqgroup_id\*(Aq);
.Ve
.PP
This method specifies a column to limit all queries in
this module by.  This effectively allows you to have multiple
ordered lists within the same table.
.SS "null_position_value"
.IX Subsection "null_position_value"
.Vb 1
\&  _\|_PACKAGE_\|_\->null_position_value(undef);
.Ve
.PP
This method specifies a value of \*(L"position_column\*(R" which \fBwould
never be assigned to a row\fR during normal operation. When
a row is moved, its position is set to this value temporarily, so
that any unique constraints can not be violated. This value defaults
to 0, which should work for all cases except when your positions do
indeed start from 0.
.SS "siblings"
.IX Subsection "siblings"
.Vb 2
\&  my $rs = $item\->siblings();
\&  my @siblings = $item\->siblings();
.Ve
.PP
Returns an \fBordered\fR resultset of all other objects in the same
group excluding the one you called it on.
.PP
The ordering is a backwards-compatibility artifact \- if you need
a resultset with no ordering applied use \*(L"_siblings\*(R"
.SS "previous_siblings"
.IX Subsection "previous_siblings"
.Vb 2
\&  my $prev_rs = $item\->previous_siblings();
\&  my @prev_siblings = $item\->previous_siblings();
.Ve
.PP
Returns a resultset of all objects in the same group
positioned before the object on which this method was called.
.SS "next_siblings"
.IX Subsection "next_siblings"
.Vb 2
\&  my $next_rs = $item\->next_siblings();
\&  my @next_siblings = $item\->next_siblings();
.Ve
.PP
Returns a resultset of all objects in the same group
positioned after the object on which this method was called.
.SS "previous_sibling"
.IX Subsection "previous_sibling"
.Vb 1
\&  my $sibling = $item\->previous_sibling();
.Ve
.PP
Returns the sibling that resides one position back.  Returns 0
if the current object is the first one.
.SS "first_sibling"
.IX Subsection "first_sibling"
.Vb 1
\&  my $sibling = $item\->first_sibling();
.Ve
.PP
Returns the first sibling object, or 0 if the first sibling
is this sibling.
.SS "next_sibling"
.IX Subsection "next_sibling"
.Vb 1
\&  my $sibling = $item\->next_sibling();
.Ve
.PP
Returns the sibling that resides one position forward. Returns 0
if the current object is the last one.
.SS "last_sibling"
.IX Subsection "last_sibling"
.Vb 1
\&  my $sibling = $item\->last_sibling();
.Ve
.PP
Returns the last sibling, or 0 if the last sibling is this
sibling.
.SS "move_previous"
.IX Subsection "move_previous"
.Vb 1
\&  $item\->move_previous();
.Ve
.PP
Swaps position with the sibling in the position previous in
the list.  Returns 1 on success, and 0 if the object is
already the first one.
.SS "move_next"
.IX Subsection "move_next"
.Vb 1
\&  $item\->move_next();
.Ve
.PP
Swaps position with the sibling in the next position in the
list.  Returns 1 on success, and 0 if the object is already
the last in the list.
.SS "move_first"
.IX Subsection "move_first"
.Vb 1
\&  $item\->move_first();
.Ve
.PP
Moves the object to the first position in the list.  Returns 1
on success, and 0 if the object is already the first.
.SS "move_last"
.IX Subsection "move_last"
.Vb 1
\&  $item\->move_last();
.Ve
.PP
Moves the object to the last position in the list.  Returns 1
on success, and 0 if the object is already the last one.
.SS "move_to"
.IX Subsection "move_to"
.Vb 1
\&  $item\->move_to( $position );
.Ve
.PP
Moves the object to the specified position.  Returns 1 on
success, and 0 if the object is already at the specified
position.
.SS "move_to_group"
.IX Subsection "move_to_group"
.Vb 1
\&  $item\->move_to_group( $group, $position );
.Ve
.PP
Moves the object to the specified position of the specified
group, or to the end of the group if \f(CW$position\fR is undef.
1 is returned on success, and 0 is returned if the object is
already at the specified position of the specified group.
.PP
\&\f(CW$group\fR may be specified as a single scalar if only one
grouping column is in use, or as a hashref of column => value pairs
if multiple grouping columns are in use.
.SS "insert"
.IX Subsection "insert"
Overrides the \s-1DBIC\s0 \fIinsert()\fR method by providing a default
position number.  The default will be the number of rows in
the table +1, thus positioning the new record at the last position.
.SS "update"
.IX Subsection "update"
Overrides the \s-1DBIC\s0 \fIupdate()\fR method by checking for a change
to the position and/or group columns.  Movement within a
group or to another group is handled by repositioning
the appropriate siblings.  Position defaults to the end
of a new group if it has been changed to undef.
.SS "delete"
.IX Subsection "delete"
Overrides the \s-1DBIC\s0 \fIdelete()\fR method by first moving the object
to the last position, then deleting it, thus ensuring the
integrity of the positions.
.SH "METHODS FOR EXTENDING ORDERED"
.IX Header "METHODS FOR EXTENDING ORDERED"
You would want to override the methods below if you use sparse
(non-linear) or non-numeric position values. This can be useful
if you are working with preexisting non-normalised position data,
or if you need to work with materialized path columns.
.SS "_position_from_value"
.IX Subsection "_position_from_value"
.Vb 1
\&  my $num_pos = $item\->_position_from_value ( $pos_value )
.Ve
.PP
Returns the \fBabsolute numeric position\fR of an object with a \fBposition
value\fR set to \f(CW$pos_value\fR. By default simply returns \f(CW$pos_value\fR.
.SS "_position_value"
.IX Subsection "_position_value"
.Vb 1
\&  my $pos_value = $item\->_position_value ( $pos )
.Ve
.PP
Returns the \fBvalue\fR of \*(L"position_column\*(R" of the object at numeric
position \f(CW$pos\fR. By default simply returns \f(CW$pos\fR.
.SS "_initial_position_value"
.IX Subsection "_initial_position_value"
.Vb 1
\&  _\|_PACKAGE_\|_\->_initial_position_value(0);
.Ve
.PP
This method specifies a \fBvalue\fR of \*(L"position_column\*(R" which is assigned
to the first inserted element of a group, if no value was supplied at
insertion time. All subsequent values are derived from this one by
\&\*(L"_next_position_value\*(R" below. Defaults to 1.
.SS "_next_position_value"
.IX Subsection "_next_position_value"
.Vb 1
\&  my $new_value = $item\->_next_position_value ( $position_value )
.Ve
.PP
Returns a position \fBvalue\fR that would be considered \f(CW\*(C`next\*(C'\fR with
regards to \f(CW$position_value\fR. Can be pretty much anything, given
that \f(CW\*(C`$position_value < $new_value\*(C'\fR where \f(CW\*(C`<\*(C'\fR is the
\&\s-1SQL\s0 comparison operator (usually works fine on strings). The
default method expects \f(CW$position_value\fR to be numeric, and
returns \f(CW\*(C`$position_value + 1\*(C'\fR
.SS "_shift_siblings"
.IX Subsection "_shift_siblings"
.Vb 1
\&  $item\->_shift_siblings ($direction, @between)
.Ve
.PP
Shifts all siblings with \fBpositions values\fR in the range \f(CW@between\fR
(inclusive) by one position as specified by \f(CW$direction\fR (left if < 0,
 right if > 0). By default simply increments/decrements each
\&\*(L"position_column\*(R" value by 1, doing so in a way as to not violate
any existing constraints.
.PP
Note that if you override this method and have unique constraints
including the \*(L"position_column\*(R" the shift is not a trivial task.
Refer to the implementation source of the default method for more
information.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Resultset Methods"
.IX Subsection "Resultset Methods"
Note that all Insert/Create/Delete overrides are happening on
DBIx::Class::Row methods only. If you use the
DBIx::Class::ResultSet versions of
update or
delete, all logic present in this
module will be bypassed entirely (possibly resulting in a broken
order-tree). Instead always use the
update_all and
delete_all methods, which will
invoke the corresponding row method on every
member of the given resultset.
.SS "Race Condition on Insert"
.IX Subsection "Race Condition on Insert"
If a position is not specified for an insert, a position
will be chosen based either on \*(L"_initial_position_value\*(R" or
\&\*(L"_next_position_value\*(R", depending if there are already some
items in the current group. The space of time between the
necessary selects and insert introduces a race condition.
Having unique constraints on your position/group columns,
and using transactions (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
will prevent such race conditions going undetected.
.SS "Multiple Moves"
.IX Subsection "Multiple Moves"
Be careful when issuing move_* methods to multiple objects.  If
you've pre-loaded the objects then when you move one of the objects
the position of the other object will not reflect their new value
until you reload them from the database \- see
\&\*(L"discard_changes\*(R" in DBIx::Class::Row.
.PP
There are times when you will want to move objects as groups, such
as changing the parent of several objects at once \- this directly
conflicts with this problem.  One solution is for us to write a
ResultSet class that supports a \fIparent()\fR method, for example.  Another
solution is to somehow automagically modify the objects that exist
in the current object's result set to have the new position value.
.SS "Default Values"
.IX Subsection "Default Values"
Using a database defined default_value on one of your group columns
could result in the position not being assigned correctly.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Original code framework
\&   Aran Deltac <bluefeet@cpan.org>
\&
\& Constraints support and code generalisation
\&   Peter Rabbitson <ribasushi@cpan.org>
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Ordered5.18.3pm                 0100644 0001750 0001750 00000041026 12566242400 025242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Ordered 3"
.TH DBIx::Class::Ordered 3 "2014-01-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Ordered \- Modify the position of objects in an ordered list.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Create a table for your ordered data.
.PP
.Vb 5
\&  CREATE TABLE items (
\&    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
\&    name TEXT NOT NULL,
\&    position INTEGER NOT NULL
\&  );
.Ve
.PP
Optionally, add one or more columns to specify groupings, allowing you
to maintain independent ordered lists within one table:
.PP
.Vb 6
\&  CREATE TABLE items (
\&    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
\&    name TEXT NOT NULL,
\&    position INTEGER NOT NULL,
\&    group_id INTEGER NOT NULL
\&  );
.Ve
.PP
Or even
.PP
.Vb 7
\&  CREATE TABLE items (
\&    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
\&    name TEXT NOT NULL,
\&    position INTEGER NOT NULL,
\&    group_id INTEGER NOT NULL,
\&    other_group_id INTEGER NOT NULL
\&  );
.Ve
.PP
In your Schema or \s-1DB\s0 class add \*(L"Ordered\*(R" to the top
of the component list.
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->load_components(qw( Ordered ... ));
.Ve
.PP
Specify the column that stores the position number for
each row.
.PP
.Vb 2
\&  package My::Item;
\&  _\|_PACKAGE_\|_\->position_column(\*(Aqposition\*(Aq);
.Ve
.PP
If you are using one grouping column, specify it as follows:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->grouping_column(\*(Aqgroup_id\*(Aq);
.Ve
.PP
Or if you have multiple grouping columns:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->grouping_column([\*(Aqgroup_id\*(Aq, \*(Aqother_group_id\*(Aq]);
.Ve
.PP
That's it, now you can change the position of your objects.
.PP
.Vb 2
\&  #!/use/bin/perl
\&  use My::Item;
\&
\&  my $item = My::Item\->create({ name=>\*(AqMatt S. Trout\*(Aq });
\&  # If using grouping_column:
\&  my $item = My::Item\->create({ name=>\*(AqMatt S. Trout\*(Aq, group_id=>1 });
\&
\&  my $rs = $item\->siblings();
\&  my @siblings = $item\->siblings();
\&
\&  my $sibling;
\&  $sibling = $item\->first_sibling();
\&  $sibling = $item\->last_sibling();
\&  $sibling = $item\->previous_sibling();
\&  $sibling = $item\->next_sibling();
\&
\&  $item\->move_previous();
\&  $item\->move_next();
\&  $item\->move_first();
\&  $item\->move_last();
\&  $item\->move_to( $position );
\&  $item\->move_to_group( \*(Aqgroupname\*(Aq );
\&  $item\->move_to_group( \*(Aqgroupname\*(Aq, $position );
\&  $item\->move_to_group( {group_id=>\*(Aqgroupname\*(Aq, \*(Aqother_group_id=>\*(Aqothergroupname\*(Aq} );
\&  $item\->move_to_group( {group_id=>\*(Aqgroupname\*(Aq, \*(Aqother_group_id=>\*(Aqothergroupname\*(Aq}, $position );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a simple interface for modifying the ordered
position of DBIx::Class objects.
.SH "AUTO UPDATE"
.IX Header "AUTO UPDATE"
All of the move_* methods automatically update the rows involved in
the query.  This is not configurable and is due to the fact that if you
move a record it always causes other records in the list to be updated.
.SH "METHODS"
.IX Header "METHODS"
.SS "position_column"
.IX Subsection "position_column"
.Vb 1
\&  _\|_PACKAGE_\|_\->position_column(\*(Aqposition\*(Aq);
.Ve
.PP
Sets and retrieves the name of the column that stores the
positional value of each record.  Defaults to \*(L"position\*(R".
.SS "grouping_column"
.IX Subsection "grouping_column"
.Vb 1
\&  _\|_PACKAGE_\|_\->grouping_column(\*(Aqgroup_id\*(Aq);
.Ve
.PP
This method specifies a column to limit all queries in
this module by.  This effectively allows you to have multiple
ordered lists within the same table.
.SS "null_position_value"
.IX Subsection "null_position_value"
.Vb 1
\&  _\|_PACKAGE_\|_\->null_position_value(undef);
.Ve
.PP
This method specifies a value of \*(L"position_column\*(R" which \fBwould
never be assigned to a row\fR during normal operation. When
a row is moved, its position is set to this value temporarily, so
that any unique constraints can not be violated. This value defaults
to 0, which should work for all cases except when your positions do
indeed start from 0.
.SS "siblings"
.IX Subsection "siblings"
.Vb 2
\&  my $rs = $item\->siblings();
\&  my @siblings = $item\->siblings();
.Ve
.PP
Returns an \fBordered\fR resultset of all other objects in the same
group excluding the one you called it on.
.PP
The ordering is a backwards-compatibility artifact \- if you need
a resultset with no ordering applied use \*(L"_siblings\*(R"
.SS "previous_siblings"
.IX Subsection "previous_siblings"
.Vb 2
\&  my $prev_rs = $item\->previous_siblings();
\&  my @prev_siblings = $item\->previous_siblings();
.Ve
.PP
Returns a resultset of all objects in the same group
positioned before the object on which this method was called.
.SS "next_siblings"
.IX Subsection "next_siblings"
.Vb 2
\&  my $next_rs = $item\->next_siblings();
\&  my @next_siblings = $item\->next_siblings();
.Ve
.PP
Returns a resultset of all objects in the same group
positioned after the object on which this method was called.
.SS "previous_sibling"
.IX Subsection "previous_sibling"
.Vb 1
\&  my $sibling = $item\->previous_sibling();
.Ve
.PP
Returns the sibling that resides one position back.  Returns 0
if the current object is the first one.
.SS "first_sibling"
.IX Subsection "first_sibling"
.Vb 1
\&  my $sibling = $item\->first_sibling();
.Ve
.PP
Returns the first sibling object, or 0 if the first sibling
is this sibling.
.SS "next_sibling"
.IX Subsection "next_sibling"
.Vb 1
\&  my $sibling = $item\->next_sibling();
.Ve
.PP
Returns the sibling that resides one position forward. Returns 0
if the current object is the last one.
.SS "last_sibling"
.IX Subsection "last_sibling"
.Vb 1
\&  my $sibling = $item\->last_sibling();
.Ve
.PP
Returns the last sibling, or 0 if the last sibling is this
sibling.
.SS "move_previous"
.IX Subsection "move_previous"
.Vb 1
\&  $item\->move_previous();
.Ve
.PP
Swaps position with the sibling in the position previous in
the list.  Returns 1 on success, and 0 if the object is
already the first one.
.SS "move_next"
.IX Subsection "move_next"
.Vb 1
\&  $item\->move_next();
.Ve
.PP
Swaps position with the sibling in the next position in the
list.  Returns 1 on success, and 0 if the object is already
the last in the list.
.SS "move_first"
.IX Subsection "move_first"
.Vb 1
\&  $item\->move_first();
.Ve
.PP
Moves the object to the first position in the list.  Returns 1
on success, and 0 if the object is already the first.
.SS "move_last"
.IX Subsection "move_last"
.Vb 1
\&  $item\->move_last();
.Ve
.PP
Moves the object to the last position in the list.  Returns 1
on success, and 0 if the object is already the last one.
.SS "move_to"
.IX Subsection "move_to"
.Vb 1
\&  $item\->move_to( $position );
.Ve
.PP
Moves the object to the specified position.  Returns 1 on
success, and 0 if the object is already at the specified
position.
.SS "move_to_group"
.IX Subsection "move_to_group"
.Vb 1
\&  $item\->move_to_group( $group, $position );
.Ve
.PP
Moves the object to the specified position of the specified
group, or to the end of the group if \f(CW$position\fR is undef.
1 is returned on success, and 0 is returned if the object is
already at the specified position of the specified group.
.PP
\&\f(CW$group\fR may be specified as a single scalar if only one
grouping column is in use, or as a hashref of column => value pairs
if multiple grouping columns are in use.
.SS "insert"
.IX Subsection "insert"
Overrides the \s-1DBIC\s0 \fIinsert()\fR method by providing a default
position number.  The default will be the number of rows in
the table +1, thus positioning the new record at the last position.
.SS "update"
.IX Subsection "update"
Overrides the \s-1DBIC\s0 \fIupdate()\fR method by checking for a change
to the position and/or group columns.  Movement within a
group or to another group is handled by repositioning
the appropriate siblings.  Position defaults to the end
of a new group if it has been changed to undef.
.SS "delete"
.IX Subsection "delete"
Overrides the \s-1DBIC\s0 \fIdelete()\fR method by first moving the object
to the last position, then deleting it, thus ensuring the
integrity of the positions.
.SH "METHODS FOR EXTENDING ORDERED"
.IX Header "METHODS FOR EXTENDING ORDERED"
You would want to override the methods below if you use sparse
(non-linear) or non-numeric position values. This can be useful
if you are working with preexisting non-normalised position data,
or if you need to work with materialized path columns.
.SS "_position_from_value"
.IX Subsection "_position_from_value"
.Vb 1
\&  my $num_pos = $item\->_position_from_value ( $pos_value )
.Ve
.PP
Returns the \fBabsolute numeric position\fR of an object with a \fBposition
value\fR set to \f(CW$pos_value\fR. By default simply returns \f(CW$pos_value\fR.
.SS "_position_value"
.IX Subsection "_position_value"
.Vb 1
\&  my $pos_value = $item\->_position_value ( $pos )
.Ve
.PP
Returns the \fBvalue\fR of \*(L"position_column\*(R" of the object at numeric
position \f(CW$pos\fR. By default simply returns \f(CW$pos\fR.
.SS "_initial_position_value"
.IX Subsection "_initial_position_value"
.Vb 1
\&  _\|_PACKAGE_\|_\->_initial_position_value(0);
.Ve
.PP
This method specifies a \fBvalue\fR of \*(L"position_column\*(R" which is assigned
to the first inserted element of a group, if no value was supplied at
insertion time. All subsequent values are derived from this one by
\&\*(L"_next_position_value\*(R" below. Defaults to 1.
.SS "_next_position_value"
.IX Subsection "_next_position_value"
.Vb 1
\&  my $new_value = $item\->_next_position_value ( $position_value )
.Ve
.PP
Returns a position \fBvalue\fR that would be considered \f(CW\*(C`next\*(C'\fR with
regards to \f(CW$position_value\fR. Can be pretty much anything, given
that \f(CW\*(C`$position_value < $new_value\*(C'\fR where \f(CW\*(C`<\*(C'\fR is the
\&\s-1SQL\s0 comparison operator (usually works fine on strings). The
default method expects \f(CW$position_value\fR to be numeric, and
returns \f(CW\*(C`$position_value + 1\*(C'\fR
.SS "_shift_siblings"
.IX Subsection "_shift_siblings"
.Vb 1
\&  $item\->_shift_siblings ($direction, @between)
.Ve
.PP
Shifts all siblings with \fBpositions values\fR in the range \f(CW@between\fR
(inclusive) by one position as specified by \f(CW$direction\fR (left if < 0,
 right if > 0). By default simply increments/decrements each
\&\*(L"position_column\*(R" value by 1, doing so in a way as to not violate
any existing constraints.
.PP
Note that if you override this method and have unique constraints
including the \*(L"position_column\*(R" the shift is not a trivial task.
Refer to the implementation source of the default method for more
information.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Resultset Methods"
.IX Subsection "Resultset Methods"
Note that all Insert/Create/Delete overrides are happening on
DBIx::Class::Row methods only. If you use the
DBIx::Class::ResultSet versions of
update or
delete, all logic present in this
module will be bypassed entirely (possibly resulting in a broken
order-tree). Instead always use the
update_all and
delete_all methods, which will
invoke the corresponding row method on every
member of the given resultset.
.SS "Race Condition on Insert"
.IX Subsection "Race Condition on Insert"
If a position is not specified for an insert, a position
will be chosen based either on \*(L"_initial_position_value\*(R" or
\&\*(L"_next_position_value\*(R", depending if there are already some
items in the current group. The space of time between the
necessary selects and insert introduces a race condition.
Having unique constraints on your position/group columns,
and using transactions (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
will prevent such race conditions going undetected.
.SS "Multiple Moves"
.IX Subsection "Multiple Moves"
Be careful when issuing move_* methods to multiple objects.  If
you've pre-loaded the objects then when you move one of the objects
the position of the other object will not reflect their new value
until you reload them from the database \- see
\&\*(L"discard_changes\*(R" in DBIx::Class::Row.
.PP
There are times when you will want to move objects as groups, such
as changing the parent of several objects at once \- this directly
conflicts with this problem.  One solution is for us to write a
ResultSet class that supports a \fIparent()\fR method, for example.  Another
solution is to somehow automagically modify the objects that exist
in the current object's result set to have the new position value.
.SS "Default Values"
.IX Subsection "Default Values"
Using a database defined default_value on one of your group columns
could result in the position not being assigned correctly.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Original code framework
\&   Aran Deltac <bluefeet@cpan.org>
\&
\& Constraints support and code generalisation
\&   Peter Rabbitson <ribasushi@cpan.org>
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK.3pm                          0100644 0001750 0001750 00000013356 12566242377 023676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK 3"
.TH DBIx::Class::PK 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK \- Primary Key class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class contains methods for handling primary keys and methods
depending on them.
.SH "METHODS"
.IX Header "METHODS"
.SS "id"
.IX Subsection "id"
Returns the primary key(s) for a row. Can't be called as
a class method.
.SS "\s-1ID\s0"
.IX Subsection "ID"
Returns a unique id string identifying a result object by primary key.
Used by DBIx::Class::CDBICompat::LiveObjectIndex and
DBIx::Class::ObjectCache.
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
The default \f(CW\*(C`_create_ID\*(C'\fR method used by this function orders the returned
values by the alphabetical order of the primary column names, \fBunlike\fR
the \*(L"id\*(R" method, which follows the same order in which columns were fed
to \*(L"set_primary_key\*(R" in DBIx::Class::ResultSource.
.SS "ident_condition"
.IX Subsection "ident_condition"
.Vb 1
\&  my $cond = $result_source\->ident_condition();
\&
\&  my $cond = $result_source\->ident_condition(\*(Aqalias\*(Aq);
.Ve
.PP
Produces a condition hash to locate a row based on the primary key(s).
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::Row" 4
.IX Item "DBIx::Class::Row"
copy, delete, discard_changes, get_column, get_columns, get_dirty_columns, get_from_storage, get_inflated_columns, has_column_loaded, in_storage, inflate_result, insert, insert_or_update, is_changed, is_column_changed, make_column_dirty, new, register_column, result_source, set_column, set_columns, set_inflated_columns, store_column, throw_exception, update, update_or_insert
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK5.16.3pm                      0100644 0001750 0001750 00000012006 12566242362 024171  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK 3"
.TH DBIx::Class::PK 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK \- Primary Key class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class contains methods for handling primary keys and methods
depending on them.
.SH "METHODS"
.IX Header "METHODS"
.SS "id"
.IX Subsection "id"
Returns the primary key(s) for a row. Can't be called as
a class method.
.SS "\s-1ID\s0"
.IX Subsection "ID"
Returns a unique id string identifying a row object by primary key.
Used by DBIx::Class::CDBICompat::LiveObjectIndex and
DBIx::Class::ObjectCache.
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
The default \f(CW\*(C`_create_ID\*(C'\fR method used by this function orders the returned
values by the alphabetical order of the primary column names, \fBunlike\fR
the \*(L"id\*(R" method, which follows the same order in which columns were fed
to \*(L"set_primary_key\*(R" in DBIx::Class::ResultSource.
.SS "ident_condition"
.IX Subsection "ident_condition"
.Vb 1
\&  my $cond = $result_source\->ident_condition();
\&
\&  my $cond = $result_source\->ident_condition(\*(Aqalias\*(Aq);
.Ve
.PP
Produces a condition hash to locate a row based on the primary key(s).
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK5.18.3pm                      0100644 0001750 0001750 00000013356 12566242377 024212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK 3"
.TH DBIx::Class::PK 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK \- Primary Key class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class contains methods for handling primary keys and methods
depending on them.
.SH "METHODS"
.IX Header "METHODS"
.SS "id"
.IX Subsection "id"
Returns the primary key(s) for a row. Can't be called as
a class method.
.SS "\s-1ID\s0"
.IX Subsection "ID"
Returns a unique id string identifying a result object by primary key.
Used by DBIx::Class::CDBICompat::LiveObjectIndex and
DBIx::Class::ObjectCache.
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
The default \f(CW\*(C`_create_ID\*(C'\fR method used by this function orders the returned
values by the alphabetical order of the primary column names, \fBunlike\fR
the \*(L"id\*(R" method, which follows the same order in which columns were fed
to \*(L"set_primary_key\*(R" in DBIx::Class::ResultSource.
.SS "ident_condition"
.IX Subsection "ident_condition"
.Vb 1
\&  my $cond = $result_source\->ident_condition();
\&
\&  my $cond = $result_source\->ident_condition(\*(Aqalias\*(Aq);
.Ve
.PP
Produces a condition hash to locate a row based on the primary key(s).
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::Row" 4
.IX Item "DBIx::Class::Row"
copy, delete, discard_changes, get_column, get_columns, get_dirty_columns, get_from_storage, get_inflated_columns, has_column_loaded, in_storage, inflate_result, insert, insert_or_update, is_changed, is_column_changed, make_column_dirty, new, register_column, result_source, set_column, set_columns, set_inflated_columns, store_column, throw_exception, update, update_or_insert
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto.3pm                    0100644 0001750 0001750 00000011754 12566242377 024713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto 3"
.TH DBIx::Class::PK::Auto 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto \- Automatic primary key class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use base 'DBIx::Class::Core';
_\|_PACKAGE_\|_\->set_primary_key('id');
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class overrides the insert method to get automatically incremented primary
keys.
.PP
PK::Auto is now part of Core.
.PP
See DBIx::Class::Manual::Component for details of component interactions.
.SH "LOGIC"
.IX Header "LOGIC"
\&\f(CW\*(C`PK::Auto\*(C'\fR does this by letting the database assign the primary key field and
fetching the assigned value afterwards.
.SH "METHODS"
.IX Header "METHODS"
.SS "insert"
.IX Subsection "insert"
The code that was handled here is now in Row for efficiency.
.SS "sequence"
.IX Subsection "sequence"
The code that was handled here is now in ResultSource, and is being proxied to
Row as well.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto5.16.3pm                0100644 0001750 0001750 00000011355 12566242362 025214  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto 3"
.TH DBIx::Class::PK::Auto 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto \- Automatic primary key class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use base 'DBIx::Class::Core';
_\|_PACKAGE_\|_\->set_primary_key('id');
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class overrides the insert method to get automatically incremented primary
keys.
.PP
PK::Auto is now part of Core.
.PP
See DBIx::Class::Manual::Component for details of component interactions.
.SH "LOGIC"
.IX Header "LOGIC"
\&\f(CW\*(C`PK::Auto\*(C'\fR does this by letting the database assign the primary key field and
fetching the assigned value afterwards.
.SH "METHODS"
.IX Header "METHODS"
.SS "insert"
.IX Subsection "insert"
The code that was handled here is now in Row for efficiency.
.SS "sequence"
.IX Subsection "sequence"
The code that was handled here is now in ResultSource, and is being proxied to
Row as well.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto5.18.3pm                0100644 0001750 0001750 00000011754 12566242377 025227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto 3"
.TH DBIx::Class::PK::Auto 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto \- Automatic primary key class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use base 'DBIx::Class::Core';
_\|_PACKAGE_\|_\->set_primary_key('id');
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class overrides the insert method to get automatically incremented primary
keys.
.PP
PK::Auto is now part of Core.
.PP
See DBIx::Class::Manual::Component for details of component interactions.
.SH "LOGIC"
.IX Header "LOGIC"
\&\f(CW\*(C`PK::Auto\*(C'\fR does this by letting the database assign the primary key field and
fetching the assigned value afterwards.
.SH "METHODS"
.IX Header "METHODS"
.SS "insert"
.IX Subsection "insert"
The code that was handled here is now in Row for efficiency.
.SS "sequence"
.IX Subsection "sequence"
The code that was handled here is now in ResultSource, and is being proxied to
Row as well.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::DB2.3pm               0100644 0001750 0001750 00000010547 12566242377 025366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::DB2 3"
.TH DBIx::Class::PK::Auto::DB2 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::DB2 \- (DEPRECATED) Automatic primary key class for DB2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::DB25.16.3pm           0100644 0001750 0001750 00000010147 12566242363 025667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::DB2 3"
.TH DBIx::Class::PK::Auto::DB2 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::DB2 \- (DEPRECATED) Automatic primary key class for DB2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::DB25.18.3pm           0100644 0001750 0001750 00000010547 12566242377 025702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::DB2 3"
.TH DBIx::Class::PK::Auto::DB2 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::DB2 \- (DEPRECATED) Automatic primary key class for DB2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::MSSQL.3pm             0100644 0001750 0001750 00000010557 12566242377 025717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::MSSQL 3"
.TH DBIx::Class::PK::Auto::MSSQL 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::MSSQL \- (DEPRECATED) Automatic primary key class for MSSQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::MSSQL5.16.3pm         0100644 0001750 0001750 00000010157 12566242362 026217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::MSSQL 3"
.TH DBIx::Class::PK::Auto::MSSQL 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::MSSQL \- (DEPRECATED) Automatic primary key class for MSSQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::MSSQL5.18.3pm         0100644 0001750 0001750 00000010557 12566242377 026233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::MSSQL 3"
.TH DBIx::Class::PK::Auto::MSSQL 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::MSSQL \- (DEPRECATED) Automatic primary key class for MSSQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::MySQL.3pm             0100644 0001750 0001750 00000010557 12566242400 025750  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::MySQL 3"
.TH DBIx::Class::PK::Auto::MySQL 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::MySQL \- (DEPRECATED) Automatic primary key class for MySQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::MySQL5.16.3pm         0100644 0001750 0001750 00000010157 12566242362 026265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::MySQL 3"
.TH DBIx::Class::PK::Auto::MySQL 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::MySQL \- (DEPRECATED) Automatic primary key class for MySQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::MySQL5.18.3pm         0100644 0001750 0001750 00000010557 12566242400 026264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::MySQL 3"
.TH DBIx::Class::PK::Auto::MySQL 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::MySQL \- (DEPRECATED) Automatic primary key class for MySQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::Oracle.3pm            0100644 0001750 0001750 00000010563 12566242400 026205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::Oracle 3"
.TH DBIx::Class::PK::Auto::Oracle 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::Oracle \- (DEPRECATED) Automatic primary key class for Oracle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::Oracle5.16.3pm        0100644 0001750 0001750 00000010163 12566242363 026523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::Oracle 3"
.TH DBIx::Class::PK::Auto::Oracle 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::Oracle \- (DEPRECATED) Automatic primary key class for Oracle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::Oracle5.18.3pm        0100644 0001750 0001750 00000010563 12566242400 026521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::Oracle 3"
.TH DBIx::Class::PK::Auto::Oracle 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::Oracle \- (DEPRECATED) Automatic primary key class for Oracle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::Pg.3pm                0100644 0001750 0001750 00000010543 12566242400 025344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::Pg 3"
.TH DBIx::Class::PK::Auto::Pg 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::Pg \- (DEPRECATED) Automatic primary key class for Pg
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::Pg5.16.3pm            0100644 0001750 0001750 00000010143 12566242362 025661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::Pg 3"
.TH DBIx::Class::PK::Auto::Pg 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::Pg \- (DEPRECATED) Automatic primary key class for Pg
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::Pg5.18.3pm            0100644 0001750 0001750 00000010543 12566242400 025660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::Pg 3"
.TH DBIx::Class::PK::Auto::Pg 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::Pg \- (DEPRECATED) Automatic primary key class for Pg
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::SQLite.3pm            0100644 0001750 0001750 00000010563 12566242400 026141  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::SQLite 3"
.TH DBIx::Class::PK::Auto::SQLite 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::SQLite \- (DEPRECATED) Automatic primary key class for SQLite
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::SQLite5.16.3pm        0100644 0001750 0001750 00000010163 12566242362 026456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::SQLite 3"
.TH DBIx::Class::PK::Auto::SQLite 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::SQLite \- (DEPRECATED) Automatic primary key class for SQLite
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::PK::Auto::SQLite5.18.3pm        0100644 0001750 0001750 00000010563 12566242400 026455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::PK::Auto::SQLite 3"
.TH DBIx::Class::PK::Auto::SQLite 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::PK::Auto::SQLite \- (DEPRECATED) Automatic primary key class for SQLite
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Just load PK::Auto instead; auto-inc is now handled by Storage.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Relationship.3pm                0100644 0001750 0001750 00000070752 12566242377 026030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship 3"
.TH DBIx::Class::Relationship 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  ## Creating relationships
\&  MyApp::Schema::Actor\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqactor\*(Aq);
\&  MyApp::Schema::Role\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqrole\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqrole\*(Aq => \*(AqMyApp::Schema::Role\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqactor\*(Aq => \*(AqMyApp::Schema::Actor\*(Aq);
\&
\&  MyApp::Schema::Role\->many_to_many(\*(Aqactors\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqactor\*(Aq);
\&  MyApp::Schema::Actor\->many_to_many(\*(Aqroles\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqrole\*(Aq);
\&
\&  ## Using relationships
\&  $schema\->resultset(\*(AqActor\*(Aq)\->find({ id => 1})\->roles();
\&  $schema\->resultset(\*(AqRole\*(Aq)\->find({ id => 1 })\->actorroles\->search_related(\*(Aqactor\*(Aq, { Name => \*(AqFred\*(Aq });
\&  $schema\->resultset(\*(AqActor\*(Aq)\->add_to_roles({ Name => \*(AqSherlock Holmes\*(Aq});
.Ve
.PP
See DBIx::Class::Manual::Cookbook for more.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The word \fIRelationship\fR has a specific meaning in DBIx::Class, see
the definition in the Glossary.
.PP
This class provides methods to set up relationships between the tables
in your database model. Relationships are the most useful and powerful
technique that DBIx::Class provides. To create efficient database queries,
create relationships between any and all tables that have something in
common, for example if you have a table Authors:
.PP
.Vb 4
\&  ID  | Name | Age
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  | Fred | 30
\&   2  | Joe  | 32
.Ve
.PP
and a table Books:
.PP
.Vb 4
\&  ID  | Author | Name
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  |      1 | Rulers of the universe
\&   2  |      1 | Rulers of the galaxy
.Ve
.PP
Then without relationships, the method of getting all books by Fred goes like
this:
.PP
.Vb 2
\& my $fred = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq });
\& my $fredsbooks = $schema\->resultset(\*(AqBook\*(Aq)\->search({ Author => $fred\->ID });
.Ve
.PP
With a has_many relationship called \*(L"books\*(R" on Author (see below for details),
we can do this instead:
.PP
.Vb 1
\& my $fredsbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq })\->books;
.Ve
.PP
Each relationship sets up an accessor method on the
Result objects that represent the items
of your table. From ResultSet objects,
the relationships can be searched using the \*(L"search_related\*(R" method.
In list context, each returns a list of Result objects for the related class,
in scalar context, a new ResultSet representing the joined tables is
returned. Thus, the calls can be chained to produce complex queries.
Since the database is not actually queried until you attempt to retrieve
the data for an actual item, no time is wasted producing them.
.PP
.Vb 5
\& my $cheapfredbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({
\&   Name => \*(AqFred\*(Aq,
\& })\->books\->search_related(\*(Aqprices\*(Aq, {
\&   Price => { \*(Aq<=\*(Aq => \*(Aq5.00\*(Aq },
\& });
.Ve
.PP
will produce a query something like:
.PP
.Vb 4
\& SELECT * FROM Author me
\& LEFT JOIN Books books ON books.author = me.id
\& LEFT JOIN Prices prices ON prices.book = books.id
\& WHERE prices.Price <= 5.00
.Ve
.PP
all without needing multiple fetches.
.PP
Only the helper methods for setting up standard relationship types
are documented here. For the basic, lower-level methods, and a description
of all the useful *_related methods that you get for free, see
DBIx::Class::Relationship::Base.
.SH "METHODS"
.IX Header "METHODS"
All helper methods are called similar to the following template:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->$method_name(\*(Aqrelname\*(Aq, \*(AqForeign::Class\*(Aq, \e%cond|\e@cond|\e&cond?, \e%attrs?);
.Ve
.PP
Both \f(CW\*(C`cond\*(C'\fR and \f(CW\*(C`attrs\*(C'\fR are optional. Pass \f(CW\*(C`undef\*(C'\fR for \f(CW\*(C`cond\*(C'\fR if
you want to use the default value for it, but still want to set \f(CW\*(C`attrs\*(C'\fR.
.PP
See \*(L"condition\*(R" in DBIx::Class::Relationship::Base for full documentation on
definition of the \f(CW\*(C`cond\*(C'\fR argument.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on the
attributes that are allowed in the \f(CW\*(C`attrs\*(C'\fR argument.
.SS "belongs_to"
.IX Subsection "belongs_to"
.ie n .IP "Arguments: $accessor_name, $related_class, $our_fk_column|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$our_fk_column\fR|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $our_fk_column|%cond|@cond|$cond?, %attrs?"
.PP
Creates a relationship where the calling class stores the foreign
class's primary key in one (or more) of the calling class columns.
This relationship defaults to using \f(CW$accessor_name\fR as the column
name in this class to resolve the join against the primary key from
\&\f(CW$related_class\fR, unless \f(CW$our_fk_column\fR specifies the foreign key column
in this class or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table referenced by the foreign key in
this class.
.IP "our_fk_column" 4
.IX Item "our_fk_column"
The column name on this class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # in a Book class (where Author has many Books)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.author_id\*(Aq }
\&  );
\&
\&  # OR (similar result but uglier accessor name)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author_id =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq
\&  );
\&
\&  # Usage
\&  my $author_obj = $book\->author; # get author object
\&  $book\->author( $new_author_obj ); # set author object
\&  $book\->author_id(); # get the plain id
\&
\&  # To retrieve the plain id if you used the ugly version:
\&  $book\->get_column(\*(Aqauthor_id\*(Aq);
.Ve
.PP
If some of the foreign key columns are
nullable you probably want to set
the join_type attribute to
\&\f(CW\*(C`left\*(C'\fR explicitly so that \s-1SQL\s0 expressing this relation is composed with
a \f(CW\*(C`LEFT JOIN\*(C'\fR (as opposed to \f(CW\*(C`INNER JOIN\*(C'\fR which is default for
\&\*(L"belongs_to\*(R" relationships). This ensures that relationship traversal
works consistently in all situations. (i.e. resultsets involving
join or
prefetch).
The modified declaration is shown below:
.PP
.Vb 7
\&  # in a Book class (where Author has_many Books)
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor\*(Aq,
\&    { join_type => \*(Aqleft\*(Aq }
\&  );
.Ve
.PP
Cascading deletes are off by default on a \f(CW\*(C`belongs_to\*(C'\fR
relationship. To turn them on, pass \f(CW\*(C`cascade_delete => 1\*(C'\fR
in the \f(CW$attr\fR hashref.
.PP
By default, \s-1DBIC\s0 will return undef and avoid querying the database if a
\&\f(CW\*(C`belongs_to\*(C'\fR accessor is called when any part of the foreign key \s-1IS NULL.\s0 To
disable this behavior, pass \f(CW\*(C`undef_on_null_fk => 0\*(C'\fR in the \f(CW\*(C`\e%attrs\*(C'\fR
hashref.
.PP
\&\s-1NOTE:\s0 If you are used to Class::DBI relationships, this is the equivalent
of \f(CW\*(C`has_a\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on relationship
methods and valid relationship attributes. Also see DBIx::Class::ResultSet
for a list of standard resultset attributes
which can be assigned to relationships as well.
.SS "has_many"
.IX Subsection "has_many"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-many relationship where the foreign class refers to
this class's primary key. This relationship refers to zero or more
records in the foreign table (e.g. a \f(CW\*(C`LEFT JOIN\*(C'\fR). This relationship
defaults to using the end of this classes namespace as the foreign key
in \f(CW$related_class\fR to resolve the join, unless \f(CW$their_fk_column\fR
specifies the foreign key column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR
specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve a resultset of the related
class restricted to the ones related to the result object. In list
context it returns the result objects. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 7
\&  # in an Author class (where Author has_many Books)
\&  # assuming related class is storing our PK in "author_id"
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # OR (similar result, assuming related_class is storing our PK, in "author")
\&  # (the "author" is guessed at from "Author" in the class namespace)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&  );
\&
\&
\&  # Usage
\&  # resultset of Books belonging to author
\&  my $booklist = $author\->books;
\&
\&  # resultset of Books belonging to author, restricted by author name
\&  my $booklist = $author\->books({
\&    name => { LIKE => \*(Aq%macaroni%\*(Aq },
\&    { prefetch => [qw/book/],
\&  });
\&
\&  # array of Book objects belonging to author
\&  my @book_objs = $author\->books;
\&
\&  # force resultset even in list context
\&  my $books_rs = $author\->books;
\&  ( $books_rs ) = $obj\->books_rs;
\&
\&  # create a new book for this author, the relation fields are auto\-filled
\&  $author\->create_related(\*(Aqbooks\*(Aq, \e%col_data);
\&  # alternative method for the above
\&  $author\->add_to_books(\e%col_data);
.Ve
.PP
Three methods are created when you create a has_many relationship.
The first method is the expected accessor method, \f(CW\*(C`$accessor_name()\*(C'\fR.
The second is almost exactly the same as the accessor method but \*(L"_rs\*(R"
is added to the end of the method name, eg \f(CW\*(C`$accessor_name_rs()\*(C'\fR.
This method works just like the normal accessor, except that it always
returns a resultset, even in list context. The third method, named \f(CW\*(C`add_to_$relname\*(C'\fR, will also be added to your Row items; this allows
you to insert new related items, using the same mechanism as in
\&\*(L"create_related\*(R" in DBIx::Class::Relationship::Base.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be deleted as well.  To turn this behaviour off,
pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
If you copy an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be copied as well. To turn this behaviour off,
pass \f(CW\*(C`cascade_copy => 0\*(C'\fR in the \f(CW$attr\fR hashref. The behaviour
defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SS "might_have"
.IX Subsection "might_have"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates an optional one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Author may have an entry in the pseudonym table
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    \*(Aqauthor_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming the related_class stores our PK)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $pname = $author\->pseudonym; # to get the Pseudonym object
.Ve
.PP
If you update or delete an object in a class with a \f(CW\*(C`might_have\*(C'\fR
relationship, the related object will be updated or deleted as well. To
turn off this behavior, add \f(CW\*(C`cascade_delete => 0\*(C'\fR to the \f(CW$attr\fR
hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, and the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than \f(CW\*(C`might_have\*(C'\fR will warn about this because it's naughty and
you shouldn't do that. The warning will look something like:
.PP
.Vb 1
\&  "might_have/has_one" must not be on columns with is_nullable set to true (MySchema::SomeClass/key)
.Ve
.PP
If you must be naughty, you can suppress the warning by setting
\&\f(CW\*(C`DBIC_DONT_VALIDATE_RELS\*(C'\fR environment variable to a true value.  Otherwise,
you probably just meant to use \f(CW\*(C`DBIx::Class::Relationship/belongs_to\*(C'\fR.
.SS "has_one"
.IX Subsection "has_one"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Every book has exactly one ISBN
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    \*(Aqbook_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming related_class stores our PK)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    { \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $isbn_obj = $book\->isbn; # to get the ISBN object
.Ve
.PP
Creates a one-to-one relationship with another class. This is just
like \f(CW\*(C`might_have\*(C'\fR, except the implication is that the other object is
always present. The only difference between \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR is that \f(CW\*(C`has_one\*(C'\fR uses an (ordinary) inner join,
whereas \f(CW\*(C`might_have\*(C'\fR defaults to a left join.
.PP
The has_one relationship should be used when a row in the table must
have exactly one related row in another table. If the related row
might not exist in the foreign table, use the
\&\*(L"might_have\*(R" in DBIx::Class::Relationship relationship.
.PP
In the above example, each Book in the database is associated with exactly one
\&\s-1ISBN\s0 object.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, if the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than warnings might apply just as with
\&\*(L"might_have\*(R" in DBIx::Class::Relationship.
.SS "many_to_many"
.IX Subsection "many_to_many"
.ie n .IP "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$link_rel_name\fR, \f(CW$foreign_rel_name\fR, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, %attrs?"
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is a \fIRelationship bridge\fR which has a specific
meaning in DBIx::Class, see the definition in the
Glossary.
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is not strictly a relationship in its own right. Instead, it is
a bridge between two resultsets which provide the same kind of convenience
accessors as true relationships provide. Although the accessor will return a
resultset or collection of objects just like has_many does, you cannot call
\&\f(CW\*(C`related_resultset\*(C'\fR and similar methods which operate on true relationships.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the rows matching this
relationship.
.Sp
On a many_to_many, unlike other relationships, this cannot be used in
\&\*(L"search\*(R" in DBIx::Class::ResultSet to join tables. Use the relations
bridged across instead.
.IP "link_rel_name" 4
.IX Item "link_rel_name"
This is the accessor_name from the has_many relationship we are
bridging from.
.IP "foreign_rel_name" 4
.IX Item "foreign_rel_name"
This is the accessor_name of the belongs_to relationship in the link
table that we are bridging across (which gives us the table we are
bridging to).
.PP
To create a many_to_many relationship from Actor to Role:
.PP
.Vb 7
\&  My::DBIC::Schema::Actor\->has_many( actor_roles =>
\&                                     \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                     \*(Aqactor\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( role =>
\&                                            \*(AqMy::DBIC::Schema::Role\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( actor =>
\&                                            \*(AqMy::DBIC::Schema::Actor\*(Aq );
\&
\&  My::DBIC::Schema::Actor\->many_to_many( roles => \*(Aqactor_roles\*(Aq,
\&                                         \*(Aqrole\*(Aq );
.Ve
.PP
And, for the reverse relationship, from Role to Actor:
.PP
.Vb 3
\&  My::DBIC::Schema::Role\->has_many( actor_roles =>
\&                                    \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                    \*(Aqrole\*(Aq );
\&
\&  My::DBIC::Schema::Role\->many_to_many( actors => \*(Aqactor_roles\*(Aq, \*(Aqactor\*(Aq );
.Ve
.PP
To add a role for your actor, and fill in the year of the role in the
actor_roles table:
.PP
.Vb 1
\&  $actor\->add_to_roles($role, { year => 1995 });
.Ve
.PP
In the above example, ActorRoles is the link table class, and Role is the
foreign class. The \f(CW$link_rel_name\fR parameter is the name of the accessor for
the has_many relationship from this table to the link table, and the
\&\f(CW$foreign_rel_name\fR parameter is the accessor for the belongs_to relationship
from the link table to the foreign table.
.PP
To use many_to_many, existing relationships from the original table to the link
table, and from the link table to the end table must already exist, these
relation names are then used in the many_to_many call.
.PP
In the above example, the Actor class will have 3 many_to_many accessor methods
set: \f(CW\*(C`roles\*(C'\fR, \f(CW\*(C`add_to_roles\*(C'\fR, \f(CW\*(C`set_roles\*(C'\fR, and similarly named accessors
will be created for the Role class for the \f(CW\*(C`actors\*(C'\fR many_to_many
relationship.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Relationship5.16.3pm            0100644 0001750 0001750 00000070607 12566242363 026334  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship 3"
.TH DBIx::Class::Relationship 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  ## Creating relationships
\&  MyApp::Schema::Actor\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqactor\*(Aq);
\&  MyApp::Schema::Role\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqrole\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqrole\*(Aq => \*(AqMyApp::Schema::Role\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqactor\*(Aq => \*(AqMyApp::Schema::Actor\*(Aq);
\&
\&  MyApp::Schema::Role\->many_to_many(\*(Aqactors\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqactor\*(Aq);
\&  MyApp::Schema::Actor\->many_to_many(\*(Aqroles\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqrole\*(Aq);
\&
\&  ## Using relationships
\&  $schema\->resultset(\*(AqActor\*(Aq)\->find({ id => 1})\->roles();
\&  $schema\->resultset(\*(AqRole\*(Aq)\->find({ id => 1 })\->actorroles\->search_related(\*(Aqactor\*(Aq, { Name => \*(AqFred\*(Aq });
\&  $schema\->resultset(\*(AqActor\*(Aq)\->add_to_roles({ Name => \*(AqSherlock Holmes\*(Aq});
.Ve
.PP
See DBIx::Class::Manual::Cookbook for more.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The word \fIRelationship\fR has a specific meaning in DBIx::Class, see
the definition in the Glossary.
.PP
This class provides methods to set up relationships between the tables
in your database model. Relationships are the most useful and powerful
technique that DBIx::Class provides. To create efficient database queries,
create relationships between any and all tables that have something in
common, for example if you have a table Authors:
.PP
.Vb 4
\&  ID  | Name | Age
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  | Fred | 30
\&   2  | Joe  | 32
.Ve
.PP
and a table Books:
.PP
.Vb 4
\&  ID  | Author | Name
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  |      1 | Rulers of the universe
\&   2  |      1 | Rulers of the galaxy
.Ve
.PP
Then without relationships, the method of getting all books by Fred goes like
this:
.PP
.Vb 2
\& my $fred = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq });
\& my $fredsbooks = $schema\->resultset(\*(AqBook\*(Aq)\->search({ Author => $fred\->ID });
.Ve
.PP
With a has_many relationship called \*(L"books\*(R" on Author (see below for details),
we can do this instead:
.PP
.Vb 1
\& my $fredsbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq })\->books;
.Ve
.PP
Each relationship sets up an accessor method on the
\&\*(L"Row\*(R" in DBIx::Class::Manual::Glossary objects that represent the items
of your table. From \*(L"ResultSet\*(R" in DBIx::Class::Manual::Glossary objects,
the relationships can be searched using the \*(L"search_related\*(R" method.
In list context, each returns a list of Row objects for the related class,
in scalar context, a new ResultSet representing the joined tables is
returned. Thus, the calls can be chained to produce complex queries.
Since the database is not actually queried until you attempt to retrieve
the data for an actual item, no time is wasted producing them.
.PP
.Vb 5
\& my $cheapfredbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({
\&   Name => \*(AqFred\*(Aq,
\& })\->books\->search_related(\*(Aqprices\*(Aq, {
\&   Price => { \*(Aq<=\*(Aq => \*(Aq5.00\*(Aq },
\& });
.Ve
.PP
will produce a query something like:
.PP
.Vb 4
\& SELECT * FROM Author me
\& LEFT JOIN Books books ON books.author = me.id
\& LEFT JOIN Prices prices ON prices.book = books.id
\& WHERE prices.Price <= 5.00
.Ve
.PP
all without needing multiple fetches.
.PP
Only the helper methods for setting up standard relationship types
are documented here. For the basic, lower-level methods, and a description
of all the useful *_related methods that you get for free, see
DBIx::Class::Relationship::Base.
.SH "METHODS"
.IX Header "METHODS"
All helper methods are called similar to the following template:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->$method_name(\*(Aqrelname\*(Aq, \*(AqForeign::Class\*(Aq, \e%cond|\e@cond|\e&cond?, \e%attrs?);
.Ve
.PP
Both \f(CW\*(C`cond\*(C'\fR and \f(CW\*(C`attrs\*(C'\fR are optional. Pass \f(CW\*(C`undef\*(C'\fR for \f(CW\*(C`cond\*(C'\fR if
you want to use the default value for it, but still want to set \f(CW\*(C`attrs\*(C'\fR.
.PP
See \*(L"condition\*(R" in DBIx::Class::Relationship::Base for full documentation on
definition of the \f(CW\*(C`cond\*(C'\fR argument.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on the
attributes that are allowed in the \f(CW\*(C`attrs\*(C'\fR argument.
.SS "belongs_to"
.IX Subsection "belongs_to"
.ie n .IP "Arguments: $accessor_name, $related_class, $our_fk_column|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$our_fk_column\fR|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $our_fk_column|%cond|@cond|$cond?, %attrs?"
.PP
Creates a relationship where the calling class stores the foreign
class's primary key in one (or more) of the calling class columns.
This relationship defaults to using \f(CW$accessor_name\fR as the column
name in this class to resolve the join against the primary key from
\&\f(CW$related_class\fR, unless \f(CW$our_fk_column\fR specifies the foreign key column
in this class or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
DBIx::Class::Row object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table referenced by the foreign key in
this class.
.IP "our_fk_column" 4
.IX Item "our_fk_column"
The column name on this class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # in a Book class (where Author has many Books)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.author_id\*(Aq }
\&  );
\&
\&  # OR (similar result but uglier accessor name)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author_id =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq
\&  );
\&
\&  # Usage
\&  my $author_obj = $book\->author; # get author object
\&  $book\->author( $new_author_obj ); # set author object
\&  $book\->author_id(); # get the plain id
\&
\&  # To retrieve the plain id if you used the ugly version:
\&  $book\->get_column(\*(Aqauthor_id\*(Aq);
.Ve
.PP
If the relationship is optional \*(-- i.e. the column containing the
foreign key can be \s-1NULL\s0 \*(-- then the belongs_to relationship does the
right thing. Thus, in the example above \f(CW\*(C`$obj\->author\*(C'\fR would
return \f(CW\*(C`undef\*(C'\fR.  However in this case you would probably want to set
the join_type attribute so that
a \f(CW\*(C`LEFT JOIN\*(C'\fR is done, which makes complex resultsets involving
\&\f(CW\*(C`join\*(C'\fR or \f(CW\*(C`prefetch\*(C'\fR operations work correctly.  The modified
declaration is shown below:
.PP
.Vb 7
\&  # in a Book class (where Author has_many Books)
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor\*(Aq,
\&    { join_type => \*(Aqleft\*(Aq }
\&  );
.Ve
.PP
Cascading deletes are off by default on a \f(CW\*(C`belongs_to\*(C'\fR
relationship. To turn them on, pass \f(CW\*(C`cascade_delete => 1\*(C'\fR
in the \f(CW$attr\fR hashref.
.PP
By default, \s-1DBIC\s0 will return undef and avoid querying the database if a
\&\f(CW\*(C`belongs_to\*(C'\fR accessor is called when any part of the foreign key \s-1IS\s0 \s-1NULL\s0. To
disable this behavior, pass \f(CW\*(C`undef_on_null_fk => 0\*(C'\fR in the \f(CW\*(C`\e%attrs\*(C'\fR
hashref.
.PP
\&\s-1NOTE:\s0 If you are used to Class::DBI relationships, this is the equivalent
of \f(CW\*(C`has_a\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on relationship
methods and valid relationship attributes. Also see DBIx::Class::ResultSet
for a list of standard resultset attributes
which can be assigned to relationships as well.
.SS "has_many"
.IX Subsection "has_many"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-many relationship where the foreign class refers to
this class's primary key. This relationship refers to zero or more
records in the foreign table (e.g. a \f(CW\*(C`LEFT JOIN\*(C'\fR). This relationship
defaults to using the end of this classes namespace as the foreign key
in \f(CW$related_class\fR to resolve the join, unless \f(CW$their_fk_column\fR
specifies the foreign key column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR
specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
DBIx::Class::Row object to retrieve a resultset of the related
class restricted to the ones related to the row object. In list
context it returns the row objects. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 7
\&  # in an Author class (where Author has_many Books)
\&  # assuming related class is storing our PK in "author_id"
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # OR (similar result, assuming related_class is storing our PK, in "author")
\&  # (the "author" is guessed at from "Author" in the class namespace)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&  );
\&
\&
\&  # Usage
\&  # resultset of Books belonging to author
\&  my $booklist = $author\->books;
\&
\&  # resultset of Books belonging to author, restricted by author name
\&  my $booklist = $author\->books({
\&    name => { LIKE => \*(Aq%macaroni%\*(Aq },
\&    { prefetch => [qw/book/],
\&  });
\&
\&  # array of Book objects belonging to author
\&  my @book_objs = $author\->books;
\&
\&  # force resultset even in list context
\&  my $books_rs = $author\->books;
\&  ( $books_rs ) = $obj\->books_rs;
\&
\&  # create a new book for this author, the relation fields are auto\-filled
\&  $author\->create_related(\*(Aqbooks\*(Aq, \e%col_data);
\&  # alternative method for the above
\&  $author\->add_to_books(\e%col_data);
.Ve
.PP
Three methods are created when you create a has_many relationship.
The first method is the expected accessor method, \f(CW\*(C`$accessor_name()\*(C'\fR.
The second is almost exactly the same as the accessor method but \*(L"_rs\*(R"
is added to the end of the method name, eg \f(CW\*(C`$accessor_name_rs()\*(C'\fR.
This method works just like the normal accessor, except that it always
returns a resultset, even in list context. The third method, named \f(CW\*(C`add_to_$relname\*(C'\fR, will also be added to your Row items; this allows
you to insert new related items, using the same mechanism as in
\&\*(L"create_related\*(R" in DBIx::Class::Relationship::Base.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be deleted as well.  To turn this behaviour off,
pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
If you copy an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be copied as well. To turn this behaviour off,
pass \f(CW\*(C`cascade_copy => 0\*(C'\fR in the \f(CW$attr\fR hashref. The behaviour
defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SS "might_have"
.IX Subsection "might_have"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates an optional one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
DBIx::Class::Row object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Author may have an entry in the pseudonym table
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    \*(Aqauthor_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming the related_class stores our PK)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $pname = $author\->pseudonym; # to get the Pseudonym object
.Ve
.PP
If you update or delete an object in a class with a \f(CW\*(C`might_have\*(C'\fR
relationship, the related object will be updated or deleted as well. To
turn off this behavior, add \f(CW\*(C`cascade_delete => 0\*(C'\fR to the \f(CW$attr\fR
hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, and the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than \f(CW\*(C`might_have\*(C'\fR will warn about this because it's naughty and
you shouldn't do that. The warning will look something like:
.PP
.Vb 1
\&  "might_have/has_one" must not be on columns with is_nullable set to true (MySchema::SomeClass/key)
.Ve
.PP
If you must be naughty, you can suppress the warning by setting
\&\f(CW\*(C`DBIC_DONT_VALIDATE_RELS\*(C'\fR environment variable to a true value.  Otherwise,
you probably just meant to use \f(CW\*(C`DBIx::Class::Relationship/belongs_to\*(C'\fR.
.SS "has_one"
.IX Subsection "has_one"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
DBIx::Class::Row object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Every book has exactly one ISBN
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    \*(Aqbook_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming related_class stores our PK)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    { \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $isbn_obj = $book\->isbn; # to get the ISBN object
.Ve
.PP
Creates a one-to-one relationship with another class. This is just
like \f(CW\*(C`might_have\*(C'\fR, except the implication is that the other object is
always present. The only difference between \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR is that \f(CW\*(C`has_one\*(C'\fR uses an (ordinary) inner join,
whereas \f(CW\*(C`might_have\*(C'\fR defaults to a left join.
.PP
The has_one relationship should be used when a row in the table must
have exactly one related row in another table. If the related row
might not exist in the foreign table, use the
\&\*(L"might_have\*(R" in DBIx::Class::Relationship relationship.
.PP
In the above example, each Book in the database is associated with exactly one
\&\s-1ISBN\s0 object.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, if the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than warnings might apply just as with
\&\*(L"might_have\*(R" in DBIx::Class::Relationship.
.SS "many_to_many"
.IX Subsection "many_to_many"
.ie n .IP "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$link_rel_name\fR, \f(CW$foreign_rel_name\fR, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, %attrs?"
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is a \fIRelationship bridge\fR which has a specific
meaning in DBIx::Class, see the definition in the
Glossary.
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is not strictly a relationship in its own right. Instead, it is
a bridge between two resultsets which provide the same kind of convenience
accessors as true relationships provide. Although the accessor will return a
resultset or collection of objects just like has_many does, you cannot call
\&\f(CW\*(C`related_resultset\*(C'\fR and similar methods which operate on true relationships.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
DBIx::Class::Row object to retrieve the rows matching this
relationship.
.Sp
On a many_to_many, unlike other relationships, this cannot be used in
\&\*(L"search\*(R" in DBIx::Class::ResultSet to join tables. Use the relations
bridged across instead.
.IP "link_rel_name" 4
.IX Item "link_rel_name"
This is the accessor_name from the has_many relationship we are
bridging from.
.IP "foreign_rel_name" 4
.IX Item "foreign_rel_name"
This is the accessor_name of the belongs_to relationship in the link
table that we are bridging across (which gives us the table we are
bridging to).
.PP
To create a many_to_many relationship from Actor to Role:
.PP
.Vb 7
\&  My::DBIC::Schema::Actor\->has_many( actor_roles =>
\&                                     \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                     \*(Aqactor\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( role =>
\&                                            \*(AqMy::DBIC::Schema::Role\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( actor =>
\&                                            \*(AqMy::DBIC::Schema::Actor\*(Aq );
\&
\&  My::DBIC::Schema::Actor\->many_to_many( roles => \*(Aqactor_roles\*(Aq,
\&                                         \*(Aqrole\*(Aq );
.Ve
.PP
And, for the reverse relationship, from Role to Actor:
.PP
.Vb 3
\&  My::DBIC::Schema::Role\->has_many( actor_roles =>
\&                                    \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                    \*(Aqrole\*(Aq );
\&
\&  My::DBIC::Schema::Role\->many_to_many( actors => \*(Aqactor_roles\*(Aq, \*(Aqactor\*(Aq );
.Ve
.PP
To add a role for your actor, and fill in the year of the role in the
actor_roles table:
.PP
.Vb 1
\&  $actor\->add_to_roles($role, { year => 1995 });
.Ve
.PP
In the above example, ActorRoles is the link table class, and Role is the
foreign class. The \f(CW$link_rel_name\fR parameter is the name of the accessor for
the has_many relationship from this table to the link table, and the
\&\f(CW$foreign_rel_name\fR parameter is the accessor for the belongs_to relationship
from the link table to the foreign table.
.PP
To use many_to_many, existing relationships from the original table to the link
table, and from the link table to the end table must already exist, these
relation names are then used in the many_to_many call.
.PP
In the above example, the Actor class will have 3 many_to_many accessor methods
set: \f(CW\*(C`roles\*(C'\fR, \f(CW\*(C`add_to_roles\*(C'\fR, \f(CW\*(C`set_roles\*(C'\fR, and similarly named accessors
will be created for the Role class for the \f(CW\*(C`actors\*(C'\fR many_to_many
relationship.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SH "AUTHORS"
.IX Header "AUTHORS"
see DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Relationship5.18.3pm            0100644 0001750 0001750 00000070752 12566242377 026344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship 3"
.TH DBIx::Class::Relationship 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  ## Creating relationships
\&  MyApp::Schema::Actor\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqactor\*(Aq);
\&  MyApp::Schema::Role\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqrole\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqrole\*(Aq => \*(AqMyApp::Schema::Role\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqactor\*(Aq => \*(AqMyApp::Schema::Actor\*(Aq);
\&
\&  MyApp::Schema::Role\->many_to_many(\*(Aqactors\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqactor\*(Aq);
\&  MyApp::Schema::Actor\->many_to_many(\*(Aqroles\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqrole\*(Aq);
\&
\&  ## Using relationships
\&  $schema\->resultset(\*(AqActor\*(Aq)\->find({ id => 1})\->roles();
\&  $schema\->resultset(\*(AqRole\*(Aq)\->find({ id => 1 })\->actorroles\->search_related(\*(Aqactor\*(Aq, { Name => \*(AqFred\*(Aq });
\&  $schema\->resultset(\*(AqActor\*(Aq)\->add_to_roles({ Name => \*(AqSherlock Holmes\*(Aq});
.Ve
.PP
See DBIx::Class::Manual::Cookbook for more.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The word \fIRelationship\fR has a specific meaning in DBIx::Class, see
the definition in the Glossary.
.PP
This class provides methods to set up relationships between the tables
in your database model. Relationships are the most useful and powerful
technique that DBIx::Class provides. To create efficient database queries,
create relationships between any and all tables that have something in
common, for example if you have a table Authors:
.PP
.Vb 4
\&  ID  | Name | Age
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  | Fred | 30
\&   2  | Joe  | 32
.Ve
.PP
and a table Books:
.PP
.Vb 4
\&  ID  | Author | Name
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  |      1 | Rulers of the universe
\&   2  |      1 | Rulers of the galaxy
.Ve
.PP
Then without relationships, the method of getting all books by Fred goes like
this:
.PP
.Vb 2
\& my $fred = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq });
\& my $fredsbooks = $schema\->resultset(\*(AqBook\*(Aq)\->search({ Author => $fred\->ID });
.Ve
.PP
With a has_many relationship called \*(L"books\*(R" on Author (see below for details),
we can do this instead:
.PP
.Vb 1
\& my $fredsbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq })\->books;
.Ve
.PP
Each relationship sets up an accessor method on the
Result objects that represent the items
of your table. From ResultSet objects,
the relationships can be searched using the \*(L"search_related\*(R" method.
In list context, each returns a list of Result objects for the related class,
in scalar context, a new ResultSet representing the joined tables is
returned. Thus, the calls can be chained to produce complex queries.
Since the database is not actually queried until you attempt to retrieve
the data for an actual item, no time is wasted producing them.
.PP
.Vb 5
\& my $cheapfredbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({
\&   Name => \*(AqFred\*(Aq,
\& })\->books\->search_related(\*(Aqprices\*(Aq, {
\&   Price => { \*(Aq<=\*(Aq => \*(Aq5.00\*(Aq },
\& });
.Ve
.PP
will produce a query something like:
.PP
.Vb 4
\& SELECT * FROM Author me
\& LEFT JOIN Books books ON books.author = me.id
\& LEFT JOIN Prices prices ON prices.book = books.id
\& WHERE prices.Price <= 5.00
.Ve
.PP
all without needing multiple fetches.
.PP
Only the helper methods for setting up standard relationship types
are documented here. For the basic, lower-level methods, and a description
of all the useful *_related methods that you get for free, see
DBIx::Class::Relationship::Base.
.SH "METHODS"
.IX Header "METHODS"
All helper methods are called similar to the following template:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->$method_name(\*(Aqrelname\*(Aq, \*(AqForeign::Class\*(Aq, \e%cond|\e@cond|\e&cond?, \e%attrs?);
.Ve
.PP
Both \f(CW\*(C`cond\*(C'\fR and \f(CW\*(C`attrs\*(C'\fR are optional. Pass \f(CW\*(C`undef\*(C'\fR for \f(CW\*(C`cond\*(C'\fR if
you want to use the default value for it, but still want to set \f(CW\*(C`attrs\*(C'\fR.
.PP
See \*(L"condition\*(R" in DBIx::Class::Relationship::Base for full documentation on
definition of the \f(CW\*(C`cond\*(C'\fR argument.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on the
attributes that are allowed in the \f(CW\*(C`attrs\*(C'\fR argument.
.SS "belongs_to"
.IX Subsection "belongs_to"
.ie n .IP "Arguments: $accessor_name, $related_class, $our_fk_column|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$our_fk_column\fR|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $our_fk_column|%cond|@cond|$cond?, %attrs?"
.PP
Creates a relationship where the calling class stores the foreign
class's primary key in one (or more) of the calling class columns.
This relationship defaults to using \f(CW$accessor_name\fR as the column
name in this class to resolve the join against the primary key from
\&\f(CW$related_class\fR, unless \f(CW$our_fk_column\fR specifies the foreign key column
in this class or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table referenced by the foreign key in
this class.
.IP "our_fk_column" 4
.IX Item "our_fk_column"
The column name on this class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # in a Book class (where Author has many Books)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.author_id\*(Aq }
\&  );
\&
\&  # OR (similar result but uglier accessor name)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author_id =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq
\&  );
\&
\&  # Usage
\&  my $author_obj = $book\->author; # get author object
\&  $book\->author( $new_author_obj ); # set author object
\&  $book\->author_id(); # get the plain id
\&
\&  # To retrieve the plain id if you used the ugly version:
\&  $book\->get_column(\*(Aqauthor_id\*(Aq);
.Ve
.PP
If some of the foreign key columns are
nullable you probably want to set
the join_type attribute to
\&\f(CW\*(C`left\*(C'\fR explicitly so that \s-1SQL\s0 expressing this relation is composed with
a \f(CW\*(C`LEFT JOIN\*(C'\fR (as opposed to \f(CW\*(C`INNER JOIN\*(C'\fR which is default for
\&\*(L"belongs_to\*(R" relationships). This ensures that relationship traversal
works consistently in all situations. (i.e. resultsets involving
join or
prefetch).
The modified declaration is shown below:
.PP
.Vb 7
\&  # in a Book class (where Author has_many Books)
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor\*(Aq,
\&    { join_type => \*(Aqleft\*(Aq }
\&  );
.Ve
.PP
Cascading deletes are off by default on a \f(CW\*(C`belongs_to\*(C'\fR
relationship. To turn them on, pass \f(CW\*(C`cascade_delete => 1\*(C'\fR
in the \f(CW$attr\fR hashref.
.PP
By default, \s-1DBIC\s0 will return undef and avoid querying the database if a
\&\f(CW\*(C`belongs_to\*(C'\fR accessor is called when any part of the foreign key \s-1IS NULL.\s0 To
disable this behavior, pass \f(CW\*(C`undef_on_null_fk => 0\*(C'\fR in the \f(CW\*(C`\e%attrs\*(C'\fR
hashref.
.PP
\&\s-1NOTE:\s0 If you are used to Class::DBI relationships, this is the equivalent
of \f(CW\*(C`has_a\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on relationship
methods and valid relationship attributes. Also see DBIx::Class::ResultSet
for a list of standard resultset attributes
which can be assigned to relationships as well.
.SS "has_many"
.IX Subsection "has_many"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-many relationship where the foreign class refers to
this class's primary key. This relationship refers to zero or more
records in the foreign table (e.g. a \f(CW\*(C`LEFT JOIN\*(C'\fR). This relationship
defaults to using the end of this classes namespace as the foreign key
in \f(CW$related_class\fR to resolve the join, unless \f(CW$their_fk_column\fR
specifies the foreign key column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR
specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve a resultset of the related
class restricted to the ones related to the result object. In list
context it returns the result objects. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 7
\&  # in an Author class (where Author has_many Books)
\&  # assuming related class is storing our PK in "author_id"
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # OR (similar result, assuming related_class is storing our PK, in "author")
\&  # (the "author" is guessed at from "Author" in the class namespace)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&  );
\&
\&
\&  # Usage
\&  # resultset of Books belonging to author
\&  my $booklist = $author\->books;
\&
\&  # resultset of Books belonging to author, restricted by author name
\&  my $booklist = $author\->books({
\&    name => { LIKE => \*(Aq%macaroni%\*(Aq },
\&    { prefetch => [qw/book/],
\&  });
\&
\&  # array of Book objects belonging to author
\&  my @book_objs = $author\->books;
\&
\&  # force resultset even in list context
\&  my $books_rs = $author\->books;
\&  ( $books_rs ) = $obj\->books_rs;
\&
\&  # create a new book for this author, the relation fields are auto\-filled
\&  $author\->create_related(\*(Aqbooks\*(Aq, \e%col_data);
\&  # alternative method for the above
\&  $author\->add_to_books(\e%col_data);
.Ve
.PP
Three methods are created when you create a has_many relationship.
The first method is the expected accessor method, \f(CW\*(C`$accessor_name()\*(C'\fR.
The second is almost exactly the same as the accessor method but \*(L"_rs\*(R"
is added to the end of the method name, eg \f(CW\*(C`$accessor_name_rs()\*(C'\fR.
This method works just like the normal accessor, except that it always
returns a resultset, even in list context. The third method, named \f(CW\*(C`add_to_$relname\*(C'\fR, will also be added to your Row items; this allows
you to insert new related items, using the same mechanism as in
\&\*(L"create_related\*(R" in DBIx::Class::Relationship::Base.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be deleted as well.  To turn this behaviour off,
pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
If you copy an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be copied as well. To turn this behaviour off,
pass \f(CW\*(C`cascade_copy => 0\*(C'\fR in the \f(CW$attr\fR hashref. The behaviour
defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SS "might_have"
.IX Subsection "might_have"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates an optional one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Author may have an entry in the pseudonym table
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    \*(Aqauthor_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming the related_class stores our PK)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $pname = $author\->pseudonym; # to get the Pseudonym object
.Ve
.PP
If you update or delete an object in a class with a \f(CW\*(C`might_have\*(C'\fR
relationship, the related object will be updated or deleted as well. To
turn off this behavior, add \f(CW\*(C`cascade_delete => 0\*(C'\fR to the \f(CW$attr\fR
hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, and the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than \f(CW\*(C`might_have\*(C'\fR will warn about this because it's naughty and
you shouldn't do that. The warning will look something like:
.PP
.Vb 1
\&  "might_have/has_one" must not be on columns with is_nullable set to true (MySchema::SomeClass/key)
.Ve
.PP
If you must be naughty, you can suppress the warning by setting
\&\f(CW\*(C`DBIC_DONT_VALIDATE_RELS\*(C'\fR environment variable to a true value.  Otherwise,
you probably just meant to use \f(CW\*(C`DBIx::Class::Relationship/belongs_to\*(C'\fR.
.SS "has_one"
.IX Subsection "has_one"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Every book has exactly one ISBN
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    \*(Aqbook_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming related_class stores our PK)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    { \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $isbn_obj = $book\->isbn; # to get the ISBN object
.Ve
.PP
Creates a one-to-one relationship with another class. This is just
like \f(CW\*(C`might_have\*(C'\fR, except the implication is that the other object is
always present. The only difference between \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR is that \f(CW\*(C`has_one\*(C'\fR uses an (ordinary) inner join,
whereas \f(CW\*(C`might_have\*(C'\fR defaults to a left join.
.PP
The has_one relationship should be used when a row in the table must
have exactly one related row in another table. If the related row
might not exist in the foreign table, use the
\&\*(L"might_have\*(R" in DBIx::Class::Relationship relationship.
.PP
In the above example, each Book in the database is associated with exactly one
\&\s-1ISBN\s0 object.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, if the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than warnings might apply just as with
\&\*(L"might_have\*(R" in DBIx::Class::Relationship.
.SS "many_to_many"
.IX Subsection "many_to_many"
.ie n .IP "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$link_rel_name\fR, \f(CW$foreign_rel_name\fR, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, %attrs?"
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is a \fIRelationship bridge\fR which has a specific
meaning in DBIx::Class, see the definition in the
Glossary.
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is not strictly a relationship in its own right. Instead, it is
a bridge between two resultsets which provide the same kind of convenience
accessors as true relationships provide. Although the accessor will return a
resultset or collection of objects just like has_many does, you cannot call
\&\f(CW\*(C`related_resultset\*(C'\fR and similar methods which operate on true relationships.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the rows matching this
relationship.
.Sp
On a many_to_many, unlike other relationships, this cannot be used in
\&\*(L"search\*(R" in DBIx::Class::ResultSet to join tables. Use the relations
bridged across instead.
.IP "link_rel_name" 4
.IX Item "link_rel_name"
This is the accessor_name from the has_many relationship we are
bridging from.
.IP "foreign_rel_name" 4
.IX Item "foreign_rel_name"
This is the accessor_name of the belongs_to relationship in the link
table that we are bridging across (which gives us the table we are
bridging to).
.PP
To create a many_to_many relationship from Actor to Role:
.PP
.Vb 7
\&  My::DBIC::Schema::Actor\->has_many( actor_roles =>
\&                                     \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                     \*(Aqactor\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( role =>
\&                                            \*(AqMy::DBIC::Schema::Role\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( actor =>
\&                                            \*(AqMy::DBIC::Schema::Actor\*(Aq );
\&
\&  My::DBIC::Schema::Actor\->many_to_many( roles => \*(Aqactor_roles\*(Aq,
\&                                         \*(Aqrole\*(Aq );
.Ve
.PP
And, for the reverse relationship, from Role to Actor:
.PP
.Vb 3
\&  My::DBIC::Schema::Role\->has_many( actor_roles =>
\&                                    \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                    \*(Aqrole\*(Aq );
\&
\&  My::DBIC::Schema::Role\->many_to_many( actors => \*(Aqactor_roles\*(Aq, \*(Aqactor\*(Aq );
.Ve
.PP
To add a role for your actor, and fill in the year of the role in the
actor_roles table:
.PP
.Vb 1
\&  $actor\->add_to_roles($role, { year => 1995 });
.Ve
.PP
In the above example, ActorRoles is the link table class, and Role is the
foreign class. The \f(CW$link_rel_name\fR parameter is the name of the accessor for
the has_many relationship from this table to the link table, and the
\&\f(CW$foreign_rel_name\fR parameter is the accessor for the belongs_to relationship
from the link table to the foreign table.
.PP
To use many_to_many, existing relationships from the original table to the link
table, and from the link table to the end table must already exist, these
relation names are then used in the many_to_many call.
.PP
In the above example, the Actor class will have 3 many_to_many accessor methods
set: \f(CW\*(C`roles\*(C'\fR, \f(CW\*(C`add_to_roles\*(C'\fR, \f(CW\*(C`set_roles\*(C'\fR, and similarly named accessors
will be created for the Role class for the \f(CW\*(C`actors\*(C'\fR many_to_many
relationship.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Relationship::Base.3pm          0100644 0001750 0001750 00000102317 12566242377 027000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship::Base 3"
.TH DBIx::Class::Relationship::Base 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship::Base \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  _\|_PACKAGE_\|_\->add_relationship(
\&    spiders => \*(AqMy::DB::Result::Creatures\*(Aq,
\&    sub {
\&      my $args = shift;
\&      return {
\&        "$args\->{foreign_alias}.id"   => { \-ident => "$args\->{self_alias}.id" },
\&        "$args\->{foreign_alias}.type" => \*(Aqarachnid\*(Aq
\&      };
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides methods to describe the relationships between the
tables in your database model. These are the \*(L"bare bones\*(R" relationships
methods, for predefined ones, look in DBIx::Class::Relationship.
.SH "METHODS"
.IX Header "METHODS"
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: 'relname', 'Foreign::Class', $condition, $attrs" 4
.el .IP "Arguments: 'relname', 'Foreign::Class', \f(CW$condition\fR, \f(CW$attrs\fR" 4
.IX Item "Arguments: 'relname', 'Foreign::Class', $condition, $attrs"
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->add_relationship(\*(Aqrelname\*(Aq,
\&                                \*(AqForeign::Class\*(Aq,
\&                                $condition, $attrs);
.Ve
.PP
Create a custom relationship between one result source and another
source, indicated by its class name.
.PP
\fIcondition\fR
.IX Subsection "condition"
.PP
The condition argument describes the \f(CW\*(C`ON\*(C'\fR clause of the \f(CW\*(C`JOIN\*(C'\fR
expression used to connect the two sources when creating \s-1SQL\s0 queries.
.PP
Simple equality
.IX Subsection "Simple equality"
.PP
To create simple equality joins, supply a hashref containing the remote
table column name as the key(s) prefixed by \f(CW\*(Aqforeign.\*(Aq\fR, and the
corresponding local table column name as the value(s) prefixed by \f(CW\*(Aqself.\*(Aq\fR.
Both \f(CW\*(C`foreign\*(C'\fR and \f(CW\*(C`self\*(C'\fR are pseudo aliases and must be entered
literally. They will be replaced with the actual correct table alias
when the \s-1SQL\s0 is produced.
.PP
For example given:
.PP
.Vb 4
\&  My::Schema::Author\->has_many(
\&    books => \*(AqMy::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
\&  );
.Ve
.PP
A query like:
.PP
.Vb 1
\&  $author_rs\->search_related(\*(Aqbooks\*(Aq)\->next
.Ve
.PP
will result in the following \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 1
\&  ... FROM author me LEFT JOIN book books ON books.author_id = me.id ...
.Ve
.PP
This describes a relationship between the \f(CW\*(C`Author\*(C'\fR table and the
\&\f(CW\*(C`Book\*(C'\fR table where the \f(CW\*(C`Book\*(C'\fR table has a column \f(CW\*(C`author_id\*(C'\fR
containing the \s-1ID\s0 value of the \f(CW\*(C`Author\*(C'\fR.
.PP
Similarly:
.PP
.Vb 7
\&  My::Schema::Book\->has_many(
\&    editions => \*(AqMy::Schema::Edition\*(Aq,
\&    {
\&      \*(Aqforeign.publisher_id\*(Aq => \*(Aqself.publisher_id\*(Aq,
\&      \*(Aqforeign.type_id\*(Aq      => \*(Aqself.type_id\*(Aq,
\&    }
\&  );
\&
\&  ...
\&
\&  $book_rs\->search_related(\*(Aqeditions\*(Aq)\->next
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 4
\&  ... FROM book me
\&      LEFT JOIN edition editions ON
\&           editions.publisher_id = me.publisher_id
\&       AND editions.type_id = me.type_id ...
.Ve
.PP
This describes the relationship from \f(CW\*(C`Book\*(C'\fR to \f(CW\*(C`Edition\*(C'\fR, where the
\&\f(CW\*(C`Edition\*(C'\fR table refers to a publisher and a type (e.g. \*(L"paperback\*(R"):
.PP
Multiple groups of simple equality conditions
.IX Subsection "Multiple groups of simple equality conditions"
.PP
As is the default in SQL::Abstract, the key-value pairs will be
\&\f(CW\*(C`AND\*(C'\fRed in the resulting \f(CW\*(C`JOIN\*(C'\fR clause. An \f(CW\*(C`OR\*(C'\fR can be achieved with
an arrayref. For example a condition like:
.PP
.Vb 7
\&  My::Schema::Item\->has_many(
\&    related_item_links => My::Schema::Item::Links,
\&    [
\&      { \*(Aqforeign.left_itemid\*(Aq  => \*(Aqself.id\*(Aq },
\&      { \*(Aqforeign.right_itemid\*(Aq => \*(Aqself.id\*(Aq },
\&    ],
\&  );
.Ve
.PP
will translate to the following \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 3
\& ... FROM item me JOIN item_relations related_item_links ON
\&         related_item_links.left_itemid = me.id
\&      OR related_item_links.right_itemid = me.id ...
.Ve
.PP
This describes the relationship from \f(CW\*(C`Item\*(C'\fR to \f(CW\*(C`Item::Links\*(C'\fR, where
\&\f(CW\*(C`Item::Links\*(C'\fR is a many-to-many linking table, linking items back to
themselves in a peer fashion (without a \*(L"parent-child\*(R" designation)
.PP
Custom join conditions
.IX Subsection "Custom join conditions"
.PP
.Vb 5
\&  NOTE: The custom join condition specification mechanism is capable of
\&  generating JOIN clauses of virtually unlimited complexity. This may limit
\&  your ability to traverse some of the more involved relationship chains the
\&  way you expect, *and* may bring your RDBMS to its knees. Exercise care
\&  when declaring relationships as described here.
.Ve
.PP
To specify joins which describe more than a simple equality of column
values, the custom join condition coderef syntax can be used. For
example:
.PP
.Vb 4
\&  My::Schema::Artist\->has_many(
\&    cds_80s => \*(AqMy::Schema::CD\*(Aq,
\&    sub {
\&      my $args = shift;
\&
\&      return {
\&        "$args\->{foreign_alias}.artist" => { \-ident => "$args\->{self_alias}.artistid" },
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      };
\&    }
\&  );
\&
\&  ...
\&
\&  $artist_rs\->search_related(\*(Aqcds_80s\*(Aq)\->next;
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 4
\&  ... FROM artist me LEFT JOIN cd cds_80s ON
\&        cds_80s.artist = me.artistid
\&    AND cds_80s.year < ?
\&    AND cds_80s.year > ?
.Ve
.PP
with the bind values:
.PP
.Vb 1
\&   \*(Aq1990\*(Aq, \*(Aq1979\*(Aq
.Ve
.PP
\&\f(CW\*(C`$args\->{foreign_alias}\*(C'\fR and \f(CW\*(C`$args\->{self_alias}\*(C'\fR are supplied the
same values that would be otherwise substituted for \f(CW\*(C`foreign\*(C'\fR and \f(CW\*(C`self\*(C'\fR
in the simple hashref syntax case.
.PP
The coderef is expected to return a valid SQL::Abstract query-structure, just
like what one would supply as the first argument to
\&\*(L"search\*(R" in DBIx::Class::ResultSet. The return value will be passed directly to
SQL::Abstract and the resulting \s-1SQL\s0 will be used verbatim as the \f(CW\*(C`ON\*(C'\fR
clause of the \f(CW\*(C`JOIN\*(C'\fR statement associated with this relationship.
.PP
While every coderef-based condition must return a valid \f(CW\*(C`ON\*(C'\fR clause, it may
elect to additionally return a simplified join-free condition hashref when
invoked as \f(CW\*(C`$result\->relationship\*(C'\fR, as opposed to
\&\f(CW\*(C`$rs\->related_resultset(\*(Aqrelationship\*(Aq)\*(C'\fR. In this case \f(CW$result\fR is
passed to the coderef as \f(CW\*(C`$args\->{self_rowobj}\*(C'\fR, so a user can do the
following:
.PP
.Vb 2
\&  sub {
\&    my $args = shift;
\&
\&    return (
\&      {
\&        "$args\->{foreign_alias}.artist" => { \-ident => "$args\->{self_alias}.artistid" },
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      },
\&      $args\->{self_rowobj} && {
\&        "$args\->{foreign_alias}.artist" => $args\->{self_rowobj}\->artistid,
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      },
\&    );
\&  }
.Ve
.PP
Now this code:
.PP
.Vb 2
\&    my $artist = $schema\->resultset("Artist")\->find({ id => 4 });
\&    $artist\->cds_80s\->all;
.Ve
.PP
Can skip a \f(CW\*(C`JOIN\*(C'\fR altogether and instead produce:
.PP
.Vb 5
\&    SELECT cds_80s.cdid, cds_80s.artist, cds_80s.title, cds_80s.year, cds_80s.genreid, cds_80s.single_track
\&      FROM cd cds_80s
\&      WHERE cds_80s.artist = ?
\&        AND cds_80s.year < ?
\&        AND cds_80s.year > ?
.Ve
.PP
With the bind values:
.PP
.Vb 1
\&    \*(Aq4\*(Aq, \*(Aq1990\*(Aq, \*(Aq1979\*(Aq
.Ve
.PP
Note that in order to be able to use
\&\f(CW$result\fR\->create_related,
the coderef must not only return as its second such a \*(L"simple\*(R" condition
hashref which does not depend on joins being available, but the hashref must
contain only plain values/deflatable objects, such that the result can be
passed directly to \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base. For
instance the \f(CW\*(C`year\*(C'\fR constraint in the above example prevents the relationship
from being used to create related objects (an exception will be thrown).
.PP
In order to allow the user to go truly crazy when generating a custom \f(CW\*(C`ON\*(C'\fR
clause, the \f(CW$args\fR hashref passed to the subroutine contains some extra
metadata. Currently the supplied coderef is executed as:
.PP
.Vb 7
\&  $relationship_info\->{cond}\->({
\&    self_alias        => The alias of the invoking resultset (\*(Aqme\*(Aq in case of a result object),
\&    foreign_alias     => The alias of the to\-be\-joined resultset (often matches relname),
\&    self_resultsource => The invocant\*(Aqs resultsource,
\&    foreign_relname   => The relationship name (does *not* always match foreign_alias),
\&    self_rowobj       => The invocant itself in case of a $result_object\->$relationship call
\&  });
.Ve
.PP
\fIattributes\fR
.IX Subsection "attributes"
.PP
The standard ResultSet attributes may
be used as relationship attributes. In particular, the 'where' attribute is
useful for filtering relationships:
.PP
.Vb 4
\&     _\|_PACKAGE_\|_\->has_many( \*(Aqvalid_users\*(Aq, \*(AqMyApp::Schema::User\*(Aq,
\&        { \*(Aqforeign.user_id\*(Aq => \*(Aqself.user_id\*(Aq },
\&        { where => { valid => 1 } }
\&    );
.Ve
.PP
The following attributes are also valid:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any \s-1SQL\s0
join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in the \s-1SQL\s0
command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.ie n .IP "proxy => $column | \e@columns | \e%column" 4
.el .IP "proxy => \f(CW$column\fR | \e@columns | \e%column" 4
.IX Item "proxy => $column | @columns | %column"
The 'proxy' attribute can be used to retrieve values, and to perform
updates if the relationship has 'cascade_update' set. The 'might_have'
and 'has_one' relationships have this set by default; if you want a proxy
to update across a 'belongs_to' relationship, you must set the attribute
yourself.
.RS 4
.IP "\e@columns" 4
.IX Item "@columns"
An arrayref containing a list of accessors in the foreign class to create in
the main class. If, for example, you do the following:
.Sp
.Vb 4
\&  MyApp::Schema::CD\->might_have(liner_notes => \*(AqMyApp::Schema::LinerNotes\*(Aq,
\&    undef, {
\&      proxy => [ qw/notes/ ],
\&    });
.Ve
.Sp
Then, assuming MyApp::Schema::LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = MyApp::Schema::CD\->find(1);
\&  $cd\->notes(\*(AqNotes go here\*(Aq); # set notes \-\- LinerNotes object is
\&                               # created if it doesn\*(Aqt exist
.Ve
.Sp
For a 'belongs_to relationship, note the 'cascade_update':
.Sp
.Vb 5
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd,
\&      { proxy => [\*(Aqtitle\*(Aq], cascade_update => 1 }
\&  );
\&  $track\->title(\*(AqNew Title\*(Aq);
\&  $track\->update; # updates title in CD
.Ve
.IP "\e%column" 4
.IX Item "%column"
A hashref where each key is the accessor you want installed in the main class,
and its value is the name of the original in the foreign class.
.Sp
.Vb 3
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd\*(Aq, {
\&      proxy => { cd_title => \*(Aqtitle\*(Aq },
\&  });
.Ve
.Sp
This will create an accessor named \f(CW\*(C`cd_title\*(C'\fR on the \f(CW$track\fR result object.
.RE
.RS 4
.Sp
\&\s-1NOTE:\s0 you can pass a nested struct too, for example:
.Sp
.Vb 3
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd\*(Aq, {
\&    proxy => [ \*(Aqyear\*(Aq, { cd_title => \*(Aqtitle\*(Aq } ],
\&  });
.Ve
.RE
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the relationship.
Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single related object),
\&\f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for when there is a single
related object, but you also want the relationship accessor to double as
a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an add_to_* method is also
created, which calls \f(CW\*(C`create_related\*(C'\fR for the relationship.
.IP "is_foreign_key_constraint" 4
.IX Item "is_foreign_key_constraint"
If you are using SQL::Translator to create \s-1SQL\s0 for you and you find that it
is creating constraints where it shouldn't, or not creating them where it
should, set this attribute to a true or false value to override the detection
of when to create constraints.
.IP "cascade_copy" 4
.IX Item "cascade_copy"
If \f(CW\*(C`cascade_copy\*(C'\fR is true on a \f(CW\*(C`has_many\*(C'\fR relationship for an
object, then when you copy the object all the related objects will
be copied too. To turn this behaviour off, pass \f(CW\*(C`cascade_copy => 0\*(C'\fR
in the \f(CW$attr\fR hashref.
.Sp
The behaviour defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR for \f(CW\*(C`has_many\*(C'\fR
relationships.
.IP "cascade_delete" 4
.IX Item "cascade_delete"
By default, DBIx::Class cascades deletes across \f(CW\*(C`has_many\*(C'\fR,
\&\f(CW\*(C`has_one\*(C'\fR and \f(CW\*(C`might_have\*(C'\fR relationships. You can disable this
behaviour on a per-relationship basis by supplying
\&\f(CW\*(C`cascade_delete => 0\*(C'\fR in the relationship attributes.
.Sp
The cascaded operations are performed after the requested delete,
so if your database has a constraint on the relationship, it will
have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.IP "cascade_update" 4
.IX Item "cascade_update"
By default, DBIx::Class cascades updates across \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR relationships. You can disable this behaviour on a
per-relationship basis by supplying \f(CW\*(C`cascade_update => 0\*(C'\fR in
the relationship attributes.
.Sp
The \f(CW\*(C`belongs_to\*(C'\fR relationship does not update across relationships
by default, so if you have a 'proxy' attribute on a belongs_to and want to
use 'update' on it, you muse set \f(CW\*(C`cascade_update => 1\*(C'\fR.
.Sp
This is not a \s-1RDMS\s0 style cascade update \- it purely means that when
an object has update called on it, all the related objects also
have update called. It will not change foreign keys automatically \-
you must arrange to do this yourself.
.IP "on_delete / on_update" 4
.IX Item "on_delete / on_update"
If you are using SQL::Translator to create \s-1SQL\s0 for you, you can use these
attributes to explicitly set the desired \f(CW\*(C`ON DELETE\*(C'\fR or \f(CW\*(C`ON UPDATE\*(C'\fR constraint
type. If not supplied the \s-1SQLT\s0 parser will attempt to infer the constraint type by
interrogating the attributes of the \fBopposite\fR relationship. For any 'multi'
relationship with \f(CW\*(C`cascade_delete => 1\*(C'\fR, the corresponding belongs_to
relationship will be created with an \f(CW\*(C`ON DELETE CASCADE\*(C'\fR constraint. For any
relationship bearing \f(CW\*(C`cascade_copy => 1\*(C'\fR the resulting belongs_to constraint
will be \f(CW\*(C`ON UPDATE CASCADE\*(C'\fR. If you wish to disable this autodetection, and just
use the \s-1RDBMS\s0' default constraint type, pass \f(CW\*(C`on_delete => undef\*(C'\fR or
\&\f(CW\*(C`on_delete => \*(Aq\*(Aq\*(C'\fR, and the same for \f(CW\*(C`on_update\*(C'\fR respectively.
.IP "is_deferrable" 4
.IX Item "is_deferrable"
Tells SQL::Translator that the foreign key constraint it creates should be
deferrable. In other words, the user may request that the constraint be ignored
until the end of the transaction. Currently, only the PostgreSQL producer
actually supports this.
.IP "add_fk_index" 4
.IX Item "add_fk_index"
Tells SQL::Translator to add an index for this constraint. Can also be
specified globally in the args to \*(L"deploy\*(R" in DBIx::Class::Schema or
\&\*(L"create_ddl_dir\*(R" in DBIx::Class::Schema. Default is on, set to 0 to disable.
.SS "register_relationship"
.IX Subsection "register_relationship"
.ie n .IP "Arguments: $rel_name, $rel_info" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$rel_info\fR" 4
.IX Item "Arguments: $rel_name, $rel_info"
.PP
Registers a relationship on the class. This is called internally by
DBIx::Class::ResultSourceProxy to set up Accessors and Proxies.
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $related_resultset" 4
.el .IP "Return Value: \f(CW$related_resultset\fR" 4
.IX Item "Return Value: $related_resultset"
.PD
.PP
.Vb 1
\&  $rs = $cd\->related_resultset(\*(Aqartist\*(Aq);
.Ve
.PP
Returns a DBIx::Class::ResultSet for the relationship named
\&\f(CW$rel_name\fR.
.ie n .SS "$relationship_accessor"
.el .SS "\f(CW$relationship_accessor\fP"
.IX Subsection "$relationship_accessor"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | $related_resultset | undef" 4
.el .IP "Return Value: \f(CW$result\fR | \f(CW$related_resultset\fR | undef" 4
.IX Item "Return Value: $result | $related_resultset | undef"
.PD
.PP
.Vb 5
\&  # These pairs do the same thing
\&  $result = $cd\->related_resultset(\*(Aqartist\*(Aq)\->single;  # has_one relationship
\&  $result = $cd\->artist;
\&  $rs = $cd\->related_resultset(\*(Aqtracks\*(Aq);           # has_many relationship
\&  $rs = $cd\->tracks;
.Ve
.PP
This is the recommended way to traverse through relationships, based
on the \*(L"accessor\*(R" name given in the relationship definition.
.PP
This will return either a Result or a
ResultSet, depending on if the relationship is
\&\f(CW\*(C`single\*(C'\fR (returns only one row) or \f(CW\*(C`multi\*(C'\fR (returns many rows).  The
method may also return \f(CW\*(C`undef\*(C'\fR if the relationship doesn't exist for
this instance (like in the case of \f(CW\*(C`might_have\*(C'\fR relationships).
.SS "search_related"
.IX Subsection "search_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
Run a search on a related resultset. The search will be restricted to the
results represented by the DBIx::Class::ResultSet it was called
upon.
.PP
See \*(L"search_related\*(R" in DBIx::Class::ResultSet for more information.
.SS "search_related_rs"
.IX Subsection "search_related_rs"
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "count_related"
.IX Subsection "count_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Returns the count of all the rows in the related resultset, restricted by the
current result or where conditions.
.SS "new_related"
.IX Subsection "new_related"
.ie n .IP "Arguments: $rel_name, \e%col_data" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data" 4
.IX Item "Arguments: $rel_name, %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Create a new result object of the related foreign class.  It will magically set
any foreign key columns of the new object to the related primary key columns
of the source object for you.  The newly created result will not be saved into
your storage until you call \*(L"insert\*(R" in DBIx::Class::Row on it.
.SS "create_related"
.IX Subsection "create_related"
.ie n .IP "Arguments: $rel_name, \e%col_data" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data" 4
.IX Item "Arguments: $rel_name, %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 1
\&  my $result = $obj\->create_related($rel_name, \e%col_data);
.Ve
.PP
Creates a new result object, similarly to new_related, and also inserts the
result's data into your storage medium. See the distinction between \f(CW\*(C`create\*(C'\fR
and \f(CW\*(C`new\*(C'\fR in DBIx::Class::ResultSet for details.
.SS "find_related"
.IX Subsection "find_related"
.ie n .IP "Arguments: $rel_name, \e%col_data | @pk_values, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data | \f(CW@pk_values\fR, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data | @pk_values, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
.Vb 1
\&  my $result = $obj\->find_related($rel_name, \e%col_data);
.Ve
.PP
Attempt to find a related object using its primary key or unique constraints.
See \*(L"find\*(R" in DBIx::Class::ResultSet for details.
.SS "find_or_new_related"
.IX Subsection "find_or_new_related"
.ie n .IP "Arguments: $rel_name, \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Find a result object of a related class.  See \*(L"find_or_new\*(R" in DBIx::Class::ResultSet
for details.
.SS "find_or_create_related"
.IX Subsection "find_or_create_related"
.ie n .IP "Arguments: $rel_name, \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Find or create a result object of a related class. See
\&\*(L"find_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "update_or_create_related"
.IX Subsection "update_or_create_related"
.ie n .IP "Arguments: $rel_name, \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Update or create a result object of a related class. See
\&\*(L"update_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "set_from_related"
.IX Subsection "set_from_related"
.ie n .IP "Arguments: $rel_name, $result" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$result\fR" 4
.IX Item "Arguments: $rel_name, $result"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 2
\&  $book\->set_from_related(\*(Aqauthor\*(Aq, $author_obj);
\&  $book\->author($author_obj);                      ## same thing
.Ve
.PP
Set column values on the current object, using related values from the given
related object. This is used to associate previously separate objects, for
example, to set the correct author for a book, find the Author object, then
call set_from_related on the book.
.PP
This is called internally when you pass existing objects as values to
\&\*(L"create\*(R" in DBIx::Class::ResultSet, or pass an object to a belongs_to accessor.
.PP
The columns are only set in the local copy of the object, call \*(L"update\*(R" to
set them in the storage.
.SS "update_from_related"
.IX Subsection "update_from_related"
.ie n .IP "Arguments: $rel_name, $result" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$result\fR" 4
.IX Item "Arguments: $rel_name, $result"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 1
\&  $book\->update_from_related(\*(Aqauthor\*(Aq, $author_obj);
.Ve
.PP
The same as \*(L"set_from_related\*(R", but the changes are immediately updated
in storage.
.SS "delete_related"
.IX Subsection "delete_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $underlying_storage_rv" 4
.el .IP "Return Value: \f(CW$underlying_storage_rv\fR" 4
.IX Item "Return Value: $underlying_storage_rv"
.PD
.PP
Delete any related row, subject to the given conditions.  Internally, this
calls:
.PP
.Vb 1
\&  $self\->search_related(@_)\->delete
.Ve
.PP
And returns the result of that.
.SS "add_to_$rel"
.IX Subsection "add_to_$rel"
\&\fBCurrently only available for \f(CB\*(C`has_many\*(C'\fB, \f(CB\*(C`many_to_many\*(C'\fB and 'multi' type
relationships.\fR
.PP
\fIhas_many / multi\fR
.IX Subsection "has_many / multi"
.IP "Arguments: \e%col_data" 4
.IX Item "Arguments: %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Creates/inserts a new result object.  Internally, this calls:
.PP
.Vb 1
\&  $self\->create_related($rel, @_)
.Ve
.PP
And returns the result of that.
.PP
\fImany_to_many\fR
.IX Subsection "many_to_many"
.ie n .IP "Arguments: (\e%col_data | $result), \e%link_col_data?" 4
.el .IP "Arguments: (\e%col_data | \f(CW$result\fR), \e%link_col_data?" 4
.IX Item "Arguments: (%col_data | $result), %link_col_data?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->add_to_roles($role);
\&      # creates a My::DBIC::Schema::ActorRoles linking table result object
\&
\&  $actor\->add_to_roles({ name => \*(Aqlead\*(Aq }, { salary => 15_000_000 });
\&      # creates a new My::DBIC::Schema::Role result object and the linking table
\&      # object with an extra column in the link
.Ve
.PP
Adds a linking table object. If the first argument is a hash reference, the
related object is created first with the column values in the hash. If an object
reference is given, just the linking table object is created. In either case,
any additional column values for the linking table object can be specified in
\&\f(CW\*(C`\e%link_col_data\*(C'\fR.
.PP
See \*(L"many_to_many\*(R" in DBIx::Class::Relationship for additional details.
.SS "set_$rel"
.IX Subsection "set_$rel"
\&\fBCurrently only available for \f(CB\*(C`many_to_many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: (\e@hashrefs_of_col_data | \e@result_objs), $link_vals?" 4
.el .IP "Arguments: (\e@hashrefs_of_col_data | \e@result_objs), \f(CW$link_vals\fR?" 4
.IX Item "Arguments: (@hashrefs_of_col_data | @result_objs), $link_vals?"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 3
\&  my $actor = $schema\->resultset(\*(AqActor\*(Aq)\->find(1);
\&  my @roles = $schema\->resultset(\*(AqRole\*(Aq)\->search({ role =>
\&     { \*(Aq\-in\*(Aq => [\*(AqFred\*(Aq, \*(AqBarney\*(Aq] } } );
\&
\&  $actor\->set_roles(\e@roles);
\&     # Replaces all of $actor\*(Aqs previous roles with the two named
\&
\&  $actor\->set_roles(\e@roles, { salary => 15_000_000 });
\&     # Sets a column in the link table for all roles
.Ve
.PP
Replace all the related objects with the given reference to a list of
objects. This does a \f(CW\*(C`delete\*(C'\fR \fBon the link table resultset\fR to remove the
association between the current object and all related objects, then calls
\&\f(CW\*(C`add_to_$rel\*(C'\fR repeatedly to link all the new objects.
.PP
Note that this means that this method will \fBnot\fR delete any objects in the
table on the right side of the relation, merely that it will delete the link
between them.
.PP
Due to a mistake in the original implementation of this method, it will also
accept a list of objects or hash references. This is \fBdeprecated\fR and will be
removed in a future version.
.SS "remove_from_$rel"
.IX Subsection "remove_from_$rel"
\&\fBCurrently only available for \f(CB\*(C`many_to_many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: $result" 4
.el .IP "Arguments: \f(CW$result\fR" 4
.IX Item "Arguments: $result"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->remove_from_roles($role);
\&      # removes $role\*(Aqs My::DBIC::Schema::ActorRoles linking table result object
.Ve
.PP
Removes the link between the current object and the related object. Note that
the related object itself won't be deleted unless you call \->\fIdelete()\fR on
it. This method just removes the link between the two objects.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Relationship::Base5.16.3pm      0100644 0001750 0001750 00000066755 12566242363 027324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship::Base 3"
.TH DBIx::Class::Relationship::Base 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship::Base \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  _\|_PACKAGE_\|_\->add_relationship(
\&    spiders => \*(AqMy::DB::Result::Creatures\*(Aq,
\&    sub {
\&      my $args = shift;
\&      return {
\&        "$args\->{foreign_alias}.id"   => { \-ident => "$args\->{self_alias}.id" },
\&        "$args\->{foreign_alias}.type" => \*(Aqarachnid\*(Aq
\&      };
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides methods to describe the relationships between the
tables in your database model. These are the \*(L"bare bones\*(R" relationships
methods, for predefined ones, look in DBIx::Class::Relationship.
.SH "METHODS"
.IX Header "METHODS"
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: 'relname', 'Foreign::Class', $condition, $attrs" 4
.el .IP "Arguments: 'relname', 'Foreign::Class', \f(CW$condition\fR, \f(CW$attrs\fR" 4
.IX Item "Arguments: 'relname', 'Foreign::Class', $condition, $attrs"
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->add_relationship(\*(Aqrelname\*(Aq,
\&                                \*(AqForeign::Class\*(Aq,
\&                                $condition, $attrs);
.Ve
.PP
Create a custom relationship between one result source and another
source, indicated by its class name.
.PP
\fIcondition\fR
.IX Subsection "condition"
.PP
The condition argument describes the \f(CW\*(C`ON\*(C'\fR clause of the \f(CW\*(C`JOIN\*(C'\fR
expression used to connect the two sources when creating \s-1SQL\s0 queries.
.PP
To create simple equality joins, supply a hashref containing the
remote table column name as the key(s), and the local table column
name as the value(s), for example given:
.PP
.Vb 4
\&  My::Schema::Author\->has_many(
\&    books => \*(AqMy::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
\&  );
.Ve
.PP
A query like:
.PP
.Vb 1
\&  $author_rs\->search_related(\*(Aqbooks\*(Aq)\->next
.Ve
.PP
will result in the following \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 1
\&  ... FROM author me LEFT JOIN book books ON books.author_id = me.id ...
.Ve
.PP
This describes a relationship between the \f(CW\*(C`Author\*(C'\fR table and the
\&\f(CW\*(C`Book\*(C'\fR table where the \f(CW\*(C`Book\*(C'\fR table has a column \f(CW\*(C`author_id\*(C'\fR
containing the \s-1ID\s0 value of the \f(CW\*(C`Author\*(C'\fR.
.PP
\&\f(CW\*(C`foreign\*(C'\fR and \f(CW\*(C`self\*(C'\fR are pseudo aliases and must be entered
literally. They will be replaced with the actual correct table alias
when the \s-1SQL\s0 is produced.
.PP
Similarly:
.PP
.Vb 7
\&  My::Schema::Book\->has_many(
\&    editions => \*(AqMy::Schema::Edition\*(Aq,
\&    {
\&      \*(Aqforeign.publisher_id\*(Aq => \*(Aqself.publisher_id\*(Aq,
\&      \*(Aqforeign.type_id\*(Aq      => \*(Aqself.type_id\*(Aq,
\&    }
\&  );
\&
\&  ...
\&
\&  $book_rs\->search_related(\*(Aqeditions\*(Aq)\->next
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 4
\&  ... FROM book me
\&      LEFT JOIN edition editions ON
\&           editions.publisher_id = me.publisher_id
\&       AND editions.type_id = me.type_id ...
.Ve
.PP
This describes the relationship from \f(CW\*(C`Book\*(C'\fR to \f(CW\*(C`Edition\*(C'\fR, where the
\&\f(CW\*(C`Edition\*(C'\fR table refers to a publisher and a type (e.g. \*(L"paperback\*(R"):
.PP
As is the default in SQL::Abstract, the key-value pairs will be
\&\f(CW\*(C`AND\*(C'\fRed in the result. \f(CW\*(C`OR\*(C'\fR can be achieved with an arrayref, for
example a condition like:
.PP
.Vb 7
\&  My::Schema::Item\->has_many(
\&    related_item_links => My::Schema::Item::Links,
\&    [
\&      { \*(Aqforeign.left_itemid\*(Aq  => \*(Aqself.id\*(Aq },
\&      { \*(Aqforeign.right_itemid\*(Aq => \*(Aqself.id\*(Aq },
\&    ],
\&  );
.Ve
.PP
will translate to the following \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 3
\& ... FROM item me JOIN item_relations related_item_links ON
\&         related_item_links.left_itemid = me.id
\&      OR related_item_links.right_itemid = me.id ...
.Ve
.PP
This describes the relationship from \f(CW\*(C`Item\*(C'\fR to \f(CW\*(C`Item::Links\*(C'\fR, where
\&\f(CW\*(C`Item::Links\*(C'\fR is a many-to-many linking table, linking items back to
themselves in a peer fashion (without a \*(L"parent-child\*(R" designation)
.PP
To specify joins which describe more than a simple equality of column
values, the custom join condition coderef syntax can be used. For
example:
.PP
.Vb 4
\&  My::Schema::Artist\->has_many(
\&    cds_80s => \*(AqMy::Schema::CD\*(Aq,
\&    sub {
\&      my $args = shift;
\&
\&      return {
\&        "$args\->{foreign_alias}.artist" => { \-ident => "$args\->{self_alias}.artistid" },
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      };
\&    }
\&  );
\&
\&  ...
\&
\&  $artist_rs\->search_related(\*(Aqcds_80s\*(Aq)\->next;
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 4
\&  ... FROM artist me LEFT JOIN cd cds_80s ON
\&        cds_80s.artist = me.artistid
\&    AND cds_80s.year < ?
\&    AND cds_80s.year > ?
.Ve
.PP
with the bind values:
.PP
.Vb 1
\&   \*(Aq1990\*(Aq, \*(Aq1979\*(Aq
.Ve
.PP
\&\f(CW\*(C`$args\->{foreign_alias}\*(C'\fR and \f(CW\*(C`$args\->{self_alias}\*(C'\fR are supplied the
same values that would be otherwise substituted for \f(CW\*(C`foreign\*(C'\fR and \f(CW\*(C`self\*(C'\fR
in the simple hashref syntax case.
.PP
The coderef is expected to return a valid SQL::Abstract query-structure, just
like what one would supply as the first argument to
\&\*(L"search\*(R" in DBIx::Class::ResultSet. The return value will be passed directly to
SQL::Abstract and the resulting \s-1SQL\s0 will be used verbatim as the \f(CW\*(C`ON\*(C'\fR
clause of the \f(CW\*(C`JOIN\*(C'\fR statement associated with this relationship.
.PP
While every coderef-based condition must return a valid \f(CW\*(C`ON\*(C'\fR clause, it may
elect to additionally return a simplified join-free condition hashref when
invoked as \f(CW\*(C`$row_object\->relationship\*(C'\fR, as opposed to
\&\f(CW\*(C`$rs\->related_resultset(\*(Aqrelationship\*(Aq)\*(C'\fR. In this case \f(CW$row_object\fR is
passed to the coderef as \f(CW\*(C`$args\->{self_rowobj}\*(C'\fR, so a user can do the
following:
.PP
.Vb 2
\&  sub {
\&    my $args = shift;
\&
\&    return (
\&      {
\&        "$args\->{foreign_alias}.artist" => { \-ident => "$args\->{self_alias}.artistid" },
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      },
\&      $args\->{self_rowobj} && {
\&        "$args\->{foreign_alias}.artist" => $args\->{self_rowobj}\->artistid,
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      },
\&    );
\&  }
.Ve
.PP
Now this code:
.PP
.Vb 2
\&    my $artist = $schema\->resultset("Artist")\->find({ id => 4 });
\&    $artist\->cds_80s\->all;
.Ve
.PP
Can skip a \f(CW\*(C`JOIN\*(C'\fR altogether and instead produce:
.PP
.Vb 5
\&    SELECT cds_80s.cdid, cds_80s.artist, cds_80s.title, cds_80s.year, cds_80s.genreid, cds_80s.single_track
\&      FROM cd cds_80s
\&      WHERE cds_80s.artist = ?
\&        AND cds_80s.year < ?
\&        AND cds_80s.year > ?
.Ve
.PP
With the bind values:
.PP
.Vb 1
\&    \*(Aq4\*(Aq, \*(Aq1990\*(Aq, \*(Aq1979\*(Aq
.Ve
.PP
Note that in order to be able to use
\&\f(CW$row\fR\->create_related,
the coderef must not only return as its second such a \*(L"simple\*(R" condition
hashref which does not depend on joins being available, but the hashref must
contain only plain values/deflatable objects, such that the result can be
passed directly to \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base. For
instance the \f(CW\*(C`year\*(C'\fR constraint in the above example prevents the relationship
from being used to to create related objects (an exception will be thrown).
.PP
In order to allow the user to go truly crazy when generating a custom \f(CW\*(C`ON\*(C'\fR
clause, the \f(CW$args\fR hashref passed to the subroutine contains some extra
metadata. Currently the supplied coderef is executed as:
.PP
.Vb 7
\&  $relationship_info\->{cond}\->({
\&    self_alias        => The alias of the invoking resultset (\*(Aqme\*(Aq in case of a row object),
\&    foreign_alias     => The alias of the to\-be\-joined resultset (often matches relname),
\&    self_resultsource => The invocant\*(Aqs resultsource,
\&    foreign_relname   => The relationship name (does *not* always match foreign_alias),
\&    self_rowobj       => The invocant itself in case of $row_obj\->relationship
\&  });
.Ve
.PP
\fIattributes\fR
.IX Subsection "attributes"
.PP
The standard ResultSet attributes may
be used as relationship attributes. In particular, the 'where' attribute is
useful for filtering relationships:
.PP
.Vb 4
\&     _\|_PACKAGE_\|_\->has_many( \*(Aqvalid_users\*(Aq, \*(AqMyApp::Schema::User\*(Aq,
\&        { \*(Aqforeign.user_id\*(Aq => \*(Aqself.user_id\*(Aq },
\&        { where => { valid => 1 } }
\&    );
.Ve
.PP
The following attributes are also valid:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any \s-1SQL\s0
join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in the \s-1SQL\s0
command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.ie n .IP "proxy => $column | \e@columns | \e%column" 4
.el .IP "proxy => \f(CW$column\fR | \e@columns | \e%column" 4
.IX Item "proxy => $column | @columns | %column"
The 'proxy' attribute can be used to retrieve values, and to perform
updates if the relationship has 'cascade_update' set. The 'might_have'
and 'has_one' relationships have this set by default; if you want a proxy
to update across a 'belongs_to' relationship, you must set the attribute
yourself.
.RS 4
.IP "\e@columns" 4
.IX Item "@columns"
An arrayref containing a list of accessors in the foreign class to create in
the main class. If, for example, you do the following:
.Sp
.Vb 4
\&  MyApp::Schema::CD\->might_have(liner_notes => \*(AqMyApp::Schema::LinerNotes\*(Aq,
\&    undef, {
\&      proxy => [ qw/notes/ ],
\&    });
.Ve
.Sp
Then, assuming MyApp::Schema::LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = MyApp::Schema::CD\->find(1);
\&  $cd\->notes(\*(AqNotes go here\*(Aq); # set notes \-\- LinerNotes object is
\&                               # created if it doesn\*(Aqt exist
.Ve
.Sp
For a 'belongs_to relationship, note the 'cascade_update':
.Sp
.Vb 5
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd,
\&      { proxy => [\*(Aqtitle\*(Aq], cascade_update => 1 }
\&  );
\&  $track\->title(\*(AqNew Title\*(Aq);
\&  $track\->update; # updates title in CD
.Ve
.IP "\e%column" 4
.IX Item "%column"
A hashref where each key is the accessor you want installed in the main class,
and its value is the name of the original in the fireign class.
.Sp
.Vb 3
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd\*(Aq, {
\&      proxy => { cd_title => \*(Aqtitle\*(Aq },
\&  });
.Ve
.Sp
This will create an accessor named \f(CW\*(C`cd_title\*(C'\fR on the \f(CW$track\fR row object.
.RE
.RS 4
.Sp
\&\s-1NOTE:\s0 you can pass a nested struct too, for example:
.Sp
.Vb 3
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd\*(Aq, {
\&    proxy => [ \*(Aqyear\*(Aq, { cd_title => \*(Aqtitle\*(Aq } ],
\&  });
.Ve
.RE
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the relationship.
Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single related object),
\&\f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for when there is a single
related object, but you also want the relationship accessor to double as
a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an add_to_* method is also
created, which calls \f(CW\*(C`create_related\*(C'\fR for the relationship.
.IP "is_foreign_key_constraint" 4
.IX Item "is_foreign_key_constraint"
If you are using SQL::Translator to create \s-1SQL\s0 for you and you find that it
is creating constraints where it shouldn't, or not creating them where it
should, set this attribute to a true or false value to override the detection
of when to create constraints.
.IP "cascade_copy" 4
.IX Item "cascade_copy"
If \f(CW\*(C`cascade_copy\*(C'\fR is true on a \f(CW\*(C`has_many\*(C'\fR relationship for an
object, then when you copy the object all the related objects will
be copied too. To turn this behaviour off, pass \f(CW\*(C`cascade_copy => 0\*(C'\fR
in the \f(CW$attr\fR hashref.
.Sp
The behaviour defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR for \f(CW\*(C`has_many\*(C'\fR
relationships.
.IP "cascade_delete" 4
.IX Item "cascade_delete"
By default, DBIx::Class cascades deletes across \f(CW\*(C`has_many\*(C'\fR,
\&\f(CW\*(C`has_one\*(C'\fR and \f(CW\*(C`might_have\*(C'\fR relationships. You can disable this
behaviour on a per-relationship basis by supplying
\&\f(CW\*(C`cascade_delete => 0\*(C'\fR in the relationship attributes.
.Sp
The cascaded operations are performed after the requested delete,
so if your database has a constraint on the relationship, it will
have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.IP "cascade_update" 4
.IX Item "cascade_update"
By default, DBIx::Class cascades updates across \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR relationships. You can disable this behaviour on a
per-relationship basis by supplying \f(CW\*(C`cascade_update => 0\*(C'\fR in
the relationship attributes.
.Sp
The \f(CW\*(C`belongs_to\*(C'\fR relationship does not update across relationships
by default, so if you have a 'proxy' attribute on a belongs_to and want to
use 'update' on it, you muse set \f(CW\*(C`cascade_update => 1\*(C'\fR.
.Sp
This is not a \s-1RDMS\s0 style cascade update \- it purely means that when
an object has update called on it, all the related objects also
have update called. It will not change foreign keys automatically \-
you must arrange to do this yourself.
.IP "on_delete / on_update" 4
.IX Item "on_delete / on_update"
If you are using SQL::Translator to create \s-1SQL\s0 for you, you can use these
attributes to explicitly set the desired \f(CW\*(C`ON DELETE\*(C'\fR or \f(CW\*(C`ON UPDATE\*(C'\fR constraint
type. If not supplied the \s-1SQLT\s0 parser will attempt to infer the constraint type by
interrogating the attributes of the \fBopposite\fR relationship. For any 'multi'
relationship with \f(CW\*(C`cascade_delete => 1\*(C'\fR, the corresponding belongs_to
relationship will be created with an \f(CW\*(C`ON DELETE CASCADE\*(C'\fR constraint. For any
relationship bearing \f(CW\*(C`cascade_copy => 1\*(C'\fR the resulting belongs_to constraint
will be \f(CW\*(C`ON UPDATE CASCADE\*(C'\fR. If you wish to disable this autodetection, and just
use the \s-1RDBMS\s0' default constraint type, pass \f(CW\*(C`on_delete => undef\*(C'\fR or
\&\f(CW\*(C`on_delete => \*(Aq\*(Aq\*(C'\fR, and the same for \f(CW\*(C`on_update\*(C'\fR respectively.
.IP "is_deferrable" 4
.IX Item "is_deferrable"
Tells SQL::Translator that the foreign key constraint it creates should be
deferrable. In other words, the user may request that the constraint be ignored
until the end of the transaction. Currently, only the PostgreSQL producer
actually supports this.
.IP "add_fk_index" 4
.IX Item "add_fk_index"
Tells SQL::Translator to add an index for this constraint. Can also be
specified globally in the args to \*(L"deploy\*(R" in DBIx::Class::Schema or
\&\*(L"create_ddl_dir\*(R" in DBIx::Class::Schema. Default is on, set to 0 to disable.
.SS "register_relationship"
.IX Subsection "register_relationship"
.ie n .IP "Arguments: $relname, $rel_info" 4
.el .IP "Arguments: \f(CW$relname\fR, \f(CW$rel_info\fR" 4
.IX Item "Arguments: $relname, $rel_info"
.PP
Registers a relationship on the class. This is called internally by
DBIx::Class::ResultSourceProxy to set up Accessors and Proxies.
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $relationship_name" 4
.el .IP "Arguments: \f(CW$relationship_name\fR" 4
.IX Item "Arguments: $relationship_name"
.PD 0
.ie n .IP "Return Value: $related_resultset" 4
.el .IP "Return Value: \f(CW$related_resultset\fR" 4
.IX Item "Return Value: $related_resultset"
.PD
.PP
.Vb 1
\&  $rs = $cd\->related_resultset(\*(Aqartist\*(Aq);
.Ve
.PP
Returns a DBIx::Class::ResultSet for the relationship named
\&\f(CW$relationship_name\fR.
.SS "search_related"
.IX Subsection "search_related"
.Vb 2
\&  @objects = $rs\->search_related(\*(Aqrelname\*(Aq, $cond, $attrs);
\&  $objects_rs = $rs\->search_related(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
Run a search on a related resultset. The search will be restricted to the
item or items represented by the DBIx::Class::ResultSet it was called
upon. This method can be called on a ResultSet, a Row or a ResultSource class.
.SS "search_related_rs"
.IX Subsection "search_related_rs"
.Vb 1
\&  ( $objects_rs ) = $rs\->search_related_rs(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "count_related"
.IX Subsection "count_related"
.Vb 1
\&  $obj\->count_related(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
Returns the count of all the items in the related resultset, restricted by the
current item or where conditions. Can be called on a
\&\*(L"ResultSet\*(R" in DBIx::Class::Manual::Glossary or a
\&\*(L"Row\*(R" in DBIx::Class::Manual::Glossary object.
.SS "new_related"
.IX Subsection "new_related"
.Vb 1
\&  my $new_obj = $obj\->new_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Create a new item of the related foreign class. If called on a
Row object, it will magically
set any foreign key columns of the new object to the related primary
key columns of the source object for you.  The newly created item will
not be saved into your storage until you call \*(L"insert\*(R" in DBIx::Class::Row
on it.
.SS "create_related"
.IX Subsection "create_related"
.Vb 1
\&  my $new_obj = $obj\->create_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Creates a new item, similarly to new_related, and also inserts the item's data
into your storage medium. See the distinction between \f(CW\*(C`create\*(C'\fR and \f(CW\*(C`new\*(C'\fR
in DBIx::Class::ResultSet for details.
.SS "find_related"
.IX Subsection "find_related"
.Vb 1
\&  my $found_item = $obj\->find_related(\*(Aqrelname\*(Aq, @pri_vals | \e%pri_vals);
.Ve
.PP
Attempt to find a related object using its primary key or unique constraints.
See \*(L"find\*(R" in DBIx::Class::ResultSet for details.
.SS "find_or_new_related"
.IX Subsection "find_or_new_related"
.Vb 1
\&  my $new_obj = $obj\->find_or_new_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Find an item of a related class. If none exists, instantiate a new item of the
related class. The object will not be saved into your storage until you call
\&\*(L"insert\*(R" in DBIx::Class::Row on it.
.SS "find_or_create_related"
.IX Subsection "find_or_create_related"
.Vb 1
\&  my $new_obj = $obj\->find_or_create_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Find or create an item of a related class. See
\&\*(L"find_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "update_or_create_related"
.IX Subsection "update_or_create_related"
.Vb 1
\&  my $updated_item = $obj\->update_or_create_related(\*(Aqrelname\*(Aq, \e%col_data, \e%attrs?);
.Ve
.PP
Update or create an item of a related class. See
\&\*(L"update_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "set_from_related"
.IX Subsection "set_from_related"
.Vb 2
\&  $book\->set_from_related(\*(Aqauthor\*(Aq, $author_obj);
\&  $book\->author($author_obj);                      ## same thing
.Ve
.PP
Set column values on the current object, using related values from the given
related object. This is used to associate previously separate objects, for
example, to set the correct author for a book, find the Author object, then
call set_from_related on the book.
.PP
This is called internally when you pass existing objects as values to
\&\*(L"create\*(R" in DBIx::Class::ResultSet, or pass an object to a belongs_to accessor.
.PP
The columns are only set in the local copy of the object, call \*(L"update\*(R" to
set them in the storage.
.SS "update_from_related"
.IX Subsection "update_from_related"
.Vb 1
\&  $book\->update_from_related(\*(Aqauthor\*(Aq, $author_obj);
.Ve
.PP
The same as \*(L"set_from_related\*(R", but the changes are immediately updated
in storage.
.SS "delete_related"
.IX Subsection "delete_related"
.Vb 1
\&  $obj\->delete_related(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
Delete any related item subject to the given conditions.
.SS "add_to_$rel"
.IX Subsection "add_to_$rel"
\&\fBCurrently only available for \f(CB\*(C`has_many\*(C'\fB, \f(CB\*(C`many\-to\-many\*(C'\fB and 'multi' type
relationships.\fR
.ie n .IP "Arguments: ($foreign_vals | $obj), $link_vals?" 4
.el .IP "Arguments: ($foreign_vals | \f(CW$obj\fR), \f(CW$link_vals\fR?" 4
.IX Item "Arguments: ($foreign_vals | $obj), $link_vals?"
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->add_to_roles($role);
\&      # creates a My::DBIC::Schema::ActorRoles linking table row object
\&
\&  $actor\->add_to_roles({ name => \*(Aqlead\*(Aq }, { salary => 15_000_000 });
\&      # creates a new My::DBIC::Schema::Role row object and the linking table
\&      # object with an extra column in the link
.Ve
.PP
Adds a linking table object for \f(CW$obj\fR or \f(CW$foreign_vals\fR. If the first
argument is a hash reference, the related object is created first with the
column values in the hash. If an object reference is given, just the linking
table object is created. In either case, any additional column values for the
linking table object can be specified in \f(CW$link_vals\fR.
.SS "set_$rel"
.IX Subsection "set_$rel"
\&\fBCurrently only available for \f(CB\*(C`many\-to\-many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: (\e@hashrefs | \e@objs), $link_vals?" 4
.el .IP "Arguments: (\e@hashrefs | \e@objs), \f(CW$link_vals\fR?" 4
.IX Item "Arguments: (@hashrefs | @objs), $link_vals?"
.PP
.Vb 3
\&  my $actor = $schema\->resultset(\*(AqActor\*(Aq)\->find(1);
\&  my @roles = $schema\->resultset(\*(AqRole\*(Aq)\->search({ role =>
\&     { \*(Aq\-in\*(Aq => [\*(AqFred\*(Aq, \*(AqBarney\*(Aq] } } );
\&
\&  $actor\->set_roles(\e@roles);
\&     # Replaces all of $actor\*(Aqs previous roles with the two named
\&
\&  $actor\->set_roles(\e@roles, { salary => 15_000_000 });
\&     # Sets a column in the link table for all roles
.Ve
.PP
Replace all the related objects with the given reference to a list of
objects. This does a \f(CW\*(C`delete\*(C'\fR \fBon the link table resultset\fR to remove the
association between the current object and all related objects, then calls
\&\f(CW\*(C`add_to_$rel\*(C'\fR repeatedly to link all the new objects.
.PP
Note that this means that this method will \fBnot\fR delete any objects in the
table on the right side of the relation, merely that it will delete the link
between them.
.PP
Due to a mistake in the original implementation of this method, it will also
accept a list of objects or hash references. This is \fBdeprecated\fR and will be
removed in a future version.
.SS "remove_from_$rel"
.IX Subsection "remove_from_$rel"
\&\fBCurrently only available for \f(CB\*(C`many\-to\-many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: $obj" 4
.el .IP "Arguments: \f(CW$obj\fR" 4
.IX Item "Arguments: $obj"
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->remove_from_roles($role);
\&      # removes $role\*(Aqs My::DBIC::Schema::ActorRoles linking table row object
.Ve
.PP
Removes the link between the current object and the related object. Note that
the related object itself won't be deleted unless you call \->\fIdelete()\fR on
it. This method just removes the link between the two objects.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Relationship::Base5.18.3pm      0100644 0001750 0001750 00000102317 12566242377 027314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship::Base 3"
.TH DBIx::Class::Relationship::Base 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship::Base \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  _\|_PACKAGE_\|_\->add_relationship(
\&    spiders => \*(AqMy::DB::Result::Creatures\*(Aq,
\&    sub {
\&      my $args = shift;
\&      return {
\&        "$args\->{foreign_alias}.id"   => { \-ident => "$args\->{self_alias}.id" },
\&        "$args\->{foreign_alias}.type" => \*(Aqarachnid\*(Aq
\&      };
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides methods to describe the relationships between the
tables in your database model. These are the \*(L"bare bones\*(R" relationships
methods, for predefined ones, look in DBIx::Class::Relationship.
.SH "METHODS"
.IX Header "METHODS"
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: 'relname', 'Foreign::Class', $condition, $attrs" 4
.el .IP "Arguments: 'relname', 'Foreign::Class', \f(CW$condition\fR, \f(CW$attrs\fR" 4
.IX Item "Arguments: 'relname', 'Foreign::Class', $condition, $attrs"
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->add_relationship(\*(Aqrelname\*(Aq,
\&                                \*(AqForeign::Class\*(Aq,
\&                                $condition, $attrs);
.Ve
.PP
Create a custom relationship between one result source and another
source, indicated by its class name.
.PP
\fIcondition\fR
.IX Subsection "condition"
.PP
The condition argument describes the \f(CW\*(C`ON\*(C'\fR clause of the \f(CW\*(C`JOIN\*(C'\fR
expression used to connect the two sources when creating \s-1SQL\s0 queries.
.PP
Simple equality
.IX Subsection "Simple equality"
.PP
To create simple equality joins, supply a hashref containing the remote
table column name as the key(s) prefixed by \f(CW\*(Aqforeign.\*(Aq\fR, and the
corresponding local table column name as the value(s) prefixed by \f(CW\*(Aqself.\*(Aq\fR.
Both \f(CW\*(C`foreign\*(C'\fR and \f(CW\*(C`self\*(C'\fR are pseudo aliases and must be entered
literally. They will be replaced with the actual correct table alias
when the \s-1SQL\s0 is produced.
.PP
For example given:
.PP
.Vb 4
\&  My::Schema::Author\->has_many(
\&    books => \*(AqMy::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
\&  );
.Ve
.PP
A query like:
.PP
.Vb 1
\&  $author_rs\->search_related(\*(Aqbooks\*(Aq)\->next
.Ve
.PP
will result in the following \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 1
\&  ... FROM author me LEFT JOIN book books ON books.author_id = me.id ...
.Ve
.PP
This describes a relationship between the \f(CW\*(C`Author\*(C'\fR table and the
\&\f(CW\*(C`Book\*(C'\fR table where the \f(CW\*(C`Book\*(C'\fR table has a column \f(CW\*(C`author_id\*(C'\fR
containing the \s-1ID\s0 value of the \f(CW\*(C`Author\*(C'\fR.
.PP
Similarly:
.PP
.Vb 7
\&  My::Schema::Book\->has_many(
\&    editions => \*(AqMy::Schema::Edition\*(Aq,
\&    {
\&      \*(Aqforeign.publisher_id\*(Aq => \*(Aqself.publisher_id\*(Aq,
\&      \*(Aqforeign.type_id\*(Aq      => \*(Aqself.type_id\*(Aq,
\&    }
\&  );
\&
\&  ...
\&
\&  $book_rs\->search_related(\*(Aqeditions\*(Aq)\->next
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 4
\&  ... FROM book me
\&      LEFT JOIN edition editions ON
\&           editions.publisher_id = me.publisher_id
\&       AND editions.type_id = me.type_id ...
.Ve
.PP
This describes the relationship from \f(CW\*(C`Book\*(C'\fR to \f(CW\*(C`Edition\*(C'\fR, where the
\&\f(CW\*(C`Edition\*(C'\fR table refers to a publisher and a type (e.g. \*(L"paperback\*(R"):
.PP
Multiple groups of simple equality conditions
.IX Subsection "Multiple groups of simple equality conditions"
.PP
As is the default in SQL::Abstract, the key-value pairs will be
\&\f(CW\*(C`AND\*(C'\fRed in the resulting \f(CW\*(C`JOIN\*(C'\fR clause. An \f(CW\*(C`OR\*(C'\fR can be achieved with
an arrayref. For example a condition like:
.PP
.Vb 7
\&  My::Schema::Item\->has_many(
\&    related_item_links => My::Schema::Item::Links,
\&    [
\&      { \*(Aqforeign.left_itemid\*(Aq  => \*(Aqself.id\*(Aq },
\&      { \*(Aqforeign.right_itemid\*(Aq => \*(Aqself.id\*(Aq },
\&    ],
\&  );
.Ve
.PP
will translate to the following \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 3
\& ... FROM item me JOIN item_relations related_item_links ON
\&         related_item_links.left_itemid = me.id
\&      OR related_item_links.right_itemid = me.id ...
.Ve
.PP
This describes the relationship from \f(CW\*(C`Item\*(C'\fR to \f(CW\*(C`Item::Links\*(C'\fR, where
\&\f(CW\*(C`Item::Links\*(C'\fR is a many-to-many linking table, linking items back to
themselves in a peer fashion (without a \*(L"parent-child\*(R" designation)
.PP
Custom join conditions
.IX Subsection "Custom join conditions"
.PP
.Vb 5
\&  NOTE: The custom join condition specification mechanism is capable of
\&  generating JOIN clauses of virtually unlimited complexity. This may limit
\&  your ability to traverse some of the more involved relationship chains the
\&  way you expect, *and* may bring your RDBMS to its knees. Exercise care
\&  when declaring relationships as described here.
.Ve
.PP
To specify joins which describe more than a simple equality of column
values, the custom join condition coderef syntax can be used. For
example:
.PP
.Vb 4
\&  My::Schema::Artist\->has_many(
\&    cds_80s => \*(AqMy::Schema::CD\*(Aq,
\&    sub {
\&      my $args = shift;
\&
\&      return {
\&        "$args\->{foreign_alias}.artist" => { \-ident => "$args\->{self_alias}.artistid" },
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      };
\&    }
\&  );
\&
\&  ...
\&
\&  $artist_rs\->search_related(\*(Aqcds_80s\*(Aq)\->next;
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 4
\&  ... FROM artist me LEFT JOIN cd cds_80s ON
\&        cds_80s.artist = me.artistid
\&    AND cds_80s.year < ?
\&    AND cds_80s.year > ?
.Ve
.PP
with the bind values:
.PP
.Vb 1
\&   \*(Aq1990\*(Aq, \*(Aq1979\*(Aq
.Ve
.PP
\&\f(CW\*(C`$args\->{foreign_alias}\*(C'\fR and \f(CW\*(C`$args\->{self_alias}\*(C'\fR are supplied the
same values that would be otherwise substituted for \f(CW\*(C`foreign\*(C'\fR and \f(CW\*(C`self\*(C'\fR
in the simple hashref syntax case.
.PP
The coderef is expected to return a valid SQL::Abstract query-structure, just
like what one would supply as the first argument to
\&\*(L"search\*(R" in DBIx::Class::ResultSet. The return value will be passed directly to
SQL::Abstract and the resulting \s-1SQL\s0 will be used verbatim as the \f(CW\*(C`ON\*(C'\fR
clause of the \f(CW\*(C`JOIN\*(C'\fR statement associated with this relationship.
.PP
While every coderef-based condition must return a valid \f(CW\*(C`ON\*(C'\fR clause, it may
elect to additionally return a simplified join-free condition hashref when
invoked as \f(CW\*(C`$result\->relationship\*(C'\fR, as opposed to
\&\f(CW\*(C`$rs\->related_resultset(\*(Aqrelationship\*(Aq)\*(C'\fR. In this case \f(CW$result\fR is
passed to the coderef as \f(CW\*(C`$args\->{self_rowobj}\*(C'\fR, so a user can do the
following:
.PP
.Vb 2
\&  sub {
\&    my $args = shift;
\&
\&    return (
\&      {
\&        "$args\->{foreign_alias}.artist" => { \-ident => "$args\->{self_alias}.artistid" },
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      },
\&      $args\->{self_rowobj} && {
\&        "$args\->{foreign_alias}.artist" => $args\->{self_rowobj}\->artistid,
\&        "$args\->{foreign_alias}.year"   => { \*(Aq>\*(Aq, "1979", \*(Aq<\*(Aq, "1990" },
\&      },
\&    );
\&  }
.Ve
.PP
Now this code:
.PP
.Vb 2
\&    my $artist = $schema\->resultset("Artist")\->find({ id => 4 });
\&    $artist\->cds_80s\->all;
.Ve
.PP
Can skip a \f(CW\*(C`JOIN\*(C'\fR altogether and instead produce:
.PP
.Vb 5
\&    SELECT cds_80s.cdid, cds_80s.artist, cds_80s.title, cds_80s.year, cds_80s.genreid, cds_80s.single_track
\&      FROM cd cds_80s
\&      WHERE cds_80s.artist = ?
\&        AND cds_80s.year < ?
\&        AND cds_80s.year > ?
.Ve
.PP
With the bind values:
.PP
.Vb 1
\&    \*(Aq4\*(Aq, \*(Aq1990\*(Aq, \*(Aq1979\*(Aq
.Ve
.PP
Note that in order to be able to use
\&\f(CW$result\fR\->create_related,
the coderef must not only return as its second such a \*(L"simple\*(R" condition
hashref which does not depend on joins being available, but the hashref must
contain only plain values/deflatable objects, such that the result can be
passed directly to \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base. For
instance the \f(CW\*(C`year\*(C'\fR constraint in the above example prevents the relationship
from being used to create related objects (an exception will be thrown).
.PP
In order to allow the user to go truly crazy when generating a custom \f(CW\*(C`ON\*(C'\fR
clause, the \f(CW$args\fR hashref passed to the subroutine contains some extra
metadata. Currently the supplied coderef is executed as:
.PP
.Vb 7
\&  $relationship_info\->{cond}\->({
\&    self_alias        => The alias of the invoking resultset (\*(Aqme\*(Aq in case of a result object),
\&    foreign_alias     => The alias of the to\-be\-joined resultset (often matches relname),
\&    self_resultsource => The invocant\*(Aqs resultsource,
\&    foreign_relname   => The relationship name (does *not* always match foreign_alias),
\&    self_rowobj       => The invocant itself in case of a $result_object\->$relationship call
\&  });
.Ve
.PP
\fIattributes\fR
.IX Subsection "attributes"
.PP
The standard ResultSet attributes may
be used as relationship attributes. In particular, the 'where' attribute is
useful for filtering relationships:
.PP
.Vb 4
\&     _\|_PACKAGE_\|_\->has_many( \*(Aqvalid_users\*(Aq, \*(AqMyApp::Schema::User\*(Aq,
\&        { \*(Aqforeign.user_id\*(Aq => \*(Aqself.user_id\*(Aq },
\&        { where => { valid => 1 } }
\&    );
.Ve
.PP
The following attributes are also valid:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any \s-1SQL\s0
join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in the \s-1SQL\s0
command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.ie n .IP "proxy => $column | \e@columns | \e%column" 4
.el .IP "proxy => \f(CW$column\fR | \e@columns | \e%column" 4
.IX Item "proxy => $column | @columns | %column"
The 'proxy' attribute can be used to retrieve values, and to perform
updates if the relationship has 'cascade_update' set. The 'might_have'
and 'has_one' relationships have this set by default; if you want a proxy
to update across a 'belongs_to' relationship, you must set the attribute
yourself.
.RS 4
.IP "\e@columns" 4
.IX Item "@columns"
An arrayref containing a list of accessors in the foreign class to create in
the main class. If, for example, you do the following:
.Sp
.Vb 4
\&  MyApp::Schema::CD\->might_have(liner_notes => \*(AqMyApp::Schema::LinerNotes\*(Aq,
\&    undef, {
\&      proxy => [ qw/notes/ ],
\&    });
.Ve
.Sp
Then, assuming MyApp::Schema::LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = MyApp::Schema::CD\->find(1);
\&  $cd\->notes(\*(AqNotes go here\*(Aq); # set notes \-\- LinerNotes object is
\&                               # created if it doesn\*(Aqt exist
.Ve
.Sp
For a 'belongs_to relationship, note the 'cascade_update':
.Sp
.Vb 5
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd,
\&      { proxy => [\*(Aqtitle\*(Aq], cascade_update => 1 }
\&  );
\&  $track\->title(\*(AqNew Title\*(Aq);
\&  $track\->update; # updates title in CD
.Ve
.IP "\e%column" 4
.IX Item "%column"
A hashref where each key is the accessor you want installed in the main class,
and its value is the name of the original in the foreign class.
.Sp
.Vb 3
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd\*(Aq, {
\&      proxy => { cd_title => \*(Aqtitle\*(Aq },
\&  });
.Ve
.Sp
This will create an accessor named \f(CW\*(C`cd_title\*(C'\fR on the \f(CW$track\fR result object.
.RE
.RS 4
.Sp
\&\s-1NOTE:\s0 you can pass a nested struct too, for example:
.Sp
.Vb 3
\&  MyApp::Schema::Track\->belongs_to( cd => \*(AqDBICTest::Schema::CD\*(Aq, \*(Aqcd\*(Aq, {
\&    proxy => [ \*(Aqyear\*(Aq, { cd_title => \*(Aqtitle\*(Aq } ],
\&  });
.Ve
.RE
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the relationship.
Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single related object),
\&\f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for when there is a single
related object, but you also want the relationship accessor to double as
a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an add_to_* method is also
created, which calls \f(CW\*(C`create_related\*(C'\fR for the relationship.
.IP "is_foreign_key_constraint" 4
.IX Item "is_foreign_key_constraint"
If you are using SQL::Translator to create \s-1SQL\s0 for you and you find that it
is creating constraints where it shouldn't, or not creating them where it
should, set this attribute to a true or false value to override the detection
of when to create constraints.
.IP "cascade_copy" 4
.IX Item "cascade_copy"
If \f(CW\*(C`cascade_copy\*(C'\fR is true on a \f(CW\*(C`has_many\*(C'\fR relationship for an
object, then when you copy the object all the related objects will
be copied too. To turn this behaviour off, pass \f(CW\*(C`cascade_copy => 0\*(C'\fR
in the \f(CW$attr\fR hashref.
.Sp
The behaviour defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR for \f(CW\*(C`has_many\*(C'\fR
relationships.
.IP "cascade_delete" 4
.IX Item "cascade_delete"
By default, DBIx::Class cascades deletes across \f(CW\*(C`has_many\*(C'\fR,
\&\f(CW\*(C`has_one\*(C'\fR and \f(CW\*(C`might_have\*(C'\fR relationships. You can disable this
behaviour on a per-relationship basis by supplying
\&\f(CW\*(C`cascade_delete => 0\*(C'\fR in the relationship attributes.
.Sp
The cascaded operations are performed after the requested delete,
so if your database has a constraint on the relationship, it will
have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.IP "cascade_update" 4
.IX Item "cascade_update"
By default, DBIx::Class cascades updates across \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR relationships. You can disable this behaviour on a
per-relationship basis by supplying \f(CW\*(C`cascade_update => 0\*(C'\fR in
the relationship attributes.
.Sp
The \f(CW\*(C`belongs_to\*(C'\fR relationship does not update across relationships
by default, so if you have a 'proxy' attribute on a belongs_to and want to
use 'update' on it, you muse set \f(CW\*(C`cascade_update => 1\*(C'\fR.
.Sp
This is not a \s-1RDMS\s0 style cascade update \- it purely means that when
an object has update called on it, all the related objects also
have update called. It will not change foreign keys automatically \-
you must arrange to do this yourself.
.IP "on_delete / on_update" 4
.IX Item "on_delete / on_update"
If you are using SQL::Translator to create \s-1SQL\s0 for you, you can use these
attributes to explicitly set the desired \f(CW\*(C`ON DELETE\*(C'\fR or \f(CW\*(C`ON UPDATE\*(C'\fR constraint
type. If not supplied the \s-1SQLT\s0 parser will attempt to infer the constraint type by
interrogating the attributes of the \fBopposite\fR relationship. For any 'multi'
relationship with \f(CW\*(C`cascade_delete => 1\*(C'\fR, the corresponding belongs_to
relationship will be created with an \f(CW\*(C`ON DELETE CASCADE\*(C'\fR constraint. For any
relationship bearing \f(CW\*(C`cascade_copy => 1\*(C'\fR the resulting belongs_to constraint
will be \f(CW\*(C`ON UPDATE CASCADE\*(C'\fR. If you wish to disable this autodetection, and just
use the \s-1RDBMS\s0' default constraint type, pass \f(CW\*(C`on_delete => undef\*(C'\fR or
\&\f(CW\*(C`on_delete => \*(Aq\*(Aq\*(C'\fR, and the same for \f(CW\*(C`on_update\*(C'\fR respectively.
.IP "is_deferrable" 4
.IX Item "is_deferrable"
Tells SQL::Translator that the foreign key constraint it creates should be
deferrable. In other words, the user may request that the constraint be ignored
until the end of the transaction. Currently, only the PostgreSQL producer
actually supports this.
.IP "add_fk_index" 4
.IX Item "add_fk_index"
Tells SQL::Translator to add an index for this constraint. Can also be
specified globally in the args to \*(L"deploy\*(R" in DBIx::Class::Schema or
\&\*(L"create_ddl_dir\*(R" in DBIx::Class::Schema. Default is on, set to 0 to disable.
.SS "register_relationship"
.IX Subsection "register_relationship"
.ie n .IP "Arguments: $rel_name, $rel_info" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$rel_info\fR" 4
.IX Item "Arguments: $rel_name, $rel_info"
.PP
Registers a relationship on the class. This is called internally by
DBIx::Class::ResultSourceProxy to set up Accessors and Proxies.
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $related_resultset" 4
.el .IP "Return Value: \f(CW$related_resultset\fR" 4
.IX Item "Return Value: $related_resultset"
.PD
.PP
.Vb 1
\&  $rs = $cd\->related_resultset(\*(Aqartist\*(Aq);
.Ve
.PP
Returns a DBIx::Class::ResultSet for the relationship named
\&\f(CW$rel_name\fR.
.ie n .SS "$relationship_accessor"
.el .SS "\f(CW$relationship_accessor\fP"
.IX Subsection "$relationship_accessor"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | $related_resultset | undef" 4
.el .IP "Return Value: \f(CW$result\fR | \f(CW$related_resultset\fR | undef" 4
.IX Item "Return Value: $result | $related_resultset | undef"
.PD
.PP
.Vb 5
\&  # These pairs do the same thing
\&  $result = $cd\->related_resultset(\*(Aqartist\*(Aq)\->single;  # has_one relationship
\&  $result = $cd\->artist;
\&  $rs = $cd\->related_resultset(\*(Aqtracks\*(Aq);           # has_many relationship
\&  $rs = $cd\->tracks;
.Ve
.PP
This is the recommended way to traverse through relationships, based
on the \*(L"accessor\*(R" name given in the relationship definition.
.PP
This will return either a Result or a
ResultSet, depending on if the relationship is
\&\f(CW\*(C`single\*(C'\fR (returns only one row) or \f(CW\*(C`multi\*(C'\fR (returns many rows).  The
method may also return \f(CW\*(C`undef\*(C'\fR if the relationship doesn't exist for
this instance (like in the case of \f(CW\*(C`might_have\*(C'\fR relationships).
.SS "search_related"
.IX Subsection "search_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
Run a search on a related resultset. The search will be restricted to the
results represented by the DBIx::Class::ResultSet it was called
upon.
.PP
See \*(L"search_related\*(R" in DBIx::Class::ResultSet for more information.
.SS "search_related_rs"
.IX Subsection "search_related_rs"
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "count_related"
.IX Subsection "count_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Returns the count of all the rows in the related resultset, restricted by the
current result or where conditions.
.SS "new_related"
.IX Subsection "new_related"
.ie n .IP "Arguments: $rel_name, \e%col_data" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data" 4
.IX Item "Arguments: $rel_name, %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Create a new result object of the related foreign class.  It will magically set
any foreign key columns of the new object to the related primary key columns
of the source object for you.  The newly created result will not be saved into
your storage until you call \*(L"insert\*(R" in DBIx::Class::Row on it.
.SS "create_related"
.IX Subsection "create_related"
.ie n .IP "Arguments: $rel_name, \e%col_data" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data" 4
.IX Item "Arguments: $rel_name, %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 1
\&  my $result = $obj\->create_related($rel_name, \e%col_data);
.Ve
.PP
Creates a new result object, similarly to new_related, and also inserts the
result's data into your storage medium. See the distinction between \f(CW\*(C`create\*(C'\fR
and \f(CW\*(C`new\*(C'\fR in DBIx::Class::ResultSet for details.
.SS "find_related"
.IX Subsection "find_related"
.ie n .IP "Arguments: $rel_name, \e%col_data | @pk_values, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data | \f(CW@pk_values\fR, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data | @pk_values, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
.Vb 1
\&  my $result = $obj\->find_related($rel_name, \e%col_data);
.Ve
.PP
Attempt to find a related object using its primary key or unique constraints.
See \*(L"find\*(R" in DBIx::Class::ResultSet for details.
.SS "find_or_new_related"
.IX Subsection "find_or_new_related"
.ie n .IP "Arguments: $rel_name, \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Find a result object of a related class.  See \*(L"find_or_new\*(R" in DBIx::Class::ResultSet
for details.
.SS "find_or_create_related"
.IX Subsection "find_or_create_related"
.ie n .IP "Arguments: $rel_name, \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Find or create a result object of a related class. See
\&\*(L"find_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "update_or_create_related"
.IX Subsection "update_or_create_related"
.ie n .IP "Arguments: $rel_name, \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: $rel_name, %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Update or create a result object of a related class. See
\&\*(L"update_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "set_from_related"
.IX Subsection "set_from_related"
.ie n .IP "Arguments: $rel_name, $result" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$result\fR" 4
.IX Item "Arguments: $rel_name, $result"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 2
\&  $book\->set_from_related(\*(Aqauthor\*(Aq, $author_obj);
\&  $book\->author($author_obj);                      ## same thing
.Ve
.PP
Set column values on the current object, using related values from the given
related object. This is used to associate previously separate objects, for
example, to set the correct author for a book, find the Author object, then
call set_from_related on the book.
.PP
This is called internally when you pass existing objects as values to
\&\*(L"create\*(R" in DBIx::Class::ResultSet, or pass an object to a belongs_to accessor.
.PP
The columns are only set in the local copy of the object, call \*(L"update\*(R" to
set them in the storage.
.SS "update_from_related"
.IX Subsection "update_from_related"
.ie n .IP "Arguments: $rel_name, $result" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$result\fR" 4
.IX Item "Arguments: $rel_name, $result"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 1
\&  $book\->update_from_related(\*(Aqauthor\*(Aq, $author_obj);
.Ve
.PP
The same as \*(L"set_from_related\*(R", but the changes are immediately updated
in storage.
.SS "delete_related"
.IX Subsection "delete_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $underlying_storage_rv" 4
.el .IP "Return Value: \f(CW$underlying_storage_rv\fR" 4
.IX Item "Return Value: $underlying_storage_rv"
.PD
.PP
Delete any related row, subject to the given conditions.  Internally, this
calls:
.PP
.Vb 1
\&  $self\->search_related(@_)\->delete
.Ve
.PP
And returns the result of that.
.SS "add_to_$rel"
.IX Subsection "add_to_$rel"
\&\fBCurrently only available for \f(CB\*(C`has_many\*(C'\fB, \f(CB\*(C`many_to_many\*(C'\fB and 'multi' type
relationships.\fR
.PP
\fIhas_many / multi\fR
.IX Subsection "has_many / multi"
.IP "Arguments: \e%col_data" 4
.IX Item "Arguments: %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Creates/inserts a new result object.  Internally, this calls:
.PP
.Vb 1
\&  $self\->create_related($rel, @_)
.Ve
.PP
And returns the result of that.
.PP
\fImany_to_many\fR
.IX Subsection "many_to_many"
.ie n .IP "Arguments: (\e%col_data | $result), \e%link_col_data?" 4
.el .IP "Arguments: (\e%col_data | \f(CW$result\fR), \e%link_col_data?" 4
.IX Item "Arguments: (%col_data | $result), %link_col_data?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->add_to_roles($role);
\&      # creates a My::DBIC::Schema::ActorRoles linking table result object
\&
\&  $actor\->add_to_roles({ name => \*(Aqlead\*(Aq }, { salary => 15_000_000 });
\&      # creates a new My::DBIC::Schema::Role result object and the linking table
\&      # object with an extra column in the link
.Ve
.PP
Adds a linking table object. If the first argument is a hash reference, the
related object is created first with the column values in the hash. If an object
reference is given, just the linking table object is created. In either case,
any additional column values for the linking table object can be specified in
\&\f(CW\*(C`\e%link_col_data\*(C'\fR.
.PP
See \*(L"many_to_many\*(R" in DBIx::Class::Relationship for additional details.
.SS "set_$rel"
.IX Subsection "set_$rel"
\&\fBCurrently only available for \f(CB\*(C`many_to_many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: (\e@hashrefs_of_col_data | \e@result_objs), $link_vals?" 4
.el .IP "Arguments: (\e@hashrefs_of_col_data | \e@result_objs), \f(CW$link_vals\fR?" 4
.IX Item "Arguments: (@hashrefs_of_col_data | @result_objs), $link_vals?"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 3
\&  my $actor = $schema\->resultset(\*(AqActor\*(Aq)\->find(1);
\&  my @roles = $schema\->resultset(\*(AqRole\*(Aq)\->search({ role =>
\&     { \*(Aq\-in\*(Aq => [\*(AqFred\*(Aq, \*(AqBarney\*(Aq] } } );
\&
\&  $actor\->set_roles(\e@roles);
\&     # Replaces all of $actor\*(Aqs previous roles with the two named
\&
\&  $actor\->set_roles(\e@roles, { salary => 15_000_000 });
\&     # Sets a column in the link table for all roles
.Ve
.PP
Replace all the related objects with the given reference to a list of
objects. This does a \f(CW\*(C`delete\*(C'\fR \fBon the link table resultset\fR to remove the
association between the current object and all related objects, then calls
\&\f(CW\*(C`add_to_$rel\*(C'\fR repeatedly to link all the new objects.
.PP
Note that this means that this method will \fBnot\fR delete any objects in the
table on the right side of the relation, merely that it will delete the link
between them.
.PP
Due to a mistake in the original implementation of this method, it will also
accept a list of objects or hash references. This is \fBdeprecated\fR and will be
removed in a future version.
.SS "remove_from_$rel"
.IX Subsection "remove_from_$rel"
\&\fBCurrently only available for \f(CB\*(C`many_to_many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: $result" 4
.el .IP "Arguments: \f(CW$result\fR" 4
.IX Item "Arguments: $result"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->remove_from_roles($role);
\&      # removes $role\*(Aqs My::DBIC::Schema::ActorRoles linking table result object
.Ve
.PP
Removes the link between the current object and the related object. Note that
the related object itself won't be deleted unless you call \->\fIdelete()\fR on
it. This method just removes the link between the two objects.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultClass::HashRefInflator.3pm0100644 0001750 0001750 00000014560 12566242400 030735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultClass::HashRefInflator 3"
.TH DBIx::Class::ResultClass::HashRefInflator 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultClass::HashRefInflator \- Get raw hashrefs from a resultset
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use DBIx::Class::ResultClass::HashRefInflator;
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq);
\& $rs\->result_class(\*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq);
\& while (my $hashref = $rs\->next) {
\&   ...
\& }
\&
\&  OR as an attribute:
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({}, {
\&   result_class => \*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq,
\& });
\& while (my $hashref = $rs\->next) {
\&   ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Class is faster than older ORMs like Class::DBI but it still isn't
designed primarily for speed. Sometimes you need to quickly retrieve the data
from a massive resultset, while skipping the creation of fancy result objects.
Specifying this class as a \f(CW\*(C`result_class\*(C'\fR for a resultset will change \f(CW\*(C`$rs\->next\*(C'\fR
to return a plain data hash-ref (or a list of such hash-refs if \f(CW\*(C`$rs\->all\*(C'\fR is used).
.PP
There are two ways of applying this class to a resultset:
.IP "\(bu" 4
Specify \f(CW\*(C`$rs\->result_class\*(C'\fR on a specific resultset to affect only that
resultset (and any chained off of it); or
.IP "\(bu" 4
Specify \f(CW\*(C`_\|_PACKAGE_\|_\->result_class\*(C'\fR on your source object to force all
uses of that result source to be inflated to hash-refs \- this approach is not
recommended.
.SH "METHODS"
.IX Header "METHODS"
.SS "inflate_result"
.IX Subsection "inflate_result"
Inflates the result and prefetched data into a hash-ref (invoked by DBIx::Class::ResultSet)
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
This will not work for relationships that have been prefetched. Consider the
following:
.Sp
.Vb 1
\& my $artist = $artitsts_rs\->search({}, {prefetch => \*(Aqcds\*(Aq })\->first;
\&
\& my $cds = $artist\->cds;
\& $cds\->result_class(\*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq);
\& my $first = $cds\->first;
.Ve
.Sp
\&\f(CW$first\fR will \fBnot\fR be a hashref, it will be a normal \s-1CD\s0 row since
HashRefInflator only affects resultsets at inflation time, and prefetch causes
relations to be inflated when the master \f(CW$artist\fR row is inflated.
.IP "\(bu" 4
Column value inflation, e.g., using modules like
DBIx::Class::InflateColumn::DateTime, is not performed.
The returned hash contains the raw database values.
                                                                                                                                                DBIx::Class::ResultClass::HashRefInflator5.16.3pm                                                   0100644 0001750 0001750 00000014234 12566242363 031176  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultClass::HashRefInflator 3"
.TH DBIx::Class::ResultClass::HashRefInflator 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultClass::HashRefInflator \- Get raw hashrefs from a resultset
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use DBIx::Class::ResultClass::HashRefInflator;
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq);
\& $rs\->result_class(\*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq);
\& while (my $hashref = $rs\->next) {
\&   ...
\& }
\&
\&  OR as an attribute:
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({}, {
\&   result_class => \*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq,
\& });
\& while (my $hashref = $rs\->next) {
\&   ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Class is faster than older ORMs like Class::DBI but it still isn't
designed primarily for speed. Sometimes you need to quickly retrieve the data
from a massive resultset, while skipping the creation of fancy row objects.
Specifying this class as a \f(CW\*(C`result_class\*(C'\fR for a resultset will change \f(CW\*(C`$rs\->next\*(C'\fR
to return a plain data hash-ref (or a list of such hash-refs if \f(CW\*(C`$rs\->all\*(C'\fR is used).
.PP
There are two ways of applying this class to a resultset:
.IP "\(bu" 4
Specify \f(CW\*(C`$rs\->result_class\*(C'\fR on a specific resultset to affect only that
resultset (and any chained off of it); or
.IP "\(bu" 4
Specify \f(CW\*(C`_\|_PACKAGE_\|_\->result_class\*(C'\fR on your source object to force all
uses of that result source to be inflated to hash-refs \- this approach is not
recommended.
.SH "METHODS"
.IX Header "METHODS"
.SS "inflate_result"
.IX Subsection "inflate_result"
Inflates the result and prefetched data into a hash-ref (invoked by DBIx::Class::ResultSet)
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
This will not work for relationships that have been prefetched. Consider the
following:
.Sp
.Vb 1
\& my $artist = $artitsts_rs\->search({}, {prefetch => \*(Aqcds\*(Aq })\->first;
\&
\& my $cds = $artist\->cds;
\& $cds\->result_class(\*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq);
\& my $first = $cds\->first;
.Ve
.Sp
\&\f(CW$first\fR will \fBnot\fR be a hashref, it will be a normal \s-1CD\s0 row since
HashRefInflator only affects resultsets at inflation time, and prefetch causes
relations to be inflated when the master \f(CW$artist\fR row is inflated.
.IP "\(bu" 4
Column value inflation, e.g., using modules like
DBIx::Class::InflateColumn::DateTime, is not performed.
The returned hash contains the raw database values.
                                                                                                                                                                                                                                                                                                                                                                    DBIx::Class::ResultClass::HashRefInflator5.18.3pm                                                   0100644 0001750 0001750 00000014560 12566242400 031172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultClass::HashRefInflator 3"
.TH DBIx::Class::ResultClass::HashRefInflator 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultClass::HashRefInflator \- Get raw hashrefs from a resultset
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use DBIx::Class::ResultClass::HashRefInflator;
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq);
\& $rs\->result_class(\*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq);
\& while (my $hashref = $rs\->next) {
\&   ...
\& }
\&
\&  OR as an attribute:
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({}, {
\&   result_class => \*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq,
\& });
\& while (my $hashref = $rs\->next) {
\&   ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Class is faster than older ORMs like Class::DBI but it still isn't
designed primarily for speed. Sometimes you need to quickly retrieve the data
from a massive resultset, while skipping the creation of fancy result objects.
Specifying this class as a \f(CW\*(C`result_class\*(C'\fR for a resultset will change \f(CW\*(C`$rs\->next\*(C'\fR
to return a plain data hash-ref (or a list of such hash-refs if \f(CW\*(C`$rs\->all\*(C'\fR is used).
.PP
There are two ways of applying this class to a resultset:
.IP "\(bu" 4
Specify \f(CW\*(C`$rs\->result_class\*(C'\fR on a specific resultset to affect only that
resultset (and any chained off of it); or
.IP "\(bu" 4
Specify \f(CW\*(C`_\|_PACKAGE_\|_\->result_class\*(C'\fR on your source object to force all
uses of that result source to be inflated to hash-refs \- this approach is not
recommended.
.SH "METHODS"
.IX Header "METHODS"
.SS "inflate_result"
.IX Subsection "inflate_result"
Inflates the result and prefetched data into a hash-ref (invoked by DBIx::Class::ResultSet)
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
This will not work for relationships that have been prefetched. Consider the
following:
.Sp
.Vb 1
\& my $artist = $artitsts_rs\->search({}, {prefetch => \*(Aqcds\*(Aq })\->first;
\&
\& my $cds = $artist\->cds;
\& $cds\->result_class(\*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq);
\& my $first = $cds\->first;
.Ve
.Sp
\&\f(CW$first\fR will \fBnot\fR be a hashref, it will be a normal \s-1CD\s0 row since
HashRefInflator only affects resultsets at inflation time, and prefetch causes
relations to be inflated when the master \f(CW$artist\fR row is inflated.
.IP "\(bu" 4
Column value inflation, e.g., using modules like
DBIx::Class::InflateColumn::DateTime, is not performed.
The returned hash contains the raw database values.
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSet.3pm                   0100644 0001750 0001750 00000236754 12566242400 025312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSet 3"
.TH DBIx::Class::ResultSet 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSet \- Represents a query used for fetching a set of results.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  my $users_rs = $schema\->resultset(\*(AqUser\*(Aq);
\&  while( $user = $users_rs\->next) {
\&    print $user\->username;
\&  }
\&
\&  my $registered_users_rs = $schema\->resultset(\*(AqUser\*(Aq)\->search({ registered => 1 });
\&  my @cds_in_2005 = $schema\->resultset(\*(AqCD\*(Aq)\->search({ year => 2005 })\->all();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSet is an object which stores a set of conditions representing
a query. It is the backbone of DBIx::Class (i.e. the really
important/useful bit).
.PP
No \s-1SQL\s0 is executed on the database when a ResultSet is created, it
just stores all the conditions needed to create the query.
.PP
A basic ResultSet representing the data of an entire table is returned
by calling \f(CW\*(C`resultset\*(C'\fR on a DBIx::Class::Schema and passing in a
Source name.
.PP
.Vb 1
\&  my $users_rs = $schema\->resultset(\*(AqUser\*(Aq);
.Ve
.PP
A new ResultSet is returned from calling \*(L"search\*(R" on an existing
ResultSet. The new one will contain all the conditions of the
original, plus any new conditions added in the \f(CW\*(C`search\*(C'\fR call.
.PP
A ResultSet also incorporates an implicit iterator. \*(L"next\*(R" and \*(L"reset\*(R"
can be used to walk through all the DBIx::Class::Rows the ResultSet
represents.
.PP
The query that the ResultSet represents is \fBonly\fR executed against
the database when these methods are called:
\&\*(L"find\*(R", \*(L"next\*(R", \*(L"all\*(R", \*(L"first\*(R", \*(L"single\*(R", \*(L"count\*(R".
.PP
If a resultset is used in a numeric context it returns the \*(L"count\*(R".
However, if it is used in a boolean context it is \fBalways\fR true.  So if
you want to check if a resultset has any results, you must use \f(CW\*(C`if $rs
!= 0\*(C'\fR.
.SH "CUSTOM ResultSet CLASSES THAT USE Moose"
.IX Header "CUSTOM ResultSet CLASSES THAT USE Moose"
If you want to make your custom ResultSet classes with Moose, use a template
similar to:
.PP
.Vb 1
\&    package MyApp::Schema::ResultSet::User;
\&
\&    use Moose;
\&    use namespace::autoclean;
\&    use MooseX::NonMoose;
\&    extends \*(AqDBIx::Class::ResultSet\*(Aq;
\&
\&    sub BUILDARGS { $_[2] }
\&
\&    ...your code...
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
\&
\&    1;
.Ve
.PP
The MooseX::NonMoose is necessary so that the Moose constructor does not
clash with the regular ResultSet constructor. Alternatively, you can use:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->meta\->make_immutable(inline_constructor => 0);
.Ve
.PP
The \s-1BUILDARGS\s0 is necessary because the
signature of the ResultSet \f(CW\*(C`new\*(C'\fR is \f(CW\*(C`\->new($source, \e%args)\*(C'\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Chaining resultsets"
.IX Subsection "Chaining resultsets"
Let's say you've got a query that needs to be run to return some data
to the user. But, you have an authorization system in place that
prevents certain users from seeing certain information. So, you want
to construct the basic query in one method, but add constraints to it in
another.
.PP
.Vb 4
\&  sub get_data {
\&    my $self = shift;
\&    my $request = $self\->get_request; # Get a request object somehow.
\&    my $schema = $self\->result_source\->schema;
\&
\&    my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&      title => $request\->param(\*(Aqtitle\*(Aq),
\&      year => $request\->param(\*(Aqyear\*(Aq),
\&    });
\&
\&    $cd_rs = $self\->apply_security_policy( $cd_rs );
\&
\&    return $cd_rs\->all();
\&  }
\&
\&  sub apply_security_policy {
\&    my $self = shift;
\&    my ($rs) = @_;
\&
\&    return $rs\->search({
\&      subversive => 0,
\&    });
\&  }
.Ve
.PP
\fIResolving conditions and attributes\fR
.IX Subsection "Resolving conditions and attributes"
.PP
When a resultset is chained from another resultset (e.g.:
\&\f(CW\*(C`my $new_rs = $old_rs\->search(\e%extra_cond, \e%attrs)\*(C'\fR), conditions
and attributes with the same keys need resolving.
.PP
If any of \*(L"columns\*(R", \*(L"select\*(R", \*(L"as\*(R" are present, they reset the
original selection, and start the selection \*(L"clean\*(R".
.PP
The \*(L"join\*(R", \*(L"prefetch\*(R", \*(L"+columns\*(R", \*(L"+select\*(R", \*(L"+as\*(R" attributes
are merged into the existing ones from the original resultset.
.PP
The \*(L"where\*(R" and \*(L"having\*(R" attributes, and any search conditions, are
merged with an \s-1SQL \s0\f(CW\*(C`AND\*(C'\fR to the existing condition from the original
resultset.
.PP
All other attributes are overridden by any new ones supplied in the
search attributes.
.SS "Multiple queries"
.IX Subsection "Multiple queries"
Since a resultset just defines a query, you can do all sorts of
things with it with the same object.
.PP
.Vb 5
\&  # Don\*(Aqt hit the DB yet.
\&  my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&  });
\&
\&  # Each of these hits the DB individually.
\&  my $count = $cd_rs\->count;
\&  my $most_recent = $cd_rs\->get_column(\*(Aqdate_released\*(Aq)\->max();
\&  my @records = $cd_rs\->all;
.Ve
.PP
And it's not just limited to \s-1SELECT\s0 statements.
.PP
.Vb 1
\&  $cd_rs\->delete();
.Ve
.PP
This is even cooler:
.PP
.Vb 1
\&  $cd_rs\->create({ artist => \*(AqFred\*(Aq });
.Ve
.PP
Which is the same as:
.PP
.Vb 5
\&  $schema\->resultset(\*(AqCD\*(Aq)\->create({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&    artist => \*(AqFred\*(Aq
\&  });
.Ve
.PP
See: \*(L"search\*(R", \*(L"count\*(R", \*(L"get_column\*(R", \*(L"all\*(R", \*(L"create\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.ie n .IP "Arguments: $source, \e%attrs?" 4
.el .IP "Arguments: \f(CW$source\fR, \e%attrs?" 4
.IX Item "Arguments: $source, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
The resultset constructor. Takes a source object (usually a
DBIx::Class::ResultSourceProxy::Table) and an attribute hash (see
\&\*(L"\s-1ATTRIBUTES\*(R"\s0 below).  Does not perform any queries \*(-- these are
executed as needed by the other methods.
.PP
Generally you never construct a resultset manually. Instead you get one
from e.g. a
\&\f(CW\*(C`$schema\->resultset(\*(Aq$source_name\*(Aq)\*(C'\fR
or \f(CW\*(C`$another_resultset\->search(...)\*(C'\fR (the later called in
scalar context):
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ title => \*(Aq100th Window\*(Aq });
.Ve
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
If called on an object, proxies to \*(L"new_result\*(R" instead, so
.Sp
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->new({ title => \*(AqSpoon\*(Aq });
.Ve
.Sp
will return a \s-1CD\s0 object, not a ResultSet, and is equivalent to:
.Sp
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->new_result({ title => \*(AqSpoon\*(Aq });
.Ve
.Sp
Please also keep in mind that many internals call \*(L"new_result\*(R" directly,
so overloading this method with the idea of intercepting new result object
creation \fBwill not work\fR. See also warning pertaining to \*(L"create\*(R".
.SS "search"
.IX Subsection "search"
.ie n .IP "Arguments: $cond | undef, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR | undef, \e%attrs?" 4
.IX Item "Arguments: $cond | undef, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds    = $cd_rs\->search({ year => 2001 }); # "... WHERE year = 2001"
\&  my $new_rs = $cd_rs\->search({ year => 2005 });
\&
\&  my $new_rs = $cd_rs\->search([ { year => 2005 }, { year => 2004 } ]);
\&                 # year = 2005 OR year = 2004
.Ve
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of result objects instead.
To avoid that, use \*(L"search_rs\*(R".
.PP
If you need to pass in additional attributes but no additional condition,
call it as \f(CW\*(C`search(undef, \e%attrs)\*(C'\fR.
.PP
.Vb 4
\&  # "SELECT name, artistid FROM $artist_table"
\&  my @all_artists = $schema\->resultset(\*(AqArtist\*(Aq)\->search(undef, {
\&    columns => [qw/name artistid/],
\&  });
.Ve
.PP
For a list of attributes that can be passed to \f(CW\*(C`search\*(C'\fR, see
\&\*(L"\s-1ATTRIBUTES\*(R"\s0. For more examples of using this function, see
Searching. For a complete
documentation for the first argument, see \*(L"\s-1WHERE CLAUSES\*(R"\s0 in SQL::Abstract
and its extension DBIx::Class::SQLMaker.
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"search\*(R" does not process/deflate any of the values passed in the
SQL::Abstract\-compatible search condition structure. This is unlike other
condition-bound methods \*(L"new_result\*(R", \*(L"create\*(R" and \*(L"find\*(R". The user must ensure
manually that any value passed to this method will stringify to something the
\&\s-1RDBMS\s0 knows how to deal with. A notable example is the handling of DateTime
objects, for more info see:
\&\*(L"Formatting DateTime objects in queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "search_rs"
.IX Subsection "search_rs"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
This method does the same exact thing as \fIsearch()\fR except it will
always return a resultset, even in list context.
.SS "search_literal"
.IX Subsection "search_literal"
\&\fB\s-1CAVEAT\s0\fR: \f(CW\*(C`search_literal\*(C'\fR is provided for Class::DBI compatibility and
should only be used in that context. \f(CW\*(C`search_literal\*(C'\fR is a convenience
method. It is equivalent to calling \f(CW\*(C`$schema\->search(\e[])\*(C'\fR, but if you
want to ensure columns are bound correctly, use \*(L"search\*(R".
.PP
See \*(L"\s-1SEARCHING\*(R"\s0 in DBIx::Class::Manual::Cookbook and
\&\*(L"Searching\*(R" in DBIx::Class::Manual::FAQ for searching techniques that do not
require \f(CW\*(C`search_literal\*(C'\fR.
.ie n .IP "Arguments: $sql_fragment, @standalone_bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@standalone_bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @standalone_bind_values"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds   = $cd_rs\->search_literal(\*(Aqyear = ? AND title = ?\*(Aq, qw/2001 Reload/);
\&  my $newrs = $artist_rs\->search_literal(\*(Aqname = ?\*(Aq, \*(AqMetallica\*(Aq);
.Ve
.PP
Pass a literal chunk of \s-1SQL\s0 to be added to the conditional part of the
resultset query.
.PP
Example of how to use \f(CW\*(C`search\*(C'\fR instead of \f(CW\*(C`search_literal\*(C'\fR
.PP
.Vb 2
\&  my @cds = $cd_rs\->search_literal(\*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, (2, 1, 2));
\&  my @cds = $cd_rs\->search(\e[ \*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, [ \*(Aqcdid\*(Aq, 2 ], [ \*(Aqartist\*(Aq, 1 ], [ \*(Aqartist\*(Aq, 2 ] ]);
.Ve
.SS "find"
.IX Subsection "find"
.ie n .IP "Arguments: \e%columns_values | @pk_values, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%columns_values | \f(CW@pk_values\fR, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %columns_values | @pk_values, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Finds and returns a single row based on supplied criteria. Takes either a
hashref with the same format as \*(L"create\*(R" (including inference of foreign
keys from related objects), or a list of primary key values in the same
order as the primary columns
declaration on the \*(L"result_source\*(R".
.PP
In either case an attempt is made to combine conditions already existing on
the resultset with the condition passed to this method.
.PP
To aid with preparing the correct query for the storage you may supply the
\&\f(CW\*(C`key\*(C'\fR attribute, which is the name of a
unique constraint (the
unique constraint corresponding to the
primary columns is always named
\&\f(CW\*(C`primary\*(C'\fR). If the \f(CW\*(C`key\*(C'\fR attribute has been supplied, and \s-1DBIC\s0 is unable
to construct a query that satisfies the named unique constraint fully (
non-NULL values for each column member of the constraint) an exception is
thrown.
.PP
If no \f(CW\*(C`key\*(C'\fR is specified, the search is carried over all unique constraints
which are fully defined by the available condition.
.PP
If no such constraint is found, \f(CW\*(C`find\*(C'\fR currently defaults to a simple
\&\f(CW\*(C`search\->(\e%column_values)\*(C'\fR which may or may not do what you expect.
Note that this fallback behavior may be deprecated in further versions. If
you need to search with arbitrary conditions \- use \*(L"search\*(R". If the query
resulting from this fallback produces more than one row, a warning to the
effect is issued, though only the first row is constructed and returned as
\&\f(CW$result_object\fR.
.PP
In addition to \f(CW\*(C`key\*(C'\fR, \*(L"find\*(R" recognizes and applies standard
resultset attributes in the same way as \*(L"search\*(R" does.
.PP
Note that if you have extra concerns about the correctness of the resulting
query you need to specify the \f(CW\*(C`key\*(C'\fR attribute and supply the entire condition
as an argument to find (since it is not always possible to perform the
combination of the resultset condition with the supplied one, especially if
the resultset condition contains literal sql).
.PP
For example, to find a row by its primary key:
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(5);
.Ve
.PP
You can also find a row by a specific unique constraint:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
See also \*(L"find_or_create\*(R" and \*(L"update_or_create\*(R".
.SS "search_related"
.IX Subsection "search_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 3
\&  $new_rs = $cd_rs\->search_related(\*(Aqartist\*(Aq, {
\&    name => \*(AqEmo\-R\-Us\*(Aq,
\&  });
.Ve
.PP
Searches the specified relationship, optionally specifying a condition and
attributes for matching records. See \*(L"\s-1ATTRIBUTES\*(R"\s0 for more information.
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of result objects instead. To avoid that, use \*(L"search_related_rs\*(R".
.PP
See also \*(L"search_related_rs\*(R".
.SS "search_related_rs"
.IX Subsection "search_related_rs"
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "cursor"
.IX Subsection "cursor"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $cursor" 4
.el .IP "Return Value: \f(CW$cursor\fR" 4
.IX Item "Return Value: $cursor"
.PD
.PP
Returns a storage-driven cursor to the given resultset. See
DBIx::Class::Cursor for more information.
.SS "single"
.IX Subsection "single"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->single({ year => 2001 });
.Ve
.PP
Inflates the first result without creating a cursor if the resultset has
any records in it; if not returns \f(CW\*(C`undef\*(C'\fR. Used by \*(L"find\*(R" as a lean version
of \*(L"search\*(R".
.PP
While this method can take an optional search condition (just like \*(L"search\*(R")
being a fast-code-path it does not recognize search attributes. If you need to
add extra joins or similar, call \*(L"search\*(R" and then chain-call \*(L"single\*(R" on the
DBIx::Class::ResultSet returned.
.IP "\fBNote\fR" 4
.IX Item "Note"
As of 0.08100, this method enforces the assumption that the preceding
query returns only one row. If more than one row is returned, you will receive
a warning:
.Sp
.Vb 1
\&  Query returned more than one row
.Ve
.Sp
In this case, you should be using \*(L"next\*(R" or \*(L"find\*(R" instead, or if you really
know what you are doing, use the \*(L"rows\*(R" attribute to explicitly limit the size
of the resultset.
.Sp
This method will also throw an exception if it is called on a resultset prefetching
has_many, as such a prefetch implies fetching multiple rows from the database in
order to assemble the resulting object.
.SS "get_column"
.IX Subsection "get_column"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $resultsetcolumn" 4
.el .IP "Return Value: \f(CW$resultsetcolumn\fR" 4
.IX Item "Return Value: $resultsetcolumn"
.PD
.PP
.Vb 1
\&  my $max_length = $rs\->get_column(\*(Aqlength\*(Aq)\->max;
.Ve
.PP
Returns a DBIx::Class::ResultSetColumn instance for a column of the ResultSet.
.SS "search_like"
.IX Subsection "search_like"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 2
\&  # WHERE title LIKE \*(Aq%blue%\*(Aq
\&  $cd_rs = $rs\->search_like({ title => \*(Aq%blue%\*(Aq});
.Ve
.PP
Performs a search, but uses \f(CW\*(C`LIKE\*(C'\fR instead of \f(CW\*(C`=\*(C'\fR as the condition. Note
that this is simply a convenience method retained for ex Class::DBI users.
You most likely want to use \*(L"search\*(R" with specific operators.
.PP
For more information, see DBIx::Class::Manual::Cookbook.
.PP
This method is deprecated and will be removed in 0.09. Use \*(L"\fIsearch()\fR\*(R"
instead. An example conversion is:
.PP
.Vb 1
\&  \->search_like({ foo => \*(Aqbar\*(Aq });
\&
\&  # Becomes
\&
\&  \->search({ foo => { like => \*(Aqbar\*(Aq } });
.Ve
.SS "slice"
.IX Subsection "slice"
.ie n .IP "Arguments: $first, $last" 4
.el .IP "Arguments: \f(CW$first\fR, \f(CW$last\fR" 4
.IX Item "Arguments: $first, $last"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
Returns a resultset or object list representing a subset of elements from the
resultset slice is called on. Indexes are from 0, i.e., to get the first
three records, call:
.PP
.Vb 1
\&  my ($one, $two, $three) = $rs\->slice(0, 2);
.Ve
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Returns the next element in the resultset (\f(CW\*(C`undef\*(C'\fR is there is none).
.PP
Can be used to efficiently iterate over records in the resultset:
.PP
.Vb 4
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search;
\&  while (my $cd = $rs\->next) {
\&    print $cd\->title;
\&  }
.Ve
.PP
Note that you need to store the resultset object, and call \f(CW\*(C`next\*(C'\fR on it.
Calling \f(CW\*(C`resultset(\*(AqTable\*(Aq)\->next\*(C'\fR repeatedly will always return the
first record from the resultset.
.SS "result_source"
.IX Subsection "result_source"
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
An accessor for the primary ResultSource object from which this ResultSet
is derived.
.SS "result_class"
.IX Subsection "result_class"
.ie n .IP "Arguments: $result_class?" 4
.el .IP "Arguments: \f(CW$result_class\fR?" 4
.IX Item "Arguments: $result_class?"
.PD 0
.ie n .IP "Return Value: $result_class" 4
.el .IP "Return Value: \f(CW$result_class\fR" 4
.IX Item "Return Value: $result_class"
.PD
.PP
An accessor for the class to use when creating result objects. Defaults to
\&\f(CW\*(C`result_source\->result_class\*(C'\fR \- which in most cases is the name of the
\&\*(L"table\*(R" class.
.PP
Note that changing the result_class will also remove any components
that were originally loaded in the source class via
\&\*(L"load_components\*(R" in DBIx::Class::ResultSource. Any overloaded methods
in the original source class will not run.
.SS "count"
.IX Subsection "count"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Performs an \s-1SQL \s0\f(CW\*(C`COUNT\*(C'\fR with the same query as the resultset was built
with to find the number of elements. Passing arguments is equivalent to
\&\f(CW\*(C`$rs\->search ($cond, \e%attrs)\->count\*(C'\fR
.SS "count_rs"
.IX Subsection "count_rs"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $count_rs" 4
.el .IP "Return Value: \f(CW$count_rs\fR" 4
.IX Item "Return Value: $count_rs"
.PD
.PP
Same as \*(L"count\*(R" but returns a DBIx::Class::ResultSetColumn object.
This can be very handy for subqueries:
.PP
.Vb 1
\&  \->search( { amount => $some_rs\->count_rs\->as_query } )
.Ve
.PP
As with regular resultsets the \s-1SQL\s0 query will be executed only after
the resultset is accessed via \*(L"next\*(R" or \*(L"all\*(R". That would return
the same single value obtainable via \*(L"count\*(R".
.SS "count_literal"
.IX Subsection "count_literal"
\&\fB\s-1CAVEAT\s0\fR: \f(CW\*(C`count_literal\*(C'\fR is provided for Class::DBI compatibility and
should only be used in that context. See \*(L"search_literal\*(R" for further info.
.ie n .IP "Arguments: $sql_fragment, @standalone_bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@standalone_bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @standalone_bind_values"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Counts the results in a literal query. Equivalent to calling \*(L"search_literal\*(R"
with the passed arguments, then \*(L"count\*(R".
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @result_objs" 4
.el .IP "Return Value: \f(CW@result_objs\fR" 4
.IX Item "Return Value: @result_objs"
.PD
.PP
Returns all elements in the resultset.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the resultset's cursor, so you can iterate through the elements again.
Implicitly resets the storage cursor, so a subsequent \*(L"next\*(R" will trigger
another query.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Resets the resultset (causing a fresh query to storage) and returns
an object for the first result (or \f(CW\*(C`undef\*(C'\fR if the resultset is empty).
.SS "update"
.IX Subsection "update"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.ie n .IP "Return Value: $underlying_storage_rv" 4
.el .IP "Return Value: \f(CW$underlying_storage_rv\fR" 4
.IX Item "Return Value: $underlying_storage_rv"
.PD
.PP
Sets the specified columns in the resultset to the supplied values in a
single query. Note that this will not run any accessor/set_column/update
triggers, nor will it update any result object instances derived from this
resultset (this includes the contents of the resultset cache
if any). See \*(L"update_all\*(R" if you need to execute any on-update
triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying
storage backend returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most
common case.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"update\*(R" does not process/deflate any of the values passed in.
This is unlike the corresponding \*(L"update\*(R" in DBIx::Class::Row. The user must
ensure manually that any value passed to this method will stringify to
something the \s-1RDBMS\s0 knows how to deal with. A notable example is the
handling of DateTime objects, for more info see:
\&\*(L"Formatting DateTime objects in queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "update_all"
.IX Subsection "update_all"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and updates them one at a time via
\&\*(L"update\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`update_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"update\*(R" will not.
.SS "delete"
.IX Subsection "delete"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $underlying_storage_rv" 4
.el .IP "Return Value: \f(CW$underlying_storage_rv\fR" 4
.IX Item "Return Value: $underlying_storage_rv"
.PD
.PP
Deletes the rows matching this resultset in a single query. Note that this
will not run any delete triggers, nor will it alter the
in_storage status of any result object instances
derived from this resultset (this includes the contents of the
resultset cache if any). See \*(L"delete_all\*(R" if you need to
execute any on-delete triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying storage backend
returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most common case.
.SS "delete_all"
.IX Subsection "delete_all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and deletes them one at a time via
\&\*(L"delete\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`delete_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"delete\*(R" will not.
.SS "populate"
.IX Subsection "populate"
.IP "Arguments: [ \e@column_list, \e@row_values+ ] | [ \e%col_data+ ]" 4
.IX Item "Arguments: [ @column_list, @row_values+ ] | [ %col_data+ ]"
.PD 0
.ie n .IP "Return Value: \e@result_objects (scalar context) | @result_objects (list context)" 4
.el .IP "Return Value: \e@result_objects (scalar context) | \f(CW@result_objects\fR (list context)" 4
.IX Item "Return Value: @result_objects (scalar context) | @result_objects (list context)"
.PD
.PP
Accepts either an arrayref of hashrefs or alternatively an arrayref of
arrayrefs.
.IP "\s-1NOTE\s0" 4
.IX Item "NOTE"
The context of this method call has an important effect on what is
submitted to storage. In void context data is fed directly to fastpath
insertion routines provided by the underlying storage (most often
\&\*(L"execute_for_fetch\*(R" in \s-1DBI\s0), bypassing the new and
insert calls on the
Result class, including any
augmentation of these methods provided by components. For example if you
are using something like DBIx::Class::UUIDColumns to create primary
keys for you, you will find that your PKs are empty.  In this case you
will have to explicitly force scalar or list context in order to create
those values.
.PP
In non-void (scalar or list) context, this method is simply a wrapper
for \*(L"create\*(R". Depending on list or scalar context either a list of
Result objects or an arrayref
containing these objects is returned.
.PP
When supplying data in \*(L"arrayref of arrayrefs\*(R" invocation style, the
first element should be a list of column names and each subsequent
element should be a data value in the earlier specified column order.
For example:
.PP
.Vb 6
\&  $schema\->resultset("Artist")\->populate([
\&    [ qw( artistid name ) ],
\&    [ 100, \*(AqA Formally Unknown Singer\*(Aq ],
\&    [ 101, \*(AqA singer that jumped the shark two albums ago\*(Aq ],
\&    [ 102, \*(AqAn actually cool singer\*(Aq ],
\&  ]);
.Ve
.PP
For the arrayref of hashrefs style each hashref should be a structure
suitable for passing to \*(L"create\*(R". Multi-create is also permitted with
this syntax.
.PP
.Vb 10
\&  $schema\->resultset("Artist")\->populate([
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&     { artistid => 5, name => \*(AqAngsty\-Whiny Girl\*(Aq, cds => [
\&        { title => \*(AqMy parents sold me to a record company\*(Aq, year => 2005 },
\&        { title => \*(AqWhy Am I So Ugly?\*(Aq, year => 2006 },
\&        { title => \*(AqI Got Surgery and am now Popular\*(Aq, year => 2007 }
\&      ],
\&     },
\&  ]);
.Ve
.PP
If you attempt a void-context multi-create as in the example above (each
Artist also has the related list of CDs), and \fBdo not\fR supply the
necessary autoinc foreign key information, this method will proxy to the
less efficient \*(L"create\*(R", and then throw the Result objects away. In this
case there are obviously no benefits to using this method over \*(L"create\*(R".
.SS "pager"
.IX Subsection "pager"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $pager" 4
.el .IP "Return Value: \f(CW$pager\fR" 4
.IX Item "Return Value: $pager"
.PD
.PP
Returns a Data::Page object for the current resultset. Only makes
sense for queries with a \f(CW\*(C`page\*(C'\fR attribute.
.PP
To get the full count of entries for a paged resultset, call
\&\f(CW\*(C`total_entries\*(C'\fR on the Data::Page object.
.SS "page"
.IX Subsection "page"
.ie n .IP "Arguments: $page_number" 4
.el .IP "Arguments: \f(CW$page_number\fR" 4
.IX Item "Arguments: $page_number"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a resultset for the \f(CW$page_number\fR page of the resultset on which page
is called, where each page contains a number of rows equal to the 'rows'
attribute set on the resultset (10 by default).
.SS "new_result"
.IX Subsection "new_result"
.IP "Arguments: \e%col_data" 4
.IX Item "Arguments: %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Creates a new result object in the resultset's result class and returns
it. The row is not inserted into the database at this point, call
\&\*(L"insert\*(R" in DBIx::Class::Row to do that. Calling \*(L"in_storage\*(R" in DBIx::Class::Row
will tell you whether the result object has been inserted or not.
.PP
Passes the hashref of input on to \*(L"new\*(R" in DBIx::Class::Row.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind_values ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind_values\fR ]" 4
.IX Item "Return Value: [ $sql, @bind_values ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "find_or_new"
.IX Subsection "find_or_new"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 2
\&  my $artist = $schema\->resultset(\*(AqArtist\*(Aq)\->find_or_new(
\&    { artist => \*(Aqfred\*(Aq }, { key => \*(Aqartists\*(Aq });
\&
\&  $cd\->cd_to_producer\->find_or_new({ producer => $producer },
\&                                   { key => \*(Aqprimary\*(Aq });
.Ve
.PP
Find an existing record from this resultset using \*(L"find\*(R". if none exists,
instantiate a new result object and return it. The object will not be saved
into your storage until you call \*(L"insert\*(R" in DBIx::Class::Row on it.
.PP
You most likely want this method when looking for existing rows using a unique
constraint that is not the primary key, or looking for related rows.
.PP
If you want objects to be saved immediately, use \*(L"find_or_create\*(R" instead.
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.SS "create"
.IX Subsection "create"
.IP "Arguments: \e%col_data" 4
.IX Item "Arguments: %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Attempt to create a single new row or a row with multiple related rows
in the table represented by the resultset (and related tables). This
will not check for duplicate rows before inserting, use
\&\*(L"find_or_create\*(R" to do that.
.PP
To create one row for this resultset, pass a hashref of key/value
pairs representing the columns of the table and the values you wish to
store. If the appropriate relationships are set up, foreign key fields
can also be passed an object representing the foreign row, and the
value will be set to its primary key.
.PP
To create related objects, pass a hashref of related-object column values
\&\fBkeyed on the relationship name\fR. If the relationship is of type \f(CW\*(C`multi\*(C'\fR
(\*(L"has_many\*(R" in DBIx::Class::Relationship) \- pass an arrayref of hashrefs.
The process will correctly identify columns holding foreign keys, and will
transparently populate them from the keys of the corresponding relation.
This can be applied recursively, and will work correctly for a structure
with an arbitrary depth and width, as long as the relationships actually
exists and the correct column data has been supplied.
.PP
Instead of hashrefs of plain related data (key/value pairs), you may
also pass new or inserted objects. New objects (not inserted yet, see
\&\*(L"new_result\*(R"), will be inserted into their appropriate tables.
.PP
Effectively a shortcut for \f(CW\*(C`\->new_result(\e%col_data)\->insert\*(C'\fR.
.PP
Example of creating a new row.
.PP
.Vb 4
\&  $person_rs\->create({
\&    name=>"Some Person",
\&    email=>"somebody@someplace.com"
\&  });
.Ve
.PP
Example of creating a new row and also creating rows in a related \f(CW\*(C`has_many\*(C'\fR
or \f(CW\*(C`has_one\*(C'\fR resultset.  Note Arrayref.
.PP
.Vb 7
\&  $artist_rs\->create(
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&  );
.Ve
.PP
Example of creating a new row and also creating a row in a related
\&\f(CW\*(C`belongs_to\*(C'\fR resultset. Note Hashref.
.PP
.Vb 7
\&  $cd_rs\->create({
\&    title=>"Music for Silly Walks",
\&    year=>2000,
\&    artist => {
\&      name=>"Silly Musician",
\&    }
\&  });
.Ve
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
When subclassing ResultSet never attempt to override this method. Since
it is a simple shortcut for \f(CW\*(C`$self\->new_result($attrs)\->insert\*(C'\fR, a
lot of the internals simply never call it, so your override will be
bypassed more often than not. Override either \*(L"new\*(R" in DBIx::Class::Row
or \*(L"insert\*(R" in DBIx::Class::Row depending on how early in the
\&\*(L"create\*(R" process you need to intervene. See also warning pertaining to
\&\*(L"new\*(R".
.SS "find_or_create"
.IX Subsection "find_or_create"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 2
\&  $cd\->cd_to_producer\->find_or_create({ producer => $producer },
\&                                      { key => \*(Aqprimary\*(Aq });
.Ve
.PP
Tries to find a record based on its primary key or unique constraints; if none
is found, creates one and returns that instead.
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
.Ve
.PP
Also takes an optional \f(CW\*(C`key\*(C'\fR attribute, to search by a specific key or unique
constraint. For example:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Because \fIfind_or_create()\fR reads from the database and then
possibly inserts based on the result, this method is subject to a race
condition. Another process could create a record in the table after
the find has completed and before the create has started. To avoid
this problem, use \fIfind_or_create()\fR inside a transaction.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"update_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.PP
If you need to know if an existing row was found or a new one created use
\&\*(L"find_or_new\*(R" and \*(L"in_storage\*(R" in DBIx::Class::Row instead. Don't forget
to call \*(L"insert\*(R" in DBIx::Class::Row to save the newly created row to the
database!
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_new({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
\&
\&  if( !$cd\->in_storage ) {
\&      # do some stuff
\&      $cd\->insert;
\&  }
.Ve
.SS "update_or_create"
.IX Subsection "update_or_create"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_create({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_create\*(R", but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_data)\*(C'\fR.
.PP
Takes an optional \f(CW\*(C`key\*(C'\fR attribute to search on a specific unique constraint.
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  $cd\->cd_to_producer\->update_or_create({
\&    producer => $producer,
\&    name => \*(Aqharry\*(Aq,
\&  }, {
\&    key => \*(Aqprimary\*(Aq,
\&  });
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"find_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.PP
If you need to know if an existing row was updated or a new one created use
\&\*(L"update_or_new\*(R" and \*(L"in_storage\*(R" in DBIx::Class::Row instead. Don't forget
to call \*(L"insert\*(R" in DBIx::Class::Row to save the newly created row to the
database!
.SS "update_or_new"
.IX Subsection "update_or_new"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_new({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_new\*(R" but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_data)\*(C'\fR.
.PP
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_new(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  if ($cd\->in_storage) {
\&      # the cd was updated
\&  }
\&  else {
\&      # the cd is not yet in the database, let\*(Aqs insert it
\&      $cd\->insert;
\&  }
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R", \*(L"find_or_create\*(R" and \*(L"find_or_new\*(R".
.SS "get_cache"
.IX Subsection "get_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \e@result_objs | undef" 4
.IX Item "Return Value: @result_objs | undef"
.PD
.PP
Gets the contents of the cache for the resultset, if the cache is set.
.PP
The cache is populated either by using the \*(L"prefetch\*(R" attribute to
\&\*(L"search\*(R" or by calling \*(L"set_cache\*(R".
.SS "set_cache"
.IX Subsection "set_cache"
.IP "Arguments: \e@result_objs" 4
.IX Item "Arguments: @result_objs"
.PD 0
.IP "Return Value: \e@result_objs" 4
.IX Item "Return Value: @result_objs"
.PD
.PP
Sets the contents of the cache for the resultset. Expects an arrayref
of objects of the same class as those produced by the resultset. Note that
if the cache is set, the resultset will return the cached objects rather
than re-querying the database even if the cache attr is not set.
.PP
The contents of the cache can also be populated by using the
\&\*(L"prefetch\*(R" attribute to \*(L"search\*(R".
.SS "clear_cache"
.IX Subsection "clear_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: undef" 4
.IX Item "Return Value: undef"
.PD
.PP
Clears the cache for the resultset.
.SS "is_paged"
.IX Subsection "is_paged"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: true, if the resultset has been paginated" 4
.IX Item "Return Value: true, if the resultset has been paginated"
.PD
.SS "is_ordered"
.IX Subsection "is_ordered"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: true, if the resultset has been ordered with ""order_by""." 4
.el .IP "Return Value: true, if the resultset has been ordered with \f(CWorder_by\fR." 4
.IX Item "Return Value: true, if the resultset has been ordered with order_by."
.PD
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a related resultset for the supplied relationship name.
.PP
.Vb 1
\&  $artist_rs = $schema\->resultset(\*(AqCD\*(Aq)\->related_resultset(\*(AqArtist\*(Aq);
.Ve
.SS "current_source_alias"
.IX Subsection "current_source_alias"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $source_alias" 4
.el .IP "Return Value: \f(CW$source_alias\fR" 4
.IX Item "Return Value: $source_alias"
.PD
.PP
Returns the current table alias for the result source this resultset is built
on, that will be used in the \s-1SQL\s0 query. Usually it is \f(CW\*(C`me\*(C'\fR.
.PP
Currently the source alias that refers to the result set returned by a
\&\*(L"search\*(R"/\*(L"find\*(R" family method depends on how you got to the resultset: it's
\&\f(CW\*(C`me\*(C'\fR by default, but eg. \*(L"search_related\*(R" aliases it to the related result
source name (and keeps \f(CW\*(C`me\*(C'\fR referring to the original result set). The long
term goal is to make DBIx::Class always alias the current resultset as \f(CW\*(C`me\*(C'\fR
(and make this method unnecessary).
.PP
Thus it's currently necessary to use this method in predefined queries (see
\&\*(L"Predefined searches\*(R" in DBIx::Class::Manual::Cookbook) when referring to the
source alias of the current result set:
.PP
.Vb 3
\&  # in a result set class
\&  sub modified_by {
\&    my ($self, $user) = @_;
\&
\&    my $me = $self\->current_source_alias;
\&
\&    return $self\->search({
\&      "$me.modified" => $user\->id,
\&    });
\&  }
.Ve
.SS "as_subselect_rs"
.IX Subsection "as_subselect_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Act as a barrier to \s-1SQL\s0 symbols.  The resultset provided will be made into a
\&\*(L"virtual view\*(R" by including it as a subquery within the from clause.  From this
point on, any joined tables are inaccessible to \->search on the resultset (as if
it were simply where-filtered without joins).  For example:
.PP
.Vb 1
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search({\*(Aqx.name\*(Aq => \*(Aqabc\*(Aq},{ join => \*(Aqx\*(Aq });
\&
\& # \*(Aqx\*(Aq now pollutes the query namespace
\&
\& # So the following works as expected
\& my $ok_rs = $rs\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # But this doesn\*(Aqt: instead of finding a \*(AqBar\*(Aq related to two x rows (abc and
\& # def) we look for one row with contradictory terms and join in another table
\& # (aliased \*(Aqx_2\*(Aq) which we never use
\& my $broken_rs = $rs\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
\&
\& my $rs2 = $rs\->as_subselect_rs;
\&
\& # doesn\*(Aqt work \- \*(Aqx\*(Aq is no longer accessible in $rs2, having been sealed away
\& my $not_joined_rs = $rs2\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # works as expected: finds a \*(Aqtable\*(Aq row related to two x rows (abc and def)
\& my $correctly_joined_rs = $rs2\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
.Ve
.PP
Another example of when one might use this would be to select a subset of
columns in a group by clause:
.PP
.Vb 5
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search(undef, {
\&   group_by => [qw{ id foo_id baz_id }],
\& })\->as_subselect_rs\->search(undef, {
\&   columns => [qw{ id foo_id }]
\& });
.Ve
.PP
In the above example normally columns would have to be equal to the group by,
but because we isolated the group by into a subselect the above works.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Attributes are used to refine a ResultSet in various ways when
searching for data. They can be passed to any method which takes an
\&\f(CW\*(C`\e%attrs\*(C'\fR argument. See \*(L"search\*(R", \*(L"search_rs\*(R", \*(L"find\*(R",
\&\*(L"count\*(R".
.PP
Default attributes can be set on the result class using
\&\*(L"resultset_attributes\*(R" in DBIx::Class::ResultSource.  (Please read
the \s-1CAVEATS\s0 on that feature before using it!)
.PP
These are in no particular order:
.SS "order_by"
.IX Subsection "order_by"
.ie n .IP "Value: ( $order_by | \e@order_by | \e%order_by )" 4
.el .IP "Value: ( \f(CW$order_by\fR | \e@order_by | \e%order_by )" 4
.IX Item "Value: ( $order_by | @order_by | %order_by )"
.PP
Which column(s) to order the results by.
.PP
[The full list of suitable values is documented in
\&\*(L"\s-1ORDER BY CLAUSES\*(R"\s0 in SQL::Abstract; the following is a summary of
common options.]
.PP
If a single column name, or an arrayref of names is supplied, the
argument is passed through directly to \s-1SQL.\s0 The hashref syntax allows
for connection-agnostic specification of ordering direction:
.PP
.Vb 1
\& For descending order:
\&
\&  order_by => { \-desc => [qw/col1 col2 col3/] }
\&
\& For explicit ascending order:
\&
\&  order_by => { \-asc => \*(Aqcol\*(Aq }
.Ve
.PP
The old scalarref syntax (i.e. order_by => \e'year \s-1DESC\s0') is still
supported, although you are strongly encouraged to use the hashref
syntax as outlined above.
.SS "columns"
.IX Subsection "columns"
.ie n .IP "Value: \e@columns | \e%columns | $column" 4
.el .IP "Value: \e@columns | \e%columns | \f(CW$column\fR" 4
.IX Item "Value: @columns | %columns | $column"
.PP
Shortcut to request a particular set of columns to be retrieved. Each
column spec may be a string (a table column name), or a hash (in which
case the key is the \f(CW\*(C`as\*(C'\fR value, and the value is used as the \f(CW\*(C`select\*(C'\fR
expression). Adds \f(CW\*(C`me.\*(C'\fR onto the start of any column without a \f(CW\*(C`.\*(C'\fR in
it and sets \f(CW\*(C`select\*(C'\fR from that, then auto-populates \f(CW\*(C`as\*(C'\fR from
\&\f(CW\*(C`select\*(C'\fR as normal. (You may also use the \f(CW\*(C`cols\*(C'\fR attribute, as in
earlier versions of \s-1DBIC,\s0 but this is deprecated.)
.PP
Essentially \f(CW\*(C`columns\*(C'\fR does the same as \*(L"select\*(R" and \*(L"as\*(R".
.PP
.Vb 1
\&    columns => [ \*(Aqfoo\*(Aq, { bar => \*(Aqbaz\*(Aq } ]
.Ve
.PP
is the same as
.PP
.Vb 2
\&    select => [qw/foo baz/],
\&    as => [qw/foo bar/]
.Ve
.SS "+columns"
.IX Subsection "+columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Indicates additional columns to be selected from storage. Works the same as
\&\*(L"columns\*(R" but adds columns to the selection. (You may also use the
\&\f(CW\*(C`include_columns\*(C'\fR attribute, as in earlier versions of \s-1DBIC,\s0 but this is
deprecated). For example:\-
.PP
.Vb 4
\&  $schema\->resultset(\*(AqCD\*(Aq)\->search(undef, {
\&    \*(Aq+columns\*(Aq => [\*(Aqartist.name\*(Aq],
\&    join => [\*(Aqartist\*(Aq]
\&  });
.Ve
.PP
would return all CDs and include a 'name' column to the information
passed to object inflation. Note that the 'artist' is the name of the
column (or relationship) accessor, and 'name' is the name of the column
accessor in the related table.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+columns' when defining the attribute.
Not doing so causes Perl to incorrectly interpret +columns as a bareword with a
unary plus operator before it.
.SS "include_columns"
.IX Subsection "include_columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Deprecated.  Acts as a synonym for \*(L"+columns\*(R" for backward compatibility.
.SS "select"
.IX Subsection "select"
.IP "Value: \e@select_columns" 4
.IX Item "Value: @select_columns"
.PP
Indicates which columns should be selected from the storage. You can use
column names, or in the case of \s-1RDBMS\s0 back ends, function or stored procedure
names:
.PP
.Vb 7
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ]
\&  });
\&
\&  # Equivalent SQL
\&  SELECT name, COUNT( employeeid ), MAX( LENGTH( name ) ) AS longest_name FROM employee
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR You will almost always need a corresponding \*(L"as\*(R" attribute when you
use \*(L"select\*(R", to instruct DBIx::Class how to store the result of the column.
Also note that the \*(L"as\*(R" attribute has nothing to do with the SQL-side '\s-1AS\s0'
identifier aliasing. You can however alias a function, so you can use it in
e.g. an \f(CW\*(C`ORDER BY\*(C'\fR clause. This is done via the \f(CW\*(C`\-as\*(C'\fR \fBselect function
attribute\fR supplied as shown in the example above.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+select'/'+as' when defining the attributes.
Not doing so causes Perl to incorrectly interpret them as a bareword with a
unary plus operator before it.
.SS "+select"
.IX Subsection "+select"
.RS 4
Indicates additional columns to be selected from storage.  Works the same as
\&\*(L"select\*(R" but adds columns to the default selection, instead of specifying
an explicit list.
.RE
.SS "as"
.IX Subsection "as"
.IP "Value: \e@inflation_names" 4
.IX Item "Value: @inflation_names"
.PP
Indicates column names for object inflation. That is \*(L"as\*(R" indicates the
slot name in which the column value will be stored within the
Row object. The value will then be accessible via this
identifier by the \f(CW\*(C`get_column\*(C'\fR method (or via the object accessor \fBif one
with the same name already exists\fR) as shown below. The \*(L"as\*(R" attribute has
\&\fBnothing to do\fR with the SQL-side \f(CW\*(C`AS\*(C'\fR. See \*(L"select\*(R" for details.
.PP
.Vb 12
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ],
\&    as => [qw/
\&      name
\&      employee_count
\&      max_name_length
\&    /],
\&  });
.Ve
.PP
If the object against which the search is performed already has an accessor
matching a column name specified in \f(CW\*(C`as\*(C'\fR, the value can be retrieved using
the accessor as normal:
.PP
.Vb 1
\&  my $name = $employee\->name();
.Ve
.PP
If on the other hand an accessor does not exist in the object, you need to
use \f(CW\*(C`get_column\*(C'\fR instead:
.PP
.Vb 1
\&  my $employee_count = $employee\->get_column(\*(Aqemployee_count\*(Aq);
.Ve
.PP
You can create your own accessors if required \- see
DBIx::Class::Manual::Cookbook for details.
.SS "+as"
.IX Subsection "+as"
.RS 4
Indicates additional column names for those added via \*(L"+select\*(R". See \*(L"as\*(R".
.RE
.SS "join"
.IX Subsection "join"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
Contains a list of relationships that should be joined for this query.  For
example:
.PP
.Vb 5
\&  # Get CDs by Nine Inch Nails
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    { \*(Aqartist.name\*(Aq => \*(AqNine Inch Nails\*(Aq },
\&    { join => \*(Aqartist\*(Aq }
\&  );
.Ve
.PP
Can also contain a hash reference to refer to the other relation's relations.
For example:
.PP
.Vb 7
\&  package MyApp::Schema::Track;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqtrack\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/trackid cd position title/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqtrackid\*(Aq);
\&  _\|_PACKAGE_\|_\->belongs_to(cd => \*(AqMyApp::Schema::CD\*(Aq);
\&  1;
\&
\&  # In your application
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&    { \*(Aqtrack.title\*(Aq => \*(AqTeardrop\*(Aq },
\&    {
\&      join     => { cd => \*(Aqtrack\*(Aq },
\&      order_by => \*(Aqartist.name\*(Aq,
\&    }
\&  );
.Ve
.PP
You need to use the relationship (not the table) name in  conditions,
because they are aliased as such. The current table is aliased as \*(L"me\*(R", so
you need to use me.column_name in order to avoid ambiguity. For example:
.PP
.Vb 8
\&  # Get CDs from 1984 with a \*(AqFoo\*(Aq track
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    {
\&      \*(Aqme.year\*(Aq => 1984,
\&      \*(Aqtracks.name\*(Aq => \*(AqFoo\*(Aq
\&    },
\&    { join => \*(Aqtracks\*(Aq }
\&  );
.Ve
.PP
If the same join is supplied twice, it will be aliased to <rel>_2 (and
similarly for a third time). For e.g.
.PP
.Vb 6
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&    \*(Aqcds.title\*(Aq   => \*(AqDown to Earth\*(Aq,
\&    \*(Aqcds_2.title\*(Aq => \*(AqPopular\*(Aq,
\&  }, {
\&    join => [ qw/cds cds/ ],
\&  });
.Ve
.PP
will return a set of all artists that have both a cd with title 'Down
to Earth' and a cd with title 'Popular'.
.PP
If you want to fetch related objects from other tables as well, see \*(L"prefetch\*(R"
below.
.PP
.Vb 5
\& NOTE: An internal join\-chain pruner will discard certain joins while
\& constructing the actual SQL query, as long as the joins in question do not
\& affect the retrieved result. This for example includes 1:1 left joins
\& that are not part of the restriction specification (WHERE/HAVING) nor are
\& a part of the query selection.
.Ve
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.SS "collapse"
.IX Subsection "collapse"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
When set to a true value, indicates that any rows fetched from joined has_many
relationships are to be aggregated into the corresponding \*(L"parent\*(R" object. For
example, the resultset:
.PP
.Vb 5
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({}, {
\&    \*(Aq+columns\*(Aq => [ qw/ tracks.title tracks.position / ],
\&    join => \*(Aqtracks\*(Aq,
\&    collapse => 1,
\&  });
.Ve
.PP
While executing the following query:
.PP
.Vb 4
\&  SELECT me.*, tracks.title, tracks.position
\&    FROM cd me
\&    LEFT JOIN track tracks
\&      ON tracks.cdid = me.cdid
.Ve
.PP
Will return only as many objects as there are rows in the \s-1CD\s0 source, even
though the result of the query may span many rows. Each of these \s-1CD\s0 objects
will in turn have multiple \*(L"Track\*(R" objects hidden behind the has_many
generated accessor \f(CW\*(C`tracks\*(C'\fR. Without \f(CW\*(C`collapse => 1\*(C'\fR, the return values
of this resultset would be as many \s-1CD\s0 objects as there are tracks (a \*(L"Cartesian
product\*(R"), with each \s-1CD\s0 object containing exactly one of all fetched Track data.
.PP
When a collapse is requested on a non-ordered resultset, an order by some
unique part of the main source (the left-most table) is inserted automatically.
This is done so that the resultset is allowed to be \*(L"lazy\*(R" \- calling
\&\f(CW$rs\fR\->next will fetch only as many rows as it needs to build the next
object with all of its related data.
.PP
If an \*(L"order_by\*(R" is already declared, and orders the resultset in a way that
makes collapsing as described above impossible (e.g. \f(CW\*(C`ORDER BY
has_many_rel.column\*(C'\fR or \f(CW\*(C`ORDER BY RANDOM()\*(C'\fR), \s-1DBIC\s0 will automatically
switch to \*(L"eager\*(R" mode and slurp the entire resultset before constructing the
first object returned by \*(L"next\*(R".
.PP
Setting this attribute on a resultset that does not join any has_many
relations is a no-op.
.PP
For a more in-depth discussion, see \*(L"\s-1PREFETCHING\*(R"\s0.
.SS "prefetch"
.IX Subsection "prefetch"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
This attribute is a shorthand for specifying a \*(L"join\*(R" spec, adding all
columns from the joined related sources as \*(L"+columns\*(R" and setting
\&\*(L"collapse\*(R" to a true value. For example, the following two queries are
equivalent:
.PP
.Vb 3
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({}, {
\&    prefetch => { cds => [\*(Aqgenre\*(Aq, \*(Aqtracks\*(Aq ] },
\&  });
.Ve
.PP
and
.PP
.Vb 10
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({}, {
\&    join => { cds => [\*(Aqgenre\*(Aq, \*(Aqtracks\*(Aq ] },
\&    collapse => 1,
\&    \*(Aq+columns\*(Aq => [
\&      (map
\&        { +{ "cds.$_" => "cds.$_" } }
\&        $schema\->source(\*(AqArtist\*(Aq)\->related_source(\*(Aqcds\*(Aq)\->columns
\&      ),
\&      (map
\&        { +{ "cds.genre.$_" => "genre.$_" } }
\&        $schema\->source(\*(AqArtist\*(Aq)\->related_source(\*(Aqcds\*(Aq)\->related_source(\*(Aqgenre\*(Aq)\->columns
\&      ),
\&      (map
\&        { +{ "cds.tracks.$_" => "tracks.$_" } }
\&        $schema\->source(\*(AqArtist\*(Aq)\->related_source(\*(Aqcds\*(Aq)\->related_source(\*(Aqtracks\*(Aq)\->columns
\&      ),
\&    ],
\&  });
.Ve
.PP
Both producing the following \s-1SQL:\s0
.PP
.Vb 12
\&  SELECT  me.artistid, me.name, me.rank, me.charfield,
\&          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track,
\&          genre.genreid, genre.name,
\&          tracks.trackid, tracks.cd, tracks.position, tracks.title, tracks.last_updated_on, tracks.last_updated_at
\&    FROM artist me
\&    LEFT JOIN cd cds
\&      ON cds.artist = me.artistid
\&    LEFT JOIN genre genre
\&      ON genre.genreid = cds.genreid
\&    LEFT JOIN track tracks
\&      ON tracks.cd = cds.cdid
\&  ORDER BY me.artistid
.Ve
.PP
While \*(L"prefetch\*(R" implies a \*(L"join\*(R", it is ok to mix the two together, as
the arguments are properly merged and generally do the right thing. For
example, you may want to do the following:
.PP
.Vb 7
\&  my $artists_and_cds_without_genre = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&    { \*(Aqgenre.genreid\*(Aq => undef },
\&    {
\&      join => { cds => \*(Aqgenre\*(Aq },
\&      prefetch => \*(Aqcds\*(Aq,
\&    }
\&  );
.Ve
.PP
Which generates the following \s-1SQL:\s0
.PP
.Vb 9
\&  SELECT  me.artistid, me.name, me.rank, me.charfield,
\&          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track
\&    FROM artist me
\&    LEFT JOIN cd cds
\&      ON cds.artist = me.artistid
\&    LEFT JOIN genre genre
\&      ON genre.genreid = cds.genreid
\&  WHERE genre.genreid IS NULL
\&  ORDER BY me.artistid
.Ve
.PP
For a more in-depth discussion, see \*(L"\s-1PREFETCHING\*(R"\s0.
.SS "alias"
.IX Subsection "alias"
.ie n .IP "Value: $source_alias" 4
.el .IP "Value: \f(CW$source_alias\fR" 4
.IX Item "Value: $source_alias"
.PP
Sets the source alias for the query.  Normally, this defaults to \f(CW\*(C`me\*(C'\fR, but
nested search queries (sub-SELECTs) might need specific aliases set to
reference inner queries.  For example:
.PP
.Vb 7
\&   my $q = $rs
\&      \->related_resultset(\*(AqCDs\*(Aq)
\&      \->related_resultset(\*(AqTracks\*(Aq)
\&      \->search({
\&         \*(Aqtrack.id\*(Aq => { \-ident => \*(Aqnone_search.id\*(Aq },
\&      })
\&      \->as_query;
\&
\&   my $ids = $self\->search({
\&      \-not_exists => $q,
\&   }, {
\&      alias    => \*(Aqnone_search\*(Aq,
\&      group_by => \*(Aqnone_search.id\*(Aq,
\&   })\->get_column(\*(Aqid\*(Aq)\->as_query;
\&
\&   $self\->search({ id => { \-in => $ids } })
.Ve
.PP
This attribute is directly tied to \*(L"current_source_alias\*(R".
.SS "page"
.IX Subsection "page"
.ie n .IP "Value: $page" 4
.el .IP "Value: \f(CW$page\fR" 4
.IX Item "Value: $page"
.PP
Makes the resultset paged and specifies the page to retrieve. Effectively
identical to creating a non-pages resultset and then calling \->page($page)
on it.
.PP
If \*(L"rows\*(R" attribute is not specified it defaults to 10 rows per page.
.PP
When you have a paged resultset, \*(L"count\*(R" will only return the number
of rows in the page. To get the total, use the \*(L"pager\*(R" and call
\&\f(CW\*(C`total_entries\*(C'\fR on it.
.SS "rows"
.IX Subsection "rows"
.ie n .IP "Value: $rows" 4
.el .IP "Value: \f(CW$rows\fR" 4
.IX Item "Value: $rows"
.PP
Specifies the maximum number of rows for direct retrieval or the number of
rows per page if the page attribute or method is used.
.SS "offset"
.IX Subsection "offset"
.ie n .IP "Value: $offset" 4
.el .IP "Value: \f(CW$offset\fR" 4
.IX Item "Value: $offset"
.PP
Specifies the (zero-based) row number for the  first row to be returned, or the
of the first row of the first page if paging is used.
.SS "software_limit"
.IX Subsection "software_limit"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
When combined with \*(L"rows\*(R" and/or \*(L"offset\*(R" the generated \s-1SQL\s0 will not
include any limit dialect stanzas. Instead the entire result will be selected
as if no limits were specified, and \s-1DBIC\s0 will perform the limit locally, by
artificially advancing and finishing the resulting \*(L"cursor\*(R".
.PP
This is the recommended way of performing resultset limiting when no sane \s-1RDBMS\s0
implementation is available (e.g.
Sybase \s-1ASE\s0 using the
Generic Sub Query hack)
.SS "group_by"
.IX Subsection "group_by"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
A arrayref of columns to group by. Can include columns of joined tables.
.PP
.Vb 1
\&  group_by => [qw/ column1 column2 ... /]
.Ve
.SS "having"
.IX Subsection "having"
.ie n .IP "Value: $condition" 4
.el .IP "Value: \f(CW$condition\fR" 4
.IX Item "Value: $condition"
.PP
\&\s-1HAVING\s0 is a select statement attribute that is applied between \s-1GROUP BY\s0 and
\&\s-1ORDER BY.\s0 It is applied to the after the grouping calculations have been
done.
.PP
.Vb 1
\&  having => { \*(Aqcount_employee\*(Aq => { \*(Aq>=\*(Aq, 100 } }
.Ve
.PP
or with an in-place function in which case literal \s-1SQL\s0 is required:
.PP
.Vb 1
\&  having => \e[ \*(Aqcount(employee) >= ?\*(Aq, [ count => 100 ] ]
.Ve
.SS "distinct"
.IX Subsection "distinct"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
Set to 1 to automatically generate a \*(L"group_by\*(R" clause based on the selection
(including intelligent handling of \*(L"order_by\*(R" contents). Note that the group
criteria calculation takes place over the \fBfinal\fR selection. This includes
any \*(L"+columns\*(R", \*(L"+select\*(R" or \*(L"order_by\*(R" additions in subsequent
\&\*(L"search\*(R" calls, and standalone columns selected via
DBIx::Class::ResultSetColumn (\*(L"get_column\*(R"). A notable exception are the
extra selections specified via \*(L"prefetch\*(R" \- such selections are explicitly
excluded from group criteria calculations.
.PP
If the final ResultSet also explicitly defines a \*(L"group_by\*(R" attribute, this
setting is ignored and an appropriate warning is issued.
.SS "where"
.IX Subsection "where"
.RS 4
Adds to the \s-1WHERE\s0 clause.
.Sp
.Vb 2
\&  # only return rows WHERE deleted IS NULL for all searches
\&  _\|_PACKAGE_\|_\->resultset_attributes({ where => { deleted => undef } });
.Ve
.Sp
Can be overridden by passing \f(CW\*(C`{ where => undef }\*(C'\fR as an attribute
to a resultset.
.Sp
For more complicated where clauses see \*(L"\s-1WHERE CLAUSES\*(R"\s0 in SQL::Abstract.
.RE
.SS "cache"
.IX Subsection "cache"
Set to 1 to cache search results. This prevents extra \s-1SQL\s0 queries if you
revisit rows in your ResultSet:
.PP
.Vb 1
\&  my $resultset = $schema\->resultset(\*(AqArtist\*(Aq)\->search( undef, { cache => 1 } );
\&
\&  while( my $artist = $resultset\->next ) {
\&    ... do stuff ...
\&  }
\&
\&  $rs\->first; # without cache, this would issue a query
.Ve
.PP
By default, searches are not cached.
.PP
For more examples of using these attributes, see
DBIx::Class::Manual::Cookbook.
.SS "for"
.IX Subsection "for"
.IP "Value: ( 'update' | 'shared' | \e$scalar )" 4
.IX Item "Value: ( 'update' | 'shared' | $scalar )"
.PP
Set to 'update' for a \s-1SELECT ... FOR UPDATE\s0 or 'shared' for a \s-1SELECT
\&... FOR SHARED.\s0 If \e$scalar is passed, this is taken directly and embedded in the
query.
.SH "PREFETCHING"
.IX Header "PREFETCHING"
DBIx::Class supports arbitrary related data prefetching from multiple related
sources. Any combination of relationship types and column sets are supported.
If collapsing is requested, there is an additional requirement of
selecting enough data to make every individual object uniquely identifiable.
.PP
Here are some more involved examples, based on the following relationship map:
.PP
.Vb 4
\&  # Assuming:
\&  My::Schema::CD\->belongs_to( artist      => \*(AqMy::Schema::Artist\*(Aq     );
\&  My::Schema::CD\->might_have( liner_note  => \*(AqMy::Schema::LinerNotes\*(Aq );
\&  My::Schema::CD\->has_many(   tracks      => \*(AqMy::Schema::Track\*(Aq      );
\&
\&  My::Schema::Artist\->belongs_to( record_label => \*(AqMy::Schema::RecordLabel\*(Aq );
\&
\&  My::Schema::Track\->has_many( guests => \*(AqMy::Schema::Guest\*(Aq );
\&
\&
\&
\&  my $rs = $schema\->resultset(\*(AqTag\*(Aq)\->search(
\&    undef,
\&    {
\&      prefetch => {
\&        cd => \*(Aqartist\*(Aq
\&      }
\&    }
\&  );
.Ve
.PP
The initial search results in \s-1SQL\s0 like the following:
.PP
.Vb 3
\&  SELECT tag.*, cd.*, artist.* FROM tag
\&  JOIN cd ON tag.cd = cd.cdid
\&  JOIN artist ON cd.artist = artist.artistid
.Ve
.PP
DBIx::Class has no need to go back to the database when we access the
\&\f(CW\*(C`cd\*(C'\fR or \f(CW\*(C`artist\*(C'\fR relationships, which saves us two \s-1SQL\s0 statements in this
case.
.PP
Simple prefetches will be joined automatically, so there is no need
for a \f(CW\*(C`join\*(C'\fR attribute in the above search.
.PP
The \*(L"prefetch\*(R" attribute can be used with any of the relationship types
and multiple prefetches can be specified together. Below is a more complex
example that prefetches a \s-1CD\s0's artist, its liner notes (if present),
the cover image, the tracks on that \s-1CD,\s0 and the guests on those
tracks.
.PP
.Vb 11
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    undef,
\&    {
\&      prefetch => [
\&        { artist => \*(Aqrecord_label\*(Aq},  # belongs_to => belongs_to
\&        \*(Aqliner_note\*(Aq,                 # might_have
\&        \*(Aqcover_image\*(Aq,                # has_one
\&        { tracks => \*(Aqguests\*(Aq },       # has_many => has_many
\&      ]
\&    }
\&  );
.Ve
.PP
This will produce \s-1SQL\s0 like the following:
.PP
.Vb 10
\&  SELECT cd.*, artist.*, record_label.*, liner_note.*, cover_image.*,
\&         tracks.*, guests.*
\&    FROM cd me
\&    JOIN artist artist
\&      ON artist.artistid = me.artistid
\&    JOIN record_label record_label
\&      ON record_label.labelid = artist.labelid
\&    LEFT JOIN track tracks
\&      ON tracks.cdid = me.cdid
\&    LEFT JOIN guest guests
\&      ON guests.trackid = track.trackid
\&    LEFT JOIN liner_notes liner_note
\&      ON liner_note.cdid = me.cdid
\&    JOIN cd_artwork cover_image
\&      ON cover_image.cdid = me.cdid
\&  ORDER BY tracks.cd
.Ve
.PP
Now the \f(CW\*(C`artist\*(C'\fR, \f(CW\*(C`record_label\*(C'\fR, \f(CW\*(C`liner_note\*(C'\fR, \f(CW\*(C`cover_image\*(C'\fR,
\&\f(CW\*(C`tracks\*(C'\fR, and \f(CW\*(C`guests\*(C'\fR of the \s-1CD\s0 will all be available through the
relationship accessors without the need for additional queries to the
database.
.PP
\fI\s-1CAVEATS\s0\fR
.IX Subsection "CAVEATS"
.PP
Prefetch does a lot of deep magic. As such, it may not behave exactly
as you might expect.
.IP "\(bu" 4
Prefetch uses the \*(L"cache\*(R" to populate the prefetched relationships. This
may or may not be what you want.
.IP "\(bu" 4
If you specify a condition on a prefetched relationship, \s-1ONLY\s0 those
rows that match the prefetched condition will be fetched into that relationship.
This means that adding prefetch to a \fIsearch()\fR \fBmay alter\fR what is returned by
traversing a relationship. So, if you have \f(CW\*(C`Artist\->has_many(CDs)\*(C'\fR and you do
.Sp
.Vb 5
\&  my $artist_rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&      \*(Aqcds.year\*(Aq => 2008,
\&  }, {
\&      join => \*(Aqcds\*(Aq,
\&  });
\&
\&  my $count = $artist_rs\->first\->cds\->count;
\&
\&  my $artist_rs_prefetch = $artist_rs\->search( {}, { prefetch => \*(Aqcds\*(Aq } );
\&
\&  my $prefetch_count = $artist_rs_prefetch\->first\->cds\->count;
\&
\&  cmp_ok( $count, \*(Aq==\*(Aq, $prefetch_count, "Counts should be the same" );
.Ve
.Sp
That \fIcmp_ok()\fR may or may not pass depending on the datasets involved. In other
words the \f(CW\*(C`WHERE\*(C'\fR condition would apply to the entire dataset, just like
it would in regular \s-1SQL.\s0 If you want to add a condition only to the \*(L"right side\*(R"
of a \f(CW\*(C`LEFT JOIN\*(C'\fR \- consider declaring and using a relationship with a custom
condition
.SH "DBIC BIND VALUES"
.IX Header "DBIC BIND VALUES"
Because \s-1DBIC\s0 may need more information to bind values than just the column name
and value itself, it uses a special format for both passing and receiving bind
values.  Each bind value should be composed of an arrayref of
\&\f(CW\*(C`[ \e%args => $val ]\*(C'\fR.  The format of \f(CW\*(C`\e%args\*(C'\fR is currently:
.IP "dbd_attrs" 4
.IX Item "dbd_attrs"
If present (in any form), this is what is being passed directly to bind_param.
Note that different \s-1DBD\s0's expect different bind args.  (e.g. DBD::SQLite takes
a single numerical type, while DBD::Pg takes a hashref if bind options.)
.Sp
If this is specified, all other bind options described below are ignored.
.IP "sqlt_datatype" 4
.IX Item "sqlt_datatype"
If present, this is used to infer the actual bind attribute by passing to
\&\f(CW\*(C`$resolved_storage\->bind_attribute_by_data_type()\*(C'\fR.  Defaults to the
\&\*(L"data_type\*(R" from the add_columns column info.
.Sp
Note that the data type is somewhat freeform (hence the sqlt_ prefix);
currently drivers are expected to \*(L"Do the Right Thing\*(R" when given a common
datatype name.  (Not ideal, but that's what we got at this point.)
.IP "sqlt_size" 4
.IX Item "sqlt_size"
Currently used to correctly allocate buffers for \fIbind_param_inout()\fR.
Defaults to \*(L"size\*(R" from the add_columns column info,
or to a sensible value based on the \*(L"data_type\*(R".
.IP "dbic_colname" 4
.IX Item "dbic_colname"
Used to fill in missing sqlt_datatype and sqlt_size attributes (if they are
explicitly specified they are never overridden).  Also used by some weird DBDs,
where the column name should be available at bind_param time (e.g. Oracle).
.PP
For backwards compatibility and convenience, the following shortcuts are
supported:
.PP
.Vb 4
\&  [ $name => $val ] === [ { dbic_colname => $name }, $val ]
\&  [ \e$dt  => $val ] === [ { sqlt_datatype => $dt }, $val ]
\&  [ undef,   $val ] === [ {}, $val ]
\&  $val              === [ {}, $val ]
.Ve
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSet5.16.3pm               0100644 0001750 0001750 00000214504 12566242362 025620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSet 3"
.TH DBIx::Class::ResultSet 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSet \- Represents a query used for fetching a set of results.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  my $users_rs   = $schema\->resultset(\*(AqUser\*(Aq);
\&  while( $user = $users_rs\->next) {
\&    print $user\->username;
\&  }
\&
\&  my $registered_users_rs   = $schema\->resultset(\*(AqUser\*(Aq)\->search({ registered => 1 });
\&  my @cds_in_2005 = $schema\->resultset(\*(AqCD\*(Aq)\->search({ year => 2005 })\->all();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSet is an object which stores a set of conditions representing
a query. It is the backbone of DBIx::Class (i.e. the really
important/useful bit).
.PP
No \s-1SQL\s0 is executed on the database when a ResultSet is created, it
just stores all the conditions needed to create the query.
.PP
A basic ResultSet representing the data of an entire table is returned
by calling \f(CW\*(C`resultset\*(C'\fR on a DBIx::Class::Schema and passing in a
Source name.
.PP
.Vb 1
\&  my $users_rs = $schema\->resultset(\*(AqUser\*(Aq);
.Ve
.PP
A new ResultSet is returned from calling \*(L"search\*(R" on an existing
ResultSet. The new one will contain all the conditions of the
original, plus any new conditions added in the \f(CW\*(C`search\*(C'\fR call.
.PP
A ResultSet also incorporates an implicit iterator. \*(L"next\*(R" and \*(L"reset\*(R"
can be used to walk through all the DBIx::Class::Rows the ResultSet
represents.
.PP
The query that the ResultSet represents is \fBonly\fR executed against
the database when these methods are called:
\&\*(L"find\*(R", \*(L"next\*(R", \*(L"all\*(R", \*(L"first\*(R", \*(L"single\*(R", \*(L"count\*(R".
.PP
If a resultset is used in a numeric context it returns the \*(L"count\*(R".
However, if it is used in a boolean context it is \fBalways\fR true.  So if
you want to check if a resultset has any results, you must use \f(CW\*(C`if $rs
!= 0\*(C'\fR.
.SH "CUSTOM ResultSet CLASSES THAT USE Moose"
.IX Header "CUSTOM ResultSet CLASSES THAT USE Moose"
If you want to make your custom ResultSet classes with Moose, use a template
similar to:
.PP
.Vb 1
\&    package MyApp::Schema::ResultSet::User;
\&
\&    use Moose;
\&    use namespace::autoclean;
\&    use MooseX::NonMoose;
\&    extends \*(AqDBIx::Class::ResultSet\*(Aq;
\&
\&    sub BUILDARGS { $_[2] }
\&
\&    ...your code...
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
\&
\&    1;
.Ve
.PP
The MooseX::NonMoose is necessary so that the Moose constructor does not
clash with the regular ResultSet constructor. Alternatively, you can use:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->meta\->make_immutable(inline_constructor => 0);
.Ve
.PP
The \s-1BUILDARGS\s0 is necessary because the
signature of the ResultSet \f(CW\*(C`new\*(C'\fR is \f(CW\*(C`\->new($source, \e%args)\*(C'\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Chaining resultsets"
.IX Subsection "Chaining resultsets"
Let's say you've got a query that needs to be run to return some data
to the user. But, you have an authorization system in place that
prevents certain users from seeing certain information. So, you want
to construct the basic query in one method, but add constraints to it in
another.
.PP
.Vb 4
\&  sub get_data {
\&    my $self = shift;
\&    my $request = $self\->get_request; # Get a request object somehow.
\&    my $schema = $self\->result_source\->schema;
\&
\&    my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&      title => $request\->param(\*(Aqtitle\*(Aq),
\&      year => $request\->param(\*(Aqyear\*(Aq),
\&    });
\&
\&    $cd_rs = $self\->apply_security_policy( $cd_rs );
\&
\&    return $cd_rs\->all();
\&  }
\&
\&  sub apply_security_policy {
\&    my $self = shift;
\&    my ($rs) = @_;
\&
\&    return $rs\->search({
\&      subversive => 0,
\&    });
\&  }
.Ve
.PP
\fIResolving conditions and attributes\fR
.IX Subsection "Resolving conditions and attributes"
.PP
When a resultset is chained from another resultset, conditions and
attributes with the same keys need resolving.
.PP
\&\*(L"join\*(R", \*(L"prefetch\*(R", \*(L"+select\*(R", \*(L"+as\*(R" attributes are merged
into the existing ones from the original resultset.
.PP
The \*(L"where\*(R" and \*(L"having\*(R" attributes, and any search conditions, are
merged with an \s-1SQL\s0 \f(CW\*(C`AND\*(C'\fR to the existing condition from the original
resultset.
.PP
All other attributes are overridden by any new ones supplied in the
search attributes.
.SS "Multiple queries"
.IX Subsection "Multiple queries"
Since a resultset just defines a query, you can do all sorts of
things with it with the same object.
.PP
.Vb 5
\&  # Don\*(Aqt hit the DB yet.
\&  my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&  });
\&
\&  # Each of these hits the DB individually.
\&  my $count = $cd_rs\->count;
\&  my $most_recent = $cd_rs\->get_column(\*(Aqdate_released\*(Aq)\->max();
\&  my @records = $cd_rs\->all;
.Ve
.PP
And it's not just limited to \s-1SELECT\s0 statements.
.PP
.Vb 1
\&  $cd_rs\->delete();
.Ve
.PP
This is even cooler:
.PP
.Vb 1
\&  $cd_rs\->create({ artist => \*(AqFred\*(Aq });
.Ve
.PP
Which is the same as:
.PP
.Vb 5
\&  $schema\->resultset(\*(AqCD\*(Aq)\->create({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&    artist => \*(AqFred\*(Aq
\&  });
.Ve
.PP
See: \*(L"search\*(R", \*(L"count\*(R", \*(L"get_column\*(R", \*(L"all\*(R", \*(L"create\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.ie n .IP "Arguments: $source, \e%$attrs" 4
.el .IP "Arguments: \f(CW$source\fR, \e%$attrs" 4
.IX Item "Arguments: $source, %$attrs"
.PD 0
.ie n .IP "Return Value: $rs" 4
.el .IP "Return Value: \f(CW$rs\fR" 4
.IX Item "Return Value: $rs"
.PD
.PP
The resultset constructor. Takes a source object (usually a
DBIx::Class::ResultSourceProxy::Table) and an attribute hash (see
\&\*(L"\s-1ATTRIBUTES\s0\*(R" below).  Does not perform any queries \*(-- these are
executed as needed by the other methods.
.PP
Generally you won't need to construct a resultset manually.  You'll
automatically get one from e.g. a \*(L"search\*(R" called in scalar context:
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ title => \*(Aq100th Window\*(Aq });
.Ve
.PP
\&\s-1IMPORTANT:\s0 If called on an object, proxies to new_result instead so
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->new({ title => \*(AqSpoon\*(Aq });
.Ve
.PP
will return a \s-1CD\s0 object, not a ResultSet.
.SS "search"
.IX Subsection "search"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) ||  @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) ||  \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) ||  @row_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds    = $cd_rs\->search({ year => 2001 }); # "... WHERE year = 2001"
\&  my $new_rs = $cd_rs\->search({ year => 2005 });
\&
\&  my $new_rs = $cd_rs\->search([ { year => 2005 }, { year => 2004 } ]);
\&                 # year = 2005 OR year = 2004
.Ve
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of row objects instead. To avoid that, use \*(L"search_rs\*(R".
.PP
If you need to pass in additional attributes but no additional condition,
call it as \f(CW\*(C`search(undef, \e%attrs)\*(C'\fR.
.PP
.Vb 4
\&  # "SELECT name, artistid FROM $artist_table"
\&  my @all_artists = $schema\->resultset(\*(AqArtist\*(Aq)\->search(undef, {
\&    columns => [qw/name artistid/],
\&  });
.Ve
.PP
For a list of attributes that can be passed to \f(CW\*(C`search\*(C'\fR, see
\&\*(L"\s-1ATTRIBUTES\s0\*(R". For more examples of using this function, see
Searching. For a complete
documentation for the first argument, see SQL::Abstract
and its extension DBIx::Class::SQLMaker.
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"search\*(R" does not process/deflate any of the values passed in the
SQL::Abstract\-compatible search condition structure. This is unlike other
condition-bound methods \*(L"new\*(R", \*(L"create\*(R" and \*(L"find\*(R". The user must ensure
manually that any value passed to this method will stringify to something the
\&\s-1RDBMS\s0 knows how to deal with. A notable example is the handling of DateTime
objects, for more info see:
\&\*(L"Formatting DateTime objects in queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "search_rs"
.IX Subsection "search_rs"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
This method does the same exact thing as \fIsearch()\fR except it will
always return a resultset, even in list context.
.SS "search_literal"
.IX Subsection "search_literal"
.ie n .IP "Arguments: $sql_fragment, @bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @bind_values"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) || @row_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds   = $cd_rs\->search_literal(\*(Aqyear = ? AND title = ?\*(Aq, qw/2001 Reload/);
\&  my $newrs = $artist_rs\->search_literal(\*(Aqname = ?\*(Aq, \*(AqMetallica\*(Aq);
.Ve
.PP
Pass a literal chunk of \s-1SQL\s0 to be added to the conditional part of the
resultset query.
.PP
\&\s-1CAVEAT:\s0 \f(CW\*(C`search_literal\*(C'\fR is provided for Class::DBI compatibility and should
only be used in that context. \f(CW\*(C`search_literal\*(C'\fR is a convenience method.
It is equivalent to calling \f(CW$schema\fR\->search(\e[]), but if you want to ensure
columns are bound correctly, use \f(CW\*(C`search\*(C'\fR.
.PP
Example of how to use \f(CW\*(C`search\*(C'\fR instead of \f(CW\*(C`search_literal\*(C'\fR
.PP
.Vb 2
\&  my @cds = $cd_rs\->search_literal(\*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, (2, 1, 2));
\&  my @cds = $cd_rs\->search(\e[ \*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, [ \*(Aqcdid\*(Aq, 2 ], [ \*(Aqartist\*(Aq, 1 ], [ \*(Aqartist\*(Aq, 2 ] ]);
.Ve
.PP
See \*(L"Searching\*(R" in DBIx::Class::Manual::Cookbook and
\&\*(L"Searching\*(R" in DBIx::Class::Manual::FAQ for searching techniques that do not
require \f(CW\*(C`search_literal\*(C'\fR.
.SS "find"
.IX Subsection "find"
.ie n .IP "Arguments: \e%columns_values | @pk_values, \e%attrs?" 4
.el .IP "Arguments: \e%columns_values | \f(CW@pk_values\fR, \e%attrs?" 4
.IX Item "Arguments: %columns_values | @pk_values, %attrs?"
.PD 0
.ie n .IP "Return Value: $row_object | undef" 4
.el .IP "Return Value: \f(CW$row_object\fR | undef" 4
.IX Item "Return Value: $row_object | undef"
.PD
.PP
Finds and returns a single row based on supplied criteria. Takes either a
hashref with the same format as \*(L"create\*(R" (including inference of foreign
keys from related objects), or a list of primary key values in the same
order as the primary columns
declaration on the \*(L"result_source\*(R".
.PP
In either case an attempt is made to combine conditions already existing on
the resultset with the condition passed to this method.
.PP
To aid with preparing the correct query for the storage you may supply the
\&\f(CW\*(C`key\*(C'\fR attribute, which is the name of a
unique constraint (the
unique constraint corresponding to the
primary columns is always named
\&\f(CW\*(C`primary\*(C'\fR). If the \f(CW\*(C`key\*(C'\fR attribute has been supplied, and \s-1DBIC\s0 is unable
to construct a query that satisfies the named unique constraint fully (
non-NULL values for each column member of the constraint) an exception is
thrown.
.PP
If no \f(CW\*(C`key\*(C'\fR is specified, the search is carried over all unique constraints
which are fully defined by the available condition.
.PP
If no such constraint is found, \f(CW\*(C`find\*(C'\fR currently defaults to a simple
\&\f(CW\*(C`search\->(\e%column_values)\*(C'\fR which may or may not do what you expect.
Note that this fallback behavior may be deprecated in further versions. If
you need to search with arbitrary conditions \- use \*(L"search\*(R". If the query
resulting from this fallback produces more than one row, a warning to the
effect is issued, though only the first row is constructed and returned as
\&\f(CW$row_object\fR.
.PP
In addition to \f(CW\*(C`key\*(C'\fR, \*(L"find\*(R" recognizes and applies standard
resultset attributes in the same way as \*(L"search\*(R" does.
.PP
Note that if you have extra concerns about the correctness of the resulting
query you need to specify the \f(CW\*(C`key\*(C'\fR attribute and supply the entire condition
as an argument to find (since it is not always possible to perform the
combination of the resultset condition with the supplied one, especially if
the resultset condition contains literal sql).
.PP
For example, to find a row by its primary key:
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(5);
.Ve
.PP
You can also find a row by a specific unique constraint:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
See also \*(L"find_or_create\*(R" and \*(L"update_or_create\*(R".
.SS "search_related"
.IX Subsection "search_related"
.ie n .IP "Arguments: $rel, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $new_resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$new_resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $new_resultset (scalar context) || @row_objs (list context)"
.PD
.PP
.Vb 3
\&  $new_rs = $cd_rs\->search_related(\*(Aqartist\*(Aq, {
\&    name => \*(AqEmo\-R\-Us\*(Aq,
\&  });
.Ve
.PP
Searches the specified relationship, optionally specifying a condition and
attributes for matching records. See \*(L"\s-1ATTRIBUTES\s0\*(R" for more information.
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of row objects instead. To avoid that, use \*(L"search_related_rs\*(R".
.PP
See also \*(L"search_related_rs\*(R".
.SS "search_related_rs"
.IX Subsection "search_related_rs"
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "cursor"
.IX Subsection "cursor"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $cursor" 4
.el .IP "Return Value: \f(CW$cursor\fR" 4
.IX Item "Return Value: $cursor"
.PD
.PP
Returns a storage-driven cursor to the given resultset. See
DBIx::Class::Cursor for more information.
.SS "single"
.IX Subsection "single"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $row_object | undef" 4
.el .IP "Return Value: \f(CW$row_object\fR | undef" 4
.IX Item "Return Value: $row_object | undef"
.PD
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->single({ year => 2001 });
.Ve
.PP
Inflates the first result without creating a cursor if the resultset has
any records in it; if not returns \f(CW\*(C`undef\*(C'\fR. Used by \*(L"find\*(R" as a lean version
of \*(L"search\*(R".
.PP
While this method can take an optional search condition (just like \*(L"search\*(R")
being a fast-code-path it does not recognize search attributes. If you need to
add extra joins or similar, call \*(L"search\*(R" and then chain-call \*(L"single\*(R" on the
DBIx::Class::ResultSet returned.
.IP "\fBNote\fR" 4
.IX Item "Note"
As of 0.08100, this method enforces the assumption that the preceding
query returns only one row. If more than one row is returned, you will receive
a warning:
.Sp
.Vb 1
\&  Query returned more than one row
.Ve
.Sp
In this case, you should be using \*(L"next\*(R" or \*(L"find\*(R" instead, or if you really
know what you are doing, use the \*(L"rows\*(R" attribute to explicitly limit the size
of the resultset.
.Sp
This method will also throw an exception if it is called on a resultset prefetching
has_many, as such a prefetch implies fetching multiple rows from the database in
order to assemble the resulting object.
.SS "get_column"
.IX Subsection "get_column"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $resultsetcolumn" 4
.el .IP "Return Value: \f(CW$resultsetcolumn\fR" 4
.IX Item "Return Value: $resultsetcolumn"
.PD
.PP
.Vb 1
\&  my $max_length = $rs\->get_column(\*(Aqlength\*(Aq)\->max;
.Ve
.PP
Returns a DBIx::Class::ResultSetColumn instance for a column of the ResultSet.
.SS "search_like"
.IX Subsection "search_like"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) || @row_objs (list context)"
.PD
.PP
.Vb 2
\&  # WHERE title LIKE \*(Aq%blue%\*(Aq
\&  $cd_rs = $rs\->search_like({ title => \*(Aq%blue%\*(Aq});
.Ve
.PP
Performs a search, but uses \f(CW\*(C`LIKE\*(C'\fR instead of \f(CW\*(C`=\*(C'\fR as the condition. Note
that this is simply a convenience method retained for ex Class::DBI users.
You most likely want to use \*(L"search\*(R" with specific operators.
.PP
For more information, see DBIx::Class::Manual::Cookbook.
.PP
This method is deprecated and will be removed in 0.09. Use \*(L"\fIsearch()\fR\*(R"
instead. An example conversion is:
.PP
.Vb 1
\&  \->search_like({ foo => \*(Aqbar\*(Aq });
\&
\&  # Becomes
\&
\&  \->search({ foo => { like => \*(Aqbar\*(Aq } });
.Ve
.SS "slice"
.IX Subsection "slice"
.ie n .IP "Arguments: $first, $last" 4
.el .IP "Arguments: \f(CW$first\fR, \f(CW$last\fR" 4
.IX Item "Arguments: $first, $last"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) || @row_objs (list context)"
.PD
.PP
Returns a resultset or object list representing a subset of elements from the
resultset slice is called on. Indexes are from 0, i.e., to get the first
three records, call:
.PP
.Vb 1
\&  my ($one, $two, $three) = $rs\->slice(0, 2);
.Ve
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Returns the next element in the resultset (\f(CW\*(C`undef\*(C'\fR is there is none).
.PP
Can be used to efficiently iterate over records in the resultset:
.PP
.Vb 4
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search;
\&  while (my $cd = $rs\->next) {
\&    print $cd\->title;
\&  }
.Ve
.PP
Note that you need to store the resultset object, and call \f(CW\*(C`next\*(C'\fR on it.
Calling \f(CW\*(C`resultset(\*(AqTable\*(Aq)\->next\*(C'\fR repeatedly will always return the
first record from the resultset.
.SS "result_source"
.IX Subsection "result_source"
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
An accessor for the primary ResultSource object from which this ResultSet
is derived.
.SS "result_class"
.IX Subsection "result_class"
.ie n .IP "Arguments: $result_class?" 4
.el .IP "Arguments: \f(CW$result_class\fR?" 4
.IX Item "Arguments: $result_class?"
.PD 0
.ie n .IP "Return Value: $result_class" 4
.el .IP "Return Value: \f(CW$result_class\fR" 4
.IX Item "Return Value: $result_class"
.PD
.PP
An accessor for the class to use when creating row objects. Defaults to
\&\f(CW\*(C`result_source\->result_class\*(C'\fR \- which in most cases is the name of the
\&\*(L"table\*(R" class.
.PP
Note that changing the result_class will also remove any components
that were originally loaded in the source class via
\&\*(L"load_components\*(R" in DBIx::Class::ResultSource. Any overloaded methods
in the original source class will not run.
.SS "count"
.IX Subsection "count"
.ie n .IP "Arguments: $cond, \e%attrs??" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs??" 4
.IX Item "Arguments: $cond, %attrs??"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Performs an \s-1SQL\s0 \f(CW\*(C`COUNT\*(C'\fR with the same query as the resultset was built
with to find the number of elements. Passing arguments is equivalent to
\&\f(CW\*(C`$rs\->search ($cond, \e%attrs)\->count\*(C'\fR
.SS "count_rs"
.IX Subsection "count_rs"
.ie n .IP "Arguments: $cond, \e%attrs??" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs??" 4
.IX Item "Arguments: $cond, %attrs??"
.PD 0
.ie n .IP "Return Value: $count_rs" 4
.el .IP "Return Value: \f(CW$count_rs\fR" 4
.IX Item "Return Value: $count_rs"
.PD
.PP
Same as \*(L"count\*(R" but returns a DBIx::Class::ResultSetColumn object.
This can be very handy for subqueries:
.PP
.Vb 1
\&  \->search( { amount => $some_rs\->count_rs\->as_query } )
.Ve
.PP
As with regular resultsets the \s-1SQL\s0 query will be executed only after
the resultset is accessed via \*(L"next\*(R" or \*(L"all\*(R". That would return
the same single value obtainable via \*(L"count\*(R".
.SS "count_literal"
.IX Subsection "count_literal"
.ie n .IP "Arguments: $sql_fragment, @bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @bind_values"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Counts the results in a literal query. Equivalent to calling \*(L"search_literal\*(R"
with the passed arguments, then \*(L"count\*(R".
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @objects" 4
.el .IP "Return Value: \f(CW@objects\fR" 4
.IX Item "Return Value: @objects"
.PD
.PP
Returns all elements in the resultset.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the resultset's cursor, so you can iterate through the elements again.
Implicitly resets the storage cursor, so a subsequent \*(L"next\*(R" will trigger
another query.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $object | undef" 4
.el .IP "Return Value: \f(CW$object\fR | undef" 4
.IX Item "Return Value: $object | undef"
.PD
.PP
Resets the resultset and returns an object for the first result (or \f(CW\*(C`undef\*(C'\fR
if the resultset is empty).
.SS "update"
.IX Subsection "update"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.ie n .IP "Return Value: $storage_rv" 4
.el .IP "Return Value: \f(CW$storage_rv\fR" 4
.IX Item "Return Value: $storage_rv"
.PD
.PP
Sets the specified columns in the resultset to the supplied values in a
single query. Note that this will not run any accessor/set_column/update
triggers, nor will it update any row object instances derived from this
resultset (this includes the contents of the resultset cache
if any). See \*(L"update_all\*(R" if you need to execute any on-update
triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying
storage backend returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most
common case.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"update\*(R" does not process/deflate any of the values passed in.
This is unlike the corresponding \*(L"update\*(R" in DBIx::Class::Row. The user must
ensure manually that any value passed to this method will stringify to
something the \s-1RDBMS\s0 knows how to deal with. A notable example is the
handling of DateTime objects, for more info see:
\&\*(L"Formatting DateTime objects in queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "update_all"
.IX Subsection "update_all"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and updates them one at a time via
\&\*(L"update\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`update_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"update\*(R" will not.
.SS "delete"
.IX Subsection "delete"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $storage_rv" 4
.el .IP "Return Value: \f(CW$storage_rv\fR" 4
.IX Item "Return Value: $storage_rv"
.PD
.PP
Deletes the rows matching this resultset in a single query. Note that this
will not run any delete triggers, nor will it alter the
in_storage status of any row object instances
derived from this resultset (this includes the contents of the
resultset cache if any). See \*(L"delete_all\*(R" if you need to
execute any on-delete triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying storage backend
returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most common case.
.SS "delete_all"
.IX Subsection "delete_all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and deletes them one at a time via
\&\*(L"delete\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`delete_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"delete\*(R" will not.
.SS "populate"
.IX Subsection "populate"
.IP "Arguments: \e@data;" 4
.IX Item "Arguments: @data;"
.PP
Accepts either an arrayref of hashrefs or alternatively an arrayref of arrayrefs.
For the arrayref of hashrefs style each hashref should be a structure suitable
for submitting to a \f(CW$resultset\fR\->create(...) method.
.PP
In void context, \f(CW\*(C`insert_bulk\*(C'\fR in DBIx::Class::Storage::DBI is used
to insert the data, as this is a faster method.
.PP
Otherwise, each set of data is inserted into the database using
\&\*(L"create\*(R" in DBIx::Class::ResultSet, and the resulting objects are
accumulated into an array. The array itself, or an array reference
is returned depending on scalar or list context.
.PP
Example:  Assuming an Artist Class that has many CDs Classes relating:
.PP
.Vb 1
\&  my $Artist_rs = $schema\->resultset("Artist");
\&
\&  ## Void Context Example
\&  $Artist_rs\->populate([
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&     { artistid => 5, name => \*(AqAngsty\-Whiny Girl\*(Aq, cds => [
\&        { title => \*(AqMy parents sold me to a record company\*(Aq, year => 2005 },
\&        { title => \*(AqWhy Am I So Ugly?\*(Aq, year => 2006 },
\&        { title => \*(AqI Got Surgery and am now Popular\*(Aq, year => 2007 }
\&      ],
\&     },
\&  ]);
\&
\&  ## Array Context Example
\&  my ($ArtistOne, $ArtistTwo, $ArtistThree) = $Artist_rs\->populate([
\&    { name => "Artist One"},
\&    { name => "Artist Two"},
\&    { name => "Artist Three", cds=> [
\&    { title => "First CD", year => 2007},
\&    { title => "Second CD", year => 2008},
\&  ]}
\&  ]);
\&
\&  print $ArtistOne\->name; ## response is \*(AqArtist One\*(Aq
\&  print $ArtistThree\->cds\->count ## reponse is \*(Aq2\*(Aq
.Ve
.PP
For the arrayref of arrayrefs style,  the first element should be a list of the
fieldsnames to which the remaining elements are rows being inserted.  For
example:
.PP
.Vb 6
\&  $Arstist_rs\->populate([
\&    [qw/artistid name/],
\&    [100, \*(AqA Formally Unknown Singer\*(Aq],
\&    [101, \*(AqA singer that jumped the shark two albums ago\*(Aq],
\&    [102, \*(AqAn actually cool singer\*(Aq],
\&  ]);
.Ve
.PP
Please note an important effect on your data when choosing between void and
wantarray context. Since void context goes straight to \f(CW\*(C`insert_bulk\*(C'\fR in
DBIx::Class::Storage::DBI this will skip any component that is overriding
\&\f(CW\*(C`insert\*(C'\fR.  So if you are using something like DBIx-Class-UUIDColumns to
create primary keys for you, you will find that your PKs are empty.  In this
case you will have to use the wantarray context in order to create those
values.
.SS "pager"
.IX Subsection "pager"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $pager" 4
.el .IP "Return Value: \f(CW$pager\fR" 4
.IX Item "Return Value: $pager"
.PD
.PP
Return Value a Data::Page object for the current resultset. Only makes
sense for queries with a \f(CW\*(C`page\*(C'\fR attribute.
.PP
To get the full count of entries for a paged resultset, call
\&\f(CW\*(C`total_entries\*(C'\fR on the Data::Page object.
.SS "page"
.IX Subsection "page"
.ie n .IP "Arguments: $page_number" 4
.el .IP "Arguments: \f(CW$page_number\fR" 4
.IX Item "Arguments: $page_number"
.PD 0
.ie n .IP "Return Value: $rs" 4
.el .IP "Return Value: \f(CW$rs\fR" 4
.IX Item "Return Value: $rs"
.PD
.PP
Returns a resultset for the \f(CW$page_number\fR page of the resultset on which page
is called, where each page contains a number of rows equal to the 'rows'
attribute set on the resultset (10 by default).
.SS "new_result"
.IX Subsection "new_result"
.IP "Arguments: \e%vals" 4
.IX Item "Arguments: %vals"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
Creates a new row object in the resultset's result class and returns
it. The row is not inserted into the database at this point, call
\&\*(L"insert\*(R" in DBIx::Class::Row to do that. Calling \*(L"in_storage\*(R" in DBIx::Class::Row
will tell you whether the row object has been inserted or not.
.PP
Passes the hashref of input on to \*(L"new\*(R" in DBIx::Class::Row.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind\fR ]" 4
.IX Item "Return Value: [ $sql, @bind ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "find_or_new"
.IX Subsection "find_or_new"
.IP "Arguments: \e%vals, \e%attrs?" 4
.IX Item "Arguments: %vals, %attrs?"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
.Vb 2
\&  my $artist = $schema\->resultset(\*(AqArtist\*(Aq)\->find_or_new(
\&    { artist => \*(Aqfred\*(Aq }, { key => \*(Aqartists\*(Aq });
\&
\&  $cd\->cd_to_producer\->find_or_new({ producer => $producer },
\&                                   { key => \*(Aqprimary });
.Ve
.PP
Find an existing record from this resultset using \*(L"find\*(R". if none exists,
instantiate a new result object and return it. The object will not be saved
into your storage until you call \*(L"insert\*(R" in DBIx::Class::Row on it.
.PP
You most likely want this method when looking for existing rows using a unique
constraint that is not the primary key, or looking for related rows.
.PP
If you want objects to be saved immediately, use \*(L"find_or_create\*(R" instead.
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.SS "create"
.IX Subsection "create"
.IP "Arguments: \e%vals" 4
.IX Item "Arguments: %vals"
.PD 0
.ie n .IP "Return Value: a DBIx::Class::Row $object" 4
.el .IP "Return Value: a DBIx::Class::Row \f(CW$object\fR" 4
.IX Item "Return Value: a DBIx::Class::Row $object"
.PD
.PP
Attempt to create a single new row or a row with multiple related rows
in the table represented by the resultset (and related tables). This
will not check for duplicate rows before inserting, use
\&\*(L"find_or_create\*(R" to do that.
.PP
To create one row for this resultset, pass a hashref of key/value
pairs representing the columns of the table and the values you wish to
store. If the appropriate relationships are set up, foreign key fields
can also be passed an object representing the foreign row, and the
value will be set to its primary key.
.PP
To create related objects, pass a hashref of related-object column values
\&\fBkeyed on the relationship name\fR. If the relationship is of type \f(CW\*(C`multi\*(C'\fR
(\*(L"has_many\*(R" in DBIx::Class::Relationship) \- pass an arrayref of hashrefs.
The process will correctly identify columns holding foreign keys, and will
transparently populate them from the keys of the corresponding relation.
This can be applied recursively, and will work correctly for a structure
with an arbitrary depth and width, as long as the relationships actually
exists and the correct column data has been supplied.
.PP
Instead of hashrefs of plain related data (key/value pairs), you may
also pass new or inserted objects. New objects (not inserted yet, see
\&\*(L"new\*(R"), will be inserted into their appropriate tables.
.PP
Effectively a shortcut for \f(CW\*(C`\->new_result(\e%vals)\->insert\*(C'\fR.
.PP
Example of creating a new row.
.PP
.Vb 4
\&  $person_rs\->create({
\&    name=>"Some Person",
\&    email=>"somebody@someplace.com"
\&  });
.Ve
.PP
Example of creating a new row and also creating rows in a related \f(CW\*(C`has_many\*(C'\fR
or \f(CW\*(C`has_one\*(C'\fR resultset.  Note Arrayref.
.PP
.Vb 7
\&  $artist_rs\->create(
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&  );
.Ve
.PP
Example of creating a new row and also creating a row in a related
\&\f(CW\*(C`belongs_to\*(C'\fR resultset. Note Hashref.
.PP
.Vb 7
\&  $cd_rs\->create({
\&    title=>"Music for Silly Walks",
\&    year=>2000,
\&    artist => {
\&      name=>"Silly Musician",
\&    }
\&  });
.Ve
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
When subclassing ResultSet never attempt to override this method. Since
it is a simple shortcut for \f(CW\*(C`$self\->new_result($attrs)\->insert\*(C'\fR, a
lot of the internals simply never call it, so your override will be
bypassed more often than not. Override either new
or insert depending on how early in the
\&\*(L"create\*(R" process you need to intervene.
.SS "find_or_create"
.IX Subsection "find_or_create"
.IP "Arguments: \e%vals, \e%attrs?" 4
.IX Item "Arguments: %vals, %attrs?"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
.Vb 2
\&  $cd\->cd_to_producer\->find_or_create({ producer => $producer },
\&                                      { key => \*(Aqprimary\*(Aq });
.Ve
.PP
Tries to find a record based on its primary key or unique constraints; if none
is found, creates one and returns that instead.
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
.Ve
.PP
Also takes an optional \f(CW\*(C`key\*(C'\fR attribute, to search by a specific key or unique
constraint. For example:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Because \fIfind_or_create()\fR reads from the database and then
possibly inserts based on the result, this method is subject to a race
condition. Another process could create a record in the table after
the find has completed and before the create has started. To avoid
this problem, use \fIfind_or_create()\fR inside a transaction.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"update_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.PP
If you need to know if an existing row was found or a new one created use
\&\*(L"find_or_new\*(R" and \*(L"in_storage\*(R" in DBIx::Class::Row instead. Don't forget
to call \*(L"insert\*(R" in DBIx::Class::Row to save the newly created row to the
database!
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_new({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
\&
\&  if( $cd\->in_storage ) {
\&      # do some stuff
\&      $cd\->insert;
\&  }
.Ve
.SS "update_or_create"
.IX Subsection "update_or_create"
.ie n .IP "Arguments: \e%col_values, { key => $unique_constraint }?" 4
.el .IP "Arguments: \e%col_values, { key => \f(CW$unique_constraint\fR }?" 4
.IX Item "Arguments: %col_values, { key => $unique_constraint }?"
.PD 0
.ie n .IP "Return Value: $row_object" 4
.el .IP "Return Value: \f(CW$row_object\fR" 4
.IX Item "Return Value: $row_object"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_create({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_create\*(R", but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_values)\*(C'\fR.
.PP
Takes an optional \f(CW\*(C`key\*(C'\fR attribute to search on a specific unique constraint.
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  $cd\->cd_to_producer\->update_or_create({
\&    producer => $producer,
\&    name => \*(Aqharry\*(Aq,
\&  }, {
\&    key => \*(Aqprimary\*(Aq,
\&  });
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"find_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.PP
If you need to know if an existing row was updated or a new one created use
\&\*(L"update_or_new\*(R" and \*(L"in_storage\*(R" in DBIx::Class::Row instead. Don't forget
to call \*(L"insert\*(R" in DBIx::Class::Row to save the newly created row to the
database!
.PP
.Vb 8
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_new(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  if( $cd\->in_storage ) {
\&      # do some stuff
\&      $cd\->insert;
\&  }
.Ve
.SS "update_or_new"
.IX Subsection "update_or_new"
.ie n .IP "Arguments: \e%col_values, { key => $unique_constraint }?" 4
.el .IP "Arguments: \e%col_values, { key => \f(CW$unique_constraint\fR }?" 4
.IX Item "Arguments: %col_values, { key => $unique_constraint }?"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_new({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_new\*(R" but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_values)\*(C'\fR.
.PP
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_new(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  if ($cd\->in_storage) {
\&      # the cd was updated
\&  }
\&  else {
\&      # the cd is not yet in the database, let\*(Aqs insert it
\&      $cd\->insert;
\&  }
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R", \*(L"find_or_create\*(R" and \*(L"find_or_new\*(R".
.SS "get_cache"
.IX Subsection "get_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \e@cache_objects | undef" 4
.IX Item "Return Value: @cache_objects | undef"
.PD
.PP
Gets the contents of the cache for the resultset, if the cache is set.
.PP
The cache is populated either by using the \*(L"prefetch\*(R" attribute to
\&\*(L"search\*(R" or by calling \*(L"set_cache\*(R".
.SS "set_cache"
.IX Subsection "set_cache"
.IP "Arguments: \e@cache_objects" 4
.IX Item "Arguments: @cache_objects"
.PD 0
.IP "Return Value: \e@cache_objects" 4
.IX Item "Return Value: @cache_objects"
.PD
.PP
Sets the contents of the cache for the resultset. Expects an arrayref
of objects of the same class as those produced by the resultset. Note that
if the cache is set the resultset will return the cached objects rather
than re-querying the database even if the cache attr is not set.
.PP
The contents of the cache can also be populated by using the
\&\*(L"prefetch\*(R" attribute to \*(L"search\*(R".
.SS "clear_cache"
.IX Subsection "clear_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: undef" 4
.IX Item "Return Value: undef"
.PD
.PP
Clears the cache for the resultset.
.SS "is_paged"
.IX Subsection "is_paged"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: true, if the resultset has been paginated" 4
.IX Item "Return Value: true, if the resultset has been paginated"
.PD
.SS "is_ordered"
.IX Subsection "is_ordered"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: true, if the resultset has been ordered with ""order_by""." 4
.el .IP "Return Value: true, if the resultset has been ordered with \f(CWorder_by\fR." 4
.IX Item "Return Value: true, if the resultset has been ordered with order_by."
.PD
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $relationship_name" 4
.el .IP "Arguments: \f(CW$relationship_name\fR" 4
.IX Item "Arguments: $relationship_name"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a related resultset for the supplied relationship name.
.PP
.Vb 1
\&  $artist_rs = $schema\->resultset(\*(AqCD\*(Aq)\->related_resultset(\*(AqArtist\*(Aq);
.Ve
.SS "current_source_alias"
.IX Subsection "current_source_alias"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $source_alias" 4
.el .IP "Return Value: \f(CW$source_alias\fR" 4
.IX Item "Return Value: $source_alias"
.PD
.PP
Returns the current table alias for the result source this resultset is built
on, that will be used in the \s-1SQL\s0 query. Usually it is \f(CW\*(C`me\*(C'\fR.
.PP
Currently the source alias that refers to the result set returned by a
\&\*(L"search\*(R"/\*(L"find\*(R" family method depends on how you got to the resultset: it's
\&\f(CW\*(C`me\*(C'\fR by default, but eg. \*(L"search_related\*(R" aliases it to the related result
source name (and keeps \f(CW\*(C`me\*(C'\fR referring to the original result set). The long
term goal is to make DBIx::Class always alias the current resultset as \f(CW\*(C`me\*(C'\fR
(and make this method unnecessary).
.PP
Thus it's currently necessary to use this method in predefined queries (see
\&\*(L"Predefined searches\*(R" in DBIx::Class::Manual::Cookbook) when referring to the
source alias of the current result set:
.PP
.Vb 3
\&  # in a result set class
\&  sub modified_by {
\&    my ($self, $user) = @_;
\&
\&    my $me = $self\->current_source_alias;
\&
\&    return $self\->search({
\&      "$me.modified" => $user\->id,
\&    });
\&  }
.Ve
.SS "as_subselect_rs"
.IX Subsection "as_subselect_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Act as a barrier to \s-1SQL\s0 symbols.  The resultset provided will be made into a
\&\*(L"virtual view\*(R" by including it as a subquery within the from clause.  From this
point on, any joined tables are inaccessible to \->search on the resultset (as if
it were simply where-filtered without joins).  For example:
.PP
.Vb 1
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search({\*(Aqx.name\*(Aq => \*(Aqabc\*(Aq},{ join => \*(Aqx\*(Aq });
\&
\& # \*(Aqx\*(Aq now pollutes the query namespace
\&
\& # So the following works as expected
\& my $ok_rs = $rs\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # But this doesn\*(Aqt: instead of finding a \*(AqBar\*(Aq related to two x rows (abc and
\& # def) we look for one row with contradictory terms and join in another table
\& # (aliased \*(Aqx_2\*(Aq) which we never use
\& my $broken_rs = $rs\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
\&
\& my $rs2 = $rs\->as_subselect_rs;
\&
\& # doesn\*(Aqt work \- \*(Aqx\*(Aq is no longer accessible in $rs2, having been sealed away
\& my $not_joined_rs = $rs2\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # works as expected: finds a \*(Aqtable\*(Aq row related to two x rows (abc and def)
\& my $correctly_joined_rs = $rs2\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
.Ve
.PP
Another example of when one might use this would be to select a subset of
columns in a group by clause:
.PP
.Vb 5
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search(undef, {
\&   group_by => [qw{ id foo_id baz_id }],
\& })\->as_subselect_rs\->search(undef, {
\&   columns => [qw{ id foo_id }]
\& });
.Ve
.PP
In the above example normally columns would have to be equal to the group by,
but because we isolated the group by into a subselect the above works.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Attributes are used to refine a ResultSet in various ways when
searching for data. They can be passed to any method which takes an
\&\f(CW\*(C`\e%attrs\*(C'\fR argument. See \*(L"search\*(R", \*(L"search_rs\*(R", \*(L"find\*(R",
\&\*(L"count\*(R".
.PP
These are in no particular order:
.SS "order_by"
.IX Subsection "order_by"
.ie n .IP "Value: ( $order_by | \e@order_by | \e%order_by )" 4
.el .IP "Value: ( \f(CW$order_by\fR | \e@order_by | \e%order_by )" 4
.IX Item "Value: ( $order_by | @order_by | %order_by )"
.PP
Which column(s) to order the results by.
.PP
[The full list of suitable values is documented in
\&\*(L"\s-1ORDER\s0 \s-1BY\s0 \s-1CLAUSES\s0\*(R" in SQL::Abstract; the following is a summary of
common options.]
.PP
If a single column name, or an arrayref of names is supplied, the
argument is passed through directly to \s-1SQL\s0. The hashref syntax allows
for connection-agnostic specification of ordering direction:
.PP
.Vb 1
\& For descending order:
\&
\&  order_by => { \-desc => [qw/col1 col2 col3/] }
\&
\& For explicit ascending order:
\&
\&  order_by => { \-asc => \*(Aqcol\*(Aq }
.Ve
.PP
The old scalarref syntax (i.e. order_by => \e'year \s-1DESC\s0') is still
supported, although you are strongly encouraged to use the hashref
syntax as outlined above.
.SS "columns"
.IX Subsection "columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Shortcut to request a particular set of columns to be retrieved. Each
column spec may be a string (a table column name), or a hash (in which
case the key is the \f(CW\*(C`as\*(C'\fR value, and the value is used as the \f(CW\*(C`select\*(C'\fR
expression). Adds \f(CW\*(C`me.\*(C'\fR onto the start of any column without a \f(CW\*(C`.\*(C'\fR in
it and sets \f(CW\*(C`select\*(C'\fR from that, then auto-populates \f(CW\*(C`as\*(C'\fR from
\&\f(CW\*(C`select\*(C'\fR as normal. (You may also use the \f(CW\*(C`cols\*(C'\fR attribute, as in
earlier versions of \s-1DBIC\s0.)
.PP
Essentially \f(CW\*(C`columns\*(C'\fR does the same as \*(L"select\*(R" and \*(L"as\*(R".
.PP
.Vb 1
\&    columns => [ \*(Aqfoo\*(Aq, { bar => \*(Aqbaz\*(Aq } ]
.Ve
.PP
is the same as
.PP
.Vb 2
\&    select => [qw/foo baz/],
\&    as => [qw/foo bar/]
.Ve
.SS "+columns"
.IX Subsection "+columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Indicates additional columns to be selected from storage. Works the same
as \*(L"columns\*(R" but adds columns to the selection. (You may also use the
\&\f(CW\*(C`include_columns\*(C'\fR attribute, as in earlier versions of \s-1DBIC\s0). For
example:\-
.PP
.Vb 4
\&  $schema\->resultset(\*(AqCD\*(Aq)\->search(undef, {
\&    \*(Aq+columns\*(Aq => [\*(Aqartist.name\*(Aq],
\&    join => [\*(Aqartist\*(Aq]
\&  });
.Ve
.PP
would return all CDs and include a 'name' column to the information
passed to object inflation. Note that the 'artist' is the name of the
column (or relationship) accessor, and 'name' is the name of the column
accessor in the related table.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+columns' when defining the attribute.
Not doing so causes Perl to incorrectly interpret +columns as a bareword with a
unary plus operator before it.
.SS "include_columns"
.IX Subsection "include_columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Deprecated.  Acts as a synonym for \*(L"+columns\*(R" for backward compatibility.
.SS "select"
.IX Subsection "select"
.IP "Value: \e@select_columns" 4
.IX Item "Value: @select_columns"
.PP
Indicates which columns should be selected from the storage. You can use
column names, or in the case of \s-1RDBMS\s0 back ends, function or stored procedure
names:
.PP
.Vb 7
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ]
\&  });
\&
\&  # Equivalent SQL
\&  SELECT name, COUNT( employeeid ), MAX( LENGTH( name ) ) AS longest_name FROM employee
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR You will almost always need a corresponding \*(L"as\*(R" attribute when you
use \*(L"select\*(R", to instruct DBIx::Class how to store the result of the column.
Also note that the \*(L"as\*(R" attribute has nothing to do with the SQL-side '\s-1AS\s0'
identifier aliasing. You can however alias a function, so you can use it in
e.g. an \f(CW\*(C`ORDER BY\*(C'\fR clause. This is done via the \f(CW\*(C`\-as\*(C'\fR \fBselect function
attribute\fR supplied as shown in the example above.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+select'/'+as' when defining the attributes.
Not doing so causes Perl to incorrectly interpret them as a bareword with a
unary plus operator before it.
.SS "+select"
.IX Subsection "+select"
.RS 4
Indicates additional columns to be selected from storage.  Works the same as
\&\*(L"select\*(R" but adds columns to the default selection, instead of specifying
an explicit list.
.RE
.SS "+as"
.IX Subsection "+as"
.RS 4
Indicates additional column names for those added via \*(L"+select\*(R". See \*(L"as\*(R".
.RE
.SS "as"
.IX Subsection "as"
.IP "Value: \e@inflation_names" 4
.IX Item "Value: @inflation_names"
.PP
Indicates column names for object inflation. That is \*(L"as\*(R" indicates the
slot name in which the column value will be stored within the
Row object. The value will then be accessible via this
identifier by the \f(CW\*(C`get_column\*(C'\fR method (or via the object accessor \fBif one
with the same name already exists\fR) as shown below. The \*(L"as\*(R" attribute has
\&\fBnothing to do\fR with the SQL-side \f(CW\*(C`AS\*(C'\fR. See \*(L"select\*(R" for details.
.PP
.Vb 12
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ],
\&    as => [qw/
\&      name
\&      employee_count
\&      max_name_length
\&    /],
\&  });
.Ve
.PP
If the object against which the search is performed already has an accessor
matching a column name specified in \f(CW\*(C`as\*(C'\fR, the value can be retrieved using
the accessor as normal:
.PP
.Vb 1
\&  my $name = $employee\->name();
.Ve
.PP
If on the other hand an accessor does not exist in the object, you need to
use \f(CW\*(C`get_column\*(C'\fR instead:
.PP
.Vb 1
\&  my $employee_count = $employee\->get_column(\*(Aqemployee_count\*(Aq);
.Ve
.PP
You can create your own accessors if required \- see
DBIx::Class::Manual::Cookbook for details.
.SS "join"
.IX Subsection "join"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
Contains a list of relationships that should be joined for this query.  For
example:
.PP
.Vb 5
\&  # Get CDs by Nine Inch Nails
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    { \*(Aqartist.name\*(Aq => \*(AqNine Inch Nails\*(Aq },
\&    { join => \*(Aqartist\*(Aq }
\&  );
.Ve
.PP
Can also contain a hash reference to refer to the other relation's relations.
For example:
.PP
.Vb 7
\&  package MyApp::Schema::Track;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqtrack\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/trackid cd position title/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqtrackid\*(Aq);
\&  _\|_PACKAGE_\|_\->belongs_to(cd => \*(AqMyApp::Schema::CD\*(Aq);
\&  1;
\&
\&  # In your application
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&    { \*(Aqtrack.title\*(Aq => \*(AqTeardrop\*(Aq },
\&    {
\&      join     => { cd => \*(Aqtrack\*(Aq },
\&      order_by => \*(Aqartist.name\*(Aq,
\&    }
\&  );
.Ve
.PP
You need to use the relationship (not the table) name in  conditions,
because they are aliased as such. The current table is aliased as \*(L"me\*(R", so
you need to use me.column_name in order to avoid ambiguity. For example:
.PP
.Vb 8
\&  # Get CDs from 1984 with a \*(AqFoo\*(Aq track
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    {
\&      \*(Aqme.year\*(Aq => 1984,
\&      \*(Aqtracks.name\*(Aq => \*(AqFoo\*(Aq
\&    },
\&    { join => \*(Aqtracks\*(Aq }
\&  );
.Ve
.PP
If the same join is supplied twice, it will be aliased to <rel>_2 (and
similarly for a third time). For e.g.
.PP
.Vb 6
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&    \*(Aqcds.title\*(Aq   => \*(AqDown to Earth\*(Aq,
\&    \*(Aqcds_2.title\*(Aq => \*(AqPopular\*(Aq,
\&  }, {
\&    join => [ qw/cds cds/ ],
\&  });
.Ve
.PP
will return a set of all artists that have both a cd with title 'Down
to Earth' and a cd with title 'Popular'.
.PP
If you want to fetch related objects from other tables as well, see \f(CW\*(C`prefetch\*(C'\fR
below.
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.SS "prefetch"
.IX Subsection "prefetch"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
Contains one or more relationships that should be fetched along with
the main query (when they are accessed afterwards the data will
already be available, without extra queries to the database).  This is
useful for when you know you will need the related objects, because it
saves at least one query:
.PP
.Vb 8
\&  my $rs = $schema\->resultset(\*(AqTag\*(Aq)\->search(
\&    undef,
\&    {
\&      prefetch => {
\&        cd => \*(Aqartist\*(Aq
\&      }
\&    }
\&  );
.Ve
.PP
The initial search results in \s-1SQL\s0 like the following:
.PP
.Vb 3
\&  SELECT tag.*, cd.*, artist.* FROM tag
\&  JOIN cd ON tag.cd = cd.cdid
\&  JOIN artist ON cd.artist = artist.artistid
.Ve
.PP
DBIx::Class has no need to go back to the database when we access the
\&\f(CW\*(C`cd\*(C'\fR or \f(CW\*(C`artist\*(C'\fR relationships, which saves us two \s-1SQL\s0 statements in this
case.
.PP
Simple prefetches will be joined automatically, so there is no need
for a \f(CW\*(C`join\*(C'\fR attribute in the above search.
.PP
\&\*(L"prefetch\*(R" can be used with the any of the relationship types and
multiple prefetches can be specified together. Below is a more complex
example that prefetches a \s-1CD\s0's artist, its liner notes (if present),
the cover image, the tracks on that cd, and the guests on those
tracks.
.PP
.Vb 5
\& # Assuming:
\& My::Schema::CD\->belongs_to( artist      => \*(AqMy::Schema::Artist\*(Aq     );
\& My::Schema::CD\->might_have( liner_note  => \*(AqMy::Schema::LinerNotes\*(Aq );
\& My::Schema::CD\->has_one(    cover_image => \*(AqMy::Schema::Artwork\*(Aq    );
\& My::Schema::CD\->has_many(   tracks      => \*(AqMy::Schema::Track\*(Aq      );
\&
\& My::Schema::Artist\->belongs_to( record_label => \*(AqMy::Schema::RecordLabel\*(Aq );
\&
\& My::Schema::Track\->has_many( guests => \*(AqMy::Schema::Guest\*(Aq );
\&
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   undef,
\&   {
\&     prefetch => [
\&       { artist => \*(Aqrecord_label\*(Aq},  # belongs_to => belongs_to
\&       \*(Aqliner_note\*(Aq,                 # might_have
\&       \*(Aqcover_image\*(Aq,                # has_one
\&       { tracks => \*(Aqguests\*(Aq },       # has_many => has_many
\&     ]
\&   }
\& );
.Ve
.PP
This will produce \s-1SQL\s0 like the following:
.PP
.Vb 10
\& SELECT cd.*, artist.*, record_label.*, liner_note.*, cover_image.*,
\&        tracks.*, guests.*
\&   FROM cd me
\&   JOIN artist artist
\&     ON artist.artistid = me.artistid
\&   JOIN record_label record_label
\&     ON record_label.labelid = artist.labelid
\&   LEFT JOIN track tracks
\&     ON tracks.cdid = me.cdid
\&   LEFT JOIN guest guests
\&     ON guests.trackid = track.trackid
\&   LEFT JOIN liner_notes liner_note
\&     ON liner_note.cdid = me.cdid
\&   JOIN cd_artwork cover_image
\&     ON cover_image.cdid = me.cdid
\& ORDER BY tracks.cd
.Ve
.PP
Now the \f(CW\*(C`artist\*(C'\fR, \f(CW\*(C`record_label\*(C'\fR, \f(CW\*(C`liner_note\*(C'\fR, \f(CW\*(C`cover_image\*(C'\fR,
\&\f(CW\*(C`tracks\*(C'\fR, and \f(CW\*(C`guests\*(C'\fR of the \s-1CD\s0 will all be available through the
relationship accessors without the need for additional queries to the
database.
.PP
However, there is one caveat to be observed: it can be dangerous to
prefetch more than one has_many
relationship on a given level. e.g.:
.PP
.Vb 9
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   undef,
\&   {
\&     prefetch => [
\&       \*(Aqtracks\*(Aq,                         # has_many
\&       { cd_to_producer => \*(Aqproducer\*(Aq }, # has_many => belongs_to (i.e. m2m)
\&     ]
\&   }
\& );
.Ve
.PP
In fact, \f(CW\*(C`DBIx::Class\*(C'\fR will emit the following warning:
.PP
.Vb 3
\& Prefetching multiple has_many rels tracks and cd_to_producer at top
\& level will explode the number of row objects retrievable via \->next
\& or \->all. Use at your own risk.
.Ve
.PP
The collapser currently can't identify duplicate tuples for multiple
has_many relationships and as a
result the second has_many
relation could contain redundant objects.
.PP
\fIUsing \*(L"prefetch\*(R" with \*(L"join\*(R"\fR
.IX Subsection "Using prefetch with join"
.PP
\&\*(L"prefetch\*(R" implies a \*(L"join\*(R" with the equivalent argument, and is
properly merged with any existing \*(L"join\*(R" specification. So the
following:
.PP
.Vb 7
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   {\*(Aqrecord_label.name\*(Aq => \*(AqMusic Product Ltd.\*(Aq},
\&   {
\&     join     => {artist => \*(Aqrecord_label\*(Aq},
\&     prefetch => \*(Aqartist\*(Aq,
\&   }
\& );
.Ve
.PP
\&... will work, searching on the record label's name, but only
prefetching the \f(CW\*(C`artist\*(C'\fR.
.PP
\fIUsing \*(L"prefetch\*(R" with \*(L"select\*(R" / \*(L"+select\*(R" / \*(L"as\*(R" / \*(L"+as\*(R"\fR
.IX Subsection "Using prefetch with select / +select / as / +as"
.PP
\&\*(L"prefetch\*(R" implies a \*(L"+select\*(R"/\*(L"+as\*(R" with the fields of the
prefetched relations.  So given:
.PP
.Vb 8
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   undef,
\&   {
\&     select   => [\*(Aqcd.title\*(Aq],
\&     as       => [\*(Aqcd_title\*(Aq],
\&     prefetch => \*(Aqartist\*(Aq,
\&   }
\& );
.Ve
.PP
The \*(L"select\*(R" becomes: \f(CW\*(Aqcd.title\*(Aq, \*(Aqartist.*\*(Aq\fR and the \*(L"as\*(R"
becomes: \f(CW\*(Aqcd_title\*(Aq, \*(Aqartist.*\*(Aq\fR.
.PP
\fI\s-1CAVEATS\s0\fR
.IX Subsection "CAVEATS"
.PP
Prefetch does a lot of deep magic. As such, it may not behave exactly
as you might expect.
.IP "\(bu" 4
Prefetch uses the \*(L"cache\*(R" to populate the prefetched relationships. This
may or may not be what you want.
.IP "\(bu" 4
If you specify a condition on a prefetched relationship, \s-1ONLY\s0 those
rows that match the prefetched condition will be fetched into that relationship.
This means that adding prefetch to a \fIsearch()\fR \fBmay alter\fR what is returned by
traversing a relationship. So, if you have \f(CW\*(C`Artist\->has_many(CDs)\*(C'\fR and you do
.Sp
.Vb 5
\&  my $artist_rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&      \*(Aqcds.year\*(Aq => 2008,
\&  }, {
\&      join => \*(Aqcds\*(Aq,
\&  });
\&
\&  my $count = $artist_rs\->first\->cds\->count;
\&
\&  my $artist_rs_prefetch = $artist_rs\->search( {}, { prefetch => \*(Aqcds\*(Aq } );
\&
\&  my $prefetch_count = $artist_rs_prefetch\->first\->cds\->count;
\&
\&  cmp_ok( $count, \*(Aq==\*(Aq, $prefetch_count, "Counts should be the same" );
.Ve
.Sp
that \fIcmp_ok()\fR may or may not pass depending on the datasets involved. This
behavior may or may not survive the 0.09 transition.
.SS "page"
.IX Subsection "page"
.ie n .IP "Value: $page" 4
.el .IP "Value: \f(CW$page\fR" 4
.IX Item "Value: $page"
.PP
Makes the resultset paged and specifies the page to retrieve. Effectively
identical to creating a non-pages resultset and then calling \->page($page)
on it.
.PP
If \*(L"rows\*(R" attribute is not specified it defaults to 10 rows per page.
.PP
When you have a paged resultset, \*(L"count\*(R" will only return the number
of rows in the page. To get the total, use the \*(L"pager\*(R" and call
\&\f(CW\*(C`total_entries\*(C'\fR on it.
.SS "rows"
.IX Subsection "rows"
.ie n .IP "Value: $rows" 4
.el .IP "Value: \f(CW$rows\fR" 4
.IX Item "Value: $rows"
.PP
Specifies the maximum number of rows for direct retrieval or the number of
rows per page if the page attribute or method is used.
.SS "offset"
.IX Subsection "offset"
.ie n .IP "Value: $offset" 4
.el .IP "Value: \f(CW$offset\fR" 4
.IX Item "Value: $offset"
.PP
Specifies the (zero-based) row number for the  first row to be returned, or the
of the first row of the first page if paging is used.
.SS "software_limit"
.IX Subsection "software_limit"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
When combined with \*(L"rows\*(R" and/or \*(L"offset\*(R" the generated \s-1SQL\s0 will not
include any limit dialect stanzas. Instead the entire result will be selected
as if no limits were specified, and \s-1DBIC\s0 will perform the limit locally, by
artificially advancing and finishing the resulting \*(L"cursor\*(R".
.PP
This is the recommended way of performing resultset limiting when no sane \s-1RDBMS\s0
implementation is available (e.g.
Sybase \s-1ASE\s0 using the
Generic Sub Query hack)
.SS "group_by"
.IX Subsection "group_by"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
A arrayref of columns to group by. Can include columns of joined tables.
.PP
.Vb 1
\&  group_by => [qw/ column1 column2 ... /]
.Ve
.SS "having"
.IX Subsection "having"
.ie n .IP "Value: $condition" 4
.el .IP "Value: \f(CW$condition\fR" 4
.IX Item "Value: $condition"
.PP
\&\s-1HAVING\s0 is a select statement attribute that is applied between \s-1GROUP\s0 \s-1BY\s0 and
\&\s-1ORDER\s0 \s-1BY\s0. It is applied to the after the grouping calculations have been
done.
.PP
.Vb 1
\&  having => { \*(Aqcount_employee\*(Aq => { \*(Aq>=\*(Aq, 100 } }
.Ve
.PP
or with an in-place function in which case literal \s-1SQL\s0 is required:
.PP
.Vb 1
\&  having => \e[ \*(Aqcount(employee) >= ?\*(Aq, [ count => 100 ] ]
.Ve
.SS "distinct"
.IX Subsection "distinct"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
Set to 1 to group by all columns. If the resultset already has a group_by
attribute, this setting is ignored and an appropriate warning is issued.
.SS "where"
.IX Subsection "where"
.RS 4
Adds to the \s-1WHERE\s0 clause.
.Sp
.Vb 2
\&  # only return rows WHERE deleted IS NULL for all searches
\&  _\|_PACKAGE_\|_\->resultset_attributes({ where => { deleted => undef } }); )
.Ve
.Sp
Can be overridden by passing \f(CW\*(C`{ where => undef }\*(C'\fR as an attribute
to a resultset.
.Sp
For more complicated where clauses see \*(L"\s-1WHERE\s0 \s-1CLAUSES\s0\*(R" in SQL::Abstract.
.RE
.SS "cache"
.IX Subsection "cache"
Set to 1 to cache search results. This prevents extra \s-1SQL\s0 queries if you
revisit rows in your ResultSet:
.PP
.Vb 1
\&  my $resultset = $schema\->resultset(\*(AqArtist\*(Aq)\->search( undef, { cache => 1 } );
\&
\&  while( my $artist = $resultset\->next ) {
\&    ... do stuff ...
\&  }
\&
\&  $rs\->first; # without cache, this would issue a query
.Ve
.PP
By default, searches are not cached.
.PP
For more examples of using these attributes, see
DBIx::Class::Manual::Cookbook.
.SS "for"
.IX Subsection "for"
.IP "Value: ( 'update' | 'shared' )" 4
.IX Item "Value: ( 'update' | 'shared' )"
.PP
Set to 'update' for a \s-1SELECT\s0 ... \s-1FOR\s0 \s-1UPDATE\s0 or 'shared' for a \s-1SELECT\s0
\&... \s-1FOR\s0 \s-1SHARED\s0.
                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSet5.18.3pm               0100644 0001750 0001750 00000236754 12566242400 025626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSet 3"
.TH DBIx::Class::ResultSet 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSet \- Represents a query used for fetching a set of results.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  my $users_rs = $schema\->resultset(\*(AqUser\*(Aq);
\&  while( $user = $users_rs\->next) {
\&    print $user\->username;
\&  }
\&
\&  my $registered_users_rs = $schema\->resultset(\*(AqUser\*(Aq)\->search({ registered => 1 });
\&  my @cds_in_2005 = $schema\->resultset(\*(AqCD\*(Aq)\->search({ year => 2005 })\->all();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSet is an object which stores a set of conditions representing
a query. It is the backbone of DBIx::Class (i.e. the really
important/useful bit).
.PP
No \s-1SQL\s0 is executed on the database when a ResultSet is created, it
just stores all the conditions needed to create the query.
.PP
A basic ResultSet representing the data of an entire table is returned
by calling \f(CW\*(C`resultset\*(C'\fR on a DBIx::Class::Schema and passing in a
Source name.
.PP
.Vb 1
\&  my $users_rs = $schema\->resultset(\*(AqUser\*(Aq);
.Ve
.PP
A new ResultSet is returned from calling \*(L"search\*(R" on an existing
ResultSet. The new one will contain all the conditions of the
original, plus any new conditions added in the \f(CW\*(C`search\*(C'\fR call.
.PP
A ResultSet also incorporates an implicit iterator. \*(L"next\*(R" and \*(L"reset\*(R"
can be used to walk through all the DBIx::Class::Rows the ResultSet
represents.
.PP
The query that the ResultSet represents is \fBonly\fR executed against
the database when these methods are called:
\&\*(L"find\*(R", \*(L"next\*(R", \*(L"all\*(R", \*(L"first\*(R", \*(L"single\*(R", \*(L"count\*(R".
.PP
If a resultset is used in a numeric context it returns the \*(L"count\*(R".
However, if it is used in a boolean context it is \fBalways\fR true.  So if
you want to check if a resultset has any results, you must use \f(CW\*(C`if $rs
!= 0\*(C'\fR.
.SH "CUSTOM ResultSet CLASSES THAT USE Moose"
.IX Header "CUSTOM ResultSet CLASSES THAT USE Moose"
If you want to make your custom ResultSet classes with Moose, use a template
similar to:
.PP
.Vb 1
\&    package MyApp::Schema::ResultSet::User;
\&
\&    use Moose;
\&    use namespace::autoclean;
\&    use MooseX::NonMoose;
\&    extends \*(AqDBIx::Class::ResultSet\*(Aq;
\&
\&    sub BUILDARGS { $_[2] }
\&
\&    ...your code...
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
\&
\&    1;
.Ve
.PP
The MooseX::NonMoose is necessary so that the Moose constructor does not
clash with the regular ResultSet constructor. Alternatively, you can use:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->meta\->make_immutable(inline_constructor => 0);
.Ve
.PP
The \s-1BUILDARGS\s0 is necessary because the
signature of the ResultSet \f(CW\*(C`new\*(C'\fR is \f(CW\*(C`\->new($source, \e%args)\*(C'\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Chaining resultsets"
.IX Subsection "Chaining resultsets"
Let's say you've got a query that needs to be run to return some data
to the user. But, you have an authorization system in place that
prevents certain users from seeing certain information. So, you want
to construct the basic query in one method, but add constraints to it in
another.
.PP
.Vb 4
\&  sub get_data {
\&    my $self = shift;
\&    my $request = $self\->get_request; # Get a request object somehow.
\&    my $schema = $self\->result_source\->schema;
\&
\&    my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&      title => $request\->param(\*(Aqtitle\*(Aq),
\&      year => $request\->param(\*(Aqyear\*(Aq),
\&    });
\&
\&    $cd_rs = $self\->apply_security_policy( $cd_rs );
\&
\&    return $cd_rs\->all();
\&  }
\&
\&  sub apply_security_policy {
\&    my $self = shift;
\&    my ($rs) = @_;
\&
\&    return $rs\->search({
\&      subversive => 0,
\&    });
\&  }
.Ve
.PP
\fIResolving conditions and attributes\fR
.IX Subsection "Resolving conditions and attributes"
.PP
When a resultset is chained from another resultset (e.g.:
\&\f(CW\*(C`my $new_rs = $old_rs\->search(\e%extra_cond, \e%attrs)\*(C'\fR), conditions
and attributes with the same keys need resolving.
.PP
If any of \*(L"columns\*(R", \*(L"select\*(R", \*(L"as\*(R" are present, they reset the
original selection, and start the selection \*(L"clean\*(R".
.PP
The \*(L"join\*(R", \*(L"prefetch\*(R", \*(L"+columns\*(R", \*(L"+select\*(R", \*(L"+as\*(R" attributes
are merged into the existing ones from the original resultset.
.PP
The \*(L"where\*(R" and \*(L"having\*(R" attributes, and any search conditions, are
merged with an \s-1SQL \s0\f(CW\*(C`AND\*(C'\fR to the existing condition from the original
resultset.
.PP
All other attributes are overridden by any new ones supplied in the
search attributes.
.SS "Multiple queries"
.IX Subsection "Multiple queries"
Since a resultset just defines a query, you can do all sorts of
things with it with the same object.
.PP
.Vb 5
\&  # Don\*(Aqt hit the DB yet.
\&  my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&  });
\&
\&  # Each of these hits the DB individually.
\&  my $count = $cd_rs\->count;
\&  my $most_recent = $cd_rs\->get_column(\*(Aqdate_released\*(Aq)\->max();
\&  my @records = $cd_rs\->all;
.Ve
.PP
And it's not just limited to \s-1SELECT\s0 statements.
.PP
.Vb 1
\&  $cd_rs\->delete();
.Ve
.PP
This is even cooler:
.PP
.Vb 1
\&  $cd_rs\->create({ artist => \*(AqFred\*(Aq });
.Ve
.PP
Which is the same as:
.PP
.Vb 5
\&  $schema\->resultset(\*(AqCD\*(Aq)\->create({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&    artist => \*(AqFred\*(Aq
\&  });
.Ve
.PP
See: \*(L"search\*(R", \*(L"count\*(R", \*(L"get_column\*(R", \*(L"all\*(R", \*(L"create\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.ie n .IP "Arguments: $source, \e%attrs?" 4
.el .IP "Arguments: \f(CW$source\fR, \e%attrs?" 4
.IX Item "Arguments: $source, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
The resultset constructor. Takes a source object (usually a
DBIx::Class::ResultSourceProxy::Table) and an attribute hash (see
\&\*(L"\s-1ATTRIBUTES\*(R"\s0 below).  Does not perform any queries \*(-- these are
executed as needed by the other methods.
.PP
Generally you never construct a resultset manually. Instead you get one
from e.g. a
\&\f(CW\*(C`$schema\->resultset(\*(Aq$source_name\*(Aq)\*(C'\fR
or \f(CW\*(C`$another_resultset\->search(...)\*(C'\fR (the later called in
scalar context):
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ title => \*(Aq100th Window\*(Aq });
.Ve
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
If called on an object, proxies to \*(L"new_result\*(R" instead, so
.Sp
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->new({ title => \*(AqSpoon\*(Aq });
.Ve
.Sp
will return a \s-1CD\s0 object, not a ResultSet, and is equivalent to:
.Sp
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->new_result({ title => \*(AqSpoon\*(Aq });
.Ve
.Sp
Please also keep in mind that many internals call \*(L"new_result\*(R" directly,
so overloading this method with the idea of intercepting new result object
creation \fBwill not work\fR. See also warning pertaining to \*(L"create\*(R".
.SS "search"
.IX Subsection "search"
.ie n .IP "Arguments: $cond | undef, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR | undef, \e%attrs?" 4
.IX Item "Arguments: $cond | undef, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds    = $cd_rs\->search({ year => 2001 }); # "... WHERE year = 2001"
\&  my $new_rs = $cd_rs\->search({ year => 2005 });
\&
\&  my $new_rs = $cd_rs\->search([ { year => 2005 }, { year => 2004 } ]);
\&                 # year = 2005 OR year = 2004
.Ve
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of result objects instead.
To avoid that, use \*(L"search_rs\*(R".
.PP
If you need to pass in additional attributes but no additional condition,
call it as \f(CW\*(C`search(undef, \e%attrs)\*(C'\fR.
.PP
.Vb 4
\&  # "SELECT name, artistid FROM $artist_table"
\&  my @all_artists = $schema\->resultset(\*(AqArtist\*(Aq)\->search(undef, {
\&    columns => [qw/name artistid/],
\&  });
.Ve
.PP
For a list of attributes that can be passed to \f(CW\*(C`search\*(C'\fR, see
\&\*(L"\s-1ATTRIBUTES\*(R"\s0. For more examples of using this function, see
Searching. For a complete
documentation for the first argument, see \*(L"\s-1WHERE CLAUSES\*(R"\s0 in SQL::Abstract
and its extension DBIx::Class::SQLMaker.
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"search\*(R" does not process/deflate any of the values passed in the
SQL::Abstract\-compatible search condition structure. This is unlike other
condition-bound methods \*(L"new_result\*(R", \*(L"create\*(R" and \*(L"find\*(R". The user must ensure
manually that any value passed to this method will stringify to something the
\&\s-1RDBMS\s0 knows how to deal with. A notable example is the handling of DateTime
objects, for more info see:
\&\*(L"Formatting DateTime objects in queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "search_rs"
.IX Subsection "search_rs"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
This method does the same exact thing as \fIsearch()\fR except it will
always return a resultset, even in list context.
.SS "search_literal"
.IX Subsection "search_literal"
\&\fB\s-1CAVEAT\s0\fR: \f(CW\*(C`search_literal\*(C'\fR is provided for Class::DBI compatibility and
should only be used in that context. \f(CW\*(C`search_literal\*(C'\fR is a convenience
method. It is equivalent to calling \f(CW\*(C`$schema\->search(\e[])\*(C'\fR, but if you
want to ensure columns are bound correctly, use \*(L"search\*(R".
.PP
See \*(L"\s-1SEARCHING\*(R"\s0 in DBIx::Class::Manual::Cookbook and
\&\*(L"Searching\*(R" in DBIx::Class::Manual::FAQ for searching techniques that do not
require \f(CW\*(C`search_literal\*(C'\fR.
.ie n .IP "Arguments: $sql_fragment, @standalone_bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@standalone_bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @standalone_bind_values"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds   = $cd_rs\->search_literal(\*(Aqyear = ? AND title = ?\*(Aq, qw/2001 Reload/);
\&  my $newrs = $artist_rs\->search_literal(\*(Aqname = ?\*(Aq, \*(AqMetallica\*(Aq);
.Ve
.PP
Pass a literal chunk of \s-1SQL\s0 to be added to the conditional part of the
resultset query.
.PP
Example of how to use \f(CW\*(C`search\*(C'\fR instead of \f(CW\*(C`search_literal\*(C'\fR
.PP
.Vb 2
\&  my @cds = $cd_rs\->search_literal(\*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, (2, 1, 2));
\&  my @cds = $cd_rs\->search(\e[ \*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, [ \*(Aqcdid\*(Aq, 2 ], [ \*(Aqartist\*(Aq, 1 ], [ \*(Aqartist\*(Aq, 2 ] ]);
.Ve
.SS "find"
.IX Subsection "find"
.ie n .IP "Arguments: \e%columns_values | @pk_values, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%columns_values | \f(CW@pk_values\fR, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %columns_values | @pk_values, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Finds and returns a single row based on supplied criteria. Takes either a
hashref with the same format as \*(L"create\*(R" (including inference of foreign
keys from related objects), or a list of primary key values in the same
order as the primary columns
declaration on the \*(L"result_source\*(R".
.PP
In either case an attempt is made to combine conditions already existing on
the resultset with the condition passed to this method.
.PP
To aid with preparing the correct query for the storage you may supply the
\&\f(CW\*(C`key\*(C'\fR attribute, which is the name of a
unique constraint (the
unique constraint corresponding to the
primary columns is always named
\&\f(CW\*(C`primary\*(C'\fR). If the \f(CW\*(C`key\*(C'\fR attribute has been supplied, and \s-1DBIC\s0 is unable
to construct a query that satisfies the named unique constraint fully (
non-NULL values for each column member of the constraint) an exception is
thrown.
.PP
If no \f(CW\*(C`key\*(C'\fR is specified, the search is carried over all unique constraints
which are fully defined by the available condition.
.PP
If no such constraint is found, \f(CW\*(C`find\*(C'\fR currently defaults to a simple
\&\f(CW\*(C`search\->(\e%column_values)\*(C'\fR which may or may not do what you expect.
Note that this fallback behavior may be deprecated in further versions. If
you need to search with arbitrary conditions \- use \*(L"search\*(R". If the query
resulting from this fallback produces more than one row, a warning to the
effect is issued, though only the first row is constructed and returned as
\&\f(CW$result_object\fR.
.PP
In addition to \f(CW\*(C`key\*(C'\fR, \*(L"find\*(R" recognizes and applies standard
resultset attributes in the same way as \*(L"search\*(R" does.
.PP
Note that if you have extra concerns about the correctness of the resulting
query you need to specify the \f(CW\*(C`key\*(C'\fR attribute and supply the entire condition
as an argument to find (since it is not always possible to perform the
combination of the resultset condition with the supplied one, especially if
the resultset condition contains literal sql).
.PP
For example, to find a row by its primary key:
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(5);
.Ve
.PP
You can also find a row by a specific unique constraint:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
See also \*(L"find_or_create\*(R" and \*(L"update_or_create\*(R".
.SS "search_related"
.IX Subsection "search_related"
.ie n .IP "Arguments: $rel_name, $cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$cond\fR?, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $cond?, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 3
\&  $new_rs = $cd_rs\->search_related(\*(Aqartist\*(Aq, {
\&    name => \*(AqEmo\-R\-Us\*(Aq,
\&  });
.Ve
.PP
Searches the specified relationship, optionally specifying a condition and
attributes for matching records. See \*(L"\s-1ATTRIBUTES\*(R"\s0 for more information.
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of result objects instead. To avoid that, use \*(L"search_related_rs\*(R".
.PP
See also \*(L"search_related_rs\*(R".
.SS "search_related_rs"
.IX Subsection "search_related_rs"
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "cursor"
.IX Subsection "cursor"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $cursor" 4
.el .IP "Return Value: \f(CW$cursor\fR" 4
.IX Item "Return Value: $cursor"
.PD
.PP
Returns a storage-driven cursor to the given resultset. See
DBIx::Class::Cursor for more information.
.SS "single"
.IX Subsection "single"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->single({ year => 2001 });
.Ve
.PP
Inflates the first result without creating a cursor if the resultset has
any records in it; if not returns \f(CW\*(C`undef\*(C'\fR. Used by \*(L"find\*(R" as a lean version
of \*(L"search\*(R".
.PP
While this method can take an optional search condition (just like \*(L"search\*(R")
being a fast-code-path it does not recognize search attributes. If you need to
add extra joins or similar, call \*(L"search\*(R" and then chain-call \*(L"single\*(R" on the
DBIx::Class::ResultSet returned.
.IP "\fBNote\fR" 4
.IX Item "Note"
As of 0.08100, this method enforces the assumption that the preceding
query returns only one row. If more than one row is returned, you will receive
a warning:
.Sp
.Vb 1
\&  Query returned more than one row
.Ve
.Sp
In this case, you should be using \*(L"next\*(R" or \*(L"find\*(R" instead, or if you really
know what you are doing, use the \*(L"rows\*(R" attribute to explicitly limit the size
of the resultset.
.Sp
This method will also throw an exception if it is called on a resultset prefetching
has_many, as such a prefetch implies fetching multiple rows from the database in
order to assemble the resulting object.
.SS "get_column"
.IX Subsection "get_column"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $resultsetcolumn" 4
.el .IP "Return Value: \f(CW$resultsetcolumn\fR" 4
.IX Item "Return Value: $resultsetcolumn"
.PD
.PP
.Vb 1
\&  my $max_length = $rs\->get_column(\*(Aqlength\*(Aq)\->max;
.Ve
.PP
Returns a DBIx::Class::ResultSetColumn instance for a column of the ResultSet.
.SS "search_like"
.IX Subsection "search_like"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
.Vb 2
\&  # WHERE title LIKE \*(Aq%blue%\*(Aq
\&  $cd_rs = $rs\->search_like({ title => \*(Aq%blue%\*(Aq});
.Ve
.PP
Performs a search, but uses \f(CW\*(C`LIKE\*(C'\fR instead of \f(CW\*(C`=\*(C'\fR as the condition. Note
that this is simply a convenience method retained for ex Class::DBI users.
You most likely want to use \*(L"search\*(R" with specific operators.
.PP
For more information, see DBIx::Class::Manual::Cookbook.
.PP
This method is deprecated and will be removed in 0.09. Use \*(L"\fIsearch()\fR\*(R"
instead. An example conversion is:
.PP
.Vb 1
\&  \->search_like({ foo => \*(Aqbar\*(Aq });
\&
\&  # Becomes
\&
\&  \->search({ foo => { like => \*(Aqbar\*(Aq } });
.Ve
.SS "slice"
.IX Subsection "slice"
.ie n .IP "Arguments: $first, $last" 4
.el .IP "Arguments: \f(CW$first\fR, \f(CW$last\fR" 4
.IX Item "Arguments: $first, $last"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) | @result_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) | \f(CW@result_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) | @result_objs (list context)"
.PD
.PP
Returns a resultset or object list representing a subset of elements from the
resultset slice is called on. Indexes are from 0, i.e., to get the first
three records, call:
.PP
.Vb 1
\&  my ($one, $two, $three) = $rs\->slice(0, 2);
.Ve
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Returns the next element in the resultset (\f(CW\*(C`undef\*(C'\fR is there is none).
.PP
Can be used to efficiently iterate over records in the resultset:
.PP
.Vb 4
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search;
\&  while (my $cd = $rs\->next) {
\&    print $cd\->title;
\&  }
.Ve
.PP
Note that you need to store the resultset object, and call \f(CW\*(C`next\*(C'\fR on it.
Calling \f(CW\*(C`resultset(\*(AqTable\*(Aq)\->next\*(C'\fR repeatedly will always return the
first record from the resultset.
.SS "result_source"
.IX Subsection "result_source"
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
An accessor for the primary ResultSource object from which this ResultSet
is derived.
.SS "result_class"
.IX Subsection "result_class"
.ie n .IP "Arguments: $result_class?" 4
.el .IP "Arguments: \f(CW$result_class\fR?" 4
.IX Item "Arguments: $result_class?"
.PD 0
.ie n .IP "Return Value: $result_class" 4
.el .IP "Return Value: \f(CW$result_class\fR" 4
.IX Item "Return Value: $result_class"
.PD
.PP
An accessor for the class to use when creating result objects. Defaults to
\&\f(CW\*(C`result_source\->result_class\*(C'\fR \- which in most cases is the name of the
\&\*(L"table\*(R" class.
.PP
Note that changing the result_class will also remove any components
that were originally loaded in the source class via
\&\*(L"load_components\*(R" in DBIx::Class::ResultSource. Any overloaded methods
in the original source class will not run.
.SS "count"
.IX Subsection "count"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Performs an \s-1SQL \s0\f(CW\*(C`COUNT\*(C'\fR with the same query as the resultset was built
with to find the number of elements. Passing arguments is equivalent to
\&\f(CW\*(C`$rs\->search ($cond, \e%attrs)\->count\*(C'\fR
.SS "count_rs"
.IX Subsection "count_rs"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $count_rs" 4
.el .IP "Return Value: \f(CW$count_rs\fR" 4
.IX Item "Return Value: $count_rs"
.PD
.PP
Same as \*(L"count\*(R" but returns a DBIx::Class::ResultSetColumn object.
This can be very handy for subqueries:
.PP
.Vb 1
\&  \->search( { amount => $some_rs\->count_rs\->as_query } )
.Ve
.PP
As with regular resultsets the \s-1SQL\s0 query will be executed only after
the resultset is accessed via \*(L"next\*(R" or \*(L"all\*(R". That would return
the same single value obtainable via \*(L"count\*(R".
.SS "count_literal"
.IX Subsection "count_literal"
\&\fB\s-1CAVEAT\s0\fR: \f(CW\*(C`count_literal\*(C'\fR is provided for Class::DBI compatibility and
should only be used in that context. See \*(L"search_literal\*(R" for further info.
.ie n .IP "Arguments: $sql_fragment, @standalone_bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@standalone_bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @standalone_bind_values"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Counts the results in a literal query. Equivalent to calling \*(L"search_literal\*(R"
with the passed arguments, then \*(L"count\*(R".
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @result_objs" 4
.el .IP "Return Value: \f(CW@result_objs\fR" 4
.IX Item "Return Value: @result_objs"
.PD
.PP
Returns all elements in the resultset.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the resultset's cursor, so you can iterate through the elements again.
Implicitly resets the storage cursor, so a subsequent \*(L"next\*(R" will trigger
another query.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Resets the resultset (causing a fresh query to storage) and returns
an object for the first result (or \f(CW\*(C`undef\*(C'\fR if the resultset is empty).
.SS "update"
.IX Subsection "update"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.ie n .IP "Return Value: $underlying_storage_rv" 4
.el .IP "Return Value: \f(CW$underlying_storage_rv\fR" 4
.IX Item "Return Value: $underlying_storage_rv"
.PD
.PP
Sets the specified columns in the resultset to the supplied values in a
single query. Note that this will not run any accessor/set_column/update
triggers, nor will it update any result object instances derived from this
resultset (this includes the contents of the resultset cache
if any). See \*(L"update_all\*(R" if you need to execute any on-update
triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying
storage backend returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most
common case.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"update\*(R" does not process/deflate any of the values passed in.
This is unlike the corresponding \*(L"update\*(R" in DBIx::Class::Row. The user must
ensure manually that any value passed to this method will stringify to
something the \s-1RDBMS\s0 knows how to deal with. A notable example is the
handling of DateTime objects, for more info see:
\&\*(L"Formatting DateTime objects in queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "update_all"
.IX Subsection "update_all"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and updates them one at a time via
\&\*(L"update\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`update_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"update\*(R" will not.
.SS "delete"
.IX Subsection "delete"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $underlying_storage_rv" 4
.el .IP "Return Value: \f(CW$underlying_storage_rv\fR" 4
.IX Item "Return Value: $underlying_storage_rv"
.PD
.PP
Deletes the rows matching this resultset in a single query. Note that this
will not run any delete triggers, nor will it alter the
in_storage status of any result object instances
derived from this resultset (this includes the contents of the
resultset cache if any). See \*(L"delete_all\*(R" if you need to
execute any on-delete triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying storage backend
returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most common case.
.SS "delete_all"
.IX Subsection "delete_all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and deletes them one at a time via
\&\*(L"delete\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`delete_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"delete\*(R" will not.
.SS "populate"
.IX Subsection "populate"
.IP "Arguments: [ \e@column_list, \e@row_values+ ] | [ \e%col_data+ ]" 4
.IX Item "Arguments: [ @column_list, @row_values+ ] | [ %col_data+ ]"
.PD 0
.ie n .IP "Return Value: \e@result_objects (scalar context) | @result_objects (list context)" 4
.el .IP "Return Value: \e@result_objects (scalar context) | \f(CW@result_objects\fR (list context)" 4
.IX Item "Return Value: @result_objects (scalar context) | @result_objects (list context)"
.PD
.PP
Accepts either an arrayref of hashrefs or alternatively an arrayref of
arrayrefs.
.IP "\s-1NOTE\s0" 4
.IX Item "NOTE"
The context of this method call has an important effect on what is
submitted to storage. In void context data is fed directly to fastpath
insertion routines provided by the underlying storage (most often
\&\*(L"execute_for_fetch\*(R" in \s-1DBI\s0), bypassing the new and
insert calls on the
Result class, including any
augmentation of these methods provided by components. For example if you
are using something like DBIx::Class::UUIDColumns to create primary
keys for you, you will find that your PKs are empty.  In this case you
will have to explicitly force scalar or list context in order to create
those values.
.PP
In non-void (scalar or list) context, this method is simply a wrapper
for \*(L"create\*(R". Depending on list or scalar context either a list of
Result objects or an arrayref
containing these objects is returned.
.PP
When supplying data in \*(L"arrayref of arrayrefs\*(R" invocation style, the
first element should be a list of column names and each subsequent
element should be a data value in the earlier specified column order.
For example:
.PP
.Vb 6
\&  $schema\->resultset("Artist")\->populate([
\&    [ qw( artistid name ) ],
\&    [ 100, \*(AqA Formally Unknown Singer\*(Aq ],
\&    [ 101, \*(AqA singer that jumped the shark two albums ago\*(Aq ],
\&    [ 102, \*(AqAn actually cool singer\*(Aq ],
\&  ]);
.Ve
.PP
For the arrayref of hashrefs style each hashref should be a structure
suitable for passing to \*(L"create\*(R". Multi-create is also permitted with
this syntax.
.PP
.Vb 10
\&  $schema\->resultset("Artist")\->populate([
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&     { artistid => 5, name => \*(AqAngsty\-Whiny Girl\*(Aq, cds => [
\&        { title => \*(AqMy parents sold me to a record company\*(Aq, year => 2005 },
\&        { title => \*(AqWhy Am I So Ugly?\*(Aq, year => 2006 },
\&        { title => \*(AqI Got Surgery and am now Popular\*(Aq, year => 2007 }
\&      ],
\&     },
\&  ]);
.Ve
.PP
If you attempt a void-context multi-create as in the example above (each
Artist also has the related list of CDs), and \fBdo not\fR supply the
necessary autoinc foreign key information, this method will proxy to the
less efficient \*(L"create\*(R", and then throw the Result objects away. In this
case there are obviously no benefits to using this method over \*(L"create\*(R".
.SS "pager"
.IX Subsection "pager"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $pager" 4
.el .IP "Return Value: \f(CW$pager\fR" 4
.IX Item "Return Value: $pager"
.PD
.PP
Returns a Data::Page object for the current resultset. Only makes
sense for queries with a \f(CW\*(C`page\*(C'\fR attribute.
.PP
To get the full count of entries for a paged resultset, call
\&\f(CW\*(C`total_entries\*(C'\fR on the Data::Page object.
.SS "page"
.IX Subsection "page"
.ie n .IP "Arguments: $page_number" 4
.el .IP "Arguments: \f(CW$page_number\fR" 4
.IX Item "Arguments: $page_number"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a resultset for the \f(CW$page_number\fR page of the resultset on which page
is called, where each page contains a number of rows equal to the 'rows'
attribute set on the resultset (10 by default).
.SS "new_result"
.IX Subsection "new_result"
.IP "Arguments: \e%col_data" 4
.IX Item "Arguments: %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Creates a new result object in the resultset's result class and returns
it. The row is not inserted into the database at this point, call
\&\*(L"insert\*(R" in DBIx::Class::Row to do that. Calling \*(L"in_storage\*(R" in DBIx::Class::Row
will tell you whether the result object has been inserted or not.
.PP
Passes the hashref of input on to \*(L"new\*(R" in DBIx::Class::Row.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind_values ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind_values\fR ]" 4
.IX Item "Return Value: [ $sql, @bind_values ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "find_or_new"
.IX Subsection "find_or_new"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 2
\&  my $artist = $schema\->resultset(\*(AqArtist\*(Aq)\->find_or_new(
\&    { artist => \*(Aqfred\*(Aq }, { key => \*(Aqartists\*(Aq });
\&
\&  $cd\->cd_to_producer\->find_or_new({ producer => $producer },
\&                                   { key => \*(Aqprimary\*(Aq });
.Ve
.PP
Find an existing record from this resultset using \*(L"find\*(R". if none exists,
instantiate a new result object and return it. The object will not be saved
into your storage until you call \*(L"insert\*(R" in DBIx::Class::Row on it.
.PP
You most likely want this method when looking for existing rows using a unique
constraint that is not the primary key, or looking for related rows.
.PP
If you want objects to be saved immediately, use \*(L"find_or_create\*(R" instead.
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.SS "create"
.IX Subsection "create"
.IP "Arguments: \e%col_data" 4
.IX Item "Arguments: %col_data"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Attempt to create a single new row or a row with multiple related rows
in the table represented by the resultset (and related tables). This
will not check for duplicate rows before inserting, use
\&\*(L"find_or_create\*(R" to do that.
.PP
To create one row for this resultset, pass a hashref of key/value
pairs representing the columns of the table and the values you wish to
store. If the appropriate relationships are set up, foreign key fields
can also be passed an object representing the foreign row, and the
value will be set to its primary key.
.PP
To create related objects, pass a hashref of related-object column values
\&\fBkeyed on the relationship name\fR. If the relationship is of type \f(CW\*(C`multi\*(C'\fR
(\*(L"has_many\*(R" in DBIx::Class::Relationship) \- pass an arrayref of hashrefs.
The process will correctly identify columns holding foreign keys, and will
transparently populate them from the keys of the corresponding relation.
This can be applied recursively, and will work correctly for a structure
with an arbitrary depth and width, as long as the relationships actually
exists and the correct column data has been supplied.
.PP
Instead of hashrefs of plain related data (key/value pairs), you may
also pass new or inserted objects. New objects (not inserted yet, see
\&\*(L"new_result\*(R"), will be inserted into their appropriate tables.
.PP
Effectively a shortcut for \f(CW\*(C`\->new_result(\e%col_data)\->insert\*(C'\fR.
.PP
Example of creating a new row.
.PP
.Vb 4
\&  $person_rs\->create({
\&    name=>"Some Person",
\&    email=>"somebody@someplace.com"
\&  });
.Ve
.PP
Example of creating a new row and also creating rows in a related \f(CW\*(C`has_many\*(C'\fR
or \f(CW\*(C`has_one\*(C'\fR resultset.  Note Arrayref.
.PP
.Vb 7
\&  $artist_rs\->create(
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&  );
.Ve
.PP
Example of creating a new row and also creating a row in a related
\&\f(CW\*(C`belongs_to\*(C'\fR resultset. Note Hashref.
.PP
.Vb 7
\&  $cd_rs\->create({
\&    title=>"Music for Silly Walks",
\&    year=>2000,
\&    artist => {
\&      name=>"Silly Musician",
\&    }
\&  });
.Ve
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
When subclassing ResultSet never attempt to override this method. Since
it is a simple shortcut for \f(CW\*(C`$self\->new_result($attrs)\->insert\*(C'\fR, a
lot of the internals simply never call it, so your override will be
bypassed more often than not. Override either \*(L"new\*(R" in DBIx::Class::Row
or \*(L"insert\*(R" in DBIx::Class::Row depending on how early in the
\&\*(L"create\*(R" process you need to intervene. See also warning pertaining to
\&\*(L"new\*(R".
.SS "find_or_create"
.IX Subsection "find_or_create"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 2
\&  $cd\->cd_to_producer\->find_or_create({ producer => $producer },
\&                                      { key => \*(Aqprimary\*(Aq });
.Ve
.PP
Tries to find a record based on its primary key or unique constraints; if none
is found, creates one and returns that instead.
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
.Ve
.PP
Also takes an optional \f(CW\*(C`key\*(C'\fR attribute, to search by a specific key or unique
constraint. For example:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Because \fIfind_or_create()\fR reads from the database and then
possibly inserts based on the result, this method is subject to a race
condition. Another process could create a record in the table after
the find has completed and before the create has started. To avoid
this problem, use \fIfind_or_create()\fR inside a transaction.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"update_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.PP
If you need to know if an existing row was found or a new one created use
\&\*(L"find_or_new\*(R" and \*(L"in_storage\*(R" in DBIx::Class::Row instead. Don't forget
to call \*(L"insert\*(R" in DBIx::Class::Row to save the newly created row to the
database!
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_new({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
\&
\&  if( !$cd\->in_storage ) {
\&      # do some stuff
\&      $cd\->insert;
\&  }
.Ve
.SS "update_or_create"
.IX Subsection "update_or_create"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_create({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_create\*(R", but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_data)\*(C'\fR.
.PP
Takes an optional \f(CW\*(C`key\*(C'\fR attribute to search on a specific unique constraint.
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  $cd\->cd_to_producer\->update_or_create({
\&    producer => $producer,
\&    name => \*(Aqharry\*(Aq,
\&  }, {
\&    key => \*(Aqprimary\*(Aq,
\&  });
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"find_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.PP
If you need to know if an existing row was updated or a new one created use
\&\*(L"update_or_new\*(R" and \*(L"in_storage\*(R" in DBIx::Class::Row instead. Don't forget
to call \*(L"insert\*(R" in DBIx::Class::Row to save the newly created row to the
database!
.SS "update_or_new"
.IX Subsection "update_or_new"
.ie n .IP "Arguments: \e%col_data, { key => $unique_constraint, %attrs }?" 4
.el .IP "Arguments: \e%col_data, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?" 4
.IX Item "Arguments: %col_data, { key => $unique_constraint, %attrs }?"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_new({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_new\*(R" but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_data)\*(C'\fR.
.PP
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_new(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  if ($cd\->in_storage) {
\&      # the cd was updated
\&  }
\&  else {
\&      # the cd is not yet in the database, let\*(Aqs insert it
\&      $cd\->insert;
\&  }
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R", \*(L"find_or_create\*(R" and \*(L"find_or_new\*(R".
.SS "get_cache"
.IX Subsection "get_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \e@result_objs | undef" 4
.IX Item "Return Value: @result_objs | undef"
.PD
.PP
Gets the contents of the cache for the resultset, if the cache is set.
.PP
The cache is populated either by using the \*(L"prefetch\*(R" attribute to
\&\*(L"search\*(R" or by calling \*(L"set_cache\*(R".
.SS "set_cache"
.IX Subsection "set_cache"
.IP "Arguments: \e@result_objs" 4
.IX Item "Arguments: @result_objs"
.PD 0
.IP "Return Value: \e@result_objs" 4
.IX Item "Return Value: @result_objs"
.PD
.PP
Sets the contents of the cache for the resultset. Expects an arrayref
of objects of the same class as those produced by the resultset. Note that
if the cache is set, the resultset will return the cached objects rather
than re-querying the database even if the cache attr is not set.
.PP
The contents of the cache can also be populated by using the
\&\*(L"prefetch\*(R" attribute to \*(L"search\*(R".
.SS "clear_cache"
.IX Subsection "clear_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: undef" 4
.IX Item "Return Value: undef"
.PD
.PP
Clears the cache for the resultset.
.SS "is_paged"
.IX Subsection "is_paged"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: true, if the resultset has been paginated" 4
.IX Item "Return Value: true, if the resultset has been paginated"
.PD
.SS "is_ordered"
.IX Subsection "is_ordered"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: true, if the resultset has been ordered with ""order_by""." 4
.el .IP "Return Value: true, if the resultset has been ordered with \f(CWorder_by\fR." 4
.IX Item "Return Value: true, if the resultset has been ordered with order_by."
.PD
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a related resultset for the supplied relationship name.
.PP
.Vb 1
\&  $artist_rs = $schema\->resultset(\*(AqCD\*(Aq)\->related_resultset(\*(AqArtist\*(Aq);
.Ve
.SS "current_source_alias"
.IX Subsection "current_source_alias"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $source_alias" 4
.el .IP "Return Value: \f(CW$source_alias\fR" 4
.IX Item "Return Value: $source_alias"
.PD
.PP
Returns the current table alias for the result source this resultset is built
on, that will be used in the \s-1SQL\s0 query. Usually it is \f(CW\*(C`me\*(C'\fR.
.PP
Currently the source alias that refers to the result set returned by a
\&\*(L"search\*(R"/\*(L"find\*(R" family method depends on how you got to the resultset: it's
\&\f(CW\*(C`me\*(C'\fR by default, but eg. \*(L"search_related\*(R" aliases it to the related result
source name (and keeps \f(CW\*(C`me\*(C'\fR referring to the original result set). The long
term goal is to make DBIx::Class always alias the current resultset as \f(CW\*(C`me\*(C'\fR
(and make this method unnecessary).
.PP
Thus it's currently necessary to use this method in predefined queries (see
\&\*(L"Predefined searches\*(R" in DBIx::Class::Manual::Cookbook) when referring to the
source alias of the current result set:
.PP
.Vb 3
\&  # in a result set class
\&  sub modified_by {
\&    my ($self, $user) = @_;
\&
\&    my $me = $self\->current_source_alias;
\&
\&    return $self\->search({
\&      "$me.modified" => $user\->id,
\&    });
\&  }
.Ve
.SS "as_subselect_rs"
.IX Subsection "as_subselect_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Act as a barrier to \s-1SQL\s0 symbols.  The resultset provided will be made into a
\&\*(L"virtual view\*(R" by including it as a subquery within the from clause.  From this
point on, any joined tables are inaccessible to \->search on the resultset (as if
it were simply where-filtered without joins).  For example:
.PP
.Vb 1
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search({\*(Aqx.name\*(Aq => \*(Aqabc\*(Aq},{ join => \*(Aqx\*(Aq });
\&
\& # \*(Aqx\*(Aq now pollutes the query namespace
\&
\& # So the following works as expected
\& my $ok_rs = $rs\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # But this doesn\*(Aqt: instead of finding a \*(AqBar\*(Aq related to two x rows (abc and
\& # def) we look for one row with contradictory terms and join in another table
\& # (aliased \*(Aqx_2\*(Aq) which we never use
\& my $broken_rs = $rs\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
\&
\& my $rs2 = $rs\->as_subselect_rs;
\&
\& # doesn\*(Aqt work \- \*(Aqx\*(Aq is no longer accessible in $rs2, having been sealed away
\& my $not_joined_rs = $rs2\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # works as expected: finds a \*(Aqtable\*(Aq row related to two x rows (abc and def)
\& my $correctly_joined_rs = $rs2\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
.Ve
.PP
Another example of when one might use this would be to select a subset of
columns in a group by clause:
.PP
.Vb 5
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search(undef, {
\&   group_by => [qw{ id foo_id baz_id }],
\& })\->as_subselect_rs\->search(undef, {
\&   columns => [qw{ id foo_id }]
\& });
.Ve
.PP
In the above example normally columns would have to be equal to the group by,
but because we isolated the group by into a subselect the above works.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Attributes are used to refine a ResultSet in various ways when
searching for data. They can be passed to any method which takes an
\&\f(CW\*(C`\e%attrs\*(C'\fR argument. See \*(L"search\*(R", \*(L"search_rs\*(R", \*(L"find\*(R",
\&\*(L"count\*(R".
.PP
Default attributes can be set on the result class using
\&\*(L"resultset_attributes\*(R" in DBIx::Class::ResultSource.  (Please read
the \s-1CAVEATS\s0 on that feature before using it!)
.PP
These are in no particular order:
.SS "order_by"
.IX Subsection "order_by"
.ie n .IP "Value: ( $order_by | \e@order_by | \e%order_by )" 4
.el .IP "Value: ( \f(CW$order_by\fR | \e@order_by | \e%order_by )" 4
.IX Item "Value: ( $order_by | @order_by | %order_by )"
.PP
Which column(s) to order the results by.
.PP
[The full list of suitable values is documented in
\&\*(L"\s-1ORDER BY CLAUSES\*(R"\s0 in SQL::Abstract; the following is a summary of
common options.]
.PP
If a single column name, or an arrayref of names is supplied, the
argument is passed through directly to \s-1SQL.\s0 The hashref syntax allows
for connection-agnostic specification of ordering direction:
.PP
.Vb 1
\& For descending order:
\&
\&  order_by => { \-desc => [qw/col1 col2 col3/] }
\&
\& For explicit ascending order:
\&
\&  order_by => { \-asc => \*(Aqcol\*(Aq }
.Ve
.PP
The old scalarref syntax (i.e. order_by => \e'year \s-1DESC\s0') is still
supported, although you are strongly encouraged to use the hashref
syntax as outlined above.
.SS "columns"
.IX Subsection "columns"
.ie n .IP "Value: \e@columns | \e%columns | $column" 4
.el .IP "Value: \e@columns | \e%columns | \f(CW$column\fR" 4
.IX Item "Value: @columns | %columns | $column"
.PP
Shortcut to request a particular set of columns to be retrieved. Each
column spec may be a string (a table column name), or a hash (in which
case the key is the \f(CW\*(C`as\*(C'\fR value, and the value is used as the \f(CW\*(C`select\*(C'\fR
expression). Adds \f(CW\*(C`me.\*(C'\fR onto the start of any column without a \f(CW\*(C`.\*(C'\fR in
it and sets \f(CW\*(C`select\*(C'\fR from that, then auto-populates \f(CW\*(C`as\*(C'\fR from
\&\f(CW\*(C`select\*(C'\fR as normal. (You may also use the \f(CW\*(C`cols\*(C'\fR attribute, as in
earlier versions of \s-1DBIC,\s0 but this is deprecated.)
.PP
Essentially \f(CW\*(C`columns\*(C'\fR does the same as \*(L"select\*(R" and \*(L"as\*(R".
.PP
.Vb 1
\&    columns => [ \*(Aqfoo\*(Aq, { bar => \*(Aqbaz\*(Aq } ]
.Ve
.PP
is the same as
.PP
.Vb 2
\&    select => [qw/foo baz/],
\&    as => [qw/foo bar/]
.Ve
.SS "+columns"
.IX Subsection "+columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Indicates additional columns to be selected from storage. Works the same as
\&\*(L"columns\*(R" but adds columns to the selection. (You may also use the
\&\f(CW\*(C`include_columns\*(C'\fR attribute, as in earlier versions of \s-1DBIC,\s0 but this is
deprecated). For example:\-
.PP
.Vb 4
\&  $schema\->resultset(\*(AqCD\*(Aq)\->search(undef, {
\&    \*(Aq+columns\*(Aq => [\*(Aqartist.name\*(Aq],
\&    join => [\*(Aqartist\*(Aq]
\&  });
.Ve
.PP
would return all CDs and include a 'name' column to the information
passed to object inflation. Note that the 'artist' is the name of the
column (or relationship) accessor, and 'name' is the name of the column
accessor in the related table.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+columns' when defining the attribute.
Not doing so causes Perl to incorrectly interpret +columns as a bareword with a
unary plus operator before it.
.SS "include_columns"
.IX Subsection "include_columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Deprecated.  Acts as a synonym for \*(L"+columns\*(R" for backward compatibility.
.SS "select"
.IX Subsection "select"
.IP "Value: \e@select_columns" 4
.IX Item "Value: @select_columns"
.PP
Indicates which columns should be selected from the storage. You can use
column names, or in the case of \s-1RDBMS\s0 back ends, function or stored procedure
names:
.PP
.Vb 7
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ]
\&  });
\&
\&  # Equivalent SQL
\&  SELECT name, COUNT( employeeid ), MAX( LENGTH( name ) ) AS longest_name FROM employee
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR You will almost always need a corresponding \*(L"as\*(R" attribute when you
use \*(L"select\*(R", to instruct DBIx::Class how to store the result of the column.
Also note that the \*(L"as\*(R" attribute has nothing to do with the SQL-side '\s-1AS\s0'
identifier aliasing. You can however alias a function, so you can use it in
e.g. an \f(CW\*(C`ORDER BY\*(C'\fR clause. This is done via the \f(CW\*(C`\-as\*(C'\fR \fBselect function
attribute\fR supplied as shown in the example above.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+select'/'+as' when defining the attributes.
Not doing so causes Perl to incorrectly interpret them as a bareword with a
unary plus operator before it.
.SS "+select"
.IX Subsection "+select"
.RS 4
Indicates additional columns to be selected from storage.  Works the same as
\&\*(L"select\*(R" but adds columns to the default selection, instead of specifying
an explicit list.
.RE
.SS "as"
.IX Subsection "as"
.IP "Value: \e@inflation_names" 4
.IX Item "Value: @inflation_names"
.PP
Indicates column names for object inflation. That is \*(L"as\*(R" indicates the
slot name in which the column value will be stored within the
Row object. The value will then be accessible via this
identifier by the \f(CW\*(C`get_column\*(C'\fR method (or via the object accessor \fBif one
with the same name already exists\fR) as shown below. The \*(L"as\*(R" attribute has
\&\fBnothing to do\fR with the SQL-side \f(CW\*(C`AS\*(C'\fR. See \*(L"select\*(R" for details.
.PP
.Vb 12
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ],
\&    as => [qw/
\&      name
\&      employee_count
\&      max_name_length
\&    /],
\&  });
.Ve
.PP
If the object against which the search is performed already has an accessor
matching a column name specified in \f(CW\*(C`as\*(C'\fR, the value can be retrieved using
the accessor as normal:
.PP
.Vb 1
\&  my $name = $employee\->name();
.Ve
.PP
If on the other hand an accessor does not exist in the object, you need to
use \f(CW\*(C`get_column\*(C'\fR instead:
.PP
.Vb 1
\&  my $employee_count = $employee\->get_column(\*(Aqemployee_count\*(Aq);
.Ve
.PP
You can create your own accessors if required \- see
DBIx::Class::Manual::Cookbook for details.
.SS "+as"
.IX Subsection "+as"
.RS 4
Indicates additional column names for those added via \*(L"+select\*(R". See \*(L"as\*(R".
.RE
.SS "join"
.IX Subsection "join"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
Contains a list of relationships that should be joined for this query.  For
example:
.PP
.Vb 5
\&  # Get CDs by Nine Inch Nails
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    { \*(Aqartist.name\*(Aq => \*(AqNine Inch Nails\*(Aq },
\&    { join => \*(Aqartist\*(Aq }
\&  );
.Ve
.PP
Can also contain a hash reference to refer to the other relation's relations.
For example:
.PP
.Vb 7
\&  package MyApp::Schema::Track;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqtrack\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/trackid cd position title/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqtrackid\*(Aq);
\&  _\|_PACKAGE_\|_\->belongs_to(cd => \*(AqMyApp::Schema::CD\*(Aq);
\&  1;
\&
\&  # In your application
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&    { \*(Aqtrack.title\*(Aq => \*(AqTeardrop\*(Aq },
\&    {
\&      join     => { cd => \*(Aqtrack\*(Aq },
\&      order_by => \*(Aqartist.name\*(Aq,
\&    }
\&  );
.Ve
.PP
You need to use the relationship (not the table) name in  conditions,
because they are aliased as such. The current table is aliased as \*(L"me\*(R", so
you need to use me.column_name in order to avoid ambiguity. For example:
.PP
.Vb 8
\&  # Get CDs from 1984 with a \*(AqFoo\*(Aq track
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    {
\&      \*(Aqme.year\*(Aq => 1984,
\&      \*(Aqtracks.name\*(Aq => \*(AqFoo\*(Aq
\&    },
\&    { join => \*(Aqtracks\*(Aq }
\&  );
.Ve
.PP
If the same join is supplied twice, it will be aliased to <rel>_2 (and
similarly for a third time). For e.g.
.PP
.Vb 6
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&    \*(Aqcds.title\*(Aq   => \*(AqDown to Earth\*(Aq,
\&    \*(Aqcds_2.title\*(Aq => \*(AqPopular\*(Aq,
\&  }, {
\&    join => [ qw/cds cds/ ],
\&  });
.Ve
.PP
will return a set of all artists that have both a cd with title 'Down
to Earth' and a cd with title 'Popular'.
.PP
If you want to fetch related objects from other tables as well, see \*(L"prefetch\*(R"
below.
.PP
.Vb 5
\& NOTE: An internal join\-chain pruner will discard certain joins while
\& constructing the actual SQL query, as long as the joins in question do not
\& affect the retrieved result. This for example includes 1:1 left joins
\& that are not part of the restriction specification (WHERE/HAVING) nor are
\& a part of the query selection.
.Ve
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.SS "collapse"
.IX Subsection "collapse"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
When set to a true value, indicates that any rows fetched from joined has_many
relationships are to be aggregated into the corresponding \*(L"parent\*(R" object. For
example, the resultset:
.PP
.Vb 5
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({}, {
\&    \*(Aq+columns\*(Aq => [ qw/ tracks.title tracks.position / ],
\&    join => \*(Aqtracks\*(Aq,
\&    collapse => 1,
\&  });
.Ve
.PP
While executing the following query:
.PP
.Vb 4
\&  SELECT me.*, tracks.title, tracks.position
\&    FROM cd me
\&    LEFT JOIN track tracks
\&      ON tracks.cdid = me.cdid
.Ve
.PP
Will return only as many objects as there are rows in the \s-1CD\s0 source, even
though the result of the query may span many rows. Each of these \s-1CD\s0 objects
will in turn have multiple \*(L"Track\*(R" objects hidden behind the has_many
generated accessor \f(CW\*(C`tracks\*(C'\fR. Without \f(CW\*(C`collapse => 1\*(C'\fR, the return values
of this resultset would be as many \s-1CD\s0 objects as there are tracks (a \*(L"Cartesian
product\*(R"), with each \s-1CD\s0 object containing exactly one of all fetched Track data.
.PP
When a collapse is requested on a non-ordered resultset, an order by some
unique part of the main source (the left-most table) is inserted automatically.
This is done so that the resultset is allowed to be \*(L"lazy\*(R" \- calling
\&\f(CW$rs\fR\->next will fetch only as many rows as it needs to build the next
object with all of its related data.
.PP
If an \*(L"order_by\*(R" is already declared, and orders the resultset in a way that
makes collapsing as described above impossible (e.g. \f(CW\*(C`ORDER BY
has_many_rel.column\*(C'\fR or \f(CW\*(C`ORDER BY RANDOM()\*(C'\fR), \s-1DBIC\s0 will automatically
switch to \*(L"eager\*(R" mode and slurp the entire resultset before constructing the
first object returned by \*(L"next\*(R".
.PP
Setting this attribute on a resultset that does not join any has_many
relations is a no-op.
.PP
For a more in-depth discussion, see \*(L"\s-1PREFETCHING\*(R"\s0.
.SS "prefetch"
.IX Subsection "prefetch"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
This attribute is a shorthand for specifying a \*(L"join\*(R" spec, adding all
columns from the joined related sources as \*(L"+columns\*(R" and setting
\&\*(L"collapse\*(R" to a true value. For example, the following two queries are
equivalent:
.PP
.Vb 3
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({}, {
\&    prefetch => { cds => [\*(Aqgenre\*(Aq, \*(Aqtracks\*(Aq ] },
\&  });
.Ve
.PP
and
.PP
.Vb 10
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({}, {
\&    join => { cds => [\*(Aqgenre\*(Aq, \*(Aqtracks\*(Aq ] },
\&    collapse => 1,
\&    \*(Aq+columns\*(Aq => [
\&      (map
\&        { +{ "cds.$_" => "cds.$_" } }
\&        $schema\->source(\*(AqArtist\*(Aq)\->related_source(\*(Aqcds\*(Aq)\->columns
\&      ),
\&      (map
\&        { +{ "cds.genre.$_" => "genre.$_" } }
\&        $schema\->source(\*(AqArtist\*(Aq)\->related_source(\*(Aqcds\*(Aq)\->related_source(\*(Aqgenre\*(Aq)\->columns
\&      ),
\&      (map
\&        { +{ "cds.tracks.$_" => "tracks.$_" } }
\&        $schema\->source(\*(AqArtist\*(Aq)\->related_source(\*(Aqcds\*(Aq)\->related_source(\*(Aqtracks\*(Aq)\->columns
\&      ),
\&    ],
\&  });
.Ve
.PP
Both producing the following \s-1SQL:\s0
.PP
.Vb 12
\&  SELECT  me.artistid, me.name, me.rank, me.charfield,
\&          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track,
\&          genre.genreid, genre.name,
\&          tracks.trackid, tracks.cd, tracks.position, tracks.title, tracks.last_updated_on, tracks.last_updated_at
\&    FROM artist me
\&    LEFT JOIN cd cds
\&      ON cds.artist = me.artistid
\&    LEFT JOIN genre genre
\&      ON genre.genreid = cds.genreid
\&    LEFT JOIN track tracks
\&      ON tracks.cd = cds.cdid
\&  ORDER BY me.artistid
.Ve
.PP
While \*(L"prefetch\*(R" implies a \*(L"join\*(R", it is ok to mix the two together, as
the arguments are properly merged and generally do the right thing. For
example, you may want to do the following:
.PP
.Vb 7
\&  my $artists_and_cds_without_genre = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&    { \*(Aqgenre.genreid\*(Aq => undef },
\&    {
\&      join => { cds => \*(Aqgenre\*(Aq },
\&      prefetch => \*(Aqcds\*(Aq,
\&    }
\&  );
.Ve
.PP
Which generates the following \s-1SQL:\s0
.PP
.Vb 9
\&  SELECT  me.artistid, me.name, me.rank, me.charfield,
\&          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track
\&    FROM artist me
\&    LEFT JOIN cd cds
\&      ON cds.artist = me.artistid
\&    LEFT JOIN genre genre
\&      ON genre.genreid = cds.genreid
\&  WHERE genre.genreid IS NULL
\&  ORDER BY me.artistid
.Ve
.PP
For a more in-depth discussion, see \*(L"\s-1PREFETCHING\*(R"\s0.
.SS "alias"
.IX Subsection "alias"
.ie n .IP "Value: $source_alias" 4
.el .IP "Value: \f(CW$source_alias\fR" 4
.IX Item "Value: $source_alias"
.PP
Sets the source alias for the query.  Normally, this defaults to \f(CW\*(C`me\*(C'\fR, but
nested search queries (sub-SELECTs) might need specific aliases set to
reference inner queries.  For example:
.PP
.Vb 7
\&   my $q = $rs
\&      \->related_resultset(\*(AqCDs\*(Aq)
\&      \->related_resultset(\*(AqTracks\*(Aq)
\&      \->search({
\&         \*(Aqtrack.id\*(Aq => { \-ident => \*(Aqnone_search.id\*(Aq },
\&      })
\&      \->as_query;
\&
\&   my $ids = $self\->search({
\&      \-not_exists => $q,
\&   }, {
\&      alias    => \*(Aqnone_search\*(Aq,
\&      group_by => \*(Aqnone_search.id\*(Aq,
\&   })\->get_column(\*(Aqid\*(Aq)\->as_query;
\&
\&   $self\->search({ id => { \-in => $ids } })
.Ve
.PP
This attribute is directly tied to \*(L"current_source_alias\*(R".
.SS "page"
.IX Subsection "page"
.ie n .IP "Value: $page" 4
.el .IP "Value: \f(CW$page\fR" 4
.IX Item "Value: $page"
.PP
Makes the resultset paged and specifies the page to retrieve. Effectively
identical to creating a non-pages resultset and then calling \->page($page)
on it.
.PP
If \*(L"rows\*(R" attribute is not specified it defaults to 10 rows per page.
.PP
When you have a paged resultset, \*(L"count\*(R" will only return the number
of rows in the page. To get the total, use the \*(L"pager\*(R" and call
\&\f(CW\*(C`total_entries\*(C'\fR on it.
.SS "rows"
.IX Subsection "rows"
.ie n .IP "Value: $rows" 4
.el .IP "Value: \f(CW$rows\fR" 4
.IX Item "Value: $rows"
.PP
Specifies the maximum number of rows for direct retrieval or the number of
rows per page if the page attribute or method is used.
.SS "offset"
.IX Subsection "offset"
.ie n .IP "Value: $offset" 4
.el .IP "Value: \f(CW$offset\fR" 4
.IX Item "Value: $offset"
.PP
Specifies the (zero-based) row number for the  first row to be returned, or the
of the first row of the first page if paging is used.
.SS "software_limit"
.IX Subsection "software_limit"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
When combined with \*(L"rows\*(R" and/or \*(L"offset\*(R" the generated \s-1SQL\s0 will not
include any limit dialect stanzas. Instead the entire result will be selected
as if no limits were specified, and \s-1DBIC\s0 will perform the limit locally, by
artificially advancing and finishing the resulting \*(L"cursor\*(R".
.PP
This is the recommended way of performing resultset limiting when no sane \s-1RDBMS\s0
implementation is available (e.g.
Sybase \s-1ASE\s0 using the
Generic Sub Query hack)
.SS "group_by"
.IX Subsection "group_by"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
A arrayref of columns to group by. Can include columns of joined tables.
.PP
.Vb 1
\&  group_by => [qw/ column1 column2 ... /]
.Ve
.SS "having"
.IX Subsection "having"
.ie n .IP "Value: $condition" 4
.el .IP "Value: \f(CW$condition\fR" 4
.IX Item "Value: $condition"
.PP
\&\s-1HAVING\s0 is a select statement attribute that is applied between \s-1GROUP BY\s0 and
\&\s-1ORDER BY.\s0 It is applied to the after the grouping calculations have been
done.
.PP
.Vb 1
\&  having => { \*(Aqcount_employee\*(Aq => { \*(Aq>=\*(Aq, 100 } }
.Ve
.PP
or with an in-place function in which case literal \s-1SQL\s0 is required:
.PP
.Vb 1
\&  having => \e[ \*(Aqcount(employee) >= ?\*(Aq, [ count => 100 ] ]
.Ve
.SS "distinct"
.IX Subsection "distinct"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
Set to 1 to automatically generate a \*(L"group_by\*(R" clause based on the selection
(including intelligent handling of \*(L"order_by\*(R" contents). Note that the group
criteria calculation takes place over the \fBfinal\fR selection. This includes
any \*(L"+columns\*(R", \*(L"+select\*(R" or \*(L"order_by\*(R" additions in subsequent
\&\*(L"search\*(R" calls, and standalone columns selected via
DBIx::Class::ResultSetColumn (\*(L"get_column\*(R"). A notable exception are the
extra selections specified via \*(L"prefetch\*(R" \- such selections are explicitly
excluded from group criteria calculations.
.PP
If the final ResultSet also explicitly defines a \*(L"group_by\*(R" attribute, this
setting is ignored and an appropriate warning is issued.
.SS "where"
.IX Subsection "where"
.RS 4
Adds to the \s-1WHERE\s0 clause.
.Sp
.Vb 2
\&  # only return rows WHERE deleted IS NULL for all searches
\&  _\|_PACKAGE_\|_\->resultset_attributes({ where => { deleted => undef } });
.Ve
.Sp
Can be overridden by passing \f(CW\*(C`{ where => undef }\*(C'\fR as an attribute
to a resultset.
.Sp
For more complicated where clauses see \*(L"\s-1WHERE CLAUSES\*(R"\s0 in SQL::Abstract.
.RE
.SS "cache"
.IX Subsection "cache"
Set to 1 to cache search results. This prevents extra \s-1SQL\s0 queries if you
revisit rows in your ResultSet:
.PP
.Vb 1
\&  my $resultset = $schema\->resultset(\*(AqArtist\*(Aq)\->search( undef, { cache => 1 } );
\&
\&  while( my $artist = $resultset\->next ) {
\&    ... do stuff ...
\&  }
\&
\&  $rs\->first; # without cache, this would issue a query
.Ve
.PP
By default, searches are not cached.
.PP
For more examples of using these attributes, see
DBIx::Class::Manual::Cookbook.
.SS "for"
.IX Subsection "for"
.IP "Value: ( 'update' | 'shared' | \e$scalar )" 4
.IX Item "Value: ( 'update' | 'shared' | $scalar )"
.PP
Set to 'update' for a \s-1SELECT ... FOR UPDATE\s0 or 'shared' for a \s-1SELECT
\&... FOR SHARED.\s0 If \e$scalar is passed, this is taken directly and embedded in the
query.
.SH "PREFETCHING"
.IX Header "PREFETCHING"
DBIx::Class supports arbitrary related data prefetching from multiple related
sources. Any combination of relationship types and column sets are supported.
If collapsing is requested, there is an additional requirement of
selecting enough data to make every individual object uniquely identifiable.
.PP
Here are some more involved examples, based on the following relationship map:
.PP
.Vb 4
\&  # Assuming:
\&  My::Schema::CD\->belongs_to( artist      => \*(AqMy::Schema::Artist\*(Aq     );
\&  My::Schema::CD\->might_have( liner_note  => \*(AqMy::Schema::LinerNotes\*(Aq );
\&  My::Schema::CD\->has_many(   tracks      => \*(AqMy::Schema::Track\*(Aq      );
\&
\&  My::Schema::Artist\->belongs_to( record_label => \*(AqMy::Schema::RecordLabel\*(Aq );
\&
\&  My::Schema::Track\->has_many( guests => \*(AqMy::Schema::Guest\*(Aq );
\&
\&
\&
\&  my $rs = $schema\->resultset(\*(AqTag\*(Aq)\->search(
\&    undef,
\&    {
\&      prefetch => {
\&        cd => \*(Aqartist\*(Aq
\&      }
\&    }
\&  );
.Ve
.PP
The initial search results in \s-1SQL\s0 like the following:
.PP
.Vb 3
\&  SELECT tag.*, cd.*, artist.* FROM tag
\&  JOIN cd ON tag.cd = cd.cdid
\&  JOIN artist ON cd.artist = artist.artistid
.Ve
.PP
DBIx::Class has no need to go back to the database when we access the
\&\f(CW\*(C`cd\*(C'\fR or \f(CW\*(C`artist\*(C'\fR relationships, which saves us two \s-1SQL\s0 statements in this
case.
.PP
Simple prefetches will be joined automatically, so there is no need
for a \f(CW\*(C`join\*(C'\fR attribute in the above search.
.PP
The \*(L"prefetch\*(R" attribute can be used with any of the relationship types
and multiple prefetches can be specified together. Below is a more complex
example that prefetches a \s-1CD\s0's artist, its liner notes (if present),
the cover image, the tracks on that \s-1CD,\s0 and the guests on those
tracks.
.PP
.Vb 11
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    undef,
\&    {
\&      prefetch => [
\&        { artist => \*(Aqrecord_label\*(Aq},  # belongs_to => belongs_to
\&        \*(Aqliner_note\*(Aq,                 # might_have
\&        \*(Aqcover_image\*(Aq,                # has_one
\&        { tracks => \*(Aqguests\*(Aq },       # has_many => has_many
\&      ]
\&    }
\&  );
.Ve
.PP
This will produce \s-1SQL\s0 like the following:
.PP
.Vb 10
\&  SELECT cd.*, artist.*, record_label.*, liner_note.*, cover_image.*,
\&         tracks.*, guests.*
\&    FROM cd me
\&    JOIN artist artist
\&      ON artist.artistid = me.artistid
\&    JOIN record_label record_label
\&      ON record_label.labelid = artist.labelid
\&    LEFT JOIN track tracks
\&      ON tracks.cdid = me.cdid
\&    LEFT JOIN guest guests
\&      ON guests.trackid = track.trackid
\&    LEFT JOIN liner_notes liner_note
\&      ON liner_note.cdid = me.cdid
\&    JOIN cd_artwork cover_image
\&      ON cover_image.cdid = me.cdid
\&  ORDER BY tracks.cd
.Ve
.PP
Now the \f(CW\*(C`artist\*(C'\fR, \f(CW\*(C`record_label\*(C'\fR, \f(CW\*(C`liner_note\*(C'\fR, \f(CW\*(C`cover_image\*(C'\fR,
\&\f(CW\*(C`tracks\*(C'\fR, and \f(CW\*(C`guests\*(C'\fR of the \s-1CD\s0 will all be available through the
relationship accessors without the need for additional queries to the
database.
.PP
\fI\s-1CAVEATS\s0\fR
.IX Subsection "CAVEATS"
.PP
Prefetch does a lot of deep magic. As such, it may not behave exactly
as you might expect.
.IP "\(bu" 4
Prefetch uses the \*(L"cache\*(R" to populate the prefetched relationships. This
may or may not be what you want.
.IP "\(bu" 4
If you specify a condition on a prefetched relationship, \s-1ONLY\s0 those
rows that match the prefetched condition will be fetched into that relationship.
This means that adding prefetch to a \fIsearch()\fR \fBmay alter\fR what is returned by
traversing a relationship. So, if you have \f(CW\*(C`Artist\->has_many(CDs)\*(C'\fR and you do
.Sp
.Vb 5
\&  my $artist_rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&      \*(Aqcds.year\*(Aq => 2008,
\&  }, {
\&      join => \*(Aqcds\*(Aq,
\&  });
\&
\&  my $count = $artist_rs\->first\->cds\->count;
\&
\&  my $artist_rs_prefetch = $artist_rs\->search( {}, { prefetch => \*(Aqcds\*(Aq } );
\&
\&  my $prefetch_count = $artist_rs_prefetch\->first\->cds\->count;
\&
\&  cmp_ok( $count, \*(Aq==\*(Aq, $prefetch_count, "Counts should be the same" );
.Ve
.Sp
That \fIcmp_ok()\fR may or may not pass depending on the datasets involved. In other
words the \f(CW\*(C`WHERE\*(C'\fR condition would apply to the entire dataset, just like
it would in regular \s-1SQL.\s0 If you want to add a condition only to the \*(L"right side\*(R"
of a \f(CW\*(C`LEFT JOIN\*(C'\fR \- consider declaring and using a relationship with a custom
condition
.SH "DBIC BIND VALUES"
.IX Header "DBIC BIND VALUES"
Because \s-1DBIC\s0 may need more information to bind values than just the column name
and value itself, it uses a special format for both passing and receiving bind
values.  Each bind value should be composed of an arrayref of
\&\f(CW\*(C`[ \e%args => $val ]\*(C'\fR.  The format of \f(CW\*(C`\e%args\*(C'\fR is currently:
.IP "dbd_attrs" 4
.IX Item "dbd_attrs"
If present (in any form), this is what is being passed directly to bind_param.
Note that different \s-1DBD\s0's expect different bind args.  (e.g. DBD::SQLite takes
a single numerical type, while DBD::Pg takes a hashref if bind options.)
.Sp
If this is specified, all other bind options described below are ignored.
.IP "sqlt_datatype" 4
.IX Item "sqlt_datatype"
If present, this is used to infer the actual bind attribute by passing to
\&\f(CW\*(C`$resolved_storage\->bind_attribute_by_data_type()\*(C'\fR.  Defaults to the
\&\*(L"data_type\*(R" from the add_columns column info.
.Sp
Note that the data type is somewhat freeform (hence the sqlt_ prefix);
currently drivers are expected to \*(L"Do the Right Thing\*(R" when given a common
datatype name.  (Not ideal, but that's what we got at this point.)
.IP "sqlt_size" 4
.IX Item "sqlt_size"
Currently used to correctly allocate buffers for \fIbind_param_inout()\fR.
Defaults to \*(L"size\*(R" from the add_columns column info,
or to a sensible value based on the \*(L"data_type\*(R".
.IP "dbic_colname" 4
.IX Item "dbic_colname"
Used to fill in missing sqlt_datatype and sqlt_size attributes (if they are
explicitly specified they are never overridden).  Also used by some weird DBDs,
where the column name should be available at bind_param time (e.g. Oracle).
.PP
For backwards compatibility and convenience, the following shortcuts are
supported:
.PP
.Vb 4
\&  [ $name => $val ] === [ { dbic_colname => $name }, $val ]
\&  [ \e$dt  => $val ] === [ { sqlt_datatype => $dt }, $val ]
\&  [ undef,   $val ] === [ {}, $val ]
\&  $val              === [ {}, $val ]
.Ve
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSetColumn.3pm             0100644 0001750 0001750 00000025011 12566242377 026463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSetColumn 3"
.TH DBIx::Class::ResultSetColumn 3 "2014-01-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 2
\&  DBIx::Class::ResultSetColumn \- helpful methods for messing
\&  with a single column of the resultset
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ artist => \*(AqTool\*(Aq });
\&  $rs_column = $rs\->get_column(\*(Aqyear\*(Aq);
\&  $max_year = $rs_column\->max; #returns latest year
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A convenience class used to perform operations on a specific column of
a resultset.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $obj = DBIx::Class::ResultSetColumn\->new($rs, $column);
.Ve
.PP
Creates a new resultset column object from the resultset and column
passed as params. Used internally by \*(L"get_column\*(R" in DBIx::Class::ResultSet.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind_values ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind_values\fR ]" 4
.IX Item "Return Value: [ $sql, @bind_values ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Returns the next value of the column in the resultset (or \f(CW\*(C`undef\*(C'\fR if
there is none).
.PP
Much like \*(L"next\*(R" in DBIx::Class::ResultSet but just returning the
one value.
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @values" 4
.el .IP "Return Value: \f(CW@values\fR" 4
.IX Item "Return Value: @values"
.PD
.PP
Returns all values of the column in the resultset (or \f(CW\*(C`undef\*(C'\fR if
there are none).
.PP
Much like \*(L"all\*(R" in DBIx::Class::ResultSet but returns values rather
than result objects.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the underlying resultset's cursor, so you can iterate through the
elements of the column again.
.PP
Much like \*(L"reset\*(R" in DBIx::Class::ResultSet.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Resets the underlying resultset and returns the next value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there is none).
.PP
Much like \*(L"first\*(R" in DBIx::Class::ResultSet but just returning the one value.
.SS "single"
.IX Subsection "single"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Much like \*(L"single\*(R" in DBIx::Class::ResultSet fetches one and only one column
value using the cursor directly. If additional rows are present a warning
is issued before discarding the cursor.
.SS "min"
.IX Subsection "min"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $lowest_value" 4
.el .IP "Return Value: \f(CW$lowest_value\fR" 4
.IX Item "Return Value: $lowest_value"
.PD
.PP
.Vb 1
\&  my $first_year = $year_col\->min();
.Ve
.PP
Wrapper for \->func. Returns the lowest value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there are none).
.SS "min_rs"
.IX Subsection "min_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->min_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fIMIN\s0()\fR.
.SS "max"
.IX Subsection "max"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $highest_value" 4
.el .IP "Return Value: \f(CW$highest_value\fR" 4
.IX Item "Return Value: $highest_value"
.PD
.PP
.Vb 1
\&  my $last_year = $year_col\->max();
.Ve
.PP
Wrapper for \->func. Returns the highest value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there are none).
.SS "max_rs"
.IX Subsection "max_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->max_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fIMAX\s0()\fR.
.SS "sum"
.IX Subsection "sum"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $sum_of_values" 4
.el .IP "Return Value: \f(CW$sum_of_values\fR" 4
.IX Item "Return Value: $sum_of_values"
.PD
.PP
.Vb 1
\&  my $total = $prices_col\->sum();
.Ve
.PP
Wrapper for \->func. Returns the sum of all the values in the column of
the resultset. Use on varchar-like columns at your own risk.
.SS "sum_rs"
.IX Subsection "sum_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->sum_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fISUM\s0()\fR.
.SS "func"
.IX Subsection "func"
.ie n .IP "Arguments: $function" 4
.el .IP "Arguments: \f(CW$function\fR" 4
.IX Item "Arguments: $function"
.PD 0
.ie n .IP "Return Value: $function_return_value" 4
.el .IP "Return Value: \f(CW$function_return_value\fR" 4
.IX Item "Return Value: $function_return_value"
.PD
.PP
.Vb 2
\&  $rs = $schema\->resultset("CD")\->search({});
\&  $length = $rs\->get_column(\*(Aqtitle\*(Aq)\->func(\*(AqLENGTH\*(Aq);
.Ve
.PP
Runs a query using the function on the column and returns the
value. Produces the following \s-1SQL:\s0
.PP
.Vb 1
\&  SELECT LENGTH( title ) FROM cd me
.Ve
.SS "func_rs"
.IX Subsection "func_rs"
.ie n .IP "Arguments: $function" 4
.el .IP "Arguments: \f(CW$function\fR" 4
.IX Item "Arguments: $function"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Creates the resultset that \f(CW\*(C`func()\*(C'\fR uses to run its query.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSetColumn5.16.3pm         0100644 0001750 0001750 00000024401 12566242362 026771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSetColumn 3"
.TH DBIx::Class::ResultSetColumn 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 2
\&  DBIx::Class::ResultSetColumn \- helpful methods for messing
\&  with a single column of the resultset
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ artist => \*(AqTool\*(Aq });
\&  $rs_column = $rs\->get_column(\*(Aqyear\*(Aq);
\&  $max_year = $rs_column\->max; #returns latest year
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A convenience class used to perform operations on a specific column of
a resultset.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $obj = DBIx::Class::ResultSetColumn\->new($rs, $column);
.Ve
.PP
Creates a new resultset column object from the resultset and column
passed as params. Used internally by \*(L"get_column\*(R" in DBIx::Class::ResultSet.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind\fR ]" 4
.IX Item "Return Value: [ $sql, @bind ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Returns the next value of the column in the resultset (or \f(CW\*(C`undef\*(C'\fR if
there is none).
.PP
Much like \*(L"next\*(R" in DBIx::Class::ResultSet but just returning the
one value.
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @values" 4
.el .IP "Return Value: \f(CW@values\fR" 4
.IX Item "Return Value: @values"
.PD
.PP
Returns all values of the column in the resultset (or \f(CW\*(C`undef\*(C'\fR if
there are none).
.PP
Much like \*(L"all\*(R" in DBIx::Class::ResultSet but returns values rather
than row objects.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the underlying resultset's cursor, so you can iterate through the
elements of the column again.
.PP
Much like \*(L"reset\*(R" in DBIx::Class::ResultSet.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Resets the underlying resultset and returns the next value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there is none).
.PP
Much like \*(L"first\*(R" in DBIx::Class::ResultSet but just returning the one value.
.SS "single"
.IX Subsection "single"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Much like \*(L"single\*(R" in DBIx::Class::ResultSet fetches one and only one column
value using the cursor directly. If additional rows are present a warning
is issued before discarding the cursor.
.SS "min"
.IX Subsection "min"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $lowest_value" 4
.el .IP "Return Value: \f(CW$lowest_value\fR" 4
.IX Item "Return Value: $lowest_value"
.PD
.PP
.Vb 1
\&  my $first_year = $year_col\->min();
.Ve
.PP
Wrapper for \->func. Returns the lowest value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there are none).
.SS "min_rs"
.IX Subsection "min_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->min_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fIMIN\s0()\fR.
.SS "max"
.IX Subsection "max"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $highest_value" 4
.el .IP "Return Value: \f(CW$highest_value\fR" 4
.IX Item "Return Value: $highest_value"
.PD
.PP
.Vb 1
\&  my $last_year = $year_col\->max();
.Ve
.PP
Wrapper for \->func. Returns the highest value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there are none).
.SS "max_rs"
.IX Subsection "max_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->max_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fIMAX\s0()\fR.
.SS "sum"
.IX Subsection "sum"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $sum_of_values" 4
.el .IP "Return Value: \f(CW$sum_of_values\fR" 4
.IX Item "Return Value: $sum_of_values"
.PD
.PP
.Vb 1
\&  my $total = $prices_col\->sum();
.Ve
.PP
Wrapper for \->func. Returns the sum of all the values in the column of
the resultset. Use on varchar-like columns at your own risk.
.SS "sum_rs"
.IX Subsection "sum_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->sum_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fISUM\s0()\fR.
.SS "func"
.IX Subsection "func"
.ie n .IP "Arguments: $function" 4
.el .IP "Arguments: \f(CW$function\fR" 4
.IX Item "Arguments: $function"
.PD 0
.ie n .IP "Return Value: $function_return_value" 4
.el .IP "Return Value: \f(CW$function_return_value\fR" 4
.IX Item "Return Value: $function_return_value"
.PD
.PP
.Vb 2
\&  $rs = $schema\->resultset("CD")\->search({});
\&  $length = $rs\->get_column(\*(Aqtitle\*(Aq)\->func(\*(AqLENGTH\*(Aq);
.Ve
.PP
Runs a query using the function on the column and returns the
value. Produces the following \s-1SQL:\s0
.PP
.Vb 1
\&  SELECT LENGTH( title ) FROM cd me
.Ve
.SS "func_rs"
.IX Subsection "func_rs"
.ie n .IP "Arguments: $function" 4
.el .IP "Arguments: \f(CW$function\fR" 4
.IX Item "Arguments: $function"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Creates the resultset that \f(CW\*(C`func()\*(C'\fR uses to run its query.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Luke Saunders <luke.saunders@gmail.com>
.PP
Jess Robinson
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSetColumn5.18.3pm         0100644 0001750 0001750 00000025011 12566242377 026777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSetColumn 3"
.TH DBIx::Class::ResultSetColumn 3 "2014-01-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 2
\&  DBIx::Class::ResultSetColumn \- helpful methods for messing
\&  with a single column of the resultset
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ artist => \*(AqTool\*(Aq });
\&  $rs_column = $rs\->get_column(\*(Aqyear\*(Aq);
\&  $max_year = $rs_column\->max; #returns latest year
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A convenience class used to perform operations on a specific column of
a resultset.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $obj = DBIx::Class::ResultSetColumn\->new($rs, $column);
.Ve
.PP
Creates a new resultset column object from the resultset and column
passed as params. Used internally by \*(L"get_column\*(R" in DBIx::Class::ResultSet.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind_values ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind_values\fR ]" 4
.IX Item "Return Value: [ $sql, @bind_values ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Returns the next value of the column in the resultset (or \f(CW\*(C`undef\*(C'\fR if
there is none).
.PP
Much like \*(L"next\*(R" in DBIx::Class::ResultSet but just returning the
one value.
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @values" 4
.el .IP "Return Value: \f(CW@values\fR" 4
.IX Item "Return Value: @values"
.PD
.PP
Returns all values of the column in the resultset (or \f(CW\*(C`undef\*(C'\fR if
there are none).
.PP
Much like \*(L"all\*(R" in DBIx::Class::ResultSet but returns values rather
than result objects.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the underlying resultset's cursor, so you can iterate through the
elements of the column again.
.PP
Much like \*(L"reset\*(R" in DBIx::Class::ResultSet.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Resets the underlying resultset and returns the next value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there is none).
.PP
Much like \*(L"first\*(R" in DBIx::Class::ResultSet but just returning the one value.
.SS "single"
.IX Subsection "single"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Much like \*(L"single\*(R" in DBIx::Class::ResultSet fetches one and only one column
value using the cursor directly. If additional rows are present a warning
is issued before discarding the cursor.
.SS "min"
.IX Subsection "min"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $lowest_value" 4
.el .IP "Return Value: \f(CW$lowest_value\fR" 4
.IX Item "Return Value: $lowest_value"
.PD
.PP
.Vb 1
\&  my $first_year = $year_col\->min();
.Ve
.PP
Wrapper for \->func. Returns the lowest value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there are none).
.SS "min_rs"
.IX Subsection "min_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->min_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fIMIN\s0()\fR.
.SS "max"
.IX Subsection "max"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $highest_value" 4
.el .IP "Return Value: \f(CW$highest_value\fR" 4
.IX Item "Return Value: $highest_value"
.PD
.PP
.Vb 1
\&  my $last_year = $year_col\->max();
.Ve
.PP
Wrapper for \->func. Returns the highest value of the column in the
resultset (or \f(CW\*(C`undef\*(C'\fR if there are none).
.SS "max_rs"
.IX Subsection "max_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->max_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fIMAX\s0()\fR.
.SS "sum"
.IX Subsection "sum"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $sum_of_values" 4
.el .IP "Return Value: \f(CW$sum_of_values\fR" 4
.IX Item "Return Value: $sum_of_values"
.PD
.PP
.Vb 1
\&  my $total = $prices_col\->sum();
.Ve
.PP
Wrapper for \->func. Returns the sum of all the values in the column of
the resultset. Use on varchar-like columns at your own risk.
.SS "sum_rs"
.IX Subsection "sum_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $year_col\->sum_rs();
.Ve
.PP
Wrapper for \->func_rs for function \s-1\fISUM\s0()\fR.
.SS "func"
.IX Subsection "func"
.ie n .IP "Arguments: $function" 4
.el .IP "Arguments: \f(CW$function\fR" 4
.IX Item "Arguments: $function"
.PD 0
.ie n .IP "Return Value: $function_return_value" 4
.el .IP "Return Value: \f(CW$function_return_value\fR" 4
.IX Item "Return Value: $function_return_value"
.PD
.PP
.Vb 2
\&  $rs = $schema\->resultset("CD")\->search({});
\&  $length = $rs\->get_column(\*(Aqtitle\*(Aq)\->func(\*(AqLENGTH\*(Aq);
.Ve
.PP
Runs a query using the function on the column and returns the
value. Produces the following \s-1SQL:\s0
.PP
.Vb 1
\&  SELECT LENGTH( title ) FROM cd me
.Ve
.SS "func_rs"
.IX Subsection "func_rs"
.ie n .IP "Arguments: $function" 4
.el .IP "Arguments: \f(CW$function\fR" 4
.IX Item "Arguments: $function"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Creates the resultset that \f(CW\*(C`func()\*(C'\fR uses to run its query.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSetManager.3pm            0100644 0001750 0001750 00000010776 12566242400 026577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSetManager 3"
.TH DBIx::Class::ResultSetManager 3 "2013-07-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSetManager \- scheduled for deletion in 09000
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Class::ResultSetManager never left experimental status and
has now been \s-1DEPRECATED.\s0 This module will be deleted in 09000 so please
migrate any and all code using it to explicit resultset classes using either
_\|_PACKAGE_\|_\->resultset_class(...) calls or by switching from using
DBIx::Class::Schema\->\fIload_classes()\fR to \fIload_namespaces()\fR and creating
appropriate My::Schema::ResultSet::* classes for it to pick up.";
  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSetManager5.16.3pm        0100644 0001750 0001750 00000010455 12566242362 027112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSetManager 3"
.TH DBIx::Class::ResultSetManager 3 "2011-05-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSetManager \- scheduled for deletion in 09000
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Class::ResultSetManager never left experimental status and
has now been \s-1DEPRECATED\s0. This module will be deleted in 09000 so please
migrate any and all code using it to explicit resultset classes using either
_\|_PACKAGE_\|_\->resultset_class(...) calls or by switching from using
DBIx::Class::Schema\->\fIload_classes()\fR to \fIload_namespaces()\fR and creating
appropriate My::Schema::ResultSet::* classes for it to pick up.";
                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSetManager5.18.3pm        0100644 0001750 0001750 00000010776 12566242400 027113  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSetManager 3"
.TH DBIx::Class::ResultSetManager 3 "2013-07-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSetManager \- scheduled for deletion in 09000
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Class::ResultSetManager never left experimental status and
has now been \s-1DEPRECATED.\s0 This module will be deleted in 09000 so please
migrate any and all code using it to explicit resultset classes using either
_\|_PACKAGE_\|_\->resultset_class(...) calls or by switching from using
DBIx::Class::Schema\->\fIload_classes()\fR to \fIload_namespaces()\fR and creating
appropriate My::Schema::ResultSet::* classes for it to pick up.";
  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource.3pm                0100644 0001750 0001750 00000111712 12566242377 026016  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource 3"
.TH DBIx::Class::ResultSource 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource \- Result source object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Create a table based result source, in a result class.
\&
\&  package MyApp::Schema::Result::Artist;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqartist\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ artistid name /);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqartistid\*(Aq);
\&  _\|_PACKAGE_\|_\->has_many(cds => \*(AqMyApp::Schema::Result::CD\*(Aq);
\&
\&  1;
\&
\&  # Create a query (view) based result source, in a result class
\&  package MyApp::Schema::Result::Year2000CDs;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->load_components(\*(AqInflateColumn::DateTime\*(Aq);
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::View\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqyear2000cds\*(Aq);
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&      );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSource is an object that represents a source of data for querying.
.PP
This class is a base class for various specialised types of result
sources, for example DBIx::Class::ResultSource::Table. Table is the
default result source type, so one is created for you when defining a
result class as described in the synopsis above.
.PP
More specifically, the DBIx::Class::Core base class pulls in the
DBIx::Class::ResultSourceProxy::Table component, which defines
the table method.
When called, \f(CW\*(C`table\*(C'\fR creates and stores an instance of
DBIx::Class::ResultSoure::Table. Luckily, to use tables as result
sources, you don't need to remember any of this.
.PP
Result sources representing select queries, or views, can also be
created, see DBIx::Class::ResultSource::View for full details.
.SS "Finding result source objects"
.IX Subsection "Finding result source objects"
As mentioned above, a result source instance is created and stored for
you when you define a result class.
.PP
You can retrieve the result source at runtime in the following ways:
.IP "From a Schema object:" 4
.IX Item "From a Schema object:"
.Vb 1
\&   $schema\->source($source_name);
.Ve
.IP "From a Result object:" 4
.IX Item "From a Result object:"
.Vb 1
\&   $result\->result_source;
.Ve
.IP "From a ResultSet object:" 4
.IX Item "From a ResultSet object:"
.Vb 1
\&   $rs\->result_source;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "add_columns"
.IX Subsection "add_columns"
.ie n .IP "Arguments: @columns" 4
.el .IP "Arguments: \f(CW@columns\fR" 4
.IX Item "Arguments: @columns"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
.Vb 1
\&  $source\->add_columns(qw/col1 col2 col3/);
\&
\&  $source\->add_columns(\*(Aqcol1\*(Aq => \e%col1_info, \*(Aqcol2\*(Aq => \e%col2_info, ...);
.Ve
.PP
Adds columns to the result source. If supplied colname => hashref
pairs, uses the hashref as the \*(L"column_info\*(R" for that column. Repeated
calls of this method will add more columns, not replace them.
.PP
The column names given will be created as accessor methods on your
Result objects. You can change the name of the accessor
by supplying an \*(L"accessor\*(R" in the column_info hash.
.PP
If a column name beginning with a plus sign ('+col1') is provided, the
attributes provided will be merged with any existing attributes for the
column, with the new attributes taking precedence in the case that an
attribute already exists. Using this without a hashref
(\f(CW\*(C`$source\->add_columns(qw/+col1 +col2/)\*(C'\fR) is legal, but useless \*(--
it does the same thing it would do without the plus.
.PP
The contents of the column_info are not set in stone. The following
keys are currently recognised/used by DBIx::Class:
.IP "accessor" 4
.IX Item "accessor"
.Vb 1
\&   { accessor => \*(Aq_name\*(Aq }
\&
\&   # example use, replace standard accessor with one of your own:
\&   sub name {
\&       my ($self, $value) = @_;
\&
\&       die "Name cannot contain digits!" if($value =~ /\ed/);
\&       $self\->_name($value);
\&
\&       return $self\->_name();
\&   }
.Ve
.Sp
Use this to set the name of the accessor method for this column. If unset,
the name of the column will be used.
.IP "data_type" 4
.IX Item "data_type"
.Vb 1
\&   { data_type => \*(Aqinteger\*(Aq }
.Ve
.Sp
This contains the column type. It is automatically filled if you use the
SQL::Translator::Producer::DBIx::Class::File producer, or the
DBIx::Class::Schema::Loader module.
.Sp
Currently there is no standard set of values for the data_type. Use
whatever your database supports.
.IP "size" 4
.IX Item "size"
.Vb 1
\&   { size => 20 }
.Ve
.Sp
The length of your column, if it is a column type that can have a size
restriction. This is currently only used to create tables from your
schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_nullable" 4
.IX Item "is_nullable"
.Vb 1
\&   { is_nullable => 1 }
.Ve
.Sp
Set this to a true value for a columns that is allowed to contain \s-1NULL\s0
values, default is false. This is currently only used to create tables
from your schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_auto_increment" 4
.IX Item "is_auto_increment"
.Vb 1
\&   { is_auto_increment => 1 }
.Ve
.Sp
Set this to a true value for a column whose value is somehow
automatically set, defaults to false. This is used to determine which
columns to empty when cloning objects using
\&\*(L"copy\*(R" in DBIx::Class::Row. It is also used by
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_numeric" 4
.IX Item "is_numeric"
.Vb 1
\&   { is_numeric => 1 }
.Ve
.Sp
Set this to a true or false value (not \f(CW\*(C`undef\*(C'\fR) to explicitly specify
if this column contains numeric data. This controls how set_column
decides whether to consider a column dirty after an update: if
\&\f(CW\*(C`is_numeric\*(C'\fR is true a numeric comparison \f(CW\*(C`!=\*(C'\fR will take place
instead of the usual \f(CW\*(C`eq\*(C'\fR
.Sp
If not specified the storage class will attempt to figure this out on
first access to the column, based on the column \f(CW\*(C`data_type\*(C'\fR. The
result will be cached in this attribute.
.IP "is_foreign_key" 4
.IX Item "is_foreign_key"
.Vb 1
\&   { is_foreign_key => 1 }
.Ve
.Sp
Set this to a true value for a column that contains a key from a
foreign table, defaults to false. This is currently only used to
create tables from your schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "default_value" 4
.IX Item "default_value"
.Vb 1
\&   { default_value => \e\*(Aqnow()\*(Aq }
.Ve
.Sp
Set this to the default value which will be inserted into a column by
the database. Can contain either a value or a function (use a
reference to a scalar e.g. \f(CW\*(C`\e\*(Aqnow()\*(Aq\*(C'\fR if you want a function). This
is currently only used to create tables from your schema, see
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.Sp
See the note on \*(L"new\*(R" in DBIx::Class::Row for more information about possible
issues related to db-side default values.
.IP "sequence" 4
.IX Item "sequence"
.Vb 1
\&   { sequence => \*(Aqmy_table_seq\*(Aq }
.Ve
.Sp
Set this on a primary key column to the name of the sequence used to
generate a new key value. If not specified, DBIx::Class::PK::Auto
will attempt to retrieve the name of the sequence from the database
automatically.
.IP "retrieve_on_insert" 4
.IX Item "retrieve_on_insert"
.Vb 1
\&  { retrieve_on_insert => 1 }
.Ve
.Sp
For every column where this is set to true, \s-1DBIC\s0 will retrieve the RDBMS-side
value upon a new row insertion (normally only the autoincrement \s-1PK\s0 is
retrieved on insert). \f(CW\*(C`INSERT ... RETURNING\*(C'\fR is used automatically if
supported by the underlying storage, otherwise an extra \s-1SELECT\s0 statement is
executed to retrieve the missing data.
.IP "auto_nextval" 4
.IX Item "auto_nextval"
.Vb 1
\&   { auto_nextval => 1 }
.Ve
.Sp
Set this to a true value for a column whose value is retrieved automatically
from a sequence or function (if supported by your Storage driver.) For a
sequence, if you do not use a trigger to get the nextval, you have to set the
\&\*(L"sequence\*(R" value as well.
.Sp
Also set this for \s-1MSSQL\s0 columns with the 'uniqueidentifier'
data_type whose values you want to
automatically generate using \f(CW\*(C`NEWID()\*(C'\fR, unless they are a primary key in which
case this will be done anyway.
.IP "extra" 4
.IX Item "extra"
This is used by \*(L"deploy\*(R" in DBIx::Class::Schema and SQL::Translator
to add extra non-generic data to the column. For example: \f(CW\*(C`extra
=> { unsigned => 1}\*(C'\fR is used by the MySQL producer to set an integer
column to unsigned. For more details, see
SQL::Translator::Producer::MySQL.
.SS "add_column"
.IX Subsection "add_column"
.ie n .IP "Arguments: $colname, \e%columninfo?" 4
.el .IP "Arguments: \f(CW$colname\fR, \e%columninfo?" 4
.IX Item "Arguments: $colname, %columninfo?"
.PD 0
.IP "Return Value: 1/0 (true/false)" 4
.IX Item "Return Value: 1/0 (true/false)"
.PD
.PP
.Vb 1
\&  $source\->add_column(\*(Aqcol\*(Aq => \e%info);
.Ve
.PP
Add a single column and optional column info. Uses the same column
info keys as \*(L"add_columns\*(R".
.SS "has_column"
.IX Subsection "has_column"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return Value: 1/0 (true/false)" 4
.IX Item "Return Value: 1/0 (true/false)"
.PD
.PP
.Vb 1
\&  if ($source\->has_column($colname)) { ... }
.Ve
.PP
Returns true if the source has a column of this name, false otherwise.
.SS "column_info"
.IX Subsection "column_info"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return Value: Hashref of info" 4
.IX Item "Return Value: Hashref of info"
.PD
.PP
.Vb 1
\&  my $info = $source\->column_info($col);
.Ve
.PP
Returns the column metadata hashref for a column, as originally passed
to \*(L"add_columns\*(R". See \*(L"add_columns\*(R" above for information on the
contents of the hashref.
.SS "columns"
.IX Subsection "columns"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Ordered list of column names" 4
.IX Item "Return Value: Ordered list of column names"
.PD
.PP
.Vb 1
\&  my @column_names = $source\->columns;
.Ve
.PP
Returns all column names in the order they were declared to \*(L"add_columns\*(R".
.SS "columns_info"
.IX Subsection "columns_info"
.IP "Arguments: \e@colnames ?" 4
.IX Item "Arguments: @colnames ?"
.PD 0
.IP "Return Value: Hashref of column name/info pairs" 4
.IX Item "Return Value: Hashref of column name/info pairs"
.PD
.PP
.Vb 1
\&  my $columns_info = $source\->columns_info;
.Ve
.PP
Like \*(L"column_info\*(R" but returns information for the requested columns. If
the optional column-list arrayref is omitted it returns info on all columns
currently defined on the ResultSource via \*(L"add_columns\*(R".
.SS "remove_columns"
.IX Subsection "remove_columns"
.ie n .IP "Arguments: @colnames" 4
.el .IP "Arguments: \f(CW@colnames\fR" 4
.IX Item "Arguments: @colnames"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 1
\&  $source\->remove_columns(qw/col1 col2 col3/);
.Ve
.PP
Removes the given list of columns by name, from the result source.
.PP
\&\fBWarning\fR: Removing a column that is also used in the sources primary
key, or in one of the sources unique constraints, \fBwill\fR result in a
broken result source.
.SS "remove_column"
.IX Subsection "remove_column"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 1
\&  $source\->remove_column(\*(Aqcol\*(Aq);
.Ve
.PP
Remove a single column by name from the result source, similar to
\&\*(L"remove_columns\*(R".
.PP
\&\fBWarning\fR: Removing a column that is also used in the sources primary
key, or in one of the sources unique constraints, \fBwill\fR result in a
broken result source.
.SS "set_primary_key"
.IX Subsection "set_primary_key"
.ie n .IP "Arguments: @cols" 4
.el .IP "Arguments: \f(CW@cols\fR" 4
.IX Item "Arguments: @cols"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Defines one or more columns as primary key for this source. Must be
called after \*(L"add_columns\*(R".
.PP
Additionally, defines a unique constraint
named \f(CW\*(C`primary\*(C'\fR.
.PP
Note: you normally do want to define a primary key on your sources
\&\fBeven if the underlying database table does not have a primary key\fR.
See
\&\*(L"The Significance and Importance of Primary Keys\*(R" in DBIx::Class::Manual::Intro
for more info.
.SS "primary_columns"
.IX Subsection "primary_columns"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Ordered list of primary column names" 4
.IX Item "Return Value: Ordered list of primary column names"
.PD
.PP
Read-only accessor which returns the list of primary keys, supplied by
\&\*(L"set_primary_key\*(R".
.SS "sequence"
.IX Subsection "sequence"
Manually define the correct sequence for your table, to avoid the overhead
associated with looking up the sequence automatically. The supplied sequence
will be applied to the \*(L"column_info\*(R" of each primary_key
.ie n .IP "Arguments: $sequence_name" 4
.el .IP "Arguments: \f(CW$sequence_name\fR" 4
.IX Item "Arguments: $sequence_name"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.SS "add_unique_constraint"
.IX Subsection "add_unique_constraint"
.ie n .IP "Arguments: $name?, \e@colnames" 4
.el .IP "Arguments: \f(CW$name\fR?, \e@colnames" 4
.IX Item "Arguments: $name?, @colnames"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Declare a unique constraint on this source. Call once for each unique
constraint.
.PP
.Vb 4
\&  # For UNIQUE (column1, column2)
\&  _\|_PACKAGE_\|_\->add_unique_constraint(
\&    constraint_name => [ qw/column1 column2/ ],
\&  );
.Ve
.PP
Alternatively, you can specify only the columns:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->add_unique_constraint([ qw/column1 column2/ ]);
.Ve
.PP
This will result in a unique constraint named
\&\f(CW\*(C`table_column1_column2\*(C'\fR, where \f(CW\*(C`table\*(C'\fR is replaced with the table
name.
.PP
Unique constraints are used, for example, when you pass the constraint
name as the \f(CW\*(C`key\*(C'\fR attribute to \*(L"find\*(R" in DBIx::Class::ResultSet. Then
only columns in the constraint are searched.
.PP
Throws an error if any of the given column names do not yet exist on
the result source.
.SS "add_unique_constraints"
.IX Subsection "add_unique_constraints"
.ie n .IP "Arguments: @constraints" 4
.el .IP "Arguments: \f(CW@constraints\fR" 4
.IX Item "Arguments: @constraints"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Declare multiple unique constraints on this source.
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->add_unique_constraints(
\&    constraint_name1 => [ qw/column1 column2/ ],
\&    constraint_name2 => [ qw/column2 column3/ ],
\&  );
.Ve
.PP
Alternatively, you can specify only the columns:
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->add_unique_constraints(
\&    [ qw/column1 column2/ ],
\&    [ qw/column3 column4/ ]
\&  );
.Ve
.PP
This will result in unique constraints named \f(CW\*(C`table_column1_column2\*(C'\fR and
\&\f(CW\*(C`table_column3_column4\*(C'\fR, where \f(CW\*(C`table\*(C'\fR is replaced with the table name.
.PP
Throws an error if any of the given column names do not yet exist on
the result source.
.PP
See also \*(L"add_unique_constraint\*(R".
.SS "name_unique_constraint"
.IX Subsection "name_unique_constraint"
.IP "Arguments: \e@colnames" 4
.IX Item "Arguments: @colnames"
.PD 0
.IP "Return Value: Constraint name" 4
.IX Item "Return Value: Constraint name"
.PD
.PP
.Vb 4
\&  $source\->table(\*(Aqmytable\*(Aq);
\&  $source\->name_unique_constraint([\*(Aqcol1\*(Aq, \*(Aqcol2\*(Aq]);
\&  # returns
\&  \*(Aqmytable_col1_col2\*(Aq
.Ve
.PP
Return a name for a unique constraint containing the specified
columns. The name is created by joining the table name and each column
name, using an underscore character.
.PP
For example, a constraint on a table named \f(CW\*(C`cd\*(C'\fR containing the columns
\&\f(CW\*(C`artist\*(C'\fR and \f(CW\*(C`title\*(C'\fR would result in a constraint name of \f(CW\*(C`cd_artist_title\*(C'\fR.
.PP
This is used by \*(L"add_unique_constraint\*(R" if you do not specify the
optional constraint name.
.SS "unique_constraints"
.IX Subsection "unique_constraints"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Hash of unique constraint data" 4
.IX Item "Return Value: Hash of unique constraint data"
.PD
.PP
.Vb 1
\&  $source\->unique_constraints();
.Ve
.PP
Read-only accessor which returns a hash of unique constraints on this
source.
.PP
The hash is keyed by constraint name, and contains an arrayref of
column names as values.
.SS "unique_constraint_names"
.IX Subsection "unique_constraint_names"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Unique constraint names" 4
.IX Item "Return Value: Unique constraint names"
.PD
.PP
.Vb 1
\&  $source\->unique_constraint_names();
.Ve
.PP
Returns the list of unique constraint names defined on this source.
.SS "unique_constraint_columns"
.IX Subsection "unique_constraint_columns"
.ie n .IP "Arguments: $constraintname" 4
.el .IP "Arguments: \f(CW$constraintname\fR" 4
.IX Item "Arguments: $constraintname"
.PD 0
.IP "Return Value: List of constraint columns" 4
.IX Item "Return Value: List of constraint columns"
.PD
.PP
.Vb 1
\&  $source\->unique_constraint_columns(\*(Aqmyconstraint\*(Aq);
.Ve
.PP
Returns the list of columns that make up the specified unique constraint.
.SS "sqlt_deploy_callback"
.IX Subsection "sqlt_deploy_callback"
.ie n .IP "Arguments: $callback_name | \e&callback_code" 4
.el .IP "Arguments: \f(CW$callback_name\fR | \e&callback_code" 4
.IX Item "Arguments: $callback_name | &callback_code"
.PD 0
.ie n .IP "Return Value: $callback_name | \e&callback_code" 4
.el .IP "Return Value: \f(CW$callback_name\fR | \e&callback_code" 4
.IX Item "Return Value: $callback_name | &callback_code"
.PD
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->sqlt_deploy_callback(\*(Aqmycallbackmethod\*(Aq);
\&
\&   or
\&
\&  _\|_PACKAGE_\|_\->sqlt_deploy_callback(sub {
\&    my ($source_instance, $sqlt_table) = @_;
\&    ...
\&  } );
.Ve
.PP
An accessor to set a callback to be called during deployment of
the schema via \*(L"create_ddl_dir\*(R" in DBIx::Class::Schema or
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.PP
The callback can be set as either a code reference or the name of a
method in the current result class.
.PP
Defaults to \*(L"default_sqlt_deploy_hook\*(R".
.PP
Your callback will be passed the \f(CW$source\fR object representing the
ResultSource instance being deployed, and the
SQL::Translator::Schema::Table object being created from it. The
callback can be used to manipulate the table object or add your own
customised indexes. If you need to manipulate a non-table object, use
the \*(L"sqlt_deploy_hook\*(R" in DBIx::Class::Schema.
.PP
See \*(L"Adding Indexes And Functions To
Your \s-1SQL\*(R"\s0 in DBIx::Class::Manual::Cookbook for examples.
.PP
This sqlt deployment callback can only be used to manipulate
SQL::Translator objects as they get turned into \s-1SQL.\s0 To execute
post-deploy statements which SQL::Translator does not currently
handle, override \*(L"deploy\*(R" in DBIx::Class::Schema in your Schema class
and call dbh_do.
.SS "default_sqlt_deploy_hook"
.IX Subsection "default_sqlt_deploy_hook"
This is the default deploy hook implementation which checks if your
current Result class has a \f(CW\*(C`sqlt_deploy_hook\*(C'\fR method, and if present
invokes it \fBon the Result class directly\fR. This is to preserve the
semantics of \f(CW\*(C`sqlt_deploy_hook\*(C'\fR which was originally designed to expect
the Result class name and the
\&\f(CW$sqlt_table\fR instance of the table being
deployed.
.SS "result_class"
.IX Subsection "result_class"
.ie n .IP "Arguments: $classname" 4
.el .IP "Arguments: \f(CW$classname\fR" 4
.IX Item "Arguments: $classname"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
.Vb 2
\& use My::Schema::ResultClass::Inflator;
\& ...
\&
\& use My::Schema::Artist;
\& ...
\& _\|_PACKAGE_\|_\->result_class(\*(AqMy::Schema::ResultClass::Inflator\*(Aq);
.Ve
.PP
Set the default result class for this source. You can use this to create
and use your own result inflator. See \*(L"result_class\*(R" in DBIx::Class::ResultSet
for more details.
.PP
Please note that setting this to something like
DBIx::Class::ResultClass::HashRefInflator will make every result unblessed
and make life more difficult.  Inflators like those are better suited to
temporary usage via \*(L"result_class\*(R" in DBIx::Class::ResultSet.
.SS "resultset"
.IX Subsection "resultset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a resultset for the given source. This will initially be created
on demand by calling
.PP
.Vb 1
\&  $self\->resultset_class\->new($self, $self\->resultset_attributes)
.Ve
.PP
but is cached from then on unless resultset_class changes.
.SS "resultset_class"
.IX Subsection "resultset_class"
.ie n .IP "Arguments: $classname" 4
.el .IP "Arguments: \f(CW$classname\fR" 4
.IX Item "Arguments: $classname"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
.Vb 3
\&  package My::Schema::ResultSet::Artist;
\&  use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&  ...
\&
\&  # In the result class
\&  _\|_PACKAGE_\|_\->resultset_class(\*(AqMy::Schema::ResultSet::Artist\*(Aq);
\&
\&  # Or in code
\&  $source\->resultset_class(\*(AqMy::Schema::ResultSet::Artist\*(Aq);
.Ve
.PP
Set the class of the resultset. This is useful if you want to create your
own resultset methods. Create your own class derived from
DBIx::Class::ResultSet, and set it here. If called with no arguments,
this method returns the name of the existing resultset class, if one
exists.
.SS "resultset_attributes"
.IX Subsection "resultset_attributes"
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Return Value: \e%attrs" 4
.IX Item "Return Value: %attrs"
.PD
.PP
.Vb 2
\&  # In the result class
\&  _\|_PACKAGE_\|_\->resultset_attributes({ order_by => [ \*(Aqid\*(Aq ] });
\&
\&  # Or in code
\&  $source\->resultset_attributes({ order_by => [ \*(Aqid\*(Aq ] });
.Ve
.PP
Store a collection of resultset attributes, that will be set on every
DBIx::Class::ResultSet produced from this result source.
.PP
\&\fB\s-1CAVEAT\s0\fR: \f(CW\*(C`resultset_attributes\*(C'\fR comes with its own set of issues and
bugs! While \f(CW\*(C`resultset_attributes\*(C'\fR isn't deprecated per se, its usage is
not recommended!
.PP
Since relationships use attributes to link tables together, the \*(L"default\*(R"
attributes you set may cause unpredictable and undesired behavior.  Furthermore,
the defaults cannot be turned off, so you are stuck with them.
.PP
In most cases, what you should actually be using are project-specific methods:
.PP
.Vb 3
\&  package My::Schema::ResultSet::Artist;
\&  use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&  ...
\&
\&  # BAD IDEA!
\&  #_\|_PACKAGE_\|_\->resultset_attributes({ prefetch => \*(Aqtracks\*(Aq });
\&
\&  # GOOD IDEA!
\&  sub with_tracks { shift\->search({}, { prefetch => \*(Aqtracks\*(Aq }) }
\&
\&  # in your code
\&  $schema\->resultset(\*(AqArtist\*(Aq)\->with_tracks\->...
.Ve
.PP
This gives you the flexibility of not using it when you don't need it.
.PP
For more complex situations, another solution would be to use a virtual view
via DBIx::Class::ResultSource::View.
.SS "name"
.IX Subsection "name"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Result value: $name" 4
.el .IP "Result value: \f(CW$name\fR" 4
.IX Item "Result value: $name"
.PD
.PP
Returns the name of the result source, which will typically be the table
name. This may be a scalar reference if the result source has a non-standard
name.
.SS "source_name"
.IX Subsection "source_name"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Result value: $source_name" 4
.el .IP "Result value: \f(CW$source_name\fR" 4
.IX Item "Result value: $source_name"
.PD
.PP
Set an alternate name for the result source when it is loaded into a schema.
This is useful if you want to refer to a result source by a name other than
its class name.
.PP
.Vb 4
\&  package ArchivedBooks;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqbooks_archive\*(Aq);
\&  _\|_PACKAGE_\|_\->source_name(\*(AqBooks\*(Aq);
\&
\&  # from your schema...
\&  $schema\->resultset(\*(AqBooks\*(Aq)\->find(1);
.Ve
.SS "from"
.IX Subsection "from"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \s-1FROM\s0 clause" 4
.IX Item "Return Value: FROM clause"
.PD
.PP
.Vb 1
\&  my $from_clause = $source\->from();
.Ve
.PP
Returns an expression of the source to be supplied to storage to specify
retrieval from this source. In the case of a database, the required \s-1FROM\s0
clause contents.
.SS "schema"
.IX Subsection "schema"
.ie n .IP "Arguments: $schema?" 4
.el .IP "Arguments: \f(CW$schema\fR?" 4
.IX Item "Arguments: $schema?"
.PD 0
.ie n .IP "Return Value: $schema" 4
.el .IP "Return Value: \f(CW$schema\fR" 4
.IX Item "Return Value: $schema"
.PD
.PP
.Vb 1
\&  my $schema = $source\->schema();
.Ve
.PP
Sets and/or returns the DBIx::Class::Schema object to which this
result source instance has been attached to.
.SS "storage"
.IX Subsection "storage"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $storage" 4
.el .IP "Return Value: \f(CW$storage\fR" 4
.IX Item "Return Value: $storage"
.PD
.PP
.Vb 1
\&  $source\->storage\->debug(1);
.Ve
.PP
Returns the storage handle for the current schema.
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: $rel_name, $related_source_name, \e%cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$related_source_name\fR, \e%cond, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $related_source_name, %cond, %attrs?"
.PD 0
.IP "Return Value: 1/true if it succeeded" 4
.IX Item "Return Value: 1/true if it succeeded"
.PD
.PP
.Vb 1
\&  $source\->add_relationship(\*(Aqrel_name\*(Aq, \*(Aqrelated_source\*(Aq, $cond, $attrs);
.Ve
.PP
DBIx::Class::Relationship describes a series of methods which
create pre-defined useful types of relationships. Look there first
before using this method directly.
.PP
The relationship name can be arbitrary, but must be unique for each
relationship attached to this result source. 'related_source' should
be the name with which the related result source was registered with
the current schema. For example:
.PP
.Vb 3
\&  $schema\->source(\*(AqBook\*(Aq)\->add_relationship(\*(Aqreviews\*(Aq, \*(AqReview\*(Aq, {
\&    \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq,
\&  });
.Ve
.PP
The condition \f(CW$cond\fR needs to be an SQL::Abstract\-style
representation of the join between the tables. For example, if you're
creating a relation from Author to Book,
.PP
.Vb 1
\&  { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
.Ve
.PP
will result in the \s-1JOIN\s0 clause
.PP
.Vb 1
\&  author me JOIN book foreign ON foreign.author_id = me.id
.Ve
.PP
You can specify as many foreign => self mappings as necessary.
.PP
Valid attributes are as follows:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any
\&\s-1SQL\s0 join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in
the \s-1SQL\s0 command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.IP "proxy" 4
.IX Item "proxy"
An arrayref containing a list of accessors in the foreign class to proxy in
the main class. If, for example, you do the following:
.Sp
.Vb 3
\&  CD\->might_have(liner_notes => \*(AqLinerNotes\*(Aq, undef, {
\&    proxy => [ qw/notes/ ],
\&  });
.Ve
.Sp
Then, assuming LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = CD\->find(1);
\&  # set notes \-\- LinerNotes object is created if it doesn\*(Aqt exist
\&  $cd\->notes(\*(AqNotes go here\*(Aq);
.Ve
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the
relationship. Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single
related object), \f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for
when there is a single related object, but you also want the relationship
accessor to double as a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an
add_to_* method is also created, which calls \f(CW\*(C`create_related\*(C'\fR for the
relationship.
.PP
Throws an exception if the condition is improperly supplied, or cannot
be resolved.
.SS "relationships"
.IX Subsection "relationships"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @rel_names" 4
.el .IP "Return Value: \f(CW@rel_names\fR" 4
.IX Item "Return Value: @rel_names"
.PD
.PP
.Vb 1
\&  my @relnames = $source\->relationships();
.Ve
.PP
Returns all relationship names for this source.
.SS "relationship_info"
.IX Subsection "relationship_info"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.IP "Return Value: \e%rel_data" 4
.IX Item "Return Value: %rel_data"
.PD
.PP
Returns a hash of relationship information for the specified relationship
name. The keys/values are as specified for \*(L"add_relationship\*(R" in DBIx::Class::Relationship::Base.
.SS "has_relationship"
.IX Subsection "has_relationship"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.IP "Return Value: 1/0 (true/false)" 4
.IX Item "Return Value: 1/0 (true/false)"
.PD
.PP
Returns true if the source has a relationship of this name, false otherwise.
.SS "reverse_relationship_info"
.IX Subsection "reverse_relationship_info"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.IP "Return Value: \e%rel_data" 4
.IX Item "Return Value: %rel_data"
.PD
.PP
Looks through all the relationships on the source this relationship
points to, looking for one whose condition is the reverse of the
condition on this relationship.
.PP
A common use of this is to find the name of the \f(CW\*(C`belongs_to\*(C'\fR relation
opposing a \f(CW\*(C`has_many\*(C'\fR relation. For definition of these look in
DBIx::Class::Relationship.
.PP
The returned hashref is keyed by the name of the opposing
relationship, and contains its data in the same manner as
\&\*(L"relationship_info\*(R".
.SS "related_source"
.IX Subsection "related_source"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $source" 4
.el .IP "Return Value: \f(CW$source\fR" 4
.IX Item "Return Value: $source"
.PD
.PP
Returns the result source object for the given relationship.
.SS "related_class"
.IX Subsection "related_class"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
Returns the class name for objects in the given relationship.
.SS "handle"
.IX Subsection "handle"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $source_handle" 4
.el .IP "Return Value: \f(CW$source_handle\fR" 4
.IX Item "Return Value: $source_handle"
.PD
.PP
Obtain a new result source handle instance
for this source. Used as a serializable pointer to this resultsource, as it is not
easy (nor advisable) to serialize CODErefs which may very well be present in e.g.
relationship definitions.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "source_info"
.IX Subsection "source_info"
Stores a hashref of per-source metadata.  No specific key names
have yet been standardized, the examples below are purely hypothetical
and don't actually accomplish anything on their own:
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->source_info({
\&    "_tablespace" => \*(Aqfast_disk_array_3\*(Aq,
\&    "_engine" => \*(AqInnoDB\*(Aq,
\&  });
.Ve
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $class\->new();
\&
\&  $class\->new({attribute_name => value});
.Ve
.PP
Creates a new ResultSource object.  Not normally called directly by end users.
.SS "column_info_from_storage"
.IX Subsection "column_info_from_storage"
.IP "Arguments: 1/0 (default: 0)" 4
.IX Item "Arguments: 1/0 (default: 0)"
.PD 0
.IP "Return Value: 1/0" 4
.IX Item "Return Value: 1/0"
.PD
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->column_info_from_storage(1);
.Ve
.PP
Enables the on-demand automatic loading of the above column
metadata from storage as necessary.  This is *deprecated*, and
should not be used.  It will be removed before 1.0.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource5.16.3pm            0100644 0001750 0001750 00000105303 12566242362 026321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource 3"
.TH DBIx::Class::ResultSource 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource \- Result source object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Create a table based result source, in a result class.
\&
\&  package MyApp::Schema::Result::Artist;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqartist\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ artistid name /);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqartistid\*(Aq);
\&  _\|_PACKAGE_\|_\->has_many(cds => \*(AqMyApp::Schema::Result::CD\*(Aq);
\&
\&  1;
\&
\&  # Create a query (view) based result source, in a result class
\&  package MyApp::Schema::Result::Year2000CDs;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->load_components(\*(AqInflateColumn::DateTime\*(Aq);
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::View\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqyear2000cds\*(Aq);
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&      );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSource is an object that represents a source of data for querying.
.PP
This class is a base class for various specialised types of result
sources, for example DBIx::Class::ResultSource::Table. Table is the
default result source type, so one is created for you when defining a
result class as described in the synopsis above.
.PP
More specifically, the DBIx::Class::Core base class pulls in the
DBIx::Class::ResultSourceProxy::Table component, which defines
the table method.
When called, \f(CW\*(C`table\*(C'\fR creates and stores an instance of
DBIx::Class::ResultSoure::Table. Luckily, to use tables as result
sources, you don't need to remember any of this.
.PP
Result sources representing select queries, or views, can also be
created, see DBIx::Class::ResultSource::View for full details.
.SS "Finding result source objects"
.IX Subsection "Finding result source objects"
As mentioned above, a result source instance is created and stored for
you when you define a Result Class.
.PP
You can retrieve the result source at runtime in the following ways:
.IP "From a Schema object:" 4
.IX Item "From a Schema object:"
.Vb 1
\&   $schema\->source($source_name);
.Ve
.IP "From a Row object:" 4
.IX Item "From a Row object:"
.Vb 1
\&   $row\->result_source;
.Ve
.IP "From a ResultSet object:" 4
.IX Item "From a ResultSet object:"
.Vb 1
\&   $rs\->result_source;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "add_columns"
.IX Subsection "add_columns"
.ie n .IP "Arguments: @columns" 4
.el .IP "Arguments: \f(CW@columns\fR" 4
.IX Item "Arguments: @columns"
.PD 0
.IP "Return value: The ResultSource object" 4
.IX Item "Return value: The ResultSource object"
.PD
.PP
.Vb 1
\&  $source\->add_columns(qw/col1 col2 col3/);
\&
\&  $source\->add_columns(\*(Aqcol1\*(Aq => \e%col1_info, \*(Aqcol2\*(Aq => \e%col2_info, ...);
.Ve
.PP
Adds columns to the result source. If supplied colname => hashref
pairs, uses the hashref as the \*(L"column_info\*(R" for that column. Repeated
calls of this method will add more columns, not replace them.
.PP
The column names given will be created as accessor methods on your
DBIx::Class::Row objects. You can change the name of the accessor
by supplying an \*(L"accessor\*(R" in the column_info hash.
.PP
If a column name beginning with a plus sign ('+col1') is provided, the
attributes provided will be merged with any existing attributes for the
column, with the new attributes taking precedence in the case that an
attribute already exists. Using this without a hashref
(\f(CW\*(C`$source\->add_columns(qw/+col1 +col2/)\*(C'\fR) is legal, but useless \*(--
it does the same thing it would do without the plus.
.PP
The contents of the column_info are not set in stone. The following
keys are currently recognised/used by DBIx::Class:
.IP "accessor" 4
.IX Item "accessor"
.Vb 1
\&   { accessor => \*(Aq_name\*(Aq }
\&
\&   # example use, replace standard accessor with one of your own:
\&   sub name {
\&       my ($self, $value) = @_;
\&
\&       die "Name cannot contain digits!" if($value =~ /\ed/);
\&       $self\->_name($value);
\&
\&       return $self\->_name();
\&   }
.Ve
.Sp
Use this to set the name of the accessor method for this column. If unset,
the name of the column will be used.
.IP "data_type" 4
.IX Item "data_type"
.Vb 1
\&   { data_type => \*(Aqinteger\*(Aq }
.Ve
.Sp
This contains the column type. It is automatically filled if you use the
SQL::Translator::Producer::DBIx::Class::File producer, or the
DBIx::Class::Schema::Loader module.
.Sp
Currently there is no standard set of values for the data_type. Use
whatever your database supports.
.IP "size" 4
.IX Item "size"
.Vb 1
\&   { size => 20 }
.Ve
.Sp
The length of your column, if it is a column type that can have a size
restriction. This is currently only used to create tables from your
schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_nullable" 4
.IX Item "is_nullable"
.Vb 1
\&   { is_nullable => 1 }
.Ve
.Sp
Set this to a true value for a columns that is allowed to contain \s-1NULL\s0
values, default is false. This is currently only used to create tables
from your schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_auto_increment" 4
.IX Item "is_auto_increment"
.Vb 1
\&   { is_auto_increment => 1 }
.Ve
.Sp
Set this to a true value for a column whose value is somehow
automatically set, defaults to false. This is used to determine which
columns to empty when cloning objects using
\&\*(L"copy\*(R" in DBIx::Class::Row. It is also used by
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_numeric" 4
.IX Item "is_numeric"
.Vb 1
\&   { is_numeric => 1 }
.Ve
.Sp
Set this to a true or false value (not \f(CW\*(C`undef\*(C'\fR) to explicitly specify
if this column contains numeric data. This controls how set_column
decides whether to consider a column dirty after an update: if
\&\f(CW\*(C`is_numeric\*(C'\fR is true a numeric comparison \f(CW\*(C`!=\*(C'\fR will take place
instead of the usual \f(CW\*(C`eq\*(C'\fR
.Sp
If not specified the storage class will attempt to figure this out on
first access to the column, based on the column \f(CW\*(C`data_type\*(C'\fR. The
result will be cached in this attribute.
.IP "is_foreign_key" 4
.IX Item "is_foreign_key"
.Vb 1
\&   { is_foreign_key => 1 }
.Ve
.Sp
Set this to a true value for a column that contains a key from a
foreign table, defaults to false. This is currently only used to
create tables from your schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "default_value" 4
.IX Item "default_value"
.Vb 1
\&   { default_value => \e\*(Aqnow()\*(Aq }
.Ve
.Sp
Set this to the default value which will be inserted into a column by
the database. Can contain either a value or a function (use a
reference to a scalar e.g. \f(CW\*(C`\e\*(Aqnow()\*(Aq\*(C'\fR if you want a function). This
is currently only used to create tables from your schema, see
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.Sp
See the note on \*(L"new\*(R" in DBIx::Class::Row for more information about possible
issues related to db-side default values.
.IP "sequence" 4
.IX Item "sequence"
.Vb 1
\&   { sequence => \*(Aqmy_table_seq\*(Aq }
.Ve
.Sp
Set this on a primary key column to the name of the sequence used to
generate a new key value. If not specified, DBIx::Class::PK::Auto
will attempt to retrieve the name of the sequence from the database
automatically.
.IP "retrieve_on_insert" 4
.IX Item "retrieve_on_insert"
.Vb 1
\&  { retrieve_on_insert => 1 }
.Ve
.Sp
For every column where this is set to true, \s-1DBIC\s0 will retrieve the RDBMS-side
value upon a new row insertion (normally only the autoincrement \s-1PK\s0 is
retrieved on insert). \f(CW\*(C`INSERT ... RETURNING\*(C'\fR is used automatically if
supported by the underlying storage, otherwise an extra \s-1SELECT\s0 statement is
executed to retrieve the missing data.
.IP "auto_nextval" 4
.IX Item "auto_nextval"
.Vb 1
\&   { auto_nextval => 1 }
.Ve
.Sp
Set this to a true value for a column whose value is retrieved automatically
from a sequence or function (if supported by your Storage driver.) For a
sequence, if you do not use a trigger to get the nextval, you have to set the
\&\*(L"sequence\*(R" value as well.
.Sp
Also set this for \s-1MSSQL\s0 columns with the 'uniqueidentifier'
data_type whose values you want to
automatically generate using \f(CW\*(C`NEWID()\*(C'\fR, unless they are a primary key in which
case this will be done anyway.
.IP "extra" 4
.IX Item "extra"
This is used by \*(L"deploy\*(R" in DBIx::Class::Schema and SQL::Translator
to add extra non-generic data to the column. For example: \f(CW\*(C`extra
=> { unsigned => 1}\*(C'\fR is used by the MySQL producer to set an integer
column to unsigned. For more details, see
SQL::Translator::Producer::MySQL.
.SS "add_column"
.IX Subsection "add_column"
.ie n .IP "Arguments: $colname, \e%columninfo?" 4
.el .IP "Arguments: \f(CW$colname\fR, \e%columninfo?" 4
.IX Item "Arguments: $colname, %columninfo?"
.PD 0
.IP "Return value: 1/0 (true/false)" 4
.IX Item "Return value: 1/0 (true/false)"
.PD
.PP
.Vb 1
\&  $source\->add_column(\*(Aqcol\*(Aq => \e%info);
.Ve
.PP
Add a single column and optional column info. Uses the same column
info keys as \*(L"add_columns\*(R".
.SS "has_column"
.IX Subsection "has_column"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return value: 1/0 (true/false)" 4
.IX Item "Return value: 1/0 (true/false)"
.PD
.PP
.Vb 1
\&  if ($source\->has_column($colname)) { ... }
.Ve
.PP
Returns true if the source has a column of this name, false otherwise.
.SS "column_info"
.IX Subsection "column_info"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return value: Hashref of info" 4
.IX Item "Return value: Hashref of info"
.PD
.PP
.Vb 1
\&  my $info = $source\->column_info($col);
.Ve
.PP
Returns the column metadata hashref for a column, as originally passed
to \*(L"add_columns\*(R". See \*(L"add_columns\*(R" above for information on the
contents of the hashref.
.SS "columns"
.IX Subsection "columns"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: Ordered list of column names" 4
.IX Item "Return value: Ordered list of column names"
.PD
.PP
.Vb 1
\&  my @column_names = $source\->columns;
.Ve
.PP
Returns all column names in the order they were declared to \*(L"add_columns\*(R".
.SS "columns_info"
.IX Subsection "columns_info"
.IP "Arguments: \e@colnames ?" 4
.IX Item "Arguments: @colnames ?"
.PD 0
.IP "Return value: Hashref of column name/info pairs" 4
.IX Item "Return value: Hashref of column name/info pairs"
.PD
.PP
.Vb 1
\&  my $columns_info = $source\->columns_info;
.Ve
.PP
Like \*(L"column_info\*(R" but returns information for the requested columns. If
the optional column-list arrayref is omitted it returns info on all columns
currently defined on the ResultSource via \*(L"add_columns\*(R".
.SS "remove_columns"
.IX Subsection "remove_columns"
.ie n .IP "Arguments: @colnames" 4
.el .IP "Arguments: \f(CW@colnames\fR" 4
.IX Item "Arguments: @colnames"
.PD 0
.IP "Return value: undefined" 4
.IX Item "Return value: undefined"
.PD
.PP
.Vb 1
\&  $source\->remove_columns(qw/col1 col2 col3/);
.Ve
.PP
Removes the given list of columns by name, from the result source.
.PP
\&\fBWarning\fR: Removing a column that is also used in the sources primary
key, or in one of the sources unique constraints, \fBwill\fR result in a
broken result source.
.SS "remove_column"
.IX Subsection "remove_column"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return value: undefined" 4
.IX Item "Return value: undefined"
.PD
.PP
.Vb 1
\&  $source\->remove_column(\*(Aqcol\*(Aq);
.Ve
.PP
Remove a single column by name from the result source, similar to
\&\*(L"remove_columns\*(R".
.PP
\&\fBWarning\fR: Removing a column that is also used in the sources primary
key, or in one of the sources unique constraints, \fBwill\fR result in a
broken result source.
.SS "set_primary_key"
.IX Subsection "set_primary_key"
.ie n .IP "Arguments: @cols" 4
.el .IP "Arguments: \f(CW@cols\fR" 4
.IX Item "Arguments: @cols"
.PD 0
.IP "Return value: undefined" 4
.IX Item "Return value: undefined"
.PD
.PP
Defines one or more columns as primary key for this source. Must be
called after \*(L"add_columns\*(R".
.PP
Additionally, defines a unique constraint
named \f(CW\*(C`primary\*(C'\fR.
.PP
Note: you normally do want to define a primary key on your sources
\&\fBeven if the underlying database table does not have a primary key\fR.
See
\&\*(L"The Significance and Importance of Primary Keys\*(R" in DBIx::Class::Manual::Intro
for more info.
.SS "primary_columns"
.IX Subsection "primary_columns"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: Ordered list of primary column names" 4
.IX Item "Return value: Ordered list of primary column names"
.PD
.PP
Read-only accessor which returns the list of primary keys, supplied by
\&\*(L"set_primary_key\*(R".
.SS "sequence"
.IX Subsection "sequence"
Manually define the correct sequence for your table, to avoid the overhead
associated with looking up the sequence automatically. The supplied sequence
will be applied to the \*(L"column_info\*(R" of each primary_key
.ie n .IP "Arguments: $sequence_name" 4
.el .IP "Arguments: \f(CW$sequence_name\fR" 4
.IX Item "Arguments: $sequence_name"
.PD 0
.IP "Return value: undefined" 4
.IX Item "Return value: undefined"
.PD
.SS "add_unique_constraint"
.IX Subsection "add_unique_constraint"
.ie n .IP "Arguments: $name?, \e@colnames" 4
.el .IP "Arguments: \f(CW$name\fR?, \e@colnames" 4
.IX Item "Arguments: $name?, @colnames"
.PD 0
.IP "Return value: undefined" 4
.IX Item "Return value: undefined"
.PD
.PP
Declare a unique constraint on this source. Call once for each unique
constraint.
.PP
.Vb 4
\&  # For UNIQUE (column1, column2)
\&  _\|_PACKAGE_\|_\->add_unique_constraint(
\&    constraint_name => [ qw/column1 column2/ ],
\&  );
.Ve
.PP
Alternatively, you can specify only the columns:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->add_unique_constraint([ qw/column1 column2/ ]);
.Ve
.PP
This will result in a unique constraint named
\&\f(CW\*(C`table_column1_column2\*(C'\fR, where \f(CW\*(C`table\*(C'\fR is replaced with the table
name.
.PP
Unique constraints are used, for example, when you pass the constraint
name as the \f(CW\*(C`key\*(C'\fR attribute to \*(L"find\*(R" in DBIx::Class::ResultSet. Then
only columns in the constraint are searched.
.PP
Throws an error if any of the given column names do not yet exist on
the result source.
.SS "add_unique_constraints"
.IX Subsection "add_unique_constraints"
.ie n .IP "Arguments: @constraints" 4
.el .IP "Arguments: \f(CW@constraints\fR" 4
.IX Item "Arguments: @constraints"
.PD 0
.IP "Return value: undefined" 4
.IX Item "Return value: undefined"
.PD
.PP
Declare multiple unique constraints on this source.
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->add_unique_constraints(
\&    constraint_name1 => [ qw/column1 column2/ ],
\&    constraint_name2 => [ qw/column2 column3/ ],
\&  );
.Ve
.PP
Alternatively, you can specify only the columns:
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->add_unique_constraints(
\&    [ qw/column1 column2/ ],
\&    [ qw/column3 column4/ ]
\&  );
.Ve
.PP
This will result in unique constraints named \f(CW\*(C`table_column1_column2\*(C'\fR and
\&\f(CW\*(C`table_column3_column4\*(C'\fR, where \f(CW\*(C`table\*(C'\fR is replaced with the table name.
.PP
Throws an error if any of the given column names do not yet exist on
the result source.
.PP
See also \*(L"add_unique_constraint\*(R".
.SS "name_unique_constraint"
.IX Subsection "name_unique_constraint"
.IP "Arguments: \e@colnames" 4
.IX Item "Arguments: @colnames"
.PD 0
.IP "Return value: Constraint name" 4
.IX Item "Return value: Constraint name"
.PD
.PP
.Vb 4
\&  $source\->table(\*(Aqmytable\*(Aq);
\&  $source\->name_unique_constraint([\*(Aqcol1\*(Aq, \*(Aqcol2\*(Aq]);
\&  # returns
\&  \*(Aqmytable_col1_col2\*(Aq
.Ve
.PP
Return a name for a unique constraint containing the specified
columns. The name is created by joining the table name and each column
name, using an underscore character.
.PP
For example, a constraint on a table named \f(CW\*(C`cd\*(C'\fR containing the columns
\&\f(CW\*(C`artist\*(C'\fR and \f(CW\*(C`title\*(C'\fR would result in a constraint name of \f(CW\*(C`cd_artist_title\*(C'\fR.
.PP
This is used by \*(L"add_unique_constraint\*(R" if you do not specify the
optional constraint name.
.SS "unique_constraints"
.IX Subsection "unique_constraints"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: Hash of unique constraint data" 4
.IX Item "Return value: Hash of unique constraint data"
.PD
.PP
.Vb 1
\&  $source\->unique_constraints();
.Ve
.PP
Read-only accessor which returns a hash of unique constraints on this
source.
.PP
The hash is keyed by constraint name, and contains an arrayref of
column names as values.
.SS "unique_constraint_names"
.IX Subsection "unique_constraint_names"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: Unique constraint names" 4
.IX Item "Return value: Unique constraint names"
.PD
.PP
.Vb 1
\&  $source\->unique_constraint_names();
.Ve
.PP
Returns the list of unique constraint names defined on this source.
.SS "unique_constraint_columns"
.IX Subsection "unique_constraint_columns"
.ie n .IP "Arguments: $constraintname" 4
.el .IP "Arguments: \f(CW$constraintname\fR" 4
.IX Item "Arguments: $constraintname"
.PD 0
.IP "Return value: List of constraint columns" 4
.IX Item "Return value: List of constraint columns"
.PD
.PP
.Vb 1
\&  $source\->unique_constraint_columns(\*(Aqmyconstraint\*(Aq);
.Ve
.PP
Returns the list of columns that make up the specified unique constraint.
.SS "sqlt_deploy_callback"
.IX Subsection "sqlt_deploy_callback"
.ie n .IP "Arguments: $callback_name | \e&callback_code" 4
.el .IP "Arguments: \f(CW$callback_name\fR | \e&callback_code" 4
.IX Item "Arguments: $callback_name | &callback_code"
.PD 0
.ie n .IP "Return value: $callback_name | \e&callback_code" 4
.el .IP "Return value: \f(CW$callback_name\fR | \e&callback_code" 4
.IX Item "Return value: $callback_name | &callback_code"
.PD
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->sqlt_deploy_callback(\*(Aqmycallbackmethod\*(Aq);
\&
\&   or
\&
\&  _\|_PACKAGE_\|_\->sqlt_deploy_callback(sub {
\&    my ($source_instance, $sqlt_table) = @_;
\&    ...
\&  } );
.Ve
.PP
An accessor to set a callback to be called during deployment of
the schema via \*(L"create_ddl_dir\*(R" in DBIx::Class::Schema or
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.PP
The callback can be set as either a code reference or the name of a
method in the current result class.
.PP
Defaults to \*(L"default_sqlt_deploy_hook\*(R".
.PP
Your callback will be passed the \f(CW$source\fR object representing the
ResultSource instance being deployed, and the
SQL::Translator::Schema::Table object being created from it. The
callback can be used to manipulate the table object or add your own
customised indexes. If you need to manipulate a non-table object, use
the \*(L"sqlt_deploy_hook\*(R" in DBIx::Class::Schema.
.PP
See \*(L"Adding Indexes And Functions To
Your \s-1SQL\s0\*(R" in DBIx::Class::Manual::Cookbook for examples.
.PP
This sqlt deployment callback can only be used to manipulate
SQL::Translator objects as they get turned into \s-1SQL\s0. To execute
post-deploy statements which SQL::Translator does not currently
handle, override \*(L"deploy\*(R" in DBIx::Class::Schema in your Schema class
and call dbh_do.
.SS "default_sqlt_deploy_hook"
.IX Subsection "default_sqlt_deploy_hook"
This is the default deploy hook implementation which checks if your
current Result class has a \f(CW\*(C`sqlt_deploy_hook\*(C'\fR method, and if present
invokes it \fBon the Result class directly\fR. This is to preserve the
semantics of \f(CW\*(C`sqlt_deploy_hook\*(C'\fR which was originally designed to expect
the Result class name and the
\&\f(CW$sqlt_table\fR instance of the table being
deployed.
.SS "resultset"
.IX Subsection "resultset"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.ie n .IP "Return value: $resultset" 4
.el .IP "Return value: \f(CW$resultset\fR" 4
.IX Item "Return value: $resultset"
.PD
.PP
Returns a resultset for the given source. This will initially be created
on demand by calling
.PP
.Vb 1
\&  $self\->resultset_class\->new($self, $self\->resultset_attributes)
.Ve
.PP
but is cached from then on unless resultset_class changes.
.SS "resultset_class"
.IX Subsection "resultset_class"
.ie n .IP "Arguments: $classname" 4
.el .IP "Arguments: \f(CW$classname\fR" 4
.IX Item "Arguments: $classname"
.PD 0
.ie n .IP "Return value: $classname" 4
.el .IP "Return value: \f(CW$classname\fR" 4
.IX Item "Return value: $classname"
.PD
.PP
.Vb 3
\&  package My::Schema::ResultSet::Artist;
\&  use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&  ...
\&
\&  # In the result class
\&  _\|_PACKAGE_\|_\->resultset_class(\*(AqMy::Schema::ResultSet::Artist\*(Aq);
\&
\&  # Or in code
\&  $source\->resultset_class(\*(AqMy::Schema::ResultSet::Artist\*(Aq);
.Ve
.PP
Set the class of the resultset. This is useful if you want to create your
own resultset methods. Create your own class derived from
DBIx::Class::ResultSet, and set it here. If called with no arguments,
this method returns the name of the existing resultset class, if one
exists.
.SS "resultset_attributes"
.IX Subsection "resultset_attributes"
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Return value: \e%attrs" 4
.IX Item "Return value: %attrs"
.PD
.PP
.Vb 2
\&  # In the result class
\&  _\|_PACKAGE_\|_\->resultset_attributes({ order_by => [ \*(Aqid\*(Aq ] });
\&
\&  # Or in code
\&  $source\->resultset_attributes({ order_by => [ \*(Aqid\*(Aq ] });
.Ve
.PP
Store a collection of resultset attributes, that will be set on every
DBIx::Class::ResultSet produced from this result source. For a full
list see \*(L"\s-1ATTRIBUTES\s0\*(R" in DBIx::Class::ResultSet.
.SS "name"
.IX Subsection "name"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.ie n .IP "Result value: $name" 4
.el .IP "Result value: \f(CW$name\fR" 4
.IX Item "Result value: $name"
.PD
.PP
Returns the name of the result source, which will typically be the table
name. This may be a scalar reference if the result source has a non-standard
name.
.SS "source_name"
.IX Subsection "source_name"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Result value: $source_name" 4
.el .IP "Result value: \f(CW$source_name\fR" 4
.IX Item "Result value: $source_name"
.PD
.PP
Set an alternate name for the result source when it is loaded into a schema.
This is useful if you want to refer to a result source by a name other than
its class name.
.PP
.Vb 4
\&  package ArchivedBooks;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqbooks_archive\*(Aq);
\&  _\|_PACKAGE_\|_\->source_name(\*(AqBooks\*(Aq);
\&
\&  # from your schema...
\&  $schema\->resultset(\*(AqBooks\*(Aq)\->find(1);
.Ve
.SS "from"
.IX Subsection "from"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: \s-1FROM\s0 clause" 4
.IX Item "Return value: FROM clause"
.PD
.PP
.Vb 1
\&  my $from_clause = $source\->from();
.Ve
.PP
Returns an expression of the source to be supplied to storage to specify
retrieval from this source. In the case of a database, the required \s-1FROM\s0
clause contents.
.SS "schema"
.IX Subsection "schema"
.ie n .IP "Arguments: $schema" 4
.el .IP "Arguments: \f(CW$schema\fR" 4
.IX Item "Arguments: $schema"
.PD 0
.IP "Return value: A schema object" 4
.IX Item "Return value: A schema object"
.PD
.PP
.Vb 1
\&  my $schema = $source\->schema();
.Ve
.PP
Sets and/or returns the DBIx::Class::Schema object to which this
result source instance has been attached to.
.SS "storage"
.IX Subsection "storage"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: A Storage object" 4
.IX Item "Return value: A Storage object"
.PD
.PP
.Vb 1
\&  $source\->storage\->debug(1);
.Ve
.PP
Returns the storage handle for the current schema.
.PP
See also: DBIx::Class::Storage
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: $relname, $related_source_name, \e%cond, [ \e%attrs ]" 4
.el .IP "Arguments: \f(CW$relname\fR, \f(CW$related_source_name\fR, \e%cond, [ \e%attrs ]" 4
.IX Item "Arguments: $relname, $related_source_name, %cond, [ %attrs ]"
.PD 0
.IP "Return value: 1/true if it succeeded" 4
.IX Item "Return value: 1/true if it succeeded"
.PD
.PP
.Vb 1
\&  $source\->add_relationship(\*(Aqrelname\*(Aq, \*(Aqrelated_source\*(Aq, $cond, $attrs);
.Ve
.PP
DBIx::Class::Relationship describes a series of methods which
create pre-defined useful types of relationships. Look there first
before using this method directly.
.PP
The relationship name can be arbitrary, but must be unique for each
relationship attached to this result source. 'related_source' should
be the name with which the related result source was registered with
the current schema. For example:
.PP
.Vb 3
\&  $schema\->source(\*(AqBook\*(Aq)\->add_relationship(\*(Aqreviews\*(Aq, \*(AqReview\*(Aq, {
\&    \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq,
\&  });
.Ve
.PP
The condition \f(CW$cond\fR needs to be an SQL::Abstract\-style
representation of the join between the tables. For example, if you're
creating a relation from Author to Book,
.PP
.Vb 1
\&  { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
.Ve
.PP
will result in the \s-1JOIN\s0 clause
.PP
.Vb 1
\&  author me JOIN book foreign ON foreign.author_id = me.id
.Ve
.PP
You can specify as many foreign => self mappings as necessary.
.PP
Valid attributes are as follows:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any
\&\s-1SQL\s0 join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in
the \s-1SQL\s0 command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.IP "proxy" 4
.IX Item "proxy"
An arrayref containing a list of accessors in the foreign class to proxy in
the main class. If, for example, you do the following:
.Sp
.Vb 3
\&  CD\->might_have(liner_notes => \*(AqLinerNotes\*(Aq, undef, {
\&    proxy => [ qw/notes/ ],
\&  });
.Ve
.Sp
Then, assuming LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = CD\->find(1);
\&  # set notes \-\- LinerNotes object is created if it doesn\*(Aqt exist
\&  $cd\->notes(\*(AqNotes go here\*(Aq);
.Ve
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the
relationship. Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single
related object), \f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for
when there is a single related object, but you also want the relationship
accessor to double as a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an
add_to_* method is also created, which calls \f(CW\*(C`create_related\*(C'\fR for the
relationship.
.PP
Throws an exception if the condition is improperly supplied, or cannot
be resolved.
.SS "relationships"
.IX Subsection "relationships"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.IP "Return value: List of relationship names" 4
.IX Item "Return value: List of relationship names"
.PD
.PP
.Vb 1
\&  my @relnames = $source\->relationships();
.Ve
.PP
Returns all relationship names for this source.
.SS "relationship_info"
.IX Subsection "relationship_info"
.ie n .IP "Arguments: $relname" 4
.el .IP "Arguments: \f(CW$relname\fR" 4
.IX Item "Arguments: $relname"
.PD 0
.IP "Return value: Hashref of relation data," 4
.IX Item "Return value: Hashref of relation data,"
.PD
.PP
Returns a hash of relationship information for the specified relationship
name. The keys/values are as specified for \*(L"add_relationship\*(R".
.SS "has_relationship"
.IX Subsection "has_relationship"
.ie n .IP "Arguments: $rel" 4
.el .IP "Arguments: \f(CW$rel\fR" 4
.IX Item "Arguments: $rel"
.PD 0
.IP "Return value: 1/0 (true/false)" 4
.IX Item "Return value: 1/0 (true/false)"
.PD
.PP
Returns true if the source has a relationship of this name, false otherwise.
.SS "reverse_relationship_info"
.IX Subsection "reverse_relationship_info"
.ie n .IP "Arguments: $relname" 4
.el .IP "Arguments: \f(CW$relname\fR" 4
.IX Item "Arguments: $relname"
.PD 0
.IP "Return value: Hashref of relationship data" 4
.IX Item "Return value: Hashref of relationship data"
.PD
.PP
Looks through all the relationships on the source this relationship
points to, looking for one whose condition is the reverse of the
condition on this relationship.
.PP
A common use of this is to find the name of the \f(CW\*(C`belongs_to\*(C'\fR relation
opposing a \f(CW\*(C`has_many\*(C'\fR relation. For definition of these look in
DBIx::Class::Relationship.
.PP
The returned hashref is keyed by the name of the opposing
relationship, and contains its data in the same manner as
\&\*(L"relationship_info\*(R".
.SS "related_source"
.IX Subsection "related_source"
.ie n .IP "Arguments: $relname" 4
.el .IP "Arguments: \f(CW$relname\fR" 4
.IX Item "Arguments: $relname"
.PD 0
.ie n .IP "Return value: $source" 4
.el .IP "Return value: \f(CW$source\fR" 4
.IX Item "Return value: $source"
.PD
.PP
Returns the result source object for the given relationship.
.SS "related_class"
.IX Subsection "related_class"
.ie n .IP "Arguments: $relname" 4
.el .IP "Arguments: \f(CW$relname\fR" 4
.IX Item "Arguments: $relname"
.PD 0
.ie n .IP "Return value: $classname" 4
.el .IP "Return value: \f(CW$classname\fR" 4
.IX Item "Return value: $classname"
.PD
.PP
Returns the class name for objects in the given relationship.
.SS "handle"
.IX Subsection "handle"
.IP "Arguments: None" 4
.IX Item "Arguments: None"
.PD 0
.ie n .IP "Return value: $source_handle" 4
.el .IP "Return value: \f(CW$source_handle\fR" 4
.IX Item "Return value: $source_handle"
.PD
.PP
Obtain a new result source handle instance
for this source. Used as a serializable pointer to this resultsource, as it is not
easy (nor advisable) to serialize CODErefs which may very well be present in e.g.
relationship definitions.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "source_info"
.IX Subsection "source_info"
Stores a hashref of per-source metadata.  No specific key names
have yet been standardized, the examples below are purely hypothetical
and don't actually accomplish anything on their own:
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->source_info({
\&    "_tablespace" => \*(Aqfast_disk_array_3\*(Aq,
\&    "_engine" => \*(AqInnoDB\*(Aq,
\&  });
.Ve
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $class\->new();
\&
\&  $class\->new({attribute_name => value});
.Ve
.PP
Creates a new ResultSource object.  Not normally called directly by end users.
.SS "column_info_from_storage"
.IX Subsection "column_info_from_storage"
.IP "Arguments: 1/0 (default: 0)" 4
.IX Item "Arguments: 1/0 (default: 0)"
.PD 0
.IP "Return value: 1/0" 4
.IX Item "Return value: 1/0"
.PD
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->column_info_from_storage(1);
.Ve
.PP
Enables the on-demand automatic loading of the above column
metadata from storage as necessary.  This is *deprecated*, and
should not be used.  It will be removed before 1.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource5.18.3pm            0100644 0001750 0001750 00000111712 12566242377 026332  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource 3"
.TH DBIx::Class::ResultSource 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource \- Result source object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Create a table based result source, in a result class.
\&
\&  package MyApp::Schema::Result::Artist;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqartist\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ artistid name /);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqartistid\*(Aq);
\&  _\|_PACKAGE_\|_\->has_many(cds => \*(AqMyApp::Schema::Result::CD\*(Aq);
\&
\&  1;
\&
\&  # Create a query (view) based result source, in a result class
\&  package MyApp::Schema::Result::Year2000CDs;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->load_components(\*(AqInflateColumn::DateTime\*(Aq);
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::View\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqyear2000cds\*(Aq);
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&      );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSource is an object that represents a source of data for querying.
.PP
This class is a base class for various specialised types of result
sources, for example DBIx::Class::ResultSource::Table. Table is the
default result source type, so one is created for you when defining a
result class as described in the synopsis above.
.PP
More specifically, the DBIx::Class::Core base class pulls in the
DBIx::Class::ResultSourceProxy::Table component, which defines
the table method.
When called, \f(CW\*(C`table\*(C'\fR creates and stores an instance of
DBIx::Class::ResultSoure::Table. Luckily, to use tables as result
sources, you don't need to remember any of this.
.PP
Result sources representing select queries, or views, can also be
created, see DBIx::Class::ResultSource::View for full details.
.SS "Finding result source objects"
.IX Subsection "Finding result source objects"
As mentioned above, a result source instance is created and stored for
you when you define a result class.
.PP
You can retrieve the result source at runtime in the following ways:
.IP "From a Schema object:" 4
.IX Item "From a Schema object:"
.Vb 1
\&   $schema\->source($source_name);
.Ve
.IP "From a Result object:" 4
.IX Item "From a Result object:"
.Vb 1
\&   $result\->result_source;
.Ve
.IP "From a ResultSet object:" 4
.IX Item "From a ResultSet object:"
.Vb 1
\&   $rs\->result_source;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "add_columns"
.IX Subsection "add_columns"
.ie n .IP "Arguments: @columns" 4
.el .IP "Arguments: \f(CW@columns\fR" 4
.IX Item "Arguments: @columns"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
.Vb 1
\&  $source\->add_columns(qw/col1 col2 col3/);
\&
\&  $source\->add_columns(\*(Aqcol1\*(Aq => \e%col1_info, \*(Aqcol2\*(Aq => \e%col2_info, ...);
.Ve
.PP
Adds columns to the result source. If supplied colname => hashref
pairs, uses the hashref as the \*(L"column_info\*(R" for that column. Repeated
calls of this method will add more columns, not replace them.
.PP
The column names given will be created as accessor methods on your
Result objects. You can change the name of the accessor
by supplying an \*(L"accessor\*(R" in the column_info hash.
.PP
If a column name beginning with a plus sign ('+col1') is provided, the
attributes provided will be merged with any existing attributes for the
column, with the new attributes taking precedence in the case that an
attribute already exists. Using this without a hashref
(\f(CW\*(C`$source\->add_columns(qw/+col1 +col2/)\*(C'\fR) is legal, but useless \*(--
it does the same thing it would do without the plus.
.PP
The contents of the column_info are not set in stone. The following
keys are currently recognised/used by DBIx::Class:
.IP "accessor" 4
.IX Item "accessor"
.Vb 1
\&   { accessor => \*(Aq_name\*(Aq }
\&
\&   # example use, replace standard accessor with one of your own:
\&   sub name {
\&       my ($self, $value) = @_;
\&
\&       die "Name cannot contain digits!" if($value =~ /\ed/);
\&       $self\->_name($value);
\&
\&       return $self\->_name();
\&   }
.Ve
.Sp
Use this to set the name of the accessor method for this column. If unset,
the name of the column will be used.
.IP "data_type" 4
.IX Item "data_type"
.Vb 1
\&   { data_type => \*(Aqinteger\*(Aq }
.Ve
.Sp
This contains the column type. It is automatically filled if you use the
SQL::Translator::Producer::DBIx::Class::File producer, or the
DBIx::Class::Schema::Loader module.
.Sp
Currently there is no standard set of values for the data_type. Use
whatever your database supports.
.IP "size" 4
.IX Item "size"
.Vb 1
\&   { size => 20 }
.Ve
.Sp
The length of your column, if it is a column type that can have a size
restriction. This is currently only used to create tables from your
schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_nullable" 4
.IX Item "is_nullable"
.Vb 1
\&   { is_nullable => 1 }
.Ve
.Sp
Set this to a true value for a columns that is allowed to contain \s-1NULL\s0
values, default is false. This is currently only used to create tables
from your schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_auto_increment" 4
.IX Item "is_auto_increment"
.Vb 1
\&   { is_auto_increment => 1 }
.Ve
.Sp
Set this to a true value for a column whose value is somehow
automatically set, defaults to false. This is used to determine which
columns to empty when cloning objects using
\&\*(L"copy\*(R" in DBIx::Class::Row. It is also used by
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "is_numeric" 4
.IX Item "is_numeric"
.Vb 1
\&   { is_numeric => 1 }
.Ve
.Sp
Set this to a true or false value (not \f(CW\*(C`undef\*(C'\fR) to explicitly specify
if this column contains numeric data. This controls how set_column
decides whether to consider a column dirty after an update: if
\&\f(CW\*(C`is_numeric\*(C'\fR is true a numeric comparison \f(CW\*(C`!=\*(C'\fR will take place
instead of the usual \f(CW\*(C`eq\*(C'\fR
.Sp
If not specified the storage class will attempt to figure this out on
first access to the column, based on the column \f(CW\*(C`data_type\*(C'\fR. The
result will be cached in this attribute.
.IP "is_foreign_key" 4
.IX Item "is_foreign_key"
.Vb 1
\&   { is_foreign_key => 1 }
.Ve
.Sp
Set this to a true value for a column that contains a key from a
foreign table, defaults to false. This is currently only used to
create tables from your schema, see \*(L"deploy\*(R" in DBIx::Class::Schema.
.IP "default_value" 4
.IX Item "default_value"
.Vb 1
\&   { default_value => \e\*(Aqnow()\*(Aq }
.Ve
.Sp
Set this to the default value which will be inserted into a column by
the database. Can contain either a value or a function (use a
reference to a scalar e.g. \f(CW\*(C`\e\*(Aqnow()\*(Aq\*(C'\fR if you want a function). This
is currently only used to create tables from your schema, see
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.Sp
See the note on \*(L"new\*(R" in DBIx::Class::Row for more information about possible
issues related to db-side default values.
.IP "sequence" 4
.IX Item "sequence"
.Vb 1
\&   { sequence => \*(Aqmy_table_seq\*(Aq }
.Ve
.Sp
Set this on a primary key column to the name of the sequence used to
generate a new key value. If not specified, DBIx::Class::PK::Auto
will attempt to retrieve the name of the sequence from the database
automatically.
.IP "retrieve_on_insert" 4
.IX Item "retrieve_on_insert"
.Vb 1
\&  { retrieve_on_insert => 1 }
.Ve
.Sp
For every column where this is set to true, \s-1DBIC\s0 will retrieve the RDBMS-side
value upon a new row insertion (normally only the autoincrement \s-1PK\s0 is
retrieved on insert). \f(CW\*(C`INSERT ... RETURNING\*(C'\fR is used automatically if
supported by the underlying storage, otherwise an extra \s-1SELECT\s0 statement is
executed to retrieve the missing data.
.IP "auto_nextval" 4
.IX Item "auto_nextval"
.Vb 1
\&   { auto_nextval => 1 }
.Ve
.Sp
Set this to a true value for a column whose value is retrieved automatically
from a sequence or function (if supported by your Storage driver.) For a
sequence, if you do not use a trigger to get the nextval, you have to set the
\&\*(L"sequence\*(R" value as well.
.Sp
Also set this for \s-1MSSQL\s0 columns with the 'uniqueidentifier'
data_type whose values you want to
automatically generate using \f(CW\*(C`NEWID()\*(C'\fR, unless they are a primary key in which
case this will be done anyway.
.IP "extra" 4
.IX Item "extra"
This is used by \*(L"deploy\*(R" in DBIx::Class::Schema and SQL::Translator
to add extra non-generic data to the column. For example: \f(CW\*(C`extra
=> { unsigned => 1}\*(C'\fR is used by the MySQL producer to set an integer
column to unsigned. For more details, see
SQL::Translator::Producer::MySQL.
.SS "add_column"
.IX Subsection "add_column"
.ie n .IP "Arguments: $colname, \e%columninfo?" 4
.el .IP "Arguments: \f(CW$colname\fR, \e%columninfo?" 4
.IX Item "Arguments: $colname, %columninfo?"
.PD 0
.IP "Return Value: 1/0 (true/false)" 4
.IX Item "Return Value: 1/0 (true/false)"
.PD
.PP
.Vb 1
\&  $source\->add_column(\*(Aqcol\*(Aq => \e%info);
.Ve
.PP
Add a single column and optional column info. Uses the same column
info keys as \*(L"add_columns\*(R".
.SS "has_column"
.IX Subsection "has_column"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return Value: 1/0 (true/false)" 4
.IX Item "Return Value: 1/0 (true/false)"
.PD
.PP
.Vb 1
\&  if ($source\->has_column($colname)) { ... }
.Ve
.PP
Returns true if the source has a column of this name, false otherwise.
.SS "column_info"
.IX Subsection "column_info"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return Value: Hashref of info" 4
.IX Item "Return Value: Hashref of info"
.PD
.PP
.Vb 1
\&  my $info = $source\->column_info($col);
.Ve
.PP
Returns the column metadata hashref for a column, as originally passed
to \*(L"add_columns\*(R". See \*(L"add_columns\*(R" above for information on the
contents of the hashref.
.SS "columns"
.IX Subsection "columns"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Ordered list of column names" 4
.IX Item "Return Value: Ordered list of column names"
.PD
.PP
.Vb 1
\&  my @column_names = $source\->columns;
.Ve
.PP
Returns all column names in the order they were declared to \*(L"add_columns\*(R".
.SS "columns_info"
.IX Subsection "columns_info"
.IP "Arguments: \e@colnames ?" 4
.IX Item "Arguments: @colnames ?"
.PD 0
.IP "Return Value: Hashref of column name/info pairs" 4
.IX Item "Return Value: Hashref of column name/info pairs"
.PD
.PP
.Vb 1
\&  my $columns_info = $source\->columns_info;
.Ve
.PP
Like \*(L"column_info\*(R" but returns information for the requested columns. If
the optional column-list arrayref is omitted it returns info on all columns
currently defined on the ResultSource via \*(L"add_columns\*(R".
.SS "remove_columns"
.IX Subsection "remove_columns"
.ie n .IP "Arguments: @colnames" 4
.el .IP "Arguments: \f(CW@colnames\fR" 4
.IX Item "Arguments: @colnames"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 1
\&  $source\->remove_columns(qw/col1 col2 col3/);
.Ve
.PP
Removes the given list of columns by name, from the result source.
.PP
\&\fBWarning\fR: Removing a column that is also used in the sources primary
key, or in one of the sources unique constraints, \fBwill\fR result in a
broken result source.
.SS "remove_column"
.IX Subsection "remove_column"
.ie n .IP "Arguments: $colname" 4
.el .IP "Arguments: \f(CW$colname\fR" 4
.IX Item "Arguments: $colname"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
.Vb 1
\&  $source\->remove_column(\*(Aqcol\*(Aq);
.Ve
.PP
Remove a single column by name from the result source, similar to
\&\*(L"remove_columns\*(R".
.PP
\&\fBWarning\fR: Removing a column that is also used in the sources primary
key, or in one of the sources unique constraints, \fBwill\fR result in a
broken result source.
.SS "set_primary_key"
.IX Subsection "set_primary_key"
.ie n .IP "Arguments: @cols" 4
.el .IP "Arguments: \f(CW@cols\fR" 4
.IX Item "Arguments: @cols"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Defines one or more columns as primary key for this source. Must be
called after \*(L"add_columns\*(R".
.PP
Additionally, defines a unique constraint
named \f(CW\*(C`primary\*(C'\fR.
.PP
Note: you normally do want to define a primary key on your sources
\&\fBeven if the underlying database table does not have a primary key\fR.
See
\&\*(L"The Significance and Importance of Primary Keys\*(R" in DBIx::Class::Manual::Intro
for more info.
.SS "primary_columns"
.IX Subsection "primary_columns"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Ordered list of primary column names" 4
.IX Item "Return Value: Ordered list of primary column names"
.PD
.PP
Read-only accessor which returns the list of primary keys, supplied by
\&\*(L"set_primary_key\*(R".
.SS "sequence"
.IX Subsection "sequence"
Manually define the correct sequence for your table, to avoid the overhead
associated with looking up the sequence automatically. The supplied sequence
will be applied to the \*(L"column_info\*(R" of each primary_key
.ie n .IP "Arguments: $sequence_name" 4
.el .IP "Arguments: \f(CW$sequence_name\fR" 4
.IX Item "Arguments: $sequence_name"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.SS "add_unique_constraint"
.IX Subsection "add_unique_constraint"
.ie n .IP "Arguments: $name?, \e@colnames" 4
.el .IP "Arguments: \f(CW$name\fR?, \e@colnames" 4
.IX Item "Arguments: $name?, @colnames"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Declare a unique constraint on this source. Call once for each unique
constraint.
.PP
.Vb 4
\&  # For UNIQUE (column1, column2)
\&  _\|_PACKAGE_\|_\->add_unique_constraint(
\&    constraint_name => [ qw/column1 column2/ ],
\&  );
.Ve
.PP
Alternatively, you can specify only the columns:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->add_unique_constraint([ qw/column1 column2/ ]);
.Ve
.PP
This will result in a unique constraint named
\&\f(CW\*(C`table_column1_column2\*(C'\fR, where \f(CW\*(C`table\*(C'\fR is replaced with the table
name.
.PP
Unique constraints are used, for example, when you pass the constraint
name as the \f(CW\*(C`key\*(C'\fR attribute to \*(L"find\*(R" in DBIx::Class::ResultSet. Then
only columns in the constraint are searched.
.PP
Throws an error if any of the given column names do not yet exist on
the result source.
.SS "add_unique_constraints"
.IX Subsection "add_unique_constraints"
.ie n .IP "Arguments: @constraints" 4
.el .IP "Arguments: \f(CW@constraints\fR" 4
.IX Item "Arguments: @constraints"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Declare multiple unique constraints on this source.
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->add_unique_constraints(
\&    constraint_name1 => [ qw/column1 column2/ ],
\&    constraint_name2 => [ qw/column2 column3/ ],
\&  );
.Ve
.PP
Alternatively, you can specify only the columns:
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->add_unique_constraints(
\&    [ qw/column1 column2/ ],
\&    [ qw/column3 column4/ ]
\&  );
.Ve
.PP
This will result in unique constraints named \f(CW\*(C`table_column1_column2\*(C'\fR and
\&\f(CW\*(C`table_column3_column4\*(C'\fR, where \f(CW\*(C`table\*(C'\fR is replaced with the table name.
.PP
Throws an error if any of the given column names do not yet exist on
the result source.
.PP
See also \*(L"add_unique_constraint\*(R".
.SS "name_unique_constraint"
.IX Subsection "name_unique_constraint"
.IP "Arguments: \e@colnames" 4
.IX Item "Arguments: @colnames"
.PD 0
.IP "Return Value: Constraint name" 4
.IX Item "Return Value: Constraint name"
.PD
.PP
.Vb 4
\&  $source\->table(\*(Aqmytable\*(Aq);
\&  $source\->name_unique_constraint([\*(Aqcol1\*(Aq, \*(Aqcol2\*(Aq]);
\&  # returns
\&  \*(Aqmytable_col1_col2\*(Aq
.Ve
.PP
Return a name for a unique constraint containing the specified
columns. The name is created by joining the table name and each column
name, using an underscore character.
.PP
For example, a constraint on a table named \f(CW\*(C`cd\*(C'\fR containing the columns
\&\f(CW\*(C`artist\*(C'\fR and \f(CW\*(C`title\*(C'\fR would result in a constraint name of \f(CW\*(C`cd_artist_title\*(C'\fR.
.PP
This is used by \*(L"add_unique_constraint\*(R" if you do not specify the
optional constraint name.
.SS "unique_constraints"
.IX Subsection "unique_constraints"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Hash of unique constraint data" 4
.IX Item "Return Value: Hash of unique constraint data"
.PD
.PP
.Vb 1
\&  $source\->unique_constraints();
.Ve
.PP
Read-only accessor which returns a hash of unique constraints on this
source.
.PP
The hash is keyed by constraint name, and contains an arrayref of
column names as values.
.SS "unique_constraint_names"
.IX Subsection "unique_constraint_names"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Unique constraint names" 4
.IX Item "Return Value: Unique constraint names"
.PD
.PP
.Vb 1
\&  $source\->unique_constraint_names();
.Ve
.PP
Returns the list of unique constraint names defined on this source.
.SS "unique_constraint_columns"
.IX Subsection "unique_constraint_columns"
.ie n .IP "Arguments: $constraintname" 4
.el .IP "Arguments: \f(CW$constraintname\fR" 4
.IX Item "Arguments: $constraintname"
.PD 0
.IP "Return Value: List of constraint columns" 4
.IX Item "Return Value: List of constraint columns"
.PD
.PP
.Vb 1
\&  $source\->unique_constraint_columns(\*(Aqmyconstraint\*(Aq);
.Ve
.PP
Returns the list of columns that make up the specified unique constraint.
.SS "sqlt_deploy_callback"
.IX Subsection "sqlt_deploy_callback"
.ie n .IP "Arguments: $callback_name | \e&callback_code" 4
.el .IP "Arguments: \f(CW$callback_name\fR | \e&callback_code" 4
.IX Item "Arguments: $callback_name | &callback_code"
.PD 0
.ie n .IP "Return Value: $callback_name | \e&callback_code" 4
.el .IP "Return Value: \f(CW$callback_name\fR | \e&callback_code" 4
.IX Item "Return Value: $callback_name | &callback_code"
.PD
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->sqlt_deploy_callback(\*(Aqmycallbackmethod\*(Aq);
\&
\&   or
\&
\&  _\|_PACKAGE_\|_\->sqlt_deploy_callback(sub {
\&    my ($source_instance, $sqlt_table) = @_;
\&    ...
\&  } );
.Ve
.PP
An accessor to set a callback to be called during deployment of
the schema via \*(L"create_ddl_dir\*(R" in DBIx::Class::Schema or
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.PP
The callback can be set as either a code reference or the name of a
method in the current result class.
.PP
Defaults to \*(L"default_sqlt_deploy_hook\*(R".
.PP
Your callback will be passed the \f(CW$source\fR object representing the
ResultSource instance being deployed, and the
SQL::Translator::Schema::Table object being created from it. The
callback can be used to manipulate the table object or add your own
customised indexes. If you need to manipulate a non-table object, use
the \*(L"sqlt_deploy_hook\*(R" in DBIx::Class::Schema.
.PP
See \*(L"Adding Indexes And Functions To
Your \s-1SQL\*(R"\s0 in DBIx::Class::Manual::Cookbook for examples.
.PP
This sqlt deployment callback can only be used to manipulate
SQL::Translator objects as they get turned into \s-1SQL.\s0 To execute
post-deploy statements which SQL::Translator does not currently
handle, override \*(L"deploy\*(R" in DBIx::Class::Schema in your Schema class
and call dbh_do.
.SS "default_sqlt_deploy_hook"
.IX Subsection "default_sqlt_deploy_hook"
This is the default deploy hook implementation which checks if your
current Result class has a \f(CW\*(C`sqlt_deploy_hook\*(C'\fR method, and if present
invokes it \fBon the Result class directly\fR. This is to preserve the
semantics of \f(CW\*(C`sqlt_deploy_hook\*(C'\fR which was originally designed to expect
the Result class name and the
\&\f(CW$sqlt_table\fR instance of the table being
deployed.
.SS "result_class"
.IX Subsection "result_class"
.ie n .IP "Arguments: $classname" 4
.el .IP "Arguments: \f(CW$classname\fR" 4
.IX Item "Arguments: $classname"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
.Vb 2
\& use My::Schema::ResultClass::Inflator;
\& ...
\&
\& use My::Schema::Artist;
\& ...
\& _\|_PACKAGE_\|_\->result_class(\*(AqMy::Schema::ResultClass::Inflator\*(Aq);
.Ve
.PP
Set the default result class for this source. You can use this to create
and use your own result inflator. See \*(L"result_class\*(R" in DBIx::Class::ResultSet
for more details.
.PP
Please note that setting this to something like
DBIx::Class::ResultClass::HashRefInflator will make every result unblessed
and make life more difficult.  Inflators like those are better suited to
temporary usage via \*(L"result_class\*(R" in DBIx::Class::ResultSet.
.SS "resultset"
.IX Subsection "resultset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a resultset for the given source. This will initially be created
on demand by calling
.PP
.Vb 1
\&  $self\->resultset_class\->new($self, $self\->resultset_attributes)
.Ve
.PP
but is cached from then on unless resultset_class changes.
.SS "resultset_class"
.IX Subsection "resultset_class"
.ie n .IP "Arguments: $classname" 4
.el .IP "Arguments: \f(CW$classname\fR" 4
.IX Item "Arguments: $classname"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
.Vb 3
\&  package My::Schema::ResultSet::Artist;
\&  use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&  ...
\&
\&  # In the result class
\&  _\|_PACKAGE_\|_\->resultset_class(\*(AqMy::Schema::ResultSet::Artist\*(Aq);
\&
\&  # Or in code
\&  $source\->resultset_class(\*(AqMy::Schema::ResultSet::Artist\*(Aq);
.Ve
.PP
Set the class of the resultset. This is useful if you want to create your
own resultset methods. Create your own class derived from
DBIx::Class::ResultSet, and set it here. If called with no arguments,
this method returns the name of the existing resultset class, if one
exists.
.SS "resultset_attributes"
.IX Subsection "resultset_attributes"
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Return Value: \e%attrs" 4
.IX Item "Return Value: %attrs"
.PD
.PP
.Vb 2
\&  # In the result class
\&  _\|_PACKAGE_\|_\->resultset_attributes({ order_by => [ \*(Aqid\*(Aq ] });
\&
\&  # Or in code
\&  $source\->resultset_attributes({ order_by => [ \*(Aqid\*(Aq ] });
.Ve
.PP
Store a collection of resultset attributes, that will be set on every
DBIx::Class::ResultSet produced from this result source.
.PP
\&\fB\s-1CAVEAT\s0\fR: \f(CW\*(C`resultset_attributes\*(C'\fR comes with its own set of issues and
bugs! While \f(CW\*(C`resultset_attributes\*(C'\fR isn't deprecated per se, its usage is
not recommended!
.PP
Since relationships use attributes to link tables together, the \*(L"default\*(R"
attributes you set may cause unpredictable and undesired behavior.  Furthermore,
the defaults cannot be turned off, so you are stuck with them.
.PP
In most cases, what you should actually be using are project-specific methods:
.PP
.Vb 3
\&  package My::Schema::ResultSet::Artist;
\&  use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&  ...
\&
\&  # BAD IDEA!
\&  #_\|_PACKAGE_\|_\->resultset_attributes({ prefetch => \*(Aqtracks\*(Aq });
\&
\&  # GOOD IDEA!
\&  sub with_tracks { shift\->search({}, { prefetch => \*(Aqtracks\*(Aq }) }
\&
\&  # in your code
\&  $schema\->resultset(\*(AqArtist\*(Aq)\->with_tracks\->...
.Ve
.PP
This gives you the flexibility of not using it when you don't need it.
.PP
For more complex situations, another solution would be to use a virtual view
via DBIx::Class::ResultSource::View.
.SS "name"
.IX Subsection "name"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Result value: $name" 4
.el .IP "Result value: \f(CW$name\fR" 4
.IX Item "Result value: $name"
.PD
.PP
Returns the name of the result source, which will typically be the table
name. This may be a scalar reference if the result source has a non-standard
name.
.SS "source_name"
.IX Subsection "source_name"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Result value: $source_name" 4
.el .IP "Result value: \f(CW$source_name\fR" 4
.IX Item "Result value: $source_name"
.PD
.PP
Set an alternate name for the result source when it is loaded into a schema.
This is useful if you want to refer to a result source by a name other than
its class name.
.PP
.Vb 4
\&  package ArchivedBooks;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqbooks_archive\*(Aq);
\&  _\|_PACKAGE_\|_\->source_name(\*(AqBooks\*(Aq);
\&
\&  # from your schema...
\&  $schema\->resultset(\*(AqBooks\*(Aq)\->find(1);
.Ve
.SS "from"
.IX Subsection "from"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \s-1FROM\s0 clause" 4
.IX Item "Return Value: FROM clause"
.PD
.PP
.Vb 1
\&  my $from_clause = $source\->from();
.Ve
.PP
Returns an expression of the source to be supplied to storage to specify
retrieval from this source. In the case of a database, the required \s-1FROM\s0
clause contents.
.SS "schema"
.IX Subsection "schema"
.ie n .IP "Arguments: $schema?" 4
.el .IP "Arguments: \f(CW$schema\fR?" 4
.IX Item "Arguments: $schema?"
.PD 0
.ie n .IP "Return Value: $schema" 4
.el .IP "Return Value: \f(CW$schema\fR" 4
.IX Item "Return Value: $schema"
.PD
.PP
.Vb 1
\&  my $schema = $source\->schema();
.Ve
.PP
Sets and/or returns the DBIx::Class::Schema object to which this
result source instance has been attached to.
.SS "storage"
.IX Subsection "storage"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $storage" 4
.el .IP "Return Value: \f(CW$storage\fR" 4
.IX Item "Return Value: $storage"
.PD
.PP
.Vb 1
\&  $source\->storage\->debug(1);
.Ve
.PP
Returns the storage handle for the current schema.
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: $rel_name, $related_source_name, \e%cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel_name\fR, \f(CW$related_source_name\fR, \e%cond, \e%attrs?" 4
.IX Item "Arguments: $rel_name, $related_source_name, %cond, %attrs?"
.PD 0
.IP "Return Value: 1/true if it succeeded" 4
.IX Item "Return Value: 1/true if it succeeded"
.PD
.PP
.Vb 1
\&  $source\->add_relationship(\*(Aqrel_name\*(Aq, \*(Aqrelated_source\*(Aq, $cond, $attrs);
.Ve
.PP
DBIx::Class::Relationship describes a series of methods which
create pre-defined useful types of relationships. Look there first
before using this method directly.
.PP
The relationship name can be arbitrary, but must be unique for each
relationship attached to this result source. 'related_source' should
be the name with which the related result source was registered with
the current schema. For example:
.PP
.Vb 3
\&  $schema\->source(\*(AqBook\*(Aq)\->add_relationship(\*(Aqreviews\*(Aq, \*(AqReview\*(Aq, {
\&    \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq,
\&  });
.Ve
.PP
The condition \f(CW$cond\fR needs to be an SQL::Abstract\-style
representation of the join between the tables. For example, if you're
creating a relation from Author to Book,
.PP
.Vb 1
\&  { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
.Ve
.PP
will result in the \s-1JOIN\s0 clause
.PP
.Vb 1
\&  author me JOIN book foreign ON foreign.author_id = me.id
.Ve
.PP
You can specify as many foreign => self mappings as necessary.
.PP
Valid attributes are as follows:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any
\&\s-1SQL\s0 join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in
the \s-1SQL\s0 command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.IP "proxy" 4
.IX Item "proxy"
An arrayref containing a list of accessors in the foreign class to proxy in
the main class. If, for example, you do the following:
.Sp
.Vb 3
\&  CD\->might_have(liner_notes => \*(AqLinerNotes\*(Aq, undef, {
\&    proxy => [ qw/notes/ ],
\&  });
.Ve
.Sp
Then, assuming LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = CD\->find(1);
\&  # set notes \-\- LinerNotes object is created if it doesn\*(Aqt exist
\&  $cd\->notes(\*(AqNotes go here\*(Aq);
.Ve
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the
relationship. Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single
related object), \f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for
when there is a single related object, but you also want the relationship
accessor to double as a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an
add_to_* method is also created, which calls \f(CW\*(C`create_related\*(C'\fR for the
relationship.
.PP
Throws an exception if the condition is improperly supplied, or cannot
be resolved.
.SS "relationships"
.IX Subsection "relationships"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @rel_names" 4
.el .IP "Return Value: \f(CW@rel_names\fR" 4
.IX Item "Return Value: @rel_names"
.PD
.PP
.Vb 1
\&  my @relnames = $source\->relationships();
.Ve
.PP
Returns all relationship names for this source.
.SS "relationship_info"
.IX Subsection "relationship_info"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.IP "Return Value: \e%rel_data" 4
.IX Item "Return Value: %rel_data"
.PD
.PP
Returns a hash of relationship information for the specified relationship
name. The keys/values are as specified for \*(L"add_relationship\*(R" in DBIx::Class::Relationship::Base.
.SS "has_relationship"
.IX Subsection "has_relationship"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.IP "Return Value: 1/0 (true/false)" 4
.IX Item "Return Value: 1/0 (true/false)"
.PD
.PP
Returns true if the source has a relationship of this name, false otherwise.
.SS "reverse_relationship_info"
.IX Subsection "reverse_relationship_info"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.IP "Return Value: \e%rel_data" 4
.IX Item "Return Value: %rel_data"
.PD
.PP
Looks through all the relationships on the source this relationship
points to, looking for one whose condition is the reverse of the
condition on this relationship.
.PP
A common use of this is to find the name of the \f(CW\*(C`belongs_to\*(C'\fR relation
opposing a \f(CW\*(C`has_many\*(C'\fR relation. For definition of these look in
DBIx::Class::Relationship.
.PP
The returned hashref is keyed by the name of the opposing
relationship, and contains its data in the same manner as
\&\*(L"relationship_info\*(R".
.SS "related_source"
.IX Subsection "related_source"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $source" 4
.el .IP "Return Value: \f(CW$source\fR" 4
.IX Item "Return Value: $source"
.PD
.PP
Returns the result source object for the given relationship.
.SS "related_class"
.IX Subsection "related_class"
.ie n .IP "Arguments: $rel_name" 4
.el .IP "Arguments: \f(CW$rel_name\fR" 4
.IX Item "Arguments: $rel_name"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
Returns the class name for objects in the given relationship.
.SS "handle"
.IX Subsection "handle"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $source_handle" 4
.el .IP "Return Value: \f(CW$source_handle\fR" 4
.IX Item "Return Value: $source_handle"
.PD
.PP
Obtain a new result source handle instance
for this source. Used as a serializable pointer to this resultsource, as it is not
easy (nor advisable) to serialize CODErefs which may very well be present in e.g.
relationship definitions.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "source_info"
.IX Subsection "source_info"
Stores a hashref of per-source metadata.  No specific key names
have yet been standardized, the examples below are purely hypothetical
and don't actually accomplish anything on their own:
.PP
.Vb 4
\&  _\|_PACKAGE_\|_\->source_info({
\&    "_tablespace" => \*(Aqfast_disk_array_3\*(Aq,
\&    "_engine" => \*(AqInnoDB\*(Aq,
\&  });
.Ve
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $class\->new();
\&
\&  $class\->new({attribute_name => value});
.Ve
.PP
Creates a new ResultSource object.  Not normally called directly by end users.
.SS "column_info_from_storage"
.IX Subsection "column_info_from_storage"
.IP "Arguments: 1/0 (default: 0)" 4
.IX Item "Arguments: 1/0 (default: 0)"
.PD 0
.IP "Return Value: 1/0" 4
.IX Item "Return Value: 1/0"
.PD
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->column_info_from_storage(1);
.Ve
.PP
Enables the on-demand automatic loading of the above column
metadata from storage as necessary.  This is *deprecated*, and
should not be used.  It will be removed before 1.0.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource::Table.3pm         0100644 0001750 0001750 00000012372 12566242400 027137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource::Table 3"
.TH DBIx::Class::ResultSource::Table 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource::Table \- Table object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Table object that inherits from DBIx::Class::ResultSource.
.SH "METHODS"
.IX Header "METHODS"
.SS "from"
.IX Subsection "from"
Returns the \s-1FROM\s0 entry for the table (i.e. the table name)
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::ResultSource" 4
.IX Item "DBIx::Class::ResultSource"
add_column, add_columns, add_relationship, add_unique_constraint, add_unique_constraints, column_info, column_info_from_storage, columns, columns_info, default_sqlt_deploy_hook, handle, has_column, has_relationship, name, name_unique_constraint, new, primary_columns, related_class, related_source, relationship_info, relationships, remove_column, remove_columns, result_class, resultset, resultset_attributes, resultset_class, reverse_relationship_info, schema, sequence, set_primary_key, source_info, source_name, sqlt_deploy_callback, storage, throw_exception, unique_constraint_columns, unique_constraint_names, unique_constraints
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource::Table5.16.3pm     0100644 0001750 0001750 00000010402 12566242362 027450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource::Table 3"
.TH DBIx::Class::ResultSource::Table 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource::Table \- Table object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Table object that inherits from DBIx::Class::ResultSource.
.SH "METHODS"
.IX Header "METHODS"
.SS "from"
.IX Subsection "from"
Returns the \s-1FROM\s0 entry for the table (i.e. the table name)
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource::Table5.18.3pm     0100644 0001750 0001750 00000012372 12566242400 027453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource::Table 3"
.TH DBIx::Class::ResultSource::Table 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource::Table \- Table object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Table object that inherits from DBIx::Class::ResultSource.
.SH "METHODS"
.IX Header "METHODS"
.SS "from"
.IX Subsection "from"
Returns the \s-1FROM\s0 entry for the table (i.e. the table name)
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::ResultSource" 4
.IX Item "DBIx::Class::ResultSource"
add_column, add_columns, add_relationship, add_unique_constraint, add_unique_constraints, column_info, column_info_from_storage, columns, columns_info, default_sqlt_deploy_hook, handle, has_column, has_relationship, name, name_unique_constraint, new, primary_columns, related_class, related_source, relationship_info, relationships, remove_column, remove_columns, result_class, resultset, resultset_attributes, resultset_class, reverse_relationship_info, schema, sequence, set_primary_key, source_info, source_name, sqlt_deploy_callback, storage, throw_exception, unique_constraint_columns, unique_constraint_names, unique_constraints
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource::View.3pm          0100644 0001750 0001750 00000022470 12566242377 027037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource::View 3"
.TH DBIx::Class::ResultSource::View 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource::View \- ResultSource object representing a view
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyApp::Schema::Result::Year2000CDs;
\&
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::View\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqyear2000cds\*(Aq);
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&  );
\&  _\|_PACKAGE_\|_\->add_columns(
\&    \*(Aqcdid\*(Aq => {
\&      data_type => \*(Aqinteger\*(Aq,
\&      is_auto_increment => 1,
\&    },
\&    \*(Aqartist\*(Aq => {
\&      data_type => \*(Aqinteger\*(Aq,
\&    },
\&    \*(Aqtitle\*(Aq => {
\&      data_type => \*(Aqvarchar\*(Aq,
\&      size      => 100,
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
View object that inherits from DBIx::Class::ResultSource
.PP
This class extends ResultSource to add basic view support.
.PP
A view has a \*(L"view_definition\*(R", which contains a \s-1SQL\s0 query. The query can
only have parameters if \*(L"is_virtual\*(R" is set to true. It may contain JOINs,
sub selects and any other \s-1SQL\s0 your database supports.
.PP
View definition \s-1SQL\s0 is deployed to your database on
\&\*(L"deploy\*(R" in DBIx::Class::Schema unless you set \*(L"is_virtual\*(R" to true.
.PP
Deploying the view does \fBnot\fR translate it between different database
syntaxes, so be careful what you write in your view \s-1SQL.\s0
.PP
Virtual views (\*(L"is_virtual\*(R" true), are assumed to not
exist in your database as a real view. The \*(L"view_definition\*(R" in this
case replaces the view name in a \s-1FROM\s0 clause in a subselect.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Having created the MyApp::Schema::Year2000CDs schema as shown in the \s-1SYNOPSIS\s0
above, you can then:
.PP
.Vb 6
\&  $2000_cds = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search()
\&                     \->all();
\&  $count    = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search()
\&                     \->count();
.Ve
.PP
If you modified the schema to include a placeholder
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year = ?"
\&  );
.Ve
.PP
and ensuring you have is_virtual set to true:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
.Ve
.PP
You could now say:
.PP
.Vb 6
\&  $2001_cds = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search({}, { bind => [2001] })
\&                     \->all();
\&  $count    = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search({}, { bind => [2001] })
\&                     \->count();
.Ve
.SH "SQL EXAMPLES"
.IX Header "SQL EXAMPLES"
.IP "is_virtual set to false" 4
.IX Item "is_virtual set to false"
.Vb 1
\&  $schema\->resultset(\*(AqYear2000CDs\*(Aq)\->all();
\&
\&  SELECT cdid, artist, title FROM year2000cds me
.Ve
.IP "is_virtual set to true" 4
.IX Item "is_virtual set to true"
.Vb 1
\&  $schema\->resultset(\*(AqYear2000CDs\*(Aq)\->all();
\&
\&  SELECT cdid, artist, title FROM
\&    (SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq) me
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "is_virtual"
.IX Subsection "is_virtual"
.Vb 1
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
.Ve
.PP
Set to true for a virtual view, false or unset for a real
database-based view.
.SS "view_definition"
.IX Subsection "view_definition"
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&      );
.Ve
.PP
An \s-1SQL\s0 query for your view. Will not be translated across database
syntaxes.
.SS "deploy_depends_on"
.IX Subsection "deploy_depends_on"
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->deploy_depends_on(
\&      ["MyApp::Schema::Result::Year","MyApp::Schema::Result::CD"]
\&      );
.Ve
.PP
Specify the views (and only the views) that this view depends on.
Pass this an array reference of fully qualified result classes.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
.SS "from"
.IX Subsection "from"
Returns the \s-1FROM\s0 entry for the table (i.e. the view name)
or the \s-1SQL\s0 as a subselect if this is a virtual view.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.SS "new"
.IX Subsection "new"
The constructor.
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::ResultSource" 4
.IX Item "DBIx::Class::ResultSource"
add_column, add_columns, add_relationship, add_unique_constraint, add_unique_constraints, column_info, column_info_from_storage, columns, columns_info, default_sqlt_deploy_hook, handle, has_column, has_relationship, name, name_unique_constraint, primary_columns, related_class, related_source, relationship_info, relationships, remove_column, remove_columns, result_class, resultset, resultset_attributes, resultset_class, reverse_relationship_info, schema, sequence, set_primary_key, source_info, source_name, sqlt_deploy_callback, storage, throw_exception, unique_constraint_columns, unique_constraint_names, unique_constraints
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource::View5.16.3pm      0100644 0001750 0001750 00000020563 12566242362 027344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource::View 3"
.TH DBIx::Class::ResultSource::View 3 "2012-08-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource::View \- ResultSource object representing a view
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyApp::Schema::Result::Year2000CDs;
\&
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::View\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqyear2000cds\*(Aq);
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&  );
\&  _\|_PACKAGE_\|_\->add_columns(
\&    \*(Aqcdid\*(Aq => {
\&      data_type => \*(Aqinteger\*(Aq,
\&      is_auto_increment => 1,
\&    },
\&    \*(Aqartist\*(Aq => {
\&      data_type => \*(Aqinteger\*(Aq,
\&    },
\&    \*(Aqtitle\*(Aq => {
\&      data_type => \*(Aqvarchar\*(Aq,
\&      size      => 100,
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
View object that inherits from DBIx::Class::ResultSource
.PP
This class extends ResultSource to add basic view support.
.PP
A view has a \*(L"view_definition\*(R", which contains a \s-1SQL\s0 query. The query can
only have parameters if \*(L"is_virtual\*(R" is set to true. It may contain JOINs,
sub selects and any other \s-1SQL\s0 your database supports.
.PP
View definition \s-1SQL\s0 is deployed to your database on
\&\*(L"deploy\*(R" in DBIx::Class::Schema unless you set \*(L"is_virtual\*(R" to true.
.PP
Deploying the view does \fBnot\fR translate it between different database
syntaxes, so be careful what you write in your view \s-1SQL\s0.
.PP
Virtual views (\*(L"is_virtual\*(R" true), are assumed to not
exist in your database as a real view. The \*(L"view_definition\*(R" in this
case replaces the view name in a \s-1FROM\s0 clause in a subselect.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Having created the MyApp::Schema::Year2000CDs schema as shown in the \s-1SYNOPSIS\s0
above, you can then:
.PP
.Vb 6
\&  $2000_cds = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search()
\&                     \->all();
\&  $count    = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search()
\&                     \->count();
.Ve
.PP
If you modified the schema to include a placeholder
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year = ?"
\&  );
.Ve
.PP
and ensuring you have is_virtual set to true:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
.Ve
.PP
You could now say:
.PP
.Vb 6
\&  $2001_cds = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search({}, { bind => [2001] })
\&                     \->all();
\&  $count    = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search({}, { bind => [2001] })
\&                     \->count();
.Ve
.SH "SQL EXAMPLES"
.IX Header "SQL EXAMPLES"
.IP "is_virtual set to false" 4
.IX Item "is_virtual set to false"
.Vb 1
\&  $schema\->resultset(\*(AqYear2000CDs\*(Aq)\->all();
\&
\&  SELECT cdid, artist, title FROM year2000cds me
.Ve
.IP "is_virtual set to true" 4
.IX Item "is_virtual set to true"
.Vb 1
\&  $schema\->resultset(\*(AqYear2000CDs\*(Aq)\->all();
\&
\&  SELECT cdid, artist, title FROM
\&    (SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq) me
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "is_virtual"
.IX Subsection "is_virtual"
.Vb 1
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
.Ve
.PP
Set to true for a virtual view, false or unset for a real
database-based view.
.SS "view_definition"
.IX Subsection "view_definition"
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&      );
.Ve
.PP
An \s-1SQL\s0 query for your view. Will not be translated across database
syntaxes.
.SS "deploy_depends_on"
.IX Subsection "deploy_depends_on"
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->deploy_depends_on(
\&      ["MyApp::Schema::Result::Year","MyApp::Schema::Result::CD"]
\&      );
.Ve
.PP
Specify the views (and only the views) that this view depends on.
Pass this an array reference of fully qualified result classes.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
.SS "from"
.IX Subsection "from"
Returns the \s-1FROM\s0 entry for the table (i.e. the view name)
or the \s-1SQL\s0 as a subselect if this is a virtual view.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.SS "new"
.IX Subsection "new"
The constructor.
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\s0\*(R" in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSource::View5.18.3pm      0100644 0001750 0001750 00000022470 12566242377 027353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSource::View 3"
.TH DBIx::Class::ResultSource::View 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSource::View \- ResultSource object representing a view
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyApp::Schema::Result::Year2000CDs;
\&
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::View\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->table(\*(Aqyear2000cds\*(Aq);
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&  );
\&  _\|_PACKAGE_\|_\->add_columns(
\&    \*(Aqcdid\*(Aq => {
\&      data_type => \*(Aqinteger\*(Aq,
\&      is_auto_increment => 1,
\&    },
\&    \*(Aqartist\*(Aq => {
\&      data_type => \*(Aqinteger\*(Aq,
\&    },
\&    \*(Aqtitle\*(Aq => {
\&      data_type => \*(Aqvarchar\*(Aq,
\&      size      => 100,
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
View object that inherits from DBIx::Class::ResultSource
.PP
This class extends ResultSource to add basic view support.
.PP
A view has a \*(L"view_definition\*(R", which contains a \s-1SQL\s0 query. The query can
only have parameters if \*(L"is_virtual\*(R" is set to true. It may contain JOINs,
sub selects and any other \s-1SQL\s0 your database supports.
.PP
View definition \s-1SQL\s0 is deployed to your database on
\&\*(L"deploy\*(R" in DBIx::Class::Schema unless you set \*(L"is_virtual\*(R" to true.
.PP
Deploying the view does \fBnot\fR translate it between different database
syntaxes, so be careful what you write in your view \s-1SQL.\s0
.PP
Virtual views (\*(L"is_virtual\*(R" true), are assumed to not
exist in your database as a real view. The \*(L"view_definition\*(R" in this
case replaces the view name in a \s-1FROM\s0 clause in a subselect.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Having created the MyApp::Schema::Year2000CDs schema as shown in the \s-1SYNOPSIS\s0
above, you can then:
.PP
.Vb 6
\&  $2000_cds = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search()
\&                     \->all();
\&  $count    = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search()
\&                     \->count();
.Ve
.PP
If you modified the schema to include a placeholder
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year = ?"
\&  );
.Ve
.PP
and ensuring you have is_virtual set to true:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
.Ve
.PP
You could now say:
.PP
.Vb 6
\&  $2001_cds = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search({}, { bind => [2001] })
\&                     \->all();
\&  $count    = $schema\->resultset(\*(AqYear2000CDs\*(Aq)
\&                     \->search({}, { bind => [2001] })
\&                     \->count();
.Ve
.SH "SQL EXAMPLES"
.IX Header "SQL EXAMPLES"
.IP "is_virtual set to false" 4
.IX Item "is_virtual set to false"
.Vb 1
\&  $schema\->resultset(\*(AqYear2000CDs\*(Aq)\->all();
\&
\&  SELECT cdid, artist, title FROM year2000cds me
.Ve
.IP "is_virtual set to true" 4
.IX Item "is_virtual set to true"
.Vb 1
\&  $schema\->resultset(\*(AqYear2000CDs\*(Aq)\->all();
\&
\&  SELECT cdid, artist, title FROM
\&    (SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq) me
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "is_virtual"
.IX Subsection "is_virtual"
.Vb 1
\&  _\|_PACKAGE_\|_\->result_source_instance\->is_virtual(1);
.Ve
.PP
Set to true for a virtual view, false or unset for a real
database-based view.
.SS "view_definition"
.IX Subsection "view_definition"
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->view_definition(
\&      "SELECT cdid, artist, title FROM cd WHERE year =\*(Aq2000\*(Aq"
\&      );
.Ve
.PP
An \s-1SQL\s0 query for your view. Will not be translated across database
syntaxes.
.SS "deploy_depends_on"
.IX Subsection "deploy_depends_on"
.Vb 3
\&  _\|_PACKAGE_\|_\->result_source_instance\->deploy_depends_on(
\&      ["MyApp::Schema::Result::Year","MyApp::Schema::Result::CD"]
\&      );
.Ve
.PP
Specify the views (and only the views) that this view depends on.
Pass this an array reference of fully qualified result classes.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
.SS "from"
.IX Subsection "from"
Returns the \s-1FROM\s0 entry for the table (i.e. the view name)
or the \s-1SQL\s0 as a subselect if this is a virtual view.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.SS "new"
.IX Subsection "new"
The constructor.
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::ResultSource" 4
.IX Item "DBIx::Class::ResultSource"
add_column, add_columns, add_relationship, add_unique_constraint, add_unique_constraints, column_info, column_info_from_storage, columns, columns_info, default_sqlt_deploy_hook, handle, has_column, has_relationship, name, name_unique_constraint, primary_columns, related_class, related_source, relationship_info, relationships, remove_column, remove_columns, result_class, resultset, resultset_attributes, resultset_class, reverse_relationship_info, schema, sequence, set_primary_key, source_info, source_name, sqlt_deploy_callback, storage, throw_exception, unique_constraint_columns, unique_constraint_names, unique_constraints
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSourceHandle.3pm          0100644 0001750 0001750 00000012436 12566242400 027120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSourceHandle 3"
.TH DBIx::Class::ResultSourceHandle 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSourceHandle \- Serializable pointers to ResultSource instances
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Currently instances of this class are used to allow proper serialization of
ResultSources (which may contain unserializable
elements like \f(CW\*(C`CODE\*(C'\fR references).
.PP
Originally this module was used to remove the fixed link between
Rows/ResultSets and the actual
result source objects in order to obviate the need
of keeping a schema instance constantly in scope, while
at the same time avoiding leaks due to circular dependencies. This is however
no longer needed after introduction of a proper mutual-assured-destruction
contract between a \f(CW\*(C`Schema\*(C'\fR instance and its \f(CW\*(C`ResultSource\*(C'\fR registrants.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.SS "resolve"
.IX Subsection "resolve"
Resolve the moniker into the actual ResultSource object
.SS "STORABLE_freeze"
.IX Subsection "STORABLE_freeze"
Freezes a handle.
.SS "STORABLE_thaw"
.IX Subsection "STORABLE_thaw"
Thaws frozen handle. Resets the internal schema reference to the package
variable \f(CW$thaw_schema\fR. The recommended way of setting this is to use
\&\f(CW\*(C`$schema\->thaw($ice)\*(C'\fR which handles this for you.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin \f(CW\*(C`<ash@cpan.org>\*(C'\fR
                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSourceHandle5.16.3pm      0100644 0001750 0001750 00000012115 12566242363 027434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSourceHandle 3"
.TH DBIx::Class::ResultSourceHandle 3 "2012-08-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSourceHandle \- Serializable pointers to ResultSource instances
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Currently instances of this class are used to allow proper serialization of
ResultSources (which may contain unserializable
elements like \f(CW\*(C`CODE\*(C'\fR references).
.PP
Originally this module was used to remove the fixed link between
Rows/ResultSets and the actual
result source objects in order to obviate the need
of keeping a schema instance constantly in scope, while
at the same time avoiding leaks due to circular dependencies. This is however
no longer needed after introduction of a proper mutual-assured-destruction
contract between a \f(CW\*(C`Schema\*(C'\fR instance and its \f(CW\*(C`ResultSource\*(C'\fR registrants.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.SS "resolve"
.IX Subsection "resolve"
Resolve the moniker into the actual ResultSource object
.SS "STORABLE_freeze"
.IX Subsection "STORABLE_freeze"
Freezes a handle.
.SS "STORABLE_thaw"
.IX Subsection "STORABLE_thaw"
Thaws frozen handle. Resets the internal schema reference to the package
variable \f(CW$thaw_schema\fR. The recommended way of setting this is to use
\&\f(CW\*(C`$schema\->thaw($ice)\*(C'\fR which handles this for you.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin \f(CW\*(C`<ash@cpan.org>\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSourceHandle5.18.3pm      0100644 0001750 0001750 00000012436 12566242400 027434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSourceHandle 3"
.TH DBIx::Class::ResultSourceHandle 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSourceHandle \- Serializable pointers to ResultSource instances
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Currently instances of this class are used to allow proper serialization of
ResultSources (which may contain unserializable
elements like \f(CW\*(C`CODE\*(C'\fR references).
.PP
Originally this module was used to remove the fixed link between
Rows/ResultSets and the actual
result source objects in order to obviate the need
of keeping a schema instance constantly in scope, while
at the same time avoiding leaks due to circular dependencies. This is however
no longer needed after introduction of a proper mutual-assured-destruction
contract between a \f(CW\*(C`Schema\*(C'\fR instance and its \f(CW\*(C`ResultSource\*(C'\fR registrants.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.SS "resolve"
.IX Subsection "resolve"
Resolve the moniker into the actual ResultSource object
.SS "STORABLE_freeze"
.IX Subsection "STORABLE_freeze"
Freezes a handle.
.SS "STORABLE_thaw"
.IX Subsection "STORABLE_thaw"
Thaws frozen handle. Resets the internal schema reference to the package
variable \f(CW$thaw_schema\fR. The recommended way of setting this is to use
\&\f(CW\*(C`$schema\->thaw($ice)\*(C'\fR which handles this for you.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin \f(CW\*(C`<ash@cpan.org>\*(C'\fR
                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSourceProxy::Table.3pm    0100644 0001750 0001750 00000014157 12566242377 030221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSourceProxy::Table 3"
.TH DBIx::Class::ResultSourceProxy::Table 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSourceProxy::Table \- provides a classdata table
object and method proxies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/cdid artist title year/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqcdid\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "add_columns"
.IX Subsection "add_columns"
.Vb 1
\&  _\|_PACKAGE_\|_\->add_columns(qw/cdid artist title year/);
.Ve
.PP
Adds columns to the current class and creates accessors for them.
.SS "table"
.IX Subsection "table"
.Vb 1
\&  _\|_PACKAGE_\|_\->table(\*(Aqtbl_name\*(Aq);
.Ve
.PP
Gets or sets the table name.
.SS "table_class"
.IX Subsection "table_class"
.Vb 1
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::Table\*(Aq);
.Ve
.PP
Gets or sets the table class used for construction and validation.
.SS "has_column"
.IX Subsection "has_column"
.Vb 1
\&  if ($obj\->has_column($col)) { ... }
.Ve
.PP
Returns 1 if the class has a column of this name, 0 otherwise.
.SS "column_info"
.IX Subsection "column_info"
.Vb 1
\&  my $info = $obj\->column_info($col);
.Ve
.PP
Returns the column metadata hashref for a column. For a description of
the various types of column data in this hashref, see
\&\*(L"add_column\*(R" in DBIx::Class::ResultSource
.SS "columns"
.IX Subsection "columns"
.Vb 1
\&  my @column_names = $obj\->columns;
.Ve
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::ResultSource" 4
.IX Item "DBIx::Class::ResultSource"
add_column, add_columns, add_relationship, add_unique_constraint, add_unique_constraints, column_info, column_info_from_storage, columns, columns_info, has_column, has_relationship, primary_columns, relationship_info, relationships, remove_column, remove_columns, result_class, resultset_attributes, resultset_class, sequence, set_primary_key, source_info, source_name, unique_constraint_columns, unique_constraint_names, unique_constraints
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSourceProxy::Table5.16.3pm0100644 0001750 0001750 00000012152 12566242362 030516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSourceProxy::Table 3"
.TH DBIx::Class::ResultSourceProxy::Table 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSourceProxy::Table \- provides a classdata table
object and method proxies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/cdid artist title year/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqcdid\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "add_columns"
.IX Subsection "add_columns"
.Vb 1
\&  _\|_PACKAGE_\|_\->add_columns(qw/cdid artist title year/);
.Ve
.PP
Adds columns to the current class and creates accessors for them.
.SS "table"
.IX Subsection "table"
.Vb 1
\&  _\|_PACKAGE_\|_\->table(\*(Aqtbl_name\*(Aq);
.Ve
.PP
Gets or sets the table name.
.SS "has_column"
.IX Subsection "has_column"
.Vb 1
\&  if ($obj\->has_column($col)) { ... }
.Ve
.PP
Returns 1 if the class has a column of this name, 0 otherwise.
.SS "column_info"
.IX Subsection "column_info"
.Vb 1
\&  my $info = $obj\->column_info($col);
.Ve
.PP
Returns the column metadata hashref for a column. For a description of
the various types of column data in this hashref, see
\&\*(L"add_column\*(R" in DBIx::Class::ResultSource
.SS "columns"
.IX Subsection "columns"
.Vb 1
\&  my @column_names = $obj\->columns;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::ResultSourceProxy::Table5.18.3pm0100644 0001750 0001750 00000014157 12566242377 030535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSourceProxy::Table 3"
.TH DBIx::Class::ResultSourceProxy::Table 3 "2014-01-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSourceProxy::Table \- provides a classdata table
object and method proxies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/cdid artist title year/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqcdid\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "add_columns"
.IX Subsection "add_columns"
.Vb 1
\&  _\|_PACKAGE_\|_\->add_columns(qw/cdid artist title year/);
.Ve
.PP
Adds columns to the current class and creates accessors for them.
.SS "table"
.IX Subsection "table"
.Vb 1
\&  _\|_PACKAGE_\|_\->table(\*(Aqtbl_name\*(Aq);
.Ve
.PP
Gets or sets the table name.
.SS "table_class"
.IX Subsection "table_class"
.Vb 1
\&  _\|_PACKAGE_\|_\->table_class(\*(AqDBIx::Class::ResultSource::Table\*(Aq);
.Ve
.PP
Gets or sets the table class used for construction and validation.
.SS "has_column"
.IX Subsection "has_column"
.Vb 1
\&  if ($obj\->has_column($col)) { ... }
.Ve
.PP
Returns 1 if the class has a column of this name, 0 otherwise.
.SS "column_info"
.IX Subsection "column_info"
.Vb 1
\&  my $info = $obj\->column_info($col);
.Ve
.PP
Returns the column metadata hashref for a column. For a description of
the various types of column data in this hashref, see
\&\*(L"add_column\*(R" in DBIx::Class::ResultSource
.SS "columns"
.IX Subsection "columns"
.Vb 1
\&  my @column_names = $obj\->columns;
.Ve
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
.IP "DBIx::Class::ResultSource" 4
.IX Item "DBIx::Class::ResultSource"
add_column, add_columns, add_relationship, add_unique_constraint, add_unique_constraints, column_info, column_info_from_storage, columns, columns_info, has_column, has_relationship, primary_columns, relationship_info, relationships, remove_column, remove_columns, result_class, resultset_attributes, resultset_class, sequence, set_primary_key, source_info, source_name, unique_constraint_columns, unique_constraint_names, unique_constraints
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Row.3pm                         0100644 0001750 0001750 00000067133 12566242400 024120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Row 3"
.TH DBIx::Class::Row 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Row \- Basic row methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is responsible for defining and doing basic operations on rows
derived from DBIx::Class::ResultSource objects.
.PP
Result objects are returned from DBIx::Class::ResultSets using the
create, find,
next and all methods,
as well as invocations of 'single' (
belongs_to,
has_one or
might_have)
relationship accessors of Result objects.
.SH "NOTE"
.IX Header "NOTE"
All \*(L"Row objects\*(R" derived from a Schema-attached DBIx::Class::ResultSet
object (such as a typical \f(CW\*(C`search\->
next\*(C'\fR call) are actually Result
instances, based on your application's
Result class.
.PP
DBIx::Class::Row implements most of the row-based communication with the
underlying storage, but a Result class \fBshould not inherit from it directly\fR.
Usually, Result classes inherit from DBIx::Class::Core, which in turn
combines the methods from several classes, one of them being
DBIx::Class::Row.  Therefore, while many of the methods available to a
DBIx::Class::Core\-derived Result class are described in the following
documentation, it does not detail all of the methods available to Result
objects.  Refer to DBIx::Class::Manual::ResultClass for more info.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $result = My::Class\->new(\e%attrs);
\&
\&  my $result = $schema\->resultset(\*(AqMySource\*(Aq)\->new(\e%colsandvalues);
.Ve
.IP "Arguments: \e%attrs or \e%colsandvalues" 4
.IX Item "Arguments: %attrs or %colsandvalues"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
While you can create a new result object by calling \f(CW\*(C`new\*(C'\fR directly on
this class, you are better off calling it on a
DBIx::Class::ResultSet object.
.PP
When calling it directly, you will not get a complete, usable row
object until you pass or set the \f(CW\*(C`result_source\*(C'\fR attribute, to a
DBIx::Class::ResultSource instance that is attached to a
DBIx::Class::Schema with a valid connection.
.PP
\&\f(CW$attrs\fR is a hashref of column name, value data. It can also contain
some other attributes such as the \f(CW\*(C`result_source\*(C'\fR.
.PP
Passing an object, or an arrayref of objects as a value will call
\&\*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base for you. When
passed a hashref or an arrayref of hashrefs as the value, these will
be turned into objects via new_related, and treated as if you had
passed objects.
.PP
For a more involved explanation, see \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
Please note that if a value is not passed to new, no value will be sent
in the \s-1SQL INSERT\s0 call, and the column will therefore assume whatever
default value was specified in your database. While \s-1DBIC\s0 will retrieve the
value of autoincrement columns, it will never make an explicit database
trip to retrieve default values assigned by the \s-1RDBMS.\s0 You can explicitly
request that all values be fetched back from the database by calling
\&\*(L"discard_changes\*(R", or you can supply an explicit \f(CW\*(C`undef\*(C'\fR to columns
with \s-1NULL\s0 as the default, and save yourself a \s-1SELECT.\s0
.PP
.Vb 1
\& CAVEAT:
\&
\& The behavior described above will backfire if you use a foreign key column
\& with a database\-defined default. If you call the relationship accessor on
\& an object that doesn\*(Aqt have a set value for the FK column, DBIC will throw
\& an exception, as it has no way of knowing the PK of the related object (if
\& there is one).
.Ve
.ie n .SS "$column_accessor"
.el .SS "\f(CW$column_accessor\fP"
.IX Subsection "$column_accessor"
.Vb 1
\&  # Each pair does the same thing
\&
\&  # (un\-inflated, regular column)
\&  my $val = $result\->get_column(\*(Aqfirst_name\*(Aq);
\&  my $val = $result\->first_name;
\&
\&  $result\->set_column(\*(Aqfirst_name\*(Aq => $val);
\&  $result\->first_name($val);
\&
\&  # (inflated column via DBIx::Class::InflateColumn::DateTime)
\&  my $val = $result\->get_inflated_column(\*(Aqlast_modified\*(Aq);
\&  my $val = $result\->last_modified;
\&
\&  $result\->set_inflated_column(\*(Aqlast_modified\*(Aq => $val);
\&  $result\->last_modified($val);
.Ve
.ie n .IP "Arguments: $value?" 4
.el .IP "Arguments: \f(CW$value\fR?" 4
.IX Item "Arguments: $value?"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
A column accessor method is created for each column, which is used for
getting/setting the value for that column.
.PP
The actual method name is based on the
accessor name given during the
Result Class column definition
\&. Like \*(L"set_column\*(R", this
will not store the data in the database until \*(L"insert\*(R" or \*(L"update\*(R"
is called on the row.
.SS "insert"
.IX Subsection "insert"
.Vb 1
\&  $result\->insert;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Inserts an object previously created by \*(L"new\*(R" into the database if
it isn't already in there. Returns the object itself. To insert an
entirely new row into the database, use \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
To fetch an uninserted result object, call
new_result on a resultset.
.PP
This will also insert any uninserted, related objects held inside this
one, see \*(L"create\*(R" in DBIx::Class::ResultSet for more details.
.SS "in_storage"
.IX Subsection "in_storage"
.Vb 2
\&  $result\->in_storage; # Get value
\&  $result\->in_storage(1); # Set value
.Ve
.IP "Arguments: none or 1|0" 4
.IX Item "Arguments: none or 1|0"
.PD 0
.IP "Return Value: 1|0" 4
.IX Item "Return Value: 1|0"
.PD
.PP
Indicates whether the object exists as a row in the database or
not. This is set to true when \*(L"find\*(R" in DBIx::Class::ResultSet,
\&\*(L"create\*(R" in DBIx::Class::ResultSet or \*(L"insert\*(R" in DBIx::Class::ResultSet
are used.
.PP
Creating a result object using \*(L"new_result\*(R" in DBIx::Class::ResultSet, or
calling \*(L"delete\*(R" on one, sets it to false.
.SS "update"
.IX Subsection "update"
.Vb 1
\&  $result\->update(\e%columns?)
.Ve
.IP "Arguments: none or a hashref" 4
.IX Item "Arguments: none or a hashref"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Throws an exception if the result object is not yet in the database,
according to \*(L"in_storage\*(R". Returns the object itself.
.PP
This method issues an \s-1SQL UPDATE\s0 query to commit any changes to the
object to the database if required (see \*(L"get_dirty_columns\*(R").
It throws an exception if a proper \s-1WHERE\s0 clause uniquely identifying
the database row can not be constructed (see
significance of primary keys
for more details).
.PP
Also takes an optional hashref of \f(CW\*(C`column_name => value\*(C'\fR pairs
to update on the object first. Be aware that the hashref will be
passed to \f(CW\*(C`set_inflated_columns\*(C'\fR, which might edit it in place, so
don't rely on it being the same after a call to \f(CW\*(C`update\*(C'\fR.  If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`update\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
If the values passed or any of the column values set on the object
contain scalar references, e.g.:
.PP
.Vb 3
\&  $result\->last_modified(\e\*(AqNOW()\*(Aq)\->update();
\&  # OR
\&  $result\->update({ last_modified => \e\*(AqNOW()\*(Aq });
.Ve
.PP
The update will pass the values verbatim into \s-1SQL. \s0(See
SQL::Abstract docs).  The values in your Result object will \s-1NOT\s0 change
as a result of the update call, if you want the object to be updated
with the actual values from the database, call \*(L"discard_changes\*(R"
after the update.
.PP
.Vb 1
\&  $result\->update()\->discard_changes();
.Ve
.PP
To determine before calling this method, which column values have
changed and will be updated, call \*(L"get_dirty_columns\*(R".
.PP
To check if any columns will be updated, call \*(L"is_changed\*(R".
.PP
To force a column to be updated, call \*(L"make_column_dirty\*(R" before
this method.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $result\->delete
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Throws an exception if the object is not in the database according to
\&\*(L"in_storage\*(R". Also throws an exception if a proper \s-1WHERE\s0 clause
uniquely identifying the database row can not be constructed (see
significance of primary keys
for more details).
.PP
The object is still perfectly usable, but \*(L"in_storage\*(R" will
now return 0 and the object must be reinserted using \*(L"insert\*(R"
before it can be used to \*(L"update\*(R" the row again.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, an
attempt is made to delete all the related objects as well. To turn
this behaviour off, pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR
hashref of the relationship, see DBIx::Class::Relationship. Any
database-level cascade or restrict will take precedence over a
DBIx-Class-based cascading delete, since DBIx-Class \fBdeletes the
main row first\fR and only then attempts to delete any remaining related
rows.
.PP
If you delete an object within a \fItxn_do()\fR (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
and the transaction subsequently fails, the result object will remain marked as
not being in storage. If you know for a fact that the object is still in
storage (i.e. by inspecting the cause of the transaction's failure), you can
use \f(CW\*(C`$obj\->in_storage(1)\*(C'\fR to restore consistency between the object and
the database. This would allow a subsequent \f(CW\*(C`$obj\->delete\*(C'\fR to work
as expected.
.PP
See also \*(L"delete\*(R" in DBIx::Class::ResultSet.
.SS "get_column"
.IX Subsection "get_column"
.Vb 1
\&  my $val = $result\->get_column($col);
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: The value of the column" 4
.IX Item "Return Value: The value of the column"
.PD
.PP
Throws an exception if the column name given doesn't exist according
to has_column.
.PP
Returns a raw column value from the result object, if it has already
been fetched from the database or set by an accessor.
.PP
If an inflated value has been set, it
will be deflated and returned.
.PP
Note that if you used the \f(CW\*(C`columns\*(C'\fR or the \f(CW\*(C`select/as\*(C'\fR
search attributes on the resultset from
which \f(CW$result\fR was derived, and \fBdid not include\fR \f(CW$columnname\fR in the list,
this method will return \f(CW\*(C`undef\*(C'\fR even if the database contains some value.
.PP
To retrieve all loaded column values as a hash, use \*(L"get_columns\*(R".
.SS "has_column_loaded"
.IX Subsection "has_column_loaded"
.Vb 3
\&  if ( $result\->has_column_loaded($col) ) {
\&     print "$col has been loaded from db";
\&  }
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: 0|1" 4
.IX Item "Return Value: 0|1"
.PD
.PP
Returns a true value if the column value has been loaded from the
database (or set locally).
.SS "get_columns"
.IX Subsection "get_columns"
.Vb 1
\&  my %data = $result\->get_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of columnname, value pairs." 4
.IX Item "Return Value: A hash of columnname, value pairs."
.PD
.PP
Returns all loaded column data as a hash, containing raw values. To
get just one value for a particular column, use \*(L"get_column\*(R".
.PP
See \*(L"get_inflated_columns\*(R" to get the inflated values.
.SS "get_dirty_columns"
.IX Subsection "get_dirty_columns"
.Vb 1
\&  my %data = $result\->get_dirty_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of column, value pairs" 4
.IX Item "Return Value: A hash of column, value pairs"
.PD
.PP
Only returns the column, value pairs for those columns that have been
changed on this object since the last \*(L"update\*(R" or \*(L"insert\*(R" call.
.PP
See \*(L"get_columns\*(R" to fetch all column/value pairs.
.SS "make_column_dirty"
.IX Subsection "make_column_dirty"
.Vb 1
\&  $result\->make_column_dirty($col)
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Throws an exception if the column does not exist.
.PP
Marks a column as having been changed regardless of whether it has
really changed.
.SS "get_inflated_columns"
.IX Subsection "get_inflated_columns"
.Vb 1
\&  my %inflated_data = $obj\->get_inflated_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of column, object|value pairs" 4
.IX Item "Return Value: A hash of column, object|value pairs"
.PD
.PP
Returns a hash of all column keys and associated values. Values for any
columns set to use inflation will be inflated and returns as objects.
.PP
See \*(L"get_columns\*(R" to get the uninflated values.
.PP
See DBIx::Class::InflateColumn for how to setup inflation.
.SS "set_column"
.IX Subsection "set_column"
.Vb 1
\&  $result\->set_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Sets a raw column value. If the new value is different from the old one,
the column is marked as dirty for when you next call \*(L"update\*(R".
.PP
If passed an object or reference as a value, this method will happily
attempt to store it, and a later \*(L"insert\*(R" or \*(L"update\*(R" will try and
stringify/numify as appropriate. To set an object to be deflated
instead, see \*(L"set_inflated_columns\*(R", or better yet, use \*(L"$column_accessor\*(R".
.SS "set_columns"
.IX Subsection "set_columns"
.Vb 1
\&  $result\->set_columns({ $col => $val, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Sets multiple column, raw value pairs at once.
.PP
Works as \*(L"set_column\*(R".
.SS "set_inflated_columns"
.IX Subsection "set_inflated_columns"
.Vb 1
\&  $result\->set_inflated_columns({ $col => $val, $relname => $obj, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Sets more than one column value at once. Any inflated values are
deflated and the raw values stored.
.PP
Any related values passed as Result objects, using the relation name as a
key, are reduced to the appropriate foreign key values and stored. If
instead of related result objects, a hashref of column, value data is
passed, will create the related object first then store.
.PP
Will even accept arrayrefs of data as a value to a
\&\*(L"has_many\*(R" in DBIx::Class::Relationship key, and create the related
objects if necessary.
.PP
Be aware that the input hashref might be edited in place, so don't rely
on it being the same after a call to \f(CW\*(C`set_inflated_columns\*(C'\fR. If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`set_inflated_columns\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
See also \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base.
.SS "copy"
.IX Subsection "copy"
.Vb 1
\&  my $copy = $orig\->copy({ change => $to, ... });
.Ve
.IP "Arguments: \e%replacementdata" 4
.IX Item "Arguments: %replacementdata"
.PD 0
.ie n .IP "Return Value: $result copy" 4
.el .IP "Return Value: \f(CW$result\fR copy" 4
.IX Item "Return Value: $result copy"
.PD
.PP
Inserts a new row into the database, as a copy of the original
object. If a hashref of replacement data is supplied, these will take
precedence over data in the original. Also any columns which have
the column info attribute
\&\f(CW\*(C`is_auto_increment => 1\*(C'\fR are explicitly removed before the copy,
so that the database can insert its own autoincremented values into
the new object.
.PP
Relationships will be followed by the copy procedure \fBonly\fR if the
relationship specifies a true value for its
cascade_copy attribute. \f(CW\*(C`cascade_copy\*(C'\fR
is set by default on \f(CW\*(C`has_many\*(C'\fR relationships and unset on all others.
.SS "store_column"
.IX Subsection "store_column"
.Vb 1
\&  $result\->store_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.IP "Return Value: The value sent to storage" 4
.IX Item "Return Value: The value sent to storage"
.PD
.PP
Set a raw value for a column without marking it as changed. This
method is used internally by \*(L"set_column\*(R" which you should probably
be using.
.PP
This is the lowest level at which data is set on a result object,
extend this method to catch all data setting methods.
.SS "inflate_result"
.IX Subsection "inflate_result"
.Vb 1
\&  Class\->inflate_result($result_source, \e%me, \e%prefetch?)
.Ve
.ie n .IP "Arguments: $result_source, \e%columndata, \e%prefetcheddata" 4
.el .IP "Arguments: \f(CW$result_source\fR, \e%columndata, \e%prefetcheddata" 4
.IX Item "Arguments: $result_source, %columndata, %prefetcheddata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
All DBIx::Class::ResultSet methods that retrieve data from the
database and turn it into result objects call this method.
.PP
Extend this method in your Result classes to hook into this process,
for example to rebless the result into a different class.
.PP
Reblessing can also be done more easily by setting \f(CW\*(C`result_class\*(C'\fR in
your Result class. See \*(L"result_class\*(R" in DBIx::Class::ResultSource.
.PP
Different types of results can also be created from a particular
DBIx::Class::ResultSet, see \*(L"result_class\*(R" in DBIx::Class::ResultSet.
.SS "update_or_insert"
.IX Subsection "update_or_insert"
.Vb 1
\&  $result\->update_or_insert
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Result of update or insert operation" 4
.IX Item "Return Value: Result of update or insert operation"
.PD
.PP
\&\*(L"Update\*(R"s the object if it's already in the database, according to
\&\*(L"in_storage\*(R", else \*(L"insert\*(R"s it.
.SS "insert_or_update"
.IX Subsection "insert_or_update"
.Vb 1
\&  $obj\->insert_or_update
.Ve
.PP
Alias for \*(L"update_or_insert\*(R"
.SS "is_changed"
.IX Subsection "is_changed"
.Vb 2
\&  my @changed_col_names = $result\->is_changed();
\&  if ($result\->is_changed()) { ... }
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: 0|1 or @columnnames" 4
.el .IP "Return Value: 0|1 or \f(CW@columnnames\fR" 4
.IX Item "Return Value: 0|1 or @columnnames"
.PD
.PP
In list context returns a list of columns with uncommited changes, or
in scalar context returns a true value if there are uncommitted
changes.
.SS "is_column_changed"
.IX Subsection "is_column_changed"
.Vb 1
\&  if ($result\->is_column_changed(\*(Aqcol\*(Aq)) { ... }
.Ve
.ie n .IP "Arguments: $columname" 4
.el .IP "Arguments: \f(CW$columname\fR" 4
.IX Item "Arguments: $columname"
.PD 0
.IP "Return Value: 0|1" 4
.IX Item "Return Value: 0|1"
.PD
.PP
Returns a true value if the column has uncommitted changes.
.SS "result_source"
.IX Subsection "result_source"
.Vb 1
\&  my $resultsource = $result\->result_source;
.Ve
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
Accessor to the DBIx::Class::ResultSource this object was created from.
.SS "register_column"
.IX Subsection "register_column"
.Vb 2
\&  $column_info = { .... };
\&  $class\->register_column($column_name, $column_info);
.Ve
.ie n .IP "Arguments: $columnname, \e%columninfo" 4
.el .IP "Arguments: \f(CW$columnname\fR, \e%columninfo" 4
.IX Item "Arguments: $columnname, %columninfo"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Registers a column on the class. If the column_info has an 'accessor'
key, creates an accessor named after the value if defined; if there is
no such key, creates an accessor with the same name as the column
.PP
The column_info attributes are described in
\&\*(L"add_columns\*(R" in DBIx::Class::ResultSource
.SS "get_from_storage"
.IX Subsection "get_from_storage"
.Vb 1
\&  my $copy = $result\->get_from_storage($attrs)
.Ve
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Return Value: A Result object" 4
.IX Item "Return Value: A Result object"
.PD
.PP
Fetches a fresh copy of the Result object from the database and returns it.
Throws an exception if a proper \s-1WHERE\s0 clause identifying the database row
can not be constructed (i.e. if the original object does not contain its
entire
 primary key
). If passed the \e%attrs argument, will first apply these attributes to
the resultset used to find the row.
.PP
This copy can then be used to compare to an existing result object, to
determine if any changes have been made in the database since it was
created.
.PP
To just update your Result object with any latest changes from the
database, use \*(L"discard_changes\*(R" instead.
.PP
The \e%attrs argument should be compatible with
\&\*(L"\s-1ATTRIBUTES\*(R"\s0 in DBIx::Class::ResultSet.
.SS "discard_changes"
.IX Subsection "discard_changes"
.Vb 1
\&  $result\->discard_changes
.Ve
.ie n .IP "Arguments: none or $attrs" 4
.el .IP "Arguments: none or \f(CW$attrs\fR" 4
.IX Item "Arguments: none or $attrs"
.PD 0
.IP "Return Value: self (updates object in-place)" 4
.IX Item "Return Value: self (updates object in-place)"
.PD
.PP
Re-selects the row from the database, losing any changes that had
been made. Throws an exception if a proper \f(CW\*(C`WHERE\*(C'\fR clause identifying
the database row can not be constructed (i.e. if the original object
does not contain its entire
primary key).
.PP
This method can also be used to refresh from storage, retrieving any
changes made since the row was last read from storage.
.PP
\&\f(CW$attrs\fR, if supplied, is expected to be a hashref of attributes suitable for passing as the
second argument to \f(CW\*(C`$resultset\->search($cond, $attrs)\*(C'\fR;
.PP
Note: If you are using DBIx::Class::Storage::DBI::Replicated as your
storage, please kept in mind that if you \*(L"discard_changes\*(R" on a row that you
just updated or created, you should wrap the entire bit inside a transaction.
Otherwise you run the risk that you insert or update to the master database
but read from a replicant database that has not yet been updated from the
master.  This will result in unexpected results.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "id"
.IX Subsection "id"
.Vb 1
\&  my @pk = $result\->id;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A list of primary key values" 4
.IX Item "Returns: A list of primary key values"
.PD
.PP
Returns the primary key(s) for a row. Can't be called as a class method.
Actually implemented in DBIx::Class::PK
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Row5.16.3pm                     0100644 0001750 0001750 00000061170 12566242362 024434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Row 3"
.TH DBIx::Class::Row 3 "2012-10-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Row \- Basic row methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is responsible for defining and doing basic operations on rows
derived from DBIx::Class::ResultSource objects.
.PP
Row objects are returned from DBIx::Class::ResultSets using the
create, find,
next and all methods,
as well as invocations of 'single' (
belongs_to,
has_one or
might_have)
relationship accessors of DBIx::Class::Row objects.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $row = My::Class\->new(\e%attrs);
\&
\&  my $row = $schema\->resultset(\*(AqMySource\*(Aq)\->new(\e%colsandvalues);
.Ve
.IP "Arguments: \e%attrs or \e%colsandvalues" 4
.IX Item "Arguments: %attrs or %colsandvalues"
.PD 0
.IP "Returns: A Row object" 4
.IX Item "Returns: A Row object"
.PD
.PP
While you can create a new row object by calling \f(CW\*(C`new\*(C'\fR directly on
this class, you are better off calling it on a
DBIx::Class::ResultSet object.
.PP
When calling it directly, you will not get a complete, usable row
object until you pass or set the \f(CW\*(C`result_source\*(C'\fR attribute, to a
DBIx::Class::ResultSource instance that is attached to a
DBIx::Class::Schema with a valid connection.
.PP
\&\f(CW$attrs\fR is a hashref of column name, value data. It can also contain
some other attributes such as the \f(CW\*(C`result_source\*(C'\fR.
.PP
Passing an object, or an arrayref of objects as a value will call
\&\*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base for you. When
passed a hashref or an arrayref of hashrefs as the value, these will
be turned into objects via new_related, and treated as if you had
passed objects.
.PP
For a more involved explanation, see \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
Please note that if a value is not passed to new, no value will be sent
in the \s-1SQL\s0 \s-1INSERT\s0 call, and the column will therefore assume whatever
default value was specified in your database. While \s-1DBIC\s0 will retrieve the
value of autoincrement columns, it will never make an explicit database
trip to retrieve default values assigned by the \s-1RDBMS\s0. You can explicitly
request that all values be fetched back from the database by calling
\&\*(L"discard_changes\*(R", or you can supply an explicit \f(CW\*(C`undef\*(C'\fR to columns
with \s-1NULL\s0 as the default, and save yourself a \s-1SELECT\s0.
.PP
.Vb 1
\& CAVEAT:
\&
\& The behavior described above will backfire if you use a foreign key column
\& with a database\-defined default. If you call the relationship accessor on
\& an object that doesn\*(Aqt have a set value for the FK column, DBIC will throw
\& an exception, as it has no way of knowing the PK of the related object (if
\& there is one).
.Ve
.SS "insert"
.IX Subsection "insert"
.Vb 1
\&  $row\->insert;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: The Row object" 4
.IX Item "Returns: The Row object"
.PD
.PP
Inserts an object previously created by \*(L"new\*(R" into the database if
it isn't already in there. Returns the object itself. To insert an
entirely new row into the database, use \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
To fetch an uninserted row object, call
new on a resultset.
.PP
This will also insert any uninserted, related objects held inside this
one, see \*(L"create\*(R" in DBIx::Class::ResultSet for more details.
.SS "in_storage"
.IX Subsection "in_storage"
.Vb 2
\&  $row\->in_storage; # Get value
\&  $row\->in_storage(1); # Set value
.Ve
.IP "Arguments: none or 1|0" 4
.IX Item "Arguments: none or 1|0"
.PD 0
.IP "Returns: 1|0" 4
.IX Item "Returns: 1|0"
.PD
.PP
Indicates whether the object exists as a row in the database or
not. This is set to true when \*(L"find\*(R" in DBIx::Class::ResultSet,
\&\*(L"create\*(R" in DBIx::Class::ResultSet or \*(L"insert\*(R" in DBIx::Class::ResultSet
are used.
.PP
Creating a row object using \*(L"new\*(R" in DBIx::Class::ResultSet, or calling
\&\*(L"delete\*(R" on one, sets it to false.
.SS "update"
.IX Subsection "update"
.Vb 1
\&  $row\->update(\e%columns?)
.Ve
.IP "Arguments: none or a hashref" 4
.IX Item "Arguments: none or a hashref"
.PD 0
.IP "Returns: The Row object" 4
.IX Item "Returns: The Row object"
.PD
.PP
Throws an exception if the row object is not yet in the database,
according to \*(L"in_storage\*(R".
.PP
This method issues an \s-1SQL\s0 \s-1UPDATE\s0 query to commit any changes to the
object to the database if required (see \*(L"get_dirty_columns\*(R").
It throws an exception if a proper \s-1WHERE\s0 clause uniquely identifying
the database row can not be constructed (see
significance of primary keys
for more details).
.PP
Also takes an optional hashref of \f(CW\*(C`column_name => value\*(C'\fR pairs
to update on the object first. Be aware that the hashref will be
passed to \f(CW\*(C`set_inflated_columns\*(C'\fR, which might edit it in place, so
don't rely on it being the same after a call to \f(CW\*(C`update\*(C'\fR.  If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`update\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
If the values passed or any of the column values set on the object
contain scalar references, e.g.:
.PP
.Vb 3
\&  $row\->last_modified(\e\*(AqNOW()\*(Aq)\->update();
\&  # OR
\&  $row\->update({ last_modified => \e\*(AqNOW()\*(Aq });
.Ve
.PP
The update will pass the values verbatim into \s-1SQL\s0. (See
SQL::Abstract docs).  The values in your Row object will \s-1NOT\s0 change
as a result of the update call, if you want the object to be updated
with the actual values from the database, call \*(L"discard_changes\*(R"
after the update.
.PP
.Vb 1
\&  $row\->update()\->discard_changes();
.Ve
.PP
To determine before calling this method, which column values have
changed and will be updated, call \*(L"get_dirty_columns\*(R".
.PP
To check if any columns will be updated, call \*(L"is_changed\*(R".
.PP
To force a column to be updated, call \*(L"make_column_dirty\*(R" before
this method.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $row\->delete
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: The Row object" 4
.IX Item "Returns: The Row object"
.PD
.PP
Throws an exception if the object is not in the database according to
\&\*(L"in_storage\*(R". Also throws an exception if a proper \s-1WHERE\s0 clause
uniquely identifying the database row can not be constructed (see
significance of primary keys
for more details).
.PP
The object is still perfectly usable, but \*(L"in_storage\*(R" will
now return 0 and the object must be reinserted using \*(L"insert\*(R"
before it can be used to \*(L"update\*(R" the row again.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, an
attempt is made to delete all the related objects as well. To turn
this behaviour off, pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR
hashref of the relationship, see DBIx::Class::Relationship. Any
database-level cascade or restrict will take precedence over a
DBIx-Class-based cascading delete, since DBIx-Class \fBdeletes the
main row first\fR and only then attempts to delete any remaining related
rows.
.PP
If you delete an object within a \fItxn_do()\fR (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
and the transaction subsequently fails, the row object will remain marked as
not being in storage. If you know for a fact that the object is still in
storage (i.e. by inspecting the cause of the transaction's failure), you can
use \f(CW\*(C`$obj\->in_storage(1)\*(C'\fR to restore consistency between the object and
the database. This would allow a subsequent \f(CW\*(C`$obj\->delete\*(C'\fR to work
as expected.
.PP
See also \*(L"delete\*(R" in DBIx::Class::ResultSet.
.SS "get_column"
.IX Subsection "get_column"
.Vb 1
\&  my $val = $row\->get_column($col);
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Returns: The value of the column" 4
.IX Item "Returns: The value of the column"
.PD
.PP
Throws an exception if the column name given doesn't exist according
to has_column.
.PP
Returns a raw column value from the row object, if it has already
been fetched from the database or set by an accessor.
.PP
If an inflated value has been set, it
will be deflated and returned.
.PP
Note that if you used the \f(CW\*(C`columns\*(C'\fR or the \f(CW\*(C`select/as\*(C'\fR
search attributes on the resultset from
which \f(CW$row\fR was derived, and \fBdid not include\fR \f(CW$columnname\fR in the list,
this method will return \f(CW\*(C`undef\*(C'\fR even if the database contains some value.
.PP
To retrieve all loaded column values as a hash, use \*(L"get_columns\*(R".
.SS "has_column_loaded"
.IX Subsection "has_column_loaded"
.Vb 3
\&  if ( $row\->has_column_loaded($col) ) {
\&     print "$col has been loaded from db";
\&  }
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Returns: 0|1" 4
.IX Item "Returns: 0|1"
.PD
.PP
Returns a true value if the column value has been loaded from the
database (or set locally).
.SS "get_columns"
.IX Subsection "get_columns"
.Vb 1
\&  my %data = $row\->get_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A hash of columnname, value pairs." 4
.IX Item "Returns: A hash of columnname, value pairs."
.PD
.PP
Returns all loaded column data as a hash, containing raw values. To
get just one value for a particular column, use \*(L"get_column\*(R".
.PP
See \*(L"get_inflated_columns\*(R" to get the inflated values.
.SS "get_dirty_columns"
.IX Subsection "get_dirty_columns"
.Vb 1
\&  my %data = $row\->get_dirty_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A hash of column, value pairs" 4
.IX Item "Returns: A hash of column, value pairs"
.PD
.PP
Only returns the column, value pairs for those columns that have been
changed on this object since the last \*(L"update\*(R" or \*(L"insert\*(R" call.
.PP
See \*(L"get_columns\*(R" to fetch all column/value pairs.
.SS "make_column_dirty"
.IX Subsection "make_column_dirty"
.Vb 1
\&  $row\->make_column_dirty($col)
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Returns: undefined" 4
.IX Item "Returns: undefined"
.PD
.PP
Throws an exception if the column does not exist.
.PP
Marks a column as having been changed regardless of whether it has
really changed.
.SS "get_inflated_columns"
.IX Subsection "get_inflated_columns"
.Vb 1
\&  my %inflated_data = $obj\->get_inflated_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A hash of column, object|value pairs" 4
.IX Item "Returns: A hash of column, object|value pairs"
.PD
.PP
Returns a hash of all column keys and associated values. Values for any
columns set to use inflation will be inflated and returns as objects.
.PP
See \*(L"get_columns\*(R" to get the uninflated values.
.PP
See DBIx::Class::InflateColumn for how to setup inflation.
.SS "set_column"
.IX Subsection "set_column"
.Vb 1
\&  $row\->set_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.ie n .IP "Returns: $value" 4
.el .IP "Returns: \f(CW$value\fR" 4
.IX Item "Returns: $value"
.PD
.PP
Sets a raw column value. If the new value is different from the old one,
the column is marked as dirty for when you next call \*(L"update\*(R".
.PP
If passed an object or reference as a value, this method will happily
attempt to store it, and a later \*(L"insert\*(R" or \*(L"update\*(R" will try and
stringify/numify as appropriate. To set an object to be deflated
instead, see \*(L"set_inflated_columns\*(R".
.SS "set_columns"
.IX Subsection "set_columns"
.Vb 1
\&  $row\->set_columns({ $col => $val, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.IP "Returns: The Row object" 4
.IX Item "Returns: The Row object"
.PD
.PP
Sets multiple column, raw value pairs at once.
.PP
Works as \*(L"set_column\*(R".
.SS "set_inflated_columns"
.IX Subsection "set_inflated_columns"
.Vb 1
\&  $row\->set_inflated_columns({ $col => $val, $relname => $obj, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.IP "Returns: The Row object" 4
.IX Item "Returns: The Row object"
.PD
.PP
Sets more than one column value at once. Any inflated values are
deflated and the raw values stored.
.PP
Any related values passed as Row objects, using the relation name as a
key, are reduced to the appropriate foreign key values and stored. If
instead of related row objects, a hashref of column, value data is
passed, will create the related object first then store.
.PP
Will even accept arrayrefs of data as a value to a
\&\*(L"has_many\*(R" in DBIx::Class::Relationship key, and create the related
objects if necessary.
.PP
Be aware that the input hashref might be edited in place, so don't rely
on it being the same after a call to \f(CW\*(C`set_inflated_columns\*(C'\fR. If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`set_inflated_columns\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
See also \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base.
.SS "copy"
.IX Subsection "copy"
.Vb 1
\&  my $copy = $orig\->copy({ change => $to, ... });
.Ve
.IP "Arguments: \e%replacementdata" 4
.IX Item "Arguments: %replacementdata"
.PD 0
.IP "Returns: The Row object copy" 4
.IX Item "Returns: The Row object copy"
.PD
.PP
Inserts a new row into the database, as a copy of the original
object. If a hashref of replacement data is supplied, these will take
precedence over data in the original. Also any columns which have
the column info attribute
\&\f(CW\*(C`is_auto_increment => 1\*(C'\fR are explicitly removed before the copy,
so that the database can insert its own autoincremented values into
the new object.
.PP
Relationships will be followed by the copy procedure \fBonly\fR if the
relationship specifies a true value for its
cascade_copy attribute. \f(CW\*(C`cascade_copy\*(C'\fR
is set by default on \f(CW\*(C`has_many\*(C'\fR relationships and unset on all others.
.SS "store_column"
.IX Subsection "store_column"
.Vb 1
\&  $row\->store_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.IP "Returns: The value sent to storage" 4
.IX Item "Returns: The value sent to storage"
.PD
.PP
Set a raw value for a column without marking it as changed. This
method is used internally by \*(L"set_column\*(R" which you should probably
be using.
.PP
This is the lowest level at which data is set on a row object,
extend this method to catch all data setting methods.
.SS "inflate_result"
.IX Subsection "inflate_result"
.Vb 1
\&  Class\->inflate_result($result_source, \e%me, \e%prefetch?)
.Ve
.ie n .IP "Arguments: $result_source, \e%columndata, \e%prefetcheddata" 4
.el .IP "Arguments: \f(CW$result_source\fR, \e%columndata, \e%prefetcheddata" 4
.IX Item "Arguments: $result_source, %columndata, %prefetcheddata"
.PD 0
.IP "Returns: A Row object" 4
.IX Item "Returns: A Row object"
.PD
.PP
All DBIx::Class::ResultSet methods that retrieve data from the
database and turn it into row objects call this method.
.PP
Extend this method in your Result classes to hook into this process,
for example to rebless the result into a different class.
.PP
Reblessing can also be done more easily by setting \f(CW\*(C`result_class\*(C'\fR in
your Result class. See \*(L"result_class\*(R" in DBIx::Class::ResultSource.
.PP
Different types of results can also be created from a particular
DBIx::Class::ResultSet, see \*(L"result_class\*(R" in DBIx::Class::ResultSet.
.SS "update_or_insert"
.IX Subsection "update_or_insert"
.Vb 1
\&  $row\->update_or_insert
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: Result of update or insert operation" 4
.IX Item "Returns: Result of update or insert operation"
.PD
.PP
\&\*(L"Update\*(R"s the object if it's already in the database, according to
\&\*(L"in_storage\*(R", else \*(L"insert\*(R"s it.
.SS "insert_or_update"
.IX Subsection "insert_or_update"
.Vb 1
\&  $obj\->insert_or_update
.Ve
.PP
Alias for \*(L"update_or_insert\*(R"
.SS "is_changed"
.IX Subsection "is_changed"
.Vb 2
\&  my @changed_col_names = $row\->is_changed();
\&  if ($row\->is_changed()) { ... }
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Returns: 0|1 or @columnnames" 4
.el .IP "Returns: 0|1 or \f(CW@columnnames\fR" 4
.IX Item "Returns: 0|1 or @columnnames"
.PD
.PP
In list context returns a list of columns with uncommited changes, or
in scalar context returns a true value if there are uncommitted
changes.
.SS "is_column_changed"
.IX Subsection "is_column_changed"
.Vb 1
\&  if ($row\->is_column_changed(\*(Aqcol\*(Aq)) { ... }
.Ve
.ie n .IP "Arguments: $columname" 4
.el .IP "Arguments: \f(CW$columname\fR" 4
.IX Item "Arguments: $columname"
.PD 0
.IP "Returns: 0|1" 4
.IX Item "Returns: 0|1"
.PD
.PP
Returns a true value if the column has uncommitted changes.
.SS "result_source"
.IX Subsection "result_source"
.Vb 1
\&  my $resultsource = $row\->result_source;
.Ve
.ie n .IP "Arguments: $result_source_instance" 4
.el .IP "Arguments: \f(CW$result_source_instance\fR" 4
.IX Item "Arguments: $result_source_instance"
.PD 0
.IP "Returns: a ResultSource instance" 4
.IX Item "Returns: a ResultSource instance"
.PD
.PP
Accessor to the DBIx::Class::ResultSource this object was created from.
.SS "register_column"
.IX Subsection "register_column"
.Vb 2
\&  $column_info = { .... };
\&  $class\->register_column($column_name, $column_info);
.Ve
.ie n .IP "Arguments: $columnname, \e%columninfo" 4
.el .IP "Arguments: \f(CW$columnname\fR, \e%columninfo" 4
.IX Item "Arguments: $columnname, %columninfo"
.PD 0
.IP "Returns: undefined" 4
.IX Item "Returns: undefined"
.PD
.PP
Registers a column on the class. If the column_info has an 'accessor'
key, creates an accessor named after the value if defined; if there is
no such key, creates an accessor with the same name as the column
.PP
The column_info attributes are described in
\&\*(L"add_columns\*(R" in DBIx::Class::ResultSource
.SS "get_from_storage"
.IX Subsection "get_from_storage"
.Vb 1
\&  my $copy = $row\->get_from_storage($attrs)
.Ve
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Returns: A Row object" 4
.IX Item "Returns: A Row object"
.PD
.PP
Fetches a fresh copy of the Row object from the database and returns it.
Throws an exception if a proper \s-1WHERE\s0 clause identifying the database row
can not be constructed (i.e. if the original object does not contain its
entire
 primary key
). If passed the \e%attrs argument, will first apply these attributes to
the resultset used to find the row.
.PP
This copy can then be used to compare to an existing row object, to
determine if any changes have been made in the database since it was
created.
.PP
To just update your Row object with any latest changes from the
database, use \*(L"discard_changes\*(R" instead.
.PP
The \e%attrs argument should be compatible with
\&\*(L"\s-1ATTRIBUTES\s0\*(R" in DBIx::Class::ResultSet.
.SS "discard_changes ($attrs?)"
.IX Subsection "discard_changes ($attrs?)"
.Vb 1
\&  $row\->discard_changes
.Ve
.ie n .IP "Arguments: none or $attrs" 4
.el .IP "Arguments: none or \f(CW$attrs\fR" 4
.IX Item "Arguments: none or $attrs"
.PD 0
.IP "Returns: self (updates object in-place)" 4
.IX Item "Returns: self (updates object in-place)"
.PD
.PP
Re-selects the row from the database, losing any changes that had
been made. Throws an exception if a proper \f(CW\*(C`WHERE\*(C'\fR clause identifying
the database row can not be constructed (i.e. if the original object
does not contain its entire
primary key).
.PP
This method can also be used to refresh from storage, retrieving any
changes made since the row was last read from storage.
.PP
\&\f(CW$attrs\fR, if supplied, is expected to be a hashref of attributes suitable for passing as the
second argument to \f(CW\*(C`$resultset\->search($cond, $attrs)\*(C'\fR;
.PP
Note: If you are using DBIx::Class::Storage::DBI::Replicated as your
storage, please kept in mind that if you \*(L"discard_changes\*(R" on a row that you
just updated or created, you should wrap the entire bit inside a transaction.
Otherwise you run the risk that you insert or update to the master database
but read from a replicant database that has not yet been updated from the
master.  This will result in unexpected results.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "id"
.IX Subsection "id"
.Vb 1
\&  my @pk = $row\->id;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A list of primary key values" 4
.IX Item "Returns: A list of primary key values"
.PD
.PP
Returns the primary key(s) for a row. Can't be called as a class method.
Actually implemented in DBIx::Class::PK
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Row5.18.3pm                     0100644 0001750 0001750 00000067133 12566242400 024434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Row 3"
.TH DBIx::Class::Row 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Row \- Basic row methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is responsible for defining and doing basic operations on rows
derived from DBIx::Class::ResultSource objects.
.PP
Result objects are returned from DBIx::Class::ResultSets using the
create, find,
next and all methods,
as well as invocations of 'single' (
belongs_to,
has_one or
might_have)
relationship accessors of Result objects.
.SH "NOTE"
.IX Header "NOTE"
All \*(L"Row objects\*(R" derived from a Schema-attached DBIx::Class::ResultSet
object (such as a typical \f(CW\*(C`search\->
next\*(C'\fR call) are actually Result
instances, based on your application's
Result class.
.PP
DBIx::Class::Row implements most of the row-based communication with the
underlying storage, but a Result class \fBshould not inherit from it directly\fR.
Usually, Result classes inherit from DBIx::Class::Core, which in turn
combines the methods from several classes, one of them being
DBIx::Class::Row.  Therefore, while many of the methods available to a
DBIx::Class::Core\-derived Result class are described in the following
documentation, it does not detail all of the methods available to Result
objects.  Refer to DBIx::Class::Manual::ResultClass for more info.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $result = My::Class\->new(\e%attrs);
\&
\&  my $result = $schema\->resultset(\*(AqMySource\*(Aq)\->new(\e%colsandvalues);
.Ve
.IP "Arguments: \e%attrs or \e%colsandvalues" 4
.IX Item "Arguments: %attrs or %colsandvalues"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
While you can create a new result object by calling \f(CW\*(C`new\*(C'\fR directly on
this class, you are better off calling it on a
DBIx::Class::ResultSet object.
.PP
When calling it directly, you will not get a complete, usable row
object until you pass or set the \f(CW\*(C`result_source\*(C'\fR attribute, to a
DBIx::Class::ResultSource instance that is attached to a
DBIx::Class::Schema with a valid connection.
.PP
\&\f(CW$attrs\fR is a hashref of column name, value data. It can also contain
some other attributes such as the \f(CW\*(C`result_source\*(C'\fR.
.PP
Passing an object, or an arrayref of objects as a value will call
\&\*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base for you. When
passed a hashref or an arrayref of hashrefs as the value, these will
be turned into objects via new_related, and treated as if you had
passed objects.
.PP
For a more involved explanation, see \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
Please note that if a value is not passed to new, no value will be sent
in the \s-1SQL INSERT\s0 call, and the column will therefore assume whatever
default value was specified in your database. While \s-1DBIC\s0 will retrieve the
value of autoincrement columns, it will never make an explicit database
trip to retrieve default values assigned by the \s-1RDBMS.\s0 You can explicitly
request that all values be fetched back from the database by calling
\&\*(L"discard_changes\*(R", or you can supply an explicit \f(CW\*(C`undef\*(C'\fR to columns
with \s-1NULL\s0 as the default, and save yourself a \s-1SELECT.\s0
.PP
.Vb 1
\& CAVEAT:
\&
\& The behavior described above will backfire if you use a foreign key column
\& with a database\-defined default. If you call the relationship accessor on
\& an object that doesn\*(Aqt have a set value for the FK column, DBIC will throw
\& an exception, as it has no way of knowing the PK of the related object (if
\& there is one).
.Ve
.ie n .SS "$column_accessor"
.el .SS "\f(CW$column_accessor\fP"
.IX Subsection "$column_accessor"
.Vb 1
\&  # Each pair does the same thing
\&
\&  # (un\-inflated, regular column)
\&  my $val = $result\->get_column(\*(Aqfirst_name\*(Aq);
\&  my $val = $result\->first_name;
\&
\&  $result\->set_column(\*(Aqfirst_name\*(Aq => $val);
\&  $result\->first_name($val);
\&
\&  # (inflated column via DBIx::Class::InflateColumn::DateTime)
\&  my $val = $result\->get_inflated_column(\*(Aqlast_modified\*(Aq);
\&  my $val = $result\->last_modified;
\&
\&  $result\->set_inflated_column(\*(Aqlast_modified\*(Aq => $val);
\&  $result\->last_modified($val);
.Ve
.ie n .IP "Arguments: $value?" 4
.el .IP "Arguments: \f(CW$value\fR?" 4
.IX Item "Arguments: $value?"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
A column accessor method is created for each column, which is used for
getting/setting the value for that column.
.PP
The actual method name is based on the
accessor name given during the
Result Class column definition
\&. Like \*(L"set_column\*(R", this
will not store the data in the database until \*(L"insert\*(R" or \*(L"update\*(R"
is called on the row.
.SS "insert"
.IX Subsection "insert"
.Vb 1
\&  $result\->insert;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Inserts an object previously created by \*(L"new\*(R" into the database if
it isn't already in there. Returns the object itself. To insert an
entirely new row into the database, use \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
To fetch an uninserted result object, call
new_result on a resultset.
.PP
This will also insert any uninserted, related objects held inside this
one, see \*(L"create\*(R" in DBIx::Class::ResultSet for more details.
.SS "in_storage"
.IX Subsection "in_storage"
.Vb 2
\&  $result\->in_storage; # Get value
\&  $result\->in_storage(1); # Set value
.Ve
.IP "Arguments: none or 1|0" 4
.IX Item "Arguments: none or 1|0"
.PD 0
.IP "Return Value: 1|0" 4
.IX Item "Return Value: 1|0"
.PD
.PP
Indicates whether the object exists as a row in the database or
not. This is set to true when \*(L"find\*(R" in DBIx::Class::ResultSet,
\&\*(L"create\*(R" in DBIx::Class::ResultSet or \*(L"insert\*(R" in DBIx::Class::ResultSet
are used.
.PP
Creating a result object using \*(L"new_result\*(R" in DBIx::Class::ResultSet, or
calling \*(L"delete\*(R" on one, sets it to false.
.SS "update"
.IX Subsection "update"
.Vb 1
\&  $result\->update(\e%columns?)
.Ve
.IP "Arguments: none or a hashref" 4
.IX Item "Arguments: none or a hashref"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Throws an exception if the result object is not yet in the database,
according to \*(L"in_storage\*(R". Returns the object itself.
.PP
This method issues an \s-1SQL UPDATE\s0 query to commit any changes to the
object to the database if required (see \*(L"get_dirty_columns\*(R").
It throws an exception if a proper \s-1WHERE\s0 clause uniquely identifying
the database row can not be constructed (see
significance of primary keys
for more details).
.PP
Also takes an optional hashref of \f(CW\*(C`column_name => value\*(C'\fR pairs
to update on the object first. Be aware that the hashref will be
passed to \f(CW\*(C`set_inflated_columns\*(C'\fR, which might edit it in place, so
don't rely on it being the same after a call to \f(CW\*(C`update\*(C'\fR.  If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`update\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
If the values passed or any of the column values set on the object
contain scalar references, e.g.:
.PP
.Vb 3
\&  $result\->last_modified(\e\*(AqNOW()\*(Aq)\->update();
\&  # OR
\&  $result\->update({ last_modified => \e\*(AqNOW()\*(Aq });
.Ve
.PP
The update will pass the values verbatim into \s-1SQL. \s0(See
SQL::Abstract docs).  The values in your Result object will \s-1NOT\s0 change
as a result of the update call, if you want the object to be updated
with the actual values from the database, call \*(L"discard_changes\*(R"
after the update.
.PP
.Vb 1
\&  $result\->update()\->discard_changes();
.Ve
.PP
To determine before calling this method, which column values have
changed and will be updated, call \*(L"get_dirty_columns\*(R".
.PP
To check if any columns will be updated, call \*(L"is_changed\*(R".
.PP
To force a column to be updated, call \*(L"make_column_dirty\*(R" before
this method.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $result\->delete
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Throws an exception if the object is not in the database according to
\&\*(L"in_storage\*(R". Also throws an exception if a proper \s-1WHERE\s0 clause
uniquely identifying the database row can not be constructed (see
significance of primary keys
for more details).
.PP
The object is still perfectly usable, but \*(L"in_storage\*(R" will
now return 0 and the object must be reinserted using \*(L"insert\*(R"
before it can be used to \*(L"update\*(R" the row again.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, an
attempt is made to delete all the related objects as well. To turn
this behaviour off, pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR
hashref of the relationship, see DBIx::Class::Relationship. Any
database-level cascade or restrict will take precedence over a
DBIx-Class-based cascading delete, since DBIx-Class \fBdeletes the
main row first\fR and only then attempts to delete any remaining related
rows.
.PP
If you delete an object within a \fItxn_do()\fR (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
and the transaction subsequently fails, the result object will remain marked as
not being in storage. If you know for a fact that the object is still in
storage (i.e. by inspecting the cause of the transaction's failure), you can
use \f(CW\*(C`$obj\->in_storage(1)\*(C'\fR to restore consistency between the object and
the database. This would allow a subsequent \f(CW\*(C`$obj\->delete\*(C'\fR to work
as expected.
.PP
See also \*(L"delete\*(R" in DBIx::Class::ResultSet.
.SS "get_column"
.IX Subsection "get_column"
.Vb 1
\&  my $val = $result\->get_column($col);
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: The value of the column" 4
.IX Item "Return Value: The value of the column"
.PD
.PP
Throws an exception if the column name given doesn't exist according
to has_column.
.PP
Returns a raw column value from the result object, if it has already
been fetched from the database or set by an accessor.
.PP
If an inflated value has been set, it
will be deflated and returned.
.PP
Note that if you used the \f(CW\*(C`columns\*(C'\fR or the \f(CW\*(C`select/as\*(C'\fR
search attributes on the resultset from
which \f(CW$result\fR was derived, and \fBdid not include\fR \f(CW$columnname\fR in the list,
this method will return \f(CW\*(C`undef\*(C'\fR even if the database contains some value.
.PP
To retrieve all loaded column values as a hash, use \*(L"get_columns\*(R".
.SS "has_column_loaded"
.IX Subsection "has_column_loaded"
.Vb 3
\&  if ( $result\->has_column_loaded($col) ) {
\&     print "$col has been loaded from db";
\&  }
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: 0|1" 4
.IX Item "Return Value: 0|1"
.PD
.PP
Returns a true value if the column value has been loaded from the
database (or set locally).
.SS "get_columns"
.IX Subsection "get_columns"
.Vb 1
\&  my %data = $result\->get_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of columnname, value pairs." 4
.IX Item "Return Value: A hash of columnname, value pairs."
.PD
.PP
Returns all loaded column data as a hash, containing raw values. To
get just one value for a particular column, use \*(L"get_column\*(R".
.PP
See \*(L"get_inflated_columns\*(R" to get the inflated values.
.SS "get_dirty_columns"
.IX Subsection "get_dirty_columns"
.Vb 1
\&  my %data = $result\->get_dirty_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of column, value pairs" 4
.IX Item "Return Value: A hash of column, value pairs"
.PD
.PP
Only returns the column, value pairs for those columns that have been
changed on this object since the last \*(L"update\*(R" or \*(L"insert\*(R" call.
.PP
See \*(L"get_columns\*(R" to fetch all column/value pairs.
.SS "make_column_dirty"
.IX Subsection "make_column_dirty"
.Vb 1
\&  $result\->make_column_dirty($col)
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Throws an exception if the column does not exist.
.PP
Marks a column as having been changed regardless of whether it has
really changed.
.SS "get_inflated_columns"
.IX Subsection "get_inflated_columns"
.Vb 1
\&  my %inflated_data = $obj\->get_inflated_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of column, object|value pairs" 4
.IX Item "Return Value: A hash of column, object|value pairs"
.PD
.PP
Returns a hash of all column keys and associated values. Values for any
columns set to use inflation will be inflated and returns as objects.
.PP
See \*(L"get_columns\*(R" to get the uninflated values.
.PP
See DBIx::Class::InflateColumn for how to setup inflation.
.SS "set_column"
.IX Subsection "set_column"
.Vb 1
\&  $result\->set_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Sets a raw column value. If the new value is different from the old one,
the column is marked as dirty for when you next call \*(L"update\*(R".
.PP
If passed an object or reference as a value, this method will happily
attempt to store it, and a later \*(L"insert\*(R" or \*(L"update\*(R" will try and
stringify/numify as appropriate. To set an object to be deflated
instead, see \*(L"set_inflated_columns\*(R", or better yet, use \*(L"$column_accessor\*(R".
.SS "set_columns"
.IX Subsection "set_columns"
.Vb 1
\&  $result\->set_columns({ $col => $val, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Sets multiple column, raw value pairs at once.
.PP
Works as \*(L"set_column\*(R".
.SS "set_inflated_columns"
.IX Subsection "set_inflated_columns"
.Vb 1
\&  $result\->set_inflated_columns({ $col => $val, $relname => $obj, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Sets more than one column value at once. Any inflated values are
deflated and the raw values stored.
.PP
Any related values passed as Result objects, using the relation name as a
key, are reduced to the appropriate foreign key values and stored. If
instead of related result objects, a hashref of column, value data is
passed, will create the related object first then store.
.PP
Will even accept arrayrefs of data as a value to a
\&\*(L"has_many\*(R" in DBIx::Class::Relationship key, and create the related
objects if necessary.
.PP
Be aware that the input hashref might be edited in place, so don't rely
on it being the same after a call to \f(CW\*(C`set_inflated_columns\*(C'\fR. If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`set_inflated_columns\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
See also \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base.
.SS "copy"
.IX Subsection "copy"
.Vb 1
\&  my $copy = $orig\->copy({ change => $to, ... });
.Ve
.IP "Arguments: \e%replacementdata" 4
.IX Item "Arguments: %replacementdata"
.PD 0
.ie n .IP "Return Value: $result copy" 4
.el .IP "Return Value: \f(CW$result\fR copy" 4
.IX Item "Return Value: $result copy"
.PD
.PP
Inserts a new row into the database, as a copy of the original
object. If a hashref of replacement data is supplied, these will take
precedence over data in the original. Also any columns which have
the column info attribute
\&\f(CW\*(C`is_auto_increment => 1\*(C'\fR are explicitly removed before the copy,
so that the database can insert its own autoincremented values into
the new object.
.PP
Relationships will be followed by the copy procedure \fBonly\fR if the
relationship specifies a true value for its
cascade_copy attribute. \f(CW\*(C`cascade_copy\*(C'\fR
is set by default on \f(CW\*(C`has_many\*(C'\fR relationships and unset on all others.
.SS "store_column"
.IX Subsection "store_column"
.Vb 1
\&  $result\->store_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.IP "Return Value: The value sent to storage" 4
.IX Item "Return Value: The value sent to storage"
.PD
.PP
Set a raw value for a column without marking it as changed. This
method is used internally by \*(L"set_column\*(R" which you should probably
be using.
.PP
This is the lowest level at which data is set on a result object,
extend this method to catch all data setting methods.
.SS "inflate_result"
.IX Subsection "inflate_result"
.Vb 1
\&  Class\->inflate_result($result_source, \e%me, \e%prefetch?)
.Ve
.ie n .IP "Arguments: $result_source, \e%columndata, \e%prefetcheddata" 4
.el .IP "Arguments: \f(CW$result_source\fR, \e%columndata, \e%prefetcheddata" 4
.IX Item "Arguments: $result_source, %columndata, %prefetcheddata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
All DBIx::Class::ResultSet methods that retrieve data from the
database and turn it into result objects call this method.
.PP
Extend this method in your Result classes to hook into this process,
for example to rebless the result into a different class.
.PP
Reblessing can also be done more easily by setting \f(CW\*(C`result_class\*(C'\fR in
your Result class. See \*(L"result_class\*(R" in DBIx::Class::ResultSource.
.PP
Different types of results can also be created from a particular
DBIx::Class::ResultSet, see \*(L"result_class\*(R" in DBIx::Class::ResultSet.
.SS "update_or_insert"
.IX Subsection "update_or_insert"
.Vb 1
\&  $result\->update_or_insert
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Result of update or insert operation" 4
.IX Item "Return Value: Result of update or insert operation"
.PD
.PP
\&\*(L"Update\*(R"s the object if it's already in the database, according to
\&\*(L"in_storage\*(R", else \*(L"insert\*(R"s it.
.SS "insert_or_update"
.IX Subsection "insert_or_update"
.Vb 1
\&  $obj\->insert_or_update
.Ve
.PP
Alias for \*(L"update_or_insert\*(R"
.SS "is_changed"
.IX Subsection "is_changed"
.Vb 2
\&  my @changed_col_names = $result\->is_changed();
\&  if ($result\->is_changed()) { ... }
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: 0|1 or @columnnames" 4
.el .IP "Return Value: 0|1 or \f(CW@columnnames\fR" 4
.IX Item "Return Value: 0|1 or @columnnames"
.PD
.PP
In list context returns a list of columns with uncommited changes, or
in scalar context returns a true value if there are uncommitted
changes.
.SS "is_column_changed"
.IX Subsection "is_column_changed"
.Vb 1
\&  if ($result\->is_column_changed(\*(Aqcol\*(Aq)) { ... }
.Ve
.ie n .IP "Arguments: $columname" 4
.el .IP "Arguments: \f(CW$columname\fR" 4
.IX Item "Arguments: $columname"
.PD 0
.IP "Return Value: 0|1" 4
.IX Item "Return Value: 0|1"
.PD
.PP
Returns a true value if the column has uncommitted changes.
.SS "result_source"
.IX Subsection "result_source"
.Vb 1
\&  my $resultsource = $result\->result_source;
.Ve
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
Accessor to the DBIx::Class::ResultSource this object was created from.
.SS "register_column"
.IX Subsection "register_column"
.Vb 2
\&  $column_info = { .... };
\&  $class\->register_column($column_name, $column_info);
.Ve
.ie n .IP "Arguments: $columnname, \e%columninfo" 4
.el .IP "Arguments: \f(CW$columnname\fR, \e%columninfo" 4
.IX Item "Arguments: $columnname, %columninfo"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Registers a column on the class. If the column_info has an 'accessor'
key, creates an accessor named after the value if defined; if there is
no such key, creates an accessor with the same name as the column
.PP
The column_info attributes are described in
\&\*(L"add_columns\*(R" in DBIx::Class::ResultSource
.SS "get_from_storage"
.IX Subsection "get_from_storage"
.Vb 1
\&  my $copy = $result\->get_from_storage($attrs)
.Ve
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Return Value: A Result object" 4
.IX Item "Return Value: A Result object"
.PD
.PP
Fetches a fresh copy of the Result object from the database and returns it.
Throws an exception if a proper \s-1WHERE\s0 clause identifying the database row
can not be constructed (i.e. if the original object does not contain its
entire
 primary key
). If passed the \e%attrs argument, will first apply these attributes to
the resultset used to find the row.
.PP
This copy can then be used to compare to an existing result object, to
determine if any changes have been made in the database since it was
created.
.PP
To just update your Result object with any latest changes from the
database, use \*(L"discard_changes\*(R" instead.
.PP
The \e%attrs argument should be compatible with
\&\*(L"\s-1ATTRIBUTES\*(R"\s0 in DBIx::Class::ResultSet.
.SS "discard_changes"
.IX Subsection "discard_changes"
.Vb 1
\&  $result\->discard_changes
.Ve
.ie n .IP "Arguments: none or $attrs" 4
.el .IP "Arguments: none or \f(CW$attrs\fR" 4
.IX Item "Arguments: none or $attrs"
.PD 0
.IP "Return Value: self (updates object in-place)" 4
.IX Item "Return Value: self (updates object in-place)"
.PD
.PP
Re-selects the row from the database, losing any changes that had
been made. Throws an exception if a proper \f(CW\*(C`WHERE\*(C'\fR clause identifying
the database row can not be constructed (i.e. if the original object
does not contain its entire
primary key).
.PP
This method can also be used to refresh from storage, retrieving any
changes made since the row was last read from storage.
.PP
\&\f(CW$attrs\fR, if supplied, is expected to be a hashref of attributes suitable for passing as the
second argument to \f(CW\*(C`$resultset\->search($cond, $attrs)\*(C'\fR;
.PP
Note: If you are using DBIx::Class::Storage::DBI::Replicated as your
storage, please kept in mind that if you \*(L"discard_changes\*(R" on a row that you
just updated or created, you should wrap the entire bit inside a transaction.
Otherwise you run the risk that you insert or update to the master database
but read from a replicant database that has not yet been updated from the
master.  This will result in unexpected results.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "id"
.IX Subsection "id"
.Vb 1
\&  my @pk = $result\->id;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A list of primary key values" 4
.IX Item "Returns: A list of primary key values"
.PD
.PP
Returns the primary key(s) for a row. Can't be called as a class method.
Actually implemented in DBIx::Class::PK
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker.3pm                    0100644 0001750 0001750 00000011712 12566242400 024760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker 3"
.TH DBIx::Class::SQLMaker 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker \- An SQL::Abstract\-based SQL maker class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a subclass of SQL::Abstract and includes a number of
DBIC-specific workarounds, not yet suitable for inclusion into the
SQL::Abstract core. It also provides all (and more than) the functionality
of SQL::Abstract::Limit, see DBIx::Class::SQLMaker::LimitDialects for
more info.
.PP
Currently the enhancements to SQL::Abstract are:
.IP "\(bu" 4
Support for \f(CW\*(C`JOIN\*(C'\fR statements (via extended \f(CW\*(C`table/from\*(C'\fR support)
.IP "\(bu" 4
Support of functions in \f(CW\*(C`SELECT\*(C'\fR lists
.IP "\(bu" 4
\&\f(CW\*(C`GROUP BY\*(C'\fR/\f(CW\*(C`HAVING\*(C'\fR support (via extensions to the order_by parameter)
.IP "\(bu" 4
Support of \f(CW\*(C`...FOR UPDATE\*(C'\fR type of select statement modifiers
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker5.16.3pm                0100644 0001750 0001750 00000013676 12566242363 025315  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker 3"
.TH DBIx::Class::SQLMaker 3 "2012-08-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker \- An SQL::Abstract\-based SQL maker class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a subclass of SQL::Abstract and includes a number of
DBIC-specific workarounds, not yet suitable for inclusion into the
SQL::Abstract core. It also provides all (and more than) the functionality
of SQL::Abstract::Limit, see DBIx::Class::SQLMaker::LimitDialects for
more info.
.PP
Currently the enhancements to SQL::Abstract are:
.IP "\(bu" 4
Support for \f(CW\*(C`JOIN\*(C'\fR statements (via extended \f(CW\*(C`table/from\*(C'\fR support)
.IP "\(bu" 4
Support of functions in \f(CW\*(C`SELECT\*(C'\fR lists
.IP "\(bu" 4
\&\f(CW\*(C`GROUP BY\*(C'\fR/\f(CW\*(C`HAVING\*(C'\fR support (via extensions to the order_by parameter)
.IP "\(bu" 4
Support of \f(CW\*(C`...FOR UPDATE\*(C'\fR type of select statement modifiers
.IP "\(bu" 4
The \*(L"\-ident\*(R" operator
.IP "\(bu" 4
The \*(L"\-value\*(R" operator
.SH "OPERATORS"
.IX Header "OPERATORS"
.SS "\-ident"
.IX Subsection "-ident"
Used to explicitly specify an \s-1SQL\s0 identifier. Takes a plain string as value
which is then invariably treated as a column name (and is being properly
quoted if quoting has been requested). Most useful for comparison of two
columns:
.PP
.Vb 4
\&    my %where = (
\&        priority => { \*(Aq<\*(Aq, 2 },
\&        requestor => { \-ident => \*(Aqsubmitter\*(Aq }
\&    );
.Ve
.PP
which results in:
.PP
.Vb 2
\&    $stmt = \*(AqWHERE "priority" < ? AND "requestor" = "submitter"\*(Aq;
\&    @bind = (\*(Aq2\*(Aq);
.Ve
.SS "\-value"
.IX Subsection "-value"
The \-value operator signals that the argument to the right is a raw bind value.
It will be passed straight to \s-1DBI\s0, without invoking any of the SQL::Abstract
condition-parsing logic. This allows you to, for example, pass an array as a
column value for databases that support array datatypes, e.g.:
.PP
.Vb 3
\&    my %where = (
\&        array => { \-value => [1, 2, 3] }
\&    );
.Ve
.PP
which results in:
.PP
.Vb 2
\&    $stmt = \*(AqWHERE array = ?\*(Aq;
\&    @bind = ([1, 2, 3]);
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\s0\*(R" in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker5.18.3pm                0100644 0001750 0001750 00000011712 12566242400 025274  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker 3"
.TH DBIx::Class::SQLMaker 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker \- An SQL::Abstract\-based SQL maker class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a subclass of SQL::Abstract and includes a number of
DBIC-specific workarounds, not yet suitable for inclusion into the
SQL::Abstract core. It also provides all (and more than) the functionality
of SQL::Abstract::Limit, see DBIx::Class::SQLMaker::LimitDialects for
more info.
.PP
Currently the enhancements to SQL::Abstract are:
.IP "\(bu" 4
Support for \f(CW\*(C`JOIN\*(C'\fR statements (via extended \f(CW\*(C`table/from\*(C'\fR support)
.IP "\(bu" 4
Support of functions in \f(CW\*(C`SELECT\*(C'\fR lists
.IP "\(bu" 4
\&\f(CW\*(C`GROUP BY\*(C'\fR/\f(CW\*(C`HAVING\*(C'\fR support (via extensions to the order_by parameter)
.IP "\(bu" 4
Support of \f(CW\*(C`...FOR UPDATE\*(C'\fR type of select statement modifiers
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker::LimitDialects.3pm     0100644 0001750 0001750 00000021327 12566242400 027617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::LimitDialects 3"
.TH DBIx::Class::SQLMaker::LimitDialects 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker::LimitDialects \- SQL::Abstract::Limit\-like functionality for DBIx::Class::SQLMaker
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module replicates a lot of the functionality originally found in
SQL::Abstract::Limit. While simple limits would work as-is, the more
complex dialects that require e.g. subqueries could not be reliably
implemented without taking full advantage of the metadata locked within
DBIx::Class::ResultSource classes. After reimplementation of close to
80% of the SQL::Abstract::Limit functionality it was deemed more
practical to simply make an independent DBIx::Class\-specific limit-dialect
provider.
.SH "SQL LIMIT DIALECTS"
.IX Header "SQL LIMIT DIALECTS"
Note that the actual implementations listed below never use \f(CW\*(C`*\*(C'\fR literally.
Instead proper re-aliasing of selectors and order criteria is done, so that
the limit dialect are safe to use on joined resultsets with clashing column
names.
.PP
Currently the provided dialects are:
.SS "LimitOffset"
.IX Subsection "LimitOffset"
.Vb 1
\& SELECT ... LIMIT $limit OFFSET $offset
.Ve
.PP
Supported by \fBPostgreSQL\fR and \fBSQLite\fR
.SS "LimitXY"
.IX Subsection "LimitXY"
.Vb 1
\& SELECT ... LIMIT $offset $limit
.Ve
.PP
Supported by \fBMySQL\fR and any SQL::Statement based \s-1DBD\s0
.SS "RowNumberOver"
.IX Subsection "RowNumberOver"
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROW_NUMBER() OVER( ORDER BY ... ) AS RNO_\|_ROW_\|_INDEX FROM (
\&   SELECT ...
\&  )
\& ) WHERE RNO_\|_ROW_\|_INDEX BETWEEN ($offset+1) AND ($limit+$offset)
.Ve
.PP
\&\s-1ANSI\s0 standard Limit/Offset implementation. Supported by \fB\s-1DB2\s0\fR and
\&\fB\s-1MSSQL \s0>= 2005\fR.
.SS "SkipFirst"
.IX Subsection "SkipFirst"
.Vb 1
\& SELECT SKIP $offset FIRST $limit * FROM ...
.Ve
.PP
Suported by \fBInformix\fR, almost like LimitOffset. According to
SQL::Abstract::Limit \f(CW\*(C`... SKIP $offset LIMIT $limit ...\*(C'\fR is also supported.
.SS "FirstSkip"
.IX Subsection "FirstSkip"
.Vb 1
\& SELECT FIRST $limit SKIP $offset * FROM ...
.Ve
.PP
Supported by \fBFirebird/Interbase\fR, reverse of SkipFirst. According to
SQL::Abstract::Limit \f(CW\*(C`... ROWS $limit TO $offset ...\*(C'\fR is also supported.
.SS "RowNum"
.IX Subsection "RowNum"
Depending on the resultset attributes one of:
.PP
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROWNUM rownum_\|_index FROM (
\&   SELECT ...
\&  ) WHERE ROWNUM <= ($limit+$offset)
\& ) WHERE rownum_\|_index >= ($offset+1)
.Ve
.PP
or
.PP
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROWNUM rownum_\|_index FROM (
\&    SELECT ...
\&  )
\& ) WHERE rownum_\|_index BETWEEN ($offset+1) AND ($limit+$offset)
.Ve
.PP
or
.PP
.Vb 3
\& SELECT * FROM (
\&    SELECT ...
\&  ) WHERE ROWNUM <= ($limit+1)
.Ve
.PP
Supported by \fBOracle\fR.
.SS "Top"
.IX Subsection "Top"
.Vb 1
\& SELECT * FROM
\&
\& SELECT TOP $limit FROM (
\&  SELECT TOP $limit FROM (
\&   SELECT TOP ($limit+$offset) ...
\&  ) ORDER BY $reversed_original_order
\& ) ORDER BY $original_order
.Ve
.PP
Unreliable Top-based implementation, supported by \fB\s-1MSSQL\s0 < 2005\fR.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Due to its implementation, this limit dialect returns \fBincorrect results\fR
when \f(CW$limit\fR+$offset > total amount of rows in the resultset.
.SS "FetchFirst"
.IX Subsection "FetchFirst"
.Vb 10
\& SELECT * FROM
\& (
\& SELECT * FROM (
\&  SELECT * FROM (
\&   SELECT * FROM ...
\&  ) ORDER BY $reversed_original_order
\&    FETCH FIRST $limit ROWS ONLY
\& ) ORDER BY $original_order
\&   FETCH FIRST $limit ROWS ONLY
\& )
.Ve
.PP
Unreliable FetchFirst-based implementation, supported by \fB\s-1IBM DB2\s0 <= V5R3\fR.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Due to its implementation, this limit dialect returns \fBincorrect results\fR
when \f(CW$limit\fR+$offset > total amount of rows in the resultset.
.SS "GenericSubQ"
.IX Subsection "GenericSubQ"
.Vb 6
\& SELECT * FROM (
\&  SELECT ...
\& )
\& WHERE (
\&  SELECT COUNT(*) FROM $original_table cnt WHERE cnt.id < $original_table.id
\& ) BETWEEN $offset AND ($offset+$rows\-1)
.Ve
.PP
This is the most evil limit \*(L"dialect\*(R" (more of a hack) for \fIreally\fR stupid
databases. It works by ordering the set by some unique column, and calculating
the amount of rows that have a less-er value (thus emulating a \*(L"RowNum\*(R"\-like
index). Of course this implies the set can only be ordered by a single unique
column.
.PP
Also note that this technique can be and often is \fBexcruciatingly slow\fR. You
may have much better luck using \*(L"software_limit\*(R" in DBIx::Class::ResultSet
instead.
.PP
Currently used by \fBSybase \s-1ASE\s0\fR, due to lack of any other option.
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker::LimitDialects5.16.3pm 0100644 0001750 0001750 00000021543 12566242362 030140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::LimitDialects 3"
.TH DBIx::Class::SQLMaker::LimitDialects 3 "2012-08-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker::LimitDialects \- SQL::Abstract::Limit\-like functionality for DBIx::Class::SQLMaker
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module replicates a lot of the functionality originally found in
SQL::Abstract::Limit. While simple limits would work as-is, the more
complex dialects that require e.g. subqueries could not be reliably
implemented without taking full advantage of the metadata locked within
DBIx::Class::ResultSource classes. After reimplementation of close to
80% of the SQL::Abstract::Limit functionality it was deemed more
practical to simply make an independent DBIx::Class\-specific limit-dialect
provider.
.SH "SQL LIMIT DIALECTS"
.IX Header "SQL LIMIT DIALECTS"
Note that the actual implementations listed below never use \f(CW\*(C`*\*(C'\fR literally.
Instead proper re-aliasing of selectors and order criteria is done, so that
the limit dialect are safe to use on joined resultsets with clashing column
names.
.PP
Currently the provided dialects are:
.SS "LimitOffset"
.IX Subsection "LimitOffset"
.Vb 1
\& SELECT ... LIMIT $limit OFFSET $offset
.Ve
.PP
Supported by \fBPostgreSQL\fR and \fBSQLite\fR
.SS "LimitXY"
.IX Subsection "LimitXY"
.Vb 1
\& SELECT ... LIMIT $offset $limit
.Ve
.PP
Supported by \fBMySQL\fR and any SQL::Statement based \s-1DBD\s0
.SS "RowNumberOver"
.IX Subsection "RowNumberOver"
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROW_NUMBER() OVER( ORDER BY ... ) AS RNO_\|_ROW_\|_INDEX FROM (
\&   SELECT ...
\&  )
\& ) WHERE RNO_\|_ROW_\|_INDEX BETWEEN ($offset+1) AND ($limit+$offset)
.Ve
.PP
\&\s-1ANSI\s0 standard Limit/Offset implementation. Supported by \fB\s-1DB2\s0\fR and
\&\fB\s-1MSSQL\s0 >= 2005\fR.
.SS "SkipFirst"
.IX Subsection "SkipFirst"
.Vb 1
\& SELECT SKIP $offset FIRST $limit * FROM ...
.Ve
.PP
Suported by \fBInformix\fR, almost like LimitOffset. According to
SQL::Abstract::Limit \f(CW\*(C`... SKIP $offset LIMIT $limit ...\*(C'\fR is also supported.
.SS "FirstSkip"
.IX Subsection "FirstSkip"
.Vb 1
\& SELECT FIRST $limit SKIP $offset * FROM ...
.Ve
.PP
Supported by \fBFirebird/Interbase\fR, reverse of SkipFirst. According to
SQL::Abstract::Limit \f(CW\*(C`... ROWS $limit TO $offset ...\*(C'\fR is also supported.
.SS "RowNum"
.IX Subsection "RowNum"
Depending on the resultset attributes one of:
.PP
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROWNUM rownum_\|_index FROM (
\&   SELECT ...
\&  ) WHERE ROWNUM <= ($limit+$offset)
\& ) WHERE rownum_\|_index >= ($offset+1)
.Ve
.PP
or
.PP
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROWNUM rownum_\|_index FROM (
\&    SELECT ...
\&  )
\& ) WHERE rownum_\|_index BETWEEN ($offset+1) AND ($limit+$offset)
.Ve
.PP
or
.PP
.Vb 3
\& SELECT * FROM (
\&    SELECT ...
\&  ) WHERE ROWNUM <= ($limit+1)
.Ve
.PP
Supported by \fBOracle\fR.
.SS "Top"
.IX Subsection "Top"
.Vb 1
\& SELECT * FROM
\&
\& SELECT TOP $limit FROM (
\&  SELECT TOP $limit FROM (
\&   SELECT TOP ($limit+$offset) ...
\&  ) ORDER BY $reversed_original_order
\& ) ORDER BY $original_order
.Ve
.PP
Unreliable Top-based implementation, supported by \fB\s-1MSSQL\s0 < 2005\fR.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Due to its implementation, this limit dialect returns \fBincorrect results\fR
when \f(CW$limit\fR+$offset > total amount of rows in the resultset.
.SS "FetchFirst"
.IX Subsection "FetchFirst"
.Vb 10
\& SELECT * FROM
\& (
\& SELECT * FROM (
\&  SELECT * FROM (
\&   SELECT * FROM ...
\&  ) ORDER BY $reversed_original_order
\&    FETCH FIRST $limit ROWS ONLY
\& ) ORDER BY $original_order
\&   FETCH FIRST $limit ROWS ONLY
\& )
.Ve
.PP
Unreliable FetchFirst-based implementation, supported by \fB\s-1IBM\s0 \s-1DB2\s0 <= V5R3\fR.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Due to its implementation, this limit dialect returns \fBincorrect results\fR
when \f(CW$limit\fR+$offset > total amount of rows in the resultset.
.SS "RowCountOrGenericSubQ"
.IX Subsection "RowCountOrGenericSubQ"
This is not exactly a limit dialect, but more of a proxy for \fBSybase \s-1ASE\s0\fR.
If no \f(CW$offset\fR is supplied the limit is simply performed as:
.PP
.Vb 3
\& SET ROWCOUNT $limit
\& SELECT ...
\& SET ROWCOUNT 0
.Ve
.PP
Otherwise we fall back to \*(L"GenericSubQ\*(R"
.SS "GenericSubQ"
.IX Subsection "GenericSubQ"
.Vb 6
\& SELECT * FROM (
\&  SELECT ...
\& )
\& WHERE (
\&  SELECT COUNT(*) FROM $original_table cnt WHERE cnt.id < $original_table.id
\& ) BETWEEN $offset AND ($offset+$rows\-1)
.Ve
.PP
This is the most evil limit \*(L"dialect\*(R" (more of a hack) for \fIreally\fR stupid
databases. It works by ordering the set by some unique column, and calculating
the amount of rows that have a less-er value (thus emulating a \*(L"RowNum\*(R"\-like
index). Of course this implies the set can only be ordered by a single unique
column.
.PP
Also note that this technique can be and often is \fBexcruciatingly slow\fR. You
may have much better luck using \*(L"software_limit\*(R" in DBIx::Class::ResultSet
instead.
.PP
Currently used by \fBSybase \s-1ASE\s0\fR, due to lack of any other option.
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\s0\*(R" in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker::LimitDialects5.18.3pm 0100644 0001750 0001750 00000021327 12566242400 030133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::LimitDialects 3"
.TH DBIx::Class::SQLMaker::LimitDialects 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker::LimitDialects \- SQL::Abstract::Limit\-like functionality for DBIx::Class::SQLMaker
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module replicates a lot of the functionality originally found in
SQL::Abstract::Limit. While simple limits would work as-is, the more
complex dialects that require e.g. subqueries could not be reliably
implemented without taking full advantage of the metadata locked within
DBIx::Class::ResultSource classes. After reimplementation of close to
80% of the SQL::Abstract::Limit functionality it was deemed more
practical to simply make an independent DBIx::Class\-specific limit-dialect
provider.
.SH "SQL LIMIT DIALECTS"
.IX Header "SQL LIMIT DIALECTS"
Note that the actual implementations listed below never use \f(CW\*(C`*\*(C'\fR literally.
Instead proper re-aliasing of selectors and order criteria is done, so that
the limit dialect are safe to use on joined resultsets with clashing column
names.
.PP
Currently the provided dialects are:
.SS "LimitOffset"
.IX Subsection "LimitOffset"
.Vb 1
\& SELECT ... LIMIT $limit OFFSET $offset
.Ve
.PP
Supported by \fBPostgreSQL\fR and \fBSQLite\fR
.SS "LimitXY"
.IX Subsection "LimitXY"
.Vb 1
\& SELECT ... LIMIT $offset $limit
.Ve
.PP
Supported by \fBMySQL\fR and any SQL::Statement based \s-1DBD\s0
.SS "RowNumberOver"
.IX Subsection "RowNumberOver"
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROW_NUMBER() OVER( ORDER BY ... ) AS RNO_\|_ROW_\|_INDEX FROM (
\&   SELECT ...
\&  )
\& ) WHERE RNO_\|_ROW_\|_INDEX BETWEEN ($offset+1) AND ($limit+$offset)
.Ve
.PP
\&\s-1ANSI\s0 standard Limit/Offset implementation. Supported by \fB\s-1DB2\s0\fR and
\&\fB\s-1MSSQL \s0>= 2005\fR.
.SS "SkipFirst"
.IX Subsection "SkipFirst"
.Vb 1
\& SELECT SKIP $offset FIRST $limit * FROM ...
.Ve
.PP
Suported by \fBInformix\fR, almost like LimitOffset. According to
SQL::Abstract::Limit \f(CW\*(C`... SKIP $offset LIMIT $limit ...\*(C'\fR is also supported.
.SS "FirstSkip"
.IX Subsection "FirstSkip"
.Vb 1
\& SELECT FIRST $limit SKIP $offset * FROM ...
.Ve
.PP
Supported by \fBFirebird/Interbase\fR, reverse of SkipFirst. According to
SQL::Abstract::Limit \f(CW\*(C`... ROWS $limit TO $offset ...\*(C'\fR is also supported.
.SS "RowNum"
.IX Subsection "RowNum"
Depending on the resultset attributes one of:
.PP
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROWNUM rownum_\|_index FROM (
\&   SELECT ...
\&  ) WHERE ROWNUM <= ($limit+$offset)
\& ) WHERE rownum_\|_index >= ($offset+1)
.Ve
.PP
or
.PP
.Vb 5
\& SELECT * FROM (
\&  SELECT *, ROWNUM rownum_\|_index FROM (
\&    SELECT ...
\&  )
\& ) WHERE rownum_\|_index BETWEEN ($offset+1) AND ($limit+$offset)
.Ve
.PP
or
.PP
.Vb 3
\& SELECT * FROM (
\&    SELECT ...
\&  ) WHERE ROWNUM <= ($limit+1)
.Ve
.PP
Supported by \fBOracle\fR.
.SS "Top"
.IX Subsection "Top"
.Vb 1
\& SELECT * FROM
\&
\& SELECT TOP $limit FROM (
\&  SELECT TOP $limit FROM (
\&   SELECT TOP ($limit+$offset) ...
\&  ) ORDER BY $reversed_original_order
\& ) ORDER BY $original_order
.Ve
.PP
Unreliable Top-based implementation, supported by \fB\s-1MSSQL\s0 < 2005\fR.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Due to its implementation, this limit dialect returns \fBincorrect results\fR
when \f(CW$limit\fR+$offset > total amount of rows in the resultset.
.SS "FetchFirst"
.IX Subsection "FetchFirst"
.Vb 10
\& SELECT * FROM
\& (
\& SELECT * FROM (
\&  SELECT * FROM (
\&   SELECT * FROM ...
\&  ) ORDER BY $reversed_original_order
\&    FETCH FIRST $limit ROWS ONLY
\& ) ORDER BY $original_order
\&   FETCH FIRST $limit ROWS ONLY
\& )
.Ve
.PP
Unreliable FetchFirst-based implementation, supported by \fB\s-1IBM DB2\s0 <= V5R3\fR.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Due to its implementation, this limit dialect returns \fBincorrect results\fR
when \f(CW$limit\fR+$offset > total amount of rows in the resultset.
.SS "GenericSubQ"
.IX Subsection "GenericSubQ"
.Vb 6
\& SELECT * FROM (
\&  SELECT ...
\& )
\& WHERE (
\&  SELECT COUNT(*) FROM $original_table cnt WHERE cnt.id < $original_table.id
\& ) BETWEEN $offset AND ($offset+$rows\-1)
.Ve
.PP
This is the most evil limit \*(L"dialect\*(R" (more of a hack) for \fIreally\fR stupid
databases. It works by ordering the set by some unique column, and calculating
the amount of rows that have a less-er value (thus emulating a \*(L"RowNum\*(R"\-like
index). Of course this implies the set can only be ordered by a single unique
column.
.PP
Also note that this technique can be and often is \fBexcruciatingly slow\fR. You
may have much better luck using \*(L"software_limit\*(R" in DBIx::Class::ResultSet
instead.
.PP
Currently used by \fBSybase \s-1ASE\s0\fR, due to lack of any other option.
.SH "AUTHORS"
.IX Header "AUTHORS"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker::OracleJoins.3pm       0100644 0001750 0001750 00000013540 12566242377 027313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::OracleJoins 3"
.TH DBIx::Class::SQLMaker::OracleJoins 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker::OracleJoins \- Pre\-ANSI Joins\-via\-Where\-Clause Syntax
.SH "PURPOSE"
.IX Header "PURPOSE"
This module is used with Oracle < 9.0 due to lack of support for standard
\&\s-1ANSI\s0 join syntax.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Not intended for use directly; used as the sql_maker_class for schemas and components.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Implements pre-ANSI joins specified in the where clause.  Instead of:
.PP
.Vb 1
\&    SELECT x FROM y JOIN z ON y.id = z.id
.Ve
.PP
It will write:
.PP
.Vb 1
\&    SELECT x FROM y, z WHERE y.id = z.id
.Ve
.PP
It should properly support left joins, and right joins.  Full outer joins are
not possible due to the fact that Oracle requires the entire query be written
to union the results of a left and right join, and by the time this module is
called to create the where query and table definition part of the sql query,
it's already too late.
.SH "METHODS"
.IX Header "METHODS"
.IP "select" 4
.IX Item "select"
Overrides DBIx::Class::SQLMaker's \fIselect()\fR method, which calls \fI_oracle_joins()\fR
to modify the column and table list before calling \fInext::method()\fR.
.SH "BUGS"
.IX Header "BUGS"
Does not support full outer joins (however neither really does \s-1DBIC\s0 itself)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "DBIx::Class::Storage::DBI::Oracle::WhereJoins \- Storage class using this" 4
.IX Item "DBIx::Class::Storage::DBI::Oracle::WhereJoins - Storage class using this"
.PD 0
.IP "DBIx::Class::SQLMaker \- Parent module" 4
.IX Item "DBIx::Class::SQLMaker - Parent module"
.IP "DBIx::Class \- Duh" 4
.IX Item "DBIx::Class - Duh"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Justin Wheeler \f(CW\*(C`<jwheeler@datademons.com>\*(C'\fR
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
David Jack Olrik \f(CW\*(C`<djo@cpan.org>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
This module is licensed under the same terms as Perl itself.
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker::OracleJoins5.16.3pm   0100644 0001750 0001750 00000013217 12566242362 027620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::OracleJoins 3"
.TH DBIx::Class::SQLMaker::OracleJoins 3 "2012-08-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker::OracleJoins \- Pre\-ANSI Joins\-via\-Where\-Clause Syntax
.SH "PURPOSE"
.IX Header "PURPOSE"
This module is used with Oracle < 9.0 due to lack of support for standard
\&\s-1ANSI\s0 join syntax.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Not intended for use directly; used as the sql_maker_class for schemas and components.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Implements pre-ANSI joins specified in the where clause.  Instead of:
.PP
.Vb 1
\&    SELECT x FROM y JOIN z ON y.id = z.id
.Ve
.PP
It will write:
.PP
.Vb 1
\&    SELECT x FROM y, z WHERE y.id = z.id
.Ve
.PP
It should properly support left joins, and right joins.  Full outer joins are
not possible due to the fact that Oracle requires the entire query be written
to union the results of a left and right join, and by the time this module is
called to create the where query and table definition part of the sql query,
it's already too late.
.SH "METHODS"
.IX Header "METHODS"
.IP "select" 4
.IX Item "select"
Overrides DBIx::Class::SQLMaker's \fIselect()\fR method, which calls \fI_oracle_joins()\fR
to modify the column and table list before calling \fInext::method()\fR.
.SH "BUGS"
.IX Header "BUGS"
Does not support full outer joins (however neither really does \s-1DBIC\s0 itself)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "DBIx::Class::Storage::DBI::Oracle::WhereJoins \- Storage class using this" 4
.IX Item "DBIx::Class::Storage::DBI::Oracle::WhereJoins - Storage class using this"
.PD 0
.IP "DBIx::Class::SQLMaker \- Parent module" 4
.IX Item "DBIx::Class::SQLMaker - Parent module"
.IP "DBIx::Class \- Duh" 4
.IX Item "DBIx::Class - Duh"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Justin Wheeler \f(CW\*(C`<jwheeler@datademons.com>\*(C'\fR
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
David Jack Olrik \f(CW\*(C`<djo@cpan.org>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
This module is licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::SQLMaker::OracleJoins5.18.3pm   0100644 0001750 0001750 00000013540 12566242377 027627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::OracleJoins 3"
.TH DBIx::Class::SQLMaker::OracleJoins 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::SQLMaker::OracleJoins \- Pre\-ANSI Joins\-via\-Where\-Clause Syntax
.SH "PURPOSE"
.IX Header "PURPOSE"
This module is used with Oracle < 9.0 due to lack of support for standard
\&\s-1ANSI\s0 join syntax.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Not intended for use directly; used as the sql_maker_class for schemas and components.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Implements pre-ANSI joins specified in the where clause.  Instead of:
.PP
.Vb 1
\&    SELECT x FROM y JOIN z ON y.id = z.id
.Ve
.PP
It will write:
.PP
.Vb 1
\&    SELECT x FROM y, z WHERE y.id = z.id
.Ve
.PP
It should properly support left joins, and right joins.  Full outer joins are
not possible due to the fact that Oracle requires the entire query be written
to union the results of a left and right join, and by the time this module is
called to create the where query and table definition part of the sql query,
it's already too late.
.SH "METHODS"
.IX Header "METHODS"
.IP "select" 4
.IX Item "select"
Overrides DBIx::Class::SQLMaker's \fIselect()\fR method, which calls \fI_oracle_joins()\fR
to modify the column and table list before calling \fInext::method()\fR.
.SH "BUGS"
.IX Header "BUGS"
Does not support full outer joins (however neither really does \s-1DBIC\s0 itself)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "DBIx::Class::Storage::DBI::Oracle::WhereJoins \- Storage class using this" 4
.IX Item "DBIx::Class::Storage::DBI::Oracle::WhereJoins - Storage class using this"
.PD 0
.IP "DBIx::Class::SQLMaker \- Parent module" 4
.IX Item "DBIx::Class::SQLMaker - Parent module"
.IP "DBIx::Class \- Duh" 4
.IX Item "DBIx::Class - Duh"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Justin Wheeler \f(CW\*(C`<jwheeler@datademons.com>\*(C'\fR
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
David Jack Olrik \f(CW\*(C`<djo@cpan.org>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
This module is licensed under the same terms as Perl itself.
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBIx::Class::Schema.3pm                      0100644 0001750 0001750 00000076116 12566242400 024552  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema 3"
.TH DBIx::Class::Schema 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Schema \- composable schemas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Library::Schema;
\&  use base qw/DBIx::Class::Schema/;
\&
\&  # load all Result classes in Library/Schema/Result/
\&  _\|_PACKAGE_\|_\->load_namespaces();
\&
\&  package Library::Schema::Result::CD;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->load_components(qw/InflateColumn::DateTime/); # for example
\&  _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&
\&  # Elsewhere in your code:
\&  my $schema1 = Library::Schema\->connect(
\&    $dsn,
\&    $user,
\&    $password,
\&    { AutoCommit => 1 },
\&  );
\&
\&  my $schema2 = Library::Schema\->connect($coderef_returning_dbh);
\&
\&  # fetch objects using Library::Schema::Result::DVD
\&  my $resultset = $schema1\->resultset(\*(AqDVD\*(Aq)\->search( ... );
\&  my @dvd_objects = $schema2\->resultset(\*(AqDVD\*(Aq)\->search( ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates database classes based on a schema. This is the recommended way to
use DBIx::Class and allows you to use more than one concurrent connection
with your classes.
.PP
\&\s-1NB:\s0 If you're used to Class::DBI it's worth reading the \*(L"\s-1SYNOPSIS\*(R"\s0
carefully, as DBIx::Class does things a little differently. Note in
particular which module inherits off which.
.SH "SETUP METHODS"
.IX Header "SETUP METHODS"
.SS "load_namespaces"
.IX Subsection "load_namespaces"
.ie n .IP "Arguments: %options?" 4
.el .IP "Arguments: \f(CW%options\fR?" 4
.IX Item "Arguments: %options?"
.PP
.Vb 2
\&  package MyApp::Schema;
\&  _\|_PACKAGE_\|_\->load_namespaces();
\&
\&  _\|_PACKAGE_\|_\->load_namespaces(
\&     result_namespace => \*(AqRes\*(Aq,
\&     resultset_namespace => \*(AqRSet\*(Aq,
\&     default_resultset_class => \*(Aq+MyApp::Othernamespace::RSet\*(Aq,
\&  );
.Ve
.PP
With no arguments, this method uses Module::Find to load all of the
Result and ResultSet classes under the namespace of the schema from
which it is called.  For example, \f(CW\*(C`My::Schema\*(C'\fR will by default find
and load Result classes named \f(CW\*(C`My::Schema::Result::*\*(C'\fR and ResultSet
classes named \f(CW\*(C`My::Schema::ResultSet::*\*(C'\fR.
.PP
ResultSet classes are associated with Result class of the same name.
For example, \f(CW\*(C`My::Schema::Result::CD\*(C'\fR will get the ResultSet class
\&\f(CW\*(C`My::Schema::ResultSet::CD\*(C'\fR if it is present.
.PP
Both Result and ResultSet namespaces are configurable via the
\&\f(CW\*(C`result_namespace\*(C'\fR and \f(CW\*(C`resultset_namespace\*(C'\fR options.
.PP
Another option, \f(CW\*(C`default_resultset_class\*(C'\fR specifies a custom default
ResultSet class for Result classes with no corresponding ResultSet.
.PP
All of the namespace and classname options are by default relative to
the schema classname.  To specify a fully-qualified name, prefix it
with a literal \f(CW\*(C`+\*(C'\fR.  For example, \f(CW\*(C`+Other::NameSpace::Result\*(C'\fR.
.PP
\fIWarnings\fR
.IX Subsection "Warnings"
.PP
You will be warned if ResultSet classes are discovered for which there
are no matching Result classes like this:
.PP
.Vb 1
\&  load_namespaces found ResultSet class $classname with no corresponding Result class
.Ve
.PP
If a Result class is found to already have a ResultSet class set using
\&\*(L"resultset_class\*(R" to some other class, you will be warned like this:
.PP
.Vb 2
\&  We found ResultSet class \*(Aq$rs_class\*(Aq for \*(Aq$result\*(Aq, but it seems
\&  that you had already set \*(Aq$result\*(Aq to use \*(Aq$rs_set\*(Aq instead
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
.Vb 3
\&  # load My::Schema::Result::CD, My::Schema::Result::Artist,
\&  #    My::Schema::ResultSet::CD, etc...
\&  My::Schema\->load_namespaces;
\&
\&  # Override everything to use ugly names.
\&  # In this example, if there is a My::Schema::Res::Foo, but no matching
\&  #   My::Schema::RSets::Foo, then Foo will have its
\&  #   resultset_class set to My::Schema::RSetBase
\&  My::Schema\->load_namespaces(
\&    result_namespace => \*(AqRes\*(Aq,
\&    resultset_namespace => \*(AqRSets\*(Aq,
\&    default_resultset_class => \*(AqRSetBase\*(Aq,
\&  );
\&
\&  # Put things in other namespaces
\&  My::Schema\->load_namespaces(
\&    result_namespace => \*(Aq+Some::Place::Results\*(Aq,
\&    resultset_namespace => \*(Aq+Another::Place::RSets\*(Aq,
\&  );
.Ve
.PP
To search multiple namespaces for either Result or ResultSet classes,
use an arrayref of namespaces for that option.  In the case that the
same result (or resultset) class exists in multiple namespaces, later
entries in the list of namespaces will override earlier ones.
.PP
.Vb 5
\&  My::Schema\->load_namespaces(
\&    # My::Schema::Results_C::Foo takes precedence over My::Schema::Results_B::Foo :
\&    result_namespace => [ \*(AqResults_A\*(Aq, \*(AqResults_B\*(Aq, \*(AqResults_C\*(Aq ],
\&    resultset_namespace => [ \*(Aq+Some::Place::RSets\*(Aq, \*(AqRSets\*(Aq ],
\&  );
.Ve
.SS "load_classes"
.IX Subsection "load_classes"
.ie n .IP "Arguments: @classes?, { $namespace => [ @classes ] }+" 4
.el .IP "Arguments: \f(CW@classes\fR?, { \f(CW$namespace\fR => [ \f(CW@classes\fR ] }+" 4
.IX Item "Arguments: @classes?, { $namespace => [ @classes ] }+"
.PP
\&\*(L"load_classes\*(R" is an alternative method to \*(L"load_namespaces\*(R", both of
which serve similar purposes, each with different advantages and disadvantages.
In the general case you should use \*(L"load_namespaces\*(R", unless you need to
be able to specify that only specific classes are loaded at runtime.
.PP
With no arguments, this method uses Module::Find to find all classes under
the schema's namespace. Otherwise, this method loads the classes you specify
(using use), and registers them (using \*(L"register_class\*(R").
.PP
It is possible to comment out classes with a leading \f(CW\*(C`#\*(C'\fR, but note that perl
will think it's a mistake (trying to use a comment in a qw list), so you'll
need to add \f(CW\*(C`no warnings \*(Aqqw\*(Aq;\*(C'\fR before your load_classes call.
.PP
If any classes found do not appear to be Result class files, you will
get the following warning:
.PP
.Vb 3
\&   Failed to load $comp_class. Can\*(Aqt find source_name method. Is
\&   $comp_class really a full DBIC result class? Fix it, move it elsewhere,
\&   or make your load_classes call more specific.
.Ve
.PP
Example:
.PP
.Vb 2
\&  My::Schema\->load_classes(); # loads My::Schema::CD, My::Schema::Artist,
\&                              # etc. (anything under the My::Schema namespace)
\&
\&  # loads My::Schema::CD, My::Schema::Artist, Other::Namespace::Producer but
\&  # not Other::Namespace::LinerNotes nor My::Schema::Track
\&  My::Schema\->load_classes(qw/ CD Artist #Track /, {
\&    Other::Namespace => [qw/ Producer #LinerNotes /],
\&  });
.Ve
.SS "storage_type"
.IX Subsection "storage_type"
.ie n .IP "Arguments: $storage_type|{$storage_type, \e%args}" 4
.el .IP "Arguments: \f(CW$storage_type\fR|{$storage_type, \e%args}" 4
.IX Item "Arguments: $storage_type|{$storage_type, %args}"
.PD 0
.ie n .IP "Return Value: $storage_type|{$storage_type, \e%args}" 4
.el .IP "Return Value: \f(CW$storage_type\fR|{$storage_type, \e%args}" 4
.IX Item "Return Value: $storage_type|{$storage_type, %args}"
.IP "Default value: DBIx::Class::Storage::DBI" 4
.IX Item "Default value: DBIx::Class::Storage::DBI"
.PD
.PP
Set the storage class that will be instantiated when \*(L"connect\*(R" is called.
If the classname starts with \f(CW\*(C`::\*(C'\fR, the prefix \f(CW\*(C`DBIx::Class::Storage\*(C'\fR is
assumed by \*(L"connect\*(R".
.PP
You want to use this to set subclasses of DBIx::Class::Storage::DBI
in cases where the appropriate subclass is not autodetected.
.PP
If your storage type requires instantiation arguments, those are
defined as a second argument in the form of a hashref and the entire
value needs to be wrapped into an arrayref or a hashref.  We support
both types of refs here in order to play nice with your
Config::[class] or your choice. See
DBIx::Class::Storage::DBI::Replicated for an example of this.
.SS "exception_action"
.IX Subsection "exception_action"
.ie n .IP "Arguments: $code_reference" 4
.el .IP "Arguments: \f(CW$code_reference\fR" 4
.IX Item "Arguments: $code_reference"
.PD 0
.ie n .IP "Return Value: $code_reference" 4
.el .IP "Return Value: \f(CW$code_reference\fR" 4
.IX Item "Return Value: $code_reference"
.IP "Default value: None" 4
.IX Item "Default value: None"
.PD
.PP
When \*(L"throw_exception\*(R" is invoked and \*(L"exception_action\*(R" is set to a code
reference, this reference will be called instead of
\&\*(L"throw\*(R" in DBIx::Class::Exception, with the exception message passed as the only
argument.
.PP
Your custom throw code \fBmust\fR rethrow the exception, as \*(L"throw_exception\*(R" is
an integral part of \s-1DBIC\s0's internal execution control flow.
.PP
Example:
.PP
.Vb 5
\&   package My::Schema;
\&   use base qw/DBIx::Class::Schema/;
\&   use My::ExceptionClass;
\&   _\|_PACKAGE_\|_\->exception_action(sub { My::ExceptionClass\->throw(@_) });
\&   _\|_PACKAGE_\|_\->load_classes;
\&
\&   # or:
\&   my $schema_obj = My::Schema\->connect( .... );
\&   $schema_obj\->exception_action(sub { My::ExceptionClass\->throw(@_) });
.Ve
.SS "stacktrace"
.IX Subsection "stacktrace"
.IP "Arguments: boolean" 4
.IX Item "Arguments: boolean"
.PP
Whether \*(L"throw_exception\*(R" should include stack trace information.
Defaults to false normally, but defaults to true if \f(CW$ENV{DBIC_TRACE}\fR
is true.
.SS "sqlt_deploy_hook"
.IX Subsection "sqlt_deploy_hook"
.ie n .IP "Arguments: $sqlt_schema" 4
.el .IP "Arguments: \f(CW$sqlt_schema\fR" 4
.IX Item "Arguments: $sqlt_schema"
.PP
An optional sub which you can declare in your own Schema class that will get
passed the SQL::Translator::Schema object when you deploy the schema via
\&\*(L"create_ddl_dir\*(R" or \*(L"deploy\*(R".
.PP
For an example of what you can do with this, see
\&\*(L"Adding Indexes And Functions To Your \s-1SQL\*(R"\s0 in DBIx::Class::Manual::Cookbook.
.PP
Note that sqlt_deploy_hook is called by \*(L"deployment_statements\*(R", which in turn
is called before \*(L"deploy\*(R". Therefore the hook can be used only to manipulate
the SQL::Translator::Schema object before it is turned into \s-1SQL\s0 fed to the
database. If you want to execute post-deploy statements which can not be generated
by SQL::Translator, the currently suggested method is to overload \*(L"deploy\*(R"
and use dbh_do.
.SH "METHODS"
.IX Header "METHODS"
.SS "connect"
.IX Subsection "connect"
.ie n .IP "Arguments: @connectinfo" 4
.el .IP "Arguments: \f(CW@connectinfo\fR" 4
.IX Item "Arguments: @connectinfo"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
Creates and returns a new Schema object. The connection info set on it
is used to create a new instance of the storage backend and set it on
the Schema object.
.PP
See \*(L"connect_info\*(R" in DBIx::Class::Storage::DBI for DBI-specific
syntax on the \f(CW@connectinfo\fR argument, or DBIx::Class::Storage in
general.
.PP
Note that \f(CW\*(C`connect_info\*(C'\fR expects an arrayref of arguments, but
\&\f(CW\*(C`connect\*(C'\fR does not. \f(CW\*(C`connect\*(C'\fR wraps its arguments in an arrayref
before passing them to \f(CW\*(C`connect_info\*(C'\fR.
.PP
\fIOverloading\fR
.IX Subsection "Overloading"
.PP
\&\f(CW\*(C`connect\*(C'\fR is a convenience method. It is equivalent to calling
\&\f(CW$schema\fR\->clone\->connection(@connectinfo). To write your own overloaded
version, overload \*(L"connection\*(R" instead.
.SS "resultset"
.IX Subsection "resultset"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqDVD\*(Aq);
.Ve
.PP
Returns the DBIx::Class::ResultSet object for the registered source
name.
.SS "sources"
.IX Subsection "sources"
.ie n .IP "Return Value: @source_names" 4
.el .IP "Return Value: \f(CW@source_names\fR" 4
.IX Item "Return Value: @source_names"
.PP
.Vb 1
\&  my @source_names = $schema\->sources;
.Ve
.PP
Lists names of all the sources registered on this Schema object.
.SS "source"
.IX Subsection "source"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
.Vb 1
\&  my $source = $schema\->source(\*(AqBook\*(Aq);
.Ve
.PP
Returns the DBIx::Class::ResultSource object for the registered
source name.
.SS "class"
.IX Subsection "class"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
.Vb 1
\&  my $class = $schema\->class(\*(AqCD\*(Aq);
.Ve
.PP
Retrieves the Result class name for the given source name.
.SS "txn_do"
.IX Subsection "txn_do"
.ie n .IP "Arguments: $coderef, @coderef_args?" 4
.el .IP "Arguments: \f(CW$coderef\fR, \f(CW@coderef_args\fR?" 4
.IX Item "Arguments: $coderef, @coderef_args?"
.PD 0
.ie n .IP "Return Value: The return value of $coderef" 4
.el .IP "Return Value: The return value of \f(CW$coderef\fR" 4
.IX Item "Return Value: The return value of $coderef"
.PD
.PP
Executes \f(CW$coderef\fR with (optional) arguments \f(CW@coderef_args\fR atomically,
returning its result (if any). Equivalent to calling \f(CW$schema\fR\->storage\->txn_do.
See \*(L"txn_do\*(R" in DBIx::Class::Storage for more information.
.PP
This interface is preferred over using the individual methods \*(L"txn_begin\*(R",
\&\*(L"txn_commit\*(R", and \*(L"txn_rollback\*(R" below.
.PP
\&\s-1WARNING:\s0 If you are connected with \f(CW\*(C`AutoCommit => 0\*(C'\fR the transaction is
considered nested, and you will still need to call \*(L"txn_commit\*(R" to write your
changes when appropriate. You will also want to connect with \f(CW\*(C`auto_savepoint =>
1\*(C'\fR to get partial rollback to work, if the storage driver for your database
supports it.
.PP
Connecting with \f(CW\*(C`AutoCommit => 1\*(C'\fR is recommended.
.SS "txn_scope_guard"
.IX Subsection "txn_scope_guard"
Runs \f(CW\*(C`txn_scope_guard\*(C'\fR on the schema's storage. See
\&\*(L"txn_scope_guard\*(R" in DBIx::Class::Storage.
.SS "txn_begin"
.IX Subsection "txn_begin"
Begins a transaction (does nothing if AutoCommit is off). Equivalent to
calling \f(CW$schema\fR\->storage\->txn_begin. See
\&\*(L"txn_begin\*(R" in DBIx::Class::Storage for more information.
.SS "txn_commit"
.IX Subsection "txn_commit"
Commits the current transaction. Equivalent to calling
\&\f(CW$schema\fR\->storage\->txn_commit. See \*(L"txn_commit\*(R" in DBIx::Class::Storage
for more information.
.SS "txn_rollback"
.IX Subsection "txn_rollback"
Rolls back the current transaction. Equivalent to calling
\&\f(CW$schema\fR\->storage\->txn_rollback. See
\&\*(L"txn_rollback\*(R" in DBIx::Class::Storage for more information.
.SS "storage"
.IX Subsection "storage"
.Vb 1
\&  my $storage = $schema\->storage;
.Ve
.PP
Returns the DBIx::Class::Storage object for this Schema. Grab this
if you want to turn on \s-1SQL\s0 statement debugging at runtime, or set the
quote character. For the default storage, the documentation can be
found in DBIx::Class::Storage::DBI.
.SS "populate"
.IX Subsection "populate"
.ie n .IP "Arguments: $source_name, [ \e@column_list, \e@row_values+ ] | [ \e%col_data+ ]" 4
.el .IP "Arguments: \f(CW$source_name\fR, [ \e@column_list, \e@row_values+ ] | [ \e%col_data+ ]" 4
.IX Item "Arguments: $source_name, [ @column_list, @row_values+ ] | [ %col_data+ ]"
.PD 0
.ie n .IP "Return Value: \e@result_objects (scalar context) | @result_objects (list context)" 4
.el .IP "Return Value: \e@result_objects (scalar context) | \f(CW@result_objects\fR (list context)" 4
.IX Item "Return Value: @result_objects (scalar context) | @result_objects (list context)"
.PD
.PP
A convenience shortcut to \*(L"populate\*(R" in DBIx::Class::ResultSet. Equivalent to:
.PP
.Vb 1
\& $schema\->resultset($source_name)\->populate([...]);
.Ve
.IP "\s-1NOTE\s0" 4
.IX Item "NOTE"
The context of this method call has an important effect on what is
submitted to storage. In void context data is fed directly to fastpath
insertion routines provided by the underlying storage (most often
\&\*(L"execute_for_fetch\*(R" in \s-1DBI\s0), bypassing the new and
insert calls on the
Result class, including any
augmentation of these methods provided by components. For example if you
are using something like DBIx::Class::UUIDColumns to create primary
keys for you, you will find that your PKs are empty.  In this case you
will have to explicitly force scalar or list context in order to create
those values.
.SS "connection"
.IX Subsection "connection"
.ie n .IP "Arguments: @args" 4
.el .IP "Arguments: \f(CW@args\fR" 4
.IX Item "Arguments: @args"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
Similar to \*(L"connect\*(R" except sets the storage object and connection
data in-place on the Schema class. You should probably be calling
\&\*(L"connect\*(R" to get a proper Schema object instead.
.PP
\fIOverloading\fR
.IX Subsection "Overloading"
.PP
Overload \f(CW\*(C`connection\*(C'\fR to change the behaviour of \f(CW\*(C`connect\*(C'\fR.
.SS "compose_namespace"
.IX Subsection "compose_namespace"
.ie n .IP "Arguments: $target_namespace, $additional_base_class?" 4
.el .IP "Arguments: \f(CW$target_namespace\fR, \f(CW$additional_base_class\fR?" 4
.IX Item "Arguments: $target_namespace, $additional_base_class?"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
For each DBIx::Class::ResultSource in the schema, this method creates a
class in the target namespace (e.g. \f(CW$target_namespace::CD\fR,
\&\f(CW$target_namespace::Artist\fR) that inherits from the corresponding classes
attached to the current schema.
.PP
It also attaches a corresponding DBIx::Class::ResultSource object to the
new \f(CW$schema\fR object. If \f(CW$additional_base_class\fR is given, the new composed
classes will inherit from first the corresponding class from the current
schema then the base class.
.PP
For example, for a schema with My::Schema::CD and My::Schema::Artist classes,
.PP
.Vb 3
\&  $schema\->compose_namespace(\*(AqMy::DB\*(Aq, \*(AqBase::Class\*(Aq);
\&  print join (\*(Aq, \*(Aq, @My::DB::CD::ISA) . "\en";
\&  print join (\*(Aq, \*(Aq, @My::DB::Artist::ISA) ."\en";
.Ve
.PP
will produce the output
.PP
.Vb 2
\&  My::Schema::CD, Base::Class
\&  My::Schema::Artist, Base::Class
.Ve
.SS "svp_begin"
.IX Subsection "svp_begin"
Creates a new savepoint (does nothing outside a transaction).
Equivalent to calling \f(CW$schema\fR\->storage\->svp_begin.  See
\&\*(L"svp_begin\*(R" in DBIx::Class::Storage for more information.
.SS "svp_release"
.IX Subsection "svp_release"
Releases a savepoint (does nothing outside a transaction).
Equivalent to calling \f(CW$schema\fR\->storage\->svp_release.  See
\&\*(L"svp_release\*(R" in DBIx::Class::Storage for more information.
.SS "svp_rollback"
.IX Subsection "svp_rollback"
Rollback to a savepoint (does nothing outside a transaction).
Equivalent to calling \f(CW$schema\fR\->storage\->svp_rollback.  See
\&\*(L"svp_rollback\*(R" in DBIx::Class::Storage for more information.
.SS "clone"
.IX Subsection "clone"
.ie n .IP "Arguments: %attrs?" 4
.el .IP "Arguments: \f(CW%attrs\fR?" 4
.IX Item "Arguments: %attrs?"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
Clones the schema and its associated result_source objects and returns the
copy. The resulting copy will have the same attributes as the source schema,
except for those attributes explicitly overridden by the provided \f(CW%attrs\fR.
.SS "throw_exception"
.IX Subsection "throw_exception"
.ie n .IP "Arguments: $message" 4
.el .IP "Arguments: \f(CW$message\fR" 4
.IX Item "Arguments: $message"
.PP
Throws an exception. Obeys the exemption rules of DBIx::Class::Carp to report
errors from outer-user's perspective. See \*(L"exception_action\*(R" for details on overriding
this method's behavior.  If \*(L"stacktrace\*(R" is turned on, \f(CW\*(C`throw_exception\*(C'\fR's
default behavior will provide a detailed stack trace.
.SS "deploy"
.IX Subsection "deploy"
.ie n .IP "Arguments: \e%sqlt_args, $dir" 4
.el .IP "Arguments: \e%sqlt_args, \f(CW$dir\fR" 4
.IX Item "Arguments: %sqlt_args, $dir"
.PP
Attempts to deploy the schema to the current storage using SQL::Translator.
.PP
See \*(L"\s-1METHODS\*(R"\s0 in SQL::Translator for a list of values for \f(CW\*(C`\e%sqlt_args\*(C'\fR.
The most common value for this would be \f(CW\*(C`{ add_drop_table => 1 }\*(C'\fR
to have the \s-1SQL\s0 produced include a \f(CW\*(C`DROP TABLE\*(C'\fR statement for each table
created. For quoting purposes supply \f(CW\*(C`quote_identifiers\*(C'\fR.
.PP
Additionally, the DBIx::Class parser accepts a \f(CW\*(C`sources\*(C'\fR parameter as a hash
ref or an array ref, containing a list of source to deploy. If present, then
only the sources listed will get deployed. Furthermore, you can use the
\&\f(CW\*(C`add_fk_index\*(C'\fR parser parameter to prevent the parser from creating an index for each
\&\s-1FK.\s0
.SS "deployment_statements"
.IX Subsection "deployment_statements"
.ie n .IP "Arguments: See ""deployment_statements"" in DBIx::Class::Storage::DBI" 4
.el .IP "Arguments: See ``deployment_statements'' in DBIx::Class::Storage::DBI" 4
.IX Item "Arguments: See deployment_statements in DBIx::Class::Storage::DBI"
.PD 0
.ie n .IP "Return Value: $listofstatements" 4
.el .IP "Return Value: \f(CW$listofstatements\fR" 4
.IX Item "Return Value: $listofstatements"
.PD
.PP
A convenient shortcut to
\&\f(CW\*(C`$self\->storage\->deployment_statements($self, @args)\*(C'\fR.
Returns the \s-1SQL\s0 statements used by \*(L"deploy\*(R" and
\&\*(L"deploy\*(R" in DBIx::Class::Schema::Storage.
.SS "create_ddl_dir"
.IX Subsection "create_ddl_dir"
.ie n .IP "Arguments: See ""create_ddl_dir"" in DBIx::Class::Storage::DBI" 4
.el .IP "Arguments: See ``create_ddl_dir'' in DBIx::Class::Storage::DBI" 4
.IX Item "Arguments: See create_ddl_dir in DBIx::Class::Storage::DBI"
.PP
A convenient shortcut to
\&\f(CW\*(C`$self\->storage\->create_ddl_dir($self, @args)\*(C'\fR.
.PP
Creates an \s-1SQL\s0 file based on the Schema, for each of the specified
database types, in the given directory.
.SS "ddl_filename"
.IX Subsection "ddl_filename"
.ie n .IP "Arguments: $database\-type, $version, $directory, $preversion" 4
.el .IP "Arguments: \f(CW$database\fR\-type, \f(CW$version\fR, \f(CW$directory\fR, \f(CW$preversion\fR" 4
.IX Item "Arguments: $database-type, $version, $directory, $preversion"
.PD 0
.ie n .IP "Return Value: $normalised_filename" 4
.el .IP "Return Value: \f(CW$normalised_filename\fR" 4
.IX Item "Return Value: $normalised_filename"
.PD
.PP
.Vb 1
\&  my $filename = $table\->ddl_filename($type, $version, $dir, $preversion)
.Ve
.PP
This method is called by \f(CW\*(C`create_ddl_dir\*(C'\fR to compose a file name out of
the supplied directory, database type and version number. The default file
name format is: \f(CW\*(C`$dir$schema\-$version\-$type.sql\*(C'\fR.
.PP
You may override this method in your schema if you wish to use a different
format.
.PP
.Vb 1
\& WARNING
\&
\& Prior to DBIx::Class version 0.08100 this method had a different signature:
\&
\&    my $filename = $table\->ddl_filename($type, $dir, $version, $preversion)
\&
\& In recent versions variables $dir and $version were reversed in order to
\& bring the signature in line with other Schema/Storage methods. If you
\& really need to maintain backward compatibility, you can do the 