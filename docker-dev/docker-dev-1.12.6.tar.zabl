ockIndex     = -1   // index of LOCK prefix in src and inst.Prefix
		repIndex      = -1   // index of REP/REPN prefix in src and inst.Prefix
		segIndex      = -1   // index of Group 2 prefix in src and inst.Prefix
		dataSizeIndex = -1   // index of Group 3 prefix in src and inst.Prefix
		addrSizeIndex = -1   // index of Group 4 prefix in src and inst.Prefix
		rex           Prefix // rex byte if present (or 0)
		rexUsed       Prefix // bits used in rex byte
		rexIndex      = -1   // index of rex byte

		addrMode = mode // address mode (width in bits)
		dataMode = mode // operand mode (width in bits)

		// decoded ModR/M fields
		haveModrm bool
		modrm     int
		mod       int
		regop     int
		rm        int

		// if ModR/M is memory reference, Mem form
		mem     Mem
		haveMem bool

		// decoded SIB fields
		haveSIB bool
		sib     int
		scale   int
		index   int
		base    int
		displen int
		dispoff int

		// decoded immediate values
		imm     int64
		imm8    int8
		immc    int64
		immcpos int

		// output
		opshift int
		inst    Inst
		narg    int // number of arguments written to inst
	)

	if mode == 64 {
		dataMode = 32
	}

	// Prefixes are certainly the most complex and underspecified part of
	// decoding x86 instructions. Although the manuals say things like
	// up to four prefixes, one from each group, nearly everyone seems to
	// agree that in practice as many prefixes as possible, including multiple
	// from a particular group or repetitions of a given prefix, can be used on
	// an instruction, provided the total instruction length including prefixes
	// does not exceed the agreed-upon maximum of 15 bytes.
	// Everyone also agrees that if one of these prefixes is the LOCK prefix
	// and the instruction is not one of the instructions that can be used with
	// the LOCK prefix or if the destination is not a memory operand,
	// then the instruction is invalid and produces the #UD exception.
	// However, that is the end of any semblance of agreement.
	//
	// What happens if prefixes are given that conflict with other prefixes?
	// For example, the memory segment overrides CS, DS, ES, FS, GS, SS
	// conflict with each other: only one segment can be in effect.
	// Disassemblers seem to agree that later prefixes take priority over
	// earlier ones. I have not taken the time to write assembly programs
	// to check to see if the hardware agrees.
	//
	// What happens if prefixes are given that have no meaning for the
	// specific instruction to which they are attached? It depends.
	// If they really have no meaning, they are ignored. However, a future
	// processor may assign a different meaning. As a disassembler, we
	// don't really know whether we're seeing a meaningless prefix or one
	// whose meaning we simply haven't been told yet.
	//
	// Combining the two questions, what happens when conflicting
	// extension prefixes are given? No one seems to know for sure.
	// For example, MOVQ is 66 0F D6 /r, MOVDQ2Q is F2 0F D6 /r,
	// and MOVQ2DQ is F3 0F D6 /r. What is '66 F2 F3 0F D6 /r'?
	// Which prefix wins? See the xCondPrefix prefix for more.
	//
	// Writing assembly test cases to divine which interpretation the
	// CPU uses might clarify the situation, but more likely it would
	// make the situation even less clear.

	// Read non-REX prefixes.
ReadPrefixes:
	for ; pos < len(src); pos++ {
		p := Prefix(src[pos])
		switch p {
		default:
			nprefix = pos
			break ReadPrefixes

		// Group 1 - lock and repeat prefixes
		// According to Intel, there should only be one from this set,
		// but according to AMD both can be present.
		case 0xF0:
			if lockIndex >= 0 {
				inst.Prefix[lockIndex] |= PrefixIgnored
			}
			lockIndex = pos
		case 0xF2, 0xF3:
			if repIndex >= 0 {
				inst.Prefix[repIndex] |= PrefixIgnored
			}
			repIndex = pos

		// Group 2 - segment override / branch hints
		case 0x26, 0x2E, 0x36, 0x3E:
			if mode == 64 {
				p |= PrefixIgnored
				break
			}
			fallthrough
		case 0x64, 0x65:
			if segIndex >= 0 {
				inst.Prefix[segIndex] |= PrefixIgnored
			}
			segIndex = pos

		// Group 3 - operand size override
		case 0x66:
			if mode == 16 {
				dataMode = 32
				p = PrefixData32
			} else {
				dataMode = 16
				p = PrefixData16
			}
			if dataSizeIndex >= 0 {
				inst.Prefix[dataSizeIndex] |= PrefixIgnored
			}
			dataSizeIndex = pos

		// Group 4 - address size override
		case 0x67:
			if mode == 32 {
				addrMode = 16
				p = PrefixAddr16
			} else {
				addrMode = 32
				p = PrefixAddr32
			}
			if addrSizeIndex >= 0 {
				inst.Prefix[addrSizeIndex] |= PrefixIgnored
			}
			addrSizeIndex = pos
		}

		if pos >= len(inst.Prefix) {
			return instPrefix(src[0], mode) // too long
		}

		inst.Prefix[pos] = p
	}

	// Read REX prefix.
	if pos < len(src) && mode == 64 && Prefix(src[pos]).IsREX() {
		rex = Prefix(src[pos])
		rexIndex = pos
		if pos >= len(inst.Prefix) {
			return instPrefix(src[0], mode) // too long
		}
		inst.Prefix[pos] = rex
		pos++
		if rex&PrefixREXW != 0 {
			dataMode = 64
			if dataSizeIndex >= 0 {
				inst.Prefix[dataSizeIndex] |= PrefixIgnored
			}
		}
	}

	// Decode instruction stream, interpreting decoding instructions.
	// opshift gives the shift to use when saving the next
	// opcode byte into inst.Opcode.
	opshift = 24
	if decoderCover == nil {
		decoderCover = make([]bool, len(decoder))
	}

	// Decode loop, executing decoder program.
	var oldPC, prevPC int
Decode:
	for pc := 1; ; { // TODO uint
		oldPC = prevPC
		prevPC = pc
		if trace {
			println("run", pc)
		}
		x := decoder[pc]
		decoderCover[pc] = true
		pc++

		// Read and decode ModR/M if needed by opcode.
		switch decodeOp(x) {
		case xCondSlashR, xReadSlashR:
			if haveModrm {
				return Inst{Len: pos}, errInternal
			}
			haveModrm = true
			if pos >= len(src) {
				return truncated(src, mode)
			}
			modrm = int(src[pos])
			pos++
			if opshift >= 0 {
				inst.Opcode |= uint32(modrm) << uint(opshift)
				opshift -= 8
			}
			mod = modrm >> 6
			regop = (modrm >> 3) & 07
			rm = modrm & 07
			if rex&PrefixREXR != 0 {
				rexUsed |= PrefixREXR
				regop |= 8
			}
			if addrMode == 16 {
				// 16-bit modrm form
				if mod != 3 {
					haveMem = true
					mem = addr16[rm]
					if rm == 6 && mod == 0 {
						mem.Base = 0
					}

					// Consume disp16 if present.
					if mod == 0 && rm == 6 || mod == 2 {
						if pos+2 > len(src) {
							return truncated(src, mode)
						}
						mem.Disp = int64(binary.LittleEndian.Uint16(src[pos:]))
						pos += 2
					}

					// Consume disp8 if present.
					if mod == 1 {
						if pos >= len(src) {
							return truncated(src, mode)
						}
						mem.Disp = int64(int8(src[pos]))
						pos++
					}
				}
			} else {
				haveMem = mod != 3

				// 32-bit or 64-bit form
				// Consume SIB encoding if present.
				if rm == 4 && mod != 3 {
					haveSIB = true
					if pos >= len(src) {
						return truncated(src, mode)
					}
					sib = int(src[pos])
					pos++
					if opshift >= 0 {
						inst.Opcode |= uint32(sib) << uint(opshift)
						opshift -= 8
					}
					scale = sib >> 6
					index = (sib >> 3) & 07
					base = sib & 07
					if rex&PrefixREXB != 0 {
						rexUsed |= PrefixREXB
						base |= 8
					}
					if rex&PrefixREXX != 0 {
						rexUsed |= PrefixREXX
						index |= 8
					}

					mem.Scale = 1 << uint(scale)
					if index == 4 {
						// no mem.Index
					} else {
						mem.Index = baseRegForBits(addrMode) + Reg(index)
					}
					if base&7 == 5 && mod == 0 {
						// no mem.Base
					} else {
						mem.Base = baseRegForBits(addrMode) + Reg(base)
					}
				} else {
					if rex&PrefixREXB != 0 {
						rexUsed |= PrefixREXB
						rm |= 8
					}
					if mod == 0 && rm&7 == 5 || rm&7 == 4 {
						// base omitted
					} else if mod != 3 {
						mem.Base = baseRegForBits(addrMode) + Reg(rm)
					}
				}

				// Consume disp32 if present.
				if mod == 0 && (rm&7 == 5 || haveSIB && base&7 == 5) || mod == 2 {
					if pos+4 > len(src) {
						return truncated(src, mode)
					}
					dispoff = pos
					displen = 4
					mem.Disp = int64(binary.LittleEndian.Uint32(src[pos:]))
					pos += 4
				}

				// Consume disp8 if present.
				if mod == 1 {
					if pos >= len(src) {
						return truncated(src, mode)
					}
					dispoff = pos
					displen = 1
					mem.Disp = int64(int8(src[pos]))
					pos++
				}

				// In 64-bit, mod=0 rm=5 is PC-relative instead of just disp.
				// See Vol 2A. Table 2-7.
				if mode == 64 && mod == 0 && rm&7 == 5 {
					if addrMode == 32 {
						mem.Base = EIP
					} else {
						mem.Base = RIP
					}
				}
			}

			if segIndex >= 0 {
				mem.Segment = prefixToSegment(inst.Prefix[segIndex])
			}
		}

		// Execute single opcode.
		switch decodeOp(x) {
		default:
			println("bad op", x, "at", pc-1, "from", oldPC)
			return Inst{Len: pos}, errInternal

		case xFail:
			inst.Op = 0
			break Decode

		case xMatch:
			break Decode

		case xJump:
			pc = int(decoder[pc])

		// Conditional branches.

		case xCondByte:
			if pos >= len(src) {
				return truncated(src, mode)
			}
			b := src[pos]
			n := int(decoder[pc])
			pc++
			for i := 0; i < n; i++ {
				xb, xpc := decoder[pc], int(decoder[pc+1])
				pc += 2
				if b == byte(xb) {
					pc = xpc
					pos++
					if opshift >= 0 {
						inst.Opcode |= uint32(b) << uint(opshift)
						opshift -= 8
					}
					continue Decode
				}
			}
			// xCondByte is the only conditional with a fall through,
			// so that it can be used to pick off special cases before
			// an xCondSlash. If the fallthrough instruction is xFail,
			// advance the position so that the decoded instruction
			// size includes the byte we just compared against.
			if decodeOp(decoder[pc]) == xJump {
				pc = int(decoder[pc+1])
			}
			if decodeOp(decoder[pc]) == xFail {
				pos++
			}

		case xCondIs64:
			if mode == 64 {
				pc = int(decoder[pc+1])
			} else {
				pc = int(decoder[pc])
			}

		case xCondIsMem:
			mem := haveMem
			if !haveModrm {
				if pos >= len(src) {
					return instPrefix(src[0], mode) // too long
				}
				mem = src[pos]>>6 != 3
			}
			if mem {
				pc = int(decoder[pc+1])
			} else {
				pc = int(decoder[pc])
			}

		case xCondDataSize:
			switch dataMode {
			case 16:
				if dataSizeIndex >= 0 {
					inst.Prefix[dataSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc])
			case 32:
				if dataSizeIndex >= 0 {
					inst.Prefix[dataSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc+1])
			case 64:
				rexUsed |= PrefixREXW
				pc = int(decoder[pc+2])
			}

		case xCondAddrSize:
			switch addrMode {
			case 16:
				if addrSizeIndex >= 0 {
					inst.Prefix[addrSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc])
			case 32:
				if addrSizeIndex >= 0 {
					inst.Prefix[addrSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc+1])
			case 64:
				pc = int(decoder[pc+2])
			}

		case xCondPrefix:
			// Conditional branch based on presence or absence of prefixes.
			// The conflict cases here are completely undocumented and
			// differ significantly between GNU libopcodes and Intel xed.
			// I have not written assembly code to divine what various CPUs
			// do, but it wouldn't surprise me if they are not consistent either.
			//
			// The basic idea is to switch on the presence of a prefix, so that
			// for example:
			//
			//	xCondPrefix, 4
			//	0xF3, 123,
			//	0xF2, 234,
			//	0x66, 345,
			//	0, 456
			//
			// branch to 123 if the F3 prefix is present, 234 if the F2 prefix
			// is present, 66 if the 345 prefix is present, and 456 otherwise.
			// The prefixes are given in descending order so that the 0 will be last.
			//
			// It is unclear what should happen if multiple conditions are
			// satisfied: what if F2 and F3 are both present, or if 66 and F2
			// are present, or if all three are present? The one chosen becomes
			// part of the opcode and the others do not. Perhaps the answer
			// depends on the specific opcodes in question.
			//
			// The only clear example is that CRC32 is F2 0F 38 F1 /r, and
			// it comes in 16-bit and 32-bit forms based on the 66 prefix,
			// so 66 F2 0F 38 F1 /r should be treated as F2 taking priority,
			// with the 66 being only an operand size override, and probably
			// F2 66 0F 38 F1 /r should be treated the same.
			// Perhaps that rule is specific to the case of CRC32, since no
			// 66 0F 38 F1 instruction is defined (today) (that we know of).
			// However, both libopcodes and xed seem to generalize this
			// example and choose F2/F3 in preference to 66, and we
			// do the same.
			//
			// Next, what if both F2 and F3 are present? Which wins?
			// The Intel xed rule, and ours, is that the one that occurs last wins.
			// The GNU libopcodes rule, which we implement only in gnuCompat mode,
			// is that F3 beats F2 unless F3 has no special meaning, in which
			// case F3 can be a modified on an F2 special meaning.
			//
			// Concretely,
			//	66 0F D6 /r is MOVQ
			//	F2 0F D6 /r is MOVDQ2Q
			//	F3 0F D6 /r is MOVQ2DQ.
			//
			//	F2 66 0F D6 /r is 66 + MOVDQ2Q always.
			//	66 F2 0F D6 /r is 66 + MOVDQ2Q always.
			//	F3 66 0F D6 /r is 66 + MOVQ2DQ always.
			//	66 F3 0F D6 /r is 66 + MOVQ2DQ always.
			//	F2 F3 0F D6 /r is F2 + MOVQ2DQ always.
			//	F3 F2 0F D6 /r is F3 + MOVQ2DQ in Intel xed, but F2 + MOVQ2DQ in GNU libopcodes.
			//	Adding 66 anywhere in the prefix section of the
			//	last two cases does not change the outcome.
			//
			// Finally, what if there is a variant in which 66 is a mandatory
			// prefix rather than an operand size override, but we know of
			// no corresponding F2/F3 form, and we see both F2/F3 and 66.
			// Does F2/F3 still take priority, so that the result is an unknown
			// instruction, or does the 66 take priority, so that the extended
			// 66 instruction should be interpreted as having a REP/REPN prefix?
			// Intel xed does the former and GNU libopcodes does the latter.
			// We side with Intel xed, unless we are trying to match libopcodes
			// more closely during the comparison-based test suite.
			//
			// In 64-bit mode REX.W is another valid prefix to test for, but
			// there is less ambiguity about that. When present, REX.W is
			// always the first entry in the table.
			n := int(decoder[pc])
			pc++
			sawF3 := false
			for j := 0; j < n; j++ {
				prefix := Prefix(decoder[pc+2*j])
				if prefix.IsREX() {
					rexUsed |= prefix
					if rex&prefix == prefix {
						pc = int(decoder[pc+2*j+1])
						continue Decode
					}
					continue
				}
				ok := false
				if prefix == 0 {
					ok = true
				} else if prefix.IsREX() {
					rexUsed |= prefix
					if rex&prefix == prefix {
						ok = true
					}
				} else {
					if prefix == 0xF3 {
						sawF3 = true
					}
					switch prefix {
					case PrefixLOCK:
						if lockIndex >= 0 {
							inst.Prefix[lockIndex] |= PrefixImplicit
							ok = true
						}
					case PrefixREP, PrefixREPN:
						if repIndex >= 0 && inst.Prefix[repIndex]&0xFF == prefix {
							inst.Prefix[repIndex] |= PrefixImplicit
							ok = true
						}
						if gnuCompat && !ok && prefix == 0xF3 && repIndex >= 0 && (j+1 >= n || decoder[pc+2*(j+1)] != 0xF2) {
							// Check to see if earlier prefix F3 is present.
							for i := repIndex - 1; i >= 0; i-- {
								if inst.Prefix[i]&0xFF == prefix {
									inst.Prefix[i] |= PrefixImplicit
									ok = true
								}
							}
						}
						if gnuCompat && !ok && prefix == 0xF2 && repIndex >= 0 && !sawF3 && inst.Prefix[repIndex]&0xFF == 0xF3 {
							// Check to see if earlier prefix F2 is present.
							for i := repIndex - 1; i >= 0; i-- {
								if inst.Prefix[i]&0xFF == prefix {
									inst.Prefix[i] |= PrefixImplicit
									ok = true
								}
							}
						}
					case PrefixCS, PrefixDS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
						if segIndex >= 0 && inst.Prefix[segIndex]&0xFF == prefix {
							inst.Prefix[segIndex] |= PrefixImplicit
							ok = true
						}
					case PrefixDataSize:
						// Looking for 66 mandatory prefix.
						// The F2/F3 mandatory prefixes take priority when both are present.
						// If we got this far in the xCondPrefix table and an F2/F3 is present,
						// it means the table didn't have any entry for that prefix. But if 66 has
						// special meaning, perhaps F2/F3 have special meaning that we don't know.
						// Intel xed works this way, treating the F2/F3 as inhibiting the 66.
						// GNU libopcodes allows the 66 to match. We do what Intel xed does
						// except in gnuCompat mode.
						if repIndex >= 0 && !gnuCompat {
							inst.Op = 0
							break Decode
						}
						if dataSizeIndex >= 0 {
							inst.Prefix[dataSizeIndex] |= PrefixImplicit
							ok = true
						}
					case PrefixAddrSize:
						if addrSizeIndex >= 0 {
							inst.Prefix[addrSizeIndex] |= PrefixImplicit
							ok = true
						}
					}
				}
				if ok {
					pc = int(decoder[pc+2*j+1])
					continue Decode
				}
			}
			inst.Op = 0
			break Decode

		case xCondSlashR:
			pc = int(decoder[pc+regop&7])

		// Input.

		case xReadSlashR:
			// done above

		case xReadIb:
			if pos >= len(src) {
				return truncated(src, mode)
			}
			imm8 = int8(src[pos])
			pos++

		case xReadIw:
			if pos+2 > len(src) {
				return truncated(src, mode)
			}
			imm = int64(binary.LittleEndian.Uint16(src[pos:]))
			pos += 2

		case xReadId:
			if pos+4 > len(src) {
				return truncated(src, mode)
			}
			imm = int64(binary.LittleEndian.Uint32(src[pos:]))
			pos += 4

		case xReadIo:
			if pos+8 > len(src) {
				return truncated(src, mode)
			}
			imm = int64(binary.LittleEndian.Uint64(src[pos:]))
			pos += 8

		case xReadCb:
			if pos >= len(src) {
				return truncated(src, mode)
			}
			immcpos = pos
			immc = int64(src[pos])
			pos++

		case xReadCw:
			if pos+2 > len(src) {
				return truncated(src, mode)
			}
			immcpos = pos
			immc = int64(binary.LittleEndian.Uint16(src[pos:]))
			pos += 2

		case xReadCm:
			immcpos = pos
			if addrMode == 16 {
				if pos+2 > len(src) {
					return truncated(src, mode)
				}
				immc = int64(binary.LittleEndian.Uint16(src[pos:]))
				pos += 2
			} else if addrMode == 32 {
				if pos+4 > len(src) {
					return truncated(src, mode)
				}
				immc = int64(binary.LittleEndian.Uint32(src[pos:]))
				pos += 4
			} else {
				if pos+8 > len(src) {
					return truncated(src, mode)
				}
				immc = int64(binary.LittleEndian.Uint64(src[pos:]))
				pos += 8
			}
		case xReadCd:
			immcpos = pos
			if pos+4 > len(src) {
				return truncated(src, mode)
			}
			immc = int64(binary.LittleEndian.Uint32(src[pos:]))
			pos += 4

		case xReadCp:
			immcpos = pos
			if pos+6 > len(src) {
				return truncated(src, mode)
			}
			w := binary.LittleEndian.Uint32(src[pos:])
			w2 := binary.LittleEndian.Uint16(src[pos+4:])
			immc = int64(w2)<<32 | int64(w)
			pos += 6

		// Output.

		case xSetOp:
			inst.Op = Op(decoder[pc])
			pc++

		case xArg1,
			xArg3,
			xArgAL,
			xArgAX,
			xArgCL,
			xArgCS,
			xArgDS,
			xArgDX,
			xArgEAX,
			xArgEDX,
			xArgES,
			xArgFS,
			xArgGS,
			xArgRAX,
			xArgRDX,
			xArgSS,
			xArgST,
			xArgXMM0:
			inst.Args[narg] = fixedArg[x]
			narg++

		case xArgImm8:
			inst.Args[narg] = Imm(imm8)
			narg++

		case xArgImm8u:
			inst.Args[narg] = Imm(uint8(imm8))
			narg++

		case xArgImm16:
			inst.Args[narg] = Imm(int16(imm))
			narg++

		case xArgImm16u:
			inst.Args[narg] = Imm(uint16(imm))
			narg++

		case xArgImm32:
			inst.Args[narg] = Imm(int32(imm))
			narg++

		case xArgImm64:
			inst.Args[narg] = Imm(imm)
			narg++

		case xArgM,
			xArgM128,
			xArgM1428byte,
			xArgM16,
			xArgM16and16,
			xArgM16and32,
			xArgM16and64,
			xArgM16colon16,
			xArgM16colon32,
			xArgM16colon64,
			xArgM16int,
			xArgM2byte,
			xArgM32,
			xArgM32and32,
			xArgM32fp,
			xArgM32int,
			xArgM512byte,
			xArgM64,
			xArgM64fp,
			xArgM64int,
			xArgM8,
			xArgM80bcd,
			xArgM80dec,
			xArgM80fp,
			xArgM94108byte,
			xArgMem:
			if !haveMem {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = mem
			inst.MemBytes = int(memBytes[decodeOp(x)])
			if mem.Base == RIP {
				inst.PCRel = displen
				inst.PCRelOff = dispoff
			}
			narg++

		case xArgPtr16colon16:
			inst.Args[narg] = Imm(immc >> 16)
			inst.Args[narg+1] = Imm(immc & (1<<16 - 1))
			narg += 2

		case xArgPtr16colon32:
			inst.Args[narg] = Imm(immc >> 32)
			inst.Args[narg+1] = Imm(immc & (1<<32 - 1))
			narg += 2

		case xArgMoffs8, xArgMoffs16, xArgMoffs32, xArgMoffs64:
			// TODO(rsc): Can address be 64 bits?
			mem = Mem{Disp: int64(immc)}
			if segIndex >= 0 {
				mem.Segment = prefixToSegment(inst.Prefix[segIndex])
				inst.Prefix[segIndex] |= PrefixImplicit
			}
			inst.Args[narg] = mem
			inst.MemBytes = int(memBytes[decodeOp(x)])
			if mem.Base == RIP {
				inst.PCRel = displen
				inst.PCRelOff = dispoff
			}
			narg++

		case xArgR8, xArgR16, xArgR32, xArgR64, xArgXmm, xArgXmm1, xArgDR0dashDR7:
			base := baseReg[x]
			index := Reg(regop)
			if rex != 0 && base == AL && index >= 4 {
				rexUsed |= PrefixREX
				index -= 4
				base = SPB
			}
			inst.Args[narg] = base + index
			narg++

		case xArgMm, xArgMm1, xArgTR0dashTR7:
			inst.Args[narg] = baseReg[x] + Reg(regop&7)
			narg++

		case xArgCR0dashCR7:
			// AMD documents an extension that the LOCK prefix
			// can be used in place of a REX prefix in order to access
			// CR8 from 32-bit mode. The LOCK prefix is allowed in
			// all modes, provided the corresponding CPUID bit is set.
			if lockIndex >= 0 {
				inst.Prefix[lockIndex] |= PrefixImplicit
				regop += 8
			}
			inst.Args[narg] = CR0 + Reg(regop)
			narg++

		case xArgSreg:
			regop &= 7
			if regop >= 6 {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = ES + Reg(regop)
			narg++

		case xArgRmf16, xArgRmf32, xArgRmf64:
			base := baseReg[x]
			index := Reg(modrm & 07)
			if rex&PrefixREXB != 0 {
				rexUsed |= PrefixREXB
				index += 8
			}
			inst.Args[narg] = base + index
			narg++

		case xArgR8op, xArgR16op, xArgR32op, xArgR64op, xArgSTi:
			n := inst.Opcode >> uint(opshift+8) & 07
			base := baseReg[x]
			index := Reg(n)
			if rex&PrefixREXB != 0 && decodeOp(x) != xArgSTi {
				rexUsed |= PrefixREXB
				index += 8
			}
			if rex != 0 && base == AL && index >= 4 {
				rexUsed |= PrefixREX
				index -= 4
				base = SPB
			}
			inst.Args[narg] = base + index
			narg++

		case xArgRM8, xArgRM16, xArgRM32, xArgRM64, xArgR32M16, xArgR32M8, xArgR64M16,
			xArgMmM32, xArgMmM64, xArgMm2M64,
			xArgXmm2M16, xArgXmm2M32, xArgXmm2M64, xArgXmmM64, xArgXmmM128, xArgXmmM32, xArgXmm2M128:
			if haveMem {
				inst.Args[narg] = mem
				inst.MemBytes = int(memBytes[decodeOp(x)])
				if mem.Base == RIP {
					inst.PCRel = displen
					inst.PCRelOff = dispoff
				}
			} else {
				base := baseReg[x]
				index := Reg(rm)
				switch decodeOp(x) {
				case xArgMmM32, xArgMmM64, xArgMm2M64:
					// There are only 8 MMX registers, so these ignore the REX.X bit.
					index &= 7
				case xArgRM8:
					if rex != 0 && index >= 4 {
						rexUsed |= PrefixREX
						index -= 4
						base = SPB
					}
				}
				inst.Args[narg] = base + index
			}
			narg++

		case xArgMm2: // register only; TODO(rsc): Handle with tag modrm_regonly tag
			if haveMem {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = baseReg[x] + Reg(rm&7)
			narg++

		case xArgXmm2: // register only; TODO(rsc): Handle with tag modrm_regonly tag
			if haveMem {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = baseReg[x] + Reg(rm)
			narg++

		case xArgRel8:
			inst.PCRelOff = immcpos
			inst.PCRel = 1
			inst.Args[narg] = Rel(int8(immc))
			narg++

		case xArgRel16:
			inst.PCRelOff = immcpos
			inst.PCRel = 2
			inst.Args[narg] = Rel(int16(immc))
			narg++

		case xArgRel32:
			inst.PCRelOff = immcpos
			inst.PCRel = 4
			inst.Args[narg] = Rel(int32(immc))
			narg++
		}
	}

	if inst.Op == 0 {
		// Invalid instruction.
		if nprefix > 0 {
			return instPrefix(src[0], mode) // invalid instruction
		}
		return Inst{Len: pos}, ErrUnrecognized
	}

	// Matched! Hooray!

	// 90 decodes as XCHG EAX, EAX but is NOP.
	// 66 90 decodes as XCHG AX, AX and is NOP too.
	// 48 90 decodes as XCHG RAX, RAX and is NOP too.
	// 43 90 decodes as XCHG R8D, EAX and is *not* NOP.
	// F3 90 decodes as REP XCHG EAX, EAX but is PAUSE.
	// It's all too special to handle in the decoding tables, at least for now.
	if inst.Op == XCHG && inst.Opcode>>24 == 0x90 {
		if inst.Args[0] == RAX || inst.Args[0] == EAX || inst.Args[0] == AX {
			inst.Op = NOP
			if dataSizeIndex >= 0 {
				inst.Prefix[dataSizeIndex] &^= PrefixImplicit
			}
			inst.Args[0] = nil
			inst.Args[1] = nil
		}
		if repIndex >= 0 && inst.Prefix[repIndex] == 0xF3 {
			inst.Prefix[repIndex] |= PrefixImplicit
			inst.Op = PAUSE
			inst.Args[0] = nil
			inst.Args[1] = nil
		} else if gnuCompat {
			for i := nprefix - 1; i >= 0; i-- {
				if inst.Prefix[i]&0xFF == 0xF3 {
					inst.Prefix[i] |= PrefixImplicit
					inst.Op = PAUSE
					inst.Args[0] = nil
					inst.Args[1] = nil
					break
				}
			}
		}
	}

	// defaultSeg returns the default segment for an implicit
	// memory reference: the final override if present, or else DS.
	defaultSeg := func() Reg {
		if segIndex >= 0 {
			inst.Prefix[segIndex] |= PrefixImplicit
			return prefixToSegment(inst.Prefix[segIndex])
		}
		return DS
	}

	// Add implicit arguments not present in the tables.
	// Normally we shy away from making implicit arguments explicit,
	// following the Intel manuals, but adding the arguments seems
	// the best way to express the effect of the segment override prefixes.
	// TODO(rsc): Perhaps add these to the tables and
	// create bytecode instructions for them.
	usedAddrSize := false
	switch inst.Op {
	case INSB, INSW, INSD:
		inst.Args[0] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		inst.Args[1] = DX
		usedAddrSize = true

	case OUTSB, OUTSW, OUTSD:
		inst.Args[0] = DX
		inst.Args[1] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		usedAddrSize = true

	case MOVSB, MOVSW, MOVSD, MOVSQ:
		inst.Args[0] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		inst.Args[1] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		usedAddrSize = true

	case CMPSB, CMPSW, CMPSD, CMPSQ:
		inst.Args[0] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		inst.Args[1] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		usedAddrSize = true

	case LODSB, LODSW, LODSD, LODSQ:
		switch inst.Op {
		case LODSB:
			inst.Args[0] = AL
		case LODSW:
			inst.Args[0] = AX
		case LODSD:
			inst.Args[0] = EAX
		case LODSQ:
			inst.Args[0] = RAX
		}
		inst.Args[1] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		usedAddrSize = true

	case STOSB, STOSW, STOSD, STOSQ:
		inst.Args[0] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		switch inst.Op {
		case STOSB:
			inst.Args[1] = AL
		case STOSW:
			inst.Args[1] = AX
		case STOSD:
			inst.Args[1] = EAX
		case STOSQ:
			inst.Args[1] = RAX
		}
		usedAddrSize = true

	case SCASB, SCASW, SCASD, SCASQ:
		inst.Args[1] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		switch inst.Op {
		case SCASB:
			inst.Args[0] = AL
		case SCASW:
			inst.Args[0] = AX
		case SCASD:
			inst.Args[0] = EAX
		case SCASQ:
			inst.Args[0] = RAX
		}
		usedAddrSize = true

	case XLATB:
		inst.Args[0] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + BX - AX}
		usedAddrSize = true
	}

	// If we used the address size annotation to construct the
	// argument list, mark that prefix as implicit: it doesn't need
	// to be shown when printing the instruction.
	if haveMem || usedAddrSize {
		if addrSizeIndex >= 0 {
			inst.Prefix[addrSizeIndex] |= PrefixImplicit
		}
	}

	// Similarly, if there's some memory operand, the segment
	// will be shown there and doesn't need to be shown as an
	// explicit prefix.
	if haveMem {
		if segIndex >= 0 {
			inst.Prefix[segIndex] |= PrefixImplicit
		}
	}

	// Branch predict prefixes are overloaded segment prefixes,
	// since segment prefixes don't make sense on conditional jumps.
	// Rewrite final instance to prediction prefix.
	// The set of instructions to which the prefixes apply (other then the
	// Jcc conditional jumps) is not 100% clear from the manuals, but
	// the disassemblers seem to agree about the LOOP and JCXZ instructions,
	// so we'll follow along.
	// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
	if isCondJmp[inst.Op] || isLoop[inst.Op] || inst.Op == JCXZ || inst.Op == JECXZ || inst.Op == JRCXZ {
	PredictLoop:
		for i := nprefix - 1; i >= 0; i-- {
			p := inst.Prefix[i]
			switch p & 0xFF {
			case PrefixCS:
				inst.Prefix[i] = PrefixPN
				break PredictLoop
			case PrefixDS:
				inst.Prefix[i] = PrefixPT
				break PredictLoop
			}
		}
	}

	// The BND prefix is part of the Intel Memory Protection Extensions (MPX).
	// A REPN applied to certain control transfers is a BND prefix to bound
	// the range of possible destinations. There's surprisingly little documentation
	// about this, so we just do what libopcodes and xed agree on.
	// In particular, it's unclear why a REPN applied to LOOP or JCXZ instructions
	// does not turn into a BND.
	// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
	if isCondJmp[inst.Op] || inst.Op == JMP || inst.Op == CALL || inst.Op == RET {
		for i := nprefix - 1; i >= 0; i-- {
			p := inst.Prefix[i]
			if p&^PrefixIgnored == PrefixREPN {
				inst.Prefix[i] = PrefixBND
				break
			}
		}
	}

	// The LOCK prefix only applies to certain instructions, and then only
	// to instances of the instruction with a memory destination.
	// Other uses of LOCK are invalid and cause a processor exception,
	// in contrast to the "just ignore it" spirit applied to all other prefixes.
	// Mark invalid lock prefixes.
	hasLock := false
	if lockIndex >= 0 && inst.Prefix[lockIndex]&PrefixImplicit == 0 {
		switch inst.Op {
		// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
		case ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG:
			if isMem(inst.Args[0]) {
				hasLock = true
				break
			}
			fallthrough
		default:
			inst.Prefix[lockIndex] |= PrefixInvalid
		}
	}

	// In certain cases, all of which require a memory destination,
	// the REPN and REP prefixes are interpreted as XACQUIRE and XRELEASE
	// from the Intel Transactional Synchroniation Extensions (TSX).
	//
	// The specific rules are:
	// (1) Any instruction with a valid LOCK prefix can have XACQUIRE or XRELEASE.
	// (2) Any XCHG, which always has an implicit LOCK, can have XACQUIRE or XRELEASE.
	// (3) Any 0x88-, 0x89-, 0xC6-, or 0xC7-opcode MOV can have XRELEASE.
	if isMem(inst.Args[0]) {
		if inst.Op == XCHG {
			hasLock = true
		}

		for i := len(inst.Prefix) - 1; i >= 0; i-- {
			p := inst.Prefix[i] &^ PrefixIgnored
			switch p {
			case PrefixREPN:
				if hasLock {
					inst.Prefix[i] = inst.Prefix[i]&PrefixIgnored | PrefixXACQUIRE
				}

			case PrefixREP:
				if hasLock {
					inst.Prefix[i] = inst.Prefix[i]&PrefixIgnored | PrefixXRELEASE
				}

				if inst.Op == MOV {
					op := (inst.Opcode >> 24) &^ 1
					if op == 0x88 || op == 0xC6 {
						inst.Prefix[i] = inst.Prefix[i]&PrefixIgnored | PrefixXRELEASE
					}
				}
			}
		}
	}

	// If REP is used on a non-REP-able instruction, mark the prefix as ignored.
	if repIndex >= 0 {
		switch inst.Prefix[repIndex] {
		case PrefixREP, PrefixREPN:
			switch inst.Op {
			// According to the manuals, the REP/REPE prefix applies to all of these,
			// while the REPN applies only to some of them. However, both libopcodes
			// and xed show both prefixes explicitly for all instructions, so we do the same.
			// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
			case INSB, INSW, INSD,
				MOVSB, MOVSW, MOVSD, MOVSQ,
				OUTSB, OUTSW, OUTSD,
				LODSB, LODSW, LODSD, LODSQ,
				CMPSB, CMPSW, CMPSD, CMPSQ,
				SCASB, SCASW, SCASD, SCASQ,
				STOSB, STOSW, STOSD, STOSQ:
				// ok
			default:
				inst.Prefix[repIndex] |= PrefixIgnored
			}
		}
	}

	// If REX was present, mark implicit if all the 1 bits were consumed.
	if rexIndex >= 0 {
		if rexUsed != 0 {
			rexUsed |= PrefixREX
		}
		if rex&^rexUsed == 0 {
			inst.Prefix[rexIndex] |= PrefixImplicit
		}
	}

	inst.DataSize = dataMode
	inst.AddrSize = addrMode
	inst.Mode = mode
	inst.Len = pos
	return inst, nil
}

var errInternal = errors.New("internal error")

// addr16 records the eight 16-bit addressing modes.
var addr16 = [8]Mem{
	{Base: BX, Scale: 1, Index: SI},
	{Base: BX, Scale: 1, Index: DI},
	{Base: BP, Scale: 1, Index: SI},
	{Base: BP, Scale: 1, Index: DI},
	{Base: SI},
	{Base: DI},
	{Base: BP},
	{Base: BX},
}

// baseReg returns the base register for a given register size in bits.
func baseRegForBits(bits int) Reg {
	switch bits {
	case 8:
		return AL
	case 16:
		return AX
	case 32:
		return EAX
	case 64:
		return RAX
	}
	return 0
}

// baseReg records the base register for argument types that specify
// a range of registers indexed by op, regop, or rm.
var baseReg = [...]Reg{
	xArgDR0dashDR7: DR0,
	xArgMm1:        M0,
	xArgMm2:        M0,
	xArgMm2M64:     M0,
	xArgMm:         M0,
	xArgMmM32:      M0,
	xArgMmM64:      M0,
	xArgR16:        AX,
	xArgR16op:      AX,
	xArgR32:        EAX,
	xArgR32M16:     EAX,
	xArgR32M8:      EAX,
	xArgR32op:      EAX,
	xArgR64:        RAX,
	xArgR64M16:     RAX,
	xArgR64op:      RAX,
	xArgR8:         AL,
	xArgR8op:       AL,
	xArgRM16:       AX,
	xArgRM32:       EAX,
	xArgRM64:       RAX,
	xArgRM8:        AL,
	xArgRmf16:      AX,
	xArgRmf32:      EAX,
	xArgRmf64:      RAX,
	xArgSTi:        F0,
	xArgTR0dashTR7: TR0,
	xArgXmm1:       X0,
	xArgXmm2:       X0,
	xArgXmm2M128:   X0,
	xArgXmm2M16:    X0,
	xArgXmm2M32:    X0,
	xArgXmm2M64:    X0,
	xArgXmm:        X0,
	xArgXmmM128:    X0,
	xArgXmmM32:     X0,
	xArgXmmM64:     X0,
}

// prefixToSegment returns the segment register
// corresponding to a particular segment prefix.
func prefixToSegment(p Prefix) Reg {
	switch p &^ PrefixImplicit {
	case PrefixCS:
		return CS
	case PrefixDS:
		return DS
	case PrefixES:
		return ES
	case PrefixFS:
		return FS
	case PrefixGS:
		return GS
	case PrefixSS:
		return SS
	}
	return 0
}

// fixedArg records the fixed arguments corresponding to the given bytecodes.
var fixedArg = [...]Arg{
	xArg1:    Imm(1),
	xArg3:    Imm(3),
	xArgAL:   AL,
	xArgAX:   AX,
	xArgDX:   DX,
	xArgEAX:  EAX,
	xArgEDX:  EDX,
	xArgRAX:  RAX,
	xArgRDX:  RDX,
	xArgCL:   CL,
	xArgCS:   CS,
	xArgDS:   DS,
	xArgES:   ES,
	xArgFS:   FS,
	xArgGS:   GS,
	xArgSS:   SS,
	xArgST:   F0,
	xArgXMM0: X0,
}

// memBytes records the size of the memory pointed at
// by a memory argument of the given form.
var memBytes = [...]int8{
	xArgM128:       128 / 8,
	xArgM16:        16 / 8,
	xArgM16and16:   (16 + 16) / 8,
	xArgM16colon16: (16 + 16) / 8,
	xArgM16colon32: (16 + 32) / 8,
	xArgM16int:     16 / 8,
	xArgM2byte:     2,
	xArgM32:        32 / 8,
	xArgM32and32:   (32 + 32) / 8,
	xArgM32fp:      32 / 8,
	xArgM32int:     32 / 8,
	xArgM64:        64 / 8,
	xArgM64fp:      64 / 8,
	xArgM64int:     64 / 8,
	xArgMm2M64:     64 / 8,
	xArgMmM32:      32 / 8,
	xArgMmM64:      64 / 8,
	xArgMoffs16:    16 / 8,
	xArgMoffs32:    32 / 8,
	xArgMoffs64:    64 / 8,
	xArgMoffs8:     8 / 8,
	xArgR32M16:     16 / 8,
	xArgR32M8:      8 / 8,
	xArgR64M16:     16 / 8,
	xArgRM16:       16 / 8,
	xArgRM32:       32 / 8,
	xArgRM64:       64 / 8,
	xArgRM8:        8 / 8,
	xArgXmm2M128:   128 / 8,
	xArgXmm2M16:    16 / 8,
	xArgXmm2M32:    32 / 8,
	xArgXmm2M64:    64 / 8,
	xArgXmm:        128 / 8,
	xArgXmmM128:    128 / 8,
	xArgXmmM32:     32 / 8,
	xArgXmmM64:     64 / 8,
}

// isCondJmp records the conditional jumps.
var isCondJmp = [maxOp + 1]bool{
	JA:  true,
	JAE: true,
	JB:  true,
	JBE: true,
	JE:  true,
	JG:  true,
	JGE: true,
	JL:  true,
	JLE: true,
	JNE: true,
	JNO: true,
	JNP: true,
	JNS: true,
	JO:  true,
	JP:  true,
	JS:  true,
}

// isLoop records the loop operators.
var isLoop = [maxOp + 1]bool{
	LOOP:   true,
	LOOPE:  true,
	LOOPNE: true,
	JECXZ:  true,
	JRCXZ:  true,
}
                                                                                                                                                                                                                                                                                                                                                      usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/decode_test.go                  0100644 0000000 0000000 00000003147 13020111411 026355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"encoding/hex"
	"io/ioutil"
	"strconv"
	"strings"
	"testing"
)

func TestDecode(t *testing.T) {
	data, err := ioutil.ReadFile("testdata/decode.txt")
	if err != nil {
		t.Fatal(err)
	}
	all := string(data)
	for strings.Contains(all, "\t\t") {
		all = strings.Replace(all, "\t\t", "\t", -1)
	}
	for _, line := range strings.Split(all, "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		f := strings.SplitN(line, "\t", 4)
		i := strings.Index(f[0], "|")
		if i < 0 {
			t.Errorf("parsing %q: missing | separator", f[0])
			continue
		}
		if i%2 != 0 {
			t.Errorf("parsing %q: misaligned | separator", f[0])
		}
		size := i / 2
		code, err := hex.DecodeString(f[0][:i] + f[0][i+1:])
		if err != nil {
			t.Errorf("parsing %q: %v", f[0], err)
			continue
		}
		mode, err := strconv.Atoi(f[1])
		if err != nil {
			t.Errorf("invalid mode %q in: %s", f[1], line)
			continue
		}
		syntax, asm := f[2], f[3]
		inst, err := Decode(code, mode)
		var out string
		if err != nil {
			out = "error: " + err.Error()
		} else {
			switch syntax {
			case "gnu":
				out = GNUSyntax(inst)
			case "intel":
				out = IntelSyntax(inst)
			case "plan9": // [sic]
				out = GoSyntax(inst, 0, nil)
			default:
				t.Errorf("unknown syntax %q", syntax)
				continue
			}
		}
		if out != asm || inst.Len != size {
			t.Errorf("Decode(%s) [%s] = %s, %d, want %s, %d", f[0], syntax, out, inst.Len, asm, size)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                         usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/ext_test.go                     0100644 0000000 0000000 00000050172 13020111411 025732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Support for testing against external disassembler program.

package x86asm

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
	"testing"
	"time"
)

var (
	printTests = flag.Bool("printtests", false, "print test cases that exercise new code paths")
	dumpTest   = flag.Bool("dump", false, "dump all encodings")
	mismatch   = flag.Bool("mismatch", false, "log allowed mismatches")
	longTest   = flag.Bool("long", false, "long test")
	keep       = flag.Bool("keep", false, "keep object files around")
	debug      = false
)

// A ExtInst represents a single decoded instruction parsed
// from an external disassembler's output.
type ExtInst struct {
	addr uint32
	enc  [32]byte
	nenc int
	text string
}

func (r ExtInst) String() string {
	return fmt.Sprintf("%#x: % x: %s", r.addr, r.enc, r.text)
}

// An ExtDis is a connection between an external disassembler and a test.
type ExtDis struct {
	Arch     int
	Dec      chan ExtInst
	File     *os.File
	Size     int
	KeepFile bool
	Cmd      *exec.Cmd
}

// Run runs the given command - the external disassembler - and returns
// a buffered reader of its standard output.
func (ext *ExtDis) Run(cmd ...string) (*bufio.Reader, error) {
	if *keep {
		log.Printf("%s\n", strings.Join(cmd, " "))
	}
	ext.Cmd = exec.Command(cmd[0], cmd[1:]...)
	out, err := ext.Cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("stdoutpipe: %v", err)
	}
	if err := ext.Cmd.Start(); err != nil {
		return nil, fmt.Errorf("exec: %v", err)
	}

	b := bufio.NewReaderSize(out, 1<<20)
	return b, nil
}

// Wait waits for the command started with Run to exit.
func (ext *ExtDis) Wait() error {
	return ext.Cmd.Wait()
}

// testExtDis tests a set of byte sequences against an external disassembler.
// The disassembler is expected to produce the given syntax and be run
// in the given architecture mode (16, 32, or 64-bit).
// The extdis function must start the external disassembler
// and then parse its output, sending the parsed instructions on ext.Dec.
// The generate function calls its argument f once for each byte sequence
// to be tested. The generate function itself will be called twice, and it must
// make the same sequence of calls to f each time.
// When a disassembly does not match the internal decoding,
// allowedMismatch determines whether this mismatch should be
// allowed, or else considered an error.
func testExtDis(
	t *testing.T,
	syntax string,
	arch int,
	extdis func(ext *ExtDis) error,
	generate func(f func([]byte)),
	allowedMismatch func(text string, size int, inst *Inst, dec ExtInst) bool,
) {
	start := time.Now()
	ext := &ExtDis{
		Dec:  make(chan ExtInst),
		Arch: arch,
	}
	errc := make(chan error)

	// First pass: write instructions to input file for external disassembler.
	file, f, size, err := writeInst(generate)
	if err != nil {
		t.Fatal(err)
	}
	ext.Size = size
	ext.File = f
	defer func() {
		f.Close()
		if !*keep {
			os.Remove(file)
		}
	}()

	// Second pass: compare disassembly against our decodings.
	var (
		totalTests  = 0
		totalSkips  = 0
		totalErrors = 0

		errors = make([]string, 0, 100) // sampled errors, at most cap
	)
	go func() {
		errc <- extdis(ext)
	}()
	generate(func(enc []byte) {
		dec, ok := <-ext.Dec
		if !ok {
			t.Errorf("decoding stream ended early")
			return
		}
		inst, text := disasm(syntax, arch, pad(enc))
		totalTests++
		if *dumpTest {
			fmt.Printf("%x -> %s [%d]\n", enc[:len(enc)], dec.text, dec.nenc)
		}
		if text != dec.text || inst.Len != dec.nenc {
			suffix := ""
			if allowedMismatch(text, size, &inst, dec) {
				totalSkips++
				if !*mismatch {
					return
				}
				suffix += " (allowed mismatch)"
			}
			totalErrors++
			if len(errors) >= cap(errors) {
				j := rand.Intn(totalErrors)
				if j >= cap(errors) {
					return
				}
				errors = append(errors[:j], errors[j+1:]...)
			}
			errors = append(errors, fmt.Sprintf("decode(%x) = %q, %d, want %q, %d%s", enc, text, inst.Len, dec.text, dec.nenc, suffix))
		}
	})

	if *mismatch {
		totalErrors -= totalSkips
	}

	for _, b := range errors {
		t.Log(b)
	}

	if totalErrors > 0 {
		t.Fail()
	}
	t.Logf("%d test cases, %d expected mismatches, %d failures; %.0f cases/second", totalTests, totalSkips, totalErrors, float64(totalTests)/time.Since(start).Seconds())

	if err := <-errc; err != nil {
		t.Fatalf("external disassembler: %v", err)
	}
}

const start = 0x8000 // start address of text

// writeInst writes the generated byte sequences to a new file
// starting at offset start. That file is intended to be the input to
// the external disassembler.
func writeInst(generate func(func([]byte))) (file string, f *os.File, size int, err error) {
	f, err = ioutil.TempFile("", "x86map")
	if err != nil {
		return
	}

	file = f.Name()

	f.Seek(start, 0)
	w := bufio.NewWriter(f)
	defer w.Flush()
	size = 0
	generate(func(x []byte) {
		if len(x) > 16 {
			x = x[:16]
		}
		if debug {
			fmt.Printf("%#x: %x%x\n", start+size, x, pops[len(x):])
		}
		w.Write(x)
		w.Write(pops[len(x):])
		size += len(pops)
	})
	return file, f, size, nil
}

// 0x5F is a single-byte pop instruction.
// We pad the bytes we want decoded with enough 0x5Fs
// that no matter what state the instruction stream is in
// after reading our bytes, the pops will get us back to
// a forced instruction boundary.
var pops = []byte{
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
}

// pad pads the code sequence with pops.
func pad(enc []byte) []byte {
	return append(enc[:len(enc):len(enc)], pops...)
}

// disasm returns the decoded instruction and text
// for the given source bytes, using the given syntax and mode.
func disasm(syntax string, mode int, src []byte) (inst Inst, text string) {
	// If printTests is set, we record the coverage value
	// before and after, and we write out the inputs for which
	// coverage went up, in the format expected in testdata/decode.text.
	// This produces a fairly small set of test cases that exercise nearly
	// all the code.
	var cover float64
	if *printTests {
		cover -= coverage()
	}

	inst, err := decode1(src, mode, syntax == "gnu")
	if err != nil {
		text = "error: " + err.Error()
	} else {
		switch syntax {
		case "gnu":
			text = GNUSyntax(inst)
		case "intel":
			text = IntelSyntax(inst)
		case "plan9": // [sic]
			text = GoSyntax(inst, 0, nil)
		default:
			text = "error: unknown syntax " + syntax
		}
	}

	if *printTests {
		cover += coverage()
		if cover > 0 {
			max := len(src)
			if max > 16 && inst.Len <= 16 {
				max = 16
			}
			fmt.Printf("%x|%x\t%d\t%s\t%s\n", src[:inst.Len], src[inst.Len:max], mode, syntax, text)
		}
	}

	return
}

// coverage returns a floating point number denoting the
// test coverage until now. The number increases when new code paths are exercised,
// both in the Go program and in the decoder byte code.
func coverage() float64 {
	/*
		testing.Coverage is not in the main distribution.
		The implementation, which must go in package testing, is:

		// Coverage reports the current code coverage as a fraction in the range [0, 1].
		func Coverage() float64 {
			var n, d int64
			for _, counters := range cover.Counters {
				for _, c := range counters {
					if c > 0 {
						n++
					}
					d++
				}
			}
			if d == 0 {
				return 0
			}
			return float64(n) / float64(d)
		}
	*/

	var f float64
	// f += testing.Coverage()
	f += decodeCoverage()
	return f
}

func decodeCoverage() float64 {
	n := 0
	for _, t := range decoderCover {
		if t {
			n++
		}
	}
	return float64(1+n) / float64(1+len(decoderCover))
}

// Helpers for writing disassembler output parsers.

// isPrefix reports whether text is the name of an instruction prefix.
func isPrefix(text string) bool {
	return prefixByte[text] > 0
}

// prefixByte maps instruction prefix text to actual prefix byte values.
var prefixByte = map[string]byte{
	"es":       0x26,
	"cs":       0x2e,
	"ss":       0x36,
	"ds":       0x3e,
	"fs":       0x64,
	"gs":       0x65,
	"data16":   0x66,
	"addr16":   0x67,
	"lock":     0xf0,
	"repn":     0xf2,
	"repne":    0xf2,
	"rep":      0xf3,
	"repe":     0xf3,
	"xacquire": 0xf2,
	"xrelease": 0xf3,
	"bnd":      0xf2,
	"addr32":   0x66,
	"data32":   0x67,
}

// hasPrefix reports whether any of the space-separated words in the text s
// begins with any of the given prefixes.
func hasPrefix(s string, prefixes ...string) bool {
	for _, prefix := range prefixes {
		for s := s; s != ""; {
			if strings.HasPrefix(s, prefix) {
				return true
			}
			i := strings.Index(s, " ")
			if i < 0 {
				break
			}
			s = s[i+1:]
		}
	}
	return false
}

// contains reports whether the text s contains any of the given substrings.
func contains(s string, substrings ...string) bool {
	for _, sub := range substrings {
		if strings.Contains(s, sub) {
			return true
		}
	}
	return false
}

// isHex reports whether b is a hexadecimal character (0-9A-Fa-f).
func isHex(b byte) bool { return b == '0' || unhex[b] > 0 }

// parseHex parses the hexadecimal byte dump in hex,
// appending the parsed bytes to raw and returning the updated slice.
// The returned bool signals whether any invalid hex was found.
// Spaces and tabs between bytes are okay but any other non-hex is not.
func parseHex(hex []byte, raw []byte) ([]byte, bool) {
	hex = trimSpace(hex)
	for j := 0; j < len(hex); {
		for hex[j] == ' ' || hex[j] == '\t' {
			j++
		}
		if j >= len(hex) {
			break
		}
		if j+2 > len(hex) || !isHex(hex[j]) || !isHex(hex[j+1]) {
			return nil, false
		}
		raw = append(raw, unhex[hex[j]]<<4|unhex[hex[j+1]])
		j += 2
	}
	return raw, true
}

var unhex = [256]byte{
	'0': 0,
	'1': 1,
	'2': 2,
	'3': 3,
	'4': 4,
	'5': 5,
	'6': 6,
	'7': 7,
	'8': 8,
	'9': 9,
	'A': 10,
	'B': 11,
	'C': 12,
	'D': 13,
	'E': 14,
	'F': 15,
	'a': 10,
	'b': 11,
	'c': 12,
	'd': 13,
	'e': 14,
	'f': 15,
}

// index is like bytes.Index(s, []byte(t)) but avoids the allocation.
func index(s []byte, t string) int {
	i := 0
	for {
		j := bytes.IndexByte(s[i:], t[0])
		if j < 0 {
			return -1
		}
		i = i + j
		if i+len(t) > len(s) {
			return -1
		}
		for k := 1; k < len(t); k++ {
			if s[i+k] != t[k] {
				goto nomatch
			}
		}
		return i
	nomatch:
		i++
	}
}

// fixSpace rewrites runs of spaces, tabs, and newline characters into single spaces in s.
// If s must be rewritten, it is rewritten in place.
func fixSpace(s []byte) []byte {
	s = trimSpace(s)
	for i := 0; i < len(s); i++ {
		if s[i] == '\t' || s[i] == '\n' || i > 0 && s[i] == ' ' && s[i-1] == ' ' {
			goto Fix
		}
	}
	return s

Fix:
	b := s
	w := 0
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c == '\t' || c == '\n' {
			c = ' '
		}
		if c == ' ' && w > 0 && b[w-1] == ' ' {
			continue
		}
		b[w] = c
		w++
	}
	if w > 0 && b[w-1] == ' ' {
		w--
	}
	return b[:w]
}

// trimSpace trims leading and trailing space from s, returning a subslice of s.
func trimSpace(s []byte) []byte {
	j := len(s)
	for j > 0 && (s[j-1] == ' ' || s[j-1] == '\t' || s[j-1] == '\n') {
		j--
	}
	i := 0
	for i < j && (s[i] == ' ' || s[i] == '\t') {
		i++
	}
	return s[i:j]
}

// pcrel and pcrelw match instructions using relative addressing mode.
var (
	pcrel  = regexp.MustCompile(`^((?:.* )?(?:j[a-z]+|call|ljmp|loopn?e?w?|xbegin)q?(?:,p[nt])?) 0x([0-9a-f]+)$`)
	pcrelw = regexp.MustCompile(`^((?:.* )?(?:callw|jmpw|xbeginw|ljmpw)(?:,p[nt])?) 0x([0-9a-f]+)$`)
)

// Generators.
//
// The test cases are described as functions that invoke a callback repeatedly,
// with a new input sequence each time. These helpers make writing those
// a little easier.

// hexCases generates the cases written in hexadecimal in the encoded string.
// Spaces in 'encoded' separate entire test cases, not individual bytes.
func hexCases(t *testing.T, encoded string) func(func([]byte)) {
	return func(try func([]byte)) {
		for _, x := range strings.Fields(encoded) {
			src, err := hex.DecodeString(x)
			if err != nil {
				t.Errorf("parsing %q: %v", x, err)
			}
			try(src)
		}
	}
}

// testdataCases generates the test cases recorded in testdata/decode.txt.
// It only uses the inputs; it ignores the answers recorded in that file.
func testdataCases(t *testing.T) func(func([]byte)) {
	var codes [][]byte
	data, err := ioutil.ReadFile("testdata/decode.txt")
	if err != nil {
		t.Fatal(err)
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		f := strings.Fields(line)[0]
		i := strings.Index(f, "|")
		if i < 0 {
			t.Errorf("parsing %q: missing | separator", f)
			continue
		}
		if i%2 != 0 {
			t.Errorf("parsing %q: misaligned | separator", f)
		}
		code, err := hex.DecodeString(f[:i] + f[i+1:])
		if err != nil {
			t.Errorf("parsing %q: %v", f, err)
			continue
		}
		codes = append(codes, code)
	}

	return func(try func([]byte)) {
		for _, code := range codes {
			try(code)
		}
	}
}

// manyPrefixes generates all possible 2 combinations of nine chosen prefixes.
// The relative ordering of the prefixes within the combinations varies deterministically.
func manyPrefixes(try func([]byte)) {
	var prefixBytes = []byte{0x66, 0x67, 0xF0, 0xF2, 0xF3, 0x3E, 0x36, 0x66, 0x67}
	var enc []byte
	for i := 0; i < 1<<uint(len(prefixBytes)); i++ {
		enc = enc[:0]
		for j, p := range prefixBytes {
			if i&(1<<uint(j)) != 0 {
				enc = append(enc, p)
			}
		}
		if len(enc) > 0 {
			k := i % len(enc)
			enc[0], enc[k] = enc[k], enc[0]
		}
		try(enc)
	}
}

// basicPrefixes geneartes 8 different possible prefix cases: no prefix
// and then one each of seven different prefix bytes.
func basicPrefixes(try func([]byte)) {
	try(nil)
	for _, b := range []byte{0x66, 0x67, 0xF0, 0xF2, 0xF3, 0x3E, 0x36} {
		try([]byte{b})
	}
}

func rexPrefixes(try func([]byte)) {
	try(nil)
	for _, b := range []byte{0x40, 0x48, 0x43, 0x4C} {
		try([]byte{b})
	}
}

// concat takes two generators and returns a generator for the
// cross product of the two, concatenating the results from each.
func concat(gen1, gen2 func(func([]byte))) func(func([]byte)) {
	return func(try func([]byte)) {
		gen1(func(enc1 []byte) {
			gen2(func(enc2 []byte) {
				try(append(enc1[:len(enc1):len(enc1)], enc2...))
			})
		})
	}
}

// concat3 takes three generators and returns a generator for the
// cross product of the three, concatenating the results from each.
func concat3(gen1, gen2, gen3 func(func([]byte))) func(func([]byte)) {
	return func(try func([]byte)) {
		gen1(func(enc1 []byte) {
			gen2(func(enc2 []byte) {
				gen3(func(enc3 []byte) {
					try(append(append(enc1[:len(enc1):len(enc1)], enc2...), enc3...))
				})
			})
		})
	}
}

// concat4 takes four generators and returns a generator for the
// cross product of the four, concatenating the results from each.
func concat4(gen1, gen2, gen3, gen4 func(func([]byte))) func(func([]byte)) {
	return func(try func([]byte)) {
		gen1(func(enc1 []byte) {
			gen2(func(enc2 []byte) {
				gen3(func(enc3 []byte) {
					gen4(func(enc4 []byte) {
						try(append(append(append(enc1[:len(enc1):len(enc1)], enc2...), enc3...), enc4...))
					})
				})
			})
		})
	}
}

// filter generates the sequences from gen that satisfy ok.
func filter(gen func(func([]byte)), ok func([]byte) bool) func(func([]byte)) {
	return func(try func([]byte)) {
		gen(func(enc []byte) {
			if ok(enc) {
				try(enc)
			}
		})
	}
}

// enum8bit generates all possible 1-byte sequences, followed by distinctive padding.
func enum8bit(try func([]byte)) {
	for i := 0; i < 1<<8; i++ {
		try([]byte{byte(i), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88})
	}
}

// enum8bit generates all possible 2-byte sequences, followed by distinctive padding.
func enum16bit(try func([]byte)) {
	for i := 0; i < 1<<16; i++ {
		try([]byte{byte(i), byte(i >> 8), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88})
	}
}

// enum24bit generates all possible 3-byte sequences, followed by distinctive padding.
func enum24bit(try func([]byte)) {
	for i := 0; i < 1<<24; i++ {
		try([]byte{byte(i), byte(i >> 8), byte(i >> 16), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88})
	}
}

// enumModRM generates all possible modrm bytes and, for modrm values that indicate
// a following sib byte, all possible modrm, sib combinations.
func enumModRM(try func([]byte)) {
	for i := 0; i < 256; i++ {
		if (i>>3)&07 == 04 && i>>6 != 3 { // has sib
			for j := 0; j < 256; j++ {
				try([]byte{0, byte(i), byte(j), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // byte encodings
				try([]byte{1, byte(i), byte(j), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // word encodings
			}
		} else {
			try([]byte{0, byte(i), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // byte encodings
			try([]byte{1, byte(i), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // word encodings
		}
	}
}

// fixed generates the single case b.
// It's mainly useful to prepare an argument for concat or concat3.
func fixed(b ...byte) func(func([]byte)) {
	return func(try func([]byte)) {
		try(b)
	}
}

// testBasic runs the given test function with cases all using opcode as the initial opcode bytes.
// It runs three phases:
//
// First, zero-or-one prefixes followed by opcode followed by all possible 1-byte values.
// If in -short mode, that's all.
//
// Second, zero-or-one prefixes followed by opcode followed by all possible 2-byte values.
// If not in -long mode, that's all. This phase and the next run in parallel with other tests
// (using t.Parallel).
//
// Finally, opcode followed by all possible 3-byte values. The test can take a very long time
// and prints progress messages to package log.
func testBasic(t *testing.T, testfn func(*testing.T, func(func([]byte))), opcode ...byte) {
	testfn(t, concat3(basicPrefixes, fixed(opcode...), enum8bit))
	if testing.Short() {
		return
	}

	t.Parallel()
	testfn(t, concat3(basicPrefixes, fixed(opcode...), enum16bit))
	if !*longTest {
		return
	}

	name := caller(2)
	op1 := make([]byte, len(opcode)+1)
	copy(op1, opcode)
	for i := 0; i < 256; i++ {
		log.Printf("%s 24-bit: %d/256\n", name, i)
		op1[len(opcode)] = byte(i)
		testfn(t, concat(fixed(op1...), enum16bit))
	}
}

func testBasicREX(t *testing.T, testfn func(*testing.T, func(func([]byte))), opcode ...byte) {
	testfn(t, filter(concat4(basicPrefixes, rexPrefixes, fixed(opcode...), enum8bit), isValidREX))
	if testing.Short() {
		return
	}

	t.Parallel()
	testfn(t, filter(concat4(basicPrefixes, rexPrefixes, fixed(opcode...), enum16bit), isValidREX))
	if !*longTest {
		return
	}

	name := caller(2)
	op1 := make([]byte, len(opcode)+1)
	copy(op1, opcode)
	for i := 0; i < 256; i++ {
		log.Printf("%s 24-bit: %d/256\n", name, i)
		op1[len(opcode)] = byte(i)
		testfn(t, filter(concat3(rexPrefixes, fixed(op1...), enum16bit), isValidREX))
	}
}

// testPrefix runs the given test function for all many prefix possibilities
// followed by all possible 1-byte sequences.
//
// If in -long mode, it then runs a test of all the prefix possibilities followed
// by all possible 2-byte sequences.
func testPrefix(t *testing.T, testfn func(*testing.T, func(func([]byte)))) {
	t.Parallel()
	testfn(t, concat(manyPrefixes, enum8bit))
	if testing.Short() || !*longTest {
		return
	}

	name := caller(2)
	for i := 0; i < 256; i++ {
		log.Printf("%s 16-bit: %d/256\n", name, i)
		testfn(t, concat3(manyPrefixes, fixed(byte(i)), enum8bit))
	}
}

func testPrefixREX(t *testing.T, testfn func(*testing.T, func(func([]byte)))) {
	t.Parallel()
	testfn(t, filter(concat3(manyPrefixes, rexPrefixes, enum8bit), isValidREX))
	if testing.Short() || !*longTest {
		return
	}

	name := caller(2)
	for i := 0; i < 256; i++ {
		log.Printf("%s 16-bit: %d/256\n", name, i)
		testfn(t, filter(concat4(manyPrefixes, rexPrefixes, fixed(byte(i)), enum8bit), isValidREX))
	}
}

func caller(skip int) string {
	pc, _, _, _ := runtime.Caller(skip)
	f := runtime.FuncForPC(pc)
	name := "?"
	if f != nil {
		name = f.Name()
		if i := strings.LastIndex(name, "."); i >= 0 {
			name = name[i+1:]
		}
	}
	return name
}

func isValidREX(x []byte) bool {
	i := 0
	for i < len(x) && isPrefixByte(x[i]) {
		i++
	}
	if i < len(x) && Prefix(x[i]).IsREX() {
		i++
		if i < len(x) {
			return !isPrefixByte(x[i]) && !Prefix(x[i]).IsREX()
		}
	}
	return true
}

func isPrefixByte(b byte) bool {
	switch b {
	case 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0x66, 0x67, 0xF0, 0xF2, 0xF3:
		return true
	}
	return false
}
                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/gnu.go                          0100644 0000000 0000000 00000050777 13020111412 024700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"fmt"
	"strings"
)

// GNUSyntax returns the GNU assembler syntax for the instruction, as defined by GNU binutils.
// This general form is often called ``AT&T syntax'' as a reference to AT&T System V Unix.
func GNUSyntax(inst Inst) string {
	// Rewrite instruction to mimic GNU peculiarities.
	// Note that inst has been passed by value and contains
	// no pointers, so any changes we make here are local
	// and will not propagate back out to the caller.

	// Adjust opcode [sic].
	switch inst.Op {
	case FDIV, FDIVR, FSUB, FSUBR, FDIVP, FDIVRP, FSUBP, FSUBRP:
		// DC E0, DC F0: libopcodes swaps FSUBR/FSUB and FDIVR/FDIV, at least
		// if you believe the Intel manual is correct (the encoding is irregular as given;
		// libopcodes uses the more regular expected encoding).
		// TODO(rsc): Test to ensure Intel manuals are correct and report to libopcodes maintainers?
		// NOTE: iant thinks this is deliberate, but we can't find the history.
		_, reg1 := inst.Args[0].(Reg)
		_, reg2 := inst.Args[1].(Reg)
		if reg1 && reg2 && (inst.Opcode>>24 == 0xDC || inst.Opcode>>24 == 0xDE) {
			switch inst.Op {
			case FDIV:
				inst.Op = FDIVR
			case FDIVR:
				inst.Op = FDIV
			case FSUB:
				inst.Op = FSUBR
			case FSUBR:
				inst.Op = FSUB
			case FDIVP:
				inst.Op = FDIVRP
			case FDIVRP:
				inst.Op = FDIVP
			case FSUBP:
				inst.Op = FSUBRP
			case FSUBRP:
				inst.Op = FSUBP
			}
		}

	case MOVNTSD:
		// MOVNTSD is F2 0F 2B /r.
		// MOVNTSS is F3 0F 2B /r (supposedly; not in manuals).
		// Usually inner prefixes win for display,
		// so that F3 F2 0F 2B 11 is REP MOVNTSD
		// and F2 F3 0F 2B 11 is REPN MOVNTSS.
		// Libopcodes always prefers MOVNTSS regardless of prefix order.
		if countPrefix(&inst, 0xF3) > 0 {
			found := false
			for i := len(inst.Prefix) - 1; i >= 0; i-- {
				switch inst.Prefix[i] & 0xFF {
				case 0xF3:
					if !found {
						found = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case 0xF2:
					inst.Prefix[i] &^= PrefixImplicit
				}
			}
			inst.Op = MOVNTSS
		}
	}

	// Add implicit arguments.
	switch inst.Op {
	case MONITOR:
		inst.Args[0] = EDX
		inst.Args[1] = ECX
		inst.Args[2] = EAX
		if inst.AddrSize == 16 {
			inst.Args[2] = AX
		}

	case MWAIT:
		if inst.Mode == 64 {
			inst.Args[0] = RCX
			inst.Args[1] = RAX
		} else {
			inst.Args[0] = ECX
			inst.Args[1] = EAX
		}
	}

	// Adjust which prefixes will be displayed.
	// The rule is to display all the prefixes not implied by
	// the usual instruction display, that is, all the prefixes
	// except the ones with PrefixImplicit set.
	// However, of course, there are exceptions to the rule.
	switch inst.Op {
	case CRC32:
		// CRC32 has a mandatory F2 prefix.
		// If there are multiple F2s and no F3s, the extra F2s do not print.
		// (And Decode has already marked them implicit.)
		// However, if there is an F3 anywhere, then the extra F2s do print.
		// If there are multiple F2 prefixes *and* an (ignored) F3,
		// then libopcodes prints the extra F2s as REPNs.
		if countPrefix(&inst, 0xF2) > 1 {
			unmarkImplicit(&inst, 0xF2)
			markLastImplicit(&inst, 0xF2)
		}

		// An unused data size override should probably be shown,
		// to distinguish DATA16 CRC32B from plain CRC32B,
		// but libopcodes always treats the final override as implicit
		// and the others as explicit.
		unmarkImplicit(&inst, PrefixDataSize)
		markLastImplicit(&inst, PrefixDataSize)

	case CVTSI2SD, CVTSI2SS:
		if !isMem(inst.Args[1]) {
			markLastImplicit(&inst, PrefixDataSize)
		}

	case CVTSD2SI, CVTSS2SI, CVTTSD2SI, CVTTSS2SI,
		ENTER, FLDENV, FNSAVE, FNSTENV, FRSTOR, LGDT, LIDT, LRET,
		POP, PUSH, RET, SGDT, SIDT, SYSRET, XBEGIN:
		markLastImplicit(&inst, PrefixDataSize)

	case LOOP, LOOPE, LOOPNE, MONITOR:
		markLastImplicit(&inst, PrefixAddrSize)

	case MOV:
		// The 16-bit and 32-bit forms of MOV Sreg, dst and MOV src, Sreg
		// cannot be distinguished when src or dst refers to memory, because
		// Sreg is always a 16-bit value, even when we're doing a 32-bit
		// instruction. Because the instruction tables distinguished these two,
		// any operand size prefix has been marked as used (to decide which
		// branch to take). Unmark it, so that it will show up in disassembly,
		// so that the reader can tell the size of memory operand.
		// up with the same arguments
		dst, _ := inst.Args[0].(Reg)
		src, _ := inst.Args[1].(Reg)
		if ES <= src && src <= GS && isMem(inst.Args[0]) || ES <= dst && dst <= GS && isMem(inst.Args[1]) {
			unmarkImplicit(&inst, PrefixDataSize)
		}

	case MOVDQU:
		if countPrefix(&inst, 0xF3) > 1 {
			unmarkImplicit(&inst, 0xF3)
			markLastImplicit(&inst, 0xF3)
		}

	case MOVQ2DQ:
		markLastImplicit(&inst, PrefixDataSize)

	case SLDT, SMSW, STR, FXRSTOR, XRSTOR, XSAVE, XSAVEOPT, CMPXCHG8B:
		if isMem(inst.Args[0]) {
			unmarkImplicit(&inst, PrefixDataSize)
		}

	case SYSEXIT:
		unmarkImplicit(&inst, PrefixDataSize)
	}

	if isCondJmp[inst.Op] || isLoop[inst.Op] || inst.Op == JCXZ || inst.Op == JECXZ || inst.Op == JRCXZ {
		if countPrefix(&inst, PrefixCS) > 0 && countPrefix(&inst, PrefixDS) > 0 {
			for i, p := range inst.Prefix {
				switch p & 0xFFF {
				case PrefixPN, PrefixPT:
					inst.Prefix[i] &= 0xF0FF // cut interpretation bits, producing original segment prefix
				}
			}
		}
	}

	// XACQUIRE/XRELEASE adjustment.
	if inst.Op == MOV {
		// MOV into memory is a candidate for turning REP into XRELEASE.
		// However, if the REP is followed by a REPN, that REPN blocks the
		// conversion.
		haveREPN := false
		for i := len(inst.Prefix) - 1; i >= 0; i-- {
			switch inst.Prefix[i] &^ PrefixIgnored {
			case PrefixREPN:
				haveREPN = true
			case PrefixXRELEASE:
				if haveREPN {
					inst.Prefix[i] = PrefixREP
				}
			}
		}
	}

	// We only format the final F2/F3 as XRELEASE/XACQUIRE.
	haveXA := false
	haveXR := false
	for i := len(inst.Prefix) - 1; i >= 0; i-- {
		switch inst.Prefix[i] &^ PrefixIgnored {
		case PrefixXRELEASE:
			if !haveXR {
				haveXR = true
			} else {
				inst.Prefix[i] = PrefixREP
			}

		case PrefixXACQUIRE:
			if !haveXA {
				haveXA = true
			} else {
				inst.Prefix[i] = PrefixREPN
			}
		}
	}

	// Determine opcode.
	op := strings.ToLower(inst.Op.String())
	if alt := gnuOp[inst.Op]; alt != "" {
		op = alt
	}

	// Determine opcode suffix.
	// Libopcodes omits the suffix if the width of the operation
	// can be inferred from a register arguments. For example,
	// add $1, %ebx has no suffix because you can tell from the
	// 32-bit register destination that it is a 32-bit add,
	// but in addl $1, (%ebx), the destination is memory, so the
	// size is not evident without the l suffix.
	needSuffix := true
SuffixLoop:
	for i, a := range inst.Args {
		if a == nil {
			break
		}
		switch a := a.(type) {
		case Reg:
			switch inst.Op {
			case MOVSX, MOVZX:
				continue

			case SHL, SHR, RCL, RCR, ROL, ROR, SAR:
				if i == 1 {
					// shift count does not tell us operand size
					continue
				}

			case CRC32:
				// The source argument does tell us operand size,
				// but libopcodes still always puts a suffix on crc32.
				continue

			case PUSH, POP:
				// Even though segment registers are 16-bit, push and pop
				// can save/restore them from 32-bit slots, so they
				// do not imply operand size.
				if ES <= a && a <= GS {
					continue
				}

			case CVTSI2SD, CVTSI2SS:
				// The integer register argument takes priority.
				if X0 <= a && a <= X15 {
					continue
				}
			}

			if AL <= a && a <= R15 || ES <= a && a <= GS || X0 <= a && a <= X15 || M0 <= a && a <= M7 {
				needSuffix = false
				break SuffixLoop
			}
		}
	}

	if needSuffix {
		switch inst.Op {
		case CMPXCHG8B, FLDCW, FNSTCW, FNSTSW, LDMXCSR, LLDT, LMSW, LTR, PCLMULQDQ,
			SETA, SETAE, SETB, SETBE, SETE, SETG, SETGE, SETL, SETLE, SETNE, SETNO, SETNP, SETNS, SETO, SETP, SETS,
			SLDT, SMSW, STMXCSR, STR, VERR, VERW:
			// For various reasons, libopcodes emits no suffix for these instructions.

		case CRC32:
			op += byteSizeSuffix(argBytes(&inst, inst.Args[1]))

		case LGDT, LIDT, SGDT, SIDT:
			op += byteSizeSuffix(inst.DataSize / 8)

		case MOVZX, MOVSX:
			// Integer size conversions get two suffixes.
			op = op[:4] + byteSizeSuffix(argBytes(&inst, inst.Args[1])) + byteSizeSuffix(argBytes(&inst, inst.Args[0]))

		case LOOP, LOOPE, LOOPNE:
			// Add w suffix to indicate use of CX register instead of ECX.
			if inst.AddrSize == 16 {
				op += "w"
			}

		case CALL, ENTER, JMP, LCALL, LEAVE, LJMP, LRET, RET, SYSRET, XBEGIN:
			// Add w suffix to indicate use of 16-bit target.
			// Exclude JMP rel8.
			if inst.Opcode>>24 == 0xEB {
				break
			}
			if inst.DataSize == 16 && inst.Mode != 16 {
				markLastImplicit(&inst, PrefixDataSize)
				op += "w"
			} else if inst.Mode == 64 {
				op += "q"
			}

		case FRSTOR, FNSAVE, FNSTENV, FLDENV:
			// Add s suffix to indicate shortened FPU state (I guess).
			if inst.DataSize == 16 {
				op += "s"
			}

		case PUSH, POP:
			if markLastImplicit(&inst, PrefixDataSize) {
				op += byteSizeSuffix(inst.DataSize / 8)
			} else if inst.Mode == 64 {
				op += "q"
			} else {
				op += byteSizeSuffix(inst.MemBytes)
			}

		default:
			if isFloat(inst.Op) {
				// I can't explain any of this, but it's what libopcodes does.
				switch inst.MemBytes {
				default:
					if (inst.Op == FLD || inst.Op == FSTP) && isMem(inst.Args[0]) {
						op += "t"
					}
				case 4:
					if isFloatInt(inst.Op) {
						op += "l"
					} else {
						op += "s"
					}
				case 8:
					if isFloatInt(inst.Op) {
						op += "ll"
					} else {
						op += "l"
					}
				}
				break
			}

			op += byteSizeSuffix(inst.MemBytes)
		}
	}

	// Adjust special case opcodes.
	switch inst.Op {
	case 0:
		if inst.Prefix[0] != 0 {
			return strings.ToLower(inst.Prefix[0].String())
		}

	case INT:
		if inst.Opcode>>24 == 0xCC {
			inst.Args[0] = nil
			op = "int3"
		}

	case CMPPS, CMPPD, CMPSD_XMM, CMPSS:
		imm, ok := inst.Args[2].(Imm)
		if ok && 0 <= imm && imm < 8 {
			inst.Args[2] = nil
			op = cmppsOps[imm] + op[3:]
		}

	case PCLMULQDQ:
		imm, ok := inst.Args[2].(Imm)
		if ok && imm&^0x11 == 0 {
			inst.Args[2] = nil
			op = pclmulqOps[(imm&0x10)>>3|(imm&1)]
		}

	case XLATB:
		if markLastImplicit(&inst, PrefixAddrSize) {
			op = "xlat" // not xlatb
		}
	}

	// Build list of argument strings.
	var (
		usedPrefixes bool     // segment prefixes consumed by Mem formatting
		args         []string // formatted arguments
	)
	for i, a := range inst.Args {
		if a == nil {
			break
		}
		switch inst.Op {
		case MOVSB, MOVSW, MOVSD, MOVSQ, OUTSB, OUTSW, OUTSD:
			if i == 0 {
				usedPrefixes = true // disable use of prefixes for first argument
			} else {
				usedPrefixes = false
			}
		}
		if a == Imm(1) && (inst.Opcode>>24)&^1 == 0xD0 {
			continue
		}
		args = append(args, gnuArg(&inst, a, &usedPrefixes))
	}

	// The default is to print the arguments in reverse Intel order.
	// A few instructions inhibit this behavior.
	switch inst.Op {
	case BOUND, LCALL, ENTER, LJMP:
		// no reverse
	default:
		// reverse args
		for i, j := 0, len(args)-1; i < j; i, j = i+1, j-1 {
			args[i], args[j] = args[j], args[i]
		}
	}

	// Build prefix string.
	// Must be after argument formatting, which can turn off segment prefixes.
	var (
		prefix       = "" // output string
		numAddr      = 0
		numData      = 0
		implicitData = false
	)
	for _, p := range inst.Prefix {
		if p&0xFF == PrefixDataSize && p&PrefixImplicit != 0 {
			implicitData = true
		}
	}
	for _, p := range inst.Prefix {
		if p == 0 {
			break
		}
		if p&PrefixImplicit != 0 {
			continue
		}
		switch p &^ (PrefixIgnored | PrefixInvalid) {
		default:
			if p.IsREX() {
				if p&0xFF == PrefixREX {
					prefix += "rex "
				} else {
					prefix += "rex." + p.String()[4:] + " "
				}
				break
			}
			prefix += strings.ToLower(p.String()) + " "

		case PrefixPN:
			op += ",pn"
			continue

		case PrefixPT:
			op += ",pt"
			continue

		case PrefixAddrSize, PrefixAddr16, PrefixAddr32:
			// For unknown reasons, if the addr16 prefix is repeated,
			// libopcodes displays all but the last as addr32, even though
			// the addressing form used in a memory reference is clearly
			// still 16-bit.
			n := 32
			if inst.Mode == 32 {
				n = 16
			}
			numAddr++
			if countPrefix(&inst, PrefixAddrSize) > numAddr {
				n = inst.Mode
			}
			prefix += fmt.Sprintf("addr%d ", n)
			continue

		case PrefixData16, PrefixData32:
			if implicitData && countPrefix(&inst, PrefixDataSize) > 1 {
				// Similar to the addr32 logic above, but it only kicks in
				// when something used the data size prefix (one is implicit).
				n := 16
				if inst.Mode == 16 {
					n = 32
				}
				numData++
				if countPrefix(&inst, PrefixDataSize) > numData {
					if inst.Mode == 16 {
						n = 16
					} else {
						n = 32
					}
				}
				prefix += fmt.Sprintf("data%d ", n)
				continue
			}
			prefix += strings.ToLower(p.String()) + " "
		}
	}

	// Finally! Put it all together.
	text := prefix + op
	if args != nil {
		text += " "
		// Indirect call/jmp gets a star to distinguish from direct jump address.
		if (inst.Op == CALL || inst.Op == JMP || inst.Op == LJMP || inst.Op == LCALL) && (isMem(inst.Args[0]) || isReg(inst.Args[0])) {
			text += "*"
		}
		text += strings.Join(args, ",")
	}
	return text
}

// gnuArg returns the GNU syntax for the argument x from the instruction inst.
// If *usedPrefixes is false and x is a Mem, then the formatting
// includes any segment prefixes and sets *usedPrefixes to true.
func gnuArg(inst *Inst, x Arg, usedPrefixes *bool) string {
	if x == nil {
		return "<nil>"
	}
	switch x := x.(type) {
	case Reg:
		switch inst.Op {
		case CVTSI2SS, CVTSI2SD, CVTSS2SI, CVTSD2SI, CVTTSD2SI, CVTTSS2SI:
			if inst.DataSize == 16 && EAX <= x && x <= R15L {
				x -= EAX - AX
			}

		case IN, INSB, INSW, INSD, OUT, OUTSB, OUTSW, OUTSD:
			// DX is the port, but libopcodes prints it as if it were a memory reference.
			if x == DX {
				return "(%dx)"
			}
		}
		return gccRegName[x]
	case Mem:
		seg := ""
		var haveCS, haveDS, haveES, haveFS, haveGS, haveSS bool
		switch x.Segment {
		case CS:
			haveCS = true
		case DS:
			haveDS = true
		case ES:
			haveES = true
		case FS:
			haveFS = true
		case GS:
			haveGS = true
		case SS:
			haveSS = true
		}
		switch inst.Op {
		case INSB, INSW, INSD, STOSB, STOSW, STOSD, STOSQ, SCASB, SCASW, SCASD, SCASQ:
			// These do not accept segment prefixes, at least in the GNU rendering.
		default:
			if *usedPrefixes {
				break
			}
			for i := len(inst.Prefix) - 1; i >= 0; i-- {
				p := inst.Prefix[i] &^ PrefixIgnored
				if p == 0 {
					continue
				}
				switch p {
				case PrefixCS:
					if !haveCS {
						haveCS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixDS:
					if !haveDS {
						haveDS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixES:
					if !haveES {
						haveES = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixFS:
					if !haveFS {
						haveFS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixGS:
					if !haveGS {
						haveGS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixSS:
					if !haveSS {
						haveSS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				}
			}
			*usedPrefixes = true
		}
		if haveCS {
			seg += "%cs:"
		}
		if haveDS {
			seg += "%ds:"
		}
		if haveSS {
			seg += "%ss:"
		}
		if haveES {
			seg += "%es:"
		}
		if haveFS {
			seg += "%fs:"
		}
		if haveGS {
			seg += "%gs:"
		}
		disp := ""
		if x.Disp != 0 {
			disp = fmt.Sprintf("%#x", x.Disp)
		}
		if x.Scale == 0 || x.Index == 0 && x.Scale == 1 && (x.Base == ESP || x.Base == RSP || x.Base == 0 && inst.Mode == 64) {
			if x.Base == 0 {
				return seg + disp
			}
			return fmt.Sprintf("%s%s(%s)", seg, disp, gccRegName[x.Base])
		}
		base := gccRegName[x.Base]
		if x.Base == 0 {
			base = ""
		}
		index := gccRegName[x.Index]
		if x.Index == 0 {
			if inst.AddrSize == 64 {
				index = "%riz"
			} else {
				index = "%eiz"
			}
		}
		if AX <= x.Base && x.Base <= DI {
			// 16-bit addressing - no scale
			return fmt.Sprintf("%s%s(%s,%s)", seg, disp, base, index)
		}
		return fmt.Sprintf("%s%s(%s,%s,%d)", seg, disp, base, index, x.Scale)
	case Rel:
		return fmt.Sprintf(".%+#x", int32(x))
	case Imm:
		if inst.Mode == 32 {
			return fmt.Sprintf("$%#x", uint32(x))
		}
		return fmt.Sprintf("$%#x", int64(x))
	}
	return x.String()
}

var gccRegName = [...]string{
	0:    "REG0",
	AL:   "%al",
	CL:   "%cl",
	BL:   "%bl",
	DL:   "%dl",
	AH:   "%ah",
	CH:   "%ch",
	BH:   "%bh",
	DH:   "%dh",
	SPB:  "%spl",
	BPB:  "%bpl",
	SIB:  "%sil",
	DIB:  "%dil",
	R8B:  "%r8b",
	R9B:  "%r9b",
	R10B: "%r10b",
	R11B: "%r11b",
	R12B: "%r12b",
	R13B: "%r13b",
	R14B: "%r14b",
	R15B: "%r15b",
	AX:   "%ax",
	CX:   "%cx",
	BX:   "%bx",
	DX:   "%dx",
	SP:   "%sp",
	BP:   "%bp",
	SI:   "%si",
	DI:   "%di",
	R8W:  "%r8w",
	R9W:  "%r9w",
	R10W: "%r10w",
	R11W: "%r11w",
	R12W: "%r12w",
	R13W: "%r13w",
	R14W: "%r14w",
	R15W: "%r15w",
	EAX:  "%eax",
	ECX:  "%ecx",
	EDX:  "%edx",
	EBX:  "%ebx",
	ESP:  "%esp",
	EBP:  "%ebp",
	ESI:  "%esi",
	EDI:  "%edi",
	R8L:  "%r8d",
	R9L:  "%r9d",
	R10L: "%r10d",
	R11L: "%r11d",
	R12L: "%r12d",
	R13L: "%r13d",
	R14L: "%r14d",
	R15L: "%r15d",
	RAX:  "%rax",
	RCX:  "%rcx",
	RDX:  "%rdx",
	RBX:  "%rbx",
	RSP:  "%rsp",
	RBP:  "%rbp",
	RSI:  "%rsi",
	RDI:  "%rdi",
	R8:   "%r8",
	R9:   "%r9",
	R10:  "%r10",
	R11:  "%r11",
	R12:  "%r12",
	R13:  "%r13",
	R14:  "%r14",
	R15:  "%r15",
	IP:   "%ip",
	EIP:  "%eip",
	RIP:  "%rip",
	F0:   "%st",
	F1:   "%st(1)",
	F2:   "%st(2)",
	F3:   "%st(3)",
	F4:   "%st(4)",
	F5:   "%st(5)",
	F6:   "%st(6)",
	F7:   "%st(7)",
	M0:   "%mm0",
	M1:   "%mm1",
	M2:   "%mm2",
	M3:   "%mm3",
	M4:   "%mm4",
	M5:   "%mm5",
	M6:   "%mm6",
	M7:   "%mm7",
	X0:   "%xmm0",
	X1:   "%xmm1",
	X2:   "%xmm2",
	X3:   "%xmm3",
	X4:   "%xmm4",
	X5:   "%xmm5",
	X6:   "%xmm6",
	X7:   "%xmm7",
	X8:   "%xmm8",
	X9:   "%xmm9",
	X10:  "%xmm10",
	X11:  "%xmm11",
	X12:  "%xmm12",
	X13:  "%xmm13",
	X14:  "%xmm14",
	X15:  "%xmm15",
	CS:   "%cs",
	SS:   "%ss",
	DS:   "%ds",
	ES:   "%es",
	FS:   "%fs",
	GS:   "%gs",
	GDTR: "%gdtr",
	IDTR: "%idtr",
	LDTR: "%ldtr",
	MSW:  "%msw",
	TASK: "%task",
	CR0:  "%cr0",
	CR1:  "%cr1",
	CR2:  "%cr2",
	CR3:  "%cr3",
	CR4:  "%cr4",
	CR5:  "%cr5",
	CR6:  "%cr6",
	CR7:  "%cr7",
	CR8:  "%cr8",
	CR9:  "%cr9",
	CR10: "%cr10",
	CR11: "%cr11",
	CR12: "%cr12",
	CR13: "%cr13",
	CR14: "%cr14",
	CR15: "%cr15",
	DR0:  "%db0",
	DR1:  "%db1",
	DR2:  "%db2",
	DR3:  "%db3",
	DR4:  "%db4",
	DR5:  "%db5",
	DR6:  "%db6",
	DR7:  "%db7",
	TR0:  "%tr0",
	TR1:  "%tr1",
	TR2:  "%tr2",
	TR3:  "%tr3",
	TR4:  "%tr4",
	TR5:  "%tr5",
	TR6:  "%tr6",
	TR7:  "%tr7",
}

var gnuOp = map[Op]string{
	CBW:       "cbtw",
	CDQ:       "cltd",
	CMPSD:     "cmpsl",
	CMPSD_XMM: "cmpsd",
	CWD:       "cwtd",
	CWDE:      "cwtl",
	CQO:       "cqto",
	INSD:      "insl",
	IRET:      "iretw",
	IRETD:     "iret",
	IRETQ:     "iretq",
	LODSB:     "lods",
	LODSD:     "lods",
	LODSQ:     "lods",
	LODSW:     "lods",
	MOVSD:     "movsl",
	MOVSD_XMM: "movsd",
	OUTSD:     "outsl",
	POPA:      "popaw",
	POPAD:     "popa",
	POPF:      "popfw",
	POPFD:     "popf",
	PUSHA:     "pushaw",
	PUSHAD:    "pusha",
	PUSHF:     "pushfw",
	PUSHFD:    "pushf",
	SCASB:     "scas",
	SCASD:     "scas",
	SCASQ:     "scas",
	SCASW:     "scas",
	STOSB:     "stos",
	STOSD:     "stos",
	STOSQ:     "stos",
	STOSW:     "stos",
	XLATB:     "xlat",
}

var cmppsOps = []string{
	"cmpeq",
	"cmplt",
	"cmple",
	"cmpunord",
	"cmpneq",
	"cmpnlt",
	"cmpnle",
	"cmpord",
}

var pclmulqOps = []string{
	"pclmullqlqdq",
	"pclmulhqlqdq",
	"pclmullqhqdq",
	"pclmulhqhqdq",
}

func countPrefix(inst *Inst, target Prefix) int {
	n := 0
	for _, p := range inst.Prefix {
		if p&0xFF == target&0xFF {
			n++
		}
	}
	return n
}

func markLastImplicit(inst *Inst, prefix Prefix) bool {
	for i := len(inst.Prefix) - 1; i >= 0; i-- {
		p := inst.Prefix[i]
		if p&0xFF == prefix {
			inst.Prefix[i] |= PrefixImplicit
			return true
		}
	}
	return false
}

func unmarkImplicit(inst *Inst, prefix Prefix) {
	for i := len(inst.Prefix) - 1; i >= 0; i-- {
		p := inst.Prefix[i]
		if p&0xFF == prefix {
			inst.Prefix[i] &^= PrefixImplicit
		}
	}
}

func byteSizeSuffix(b int) string {
	switch b {
	case 1:
		return "b"
	case 2:
		return "w"
	case 4:
		return "l"
	case 8:
		return "q"
	}
	return ""
}

func argBytes(inst *Inst, arg Arg) int {
	if isMem(arg) {
		return inst.MemBytes
	}
	return regBytes(arg)
}

func isFloat(op Op) bool {
	switch op {
	case FADD, FCOM, FCOMP, FDIV, FDIVR, FIADD, FICOM, FICOMP, FIDIV, FIDIVR, FILD, FIMUL, FIST, FISTP, FISTTP, FISUB, FISUBR, FLD, FMUL, FST, FSTP, FSUB, FSUBR:
		return true
	}
	return false
}

func isFloatInt(op Op) bool {
	switch op {
	case FIADD, FICOM, FICOMP, FIDIV, FIDIVR, FILD, FIMUL, FIST, FISTP, FISTTP, FISUB, FISUBR:
		return true
	}
	return false
}
 usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/inst.go                         0100644 0000000 0000000 00000024573 13020111412 025057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package x86asm implements decoding of x86 machine code.
package x86asm

import (
	"bytes"
	"fmt"
)

// An Inst is a single instruction.
type Inst struct {
	Prefix   Prefixes // Prefixes applied to the instruction.
	Op       Op       // Opcode mnemonic
	Opcode   uint32   // Encoded opcode bits, left aligned (first byte is Opcode>>24, etc)
	Args     Args     // Instruction arguments, in Intel order
	Mode     int      // processor mode in bits: 16, 32, or 64
	AddrSize int      // address size in bits: 16, 32, or 64
	DataSize int      // operand size in bits: 16, 32, or 64
	MemBytes int      // size of memory argument in bytes: 1, 2, 4, 8, 16, and so on.
	Len      int      // length of encoded instruction in bytes
	PCRel    int      // length of PC-relative address in instruction encoding
	PCRelOff int      // index of start of PC-relative address in instruction encoding
}

// Prefixes is an array of prefixes associated with a single instruction.
// The prefixes are listed in the same order as found in the instruction:
// each prefix byte corresponds to one slot in the array. The first zero
// in the array marks the end of the prefixes.
type Prefixes [14]Prefix

// A Prefix represents an Intel instruction prefix.
// The low 8 bits are the actual prefix byte encoding,
// and the top 8 bits contain distinguishing bits and metadata.
type Prefix uint16

const (
	// Metadata about the role of a prefix in an instruction.
	PrefixImplicit Prefix = 0x8000 // prefix is implied by instruction text
	PrefixIgnored  Prefix = 0x4000 // prefix is ignored: either irrelevant or overridden by a later prefix
	PrefixInvalid  Prefix = 0x2000 // prefix makes entire instruction invalid (bad LOCK)

	// Memory segment overrides.
	PrefixES Prefix = 0x26 // ES segment override
	PrefixCS Prefix = 0x2E // CS segment override
	PrefixSS Prefix = 0x36 // SS segment override
	PrefixDS Prefix = 0x3E // DS segment override
	PrefixFS Prefix = 0x64 // FS segment override
	PrefixGS Prefix = 0x65 // GS segment override

	// Branch prediction.
	PrefixPN Prefix = 0x12E // predict not taken (conditional branch only)
	PrefixPT Prefix = 0x13E // predict taken (conditional branch only)

	// Size attributes.
	PrefixDataSize Prefix = 0x66 // operand size override
	PrefixData16   Prefix = 0x166
	PrefixData32   Prefix = 0x266
	PrefixAddrSize Prefix = 0x67 // address size override
	PrefixAddr16   Prefix = 0x167
	PrefixAddr32   Prefix = 0x267

	// One of a kind.
	PrefixLOCK     Prefix = 0xF0 // lock
	PrefixREPN     Prefix = 0xF2 // repeat not zero
	PrefixXACQUIRE Prefix = 0x1F2
	PrefixBND      Prefix = 0x2F2
	PrefixREP      Prefix = 0xF3 // repeat
	PrefixXRELEASE Prefix = 0x1F3

	// The REX prefixes must be in the range [PrefixREX, PrefixREX+0x10).
	// the other bits are set or not according to the intended use.
	PrefixREX  Prefix = 0x40 // REX 64-bit extension prefix
	PrefixREXW Prefix = 0x08 // extension bit W (64-bit instruction width)
	PrefixREXR Prefix = 0x04 // extension bit R (r field in modrm)
	PrefixREXX Prefix = 0x02 // extension bit X (index field in sib)
	PrefixREXB Prefix = 0x01 // extension bit B (r/m field in modrm or base field in sib)
)

// IsREX reports whether p is a REX prefix byte.
func (p Prefix) IsREX() bool {
	return p&0xF0 == PrefixREX
}

func (p Prefix) String() string {
	p &^= PrefixImplicit | PrefixIgnored | PrefixInvalid
	if s := prefixNames[p]; s != "" {
		return s
	}

	if p.IsREX() {
		s := "REX."
		if p&PrefixREXW != 0 {
			s += "W"
		}
		if p&PrefixREXR != 0 {
			s += "R"
		}
		if p&PrefixREXX != 0 {
			s += "X"
		}
		if p&PrefixREXB != 0 {
			s += "B"
		}
		return s
	}

	return fmt.Sprintf("Prefix(%#x)", int(p))
}

// An Op is an x86 opcode.
type Op uint32

func (op Op) String() string {
	i := int(op)
	if i < 0 || i >= len(opNames) || opNames[i] == "" {
		return fmt.Sprintf("Op(%d)", i)
	}
	return opNames[i]
}

// An Args holds the instruction arguments.
// If an instruction has fewer than 4 arguments,
// the final elements in the array are nil.
type Args [4]Arg

// An Arg is a single instruction argument,
// one of these types: Reg, Mem, Imm, Rel.
type Arg interface {
	String() string
	isArg()
}

// Note that the implements of Arg that follow are all sized
// so that on a 64-bit machine the data can be inlined in
// the interface value instead of requiring an allocation.

// A Reg is a single register.
// The zero Reg value has no name but indicates ``no register.''
type Reg uint8

const (
	_ Reg = iota

	// 8-bit
	AL
	CL
	DL
	BL
	AH
	CH
	DH
	BH
	SPB
	BPB
	SIB
	DIB
	R8B
	R9B
	R10B
	R11B
	R12B
	R13B
	R14B
	R15B

	// 16-bit
	AX
	CX
	DX
	BX
	SP
	BP
	SI
	DI
	R8W
	R9W
	R10W
	R11W
	R12W
	R13W
	R14W
	R15W

	// 32-bit
	EAX
	ECX
	EDX
	EBX
	ESP
	EBP
	ESI
	EDI
	R8L
	R9L
	R10L
	R11L
	R12L
	R13L
	R14L
	R15L

	// 64-bit
	RAX
	RCX
	RDX
	RBX
	RSP
	RBP
	RSI
	RDI
	R8
	R9
	R10
	R11
	R12
	R13
	R14
	R15

	// Instruction pointer.
	IP  // 16-bit
	EIP // 32-bit
	RIP // 64-bit

	// 387 floating point registers.
	F0
	F1
	F2
	F3
	F4
	F5
	F6
	F7

	// MMX registers.
	M0
	M1
	M2
	M3
	M4
	M5
	M6
	M7

	// XMM registers.
	X0
	X1
	X2
	X3
	X4
	X5
	X6
	X7
	X8
	X9
	X10
	X11
	X12
	X13
	X14
	X15

	// Segment registers.
	ES
	CS
	SS
	DS
	FS
	GS

	// System registers.
	GDTR
	IDTR
	LDTR
	MSW
	TASK

	// Control registers.
	CR0
	CR1
	CR2
	CR3
	CR4
	CR5
	CR6
	CR7
	CR8
	CR9
	CR10
	CR11
	CR12
	CR13
	CR14
	CR15

	// Debug registers.
	DR0
	DR1
	DR2
	DR3
	DR4
	DR5
	DR6
	DR7
	DR8
	DR9
	DR10
	DR11
	DR12
	DR13
	DR14
	DR15

	// Task registers.
	TR0
	TR1
	TR2
	TR3
	TR4
	TR5
	TR6
	TR7
)

const regMax = TR7

func (Reg) isArg() {}

func (r Reg) String() string {
	i := int(r)
	if i < 0 || i >= len(regNames) || regNames[i] == "" {
		return fmt.Sprintf("Reg(%d)", i)
	}
	return regNames[i]
}

// A Mem is a memory reference.
// The general form is Segment:[Base+Scale*Index+Disp].
type Mem struct {
	Segment Reg
	Base    Reg
	Scale   uint8
	Index   Reg
	Disp    int64
}

func (Mem) isArg() {}

func (m Mem) String() string {
	var base, plus, scale, index, disp string

	if m.Base != 0 {
		base = m.Base.String()
	}
	if m.Scale != 0 {
		if m.Base != 0 {
			plus = "+"
		}
		if m.Scale > 1 {
			scale = fmt.Sprintf("%d*", m.Scale)
		}
		index = m.Index.String()
	}
	if m.Disp != 0 || m.Base == 0 && m.Scale == 0 {
		disp = fmt.Sprintf("%+#x", m.Disp)
	}
	return "[" + base + plus + scale + index + disp + "]"
}

// A Rel is an offset relative to the current instruction pointer.
type Rel int32

func (Rel) isArg() {}

func (r Rel) String() string {
	return fmt.Sprintf(".%+d", r)
}

// An Imm is an integer constant.
type Imm int64

func (Imm) isArg() {}

func (i Imm) String() string {
	return fmt.Sprintf("%#x", int64(i))
}

func (i Inst) String() string {
	var buf bytes.Buffer
	for _, p := range i.Prefix {
		if p == 0 {
			break
		}
		if p&PrefixImplicit != 0 {
			continue
		}
		fmt.Fprintf(&buf, "%v ", p)
	}
	fmt.Fprintf(&buf, "%v", i.Op)
	sep := " "
	for _, v := range i.Args {
		if v == nil {
			break
		}
		fmt.Fprintf(&buf, "%s%v", sep, v)
		sep = ", "
	}
	return buf.String()
}

func isReg(a Arg) bool {
	_, ok := a.(Reg)
	return ok
}

func isSegReg(a Arg) bool {
	r, ok := a.(Reg)
	return ok && ES <= r && r <= GS
}

func isMem(a Arg) bool {
	_, ok := a.(Mem)
	return ok
}

func isImm(a Arg) bool {
	_, ok := a.(Imm)
	return ok
}

func regBytes(a Arg) int {
	r, ok := a.(Reg)
	if !ok {
		return 0
	}
	if AL <= r && r <= R15B {
		return 1
	}
	if AX <= r && r <= R15W {
		return 2
	}
	if EAX <= r && r <= R15L {
		return 4
	}
	if RAX <= r && r <= R15 {
		return 8
	}
	return 0
}

func isSegment(p Prefix) bool {
	switch p {
	case PrefixCS, PrefixDS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
		return true
	}
	return false
}

// The Op definitions and string list are in tables.go.

var prefixNames = map[Prefix]string{
	PrefixCS:       "CS",
	PrefixDS:       "DS",
	PrefixES:       "ES",
	PrefixFS:       "FS",
	PrefixGS:       "GS",
	PrefixSS:       "SS",
	PrefixLOCK:     "LOCK",
	PrefixREP:      "REP",
	PrefixREPN:     "REPN",
	PrefixAddrSize: "ADDRSIZE",
	PrefixDataSize: "DATASIZE",
	PrefixAddr16:   "ADDR16",
	PrefixData16:   "DATA16",
	PrefixAddr32:   "ADDR32",
	PrefixData32:   "DATA32",
	PrefixBND:      "BND",
	PrefixXACQUIRE: "XACQUIRE",
	PrefixXRELEASE: "XRELEASE",
	PrefixREX:      "REX",
	PrefixPT:       "PT",
	PrefixPN:       "PN",
}

var regNames = [...]string{
	AL:   "AL",
	CL:   "CL",
	BL:   "BL",
	DL:   "DL",
	AH:   "AH",
	CH:   "CH",
	BH:   "BH",
	DH:   "DH",
	SPB:  "SPB",
	BPB:  "BPB",
	SIB:  "SIB",
	DIB:  "DIB",
	R8B:  "R8B",
	R9B:  "R9B",
	R10B: "R10B",
	R11B: "R11B",
	R12B: "R12B",
	R13B: "R13B",
	R14B: "R14B",
	R15B: "R15B",
	AX:   "AX",
	CX:   "CX",
	BX:   "BX",
	DX:   "DX",
	SP:   "SP",
	BP:   "BP",
	SI:   "SI",
	DI:   "DI",
	R8W:  "R8W",
	R9W:  "R9W",
	R10W: "R10W",
	R11W: "R11W",
	R12W: "R12W",
	R13W: "R13W",
	R14W: "R14W",
	R15W: "R15W",
	EAX:  "EAX",
	ECX:  "ECX",
	EDX:  "EDX",
	EBX:  "EBX",
	ESP:  "ESP",
	EBP:  "EBP",
	ESI:  "ESI",
	EDI:  "EDI",
	R8L:  "R8L",
	R9L:  "R9L",
	R10L: "R10L",
	R11L: "R11L",
	R12L: "R12L",
	R13L: "R13L",
	R14L: "R14L",
	R15L: "R15L",
	RAX:  "RAX",
	RCX:  "RCX",
	RDX:  "RDX",
	RBX:  "RBX",
	RSP:  "RSP",
	RBP:  "RBP",
	RSI:  "RSI",
	RDI:  "RDI",
	R8:   "R8",
	R9:   "R9",
	R10:  "R10",
	R11:  "R11",
	R12:  "R12",
	R13:  "R13",
	R14:  "R14",
	R15:  "R15",
	IP:   "IP",
	EIP:  "EIP",
	RIP:  "RIP",
	F0:   "F0",
	F1:   "F1",
	F2:   "F2",
	F3:   "F3",
	F4:   "F4",
	F5:   "F5",
	F6:   "F6",
	F7:   "F7",
	M0:   "M0",
	M1:   "M1",
	M2:   "M2",
	M3:   "M3",
	M4:   "M4",
	M5:   "M5",
	M6:   "M6",
	M7:   "M7",
	X0:   "X0",
	X1:   "X1",
	X2:   "X2",
	X3:   "X3",
	X4:   "X4",
	X5:   "X5",
	X6:   "X6",
	X7:   "X7",
	X8:   "X8",
	X9:   "X9",
	X10:  "X10",
	X11:  "X11",
	X12:  "X12",
	X13:  "X13",
	X14:  "X14",
	X15:  "X15",
	CS:   "CS",
	SS:   "SS",
	DS:   "DS",
	ES:   "ES",
	FS:   "FS",
	GS:   "GS",
	GDTR: "GDTR",
	IDTR: "IDTR",
	LDTR: "LDTR",
	MSW:  "MSW",
	TASK: "TASK",
	CR0:  "CR0",
	CR1:  "CR1",
	CR2:  "CR2",
	CR3:  "CR3",
	CR4:  "CR4",
	CR5:  "CR5",
	CR6:  "CR6",
	CR7:  "CR7",
	CR8:  "CR8",
	CR9:  "CR9",
	CR10: "CR10",
	CR11: "CR11",
	CR12: "CR12",
	CR13: "CR13",
	CR14: "CR14",
	CR15: "CR15",
	DR0:  "DR0",
	DR1:  "DR1",
	DR2:  "DR2",
	DR3:  "DR3",
	DR4:  "DR4",
	DR5:  "DR5",
	DR6:  "DR6",
	DR7:  "DR7",
	DR8:  "DR8",
	DR9:  "DR9",
	DR10: "DR10",
	DR11: "DR11",
	DR12: "DR12",
	DR13: "DR13",
	DR14: "DR14",
	DR15: "DR15",
	TR0:  "TR0",
	TR1:  "TR1",
	TR2:  "TR2",
	TR3:  "TR3",
	TR4:  "TR4",
	TR5:  "TR5",
	TR6:  "TR6",
	TR7:  "TR7",
}
                                                                                                                                     usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/inst_test.go                    0100644 0000000 0000000 00000000751 13020111412 026106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"strings"
	"testing"
)

func TestRegString(t *testing.T) {
	for r := Reg(1); r <= regMax; r++ {
		if regNames[r] == "" {
			t.Errorf("regNames[%d] is missing", int(r))
		} else if s := r.String(); strings.Contains(s, "Reg(") {
			t.Errorf("Reg(%d).String() = %s, want proper name", int(r), s)
		}
	}
}
                       usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/intel.go                        0100644 0000000 0000000 00000025016 13020111412 025206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"fmt"
	"strings"
)

// IntelSyntax returns the Intel assembler syntax for the instruction, as defined by Intel's XED tool.
func IntelSyntax(inst Inst) string {
	var iargs []Arg
	for _, a := range inst.Args {
		if a == nil {
			break
		}
		iargs = append(iargs, a)
	}

	switch inst.Op {
	case INSB, INSD, INSW, OUTSB, OUTSD, OUTSW, LOOPNE, JCXZ, JECXZ, JRCXZ, LOOP, LOOPE, MOV, XLATB:
		if inst.Op == MOV && (inst.Opcode>>16)&0xFFFC != 0x0F20 {
			break
		}
		for i, p := range inst.Prefix {
			if p&0xFF == PrefixAddrSize {
				inst.Prefix[i] &^= PrefixImplicit
			}
		}
	}

	switch inst.Op {
	case MOV:
		dst, _ := inst.Args[0].(Reg)
		src, _ := inst.Args[1].(Reg)
		if ES <= dst && dst <= GS && EAX <= src && src <= R15L {
			src -= EAX - AX
			iargs[1] = src
		}
		if ES <= dst && dst <= GS && RAX <= src && src <= R15 {
			src -= RAX - AX
			iargs[1] = src
		}

		if inst.Opcode>>24&^3 == 0xA0 {
			for i, p := range inst.Prefix {
				if p&0xFF == PrefixAddrSize {
					inst.Prefix[i] |= PrefixImplicit
				}
			}
		}
	}

	switch inst.Op {
	case AAM, AAD:
		if imm, ok := iargs[0].(Imm); ok {
			if inst.DataSize == 32 {
				iargs[0] = Imm(uint32(int8(imm)))
			} else if inst.DataSize == 16 {
				iargs[0] = Imm(uint16(int8(imm)))
			}
		}

	case PUSH:
		if imm, ok := iargs[0].(Imm); ok {
			iargs[0] = Imm(uint32(imm))
		}
	}

	for _, p := range inst.Prefix {
		if p&PrefixImplicit != 0 {
			for j, pj := range inst.Prefix {
				if pj&0xFF == p&0xFF {
					inst.Prefix[j] |= PrefixImplicit
				}
			}
		}
	}

	if inst.Op != 0 {
		for i, p := range inst.Prefix {
			switch p &^ PrefixIgnored {
			case PrefixData16, PrefixData32, PrefixCS, PrefixDS, PrefixES, PrefixSS:
				inst.Prefix[i] |= PrefixImplicit
			}
			if p.IsREX() {
				inst.Prefix[i] |= PrefixImplicit
			}
		}
	}

	if isLoop[inst.Op] || inst.Op == JCXZ || inst.Op == JECXZ || inst.Op == JRCXZ {
		for i, p := range inst.Prefix {
			if p == PrefixPT || p == PrefixPN {
				inst.Prefix[i] |= PrefixImplicit
			}
		}
	}

	switch inst.Op {
	case AAA, AAS, CBW, CDQE, CLC, CLD, CLI, CLTS, CMC, CPUID, CQO, CWD, DAA, DAS,
		FDECSTP, FINCSTP, FNCLEX, FNINIT, FNOP, FWAIT, HLT,
		ICEBP, INSB, INSD, INSW, INT, INTO, INVD, IRET, IRETQ,
		LAHF, LEAVE, LRET, MONITOR, MWAIT, NOP, OUTSB, OUTSD, OUTSW,
		PAUSE, POPA, POPF, POPFQ, PUSHA, PUSHF, PUSHFQ,
		RDMSR, RDPMC, RDTSC, RDTSCP, RET, RSM,
		SAHF, STC, STD, STI, SYSENTER, SYSEXIT, SYSRET,
		UD2, WBINVD, WRMSR, XEND, XLATB, XTEST:

		if inst.Op == NOP && inst.Opcode>>24 != 0x90 {
			break
		}
		if inst.Op == RET && inst.Opcode>>24 != 0xC3 {
			break
		}
		if inst.Op == INT && inst.Opcode>>24 != 0xCC {
			break
		}
		if inst.Op == LRET && inst.Opcode>>24 != 0xcb {
			break
		}
		for i, p := range inst.Prefix {
			if p&0xFF == PrefixDataSize {
				inst.Prefix[i] &^= PrefixImplicit | PrefixIgnored
			}
		}

	case 0:
		// ok
	}

	switch inst.Op {
	case INSB, INSD, INSW, OUTSB, OUTSD, OUTSW, MONITOR, MWAIT, XLATB:
		iargs = nil

	case STOSB, STOSW, STOSD, STOSQ:
		iargs = iargs[:1]

	case LODSB, LODSW, LODSD, LODSQ, SCASB, SCASW, SCASD, SCASQ:
		iargs = iargs[1:]
	}

	const (
		haveData16 = 1 << iota
		haveData32
		haveAddr16
		haveAddr32
		haveXacquire
		haveXrelease
		haveLock
		haveHintTaken
		haveHintNotTaken
		haveBnd
	)
	var prefixBits uint32
	prefix := ""
	for _, p := range inst.Prefix {
		if p == 0 {
			break
		}
		if p&0xFF == 0xF3 {
			prefixBits &^= haveBnd
		}
		if p&(PrefixImplicit|PrefixIgnored) != 0 {
			continue
		}
		switch p {
		default:
			prefix += strings.ToLower(p.String()) + " "
		case PrefixCS, PrefixDS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
			if inst.Op == 0 {
				prefix += strings.ToLower(p.String()) + " "
			}
		case PrefixREPN:
			prefix += "repne "
		case PrefixLOCK:
			prefixBits |= haveLock
		case PrefixData16, PrefixDataSize:
			prefixBits |= haveData16
		case PrefixData32:
			prefixBits |= haveData32
		case PrefixAddrSize, PrefixAddr16:
			prefixBits |= haveAddr16
		case PrefixAddr32:
			prefixBits |= haveAddr32
		case PrefixXACQUIRE:
			prefixBits |= haveXacquire
		case PrefixXRELEASE:
			prefixBits |= haveXrelease
		case PrefixPT:
			prefixBits |= haveHintTaken
		case PrefixPN:
			prefixBits |= haveHintNotTaken
		case PrefixBND:
			prefixBits |= haveBnd
		}
	}
	switch inst.Op {
	case JMP:
		if inst.Opcode>>24 == 0xEB {
			prefixBits &^= haveBnd
		}
	case RET, LRET:
		prefixBits &^= haveData16 | haveData32
	}

	if prefixBits&haveXacquire != 0 {
		prefix += "xacquire "
	}
	if prefixBits&haveXrelease != 0 {
		prefix += "xrelease "
	}
	if prefixBits&haveLock != 0 {
		prefix += "lock "
	}
	if prefixBits&haveBnd != 0 {
		prefix += "bnd "
	}
	if prefixBits&haveHintTaken != 0 {
		prefix += "hint-taken "
	}
	if prefixBits&haveHintNotTaken != 0 {
		prefix += "hint-not-taken "
	}
	if prefixBits&haveAddr16 != 0 {
		prefix += "addr16 "
	}
	if prefixBits&haveAddr32 != 0 {
		prefix += "addr32 "
	}
	if prefixBits&haveData16 != 0 {
		prefix += "data16 "
	}
	if prefixBits&haveData32 != 0 {
		prefix += "data32 "
	}

	if inst.Op == 0 {
		if prefix == "" {
			return "<no instruction>"
		}
		return prefix[:len(prefix)-1]
	}

	var args []string
	for _, a := range iargs {
		if a == nil {
			break
		}
		args = append(args, intelArg(&inst, a))
	}

	var op string
	switch inst.Op {
	case NOP:
		if inst.Opcode>>24 == 0x0F {
			if inst.DataSize == 16 {
				args = append(args, "ax")
			} else {
				args = append(args, "eax")
			}
		}

	case BLENDVPD, BLENDVPS, PBLENDVB:
		args = args[:2]

	case INT:
		if inst.Opcode>>24 == 0xCC {
			args = nil
			op = "int3"
		}

	case LCALL, LJMP:
		if len(args) == 2 {
			args[0], args[1] = args[1], args[0]
		}

	case FCHS, FABS, FTST, FLDPI, FLDL2E, FLDLG2, F2XM1, FXAM, FLD1, FLDL2T, FSQRT, FRNDINT, FCOS, FSIN:
		if len(args) == 0 {
			args = append(args, "st0")
		}

	case FPTAN, FSINCOS, FUCOMPP, FCOMPP, FYL2X, FPATAN, FXTRACT, FPREM1, FPREM, FYL2XP1, FSCALE:
		if len(args) == 0 {
			args = []string{"st0", "st1"}
		}

	case FST, FSTP, FISTTP, FIST, FISTP, FBSTP:
		if len(args) == 1 {
			args = append(args, "st0")
		}

	case FLD, FXCH, FCOM, FCOMP, FIADD, FIMUL, FICOM, FICOMP, FISUBR, FIDIV, FUCOM, FUCOMP, FILD, FBLD, FADD, FMUL, FSUB, FSUBR, FISUB, FDIV, FDIVR, FIDIVR:
		if len(args) == 1 {
			args = []string{"st0", args[0]}
		}

	case MASKMOVDQU, MASKMOVQ, XLATB, OUTSB, OUTSW, OUTSD:
	FixSegment:
		for i := len(inst.Prefix) - 1; i >= 0; i-- {
			p := inst.Prefix[i] & 0xFF
			switch p {
			case PrefixCS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
				if inst.Mode != 64 || p == PrefixFS || p == PrefixGS {
					args = append(args, strings.ToLower((inst.Prefix[i] & 0xFF).String()))
					break FixSegment
				}
			case PrefixDS:
				if inst.Mode != 64 {
					break FixSegment
				}
			}
		}
	}

	if op == "" {
		op = intelOp[inst.Op]
	}
	if op == "" {
		op = strings.ToLower(inst.Op.String())
	}
	if args != nil {
		op += " " + strings.Join(args, ", ")
	}
	return prefix + op
}

func intelArg(inst *Inst, arg Arg) string {
	switch a := arg.(type) {
	case Imm:
		if inst.Mode == 32 {
			return fmt.Sprintf("%#x", uint32(a))
		}
		if Imm(int32(a)) == a {
			return fmt.Sprintf("%#x", int64(a))
		}
		return fmt.Sprintf("%#x", uint64(a))
	case Mem:
		if a.Base == EIP {
			a.Base = RIP
		}
		prefix := ""
		switch inst.MemBytes {
		case 1:
			prefix = "byte "
		case 2:
			prefix = "word "
		case 4:
			prefix = "dword "
		case 8:
			prefix = "qword "
		case 16:
			prefix = "xmmword "
		}
		switch inst.Op {
		case INVLPG:
			prefix = "byte "
		case STOSB, MOVSB, CMPSB, LODSB, SCASB:
			prefix = "byte "
		case STOSW, MOVSW, CMPSW, LODSW, SCASW:
			prefix = "word "
		case STOSD, MOVSD, CMPSD, LODSD, SCASD:
			prefix = "dword "
		case STOSQ, MOVSQ, CMPSQ, LODSQ, SCASQ:
			prefix = "qword "
		case LAR:
			prefix = "word "
		case BOUND:
			if inst.Mode == 32 {
				prefix = "qword "
			} else {
				prefix = "dword "
			}
		case PREFETCHW, PREFETCHNTA, PREFETCHT0, PREFETCHT1, PREFETCHT2, CLFLUSH:
			prefix = "zmmword "
		}
		switch inst.Op {
		case MOVSB, MOVSW, MOVSD, MOVSQ, CMPSB, CMPSW, CMPSD, CMPSQ, STOSB, STOSW, STOSD, STOSQ, SCASB, SCASW, SCASD, SCASQ, LODSB, LODSW, LODSD, LODSQ:
			switch a.Base {
			case DI, EDI, RDI:
				if a.Segment == ES {
					a.Segment = 0
				}
			case SI, ESI, RSI:
				if a.Segment == DS {
					a.Segment = 0
				}
			}
		case LEA:
			a.Segment = 0
		default:
			switch a.Base {
			case SP, ESP, RSP, BP, EBP, RBP:
				if a.Segment == SS {
					a.Segment = 0
				}
			default:
				if a.Segment == DS {
					a.Segment = 0
				}
			}
		}

		if inst.Mode == 64 && a.Segment != FS && a.Segment != GS {
			a.Segment = 0
		}

		prefix += "ptr "
		if a.Segment != 0 {
			prefix += strings.ToLower(a.Segment.String()) + ":"
		}
		prefix += "["
		if a.Base != 0 {
			prefix += intelArg(inst, a.Base)
		}
		if a.Scale != 0 && a.Index != 0 {
			if a.Base != 0 {
				prefix += "+"
			}
			prefix += fmt.Sprintf("%s*%d", intelArg(inst, a.Index), a.Scale)
		}
		if a.Disp != 0 {
			if prefix[len(prefix)-1] == '[' && (a.Disp >= 0 || int64(int32(a.Disp)) != a.Disp) {
				prefix += fmt.Sprintf("%#x", uint64(a.Disp))
			} else {
				prefix += fmt.Sprintf("%+#x", a.Disp)
			}
		}
		prefix += "]"
		return prefix
	case Rel:
		return fmt.Sprintf(".%+#x", int64(a))
	case Reg:
		if int(a) < len(intelReg) && intelReg[a] != "" {
			return intelReg[a]
		}
	}
	return strings.ToLower(arg.String())
}

var intelOp = map[Op]string{
	JAE:       "jnb",
	JA:        "jnbe",
	JGE:       "jnl",
	JNE:       "jnz",
	JG:        "jnle",
	JE:        "jz",
	SETAE:     "setnb",
	SETA:      "setnbe",
	SETGE:     "setnl",
	SETNE:     "setnz",
	SETG:      "setnle",
	SETE:      "setz",
	CMOVAE:    "cmovnb",
	CMOVA:     "cmovnbe",
	CMOVGE:    "cmovnl",
	CMOVNE:    "cmovnz",
	CMOVG:     "cmovnle",
	CMOVE:     "cmovz",
	LCALL:     "call far",
	LJMP:      "jmp far",
	LRET:      "ret far",
	ICEBP:     "int1",
	MOVSD_XMM: "movsd",
	XLATB:     "xlat",
}

var intelReg = [...]string{
	F0:  "st0",
	F1:  "st1",
	F2:  "st2",
	F3:  "st3",
	F4:  "st4",
	F5:  "st5",
	F6:  "st6",
	F7:  "st7",
	M0:  "mmx0",
	M1:  "mmx1",
	M2:  "mmx2",
	M3:  "mmx3",
	M4:  "mmx4",
	M5:  "mmx5",
	M6:  "mmx6",
	M7:  "mmx7",
	X0:  "xmm0",
	X1:  "xmm1",
	X2:  "xmm2",
	X3:  "xmm3",
	X4:  "xmm4",
	X5:  "xmm5",
	X6:  "xmm6",
	X7:  "xmm7",
	X8:  "xmm8",
	X9:  "xmm9",
	X10: "xmm10",
	X11: "xmm11",
	X12: "xmm12",
	X13: "xmm13",
	X14: "xmm14",
	X15: "xmm15",

	// TODO: Maybe the constants are named wrong.
	SPB: "spl",
	BPB: "bpl",
	SIB: "sil",
	DIB: "dil",

	R8L:  "r8d",
	R9L:  "r9d",
	R10L: "r10d",
	R11L: "r11d",
	R12L: "r12d",
	R13L: "r13d",
	R14L: "r14d",
	R15L: "r15d",
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/objdump_test.go                 0100644 0000000 0000000 00000022655 13020111412 026600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"strings"
	"testing"
)

func TestObjdump32Manual(t *testing.T)   { testObjdump32(t, hexCases(t, objdumpManualTests)) }
func TestObjdump32Testdata(t *testing.T) { testObjdump32(t, concat(basicPrefixes, testdataCases(t))) }
func TestObjdump32ModRM(t *testing.T)    { testObjdump32(t, concat(basicPrefixes, enumModRM)) }
func TestObjdump32OneByte(t *testing.T)  { testBasic(t, testObjdump32) }
func TestObjdump320F(t *testing.T)       { testBasic(t, testObjdump32, 0x0F) }
func TestObjdump320F38(t *testing.T)     { testBasic(t, testObjdump32, 0x0F, 0x38) }
func TestObjdump320F3A(t *testing.T)     { testBasic(t, testObjdump32, 0x0F, 0x3A) }
func TestObjdump32Prefix(t *testing.T)   { testPrefix(t, testObjdump32) }

func TestObjdump64Manual(t *testing.T)   { testObjdump64(t, hexCases(t, objdumpManualTests)) }
func TestObjdump64Testdata(t *testing.T) { testObjdump64(t, concat(basicPrefixes, testdataCases(t))) }
func TestObjdump64ModRM(t *testing.T)    { testObjdump64(t, concat(basicPrefixes, enumModRM)) }
func TestObjdump64OneByte(t *testing.T)  { testBasic(t, testObjdump64) }
func TestObjdump640F(t *testing.T)       { testBasic(t, testObjdump64, 0x0F) }
func TestObjdump640F38(t *testing.T)     { testBasic(t, testObjdump64, 0x0F, 0x38) }
func TestObjdump640F3A(t *testing.T)     { testBasic(t, testObjdump64, 0x0F, 0x3A) }
func TestObjdump64Prefix(t *testing.T)   { testPrefix(t, testObjdump64) }

func TestObjdump64REXTestdata(t *testing.T) {
	testObjdump64(t, filter(concat3(basicPrefixes, rexPrefixes, testdataCases(t)), isValidREX))
}
func TestObjdump64REXModRM(t *testing.T) {
	testObjdump64(t, concat3(basicPrefixes, rexPrefixes, enumModRM))
}
func TestObjdump64REXOneByte(t *testing.T) { testBasicREX(t, testObjdump64) }
func TestObjdump64REX0F(t *testing.T)      { testBasicREX(t, testObjdump64, 0x0F) }
func TestObjdump64REX0F38(t *testing.T)    { testBasicREX(t, testObjdump64, 0x0F, 0x38) }
func TestObjdump64REX0F3A(t *testing.T)    { testBasicREX(t, testObjdump64, 0x0F, 0x3A) }
func TestObjdump64REXPrefix(t *testing.T)  { testPrefixREX(t, testObjdump64) }

// objdumpManualTests holds test cases that will be run by TestObjdumpManual.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=ObjdumpManual, particularly with tracing enabled.
var objdumpManualTests = `
4883FE017413
488DFC2500000000
488D3D00000000
`

// allowedMismatchObjdump reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchObjdump(text string, size int, inst *Inst, dec ExtInst) bool {
	if size == 15 && dec.nenc == 15 && contains(text, "truncated") && contains(dec.text, "(bad)") {
		return true
	}

	if i := strings.LastIndex(dec.text, " "); isPrefix(dec.text[i+1:]) && size == 1 && isPrefix(text) {
		return true
	}

	if size == dec.nenc && contains(dec.text, "movupd") && contains(dec.text, "data32") {
		s := strings.Replace(dec.text, "data32 ", "", -1)
		if text == s {
			return true
		}
	}

	// Simplify our invalid instruction text.
	if text == "error: unrecognized instruction" {
		text = "BAD"
	}

	// Invalid instructions for which libopcodes prints %? register.
	// FF E8 11 22 33 44:
	// Invalid instructions for which libopcodes prints "internal disassembler error".
	// Invalid instructions for which libopcodes prints 8087 only (e.g., DB E0)
	// or prints 287 only (e.g., DB E4).
	if contains(dec.text, "%?", "<internal disassembler error>", "(8087 only)", "(287 only)") {
		dec.text = "(bad)"
	}

	// 0F 19 11, 0F 1C 11, 0F 1D 11, 0F 1E 11, 0F 1F 11: libopcodes says nop,
	// but the Intel manuals say that the only NOP there is 0F 1F /0.
	// Perhaps libopcodes is reporting an older encoding.
	i := bytes.IndexByte(dec.enc[:], 0x0F)
	if contains(dec.text, "nop") && i >= 0 && i+2 < len(dec.enc) && dec.enc[i+1]&^7 == 0x18 && (dec.enc[i+1] != 0x1F || (dec.enc[i+2]>>3)&7 != 0) {
		dec.text = "(bad)"
	}

	// Any invalid instruction.
	if text == "BAD" && contains(dec.text, "(bad)") {
		return true
	}

	// Instructions libopcodes knows but we do not (e.g., 0F 19 11).
	if (text == "BAD" || size == 1 && isPrefix(text)) && hasPrefix(dec.text, unsupported...) {
		return true
	}

	// Instructions we know but libopcodes does not (e.g., 0F D0 11).
	if (contains(dec.text, "(bad)") || dec.nenc == 1 && isPrefix(dec.text)) && hasPrefix(text, libopcodesUnsupported...) {
		return true
	}

	// Libopcodes rejects F2 90 as NOP. Not sure why.
	if (contains(dec.text, "(bad)") || dec.nenc == 1 && isPrefix(dec.text)) && inst.Opcode>>24 == 0x90 && countPrefix(inst, 0xF2) > 0 {
		return true
	}

	// 0F 20 11, 0F 21 11, 0F 22 11, 0F 23 11, 0F 24 11:
	// Moves into and out of some control registers seem to be unsupported by libopcodes.
	// TODO(rsc): Are they invalid somehow?
	if (contains(dec.text, "(bad)") || dec.nenc == 1 && isPrefix(dec.text)) && contains(text, "%cr", "%db", "%tr") {
		return true
	}

	if contains(dec.text, "fwait") && dec.nenc == 1 && dec.enc[0] != 0x9B {
		return true
	}

	// 9B D9 11: libopcodes reports FSTSW instead of FWAIT + FNSTSW.
	// This is correct in that FSTSW is a pseudo-op for the pair, but it really
	// is a pair of instructions: execution can stop between them.
	// Our decoder chooses to separate them.
	if (text == "fwait" || strings.HasSuffix(text, " fwait")) && dec.nenc >= len(strings.Fields(text)) && dec.enc[len(strings.Fields(text))-1] == 0x9B {
		return true
	}

	// 0F 18 77 11:
	// Invalid instructions for which libopcodes prints "nop/reserved".
	// Perhaps libopcodes is reporting an older encoding.
	if text == "BAD" && contains(dec.text, "nop/reserved") {
		return true
	}

	// 0F C7 B0 11 22 33 44: libopcodes says vmptrld 0x44332211(%eax); we say rdrand %eax.
	// TODO(rsc): Fix, since we are probably wrong, but we don't have vmptrld in the manual.
	if contains(text, "rdrand") && contains(dec.text, "vmptrld", "vmxon", "vmclear") {
		return true
	}

	// DD C8: libopcodes says FNOP but the Intel manual is clear FNOP is only D9 D0.
	// Perhaps libopcodes is reporting an older encoding.
	if text == "BAD" && contains(dec.text, "fnop") && (dec.enc[0] != 0xD9 || dec.enc[1] != 0xD0) {
		return true
	}

	// 66 90: libopcodes says xchg %ax,%ax; we say 'data16 nop'.
	// The 16-bit swap will preserve the high bits of the register,
	// so they are the same.
	if contains(text, "nop") && contains(dec.text, "xchg %ax,%ax") {
		return true
	}

	// If there are multiple prefixes, allow libopcodes to use an alternate name.
	if size == 1 && dec.nenc == 1 && prefixByte[text] > 0 && prefixByte[text] == prefixByte[dec.text] {
		return true
	}

	// 26 9B: libopcodes reports "fwait"/1, ignoring segment prefix.
	// https://sourceware.org/bugzilla/show_bug.cgi?id=16891
	// F0 82: Decode="lock"/1 but libopcodes="lock (bad)"/2.
	if size == 1 && dec.nenc >= 1 && prefixByte[text] == dec.enc[0] && contains(dec.text, "(bad)", "fwait", "fnop") {
		return true
	}

	// libopcodes interprets 660f801122 as taking a rel16 but
	// truncating the address at 16 bits. Not sure what is correct.
	if contains(text, ".+0x2211", ".+0x11") && contains(dec.text, " .-") {
		return true
	}

	// 66 F3 0F D6 C5, 66 F2 0F D6 C0: libopcodes reports use of XMM register instead of MMX register,
	// but only when the instruction has a 66 prefix. Maybe they know something we don't.
	if countPrefix(inst, 0x66) > 0 && contains(dec.text, "movdq2q", "movq2dq") && !contains(dec.text, "%mm") {
		return true
	}

	// 0F 01 F8, 0F 05, 0F 07: these are 64-bit instructions but libopcodes accepts them.
	if (text == "BAD" || size == 1 && isPrefix(text)) && contains(dec.text, "swapgs", "syscall", "sysret", "rdfsbase", "rdgsbase", "wrfsbase", "wrgsbase") {
		return true
	}

	return false
}

// Instructions known to libopcodes (or xed) but not to us.
// Most of these come from supplementary manuals of one form or another.
var unsupported = strings.Fields(`
	bndc
	bndl
	bndm
	bnds
	clac
	clgi
	femms
	fldln
	fldz
	getsec
	invlpga
	kmov
	montmul
	pavg
	pf2i
	pfacc
	pfadd
	pfcmp
	pfmax
	pfmin
	pfmul
	pfna
	pfpnac
	pfrc
	pfrs
	pfsub
	phadd
	phsub
	pi2f
	pmulhr
	prefetch
	pswap
	ptest
	rdseed
	sha1
	sha256
	skinit
	stac
	stgi
	vadd
	vand
	vcmp
	vcomis
	vcvt
	vcvt
	vdiv
	vhadd
	vhsub
	vld
	vmax
	vmcall
	vmfunc
	vmin
	vmlaunch
	vmload
	vmmcall
	vmov
	vmov
	vmov
	vmptrld
	vmptrst
	vmread
	vmresume
	vmrun
	vmsave
	vmul
	vmwrite
	vmxoff
	vor
	vpack
	vpadd
	vpand
	vpavg
	vpcmp
	vpcmp
	vpins
	vpmadd
	vpmax
	vpmin
	vpmul
	vpmul
	vpor
	vpsad
	vpshuf
	vpsll
	vpsra
	vpsrad
	vpsrl
	vpsub
	vpunp
	vpxor
	vrcp
	vrsqrt
	vshuf
	vsqrt
	vsub
	vucomis
	vunp
	vxor
	vzero
	xcrypt
	xsha1
	xsha256
	xstore-rng
	insertq
	extrq
	vmclear
	invvpid
	adox
	vmxon
	invept
	adcx
	vmclear
	prefetchwt1
	enclu
	encls
	salc
	fstpnce
	fdisi8087_nop
	fsetpm287_nop
	feni8087_nop
	syscall
	sysret
`)

// Instructions known to us but not to libopcodes (at least in binutils 2.24).
var libopcodesUnsupported = strings.Fields(`
	addsubps
	aes
	blend
	cvttpd2dq
	dpp
	extract
	haddps
	hsubps
	insert
	invpcid
	lddqu
	movmsk
	movnt
	movq2dq
	mps
	pack
	pblend
	pclmul
	pcmp
	pext
	phmin
	pins
	pmax
	pmin
	pmov
	pmovmsk
	pmul
	popcnt
	pslld
	psllq
	psllw
	psrad
	psraw
	psrl
	ptest
	punpck
	round
	xrstor
	xsavec
	xsaves
	comis
	ucomis
	movhps
	movntps
	rsqrt
	rcpp
	puncpck
	bsf
	movq2dq
	cvttpd2dq
	movq
	hsubpd
	movdqa
	movhpd
	addsubpd
	movd
	haddpd
	cvtps2dq
	bsr
	cvtdq2ps
	rdrand
	maskmov
	movq2dq
	movlhps
	movbe
	movlpd
`)
                                                                                   usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/objdumpext_test.go              0100644 0000000 0000000 00000017206 13020111412 027315  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"debug/elf"
	"encoding/binary"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"testing"
)

// Apologies for the proprietary path, but we need objdump 2.24 + some committed patches that will land in 2.25.
const objdumpPath = "/Users/rsc/bin/objdump2"

func testObjdump32(t *testing.T, generate func(func([]byte))) {
	testObjdumpArch(t, generate, 32)
}

func testObjdump64(t *testing.T, generate func(func([]byte))) {
	testObjdumpArch(t, generate, 64)
}

func testObjdumpArch(t *testing.T, generate func(func([]byte)), arch int) {
	if testing.Short() {
		t.Skip("skipping objdump test in short mode")
	}
	if _, err := os.Stat(objdumpPath); err != nil {
		t.Skip(err)
	}

	testExtDis(t, "gnu", arch, objdump, generate, allowedMismatchObjdump)
}

func objdump(ext *ExtDis) error {
	// File already written with instructions; add ELF header.
	if ext.Arch == 32 {
		if err := writeELF32(ext.File, ext.Size); err != nil {
			return err
		}
	} else {
		if err := writeELF64(ext.File, ext.Size); err != nil {
			return err
		}
	}

	b, err := ext.Run(objdumpPath, "-d", "-z", ext.File.Name())
	if err != nil {
		return err
	}

	var (
		nmatch  int
		reading bool
		next    uint32 = start
		addr    uint32
		encbuf  [32]byte
		enc     []byte
		text    string
	)
	flush := func() {
		if addr == next {
			switch text {
			case "repz":
				text = "rep"
			case "repnz":
				text = "repn"
			default:
				text = strings.Replace(text, "repz ", "rep ", -1)
				text = strings.Replace(text, "repnz ", "repn ", -1)
			}
			if m := pcrelw.FindStringSubmatch(text); m != nil {
				targ, _ := strconv.ParseUint(m[2], 16, 64)
				text = fmt.Sprintf("%s .%+#x", m[1], int16(uint32(targ)-uint32(uint16(addr))-uint32(len(enc))))
			}
			if m := pcrel.FindStringSubmatch(text); m != nil {
				targ, _ := strconv.ParseUint(m[2], 16, 64)
				text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
			}
			text = strings.Replace(text, "0x0(", "(", -1)
			text = strings.Replace(text, "%st(0)", "%st", -1)

			ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
			encbuf = [32]byte{}
			enc = nil
			next += 32
		}
	}
	var textangle = []byte("<.text>:")
	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading objdump output: %v", err)
		}
		if bytes.Contains(line, textangle) {
			reading = true
			continue
		}
		if !reading {
			continue
		}
		if debug {
			os.Stdout.Write(line)
		}
		if enc1 := parseContinuation(line, encbuf[:len(enc)]); enc1 != nil {
			enc = enc1
			continue
		}
		flush()
		nmatch++
		addr, enc, text = parseLine(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
	}
	flush()
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

func parseLine(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	oline := line
	i := index(line, ":\t")
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	x, err := strconv.ParseUint(string(trimSpace(line[:i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	addr = uint32(x)
	line = line[i+2:]
	i = bytes.IndexByte(line, '\t')
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	enc, ok := parseHex(line[:i], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	line = trimSpace(line[i:])
	if i := bytes.IndexByte(line, '#'); i >= 0 {
		line = trimSpace(line[:i])
	}
	text = string(fixSpace(line))
	return
}

func parseContinuation(line []byte, enc []byte) []byte {
	i := index(line, ":\t")
	if i < 0 {
		return nil
	}
	line = line[i+1:]
	enc, _ = parseHex(line, enc)
	return enc
}

// writeELF32 writes an ELF32 header to the file,
// describing a text segment that starts at start
// and extends for size bytes.
func writeELF32(f *os.File, size int) error {
	f.Seek(0, 0)
	var hdr elf.Header32
	var prog elf.Prog32
	var sect elf.Section32
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, &hdr)
	off1 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &prog)
	off2 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &sect)
	off3 := buf.Len()
	buf.Reset()
	data := byte(elf.ELFDATA2LSB)
	hdr = elf.Header32{
		Ident:     [16]byte{0x7F, 'E', 'L', 'F', 1, data, 1},
		Type:      2,
		Machine:   uint16(elf.EM_386),
		Version:   1,
		Entry:     start,
		Phoff:     uint32(off1),
		Shoff:     uint32(off2),
		Flags:     0x05000002,
		Ehsize:    uint16(off1),
		Phentsize: uint16(off2 - off1),
		Phnum:     1,
		Shentsize: uint16(off3 - off2),
		Shnum:     3,
		Shstrndx:  2,
	}
	binary.Write(&buf, binary.LittleEndian, &hdr)
	prog = elf.Prog32{
		Type:   1,
		Off:    start,
		Vaddr:  start,
		Paddr:  start,
		Filesz: uint32(size),
		Memsz:  uint32(size),
		Flags:  5,
		Align:  start,
	}
	binary.Write(&buf, binary.LittleEndian, &prog)
	binary.Write(&buf, binary.LittleEndian, &sect) // NULL section
	sect = elf.Section32{
		Name:      1,
		Type:      uint32(elf.SHT_PROGBITS),
		Addr:      start,
		Off:       start,
		Size:      uint32(size),
		Flags:     uint32(elf.SHF_ALLOC | elf.SHF_EXECINSTR),
		Addralign: 4,
	}
	binary.Write(&buf, binary.LittleEndian, &sect) // .text
	sect = elf.Section32{
		Name:      uint32(len("\x00.text\x00")),
		Type:      uint32(elf.SHT_STRTAB),
		Addr:      0,
		Off:       uint32(off2 + (off3-off2)*3),
		Size:      uint32(len("\x00.text\x00.shstrtab\x00")),
		Addralign: 1,
	}
	binary.Write(&buf, binary.LittleEndian, &sect)
	buf.WriteString("\x00.text\x00.shstrtab\x00")
	f.Write(buf.Bytes())
	return nil
}

// writeELF64 writes an ELF64 header to the file,
// describing a text segment that starts at start
// and extends for size bytes.
func writeELF64(f *os.File, size int) error {
	f.Seek(0, 0)
	var hdr elf.Header64
	var prog elf.Prog64
	var sect elf.Section64
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, &hdr)
	off1 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &prog)
	off2 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &sect)
	off3 := buf.Len()
	buf.Reset()
	data := byte(elf.ELFDATA2LSB)
	hdr = elf.Header64{
		Ident:     [16]byte{0x7F, 'E', 'L', 'F', 2, data, 1},
		Type:      2,
		Machine:   uint16(elf.EM_X86_64),
		Version:   1,
		Entry:     start,
		Phoff:     uint64(off1),
		Shoff:     uint64(off2),
		Flags:     0x05000002,
		Ehsize:    uint16(off1),
		Phentsize: uint16(off2 - off1),
		Phnum:     1,
		Shentsize: uint16(off3 - off2),
		Shnum:     3,
		Shstrndx:  2,
	}
	binary.Write(&buf, binary.LittleEndian, &hdr)
	prog = elf.Prog64{
		Type:   1,
		Off:    start,
		Vaddr:  start,
		Paddr:  start,
		Filesz: uint64(size),
		Memsz:  uint64(size),
		Flags:  5,
		Align:  start,
	}
	binary.Write(&buf, binary.LittleEndian, &prog)
	binary.Write(&buf, binary.LittleEndian, &sect) // NULL section
	sect = elf.Section64{
		Name:      1,
		Type:      uint32(elf.SHT_PROGBITS),
		Addr:      start,
		Off:       start,
		Size:      uint64(size),
		Flags:     uint64(elf.SHF_ALLOC | elf.SHF_EXECINSTR),
		Addralign: 4,
	}
	binary.Write(&buf, binary.LittleEndian, &sect) // .text
	sect = elf.Section64{
		Name:      uint32(len("\x00.text\x00")),
		Type:      uint32(elf.SHT_STRTAB),
		Addr:      0,
		Off:       uint64(off2 + (off3-off2)*3),
		Size:      uint64(len("\x00.text\x00.shstrtab\x00")),
		Addralign: 1,
	}
	binary.Write(&buf, binary.LittleEndian, &sect)
	buf.WriteString("\x00.text\x00.shstrtab\x00")
	f.Write(buf.Bytes())
	return nil
}
                                                                                                                                                                                                                                                                                                                                                                                          usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/plan9ext_test.go                0100644 0000000 0000000 00000005404 13020111412 026675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"testing"
)

const plan9Path = "testdata/libmach8db"

func testPlan9Arch(t *testing.T, arch int, generate func(func([]byte))) {
	if testing.Short() {
		t.Skip("skipping libmach test in short mode")
	}
	if _, err := os.Stat(plan9Path); err != nil {
		t.Skip(err)
	}

	testExtDis(t, "plan9", arch, plan9, generate, allowedMismatchPlan9)
}

func testPlan932(t *testing.T, generate func(func([]byte))) {
	testPlan9Arch(t, 32, generate)
}

func testPlan964(t *testing.T, generate func(func([]byte))) {
	testPlan9Arch(t, 64, generate)
}

func plan9(ext *ExtDis) error {
	flag := "-8"
	if ext.Arch == 64 {
		flag = "-6"
	}
	b, err := ext.Run(plan9Path, flag, ext.File.Name())
	if err != nil {
		return err
	}

	nmatch := 0
	next := uint32(start)
	var (
		addr   uint32
		encbuf [32]byte
		enc    []byte
		text   string
	)

	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading libmach8db output: %v", err)
		}
		if debug {
			os.Stdout.Write(line)
		}
		nmatch++
		addr, enc, text = parseLinePlan9(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
		if addr < next {
			continue
		}
		if m := pcrelw.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int16(uint32(targ)-uint32(uint16(addr))-uint32(len(enc))))
		}
		if m := pcrel.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
		}
		ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
		encbuf = [32]byte{}
		enc = nil
		next += 32
	}
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

func parseLinePlan9(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	i := bytes.IndexByte(line, ' ')
	if i < 0 || line[0] != '0' || line[1] != 'x' {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	j := bytes.IndexByte(line[i+1:], ' ')
	if j < 0 {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	j += i + 1
	x, err := strconv.ParseUint(string(trimSpace(line[2:i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	addr = uint32(x)
	enc, ok := parseHex(line[i+1:j], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	return addr, enc, string(fixSpace(line[j+1:]))
}
                                                                                                                                                                                                                                                            usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/plan9x.go                       0100644 0000000 0000000 00000014326 13020111412 025310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"fmt"
	"strings"
)

// GoSyntax returns the Go assembler syntax for the instruction.
// The syntax was originally defined by Plan 9.
// The pc is the program counter of the instruction, used for expanding
// PC-relative addresses into absolute ones.
// The symname function queries the symbol table for the program
// being disassembled. Given a target address it returns the name and base
// address of the symbol containing the target, if any; otherwise it returns "", 0.
func GoSyntax(inst Inst, pc uint64, symname func(uint64) (string, uint64)) string {
	if symname == nil {
		symname = func(uint64) (string, uint64) { return "", 0 }
	}
	var args []string
	for i := len(inst.Args) - 1; i >= 0; i-- {
		a := inst.Args[i]
		if a == nil {
			continue
		}
		args = append(args, plan9Arg(&inst, pc, symname, a))
	}

	var last Prefix
	for _, p := range inst.Prefix {
		if p == 0 || p.IsREX() {
			break
		}
		last = p
	}

	prefix := ""
	switch last & 0xFF {
	case 0, 0x66, 0x67:
		// ignore
	case PrefixREPN:
		prefix += "REPNE "
	default:
		prefix += last.String() + " "
	}

	op := inst.Op.String()
	if plan9Suffix[inst.Op] {
		switch inst.DataSize {
		case 8:
			op += "B"
		case 16:
			op += "W"
		case 32:
			op += "L"
		case 64:
			op += "Q"
		}
	}

	if args != nil {
		op += " " + strings.Join(args, ", ")
	}

	return prefix + op
}

func plan9Arg(inst *Inst, pc uint64, symname func(uint64) (string, uint64), arg Arg) string {
	switch a := arg.(type) {
	case Reg:
		return plan9Reg[a]
	case Rel:
		if pc == 0 {
			break
		}
		// If the absolute address is the start of a symbol, use the name.
		// Otherwise use the raw address, so that things like relative
		// jumps show up as JMP 0x123 instead of JMP f+10(SB).
		// It is usually easier to search for 0x123 than to do the mental
		// arithmetic to find f+10.
		addr := pc + uint64(inst.Len) + uint64(a)
		if s, base := symname(addr); s != "" && addr == base {
			return fmt.Sprintf("%s(SB)", s)
		}
		return fmt.Sprintf("%#x", addr)

	case Imm:
		if s, base := symname(uint64(a)); s != "" {
			suffix := ""
			if uint64(a) != base {
				suffix = fmt.Sprintf("%+d", uint64(a)-base)
			}
			return fmt.Sprintf("$%s%s(SB)", s, suffix)
		}
		if inst.Mode == 32 {
			return fmt.Sprintf("$%#x", uint32(a))
		}
		if Imm(int32(a)) == a {
			return fmt.Sprintf("$%#x", int64(a))
		}
		return fmt.Sprintf("$%#x", uint64(a))
	case Mem:
		if a.Segment == 0 && a.Disp != 0 && a.Base == 0 && (a.Index == 0 || a.Scale == 0) {
			if s, base := symname(uint64(a.Disp)); s != "" {
				suffix := ""
				if uint64(a.Disp) != base {
					suffix = fmt.Sprintf("%+d", uint64(a.Disp)-base)
				}
				return fmt.Sprintf("%s%s(SB)", s, suffix)
			}
		}
		s := ""
		if a.Segment != 0 {
			s += fmt.Sprintf("%s:", plan9Reg[a.Segment])
		}
		if a.Disp != 0 {
			s += fmt.Sprintf("%#x", a.Disp)
		} else {
			s += "0"
		}
		if a.Base != 0 {
			s += fmt.Sprintf("(%s)", plan9Reg[a.Base])
		}
		if a.Index != 0 && a.Scale != 0 {
			s += fmt.Sprintf("(%s*%d)", plan9Reg[a.Index], a.Scale)
		}
		return s
	}
	return arg.String()
}

var plan9Suffix = [maxOp + 1]bool{
	ADC:       true,
	ADD:       true,
	AND:       true,
	BSF:       true,
	BSR:       true,
	BT:        true,
	BTC:       true,
	BTR:       true,
	BTS:       true,
	CMP:       true,
	CMPXCHG:   true,
	CVTSI2SD:  true,
	CVTSI2SS:  true,
	CVTSD2SI:  true,
	CVTSS2SI:  true,
	CVTTSD2SI: true,
	CVTTSS2SI: true,
	DEC:       true,
	DIV:       true,
	FLDENV:    true,
	FRSTOR:    true,
	IDIV:      true,
	IMUL:      true,
	IN:        true,
	INC:       true,
	LEA:       true,
	MOV:       true,
	MOVNTI:    true,
	MUL:       true,
	NEG:       true,
	NOP:       true,
	NOT:       true,
	OR:        true,
	OUT:       true,
	POP:       true,
	POPA:      true,
	PUSH:      true,
	PUSHA:     true,
	RCL:       true,
	RCR:       true,
	ROL:       true,
	ROR:       true,
	SAR:       true,
	SBB:       true,
	SHL:       true,
	SHLD:      true,
	SHR:       true,
	SHRD:      true,
	SUB:       true,
	TEST:      true,
	XADD:      true,
	XCHG:      true,
	XOR:       true,
}

var plan9Reg = [...]string{
	AL:   "AL",
	CL:   "CL",
	BL:   "BL",
	DL:   "DL",
	AH:   "AH",
	CH:   "CH",
	BH:   "BH",
	DH:   "DH",
	SPB:  "SP",
	BPB:  "BP",
	SIB:  "SI",
	DIB:  "DI",
	R8B:  "R8",
	R9B:  "R9",
	R10B: "R10",
	R11B: "R11",
	R12B: "R12",
	R13B: "R13",
	R14B: "R14",
	R15B: "R15",
	AX:   "AX",
	CX:   "CX",
	BX:   "BX",
	DX:   "DX",
	SP:   "SP",
	BP:   "BP",
	SI:   "SI",
	DI:   "DI",
	R8W:  "R8",
	R9W:  "R9",
	R10W: "R10",
	R11W: "R11",
	R12W: "R12",
	R13W: "R13",
	R14W: "R14",
	R15W: "R15",
	EAX:  "AX",
	ECX:  "CX",
	EDX:  "DX",
	EBX:  "BX",
	ESP:  "SP",
	EBP:  "BP",
	ESI:  "SI",
	EDI:  "DI",
	R8L:  "R8",
	R9L:  "R9",
	R10L: "R10",
	R11L: "R11",
	R12L: "R12",
	R13L: "R13",
	R14L: "R14",
	R15L: "R15",
	RAX:  "AX",
	RCX:  "CX",
	RDX:  "DX",
	RBX:  "BX",
	RSP:  "SP",
	RBP:  "BP",
	RSI:  "SI",
	RDI:  "DI",
	R8:   "R8",
	R9:   "R9",
	R10:  "R10",
	R11:  "R11",
	R12:  "R12",
	R13:  "R13",
	R14:  "R14",
	R15:  "R15",
	IP:   "IP",
	EIP:  "IP",
	RIP:  "IP",
	F0:   "F0",
	F1:   "F1",
	F2:   "F2",
	F3:   "F3",
	F4:   "F4",
	F5:   "F5",
	F6:   "F6",
	F7:   "F7",
	M0:   "M0",
	M1:   "M1",
	M2:   "M2",
	M3:   "M3",
	M4:   "M4",
	M5:   "M5",
	M6:   "M6",
	M7:   "M7",
	X0:   "X0",
	X1:   "X1",
	X2:   "X2",
	X3:   "X3",
	X4:   "X4",
	X5:   "X5",
	X6:   "X6",
	X7:   "X7",
	X8:   "X8",
	X9:   "X9",
	X10:  "X10",
	X11:  "X11",
	X12:  "X12",
	X13:  "X13",
	X14:  "X14",
	X15:  "X15",
	CS:   "CS",
	SS:   "SS",
	DS:   "DS",
	ES:   "ES",
	FS:   "FS",
	GS:   "GS",
	GDTR: "GDTR",
	IDTR: "IDTR",
	LDTR: "LDTR",
	MSW:  "MSW",
	TASK: "TASK",
	CR0:  "CR0",
	CR1:  "CR1",
	CR2:  "CR2",
	CR3:  "CR3",
	CR4:  "CR4",
	CR5:  "CR5",
	CR6:  "CR6",
	CR7:  "CR7",
	CR8:  "CR8",
	CR9:  "CR9",
	CR10: "CR10",
	CR11: "CR11",
	CR12: "CR12",
	CR13: "CR13",
	CR14: "CR14",
	CR15: "CR15",
	DR0:  "DR0",
	DR1:  "DR1",
	DR2:  "DR2",
	DR3:  "DR3",
	DR4:  "DR4",
	DR5:  "DR5",
	DR6:  "DR6",
	DR7:  "DR7",
	DR8:  "DR8",
	DR9:  "DR9",
	DR10: "DR10",
	DR11: "DR11",
	DR12: "DR12",
	DR13: "DR13",
	DR14: "DR14",
	DR15: "DR15",
	TR0:  "TR0",
	TR1:  "TR1",
	TR2:  "TR2",
	TR3:  "TR3",
	TR4:  "TR4",
	TR5:  "TR5",
	TR6:  "TR6",
	TR7:  "TR7",
}
                                                                                                                                                                                                                                                                                                          usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/plan9x_test.go                  0100644 0000000 0000000 00000005315 13020111412 026345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"strings"
	"testing"
)

func TestPlan932Manual(t *testing.T)   { testPlan932(t, hexCases(t, plan9ManualTests)) }
func TestPlan932Testdata(t *testing.T) { testPlan932(t, concat(basicPrefixes, testdataCases(t))) }
func TestPlan932ModRM(t *testing.T)    { testPlan932(t, concat(basicPrefixes, enumModRM)) }
func TestPlan932OneByte(t *testing.T)  { testBasic(t, testPlan932) }
func TestPlan9320F(t *testing.T)       { testBasic(t, testPlan932, 0x0F) }
func TestPlan9320F38(t *testing.T)     { testBasic(t, testPlan932, 0x0F, 0x38) }
func TestPlan9320F3A(t *testing.T)     { testBasic(t, testPlan932, 0x0F, 0x3A) }
func TestPlan932Prefix(t *testing.T)   { testPrefix(t, testPlan932) }

func TestPlan964Manual(t *testing.T)   { testPlan964(t, hexCases(t, plan9ManualTests)) }
func TestPlan964Testdata(t *testing.T) { testPlan964(t, concat(basicPrefixes, testdataCases(t))) }
func TestPlan964ModRM(t *testing.T)    { testPlan964(t, concat(basicPrefixes, enumModRM)) }
func TestPlan964OneByte(t *testing.T)  { testBasic(t, testPlan964) }
func TestPlan9640F(t *testing.T)       { testBasic(t, testPlan964, 0x0F) }
func TestPlan9640F38(t *testing.T)     { testBasic(t, testPlan964, 0x0F, 0x38) }
func TestPlan9640F3A(t *testing.T)     { testBasic(t, testPlan964, 0x0F, 0x3A) }
func TestPlan964Prefix(t *testing.T)   { testPrefix(t, testPlan964) }

func TestPlan964REXTestdata(t *testing.T) {
	testPlan964(t, filter(concat3(basicPrefixes, rexPrefixes, testdataCases(t)), isValidREX))
}
func TestPlan964REXModRM(t *testing.T)   { testPlan964(t, concat3(basicPrefixes, rexPrefixes, enumModRM)) }
func TestPlan964REXOneByte(t *testing.T) { testBasicREX(t, testPlan964) }
func TestPlan964REX0F(t *testing.T)      { testBasicREX(t, testPlan964, 0x0F) }
func TestPlan964REX0F38(t *testing.T)    { testBasicREX(t, testPlan964, 0x0F, 0x38) }
func TestPlan964REX0F3A(t *testing.T)    { testBasicREX(t, testPlan964, 0x0F, 0x3A) }
func TestPlan964REXPrefix(t *testing.T)  { testPrefixREX(t, testPlan964) }

// plan9ManualTests holds test cases that will be run by TestPlan9Manual32 and TestPlan9Manual64.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=Plan9Manual, particularly with tracing enabled.
var plan9ManualTests = `
`

// allowedMismatchPlan9 reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchPlan9(text string, size int, inst *Inst, dec ExtInst) bool {
	return false
}

// Instructions known to us but not to plan9.
var plan9Unsupported = strings.Fields(`
`)
                                                                                                                                                                                                                                                                                                                   usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/tables.go                       0100644 0000000 0000000 00001014612 13020111412 025346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // DO NOT EDIT
// generated by: x86map -fmt=decoder ../x86.csv

package x86asm

var decoder = [...]uint16{
	uint16(xFail),
	/*1*/ uint16(xCondByte), 243,
	0x00, 490,
	0x01, 496,
	0x02, 525,
	0x03, 531,
	0x04, 560,
	0x05, 566,
	0x06, 595,
	0x07, 602,
	0x08, 609,
	0x09, 615,
	0x0A, 644,
	0x0B, 650,
	0x0C, 679,
	0x0D, 685,
	0x0E, 714,
	0x0F, 721,
	0x10, 8026,
	0x11, 8032,
	0x12, 8061,
	0x13, 8067,
	0x14, 8096,
	0x15, 8102,
	0x16, 8131,
	0x17, 8138,
	0x18, 8145,
	0x19, 8151,
	0x1A, 8180,
	0x1B, 8186,
	0x1C, 8215,
	0x1D, 8221,
	0x1E, 8250,
	0x1F, 8257,
	0x20, 8264,
	0x21, 8270,
	0x22, 8299,
	0x23, 8305,
	0x24, 8334,
	0x25, 8340,
	0x27, 8369,
	0x28, 8375,
	0x29, 8381,
	0x2A, 8410,
	0x2B, 8416,
	0x2C, 8445,
	0x2D, 8451,
	0x2F, 8480,
	0x30, 8486,
	0x31, 8492,
	0x32, 8521,
	0x33, 8527,
	0x34, 8556,
	0x35, 8562,
	0x37, 8591,
	0x38, 8597,
	0x39, 8603,
	0x3A, 8632,
	0x3B, 8638,
	0x3C, 8667,
	0x3D, 8673,
	0x3F, 8702,
	0x40, 8708,
	0x41, 8708,
	0x42, 8708,
	0x43, 8708,
	0x44, 8708,
	0x45, 8708,
	0x46, 8708,
	0x47, 8708,
	0x48, 8723,
	0x49, 8723,
	0x4a, 8723,
	0x4b, 8723,
	0x4c, 8723,
	0x4d, 8723,
	0x4e, 8723,
	0x4f, 8723,
	0x50, 8738,
	0x51, 8738,
	0x52, 8738,
	0x53, 8738,
	0x54, 8738,
	0x55, 8738,
	0x56, 8738,
	0x57, 8738,
	0x58, 8765,
	0x59, 8765,
	0x5a, 8765,
	0x5b, 8765,
	0x5c, 8765,
	0x5d, 8765,
	0x5e, 8765,
	0x5f, 8765,
	0x60, 8792,
	0x61, 8805,
	0x62, 8818,
	0x63, 8837,
	0x68, 8868,
	0x69, 8887,
	0x6A, 8922,
	0x6B, 8927,
	0x6C, 8962,
	0x6D, 8965,
	0x6E, 8978,
	0x6F, 8981,
	0x70, 8994,
	0x71, 8999,
	0x72, 9004,
	0x73, 9009,
	0x74, 9014,
	0x75, 9019,
	0x76, 9024,
	0x77, 9029,
	0x78, 9034,
	0x79, 9039,
	0x7A, 9044,
	0x7B, 9049,
	0x7C, 9054,
	0x7D, 9059,
	0x7E, 9064,
	0x7F, 9069,
	0x80, 9074,
	0x81, 9131,
	0x83, 9372,
	0x84, 9613,
	0x85, 9619,
	0x86, 9648,
	0x87, 9654,
	0x88, 9683,
	0x89, 9689,
	0x8A, 9711,
	0x8B, 9717,
	0x8C, 9739,
	0x8D, 9768,
	0x8E, 9797,
	0x8F, 9826,
	0x90, 9862,
	0x91, 9862,
	0x92, 9862,
	0x93, 9862,
	0x94, 9862,
	0x95, 9862,
	0x96, 9862,
	0x97, 9862,
	0x98, 9888,
	0x99, 9908,
	0x9A, 9928,
	0x9B, 9945,
	0x9C, 9948,
	0x9D, 9971,
	0x9E, 9994,
	0x9F, 9997,
	0xA0, 10000,
	0xA1, 10019,
	0xA2, 10041,
	0xA3, 10060,
	0xA4, 10082,
	0xA5, 10085,
	0xA6, 10105,
	0xA7, 10108,
	0xA8, 10128,
	0xA9, 10134,
	0xAA, 10163,
	0xAB, 10166,
	0xAC, 10186,
	0xAD, 10189,
	0xAE, 10209,
	0xAF, 10212,
	0xb0, 10232,
	0xb1, 10232,
	0xb2, 10232,
	0xb3, 10232,
	0xb4, 10232,
	0xb5, 10232,
	0xb6, 10232,
	0xb7, 10232,
	0xb8, 10238,
	0xb9, 10238,
	0xba, 10238,
	0xbb, 10238,
	0xbc, 10238,
	0xbd, 10238,
	0xbe, 10238,
	0xbf, 10238,
	0xC0, 10267,
	0xC1, 10318,
	0xC2, 10516,
	0xC3, 10521,
	0xC4, 10524,
	0xC5, 10543,
	0xC6, 10562,
	0xC7, 10586,
	0xC8, 10647,
	0xC9, 10654,
	0xCA, 10677,
	0xCB, 10682,
	0xCC, 10685,
	0xCD, 10689,
	0xCE, 10694,
	0xCF, 10700,
	0xD0, 10720,
	0xD1, 10764,
	0xD2, 10955,
	0xD3, 10999,
	0xD4, 11190,
	0xD5, 11198,
	0xD7, 11206,
	0xD8, 11219,
	0xD9, 11428,
	0xDA, 11637,
	0xDB, 11769,
	0xDC, 11940,
	0xDD, 12109,
	0xDE, 12248,
	0xDF, 12422,
	0xE0, 12533,
	0xE1, 12538,
	0xE2, 12543,
	0xE3, 12548,
	0xE4, 12574,
	0xE5, 12580,
	0xE6, 12602,
	0xE7, 12608,
	0xE8, 12630,
	0xE9, 12661,
	0xEA, 12692,
	0xEB, 12709,
	0xEC, 12714,
	0xED, 12719,
	0xEE, 12738,
	0xEF, 12743,
	0xF1, 12762,
	0xF4, 12765,
	0xF5, 12768,
	0xF6, 12771,
	0xF7, 12810,
	0xF8, 12986,
	0xF9, 12989,
	0xFA, 12992,
	0xFB, 12995,
	0xFC, 12998,
	0xFD, 13001,
	0xFE, 13004,
	0xFF, 13021,
	uint16(xFail),
	/*490*/ uint16(xSetOp), uint16(ADD),
	/*492*/ uint16(xReadSlashR),
	/*493*/ uint16(xArgRM8),
	/*494*/ uint16(xArgR8),
	/*495*/ uint16(xMatch),
	/*496*/ uint16(xCondIs64), 499, 515,
	/*499*/ uint16(xCondDataSize), 503, 509, 0,
	/*503*/ uint16(xSetOp), uint16(ADD),
	/*505*/ uint16(xReadSlashR),
	/*506*/ uint16(xArgRM16),
	/*507*/ uint16(xArgR16),
	/*508*/ uint16(xMatch),
	/*509*/ uint16(xSetOp), uint16(ADD),
	/*511*/ uint16(xReadSlashR),
	/*512*/ uint16(xArgRM32),
	/*513*/ uint16(xArgR32),
	/*514*/ uint16(xMatch),
	/*515*/ uint16(xCondDataSize), 503, 509, 519,
	/*519*/ uint16(xSetOp), uint16(ADD),
	/*521*/ uint16(xReadSlashR),
	/*522*/ uint16(xArgRM64),
	/*523*/ uint16(xArgR64),
	/*524*/ uint16(xMatch),
	/*525*/ uint16(xSetOp), uint16(ADD),
	/*527*/ uint16(xReadSlashR),
	/*528*/ uint16(xArgR8),
	/*529*/ uint16(xArgRM8),
	/*530*/ uint16(xMatch),
	/*531*/ uint16(xCondIs64), 534, 550,
	/*534*/ uint16(xCondDataSize), 538, 544, 0,
	/*538*/ uint16(xSetOp), uint16(ADD),
	/*540*/ uint16(xReadSlashR),
	/*541*/ uint16(xArgR16),
	/*542*/ uint16(xArgRM16),
	/*543*/ uint16(xMatch),
	/*544*/ uint16(xSetOp), uint16(ADD),
	/*546*/ uint16(xReadSlashR),
	/*547*/ uint16(xArgR32),
	/*548*/ uint16(xArgRM32),
	/*549*/ uint16(xMatch),
	/*550*/ uint16(xCondDataSize), 538, 544, 554,
	/*554*/ uint16(xSetOp), uint16(ADD),
	/*556*/ uint16(xReadSlashR),
	/*557*/ uint16(xArgR64),
	/*558*/ uint16(xArgRM64),
	/*559*/ uint16(xMatch),
	/*560*/ uint16(xSetOp), uint16(ADD),
	/*562*/ uint16(xReadIb),
	/*563*/ uint16(xArgAL),
	/*564*/ uint16(xArgImm8u),
	/*565*/ uint16(xMatch),
	/*566*/ uint16(xCondIs64), 569, 585,
	/*569*/ uint16(xCondDataSize), 573, 579, 0,
	/*573*/ uint16(xSetOp), uint16(ADD),
	/*575*/ uint16(xReadIw),
	/*576*/ uint16(xArgAX),
	/*577*/ uint16(xArgImm16),
	/*578*/ uint16(xMatch),
	/*579*/ uint16(xSetOp), uint16(ADD),
	/*581*/ uint16(xReadId),
	/*582*/ uint16(xArgEAX),
	/*583*/ uint16(xArgImm32),
	/*584*/ uint16(xMatch),
	/*585*/ uint16(xCondDataSize), 573, 579, 589,
	/*589*/ uint16(xSetOp), uint16(ADD),
	/*591*/ uint16(xReadId),
	/*592*/ uint16(xArgRAX),
	/*593*/ uint16(xArgImm32),
	/*594*/ uint16(xMatch),
	/*595*/ uint16(xCondIs64), 598, 0,
	/*598*/ uint16(xSetOp), uint16(PUSH),
	/*600*/ uint16(xArgES),
	/*601*/ uint16(xMatch),
	/*602*/ uint16(xCondIs64), 605, 0,
	/*605*/ uint16(xSetOp), uint16(POP),
	/*607*/ uint16(xArgES),
	/*608*/ uint16(xMatch),
	/*609*/ uint16(xSetOp), uint16(OR),
	/*611*/ uint16(xReadSlashR),
	/*612*/ uint16(xArgRM8),
	/*613*/ uint16(xArgR8),
	/*614*/ uint16(xMatch),
	/*615*/ uint16(xCondIs64), 618, 634,
	/*618*/ uint16(xCondDataSize), 622, 628, 0,
	/*622*/ uint16(xSetOp), uint16(OR),
	/*624*/ uint16(xReadSlashR),
	/*625*/ uint16(xArgRM16),
	/*626*/ uint16(xArgR16),
	/*627*/ uint16(xMatch),
	/*628*/ uint16(xSetOp), uint16(OR),
	/*630*/ uint16(xReadSlashR),
	/*631*/ uint16(xArgRM32),
	/*632*/ uint16(xArgR32),
	/*633*/ uint16(xMatch),
	/*634*/ uint16(xCondDataSize), 622, 628, 638,
	/*638*/ uint16(xSetOp), uint16(OR),
	/*640*/ uint16(xReadSlashR),
	/*641*/ uint16(xArgRM64),
	/*642*/ uint16(xArgR64),
	/*643*/ uint16(xMatch),
	/*644*/ uint16(xSetOp), uint16(OR),
	/*646*/ uint16(xReadSlashR),
	/*647*/ uint16(xArgR8),
	/*648*/ uint16(xArgRM8),
	/*649*/ uint16(xMatch),
	/*650*/ uint16(xCondIs64), 653, 669,
	/*653*/ uint16(xCondDataSize), 657, 663, 0,
	/*657*/ uint16(xSetOp), uint16(OR),
	/*659*/ uint16(xReadSlashR),
	/*660*/ uint16(xArgR16),
	/*661*/ uint16(xArgRM16),
	/*662*/ uint16(xMatch),
	/*663*/ uint16(xSetOp), uint16(OR),
	/*665*/ uint16(xReadSlashR),
	/*666*/ uint16(xArgR32),
	/*667*/ uint16(xArgRM32),
	/*668*/ uint16(xMatch),
	/*669*/ uint16(xCondDataSize), 657, 663, 673,
	/*673*/ uint16(xSetOp), uint16(OR),
	/*675*/ uint16(xReadSlashR),
	/*676*/ uint16(xArgR64),
	/*677*/ uint16(xArgRM64),
	/*678*/ uint16(xMatch),
	/*679*/ uint16(xSetOp), uint16(OR),
	/*681*/ uint16(xReadIb),
	/*682*/ uint16(xArgAL),
	/*683*/ uint16(xArgImm8u),
	/*684*/ uint16(xMatch),
	/*685*/ uint16(xCondIs64), 688, 704,
	/*688*/ uint16(xCondDataSize), 692, 698, 0,
	/*692*/ uint16(xSetOp), uint16(OR),
	/*694*/ uint16(xReadIw),
	/*695*/ uint16(xArgAX),
	/*696*/ uint16(xArgImm16),
	/*697*/ uint16(xMatch),
	/*698*/ uint16(xSetOp), uint16(OR),
	/*700*/ uint16(xReadId),
	/*701*/ uint16(xArgEAX),
	/*702*/ uint16(xArgImm32),
	/*703*/ uint16(xMatch),
	/*704*/ uint16(xCondDataSize), 692, 698, 708,
	/*708*/ uint16(xSetOp), uint16(OR),
	/*710*/ uint16(xReadId),
	/*711*/ uint16(xArgRAX),
	/*712*/ uint16(xArgImm32),
	/*713*/ uint16(xMatch),
	/*714*/ uint16(xCondIs64), 717, 0,
	/*717*/ uint16(xSetOp), uint16(PUSH),
	/*719*/ uint16(xArgCS),
	/*720*/ uint16(xMatch),
	/*721*/ uint16(xCondByte), 228,
	0x00, 1180,
	0x01, 1237,
	0x02, 1345,
	0x03, 1367,
	0x05, 1389,
	0x06, 1395,
	0x07, 1398,
	0x08, 1404,
	0x09, 1407,
	0x0B, 1410,
	0x0D, 1413,
	0x10, 1426,
	0x11, 1460,
	0x12, 1494,
	0x13, 1537,
	0x14, 1555,
	0x15, 1573,
	0x16, 1591,
	0x17, 1626,
	0x18, 1644,
	0x1F, 1669,
	0x20, 1690,
	0x21, 1705,
	0x22, 1720,
	0x23, 1735,
	0x24, 1750,
	0x26, 1765,
	0x28, 1780,
	0x29, 1798,
	0x2A, 1816,
	0x2B, 1903,
	0x2C, 1937,
	0x2D, 2024,
	0x2E, 2111,
	0x2F, 2129,
	0x30, 2147,
	0x31, 2150,
	0x32, 2153,
	0x33, 2156,
	0x34, 2159,
	0x35, 2162,
	0x38, 2172,
	0x3A, 3073,
	0x40, 3484,
	0x41, 3513,
	0x42, 3542,
	0x43, 3571,
	0x44, 3600,
	0x45, 3629,
	0x46, 3658,
	0x47, 3687,
	0x48, 3716,
	0x49, 3745,
	0x4A, 3774,
	0x4B, 3803,
	0x4C, 3832,
	0x4D, 3861,
	0x4E, 3890,
	0x4F, 3919,
	0x50, 3948,
	0x51, 3966,
	0x52, 4000,
	0x53, 4018,
	0x54, 4036,
	0x55, 4054,
	0x56, 4072,
	0x57, 4090,
	0x58, 4108,
	0x59, 4142,
	0x5A, 4176,
	0x5B, 4210,
	0x5C, 4236,
	0x5D, 4270,
	0x5E, 4304,
	0x5F, 4338,
	0x60, 4372,
	0x61, 4390,
	0x62, 4408,
	0x63, 4426,
	0x64, 4444,
	0x65, 4462,
	0x66, 4480,
	0x67, 4498,
	0x68, 4516,
	0x69, 4534,
	0x6A, 4552,
	0x6B, 4570,
	0x6C, 4588,
	0x6D, 4598,
	0x6E, 4608,
	0x6F, 4675,
	0x70, 4701,
	0x71, 4743,
	0x72, 4806,
	0x73, 4869,
	0x74, 4934,
	0x75, 4952,
	0x76, 4970,
	0x77, 4988,
	0x7C, 4991,
	0x7D, 5009,
	0x7E, 5027,
	0x7F, 5104,
	0x80, 5130,
	0x81, 5161,
	0x82, 5192,
	0x83, 5223,
	0x84, 5254,
	0x85, 5285,
	0x86, 5316,
	0x87, 5347,
	0x88, 5378,
	0x89, 5409,
	0x8A, 5440,
	0x8B, 5471,
	0x8C, 5502,
	0x8D, 5533,
	0x8E, 5564,
	0x8F, 5595,
	0x90, 5626,
	0x91, 5631,
	0x92, 5636,
	0x93, 5641,
	0x94, 5646,
	0x95, 5651,
	0x96, 5656,
	0x97, 5661,
	0x98, 5666,
	0x99, 5671,
	0x9A, 5676,
	0x9B, 5681,
	0x9C, 5686,
	0x9D, 5691,
	0x9E, 5696,
	0x9F, 5701,
	0xA0, 5706,
	0xA1, 5710,
	0xA2, 5737,
	0xA3, 5740,
	0xA4, 5769,
	0xA5, 5804,
	0xA8, 5836,
	0xA9, 5840,
	0xAA, 5867,
	0xAB, 5870,
	0xAC, 5899,
	0xAD, 5934,
	0xAE, 5966,
	0xAF, 6224,
	0xB0, 6253,
	0xB1, 6259,
	0xB2, 6288,
	0xB3, 6317,
	0xB4, 6346,
	0xB5, 6375,
	0xB6, 6404,
	0xB7, 6433,
	0xB8, 6462,
	0xB9, 6499,
	0xBA, 6502,
	0xBB, 6627,
	0xBC, 6656,
	0xBD, 6723,
	0xBE, 6790,
	0xBF, 6819,
	0xC0, 6848,
	0xC1, 6854,
	0xC2, 6883,
	0xC3, 6925,
	0xC4, 6954,
	0xC5, 6976,
	0xC6, 6998,
	0xC7, 7020,
	0xc8, 7149,
	0xc9, 7149,
	0xca, 7149,
	0xcb, 7149,
	0xcc, 7149,
	0xcd, 7149,
	0xce, 7149,
	0xcf, 7149,
	0xD0, 7172,
	0xD1, 7190,
	0xD2, 7208,
	0xD3, 7226,
	0xD4, 7244,
	0xD5, 7262,
	0xD6, 7280,
	0xD7, 7306,
	0xD8, 7324,
	0xD9, 7342,
	0xDA, 7360,
	0xDB, 7378,
	0xDC, 7396,
	0xDD, 7414,
	0xDE, 7432,
	0xDF, 7450,
	0xE0, 7468,
	0xE1, 7486,
	0xE2, 7504,
	0xE3, 7522,
	0xE4, 7540,
	0xE5, 7558,
	0xE6, 7576,
	0xE7, 7602,
	0xE8, 7620,
	0xE9, 7638,
	0xEA, 7656,
	0xEB, 7674,
	0xEC, 7692,
	0xED, 7710,
	0xEE, 7728,
	0xEF, 7746,
	0xF0, 7764,
	0xF1, 7774,
	0xF2, 7792,
	0xF3, 7810,
	0xF4, 7828,
	0xF5, 7846,
	0xF6, 7864,
	0xF7, 7882,
	0xF8, 7900,
	0xF9, 7918,
	0xFA, 7936,
	0xFB, 7954,
	0xFC, 7972,
	0xFD, 7990,
	0xFE, 8008,
	uint16(xFail),
	/*1180*/ uint16(xCondSlashR),
	1189, // 0
	1205, // 1
	1221, // 2
	1225, // 3
	1229, // 4
	1233, // 5
	0,    // 6
	0,    // 7
	/*1189*/ uint16(xCondDataSize), 1193, 1197, 1201,
	/*1193*/ uint16(xSetOp), uint16(SLDT),
	/*1195*/ uint16(xArgRM16),
	/*1196*/ uint16(xMatch),
	/*1197*/ uint16(xSetOp), uint16(SLDT),
	/*1199*/ uint16(xArgR32M16),
	/*1200*/ uint16(xMatch),
	/*1201*/ uint16(xSetOp), uint16(SLDT),
	/*1203*/ uint16(xArgR64M16),
	/*1204*/ uint16(xMatch),
	/*1205*/ uint16(xCondDataSize), 1209, 1213, 1217,
	/*1209*/ uint16(xSetOp), uint16(STR),
	/*1211*/ uint16(xArgRM16),
	/*1212*/ uint16(xMatch),
	/*1213*/ uint16(xSetOp), uint16(STR),
	/*1215*/ uint16(xArgR32M16),
	/*1216*/ uint16(xMatch),
	/*1217*/ uint16(xSetOp), uint16(STR),
	/*1219*/ uint16(xArgR64M16),
	/*1220*/ uint16(xMatch),
	/*1221*/ uint16(xSetOp), uint16(LLDT),
	/*1223*/ uint16(xArgRM16),
	/*1224*/ uint16(xMatch),
	/*1225*/ uint16(xSetOp), uint16(LTR),
	/*1227*/ uint16(xArgRM16),
	/*1228*/ uint16(xMatch),
	/*1229*/ uint16(xSetOp), uint16(VERR),
	/*1231*/ uint16(xArgRM16),
	/*1232*/ uint16(xMatch),
	/*1233*/ uint16(xSetOp), uint16(VERW),
	/*1235*/ uint16(xArgRM16),
	/*1236*/ uint16(xMatch),
	/*1237*/ uint16(xCondByte), 8,
	0xC8, 1318,
	0xC9, 1321,
	0xD0, 1324,
	0xD1, 1327,
	0xD5, 1330,
	0xD6, 1333,
	0xF8, 1336,
	0xF9, 1342,
	/*1255*/ uint16(xCondSlashR),
	1264, // 0
	1268, // 1
	1272, // 2
	1283, // 3
	1294, // 4
	0,    // 5
	1310, // 6
	1314, // 7
	/*1264*/ uint16(xSetOp), uint16(SGDT),
	/*1266*/ uint16(xArgM),
	/*1267*/ uint16(xMatch),
	/*1268*/ uint16(xSetOp), uint16(SIDT),
	/*1270*/ uint16(xArgM),
	/*1271*/ uint16(xMatch),
	/*1272*/ uint16(xCondIs64), 1275, 1279,
	/*1275*/ uint16(xSetOp), uint16(LGDT),
	/*1277*/ uint16(xArgM16and32),
	/*1278*/ uint16(xMatch),
	/*1279*/ uint16(xSetOp), uint16(LGDT),
	/*1281*/ uint16(xArgM16and64),
	/*1282*/ uint16(xMatch),
	/*1283*/ uint16(xCondIs64), 1286, 1290,
	/*1286*/ uint16(xSetOp), uint16(LIDT),
	/*1288*/ uint16(xArgM16and32),
	/*1289*/ uint16(xMatch),
	/*1290*/ uint16(xSetOp), uint16(LIDT),
	/*1292*/ uint16(xArgM16and64),
	/*1293*/ uint16(xMatch),
	/*1294*/ uint16(xCondDataSize), 1298, 1302, 1306,
	/*1298*/ uint16(xSetOp), uint16(SMSW),
	/*1300*/ uint16(xArgRM16),
	/*1301*/ uint16(xMatch),
	/*1302*/ uint16(xSetOp), uint16(SMSW),
	/*1304*/ uint16(xArgR32M16),
	/*1305*/ uint16(xMatch),
	/*1306*/ uint16(xSetOp), uint16(SMSW),
	/*1308*/ uint16(xArgR64M16),
	/*1309*/ uint16(xMatch),
	/*1310*/ uint16(xSetOp), uint16(LMSW),
	/*1312*/ uint16(xArgRM16),
	/*1313*/ uint16(xMatch),
	/*1314*/ uint16(xSetOp), uint16(INVLPG),
	/*1316*/ uint16(xArgM),
	/*1317*/ uint16(xMatch),
	/*1318*/ uint16(xSetOp), uint16(MONITOR),
	/*1320*/ uint16(xMatch),
	/*1321*/ uint16(xSetOp), uint16(MWAIT),
	/*1323*/ uint16(xMatch),
	/*1324*/ uint16(xSetOp), uint16(XGETBV),
	/*1326*/ uint16(xMatch),
	/*1327*/ uint16(xSetOp), uint16(XSETBV),
	/*1329*/ uint16(xMatch),
	/*1330*/ uint16(xSetOp), uint16(XEND),
	/*1332*/ uint16(xMatch),
	/*1333*/ uint16(xSetOp), uint16(XTEST),
	/*1335*/ uint16(xMatch),
	/*1336*/ uint16(xCondIs64), 0, 1339,
	/*1339*/ uint16(xSetOp), uint16(SWAPGS),
	/*1341*/ uint16(xMatch),
	/*1342*/ uint16(xSetOp), uint16(RDTSCP),
	/*1344*/ uint16(xMatch),
	/*1345*/ uint16(xCondDataSize), 1349, 1355, 1361,
	/*1349*/ uint16(xSetOp), uint16(LAR),
	/*1351*/ uint16(xReadSlashR),
	/*1352*/ uint16(xArgR16),
	/*1353*/ uint16(xArgRM16),
	/*1354*/ uint16(xMatch),
	/*1355*/ uint16(xSetOp), uint16(LAR),
	/*1357*/ uint16(xReadSlashR),
	/*1358*/ uint16(xArgR32),
	/*1359*/ uint16(xArgR32M16),
	/*1360*/ uint16(xMatch),
	/*1361*/ uint16(xSetOp), uint16(LAR),
	/*1363*/ uint16(xReadSlashR),
	/*1364*/ uint16(xArgR64),
	/*1365*/ uint16(xArgR64M16),
	/*1366*/ uint16(xMatch),
	/*1367*/ uint16(xCondDataSize), 1371, 1377, 1383,
	/*1371*/ uint16(xSetOp), uint16(LSL),
	/*1373*/ uint16(xReadSlashR),
	/*1374*/ uint16(xArgR16),
	/*1375*/ uint16(xArgRM16),
	/*1376*/ uint16(xMatch),
	/*1377*/ uint16(xSetOp), uint16(LSL),
	/*1379*/ uint16(xReadSlashR),
	/*1380*/ uint16(xArgR32),
	/*1381*/ uint16(xArgR32M16),
	/*1382*/ uint16(xMatch),
	/*1383*/ uint16(xSetOp), uint16(LSL),
	/*1385*/ uint16(xReadSlashR),
	/*1386*/ uint16(xArgR64),
	/*1387*/ uint16(xArgR32M16),
	/*1388*/ uint16(xMatch),
	/*1389*/ uint16(xCondIs64), 0, 1392,
	/*1392*/ uint16(xSetOp), uint16(SYSCALL),
	/*1394*/ uint16(xMatch),
	/*1395*/ uint16(xSetOp), uint16(CLTS),
	/*1397*/ uint16(xMatch),
	/*1398*/ uint16(xCondIs64), 0, 1401,
	/*1401*/ uint16(xSetOp), uint16(SYSRET),
	/*1403*/ uint16(xMatch),
	/*1404*/ uint16(xSetOp), uint16(INVD),
	/*1406*/ uint16(xMatch),
	/*1407*/ uint16(xSetOp), uint16(WBINVD),
	/*1409*/ uint16(xMatch),
	/*1410*/ uint16(xSetOp), uint16(UD2),
	/*1412*/ uint16(xMatch),
	/*1413*/ uint16(xCondSlashR),
	0,    // 0
	1422, // 1
	0,    // 2
	0,    // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*1422*/ uint16(xSetOp), uint16(PREFETCHW),
	/*1424*/ uint16(xArgM8),
	/*1425*/ uint16(xMatch),
	/*1426*/ uint16(xCondPrefix), 4,
	0xF3, 1454,
	0xF2, 1448,
	0x66, 1442,
	0x0, 1436,
	/*1436*/ uint16(xSetOp), uint16(MOVUPS),
	/*1438*/ uint16(xReadSlashR),
	/*1439*/ uint16(xArgXmm1),
	/*1440*/ uint16(xArgXmm2M128),
	/*1441*/ uint16(xMatch),
	/*1442*/ uint16(xSetOp), uint16(MOVUPD),
	/*1444*/ uint16(xReadSlashR),
	/*1445*/ uint16(xArgXmm1),
	/*1446*/ uint16(xArgXmm2M128),
	/*1447*/ uint16(xMatch),
	/*1448*/ uint16(xSetOp), uint16(MOVSD_XMM),
	/*1450*/ uint16(xReadSlashR),
	/*1451*/ uint16(xArgXmm1),
	/*1452*/ uint16(xArgXmm2M64),
	/*1453*/ uint16(xMatch),
	/*1454*/ uint16(xSetOp), uint16(MOVSS),
	/*1456*/ uint16(xReadSlashR),
	/*1457*/ uint16(xArgXmm1),
	/*1458*/ uint16(xArgXmm2M32),
	/*1459*/ uint16(xMatch),
	/*1460*/ uint16(xCondPrefix), 4,
	0xF3, 1488,
	0xF2, 1482,
	0x66, 1476,
	0x0, 1470,
	/*1470*/ uint16(xSetOp), uint16(MOVUPS),
	/*1472*/ uint16(xReadSlashR),
	/*1473*/ uint16(xArgXmm2M128),
	/*1474*/ uint16(xArgXmm1),
	/*1475*/ uint16(xMatch),
	/*1476*/ uint16(xSetOp), uint16(MOVUPD),
	/*1478*/ uint16(xReadSlashR),
	/*1479*/ uint16(xArgXmm2M128),
	/*1480*/ uint16(xArgXmm),
	/*1481*/ uint16(xMatch),
	/*1482*/ uint16(xSetOp), uint16(MOVSD_XMM),
	/*1484*/ uint16(xReadSlashR),
	/*1485*/ uint16(xArgXmm2M64),
	/*1486*/ uint16(xArgXmm1),
	/*1487*/ uint16(xMatch),
	/*1488*/ uint16(xSetOp), uint16(MOVSS),
	/*1490*/ uint16(xReadSlashR),
	/*1491*/ uint16(xArgXmm2M32),
	/*1492*/ uint16(xArgXmm),
	/*1493*/ uint16(xMatch),
	/*1494*/ uint16(xCondPrefix), 4,
	0xF3, 1531,
	0xF2, 1525,
	0x66, 1519,
	0x0, 1504,
	/*1504*/ uint16(xCondIsMem), 1507, 1513,
	/*1507*/ uint16(xSetOp), uint16(MOVHLPS),
	/*1509*/ uint16(xReadSlashR),
	/*1510*/ uint16(xArgXmm1),
	/*1511*/ uint16(xArgXmm2),
	/*1512*/ uint16(xMatch),
	/*1513*/ uint16(xSetOp), uint16(MOVLPS),
	/*1515*/ uint16(xReadSlashR),
	/*1516*/ uint16(xArgXmm),
	/*1517*/ uint16(xArgM64),
	/*1518*/ uint16(xMatch),
	/*1519*/ uint16(xSetOp), uint16(MOVLPD),
	/*1521*/ uint16(xReadSlashR),
	/*1522*/ uint16(xArgXmm),
	/*1523*/ uint16(xArgXmm2M64),
	/*1524*/ uint16(xMatch),
	/*1525*/ uint16(xSetOp), uint16(MOVDDUP),
	/*1527*/ uint16(xReadSlashR),
	/*1528*/ uint16(xArgXmm1),
	/*1529*/ uint16(xArgXmm2M64),
	/*1530*/ uint16(xMatch),
	/*1531*/ uint16(xSetOp), uint16(MOVSLDUP),
	/*1533*/ uint16(xReadSlashR),
	/*1534*/ uint16(xArgXmm1),
	/*1535*/ uint16(xArgXmm2M128),
	/*1536*/ uint16(xMatch),
	/*1537*/ uint16(xCondPrefix), 2,
	0x66, 1549,
	0x0, 1543,
	/*1543*/ uint16(xSetOp), uint16(MOVLPS),
	/*1545*/ uint16(xReadSlashR),
	/*1546*/ uint16(xArgM64),
	/*1547*/ uint16(xArgXmm),
	/*1548*/ uint16(xMatch),
	/*1549*/ uint16(xSetOp), uint16(MOVLPD),
	/*1551*/ uint16(xReadSlashR),
	/*1552*/ uint16(xArgXmm2M64),
	/*1553*/ uint16(xArgXmm),
	/*1554*/ uint16(xMatch),
	/*1555*/ uint16(xCondPrefix), 2,
	0x66, 1567,
	0x0, 1561,
	/*1561*/ uint16(xSetOp), uint16(UNPCKLPS),
	/*1563*/ uint16(xReadSlashR),
	/*1564*/ uint16(xArgXmm1),
	/*1565*/ uint16(xArgXmm2M128),
	/*1566*/ uint16(xMatch),
	/*1567*/ uint16(xSetOp), uint16(UNPCKLPD),
	/*1569*/ uint16(xReadSlashR),
	/*1570*/ uint16(xArgXmm1),
	/*1571*/ uint16(xArgXmm2M128),
	/*1572*/ uint16(xMatch),
	/*1573*/ uint16(xCondPrefix), 2,
	0x66, 1585,
	0x0, 1579,
	/*1579*/ uint16(xSetOp), uint16(UNPCKHPS),
	/*1581*/ uint16(xReadSlashR),
	/*1582*/ uint16(xArgXmm1),
	/*1583*/ uint16(xArgXmm2M128),
	/*1584*/ uint16(xMatch),
	/*1585*/ uint16(xSetOp), uint16(UNPCKHPD),
	/*1587*/ uint16(xReadSlashR),
	/*1588*/ uint16(xArgXmm1),
	/*1589*/ uint16(xArgXmm2M128),
	/*1590*/ uint16(xMatch),
	/*1591*/ uint16(xCondPrefix), 3,
	0xF3, 1620,
	0x66, 1614,
	0x0, 1599,
	/*1599*/ uint16(xCondIsMem), 1602, 1608,
	/*1602*/ uint16(xSetOp), uint16(MOVLHPS),
	/*1604*/ uint16(xReadSlashR),
	/*1605*/ uint16(xArgXmm1),
	/*1606*/ uint16(xArgXmm2),
	/*1607*/ uint16(xMatch),
	/*1608*/ uint16(xSetOp), uint16(MOVHPS),
	/*1610*/ uint16(xReadSlashR),
	/*1611*/ uint16(xArgXmm),
	/*1612*/ uint16(xArgM64),
	/*1613*/ uint16(xMatch),
	/*1614*/ uint16(xSetOp), uint16(MOVHPD),
	/*1616*/ uint16(xReadSlashR),
	/*1617*/ uint16(xArgXmm),
	/*1618*/ uint16(xArgXmm2M64),
	/*1619*/ uint16(xMatch),
	/*1620*/ uint16(xSetOp), uint16(MOVSHDUP),
	/*1622*/ uint16(xReadSlashR),
	/*1623*/ uint16(xArgXmm1),
	/*1624*/ uint16(xArgXmm2M128),
	/*1625*/ uint16(xMatch),
	/*1626*/ uint16(xCondPrefix), 2,
	0x66, 1638,
	0x0, 1632,
	/*1632*/ uint16(xSetOp), uint16(MOVHPS),
	/*1634*/ uint16(xReadSlashR),
	/*1635*/ uint16(xArgM64),
	/*1636*/ uint16(xArgXmm),
	/*1637*/ uint16(xMatch),
	/*1638*/ uint16(xSetOp), uint16(MOVHPD),
	/*1640*/ uint16(xReadSlashR),
	/*1641*/ uint16(xArgXmm2M64),
	/*1642*/ uint16(xArgXmm),
	/*1643*/ uint16(xMatch),
	/*1644*/ uint16(xCondSlashR),
	1653, // 0
	1657, // 1
	1661, // 2
	1665, // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*1653*/ uint16(xSetOp), uint16(PREFETCHNTA),
	/*1655*/ uint16(xArgM8),
	/*1656*/ uint16(xMatch),
	/*1657*/ uint16(xSetOp), uint16(PREFETCHT0),
	/*1659*/ uint16(xArgM8),
	/*1660*/ uint16(xMatch),
	/*1661*/ uint16(xSetOp), uint16(PREFETCHT1),
	/*1663*/ uint16(xArgM8),
	/*1664*/ uint16(xMatch),
	/*1665*/ uint16(xSetOp), uint16(PREFETCHT2),
	/*1667*/ uint16(xArgM8),
	/*1668*/ uint16(xMatch),
	/*1669*/ uint16(xCondSlashR),
	1678, // 0
	0,    // 1
	0,    // 2
	0,    // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*1678*/ uint16(xCondDataSize), 1682, 1686, 0,
	/*1682*/ uint16(xSetOp), uint16(NOP),
	/*1684*/ uint16(xArgRM16),
	/*1685*/ uint16(xMatch),
	/*1686*/ uint16(xSetOp), uint16(NOP),
	/*1688*/ uint16(xArgRM32),
	/*1689*/ uint16(xMatch),
	/*1690*/ uint16(xCondIs64), 1693, 1699,
	/*1693*/ uint16(xSetOp), uint16(MOV),
	/*1695*/ uint16(xReadSlashR),
	/*1696*/ uint16(xArgRmf32),
	/*1697*/ uint16(xArgCR0dashCR7),
	/*1698*/ uint16(xMatch),
	/*1699*/ uint16(xSetOp), uint16(MOV),
	/*1701*/ uint16(xReadSlashR),
	/*1702*/ uint16(xArgRmf64),
	/*1703*/ uint16(xArgCR0dashCR7),
	/*1704*/ uint16(xMatch),
	/*1705*/ uint16(xCondIs64), 1708, 1714,
	/*1708*/ uint16(xSetOp), uint16(MOV),
	/*1710*/ uint16(xReadSlashR),
	/*1711*/ uint16(xArgRmf32),
	/*1712*/ uint16(xArgDR0dashDR7),
	/*1713*/ uint16(xMatch),
	/*1714*/ uint16(xSetOp), uint16(MOV),
	/*1716*/ uint16(xReadSlashR),
	/*1717*/ uint16(xArgRmf64),
	/*1718*/ uint16(xArgDR0dashDR7),
	/*1719*/ uint16(xMatch),
	/*1720*/ uint16(xCondIs64), 1723, 1729,
	/*1723*/ uint16(xSetOp), uint16(MOV),
	/*1725*/ uint16(xReadSlashR),
	/*1726*/ uint16(xArgCR0dashCR7),
	/*1727*/ uint16(xArgRmf32),
	/*1728*/ uint16(xMatch),
	/*1729*/ uint16(xSetOp), uint16(MOV),
	/*1731*/ uint16(xReadSlashR),
	/*1732*/ uint16(xArgCR0dashCR7),
	/*1733*/ uint16(xArgRmf64),
	/*1734*/ uint16(xMatch),
	/*1735*/ uint16(xCondIs64), 1738, 1744,
	/*1738*/ uint16(xSetOp), uint16(MOV),
	/*1740*/ uint16(xReadSlashR),
	/*1741*/ uint16(xArgDR0dashDR7),
	/*1742*/ uint16(xArgRmf32),
	/*1743*/ uint16(xMatch),
	/*1744*/ uint16(xSetOp), uint16(MOV),
	/*1746*/ uint16(xReadSlashR),
	/*1747*/ uint16(xArgDR0dashDR7),
	/*1748*/ uint16(xArgRmf64),
	/*1749*/ uint16(xMatch),
	/*1750*/ uint16(xCondIs64), 1753, 1759,
	/*1753*/ uint16(xSetOp), uint16(MOV),
	/*1755*/ uint16(xReadSlashR),
	/*1756*/ uint16(xArgRmf32),
	/*1757*/ uint16(xArgTR0dashTR7),
	/*1758*/ uint16(xMatch),
	/*1759*/ uint16(xSetOp), uint16(MOV),
	/*1761*/ uint16(xReadSlashR),
	/*1762*/ uint16(xArgRmf64),
	/*1763*/ uint16(xArgTR0dashTR7),
	/*1764*/ uint16(xMatch),
	/*1765*/ uint16(xCondIs64), 1768, 1774,
	/*1768*/ uint16(xSetOp), uint16(MOV),
	/*1770*/ uint16(xReadSlashR),
	/*1771*/ uint16(xArgTR0dashTR7),
	/*1772*/ uint16(xArgRmf32),
	/*1773*/ uint16(xMatch),
	/*1774*/ uint16(xSetOp), uint16(MOV),
	/*1776*/ uint16(xReadSlashR),
	/*1777*/ uint16(xArgTR0dashTR7),
	/*1778*/ uint16(xArgRmf64),
	/*1779*/ uint16(xMatch),
	/*1780*/ uint16(xCondPrefix), 2,
	0x66, 1792,
	0x0, 1786,
	/*1786*/ uint16(xSetOp), uint16(MOVAPS),
	/*1788*/ uint16(xReadSlashR),
	/*1789*/ uint16(xArgXmm1),
	/*1790*/ uint16(xArgXmm2M128),
	/*1791*/ uint16(xMatch),
	/*1792*/ uint16(xSetOp), uint16(MOVAPD),
	/*1794*/ uint16(xReadSlashR),
	/*1795*/ uint16(xArgXmm1),
	/*1796*/ uint16(xArgXmm2M128),
	/*1797*/ uint16(xMatch),
	/*1798*/ uint16(xCondPrefix), 2,
	0x66, 1810,
	0x0, 1804,
	/*1804*/ uint16(xSetOp), uint16(MOVAPS),
	/*1806*/ uint16(xReadSlashR),
	/*1807*/ uint16(xArgXmm2M128),
	/*1808*/ uint16(xArgXmm1),
	/*1809*/ uint16(xMatch),
	/*1810*/ uint16(xSetOp), uint16(MOVAPD),
	/*1812*/ uint16(xReadSlashR),
	/*1813*/ uint16(xArgXmm2M128),
	/*1814*/ uint16(xArgXmm1),
	/*1815*/ uint16(xMatch),
	/*1816*/ uint16(xCondIs64), 1819, 1873,
	/*1819*/ uint16(xCondPrefix), 4,
	0xF3, 1857,
	0xF2, 1841,
	0x66, 1835,
	0x0, 1829,
	/*1829*/ uint16(xSetOp), uint16(CVTPI2PS),
	/*1831*/ uint16(xReadSlashR),
	/*1832*/ uint16(xArgXmm),
	/*1833*/ uint16(xArgMmM64),
	/*1834*/ uint16(xMatch),
	/*1835*/ uint16(xSetOp), uint16(CVTPI2PD),
	/*1837*/ uint16(xReadSlashR),
	/*1838*/ uint16(xArgXmm),
	/*1839*/ uint16(xArgMmM64),
	/*1840*/ uint16(xMatch),
	/*1841*/ uint16(xCondDataSize), 1845, 1851, 0,
	/*1845*/ uint16(xSetOp), uint16(CVTSI2SD),
	/*1847*/ uint16(xReadSlashR),
	/*1848*/ uint16(xArgXmm),
	/*1849*/ uint16(xArgRM32),
	/*1850*/ uint16(xMatch),
	/*1851*/ uint16(xSetOp), uint16(CVTSI2SD),
	/*1853*/ uint16(xReadSlashR),
	/*1854*/ uint16(xArgXmm),
	/*1855*/ uint16(xArgRM32),
	/*1856*/ uint16(xMatch),
	/*1857*/ uint16(xCondDataSize), 1861, 1867, 0,
	/*1861*/ uint16(xSetOp), uint16(CVTSI2SS),
	/*1863*/ uint16(xReadSlashR),
	/*1864*/ uint16(xArgXmm),
	/*1865*/ uint16(xArgRM32),
	/*1866*/ uint16(xMatch),
	/*1867*/ uint16(xSetOp), uint16(CVTSI2SS),
	/*1869*/ uint16(xReadSlashR),
	/*1870*/ uint16(xArgXmm),
	/*1871*/ uint16(xArgRM32),
	/*1872*/ uint16(xMatch),
	/*1873*/ uint16(xCondPrefix), 4,
	0xF3, 1893,
	0xF2, 1883,
	0x66, 1835,
	0x0, 1829,
	/*1883*/ uint16(xCondDataSize), 1845, 1851, 1887,
	/*1887*/ uint16(xSetOp), uint16(CVTSI2SD),
	/*1889*/ uint16(xReadSlashR),
	/*1890*/ uint16(xArgXmm),
	/*1891*/ uint16(xArgRM64),
	/*1892*/ uint16(xMatch),
	/*1893*/ uint16(xCondDataSize), 1861, 1867, 1897,
	/*1897*/ uint16(xSetOp), uint16(CVTSI2SS),
	/*1899*/ uint16(xReadSlashR),
	/*1900*/ uint16(xArgXmm),
	/*1901*/ uint16(xArgRM64),
	/*1902*/ uint16(xMatch),
	/*1903*/ uint16(xCondPrefix), 4,
	0xF3, 1931,
	0xF2, 1925,
	0x66, 1919,
	0x0, 1913,
	/*1913*/ uint16(xSetOp), uint16(MOVNTPS),
	/*1915*/ uint16(xReadSlashR),
	/*1916*/ uint16(xArgM128),
	/*1917*/ uint16(xArgXmm),
	/*1918*/ uint16(xMatch),
	/*1919*/ uint16(xSetOp), uint16(MOVNTPD),
	/*1921*/ uint16(xReadSlashR),
	/*1922*/ uint16(xArgM128),
	/*1923*/ uint16(xArgXmm),
	/*1924*/ uint16(xMatch),
	/*1925*/ uint16(xSetOp), uint16(MOVNTSD),
	/*1927*/ uint16(xReadSlashR),
	/*1928*/ uint16(xArgM64),
	/*1929*/ uint16(xArgXmm),
	/*1930*/ uint16(xMatch),
	/*1931*/ uint16(xSetOp), uint16(MOVNTSS),
	/*1933*/ uint16(xReadSlashR),
	/*1934*/ uint16(xArgM32),
	/*1935*/ uint16(xArgXmm),
	/*1936*/ uint16(xMatch),
	/*1937*/ uint16(xCondIs64), 1940, 1994,
	/*1940*/ uint16(xCondPrefix), 4,
	0xF3, 1978,
	0xF2, 1962,
	0x66, 1956,
	0x0, 1950,
	/*1950*/ uint16(xSetOp), uint16(CVTTPS2PI),
	/*1952*/ uint16(xReadSlashR),
	/*1953*/ uint16(xArgMm),
	/*1954*/ uint16(xArgXmmM64),
	/*1955*/ uint16(xMatch),
	/*1956*/ uint16(xSetOp), uint16(CVTTPD2PI),
	/*1958*/ uint16(xReadSlashR),
	/*1959*/ uint16(xArgMm),
	/*1960*/ uint16(xArgXmmM128),
	/*1961*/ uint16(xMatch),
	/*1962*/ uint16(xCondDataSize), 1966, 1972, 0,
	/*1966*/ uint16(xSetOp), uint16(CVTTSD2SI),
	/*1968*/ uint16(xReadSlashR),
	/*1969*/ uint16(xArgR32),
	/*1970*/ uint16(xArgXmmM64),
	/*1971*/ uint16(xMatch),
	/*1972*/ uint16(xSetOp), uint16(CVTTSD2SI),
	/*1974*/ uint16(xReadSlashR),
	/*1975*/ uint16(xArgR32),
	/*1976*/ uint16(xArgXmmM64),
	/*1977*/ uint16(xMatch),
	/*1978*/ uint16(xCondDataSize), 1982, 1988, 0,
	/*1982*/ uint16(xSetOp), uint16(CVTTSS2SI),
	/*1984*/ uint16(xReadSlashR),
	/*1985*/ uint16(xArgR32),
	/*1986*/ uint16(xArgXmmM32),
	/*1987*/ uint16(xMatch),
	/*1988*/ uint16(xSetOp), uint16(CVTTSS2SI),
	/*1990*/ uint16(xReadSlashR),
	/*1991*/ uint16(xArgR32),
	/*1992*/ uint16(xArgXmmM32),
	/*1993*/ uint16(xMatch),
	/*1994*/ uint16(xCondPrefix), 4,
	0xF3, 2014,
	0xF2, 2004,
	0x66, 1956,
	0x0, 1950,
	/*2004*/ uint16(xCondDataSize), 1966, 1972, 2008,
	/*2008*/ uint16(xSetOp), uint16(CVTTSD2SI),
	/*2010*/ uint16(xReadSlashR),
	/*2011*/ uint16(xArgR64),
	/*2012*/ uint16(xArgXmmM64),
	/*2013*/ uint16(xMatch),
	/*2014*/ uint16(xCondDataSize), 1982, 1988, 2018,
	/*2018*/ uint16(xSetOp), uint16(CVTTSS2SI),
	/*2020*/ uint16(xReadSlashR),
	/*2021*/ uint16(xArgR64),
	/*2022*/ uint16(xArgXmmM32),
	/*2023*/ uint16(xMatch),
	/*2024*/ uint16(xCondIs64), 2027, 2081,
	/*2027*/ uint16(xCondPrefix), 4,
	0xF3, 2065,
	0xF2, 2049,
	0x66, 2043,
	0x0, 2037,
	/*2037*/ uint16(xSetOp), uint16(CVTPS2PI),
	/*2039*/ uint16(xReadSlashR),
	/*2040*/ uint16(xArgMm),
	/*2041*/ uint16(xArgXmmM64),
	/*2042*/ uint16(xMatch),
	/*2043*/ uint16(xSetOp), uint16(CVTPD2PI),
	/*2045*/ uint16(xReadSlashR),
	/*2046*/ uint16(xArgMm),
	/*2047*/ uint16(xArgXmmM128),
	/*2048*/ uint16(xMatch),
	/*2049*/ uint16(xCondDataSize), 2053, 2059, 0,
	/*2053*/ uint16(xSetOp), uint16(CVTSD2SI),
	/*2055*/ uint16(xReadSlashR),
	/*2056*/ uint16(xArgR32),
	/*2057*/ uint16(xArgXmmM64),
	/*2058*/ uint16(xMatch),
	/*2059*/ uint16(xSetOp), uint16(CVTSD2SI),
	/*2061*/ uint16(xReadSlashR),
	/*2062*/ uint16(xArgR32),
	/*2063*/ uint16(xArgXmmM64),
	/*2064*/ uint16(xMatch),
	/*2065*/ uint16(xCondDataSize), 2069, 2075, 0,
	/*2069*/ uint16(xSetOp), uint16(CVTSS2SI),
	/*2071*/ uint16(xReadSlashR),
	/*2072*/ uint16(xArgR32),
	/*2073*/ uint16(xArgXmmM32),
	/*2074*/ uint16(xMatch),
	/*2075*/ uint16(xSetOp), uint16(CVTSS2SI),
	/*2077*/ uint16(xReadSlashR),
	/*2078*/ uint16(xArgR32),
	/*2079*/ uint16(xArgXmmM32),
	/*2080*/ uint16(xMatch),
	/*2081*/ uint16(xCondPrefix), 4,
	0xF3, 2101,
	0xF2, 2091,
	0x66, 2043,
	0x0, 2037,
	/*2091*/ uint16(xCondDataSize), 2053, 2059, 2095,
	/*2095*/ uint16(xSetOp), uint16(CVTSD2SI),
	/*2097*/ uint16(xReadSlashR),
	/*2098*/ uint16(xArgR64),
	/*2099*/ uint16(xArgXmmM64),
	/*2100*/ uint16(xMatch),
	/*2101*/ uint16(xCondDataSize), 2069, 2075, 2105,
	/*2105*/ uint16(xSetOp), uint16(CVTSS2SI),
	/*2107*/ uint16(xReadSlashR),
	/*2108*/ uint16(xArgR64),
	/*2109*/ uint16(xArgXmmM32),
	/*2110*/ uint16(xMatch),
	/*2111*/ uint16(xCondPrefix), 2,
	0x66, 2123,
	0x0, 2117,
	/*2117*/ uint16(xSetOp), uint16(UCOMISS),
	/*2119*/ uint16(xReadSlashR),
	/*2120*/ uint16(xArgXmm1),
	/*2121*/ uint16(xArgXmm2M32),
	/*2122*/ uint16(xMatch),
	/*2123*/ uint16(xSetOp), uint16(UCOMISD),
	/*2125*/ uint16(xReadSlashR),
	/*2126*/ uint16(xArgXmm1),
	/*2127*/ uint16(xArgXmm2M64),
	/*2128*/ uint16(xMatch),
	/*2129*/ uint16(xCondPrefix), 2,
	0x66, 2141,
	0x0, 2135,
	/*2135*/ uint16(xSetOp), uint16(COMISS),
	/*2137*/ uint16(xReadSlashR),
	/*2138*/ uint16(xArgXmm1),
	/*2139*/ uint16(xArgXmm2M32),
	/*2140*/ uint16(xMatch),
	/*2141*/ uint16(xSetOp), uint16(COMISD),
	/*2143*/ uint16(xReadSlashR),
	/*2144*/ uint16(xArgXmm1),
	/*2145*/ uint16(xArgXmm2M64),
	/*2146*/ uint16(xMatch),
	/*2147*/ uint16(xSetOp), uint16(WRMSR),
	/*2149*/ uint16(xMatch),
	/*2150*/ uint16(xSetOp), uint16(RDTSC),
	/*2152*/ uint16(xMatch),
	/*2153*/ uint16(xSetOp), uint16(RDMSR),
	/*2155*/ uint16(xMatch),
	/*2156*/ uint16(xSetOp), uint16(RDPMC),
	/*2158*/ uint16(xMatch),
	/*2159*/ uint16(xSetOp), uint16(SYSENTER),
	/*2161*/ uint16(xMatch),
	/*2162*/ uint16(xCondDataSize), 2166, 2166, 2169,
	/*2166*/ uint16(xSetOp), uint16(SYSEXIT),
	/*2168*/ uint16(xMatch),
	/*2169*/ uint16(xSetOp), uint16(SYSEXIT),
	/*2171*/ uint16(xMatch),
	/*2172*/ uint16(xCondByte), 54,
	0x00, 2283,
	0x01, 2301,
	0x02, 2319,
	0x03, 2337,
	0x04, 2355,
	0x05, 2373,
	0x06, 2391,
	0x07, 2409,
	0x08, 2427,
	0x09, 2445,
	0x0A, 2463,
	0x0B, 2481,
	0x10, 2499,
	0x14, 2510,
	0x15, 2521,
	0x17, 2532,
	0x1C, 2542,
	0x1D, 2560,
	0x1E, 2578,
	0x20, 2596,
	0x21, 2606,
	0x22, 2616,
	0x23, 2626,
	0x24, 2636,
	0x25, 2646,
	0x28, 2656,
	0x29, 2666,
	0x2A, 2676,
	0x2B, 2686,
	0x30, 2696,
	0x31, 2706,
	0x32, 2716,
	0x33, 2726,
	0x34, 2736,
	0x35, 2746,
	0x37, 2756,
	0x38, 2766,
	0x39, 2776,
	0x3A, 2786,
	0x3B, 2796,
	0x3C, 2806,
	0x3D, 2816,
	0x3E, 2826,
	0x3F, 2836,
	0x40, 2846,
	0x41, 2856,
	0x82, 2866,
	0xDB, 2889,
	0xDC, 2899,
	0xDD, 2909,
	0xDE, 2919,
	0xDF, 2929,
	0xF0, 2939,
	0xF1, 3006,
	uint16(xFail),
	/*2283*/ uint16(xCondPrefix), 2,
	0x66, 2295,
	0x0, 2289,
	/*2289*/ uint16(xSetOp), uint16(PSHUFB),
	/*2291*/ uint16(xReadSlashR),
	/*2292*/ uint16(xArgMm1),
	/*2293*/ uint16(xArgMm2M64),
	/*2294*/ uint16(xMatch),
	/*2295*/ uint16(xSetOp), uint16(PSHUFB),
	/*2297*/ uint16(xReadSlashR),
	/*2298*/ uint16(xArgXmm1),
	/*2299*/ uint16(xArgXmm2M128),
	/*2300*/ uint16(xMatch),
	/*2301*/ uint16(xCondPrefix), 2,
	0x66, 2313,
	0x0, 2307,
	/*2307*/ uint16(xSetOp), uint16(PHADDW),
	/*2309*/ uint16(xReadSlashR),
	/*2310*/ uint16(xArgMm1),
	/*2311*/ uint16(xArgMm2M64),
	/*2312*/ uint16(xMatch),
	/*2313*/ uint16(xSetOp), uint16(PHADDW),
	/*2315*/ uint16(xReadSlashR),
	/*2316*/ uint16(xArgXmm1),
	/*2317*/ uint16(xArgXmm2M128),
	/*2318*/ uint16(xMatch),
	/*2319*/ uint16(xCondPrefix), 2,
	0x66, 2331,
	0x0, 2325,
	/*2325*/ uint16(xSetOp), uint16(PHADDD),
	/*2327*/ uint16(xReadSlashR),
	/*2328*/ uint16(xArgMm1),
	/*2329*/ uint16(xArgMm2M64),
	/*2330*/ uint16(xMatch),
	/*2331*/ uint16(xSetOp), uint16(PHADDD),
	/*2333*/ uint16(xReadSlashR),
	/*2334*/ uint16(xArgXmm1),
	/*2335*/ uint16(xArgXmm2M128),
	/*2336*/ uint16(xMatch),
	/*2337*/ uint16(xCondPrefix), 2,
	0x66, 2349,
	0x0, 2343,
	/*2343*/ uint16(xSetOp), uint16(PHADDSW),
	/*2345*/ uint16(xReadSlashR),
	/*2346*/ uint16(xArgMm1),
	/*2347*/ uint16(xArgMm2M64),
	/*2348*/ uint16(xMatch),
	/*2349*/ uint16(xSetOp), uint16(PHADDSW),
	/*2351*/ uint16(xReadSlashR),
	/*2352*/ uint16(xArgXmm1),
	/*2353*/ uint16(xArgXmm2M128),
	/*2354*/ uint16(xMatch),
	/*2355*/ uint16(xCondPrefix), 2,
	0x66, 2367,
	0x0, 2361,
	/*2361*/ uint16(xSetOp), uint16(PMADDUBSW),
	/*2363*/ uint16(xReadSlashR),
	/*2364*/ uint16(xArgMm1),
	/*2365*/ uint16(xArgMm2M64),
	/*2366*/ uint16(xMatch),
	/*2367*/ uint16(xSetOp), uint16(PMADDUBSW),
	/*2369*/ uint16(xReadSlashR),
	/*2370*/ uint16(xArgXmm1),
	/*2371*/ uint16(xArgXmm2M128),
	/*2372*/ uint16(xMatch),
	/*2373*/ uint16(xCondPrefix), 2,
	0x66, 2385,
	0x0, 2379,
	/*2379*/ uint16(xSetOp), uint16(PHSUBW),
	/*2381*/ uint16(xReadSlashR),
	/*2382*/ uint16(xArgMm1),
	/*2383*/ uint16(xArgMm2M64),
	/*2384*/ uint16(xMatch),
	/*2385*/ uint16(xSetOp), uint16(PHSUBW),
	/*2387*/ uint16(xReadSlashR),
	/*2388*/ uint16(xArgXmm1),
	/*2389*/ uint16(xArgXmm2M128),
	/*2390*/ uint16(xMatch),
	/*2391*/ uint16(xCondPrefix), 2,
	0x66, 2403,
	0x0, 2397,
	/*2397*/ uint16(xSetOp), uint16(PHSUBD),
	/*2399*/ uint16(xReadSlashR),
	/*2400*/ uint16(xArgMm1),
	/*2401*/ uint16(xArgMm2M64),
	/*2402*/ uint16(xMatch),
	/*2403*/ uint16(xSetOp), uint16(PHSUBD),
	/*2405*/ uint16(xReadSlashR),
	/*2406*/ uint16(xArgXmm1),
	/*2407*/ uint16(xArgXmm2M128),
	/*2408*/ uint16(xMatch),
	/*2409*/ uint16(xCondPrefix), 2,
	0x66, 2421,
	0x0, 2415,
	/*2415*/ uint16(xSetOp), uint16(PHSUBSW),
	/*2417*/ uint16(xReadSlashR),
	/*2418*/ uint16(xArgMm1),
	/*2419*/ uint16(xArgMm2M64),
	/*2420*/ uint16(xMatch),
	/*2421*/ uint16(xSetOp), uint16(PHSUBSW),
	/*2423*/ uint16(xReadSlashR),
	/*2424*/ uint16(xArgXmm1),
	/*2425*/ uint16(xArgXmm2M128),
	/*2426*/ uint16(xMatch),
	/*2427*/ uint16(xCondPrefix), 2,
	0x66, 2439,
	0x0, 2433,
	/*2433*/ uint16(xSetOp), uint16(PSIGNB),
	/*2435*/ uint16(xReadSlashR),
	/*2436*/ uint16(xArgMm1),
	/*2437*/ uint16(xArgMm2M64),
	/*2438*/ uint16(xMatch),
	/*2439*/ uint16(xSetOp), uint16(PSIGNB),
	/*2441*/ uint16(xReadSlashR),
	/*2442*/ uint16(xArgXmm1),
	/*2443*/ uint16(xArgXmm2M128),
	/*2444*/ uint16(xMatch),
	/*2445*/ uint16(xCondPrefix), 2,
	0x66, 2457,
	0x0, 2451,
	/*2451*/ uint16(xSetOp), uint16(PSIGNW),
	/*2453*/ uint16(xReadSlashR),
	/*2454*/ uint16(xArgMm1),
	/*2455*/ uint16(xArgMm2M64),
	/*2456*/ uint16(xMatch),
	/*2457*/ uint16(xSetOp), uint16(PSIGNW),
	/*2459*/ uint16(xReadSlashR),
	/*2460*/ uint16(xArgXmm1),
	/*2461*/ uint16(xArgXmm2M128),
	/*2462*/ uint16(xMatch),
	/*2463*/ uint16(xCondPrefix), 2,
	0x66, 2475,
	0x0, 2469,
	/*2469*/ uint16(xSetOp), uint16(PSIGND),
	/*2471*/ uint16(xReadSlashR),
	/*2472*/ uint16(xArgMm1),
	/*2473*/ uint16(xArgMm2M64),
	/*2474*/ uint16(xMatch),
	/*2475*/ uint16(xSetOp), uint16(PSIGND),
	/*2477*/ uint16(xReadSlashR),
	/*2478*/ uint16(xArgXmm1),
	/*2479*/ uint16(xArgXmm2M128),
	/*2480*/ uint16(xMatch),
	/*2481*/ uint16(xCondPrefix), 2,
	0x66, 2493,
	0x0, 2487,
	/*2487*/ uint16(xSetOp), uint16(PMULHRSW),
	/*2489*/ uint16(xReadSlashR),
	/*2490*/ uint16(xArgMm1),
	/*2491*/ uint16(xArgMm2M64),
	/*2492*/ uint16(xMatch),
	/*2493*/ uint16(xSetOp), uint16(PMULHRSW),
	/*2495*/ uint16(xReadSlashR),
	/*2496*/ uint16(xArgXmm1),
	/*2497*/ uint16(xArgXmm2M128),
	/*2498*/ uint16(xMatch),
	/*2499*/ uint16(xCondPrefix), 1,
	0x66, 2503,
	/*2503*/ uint16(xSetOp), uint16(PBLENDVB),
	/*2505*/ uint16(xReadSlashR),
	/*2506*/ uint16(xArgXmm1),
	/*2507*/ uint16(xArgXmm2M128),
	/*2508*/ uint16(xArgXMM0),
	/*2509*/ uint16(xMatch),
	/*2510*/ uint16(xCondPrefix), 1,
	0x66, 2514,
	/*2514*/ uint16(xSetOp), uint16(BLENDVPS),
	/*2516*/ uint16(xReadSlashR),
	/*2517*/ uint16(xArgXmm1),
	/*2518*/ uint16(xArgXmm2M128),
	/*2519*/ uint16(xArgXMM0),
	/*2520*/ uint16(xMatch),
	/*2521*/ uint16(xCondPrefix), 1,
	0x66, 2525,
	/*2525*/ uint16(xSetOp), uint16(BLENDVPD),
	/*2527*/ uint16(xReadSlashR),
	/*2528*/ uint16(xArgXmm1),
	/*2529*/ uint16(xArgXmm2M128),
	/*2530*/ uint16(xArgXMM0),
	/*2531*/ uint16(xMatch),
	/*2532*/ uint16(xCondPrefix), 1,
	0x66, 2536,
	/*2536*/ uint16(xSetOp), uint16(PTEST),
	/*2538*/ uint16(xReadSlashR),
	/*2539*/ uint16(xArgXmm1),
	/*2540*/ uint16(xArgXmm2M128),
	/*2541*/ uint16(xMatch),
	/*2542*/ uint16(xCondPrefix), 2,
	0x66, 2554,
	0x0, 2548,
	/*2548*/ uint16(xSetOp), uint16(PABSB),
	/*2550*/ uint16(xReadSlashR),
	/*2551*/ uint16(xArgMm1),
	/*2552*/ uint16(xArgMm2M64),
	/*2553*/ uint16(xMatch),
	/*2554*/ uint16(xSetOp), uint16(PABSB),
	/*2556*/ uint16(xReadSlashR),
	/*2557*/ uint16(xArgXmm1),
	/*2558*/ uint16(xArgXmm2M128),
	/*2559*/ uint16(xMatch),
	/*2560*/ uint16(xCondPrefix), 2,
	0x66, 2572,
	0x0, 2566,
	/*2566*/ uint16(xSetOp), uint16(PABSW),
	/*2568*/ uint16(xReadSlashR),
	/*2569*/ uint16(xArgMm1),
	/*2570*/ uint16(xArgMm2M64),
	/*2571*/ uint16(xMatch),
	/*2572*/ uint16(xSetOp), uint16(PABSW),
	/*2574*/ uint16(xReadSlashR),
	/*2575*/ uint16(xArgXmm1),
	/*2576*/ uint16(xArgXmm2M128),
	/*2577*/ uint16(xMatch),
	/*2578*/ uint16(xCondPrefix), 2,
	0x66, 2590,
	0x0, 2584,
	/*2584*/ uint16(xSetOp), uint16(PABSD),
	/*2586*/ uint16(xReadSlashR),
	/*2587*/ uint16(xArgMm1),
	/*2588*/ uint16(xArgMm2M64),
	/*2589*/ uint16(xMatch),
	/*2590*/ uint16(xSetOp), uint16(PABSD),
	/*2592*/ uint16(xReadSlashR),
	/*2593*/ uint16(xArgXmm1),
	/*2594*/ uint16(xArgXmm2M128),
	/*2595*/ uint16(xMatch),
	/*2596*/ uint16(xCondPrefix), 1,
	0x66, 2600,
	/*2600*/ uint16(xSetOp), uint16(PMOVSXBW),
	/*2602*/ uint16(xReadSlashR),
	/*2603*/ uint16(xArgXmm1),
	/*2604*/ uint16(xArgXmm2M64),
	/*2605*/ uint16(xMatch),
	/*2606*/ uint16(xCondPrefix), 1,
	0x66, 2610,
	/*2610*/ uint16(xSetOp), uint16(PMOVSXBD),
	/*2612*/ uint16(xReadSlashR),
	/*2613*/ uint16(xArgXmm1),
	/*2614*/ uint16(xArgXmm2M32),
	/*2615*/ uint16(xMatch),
	/*2616*/ uint16(xCondPrefix), 1,
	0x66, 2620,
	/*2620*/ uint16(xSetOp), uint16(PMOVSXBQ),
	/*2622*/ uint16(xReadSlashR),
	/*2623*/ uint16(xArgXmm1),
	/*2624*/ uint16(xArgXmm2M16),
	/*2625*/ uint16(xMatch),
	/*2626*/ uint16(xCondPrefix), 1,
	0x66, 2630,
	/*2630*/ uint16(xSetOp), uint16(PMOVSXWD),
	/*2632*/ uint16(xReadSlashR),
	/*2633*/ uint16(xArgXmm1),
	/*2634*/ uint16(xArgXmm2M64),
	/*2635*/ uint16(xMatch),
	/*2636*/ uint16(xCondPrefix), 1,
	0x66, 2640,
	/*2640*/ uint16(xSetOp), uint16(PMOVSXWQ),
	/*2642*/ uint16(xReadSlashR),
	/*2643*/ uint16(xArgXmm1),
	/*2644*/ uint16(xArgXmm2M32),
	/*2645*/ uint16(xMatch),
	/*2646*/ uint16(xCondPrefix), 1,
	0x66, 2650,
	/*2650*/ uint16(xSetOp), uint16(PMOVSXDQ),
	/*2652*/ uint16(xReadSlashR),
	/*2653*/ uint16(xArgXmm1),
	/*2654*/ uint16(xArgXmm2M64),
	/*2655*/ uint16(xMatch),
	/*2656*/ uint16(xCondPrefix), 1,
	0x66, 2660,
	/*2660*/ uint16(xSetOp), uint16(PMULDQ),
	/*2662*/ uint16(xReadSlashR),
	/*2663*/ uint16(xArgXmm1),
	/*2664*/ uint16(xArgXmm2M128),
	/*2665*/ uint16(xMatch),
	/*2666*/ uint16(xCondPrefix), 1,
	0x66, 2670,
	/*2670*/ uint16(xSetOp), uint16(PCMPEQQ),
	/*2672*/ uint16(xReadSlashR),
	/*2673*/ uint16(xArgXmm1),
	/*2674*/ uint16(xArgXmm2M128),
	/*2675*/ uint16(xMatch),
	/*2676*/ uint16(xCondPrefix), 1,
	0x66, 2680,
	/*2680*/ uint16(xSetOp), uint16(MOVNTDQA),
	/*2682*/ uint16(xReadSlashR),
	/*2683*/ uint16(xArgXmm1),
	/*2684*/ uint16(xArgM128),
	/*2685*/ uint16(xMatch),
	/*2686*/ uint16(xCondPrefix), 1,
	0x66, 2690,
	/*2690*/ uint16(xSetOp), uint16(PACKUSDW),
	/*2692*/ uint16(xReadSlashR),
	/*2693*/ uint16(xArgXmm1),
	/*2694*/ uint16(xArgXmm2M128),
	/*2695*/ uint16(xMatch),
	/*2696*/ uint16(xCondPrefix), 1,
	0x66, 2700,
	/*2700*/ uint16(xSetOp), uint16(PMOVZXBW),
	/*2702*/ uint16(xReadSlashR),
	/*2703*/ uint16(xArgXmm1),
	/*2704*/ uint16(xArgXmm2M64),
	/*2705*/ uint16(xMatch),
	/*2706*/ uint16(xCondPrefix), 1,
	0x66, 2710,
	/*2710*/ uint16(xSetOp), uint16(PMOVZXBD),
	/*2712*/ uint16(xReadSlashR),
	/*2713*/ uint16(xArgXmm1),
	/*2714*/ uint16(xArgXmm2M32),
	/*2715*/ uint16(xMatch),
	/*2716*/ uint16(xCondPrefix), 1,
	0x66, 2720,
	/*2720*/ uint16(xSetOp), uint16(PMOVZXBQ),
	/*2722*/ uint16(xReadSlashR),
	/*2723*/ uint16(xArgXmm1),
	/*2724*/ uint16(xArgXmm2M16),
	/*2725*/ uint16(xMatch),
	/*2726*/ uint16(xCondPrefix), 1,
	0x66, 2730,
	/*2730*/ uint16(xSetOp), uint16(PMOVZXWD),
	/*2732*/ uint16(xReadSlashR),
	/*2733*/ uint16(xArgXmm1),
	/*2734*/ uint16(xArgXmm2M64),
	/*2735*/ uint16(xMatch),
	/*2736*/ uint16(xCondPrefix), 1,
	0x66, 2740,
	/*2740*/ uint16(xSetOp), uint16(PMOVZXWQ),
	/*2742*/ uint16(xReadSlashR),
	/*2743*/ uint16(xArgXmm1),
	/*2744*/ uint16(xArgXmm2M32),
	/*2745*/ uint16(xMatch),
	/*2746*/ uint16(xCondPrefix), 1,
	0x66, 2750,
	/*2750*/ uint16(xSetOp), uint16(PMOVZXDQ),
	/*2752*/ uint16(xReadSlashR),
	/*2753*/ uint16(xArgXmm1),
	/*2754*/ uint16(xArgXmm2M64),
	/*2755*/ uint16(xMatch),
	/*2756*/ uint16(xCondPrefix), 1,
	0x66, 2760,
	/*2760*/ uint16(xSetOp), uint16(PCMPGTQ),
	/*2762*/ uint16(xReadSlashR),
	/*2763*/ uint16(xArgXmm1),
	/*2764*/ uint16(xArgXmm2M128),
	/*2765*/ uint16(xMatch),
	/*2766*/ uint16(xCondPrefix), 1,
	0x66, 2770,
	/*2770*/ uint16(xSetOp), uint16(PMINSB),
	/*2772*/ uint16(xReadSlashR),
	/*2773*/ uint16(xArgXmm1),
	/*2774*/ uint16(xArgXmm2M128),
	/*2775*/ uint16(xMatch),
	/*2776*/ uint16(xCondPrefix), 1,
	0x66, 2780,
	/*2780*/ uint16(xSetOp), uint16(PMINSD),
	/*2782*/ uint16(xReadSlashR),
	/*2783*/ uint16(xArgXmm1),
	/*2784*/ uint16(xArgXmm2M128),
	/*2785*/ uint16(xMatch),
	/*2786*/ uint16(xCondPrefix), 1,
	0x66, 2790,
	/*2790*/ uint16(xSetOp), uint16(PMINUW),
	/*2792*/ uint16(xReadSlashR),
	/*2793*/ uint16(xArgXmm1),
	/*2794*/ uint16(xArgXmm2M128),
	/*2795*/ uint16(xMatch),
	/*2796*/ uint16(xCondPrefix), 1,
	0x66, 2800,
	/*2800*/ uint16(xSetOp), uint16(PMINUD),
	/*2802*/ uint16(xReadSlashR),
	/*2803*/ uint16(xArgXmm1),
	/*2804*/ uint16(xArgXmm2M128),
	/*2805*/ uint16(xMatch),
	/*2806*/ uint16(xCondPrefix), 1,
	0x66, 2810,
	/*2810*/ uint16(xSetOp), uint16(PMAXSB),
	/*2812*/ uint16(xReadSlashR),
	/*2813*/ uint16(xArgXmm1),
	/*2814*/ uint16(xArgXmm2M128),
	/*2815*/ uint16(xMatch),
	/*2816*/ uint16(xCondPrefix), 1,
	0x66, 2820,
	/*2820*/ uint16(xSetOp), uint16(PMAXSD),
	/*2822*/ uint16(xReadSlashR),
	/*2823*/ uint16(xArgXmm1),
	/*2824*/ uint16(xArgXmm2M128),
	/*2825*/ uint16(xMatch),
	/*2826*/ uint16(xCondPrefix), 1,
	0x66, 2830,
	/*2830*/ uint16(xSetOp), uint16(PMAXUW),
	/*2832*/ uint16(xReadSlashR),
	/*2833*/ uint16(xArgXmm1),
	/*2834*/ uint16(xArgXmm2M128),
	/*2835*/ uint16(xMatch),
	/*2836*/ uint16(xCondPrefix), 1,
	0x66, 2840,
	/*2840*/ uint16(xSetOp), uint16(PMAXUD),
	/*2842*/ uint16(xReadSlashR),
	/*2843*/ uint16(xArgXmm1),
	/*2844*/ uint16(xArgXmm2M128),
	/*2845*/ uint16(xMatch),
	/*2846*/ uint16(xCondPrefix), 1,
	0x66, 2850,
	/*2850*/ uint16(xSetOp), uint16(PMULLD),
	/*2852*/ uint16(xReadSlashR),
	/*2853*/ uint16(xArgXmm1),
	/*2854*/ uint16(xArgXmm2M128),
	/*2855*/ uint16(xMatch),
	/*2856*/ uint16(xCondPrefix), 1,
	0x66, 2860,
	/*2860*/ uint16(xSetOp), uint16(PHMINPOSUW),
	/*2862*/ uint16(xReadSlashR),
	/*2863*/ uint16(xArgXmm1),
	/*2864*/ uint16(xArgXmm2M128),
	/*2865*/ uint16(xMatch),
	/*2866*/ uint16(xCondIs64), 2869, 2879,
	/*2869*/ uint16(xCondPrefix), 1,
	0x66, 2873,
	/*2873*/ uint16(xSetOp), uint16(INVPCID),
	/*2875*/ uint16(xReadSlashR),
	/*2876*/ uint16(xArgR32),
	/*2877*/ uint16(xArgM128),
	/*2878*/ uint16(xMatch),
	/*2879*/ uint16(xCondPrefix), 1,
	0x66, 2883,
	/*2883*/ uint16(xSetOp), uint16(INVPCID),
	/*2885*/ uint16(xReadSlashR),
	/*2886*/ uint16(xArgR64),
	/*2887*/ uint16(xArgM128),
	/*2888*/ uint16(xMatch),
	/*2889*/ uint16(xCondPrefix), 1,
	0x66, 2893,
	/*2893*/ uint16(xSetOp), uint16(AESIMC),
	/*2895*/ uint16(xReadSlashR),
	/*2896*/ uint16(xArgXmm1),
	/*2897*/ uint16(xArgXmm2M128),
	/*2898*/ uint16(xMatch),
	/*2899*/ uint16(xCondPrefix), 1,
	0x66, 2903,
	/*2903*/ uint16(xSetOp), uint16(AESENC),
	/*2905*/ uint16(xReadSlashR),
	/*2906*/ uint16(xArgXmm1),
	/*2907*/ uint16(xArgXmm2M128),
	/*2908*/ uint16(xMatch),
	/*2909*/ uint16(xCondPrefix), 1,
	0x66, 2913,
	/*2913*/ uint16(xSetOp), uint16(AESENCLAST),
	/*2915*/ uint16(xReadSlashR),
	/*2916*/ uint16(xArgXmm1),
	/*2917*/ uint16(xArgXmm2M128),
	/*2918*/ uint16(xMatch),
	/*2919*/ uint16(xCondPrefix), 1,
	0x66, 2923,
	/*2923*/ uint16(xSetOp), uint16(AESDEC),
	/*2925*/ uint16(xReadSlashR),
	/*2926*/ uint16(xArgXmm1),
	/*2927*/ uint16(xArgXmm2M128),
	/*2928*/ uint16(xMatch),
	/*2929*/ uint16(xCondPrefix), 1,
	0x66, 2933,
	/*2933*/ uint16(xSetOp), uint16(AESDECLAST),
	/*2935*/ uint16(xReadSlashR),
	/*2936*/ uint16(xArgXmm1),
	/*2937*/ uint16(xArgXmm2M128),
	/*2938*/ uint16(xMatch),
	/*2939*/ uint16(xCondIs64), 2942, 2980,
	/*2942*/ uint16(xCondPrefix), 2,
	0xF2, 2964,
	0x0, 2948,
	/*2948*/ uint16(xCondDataSize), 2952, 2958, 0,
	/*2952*/ uint16(xSetOp), uint16(MOVBE),
	/*2954*/ uint16(xReadSlashR),
	/*2955*/ uint16(xArgR16),
	/*2956*/ uint16(xArgM16),
	/*2957*/ uint16(xMatch),
	/*2958*/ uint16(xSetOp), uint16(MOVBE),
	/*2960*/ uint16(xReadSlashR),
	/*2961*/ uint16(xArgR32),
	/*2962*/ uint16(xArgM32),
	/*2963*/ uint16(xMatch),
	/*2964*/ uint16(xCondDataSize), 2968, 2974, 0,
	/*2968*/ uint16(xSetOp), uint16(CRC32),
	/*2970*/ uint16(xReadSlashR),
	/*2971*/ uint16(xArgR32),
	/*2972*/ uint16(xArgRM8),
	/*2973*/ uint16(xMatch),
	/*2974*/ uint16(xSetOp), uint16(CRC32),
	/*2976*/ uint16(xReadSlashR),
	/*2977*/ uint16(xArgR32),
	/*2978*/ uint16(xArgRM8),
	/*2979*/ uint16(xMatch),
	/*2980*/ uint16(xCondPrefix), 2,
	0xF2, 2996,
	0x0, 2986,
	/*2986*/ uint16(xCondDataSize), 2952, 2958, 2990,
	/*2990*/ uint16(xSetOp), uint16(MOVBE),
	/*2992*/ uint16(xReadSlashR),
	/*2993*/ uint16(xArgR64),
	/*2994*/ uint16(xArgM64),
	/*2995*/ uint16(xMatch),
	/*2996*/ uint16(xCondDataSize), 2968, 2974, 3000,
	/*3000*/ uint16(xSetOp), uint16(CRC32),
	/*3002*/ uint16(xReadSlashR),
	/*3003*/ uint16(xArgR64),
	/*3004*/ uint16(xArgRM8),
	/*3005*/ uint16(xMatch),
	/*3006*/ uint16(xCondIs64), 3009, 3047,
	/*3009*/ uint16(xCondPrefix), 2,
	0xF2, 3031,
	0x0, 3015,
	/*3015*/ uint16(xCondDataSize), 3019, 3025, 0,
	/*3019*/ uint16(xSetOp), uint16(MOVBE),
	/*3021*/ uint16(xReadSlashR),
	/*3022*/ uint16(xArgM16),
	/*3023*/ uint16(xArgR16),
	/*3024*/ uint16(xMatch),
	/*3025*/ uint16(xSetOp), uint16(MOVBE),
	/*3027*/ uint16(xReadSlashR),
	/*3028*/ uint16(xArgM32),
	/*3029*/ uint16(xArgR32),
	/*3030*/ uint16(xMatch),
	/*3031*/ uint16(xCondDataSize), 3035, 3041, 0,
	/*3035*/ uint16(xSetOp), uint16(CRC32),
	/*3037*/ uint16(xReadSlashR),
	/*3038*/ uint16(xArgR32),
	/*3039*/ uint16(xArgRM16),
	/*3040*/ uint16(xMatch),
	/*3041*/ uint16(xSetOp), uint16(CRC32),
	/*3043*/ uint16(xReadSlashR),
	/*3044*/ uint16(xArgR32),
	/*3045*/ uint16(xArgRM32),
	/*3046*/ uint16(xMatch),
	/*3047*/ uint16(xCondPrefix), 2,
	0xF2, 3063,
	0x0, 3053,
	/*3053*/ uint16(xCondDataSize), 3019, 3025, 3057,
	/*3057*/ uint16(xSetOp), uint16(MOVBE),
	/*3059*/ uint16(xReadSlashR),
	/*3060*/ uint16(xArgM64),
	/*3061*/ uint16(xArgR64),
	/*3062*/ uint16(xMatch),
	/*3063*/ uint16(xCondDataSize), 3035, 3041, 3067,
	/*3067*/ uint16(xSetOp), uint16(CRC32),
	/*3069*/ uint16(xReadSlashR),
	/*3070*/ uint16(xArgR64),
	/*3071*/ uint16(xArgRM64),
	/*3072*/ uint16(xMatch),
	/*3073*/ uint16(xCondByte), 24,
	0x08, 3124,
	0x09, 3136,
	0x0A, 3148,
	0x0B, 3160,
	0x0C, 3172,
	0x0D, 3184,
	0x0E, 3196,
	0x0F, 3208,
	0x14, 3230,
	0x15, 3242,
	0x16, 3254,
	0x17, 3297,
	0x20, 3309,
	0x21, 3321,
	0x22, 3333,
	0x40, 3376,
	0x41, 3388,
	0x42, 3400,
	0x44, 3412,
	0x60, 3424,
	0x61, 3436,
	0x62, 3448,
	0x63, 3460,
	0xDF, 3472,
	uint16(xFail),
	/*3124*/ uint16(xCondPrefix), 1,
	0x66, 3128,
	/*3128*/ uint16(xSetOp), uint16(ROUNDPS),
	/*3130*/ uint16(xReadSlashR),
	/*3131*/ uint16(xReadIb),
	/*3132*/ uint16(xArgXmm1),
	/*3133*/ uint16(xArgXmm2M128),
	/*3134*/ uint16(xArgImm8u),
	/*3135*/ uint16(xMatch),
	/*3136*/ uint16(xCondPrefix), 1,
	0x66, 3140,
	/*3140*/ uint16(xSetOp), uint16(ROUNDPD),
	/*3142*/ uint16(xReadSlashR),
	/*3143*/ uint16(xReadIb),
	/*3144*/ uint16(xArgXmm1),
	/*3145*/ uint16(xArgXmm2M128),
	/*3146*/ uint16(xArgImm8u),
	/*3147*/ uint16(xMatch),
	/*3148*/ uint16(xCondPrefix), 1,
	0x66, 3152,
	/*3152*/ uint16(xSetOp), uint16(ROUNDSS),
	/*3154*/ uint16(xReadSlashR),
	/*3155*/ uint16(xReadIb),
	/*3156*/ uint16(xArgXmm1),
	/*3157*/ uint16(xArgXmm2M32),
	/*3158*/ uint16(xArgImm8u),
	/*3159*/ uint16(xMatch),
	/*3160*/ uint16(xCondPrefix), 1,
	0x66, 3164,
	/*3164*/ uint16(xSetOp), uint16(ROUNDSD),
	/*3166*/ uint16(xReadSlashR),
	/*3167*/ uint16(xReadIb),
	/*3168*/ uint16(xArgXmm1),
	/*3169*/ uint16(xArgXmm2M64),
	/*3170*/ uint16(xArgImm8u),
	/*3171*/ uint16(xMatch),
	/*3172*/ uint16(xCondPrefix), 1,
	0x66, 3176,
	/*3176*/ uint16(xSetOp), uint16(BLENDPS),
	/*3178*/ uint16(xReadSlashR),
	/*3179*/ uint16(xReadIb),
	/*3180*/ uint16(xArgXmm1),
	/*3181*/ uint16(xArgXmm2M128),
	/*3182*/ uint16(xArgImm8u),
	/*3183*/ uint16(xMatch),
	/*3184*/ uint16(xCondPrefix), 1,
	0x66, 3188,
	/*3188*/ uint16(xSetOp), uint16(BLENDPD),
	/*3190*/ uint16(xReadSlashR),
	/*3191*/ uint16(xReadIb),
	/*3192*/ uint16(xArgXmm1),
	/*3193*/ uint16(xArgXmm2M128),
	/*3194*/ uint16(xArgImm8u),
	/*3195*/ uint16(xMatch),
	/*3196*/ uint16(xCondPrefix), 1,
	0x66, 3200,
	/*3200*/ uint16(xSetOp), uint16(PBLENDW),
	/*3202*/ uint16(xReadSlashR),
	/*3203*/ uint16(xReadIb),
	/*3204*/ uint16(xArgXmm1),
	/*3205*/ uint16(xArgXmm2M128),
	/*3206*/ uint16(xArgImm8u),
	/*3207*/ uint16(xMatch),
	/*3208*/ uint16(xCondPrefix), 2,
	0x66, 3222,
	0x0, 3214,
	/*3214*/ uint16(xSetOp), uint16(PALIGNR),
	/*3216*/ uint16(xReadSlashR),
	/*3217*/ uint16(xReadIb),
	/*3218*/ uint16(xArgMm1),
	/*3219*/ uint16(xArgMm2M64),
	/*3220*/ uint16(xArgImm8u),
	/*3221*/ uint16(xMatch),
	/*3222*/ uint16(xSetOp), uint16(PALIGNR),
	/*3224*/ uint16(xReadSlashR),
	/*3225*/ uint16(xReadIb),
	/*3226*/ uint16(xArgXmm1),
	/*3227*/ uint16(xArgXmm2M128),
	/*3228*/ uint16(xArgImm8u),
	/*3229*/ uint16(xMatch),
	/*3230*/ uint16(xCondPrefix), 1,
	0x66, 3234,
	/*3234*/ uint16(xSetOp), uint16(PEXTRB),
	/*3236*/ uint16(xReadSlashR),
	/*3237*/ uint16(xReadIb),
	/*3238*/ uint16(xArgR32M8),
	/*3239*/ uint16(xArgXmm1),
	/*3240*/ uint16(xArgImm8u),
	/*3241*/ uint16(xMatch),
	/*3242*/ uint16(xCondPrefix), 1,
	0x66, 3246,
	/*3246*/ uint16(xSetOp), uint16(PEXTRW),
	/*3248*/ uint16(xReadSlashR),
	/*3249*/ uint16(xReadIb),
	/*3250*/ uint16(xArgR32M16),
	/*3251*/ uint16(xArgXmm1),
	/*3252*/ uint16(xArgImm8u),
	/*3253*/ uint16(xMatch),
	/*3254*/ uint16(xCondIs64), 3257, 3281,
	/*3257*/ uint16(xCondPrefix), 1,
	0x66, 3261,
	/*3261*/ uint16(xCondDataSize), 3265, 3273, 0,
	/*3265*/ uint16(xSetOp), uint16(PEXTRD),
	/*3267*/ uint16(xReadSlashR),
	/*3268*/ uint16(xReadIb),
	/*3269*/ uint16(xArgRM32),
	/*3270*/ uint16(xArgXmm1),
	/*3271*/ uint16(xArgImm8u),
	/*3272*/ uint16(xMatch),
	/*3273*/ uint16(xSetOp), uint16(PEXTRD),
	/*3275*/ uint16(xReadSlashR),
	/*3276*/ uint16(xReadIb),
	/*3277*/ uint16(xArgRM32),
	/*3278*/ uint16(xArgXmm1),
	/*3279*/ uint16(xArgImm8u),
	/*3280*/ uint16(xMatch),
	/*3281*/ uint16(xCondPrefix), 1,
	0x66, 3285,
	/*3285*/ uint16(xCondDataSize), 3265, 3273, 3289,
	/*3289*/ uint16(xSetOp), uint16(PEXTRQ),
	/*3291*/ uint16(xReadSlashR),
	/*3292*/ uint16(xReadIb),
	/*3293*/ uint16(xArgRM64),
	/*3294*/ uint16(xArgXmm1),
	/*3295*/ uint16(xArgImm8u),
	/*3296*/ uint16(xMatch),
	/*3297*/ uint16(xCondPrefix), 1,
	0x66, 3301,
	/*3301*/ uint16(xSetOp), uint16(EXTRACTPS),
	/*3303*/ uint16(xReadSlashR),
	/*3304*/ uint16(xReadIb),
	/*3305*/ uint16(xArgRM32),
	/*3306*/ uint16(xArgXmm1),
	/*3307*/ uint16(xArgImm8u),
	/*3308*/ uint16(xMatch),
	/*3309*/ uint16(xCondPrefix), 1,
	0x66, 3313,
	/*3313*/ uint16(xSetOp), uint16(PINSRB),
	/*3315*/ uint16(xReadSlashR),
	/*3316*/ uint16(xReadIb),
	/*3317*/ uint16(xArgXmm1),
	/*3318*/ uint16(xArgR32M8),
	/*3319*/ uint16(xArgImm8u),
	/*3320*/ uint16(xMatch),
	/*3321*/ uint16(xCondPrefix), 1,
	0x66, 3325,
	/*3325*/ uint16(xSetOp), uint16(INSERTPS),
	/*3327*/ uint16(xReadSlashR),
	/*3328*/ uint16(xReadIb),
	/*3329*/ uint16(xArgXmm1),
	/*3330*/ uint16(xArgXmm2M32),
	/*3331*/ uint16(xArgImm8u),
	/*3332*/ uint16(xMatch),
	/*3333*/ uint16(xCondIs64), 3336, 3360,
	/*3336*/ uint16(xCondPrefix), 1,
	0x66, 3340,
	/*3340*/ uint16(xCondDataSize), 3344, 3352, 0,
	/*3344*/ uint16(xSetOp), uint16(PINSRD),
	/*3346*/ uint16(xReadSlashR),
	/*3347*/ uint16(xReadIb),
	/*3348*/ uint16(xArgXmm1),
	/*3349*/ uint16(xArgRM32),
	/*3350*/ uint16(xArgImm8u),
	/*3351*/ uint16(xMatch),
	/*3352*/ uint16(xSetOp), uint16(PINSRD),
	/*3354*/ uint16(xReadSlashR),
	/*3355*/ uint16(xReadIb),
	/*3356*/ uint16(xArgXmm1),
	/*3357*/ uint16(xArgRM32),
	/*3358*/ uint16(xArgImm8u),
	/*3359*/ uint16(xMatch),
	/*3360*/ uint16(xCondPrefix), 1,
	0x66, 3364,
	/*3364*/ uint16(xCondDataSize), 3344, 3352, 3368,
	/*3368*/ uint16(xSetOp), uint16(PINSRQ),
	/*3370*/ uint16(xReadSlashR),
	/*3371*/ uint16(xReadIb),
	/*3372*/ uint16(xArgXmm1),
	/*3373*/ uint16(xArgRM64),
	/*3374*/ uint16(xArgImm8u),
	/*3375*/ uint16(xMatch),
	/*3376*/ uint16(xCondPrefix), 1,
	0x66, 3380,
	/*3380*/ uint16(xSetOp), uint16(DPPS),
	/*3382*/ uint16(xReadSlashR),
	/*3383*/ uint16(xReadIb),
	/*3384*/ uint16(xArgXmm1),
	/*3385*/ uint16(xArgXmm2M128),
	/*3386*/ uint16(xArgImm8u),
	/*3387*/ uint16(xMatch),
	/*3388*/ uint16(xCondPrefix), 1,
	0x66, 3392,
	/*3392*/ uint16(xSetOp), uint16(DPPD),
	/*3394*/ uint16(xReadSlashR),
	/*3395*/ uint16(xReadIb),
	/*3396*/ uint16(xArgXmm1),
	/*3397*/ uint16(xArgXmm2M128),
	/*3398*/ uint16(xArgImm8u),
	/*3399*/ uint16(xMatch),
	/*3400*/ uint16(xCondPrefix), 1,
	0x66, 3404,
	/*3404*/ uint16(xSetOp), uint16(MPSADBW),
	/*3406*/ uint16(xReadSlashR),
	/*3407*/ uint16(xReadIb),
	/*3408*/ uint16(xArgXmm1),
	/*3409*/ uint16(xArgXmm2M128),
	/*3410*/ uint16(xArgImm8u),
	/*3411*/ uint16(xMatch),
	/*3412*/ uint16(xCondPrefix), 1,
	0x66, 3416,
	/*3416*/ uint16(xSetOp), uint16(PCLMULQDQ),
	/*3418*/ uint16(xReadSlashR),
	/*3419*/ uint16(xReadIb),
	/*3420*/ uint16(xArgXmm1),
	/*3421*/ uint16(xArgXmm2M128),
	/*3422*/ uint16(xArgImm8u),
	/*3423*/ uint16(xMatch),
	/*3424*/ uint16(xCondPrefix), 1,
	0x66, 3428,
	/*3428*/ uint16(xSetOp), uint16(PCMPESTRM),
	/*3430*/ uint16(xReadSlashR),
	/*3431*/ uint16(xReadIb),
	/*3432*/ uint16(xArgXmm1),
	/*3433*/ uint16(xArgXmm2M128),
	/*3434*/ uint16(xArgImm8u),
	/*3435*/ uint16(xMatch),
	/*3436*/ uint16(xCondPrefix), 1,
	0x66, 3440,
	/*3440*/ uint16(xSetOp), uint16(PCMPESTRI),
	/*3442*/ uint16(xReadSlashR),
	/*3443*/ uint16(xReadIb),
	/*3444*/ uint16(xArgXmm1),
	/*3445*/ uint16(xArgXmm2M128),
	/*3446*/ uint16(xArgImm8u),
	/*3447*/ uint16(xMatch),
	/*3448*/ uint16(xCondPrefix), 1,
	0x66, 3452,
	/*3452*/ uint16(xSetOp), uint16(PCMPISTRM),
	/*3454*/ uint16(xReadSlashR),
	/*3455*/ uint16(xReadIb),
	/*3456*/ uint16(xArgXmm1),
	/*3457*/ uint16(xArgXmm2M128),
	/*3458*/ uint16(xArgImm8u),
	/*3459*/ uint16(xMatch),
	/*3460*/ uint16(xCondPrefix), 1,
	0x66, 3464,
	/*3464*/ uint16(xSetOp), uint16(PCMPISTRI),
	/*3466*/ uint16(xReadSlashR),
	/*3467*/ uint16(xReadIb),
	/*3468*/ uint16(xArgXmm1),
	/*3469*/ uint16(xArgXmm2M128),
	/*3470*/ uint16(xArgImm8u),
	/*3471*/ uint16(xMatch),
	/*3472*/ uint16(xCondPrefix), 1,
	0x66, 3476,
	/*3476*/ uint16(xSetOp), uint16(AESKEYGENASSIST),
	/*3478*/ uint16(xReadSlashR),
	/*3479*/ uint16(xReadIb),
	/*3480*/ uint16(xArgXmm1),
	/*3481*/ uint16(xArgXmm2M128),
	/*3482*/ uint16(xArgImm8u),
	/*3483*/ uint16(xMatch),
	/*3484*/ uint16(xCondIs64), 3487, 3503,
	/*3487*/ uint16(xCondDataSize), 3491, 3497, 0,
	/*3491*/ uint16(xSetOp), uint16(CMOVO),
	/*3493*/ uint16(xReadSlashR),
	/*3494*/ uint16(xArgR16),
	/*3495*/ uint16(xArgRM16),
	/*3496*/ uint16(xMatch),
	/*3497*/ uint16(xSetOp), uint16(CMOVO),
	/*3499*/ uint16(xReadSlashR),
	/*3500*/ uint16(xArgR32),
	/*3501*/ uint16(xArgRM32),
	/*3502*/ uint16(xMatch),
	/*3503*/ uint16(xCondDataSize), 3491, 3497, 3507,
	/*3507*/ uint16(xSetOp), uint16(CMOVO),
	/*3509*/ uint16(xReadSlashR),
	/*3510*/ uint16(xArgR64),
	/*3511*/ uint16(xArgRM64),
	/*3512*/ uint16(xMatch),
	/*3513*/ uint16(xCondIs64), 3516, 3532,
	/*3516*/ uint16(xCondDataSize), 3520, 3526, 0,
	/*3520*/ uint16(xSetOp), uint16(CMOVNO),
	/*3522*/ uint16(xReadSlashR),
	/*3523*/ uint16(xArgR16),
	/*3524*/ uint16(xArgRM16),
	/*3525*/ uint16(xMatch),
	/*3526*/ uint16(xSetOp), uint16(CMOVNO),
	/*3528*/ uint16(xReadSlashR),
	/*3529*/ uint16(xArgR32),
	/*3530*/ uint16(xArgRM32),
	/*3531*/ uint16(xMatch),
	/*3532*/ uint16(xCondDataSize), 3520, 3526, 3536,
	/*3536*/ uint16(xSetOp), uint16(CMOVNO),
	/*3538*/ uint16(xReadSlashR),
	/*3539*/ uint16(xArgR64),
	/*3540*/ uint16(xArgRM64),
	/*3541*/ uint16(xMatch),
	/*3542*/ uint16(xCondIs64), 3545, 3561,
	/*3545*/ uint16(xCondDataSize), 3549, 3555, 0,
	/*3549*/ uint16(xSetOp), uint16(CMOVB),
	/*3551*/ uint16(xReadSlashR),
	/*3552*/ uint16(xArgR16),
	/*3553*/ uint16(xArgRM16),
	/*3554*/ uint16(xMatch),
	/*3555*/ uint16(xSetOp), uint16(CMOVB),
	/*3557*/ uint16(xReadSlashR),
	/*3558*/ uint16(xArgR32),
	/*3559*/ uint16(xArgRM32),
	/*3560*/ uint16(xMatch),
	/*3561*/ uint16(xCondDataSize), 3549, 3555, 3565,
	/*3565*/ uint16(xSetOp), uint16(CMOVB),
	/*3567*/ uint16(xReadSlashR),
	/*3568*/ uint16(xArgR64),
	/*3569*/ uint16(xArgRM64),
	/*3570*/ uint16(xMatch),
	/*3571*/ uint16(xCondIs64), 3574, 3590,
	/*3574*/ uint16(xCondDataSize), 3578, 3584, 0,
	/*3578*/ uint16(xSetOp), uint16(CMOVAE),
	/*3580*/ uint16(xReadSlashR),
	/*3581*/ uint16(xArgR16),
	/*3582*/ uint16(xArgRM16),
	/*3583*/ uint16(xMatch),
	/*3584*/ uint16(xSetOp), uint16(CMOVAE),
	/*3586*/ uint16(xReadSlashR),
	/*3587*/ uint16(xArgR32),
	/*3588*/ uint16(xArgRM32),
	/*3589*/ uint16(xMatch),
	/*3590*/ uint16(xCondDataSize), 3578, 3584, 3594,
	/*3594*/ uint16(xSetOp), uint16(CMOVAE),
	/*3596*/ uint16(xReadSlashR),
	/*3597*/ uint16(xArgR64),
	/*3598*/ uint16(xArgRM64),
	/*3599*/ uint16(xMatch),
	/*3600*/ uint16(xCondIs64), 3603, 3619,
	/*3603*/ uint16(xCondDataSize), 3607, 3613, 0,
	/*3607*/ uint16(xSetOp), uint16(CMOVE),
	/*3609*/ uint16(xReadSlashR),
	/*3610*/ uint16(xArgR16),
	/*3611*/ uint16(xArgRM16),
	/*3612*/ uint16(xMatch),
	/*3613*/ uint16(xSetOp), uint16(CMOVE),
	/*3615*/ uint16(xReadSlashR),
	/*3616*/ uint16(xArgR32),
	/*3617*/ uint16(xArgRM32),
	/*3618*/ uint16(xMatch),
	/*3619*/ uint16(xCondDataSize), 3607, 3613, 3623,
	/*3623*/ uint16(xSetOp), uint16(CMOVE),
	/*3625*/ uint16(xReadSlashR),
	/*3626*/ uint16(xArgR64),
	/*3627*/ uint16(xArgRM64),
	/*3628*/ uint16(xMatch),
	/*3629*/ uint16(xCondIs64), 3632, 3648,
	/*3632*/ uint16(xCondDataSize), 3636, 3642, 0,
	/*3636*/ uint16(xSetOp), uint16(CMOVNE),
	/*3638*/ uint16(xReadSlashR),
	/*3639*/ uint16(xArgR16),
	/*3640*/ uint16(xArgRM16),
	/*3641*/ uint16(xMatch),
	/*3642*/ uint16(xSetOp), uint16(CMOVNE),
	/*3644*/ uint16(xReadSlashR),
	/*3645*/ uint16(xArgR32),
	/*3646*/ uint16(xArgRM32),
	/*3647*/ uint16(xMatch),
	/*3648*/ uint16(xCondDataSize), 3636, 3642, 3652,
	/*3652*/ uint16(xSetOp), uint16(CMOVNE),
	/*3654*/ uint16(xReadSlashR),
	/*3655*/ uint16(xArgR64),
	/*3656*/ uint16(xArgRM64),
	/*3657*/ uint16(xMatch),
	/*3658*/ uint16(xCondIs64), 3661, 3677,
	/*3661*/ uint16(xCondDataSize), 3665, 3671, 0,
	/*3665*/ uint16(xSetOp), uint16(CMOVBE),
	/*3667*/ uint16(xReadSlashR),
	/*3668*/ uint16(xArgR16),
	/*3669*/ uint16(xArgRM16),
	/*3670*/ uint16(xMatch),
	/*3671*/ uint16(xSetOp), uint16(CMOVBE),
	/*3673*/ uint16(xReadSlashR),
	/*3674*/ uint16(xArgR32),
	/*3675*/ uint16(xArgRM32),
	/*3676*/ uint16(xMatch),
	/*3677*/ uint16(xCondDataSize), 3665, 3671, 3681,
	/*3681*/ uint16(xSetOp), uint16(CMOVBE),
	/*3683*/ uint16(xReadSlashR),
	/*3684*/ uint16(xArgR64),
	/*3685*/ uint16(xArgRM64),
	/*3686*/ uint16(xMatch),
	/*3687*/ uint16(xCondIs64), 3690, 3706,
	/*3690*/ uint16(xCondDataSize), 3694, 3700, 0,
	/*3694*/ uint16(xSetOp), uint16(CMOVA),
	/*3696*/ uint16(xReadSlashR),
	/*3697*/ uint16(xArgR16),
	/*3698*/ uint16(xArgRM16),
	/*3699*/ uint16(xMatch),
	/*3700*/ uint16(xSetOp), uint16(CMOVA),
	/*3702*/ uint16(xReadSlashR),
	/*3703*/ uint16(xArgR32),
	/*3704*/ uint16(xArgRM32),
	/*3705*/ uint16(xMatch),
	/*3706*/ uint16(xCondDataSize), 3694, 3700, 3710,
	/*3710*/ uint16(xSetOp), uint16(CMOVA),
	/*3712*/ uint16(xReadSlashR),
	/*3713*/ uint16(xArgR64),
	/*3714*/ uint16(xArgRM64),
	/*3715*/ uint16(xMatch),
	/*3716*/ uint16(xCondIs64), 3719, 3735,
	/*3719*/ uint16(xCondDataSize), 3723, 3729, 0,
	/*3723*/ uint16(xSetOp), uint16(CMOVS),
	/*3725*/ uint16(xReadSlashR),
	/*3726*/ uint16(xArgR16),
	/*3727*/ uint16(xArgRM16),
	/*3728*/ uint16(xMatch),
	/*3729*/ uint16(xSetOp), uint16(CMOVS),
	/*3731*/ uint16(xReadSlashR),
	/*3732*/ uint16(xArgR32),
	/*3733*/ uint16(xArgRM32),
	/*3734*/ uint16(xMatch),
	/*3735*/ uint16(xCondDataSize), 3723, 3729, 3739,
	/*3739*/ uint16(xSetOp), uint16(CMOVS),
	/*3741*/ uint16(xReadSlashR),
	/*3742*/ uint16(xArgR64),
	/*3743*/ uint16(xArgRM64),
	/*3744*/ uint16(xMatch),
	/*3745*/ uint16(xCondIs64), 3748, 3764,
	/*3748*/ uint16(xCondDataSize), 3752, 3758, 0,
	/*3752*/ uint16(xSetOp), uint16(CMOVNS),
	/*3754*/ uint16(xReadSlashR),
	/*3755*/ uint16(xArgR16),
	/*3756*/ uint16(xArgRM16),
	/*3757*/ uint16(xMatch),
	/*3758*/ uint16(xSetOp), uint16(CMOVNS),
	/*3760*/ uint16(xReadSlashR),
	/*3761*/ uint16(xArgR32),
	/*3762*/ uint16(xArgRM32),
	/*3763*/ uint16(xMatch),
	/*3764*/ uint16(xCondDataSize), 3752, 3758, 3768,
	/*3768*/ uint16(xSetOp), uint16(CMOVNS),
	/*3770*/ uint16(xReadSlashR),
	/*3771*/ uint16(xArgR64),
	/*3772*/ uint16(xArgRM64),
	/*3773*/ uint16(xMatch),
	/*3774*/ uint16(xCondIs64), 3777, 3793,
	/*3777*/ uint16(xCondDataSize), 3781, 3787, 0,
	/*3781*/ uint16(xSetOp), uint16(CMOVP),
	/*3783*/ uint16(xReadSlashR),
	/*3784*/ uint16(xArgR16),
	/*3785*/ uint16(xArgRM16),
	/*3786*/ uint16(xMatch),
	/*3787*/ uint16(xSetOp), uint16(CMOVP),
	/*3789*/ uint16(xReadSlashR),
	/*3790*/ uint16(xArgR32),
	/*3791*/ uint16(xArgRM32),
	/*3792*/ uint16(xMatch),
	/*3793*/ uint16(xCondDataSize), 3781, 3787, 3797,
	/*3797*/ uint16(xSetOp), uint16(CMOVP),
	/*3799*/ uint16(xReadSlashR),
	/*3800*/ uint16(xArgR64),
	/*3801*/ uint16(xArgRM64),
	/*3802*/ uint16(xMatch),
	/*3803*/ uint16(xCondIs64), 3806, 3822,
	/*3806*/ uint16(xCondDataSize), 3810, 3816, 0,
	/*3810*/ uint16(xSetOp), uint16(CMOVNP),
	/*3812*/ uint16(xReadSlashR),
	/*3813*/ uint16(xArgR16),
	/*3814*/ uint16(xArgRM16),
	/*3815*/ uint16(xMatch),
	/*3816*/ uint16(xSetOp), uint16(CMOVNP),
	/*3818*/ uint16(xReadSlashR),
	/*3819*/ uint16(xArgR32),
	/*3820*/ uint16(xArgRM32),
	/*3821*/ uint16(xMatch),
	/*3822*/ uint16(xCondDataSize), 3810, 3816, 3826,
	/*3826*/ uint16(xSetOp), uint16(CMOVNP),
	/*3828*/ uint16(xReadSlashR),
	/*3829*/ uint16(xArgR64),
	/*3830*/ uint16(xArgRM64),
	/*3831*/ uint16(xMatch),
	/*3832*/ uint16(xCondIs64), 3835, 3851,
	/*3835*/ uint16(xCondDataSize), 3839, 3845, 0,
	/*3839*/ uint16(xSetOp), uint16(CMOVL),
	/*3841*/ uint16(xReadSlashR),
	/*3842*/ uint16(xArgR16),
	/*3843*/ uint16(xArgRM16),
	/*3844*/ uint16(xMatch),
	/*3845*/ uint16(xSetOp), uint16(CMOVL),
	/*3847*/ uint16(xReadSlashR),
	/*3848*/ uint16(xArgR32),
	/*3849*/ uint16(xArgRM32),
	/*3850*/ uint16(xMatch),
	/*3851*/ uint16(xCondDataSize), 3839, 3845, 3855,
	/*3855*/ uint16(xSetOp), uint16(CMOVL),
	/*3857*/ uint16(xReadSlashR),
	/*3858*/ uint16(xArgR64),
	/*3859*/ uint16(xArgRM64),
	/*3860*/ uint16(xMatch),
	/*3861*/ uint16(xCondIs64), 3864, 3880,
	/*3864*/ uint16(xCondDataSize), 3868, 3874, 0,
	/*3868*/ uint16(xSetOp), uint16(CMOVGE),
	/*3870*/ uint16(xReadSlashR),
	/*3871*/ uint16(xArgR16),
	/*3872*/ uint16(xArgRM16),
	/*3873*/ uint16(xMatch),
	/*3874*/ uint16(xSetOp), uint16(CMOVGE),
	/*3876*/ uint16(xReadSlashR),
	/*3877*/ uint16(xArgR32),
	/*3878*/ uint16(xArgRM32),
	/*3879*/ uint16(xMatch),
	/*3880*/ uint16(xCondDataSize), 3868, 3874, 3884,
	/*3884*/ uint16(xSetOp), uint16(CMOVGE),
	/*3886*/ uint16(xReadSlashR),
	/*3887*/ uint16(xArgR64),
	/*3888*/ uint16(xArgRM64),
	/*3889*/ uint16(xMatch),
	/*3890*/ uint16(xCondIs64), 3893, 3909,
	/*3893*/ uint16(xCondDataSize), 3897, 3903, 0,
	/*3897*/ uint16(xSetOp), uint16(CMOVLE),
	/*3899*/ uint16(xReadSlashR),
	/*3900*/ uint16(xArgR16),
	/*3901*/ uint16(xArgRM16),
	/*3902*/ uint16(xMatch),
	/*3903*/ uint16(xSetOp), uint16(CMOVLE),
	/*3905*/ uint16(xReadSlashR),
	/*3906*/ uint16(xArgR32),
	/*3907*/ uint16(xArgRM32),
	/*3908*/ uint16(xMatch),
	/*3909*/ uint16(xCondDataSize), 3897, 3903, 3913,
	/*3913*/ uint16(xSetOp), uint16(CMOVLE),
	/*3915*/ uint16(xReadSlashR),
	/*3916*/ uint16(xArgR64),
	/*3917*/ uint16(xArgRM64),
	/*3918*/ uint16(xMatch),
	/*3919*/ uint16(xCondIs64), 3922, 3938,
	/*3922*/ uint16(xCondDataSize), 3926, 3932, 0,
	/*3926*/ uint16(xSetOp), uint16(CMOVG),
	/*3928*/ uint16(xReadSlashR),
	/*3929*/ uint16(xArgR16),
	/*3930*/ uint16(xArgRM16),
	/*3931*/ uint16(xMatch),
	/*3932*/ uint16(xSetOp), uint16(CMOVG),
	/*3934*/ uint16(xReadSlashR),
	/*3935*/ uint16(xArgR32),
	/*3936*/ uint16(xArgRM32),
	/*3937*/ uint16(xMatch),
	/*3938*/ uint16(xCondDataSize), 3926, 3932, 3942,
	/*3942*/ uint16(xSetOp), uint16(CMOVG),
	/*3944*/ uint16(xReadSlashR),
	/*3945*/ uint16(xArgR64),
	/*3946*/ uint16(xArgRM64),
	/*3947*/ uint16(xMatch),
	/*3948*/ uint16(xCondPrefix), 2,
	0x66, 3960,
	0x0, 3954,
	/*3954*/ uint16(xSetOp), uint16(MOVMSKPS),
	/*3956*/ uint16(xReadSlashR),
	/*3957*/ uint16(xArgR32),
	/*3958*/ uint16(xArgXmm2),
	/*3959*/ uint16(xMatch),
	/*3960*/ uint16(xSetOp), uint16(MOVMSKPD),
	/*3962*/ uint16(xReadSlashR),
	/*3963*/ uint16(xArgR32),
	/*3964*/ uint16(xArgXmm2),
	/*3965*/ uint16(xMatch),
	/*3966*/ uint16(xCondPrefix), 4,
	0xF3, 3994,
	0xF2, 3988,
	0x66, 3982,
	0x0, 3976,
	/*3976*/ uint16(xSetOp), uint16(SQRTPS),
	/*3978*/ uint16(xReadSlashR),
	/*3979*/ uint16(xArgXmm1),
	/*3980*/ uint16(xArgXmm2M128),
	/*3981*/ uint16(xMatch),
	/*3982*/ uint16(xSetOp), uint16(SQRTPD),
	/*3984*/ uint16(xReadSlashR),
	/*3985*/ uint16(xArgXmm1),
	/*3986*/ uint16(xArgXmm2M128),
	/*3987*/ uint16(xMatch),
	/*3988*/ uint16(xSetOp), uint16(SQRTSD),
	/*3990*/ uint16(xReadSlashR),
	/*3991*/ uint16(xArgXmm1),
	/*3992*/ uint16(xArgXmm2M64),
	/*3993*/ uint16(xMatch),
	/*3994*/ uint16(xSetOp), uint16(SQRTSS),
	/*3996*/ uint16(xReadSlashR),
	/*3997*/ uint16(xArgXmm1),
	/*3998*/ uint16(xArgXmm2M32),
	/*3999*/ uint16(xMatch),
	/*4000*/ uint16(xCondPrefix), 2,
	0xF3, 4012,
	0x0, 4006,
	/*4006*/ uint16(xSetOp), uint16(RSQRTPS),
	/*4008*/ uint16(xReadSlashR),
	/*4009*/ uint16(xArgXmm1),
	/*4010*/ uint16(xArgXmm2M128),
	/*4011*/ uint16(xMatch),
	/*4012*/ uint16(xSetOp), uint16(RSQRTSS),
	/*4014*/ uint16(xReadSlashR),
	/*4015*/ uint16(xArgXmm1),
	/*4016*/ uint16(xArgXmm2M32),
	/*4017*/ uint16(xMatch),
	/*4018*/ uint16(xCondPrefix), 2,
	0xF3, 4030,
	0x0, 4024,
	/*4024*/ uint16(xSetOp), uint16(RCPPS),
	/*4026*/ uint16(xReadSlashR),
	/*4027*/ uint16(xArgXmm1),
	/*4028*/ uint16(xArgXmm2M128),
	/*4029*/ uint16(xMatch),
	/*4030*/ uint16(xSetOp), uint16(RCPSS),
	/*4032*/ uint16(xReadSlashR),
	/*4033*/ uint16(xArgXmm1),
	/*4034*/ uint16(xArgXmm2M32),
	/*4035*/ uint16(xMatch),
	/*4036*/ uint16(xCondPrefix), 2,
	0x66, 4048,
	0x0, 4042,
	/*4042*/ uint16(xSetOp), uint16(ANDPS),
	/*4044*/ uint16(xReadSlashR),
	/*4045*/ uint16(xArgXmm1),
	/*4046*/ uint16(xArgXmm2M128),
	/*4047*/ uint16(xMatch),
	/*4048*/ uint16(xSetOp), uint16(ANDPD),
	/*4050*/ uint16(xReadSlashR),
	/*4051*/ uint16(xArgXmm1),
	/*4052*/ uint16(xArgXmm2M128),
	/*4053*/ uint16(xMatch),
	/*4054*/ uint16(xCondPrefix), 2,
	0x66, 4066,
	0x0, 4060,
	/*4060*/ uint16(xSetOp), uint16(ANDNPS),
	/*4062*/ uint16(xReadSlashR),
	/*4063*/ uint16(xArgXmm1),
	/*4064*/ uint16(xArgXmm2M128),
	/*4065*/ uint16(xMatch),
	/*4066*/ uint16(xSetOp), uint16(ANDNPD),
	/*4068*/ uint16(xReadSlashR),
	/*4069*/ uint16(xArgXmm1),
	/*4070*/ uint16(xArgXmm2M128),
	/*4071*/ uint16(xMatch),
	/*4072*/ uint16(xCondPrefix), 2,
	0x66, 4084,
	0x0, 4078,
	/*4078*/ uint16(xSetOp), uint16(ORPS),
	/*4080*/ uint16(xReadSlashR),
	/*4081*/ uint16(xArgXmm1),
	/*4082*/ uint16(xArgXmm2M128),
	/*4083*/ uint16(xMatch),
	/*4084*/ uint16(xSetOp), uint16(ORPD),
	/*4086*/ uint16(xReadSlashR),
	/*4087*/ uint16(xArgXmm1),
	/*4088*/ uint16(xArgXmm2M128),
	/*4089*/ uint16(xMatch),
	/*4090*/ uint16(xCondPrefix), 2,
	0x66, 4102,
	0x0, 4096,
	/*4096*/ uint16(xSetOp), uint16(XORPS),
	/*4098*/ uint16(xReadSlashR),
	/*4099*/ uint16(xArgXmm1),
	/*4100*/ uint16(xArgXmm2M128),
	/*4101*/ uint16(xMatch),
	/*4102*/ uint16(xSetOp), uint16(XORPD),
	/*4104*/ uint16(xReadSlashR),
	/*4105*/ uint16(xArgXmm1),
	/*4106*/ uint16(xArgXmm2M128),
	/*4107*/ uint16(xMatch),
	/*4108*/ uint16(xCondPrefix), 4,
	0xF3, 4136,
	0xF2, 4130,
	0x66, 4124,
	0x0, 4118,
	/*4118*/ uint16(xSetOp), uint16(ADDPS),
	/*4120*/ uint16(xReadSlashR),
	/*4121*/ uint16(xArgXmm1),
	/*4122*/ uint16(xArgXmm2M128),
	/*4123*/ uint16(xMatch),
	/*4124*/ uint16(xSetOp), uint16(ADDPD),
	/*4126*/ uint16(xReadSlashR),
	/*4127*/ uint16(xArgXmm1),
	/*4128*/ uint16(xArgXmm2M128),
	/*4129*/ uint16(xMatch),
	/*4130*/ uint16(xSetOp), uint16(ADDSD),
	/*4132*/ uint16(xReadSlashR),
	/*4133*/ uint16(xArgXmm1),
	/*4134*/ uint16(xArgXmm2M64),
	/*4135*/ uint16(xMatch),
	/*4136*/ uint16(xSetOp), uint16(ADDSS),
	/*4138*/ uint16(xReadSlashR),
	/*4139*/ uint16(xArgXmm1),
	/*4140*/ uint16(xArgXmm2M32),
	/*4141*/ uint16(xMatch),
	/*4142*/ uint16(xCondPrefix), 4,
	0xF3, 4170,
	0xF2, 4164,
	0x66, 4158,
	0x0, 4152,
	/*4152*/ uint16(xSetOp), uint16(MULPS),
	/*4154*/ uint16(xReadSlashR),
	/*4155*/ uint16(xArgXmm1),
	/*4156*/ uint16(xArgXmm2M128),
	/*4157*/ uint16(xMatch),
	/*4158*/ uint16(xSetOp), uint16(MULPD),
	/*4160*/ uint16(xReadSlashR),
	/*4161*/ uint16(xArgXmm1),
	/*4162*/ uint16(xArgXmm2M128),
	/*4163*/ uint16(xMatch),
	/*4164*/ uint16(xSetOp), uint16(MULSD),
	/*4166*/ uint16(xReadSlashR),
	/*4167*/ uint16(xArgXmm1),
	/*4168*/ uint16(xArgXmm2M64),
	/*4169*/ uint16(xMatch),
	/*4170*/ uint16(xSetOp), uint16(MULSS),
	/*4172*/ uint16(xReadSlashR),
	/*4173*/ uint16(xArgXmm1),
	/*4174*/ uint16(xArgXmm2M32),
	/*4175*/ uint16(xMatch),
	/*4176*/ uint16(xCondPrefix), 4,
	0xF3, 4204,
	0xF2, 4198,
	0x66, 4192,
	0x0, 4186,
	/*4186*/ uint16(xSetOp), uint16(CVTPS2PD),
	/*4188*/ uint16(xReadSlashR),
	/*4189*/ uint16(xArgXmm1),
	/*4190*/ uint16(xArgXmm2M64),
	/*4191*/ uint16(xMatch),
	/*4192*/ uint16(xSetOp), uint16(CVTPD2PS),
	/*4194*/ uint16(xReadSlashR),
	/*4195*/ uint16(xArgXmm1),
	/*4196*/ uint16(xArgXmm2M128),
	/*4197*/ uint16(xMatch),
	/*4198*/ uint16(xSetOp), uint16(CVTSD2SS),
	/*4200*/ uint16(xReadSlashR),
	/*4201*/ uint16(xArgXmm1),
	/*4202*/ uint16(xArgXmm2M64),
	/*4203*/ uint16(xMatch),
	/*4204*/ uint16(xSetOp), uint16(CVTSS2SD),
	/*4206*/ uint16(xReadSlashR),
	/*4207*/ uint16(xArgXmm1),
	/*4208*/ uint16(xArgXmm2M32),
	/*4209*/ uint16(xMatch),
	/*4210*/ uint16(xCondPrefix), 3,
	0xF3, 4230,
	0x66, 4224,
	0x0, 4218,
	/*4218*/ uint16(xSetOp), uint16(CVTDQ2PS),
	/*4220*/ uint16(xReadSlashR),
	/*4221*/ uint16(xArgXmm1),
	/*4222*/ uint16(xArgXmm2M128),
	/*4223*/ uint16(xMatch),
	/*4224*/ uint16(xSetOp), uint16(CVTPS2DQ),
	/*4226*/ uint16(xReadSlashR),
	/*4227*/ uint16(xArgXmm1),
	/*4228*/ uint16(xArgXmm2M128),
	/*4229*/ uint16(xMatch),
	/*4230*/ uint16(xSetOp), uint16(CVTTPS2DQ),
	/*4232*/ uint16(xReadSlashR),
	/*4233*/ uint16(xArgXmm1),
	/*4234*/ uint16(xArgXmm2M128),
	/*4235*/ uint16(xMatch),
	/*4236*/ uint16(xCondPrefix), 4,
	0xF3, 4264,
	0xF2, 4258,
	0x66, 4252,
	0x0, 4246,
	/*4246*/ uint16(xSetOp), uint16(SUBPS),
	/*4248*/ uint16(xReadSlashR),
	/*4249*/ uint16(xArgXmm1),
	/*4250*/ uint16(xArgXmm2M128),
	/*4251*/ uint16(xMatch),
	/*4252*/ uint16(xSetOp), uint16(SUBPD),
	/*4254*/ uint16(xReadSlashR),
	/*4255*/ uint16(xArgXmm1),
	/*4256*/ uint16(xArgXmm2M128),
	/*4257*/ uint16(xMatch),
	/*4258*/ uint16(xSetOp), uint16(SUBSD),
	/*4260*/ uint16(xReadSlashR),
	/*4261*/ uint16(xArgXmm1),
	/*4262*/ uint16(xArgXmm2M64),
	/*4263*/ uint16(xMatch),
	/*4264*/ uint16(xSetOp), uint16(SUBSS),
	/*4266*/ uint16(xReadSlashR),
	/*4267*/ uint16(xArgXmm1),
	/*4268*/ uint16(xArgXmm2M32),
	/*4269*/ uint16(xMatch),
	/*4270*/ uint16(xCondPrefix), 4,
	0xF3, 4298,
	0xF2, 4292,
	0x66, 4286,
	0x0, 4280,
	/*4280*/ uint16(xSetOp), uint16(MINPS),
	/*4282*/ uint16(xReadSlashR),
	/*4283*/ uint16(xArgXmm1),
	/*4284*/ uint16(xArgXmm2M128),
	/*4285*/ uint16(xMatch),
	/*4286*/ uint16(xSetOp), uint16(MINPD),
	/*4288*/ uint16(xReadSlashR),
	/*4289*/ uint16(xArgXmm1),
	/*4290*/ uint16(xArgXmm2M128),
	/*4291*/ uint16(xMatch),
	/*4292*/ uint16(xSetOp), uint16(MINSD),
	/*4294*/ uint16(xReadSlashR),
	/*4295*/ uint16(xArgXmm1),
	/*4296*/ uint16(xArgXmm2M64),
	/*4297*/ uint16(xMatch),
	/*4298*/ uint16(xSetOp), uint16(MINSS),
	/*4300*/ uint16(xReadSlashR),
	/*4301*/ uint16(xArgXmm1),
	/*4302*/ uint16(xArgXmm2M32),
	/*4303*/ uint16(xMatch),
	/*4304*/ uint16(xCondPrefix), 4,
	0xF3, 4332,
	0xF2, 4326,
	0x66, 4320,
	0x0, 4314,
	/*4314*/ uint16(xSetOp), uint16(DIVPS),
	/*4316*/ uint16(xReadSlashR),
	/*4317*/ uint16(xArgXmm1),
	/*4318*/ uint16(xArgXmm2M128),
	/*4319*/ uint16(xMatch),
	/*4320*/ uint16(xSetOp), uint16(DIVPD),
	/*4322*/ uint16(xReadSlashR),
	/*4323*/ uint16(xArgXmm1),
	/*4324*/ uint16(xArgXmm2M128),
	/*4325*/ uint16(xMatch),
	/*4326*/ uint16(xSetOp), uint16(DIVSD),
	/*4328*/ uint16(xReadSlashR),
	/*4329*/ uint16(xArgXmm1),
	/*4330*/ uint16(xArgXmm2M64),
	/*4331*/ uint16(xMatch),
	/*4332*/ uint16(xSetOp), uint16(DIVSS),
	/*4334*/ uint16(xReadSlashR),
	/*4335*/ uint16(xArgXmm1),
	/*4336*/ uint16(xArgXmm2M32),
	/*4337*/ uint16(xMatch),
	/*4338*/ uint16(xCondPrefix), 4,
	0xF3, 4366,
	0xF2, 4360,
	0x66, 4354,
	0x0, 4348,
	/*4348*/ uint16(xSetOp), uint16(MAXPS),
	/*4350*/ uint16(xReadSlashR),
	/*4351*/ uint16(xArgXmm1),
	/*4352*/ uint16(xArgXmm2M128),
	/*4353*/ uint16(xMatch),
	/*4354*/ uint16(xSetOp), uint16(MAXPD),
	/*4356*/ uint16(xReadSlashR),
	/*4357*/ uint16(xArgXmm1),
	/*4358*/ uint16(xArgXmm2M128),
	/*4359*/ uint16(xMatch),
	/*4360*/ uint16(xSetOp), uint16(MAXSD),
	/*4362*/ uint16(xReadSlashR),
	/*4363*/ uint16(xArgXmm1),
	/*4364*/ uint16(xArgXmm2M64),
	/*4365*/ uint16(xMatch),
	/*4366*/ uint16(xSetOp), uint16(MAXSS),
	/*4368*/ uint16(xReadSlashR),
	/*4369*/ uint16(xArgXmm1),
	/*4370*/ uint16(xArgXmm2M32),
	/*4371*/ uint16(xMatch),
	/*4372*/ uint16(xCondPrefix), 2,
	0x66, 4384,
	0x0, 4378,
	/*4378*/ uint16(xSetOp), uint16(PUNPCKLBW),
	/*4380*/ uint16(xReadSlashR),
	/*4381*/ uint16(xArgMm),
	/*4382*/ uint16(xArgMmM32),
	/*4383*/ uint16(xMatch),
	/*4384*/ uint16(xSetOp), uint16(PUNPCKLBW),
	/*4386*/ uint16(xReadSlashR),
	/*4387*/ uint16(xArgXmm1),
	/*4388*/ uint16(xArgXmm2M128),
	/*4389*/ uint16(xMatch),
	/*4390*/ uint16(xCondPrefix), 2,
	0x66, 4402,
	0x0, 4396,
	/*4396*/ uint16(xSetOp), uint16(PUNPCKLWD),
	/*4398*/ uint16(xReadSlashR),
	/*4399*/ uint16(xArgMm),
	/*4400*/ uint16(xArgMmM32),
	/*4401*/ uint16(xMatch),
	/*4402*/ uint16(xSetOp), uint16(PUNPCKLWD),
	/*4404*/ uint16(xReadSlashR),
	/*4405*/ uint16(xArgXmm1),
	/*4406*/ uint16(xArgXmm2M128),
	/*4407*/ uint16(xMatch),
	/*4408*/ uint16(xCondPrefix), 2,
	0x66, 4420,
	0x0, 4414,
	/*4414*/ uint16(xSetOp), uint16(PUNPCKLDQ),
	/*4416*/ uint16(xReadSlashR),
	/*4417*/ uint16(xArgMm),
	/*4418*/ uint16(xArgMmM32),
	/*4419*/ uint16(xMatch),
	/*4420*/ uint16(xSetOp), uint16(PUNPCKLDQ),
	/*4422*/ uint16(xReadSlashR),
	/*4423*/ uint16(xArgXmm1),
	/*4424*/ uint16(xArgXmm2M128),
	/*4425*/ uint16(xMatch),
	/*4426*/ uint16(xCondPrefix), 2,
	0x66, 4438,
	0x0, 4432,
	/*4432*/ uint16(xSetOp), uint16(PACKSSWB),
	/*4434*/ uint16(xReadSlashR),
	/*4435*/ uint16(xArgMm1),
	/*4436*/ uint16(xArgMm2M64),
	/*4437*/ uint16(xMatch),
	/*4438*/ uint16(xSetOp), uint16(PACKSSWB),
	/*4440*/ uint16(xReadSlashR),
	/*4441*/ uint16(xArgXmm1),
	/*4442*/ uint16(xArgXmm2M128),
	/*4443*/ uint16(xMatch),
	/*4444*/ uint16(xCondPrefix), 2,
	0x66, 4456,
	0x0, 4450,
	/*4450*/ uint16(xSetOp), uint16(PCMPGTB),
	/*4452*/ uint16(xReadSlashR),
	/*4453*/ uint16(xArgMm),
	/*4454*/ uint16(xArgMmM64),
	/*4455*/ uint16(xMatch),
	/*4456*/ uint16(xSetOp), uint16(PCMPGTB),
	/*4458*/ uint16(xReadSlashR),
	/*4459*/ uint16(xArgXmm1),
	/*4460*/ uint16(xArgXmm2M128),
	/*4461*/ uint16(xMatch),
	/*4462*/ uint16(xCondPrefix), 2,
	0x66, 4474,
	0x0, 4468,
	/*4468*/ uint16(xSetOp), uint16(PCMPGTW),
	/*4470*/ uint16(xReadSlashR),
	/*4471*/ uint16(xArgMm),
	/*4472*/ uint16(xArgMmM64),
	/*4473*/ uint16(xMatch),
	/*4474*/ uint16(xSetOp), uint16(PCMPGTW),
	/*4476*/ uint16(xReadSlashR),
	/*4477*/ uint16(xArgXmm1),
	/*4478*/ uint16(xArgXmm2M128),
	/*4479*/ uint16(xMatch),
	/*4480*/ uint16(xCondPrefix), 2,
	0x66, 4492,
	0x0, 4486,
	/*4486*/ uint16(xSetOp), uint16(PCMPGTD),
	/*4488*/ uint16(xReadSlashR),
	/*4489*/ uint16(xArgMm),
	/*4490*/ uint16(xArgMmM64),
	/*4491*/ uint16(xMatch),
	/*4492*/ uint16(xSetOp), uint16(PCMPGTD),
	/*4494*/ uint16(xReadSlashR),
	/*4495*/ uint16(xArgXmm1),
	/*4496*/ uint16(xArgXmm2M128),
	/*4497*/ uint16(xMatch),
	/*4498*/ uint16(xCondPrefix), 2,
	0x66, 4510,
	0x0, 4504,
	/*4504*/ uint16(xSetOp), uint16(PACKUSWB),
	/*4506*/ uint16(xReadSlashR),
	/*4507*/ uint16(xArgMm),
	/*4508*/ uint16(xArgMmM64),
	/*4509*/ uint16(xMatch),
	/*4510*/ uint16(xSetOp), uint16(PACKUSWB),
	/*4512*/ uint16(xReadSlashR),
	/*4513*/ uint16(xArgXmm1),
	/*4514*/ uint16(xArgXmm2M128),
	/*4515*/ uint16(xMatch),
	/*4516*/ uint16(xCondPrefix), 2,
	0x66, 4528,
	0x0, 4522,
	/*4522*/ uint16(xSetOp), uint16(PUNPCKHBW),
	/*4524*/ uint16(xReadSlashR),
	/*4525*/ uint16(xArgMm),
	/*4526*/ uint16(xArgMmM64),
	/*4527*/ uint16(xMatch),
	/*4528*/ uint16(xSetOp), uint16(PUNPCKHBW),
	/*4530*/ uint16(xReadSlashR),
	/*4531*/ uint16(xArgXmm1),
	/*4532*/ uint16(xArgXmm2M128),
	/*4533*/ uint16(xMatch),
	/*4534*/ uint16(xCondPrefix), 2,
	0x66, 4546,
	0x0, 4540,
	/*4540*/ uint16(xSetOp), uint16(PUNPCKHWD),
	/*4542*/ uint16(xReadSlashR),
	/*4543*/ uint16(xArgMm),
	/*4544*/ uint16(xArgMmM64),
	/*4545*/ uint16(xMatch),
	/*4546*/ uint16(xSetOp), uint16(PUNPCKHWD),
	/*4548*/ uint16(xReadSlashR),
	/*4549*/ uint16(xArgXmm1),
	/*4550*/ uint16(xArgXmm2M128),
	/*4551*/ uint16(xMatch),
	/*4552*/ uint16(xCondPrefix), 2,
	0x66, 4564,
	0x0, 4558,
	/*4558*/ uint16(xSetOp), uint16(PUNPCKHDQ),
	/*4560*/ uint16(xReadSlashR),
	/*4561*/ uint16(xArgMm),
	/*4562*/ uint16(xArgMmM64),
	/*4563*/ uint16(xMatch),
	/*4564*/ uint16(xSetOp), uint16(PUNPCKHDQ),
	/*4566*/ uint16(xReadSlashR),
	/*4567*/ uint16(xArgXmm1),
	/*4568*/ uint16(xArgXmm2M128),
	/*4569*/ uint16(xMatch),
	/*4570*/ uint16(xCondPrefix), 2,
	0x66, 4582,
	0x0, 4576,
	/*4576*/ uint16(xSetOp), uint16(PACKSSDW),
	/*4578*/ uint16(xReadSlashR),
	/*4579*/ uint16(xArgMm1),
	/*4580*/ uint16(xArgMm2M64),
	/*4581*/ uint16(xMatch),
	/*4582*/ uint16(xSetOp), uint16(PACKSSDW),
	/*4584*/ uint16(xReadSlashR),
	/*4585*/ uint16(xArgXmm1),
	/*4586*/ uint16(xArgXmm2M128),
	/*4587*/ uint16(xMatch),
	/*4588*/ uint16(xCondPrefix), 1,
	0x66, 4592,
	/*4592*/ uint16(xSetOp), uint16(PUNPCKLQDQ),
	/*4594*/ uint16(xReadSlashR),
	/*4595*/ uint16(xArgXmm1),
	/*4596*/ uint16(xArgXmm2M128),
	/*4597*/ uint16(xMatch),
	/*4598*/ uint16(xCondPrefix), 1,
	0x66, 4602,
	/*4602*/ uint16(xSetOp), uint16(PUNPCKHQDQ),
	/*4604*/ uint16(xReadSlashR),
	/*4605*/ uint16(xArgXmm1),
	/*4606*/ uint16(xArgXmm2M128),
	/*4607*/ uint16(xMatch),
	/*4608*/ uint16(xCondIs64), 4611, 4649,
	/*4611*/ uint16(xCondPrefix), 2,
	0x66, 4633,
	0x0, 4617,
	/*4617*/ uint16(xCondDataSize), 4621, 4627, 0,
	/*4621*/ uint16(xSetOp), uint16(MOVD),
	/*4623*/ uint16(xReadSlashR),
	/*4624*/ uint16(xArgMm),
	/*4625*/ uint16(xArgRM32),
	/*4626*/ uint16(xMatch),
	/*4627*/ uint16(xSetOp), uint16(MOVD),
	/*4629*/ uint16(xReadSlashR),
	/*4630*/ uint16(xArgMm),
	/*4631*/ uint16(xArgRM32),
	/*4632*/ uint16(xMatch),
	/*4633*/ uint16(xCondDataSize), 4637, 4643, 0,
	/*4637*/ uint16(xSetOp), uint16(MOVD),
	/*4639*/ uint16(xReadSlashR),
	/*4640*/ uint16(xArgXmm),
	/*4641*/ uint16(xArgRM32),
	/*4642*/ uint16(xMatch),
	/*4643*/ uint16(xSetOp), uint16(MOVD),
	/*4645*/ uint16(xReadSlashR),
	/*4646*/ uint16(xArgXmm),
	/*4647*/ uint16(xArgRM32),
	/*4648*/ uint16(xMatch),
	/*4649*/ uint16(xCondPrefix), 2,
	0x66, 4665,
	0x0, 4655,
	/*4655*/ uint16(xCondDataSize), 4621, 4627, 4659,
	/*4659*/ uint16(xSetOp), uint16(MOVQ),
	/*4661*/ uint16(xReadSlashR),
	/*4662*/ uint16(xArgMm),
	/*4663*/ uint16(xArgRM64),
	/*4664*/ uint16(xMatch),
	/*4665*/ uint16(xCondDataSize), 4637, 4643, 4669,
	/*4669*/ uint16(xSetOp), uint16(MOVQ),
	/*4671*/ uint16(xReadSlashR),
	/*4672*/ uint16(xArgXmm),
	/*4673*/ uint16(xArgRM64),
	/*4674*/ uint16(xMatch),
	/*4675*/ uint16(xCondPrefix), 3,
	0xF3, 4695,
	0x66, 4689,
	0x0, 4683,
	/*4683*/ uint16(xSetOp), uint16(MOVQ),
	/*4685*/ uint16(xReadSlashR),
	/*4686*/ uint16(xArgMm),
	/*4687*/ uint16(xArgMmM64),
	/*4688*/ uint16(xMatch),
	/*4689*/ uint16(xSetOp), uint16(MOVDQA),
	/*4691*/ uint16(xReadSlashR),
	/*4692*/ uint16(xArgXmm1),
	/*4693*/ uint16(xArgXmm2M128),
	/*4694*/ uint16(xMatch),
	/*4695*/ uint16(xSetOp), uint16(MOVDQU),
	/*4697*/ uint16(xReadSlashR),
	/*4698*/ uint16(xArgXmm1),
	/*4699*/ uint16(xArgXmm2M128),
	/*4700*/ uint16(xMatch),
	/*4701*/ uint16(xCondPrefix), 4,
	0xF3, 4735,
	0xF2, 4727,
	0x66, 4719,
	0x0, 4711,
	/*4711*/ uint16(xSetOp), uint16(PSHUFW),
	/*4713*/ uint16(xReadSlashR),
	/*4714*/ uint16(xReadIb),
	/*4715*/ uint16(xArgMm1),
	/*4716*/ uint16(xArgMm2M64),
	/*4717*/ uint16(xArgImm8u),
	/*4718*/ uint16(xMatch),
	/*4719*/ uint16(xSetOp), uint16(PSHUFD),
	/*4721*/ uint16(xReadSlashR),
	/*4722*/ uint16(xReadIb),
	/*4723*/ uint16(xArgXmm1),
	/*4724*/ uint16(xArgXmm2M128),
	/*4725*/ uint16(xArgImm8u),
	/*4726*/ uint16(xMatch),
	/*4727*/ uint16(xSetOp), uint16(PSHUFLW),
	/*4729*/ uint16(xReadSlashR),
	/*4730*/ uint16(xReadIb),
	/*4731*/ uint16(xArgXmm1),
	/*4732*/ uint16(xArgXmm2M128),
	/*4733*/ uint16(xArgImm8u),
	/*4734*/ uint16(xMatch),
	/*4735*/ uint16(xSetOp), uint16(PSHUFHW),
	/*4737*/ uint16(xReadSlashR),
	/*4738*/ uint16(xReadIb),
	/*4739*/ uint16(xArgXmm1),
	/*4740*/ uint16(xArgXmm2M128),
	/*4741*/ uint16(xArgImm8u),
	/*4742*/ uint16(xMatch),
	/*4743*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	4752, // 2
	0,    // 3
	4770, // 4
	0,    // 5
	4788, // 6
	0,    // 7
	/*4752*/ uint16(xCondPrefix), 2,
	0x66, 4764,
	0x0, 4758,
	/*4758*/ uint16(xSetOp), uint16(PSRLW),
	/*4760*/ uint16(xReadIb),
	/*4761*/ uint16(xArgMm2),
	/*4762*/ uint16(xArgImm8u),
	/*4763*/ uint16(xMatch),
	/*4764*/ uint16(xSetOp), uint16(PSRLW),
	/*4766*/ uint16(xReadIb),
	/*4767*/ uint16(xArgXmm2),
	/*4768*/ uint16(xArgImm8u),
	/*4769*/ uint16(xMatch),
	/*4770*/ uint16(xCondPrefix), 2,
	0x66, 4782,
	0x0, 4776,
	/*4776*/ uint16(xSetOp), uint16(PSRAW),
	/*4778*/ uint16(xReadIb),
	/*4779*/ uint16(xArgMm2),
	/*4780*/ uint16(xArgImm8u),
	/*4781*/ uint16(xMatch),
	/*4782*/ uint16(xSetOp), uint16(PSRAW),
	/*4784*/ uint16(xReadIb),
	/*4785*/ uint16(xArgXmm2),
	/*4786*/ uint16(xArgImm8u),
	/*4787*/ uint16(xMatch),
	/*4788*/ uint16(xCondPrefix), 2,
	0x66, 4800,
	0x0, 4794,
	/*4794*/ uint16(xSetOp), uint16(PSLLW),
	/*4796*/ uint16(xReadIb),
	/*4797*/ uint16(xArgMm2),
	/*4798*/ uint16(xArgImm8u),
	/*4799*/ uint16(xMatch),
	/*4800*/ uint16(xSetOp), uint16(PSLLW),
	/*4802*/ uint16(xReadIb),
	/*4803*/ uint16(xArgXmm2),
	/*4804*/ uint16(xArgImm8u),
	/*4805*/ uint16(xMatch),
	/*4806*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	4815, // 2
	0,    // 3
	4833, // 4
	0,    // 5
	4851, // 6
	0,    // 7
	/*4815*/ uint16(xCondPrefix), 2,
	0x66, 4827,
	0x0, 4821,
	/*4821*/ uint16(xSetOp), uint16(PSRLD),
	/*4823*/ uint16(xReadIb),
	/*4824*/ uint16(xArgMm2),
	/*4825*/ uint16(xArgImm8u),
	/*4826*/ uint16(xMatch),
	/*4827*/ uint16(xSetOp), uint16(PSRLD),
	/*4829*/ uint16(xReadIb),
	/*4830*/ uint16(xArgXmm2),
	/*4831*/ uint16(xArgImm8u),
	/*4832*/ uint16(xMatch),
	/*4833*/ uint16(xCondPrefix), 2,
	0x66, 4845,
	0x0, 4839,
	/*4839*/ uint16(xSetOp), uint16(PSRAD),
	/*4841*/ uint16(xReadIb),
	/*4842*/ uint16(xArgMm2),
	/*4843*/ uint16(xArgImm8u),
	/*4844*/ uint16(xMatch),
	/*4845*/ uint16(xSetOp), uint16(PSRAD),
	/*4847*/ uint16(xReadIb),
	/*4848*/ uint16(xArgXmm2),
	/*4849*/ uint16(xArgImm8u),
	/*4850*/ uint16(xMatch),
	/*4851*/ uint16(xCondPrefix), 2,
	0x66, 4863,
	0x0, 4857,
	/*4857*/ uint16(xSetOp), uint16(PSLLD),
	/*4859*/ uint16(xReadIb),
	/*4860*/ uint16(xArgMm2),
	/*4861*/ uint16(xArgImm8u),
	/*4862*/ uint16(xMatch),
	/*4863*/ uint16(xSetOp), uint16(PSLLD),
	/*4865*/ uint16(xReadIb),
	/*4866*/ uint16(xArgXmm2),
	/*4867*/ uint16(xArgImm8u),
	/*4868*/ uint16(xMatch),
	/*4869*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	4878, // 2
	4896, // 3
	0,    // 4
	0,    // 5
	4906, // 6
	4924, // 7
	/*4878*/ uint16(xCondPrefix), 2,
	0x66, 4890,
	0x0, 4884,
	/*4884*/ uint16(xSetOp), uint16(PSRLQ),
	/*4886*/ uint16(xReadIb),
	/*4887*/ uint16(xArgMm2),
	/*4888*/ uint16(xArgImm8u),
	/*4889*/ uint16(xMatch),
	/*4890*/ uint16(xSetOp), uint16(PSRLQ),
	/*4892*/ uint16(xReadIb),
	/*4893*/ uint16(xArgXmm2),
	/*4894*/ uint16(xArgImm8u),
	/*4895*/ uint16(xMatch),
	/*4896*/ uint16(xCondPrefix), 1,
	0x66, 4900,
	/*4900*/ uint16(xSetOp), uint16(PSRLDQ),
	/*4902*/ uint16(xReadIb),
	/*4903*/ uint16(xArgXmm2),
	/*4904*/ uint16(xArgImm8u),
	/*4905*/ uint16(xMatch),
	/*4906*/ uint16(xCondPrefix), 2,
	0x66, 4918,
	0x0, 4912,
	/*4912*/ uint16(xSetOp), uint16(PSLLQ),
	/*4914*/ uint16(xReadIb),
	/*4915*/ uint16(xArgMm2),
	/*4916*/ uint16(xArgImm8u),
	/*4917*/ uint16(xMatch),
	/*4918*/ uint16(xSetOp), uint16(PSLLQ),
	/*4920*/ uint16(xReadIb),
	/*4921*/ uint16(xArgXmm2),
	/*4922*/ uint16(xArgImm8u),
	/*4923*/ uint16(xMatch),
	/*4924*/ uint16(xCondPrefix), 1,
	0x66, 4928,
	/*4928*/ uint16(xSetOp), uint16(PSLLDQ),
	/*4930*/ uint16(xReadIb),
	/*4931*/ uint16(xArgXmm2),
	/*4932*/ uint16(xArgImm8u),
	/*4933*/ uint16(xMatch),
	/*4934*/ uint16(xCondPrefix), 2,
	0x66, 4946,
	0x0, 4940,
	/*4940*/ uint16(xSetOp), uint16(PCMPEQB),
	/*4942*/ uint16(xReadSlashR),
	/*4943*/ uint16(xArgMm),
	/*4944*/ uint16(xArgMmM64),
	/*4945*/ uint16(xMatch),
	/*4946*/ uint16(xSetOp), uint16(PCMPEQB),
	/*4948*/ uint16(xReadSlashR),
	/*4949*/ uint16(xArgXmm1),
	/*4950*/ uint16(xArgXmm2M128),
	/*4951*/ uint16(xMatch),
	/*4952*/ uint16(xCondPrefix), 2,
	0x66, 4964,
	0x0, 4958,
	/*4958*/ uint16(xSetOp), uint16(PCMPEQW),
	/*4960*/ uint16(xReadSlashR),
	/*4961*/ uint16(xArgMm),
	/*4962*/ uint16(xArgMmM64),
	/*4963*/ uint16(xMatch),
	/*4964*/ uint16(xSetOp), uint16(PCMPEQW),
	/*4966*/ uint16(xReadSlashR),
	/*4967*/ uint16(xArgXmm1),
	/*4968*/ uint16(xArgXmm2M128),
	/*4969*/ uint16(xMatch),
	/*4970*/ uint16(xCondPrefix), 2,
	0x66, 4982,
	0x0, 4976,
	/*4976*/ uint16(xSetOp), uint16(PCMPEQD),
	/*4978*/ uint16(xReadSlashR),
	/*4979*/ uint16(xArgMm),
	/*4980*/ uint16(xArgMmM64),
	/*4981*/ uint16(xMatch),
	/*4982*/ uint16(xSetOp), uint16(PCMPEQD),
	/*4984*/ uint16(xReadSlashR),
	/*4985*/ uint16(xArgXmm1),
	/*4986*/ uint16(xArgXmm2M128),
	/*4987*/ uint16(xMatch),
	/*4988*/ uint16(xSetOp), uint16(EMMS),
	/*4990*/ uint16(xMatch),
	/*4991*/ uint16(xCondPrefix), 2,
	0xF2, 5003,
	0x66, 4997,
	/*4997*/ uint16(xSetOp), uint16(HADDPD),
	/*4999*/ uint16(xReadSlashR),
	/*5000*/ uint16(xArgXmm1),
	/*5001*/ uint16(xArgXmm2M128),
	/*5002*/ uint16(xMatch),
	/*5003*/ uint16(xSetOp), uint16(HADDPS),
	/*5005*/ uint16(xReadSlashR),
	/*5006*/ uint16(xArgXmm1),
	/*5007*/ uint16(xArgXmm2M128),
	/*5008*/ uint16(xMatch),
	/*5009*/ uint16(xCondPrefix), 2,
	0xF2, 5021,
	0x66, 5015,
	/*5015*/ uint16(xSetOp), uint16(HSUBPD),
	/*5017*/ uint16(xReadSlashR),
	/*5018*/ uint16(xArgXmm1),
	/*5019*/ uint16(xArgXmm2M128),
	/*5020*/ uint16(xMatch),
	/*5021*/ uint16(xSetOp), uint16(HSUBPS),
	/*5023*/ uint16(xReadSlashR),
	/*5024*/ uint16(xArgXmm1),
	/*5025*/ uint16(xArgXmm2M128),
	/*5026*/ uint16(xMatch),
	/*5027*/ uint16(xCondIs64), 5030, 5076,
	/*5030*/ uint16(xCondPrefix), 3,
	0xF3, 5070,
	0x66, 5054,
	0x0, 5038,
	/*5038*/ uint16(xCondDataSize), 5042, 5048, 0,
	/*5042*/ uint16(xSetOp), uint16(MOVD),
	/*5044*/ uint16(xReadSlashR),
	/*5045*/ uint16(xArgRM32),
	/*5046*/ uint16(xArgMm),
	/*5047*/ uint16(xMatch),
	/*5048*/ uint16(xSetOp), uint16(MOVD),
	/*5050*/ uint16(xReadSlashR),
	/*5051*/ uint16(xArgRM32),
	/*5052*/ uint16(xArgMm),
	/*5053*/ uint16(xMatch),
	/*5054*/ uint16(xCondDataSize), 5058, 5064, 0,
	/*5058*/ uint16(xSetOp), uint16(MOVD),
	/*5060*/ uint16(xReadSlashR),
	/*5061*/ uint16(xArgRM32),
	/*5062*/ uint16(xArgXmm),
	/*5063*/ uint16(xMatch),
	/*5064*/ uint16(xSetOp), uint16(MOVD),
	/*5066*/ uint16(xReadSlashR),
	/*5067*/ uint16(xArgRM32),
	/*5068*/ uint16(xArgXmm),
	/*5069*/ uint16(xMatch),
	/*5070*/ uint16(xSetOp), uint16(MOVQ),
	/*5072*/ uint16(xReadSlashR),
	/*5073*/ uint16(xArgXmm1),
	/*5074*/ uint16(xArgXmm2M64),
	/*5075*/ uint16(xMatch),
	/*5076*/ uint16(xCondPrefix), 3,
	0xF3, 5070,
	0x66, 5094,
	0x0, 5084,
	/*5084*/ uint16(xCondDataSize), 5042, 5048, 5088,
	/*5088*/ uint16(xSetOp), uint16(MOVQ),
	/*5090*/ uint16(xReadSlashR),
	/*5091*/ uint16(xArgRM64),
	/*5092*/ uint16(xArgMm),
	/*5093*/ uint16(xMatch),
	/*5094*/ uint16(xCondDataSize), 5058, 5064, 5098,
	/*5098*/ uint16(xSetOp), uint16(MOVQ),
	/*5100*/ uint16(xReadSlashR),
	/*5101*/ uint16(xArgRM64),
	/*5102*/ uint16(xArgXmm),
	/*5103*/ uint16(xMatch),
	/*5104*/ uint16(xCondPrefix), 3,
	0xF3, 5124,
	0x66, 5118,
	0x0, 5112,
	/*5112*/ uint16(xSetOp), uint16(MOVQ),
	/*5114*/ uint16(xReadSlashR),
	/*5115*/ uint16(xArgMmM64),
	/*5116*/ uint16(xArgMm),
	/*5117*/ uint16(xMatch),
	/*5118*/ uint16(xSetOp), uint16(MOVDQA),
	/*5120*/ uint16(xReadSlashR),
	/*5121*/ uint16(xArgXmm2M128),
	/*5122*/ uint16(xArgXmm1),
	/*5123*/ uint16(xMatch),
	/*5124*/ uint16(xSetOp), uint16(MOVDQU),
	/*5126*/ uint16(xReadSlashR),
	/*5127*/ uint16(xArgXmm2M128),
	/*5128*/ uint16(xArgXmm1),
	/*5129*/ uint16(xMatch),
	/*5130*/ uint16(xCondIs64), 5133, 5147,
	/*5133*/ uint16(xCondDataSize), 5137, 5142, 0,
	/*5137*/ uint16(xSetOp), uint16(JO),
	/*5139*/ uint16(xReadCw),
	/*5140*/ uint16(xArgRel16),
	/*5141*/ uint16(xMatch),
	/*5142*/ uint16(xSetOp), uint16(JO),
	/*5144*/ uint16(xReadCd),
	/*5145*/ uint16(xArgRel32),
	/*5146*/ uint16(xMatch),
	/*5147*/ uint16(xCondDataSize), 5151, 5142, 5156,
	/*5151*/ uint16(xSetOp), uint16(JO),
	/*5153*/ uint16(xReadCd),
	/*5154*/ uint16(xArgRel32),
	/*5155*/ uint16(xMatch),
	/*5156*/ uint16(xSetOp), uint16(JO),
	/*5158*/ uint16(xReadCd),
	/*5159*/ uint16(xArgRel32),
	/*5160*/ uint16(xMatch),
	/*5161*/ uint16(xCondIs64), 5164, 5178,
	/*5164*/ uint16(xCondDataSize), 5168, 5173, 0,
	/*5168*/ uint16(xSetOp), uint16(JNO),
	/*5170*/ uint16(xReadCw),
	/*5171*/ uint16(xArgRel16),
	/*5172*/ uint16(xMatch),
	/*5173*/ uint16(xSetOp), uint16(JNO),
	/*5175*/ uint16(xReadCd),
	/*5176*/ uint16(xArgRel32),
	/*5177*/ uint16(xMatch),
	/*5178*/ uint16(xCondDataSize), 5182, 5173, 5187,
	/*5182*/ uint16(xSetOp), uint16(JNO),
	/*5184*/ uint16(xReadCd),
	/*5185*/ uint16(xArgRel32),
	/*5186*/ uint16(xMatch),
	/*5187*/ uint16(xSetOp), uint16(JNO),
	/*5189*/ uint16(xReadCd),
	/*5190*/ uint16(xArgRel32),
	/*5191*/ uint16(xMatch),
	/*5192*/ uint16(xCondIs64), 5195, 5209,
	/*5195*/ uint16(xCondDataSize), 5199, 5204, 0,
	/*5199*/ uint16(xSetOp), uint16(JB),
	/*5201*/ uint16(xReadCw),
	/*5202*/ uint16(xArgRel16),
	/*5203*/ uint16(xMatch),
	/*5204*/ uint16(xSetOp), uint16(JB),
	/*5206*/ uint16(xReadCd),
	/*5207*/ uint16(xArgRel32),
	/*5208*/ uint16(xMatch),
	/*5209*/ uint16(xCondDataSize), 5213, 5204, 5218,
	/*5213*/ uint16(xSetOp), uint16(JB),
	/*5215*/ uint16(xReadCd),
	/*5216*/ uint16(xArgRel32),
	/*5217*/ uint16(xMatch),
	/*5218*/ uint16(xSetOp), uint16(JB),
	/*5220*/ uint16(xReadCd),
	/*5221*/ uint16(xArgRel32),
	/*5222*/ uint16(xMatch),
	/*5223*/ uint16(xCondIs64), 5226, 5240,
	/*5226*/ uint16(xCondDataSize), 5230, 5235, 0,
	/*5230*/ uint16(xSetOp), uint16(JAE),
	/*5232*/ uint16(xReadCw),
	/*5233*/ uint16(xArgRel16),
	/*5234*/ uint16(xMatch),
	/*5235*/ uint16(xSetOp), uint16(JAE),
	/*5237*/ uint16(xReadCd),
	/*5238*/ uint16(xArgRel32),
	/*5239*/ uint16(xMatch),
	/*5240*/ uint16(xCondDataSize), 5244, 5235, 5249,
	/*5244*/ uint16(xSetOp), uint16(JAE),
	/*5246*/ uint16(xReadCd),
	/*5247*/ uint16(xArgRel32),
	/*5248*/ uint16(xMatch),
	/*5249*/ uint16(xSetOp), uint16(JAE),
	/*5251*/ uint16(xReadCd),
	/*5252*/ uint16(xArgRel32),
	/*5253*/ uint16(xMatch),
	/*5254*/ uint16(xCondIs64), 5257, 5271,
	/*5257*/ uint16(xCondDataSize), 5261, 5266, 0,
	/*5261*/ uint16(xSetOp), uint16(JE),
	/*5263*/ uint16(xReadCw),
	/*5264*/ uint16(xArgRel16),
	/*5265*/ uint16(xMatch),
	/*5266*/ uint16(xSetOp), uint16(JE),
	/*5268*/ uint16(xReadCd),
	/*5269*/ uint16(xArgRel32),
	/*5270*/ uint16(xMatch),
	/*5271*/ uint16(xCondDataSize), 5275, 5266, 5280,
	/*5275*/ uint16(xSetOp), uint16(JE),
	/*5277*/ uint16(xReadCd),
	/*5278*/ uint16(xArgRel32),
	/*5279*/ uint16(xMatch),
	/*5280*/ uint16(xSetOp), uint16(JE),
	/*5282*/ uint16(xReadCd),
	/*5283*/ uint16(xArgRel32),
	/*5284*/ uint16(xMatch),
	/*5285*/ uint16(xCondIs64), 5288, 5302,
	/*5288*/ uint16(xCondDataSize), 5292, 5297, 0,
	/*5292*/ uint16(xSetOp), uint16(JNE),
	/*5294*/ uint16(xReadCw),
	/*5295*/ uint16(xArgRel16),
	/*5296*/ uint16(xMatch),
	/*5297*/ uint16(xSetOp), uint16(JNE),
	/*5299*/ uint16(xReadCd),
	/*5300*/ uint16(xArgRel32),
	/*5301*/ uint16(xMatch),
	/*5302*/ uint16(xCondDataSize), 5306, 5297, 5311,
	/*5306*/ uint16(xSetOp), uint16(JNE),
	/*5308*/ uint16(xReadCd),
	/*5309*/ uint16(xArgRel32),
	/*5310*/ uint16(xMatch),
	/*5311*/ uint16(xSetOp), uint16(JNE),
	/*5313*/ uint16(xReadCd),
	/*5314*/ uint16(xArgRel32),
	/*5315*/ uint16(xMatch),
	/*5316*/ uint16(xCondIs64), 5319, 5333,
	/*5319*/ uint16(xCondDataSize), 5323, 5328, 0,
	/*5323*/ uint16(xSetOp), uint16(JBE),
	/*5325*/ uint16(xReadCw),
	/*5326*/ uint16(xArgRel16),
	/*5327*/ uint16(xMatch),
	/*5328*/ uint16(xSetOp), uint16(JBE),
	/*5330*/ uint16(xReadCd),
	/*5331*/ uint16(xArgRel32),
	/*5332*/ uint16(xMatch),
	/*5333*/ uint16(xCondDataSize), 5337, 5328, 5342,
	/*5337*/ uint16(xSetOp), uint16(JBE),
	/*5339*/ uint16(xReadCd),
	/*5340*/ uint16(xArgRel32),
	/*5341*/ uint16(xMatch),
	/*5342*/ uint16(xSetOp), uint16(JBE),
	/*5344*/ uint16(xReadCd),
	/*5345*/ uint16(xArgRel32),
	/*5346*/ uint16(xMatch),
	/*5347*/ uint16(xCondIs64), 5350, 5364,
	/*5350*/ uint16(xCondDataSize), 5354, 5359, 0,
	/*5354*/ uint16(xSetOp), uint16(JA),
	/*5356*/ uint16(xReadCw),
	/*5357*/ uint16(xArgRel16),
	/*5358*/ uint16(xMatch),
	/*5359*/ uint16(xSetOp), uint16(JA),
	/*5361*/ uint16(xReadCd),
	/*5362*/ uint16(xArgRel32),
	/*5363*/ uint16(xMatch),
	/*5364*/ uint16(xCondDataSize), 5368, 5359, 5373,
	/*5368*/ uint16(xSetOp), uint16(JA),
	/*5370*/ uint16(xReadCd),
	/*5371*/ uint16(xArgRel32),
	/*5372*/ uint16(xMatch),
	/*5373*/ uint16(xSetOp), uint16(JA),
	/*5375*/ uint16(xReadCd),
	/*5376*/ uint16(xArgRel32),
	/*5377*/ uint16(xMatch),
	/*5378*/ uint16(xCondIs64), 5381, 5395,
	/*5381*/ uint16(xCondDataSize), 5385, 5390, 0,
	/*5385*/ uint16(xSetOp), uint16(JS),
	/*5387*/ uint16(xReadCw),
	/*5388*/ uint16(xArgRel16),
	/*5389*/ uint16(xMatch),
	/*5390*/ uint16(xSetOp), uint16(JS),
	/*5392*/ uint16(xReadCd),
	/*5393*/ uint16(xArgRel32),
	/*5394*/ uint16(xMatch),
	/*5395*/ uint16(xCondDataSize), 5399, 5390, 5404,
	/*5399*/ uint16(xSetOp), uint16(JS),
	/*5401*/ uint16(xReadCd),
	/*5402*/ uint16(xArgRel32),
	/*5403*/ uint16(xMatch),
	/*5404*/ uint16(xSetOp), uint16(JS),
	/*5406*/ uint16(xReadCd),
	/*5407*/ uint16(xArgRel32),
	/*5408*/ uint16(xMatch),
	/*5409*/ uint16(xCondIs64), 5412, 5426,
	/*5412*/ uint16(xCondDataSize), 5416, 5421, 0,
	/*5416*/ uint16(xSetOp), uint16(JNS),
	/*5418*/ uint16(xReadCw),
	/*5419*/ uint16(xArgRel16),
	/*5420*/ uint16(xMatch),
	/*5421*/ uint16(xSetOp), uint16(JNS),
	/*5423*/ uint16(xReadCd),
	/*5424*/ uint16(xArgRel32),
	/*5425*/ uint16(xMatch),
	/*5426*/ uint16(xCondDataSize), 5430, 5421, 5435,
	/*5430*/ uint16(xSetOp), uint16(JNS),
	/*5432*/ uint16(xReadCd),
	/*5433*/ uint16(xArgRel32),
	/*5434*/ uint16(xMatch),
	/*5435*/ uint16(xSetOp), uint16(JNS),
	/*5437*/ uint16(xReadCd),
	/*5438*/ uint16(xArgRel32),
	/*5439*/ uint16(xMatch),
	/*5440*/ uint16(xCondIs64), 5443, 5457,
	/*5443*/ uint16(xCondDataSize), 5447, 5452, 0,
	/*5447*/ uint16(xSetOp), uint16(JP),
	/*5449*/ uint16(xReadCw),
	/*5450*/ uint16(xArgRel16),
	/*5451*/ uint16(xMatch),
	/*5452*/ uint16(xSetOp), uint16(JP),
	/*5454*/ uint16(xReadCd),
	/*5455*/ uint16(xArgRel32),
	/*5456*/ uint16(xMatch),
	/*5457*/ uint16(xCondDataSize), 5461, 5452, 5466,
	/*5461*/ uint16(xSetOp), uint16(JP),
	/*5463*/ uint16(xReadCd),
	/*5464*/ uint16(xArgRel32),
	/*5465*/ uint16(xMatch),
	/*5466*/ uint16(xSetOp), uint16(JP),
	/*5468*/ uint16(xReadCd),
	/*5469*/ uint16(xArgRel32),
	/*5470*/ uint16(xMatch),
	/*5471*/ uint16(xCondIs64), 5474, 5488,
	/*5474*/ uint16(xCondDataSize), 5478, 5483, 0,
	/*5478*/ uint16(xSetOp), uint16(JNP),
	/*5480*/ uint16(xReadCw),
	/*5481*/ uint16(xArgRel16),
	/*5482*/ uint16(xMatch),
	/*5483*/ uint16(xSetOp), uint16(JNP),
	/*5485*/ uint16(xReadCd),
	/*5486*/ uint16(xArgRel32),
	/*5487*/ uint16(xMatch),
	/*5488*/ uint16(xCondDataSize), 5492, 5483, 5497,
	/*5492*/ uint16(xSetOp), uint16(JNP),
	/*5494*/ uint16(xReadCd),
	/*5495*/ uint16(xArgRel32),
	/*5496*/ uint16(xMatch),
	/*5497*/ uint16(xSetOp), uint16(JNP),
	/*5499*/ uint16(xReadCd),
	/*5500*/ uint16(xArgRel32),
	/*5501*/ uint16(xMatch),
	/*5502*/ uint16(xCondIs64), 5505, 5519,
	/*5505*/ uint16(xCondDataSize), 5509, 5514, 0,
	/*5509*/ uint16(xSetOp), uint16(JL),
	/*5511*/ uint16(xReadCw),
	/*5512*/ uint16(xArgRel16),
	/*5513*/ uint16(xMatch),
	/*5514*/ uint16(xSetOp), uint16(JL),
	/*5516*/ uint16(xReadCd),
	/*5517*/ uint16(xArgRel32),
	/*5518*/ uint16(xMatch),
	/*5519*/ uint16(xCondDataSize), 5523, 5514, 5528,
	/*5523*/ uint16(xSetOp), uint16(JL),
	/*5525*/ uint16(xReadCd),
	/*5526*/ uint16(xArgRel32),
	/*5527*/ uint16(xMatch),
	/*5528*/ uint16(xSetOp), uint16(JL),
	/*5530*/ uint16(xReadCd),
	/*5531*/ uint16(xArgRel32),
	/*5532*/ uint16(xMatch),
	/*5533*/ uint16(xCondIs64), 5536, 5550,
	/*5536*/ uint16(xCondDataSize), 5540, 5545, 0,
	/*5540*/ uint16(xSetOp), uint16(JGE),
	/*5542*/ uint16(xReadCw),
	/*5543*/ uint16(xArgRel16),
	/*5544*/ uint16(xMatch),
	/*5545*/ uint16(xSetOp), uint16(JGE),
	/*5547*/ uint16(xReadCd),
	/*5548*/ uint16(xArgRel32),
	/*5549*/ uint16(xMatch),
	/*5550*/ uint16(xCondDataSize), 5554, 5545, 5559,
	/*5554*/ uint16(xSetOp), uint16(JGE),
	/*5556*/ uint16(xReadCd),
	/*5557*/ uint16(xArgRel32),
	/*5558*/ uint16(xMatch),
	/*5559*/ uint16(xSetOp), uint16(JGE),
	/*5561*/ uint16(xReadCd),
	/*5562*/ uint16(xArgRel32),
	/*5563*/ uint16(xMatch),
	/*5564*/ uint16(xCondIs64), 5567, 5581,
	/*5567*/ uint16(xCondDataSize), 5571, 5576, 0,
	/*5571*/ uint16(xSetOp), uint16(JLE),
	/*5573*/ uint16(xReadCw),
	/*5574*/ uint16(xArgRel16),
	/*5575*/ uint16(xMatch),
	/*5576*/ uint16(xSetOp), uint16(JLE),
	/*5578*/ uint16(xReadCd),
	/*5579*/ uint16(xArgRel32),
	/*5580*/ uint16(xMatch),
	/*5581*/ uint16(xCondDataSize), 5585, 5576, 5590,
	/*5585*/ uint16(xSetOp), uint16(JLE),
	/*5587*/ uint16(xReadCd),
	/*5588*/ uint16(xArgRel32),
	/*5589*/ uint16(xMatch),
	/*5590*/ uint16(xSetOp), uint16(JLE),
	/*5592*/ uint16(xReadCd),
	/*5593*/ uint16(xArgRel32),
	/*5594*/ uint16(xMatch),
	/*5595*/ uint16(xCondIs64), 5598, 5612,
	/*5598*/ uint16(xCondDataSize), 5602, 5607, 0,
	/*5602*/ uint16(xSetOp), uint16(JG),
	/*5604*/ uint16(xReadCw),
	/*5605*/ uint16(xArgRel16),
	/*5606*/ uint16(xMatch),
	/*5607*/ uint16(xSetOp), uint16(JG),
	/*5609*/ uint16(xReadCd),
	/*5610*/ uint16(xArgRel32),
	/*5611*/ uint16(xMatch),
	/*5612*/ uint16(xCondDataSize), 5616, 5607, 5621,
	/*5616*/ uint16(xSetOp), uint16(JG),
	/*5618*/ uint16(xReadCd),
	/*5619*/ uint16(xArgRel32),
	/*5620*/ uint16(xMatch),
	/*5621*/ uint16(xSetOp), uint16(JG),
	/*5623*/ uint16(xReadCd),
	/*5624*/ uint16(xArgRel32),
	/*5625*/ uint16(xMatch),
	/*5626*/ uint16(xSetOp), uint16(SETO),
	/*5628*/ uint16(xReadSlashR),
	/*5629*/ uint16(xArgRM8),
	/*5630*/ uint16(xMatch),
	/*5631*/ uint16(xSetOp), uint16(SETNO),
	/*5633*/ uint16(xReadSlashR),
	/*5634*/ uint16(xArgRM8),
	/*5635*/ uint16(xMatch),
	/*5636*/ uint16(xSetOp), uint16(SETB),
	/*5638*/ uint16(xReadSlashR),
	/*5639*/ uint16(xArgRM8),
	/*5640*/ uint16(xMatch),
	/*5641*/ uint16(xSetOp), uint16(SETAE),
	/*5643*/ uint16(xReadSlashR),
	/*5644*/ uint16(xArgRM8),
	/*5645*/ uint16(xMatch),
	/*5646*/ uint16(xSetOp), uint16(SETE),
	/*5648*/ uint16(xReadSlashR),
	/*5649*/ uint16(xArgRM8),
	/*5650*/ uint16(xMatch),
	/*5651*/ uint16(xSetOp), uint16(SETNE),
	/*5653*/ uint16(xReadSlashR),
	/*5654*/ uint16(xArgRM8),
	/*5655*/ uint16(xMatch),
	/*5656*/ uint16(xSetOp), uint16(SETBE),
	/*5658*/ uint16(xReadSlashR),
	/*5659*/ uint16(xArgRM8),
	/*5660*/ uint16(xMatch),
	/*5661*/ uint16(xSetOp), uint16(SETA),
	/*5663*/ uint16(xReadSlashR),
	/*5664*/ uint16(xArgRM8),
	/*5665*/ uint16(xMatch),
	/*5666*/ uint16(xSetOp), uint16(SETS),
	/*5668*/ uint16(xReadSlashR),
	/*5669*/ uint16(xArgRM8),
	/*5670*/ uint16(xMatch),
	/*5671*/ uint16(xSetOp), uint16(SETNS),
	/*5673*/ uint16(xReadSlashR),
	/*5674*/ uint16(xArgRM8),
	/*5675*/ uint16(xMatch),
	/*5676*/ uint16(xSetOp), uint16(SETP),
	/*5678*/ uint16(xReadSlashR),
	/*5679*/ uint16(xArgRM8),
	/*5680*/ uint16(xMatch),
	/*5681*/ uint16(xSetOp), uint16(SETNP),
	/*5683*/ uint16(xReadSlashR),
	/*5684*/ uint16(xArgRM8),
	/*5685*/ uint16(xMatch),
	/*5686*/ uint16(xSetOp), uint16(SETL),
	/*5688*/ uint16(xReadSlashR),
	/*5689*/ uint16(xArgRM8),
	/*5690*/ uint16(xMatch),
	/*5691*/ uint16(xSetOp), uint16(SETGE),
	/*5693*/ uint16(xReadSlashR),
	/*5694*/ uint16(xArgRM8),
	/*5695*/ uint16(xMatch),
	/*5696*/ uint16(xSetOp), uint16(SETLE),
	/*5698*/ uint16(xReadSlashR),
	/*5699*/ uint16(xArgRM8),
	/*5700*/ uint16(xMatch),
	/*5701*/ uint16(xSetOp), uint16(SETG),
	/*5703*/ uint16(xReadSlashR),
	/*5704*/ uint16(xArgRM8),
	/*5705*/ uint16(xMatch),
	/*5706*/ uint16(xSetOp), uint16(PUSH),
	/*5708*/ uint16(xArgFS),
	/*5709*/ uint16(xMatch),
	/*5710*/ uint16(xCondIs64), 5713, 5725,
	/*5713*/ uint16(xCondDataSize), 5717, 5721, 0,
	/*5717*/ uint16(xSetOp), uint16(POP),
	/*5719*/ uint16(xArgFS),
	/*5720*/ uint16(xMatch),
	/*5721*/ uint16(xSetOp), uint16(POP),
	/*5723*/ uint16(xArgFS),
	/*5724*/ uint16(xMatch),
	/*5725*/ uint16(xCondDataSize), 5717, 5729, 5733,
	/*5729*/ uint16(xSetOp), uint16(POP),
	/*5731*/ uint16(xArgFS),
	/*5732*/ uint16(xMatch),
	/*5733*/ uint16(xSetOp), uint16(POP),
	/*5735*/ uint16(xArgFS),
	/*5736*/ uint16(xMatch),
	/*5737*/ uint16(xSetOp), uint16(CPUID),
	/*5739*/ uint16(xMatch),
	/*5740*/ uint16(xCondIs64), 5743, 5759,
	/*5743*/ uint16(xCondDataSize), 5747, 5753, 0,
	/*5747*/ uint16(xSetOp), uint16(BT),
	/*5749*/ uint16(xReadSlashR),
	/*5750*/ uint16(xArgRM16),
	/*5751*/ uint16(xArgR16),
	/*5752*/ uint16(xMatch),
	/*5753*/ uint16(xSetOp), uint16(BT),
	/*5755*/ uint16(xReadSlashR),
	/*5756*/ uint16(xArgRM32),
	/*5757*/ uint16(xArgR32),
	/*5758*/ uint16(xMatch),
	/*5759*/ uint16(xCondDataSize), 5747, 5753, 5763,
	/*5763*/ uint16(xSetOp), uint16(BT),
	/*5765*/ uint16(xReadSlashR),
	/*5766*/ uint16(xArgRM64),
	/*5767*/ uint16(xArgR64),
	/*5768*/ uint16(xMatch),
	/*5769*/ uint16(xCondIs64), 5772, 5792,
	/*5772*/ uint16(xCondDataSize), 5776, 5784, 0,
	/*5776*/ uint16(xSetOp), uint16(SHLD),
	/*5778*/ uint16(xReadSlashR),
	/*5779*/ uint16(xReadIb),
	/*5780*/ uint16(xArgRM16),
	/*5781*/ uint16(xArgR16),
	/*5782*/ uint16(xArgImm8u),
	/*5783*/ uint16(xMatch),
	/*5784*/ uint16(xSetOp), uint16(SHLD),
	/*5786*/ uint16(xReadSlashR),
	/*5787*/ uint16(xReadIb),
	/*5788*/ uint16(xArgRM32),
	/*5789*/ uint16(xArgR32),
	/*5790*/ uint16(xArgImm8u),
	/*5791*/ uint16(xMatch),
	/*5792*/ uint16(xCondDataSize), 5776, 5784, 5796,
	/*5796*/ uint16(xSetOp), uint16(SHLD),
	/*5798*/ uint16(xReadSlashR),
	/*5799*/ uint16(xReadIb),
	/*5800*/ uint16(xArgRM64),
	/*5801*/ uint16(xArgR64),
	/*5802*/ uint16(xArgImm8u),
	/*5803*/ uint16(xMatch),
	/*5804*/ uint16(xCondIs64), 5807, 5825,
	/*5807*/ uint16(xCondDataSize), 5811, 5818, 0,
	/*5811*/ uint16(xSetOp), uint16(SHLD),
	/*5813*/ uint16(xReadSlashR),
	/*5814*/ uint16(xArgRM16),
	/*5815*/ uint16(xArgR16),
	/*5816*/ uint16(xArgCL),
	/*5817*/ uint16(xMatch),
	/*5818*/ uint16(xSetOp), uint16(SHLD),
	/*5820*/ uint16(xReadSlashR),
	/*5821*/ uint16(xArgRM32),
	/*5822*/ uint16(xArgR32),
	/*5823*/ uint16(xArgCL),
	/*5824*/ uint16(xMatch),
	/*5825*/ uint16(xCondDataSize), 5811, 5818, 5829,
	/*5829*/ uint16(xSetOp), uint16(SHLD),
	/*5831*/ uint16(xReadSlashR),
	/*5832*/ uint16(xArgRM64),
	/*5833*/ uint16(xArgR64),
	/*5834*/ uint16(xArgCL),
	/*5835*/ uint16(xMatch),
	/*5836*/ uint16(xSetOp), uint16(PUSH),
	/*5838*/ uint16(xArgGS),
	/*5839*/ uint16(xMatch),
	/*5840*/ uint16(xCondIs64), 5843, 5855,
	/*5843*/ uint16(xCondDataSize), 5847, 5851, 0,
	/*5847*/ uint16(xSetOp), uint16(POP),
	/*5849*/ uint16(xArgGS),
	/*5850*/ uint16(xMatch),
	/*5851*/ uint16(xSetOp), uint16(POP),
	/*5853*/ uint16(xArgGS),
	/*5854*/ uint16(xMatch),
	/*5855*/ uint16(xCondDataSize), 5847, 5859, 5863,
	/*5859*/ uint16(xSetOp), uint16(POP),
	/*5861*/ uint16(xArgGS),
	/*5862*/ uint16(xMatch),
	/*5863*/ uint16(xSetOp), uint16(POP),
	/*5865*/ uint16(xArgGS),
	/*5866*/ uint16(xMatch),
	/*5867*/ uint16(xSetOp), uint16(RSM),
	/*5869*/ uint16(xMatch),
	/*5870*/ uint16(xCondIs64), 5873, 5889,
	/*5873*/ uint16(xCondDataSize), 5877, 5883, 0,
	/*5877*/ uint16(xSetOp), uint16(BTS),
	/*5879*/ uint16(xReadSlashR),
	/*5880*/ uint16(xArgRM16),
	/*5881*/ uint16(xArgR16),
	/*5882*/ uint16(xMatch),
	/*5883*/ uint16(xSetOp), uint16(BTS),
	/*5885*/ uint16(xReadSlashR),
	/*5886*/ uint16(xArgRM32),
	/*5887*/ uint16(xArgR32),
	/*5888*/ uint16(xMatch),
	/*5889*/ uint16(xCondDataSize), 5877, 5883, 5893,
	/*5893*/ uint16(xSetOp), uint16(BTS),
	/*5895*/ uint16(xReadSlashR),
	/*5896*/ uint16(xArgRM64),
	/*5897*/ uint16(xArgR64),
	/*5898*/ uint16(xMatch),
	/*5899*/ uint16(xCondIs64), 5902, 5922,
	/*5902*/ uint16(xCondDataSize), 5906, 5914, 0,
	/*5906*/ uint16(xSetOp), uint16(SHRD),
	/*5908*/ uint16(xReadSlashR),
	/*5909*/ uint16(xReadIb),
	/*5910*/ uint16(xArgRM16),
	/*5911*/ uint16(xArgR16),
	/*5912*/ uint16(xArgImm8u),
	/*5913*/ uint16(xMatch),
	/*5914*/ uint16(xSetOp), uint16(SHRD),
	/*5916*/ uint16(xReadSlashR),
	/*5917*/ uint16(xReadIb),
	/*5918*/ uint16(xArgRM32),
	/*5919*/ uint16(xArgR32),
	/*5920*/ uint16(xArgImm8u),
	/*5921*/ uint16(xMatch),
	/*5922*/ uint16(xCondDataSize), 5906, 5914, 5926,
	/*5926*/ uint16(xSetOp), uint16(SHRD),
	/*5928*/ uint16(xReadSlashR),
	/*5929*/ uint16(xReadIb),
	/*5930*/ uint16(xArgRM64),
	/*5931*/ uint16(xArgR64),
	/*5932*/ uint16(xArgImm8u),
	/*5933*/ uint16(xMatch),
	/*5934*/ uint16(xCondIs64), 5937, 5955,
	/*5937*/ uint16(xCondDataSize), 5941, 5948, 0,
	/*5941*/ uint16(xSetOp), uint16(SHRD),
	/*5943*/ uint16(xReadSlashR),
	/*5944*/ uint16(xArgRM16),
	/*5945*/ uint16(xArgR16),
	/*5946*/ uint16(xArgCL),
	/*5947*/ uint16(xMatch),
	/*5948*/ uint16(xSetOp), uint16(SHRD),
	/*5950*/ uint16(xReadSlashR),
	/*5951*/ uint16(xArgRM32),
	/*5952*/ uint16(xArgR32),
	/*5953*/ uint16(xArgCL),
	/*5954*/ uint16(xMatch),
	/*5955*/ uint16(xCondDataSize), 5941, 5948, 5959,
	/*5959*/ uint16(xSetOp), uint16(SHRD),
	/*5961*/ uint16(xReadSlashR),
	/*5962*/ uint16(xArgRM64),
	/*5963*/ uint16(xArgR64),
	/*5964*/ uint16(xArgCL),
	/*5965*/ uint16(xMatch),
	/*5966*/ uint16(xCondByte), 3,
	0xE8, 6215,
	0xF0, 6218,
	0xF8, 6221,
	/*5974*/ uint16(xCondSlashR),
	5983, // 0
	6037, // 1
	6091, // 2
	6120, // 3
	6149, // 4
	6172, // 5
	6195, // 6
	6211, // 7
	/*5983*/ uint16(xCondIs64), 5986, 5998,
	/*5986*/ uint16(xCondDataSize), 5990, 5994, 0,
	/*5990*/ uint16(xSetOp), uint16(FXSAVE),
	/*5992*/ uint16(xArgM512byte),
	/*5993*/ uint16(xMatch),
	/*5994*/ uint16(xSetOp), uint16(FXSAVE),
	/*5996*/ uint16(xArgM512byte),
	/*5997*/ uint16(xMatch),
	/*5998*/ uint16(xCondPrefix), 2,
	0xF3, 6012,
	0x0, 6004,
	/*6004*/ uint16(xCondDataSize), 5990, 5994, 6008,
	/*6008*/ uint16(xSetOp), uint16(FXSAVE64),
	/*6010*/ uint16(xArgM512byte),
	/*6011*/ uint16(xMatch),
	/*6012*/ uint16(xCondDataSize), 6016, 6023, 6030,
	/*6016*/ uint16(xCondIsMem), 6019, 0,
	/*6019*/ uint16(xSetOp), uint16(RDFSBASE),
	/*6021*/ uint16(xArgRM32),
	/*6022*/ uint16(xMatch),
	/*6023*/ uint16(xCondIsMem), 6026, 0,
	/*6026*/ uint16(xSetOp), uint16(RDFSBASE),
	/*6028*/ uint16(xArgRM32),
	/*6029*/ uint16(xMatch),
	/*6030*/ uint16(xCondIsMem), 6033, 0,
	/*6033*/ uint16(xSetOp), uint16(RDFSBASE),
	/*6035*/ uint16(xArgRM64),
	/*6036*/ uint16(xMatch),
	/*6037*/ uint16(xCondIs64), 6040, 6052,
	/*6040*/ uint16(xCondDataSize), 6044, 6048, 0,
	/*6044*/ uint16(xSetOp), uint16(FXRSTOR),
	/*6046*/ uint16(xArgM512byte),
	/*6047*/ uint16(xMatch),
	/*6048*/ uint16(xSetOp), uint16(FXRSTOR),
	/*6050*/ uint16(xArgM512byte),
	/*6051*/ uint16(xMatch),
	/*6052*/ uint16(xCondPrefix), 2,
	0xF3, 6066,
	0x0, 6058,
	/*6058*/ uint16(xCondDataSize), 6044, 6048, 6062,
	/*6062*/ uint16(xSetOp), uint16(FXRSTOR64),
	/*6064*/ uint16(xArgM512byte),
	/*6065*/ uint16(xMatch),
	/*6066*/ uint16(xCondDataSize), 6070, 6077, 6084,
	/*6070*/ uint16(xCondIsMem), 6073, 0,
	/*6073*/ uint16(xSetOp), uint16(RDGSBASE),
	/*6075*/ uint16(xArgRM32),
	/*6076*/ uint16(xMatch),
	/*6077*/ uint16(xCondIsMem), 6080, 0,
	/*6080*/ uint16(xSetOp), uint16(RDGSBASE),
	/*6082*/ uint16(xArgRM32),
	/*6083*/ uint16(xMatch),
	/*6084*/ uint16(xCondIsMem), 6087, 0,
	/*6087*/ uint16(xSetOp), uint16(RDGSBASE),
	/*6089*/ uint16(xArgRM64),
	/*6090*/ uint16(xMatch),
	/*6091*/ uint16(xCondIs64), 6094, 6098,
	/*6094*/ uint16(xSetOp), uint16(LDMXCSR),
	/*6096*/ uint16(xArgM32),
	/*6097*/ uint16(xMatch),
	/*6098*/ uint16(xCondPrefix), 2,
	0xF3, 6104,
	0x0, 6094,
	/*6104*/ uint16(xCondDataSize), 6108, 6112, 6116,
	/*6108*/ uint16(xSetOp), uint16(WRFSBASE),
	/*6110*/ uint16(xArgRM32),
	/*6111*/ uint16(xMatch),
	/*6112*/ uint16(xSetOp), uint16(WRFSBASE),
	/*6114*/ uint16(xArgRM32),
	/*6115*/ uint16(xMatch),
	/*6116*/ uint16(xSetOp), uint16(WRFSBASE),
	/*6118*/ uint16(xArgRM64),
	/*6119*/ uint16(xMatch),
	/*6120*/ uint16(xCondIs64), 6123, 6127,
	/*6123*/ uint16(xSetOp), uint16(STMXCSR),
	/*6125*/ uint16(xArgM32),
	/*6126*/ uint16(xMatch),
	/*6127*/ uint16(xCondPrefix), 2,
	0xF3, 6133,
	0x0, 6123,
	/*6133*/ uint16(xCondDataSize), 6137, 6141, 6145,
	/*6137*/ uint16(xSetOp), uint16(WRGSBASE),
	/*6139*/ uint16(xArgRM32),
	/*6140*/ uint16(xMatch),
	/*6141*/ uint16(xSetOp), uint16(WRGSBASE),
	/*6143*/ uint16(xArgRM32),
	/*6144*/ uint16(xMatch),
	/*6145*/ uint16(xSetOp), uint16(WRGSBASE),
	/*6147*/ uint16(xArgRM64),
	/*6148*/ uint16(xMatch),
	/*6149*/ uint16(xCondIs64), 6152, 6164,
	/*6152*/ uint16(xCondDataSize), 6156, 6160, 0,
	/*6156*/ uint16(xSetOp), uint16(XSAVE),
	/*6158*/ uint16(xArgMem),
	/*6159*/ uint16(xMatch),
	/*6160*/ uint16(xSetOp), uint16(XSAVE),
	/*6162*/ uint16(xArgMem),
	/*6163*/ uint16(xMatch),
	/*6164*/ uint16(xCondDataSize), 6156, 6160, 6168,
	/*6168*/ uint16(xSetOp), uint16(XSAVE64),
	/*6170*/ uint16(xArgMem),
	/*6171*/ uint16(xMatch),
	/*6172*/ uint16(xCondIs64), 6175, 6187,
	/*6175*/ uint16(xCondDataSize), 6179, 6183, 0,
	/*6179*/ uint16(xSetOp), uint16(XRSTOR),
	/*6181*/ uint16(xArgMem),
	/*6182*/ uint16(xMatch),
	/*6183*/ uint16(xSetOp), uint16(XRSTOR),
	/*6185*/ uint16(xArgMem),
	/*6186*/ uint16(xMatch),
	/*6187*/ uint16(xCondDataSize), 6179, 6183, 6191,
	/*6191*/ uint16(xSetOp), uint16(XRSTOR64),
	/*6193*/ uint16(xArgMem),
	/*6194*/ uint16(xMatch),
	/*6195*/ uint16(xCondDataSize), 6199, 6203, 6207,
	/*6199*/ uint16(xSetOp), uint16(XSAVEOPT),
	/*6201*/ uint16(xArgMem),
	/*6202*/ uint16(xMatch),
	/*6203*/ uint16(xSetOp), uint16(XSAVEOPT),
	/*6205*/ uint16(xArgMem),
	/*6206*/ uint16(xMatch),
	/*6207*/ uint16(xSetOp), uint16(XSAVEOPT64),
	/*6209*/ uint16(xArgMem),
	/*6210*/ uint16(xMatch),
	/*6211*/ uint16(xSetOp), uint16(CLFLUSH),
	/*6213*/ uint16(xArgM8),
	/*6214*/ uint16(xMatch),
	/*6215*/ uint16(xSetOp), uint16(LFENCE),
	/*6217*/ uint16(xMatch),
	/*6218*/ uint16(xSetOp), uint16(MFENCE),
	/*6220*/ uint16(xMatch),
	/*6221*/ uint16(xSetOp), uint16(SFENCE),
	/*6223*/ uint16(xMatch),
	/*6224*/ uint16(xCondIs64), 6227, 6243,
	/*6227*/ uint16(xCondDataSize), 6231, 6237, 0,
	/*6231*/ uint16(xSetOp), uint16(IMUL),
	/*6233*/ uint16(xReadSlashR),
	/*6234*/ uint16(xArgR16),
	/*6235*/ uint16(xArgRM16),
	/*6236*/ uint16(xMatch),
	/*6237*/ uint16(xSetOp), uint16(IMUL),
	/*6239*/ uint16(xReadSlashR),
	/*6240*/ uint16(xArgR32),
	/*6241*/ uint16(xArgRM32),
	/*6242*/ uint16(xMatch),
	/*6243*/ uint16(xCondDataSize), 6231, 6237, 6247,
	/*6247*/ uint16(xSetOp), uint16(IMUL),
	/*6249*/ uint16(xReadSlashR),
	/*6250*/ uint16(xArgR64),
	/*6251*/ uint16(xArgRM64),
	/*6252*/ uint16(xMatch),
	/*6253*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6255*/ uint16(xReadSlashR),
	/*6256*/ uint16(xArgRM8),
	/*6257*/ uint16(xArgR8),
	/*6258*/ uint16(xMatch),
	/*6259*/ uint16(xCondIs64), 6262, 6278,
	/*6262*/ uint16(xCondDataSize), 6266, 6272, 0,
	/*6266*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6268*/ uint16(xReadSlashR),
	/*6269*/ uint16(xArgRM16),
	/*6270*/ uint16(xArgR16),
	/*6271*/ uint16(xMatch),
	/*6272*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6274*/ uint16(xReadSlashR),
	/*6275*/ uint16(xArgRM32),
	/*6276*/ uint16(xArgR32),
	/*6277*/ uint16(xMatch),
	/*6278*/ uint16(xCondDataSize), 6266, 6272, 6282,
	/*6282*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6284*/ uint16(xReadSlashR),
	/*6285*/ uint16(xArgRM64),
	/*6286*/ uint16(xArgR64),
	/*6287*/ uint16(xMatch),
	/*6288*/ uint16(xCondIs64), 6291, 6307,
	/*6291*/ uint16(xCondDataSize), 6295, 6301, 0,
	/*6295*/ uint16(xSetOp), uint16(LSS),
	/*6297*/ uint16(xReadSlashR),
	/*6298*/ uint16(xArgR16),
	/*6299*/ uint16(xArgM16colon16),
	/*6300*/ uint16(xMatch),
	/*6301*/ uint16(xSetOp), uint16(LSS),
	/*6303*/ uint16(xReadSlashR),
	/*6304*/ uint16(xArgR32),
	/*6305*/ uint16(xArgM16colon32),
	/*6306*/ uint16(xMatch),
	/*6307*/ uint16(xCondDataSize), 6295, 6301, 6311,
	/*6311*/ uint16(xSetOp), uint16(LSS),
	/*6313*/ uint16(xReadSlashR),
	/*6314*/ uint16(xArgR64),
	/*6315*/ uint16(xArgM16colon64),
	/*6316*/ uint16(xMatch),
	/*6317*/ uint16(xCondIs64), 6320, 6336,
	/*6320*/ uint16(xCondDataSize), 6324, 6330, 0,
	/*6324*/ uint16(xSetOp), uint16(BTR),
	/*6326*/ uint16(xReadSlashR),
	/*6327*/ uint16(xArgRM16),
	/*6328*/ uint16(xArgR16),
	/*6329*/ uint16(xMatch),
	/*6330*/ uint16(xSetOp), uint16(BTR),
	/*6332*/ uint16(xReadSlashR),
	/*6333*/ uint16(xArgRM32),
	/*6334*/ uint16(xArgR32),
	/*6335*/ uint16(xMatch),
	/*6336*/ uint16(xCondDataSize), 6324, 6330, 6340,
	/*6340*/ uint16(xSetOp), uint16(BTR),
	/*6342*/ uint16(xReadSlashR),
	/*6343*/ uint16(xArgRM64),
	/*6344*/ uint16(xArgR64),
	/*6345*/ uint16(xMatch),
	/*6346*/ uint16(xCondIs64), 6349, 6365,
	/*6349*/ uint16(xCondDataSize), 6353, 6359, 0,
	/*6353*/ uint16(xSetOp), uint16(LFS),
	/*6355*/ uint16(xReadSlashR),
	/*6356*/ uint16(xArgR16),
	/*6357*/ uint16(xArgM16colon16),
	/*6358*/ uint16(xMatch),
	/*6359*/ uint16(xSetOp), uint16(LFS),
	/*6361*/ uint16(xReadSlashR),
	/*6362*/ uint16(xArgR32),
	/*6363*/ uint16(xArgM16colon32),
	/*6364*/ uint16(xMatch),
	/*6365*/ uint16(xCondDataSize), 6353, 6359, 6369,
	/*6369*/ uint16(xSetOp), uint16(LFS),
	/*6371*/ uint16(xReadSlashR),
	/*6372*/ uint16(xArgR64),
	/*6373*/ uint16(xArgM16colon64),
	/*6374*/ uint16(xMatch),
	/*6375*/ uint16(xCondIs64), 6378, 6394,
	/*6378*/ uint16(xCondDataSize), 6382, 6388, 0,
	/*6382*/ uint16(xSetOp), uint16(LGS),
	/*6384*/ uint16(xReadSlashR),
	/*6385*/ uint16(xArgR16),
	/*6386*/ uint16(xArgM16colon16),
	/*6387*/ uint16(xMatch),
	/*6388*/ uint16(xSetOp), uint16(LGS),
	/*6390*/ uint16(xReadSlashR),
	/*6391*/ uint16(xArgR32),
	/*6392*/ uint16(xArgM16colon32),
	/*6393*/ uint16(xMatch),
	/*6394*/ uint16(xCondDataSize), 6382, 6388, 6398,
	/*6398*/ uint16(xSetOp), uint16(LGS),
	/*6400*/ uint16(xReadSlashR),
	/*6401*/ uint16(xArgR64),
	/*6402*/ uint16(xArgM16colon64),
	/*6403*/ uint16(xMatch),
	/*6404*/ uint16(xCondIs64), 6407, 6423,
	/*6407*/ uint16(xCondDataSize), 6411, 6417, 0,
	/*6411*/ uint16(xSetOp), uint16(MOVZX),
	/*6413*/ uint16(xReadSlashR),
	/*6414*/ uint16(xArgR16),
	/*6415*/ uint16(xArgRM8),
	/*6416*/ uint16(xMatch),
	/*6417*/ uint16(xSetOp), uint16(MOVZX),
	/*6419*/ uint16(xReadSlashR),
	/*6420*/ uint16(xArgR32),
	/*6421*/ uint16(xArgRM8),
	/*6422*/ uint16(xMatch),
	/*6423*/ uint16(xCondDataSize), 6411, 6417, 6427,
	/*6427*/ uint16(xSetOp), uint16(MOVZX),
	/*6429*/ uint16(xReadSlashR),
	/*6430*/ uint16(xArgR64),
	/*6431*/ uint16(xArgRM8),
	/*6432*/ uint16(xMatch),
	/*6433*/ uint16(xCondIs64), 6436, 6452,
	/*6436*/ uint16(xCondDataSize), 6440, 6446, 0,
	/*6440*/ uint16(xSetOp), uint16(MOVZX),
	/*6442*/ uint16(xReadSlashR),
	/*6443*/ uint16(xArgR16),
	/*6444*/ uint16(xArgRM16),
	/*6445*/ uint16(xMatch),
	/*6446*/ uint16(xSetOp), uint16(MOVZX),
	/*6448*/ uint16(xReadSlashR),
	/*6449*/ uint16(xArgR32),
	/*6450*/ uint16(xArgRM16),
	/*6451*/ uint16(xMatch),
	/*6452*/ uint16(xCondDataSize), 6440, 6446, 6456,
	/*6456*/ uint16(xSetOp), uint16(MOVZX),
	/*6458*/ uint16(xReadSlashR),
	/*6459*/ uint16(xArgR64),
	/*6460*/ uint16(xArgRM16),
	/*6461*/ uint16(xMatch),
	/*6462*/ uint16(xCondIs64), 6465, 6485,
	/*6465*/ uint16(xCondPrefix), 1,
	0xF3, 6469,
	/*6469*/ uint16(xCondDataSize), 6473, 6479, 0,
	/*6473*/ uint16(xSetOp), uint16(POPCNT),
	/*6475*/ uint16(xReadSlashR),
	/*6476*/ uint16(xArgR16),
	/*6477*/ uint16(xArgRM16),
	/*6478*/ uint16(xMatch),
	/*6479*/ uint16(xSetOp), uint16(POPCNT),
	/*6481*/ uint16(xReadSlashR),
	/*6482*/ uint16(xArgR32),
	/*6483*/ uint16(xArgRM32),
	/*6484*/ uint16(xMatch),
	/*6485*/ uint16(xCondPrefix), 1,
	0xF3, 6489,
	/*6489*/ uint16(xCondDataSize), 6473, 6479, 6493,
	/*6493*/ uint16(xSetOp), uint16(POPCNT),
	/*6495*/ uint16(xReadSlashR),
	/*6496*/ uint16(xArgR64),
	/*6497*/ uint16(xArgRM64),
	/*6498*/ uint16(xMatch),
	/*6499*/ uint16(xSetOp), uint16(UD1),
	/*6501*/ uint16(xMatch),
	/*6502*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	0,    // 2
	0,    // 3
	6511, // 4
	6540, // 5
	6569, // 6
	6598, // 7
	/*6511*/ uint16(xCondIs64), 6514, 6530,
	/*6514*/ uint16(xCondDataSize), 6518, 6524, 0,
	/*6518*/ uint16(xSetOp), uint16(BT),
	/*6520*/ uint16(xReadIb),
	/*6521*/ uint16(xArgRM16),
	/*6522*/ uint16(xArgImm8u),
	/*6523*/ uint16(xMatch),
	/*6524*/ uint16(xSetOp), uint16(BT),
	/*6526*/ uint16(xReadIb),
	/*6527*/ uint16(xArgRM32),
	/*6528*/ uint16(xArgImm8u),
	/*6529*/ uint16(xMatch),
	/*6530*/ uint16(xCondDataSize), 6518, 6524, 6534,
	/*6534*/ uint16(xSetOp), uint16(BT),
	/*6536*/ uint16(xReadIb),
	/*6537*/ uint16(xArgRM64),
	/*6538*/ uint16(xArgImm8u),
	/*6539*/ uint16(xMatch),
	/*6540*/ uint16(xCondIs64), 6543, 6559,
	/*6543*/ uint16(xCondDataSize), 6547, 6553, 0,
	/*6547*/ uint16(xSetOp), uint16(BTS),
	/*6549*/ uint16(xReadIb),
	/*6550*/ uint16(xArgRM16),
	/*6551*/ uint16(xArgImm8u),
	/*6552*/ uint16(xMatch),
	/*6553*/ uint16(xSetOp), uint16(BTS),
	/*6555*/ uint16(xReadIb),
	/*6556*/ uint16(xArgRM32),
	/*6557*/ uint16(xArgImm8u),
	/*6558*/ uint16(xMatch),
	/*6559*/ uint16(xCondDataSize), 6547, 6553, 6563,
	/*6563*/ uint16(xSetOp), uint16(BTS),
	/*6565*/ uint16(xReadIb),
	/*6566*/ uint16(xArgRM64),
	/*6567*/ uint16(xArgImm8u),
	/*6568*/ uint16(xMatch),
	/*6569*/ uint16(xCondIs64), 6572, 6588,
	/*6572*/ uint16(xCondDataSize), 6576, 6582, 0,
	/*6576*/ uint16(xSetOp), uint16(BTR),
	/*6578*/ uint16(xReadIb),
	/*6579*/ uint16(xArgRM16),
	/*6580*/ uint16(xArgImm8u),
	/*6581*/ uint16(xMatch),
	/*6582*/ uint16(xSetOp), uint16(BTR),
	/*6584*/ uint16(xReadIb),
	/*6585*/ uint16(xArgRM32),
	/*6586*/ uint16(xArgImm8u),
	/*6587*/ uint16(xMatch),
	/*6588*/ uint16(xCondDataSize), 6576, 6582, 6592,
	/*6592*/ uint16(xSetOp), uint16(BTR),
	/*6594*/ uint16(xReadIb),
	/*6595*/ uint16(xArgRM64),
	/*6596*/ uint16(xArgImm8u),
	/*6597*/ uint16(xMatch),
	/*6598*/ uint16(xCondIs64), 6601, 6617,
	/*6601*/ uint16(xCondDataSize), 6605, 6611, 0,
	/*6605*/ uint16(xSetOp), uint16(BTC),
	/*6607*/ uint16(xReadIb),
	/*6608*/ uint16(xArgRM16),
	/*6609*/ uint16(xArgImm8u),
	/*6610*/ uint16(xMatch),
	/*6611*/ uint16(xSetOp), uint16(BTC),
	/*6613*/ uint16(xReadIb),
	/*6614*/ uint16(xArgRM32),
	/*6615*/ uint16(xArgImm8u),
	/*6616*/ uint16(xMatch),
	/*6617*/ uint16(xCondDataSize), 6605, 6611, 6621,
	/*6621*/ uint16(xSetOp), uint16(BTC),
	/*6623*/ uint16(xReadIb),
	/*6624*/ uint16(xArgRM64),
	/*6625*/ uint16(xArgImm8u),
	/*6626*/ uint16(xMatch),
	/*6627*/ uint16(xCondIs64), 6630, 6646,
	/*6630*/ uint16(xCondDataSize), 6634, 6640, 0,
	/*6634*/ uint16(xSetOp), uint16(BTC),
	/*6636*/ uint16(xReadSlashR),
	/*6637*/ uint16(xArgRM16),
	/*6638*/ uint16(xArgR16),
	/*6639*/ uint16(xMatch),
	/*6640*/ uint16(xSetOp), uint16(BTC),
	/*6642*/ uint16(xReadSlashR),
	/*6643*/ uint16(xArgRM32),
	/*6644*/ uint16(xArgR32),
	/*6645*/ uint16(xMatch),
	/*6646*/ uint16(xCondDataSize), 6634, 6640, 6650,
	/*6650*/ uint16(xSetOp), uint16(BTC),
	/*6652*/ uint16(xReadSlashR),
	/*6653*/ uint16(xArgRM64),
	/*6654*/ uint16(xArgR64),
	/*6655*/ uint16(xMatch),
	/*6656*/ uint16(xCondIs64), 6659, 6697,
	/*6659*/ uint16(xCondPrefix), 2,
	0xF3, 6681,
	0x0, 6665,
	/*6665*/ uint16(xCondDataSize), 6669, 6675, 0,
	/*6669*/ uint16(xSetOp), uint16(BSF),
	/*6671*/ uint16(xReadSlashR),
	/*6672*/ uint16(xArgR16),
	/*6673*/ uint16(xArgRM16),
	/*6674*/ uint16(xMatch),
	/*6675*/ uint16(xSetOp), uint16(BSF),
	/*6677*/ uint16(xReadSlashR),
	/*6678*/ uint16(xArgR32),
	/*6679*/ uint16(xArgRM32),
	/*6680*/ uint16(xMatch),
	/*6681*/ uint16(xCondDataSize), 6685, 6691, 0,
	/*6685*/ uint16(xSetOp), uint16(TZCNT),
	/*6687*/ uint16(xReadSlashR),
	/*6688*/ uint16(xArgR16),
	/*6689*/ uint16(xArgRM16),
	/*6690*/ uint16(xMatch),
	/*6691*/ uint16(xSetOp), uint16(TZCNT),
	/*6693*/ uint16(xReadSlashR),
	/*6694*/ uint16(xArgR32),
	/*6695*/ uint16(xArgRM32),
	/*6696*/ uint16(xMatch),
	/*6697*/ uint16(xCondPrefix), 2,
	0xF3, 6713,
	0x0, 6703,
	/*6703*/ uint16(xCondDataSize), 6669, 6675, 6707,
	/*6707*/ uint16(xSetOp), uint16(BSF),
	/*6709*/ uint16(xReadSlashR),
	/*6710*/ uint16(xArgR64),
	/*6711*/ uint16(xArgRM64),
	/*6712*/ uint16(xMatch),
	/*6713*/ uint16(xCondDataSize), 6685, 6691, 6717,
	/*6717*/ uint16(xSetOp), uint16(TZCNT),
	/*6719*/ uint16(xReadSlashR),
	/*6720*/ uint16(xArgR64),
	/*6721*/ uint16(xArgRM64),
	/*6722*/ uint16(xMatch),
	/*6723*/ uint16(xCondIs64), 6726, 6764,
	/*6726*/ uint16(xCondPrefix), 2,
	0xF3, 6748,
	0x0, 6732,
	/*6732*/ uint16(xCondDataSize), 6736, 6742, 0,
	/*6736*/ uint16(xSetOp), uint16(BSR),
	/*6738*/ uint16(xReadSlashR),
	/*6739*/ uint16(xArgR16),
	/*6740*/ uint16(xArgRM16),
	/*6741*/ uint16(xMatch),
	/*6742*/ uint16(xSetOp), uint16(BSR),
	/*6744*/ uint16(xReadSlashR),
	/*6745*/ uint16(xArgR32),
	/*6746*/ uint16(xArgRM32),
	/*6747*/ uint16(xMatch),
	/*6748*/ uint16(xCondDataSize), 6752, 6758, 0,
	/*6752*/ uint16(xSetOp), uint16(LZCNT),
	/*6754*/ uint16(xReadSlashR),
	/*6755*/ uint16(xArgR16),
	/*6756*/ uint16(xArgRM16),
	/*6757*/ uint16(xMatch),
	/*6758*/ uint16(xSetOp), uint16(LZCNT),
	/*6760*/ uint16(xReadSlashR),
	/*6761*/ uint16(xArgR32),
	/*6762*/ uint16(xArgRM32),
	/*6763*/ uint16(xMatch),
	/*6764*/ uint16(xCondPrefix), 2,
	0xF3, 6780,
	0x0, 6770,
	/*6770*/ uint16(xCondDataSize), 6736, 6742, 6774,
	/*6774*/ uint16(xSetOp), uint16(BSR),
	/*6776*/ uint16(xReadSlashR),
	/*6777*/ uint16(xArgR64),
	/*6778*/ uint16(xArgRM64),
	/*6779*/ uint16(xMatch),
	/*6780*/ uint16(xCondDataSize), 6752, 6758, 6784,
	/*6784*/ uint16(xSetOp), uint16(LZCNT),
	/*6786*/ uint16(xReadSlashR),
	/*6787*/ uint16(xArgR64),
	/*6788*/ uint16(xArgRM64),
	/*6789*/ uint16(xMatch),
	/*6790*/ uint16(xCondIs64), 6793, 6809,
	/*6793*/ uint16(xCondDataSize), 6797, 6803, 0,
	/*6797*/ uint16(xSetOp), uint16(MOVSX),
	/*6799*/ uint16(xReadSlashR),
	/*6800*/ uint16(xArgR16),
	/*6801*/ uint16(xArgRM8),
	/*6802*/ uint16(xMatch),
	/*6803*/ uint16(xSetOp), uint16(MOVSX),
	/*6805*/ uint16(xReadSlashR),
	/*6806*/ uint16(xArgR32),
	/*6807*/ uint16(xArgRM8),
	/*6808*/ uint16(xMatch),
	/*6809*/ uint16(xCondDataSize), 6797, 6803, 6813,
	/*6813*/ uint16(xSetOp), uint16(MOVSX),
	/*6815*/ uint16(xReadSlashR),
	/*6816*/ uint16(xArgR64),
	/*6817*/ uint16(xArgRM8),
	/*6818*/ uint16(xMatch),
	/*6819*/ uint16(xCondIs64), 6822, 6838,
	/*6822*/ uint16(xCondDataSize), 6826, 6832, 0,
	/*6826*/ uint16(xSetOp), uint16(MOVSX),
	/*6828*/ uint16(xReadSlashR),
	/*6829*/ uint16(xArgR16),
	/*6830*/ uint16(xArgRM16),
	/*6831*/ uint16(xMatch),
	/*6832*/ uint16(xSetOp), uint16(MOVSX),
	/*6834*/ uint16(xReadSlashR),
	/*6835*/ uint16(xArgR32),
	/*6836*/ uint16(xArgRM16),
	/*6837*/ uint16(xMatch),
	/*6838*/ uint16(xCondDataSize), 6826, 6832, 6842,
	/*6842*/ uint16(xSetOp), uint16(MOVSX),
	/*6844*/ uint16(xReadSlashR),
	/*6845*/ uint16(xArgR64),
	/*6846*/ uint16(xArgRM16),
	/*6847*/ uint16(xMatch),
	/*6848*/ uint16(xSetOp), uint16(XADD),
	/*6850*/ uint16(xReadSlashR),
	/*6851*/ uint16(xArgRM8),
	/*6852*/ uint16(xArgR8),
	/*6853*/ uint16(xMatch),
	/*6854*/ uint16(xCondIs64), 6857, 6873,
	/*6857*/ uint16(xCondDataSize), 6861, 6867, 0,
	/*6861*/ uint16(xSetOp), uint16(XADD),
	/*6863*/ uint16(xReadSlashR),
	/*6864*/ uint16(xArgRM16),
	/*6865*/ uint16(xArgR16),
	/*6866*/ uint16(xMatch),
	/*6867*/ uint16(xSetOp), uint16(XADD),
	/*6869*/ uint16(xReadSlashR),
	/*6870*/ uint16(xArgRM32),
	/*6871*/ uint16(xArgR32),
	/*6872*/ uint16(xMatch),
	/*6873*/ uint16(xCondDataSize), 6861, 6867, 6877,
	/*6877*/ uint16(xSetOp), uint16(XADD),
	/*6879*/ uint16(xReadSlashR),
	/*6880*/ uint16(xArgRM64),
	/*6881*/ uint16(xArgR64),
	/*6882*/ uint16(xMatch),
	/*6883*/ uint16(xCondPrefix), 4,
	0xF3, 6917,
	0xF2, 6909,
	0x66, 6901,
	0x0, 6893,
	/*6893*/ uint16(xSetOp), uint16(CMPPS),
	/*6895*/ uint16(xReadSlashR),
	/*6896*/ uint16(xReadIb),
	/*6897*/ uint16(xArgXmm1),
	/*6898*/ uint16(xArgXmm2M128),
	/*6899*/ uint16(xArgImm8u),
	/*6900*/ uint16(xMatch),
	/*6901*/ uint16(xSetOp), uint16(CMPPD),
	/*6903*/ uint16(xReadSlashR),
	/*6904*/ uint16(xReadIb),
	/*6905*/ uint16(xArgXmm1),
	/*6906*/ uint16(xArgXmm2M128),
	/*6907*/ uint16(xArgImm8u),
	/*6908*/ uint16(xMatch),
	/*6909*/ uint16(xSetOp), uint16(CMPSD_XMM),
	/*6911*/ uint16(xReadSlashR),
	/*6912*/ uint16(xReadIb),
	/*6913*/ uint16(xArgXmm1),
	/*6914*/ uint16(xArgXmm2M64),
	/*6915*/ uint16(xArgImm8u),
	/*6916*/ uint16(xMatch),
	/*6917*/ uint16(xSetOp), uint16(CMPSS),
	/*6919*/ uint16(xReadSlashR),
	/*6920*/ uint16(xReadIb),
	/*6921*/ uint16(xArgXmm1),
	/*6922*/ uint16(xArgXmm2M32),
	/*6923*/ uint16(xArgImm8u),
	/*6924*/ uint16(xMatch),
	/*6925*/ uint16(xCondIs64), 6928, 6944,
	/*6928*/ uint16(xCondDataSize), 6932, 6938, 0,
	/*6932*/ uint16(xSetOp), uint16(MOVNTI),
	/*6934*/ uint16(xReadSlashR),
	/*6935*/ uint16(xArgM32),
	/*6936*/ uint16(xArgR32),
	/*6937*/ uint16(xMatch),
	/*6938*/ uint16(xSetOp), uint16(MOVNTI),
	/*6940*/ uint16(xReadSlashR),
	/*6941*/ uint16(xArgM32),
	/*6942*/ uint16(xArgR32),
	/*6943*/ uint16(xMatch),
	/*6944*/ uint16(xCondDataSize), 6932, 6938, 6948,
	/*6948*/ uint16(xSetOp), uint16(MOVNTI),
	/*6950*/ uint16(xReadSlashR),
	/*6951*/ uint16(xArgM64),
	/*6952*/ uint16(xArgR64),
	/*6953*/ uint16(xMatch),
	/*6954*/ uint16(xCondPrefix), 2,
	0x66, 6968,
	0x0, 6960,
	/*6960*/ uint16(xSetOp), uint16(PINSRW),
	/*6962*/ uint16(xReadSlashR),
	/*6963*/ uint16(xReadIb),
	/*6964*/ uint16(xArgMm),
	/*6965*/ uint16(xArgR32M16),
	/*6966*/ uint16(xArgImm8u),
	/*6967*/ uint16(xMatch),
	/*6968*/ uint16(xSetOp), uint16(PINSRW),
	/*6970*/ uint16(xReadSlashR),
	/*6971*/ uint16(xReadIb),
	/*6972*/ uint16(xArgXmm),
	/*6973*/ uint16(xArgR32M16),
	/*6974*/ uint16(xArgImm8u),
	/*6975*/ uint16(xMatch),
	/*6976*/ uint16(xCondPrefix), 2,
	0x66, 6990,
	0x0, 6982,
	/*6982*/ uint16(xSetOp), uint16(PEXTRW),
	/*6984*/ uint16(xReadSlashR),
	/*6985*/ uint16(xReadIb),
	/*6986*/ uint16(xArgR32),
	/*6987*/ uint16(xArgMm2),
	/*6988*/ uint16(xArgImm8u),
	/*6989*/ uint16(xMatch),
	/*6990*/ uint16(xSetOp), uint16(PEXTRW),
	/*6992*/ uint16(xReadSlashR),
	/*6993*/ uint16(xReadIb),
	/*6994*/ uint16(xArgR32),
	/*6995*/ uint16(xArgXmm2),
	/*6996*/ uint16(xArgImm8u),
	/*6997*/ uint16(xMatch),
	/*6998*/ uint16(xCondPrefix), 2,
	0x66, 7012,
	0x0, 7004,
	/*7004*/ uint16(xSetOp), uint16(SHUFPS),
	/*7006*/ uint16(xReadSlashR),
	/*7007*/ uint16(xReadIb),
	/*7008*/ uint16(xArgXmm1),
	/*7009*/ uint16(xArgXmm2M128),
	/*7010*/ uint16(xArgImm8u),
	/*7011*/ uint16(xMatch),
	/*7012*/ uint16(xSetOp), uint16(SHUFPD),
	/*7014*/ uint16(xReadSlashR),
	/*7015*/ uint16(xReadIb),
	/*7016*/ uint16(xArgXmm1),
	/*7017*/ uint16(xArgXmm2M128),
	/*7018*/ uint16(xArgImm8u),
	/*7019*/ uint16(xMatch),
	/*7020*/ uint16(xCondSlashR),
	0,    // 0
	7029, // 1
	0,    // 2
	7052, // 3
	7075, // 4
	7098, // 5
	7121, // 6
	0,    // 7
	/*7029*/ uint16(xCondIs64), 7032, 7044,
	/*7032*/ uint16(xCondDataSize), 7036, 7040, 0,
	/*7036*/ uint16(xSetOp), uint16(CMPXCHG8B),
	/*7038*/ uint16(xArgM64),
	/*7039*/ uint16(xMatch),
	/*7040*/ uint16(xSetOp), uint16(CMPXCHG8B),
	/*7042*/ uint16(xArgM64),
	/*7043*/ uint16(xMatch),
	/*7044*/ uint16(xCondDataSize), 7036, 7040, 7048,
	/*7048*/ uint16(xSetOp), uint16(CMPXCHG16B),
	/*7050*/ uint16(xArgM128),
	/*7051*/ uint16(xMatch),
	/*7052*/ uint16(xCondIs64), 7055, 7067,
	/*7055*/ uint16(xCondDataSize), 7059, 7063, 0,
	/*7059*/ uint16(xSetOp), uint16(XRSTORS),
	/*7061*/ uint16(xArgMem),
	/*7062*/ uint16(xMatch),
	/*7063*/ uint16(xSetOp), uint16(XRSTORS),
	/*7065*/ uint16(xArgMem),
	/*7066*/ uint16(xMatch),
	/*7067*/ uint16(xCondDataSize), 7059, 7063, 7071,
	/*7071*/ uint16(xSetOp), uint16(XRSTORS64),
	/*7073*/ uint16(xArgMem),
	/*7074*/ uint16(xMatch),
	/*7075*/ uint16(xCondIs64), 7078, 7090,
	/*7078*/ uint16(xCondDataSize), 7082, 7086, 0,
	/*7082*/ uint16(xSetOp), uint16(XSAVEC),
	/*7084*/ uint16(xArgMem),
	/*7085*/ uint16(xMatch),
	/*7086*/ uint16(xSetOp), uint16(XSAVEC),
	/*7088*/ uint16(xArgMem),
	/*7089*/ uint16(xMatch),
	/*7090*/ uint16(xCondDataSize), 7082, 7086, 7094,
	/*7094*/ uint16(xSetOp), uint16(XSAVEC64),
	/*7096*/ uint16(xArgMem),
	/*7097*/ uint16(xMatch),
	/*7098*/ uint16(xCondIs64), 7101, 7113,
	/*7101*/ uint16(xCondDataSize), 7105, 7109, 0,
	/*7105*/ uint16(xSetOp), uint16(XSAVES),
	/*7107*/ uint16(xArgMem),
	/*7108*/ uint16(xMatch),
	/*7109*/ uint16(xSetOp), uint16(XSAVES),
	/*7111*/ uint16(xArgMem),
	/*7112*/ uint16(xMatch),
	/*7113*/ uint16(xCondDataSize), 7105, 7109, 7117,
	/*7117*/ uint16(xSetOp), uint16(XSAVES64),
	/*7119*/ uint16(xArgMem),
	/*7120*/ uint16(xMatch),
	/*7121*/ uint16(xCondIs64), 7124, 7142,
	/*7124*/ uint16(xCondDataSize), 7128, 7135, 0,
	/*7128*/ uint16(xCondIsMem), 7131, 0,
	/*7131*/ uint16(xSetOp), uint16(RDRAND),
	/*7133*/ uint16(xArgRmf16),
	/*7134*/ uint16(xMatch),
	/*7135*/ uint16(xCondIsMem), 7138, 0,
	/*7138*/ uint16(xSetOp), uint16(RDRAND),
	/*7140*/ uint16(xArgRmf32),
	/*7141*/ uint16(xMatch),
	/*7142*/ uint16(xCondDataSize), 7128, 7135, 7146,
	/*7146*/ uint16(xSetOp), uint16(RDRAND),
	/*7148*/ uint16(xMatch),
	/*7149*/ uint16(xCondIs64), 7152, 7164,
	/*7152*/ uint16(xCondDataSize), 7156, 7160, 0,
	/*7156*/ uint16(xSetOp), uint16(BSWAP),
	/*7158*/ uint16(xArgR16op),
	/*7159*/ uint16(xMatch),
	/*7160*/ uint16(xSetOp), uint16(BSWAP),
	/*7162*/ uint16(xArgR32op),
	/*7163*/ uint16(xMatch),
	/*7164*/ uint16(xCondDataSize), 7156, 7160, 7168,
	/*7168*/ uint16(xSetOp), uint16(BSWAP),
	/*7170*/ uint16(xArgR64op),
	/*7171*/ uint16(xMatch),
	/*7172*/ uint16(xCondPrefix), 2,
	0xF2, 7184,
	0x66, 7178,
	/*7178*/ uint16(xSetOp), uint16(ADDSUBPD),
	/*7180*/ uint16(xReadSlashR),
	/*7181*/ uint16(xArgXmm1),
	/*7182*/ uint16(xArgXmm2M128),
	/*7183*/ uint16(xMatch),
	/*7184*/ uint16(xSetOp), uint16(ADDSUBPS),
	/*7186*/ uint16(xReadSlashR),
	/*7187*/ uint16(xArgXmm1),
	/*7188*/ uint16(xArgXmm2M128),
	/*7189*/ uint16(xMatch),
	/*7190*/ uint16(xCondPrefix), 2,
	0x66, 7202,
	0x0, 7196,
	/*7196*/ uint16(xSetOp), uint16(PSRLW),
	/*7198*/ uint16(xReadSlashR),
	/*7199*/ uint16(xArgMm),
	/*7200*/ uint16(xArgMmM64),
	/*7201*/ uint16(xMatch),
	/*7202*/ uint16(xSetOp), uint16(PSRLW),
	/*7204*/ uint16(xReadSlashR),
	/*7205*/ uint16(xArgXmm1),
	/*7206*/ uint16(xArgXmm2M128),
	/*7207*/ uint16(xMatch),
	/*7208*/ uint16(xCondPrefix), 2,
	0x66, 7220,
	0x0, 7214,
	/*7214*/ uint16(xSetOp), uint16(PSRLD),
	/*7216*/ uint16(xReadSlashR),
	/*7217*/ uint16(xArgMm),
	/*7218*/ uint16(xArgMmM64),
	/*7219*/ uint16(xMatch),
	/*7220*/ uint16(xSetOp), uint16(PSRLD),
	/*7222*/ uint16(xReadSlashR),
	/*7223*/ uint16(xArgXmm1),
	/*7224*/ uint16(xArgXmm2M128),
	/*7225*/ uint16(xMatch),
	/*7226*/ uint16(xCondPrefix), 2,
	0x66, 7238,
	0x0, 7232,
	/*7232*/ uint16(xSetOp), uint16(PSRLQ),
	/*7234*/ uint16(xReadSlashR),
	/*7235*/ uint16(xArgMm),
	/*7236*/ uint16(xArgMmM64),
	/*7237*/ uint16(xMatch),
	/*7238*/ uint16(xSetOp), uint16(PSRLQ),
	/*7240*/ uint16(xReadSlashR),
	/*7241*/ uint16(xArgXmm1),
	/*7242*/ uint16(xArgXmm2M128),
	/*7243*/ uint16(xMatch),
	/*7244*/ uint16(xCondPrefix), 2,
	0x66, 7256,
	0x0, 7250,
	/*7250*/ uint16(xSetOp), uint16(PADDQ),
	/*7252*/ uint16(xReadSlashR),
	/*7253*/ uint16(xArgMm1),
	/*7254*/ uint16(xArgMm2M64),
	/*7255*/ uint16(xMatch),
	/*7256*/ uint16(xSetOp), uint16(PADDQ),
	/*7258*/ uint16(xReadSlashR),
	/*7259*/ uint16(xArgXmm1),
	/*7260*/ uint16(xArgXmm2M128),
	/*7261*/ uint16(xMatch),
	/*7262*/ uint16(xCondPrefix), 2,
	0x66, 7274,
	0x0, 7268,
	/*7268*/ uint16(xSetOp), uint16(PMULLW),
	/*7270*/ uint16(xReadSlashR),
	/*7271*/ uint16(xArgMm),
	/*7272*/ uint16(xArgMmM64),
	/*7273*/ uint16(xMatch),
	/*7274*/ uint16(xSetOp), uint16(PMULLW),
	/*7276*/ uint16(xReadSlashR),
	/*7277*/ uint16(xArgXmm1),
	/*7278*/ uint16(xArgXmm2M128),
	/*7279*/ uint16(xMatch),
	/*7280*/ uint16(xCondPrefix), 3,
	0xF3, 7300,
	0xF2, 7294,
	0x66, 7288,
	/*7288*/ uint16(xSetOp), uint16(MOVQ),
	/*7290*/ uint16(xReadSlashR),
	/*7291*/ uint16(xArgXmm2M64),
	/*7292*/ uint16(xArgXmm1),
	/*7293*/ uint16(xMatch),
	/*7294*/ uint16(xSetOp), uint16(MOVDQ2Q),
	/*7296*/ uint16(xReadSlashR),
	/*7297*/ uint16(xArgMm),
	/*7298*/ uint16(xArgXmm2),
	/*7299*/ uint16(xMatch),
	/*7300*/ uint16(xSetOp), uint16(MOVQ2DQ),
	/*7302*/ uint16(xReadSlashR),
	/*7303*/ uint16(xArgXmm1),
	/*7304*/ uint16(xArgMm2),
	/*7305*/ uint16(xMatch),
	/*7306*/ uint16(xCondPrefix), 2,
	0x66, 7318,
	0x0, 7312,
	/*7312*/ uint16(xSetOp), uint16(PMOVMSKB),
	/*7314*/ uint16(xReadSlashR),
	/*7315*/ uint16(xArgR32),
	/*7316*/ uint16(xArgMm2),
	/*7317*/ uint16(xMatch),
	/*7318*/ uint16(xSetOp), uint16(PMOVMSKB),
	/*7320*/ uint16(xReadSlashR),
	/*7321*/ uint16(xArgR32),
	/*7322*/ uint16(xArgXmm2),
	/*7323*/ uint16(xMatch),
	/*7324*/ uint16(xCondPrefix), 2,
	0x66, 7336,
	0x0, 7330,
	/*7330*/ uint16(xSetOp), uint16(PSUBUSB),
	/*7332*/ uint16(xReadSlashR),
	/*7333*/ uint16(xArgMm),
	/*7334*/ uint16(xArgMmM64),
	/*7335*/ uint16(xMatch),
	/*7336*/ uint16(xSetOp), uint16(PSUBUSB),
	/*7338*/ uint16(xReadSlashR),
	/*7339*/ uint16(xArgXmm1),
	/*7340*/ uint16(xArgXmm2M128),
	/*7341*/ uint16(xMatch),
	/*7342*/ uint16(xCondPrefix), 2,
	0x66, 7354,
	0x0, 7348,
	/*7348*/ uint16(xSetOp), uint16(PSUBUSW),
	/*7350*/ uint16(xReadSlashR),
	/*7351*/ uint16(xArgMm),
	/*7352*/ uint16(xArgMmM64),
	/*7353*/ uint16(xMatch),
	/*7354*/ uint16(xSetOp), uint16(PSUBUSW),
	/*7356*/ uint16(xReadSlashR),
	/*7357*/ uint16(xArgXmm1),
	/*7358*/ uint16(xArgXmm2M128),
	/*7359*/ uint16(xMatch),
	/*7360*/ uint16(xCondPrefix), 2,
	0x66, 7372,
	0x0, 7366,
	/*7366*/ uint16(xSetOp), uint16(PMINUB),
	/*7368*/ uint16(xReadSlashR),
	/*7369*/ uint16(xArgMm1),
	/*7370*/ uint16(xArgMm2M64),
	/*7371*/ uint16(xMatch),
	/*7372*/ uint16(xSetOp), uint16(PMINUB),
	/*7374*/ uint16(xReadSlashR),
	/*7375*/ uint16(xArgXmm1),
	/*7376*/ uint16(xArgXmm2M128),
	/*7377*/ uint16(xMatch),
	/*7378*/ uint16(xCondPrefix), 2,
	0x66, 7390,
	0x0, 7384,
	/*7384*/ uint16(xSetOp), uint16(PAND),
	/*7386*/ uint16(xReadSlashR),
	/*7387*/ uint16(xArgMm),
	/*7388*/ uint16(xArgMmM64),
	/*7389*/ uint16(xMatch),
	/*7390*/ uint16(xSetOp), uint16(PAND),
	/*7392*/ uint16(xReadSlashR),
	/*7393*/ uint16(xArgXmm1),
	/*7394*/ uint16(xArgXmm2M128),
	/*7395*/ uint16(xMatch),
	/*7396*/ uint16(xCondPrefix), 2,
	0x66, 7408,
	0x0, 7402,
	/*7402*/ uint16(xSetOp), uint16(PADDUSB),
	/*7404*/ uint16(xReadSlashR),
	/*7405*/ uint16(xArgMm),
	/*7406*/ uint16(xArgMmM64),
	/*7407*/ uint16(xMatch),
	/*7408*/ uint16(xSetOp), uint16(PADDUSB),
	/*7410*/ uint16(xReadSlashR),
	/*7411*/ uint16(xArgXmm1),
	/*7412*/ uint16(xArgXmm2M128),
	/*7413*/ uint16(xMatch),
	/*7414*/ uint16(xCondPrefix), 2,
	0x66, 7426,
	0x0, 7420,
	/*7420*/ uint16(xSetOp), uint16(PADDUSW),
	/*7422*/ uint16(xReadSlashR),
	/*7423*/ uint16(xArgMm),
	/*7424*/ uint16(xArgMmM64),
	/*7425*/ uint16(xMatch),
	/*7426*/ uint16(xSetOp), uint16(PADDUSW),
	/*7428*/ uint16(xReadSlashR),
	/*7429*/ uint16(xArgXmm1),
	/*7430*/ uint16(xArgXmm2M128),
	/*7431*/ uint16(xMatch),
	/*7432*/ uint16(xCondPrefix), 2,
	0x66, 7444,
	0x0, 7438,
	/*7438*/ uint16(xSetOp), uint16(PMAXUB),
	/*7440*/ uint16(xReadSlashR),
	/*7441*/ uint16(xArgMm1),
	/*7442*/ uint16(xArgMm2M64),
	/*7443*/ uint16(xMatch),
	/*7444*/ uint16(xSetOp), uint16(PMAXUB),
	/*7446*/ uint16(xReadSlashR),
	/*7447*/ uint16(xArgXmm1),
	/*7448*/ uint16(xArgXmm2M128),
	/*7449*/ uint16(xMatch),
	/*7450*/ uint16(xCondPrefix), 2,
	0x66, 7462,
	0x0, 7456,
	/*7456*/ uint16(xSetOp), uint16(PANDN),
	/*7458*/ uint16(xReadSlashR),
	/*7459*/ uint16(xArgMm),
	/*7460*/ uint16(xArgMmM64),
	/*7461*/ uint16(xMatch),
	/*7462*/ uint16(xSetOp), uint16(PANDN),
	/*7464*/ uint16(xReadSlashR),
	/*7465*/ uint16(xArgXmm1),
	/*7466*/ uint16(xArgXmm2M128),
	/*7467*/ uint16(xMatch),
	/*7468*/ uint16(xCondPrefix), 2,
	0x66, 7480,
	0x0, 7474,
	/*7474*/ uint16(xSetOp), uint16(PAVGB),
	/*7476*/ uint16(xReadSlashR),
	/*7477*/ uint16(xArgMm1),
	/*7478*/ uint16(xArgMm2M64),
	/*7479*/ uint16(xMatch),
	/*7480*/ uint16(xSetOp), uint16(PAVGB),
	/*7482*/ uint16(xReadSlashR),
	/*7483*/ uint16(xArgXmm1),
	/*7484*/ uint16(xArgXmm2M128),
	/*7485*/ uint16(xMatch),
	/*7486*/ uint16(xCondPrefix), 2,
	0x66, 7498,
	0x0, 7492,
	/*7492*/ uint16(xSetOp), uint16(PSRAW),
	/*7494*/ uint16(xReadSlashR),
	/*7495*/ uint16(xArgMm),
	/*7496*/ uint16(xArgMmM64),
	/*7497*/ uint16(xMatch),
	/*7498*/ uint16(xSetOp), uint16(PSRAW),
	/*7500*/ uint16(xReadSlashR),
	/*7501*/ uint16(xArgXmm1),
	/*7502*/ uint16(xArgXmm2M128),
	/*7503*/ uint16(xMatch),
	/*7504*/ uint16(xCondPrefix), 2,
	0x66, 7516,
	0x0, 7510,
	/*7510*/ uint16(xSetOp), uint16(PSRAD),
	/*7512*/ uint16(xReadSlashR),
	/*7513*/ uint16(xArgMm),
	/*7514*/ uint16(xArgMmM64),
	/*7515*/ uint16(xMatch),
	/*7516*/ uint16(xSetOp), uint16(PSRAD),
	/*7518*/ uint16(xReadSlashR),
	/*7519*/ uint16(xArgXmm1),
	/*7520*/ uint16(xArgXmm2M128),
	/*7521*/ uint16(xMatch),
	/*7522*/ uint16(xCondPrefix), 2,
	0x66, 7534,
	0x0, 7528,
	/*7528*/ uint16(xSetOp), uint16(PAVGW),
	/*7530*/ uint16(xReadSlashR),
	/*7531*/ uint16(xArgMm1),
	/*7532*/ uint16(xArgMm2M64),
	/*7533*/ uint16(xMatch),
	/*7534*/ uint16(xSetOp), uint16(PAVGW),
	/*7536*/ uint16(xReadSlashR),
	/*7537*/ uint16(xArgXmm1),
	/*7538*/ uint16(xArgXmm2M128),
	/*7539*/ uint16(xMatch),
	/*7540*/ uint16(xCondPrefix), 2,
	0x66, 7552,
	0x0, 7546,
	/*7546*/ uint16(xSetOp), uint16(PMULHUW),
	/*7548*/ uint16(xReadSlashR),
	/*7549*/ uint16(xArgMm1),
	/*7550*/ uint16(xArgMm2M64),
	/*7551*/ uint16(xMatch),
	/*7552*/ uint16(xSetOp), uint16(PMULHUW),
	/*7554*/ uint16(xReadSlashR),
	/*7555*/ uint16(xArgXmm1),
	/*7556*/ uint16(xArgXmm2M128),
	/*7557*/ uint16(xMatch),
	/*7558*/ uint16(xCondPrefix), 2,
	0x66, 7570,
	0x0, 7564,
	/*7564*/ uint16(xSetOp), uint16(PMULHW),
	/*7566*/ uint16(xReadSlashR),
	/*7567*/ uint16(xArgMm),
	/*7568*/ uint16(xArgMmM64),
	/*7569*/ uint16(xMatch),
	/*7570*/ uint16(xSetOp), uint16(PMULHW),
	/*7572*/ uint16(xReadSlashR),
	/*7573*/ uint16(xArgXmm1),
	/*7574*/ uint16(xArgXmm2M128),
	/*7575*/ uint16(xMatch),
	/*7576*/ uint16(xCondPrefix), 3,
	0xF3, 7596,
	0xF2, 7590,
	0x66, 7584,
	/*7584*/ uint16(xSetOp), uint16(CVTTPD2DQ),
	/*7586*/ uint16(xReadSlashR),
	/*7587*/ uint16(xArgXmm1),
	/*7588*/ uint16(xArgXmm2M128),
	/*7589*/ uint16(xMatch),
	/*7590*/ uint16(xSetOp), uint16(CVTPD2DQ),
	/*7592*/ uint16(xReadSlashR),
	/*7593*/ uint16(xArgXmm1),
	/*7594*/ uint16(xArgXmm2M128),
	/*7595*/ uint16(xMatch),
	/*7596*/ uint16(xSetOp), uint16(CVTDQ2PD),
	/*7598*/ uint16(xReadSlashR),
	/*7599*/ uint16(xArgXmm1),
	/*7600*/ uint16(xArgXmm2M64),
	/*7601*/ uint16(xMatch),
	/*7602*/ uint16(xCondPrefix), 2,
	0x66, 7614,
	0x0, 7608,
	/*7608*/ uint16(xSetOp), uint16(MOVNTQ),
	/*7610*/ uint16(xReadSlashR),
	/*7611*/ uint16(xArgM64),
	/*7612*/ uint16(xArgMm),
	/*7613*/ uint16(xMatch),
	/*7614*/ uint16(xSetOp), uint16(MOVNTDQ),
	/*7616*/ uint16(xReadSlashR),
	/*7617*/ uint16(xArgM128),
	/*7618*/ uint16(xArgXmm),
	/*7619*/ uint16(xMatch),
	/*7620*/ uint16(xCondPrefix), 2,
	0x66, 7632,
	0x0, 7626,
	/*7626*/ uint16(xSetOp), uint16(PSUBSB),
	/*7628*/ uint16(xReadSlashR),
	/*7629*/ uint16(xArgMm),
	/*7630*/ uint16(xArgMmM64),
	/*7631*/ uint16(xMatch),
	/*7632*/ uint16(xSetOp), uint16(PSUBSB),
	/*7634*/ uint16(xReadSlashR),
	/*7635*/ uint16(xArgXmm1),
	/*7636*/ uint16(xArgXmm2M128),
	/*7637*/ uint16(xMatch),
	/*7638*/ uint16(xCondPrefix), 2,
	0x66, 7650,
	0x0, 7644,
	/*7644*/ uint16(xSetOp), uint16(PSUBSW),
	/*7646*/ uint16(xReadSlashR),
	/*7647*/ uint16(xArgMm),
	/*7648*/ uint16(xArgMmM64),
	/*7649*/ uint16(xMatch),
	/*7650*/ uint16(xSetOp), uint16(PSUBSW),
	/*7652*/ uint16(xReadSlashR),
	/*7653*/ uint16(xArgXmm1),
	/*7654*/ uint16(xArgXmm2M128),
	/*7655*/ uint16(xMatch),
	/*7656*/ uint16(xCondPrefix), 2,
	0x66, 7668,
	0x0, 7662,
	/*7662*/ uint16(xSetOp), uint16(PMINSW),
	/*7664*/ uint16(xReadSlashR),
	/*7665*/ uint16(xArgMm1),
	/*7666*/ uint16(xArgMm2M64),
	/*7667*/ uint16(xMatch),
	/*7668*/ uint16(xSetOp), uint16(PMINSW),
	/*7670*/ uint16(xReadSlashR),
	/*7671*/ uint16(xArgXmm1),
	/*7672*/ uint16(xArgXmm2M128),
	/*7673*/ uint16(xMatch),
	/*7674*/ uint16(xCondPrefix), 2,
	0x66, 7686,
	0x0, 7680,
	/*7680*/ uint16(xSetOp), uint16(POR),
	/*7682*/ uint16(xReadSlashR),
	/*7683*/ uint16(xArgMm),
	/*7684*/ uint16(xArgMmM64),
	/*7685*/ uint16(xMatch),
	/*7686*/ uint16(xSetOp), uint16(POR),
	/*7688*/ uint16(xReadSlashR),
	/*7689*/ uint16(xArgXmm1),
	/*7690*/ uint16(xArgXmm2M128),
	/*7691*/ uint16(xMatch),
	/*7692*/ uint16(xCondPrefix), 2,
	0x66, 7704,
	0x0, 7698,
	/*7698*/ uint16(xSetOp), uint16(PADDSB),
	/*7700*/ uint16(xReadSlashR),
	/*7701*/ uint16(xArgMm),
	/*7702*/ uint16(xArgMmM64),
	/*7703*/ uint16(xMatch),
	/*7704*/ uint16(xSetOp), uint16(PADDSB),
	/*7706*/ uint16(xReadSlashR),
	/*7707*/ uint16(xArgXmm1),
	/*7708*/ uint16(xArgXmm2M128),
	/*7709*/ uint16(xMatch),
	/*7710*/ uint16(xCondPrefix), 2,
	0x66, 7722,
	0x0, 7716,
	/*7716*/ uint16(xSetOp), uint16(PADDSW),
	/*7718*/ uint16(xReadSlashR),
	/*7719*/ uint16(xArgMm),
	/*7720*/ uint16(xArgMmM64),
	/*7721*/ uint16(xMatch),
	/*7722*/ uint16(xSetOp), uint16(PADDSW),
	/*7724*/ uint16(xReadSlashR),
	/*7725*/ uint16(xArgXmm1),
	/*7726*/ uint16(xArgXmm2M128),
	/*7727*/ uint16(xMatch),
	/*7728*/ uint16(xCondPrefix), 2,
	0x66, 7740,
	0x0, 7734,
	/*7734*/ uint16(xSetOp), uint16(PMAXSW),
	/*7736*/ uint16(xReadSlashR),
	/*7737*/ uint16(xArgMm1),
	/*7738*/ uint16(xArgMm2M64),
	/*7739*/ uint16(xMatch),
	/*7740*/ uint16(xSetOp), uint16(PMAXSW),
	/*7742*/ uint16(xReadSlashR),
	/*7743*/ uint16(xArgXmm1),
	/*7744*/ uint16(xArgXmm2M128),
	/*7745*/ uint16(xMatch),
	/*7746*/ uint16(xCondPrefix), 2,
	0x66, 7758,
	0x0, 7752,
	/*7752*/ uint16(xSetOp), uint16(PXOR),
	/*7754*/ uint16(xReadSlashR),
	/*7755*/ uint16(xArgMm),
	/*7756*/ uint16(xArgMmM64),
	/*7757*/ uint16(xMatch),
	/*7758*/ uint16(xSetOp), uint16(PXOR),
	/*7760*/ uint16(xReadSlashR),
	/*7761*/ uint16(xArgXmm1),
	/*7762*/ uint16(xArgXmm2M128),
	/*7763*/ uint16(xMatch),
	/*7764*/ uint16(xCondPrefix), 1,
	0xF2, 7768,
	/*7768*/ uint16(xSetOp), uint16(LDDQU),
	/*7770*/ uint16(xReadSlashR),
	/*7771*/ uint16(xArgXmm1),
	/*7772*/ uint16(xArgM128),
	/*7773*/ uint16(xMatch),
	/*7774*/ uint16(xCondPrefix), 2,
	0x66, 7786,
	0x0, 7780,
	/*7780*/ uint16(xSetOp), uint16(PSLLW),
	/*7782*/ uint16(xReadSlashR),
	/*7783*/ uint16(xArgMm),
	/*7784*/ uint16(xArgMmM64),
	/*7785*/ uint16(xMatch),
	/*7786*/ uint16(xSetOp), uint16(PSLLW),
	/*7788*/ uint16(xReadSlashR),
	/*7789*/ uint16(xArgXmm1),
	/*7790*/ uint16(xArgXmm2M128),
	/*7791*/ uint16(xMatch),
	/*7792*/ uint16(xCondPrefix), 2,
	0x66, 7804,
	0x0, 7798,
	/*7798*/ uint16(xSetOp), uint16(PSLLD),
	/*7800*/ uint16(xReadSlashR),
	/*7801*/ uint16(xArgMm),
	/*7802*/ uint16(xArgMmM64),
	/*7803*/ uint16(xMatch),
	/*7804*/ uint16(xSetOp), uint16(PSLLD),
	/*7806*/ uint16(xReadSlashR),
	/*7807*/ uint16(xArgXmm1),
	/*7808*/ uint16(xArgXmm2M128),
	/*7809*/ uint16(xMatch),
	/*7810*/ uint16(xCondPrefix), 2,
	0x66, 7822,
	0x0, 7816,
	/*7816*/ uint16(xSetOp), uint16(PSLLQ),
	/*7818*/ uint16(xReadSlashR),
	/*7819*/ uint16(xArgMm),
	/*7820*/ uint16(xArgMmM64),
	/*7821*/ uint16(xMatch),
	/*7822*/ uint16(xSetOp), uint16(PSLLQ),
	/*7824*/ uint16(xReadSlashR),
	/*7825*/ uint16(xArgXmm1),
	/*7826*/ uint16(xArgXmm2M128),
	/*7827*/ uint16(xMatch),
	/*7828*/ uint16(xCondPrefix), 2,
	0x66, 7840,
	0x0, 7834,
	/*7834*/ uint16(xSetOp), uint16(PMULUDQ),
	/*7836*/ uint16(xReadSlashR),
	/*7837*/ uint16(xArgMm1),
	/*7838*/ uint16(xArgMm2M64),
	/*7839*/ uint16(xMatch),
	/*7840*/ uint16(xSetOp), uint16(PMULUDQ),
	/*7842*/ uint16(xReadSlashR),
	/*7843*/ uint16(xArgXmm1),
	/*7844*/ uint16(xArgXmm2M128),
	/*7845*/ uint16(xMatch),
	/*7846*/ uint16(xCondPrefix), 2,
	0x66, 7858,
	0x0, 7852,
	/*7852*/ uint16(xSetOp), uint16(PMADDWD),
	/*7854*/ uint16(xReadSlashR),
	/*7855*/ uint16(xArgMm),
	/*7856*/ uint16(xArgMmM64),
	/*7857*/ uint16(xMatch),
	/*7858*/ uint16(xSetOp), uint16(PMADDWD),
	/*7860*/ uint16(xReadSlashR),
	/*7861*/ uint16(xArgXmm1),
	/*7862*/ uint16(xArgXmm2M128),
	/*7863*/ uint16(xMatch),
	/*7864*/ uint16(xCondPrefix), 2,
	0x66, 7876,
	0x0, 7870,
	/*7870*/ uint16(xSetOp), uint16(PSADBW),
	/*7872*/ uint16(xReadSlashR),
	/*7873*/ uint16(xArgMm1),
	/*7874*/ uint16(xArgMm2M64),
	/*7875*/ uint16(xMatch),
	/*7876*/ uint16(xSetOp), uint16(PSADBW),
	/*7878*/ uint16(xReadSlashR),
	/*7879*/ uint16(xArgXmm1),
	/*7880*/ uint16(xArgXmm2M128),
	/*7881*/ uint16(xMatch),
	/*7882*/ uint16(xCondPrefix), 2,
	0x66, 7894,
	0x0, 7888,
	/*7888*/ uint16(xSetOp), uint16(MASKMOVQ),
	/*7890*/ uint16(xReadSlashR),
	/*7891*/ uint16(xArgMm1),
	/*7892*/ uint16(xArgMm2),
	/*7893*/ uint16(xMatch),
	/*7894*/ uint16(xSetOp), uint16(MASKMOVDQU),
	/*7896*/ uint16(xReadSlashR),
	/*7897*/ uint16(xArgXmm1),
	/*7898*/ uint16(xArgXmm2),
	/*7899*/ uint16(xMatch),
	/*7900*/ uint16(xCondPrefix), 2,
	0x66, 7912,
	0x0, 7906,
	/*7906*/ uint16(xSetOp), uint16(PSUBB),
	/*7908*/ uint16(xReadSlashR),
	/*7909*/ uint16(xArgMm),
	/*7910*/ uint16(xArgMmM64),
	/*7911*/ uint16(xMatch),
	/*7912*/ uint16(xSetOp), uint16(PSUBB),
	/*7914*/ uint16(xReadSlashR),
	/*7915*/ uint16(xArgXmm1),
	/*7916*/ uint16(xArgXmm2M128),
	/*7917*/ uint16(xMatch),
	/*7918*/ uint16(xCondPrefix), 2,
	0x66, 7930,
	0x0, 7924,
	/*7924*/ uint16(xSetOp), uint16(PSUBW),
	/*7926*/ uint16(xReadSlashR),
	/*7927*/ uint16(xArgMm),
	/*7928*/ uint16(xArgMmM64),
	/*7929*/ uint16(xMatch),
	/*7930*/ uint16(xSetOp), uint16(PSUBW),
	/*7932*/ uint16(xReadSlashR),
	/*7933*/ uint16(xArgXmm1),
	/*7934*/ uint16(xArgXmm2M128),
	/*7935*/ uint16(xMatch),
	/*7936*/ uint16(xCondPrefix), 2,
	0x66, 7948,
	0x0, 7942,
	/*7942*/ uint16(xSetOp), uint16(PSUBD),
	/*7944*/ uint16(xReadSlashR),
	/*7945*/ uint16(xArgMm),
	/*7946*/ uint16(xArgMmM64),
	/*7947*/ uint16(xMatch),
	/*7948*/ uint16(xSetOp), uint16(PSUBD),
	/*7950*/ uint16(xReadSlashR),
	/*7951*/ uint16(xArgXmm1),
	/*7952*/ uint16(xArgXmm2M128),
	/*7953*/ uint16(xMatch),
	/*7954*/ uint16(xCondPrefix), 2,
	0x66, 7966,
	0x0, 7960,
	/*7960*/ uint16(xSetOp), uint16(PSUBQ),
	/*7962*/ uint16(xReadSlashR),
	/*7963*/ uint16(xArgMm1),
	/*7964*/ uint16(xArgMm2M64),
	/*7965*/ uint16(xMatch),
	/*7966*/ uint16(xSetOp), uint16(PSUBQ),
	/*7968*/ uint16(xReadSlashR),
	/*7969*/ uint16(xArgXmm1),
	/*7970*/ uint16(xArgXmm2M128),
	/*7971*/ uint16(xMatch),
	/*7972*/ uint16(xCondPrefix), 2,
	0x66, 7984,
	0x0, 7978,
	/*7978*/ uint16(xSetOp), uint16(PADDB),
	/*7980*/ uint16(xReadSlashR),
	/*7981*/ uint16(xArgMm),
	/*7982*/ uint16(xArgMmM64),
	/*7983*/ uint16(xMatch),
	/*7984*/ uint16(xSetOp), uint16(PADDB),
	/*7986*/ uint16(xReadSlashR),
	/*7987*/ uint16(xArgXmm1),
	/*7988*/ uint16(xArgXmm2M128),
	/*7989*/ uint16(xMatch),
	/*7990*/ uint16(xCondPrefix), 2,
	0x66, 8002,
	0x0, 7996,
	/*7996*/ uint16(xSetOp), uint16(PADDW),
	/*7998*/ uint16(xReadSlashR),
	/*7999*/ uint16(xArgMm),
	/*8000*/ uint16(xArgMmM64),
	/*8001*/ uint16(xMatch),
	/*8002*/ uint16(xSetOp), uint16(PADDW),
	/*8004*/ uint16(xReadSlashR),
	/*8005*/ uint16(xArgXmm1),
	/*8006*/ uint16(xArgXmm2M128),
	/*8007*/ uint16(xMatch),
	/*8008*/ uint16(xCondPrefix), 2,
	0x66, 8020,
	0x0, 8014,
	/*8014*/ uint16(xSetOp), uint16(PADDD),
	/*8016*/ uint16(xReadSlashR),
	/*8017*/ uint16(xArgMm),
	/*8018*/ uint16(xArgMmM64),
	/*8019*/ uint16(xMatch),
	/*8020*/ uint16(xSetOp), uint16(PADDD),
	/*8022*/ uint16(xReadSlashR),
	/*8023*/ uint16(xArgXmm1),
	/*8024*/ uint16(xArgXmm2M128),
	/*8025*/ uint16(xMatch),
	/*8026*/ uint16(xSetOp), uint16(ADC),
	/*8028*/ uint16(xReadSlashR),
	/*8029*/ uint16(xArgRM8),
	/*8030*/ uint16(xArgR8),
	/*8031*/ uint16(xMatch),
	/*8032*/ uint16(xCondIs64), 8035, 8051,
	/*8035*/ uint16(xCondDataSize), 8039, 8045, 0,
	/*8039*/ uint16(xSetOp), uint16(ADC),
	/*8041*/ uint16(xReadSlashR),
	/*8042*/ uint16(xArgRM16),
	/*8043*/ uint16(xArgR16),
	/*8044*/ uint16(xMatch),
	/*8045*/ uint16(xSetOp), uint16(ADC),
	/*8047*/ uint16(xReadSlashR),
	/*8048*/ uint16(xArgRM32),
	/*8049*/ uint16(xArgR32),
	/*8050*/ uint16(xMatch),
	/*8051*/ uint16(xCondDataSize), 8039, 8045, 8055,
	/*8055*/ uint16(xSetOp), uint16(ADC),
	/*8057*/ uint16(xReadSlashR),
	/*8058*/ uint16(xArgRM64),
	/*8059*/ uint16(xArgR64),
	/*8060*/ uint16(xMatch),
	/*8061*/ uint16(xSetOp), uint16(ADC),
	/*8063*/ uint16(xReadSlashR),
	/*8064*/ uint16(xArgR8),
	/*8065*/ uint16(xArgRM8),
	/*8066*/ uint16(xMatch),
	/*8067*/ uint16(xCondIs64), 8070, 8086,
	/*8070*/ uint16(xCondDataSize), 8074, 8080, 0,
	/*8074*/ uint16(xSetOp), uint16(ADC),
	/*8076*/ uint16(xReadSlashR),
	/*8077*/ uint16(xArgR16),
	/*8078*/ uint16(xArgRM16),
	/*8079*/ uint16(xMatch),
	/*8080*/ uint16(xSetOp), uint16(ADC),
	/*8082*/ uint16(xReadSlashR),
	/*8083*/ uint16(xArgR32),
	/*8084*/ uint16(xArgRM32),
	/*8085*/ uint16(xMatch),
	/*8086*/ uint16(xCondDataSize), 8074, 8080, 8090,
	/*8090*/ uint16(xSetOp), uint16(ADC),
	/*8092*/ uint16(xReadSlashR),
	/*8093*/ uint16(xArgR64),
	/*8094*/ uint16(xArgRM64),
	/*8095*/ uint16(xMatch),
	/*8096*/ uint16(xSetOp), uint16(ADC),
	/*8098*/ uint16(xReadIb),
	/*8099*/ uint16(xArgAL),
	/*8100*/ uint16(xArgImm8u),
	/*8101*/ uint16(xMatch),
	/*8102*/ uint16(xCondIs64), 8105, 8121,
	/*8105*/ uint16(xCondDataSize), 8109, 8115, 0,
	/*8109*/ uint16(xSetOp), uint16(ADC),
	/*8111*/ uint16(xReadIw),
	/*8112*/ uint16(xArgAX),
	/*8113*/ uint16(xArgImm16),
	/*8114*/ uint16(xMatch),
	/*8115*/ uint16(xSetOp), uint16(ADC),
	/*8117*/ uint16(xReadId),
	/*8118*/ uint16(xArgEAX),
	/*8119*/ uint16(xArgImm32),
	/*8120*/ uint16(xMatch),
	/*8121*/ uint16(xCondDataSize), 8109, 8115, 8125,
	/*8125*/ uint16(xSetOp), uint16(ADC),
	/*8127*/ uint16(xReadId),
	/*8128*/ uint16(xArgRAX),
	/*8129*/ uint16(xArgImm32),
	/*8130*/ uint16(xMatch),
	/*8131*/ uint16(xCondIs64), 8134, 0,
	/*8134*/ uint16(xSetOp), uint16(PUSH),
	/*8136*/ uint16(xArgSS),
	/*8137*/ uint16(xMatch),
	/*8138*/ uint16(xCondIs64), 8141, 0,
	/*8141*/ uint16(xSetOp), uint16(POP),
	/*8143*/ uint16(xArgSS),
	/*8144*/ uint16(xMatch),
	/*8145*/ uint16(xSetOp), uint16(SBB),
	/*8147*/ uint16(xReadSlashR),
	/*8148*/ uint16(xArgRM8),
	/*8149*/ uint16(xArgR8),
	/*8150*/ uint16(xMatch),
	/*8151*/ uint16(xCondIs64), 8154, 8170,
	/*8154*/ uint16(xCondDataSize), 8158, 8164, 0,
	/*8158*/ uint16(xSetOp), uint16(SBB),
	/*8160*/ uint16(xReadSlashR),
	/*8161*/ uint16(xArgRM16),
	/*8162*/ uint16(xArgR16),
	/*8163*/ uint16(xMatch),
	/*8164*/ uint16(xSetOp), uint16(SBB),
	/*8166*/ uint16(xReadSlashR),
	/*8167*/ uint16(xArgRM32),
	/*8168*/ uint16(xArgR32),
	/*8169*/ uint16(xMatch),
	/*8170*/ uint16(xCondDataSize), 8158, 8164, 8174,
	/*8174*/ uint16(xSetOp), uint16(SBB),
	/*8176*/ uint16(xReadSlashR),
	/*8177*/ uint16(xArgRM64),
	/*8178*/ uint16(xArgR64),
	/*8179*/ uint16(xMatch),
	/*8180*/ uint16(xSetOp), uint16(SBB),
	/*8182*/ uint16(xReadSlashR),
	/*8183*/ uint16(xArgR8),
	/*8184*/ uint16(xArgRM8),
	/*8185*/ uint16(xMatch),
	/*8186*/ uint16(xCondIs64), 8189, 8205,
	/*8189*/ uint16(xCondDataSize), 8193, 8199, 0,
	/*8193*/ uint16(xSetOp), uint16(SBB),
	/*8195*/ uint16(xReadSlashR),
	/*8196*/ uint16(xArgR16),
	/*8197*/ uint16(xArgRM16),
	/*8198*/ uint16(xMatch),
	/*8199*/ uint16(xSetOp), uint16(SBB),
	/*8201*/ uint16(xReadSlashR),
	/*8202*/ uint16(xArgR32),
	/*8203*/ uint16(xArgRM32),
	/*8204*/ uint16(xMatch),
	/*8205*/ uint16(xCondDataSize), 8193, 8199, 8209,
	/*8209*/ uint16(xSetOp), uint16(SBB),
	/*8211*/ uint16(xReadSlashR),
	/*8212*/ uint16(xArgR64),
	/*8213*/ uint16(xArgRM64),
	/*8214*/ uint16(xMatch),
	/*8215*/ uint16(xSetOp), uint16(SBB),
	/*8217*/ uint16(xReadIb),
	/*8218*/ uint16(xArgAL),
	/*8219*/ uint16(xArgImm8u),
	/*8220*/ uint16(xMatch),
	/*8221*/ uint16(xCondIs64), 8224, 8240,
	/*8224*/ uint16(xCondDataSize), 8228, 8234, 0,
	/*8228*/ uint16(xSetOp), uint16(SBB),
	/*8230*/ uint16(xReadIw),
	/*8231*/ uint16(xArgAX),
	/*8232*/ uint16(xArgImm16),
	/*8233*/ uint16(xMatch),
	/*8234*/ uint16(xSetOp), uint16(SBB),
	/*8236*/ uint16(xReadId),
	/*8237*/ uint16(xArgEAX),
	/*8238*/ uint16(xArgImm32),
	/*8239*/ uint16(xMatch),
	/*8240*/ uint16(xCondDataSize), 8228, 8234, 8244,
	/*8244*/ uint16(xSetOp), uint16(SBB),
	/*8246*/ uint16(xReadId),
	/*8247*/ uint16(xArgRAX),
	/*8248*/ uint16(xArgImm32),
	/*8249*/ uint16(xMatch),
	/*8250*/ uint16(xCondIs64), 8253, 0,
	/*8253*/ uint16(xSetOp), uint16(PUSH),
	/*8255*/ uint16(xArgDS),
	/*8256*/ uint16(xMatch),
	/*8257*/ uint16(xCondIs64), 8260, 0,
	/*8260*/ uint16(xSetOp), uint16(POP),
	/*8262*/ uint16(xArgDS),
	/*8263*/ uint16(xMatch),
	/*8264*/ uint16(xSetOp), uint16(AND),
	/*8266*/ uint16(xReadSlashR),
	/*8267*/ uint16(xArgRM8),
	/*8268*/ uint16(xArgR8),
	/*8269*/ uint16(xMatch),
	/*8270*/ uint16(xCondIs64), 8273, 8289,
	/*8273*/ uint16(xCondDataSize), 8277, 8283, 0,
	/*8277*/ uint16(xSetOp), uint16(AND),
	/*8279*/ uint16(xReadSlashR),
	/*8280*/ uint16(xArgRM16),
	/*8281*/ uint16(xArgR16),
	/*8282*/ uint16(xMatch),
	/*8283*/ uint16(xSetOp), uint16(AND),
	/*8285*/ uint16(xReadSlashR),
	/*8286*/ uint16(xArgRM32),
	/*8287*/ uint16(xArgR32),
	/*8288*/ uint16(xMatch),
	/*8289*/ uint16(xCondDataSize), 8277, 8283, 8293,
	/*8293*/ uint16(xSetOp), uint16(AND),
	/*8295*/ uint16(xReadSlashR),
	/*8296*/ uint16(xArgRM64),
	/*8297*/ uint16(xArgR64),
	/*8298*/ uint16(xMatch),
	/*8299*/ uint16(xSetOp), uint16(AND),
	/*8301*/ uint16(xReadSlashR),
	/*8302*/ uint16(xArgR8),
	/*8303*/ uint16(xArgRM8),
	/*8304*/ uint16(xMatch),
	/*8305*/ uint16(xCondIs64), 8308, 8324,
	/*8308*/ uint16(xCondDataSize), 8312, 8318, 0,
	/*8312*/ uint16(xSetOp), uint16(AND),
	/*8314*/ uint16(xReadSlashR),
	/*8315*/ uint16(xArgR16),
	/*8316*/ uint16(xArgRM16),
	/*8317*/ uint16(xMatch),
	/*8318*/ uint16(xSetOp), uint16(AND),
	/*8320*/ uint16(xReadSlashR),
	/*8321*/ uint16(xArgR32),
	/*8322*/ uint16(xArgRM32),
	/*8323*/ uint16(xMatch),
	/*8324*/ uint16(xCondDataSize), 8312, 8318, 8328,
	/*8328*/ uint16(xSetOp), uint16(AND),
	/*8330*/ uint16(xReadSlashR),
	/*8331*/ uint16(xArgR64),
	/*8332*/ uint16(xArgRM64),
	/*8333*/ uint16(xMatch),
	/*8334*/ uint16(xSetOp), uint16(AND),
	/*8336*/ uint16(xReadIb),
	/*8337*/ uint16(xArgAL),
	/*8338*/ uint16(xArgImm8u),
	/*8339*/ uint16(xMatch),
	/*8340*/ uint16(xCondIs64), 8343, 8359,
	/*8343*/ uint16(xCondDataSize), 8347, 8353, 0,
	/*8347*/ uint16(xSetOp), uint16(AND),
	/*8349*/ uint16(xReadIw),
	/*8350*/ uint16(xArgAX),
	/*8351*/ uint16(xArgImm16),
	/*8352*/ uint16(xMatch),
	/*8353*/ uint16(xSetOp), uint16(AND),
	/*8355*/ uint16(xReadId),
	/*8356*/ uint16(xArgEAX),
	/*8357*/ uint16(xArgImm32),
	/*8358*/ uint16(xMatch),
	/*8359*/ uint16(xCondDataSize), 8347, 8353, 8363,
	/*8363*/ uint16(xSetOp), uint16(AND),
	/*8365*/ uint16(xReadId),
	/*8366*/ uint16(xArgRAX),
	/*8367*/ uint16(xArgImm32),
	/*8368*/ uint16(xMatch),
	/*8369*/ uint16(xCondIs64), 8372, 0,
	/*8372*/ uint16(xSetOp), uint16(DAA),
	/*8374*/ uint16(xMatch),
	/*8375*/ uint16(xSetOp), uint16(SUB),
	/*8377*/ uint16(xReadSlashR),
	/*8378*/ uint16(xArgRM8),
	/*8379*/ uint16(xArgR8),
	/*8380*/ uint16(xMatch),
	/*8381*/ uint16(xCondIs64), 8384, 8400,
	/*8384*/ uint16(xCondDataSize), 8388, 8394, 0,
	/*8388*/ uint16(xSetOp), uint16(SUB),
	/*8390*/ uint16(xReadSlashR),
	/*8391*/ uint16(xArgRM16),
	/*8392*/ uint16(xArgR16),
	/*8393*/ uint16(xMatch),
	/*8394*/ uint16(xSetOp), uint16(SUB),
	/*8396*/ uint16(xReadSlashR),
	/*8397*/ uint16(xArgRM32),
	/*8398*/ uint16(xArgR32),
	/*8399*/ uint16(xMatch),
	/*8400*/ uint16(xCondDataSize), 8388, 8394, 8404,
	/*8404*/ uint16(xSetOp), uint16(SUB),
	/*8406*/ uint16(xReadSlashR),
	/*8407*/ uint16(xArgRM64),
	/*8408*/ uint16(xArgR64),
	/*8409*/ uint16(xMatch),
	/*8410*/ uint16(xSetOp), uint16(SUB),
	/*8412*/ uint16(xReadSlashR),
	/*8413*/ uint16(xArgR8),
	/*8414*/ uint16(xArgRM8),
	/*8415*/ uint16(xMatch),
	/*8416*/ uint16(xCondIs64), 8419, 8435,
	/*8419*/ uint16(xCondDataSize), 8423, 8429, 0,
	/*8423*/ uint16(xSetOp), uint16(SUB),
	/*8425*/ uint16(xReadSlashR),
	/*8426*/ uint16(xArgR16),
	/*8427*/ uint16(xArgRM16),
	/*8428*/ uint16(xMatch),
	/*8429*/ uint16(xSetOp), uint16(SUB),
	/*8431*/ uint16(xReadSlashR),
	/*8432*/ uint16(xArgR32),
	/*8433*/ uint16(xArgRM32),
	/*8434*/ uint16(xMatch),
	/*8435*/ uint16(xCondDataSize), 8423, 8429, 8439,
	/*8439*/ uint16(xSetOp), uint16(SUB),
	/*8441*/ uint16(xReadSlashR),
	/*8442*/ uint16(xArgR64),
	/*8443*/ uint16(xArgRM64),
	/*8444*/ uint16(xMatch),
	/*8445*/ uint16(xSetOp), uint16(SUB),
	/*8447*/ uint16(xReadIb),
	/*8448*/ uint16(xArgAL),
	/*8449*/ uint16(xArgImm8u),
	/*8450*/ uint16(xMatch),
	/*8451*/ uint16(xCondIs64), 8454, 8470,
	/*8454*/ uint16(xCondDataSize), 8458, 8464, 0,
	/*8458*/ uint16(xSetOp), uint16(SUB),
	/*8460*/ uint16(xReadIw),
	/*8461*/ uint16(xArgAX),
	/*8462*/ uint16(xArgImm16),
	/*8463*/ uint16(xMatch),
	/*8464*/ uint16(xSetOp), uint16(SUB),
	/*8466*/ uint16(xReadId),
	/*8467*/ uint16(xArgEAX),
	/*8468*/ uint16(xArgImm32),
	/*8469*/ uint16(xMatch),
	/*8470*/ uint16(xCondDataSize), 8458, 8464, 8474,
	/*8474*/ uint16(xSetOp), uint16(SUB),
	/*8476*/ uint16(xReadId),
	/*8477*/ uint16(xArgRAX),
	/*8478*/ uint16(xArgImm32),
	/*8479*/ uint16(xMatch),
	/*8480*/ uint16(xCondIs64), 8483, 0,
	/*8483*/ uint16(xSetOp), uint16(DAS),
	/*8485*/ uint16(xMatch),
	/*8486*/ uint16(xSetOp), uint16(XOR),
	/*8488*/ uint16(xReadSlashR),
	/*8489*/ uint16(xArgRM8),
	/*8490*/ uint16(xArgR8),
	/*8491*/ uint16(xMatch),
	/*8492*/ uint16(xCondIs64), 8495, 8511,
	/*8495*/ uint16(xCondDataSize), 8499, 8505, 0,
	/*8499*/ uint16(xSetOp), uint16(XOR),
	/*8501*/ uint16(xReadSlashR),
	/*8502*/ uint16(xArgRM16),
	/*8503*/ uint16(xArgR16),
	/*8504*/ uint16(xMatch),
	/*8505*/ uint16(xSetOp), uint16(XOR),
	/*8507*/ uint16(xReadSlashR),
	/*8508*/ uint16(xArgRM32),
	/*8509*/ uint16(xArgR32),
	/*8510*/ uint16(xMatch),
	/*8511*/ uint16(xCondDataSize), 8499, 8505, 8515,
	/*8515*/ uint16(xSetOp), uint16(XOR),
	/*8517*/ uint16(xReadSlashR),
	/*8518*/ uint16(xArgRM64),
	/*8519*/ uint16(xArgR64),
	/*8520*/ uint16(xMatch),
	/*8521*/ uint16(xSetOp), uint16(XOR),
	/*8523*/ uint16(xReadSlashR),
	/*8524*/ uint16(xArgR8),
	/*8525*/ uint16(xArgRM8),
	/*8526*/ uint16(xMatch),
	/*8527*/ uint16(xCondIs64), 8530, 8546,
	/*8530*/ uint16(xCondDataSize), 8534, 8540, 0,
	/*8534*/ uint16(xSetOp), uint16(XOR),
	/*8536*/ uint16(xReadSlashR),
	/*8537*/ uint16(xArgR16),
	/*8538*/ uint16(xArgRM16),
	/*8539*/ uint16(xMatch),
	/*8540*/ uint16(xSetOp), uint16(XOR),
	/*8542*/ uint16(xReadSlashR),
	/*8543*/ uint16(xArgR32),
	/*8544*/ uint16(xArgRM32),
	/*8545*/ uint16(xMatch),
	/*8546*/ uint16(xCondDataSize), 8534, 8540, 8550,
	/*8550*/ uint16(xSetOp), uint16(XOR),
	/*8552*/ uint16(xReadSlashR),
	/*8553*/ uint16(xArgR64),
	/*8554*/ uint16(xArgRM64),
	/*8555*/ uint16(xMatch),
	/*8556*/ uint16(xSetOp), uint16(XOR),
	/*8558*/ uint16(xReadIb),
	/*8559*/ uint16(xArgAL),
	/*8560*/ uint16(xArgImm8u),
	/*8561*/ uint16(xMatch),
	/*8562*/ uint16(xCondIs64), 8565, 8581,
	/*8565*/ uint16(xCondDataSize), 8569, 8575, 0,
	/*8569*/ uint16(xSetOp), uint16(XOR),
	/*8571*/ uint16(xReadIw),
	/*8572*/ uint16(xArgAX),
	/*8573*/ uint16(xArgImm16),
	/*8574*/ uint16(xMatch),
	/*8575*/ uint16(xSetOp), uint16(XOR),
	/*8577*/ uint16(xReadId),
	/*8578*/ uint16(xArgEAX),
	/*8579*/ uint16(xArgImm32),
	/*8580*/ uint16(xMatch),
	/*8581*/ uint16(xCondDataSize), 8569, 8575, 8585,
	/*8585*/ uint16(xSetOp), uint16(XOR),
	/*8587*/ uint16(xReadId),
	/*8588*/ uint16(xArgRAX),
	/*8589*/ uint16(xArgImm32),
	/*8590*/ uint16(xMatch),
	/*8591*/ uint16(xCondIs64), 8594, 0,
	/*8594*/ uint16(xSetOp), uint16(AAA),
	/*8596*/ uint16(xMatch),
	/*8597*/ uint16(xSetOp), uint16(CMP),
	/*8599*/ uint16(xReadSlashR),
	/*8600*/ uint16(xArgRM8),
	/*8601*/ uint16(xArgR8),
	/*8602*/ uint16(xMatch),
	/*8603*/ uint16(xCondIs64), 8606, 8622,
	/*8606*/ uint16(xCondDataSize), 8610, 8616, 0,
	/*8610*/ uint16(xSetOp), uint16(CMP),
	/*8612*/ uint16(xReadSlashR),
	/*8613*/ uint16(xArgRM16),
	/*8614*/ uint16(xArgR16),
	/*8615*/ uint16(xMatch),
	/*8616*/ uint16(xSetOp), uint16(CMP),
	/*8618*/ uint16(xReadSlashR),
	/*8619*/ uint16(xArgRM32),
	/*8620*/ uint16(xArgR32),
	/*8621*/ uint16(xMatch),
	/*8622*/ uint16(xCondDataSize), 8610, 8616, 8626,
	/*8626*/ uint16(xSetOp), uint16(CMP),
	/*8628*/ uint16(xReadSlashR),
	/*8629*/ uint16(xArgRM64),
	/*8630*/ uint16(xArgR64),
	/*8631*/ uint16(xMatch),
	/*8632*/ uint16(xSetOp), uint16(CMP),
	/*8634*/ uint16(xReadSlashR),
	/*8635*/ uint16(xArgR8),
	/*8636*/ uint16(xArgRM8),
	/*8637*/ uint16(xMatch),
	/*8638*/ uint16(xCondIs64), 8641, 8657,
	/*8641*/ uint16(xCondDataSize), 8645, 8651, 0,
	/*8645*/ uint16(xSetOp), uint16(CMP),
	/*8647*/ uint16(xReadSlashR),
	/*8648*/ uint16(xArgR16),
	/*8649*/ uint16(xArgRM16),
	/*8650*/ uint16(xMatch),
	/*8651*/ uint16(xSetOp), uint16(CMP),
	/*8653*/ uint16(xReadSlashR),
	/*8654*/ uint16(xArgR32),
	/*8655*/ uint16(xArgRM32),
	/*8656*/ uint16(xMatch),
	/*8657*/ uint16(xCondDataSize), 8645, 8651, 8661,
	/*8661*/ uint16(xSetOp), uint16(CMP),
	/*8663*/ uint16(xReadSlashR),
	/*8664*/ uint16(xArgR64),
	/*8665*/ uint16(xArgRM64),
	/*8666*/ uint16(xMatch),
	/*8667*/ uint16(xSetOp), uint16(CMP),
	/*8669*/ uint16(xReadIb),
	/*8670*/ uint16(xArgAL),
	/*8671*/ uint16(xArgImm8u),
	/*8672*/ uint16(xMatch),
	/*8673*/ uint16(xCondIs64), 8676, 8692,
	/*8676*/ uint16(xCondDataSize), 8680, 8686, 0,
	/*8680*/ uint16(xSetOp), uint16(CMP),
	/*8682*/ uint16(xReadIw),
	/*8683*/ uint16(xArgAX),
	/*8684*/ uint16(xArgImm16),
	/*8685*/ uint16(xMatch),
	/*8686*/ uint16(xSetOp), uint16(CMP),
	/*8688*/ uint16(xReadId),
	/*8689*/ uint16(xArgEAX),
	/*8690*/ uint16(xArgImm32),
	/*8691*/ uint16(xMatch),
	/*8692*/ uint16(xCondDataSize), 8680, 8686, 8696,
	/*8696*/ uint16(xSetOp), uint16(CMP),
	/*8698*/ uint16(xReadId),
	/*8699*/ uint16(xArgRAX),
	/*8700*/ uint16(xArgImm32),
	/*8701*/ uint16(xMatch),
	/*8702*/ uint16(xCondIs64), 8705, 0,
	/*8705*/ uint16(xSetOp), uint16(AAS),
	/*8707*/ uint16(xMatch),
	/*8708*/ uint16(xCondIs64), 8711, 0,
	/*8711*/ uint16(xCondDataSize), 8715, 8719, 0,
	/*8715*/ uint16(xSetOp), uint16(INC),
	/*8717*/ uint16(xArgR16op),
	/*8718*/ uint16(xMatch),
	/*8719*/ uint16(xSetOp), uint16(INC),
	/*8721*/ uint16(xArgR32op),
	/*8722*/ uint16(xMatch),
	/*8723*/ uint16(xCondIs64), 8726, 0,
	/*8726*/ uint16(xCondDataSize), 8730, 8734, 0,
	/*8730*/ uint16(xSetOp), uint16(DEC),
	/*8732*/ uint16(xArgR16op),
	/*8733*/ uint16(xMatch),
	/*8734*/ uint16(xSetOp), uint16(DEC),
	/*8736*/ uint16(xArgR32op),
	/*8737*/ uint16(xMatch),
	/*8738*/ uint16(xCondIs64), 8741, 8753,
	/*8741*/ uint16(xCondDataSize), 8745, 8749, 0,
	/*8745*/ uint16(xSetOp), uint16(PUSH),
	/*8747*/ uint16(xArgR16op),
	/*8748*/ uint16(xMatch),
	/*8749*/ uint16(xSetOp), uint16(PUSH),
	/*8751*/ uint16(xArgR32op),
	/*8752*/ uint16(xMatch),
	/*8753*/ uint16(xCondDataSize), 8745, 8757, 8761,
	/*8757*/ uint16(xSetOp), uint16(PUSH),
	/*8759*/ uint16(xArgR64op),
	/*8760*/ uint16(xMatch),
	/*8761*/ uint16(xSetOp), uint16(PUSH),
	/*8763*/ uint16(xArgR64op),
	/*8764*/ uint16(xMatch),
	/*8765*/ uint16(xCondIs64), 8768, 8780,
	/*8768*/ uint16(xCondDataSize), 8772, 8776, 0,
	/*8772*/ uint16(xSetOp), uint16(POP),
	/*8774*/ uint16(xArgR16op),
	/*8775*/ uint16(xMatch),
	/*8776*/ uint16(xSetOp), uint16(POP),
	/*8778*/ uint16(xArgR32op),
	/*8779*/ uint16(xMatch),
	/*8780*/ uint16(xCondDataSize), 8772, 8784, 8788,
	/*8784*/ uint16(xSetOp), uint16(POP),
	/*8786*/ uint16(xArgR64op),
	/*8787*/ uint16(xMatch),
	/*8788*/ uint16(xSetOp), uint16(POP),
	/*8790*/ uint16(xArgR64op),
	/*8791*/ uint16(xMatch),
	/*8792*/ uint16(xCondIs64), 8795, 0,
	/*8795*/ uint16(xCondDataSize), 8799, 8802, 0,
	/*8799*/ uint16(xSetOp), uint16(PUSHA),
	/*8801*/ uint16(xMatch),
	/*8802*/ uint16(xSetOp), uint16(PUSHAD),
	/*8804*/ uint16(xMatch),
	/*8805*/ uint16(xCondIs64), 8808, 0,
	/*8808*/ uint16(xCondDataSize), 8812, 8815, 0,
	/*8812*/ uint16(xSetOp), uint16(POPA),
	/*8814*/ uint16(xMatch),
	/*8815*/ uint16(xSetOp), uint16(POPAD),
	/*8817*/ uint16(xMatch),
	/*8818*/ uint16(xCondIs64), 8821, 0,
	/*8821*/ uint16(xCondDataSize), 8825, 8831, 0,
	/*8825*/ uint16(xSetOp), uint16(BOUND),
	/*8827*/ uint16(xReadSlashR),
	/*8828*/ uint16(xArgR16),
	/*8829*/ uint16(xArgM16and16),
	/*8830*/ uint16(xMatch),
	/*8831*/ uint16(xSetOp), uint16(BOUND),
	/*8833*/ uint16(xReadSlashR),
	/*8834*/ uint16(xArgR32),
	/*8835*/ uint16(xArgM32and32),
	/*8836*/ uint16(xMatch),
	/*8837*/ uint16(xCondIs64), 8840, 8846,
	/*8840*/ uint16(xSetOp), uint16(ARPL),
	/*8842*/ uint16(xReadSlashR),
	/*8843*/ uint16(xArgRM16),
	/*8844*/ uint16(xArgR16),
	/*8845*/ uint16(xMatch),
	/*8846*/ uint16(xCondDataSize), 8850, 8856, 8862,
	/*8850*/ uint16(xSetOp), uint16(MOVSXD),
	/*8852*/ uint16(xReadSlashR),
	/*8853*/ uint16(xArgR16),
	/*8854*/ uint16(xArgRM32),
	/*8855*/ uint16(xMatch),
	/*8856*/ uint16(xSetOp), uint16(MOVSXD),
	/*8858*/ uint16(xReadSlashR),
	/*8859*/ uint16(xArgR32),
	/*8860*/ uint16(xArgRM32),
	/*8861*/ uint16(xMatch),
	/*8862*/ uint16(xSetOp), uint16(MOVSXD),
	/*8864*/ uint16(xReadSlashR),
	/*8865*/ uint16(xArgR64),
	/*8866*/ uint16(xArgRM32),
	/*8867*/ uint16(xMatch),
	/*8868*/ uint16(xCondDataSize), 8872, 8877, 8882,
	/*8872*/ uint16(xSetOp), uint16(PUSH),
	/*8874*/ uint16(xReadIw),
	/*8875*/ uint16(xArgImm16),
	/*8876*/ uint16(xMatch),
	/*8877*/ uint16(xSetOp), uint16(PUSH),
	/*8879*/ uint16(xReadId),
	/*8880*/ uint16(xArgImm32),
	/*8881*/ uint16(xMatch),
	/*8882*/ uint16(xSetOp), uint16(PUSH),
	/*8884*/ uint16(xReadId),
	/*8885*/ uint16(xArgImm32),
	/*8886*/ uint16(xMatch),
	/*8887*/ uint16(xCondIs64), 8890, 8910,
	/*8890*/ uint16(xCondDataSize), 8894, 8902, 0,
	/*8894*/ uint16(xSetOp), uint16(IMUL),
	/*8896*/ uint16(xReadSlashR),
	/*8897*/ uint16(xReadIw),
	/*8898*/ uint16(xArgR16),
	/*8899*/ uint16(xArgRM16),
	/*8900*/ uint16(xArgImm16),
	/*8901*/ uint16(xMatch),
	/*8902*/ uint16(xSetOp), uint16(IMUL),
	/*8904*/ uint16(xReadSlashR),
	/*8905*/ uint16(xReadId),
	/*8906*/ uint16(xArgR32),
	/*8907*/ uint16(xArgRM32),
	/*8908*/ uint16(xArgImm32),
	/*8909*/ uint16(xMatch),
	/*8910*/ uint16(xCondDataSize), 8894, 8902, 8914,
	/*8914*/ uint16(xSetOp), uint16(IMUL),
	/*8916*/ uint16(xReadSlashR),
	/*8917*/ uint16(xReadId),
	/*8918*/ uint16(xArgR64),
	/*8919*/ uint16(xArgRM64),
	/*8920*/ uint16(xArgImm32),
	/*8921*/ uint16(xMatch),
	/*8922*/ uint16(xSetOp), uint16(PUSH),
	/*8924*/ uint16(xReadIb),
	/*8925*/ uint16(xArgImm8),
	/*8926*/ uint16(xMatch),
	/*8927*/ uint16(xCondIs64), 8930, 8950,
	/*8930*/ uint16(xCondDataSize), 8934, 8942, 0,
	/*8934*/ uint16(xSetOp), uint16(IMUL),
	/*8936*/ uint16(xReadSlashR),
	/*8937*/ uint16(xReadIb),
	/*8938*/ uint16(xArgR16),
	/*8939*/ uint16(xArgRM16),
	/*8940*/ uint16(xArgImm8),
	/*8941*/ uint16(xMatch),
	/*8942*/ uint16(xSetOp), uint16(IMUL),
	/*8944*/ uint16(xReadSlashR),
	/*8945*/ uint16(xReadIb),
	/*8946*/ uint16(xArgR32),
	/*8947*/ uint16(xArgRM32),
	/*8948*/ uint16(xArgImm8),
	/*8949*/ uint16(xMatch),
	/*8950*/ uint16(xCondDataSize), 8934, 8942, 8954,
	/*8954*/ uint16(xSetOp), uint16(IMUL),
	/*8956*/ uint16(xReadSlashR),
	/*8957*/ uint16(xReadIb),
	/*8958*/ uint16(xArgR64),
	/*8959*/ uint16(xArgRM64),
	/*8960*/ uint16(xArgImm8),
	/*8961*/ uint16(xMatch),
	/*8962*/ uint16(xSetOp), uint16(INSB),
	/*8964*/ uint16(xMatch),
	/*8965*/ uint16(xCondDataSize), 8969, 8972, 8975,
	/*8969*/ uint16(xSetOp), uint16(INSW),
	/*8971*/ uint16(xMatch),
	/*8972*/ uint16(xSetOp), uint16(INSD),
	/*8974*/ uint16(xMatch),
	/*8975*/ uint16(xSetOp), uint16(INSD),
	/*8977*/ uint16(xMatch),
	/*8978*/ uint16(xSetOp), uint16(OUTSB),
	/*8980*/ uint16(xMatch),
	/*8981*/ uint16(xCondDataSize), 8985, 8988, 8991,
	/*8985*/ uint16(xSetOp), uint16(OUTSW),
	/*8987*/ uint16(xMatch),
	/*8988*/ uint16(xSetOp), uint16(OUTSD),
	/*8990*/ uint16(xMatch),
	/*8991*/ uint16(xSetOp), uint16(OUTSD),
	/*8993*/ uint16(xMatch),
	/*8994*/ uint16(xSetOp), uint16(JO),
	/*8996*/ uint16(xReadCb),
	/*8997*/ uint16(xArgRel8),
	/*8998*/ uint16(xMatch),
	/*8999*/ uint16(xSetOp), uint16(JNO),
	/*9001*/ uint16(xReadCb),
	/*9002*/ uint16(xArgRel8),
	/*9003*/ uint16(xMatch),
	/*9004*/ uint16(xSetOp), uint16(JB),
	/*9006*/ uint16(xReadCb),
	/*9007*/ uint16(xArgRel8),
	/*9008*/ uint16(xMatch),
	/*9009*/ uint16(xSetOp), uint16(JAE),
	/*9011*/ uint16(xReadCb),
	/*9012*/ uint16(xArgRel8),
	/*9013*/ uint16(xMatch),
	/*9014*/ uint16(xSetOp), uint16(JE),
	/*9016*/ uint16(xReadCb),
	/*9017*/ uint16(xArgRel8),
	/*9018*/ uint16(xMatch),
	/*9019*/ uint16(xSetOp), uint16(JNE),
	/*9021*/ uint16(xReadCb),
	/*9022*/ uint16(xArgRel8),
	/*9023*/ uint16(xMatch),
	/*9024*/ uint16(xSetOp), uint16(JBE),
	/*9026*/ uint16(xReadCb),
	/*9027*/ uint16(xArgRel8),
	/*9028*/ uint16(xMatch),
	/*9029*/ uint16(xSetOp), uint16(JA),
	/*9031*/ uint16(xReadCb),
	/*9032*/ uint16(xArgRel8),
	/*9033*/ uint16(xMatch),
	/*9034*/ uint16(xSetOp), uint16(JS),
	/*9036*/ uint16(xReadCb),
	/*9037*/ uint16(xArgRel8),
	/*9038*/ uint16(xMatch),
	/*9039*/ uint16(xSetOp), uint16(JNS),
	/*9041*/ uint16(xReadCb),
	/*9042*/ uint16(xArgRel8),
	/*9043*/ uint16(xMatch),
	/*9044*/ uint16(xSetOp), uint16(JP),
	/*9046*/ uint16(xReadCb),
	/*9047*/ uint16(xArgRel8),
	/*9048*/ uint16(xMatch),
	/*9049*/ uint16(xSetOp), uint16(JNP),
	/*9051*/ uint16(xReadCb),
	/*9052*/ uint16(xArgRel8),
	/*9053*/ uint16(xMatch),
	/*9054*/ uint16(xSetOp), uint16(JL),
	/*9056*/ uint16(xReadCb),
	/*9057*/ uint16(xArgRel8),
	/*9058*/ uint16(xMatch),
	/*9059*/ uint16(xSetOp), uint16(JGE),
	/*9061*/ uint16(xReadCb),
	/*9062*/ uint16(xArgRel8),
	/*9063*/ uint16(xMatch),
	/*9064*/ uint16(xSetOp), uint16(JLE),
	/*9066*/ uint16(xReadCb),
	/*9067*/ uint16(xArgRel8),
	/*9068*/ uint16(xMatch),
	/*9069*/ uint16(xSetOp), uint16(JG),
	/*9071*/ uint16(xReadCb),
	/*9072*/ uint16(xArgRel8),
	/*9073*/ uint16(xMatch),
	/*9074*/ uint16(xCondSlashR),
	9083, // 0
	9089, // 1
	9095, // 2
	9101, // 3
	9107, // 4
	9113, // 5
	9119, // 6
	9125, // 7
	/*9083*/ uint16(xSetOp), uint16(ADD),
	/*9085*/ uint16(xReadIb),
	/*9086*/ uint16(xArgRM8),
	/*9087*/ uint16(xArgImm8u),
	/*9088*/ uint16(xMatch),
	/*9089*/ uint16(xSetOp), uint16(OR),
	/*9091*/ uint16(xReadIb),
	/*9092*/ uint16(xArgRM8),
	/*9093*/ uint16(xArgImm8u),
	/*9094*/ uint16(xMatch),
	/*9095*/ uint16(xSetOp), uint16(ADC),
	/*9097*/ uint16(xReadIb),
	/*9098*/ uint16(xArgRM8),
	/*9099*/ uint16(xArgImm8u),
	/*9100*/ uint16(xMatch),
	/*9101*/ uint16(xSetOp), uint16(SBB),
	/*9103*/ uint16(xReadIb),
	/*9104*/ uint16(xArgRM8),
	/*9105*/ uint16(xArgImm8u),
	/*9106*/ uint16(xMatch),
	/*9107*/ uint16(xSetOp), uint16(AND),
	/*9109*/ uint16(xReadIb),
	/*9110*/ uint16(xArgRM8),
	/*9111*/ uint16(xArgImm8u),
	/*9112*/ uint16(xMatch),
	/*9113*/ uint16(xSetOp), uint16(SUB),
	/*9115*/ uint16(xReadIb),
	/*9116*/ uint16(xArgRM8),
	/*9117*/ uint16(xArgImm8u),
	/*9118*/ uint16(xMatch),
	/*9119*/ uint16(xSetOp), uint16(XOR),
	/*9121*/ uint16(xReadIb),
	/*9122*/ uint16(xArgRM8),
	/*9123*/ uint16(xArgImm8u),
	/*9124*/ uint16(xMatch),
	/*9125*/ uint16(xSetOp), uint16(CMP),
	/*9127*/ uint16(xReadIb),
	/*9128*/ uint16(xArgRM8),
	/*9129*/ uint16(xArgImm8u),
	/*9130*/ uint16(xMatch),
	/*9131*/ uint16(xCondSlashR),
	9140, // 0
	9169, // 1
	9198, // 2
	9227, // 3
	9256, // 4
	9285, // 5
	9314, // 6
	9343, // 7
	/*9140*/ uint16(xCondIs64), 9143, 9159,
	/*9143*/ uint16(xCondDataSize), 9147, 9153, 0,
	/*9147*/ uint16(xSetOp), uint16(ADD),
	/*9149*/ uint16(xReadIw),
	/*9150*/ uint16(xArgRM16),
	/*9151*/ uint16(xArgImm16),
	/*9152*/ uint16(xMatch),
	/*9153*/ uint16(xSetOp), uint16(ADD),
	/*9155*/ uint16(xReadId),
	/*9156*/ uint16(xArgRM32),
	/*9157*/ uint16(xArgImm32),
	/*9158*/ uint16(xMatch),
	/*9159*/ uint16(xCondDataSize), 9147, 9153, 9163,
	/*9163*/ uint16(xSetOp), uint16(ADD),
	/*9165*/ uint16(xReadId),
	/*9166*/ uint16(xArgRM64),
	/*9167*/ uint16(xArgImm32),
	/*9168*/ uint16(xMatch),
	/*9169*/ uint16(xCondIs64), 9172, 9188,
	/*9172*/ uint16(xCondDataSize), 9176, 9182, 0,
	/*9176*/ uint16(xSetOp), uint16(OR),
	/*9178*/ uint16(xReadIw),
	/*9179*/ uint16(xArgRM16),
	/*9180*/ uint16(xArgImm16),
	/*9181*/ uint16(xMatch),
	/*9182*/ uint16(xSetOp), uint16(OR),
	/*9184*/ uint16(xReadId),
	/*9185*/ uint16(xArgRM32),
	/*9186*/ uint16(xArgImm32),
	/*9187*/ uint16(xMatch),
	/*9188*/ uint16(xCondDataSize), 9176, 9182, 9192,
	/*9192*/ uint16(xSetOp), uint16(OR),
	/*9194*/ uint16(xReadId),
	/*9195*/ uint16(xArgRM64),
	/*9196*/ uint16(xArgImm32),
	/*9197*/ uint16(xMatch),
	/*9198*/ uint16(xCondIs64), 9201, 9217,
	/*9201*/ uint16(xCondDataSize), 9205, 9211, 0,
	/*9205*/ uint16(xSetOp), uint16(ADC),
	/*9207*/ uint16(xReadIw),
	/*9208*/ uint16(xArgRM16),
	/*9209*/ uint16(xArgImm16),
	/*9210*/ uint16(xMatch),
	/*9211*/ uint16(xSetOp), uint16(ADC),
	/*9213*/ uint16(xReadId),
	/*9214*/ uint16(xArgRM32),
	/*9215*/ uint16(xArgImm32),
	/*9216*/ uint16(xMatch),
	/*9217*/ uint16(xCondDataSize), 9205, 9211, 9221,
	/*9221*/ uint16(xSetOp), uint16(ADC),
	/*9223*/ uint16(xReadId),
	/*9224*/ uint16(xArgRM64),
	/*9225*/ uint16(xArgImm32),
	/*9226*/ uint16(xMatch),
	/*9227*/ uint16(xCondIs64), 9230, 9246,
	/*9230*/ uint16(xCondDataSize), 9234, 9240, 0,
	/*9234*/ uint16(xSetOp), uint16(SBB),
	/*9236*/ uint16(xReadIw),
	/*9237*/ uint16(xArgRM16),
	/*9238*/ uint16(xArgImm16),
	/*9239*/ uint16(xMatch),
	/*9240*/ uint16(xSetOp), uint16(SBB),
	/*9242*/ uint16(xReadId),
	/*9243*/ uint16(xArgRM32),
	/*9244*/ uint16(xArgImm32),
	/*9245*/ uint16(xMatch),
	/*9246*/ uint16(xCondDataSize), 9234, 9240, 9250,
	/*9250*/ uint16(xSetOp), uint16(SBB),
	/*9252*/ uint16(xReadId),
	/*9253*/ uint16(xArgRM64),
	/*9254*/ uint16(xArgImm32),
	/*9255*/ uint16(xMatch),
	/*9256*/ uint16(xCondIs64), 9259, 9275,
	/*9259*/ uint16(xCondDataSize), 9263, 9269, 0,
	/*9263*/ uint16(xSetOp), uint16(AND),
	/*9265*/ uint16(xReadIw),
	/*9266*/ uint16(xArgRM16),
	/*9267*/ uint16(xArgImm16),
	/*9268*/ uint16(xMatch),
	/*9269*/ uint16(xSetOp), uint16(AND),
	/*9271*/ uint16(xReadId),
	/*9272*/ uint16(xArgRM32),
	/*9273*/ uint16(xArgImm32),
	/*9274*/ uint16(xMatch),
	/*9275*/ uint16(xCondDataSize), 9263, 9269, 9279,
	/*9279*/ uint16(xSetOp), uint16(AND),
	/*9281*/ uint16(xReadId),
	/*9282*/ uint16(xArgRM64),
	/*9283*/ uint16(xArgImm32),
	/*9284*/ uint16(xMatch),
	/*9285*/ uint16(xCondIs64), 9288, 9304,
	/*9288*/ uint16(xCondDataSize), 9292, 9298, 0,
	/*9292*/ uint16(xSetOp), uint16(SUB),
	/*9294*/ uint16(xReadIw),
	/*9295*/ uint16(xArgRM16),
	/*9296*/ uint16(xArgImm16),
	/*9297*/ uint16(xMatch),
	/*9298*/ uint16(xSetOp), uint16(SUB),
	/*9300*/ uint16(xReadId),
	/*9301*/ uint16(xArgRM32),
	/*9302*/ uint16(xArgImm32),
	/*9303*/ uint16(xMatch),
	/*9304*/ uint16(xCondDataSize), 9292, 9298, 9308,
	/*9308*/ uint16(xSetOp), uint16(SUB),
	/*9310*/ uint16(xReadId),
	/*9311*/ uint16(xArgRM64),
	/*9312*/ uint16(xArgImm32),
	/*9313*/ uint16(xMatch),
	/*9314*/ uint16(xCondIs64), 9317, 9333,
	/*9317*/ uint16(xCondDataSize), 9321, 9327, 0,
	/*9321*/ uint16(xSetOp), uint16(XOR),
	/*9323*/ uint16(xReadIw),
	/*9324*/ uint16(xArgRM16),
	/*9325*/ uint16(xArgImm16),
	/*9326*/ uint16(xMatch),
	/*9327*/ uint16(xSetOp), uint16(XOR),
	/*9329*/ uint16(xReadId),
	/*9330*/ uint16(xArgRM32),
	/*9331*/ uint16(xArgImm32),
	/*9332*/ uint16(xMatch),
	/*9333*/ uint16(xCondDataSize), 9321, 9327, 9337,
	/*9337*/ uint16(xSetOp), uint16(XOR),
	/*9339*/ uint16(xReadId),
	/*9340*/ uint16(xArgRM64),
	/*9341*/ uint16(xArgImm32),
	/*9342*/ uint16(xMatch),
	/*9343*/ uint16(xCondIs64), 9346, 9362,
	/*9346*/ uint16(xCondDataSize), 9350, 9356, 0,
	/*9350*/ uint16(xSetOp), uint16(CMP),
	/*9352*/ uint16(xReadIw),
	/*9353*/ uint16(xArgRM16),
	/*9354*/ uint16(xArgImm16),
	/*9355*/ uint16(xMatch),
	/*9356*/ uint16(xSetOp), uint16(CMP),
	/*9358*/ uint16(xReadId),
	/*9359*/ uint16(xArgRM32),
	/*9360*/ uint16(xArgImm32),
	/*9361*/ uint16(xMatch),
	/*9362*/ uint16(xCondDataSize), 9350, 9356, 9366,
	/*9366*/ uint16(xSetOp), uint16(CMP),
	/*9368*/ uint16(xReadId),
	/*9369*/ uint16(xArgRM64),
	/*9370*/ uint16(xArgImm32),
	/*9371*/ uint16(xMatch),
	/*9372*/ uint16(xCondSlashR),
	9381, // 0
	9410, // 1
	9439, // 2
	9468, // 3
	9497, // 4
	9526, // 5
	9555, // 6
	9584, // 7
	/*9381*/ uint16(xCondIs64), 9384, 9400,
	/*9384*/ uint16(xCondDataSize), 9388, 9394, 0,
	/*9388*/ uint16(xSetOp), uint16(ADD),
	/*9390*/ uint16(xReadIb),
	/*9391*/ uint16(xArgRM16),
	/*9392*/ uint16(xArgImm8),
	/*9393*/ uint16(xMatch),
	/*9394*/ uint16(xSetOp), uint16(ADD),
	/*9396*/ uint16(xReadIb),
	/*9397*/ uint16(xArgRM32),
	/*9398*/ uint16(xArgImm8),
	/*9399*/ uint16(xMatch),
	/*9400*/ uint16(xCondDataSize), 9388, 9394, 9404,
	/*9404*/ uint16(xSetOp), uint16(ADD),
	/*9406*/ uint16(xReadIb),
	/*9407*/ uint16(xArgRM64),
	/*9408*/ uint16(xArgImm8),
	/*9409*/ uint16(xMatch),
	/*9410*/ uint16(xCondIs64), 9413, 9429,
	/*9413*/ uint16(xCondDataSize), 9417, 9423, 0,
	/*9417*/ uint16(xSetOp), uint16(OR),
	/*9419*/ uint16(xReadIb),
	/*9420*/ uint16(xArgRM16),
	/*9421*/ uint16(xArgImm8),
	/*9422*/ uint16(xMatch),
	/*9423*/ uint16(xSetOp), uint16(OR),
	/*9425*/ uint16(xReadIb),
	/*9426*/ uint16(xArgRM32),
	/*9427*/ uint16(xArgImm8),
	/*9428*/ uint16(xMatch),
	/*9429*/ uint16(xCondDataSize), 9417, 9423, 9433,
	/*9433*/ uint16(xSetOp), uint16(OR),
	/*9435*/ uint16(xReadIb),
	/*9436*/ uint16(xArgRM64),
	/*9437*/ uint16(xArgImm8),
	/*9438*/ uint16(xMatch),
	/*9439*/ uint16(xCondIs64), 9442, 9458,
	/*9442*/ uint16(xCondDataSize), 9446, 9452, 0,
	/*9446*/ uint16(xSetOp), uint16(ADC),
	/*9448*/ uint16(xReadIb),
	/*9449*/ uint16(xArgRM16),
	/*9450*/ uint16(xArgImm8),
	/*9451*/ uint16(xMatch),
	/*9452*/ uint16(xSetOp), uint16(ADC),
	/*9454*/ uint16(xReadIb),
	/*9455*/ uint16(xArgRM32),
	/*9456*/ uint16(xArgImm8),
	/*9457*/ uint16(xMatch),
	/*9458*/ uint16(xCondDataSize), 9446, 9452, 9462,
	/*9462*/ uint16(xSetOp), uint16(ADC),
	/*9464*/ uint16(xReadIb),
	/*9465*/ uint16(xArgRM64),
	/*9466*/ uint16(xArgImm8),
	/*9467*/ uint16(xMatch),
	/*9468*/ uint16(xCondIs64), 9471, 9487,
	/*9471*/ uint16(xCondDataSize), 9475, 9481, 0,
	/*9475*/ uint16(xSetOp), uint16(SBB),
	/*9477*/ uint16(xReadIb),
	/*9478*/ uint16(xArgRM16),
	/*9479*/ uint16(xArgImm8),
	/*9480*/ uint16(xMatch),
	/*9481*/ uint16(xSetOp), uint16(SBB),
	/*9483*/ uint16(xReadIb),
	/*9484*/ uint16(xArgRM32),
	/*9485*/ uint16(xArgImm8),
	/*9486*/ uint16(xMatch),
	/*9487*/ uint16(xCondDataSize), 9475, 9481, 9491,
	/*9491*/ uint16(xSetOp), uint16(SBB),
	/*9493*/ uint16(xReadIb),
	/*9494*/ uint16(xArgRM64),
	/*9495*/ uint16(xArgImm8),
	/*9496*/ uint16(xMatch),
	/*9497*/ uint16(xCondIs64), 9500, 9516,
	/*9500*/ uint16(xCondDataSize), 9504, 9510, 0,
	/*9504*/ uint16(xSetOp), uint16(AND),
	/*9506*/ uint16(xReadIb),
	/*9507*/ uint16(xArgRM16),
	/*9508*/ uint16(xArgImm8),
	/*9509*/ uint16(xMatch),
	/*9510*/ uint16(xSetOp), uint16(AND),
	/*9512*/ uint16(xReadIb),
	/*9513*/ uint16(xArgRM32),
	/*9514*/ uint16(xArgImm8),
	/*9515*/ uint16(xMatch),
	/*9516*/ uint16(xCondDataSize), 9504, 9510, 9520,
	/*9520*/ uint16(xSetOp), uint16(AND),
	/*9522*/ uint16(xReadIb),
	/*9523*/ uint16(xArgRM64),
	/*9524*/ uint16(xArgImm8),
	/*9525*/ uint16(xMatch),
	/*9526*/ uint16(xCondIs64), 9529, 9545,
	/*9529*/ uint16(xCondDataSize), 9533, 9539, 0,
	/*9533*/ uint16(xSetOp), uint16(SUB),
	/*9535*/ uint16(xReadIb),
	/*9536*/ uint16(xArgRM16),
	/*9537*/ uint16(xArgImm8),
	/*9538*/ uint16(xMatch),
	/*9539*/ uint16(xSetOp), uint16(SUB),
	/*9541*/ uint16(xReadIb),
	/*9542*/ uint16(xArgRM32),
	/*9543*/ uint16(xArgImm8),
	/*9544*/ uint16(xMatch),
	/*9545*/ uint16(xCondDataSize), 9533, 9539, 9549,
	/*9549*/ uint16(xSetOp), uint16(SUB),
	/*9551*/ uint16(xReadIb),
	/*9552*/ uint16(xArgRM64),
	/*9553*/ uint16(xArgImm8),
	/*9554*/ uint16(xMatch),
	/*9555*/ uint16(xCondIs64), 9558, 9574,
	/*9558*/ uint16(xCondDataSize), 9562, 9568, 0,
	/*9562*/ uint16(xSetOp), uint16(XOR),
	/*9564*/ uint16(xReadIb),
	/*9565*/ uint16(xArgRM16),
	/*9566*/ uint16(xArgImm8),
	/*9567*/ uint16(xMatch),
	/*9568*/ uint16(xSetOp), uint16(XOR),
	/*9570*/ uint16(xReadIb),
	/*9571*/ uint16(xArgRM32),
	/*9572*/ uint16(xArgImm8),
	/*9573*/ uint16(xMatch),
	/*9574*/ uint16(xCondDataSize), 9562, 9568, 9578,
	/*9578*/ uint16(xSetOp), uint16(XOR),
	/*9580*/ uint16(xReadIb),
	/*9581*/ uint16(xArgRM64),
	/*9582*/ uint16(xArgImm8),
	/*9583*/ uint16(xMatch),
	/*9584*/ uint16(xCondIs64), 9587, 9603,
	/*9587*/ uint16(xCondDataSize), 9591, 9597, 0,
	/*9591*/ uint16(xSetOp), uint16(CMP),
	/*9593*/ uint16(xReadIb),
	/*9594*/ uint16(xArgRM16),
	/*9595*/ uint16(xArgImm8),
	/*9596*/ uint16(xMatch),
	/*9597*/ uint16(xSetOp), uint16(CMP),
	/*9599*/ uint16(xReadIb),
	/*9600*/ uint16(xArgRM32),
	/*9601*/ uint16(xArgImm8),
	/*9602*/ uint16(xMatch),
	/*9603*/ uint16(xCondDataSize), 9591, 9597, 9607,
	/*9607*/ uint16(xSetOp), uint16(CMP),
	/*9609*/ uint16(xReadIb),
	/*9610*/ uint16(xArgRM64),
	/*9611*/ uint16(xArgImm8),
	/*9612*/ uint16(xMatch),
	/*9613*/ uint16(xSetOp), uint16(TEST),
	/*9615*/ uint16(xReadSlashR),
	/*9616*/ uint16(xArgRM8),
	/*9617*/ uint16(xArgR8),
	/*9618*/ uint16(xMatch),
	/*9619*/ uint16(xCondIs64), 9622, 9638,
	/*9622*/ uint16(xCondDataSize), 9626, 9632, 0,
	/*9626*/ uint16(xSetOp), uint16(TEST),
	/*9628*/ uint16(xReadSlashR),
	/*9629*/ uint16(xArgRM16),
	/*9630*/ uint16(xArgR16),
	/*9631*/ uint16(xMatch),
	/*9632*/ uint16(xSetOp), uint16(TEST),
	/*9634*/ uint16(xReadSlashR),
	/*9635*/ uint16(xArgRM32),
	/*9636*/ uint16(xArgR32),
	/*9637*/ uint16(xMatch),
	/*9638*/ uint16(xCondDataSize), 9626, 9632, 9642,
	/*9642*/ uint16(xSetOp), uint16(TEST),
	/*9644*/ uint16(xReadSlashR),
	/*9645*/ uint16(xArgRM64),
	/*9646*/ uint16(xArgR64),
	/*9647*/ uint16(xMatch),
	/*9648*/ uint16(xSetOp), uint16(XCHG),
	/*9650*/ uint16(xReadSlashR),
	/*9651*/ uint16(xArgRM8),
	/*9652*/ uint16(xArgR8),
	/*9653*/ uint16(xMatch),
	/*9654*/ uint16(xCondIs64), 9657, 9673,
	/*9657*/ uint16(xCondDataSize), 9661, 9667, 0,
	/*9661*/ uint16(xSetOp), uint16(XCHG),
	/*9663*/ uint16(xReadSlashR),
	/*9664*/ uint16(xArgRM16),
	/*9665*/ uint16(xArgR16),
	/*9666*/ uint16(xMatch),
	/*9667*/ uint16(xSetOp), uint16(XCHG),
	/*9669*/ uint16(xReadSlashR),
	/*9670*/ uint16(xArgRM32),
	/*9671*/ uint16(xArgR32),
	/*9672*/ uint16(xMatch),
	/*9673*/ uint16(xCondDataSize), 9661, 9667, 9677,
	/*9677*/ uint16(xSetOp), uint16(XCHG),
	/*9679*/ uint16(xReadSlashR),
	/*9680*/ uint16(xArgRM64),
	/*9681*/ uint16(xArgR64),
	/*9682*/ uint16(xMatch),
	/*9683*/ uint16(xSetOp), uint16(MOV),
	/*9685*/ uint16(xReadSlashR),
	/*9686*/ uint16(xArgRM8),
	/*9687*/ uint16(xArgR8),
	/*9688*/ uint16(xMatch),
	/*9689*/ uint16(xCondDataSize), 9693, 9699, 9705,
	/*9693*/ uint16(xSetOp), uint16(MOV),
	/*9695*/ uint16(xReadSlashR),
	/*9696*/ uint16(xArgRM16),
	/*9697*/ uint16(xArgR16),
	/*9698*/ uint16(xMatch),
	/*9699*/ uint16(xSetOp), uint16(MOV),
	/*9701*/ uint16(xReadSlashR),
	/*9702*/ uint16(xArgRM32),
	/*9703*/ uint16(xArgR32),
	/*9704*/ uint16(xMatch),
	/*9705*/ uint16(xSetOp), uint16(MOV),
	/*9707*/ uint16(xReadSlashR),
	/*9708*/ uint16(xArgRM64),
	/*9709*/ uint16(xArgR64),
	/*9710*/ uint16(xMatch),
	/*9711*/ uint16(xSetOp), uint16(MOV),
	/*9713*/ uint16(xReadSlashR),
	/*9714*/ uint16(xArgR8),
	/*9715*/ uint16(xArgRM8),
	/*9716*/ uint16(xMatch),
	/*9717*/ uint16(xCondDataSize), 9721, 9727, 9733,
	/*9721*/ uint16(xSetOp), uint16(MOV),
	/*9723*/ uint16(xReadSlashR),
	/*9724*/ uint16(xArgR16),
	/*9725*/ uint16(xArgRM16),
	/*9726*/ uint16(xMatch),
	/*9727*/ uint16(xSetOp), uint16(MOV),
	/*9729*/ uint16(xReadSlashR),
	/*9730*/ uint16(xArgR32),
	/*9731*/ uint16(xArgRM32),
	/*9732*/ uint16(xMatch),
	/*9733*/ uint16(xSetOp), uint16(MOV),
	/*9735*/ uint16(xReadSlashR),
	/*9736*/ uint16(xArgR64),
	/*9737*/ uint16(xArgRM64),
	/*9738*/ uint16(xMatch),
	/*9739*/ uint16(xCondIs64), 9742, 9758,
	/*9742*/ uint16(xCondDataSize), 9746, 9752, 0,
	/*9746*/ uint16(xSetOp), uint16(MOV),
	/*9748*/ uint16(xReadSlashR),
	/*9749*/ uint16(xArgRM16),
	/*9750*/ uint16(xArgSreg),
	/*9751*/ uint16(xMatch),
	/*9752*/ uint16(xSetOp), uint16(MOV),
	/*9754*/ uint16(xReadSlashR),
	/*9755*/ uint16(xArgR32M16),
	/*9756*/ uint16(xArgSreg),
	/*9757*/ uint16(xMatch),
	/*9758*/ uint16(xCondDataSize), 9746, 9752, 9762,
	/*9762*/ uint16(xSetOp), uint16(MOV),
	/*9764*/ uint16(xReadSlashR),
	/*9765*/ uint16(xArgR64M16),
	/*9766*/ uint16(xArgSreg),
	/*9767*/ uint16(xMatch),
	/*9768*/ uint16(xCondIs64), 9771, 9787,
	/*9771*/ uint16(xCondDataSize), 9775, 9781, 0,
	/*9775*/ uint16(xSetOp), uint16(LEA),
	/*9777*/ uint16(xReadSlashR),
	/*9778*/ uint16(xArgR16),
	/*9779*/ uint16(xArgM),
	/*9780*/ uint16(xMatch),
	/*9781*/ uint16(xSetOp), uint16(LEA),
	/*9783*/ uint16(xReadSlashR),
	/*9784*/ uint16(xArgR32),
	/*9785*/ uint16(xArgM),
	/*9786*/ uint16(xMatch),
	/*9787*/ uint16(xCondDataSize), 9775, 9781, 9791,
	/*9791*/ uint16(xSetOp), uint16(LEA),
	/*9793*/ uint16(xReadSlashR),
	/*9794*/ uint16(xArgR64),
	/*9795*/ uint16(xArgM),
	/*9796*/ uint16(xMatch),
	/*9797*/ uint16(xCondIs64), 9800, 9816,
	/*9800*/ uint16(xCondDataSize), 9804, 9810, 0,
	/*9804*/ uint16(xSetOp), uint16(MOV),
	/*9806*/ uint16(xReadSlashR),
	/*9807*/ uint16(xArgSreg),
	/*9808*/ uint16(xArgRM16),
	/*9809*/ uint16(xMatch),
	/*9810*/ uint16(xSetOp), uint16(MOV),
	/*9812*/ uint16(xReadSlashR),
	/*9813*/ uint16(xArgSreg),
	/*9814*/ uint16(xArgR32M16),
	/*9815*/ uint16(xMatch),
	/*9816*/ uint16(xCondDataSize), 9804, 9810, 9820,
	/*9820*/ uint16(xSetOp), uint16(MOV),
	/*9822*/ uint16(xReadSlashR),
	/*9823*/ uint16(xArgSreg),
	/*9824*/ uint16(xArgR64M16),
	/*9825*/ uint16(xMatch),
	/*9826*/ uint16(xCondSlashR),
	9835, // 0
	0,    // 1
	0,    // 2
	0,    // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*9835*/ uint16(xCondIs64), 9838, 9850,
	/*9838*/ uint16(xCondDataSize), 9842, 9846, 0,
	/*9842*/ uint16(xSetOp), uint16(POP),
	/*9844*/ uint16(xArgRM16),
	/*9845*/ uint16(xMatch),
	/*9846*/ uint16(xSetOp), uint16(POP),
	/*9848*/ uint16(xArgRM32),
	/*9849*/ uint16(xMatch),
	/*9850*/ uint16(xCondDataSize), 9842, 9854, 9858,
	/*9854*/ uint16(xSetOp), uint16(POP),
	/*9856*/ uint16(xArgRM64),
	/*9857*/ uint16(xMatch),
	/*9858*/ uint16(xSetOp), uint16(POP),
	/*9860*/ uint16(xArgRM64),
	/*9861*/ uint16(xMatch),
	/*9862*/ uint16(xCondIs64), 9865, 9879,
	/*9865*/ uint16(xCondDataSize), 9869, 9874, 0,
	/*9869*/ uint16(xSetOp), uint16(XCHG),
	/*9871*/ uint16(xArgR16op),
	/*9872*/ uint16(xArgAX),
	/*9873*/ uint16(xMatch),
	/*9874*/ uint16(xSetOp), uint16(XCHG),
	/*9876*/ uint16(xArgR32op),
	/*9877*/ uint16(xArgEAX),
	/*9878*/ uint16(xMatch),
	/*9879*/ uint16(xCondDataSize), 9869, 9874, 9883,
	/*9883*/ uint16(xSetOp), uint16(XCHG),
	/*9885*/ uint16(xArgR64op),
	/*9886*/ uint16(xArgRAX),
	/*9887*/ uint16(xMatch),
	/*9888*/ uint16(xCondIs64), 9891, 9901,
	/*9891*/ uint16(xCondDataSize), 9895, 9898, 0,
	/*9895*/ uint16(xSetOp), uint16(CBW),
	/*9897*/ uint16(xMatch),
	/*9898*/ uint16(xSetOp), uint16(CWDE),
	/*9900*/ uint16(xMatch),
	/*9901*/ uint16(xCondDataSize), 9895, 9898, 9905,
	/*9905*/ uint16(xSetOp), uint16(CDQE),
	/*9907*/ uint16(xMatch),
	/*9908*/ uint16(xCondIs64), 9911, 9921,
	/*9911*/ uint16(xCondDataSize), 9915, 9918, 0,
	/*9915*/ uint16(xSetOp), uint16(CWD),
	/*9917*/ uint16(xMatch),
	/*9918*/ uint16(xSetOp), uint16(CDQ),
	/*9920*/ uint16(xMatch),
	/*9921*/ uint16(xCondDataSize), 9915, 9918, 9925,
	/*9925*/ uint16(xSetOp), uint16(CQO),
	/*9927*/ uint16(xMatch),
	/*9928*/ uint16(xCondIs64), 9931, 0,
	/*9931*/ uint16(xCondDataSize), 9935, 9940, 0,
	/*9935*/ uint16(xSetOp), uint16(LCALL),
	/*9937*/ uint16(xReadCd),
	/*9938*/ uint16(xArgPtr16colon16),
	/*9939*/ uint16(xMatch),
	/*9940*/ uint16(xSetOp), uint16(LCALL),
	/*9942*/ uint16(xReadCp),
	/*9943*/ uint16(xArgPtr16colon32),
	/*9944*/ uint16(xMatch),
	/*9945*/ uint16(xSetOp), uint16(FWAIT),
	/*9947*/ uint16(xMatch),
	/*9948*/ uint16(xCondIs64), 9951, 9961,
	/*9951*/ uint16(xCondDataSize), 9955, 9958, 0,
	/*9955*/ uint16(xSetOp), uint16(PUSHF),
	/*9957*/ uint16(xMatch),
	/*9958*/ uint16(xSetOp), uint16(PUSHFD),
	/*9960*/ uint16(xMatch),
	/*9961*/ uint16(xCondDataSize), 9955, 9965, 9968,
	/*9965*/ uint16(xSetOp), uint16(PUSHFQ),
	/*9967*/ uint16(xMatch),
	/*9968*/ uint16(xSetOp), uint16(PUSHFQ),
	/*9970*/ uint16(xMatch),
	/*9971*/ uint16(xCondIs64), 9974, 9984,
	/*9974*/ uint16(xCondDataSize), 9978, 9981, 0,
	/*9978*/ uint16(xSetOp), uint16(POPF),
	/*9980*/ uint16(xMatch),
	/*9981*/ uint16(xSetOp), uint16(POPFD),
	/*9983*/ uint16(xMatch),
	/*9984*/ uint16(xCondDataSize), 9978, 9988, 9991,
	/*9988*/ uint16(xSetOp), uint16(POPFQ),
	/*9990*/ uint16(xMatch),
	/*9991*/ uint16(xSetOp), uint16(POPFQ),
	/*9993*/ uint16(xMatch),
	/*9994*/ uint16(xSetOp), uint16(SAHF),
	/*9996*/ uint16(xMatch),
	/*9997*/ uint16(xSetOp), uint16(LAHF),
	/*9999*/ uint16(xMatch),
	/*10000*/ uint16(xCondIs64), 10003, 10009,
	/*10003*/ uint16(xSetOp), uint16(MOV),
	/*10005*/ uint16(xReadCm),
	/*10006*/ uint16(xArgAL),
	/*10007*/ uint16(xArgMoffs8),
	/*10008*/ uint16(xMatch),
	/*10009*/ uint16(xCondDataSize), 10003, 10003, 10013,
	/*10013*/ uint16(xSetOp), uint16(MOV),
	/*10015*/ uint16(xReadCm),
	/*10016*/ uint16(xArgAL),
	/*10017*/ uint16(xArgMoffs8),
	/*10018*/ uint16(xMatch),
	/*10019*/ uint16(xCondDataSize), 10023, 10029, 10035,
	/*10023*/ uint16(xSetOp), uint16(MOV),
	/*10025*/ uint16(xReadCm),
	/*10026*/ uint16(xArgAX),
	/*10027*/ uint16(xArgMoffs16),
	/*10028*/ uint16(xMatch),
	/*10029*/ uint16(xSetOp), uint16(MOV),
	/*10031*/ uint16(xReadCm),
	/*10032*/ uint16(xArgEAX),
	/*10033*/ uint16(xArgMoffs32),
	/*10034*/ uint16(xMatch),
	/*10035*/ uint16(xSetOp), uint16(MOV),
	/*10037*/ uint16(xReadCm),
	/*10038*/ uint16(xArgRAX),
	/*10039*/ uint16(xArgMoffs64),
	/*10040*/ uint16(xMatch),
	/*10041*/ uint16(xCondIs64), 10044, 10050,
	/*10044*/ uint16(xSetOp), uint16(MOV),
	/*10046*/ uint16(xReadCm),
	/*10047*/ uint16(xArgMoffs8),
	/*10048*/ uint16(xArgAL),
	/*10049*/ uint16(xMatch),
	/*10050*/ uint16(xCondDataSize), 10044, 10044, 10054,
	/*10054*/ uint16(xSetOp), uint16(MOV),
	/*10056*/ uint16(xReadCm),
	/*10057*/ uint16(xArgMoffs8),
	/*10058*/ uint16(xArgAL),
	/*10059*/ uint16(xMatch),
	/*10060*/ uint16(xCondDataSize), 10064, 10070, 10076,
	/*10064*/ uint16(xSetOp), uint16(MOV),
	/*10066*/ uint16(xReadCm),
	/*10067*/ uint16(xArgMoffs16),
	/*10068*/ uint16(xArgAX),
	/*10069*/ uint16(xMatch),
	/*10070*/ uint16(xSetOp), uint16(MOV),
	/*10072*/ uint16(xReadCm),
	/*10073*/ uint16(xArgMoffs32),
	/*10074*/ uint16(xArgEAX),
	/*10075*/ uint16(xMatch),
	/*10076*/ uint16(xSetOp), uint16(MOV),
	/*10078*/ uint16(xReadCm),
	/*10079*/ uint16(xArgMoffs64),
	/*10080*/ uint16(xArgRAX),
	/*10081*/ uint16(xMatch),
	/*10082*/ uint16(xSetOp), uint16(MOVSB),
	/*10084*/ uint16(xMatch),
	/*10085*/ uint16(xCondIs64), 10088, 10098,
	/*10088*/ uint16(xCondDataSize), 10092, 10095, 0,
	/*10092*/ uint16(xSetOp), uint16(MOVSW),
	/*10094*/ uint16(xMatch),
	/*10095*/ uint16(xSetOp), uint16(MOVSD),
	/*10097*/ uint16(xMatch),
	/*10098*/ uint16(xCondDataSize), 10092, 10095, 10102,
	/*10102*/ uint16(xSetOp), uint16(MOVSQ),
	/*10104*/ uint16(xMatch),
	/*10105*/ uint16(xSetOp), uint16(CMPSB),
	/*10107*/ uint16(xMatch),
	/*10108*/ uint16(xCondIs64), 10111, 10121,
	/*10111*/ uint16(xCondDataSize), 10115, 10118, 0,
	/*10115*/ uint16(xSetOp), uint16(CMPSW),
	/*10117*/ uint16(xMatch),
	/*10118*/ uint16(xSetOp), uint16(CMPSD),
	/*10120*/ uint16(xMatch),
	/*10121*/ uint16(xCondDataSize), 10115, 10118, 10125,
	/*10125*/ uint16(xSetOp), uint16(CMPSQ),
	/*10127*/ uint16(xMatch),
	/*10128*/ uint16(xSetOp), uint16(TEST),
	/*10130*/ uint16(xReadIb),
	/*10131*/ uint16(xArgAL),
	/*10132*/ uint16(xArgImm8u),
	/*10133*/ uint16(xMatch),
	/*10134*/ uint16(xCondIs64), 10137, 10153,
	/*10137*/ uint16(xCondDataSize), 10141, 10147, 0,
	/*10141*/ uint16(xSetOp), uint16(TEST),
	/*10143*/ uint16(xReadIw),
	/*10144*/ uint16(xArgAX),
	/*10145*/ uint16(xArgImm16),
	/*10146*/ uint16(xMatch),
	/*10147*/ uint16(xSetOp), uint16(TEST),
	/*10149*/ uint16(xReadId),
	/*10150*/ uint16(xArgEAX),
	/*10151*/ uint16(xArgImm32),
	/*10152*/ uint16(xMatch),
	/*10153*/ uint16(xCondDataSize), 10141, 10147, 10157,
	/*10157*/ uint16(xSetOp), uint16(TEST),
	/*10159*/ uint16(xReadId),
	/*10160*/ uint16(xArgRAX),
	/*10161*/ uint16(xArgImm32),
	/*10162*/ uint16(xMatch),
	/*10163*/ uint16(xSetOp), uint16(STOSB),
	/*10165*/ uint16(xMatch),
	/*10166*/ uint16(xCondIs64), 10169, 10179,
	/*10169*/ uint16(xCondDataSize), 10173, 10176, 0,
	/*10173*/ uint16(xSetOp), uint16(STOSW),
	/*10175*/ uint16(xMatch),
	/*10176*/ uint16(xSetOp), uint16(STOSD),
	/*10178*/ uint16(xMatch),
	/*10179*/ uint16(xCondDataSize), 10173, 10176, 10183,
	/*10183*/ uint16(xSetOp), uint16(STOSQ),
	/*10185*/ uint16(xMatch),
	/*10186*/ uint16(xSetOp), uint16(LODSB),
	/*10188*/ uint16(xMatch),
	/*10189*/ uint16(xCondIs64), 10192, 10202,
	/*10192*/ uint16(xCondDataSize), 10196, 10199, 0,
	/*10196*/ uint16(xSetOp), uint16(LODSW),
	/*10198*/ uint16(xMatch),
	/*10199*/ uint16(xSetOp), uint16(LODSD),
	/*10201*/ uint16(xMatch),
	/*10202*/ uint16(xCondDataSize), 10196, 10199, 10206,
	/*10206*/ uint16(xSetOp), uint16(LODSQ),
	/*10208*/ uint16(xMatch),
	/*10209*/ uint16(xSetOp), uint16(SCASB),
	/*10211*/ uint16(xMatch),
	/*10212*/ uint16(xCondIs64), 10215, 10225,
	/*10215*/ uint16(xCondDataSize), 10219, 10222, 0,
	/*10219*/ uint16(xSetOp), uint16(SCASW),
	/*10221*/ uint16(xMatch),
	/*10222*/ uint16(xSetOp), uint16(SCASD),
	/*10224*/ uint16(xMatch),
	/*10225*/ uint16(xCondDataSize), 10219, 10222, 10229,
	/*10229*/ uint16(xSetOp), uint16(SCASQ),
	/*10231*/ uint16(xMatch),
	/*10232*/ uint16(xSetOp), uint16(MOV),
	/*10234*/ uint16(xReadIb),
	/*10235*/ uint16(xArgR8op),
	/*10236*/ uint16(xArgImm8u),
	/*10237*/ uint16(xMatch),
	/*10238*/ uint16(xCondIs64), 10241, 10257,
	/*10241*/ uint16(xCondDataSize), 10245, 10251, 0,
	/*10245*/ uint16(xSetOp), uint16(MOV),
	/*10247*/ uint16(xReadIw),
	/*10248*/ uint16(xArgR16op),
	/*10249*/ uint16(xArgImm16),
	/*10250*/ uint16(xMatch),
	/*10251*/ uint16(xSetOp), uint16(MOV),
	/*10253*/ uint16(xReadId),
	/*10254*/ uint16(xArgR32op),
	/*10255*/ uint16(xArgImm32),
	/*10256*/ uint16(xMatch),
	/*10257*/ uint16(xCondDataSize), 10245, 10251, 10261,
	/*10261*/ uint16(xSetOp), uint16(MOV),
	/*10263*/ uint16(xReadIo),
	/*10264*/ uint16(xArgR64op),
	/*10265*/ uint16(xArgImm64),
	/*10266*/ uint16(xMatch),
	/*10267*/ uint16(xCondSlashR),
	10276, // 0
	10282, // 1
	10288, // 2
	10294, // 3
	10300, // 4
	10306, // 5
	0,     // 6
	10312, // 7
	/*10276*/ uint16(xSetOp), uint16(ROL),
	/*10278*/ uint16(xReadIb),
	/*10279*/ uint16(xArgRM8),
	/*10280*/ uint16(xArgImm8u),
	/*10281*/ uint16(xMatch),
	/*10282*/ uint16(xSetOp), uint16(ROR),
	/*10284*/ uint16(xReadIb),
	/*10285*/ uint16(xArgRM8),
	/*10286*/ uint16(xArgImm8u),
	/*10287*/ uint16(xMatch),
	/*10288*/ uint16(xSetOp), uint16(RCL),
	/*10290*/ uint16(xReadIb),
	/*10291*/ uint16(xArgRM8),
	/*10292*/ uint16(xArgImm8u),
	/*10293*/ uint16(xMatch),
	/*10294*/ uint16(xSetOp), uint16(RCR),
	/*10296*/ uint16(xReadIb),
	/*10297*/ uint16(xArgRM8),
	/*10298*/ uint16(xArgImm8u),
	/*10299*/ uint16(xMatch),
	/*10300*/ uint16(xSetOp), uint16(SHL),
	/*10302*/ uint16(xReadIb),
	/*10303*/ uint16(xArgRM8),
	/*10304*/ uint16(xArgImm8u),
	/*10305*/ uint16(xMatch),
	/*10306*/ uint16(xSetOp), uint16(SHR),
	/*10308*/ uint16(xReadIb),
	/*10309*/ uint16(xArgRM8),
	/*10310*/ uint16(xArgImm8u),
	/*10311*/ uint16(xMatch),
	/*10312*/ uint16(xSetOp), uint16(SAR),
	/*10314*/ uint16(xReadIb),
	/*10315*/ uint16(xArgRM8),
	/*10316*/ uint16(xArgImm8u),
	/*10317*/ uint16(xMatch),
	/*10318*/ uint16(xCondSlashR),
	10327, // 0
	10349, // 1
	10371, // 2
	10400, // 3
	10429, // 4
	10458, // 5
	0,     // 6
	10487, // 7
	/*10327*/ uint16(xCondDataSize), 10331, 10337, 10343,
	/*10331*/ uint16(xSetOp), uint16(ROL),
	/*10333*/ uint16(xReadIb),
	/*10334*/ uint16(xArgRM16),
	/*10335*/ uint16(xArgImm8u),
	/*10336*/ uint16(xMatch),
	/*10337*/ uint16(xSetOp), uint16(ROL),
	/*10339*/ uint16(xReadIb),
	/*10340*/ uint16(xArgRM32),
	/*10341*/ uint16(xArgImm8u),
	/*10342*/ uint16(xMatch),
	/*10343*/ uint16(xSetOp), uint16(ROL),
	/*10345*/ uint16(xReadIb),
	/*10346*/ uint16(xArgRM64),
	/*10347*/ uint16(xArgImm8u),
	/*10348*/ uint16(xMatch),
	/*10349*/ uint16(xCondDataSize), 10353, 10359, 10365,
	/*10353*/ uint16(xSetOp), uint16(ROR),
	/*10355*/ uint16(xReadIb),
	/*10356*/ uint16(xArgRM16),
	/*10357*/ uint16(xArgImm8u),
	/*10358*/ uint16(xMatch),
	/*10359*/ uint16(xSetOp), uint16(ROR),
	/*10361*/ uint16(xReadIb),
	/*10362*/ uint16(xArgRM32),
	/*10363*/ uint16(xArgImm8u),
	/*10364*/ uint16(xMatch),
	/*10365*/ uint16(xSetOp), uint16(ROR),
	/*10367*/ uint16(xReadIb),
	/*10368*/ uint16(xArgRM64),
	/*10369*/ uint16(xArgImm8u),
	/*10370*/ uint16(xMatch),
	/*10371*/ uint16(xCondIs64), 10374, 10390,
	/*10374*/ uint16(xCondDataSize), 10378, 10384, 0,
	/*10378*/ uint16(xSetOp), uint16(RCL),
	/*10380*/ uint16(xReadIb),
	/*10381*/ uint16(xArgRM16),
	/*10382*/ uint16(xArgImm8u),
	/*10383*/ uint16(xMatch),
	/*10384*/ uint16(xSetOp), uint16(RCL),
	/*10386*/ uint16(xReadIb),
	/*10387*/ uint16(xArgRM32),
	/*10388*/ uint16(xArgImm8u),
	/*10389*/ uint16(xMatch),
	/*10390*/ uint16(xCondDataSize), 10378, 10384, 10394,
	/*10394*/ uint16(xSetOp), uint16(RCL),
	/*10396*/ uint16(xReadIb),
	/*10397*/ uint16(xArgRM64),
	/*10398*/ uint16(xArgImm8u),
	/*10399*/ uint16(xMatch),
	/*10400*/ uint16(xCondIs64), 10403, 10419,
	/*10403*/ uint16(xCondDataSize), 10407, 10413, 0,
	/*10407*/ uint16(xSetOp), uint16(RCR),
	/*10409*/ uint16(xReadIb),
	/*10410*/ uint16(xArgRM16),
	/*10411*/ uint16(xArgImm8u),
	/*10412*/ uint16(xMatch),
	/*10413*/ uint16(xSetOp), uint16(RCR),
	/*10415*/ uint16(xReadIb),
	/*10416*/ uint16(xArgRM32),
	/*10417*/ uint16(xArgImm8u),
	/*10418*/ uint16(xMatch),
	/*10419*/ uint16(xCondDataSize), 10407, 10413, 10423,
	/*10423*/ uint16(xSetOp), uint16(RCR),
	/*10425*/ uint16(xReadIb),
	/*10426*/ uint16(xArgRM64),
	/*10427*/ uint16(xArgImm8u),
	/*10428*/ uint16(xMatch),
	/*10429*/ uint16(xCondIs64), 10432, 10448,
	/*10432*/ uint16(xCondDataSize), 10436, 10442, 0,
	/*10436*/ uint16(xSetOp), uint16(SHL),
	/*10438*/ uint16(xReadIb),
	/*10439*/ uint16(xArgRM16),
	/*10440*/ uint16(xArgImm8u),
	/*10441*/ uint16(xMatch),
	/*10442*/ uint16(xSetOp), uint16(SHL),
	/*10444*/ uint16(xReadIb),
	/*10445*/ uint16(xArgRM32),
	/*10446*/ uint16(xArgImm8u),
	/*10447*/ uint16(xMatch),
	/*10448*/ uint16(xCondDataSize), 10436, 10442, 10452,
	/*10452*/ uint16(xSetOp), uint16(SHL),
	/*10454*/ uint16(xReadIb),
	/*10455*/ uint16(xArgRM64),
	/*10456*/ uint16(xArgImm8u),
	/*10457*/ uint16(xMatch),
	/*10458*/ uint16(xCondIs64), 10461, 10477,
	/*10461*/ uint16(xCondDataSize), 10465, 10471, 0,
	/*10465*/ uint16(xSetOp), uint16(SHR),
	/*10467*/ uint16(xReadIb),
	/*10468*/ uint16(xArgRM16),
	/*10469*/ uint16(xArgImm8u),
	/*10470*/ uint16(xMatch),
	/*10471*/ uint16(xSetOp), uint16(SHR),
	/*10473*/ uint16(xReadIb),
	/*10474*/ uint16(xArgRM32),
	/*10475*/ uint16(xArgImm8u),
	/*10476*/ uint16(xMatch),
	/*10477*/ uint16(xCondDataSize), 10465, 10471, 10481,
	/*10481*/ uint16(xSetOp), uint16(SHR),
	/*10483*/ uint16(xReadIb),
	/*10484*/ uint16(xArgRM64),
	/*10485*/ uint16(xArgImm8u),
	/*10486*/ uint16(xMatch),
	/*10487*/ uint16(xCondIs64), 10490, 10506,
	/*10490*/ uint16(xCondDataSize), 10494, 10500, 0,
	/*10494*/ uint16(xSetOp), uint16(SAR),
	/*10496*/ uint16(xReadIb),
	/*10497*/ uint16(xArgRM16),
	/*10498*/ uint16(xArgImm8u),
	/*10499*/ uint16(xMatch),
	/*10500*/ uint16(xSetOp), uint16(SAR),
	/*10502*/ uint16(xReadIb),
	/*10503*/ uint16(xArgRM32),
	/*10504*/ uint16(xArgImm8u),
	/*10505*/ uint16(xMatch),
	/*10506*/ uint16(xCondDataSize), 10494, 10500, 10510,
	/*10510*/ uint16(xSetOp), uint16(SAR),
	/*10512*/ uint16(xReadIb),
	/*10513*/ uint16(xArgRM64),
	/*10514*/ uint16(xArgImm8u),
	/*10515*/ uint16(xMatch),
	/*10516*/ uint16(xSetOp), uint16(RET),
	/*10518*/ uint16(xReadIw),
	/*10519*/ uint16(xArgImm16u),
	/*10520*/ uint16(xMatch),
	/*10521*/ uint16(xSetOp), uint16(RET),
	/*10523*/ uint16(xMatch),
	/*10524*/ uint16(xCondIs64), 10527, 0,
	/*10527*/ uint16(xCondDataSize), 10531, 10537, 0,
	/*10531*/ uint16(xSetOp), uint16(LES),
	/*10533*/ uint16(xReadSlashR),
	/*10534*/ uint16(xArgR16),
	/*10535*/ uint16(xArgM16colon16),
	/*10536*/ uint16(xMatch),
	/*10537*/ uint16(xSetOp), uint16(LES),
	/*10539*/ uint16(xReadSlashR),
	/*10540*/ uint16(xArgR32),
	/*10541*/ uint16(xArgM16colon32),
	/*10542*/ uint16(xMatch),
	/*10543*/ uint16(xCondIs64), 10546, 0,
	/*10546*/ uint16(xCondDataSize), 10550, 10556, 0,
	/*10550*/ uint16(xSetOp), uint16(LDS),
	/*10552*/ uint16(xReadSlashR),
	/*10553*/ uint16(xArgR16),
	/*10554*/ uint16(xArgM16colon16),
	/*10555*/ uint16(xMatch),
	/*10556*/ uint16(xSetOp), uint16(LDS),
	/*10558*/ uint16(xReadSlashR),
	/*10559*/ uint16(xArgR32),
	/*10560*/ uint16(xArgM16colon32),
	/*10561*/ uint16(xMatch),
	/*10562*/ uint16(xCondByte), 1,
	0xF8, 10581,
	/*10566*/ uint16(xCondSlashR),
	10575, // 0
	0,     // 1
	0,     // 2
	0,     // 3
	0,     // 4
	0,     // 5
	0,     // 6
	0,     // 7
	/*10575*/ uint16(xSetOp), uint16(MOV),
	/*10577*/ uint16(xReadIb),
	/*10578*/ uint16(xArgRM8),
	/*10579*/ uint16(xArgImm8u),
	/*10580*/ uint16(xMatch),
	/*10581*/ uint16(xSetOp), uint16(XABORT),
	/*10583*/ uint16(xReadIb),
	/*10584*/ uint16(xArgImm8u),
	/*10585*/ uint16(xMatch),
	/*10586*/ uint16(xCondByte), 1,
	0xF8, 10628,
	/*10590*/ uint16(xCondSlashR),
	10599, // 0
	0,     // 1
	0,     // 2
	0,     // 3
	0,     // 4
	0,     // 5
	0,     // 6
	0,     // 7
	/*10599*/ uint16(xCondIs64), 10602, 10618,
	/*10602*/ uint16(xCondDataSize), 10606, 10612, 0,
	/*10606*/ uint16(xSetOp), uint16(MOV),
	/*10608*/ uint16(xReadIw),
	/*10609*/ uint16(xArgRM16),
	/*10610*/ uint16(xArgImm16),
	/*10611*/ uint16(xMatch),
	/*10612*/ uint16(xSetOp), uint16(MOV),
	/*10614*/ uint16(xReadId),
	/*10615*/ uint16(xArgRM32),
	/*10616*/ uint16(xArgImm32),
	/*10617*/ uint16(xMatch),
	/*10618*/ uint16(xCondDataSize), 10606, 10612, 10622,
	/*10622*/ uint16(xSetOp), uint16(MOV),
	/*10624*/ uint16(xReadId),
	/*10625*/ uint16(xArgRM64),
	/*10626*/ uint16(xArgImm32),
	/*10627*/ uint16(xMatch),
	/*10628*/ uint16(xCondDataSize), 10632, 10637, 10642,
	/*10632*/ uint16(xSetOp), uint16(XBEGIN),
	/*10634*/ uint16(xReadCw),
	/*10635*/ uint16(xArgRel16),
	/*10636*/ uint16(xMatch),
	/*10637*/ uint16(xSetOp), uint16(XBEGIN),
	/*10639*/ uint16(xReadCd),
	/*10640*/ uint16(xArgRel32),
	/*10641*/ uint16(xMatch),
	/*10642*/ uint16(xSetOp), uint16(XBEGIN),
	/*10644*/ uint16(xReadCd),
	/*10645*/ uint16(xArgRel32),
	/*10646*/ uint16(xMatch),
	/*10647*/ uint16(xSetOp), uint16(ENTER),
	/*10649*/ uint16(xReadIw),
	/*10650*/ uint16(xReadIb),
	/*10651*/ uint16(xArgImm16u),
	/*10652*/ uint16(xArgImm8u),
	/*10653*/ uint16(xMatch),
	/*10654*/ uint16(xCondIs64), 10657, 10667,
	/*10657*/ uint16(xCondDataSize), 10661, 10664, 0,
	/*10661*/ uint16(xSetOp), uint16(LEAVE),
	/*10663*/ uint16(xMatch),
	/*10664*/ uint16(xSetOp), uint16(LEAVE),
	/*10666*/ uint16(xMatch),
	/*10667*/ uint16(xCondDataSize), 10661, 10671, 10674,
	/*10671*/ uint16(xSetOp), uint16(LEAVE),
	/*10673*/ uint16(xMatch),
	/*10674*/ uint16(xSetOp), uint16(LEAVE),
	/*10676*/ uint16(xMatch),
	/*10677*/ uint16(xSetOp), uint16(LRET),
	/*10679*/ uint16(xReadIw),
	/*10680*/ uint16(xArgImm16u),
	/*10681*/ uint16(xMatch),
	/*10682*/ uint16(xSetOp), uint16(LRET),
	/*10684*/ uint16(xMatch),
	/*10685*/ uint16(xSetOp), uint16(INT),
	/*10687*/ uint16(xArg3),
	/*10688*/ uint16(xMatch),
	/*10689*/ uint16(xSetOp), uint16(INT),
	/*10691*/ uint16(xReadIb),
	/*10692*/ uint16(xArgImm8u),
	/*10693*/ uint16(xMatch),
	/*10694*/ uint16(xCondIs64), 10697, 0,
	/*10697*/ uint16(xSetOp), uint16(INTO),
	/*10699*/ uint16(xMatch),
	/*10700*/ uint16(xCondIs64), 10703, 10713,
	/*10703*/ uint16(xCondDataSize), 10707, 10710, 0,
	/*10707*/ uint16(xSetOp), uint16(IRET),
	/*10709*/ uint16(xMatch),
	/*10710*/ uint16(xSetOp), uint16(IRETD),
	/*10712*/ uint16(xMatch),
	/*10713*/ uint16(xCondDataSize), 10707, 10710, 10717,
	/*10717*/ uint16(xSetOp), uint16(IRETQ),
	/*10719*/ uint16(xMatch),
	/*10720*/ uint16(xCondSlashR),
	10729, // 0
	10734, // 1
	10739, // 2
	10744, // 3
	10749, // 4
	10754, // 5
	0,     // 6
	10759, // 7
	/*10729*/ uint16(xSetOp), uint16(ROL),
	/*10731*/ uint16(xArgRM8),
	/*10732*/ uint16(xArg1),
	/*10733*/ uint16(xMatch),
	/*10734*/ uint16(xSetOp), uint16(ROR),
	/*10736*/ uint16(xArgRM8),
	/*10737*/ uint16(xArg1),
	/*10738*/ uint16(xMatch),
	/*10739*/ uint16(xSetOp), uint16(RCL),
	/*10741*/ uint16(xArgRM8),
	/*10742*/ uint16(xArg1),
	/*10743*/ uint16(xMatch),
	/*10744*/ uint16(xSetOp), uint16(RCR),
	/*10746*/ uint16(xArgRM8),
	/*10747*/ uint16(xArg1),
	/*10748*/ uint16(xMatch),
	/*10749*/ uint16(xSetOp), uint16(SHL),
	/*10751*/ uint16(xArgRM8),
	/*10752*/ uint16(xArg1),
	/*10753*/ uint16(xMatch),
	/*10754*/ uint16(xSetOp), uint16(SHR),
	/*10756*/ uint16(xArgRM8),
	/*10757*/ uint16(xArg1),
	/*10758*/ uint16(xMatch),
	/*10759*/ uint16(xSetOp), uint16(SAR),
	/*10761*/ uint16(xArgRM8),
	/*10762*/ uint16(xArg1),
	/*10763*/ uint16(xMatch),
	/*10764*/ uint16(xCondSlashR),
	10773, // 0
	10799, // 1
	10825, // 2
	10851, // 3
	10877, // 4
	10903, // 5
	0,     // 6
	10929, // 7
	/*10773*/ uint16(xCondIs64), 10776, 10790,
	/*10776*/ uint16(xCondDataSize), 10780, 10785, 0,
	/*10780*/ uint16(xSetOp), uint16(ROL),
	/*10782*/ uint16(xArgRM16),
	/*10783*/ uint16(xArg1),
	/*10784*/ uint16(xMatch),
	/*10785*/ uint16(xSetOp), uint16(ROL),
	/*10787*/ uint16(xArgRM32),
	/*10788*/ uint16(xArg1),
	/*10789*/ uint16(xMatch),
	/*10790*/ uint16(xCondDataSize), 10780, 10785, 10794,
	/*10794*/ uint16(xSetOp), uint16(ROL),
	/*10796*/ uint16(xArgRM64),
	/*10797*/ uint16(xArg1),
	/*10798*/ uint16(xMatch),
	/*10799*/ uint16(xCondIs64), 10802, 10816,
	/*10802*/ uint16(xCondDataSize), 10806, 10811, 0,
	/*10806*/ uint16(xSetOp), uint16(ROR),
	/*10808*/ uint16(xArgRM16),
	/*10809*/ uint16(xArg1),
	/*10810*/ uint16(xMatch),
	/*10811*/ uint16(xSetOp), uint16(ROR),
	/*10813*/ uint16(xArgRM32),
	/*10814*/ uint16(xArg1),
	/*10815*/ uint16(xMatch),
	/*10816*/ uint16(xCondDataSize), 10806, 10811, 10820,
	/*10820*/ uint16(xSetOp), uint16(ROR),
	/*10822*/ uint16(xArgRM64),
	/*10823*/ uint16(xArg1),
	/*10824*/ uint16(xMatch),
	/*10825*/ uint16(xCondIs64), 10828, 10842,
	/*10828*/ uint16(xCondDataSize), 10832, 10837, 0,
	/*10832*/ uint16(xSetOp), uint16(RCL),
	/*10834*/ uint16(xArgRM16),
	/*10835*/ uint16(xArg1),
	/*10836*/ uint16(xMatch),
	/*10837*/ uint16(xSetOp), uint16(RCL),
	/*10839*/ uint16(xArgRM32),
	/*10840*/ uint16(xArg1),
	/*10841*/ uint16(xMatch),
	/*10842*/ uint16(xCondDataSize), 10832, 10837, 10846,
	/*10846*/ uint16(xSetOp), uint16(RCL),
	/*10848*/ uint16(xArgRM64),
	/*10849*/ uint16(xArg1),
	/*10850*/ uint16(xMatch),
	/*10851*/ uint16(xCondIs64), 10854, 10868,
	/*10854*/ uint16(xCondDataSize), 10858, 10863, 0,
	/*10858*/ uint16(xSetOp), uint16(RCR),
	/*10860*/ uint16(xArgRM16),
	/*10861*/ uint16(xArg1),
	/*10862*/ uint16(xMatch),
	/*10863*/ uint16(xSetOp), uint16(RCR),
	/*10865*/ uint16(xArgRM32),
	/*10866*/ uint16(xArg1),
	/*10867*/ uint16(xMatch),
	/*10868*/ uint16(xCondDataSize), 10858, 10863, 10872,
	/*10872*/ uint16(xSetOp), uint16(RCR),
	/*10874*/ uint16(xArgRM64),
	/*10875*/ uint16(xArg1),
	/*10876*/ uint16(xMatch),
	/*10877*/ uint16(xCondIs64), 10880, 10894,
	/*10880*/ uint16(xCondDataSize), 10884, 10889, 0,
	/*10884*/ uint16(xSetOp), uint16(SHL),
	/*10886*/ uint16(xArgRM16),
	/*10887*/ uint16(xArg1),
	/*10888*/ uint16(xMatch),
	/*10889*/ uint16(xSetOp), uint16(SHL),
	/*10891*/ uint16(xArgRM32),
	/*10892*/ uint16(xArg1),
	/*10893*/ uint16(xMatch),
	/*10894*/ uint16(xCondDataSize), 10884, 10889, 10898,
	/*10898*/ uint16(xSetOp), uint16(SHL),
	/*10900*/ uint16(xArgRM64),
	/*10901*/ uint16(xArg1),
	/*10902*/ uint16(xMatch),
	/*10903*/ uint16(xCondIs64), 10906, 10920,
	/*10906*/ uint16(xCondDataSize), 10910, 10915, 0,
	/*10910*/ uint16(xSetOp), uint16(SHR),
	/*10912*/ uint16(xArgRM16),
	/*10913*/ uint16(xArg1),
	/*10914*/ uint16(xMatch),
	/*10915*/ uint16(xSetOp), uint16(SHR),
	/*10917*/ uint16(xArgRM32),
	/*10918*/ uint16(xArg1),
	/*10919*/ uint16(xMatch),
	/*10920*/ uint16(xCondDataSize), 10910, 10915, 10924,
	/*10924*/ uint16(xSetOp), uint16(SHR),
	/*10926*/ uint16(xArgRM64),
	/*10927*/ uint16(xArg1),
	/*10928*/ uint16(xMatch),
	/*10929*/ uint16(xCondIs64), 10932, 10946,
	/*10932*/ uint16(xCondDataSize), 10936, 10941, 0,
	/*10936*/ uint16(xSetOp), uint16(SAR),
	/*10938*/ uint16(xArgRM16),
	/*10939*/ uint16(xArg1),
	/*10940*/ uint16(xMatch),
	/*10941*/ uint16(xSetOp), uint16(SAR),
	/*10943*/ uint16(xArgRM32),
	/*10944*/ uint16(xArg1),
	/*10945*/ uint16(xMatch),
	/*10946*/ uint16(xCondDataSize), 10936, 10941, 10950,
	/*10950*/ uint16(xSetOp), uint16(SAR),
	/*10952*/ uint16(xArgRM64),
	/*10953*/ uint16(xArg1),
	/*10954*/ uint16(xMatch),
	/*10955*/ uint16(xCondSlashR),
	10964, // 0
	10969, // 1
	10974, // 2
	10979, // 3
	10984, // 4
	10989, // 5
	0,     // 6
	10994, // 7
	/*10964*/ uint16(xSetOp), uint16(ROL),
	/*10966*/ uint16(xArgRM8),
	/*10967*/ uint16(xArgCL),
	/*10968*/ uint16(xMatch),
	/*10969*/ uint16(xSetOp), uint16(ROR),
	/*10971*/ uint16(xArgRM8),
	/*10972*/ uint16(xArgCL),
	/*10973*/ uint16(xMatch),
	/*10974*/ uint16(xSetOp), uint16(RCL),
	/*10976*/ uint16(xArgRM8),
	/*10977*/ uint16(xArgCL),
	/*10978*/ uint16(xMatch),
	/*10979*/ uint16(xSetOp), uint16(RCR),
	/*10981*/ uint16(xArgRM8),
	/*10982*/ uint16(xArgCL),
	/*10983*/ uint16(xMatch),
	/*10984*/ uint16(xSetOp), uint16(SHL),
	/*10986*/ uint16(xArgRM8),
	/*10987*/ uint16(xArgCL),
	/*10988*/ uint16(xMatch),
	/*10989*/ uint16(xSetOp), uint16(SHR),
	/*10991*/ uint16(xArgRM8),
	/*10992*/ uint16(xArgCL),
	/*10993*/ uint16(xMatch),
	/*10994*/ uint16(xSetOp), uint16(SAR),
	/*10996*/ uint16(xArgRM8),
	/*10997*/ uint16(xArgCL),
	/*10998*/ uint16(xMatch),
	/*10999*/ uint16(xCondSlashR),
	11008, // 0
	11034, // 1
	11060, // 2
	11086, // 3
	11112, // 4
	11138, // 5
	0,     // 6
	11164, // 7
	/*11008*/ uint16(xCondIs64), 11011, 11025,
	/*11011*/ uint16(xCondDataSize), 11015, 11020, 0,
	/*11015*/ uint16(xSetOp), uint16(ROL),
	/*11017*/ uint16(xArgRM16),
	/*11018*/ uint16(xArgCL),
	/*11019*/ uint16(xMatch),
	/*11020*/ uint16(xSetOp), uint16(ROL),
	/*11022*/ uint16(xArgRM32),
	/*11023*/ uint16(xArgCL),
	/*11024*/ uint16(xMatch),
	/*11025*/ uint16(xCondDataSize), 11015, 11020, 11029,
	/*11029*/ uint16(xSetOp), uint16(ROL),
	/*11031*/ uint16(xArgRM64),
	/*11032*/ uint16(xArgCL),
	/*11033*/ uint16(xMatch),
	/*11034*/ uint16(xCondIs64), 11037, 11051,
	/*11037*/ uint16(xCondDataSize), 11041, 11046, 0,
	/*11041*/ uint16(xSetOp), uint16(ROR),
	/*11043*/ uint16(xArgRM16),
	/*11044*/ uint16(xArgCL),
	/*11045*/ uint16(xMatch),
	/*11046*/ uint16(xSetOp), uint16(ROR),
	/*11048*/ uint16(xArgRM32),
	/*11049*/ uint16(xArgCL),
	/*11050*/ uint16(xMatch),
	/*11051*/ uint16(xCondDataSize), 11041, 11046, 11055,
	/*11055*/ uint16(xSetOp), uint16(ROR),
	/*11057*/ uint16(xArgRM64),
	/*11058*/ uint16(xArgCL),
	/*11059*/ uint16(xMatch),
	/*11060*/ uint16(xCondIs64), 11063, 11077,
	/*11063*/ uint16(xCondDataSize), 11067, 11072, 0,
	/*11067*/ uint16(xSetOp), uint16(RCL),
	/*11069*/ uint16(xArgRM16),
	/*11070*/ uint16(xArgCL),
	/*11071*/ uint16(xMatch),
	/*11072*/ uint16(xSetOp), uint16(RCL),
	/*11074*/ uint16(xArgRM32),
	/*11075*/ uint16(xArgCL),
	/*11076*/ uint16(xMatch),
	/*11077*/ uint16(xCondDataSize), 11067, 11072, 11081,
	/*11081*/ uint16(xSetOp), uint16(RCL),
	/*11083*/ uint16(xArgRM64),
	/*11084*/ uint16(xArgCL),
	/*11085*/ uint16(xMatch),
	/*11086*/ uint16(xCondIs64), 11089, 11103,
	/*11089*/ uint16(xCondDataSize), 11093, 11098, 0,
	/*11093*/ uint16(xSetOp), uint16(RCR),
	/*11095*/ uint16(xArgRM16),
	/*11096*/ uint16(xArgCL),
	/*11097*/ uint16(xMatch),
	/*11098*/ uint16(xSetOp), uint16(RCR),
	/*11100*/ uint16(xArgRM32),
	/*11101*/ uint16(xArgCL),
	/*11102*/ uint16(xMatch),
	/*11103*/ uint16(xCondDataSize), 11093, 11098, 11107,
	/*11107*/ uint16(xSetOp), uint16(RCR),
	/*11109*/ uint16(xArgRM64),
	/*11110*/ uint16(xArgCL),
	/*11111*/ uint16(xMatch),
	/*11112*/ uint16(xCondIs64), 11115, 11129,
	/*11115*/ uint16(xCondDataSize), 11119, 11124, 0,
	/*11119*/ uint16(xSetOp), uint16(SHL),
	/*11121*/ uint16(xArgRM16),
	/*11122*/ uint16(xArgCL),
	/*11123*/ uint16(xMatch),
	/*11124*/ uint16(xSetOp), uint16(SHL),
	/*11126*/ uint16(xArgRM32),
	/*11127*/ uint16(xArgCL),
	/*11128*/ uint16(xMatch),
	/*11129*/ uint16(xCondDataSize), 11119, 11124, 11133,
	/*11133*/ uint16(xSetOp), uint16(SHL),
	/*11135*/ uint16(xArgRM64),
	/*11136*/ uint16(xArgCL),
	/*11137*/ uint16(xMatch),
	/*11138*/ uint16(xCondIs64), 11141, 11155,
	/*11141*/ uint16(xCondDataSize), 11145, 11150, 0,
	/*11145*/ uint16(xSetOp), uint16(SHR),
	/*11147*/ uint16(xArgRM16),
	/*11148*/ uint16(xArgCL),
	/*11149*/ uint16(xMatch),
	/*11150*/ uint16(xSetOp), uint16(SHR),
	/*11152*/ uint16(xArgRM32),
	/*11153*/ uint16(xArgCL),
	/*11154*/ uint16(xMatch),
	/*11155*/ uint16(xCondDataSize), 11145, 11150, 11159,
	/*11159*/ uint16(xSetOp), uint16(SHR),
	/*11161*/ uint16(xArgRM64),
	/*11162*/ uint16(xArgCL),
	/*11163*/ uint16(xMatch),
	/*11164*/ uint16(xCondIs64), 11167, 11181,
	/*11167*/ uint16(xCondDataSize), 11171, 11176, 0,
	/*11171*/ uint16(xSetOp), uint16(SAR),
	/*11173*/ uint16(xArgRM16),
	/*11174*/ uint16(xArgCL),
	/*11175*/ uint16(xMatch),
	/*11176*/ uint16(xSetOp), uint16(SAR),
	/*11178*/ uint16(xArgRM32),
	/*11179*/ uint16(xArgCL),
	/*11180*/ uint16(xMatch),
	/*11181*/ uint16(xCondDataSize), 11171, 11176, 11185,
	/*11185*/ uint16(xSetOp), uint16(SAR),
	/*11187*/ uint16(xArgRM64),
	/*11188*/ uint16(xArgCL),
	/*11189*/ uint16(xMatch),
	/*11190*/ uint16(xCondIs64), 11193, 0,
	/*11193*/ uint16(xSetOp), uint16(AAM),
	/*11195*/ uint16(xReadIb),
	/*11196*/ uint16(xArgImm8u),
	/*11197*/ uint16(xMatch),
	/*11198*/ uint16(xCondIs64), 11201, 0,
	/*11201*/ uint16(xSetOp), uint16(AAD),
	/*11203*/ uint16(xReadIb),
	/*11204*/ uint16(xArgImm8u),
	/*11205*/ uint16(xMatch),
	/*11206*/ uint16(xCondIs64), 11209, 11212,
	/*11209*/ uint16(xSetOp), uint16(XLATB),
	/*11211*/ uint16(xMatch),
	/*11212*/ uint16(xCondDataSize), 11209, 11209, 11216,
	/*11216*/ uint16(xSetOp), uint16(XLATB),
	/*11218*/ uint16(xMatch),
	/*11219*/ uint16(xCondByte), 64,
	0xc0, 11390,
	0xc1, 11390,
	0xc2, 11390,
	0xc3, 11390,
	0xc4, 11390,
	0xc5, 11390,
	0xc6, 11390,
	0xc7, 11390,
	0xc8, 11395,
	0xc9, 11395,
	0xca, 11395,
	0xcb, 11395,
	0xcc, 11395,
	0xcd, 11395,
	0xce, 11395,
	0xcf, 11395,
	0xd0, 11400,
	0xd1, 11400,
	0xd2, 11400,
	0xd3, 11400,
	0xd4, 11400,
	0xd5, 11400,
	0xd6, 11400,
	0xd7, 11400,
	0xd8, 11404,
	0xd9, 11404,
	0xda, 11404,
	0xdb, 11404,
	0xdc, 11404,
	0xdd, 11404,
	0xde, 11404,
	0xdf, 11404,
	0xe0, 11408,
	0xe1, 11408,
	0xe2, 11408,
	0xe3, 11408,
	0xe4, 11408,
	0xe5, 11408,
	0xe6, 11408,
	0xe7, 11408,
	0xe8, 11413,
	0xe9, 11413,
	0xea, 11413,
	0xeb, 11413,
	0xec, 11413,
	0xed, 11413,
	0xee, 11413,
	0xef, 11413,
	0xf0, 11418,
	0xf1, 11418,
	0xf2, 11418,
	0xf3, 11418,
	0xf4, 11418,
	0xf5, 11418,
	0xf6, 11418,
	0xf7, 11418,
	0xf8, 11423,
	0xf9, 11423,
	0xfa, 11423,
	0xfb, 11423,
	0xfc, 11423,
	0xfd, 11423,
	0xfe, 11423,
	0xff, 11423,
	/*11349*/ uint16(xCondSlashR),
	11358, // 0
	11362, // 1
	11366, // 2
	11370, // 3
	11374, // 4
	11378, // 5
	11382, // 6
	11386, // 7
	/*11358*/ uint16(xSetOp), uint16(FADD),
	/*11360*/ uint16(xArgM32fp),
	/*11361*/ uint16(xMatch),
	/*11362*/ uint16(xSetOp), uint16(FMUL),
	/*11364*/ uint16(xArgM32fp),
	/*11365*/ uint16(xMatch),
	/*11366*/ uint16(xSetOp), uint16(FCOM),
	/*11368*/ uint16(xArgM32fp),
	/*11369*/ uint16(xMatch),
	/*11370*/ uint16(xSetOp), uint16(FCOMP),
	/*11372*/ uint16(xArgM32fp),
	/*11373*/ uint16(xMatch),
	/*11374*/ uint16(xSetOp), uint16(FSUB),
	/*11376*/ uint16(xArgM32fp),
	/*11377*/ uint16(xMatch),
	/*11378*/ uint16(xSetOp), uint16(FSUBR),
	/*11380*/ uint16(xArgM32fp),
	/*11381*/ uint16(xMatch),
	/*11382*/ uint16(xSetOp), uint16(FDIV),
	/*11384*/ uint16(xArgM32fp),
	/*11385*/ uint16(xMatch),
	/*11386*/ uint16(xSetOp), uint16(FDIVR),
	/*11388*/ uint16(xArgM32fp),
	/*11389*/ uint16(xMatch),
	/*11390*/ uint16(xSetOp), uint16(FADD),
	/*11392*/ uint16(xArgST),
	/*11393*/ uint16(xArgSTi),
	/*11394*/ uint16(xMatch),
	/*11395*/ uint16(xSetOp), uint16(FMUL),
	/*11397*/ uint16(xArgST),
	/*11398*/ uint16(xArgSTi),
	/*11399*/ uint16(xMatch),
	/*11400*/ uint16(xSetOp), uint16(FCOM),
	/*11402*/ uint16(xArgSTi),
	/*11403*/ uint16(xMatch),
	/*11404*/ uint16(xSetOp), uint16(FCOMP),
	/*11406*/ uint16(xArgSTi),
	/*11407*/ uint16(xMatch),
	/*11408*/ uint16(xSetOp), uint16(FSUB),
	/*11410*/ uint16(xArgST),
	/*11411*/ uint16(xArgSTi),
	/*11412*/ uint16(xMatch),
	/*11413*/ uint16(xSetOp), uint16(FSUBR),
	/*11415*/ uint16(xArgST),
	/*11416*/ uint16(xArgSTi),
	/*11417*/ uint16(xMatch),
	/*11418*/ uint16(xSetOp), uint16(FDIV),
	/*11420*/ uint16(xArgST),
	/*11421*/ uint16(xArgSTi),
	/*11422*/ uint16(xMatch),
	/*11423*/ uint16(xSetOp), uint16(FDIVR),
	/*11425*/ uint16(xArgST),
	/*11426*/ uint16(xArgSTi),
	/*11427*/ uint16(xMatch),
	/*11428*/ uint16(xCondByte), 42,
	0xc0, 11551,
	0xc1, 11551,
	0xc2, 11551,
	0xc3, 11551,
	0xc4, 11551,
	0xc5, 11551,
	0xc6, 11551,
	0xc7, 11551,
	0xc8, 11555,
	0xc9, 11555,
	0xca, 11555,
	0xcb, 11555,
	0xcc, 11555,
	0xcd, 11555,
	0xce, 11555,
	0xcf, 11555,
	0xD0, 11559,
	0xE0, 11562,
	0xE1, 11565,
	0xE4, 11568,
	0xE5, 11571,
	0xE8, 11574,
	0xE9, 11577,
	0xEA, 11580,
	0xEB, 11583,
	0xEC, 11586,
	0xF0, 11589,
	0xF1, 11592,
	0xF2, 11595,
	0xF3, 11598,
	0xF4, 11601,
	0xF5, 11604,
	0xF6, 11607,
	0xF7, 11610,
	0xF8, 11613,
	0xF9, 11616,
	0xFA, 11619,
	0xFB, 11622,
	0xFC, 11625,
	0xFD, 11628,
	0xFE, 11631,
	0xFF, 11634,
	/*11514*/ uint16(xCondSlashR),
	11523, // 0
	0,     // 1
	11527, // 2
	11531, // 3
	11535, // 4
	11539, // 5
	11543, // 6
	11547, // 7
	/*11523*/ uint16(xSetOp), uint16(FLD),
	/*11525*/ uint16(xArgM32fp),
	/*11526*/ uint16(xMatch),
	/*11527*/ uint16(xSetOp), uint16(FST),
	/*11529*/ uint16(xArgM32fp),
	/*11530*/ uint16(xMatch),
	/*11531*/ uint16(xSetOp), uint16(FSTP),
	/*11533*/ uint16(xArgM32fp),
	/*11534*/ uint16(xMatch),
	/*11535*/ uint16(xSetOp), uint16(FLDENV),
	/*11537*/ uint16(xArgM1428byte),
	/*11538*/ uint16(xMatch),
	/*11539*/ uint16(xSetOp), uint16(FLDCW),
	/*11541*/ uint16(xArgM2byte),
	/*11542*/ uint16(xMatch),
	/*11543*/ uint16(xSetOp), uint16(FNSTENV),
	/*11545*/ uint16(xArgM1428byte),
	/*11546*/ uint16(xMatch),
	/*11547*/ uint16(xSetOp), uint16(FNSTCW),
	/*11549*/ uint16(xArgM2byte),
	/*11550*/ uint16(xMatch),
	/*11551*/ uint16(xSetOp), uint16(FLD),
	/*11553*/ uint16(xArgSTi),
	/*11554*/ uint16(xMatch),
	/*11555*/ uint16(xSetOp), uint16(FXCH),
	/*11557*/ uint16(xArgSTi),
	/*11558*/ uint16(xMatch),
	/*11559*/ uint16(xSetOp), uint16(FNOP),
	/*11561*/ uint16(xMatch),
	/*11562*/ uint16(xSetOp), uint16(FCHS),
	/*11564*/ uint16(xMatch),
	/*11565*/ uint16(xSetOp), uint16(FABS),
	/*11567*/ uint16(xMatch),
	/*11568*/ uint16(xSetOp), uint16(FTST),
	/*11570*/ uint16(xMatch),
	/*11571*/ uint16(xSetOp), uint16(FXAM),
	/*11573*/ uint16(xMatch),
	/*11574*/ uint16(xSetOp), uint16(FLD1),
	/*11576*/ uint16(xMatch),
	/*11577*/ uint16(xSetOp), uint16(FLDL2T),
	/*11579*/ uint16(xMatch),
	/*11580*/ uint16(xSetOp), uint16(FLDL2E),
	/*11582*/ uint16(xMatch),
	/*11583*/ uint16(xSetOp), uint16(FLDPI),
	/*11585*/ uint16(xMatch),
	/*11586*/ uint16(xSetOp), uint16(FLDLG2),
	/*11588*/ uint16(xMatch),
	/*11589*/ uint16(xSetOp), uint16(F2XM1),
	/*11591*/ uint16(xMatch),
	/*11592*/ uint16(xSetOp), uint16(FYL2X),
	/*11594*/ uint16(xMatch),
	/*11595*/ uint16(xSetOp), uint16(FPTAN),
	/*11597*/ uint16(xMatch),
	/*11598*/ uint16(xSetOp), uint16(FPATAN),
	/*11600*/ uint16(xMatch),
	/*11601*/ uint16(xSetOp), uint16(FXTRACT),
	/*11603*/ uint16(xMatch),
	/*11604*/ uint16(xSetOp), uint16(FPREM1),
	/*11606*/ uint16(xMatch),
	/*11607*/ uint16(xSetOp), uint16(FDECSTP),
	/*11609*/ uint16(xMatch),
	/*11610*/ uint16(xSetOp), uint16(FINCSTP),
	/*11612*/ uint16(xMatch),
	/*11613*/ uint16(xSetOp), uint16(FPREM),
	/*11615*/ uint16(xMatch),
	/*11616*/ uint16(xSetOp), uint16(FYL2XP1),
	/*11618*/ uint16(xMatch),
	/*11619*/ uint16(xSetOp), uint16(FSQRT),
	/*11621*/ uint16(xMatch),
	/*11622*/ uint16(xSetOp), uint16(FSINCOS),
	/*11624*/ uint16(xMatch),
	/*11625*/ uint16(xSetOp), uint16(FRNDINT),
	/*11627*/ uint16(xMatch),
	/*11628*/ uint16(xSetOp), uint16(FSCALE),
	/*11630*/ uint16(xMatch),
	/*11631*/ uint16(xSetOp), uint16(FSIN),
	/*11633*/ uint16(xMatch),
	/*11634*/ uint16(xSetOp), uint16(FCOS),
	/*11636*/ uint16(xMatch),
	/*11637*/ uint16(xCondByte), 33,
	0xc0, 11746,
	0xc1, 11746,
	0xc2, 11746,
	0xc3, 11746,
	0xc4, 11746,
	0xc5, 11746,
	0xc6, 11746,
	0xc7, 11746,
	0xc8, 11751,
	0xc9, 11751,
	0xca, 11751,
	0xcb, 11751,
	0xcc, 11751,
	0xcd, 11751,
	0xce, 11751,
	0xcf, 11751,
	0xd0, 11756,
	0xd1, 11756,
	0xd2, 11756,
	0xd3, 11756,
	0xd4, 11756,
	0xd5, 11756,
	0xd6, 11756,
	0xd7, 11756,
	0xd8, 11761,
	0xd9, 11761,
	0xda, 11761,
	0xdb, 11761,
	0xdc, 11761,
	0xdd, 11761,
	0xde, 11761,
	0xdf, 11761,
	0xE9, 11766,
	/*11705*/ uint16(xCondSlashR),
	11714, // 0
	11718, // 1
	11722, // 2
	11726, // 3
	11730, // 4
	11734, // 5
	11738, // 6
	11742, // 7
	/*11714*/ uint16(xSetOp), uint16(FIADD),
	/*11716*/ uint16(xArgM32int),
	/*11717*/ uint16(xMatch),
	/*11718*/ uint16(xSetOp), uint16(FIMUL),
	/*11720*/ uint16(xArgM32int),
	/*11721*/ uint16(xMatch),
	/*11722*/ uint16(xSetOp), uint16(FICOM),
	/*11724*/ uint16(xArgM32int),
	/*11725*/ uint16(xMatch),
	/*11726*/ uint16(xSetOp), uint16(FICOMP),
	/*11728*/ uint16(xArgM32int),
	/*11729*/ uint16(xMatch),
	/*11730*/ uint16(xSetOp), uint16(FISUB),
	/*11732*/ uint16(xArgM32int),
	/*11733*/ uint16(xMatch),
	/*11734*/ uint16(xSetOp), uint16(FISUBR),
	/*11736*/ uint16(xArgM32int),
	/*11737*/ uint16(xMatch),
	/*11738*/ uint16(xSetOp), uint16(FIDIV),
	/*11740*/ uint16(xArgM32int),
	/*11741*/ uint16(xMatch),
	/*11742*/ uint16(xSetOp), uint16(FIDIVR),
	/*11744*/ uint16(xArgM32int),
	/*11745*/ uint16(xMatch),
	/*11746*/ uint16(xSetOp), uint16(FCMOVB),
	/*11748*/ uint16(xArgST),
	/*11749*/ uint16(xArgSTi),
	/*11750*/ uint16(xMatch),
	/*11751*/ uint16(xSetOp), uint16(FCMOVE),
	/*11753*/ uint16(xArgST),
	/*11754*/ uint16(xArgSTi),
	/*11755*/ uint16(xMatch),
	/*11756*/ uint16(xSetOp), uint16(FCMOVBE),
	/*11758*/ uint16(xArgST),
	/*11759*/ uint16(xArgSTi),
	/*11760*/ uint16(xMatch),
	/*11761*/ uint16(xSetOp), uint16(FCMOVU),
	/*11763*/ uint16(xArgST),
	/*11764*/ uint16(xArgSTi),
	/*11765*/ uint16(xMatch),
	/*11766*/ uint16(xSetOp), uint16(FUCOMPP),
	/*11768*/ uint16(xMatch),
	/*11769*/ uint16(xCondByte), 50,
	0xc0, 11904,
	0xc1, 11904,
	0xc2, 11904,
	0xc3, 11904,
	0xc4, 11904,
	0xc5, 11904,
	0xc6, 11904,
	0xc7, 11904,
	0xc8, 11909,
	0xc9, 11909,
	0xca, 11909,
	0xcb, 11909,
	0xcc, 11909,
	0xcd, 11909,
	0xce, 11909,
	0xcf, 11909,
	0xd0, 11914,
	0xd1, 11914,
	0xd2, 11914,
	0xd3, 11914,
	0xd4, 11914,
	0xd5, 11914,
	0xd6, 11914,
	0xd7, 11914,
	0xd8, 11919,
	0xd9, 11919,
	0xda, 11919,
	0xdb, 11919,
	0xdc, 11919,
	0xdd, 11919,
	0xde, 11919,
	0xdf, 11919,
	0xE2, 11924,
	0xE3, 11927,
	0xe8, 11930,
	0xe9, 11930,
	0xea, 11930,
	0xeb, 11930,
	0xec, 11930,
	0xed, 11930,
	0xee, 11930,
	0xef, 11930,
	0xf0, 11935,
	0xf1, 11935,
	0xf2, 11935,
	0xf3, 11935,
	0xf4, 11935,
	0xf5, 11935,
	0xf6, 11935,
	0xf7, 11935,
	/*11871*/ uint16(xCondSlashR),
	11880, // 0
	11884, // 1
	11888, // 2
	11892, // 3
	0,     // 4
	11896, // 5
	0,     // 6
	11900, // 7
	/*11880*/ uint16(xSetOp), uint16(FILD),
	/*11882*/ uint16(xArgM32int),
	/*11883*/ uint16(xMatch),
	/*11884*/ uint16(xSetOp), uint16(FISTTP),
	/*11886*/ uint16(xArgM32int),
	/*11887*/ uint16(xMatch),
	/*11888*/ uint16(xSetOp), uint16(FIST),
	/*11890*/ uint16(xArgM32int),
	/*11891*/ uint16(xMatch),
	/*11892*/ uint16(xSetOp), uint16(FISTP),
	/*11894*/ uint16(xArgM32int),
	/*11895*/ uint16(xMatch),
	/*11896*/ uint16(xSetOp), uint16(FLD),
	/*11898*/ uint16(xArgM80fp),
	/*11899*/ uint16(xMatch),
	/*11900*/ uint16(xSetOp), uint16(FSTP),
	/*11902*/ uint16(xArgM80fp),
	/*11903*/ uint16(xMatch),
	/*11904*/ uint16(xSetOp), uint16(FCMOVNB),
	/*11906*/ uint16(xArgST),
	/*11907*/ uint16(xArgSTi),
	/*11908*/ uint16(xMatch),
	/*11909*/ uint16(xSetOp), uint16(FCMOVNE),
	/*11911*/ uint16(xArgST),
	/*11912*/ uint16(xArgSTi),
	/*11913*/ uint16(xMatch),
	/*11914*/ uint16(xSetOp), uint16(FCMOVNBE),
	/*11916*/ uint16(xArgST),
	/*11917*/ uint16(xArgSTi),
	/*11918*/ uint16(xMatch),
	/*11919*/ uint16(xSetOp), uint16(FCMOVNU),
	/*11921*/ uint16(xArgST),
	/*11922*/ uint16(xArgSTi),
	/*11923*/ uint16(xMatch),
	/*11924*/ uint16(xSetOp), uint16(FNCLEX),
	/*11926*/ uint16(xMatch),
	/*11927*/ uint16(xSetOp), uint16(FNINIT),
	/*11929*/ uint16(xMatch),
	/*11930*/ uint16(xSetOp), uint16(FUCOMI),
	/*11932*/ uint16(xArgST),
	/*11933*/ uint16(xArgSTi),
	/*11934*/ uint16(xMatch),
	/*11935*/ uint16(xSetOp), uint16(FCOMI),
	/*11937*/ uint16(xArgST),
	/*11938*/ uint16(xArgSTi),
	/*11939*/ uint16(xMatch),
	/*11940*/ uint16(xCondByte), 48,
	0xc0, 12079,
	0xc1, 12079,
	0xc2, 12079,
	0xc3, 12079,
	0xc4, 12079,
	0xc5, 12079,
	0xc6, 12079,
	0xc7, 12079,
	0xc8, 12084,
	0xc9, 12084,
	0xca, 12084,
	0xcb, 12084,
	0xcc, 12084,
	0xcd, 12084,
	0xce, 12084,
	0xcf, 12084,
	0xe0, 12089,
	0xe1, 12089,
	0xe2, 12089,
	0xe3, 12089,
	0xe4, 12089,
	0xe5, 12089,
	0xe6, 12089,
	0xe7, 12089,
	0xe8, 12094,
	0xe9, 12094,
	0xea, 12094,
	0xeb, 12094,
	0xec, 12094,
	0xed, 12094,
	0xee, 12094,
	0xef, 12094,
	0xf0, 12099,
	0xf1, 12099,
	0xf2, 12099,
	0xf3, 12099,
	0xf4, 12099,
	0xf5, 12099,
	0xf6, 12099,
	0xf7, 12099,
	0xf8, 12104,
	0xf9, 12104,
	0xfa, 12104,
	0xfb, 12104,
	0xfc, 12104,
	0xfd, 12104,
	0xfe, 12104,
	0xff, 12104,
	/*12038*/ uint16(xCondSlashR),
	12047, // 0
	12051, // 1
	12055, // 2
	12059, // 3
	12063, // 4
	12067, // 5
	12071, // 6
	12075, // 7
	/*12047*/ uint16(xSetOp), uint16(FADD),
	/*12049*/ uint16(xArgM64fp),
	/*12050*/ uint16(xMatch),
	/*12051*/ uint16(xSetOp), uint16(FMUL),
	/*12053*/ uint16(xArgM64fp),
	/*12054*/ uint16(xMatch),
	/*12055*/ uint16(xSetOp), uint16(FCOM),
	/*12057*/ uint16(xArgM64fp),
	/*12058*/ uint16(xMatch),
	/*12059*/ uint16(xSetOp), uint16(FCOMP),
	/*12061*/ uint16(xArgM64fp),
	/*12062*/ uint16(xMatch),
	/*12063*/ uint16(xSetOp), uint16(FSUB),
	/*12065*/ uint16(xArgM64fp),
	/*12066*/ uint16(xMatch),
	/*12067*/ uint16(xSetOp), uint16(FSUBR),
	/*12069*/ uint16(xArgM64fp),
	/*12070*/ uint16(xMatch),
	/*12071*/ uint16(xSetOp), uint16(FDIV),
	/*12073*/ uint16(xArgM64fp),
	/*12074*/ uint16(xMatch),
	/*12075*/ uint16(xSetOp), uint16(FDIVR),
	/*12077*/ uint16(xArgM64fp),
	/*12078*/ uint16(xMatch),
	/*12079*/ uint16(xSetOp), uint16(FADD),
	/*12081*/ uint16(xArgSTi),
	/*12082*/ uint16(xArgST),
	/*12083*/ uint16(xMatch),
	/*12084*/ uint16(xSetOp), uint16(FMUL),
	/*12086*/ uint16(xArgSTi),
	/*12087*/ uint16(xArgST),
	/*12088*/ uint16(xMatch),
	/*12089*/ uint16(xSetOp), uint16(FSUBR),
	/*12091*/ uint16(xArgSTi),
	/*12092*/ uint16(xArgST),
	/*12093*/ uint16(xMatch),
	/*12094*/ uint16(xSetOp), uint16(FSUB),
	/*12096*/ uint16(xArgSTi),
	/*12097*/ uint16(xArgST),
	/*12098*/ uint16(xMatch),
	/*12099*/ uint16(xSetOp), uint16(FDIVR),
	/*12101*/ uint16(xArgSTi),
	/*12102*/ uint16(xArgST),
	/*12103*/ uint16(xMatch),
	/*12104*/ uint16(xSetOp), uint16(FDIV),
	/*12106*/ uint16(xArgSTi),
	/*12107*/ uint16(xArgST),
	/*12108*/ uint16(xMatch),
	/*12109*/ uint16(xCondByte), 40,
	0xc0, 12228,
	0xc1, 12228,
	0xc2, 12228,
	0xc3, 12228,
	0xc4, 12228,
	0xc5, 12228,
	0xc6, 12228,
	0xc7, 12228,
	0xd0, 12232,
	0xd1, 12232,
	0xd2, 12232,
	0xd3, 12232,
	0xd4, 12232,
	0xd5, 12232,
	0xd6, 12232,
	0xd7, 12232,
	0xd8, 12236,
	0xd9, 12236,
	0xda, 12236,
	0xdb, 12236,
	0xdc, 12236,
	0xdd, 12236,
	0xde, 12236,
	0xdf, 12236,
	0xe0, 12240,
	0xe1, 12240,
	0xe2, 12240,
	0xe3, 12240,
	0xe4, 12240,
	0xe5, 12240,
	0xe6, 12240,
	0xe7, 12240,
	0xe8, 12244,
	0xe9, 12244,
	0xea, 12244,
	0xeb, 12244,
	0xec, 12244,
	0xed, 12244,
	0xee, 12244,
	0xef, 12244,
	/*12191*/ uint16(xCondSlashR),
	12200, // 0
	12204, // 1
	12208, // 2
	12212, // 3
	12216, // 4
	0,     // 5
	12220, // 6
	12224, // 7
	/*12200*/ uint16(xSetOp), uint16(FLD),
	/*12202*/ uint16(xArgM64fp),
	/*12203*/ uint16(xMatch),
	/*12204*/ uint16(xSetOp), uint16(FISTTP),
	/*12206*/ uint16(xArgM64int),
	/*12207*/ uint16(xMatch),
	/*12208*/ uint16(xSetOp), uint16(FST),
	/*12210*/ uint16(xArgM64fp),
	/*12211*/ uint16(xMatch),
	/*12212*/ uint16(xSetOp), uint16(FSTP),
	/*12214*/ uint16(xArgM64fp),
	/*12215*/ uint16(xMatch),
	/*12216*/ uint16(xSetOp), uint16(FRSTOR),
	/*12218*/ uint16(xArgM94108byte),
	/*12219*/ uint16(xMatch),
	/*12220*/ uint16(xSetOp), uint16(FNSAVE),
	/*12222*/ uint16(xArgM94108byte),
	/*12223*/ uint16(xMatch),
	/*12224*/ uint16(xSetOp), uint16(FNSTSW),
	/*12226*/ uint16(xArgM2byte),
	/*12227*/ uint16(xMatch),
	/*12228*/ uint16(xSetOp), uint16(FFREE),
	/*12230*/ uint16(xArgSTi),
	/*12231*/ uint16(xMatch),
	/*12232*/ uint16(xSetOp), uint16(FST),
	/*12234*/ uint16(xArgSTi),
	/*12235*/ uint16(xMatch),
	/*12236*/ uint16(xSetOp), uint16(FSTP),
	/*12238*/ uint16(xArgSTi),
	/*12239*/ uint16(xMatch),
	/*12240*/ uint16(xSetOp), uint16(FUCOM),
	/*12242*/ uint16(xArgSTi),
	/*12243*/ uint16(xMatch),
	/*12244*/ uint16(xSetOp), uint16(FUCOMP),
	/*12246*/ uint16(xArgSTi),
	/*12247*/ uint16(xMatch),
	/*12248*/ uint16(xCondByte), 49,
	0xc0, 12389,
	0xc1, 12389,
	0xc2, 12389,
	0xc3, 12389,
	0xc4, 12389,
	0xc5, 12389,
	0xc6, 12389,
	0xc7, 12389,
	0xc8, 12394,
	0xc9, 12394,
	0xca, 12394,
	0xcb, 12394,
	0xcc, 12394,
	0xcd, 12394,
	0xce, 12394,
	0xcf, 12394,
	0xD9, 12399,
	0xe0, 12402,
	0xe1, 12402,
	0xe2, 12402,
	0xe3, 12402,
	0xe4, 12402,
	0xe5, 12402,
	0xe6, 12402,
	0xe7, 12402,
	0xe8, 12407,
	0xe9, 12407,
	0xea, 12407,
	0xeb, 12407,
	0xec, 12407,
	0xed, 12407,
	0xee, 12407,
	0xef, 12407,
	0xf0, 12412,
	0xf1, 12412,
	0xf2, 12412,
	0xf3, 12412,
	0xf4, 12412,
	0xf5, 12412,
	0xf6, 12412,
	0xf7, 12412,
	0xf8, 12417,
	0xf9, 12417,
	0xfa, 12417,
	0xfb, 12417,
	0xfc, 12417,
	0xfd, 12417,
	0xfe, 12417,
	0xff, 12417,
	/*12348*/ uint16(xCondSlashR),
	12357, // 0
	12361, // 1
	12365, // 2
	12369, // 3
	12373, // 4
	12377, // 5
	12381, // 6
	12385, // 7
	/*12357*/ uint16(xSetOp), uint16(FIADD),
	/*12359*/ uint16(xArgM16int),
	/*12360*/ uint16(xMatch),
	/*12361*/ uint16(xSetOp), uint16(FIMUL),
	/*12363*/ uint16(xArgM16int),
	/*12364*/ uint16(xMatch),
	/*12365*/ uint16(xSetOp), uint16(FICOM),
	/*12367*/ uint16(xArgM16int),
	/*12368*/ uint16(xMatch),
	/*12369*/ uint16(xSetOp), uint16(FICOMP),
	/*12371*/ uint16(xArgM16int),
	/*12372*/ uint16(xMatch),
	/*12373*/ uint16(xSetOp), uint16(FISUB),
	/*12375*/ uint16(xArgM16int),
	/*12376*/ uint16(xMatch),
	/*12377*/ uint16(xSetOp), uint16(FISUBR),
	/*12379*/ uint16(xArgM16int),
	/*12380*/ uint16(xMatch),
	/*12381*/ uint16(xSetOp), uint16(FIDIV),
	/*12383*/ uint16(xArgM16int),
	/*12384*/ uint16(xMatch),
	/*12385*/ uint16(xSetOp), uint16(FIDIVR),
	/*12387*/ uint16(xArgM16int),
	/*12388*/ uint16(xMatch),
	/*12389*/ uint16(xSetOp), uint16(FADDP),
	/*12391*/ uint16(xArgSTi),
	/*12392*/ uint16(xArgST),
	/*12393*/ uint16(xMatch),
	/*12394*/ uint16(xSetOp), uint16(FMULP),
	/*12396*/ uint16(xArgSTi),
	/*12397*/ uint16(xArgST),
	/*12398*/ uint16(xMatch),
	/*12399*/ uint16(xSetOp), uint16(FCOMPP),
	/*12401*/ uint16(xMatch),
	/*12402*/ uint16(xSetOp), uint16(FSUBRP),
	/*12404*/ uint16(xArgSTi),
	/*12405*/ uint16(xArgST),
	/*12406*/ uint16(xMatch),
	/*12407*/ uint16(xSetOp), uint16(FSUBP),
	/*12409*/ uint16(xArgSTi),
	/*12410*/ uint16(xArgST),
	/*12411*/ uint16(xMatch),
	/*12412*/ uint16(xSetOp), uint16(FDIVRP),
	/*12414*/ uint16(xArgSTi),
	/*12415*/ uint16(xArgST),
	/*12416*/ uint16(xMatch),
	/*12417*/ uint16(xSetOp), uint16(FDIVP),
	/*12419*/ uint16(xArgSTi),
	/*12420*/ uint16(xArgST),
	/*12421*/ uint16(xMatch),
	/*12422*/ uint16(xCondByte), 25,
	0xc0, 12515,
	0xc1, 12515,
	0xc2, 12515,
	0xc3, 12515,
	0xc4, 12515,
	0xc5, 12515,
	0xc6, 12515,
	0xc7, 12515,
	0xE0, 12519,
	0xe8, 12523,
	0xe9, 12523,
	0xea, 12523,
	0xeb, 12523,
	0xec, 12523,
	0xed, 12523,
	0xee, 12523,
	0xef, 12523,
	0xf0, 12528,
	0xf1, 12528,
	0xf2, 12528,
	0xf3, 12528,
	0xf4, 12528,
	0xf5, 12528,
	0xf6, 12528,
	0xf7, 12528,
	/*12474*/ uint16(xCondSlashR),
	12483, // 0
	12487, // 1
	12491, // 2
	12495, // 3
	12499, // 4
	12503, // 5
	12507, // 6
	12511, // 7
	/*12483*/ uint16(xSetOp), uint16(FILD),
	/*12485*/ uint16(xArgM16int),
	/*12486*/ uint16(xMatch),
	/*12487*/ uint16(xSetOp), uint16(FISTTP),
	/*12489*/ uint16(xArgM16int),
	/*12490*/ uint16(xMatch),
	/*12491*/ uint16(xSetOp), uint16(FIST),
	/*12493*/ uint16(xArgM16int),
	/*12494*/ uint16(xMatch),
	/*12495*/ uint16(xSetOp), uint16(FISTP),
	/*12497*/ uint16(xArgM16int),
	/*12498*/ uint16(xMatch),
	/*12499*/ uint16(xSetOp), uint16(FBLD),
	/*12501*/ uint16(xArgM80dec),
	/*12502*/ uint16(xMatch),
	/*12503*/ uint16(xSetOp), uint16(FILD),
	/*12505*/ uint16(xArgM64int),
	/*12506*/ uint16(xMatch),
	/*12507*/ uint16(xSetOp), uint16(FBSTP),
	/*12509*/ uint16(xArgM80bcd),
	/*12510*/ uint16(xMatch),
	/*12511*/ uint16(xSetOp), uint16(FISTP),
	/*12513*/ uint16(xArgM64int),
	/*12514*/ uint16(xMatch),
	/*12515*/ uint16(xSetOp), uint16(FFREEP),
	/*12517*/ uint16(xArgSTi),
	/*12518*/ uint16(xMatch),
	/*12519*/ uint16(xSetOp), uint16(FNSTSW),
	/*12521*/ uint16(xArgAX),
	/*12522*/ uint16(xMatch),
	/*12523*/ uint16(xSetOp), uint16(FUCOMIP),
	/*12525*/ uint16(xArgST),
	/*12526*/ uint16(xArgSTi),
	/*12527*/ uint16(xMatch),
	/*12528*/ uint16(xSetOp), uint16(FCOMIP),
	/*12530*/ uint16(xArgST),
	/*12531*/ uint16(xArgSTi),
	/*12532*/ uint16(xMatch),
	/*12533*/ uint16(xSetOp), uint16(LOOPNE),
	/*12535*/ uint16(xReadCb),
	/*12536*/ uint16(xArgRel8),
	/*12537*/ uint16(xMatch),
	/*12538*/ uint16(xSetOp), uint16(LOOPE),
	/*12540*/ uint16(xReadCb),
	/*12541*/ uint16(xArgRel8),
	/*12542*/ uint16(xMatch),
	/*12543*/ uint16(xSetOp), uint16(LOOP),
	/*12545*/ uint16(xReadCb),
	/*12546*/ uint16(xArgRel8),
	/*12547*/ uint16(xMatch),
	/*12548*/ uint16(xCondIs64), 12551, 12565,
	/*12551*/ uint16(xCondAddrSize), 12555, 12560, 0,
	/*12555*/ uint16(xSetOp), uint16(JCXZ),
	/*12557*/ uint16(xReadCb),
	/*12558*/ uint16(xArgRel8),
	/*12559*/ uint16(xMatch),
	/*12560*/ uint16(xSetOp), uint16(JECXZ),
	/*12562*/ uint16(xReadCb),
	/*12563*/ uint16(xArgRel8),
	/*12564*/ uint16(xMatch),
	/*12565*/ uint16(xCondAddrSize), 0, 12560, 12569,
	/*12569*/ uint16(xSetOp), uint16(JRCXZ),
	/*12571*/ uint16(xReadCb),
	/*12572*/ uint16(xArgRel8),
	/*12573*/ uint16(xMatch),
	/*12574*/ uint16(xSetOp), uint16(IN),
	/*12576*/ uint16(xReadIb),
	/*12577*/ uint16(xArgAL),
	/*12578*/ uint16(xArgImm8u),
	/*12579*/ uint16(xMatch),
	/*12580*/ uint16(xCondDataSize), 12584, 12590, 12596,
	/*12584*/ uint16(xSetOp), uint16(IN),
	/*12586*/ uint16(xReadIb),
	/*12587*/ uint16(xArgAX),
	/*12588*/ uint16(xArgImm8u),
	/*12589*/ uint16(xMatch),
	/*12590*/ uint16(xSetOp), uint16(IN),
	/*12592*/ uint16(xReadIb),
	/*12593*/ uint16(xArgEAX),
	/*12594*/ uint16(xArgImm8u),
	/*12595*/ uint16(xMatch),
	/*12596*/ uint16(xSetOp), uint16(IN),
	/*12598*/ uint16(xReadIb),
	/*12599*/ uint16(xArgEAX),
	/*12600*/ uint16(xArgImm8u),
	/*12601*/ uint16(xMatch),
	/*12602*/ uint16(xSetOp), uint16(OUT),
	/*12604*/ uint16(xReadIb),
	/*12605*/ uint16(xArgImm8u),
	/*12606*/ uint16(xArgAL),
	/*12607*/ uint16(xMatch),
	/*12608*/ uint16(xCondDataSize), 12612, 12618, 12624,
	/*12612*/ uint16(xSetOp), uint16(OUT),
	/*12614*/ uint16(xReadIb),
	/*12615*/ uint16(xArgImm8u),
	/*12616*/ uint16(xArgAX),
	/*12617*/ uint16(xMatch),
	/*12618*/ uint16(xSetOp), uint16(OUT),
	/*12620*/ uint16(xReadIb),
	/*12621*/ uint16(xArgImm8u),
	/*12622*/ uint16(xArgEAX),
	/*12623*/ uint16(xMatch),
	/*12624*/ uint16(xSetOp), uint16(OUT),
	/*12626*/ uint16(xReadIb),
	/*12627*/ uint16(xArgImm8u),
	/*12628*/ uint16(xArgEAX),
	/*12629*/ uint16(xMatch),
	/*12630*/ uint16(xCondIs64), 12633, 12647,
	/*12633*/ uint16(xCondDataSize), 12637, 12642, 0,
	/*12637*/ uint16(xSetOp), uint16(CALL),
	/*12639*/ uint16(xReadCw),
	/*12640*/ uint16(xArgRel16),
	/*12641*/ uint16(xMatch),
	/*12642*/ uint16(xSetOp), uint16(CALL),
	/*12644*/ uint16(xReadCd),
	/*12645*/ uint16(xArgRel32),
	/*12646*/ uint16(xMatch),
	/*12647*/ uint16(xCondDataSize), 12651, 12642, 12656,
	/*12651*/ uint16(xSetOp), uint16(CALL),
	/*12653*/ uint16(xReadCd),
	/*12654*/ uint16(xArgRel32),
	/*12655*/ uint16(xMatch),
	/*12656*/ uint16(xSetOp), uint16(CALL),
	/*12658*/ uint16(xReadCd),
	/*12659*/ uint16(xArgRel32),
	/*12660*/ uint16(xMatch),
	/*12661*/ uint16(xCondIs64), 12664, 12678,
	/*12664*/ uint16(xCondDataSize), 12668, 12673, 0,
	/*12668*/ uint16(xSetOp), uint16(JMP),
	/*12670*/ uint16(xReadCw),
	/*12671*/ uint16(xArgRel16),
	/*12672*/ uint16(xMatch),
	/*12673*/ uint16(xSetOp), uint16(JMP),
	/*12675*/ uint16(xReadCd),
	/*12676*/ uint16(xArgRel32),
	/*12677*/ uint16(xMatch),
	/*12678*/ uint16(xCondDataSize), 12682, 12673, 12687,
	/*12682*/ uint16(xSetOp), uint16(JMP),
	/*12684*/ uint16(xReadCd),
	/*12685*/ uint16(xArgRel32),
	/*12686*/ uint16(xMatch),
	/*12687*/ uint16(xSetOp), uint16(JMP),
	/*12689*/ uint16(xReadCd),
	/*12690*/ uint16(xArgRel32),
	/*12691*/ uint16(xMatch),
	/*12692*/ uint16(xCondIs64), 12695, 0,
	/*12695*/ uint16(xCondDataSize), 12699, 12704, 0,
	/*12699*/ uint16(xSetOp), uint16(LJMP),
	/*12701*/ uint16(xReadCd),
	/*12702*/ uint16(xArgPtr16colon16),
	/*12703*/ uint16(xMatch),
	/*12704*/ uint16(xSetOp), uint16(LJMP),
	/*12706*/ uint16(xReadCp),
	/*12707*/ uint16(xArgPtr16colon32),
	/*12708*/ uint16(xMatch),
	/*12709*/ uint16(xSetOp), uint16(JMP),
	/*12711*/ uint16(xReadCb),
	/*12712*/ uint16(xArgRel8),
	/*12713*/ uint16(xMatch),
	/*12714*/ uint16(xSetOp), uint16(IN),
	/*12716*/ uint16(xArgAL),
	/*12717*/ uint16(xArgDX),
	/*12718*/ uint16(xMatch),
	/*12719*/ uint16(xCondDataSize), 12723, 12728, 12733,
	/*12723*/ uint16(xSetOp), uint16(IN),
	/*12725*/ uint16(xArgAX),
	/*12726*/ uint16(xArgDX),
	/*12727*/ uint16(xMatch),
	/*12728*/ uint16(xSetOp), uint16(IN),
	/*12730*/ uint16(xArgEAX),
	/*12731*/ uint16(xArgDX),
	/*12732*/ uint16(xMatch),
	/*12733*/ uint16(xSetOp), uint16(IN),
	/*12735*/ uint16(xArgEAX),
	/*12736*/ uint16(xArgDX),
	/*12737*/ uint16(xMatch),
	/*12738*/ uint16(xSetOp), uint16(OUT),
	/*12740*/ uint16(xArgDX),
	/*12741*/ uint16(xArgAL),
	/*12742*/ uint16(xMatch),
	/*12743*/ uint16(xCondDataSize), 12747, 12752, 12757,
	/*12747*/ uint16(xSetOp), uint16(OUT),
	/*12749*/ uint16(xArgDX),
	/*12750*/ uint16(xArgAX),
	/*12751*/ uint16(xMatch),
	/*12752*/ uint16(xSetOp), uint16(OUT),
	/*12754*/ uint16(xArgDX),
	/*12755*/ uint16(xArgEAX),
	/*12756*/ uint16(xMatch),
	/*12757*/ uint16(xSetOp), uint16(OUT),
	/*12759*/ uint16(xArgDX),
	/*12760*/ uint16(xArgEAX),
	/*12761*/ uint16(xMatch),
	/*12762*/ uint16(xSetOp), uint16(ICEBP),
	/*12764*/ uint16(xMatch),
	/*12765*/ uint16(xSetOp), uint16(HLT),
	/*12767*/ uint16(xMatch),
	/*12768*/ uint16(xSetOp), uint16(CMC),
	/*12770*/ uint16(xMatch),
	/*12771*/ uint16(xCondSlashR),
	12780, // 0
	0,     // 1
	12786, // 2
	12790, // 3
	12794, // 4
	12798, // 5
	12802, // 6
	12806, // 7
	/*12780*/ uint16(xSetOp), uint16(TEST),
	/*12782*/ uint16(xReadIb),
	/*12783*/ uint16(xArgRM8),
	/*12784*/ uint16(xArgImm8u),
	/*12785*/ uint16(xMatch),
	/*12786*/ uint16(xSetOp), uint16(NOT),
	/*12788*/ uint16(xArgRM8),
	/*12789*/ uint16(xMatch),
	/*12790*/ uint16(xSetOp), uint16(NEG),
	/*12792*/ uint16(xArgRM8),
	/*12793*/ uint16(xMatch),
	/*12794*/ uint16(xSetOp), uint16(MUL),
	/*12796*/ uint16(xArgRM8),
	/*12797*/ uint16(xMatch),
	/*12798*/ uint16(xSetOp), uint16(IMUL),
	/*12800*/ uint16(xArgRM8),
	/*12801*/ uint16(xMatch),
	/*12802*/ uint16(xSetOp), uint16(DIV),
	/*12804*/ uint16(xArgRM8),
	/*12805*/ uint16(xMatch),
	/*12806*/ uint16(xSetOp), uint16(IDIV),
	/*12808*/ uint16(xArgRM8),
	/*12809*/ uint16(xMatch),
	/*12810*/ uint16(xCondSlashR),
	12819, // 0
	0,     // 1
	12848, // 2
	12871, // 3
	12894, // 4
	12917, // 5
	12940, // 6
	12963, // 7
	/*12819*/ uint16(xCondIs64), 12822, 12838,
	/*12822*/ uint16(xCondDataSize), 12826, 12832, 0,
	/*12826*/ uint16(xSetOp), uint16(TEST),
	/*12828*/ uint16(xReadIw),
	/*12829*/ uint16(xArgRM16),
	/*12830*/ uint16(xArgImm16),
	/*12831*/ uint16(xMatch),
	/*12832*/ uint16(xSetOp), uint16(TEST),
	/*12834*/ uint16(xReadId),
	/*12835*/ uint16(xArgRM32),
	/*12836*/ uint16(xArgImm32),
	/*12837*/ uint16(xMatch),
	/*12838*/ uint16(xCondDataSize), 12826, 12832, 12842,
	/*12842*/ uint16(xSetOp), uint16(TEST),
	/*12844*/ uint16(xReadId),
	/*12845*/ uint16(xArgRM64),
	/*12846*/ uint16(xArgImm32),
	/*12847*/ uint16(xMatch),
	/*12848*/ uint16(xCondIs64), 12851, 12863,
	/*12851*/ uint16(xCondDataSize), 12855, 12859, 0,
	/*12855*/ uint16(xSetOp), uint16(NOT),
	/*12857*/ uint16(xArgRM16),
	/*12858*/ uint16(xMatch),
	/*12859*/ uint16(xSetOp), uint16(NOT),
	/*12861*/ uint16(xArgRM32),
	/*12862*/ uint16(xMatch),
	/*12863*/ uint16(xCondDataSize), 12855, 12859, 12867,
	/*12867*/ uint16(xSetOp), uint16(NOT),
	/*12869*/ uint16(xArgRM64),
	/*12870*/ uint16(xMatch),
	/*12871*/ uint16(xCondIs64), 12874, 12886,
	/*12874*/ uint16(xCondDataSize), 12878, 12882, 0,
	/*12878*/ uint16(xSetOp), uint16(NEG),
	/*12880*/ uint16(xArgRM16),
	/*12881*/ uint16(xMatch),
	/*12882*/ uint16(xSetOp), uint16(NEG),
	/*12884*/ uint16(xArgRM32),
	/*12885*/ uint16(xMatch),
	/*12886*/ uint16(xCondDataSize), 12878, 12882, 12890,
	/*12890*/ uint16(xSetOp), uint16(NEG),
	/*12892*/ uint16(xArgRM64),
	/*12893*/ uint16(xMatch),
	/*12894*/ uint16(xCondIs64), 12897, 12909,
	/*12897*/ uint16(xCondDataSize), 12901, 12905, 0,
	/*12901*/ uint16(xSetOp), uint16(MUL),
	/*12903*/ uint16(xArgRM16),
	/*12904*/ uint16(xMatch),
	/*12905*/ uint16(xSetOp), uint16(MUL),
	/*12907*/ uint16(xArgRM32),
	/*12908*/ uint16(xMatch),
	/*12909*/ uint16(xCondDataSize), 12901, 12905, 12913,
	/*12913*/ uint16(xSetOp), uint16(MUL),
	/*12915*/ uint16(xArgRM64),
	/*12916*/ uint16(xMatch),
	/*12917*/ uint16(xCondIs64), 12920, 12932,
	/*12920*/ uint16(xCondDataSize), 12924, 12928, 0,
	/*12924*/ uint16(xSetOp), uint16(IMUL),
	/*12926*/ uint16(xArgRM16),
	/*12927*/ uint16(xMatch),
	/*12928*/ uint16(xSetOp), uint16(IMUL),
	/*12930*/ uint16(xArgRM32),
	/*12931*/ uint16(xMatch),
	/*12932*/ uint16(xCondDataSize), 12924, 12928, 12936,
	/*12936*/ uint16(xSetOp), uint16(IMUL),
	/*12938*/ uint16(xArgRM64),
	/*12939*/ uint16(xMatch),
	/*12940*/ uint16(xCondIs64), 12943, 12955,
	/*12943*/ uint16(xCondDataSize), 12947, 12951, 0,
	/*12947*/ uint16(xSetOp), uint16(DIV),
	/*12949*/ uint16(xArgRM16),
	/*12950*/ uint16(xMatch),
	/*12951*/ uint16(xSetOp), uint16(DIV),
	/*12953*/ uint16(xArgRM32),
	/*12954*/ uint16(xMatch),
	/*12955*/ uint16(xCondDataSize), 12947, 12951, 12959,
	/*12959*/ uint16(xSetOp), uint16(DIV),
	/*12961*/ uint16(xArgRM64),
	/*12962*/ uint16(xMatch),
	/*12963*/ uint16(xCondIs64), 12966, 12978,
	/*12966*/ uint16(xCondDataSize), 12970, 12974, 0,
	/*12970*/ uint16(xSetOp), uint16(IDIV),
	/*12972*/ uint16(xArgRM16),
	/*12973*/ uint16(xMatch),
	/*12974*/ uint16(xSetOp), uint16(IDIV),
	/*12976*/ uint16(xArgRM32),
	/*12977*/ uint16(xMatch),
	/*12978*/ uint16(xCondDataSize), 12970, 12974, 12982,
	/*12982*/ uint16(xSetOp), uint16(IDIV),
	/*12984*/ uint16(xArgRM64),
	/*12985*/ uint16(xMatch),
	/*12986*/ uint16(xSetOp), uint16(CLC),
	/*12988*/ uint16(xMatch),
	/*12989*/ uint16(xSetOp), uint16(STC),
	/*12991*/ uint16(xMatch),
	/*12992*/ uint16(xSetOp), uint16(CLI),
	/*12994*/ uint16(xMatch),
	/*12995*/ uint16(xSetOp), uint16(STI),
	/*12997*/ uint16(xMatch),
	/*12998*/ uint16(xSetOp), uint16(CLD),
	/*13000*/ uint16(xMatch),
	/*13001*/ uint16(xSetOp), uint16(STD),
	/*13003*/ uint16(xMatch),
	/*13004*/ uint16(xCondSlashR),
	13013, // 0
	13017, // 1
	0,     // 2
	0,     // 3
	0,     // 4
	0,     // 5
	0,     // 6
	0,     // 7
	/*13013*/ uint16(xSetOp), uint16(INC),
	/*13015*/ uint16(xArgRM8),
	/*13016*/ uint16(xMatch),
	/*13017*/ uint16(xSetOp), uint16(DEC),
	/*13019*/ uint16(xArgRM8),
	/*13020*/ uint16(xMatch),
	/*13021*/ uint16(xCondSlashR),
	13030, // 0
	13053, // 1
	13076, // 2
	13095, // 3
	13118, // 4
	13137, // 5
	13160, // 6
	0,     // 7
	/*13030*/ uint16(xCondIs64), 13033, 13045,
	/*13033*/ uint16(xCondDataSize), 13037, 13041, 0,
	/*13037*/ uint16(xSetOp), uint16(INC),
	/*13039*/ uint16(xArgRM16),
	/*13040*/ uint16(xMatch),
	/*13041*/ uint16(xSetOp), uint16(INC),
	/*13043*/ uint16(xArgRM32),
	/*13044*/ uint16(xMatch),
	/*13045*/ uint16(xCondDataSize), 13037, 13041, 13049,
	/*13049*/ uint16(xSetOp), uint16(INC),
	/*13051*/ uint16(xArgRM64),
	/*13052*/ uint16(xMatch),
	/*13053*/ uint16(xCondIs64), 13056, 13068,
	/*13056*/ uint16(xCondDataSize), 13060, 13064, 0,
	/*13060*/ uint16(xSetOp), uint16(DEC),
	/*13062*/ uint16(xArgRM16),
	/*13063*/ uint16(xMatch),
	/*13064*/ uint16(xSetOp), uint16(DEC),
	/*13066*/ uint16(xArgRM32),
	/*13067*/ uint16(xMatch),
	/*13068*/ uint16(xCondDataSize), 13060, 13064, 13072,
	/*13072*/ uint16(xSetOp), uint16(DEC),
	/*13074*/ uint16(xArgRM64),
	/*13075*/ uint16(xMatch),
	/*13076*/ uint16(xCondIs64), 13079, 13091,
	/*13079*/ uint16(xCondDataSize), 13083, 13087, 0,
	/*13083*/ uint16(xSetOp), uint16(CALL),
	/*13085*/ uint16(xArgRM16),
	/*13086*/ uint16(xMatch),
	/*13087*/ uint16(xSetOp), uint16(CALL),
	/*13089*/ uint16(xArgRM32),
	/*13090*/ uint16(xMatch),
	/*13091*/ uint16(xSetOp), uint16(CALL),
	/*13093*/ uint16(xArgRM64),
	/*13094*/ uint16(xMatch),
	/*13095*/ uint16(xCondIs64), 13098, 13110,
	/*13098*/ uint16(xCondDataSize), 13102, 13106, 0,
	/*13102*/ uint16(xSetOp), uint16(LCALL),
	/*13104*/ uint16(xArgM16colon16),
	/*13105*/ uint16(xMatch),
	/*13106*/ uint16(xSetOp), uint16(LCALL),
	/*13108*/ uint16(xArgM16colon32),
	/*13109*/ uint16(xMatch),
	/*13110*/ uint16(xCondDataSize), 13102, 13106, 13114,
	/*13114*/ uint16(xSetOp), uint16(LCALL),
	/*13116*/ uint16(xArgM16colon64),
	/*13117*/ uint16(xMatch),
	/*13118*/ uint16(xCondIs64), 13121, 13133,
	/*13121*/ uint16(xCondDataSize), 13125, 13129, 0,
	/*13125*/ uint16(xSetOp), uint16(JMP),
	/*13127*/ uint16(xArgRM16),
	/*13128*/ uint16(xMatch),
	/*13129*/ uint16(xSetOp), uint16(JMP),
	/*13131*/ uint16(xArgRM32),
	/*13132*/ uint16(xMatch),
	/*13133*/ uint16(xSetOp), uint16(JMP),
	/*13135*/ uint16(xArgRM64),
	/*13136*/ uint16(xMatch),
	/*13137*/ uint16(xCondIs64), 13140, 13152,
	/*13140*/ uint16(xCondDataSize), 13144, 13148, 0,
	/*13144*/ uint16(xSetOp), uint16(LJMP),
	/*13146*/ uint16(xArgM16colon16),
	/*13147*/ uint16(xMatch),
	/*13148*/ uint16(xSetOp), uint16(LJMP),
	/*13150*/ uint16(xArgM16colon32),
	/*13151*/ uint16(xMatch),
	/*13152*/ uint16(xCondDataSize), 13144, 13148, 13156,
	/*13156*/ uint16(xSetOp), uint16(LJMP),
	/*13158*/ uint16(xArgM16colon64),
	/*13159*/ uint16(xMatch),
	/*13160*/ uint16(xCondIs64), 13163, 13175,
	/*13163*/ uint16(xCondDataSize), 13167, 13171, 0,
	/*13167*/ uint16(xSetOp), uint16(PUSH),
	/*13169*/ uint16(xArgRM16),
	/*13170*/ uint16(xMatch),
	/*13171*/ uint16(xSetOp), uint16(PUSH),
	/*13173*/ uint16(xArgRM32),
	/*13174*/ uint16(xMatch),
	/*13175*/ uint16(xCondDataSize), 13167, 13179, 13183,
	/*13179*/ uint16(xSetOp), uint16(PUSH),
	/*13181*/ uint16(xArgRM64),
	/*13182*/ uint16(xMatch),
	/*13183*/ uint16(xSetOp), uint16(PUSH),
	/*13185*/ uint16(xArgRM64),
	/*13186*/ uint16(xMatch),
}

const (
	_ Op = iota

	AAA
	AAD
	AAM
	AAS
	ADC
	ADD
	ADDPD
	ADDPS
	ADDSD
	ADDSS
	ADDSUBPD
	ADDSUBPS
	AESDEC
	AESDECLAST
	AESENC
	AESENCLAST
	AESIMC
	AESKEYGENASSIST
	AND
	ANDNPD
	ANDNPS
	ANDPD
	ANDPS
	ARPL
	BLENDPD
	BLENDPS
	BLENDVPD
	BLENDVPS
	BOUND
	BSF
	BSR
	BSWAP
	BT
	BTC
	BTR
	BTS
	CALL
	CBW
	CDQ
	CDQE
	CLC
	CLD
	CLFLUSH
	CLI
	CLTS
	CMC
	CMOVA
	CMOVAE
	CMOVB
	CMOVBE
	CMOVE
	CMOVG
	CMOVGE
	CMOVL
	CMOVLE
	CMOVNE
	CMOVNO
	CMOVNP
	CMOVNS
	CMOVO
	CMOVP
	CMOVS
	CMP
	CMPPD
	CMPPS
	CMPSB
	CMPSD
	CMPSD_XMM
	CMPSQ
	CMPSS
	CMPSW
	CMPXCHG
	CMPXCHG16B
	CMPXCHG8B
	COMISD
	COMISS
	CPUID
	CQO
	CRC32
	CVTDQ2PD
	CVTDQ2PS
	CVTPD2DQ
	CVTPD2PI
	CVTPD2PS
	CVTPI2PD
	CVTPI2PS
	CVTPS2DQ
	CVTPS2PD
	CVTPS2PI
	CVTSD2SI
	CVTSD2SS
	CVTSI2SD
	CVTSI2SS
	CVTSS2SD
	CVTSS2SI
	CVTTPD2DQ
	CVTTPD2PI
	CVTTPS2DQ
	CVTTPS2PI
	CVTTSD2SI
	CVTTSS2SI
	CWD
	CWDE
	DAA
	DAS
	DEC
	DIV
	DIVPD
	DIVPS
	DIVSD
	DIVSS
	DPPD
	DPPS
	EMMS
	ENTER
	EXTRACTPS
	F2XM1
	FABS
	FADD
	FADDP
	FBLD
	FBSTP
	FCHS
	FCMOVB
	FCMOVBE
	FCMOVE
	FCMOVNB
	FCMOVNBE
	FCMOVNE
	FCMOVNU
	FCMOVU
	FCOM
	FCOMI
	FCOMIP
	FCOMP
	FCOMPP
	FCOS
	FDECSTP
	FDIV
	FDIVP
	FDIVR
	FDIVRP
	FFREE
	FFREEP
	FIADD
	FICOM
	FICOMP
	FIDIV
	FIDIVR
	FILD
	FIMUL
	FINCSTP
	FIST
	FISTP
	FISTTP
	FISUB
	FISUBR
	FLD
	FLD1
	FLDCW
	FLDENV
	FLDL2E
	FLDL2T
	FLDLG2
	FLDPI
	FMUL
	FMULP
	FNCLEX
	FNINIT
	FNOP
	FNSAVE
	FNSTCW
	FNSTENV
	FNSTSW
	FPATAN
	FPREM
	FPREM1
	FPTAN
	FRNDINT
	FRSTOR
	FSCALE
	FSIN
	FSINCOS
	FSQRT
	FST
	FSTP
	FSUB
	FSUBP
	FSUBR
	FSUBRP
	FTST
	FUCOM
	FUCOMI
	FUCOMIP
	FUCOMP
	FUCOMPP
	FWAIT
	FXAM
	FXCH
	FXRSTOR
	FXRSTOR64
	FXSAVE
	FXSAVE64
	FXTRACT
	FYL2X
	FYL2XP1
	HADDPD
	HADDPS
	HLT
	HSUBPD
	HSUBPS
	ICEBP
	IDIV
	IMUL
	IN
	INC
	INSB
	INSD
	INSERTPS
	INSW
	INT
	INTO
	INVD
	INVLPG
	INVPCID
	IRET
	IRETD
	IRETQ
	JA
	JAE
	JB
	JBE
	JCXZ
	JE
	JECXZ
	JG
	JGE
	JL
	JLE
	JMP
	JNE
	JNO
	JNP
	JNS
	JO
	JP
	JRCXZ
	JS
	LAHF
	LAR
	LCALL
	LDDQU
	LDMXCSR
	LDS
	LEA
	LEAVE
	LES
	LFENCE
	LFS
	LGDT
	LGS
	LIDT
	LJMP
	LLDT
	LMSW
	LODSB
	LODSD
	LODSQ
	LODSW
	LOOP
	LOOPE
	LOOPNE
	LRET
	LSL
	LSS
	LTR
	LZCNT
	MASKMOVDQU
	MASKMOVQ
	MAXPD
	MAXPS
	MAXSD
	MAXSS
	MFENCE
	MINPD
	MINPS
	MINSD
	MINSS
	MONITOR
	MOV
	MOVAPD
	MOVAPS
	MOVBE
	MOVD
	MOVDDUP
	MOVDQ2Q
	MOVDQA
	MOVDQU
	MOVHLPS
	MOVHPD
	MOVHPS
	MOVLHPS
	MOVLPD
	MOVLPS
	MOVMSKPD
	MOVMSKPS
	MOVNTDQ
	MOVNTDQA
	MOVNTI
	MOVNTPD
	MOVNTPS
	MOVNTQ
	MOVNTSD
	MOVNTSS
	MOVQ
	MOVQ2DQ
	MOVSB
	MOVSD
	MOVSD_XMM
	MOVSHDUP
	MOVSLDUP
	MOVSQ
	MOVSS
	MOVSW
	MOVSX
	MOVSXD
	MOVUPD
	MOVUPS
	MOVZX
	MPSADBW
	MUL
	MULPD
	MULPS
	MULSD
	MULSS
	MWAIT
	NEG
	NOP
	NOT
	OR
	ORPD
	ORPS
	OUT
	OUTSB
	OUTSD
	OUTSW
	PABSB
	PABSD
	PABSW
	PACKSSDW
	PACKSSWB
	PACKUSDW
	PACKUSWB
	PADDB
	PADDD
	PADDQ
	PADDSB
	PADDSW
	PADDUSB
	PADDUSW
	PADDW
	PALIGNR
	PAND
	PANDN
	PAUSE
	PAVGB
	PAVGW
	PBLENDVB
	PBLENDW
	PCLMULQDQ
	PCMPEQB
	PCMPEQD
	PCMPEQQ
	PCMPEQW
	PCMPESTRI
	PCMPESTRM
	PCMPGTB
	PCMPGTD
	PCMPGTQ
	PCMPGTW
	PCMPISTRI
	PCMPISTRM
	PEXTRB
	PEXTRD
	PEXTRQ
	PEXTRW
	PHADDD
	PHADDSW
	PHADDW
	PHMINPOSUW
	PHSUBD
	PHSUBSW
	PHSUBW
	PINSRB
	PINSRD
	PINSRQ
	PINSRW
	PMADDUBSW
	PMADDWD
	PMAXSB
	PMAXSD
	PMAXSW
	PMAXUB
	PMAXUD
	PMAXUW
	PMINSB
	PMINSD
	PMINSW
	PMINUB
	PMINUD
	PMINUW
	PMOVMSKB
	PMOVSXBD
	PMOVSXBQ
	PMOVSXBW
	PMOVSXDQ
	PMOVSXWD
	PMOVSXWQ
	PMOVZXBD
	PMOVZXBQ
	PMOVZXBW
	PMOVZXDQ
	PMOVZXWD
	PMOVZXWQ
	PMULDQ
	PMULHRSW
	PMULHUW
	PMULHW
	PMULLD
	PMULLW
	PMULUDQ
	POP
	POPA
	POPAD
	POPCNT
	POPF
	POPFD
	POPFQ
	POR
	PREFETCHNTA
	PREFETCHT0
	PREFETCHT1
	PREFETCHT2
	PREFETCHW
	PSADBW
	PSHUFB
	PSHUFD
	PSHUFHW
	PSHUFLW
	PSHUFW
	PSIGNB
	PSIGND
	PSIGNW
	PSLLD
	PSLLDQ
	PSLLQ
	PSLLW
	PSRAD
	PSRAW
	PSRLD
	PSRLDQ
	PSRLQ
	PSRLW
	PSUBB
	PSUBD
	PSUBQ
	PSUBSB
	PSUBSW
	PSUBUSB
	PSUBUSW
	PSUBW
	PTEST
	PUNPCKHBW
	PUNPCKHDQ
	PUNPCKHQDQ
	PUNPCKHWD
	PUNPCKLBW
	PUNPCKLDQ
	PUNPCKLQDQ
	PUNPCKLWD
	PUSH
	PUSHA
	PUSHAD
	PUSHF
	PUSHFD
	PUSHFQ
	PXOR
	RCL
	RCPPS
	RCPSS
	RCR
	RDFSBASE
	RDGSBASE
	RDMSR
	RDPMC
	RDRAND
	RDTSC
	RDTSCP
	RET
	ROL
	ROR
	ROUNDPD
	ROUNDPS
	ROUNDSD
	ROUNDSS
	RSM
	RSQRTPS
	RSQRTSS
	SAHF
	SAR
	SBB
	SCASB
	SCASD
	SCASQ
	SCASW
	SETA
	SETAE
	SETB
	SETBE
	SETE
	SETG
	SETGE
	SETL
	SETLE
	SETNE
	SETNO
	SETNP
	SETNS
	SETO
	SETP
	SETS
	SFENCE
	SGDT
	SHL
	SHLD
	SHR
	SHRD
	SHUFPD
	SHUFPS
	SIDT
	SLDT
	SMSW
	SQRTPD
	SQRTPS
	SQRTSD
	SQRTSS
	STC
	STD
	STI
	STMXCSR
	STOSB
	STOSD
	STOSQ
	STOSW
	STR
	SUB
	SUBPD
	SUBPS
	SUBSD
	SUBSS
	SWAPGS
	SYSCALL
	SYSENTER
	SYSEXIT
	SYSRET
	TEST
	TZCNT
	UCOMISD
	UCOMISS
	UD1
	UD2
	UNPCKHPD
	UNPCKHPS
	UNPCKLPD
	UNPCKLPS
	VERR
	VERW
	WBINVD
	WRFSBASE
	WRGSBASE
	WRMSR
	XABORT
	XADD
	XBEGIN
	XCHG
	XEND
	XGETBV
	XLATB
	XOR
	XORPD
	XORPS
	XRSTOR
	XRSTOR64
	XRSTORS
	XRSTORS64
	XSAVE
	XSAVE64
	XSAVEC
	XSAVEC64
	XSAVEOPT
	XSAVEOPT64
	XSAVES
	XSAVES64
	XSETBV
	XTEST
)

const maxOp = XTEST

var opNames = [...]string{
	AAA:             "AAA",
	AAD:             "AAD",
	AAM:             "AAM",
	AAS:             "AAS",
	ADC:             "ADC",
	ADD:             "ADD",
	ADDPD:           "ADDPD",
	ADDPS:           "ADDPS",
	ADDSD:           "ADDSD",
	ADDSS:           "ADDSS",
	ADDSUBPD:        "ADDSUBPD",
	ADDSUBPS:        "ADDSUBPS",
	AESDEC:          "AESDEC",
	AESDECLAST:      "AESDECLAST",
	AESENC:          "AESENC",
	AESENCLAST:      "AESENCLAST",
	AESIMC:          "AESIMC",
	AESKEYGENASSIST: "AESKEYGENASSIST",
	AND:             "AND",
	ANDNPD:          "ANDNPD",
	ANDNPS:          "ANDNPS",
	ANDPD:           "ANDPD",
	ANDPS:           "ANDPS",
	ARPL:            "ARPL",
	BLENDPD:         "BLENDPD",
	BLENDPS:         "BLENDPS",
	BLENDVPD:        "BLENDVPD",
	BLENDVPS:        "BLENDVPS",
	BOUND:           "BOUND",
	BSF:             "BSF",
	BSR:             "BSR",
	BSWAP:           "BSWAP",
	BT:              "BT",
	BTC:             "BTC",
	BTR:             "BTR",
	BTS:             "BTS",
	CALL:            "CALL",
	CBW:             "CBW",
	CDQ:             "CDQ",
	CDQE:            "CDQE",
	CLC:             "CLC",
	CLD:             "CLD",
	CLFLUSH:         "CLFLUSH",
	CLI:             "CLI",
	CLTS:            "CLTS",
	CMC:             "CMC",
	CMOVA:           "CMOVA",
	CMOVAE:          "CMOVAE",
	CMOVB:           "CMOVB",
	CMOVBE:          "CMOVBE",
	CMOVE:           "CMOVE",
	CMOVG:           "CMOVG",
	CMOVGE:          "CMOVGE",
	CMOVL:           "CMOVL",
	CMOVLE:          "CMOVLE",
	CMOVNE:          "CMOVNE",
	CMOVNO:          "CMOVNO",
	CMOVNP:          "CMOVNP",
	CMOVNS:          "CMOVNS",
	CMOVO:           "CMOVO",
	CMOVP:           "CMOVP",
	CMOVS:           "CMOVS",
	CMP:             "CMP",
	CMPPD:           "CMPPD",
	CMPPS:           "CMPPS",
	CMPSB:           "CMPSB",
	CMPSD:           "CMPSD",
	CMPSD_XMM:       "CMPSD_XMM",
	CMPSQ:           "CMPSQ",
	CMPSS:           "CMPSS",
	CMPSW:           "CMPSW",
	CMPXCHG:         "CMPXCHG",
	CMPXCHG16B:      "CMPXCHG16B",
	CMPXCHG8B:       "CMPXCHG8B",
	COMISD:          "COMISD",
	COMISS:          "COMISS",
	CPUID:           "CPUID",
	CQO:             "CQO",
	CRC32:           "CRC32",
	CVTDQ2PD:        "CVTDQ2PD",
	CVTDQ2PS:        "CVTDQ2PS",
	CVTPD2DQ:        "CVTPD2DQ",
	CVTPD2PI:        "CVTPD2PI",
	CVTPD2PS:        "CVTPD2PS",
	CVTPI2PD:        "CVTPI2PD",
	CVTPI2PS:        "CVTPI2PS",
	CVTPS2DQ:        "CVTPS2DQ",
	CVTPS2PD:        "CVTPS2PD",
	CVTPS2PI:        "CVTPS2PI",
	CVTSD2SI:        "CVTSD2SI",
	CVTSD2SS:        "CVTSD2SS",
	CVTSI2SD:        "CVTSI2SD",
	CVTSI2SS:        "CVTSI2SS",
	CVTSS2SD:        "CVTSS2SD",
	CVTSS2SI:        "CVTSS2SI",
	CVTTPD2DQ:       "CVTTPD2DQ",
	CVTTPD2PI:       "CVTTPD2PI",
	CVTTPS2DQ:       "CVTTPS2DQ",
	CVTTPS2PI:       "CVTTPS2PI",
	CVTTSD2SI:       "CVTTSD2SI",
	CVTTSS2SI:       "CVTTSS2SI",
	CWD:             "CWD",
	CWDE:            "CWDE",
	DAA:             "DAA",
	DAS:             "DAS",
	DEC:             "DEC",
	DIV:             "DIV",
	DIVPD:           "DIVPD",
	DIVPS:           "DIVPS",
	DIVSD:           "DIVSD",
	DIVSS:           "DIVSS",
	DPPD:            "DPPD",
	DPPS:            "DPPS",
	EMMS:            "EMMS",
	ENTER:           "ENTER",
	EXTRACTPS:       "EXTRACTPS",
	F2XM1:           "F2XM1",
	FABS:            "FABS",
	FADD:            "FADD",
	FADDP:           "FADDP",
	FBLD:            "FBLD",
	FBSTP:           "FBSTP",
	FCHS:            "FCHS",
	FCMOVB:          "FCMOVB",
	FCMOVBE:         "FCMOVBE",
	FCMOVE:          "FCMOVE",
	FCMOVNB:         "FCMOVNB",
	FCMOVNBE:        "FCMOVNBE",
	FCMOVNE:         "FCMOVNE",
	FCMOVNU:         "FCMOVNU",
	FCMOVU:          "FCMOVU",
	FCOM:            "FCOM",
	FCOMI:           "FCOMI",
	FCOMIP:          "FCOMIP",
	FCOMP:           "FCOMP",
	FCOMPP:          "FCOMPP",
	FCOS:            "FCOS",
	FDECSTP:         "FDECSTP",
	FDIV:            "FDIV",
	FDIVP:           "FDIVP",
	FDIVR:           "FDIVR",
	FDIVRP:          "FDIVRP",
	FFREE:           "FFREE",
	FFREEP:          "FFREEP",
	FIADD:           "FIADD",
	FICOM:           "FICOM",
	FICOMP:          "FICOMP",
	FIDIV:           "FIDIV",
	FIDIVR:          "FIDIVR",
	FILD:            "FILD",
	FIMUL:           "FIMUL",
	FINCSTP:         "FINCSTP",
	FIST:            "FIST",
	FISTP:           "FISTP",
	FISTTP:          "FISTTP",
	FISUB:           "FISUB",
	FISUBR:          "FISUBR",
	FLD:             "FLD",
	FLD1:            "FLD1",
	FLDCW:           "FLDCW",
	FLDENV:          "FLDENV",
	FLDL2E:          "FLDL2E",
	FLDL2T:          "FLDL2T",
	FLDLG2:          "FLDLG2",
	FLDPI:           "FLDPI",
	FMUL:            "FMUL",
	FMULP:           "FMULP",
	FNCLEX:          "FNCLEX",
	FNINIT:          "FNINIT",
	FNOP:            "FNOP",
	FNSAVE:          "FNSAVE",
	FNSTCW:          "FNSTCW",
	FNSTENV:         "FNSTENV",
	FNSTSW:          "FNSTSW",
	FPATAN:          "FPATAN",
	FPREM:           "FPREM",
	FPREM1:          "FPREM1",
	FPTAN:           "FPTAN",
	FRNDINT:         "FRNDINT",
	FRSTOR:          "FRSTOR",
	FSCALE:          "FSCALE",
	FSIN:            "FSIN",
	FSINCOS:         "FSINCOS",
	FSQRT:           "FSQRT",
	FST:             "FST",
	FSTP:            "FSTP",
	FSUB:            "FSUB",
	FSUBP:           "FSUBP",
	FSUBR:           "FSUBR",
	FSUBRP:          "FSUBRP",
	FTST:            "FTST",
	FUCOM:           "FUCOM",
	FUCOMI:          "FUCOMI",
	FUCOMIP:         "FUCOMIP",
	FUCOMP:          "FUCOMP",
	FUCOMPP:         "FUCOMPP",
	FWAIT:           "FWAIT",
	FXAM:            "FXAM",
	FXCH:            "FXCH",
	FXRSTOR:         "FXRSTOR",
	FXRSTOR64:       "FXRSTOR64",
	FXSAVE:          "FXSAVE",
	FXSAVE64:        "FXSAVE64",
	FXTRACT:         "FXTRACT",
	FYL2X:           "FYL2X",
	FYL2XP1:         "FYL2XP1",
	HADDPD:          "HADDPD",
	HADDPS:          "HADDPS",
	HLT:             "HLT",
	HSUBPD:          "HSUBPD",
	HSUBPS:          "HSUBPS",
	ICEBP:           "ICEBP",
	IDIV:            "IDIV",
	IMUL:            "IMUL",
	IN:              "IN",
	INC:             "INC",
	INSB:            "INSB",
	INSD:            "INSD",
	INSERTPS:        "INSERTPS",
	INSW:            "INSW",
	INT:             "INT",
	INTO:            "INTO",
	INVD:            "INVD",
	INVLPG:          "INVLPG",
	INVPCID:         "INVPCID",
	IRET:            "IRET",
	IRETD:           "IRETD",
	IRETQ:           "IRETQ",
	JA:              "JA",
	JAE:             "JAE",
	JB:              "JB",
	JBE:             "JBE",
	JCXZ:            "JCXZ",
	JE:              "JE",
	JECXZ:           "JECXZ",
	JG:              "JG",
	JGE:             "JGE",
	JL:              "JL",
	JLE:             "JLE",
	JMP:             "JMP",
	JNE:             "JNE",
	JNO:             "JNO",
	JNP:             "JNP",
	JNS:             "JNS",
	JO:              "JO",
	JP:              "JP",
	JRCXZ:           "JRCXZ",
	JS:              "JS",
	LAHF:            "LAHF",
	LAR:             "LAR",
	LCALL:           "LCALL",
	LDDQU:           "LDDQU",
	LDMXCSR:         "LDMXCSR",
	LDS:             "LDS",
	LEA:             "LEA",
	LEAVE:           "LEAVE",
	LES:             "LES",
	LFENCE:          "LFENCE",
	LFS:             "LFS",
	LGDT:            "LGDT",
	LGS:             "LGS",
	LIDT:            "LIDT",
	LJMP:            "LJMP",
	LLDT:            "LLDT",
	LMSW:            "LMSW",
	LODSB:           "LODSB",
	LODSD:           "LODSD",
	LODSQ:           "LODSQ",
	LODSW:           "LODSW",
	LOOP:            "LOOP",
	LOOPE:           "LOOPE",
	LOOPNE:          "LOOPNE",
	LRET:            "LRET",
	LSL:             "LSL",
	LSS:             "LSS",
	LTR:             "LTR",
	LZCNT:           "LZCNT",
	MASKMOVDQU:      "MASKMOVDQU",
	MASKMOVQ:        "MASKMOVQ",
	MAXPD:           "MAXPD",
	MAXPS:           "MAXPS",
	MAXSD:           "MAXSD",
	MAXSS:           "MAXSS",
	MFENCE:          "MFENCE",
	MINPD:           "MINPD",
	MINPS:           "MINPS",
	MINSD:           "MINSD",
	MINSS:           "MINSS",
	MONITOR:         "MONITOR",
	MOV:             "MOV",
	MOVAPD:          "MOVAPD",
	MOVAPS:          "MOVAPS",
	MOVBE:           "MOVBE",
	MOVD:            "MOVD",
	MOVDDUP:         "MOVDDUP",
	MOVDQ2Q:         "MOVDQ2Q",
	MOVDQA:          "MOVDQA",
	MOVDQU:          "MOVDQU",
	MOVHLPS:         "MOVHLPS",
	MOVHPD:          "MOVHPD",
	MOVHPS:          "MOVHPS",
	MOVLHPS:         "MOVLHPS",
	MOVLPD:          "MOVLPD",
	MOVLPS:          "MOVLPS",
	MOVMSKPD:        "MOVMSKPD",
	MOVMSKPS:        "MOVMSKPS",
	MOVNTDQ:         "MOVNTDQ",
	MOVNTDQA:        "MOVNTDQA",
	MOVNTI:          "MOVNTI",
	MOVNTPD:         "MOVNTPD",
	MOVNTPS:         "MOVNTPS",
	MOVNTQ:          "MOVNTQ",
	MOVNTSD:         "MOVNTSD",
	MOVNTSS:         "MOVNTSS",
	MOVQ:            "MOVQ",
	MOVQ2DQ:         "MOVQ2DQ",
	MOVSB:           "MOVSB",
	MOVSD:           "MOVSD",
	MOVSD_XMM:       "MOVSD_XMM",
	MOVSHDUP:        "MOVSHDUP",
	MOVSLDUP:        "MOVSLDUP",
	MOVSQ:           "MOVSQ",
	MOVSS:           "MOVSS",
	MOVSW:           "MOVSW",
	MOVSX:           "MOVSX",
	MOVSXD:          "MOVSXD",
	MOVUPD:          "MOVUPD",
	MOVUPS:          "MOVUPS",
	MOVZX:           "MOVZX",
	MPSADBW:         "MPSADBW",
	MUL:             "MUL",
	MULPD:           "MULPD",
	MULPS:           "MULPS",
	MULSD:           "MULSD",
	MULSS:           "MULSS",
	MWAIT:           "MWAIT",
	NEG:             "NEG",
	NOP:             "NOP",
	NOT:             "NOT",
	OR:              "OR",
	ORPD:            "ORPD",
	ORPS:            "ORPS",
	OUT:             "OUT",
	OUTSB:           "OUTSB",
	OUTSD:           "OUTSD",
	OUTSW:           "OUTSW",
	PABSB:           "PABSB",
	PABSD:           "PABSD",
	PABSW:           "PABSW",
	PACKSSDW:        "PACKSSDW",
	PACKSSWB:        "PACKSSWB",
	PACKUSDW:        "PACKUSDW",
	PACKUSWB:        "PACKUSWB",
	PADDB:           "PADDB",
	PADDD:           "PADDD",
	PADDQ:           "PADDQ",
	PADDSB:          "PADDSB",
	PADDSW:          "PADDSW",
	PADDUSB:         "PADDUSB",
	PADDUSW:         "PADDUSW",
	PADDW:           "PADDW",
	PALIGNR:         "PALIGNR",
	PAND:            "PAND",
	PANDN:           "PANDN",
	PAUSE:           "PAUSE",
	PAVGB:           "PAVGB",
	PAVGW:           "PAVGW",
	PBLENDVB:        "PBLENDVB",
	PBLENDW:         "PBLENDW",
	PCLMULQDQ:       "PCLMULQDQ",
	PCMPEQB:         "PCMPEQB",
	PCMPEQD:         "PCMPEQD",
	PCMPEQQ:         "PCMPEQQ",
	PCMPEQW:         "PCMPEQW",
	PCMPESTRI:       "PCMPESTRI",
	PCMPESTRM:       "PCMPESTRM",
	PCMPGTB:         "PCMPGTB",
	PCMPGTD:         "PCMPGTD",
	PCMPGTQ:         "PCMPGTQ",
	PCMPGTW:         "PCMPGTW",
	PCMPISTRI:       "PCMPISTRI",
	PCMPISTRM:       "PCMPISTRM",
	PEXTRB:          "PEXTRB",
	PEXTRD:          "PEXTRD",
	PEXTRQ:          "PEXTRQ",
	PEXTRW:          "PEXTRW",
	PHADDD:          "PHADDD",
	PHADDSW:         "PHADDSW",
	PHADDW:          "PHADDW",
	PHMINPOSUW:      "PHMINPOSUW",
	PHSUBD:          "PHSUBD",
	PHSUBSW:         "PHSUBSW",
	PHSUBW:          "PHSUBW",
	PINSRB:          "PINSRB",
	PINSRD:          "PINSRD",
	PINSRQ:          "PINSRQ",
	PINSRW:          "PINSRW",
	PMADDUBSW:       "PMADDUBSW",
	PMADDWD:         "PMADDWD",
	PMAXSB:          "PMAXSB",
	PMAXSD:          "PMAXSD",
	PMAXSW:          "PMAXSW",
	PMAXUB:          "PMAXUB",
	PMAXUD:          "PMAXUD",
	PMAXUW:          "PMAXUW",
	PMINSB:          "PMINSB",
	PMINSD:          "PMINSD",
	PMINSW:          "PMINSW",
	PMINUB:          "PMINUB",
	PMINUD:          "PMINUD",
	PMINUW:          "PMINUW",
	PMOVMSKB:        "PMOVMSKB",
	PMOVSXBD:        "PMOVSXBD",
	PMOVSXBQ:        "PMOVSXBQ",
	PMOVSXBW:        "PMOVSXBW",
	PMOVSXDQ:        "PMOVSXDQ",
	PMOVSXWD:        "PMOVSXWD",
	PMOVSXWQ:        "PMOVSXWQ",
	PMOVZXBD:        "PMOVZXBD",
	PMOVZXBQ:        "PMOVZXBQ",
	PMOVZXBW:        "PMOVZXBW",
	PMOVZXDQ:        "PMOVZXDQ",
	PMOVZXWD:        "PMOVZXWD",
	PMOVZXWQ:        "PMOVZXWQ",
	PMULDQ:          "PMULDQ",
	PMULHRSW:        "PMULHRSW",
	PMULHUW:         "PMULHUW",
	PMULHW:          "PMULHW",
	PMULLD:          "PMULLD",
	PMULLW:          "PMULLW",
	PMULUDQ:         "PMULUDQ",
	POP:             "POP",
	POPA:            "POPA",
	POPAD:           "POPAD",
	POPCNT:          "POPCNT",
	POPF:            "POPF",
	POPFD:           "POPFD",
	POPFQ:           "POPFQ",
	POR:             "POR",
	PREFETCHNTA:     "PREFETCHNTA",
	PREFETCHT0:      "PREFETCHT0",
	PREFETCHT1:      "PREFETCHT1",
	PREFETCHT2:      "PREFETCHT2",
	PREFETCHW:       "PREFETCHW",
	PSADBW:          "PSADBW",
	PSHUFB:          "PSHUFB",
	PSHUFD:          "PSHUFD",
	PSHUFHW:         "PSHUFHW",
	PSHUFLW:         "PSHUFLW",
	PSHUFW:          "PSHUFW",
	PSIGNB:          "PSIGNB",
	PSIGND:          "PSIGND",
	PSIGNW:          "PSIGNW",
	PSLLD:           "PSLLD",
	PSLLDQ:          "PSLLDQ",
	PSLLQ:           "PSLLQ",
	PSLLW:           "PSLLW",
	PSRAD:           "PSRAD",
	PSRAW:           "PSRAW",
	PSRLD:           "PSRLD",
	PSRLDQ:          "PSRLDQ",
	PSRLQ:           "PSRLQ",
	PSRLW:           "PSRLW",
	PSUBB:           "PSUBB",
	PSUBD:           "PSUBD",
	PSUBQ:           "PSUBQ",
	PSUBSB:          "PSUBSB",
	PSUBSW:          "PSUBSW",
	PSUBUSB:         "PSUBUSB",
	PSUBUSW:         "PSUBUSW",
	PSUBW:           "PSUBW",
	PTEST:           "PTEST",
	PUNPCKHBW:       "PUNPCKHBW",
	PUNPCKHDQ:       "PUNPCKHDQ",
	PUNPCKHQDQ:      "PUNPCKHQDQ",
	PUNPCKHWD:       "PUNPCKHWD",
	PUNPCKLBW:       "PUNPCKLBW",
	PUNPCKLDQ:       "PUNPCKLDQ",
	PUNPCKLQDQ:      "PUNPCKLQDQ",
	PUNPCKLWD:       "PUNPCKLWD",
	PUSH:            "PUSH",
	PUSHA:           "PUSHA",
	PUSHAD:          "PUSHAD",
	PUSHF:           "PUSHF",
	PUSHFD:          "PUSHFD",
	PUSHFQ:          "PUSHFQ",
	PXOR:            "PXOR",
	RCL:             "RCL",
	RCPPS:           "RCPPS",
	RCPSS:           "RCPSS",
	RCR:             "RCR",
	RDFSBASE:        "RDFSBASE",
	RDGSBASE:        "RDGSBASE",
	RDMSR:           "RDMSR",
	RDPMC:           "RDPMC",
	RDRAND:          "RDRAND",
	RDTSC:           "RDTSC",
	RDTSCP:          "RDTSCP",
	RET:             "RET",
	ROL:             "ROL",
	ROR:             "ROR",
	ROUNDPD:         "ROUNDPD",
	ROUNDPS:         "ROUNDPS",
	ROUNDSD:         "ROUNDSD",
	ROUNDSS:         "ROUNDSS",
	RSM:             "RSM",
	RSQRTPS:         "RSQRTPS",
	RSQRTSS:         "RSQRTSS",
	SAHF:            "SAHF",
	SAR:             "SAR",
	SBB:             "SBB",
	SCASB:           "SCASB",
	SCASD:           "SCASD",
	SCASQ:           "SCASQ",
	SCASW:           "SCASW",
	SETA:            "SETA",
	SETAE:           "SETAE",
	SETB:            "SETB",
	SETBE:           "SETBE",
	SETE:            "SETE",
	SETG:            "SETG",
	SETGE:           "SETGE",
	SETL:            "SETL",
	SETLE:           "SETLE",
	SETNE:           "SETNE",
	SETNO:           "SETNO",
	SETNP:           "SETNP",
	SETNS:           "SETNS",
	SETO:            "SETO",
	SETP:            "SETP",
	SETS:            "SETS",
	SFENCE:          "SFENCE",
	SGDT:            "SGDT",
	SHL:             "SHL",
	SHLD:            "SHLD",
	SHR:             "SHR",
	SHRD:            "SHRD",
	SHUFPD:          "SHUFPD",
	SHUFPS:          "SHUFPS",
	SIDT:            "SIDT",
	SLDT:            "SLDT",
	SMSW:            "SMSW",
	SQRTPD:          "SQRTPD",
	SQRTPS:          "SQRTPS",
	SQRTSD:          "SQRTSD",
	SQRTSS:          "SQRTSS",
	STC:             "STC",
	STD:             "STD",
	STI:             "STI",
	STMXCSR:         "STMXCSR",
	STOSB:           "STOSB",
	STOSD:           "STOSD",
	STOSQ:           "STOSQ",
	STOSW:           "STOSW",
	STR:             "STR",
	SUB:             "SUB",
	SUBPD:           "SUBPD",
	SUBPS:           "SUBPS",
	SUBSD:           "SUBSD",
	SUBSS:           "SUBSS",
	SWAPGS:          "SWAPGS",
	SYSCALL:         "SYSCALL",
	SYSENTER:        "SYSENTER",
	SYSEXIT:         "SYSEXIT",
	SYSRET:          "SYSRET",
	TEST:            "TEST",
	TZCNT:           "TZCNT",
	UCOMISD:         "UCOMISD",
	UCOMISS:         "UCOMISS",
	UD1:             "UD1",
	UD2:             "UD2",
	UNPCKHPD:        "UNPCKHPD",
	UNPCKHPS:        "UNPCKHPS",
	UNPCKLPD:        "UNPCKLPD",
	UNPCKLPS:        "UNPCKLPS",
	VERR:            "VERR",
	VERW:            "VERW",
	WBINVD:          "WBINVD",
	WRFSBASE:        "WRFSBASE",
	WRGSBASE:        "WRGSBASE",
	WRMSR:           "WRMSR",
	XABORT:          "XABORT",
	XADD:            "XADD",
	XBEGIN:          "XBEGIN",
	XCHG:            "XCHG",
	XEND:            "XEND",
	XGETBV:          "XGETBV",
	XLATB:           "XLATB",
	XOR:             "XOR",
	XORPD:           "XORPD",
	XORPS:           "XORPS",
	XRSTOR:          "XRSTOR",
	XRSTOR64:        "XRSTOR64",
	XRSTORS:         "XRSTORS",
	XRSTORS64:       "XRSTORS64",
	XSAVE:           "XSAVE",
	XSAVE64:         "XSAVE64",
	XSAVEC:          "XSAVEC",
	XSAVEC64:        "XSAVEC64",
	XSAVEOPT:        "XSAVEOPT",
	XSAVEOPT64:      "XSAVEOPT64",
	XSAVES:          "XSAVES",
	XSAVES64:        "XSAVES64",
	XSETBV:          "XSETBV",
	XTEST:           "XTEST",
}
                                                                                                                      usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/testdata/                       0040755 0000000 0000000 00000000000 13020111412 025354  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/testdata/Makefile               0100644 0000000 0000000 00000001247 13020111412 027015  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        libmach8db: libmach8db.c
	9c libmach8db.c && 9l -o libmach8db libmach8db.o; rm libmach8db.o

newdecode.txt:
	cd ..; go test -cover -run 'Objdump.*32' -v -timeout 10h -printtests 2>&1 | tee log
	cd ..; go test -cover -run 'Objdump.*64' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Xed.*32' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Xed.*64' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Plan9.*32' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Plan9.*64' -v -timeout 10h -printtests 2>&1 | tee -a log
	egrep '	(gnu|intel|plan9)	' ../log |sort >newdecode.txt

                                                                                                                                                                                                                                                                                                                                                         usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/testdata/decode.txt             0100644 0000000 0000000 00001464511 13020111412 027351  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        000511223344|556677885f5f5f5f5f5f	32	intel	add byte ptr [0x44332211], al
000511223344|556677885f5f5f5f5f5f	64	gnu	add %al,0x44332211(%rip)
000511223344|556677885f5f5f5f5f5f	64	intel	add byte ptr [rip+0x44332211], al
0100|11223344556677885f5f5f5f5f5f	32	intel	add dword ptr [eax], eax
0100|11223344556677885f5f5f5f5f5f	32	plan9	ADDL AX, 0(AX)
0100|11223344556677885f5f5f5f5f5f	64	gnu	add %eax,(%rax)
0100|11223344556677885f5f5f5f5f5f	64	intel	add dword ptr [rax], eax
0100|11223344556677885f5f5f5f5f5f	64	plan9	ADDL AX, 0(AX)
0211|223344556677885f5f5f5f5f5f5f	32	intel	add dl, byte ptr [ecx]
0211|223344556677885f5f5f5f5f5f5f	32	plan9	ADDL 0(CX), DL
0211|223344556677885f5f5f5f5f5f5f	64	gnu	add (%rcx),%dl
0211|223344556677885f5f5f5f5f5f5f	64	intel	add dl, byte ptr [rcx]
0211|223344556677885f5f5f5f5f5f5f	64	plan9	ADDL 0(CX), DL
0311|223344556677885f5f5f5f5f5f5f	32	intel	add edx, dword ptr [ecx]
0311|223344556677885f5f5f5f5f5f5f	32	plan9	ADDL 0(CX), DX
0311|223344556677885f5f5f5f5f5f5f	64	gnu	add (%rcx),%edx
0311|223344556677885f5f5f5f5f5f5f	64	intel	add edx, dword ptr [rcx]
0311|223344556677885f5f5f5f5f5f5f	64	plan9	ADDL 0(CX), DX
0411|223344556677885f5f5f5f5f5f5f	32	intel	add al, 0x11
0411|223344556677885f5f5f5f5f5f5f	32	plan9	ADDL $0x11, AL
0411|223344556677885f5f5f5f5f5f5f	64	gnu	add $0x11,%al
0411|223344556677885f5f5f5f5f5f5f	64	intel	add al, 0x11
0411|223344556677885f5f5f5f5f5f5f	64	plan9	ADDL $0x11, AL
0511223344|556677885f5f5f5f5f5f5f	32	intel	add eax, 0x44332211
0511223344|556677885f5f5f5f5f5f5f	32	plan9	ADDL $0x44332211, AX
0511223344|556677885f5f5f5f5f5f5f	64	gnu	add $0x44332211,%eax
0511223344|556677885f5f5f5f5f5f5f	64	intel	add eax, 0x44332211
0511223344|556677885f5f5f5f5f5f5f	64	plan9	ADDL $0x44332211, AX
06|11223344556677885f5f5f5f5f5f5f	32	intel	push es
06|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL ES
06|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
06|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
06|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
07|11223344556677885f5f5f5f5f5f5f	32	intel	pop es
07|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL ES
07|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
07|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
07|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0811|223344556677885f5f5f5f5f5f5f	32	intel	or byte ptr [ecx], dl
0811|223344556677885f5f5f5f5f5f5f	32	plan9	ORL DL, 0(CX)
0811|223344556677885f5f5f5f5f5f5f	64	gnu	or %dl,(%rcx)
0811|223344556677885f5f5f5f5f5f5f	64	intel	or byte ptr [rcx], dl
0811|223344556677885f5f5f5f5f5f5f	64	plan9	ORL DL, 0(CX)
0911|223344556677885f5f5f5f5f5f5f	32	intel	or dword ptr [ecx], edx
0911|223344556677885f5f5f5f5f5f5f	32	plan9	ORL DX, 0(CX)
0911|223344556677885f5f5f5f5f5f5f	64	gnu	or %edx,(%rcx)
0911|223344556677885f5f5f5f5f5f5f	64	intel	or dword ptr [rcx], edx
0911|223344556677885f5f5f5f5f5f5f	64	plan9	ORL DX, 0(CX)
0a11|223344556677885f5f5f5f5f5f5f	32	intel	or dl, byte ptr [ecx]
0a11|223344556677885f5f5f5f5f5f5f	32	plan9	ORL 0(CX), DL
0a11|223344556677885f5f5f5f5f5f5f	64	gnu	or (%rcx),%dl
0a11|223344556677885f5f5f5f5f5f5f	64	intel	or dl, byte ptr [rcx]
0a11|223344556677885f5f5f5f5f5f5f	64	plan9	ORL 0(CX), DL
0b11|223344556677885f5f5f5f5f5f5f	32	intel	or edx, dword ptr [ecx]
0b11|223344556677885f5f5f5f5f5f5f	32	plan9	ORL 0(CX), DX
0b11|223344556677885f5f5f5f5f5f5f	64	gnu	or (%rcx),%edx
0b11|223344556677885f5f5f5f5f5f5f	64	intel	or edx, dword ptr [rcx]
0b11|223344556677885f5f5f5f5f5f5f	64	plan9	ORL 0(CX), DX
0c11|223344556677885f5f5f5f5f5f5f	32	intel	or al, 0x11
0c11|223344556677885f5f5f5f5f5f5f	32	plan9	ORL $0x11, AL
0c11|223344556677885f5f5f5f5f5f5f	64	gnu	or $0x11,%al
0c11|223344556677885f5f5f5f5f5f5f	64	intel	or al, 0x11
0c11|223344556677885f5f5f5f5f5f5f	64	plan9	ORL $0x11, AL
0d11223344|556677885f5f5f5f5f5f5f	32	intel	or eax, 0x44332211
0d11223344|556677885f5f5f5f5f5f5f	32	plan9	ORL $0x44332211, AX
0d11223344|556677885f5f5f5f5f5f5f	64	gnu	or $0x44332211,%eax
0d11223344|556677885f5f5f5f5f5f5f	64	intel	or eax, 0x44332211
0d11223344|556677885f5f5f5f5f5f5f	64	plan9	ORL $0x44332211, AX
0e|11223344556677885f5f5f5f5f5f5f	32	intel	push cs
0e|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL CS
0e|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0e|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
0e|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f0000|11223344556677885f5f5f5f5f	32	intel	sldt word ptr [eax]
0f0000|11223344556677885f5f5f5f5f	32	plan9	SLDT 0(AX)
0f0000|11223344556677885f5f5f5f5f	64	gnu	sldt (%rax)
0f0000|11223344556677885f5f5f5f5f	64	intel	sldt word ptr [rax]
0f0000|11223344556677885f5f5f5f5f	64	plan9	SLDT 0(AX)
0f0008|11223344556677885f5f5f5f5f	32	intel	str word ptr [eax]
0f0008|11223344556677885f5f5f5f5f	32	plan9	STR 0(AX)
0f0008|11223344556677885f5f5f5f5f	64	gnu	str (%rax)
0f0008|11223344556677885f5f5f5f5f	64	intel	str word ptr [rax]
0f0008|11223344556677885f5f5f5f5f	64	plan9	STR 0(AX)
0f0011|223344556677885f5f5f5f5f5f	32	intel	lldt word ptr [ecx]
0f0011|223344556677885f5f5f5f5f5f	32	plan9	LLDT 0(CX)
0f0011|223344556677885f5f5f5f5f5f	64	gnu	lldt (%rcx)
0f0011|223344556677885f5f5f5f5f5f	64	intel	lldt word ptr [rcx]
0f0011|223344556677885f5f5f5f5f5f	64	plan9	LLDT 0(CX)
0f0018|11223344556677885f5f5f5f5f	32	intel	ltr word ptr [eax]
0f0018|11223344556677885f5f5f5f5f	32	plan9	LTR 0(AX)
0f0018|11223344556677885f5f5f5f5f	64	gnu	ltr (%rax)
0f0018|11223344556677885f5f5f5f5f	64	intel	ltr word ptr [rax]
0f0018|11223344556677885f5f5f5f5f	64	plan9	LTR 0(AX)
0f0020|11223344556677885f5f5f5f5f	32	intel	verr word ptr [eax]
0f0020|11223344556677885f5f5f5f5f	32	plan9	VERR 0(AX)
0f0020|11223344556677885f5f5f5f5f	64	gnu	verr (%rax)
0f0020|11223344556677885f5f5f5f5f	64	intel	verr word ptr [rax]
0f0020|11223344556677885f5f5f5f5f	64	plan9	VERR 0(AX)
0f0028|11223344556677885f5f5f5f5f	32	intel	verw word ptr [eax]
0f0028|11223344556677885f5f5f5f5f	32	plan9	VERW 0(AX)
0f0028|11223344556677885f5f5f5f5f	64	gnu	verw (%rax)
0f0028|11223344556677885f5f5f5f5f	64	intel	verw word ptr [rax]
0f0028|11223344556677885f5f5f5f5f	64	plan9	VERW 0(AX)
0f0030|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f0030|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f0100|11223344556677885f5f5f5f5f	32	intel	sgdt ptr [eax]
0f0100|11223344556677885f5f5f5f5f	32	plan9	SGDT 0(AX)
0f0100|11223344556677885f5f5f5f5f	64	gnu	sgdtl (%rax)
0f0100|11223344556677885f5f5f5f5f	64	intel	sgdt ptr [rax]
0f0100|11223344556677885f5f5f5f5f	64	plan9	SGDT 0(AX)
0f0108|11223344556677885f5f5f5f5f	32	intel	sidt ptr [eax]
0f0108|11223344556677885f5f5f5f5f	32	plan9	SIDT 0(AX)
0f0108|11223344556677885f5f5f5f5f	64	gnu	sidtl (%rax)
0f0108|11223344556677885f5f5f5f5f	64	intel	sidt ptr [rax]
0f0108|11223344556677885f5f5f5f5f	64	plan9	SIDT 0(AX)
0f0111|223344556677885f5f5f5f5f5f	32	intel	lgdt ptr [ecx]
0f0111|223344556677885f5f5f5f5f5f	32	plan9	LGDT 0(CX)
0f0111|223344556677885f5f5f5f5f5f	64	gnu	lgdtl (%rcx)
0f0111|223344556677885f5f5f5f5f5f	64	intel	lgdt ptr [rcx]
0f0111|223344556677885f5f5f5f5f5f	64	plan9	LGDT 0(CX)
0f0118|11223344556677885f5f5f5f5f	32	intel	lidt ptr [eax]
0f0118|11223344556677885f5f5f5f5f	32	plan9	LIDT 0(AX)
0f0118|11223344556677885f5f5f5f5f	64	gnu	lidtl (%rax)
0f0118|11223344556677885f5f5f5f5f	64	intel	lidt ptr [rax]
0f0118|11223344556677885f5f5f5f5f	64	plan9	LIDT 0(AX)
0f0120|11223344556677885f5f5f5f5f	32	intel	smsw word ptr [eax]
0f0120|11223344556677885f5f5f5f5f	32	plan9	SMSW 0(AX)
0f0120|11223344556677885f5f5f5f5f	64	gnu	smsw (%rax)
0f0120|11223344556677885f5f5f5f5f	64	intel	smsw word ptr [rax]
0f0120|11223344556677885f5f5f5f5f	64	plan9	SMSW 0(AX)
0f0130|11223344556677885f5f5f5f5f	32	intel	lmsw word ptr [eax]
0f0130|11223344556677885f5f5f5f5f	32	plan9	LMSW 0(AX)
0f0130|11223344556677885f5f5f5f5f	64	gnu	lmsw (%rax)
0f0130|11223344556677885f5f5f5f5f	64	intel	lmsw word ptr [rax]
0f0130|11223344556677885f5f5f5f5f	64	plan9	LMSW 0(AX)
0f0138|11223344556677885f5f5f5f5f	32	intel	invlpg byte ptr [eax]
0f0138|11223344556677885f5f5f5f5f	32	plan9	INVLPG 0(AX)
0f0138|11223344556677885f5f5f5f5f	64	gnu	invlpg (%rax)
0f0138|11223344556677885f5f5f5f5f	64	intel	invlpg byte ptr [rax]
0f0138|11223344556677885f5f5f5f5f	64	plan9	INVLPG 0(AX)
0f01c8|11223344556677885f5f5f5f5f	32	intel	monitor
0f01c8|11223344556677885f5f5f5f5f	32	plan9	MONITOR
0f01c8|11223344556677885f5f5f5f5f	64	gnu	monitor %eax,%ecx,%edx
0f01c8|11223344556677885f5f5f5f5f	64	intel	monitor
0f01c8|11223344556677885f5f5f5f5f	64	plan9	MONITOR
0f01c9|11223344556677885f5f5f5f5f	32	intel	mwait
0f01c9|11223344556677885f5f5f5f5f	32	plan9	MWAIT
0f01c9|11223344556677885f5f5f5f5f	64	gnu	mwait %rax,%rcx
0f01c9|11223344556677885f5f5f5f5f	64	intel	mwait
0f01c9|11223344556677885f5f5f5f5f	64	plan9	MWAIT
0f01d0|11223344556677885f5f5f5f5f	32	intel	xgetbv
0f01d0|11223344556677885f5f5f5f5f	32	plan9	XGETBV
0f01d0|11223344556677885f5f5f5f5f	64	gnu	xgetbv
0f01d0|11223344556677885f5f5f5f5f	64	intel	xgetbv
0f01d0|11223344556677885f5f5f5f5f	64	plan9	XGETBV
0f01d1|11223344556677885f5f5f5f5f	32	intel	xsetbv
0f01d1|11223344556677885f5f5f5f5f	32	plan9	XSETBV
0f01d1|11223344556677885f5f5f5f5f	64	gnu	xsetbv
0f01d1|11223344556677885f5f5f5f5f	64	intel	xsetbv
0f01d1|11223344556677885f5f5f5f5f	64	plan9	XSETBV
0f01d5|11223344556677885f5f5f5f5f	32	intel	xend
0f01d5|11223344556677885f5f5f5f5f	32	plan9	XEND
0f01d5|11223344556677885f5f5f5f5f	64	gnu	xend
0f01d5|11223344556677885f5f5f5f5f	64	intel	xend
0f01d5|11223344556677885f5f5f5f5f	64	plan9	XEND
0f01d6|11223344556677885f5f5f5f5f	32	intel	xtest
0f01d6|11223344556677885f5f5f5f5f	32	plan9	XTEST
0f01d6|11223344556677885f5f5f5f5f	64	gnu	xtest
0f01d6|11223344556677885f5f5f5f5f	64	intel	xtest
0f01d6|11223344556677885f5f5f5f5f	64	plan9	XTEST
0f01f8|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f01f8|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f01f8|11223344556677885f5f5f5f5f	64	gnu	swapgs
0f01f8|11223344556677885f5f5f5f5f	64	intel	swapgs
0f01f8|11223344556677885f5f5f5f5f	64	plan9	SWAPGS
0f01f9|11223344556677885f5f5f5f5f	32	intel	rdtscp
0f01f9|11223344556677885f5f5f5f5f	32	plan9	RDTSCP
0f01f9|11223344556677885f5f5f5f5f	64	gnu	rdtscp
0f01f9|11223344556677885f5f5f5f5f	64	intel	rdtscp
0f01f9|11223344556677885f5f5f5f5f	64	plan9	RDTSCP
0f0211|223344556677885f5f5f5f5f5f	32	intel	lar edx, word ptr [ecx]
0f0211|223344556677885f5f5f5f5f5f	32	plan9	LAR 0(CX), DX
0f0211|223344556677885f5f5f5f5f5f	64	gnu	lar (%rcx),%edx
0f0211|223344556677885f5f5f5f5f5f	64	intel	lar edx, word ptr [rcx]
0f0211|223344556677885f5f5f5f5f5f	64	plan9	LAR 0(CX), DX
0f0311|223344556677885f5f5f5f5f5f	32	intel	lsl edx, word ptr [ecx]
0f0311|223344556677885f5f5f5f5f5f	32	plan9	LSL 0(CX), DX
0f0311|223344556677885f5f5f5f5f5f	64	gnu	lsl (%rcx),%edx
0f0311|223344556677885f5f5f5f5f5f	64	intel	lsl edx, word ptr [rcx]
0f0311|223344556677885f5f5f5f5f5f	64	plan9	LSL 0(CX), DX
0f04|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f05|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f05|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f05|11223344556677885f5f5f5f5f5f	64	gnu	syscall
0f05|11223344556677885f5f5f5f5f5f	64	intel	syscall
0f05|11223344556677885f5f5f5f5f5f	64	plan9	SYSCALL
0f06|11223344556677885f5f5f5f5f5f	32	intel	clts
0f06|11223344556677885f5f5f5f5f5f	32	plan9	CLTS
0f06|11223344556677885f5f5f5f5f5f	64	gnu	clts
0f06|11223344556677885f5f5f5f5f5f	64	intel	clts
0f06|11223344556677885f5f5f5f5f5f	64	plan9	CLTS
0f07|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f07|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f07|11223344556677885f5f5f5f5f5f	64	gnu	sysretq
0f07|11223344556677885f5f5f5f5f5f	64	intel	sysret
0f07|11223344556677885f5f5f5f5f5f	64	plan9	SYSRET
0f08|11223344556677885f5f5f5f5f5f	32	intel	invd
0f08|11223344556677885f5f5f5f5f5f	32	plan9	INVD
0f08|11223344556677885f5f5f5f5f5f	64	gnu	invd
0f08|11223344556677885f5f5f5f5f5f	64	intel	invd
0f08|11223344556677885f5f5f5f5f5f	64	plan9	INVD
0f09|11223344556677885f5f5f5f5f5f	32	intel	wbinvd
0f09|11223344556677885f5f5f5f5f5f	32	plan9	WBINVD
0f09|11223344556677885f5f5f5f5f5f	64	gnu	wbinvd
0f09|11223344556677885f5f5f5f5f5f	64	intel	wbinvd
0f09|11223344556677885f5f5f5f5f5f	64	plan9	WBINVD
0f0b|11223344556677885f5f5f5f5f5f	32	intel	ud2
0f0b|11223344556677885f5f5f5f5f5f	32	plan9	UD2
0f0b|11223344556677885f5f5f5f5f5f	64	gnu	ud2
0f0b|11223344556677885f5f5f5f5f5f	64	intel	ud2
0f0b|11223344556677885f5f5f5f5f5f	64	plan9	UD2
0f0d08|11223344556677885f5f5f5f5f	32	intel	prefetchw zmmword ptr [eax]
0f0d08|11223344556677885f5f5f5f5f	32	plan9	PREFETCHW 0(AX)
0f0d08|11223344556677885f5f5f5f5f	64	gnu	prefetchw (%rax)
0f0d08|11223344556677885f5f5f5f5f	64	intel	prefetchw zmmword ptr [rax]
0f0d08|11223344556677885f5f5f5f5f	64	plan9	PREFETCHW 0(AX)
0f1011|223344556677885f5f5f5f5f5f	32	intel	movups xmm2, xmmword ptr [ecx]
0f1011|223344556677885f5f5f5f5f5f	32	plan9	MOVUPS 0(CX), X2
0f1011|223344556677885f5f5f5f5f5f	64	gnu	movups (%rcx),%xmm2
0f1011|223344556677885f5f5f5f5f5f	64	intel	movups xmm2, xmmword ptr [rcx]
0f1011|223344556677885f5f5f5f5f5f	64	plan9	MOVUPS 0(CX), X2
0f1122|3344556677885f5f5f5f5f5f5f	32	intel	movups xmmword ptr [edx], xmm4
0f1122|3344556677885f5f5f5f5f5f5f	32	plan9	MOVUPS X4, 0(DX)
0f1122|3344556677885f5f5f5f5f5f5f	64	gnu	movups %xmm4,(%rdx)
0f1122|3344556677885f5f5f5f5f5f5f	64	intel	movups xmmword ptr [rdx], xmm4
0f1122|3344556677885f5f5f5f5f5f5f	64	plan9	MOVUPS X4, 0(DX)
0f1211|223344556677885f5f5f5f5f5f	32	intel	movlps xmm2, qword ptr [ecx]
0f1211|223344556677885f5f5f5f5f5f	32	plan9	MOVLPS 0(CX), X2
0f1211|223344556677885f5f5f5f5f5f	64	gnu	movlps (%rcx),%xmm2
0f1211|223344556677885f5f5f5f5f5f	64	intel	movlps xmm2, qword ptr [rcx]
0f1211|223344556677885f5f5f5f5f5f	64	plan9	MOVLPS 0(CX), X2
0f12c0|11223344556677885f5f5f5f5f	32	intel	movhlps xmm0, xmm0
0f12c0|11223344556677885f5f5f5f5f	32	plan9	MOVHLPS X0, X0
0f12c0|11223344556677885f5f5f5f5f	64	gnu	movhlps %xmm0,%xmm0
0f12c0|11223344556677885f5f5f5f5f	64	intel	movhlps xmm0, xmm0
0f12c0|11223344556677885f5f5f5f5f	64	plan9	MOVHLPS X0, X0
0f1311|223344556677885f5f5f5f5f5f	32	intel	movlps qword ptr [ecx], xmm2
0f1311|223344556677885f5f5f5f5f5f	32	plan9	MOVLPS X2, 0(CX)
0f1311|223344556677885f5f5f5f5f5f	64	gnu	movlps %xmm2,(%rcx)
0f1311|223344556677885f5f5f5f5f5f	64	intel	movlps qword ptr [rcx], xmm2
0f1311|223344556677885f5f5f5f5f5f	64	plan9	MOVLPS X2, 0(CX)
0f1411|223344556677885f5f5f5f5f5f	32	intel	unpcklps xmm2, xmmword ptr [ecx]
0f1411|223344556677885f5f5f5f5f5f	32	plan9	UNPCKLPS 0(CX), X2
0f1411|223344556677885f5f5f5f5f5f	64	gnu	unpcklps (%rcx),%xmm2
0f1411|223344556677885f5f5f5f5f5f	64	intel	unpcklps xmm2, xmmword ptr [rcx]
0f1411|223344556677885f5f5f5f5f5f	64	plan9	UNPCKLPS 0(CX), X2
0f1511|223344556677885f5f5f5f5f5f	32	intel	unpckhps xmm2, xmmword ptr [ecx]
0f1511|223344556677885f5f5f5f5f5f	32	plan9	UNPCKHPS 0(CX), X2
0f1511|223344556677885f5f5f5f5f5f	64	gnu	unpckhps (%rcx),%xmm2
0f1511|223344556677885f5f5f5f5f5f	64	intel	unpckhps xmm2, xmmword ptr [rcx]
0f1511|223344556677885f5f5f5f5f5f	64	plan9	UNPCKHPS 0(CX), X2
0f1611|223344556677885f5f5f5f5f5f	32	intel	movhps xmm2, qword ptr [ecx]
0f1611|223344556677885f5f5f5f5f5f	32	plan9	MOVHPS 0(CX), X2
0f1611|223344556677885f5f5f5f5f5f	64	gnu	movhps (%rcx),%xmm2
0f1611|223344556677885f5f5f5f5f5f	64	intel	movhps xmm2, qword ptr [rcx]
0f1611|223344556677885f5f5f5f5f5f	64	plan9	MOVHPS 0(CX), X2
0f16c0|11223344556677885f5f5f5f5f	32	intel	movlhps xmm0, xmm0
0f16c0|11223344556677885f5f5f5f5f	32	plan9	MOVLHPS X0, X0
0f16c0|11223344556677885f5f5f5f5f	64	gnu	movlhps %xmm0,%xmm0
0f16c0|11223344556677885f5f5f5f5f	64	intel	movlhps xmm0, xmm0
0f16c0|11223344556677885f5f5f5f5f	64	plan9	MOVLHPS X0, X0
0f1711|223344556677885f5f5f5f5f5f	32	intel	movhps qword ptr [ecx], xmm2
0f1711|223344556677885f5f5f5f5f5f	32	plan9	MOVHPS X2, 0(CX)
0f1711|223344556677885f5f5f5f5f5f	64	gnu	movhps %xmm2,(%rcx)
0f1711|223344556677885f5f5f5f5f5f	64	intel	movhps qword ptr [rcx], xmm2
0f1711|223344556677885f5f5f5f5f5f	64	plan9	MOVHPS X2, 0(CX)
0f1800|11223344556677885f5f5f5f5f	32	intel	prefetchnta zmmword ptr [eax]
0f1800|11223344556677885f5f5f5f5f	32	plan9	PREFETCHNTA 0(AX)
0f1800|11223344556677885f5f5f5f5f	64	gnu	prefetchnta (%rax)
0f1800|11223344556677885f5f5f5f5f	64	intel	prefetchnta zmmword ptr [rax]
0f1800|11223344556677885f5f5f5f5f	64	plan9	PREFETCHNTA 0(AX)
0f1808|11223344556677885f5f5f5f5f	32	intel	prefetcht0 zmmword ptr [eax]
0f1808|11223344556677885f5f5f5f5f	32	plan9	PREFETCHT0 0(AX)
0f1808|11223344556677885f5f5f5f5f	64	gnu	prefetcht0 (%rax)
0f1808|11223344556677885f5f5f5f5f	64	intel	prefetcht0 zmmword ptr [rax]
0f1808|11223344556677885f5f5f5f5f	64	plan9	PREFETCHT0 0(AX)
0f1811|223344556677885f5f5f5f5f5f	32	intel	prefetcht1 zmmword ptr [ecx]
0f1811|223344556677885f5f5f5f5f5f	32	plan9	PREFETCHT1 0(CX)
0f1811|223344556677885f5f5f5f5f5f	64	gnu	prefetcht1 (%rcx)
0f1811|223344556677885f5f5f5f5f5f	64	intel	prefetcht1 zmmword ptr [rcx]
0f1811|223344556677885f5f5f5f5f5f	64	plan9	PREFETCHT1 0(CX)
0f1818|11223344556677885f5f5f5f5f	32	intel	prefetcht2 zmmword ptr [eax]
0f1818|11223344556677885f5f5f5f5f	32	plan9	PREFETCHT2 0(AX)
0f1818|11223344556677885f5f5f5f5f	64	gnu	prefetcht2 (%rax)
0f1818|11223344556677885f5f5f5f5f	64	intel	prefetcht2 zmmword ptr [rax]
0f1818|11223344556677885f5f5f5f5f	64	plan9	PREFETCHT2 0(AX)
0f1f00|11223344556677885f5f5f5f5f	32	intel	nop dword ptr [eax], eax
0f1f00|11223344556677885f5f5f5f5f	32	plan9	NOPL 0(AX)
0f1f00|11223344556677885f5f5f5f5f	64	gnu	nopl (%rax)
0f1f00|11223344556677885f5f5f5f5f	64	intel	nop dword ptr [rax], eax
0f1f00|11223344556677885f5f5f5f5f	64	plan9	NOPL 0(AX)
0f2011|223344556677885f5f5f5f5f5f	32	intel	mov ecx, cr2
0f2011|223344556677885f5f5f5f5f5f	32	plan9	MOVL CR2, CX
0f2011|223344556677885f5f5f5f5f5f	64	gnu	mov %cr2,%rcx
0f2011|223344556677885f5f5f5f5f5f	64	intel	mov rcx, cr2
0f2011|223344556677885f5f5f5f5f5f	64	plan9	MOVL CR2, CX
0f2111|223344556677885f5f5f5f5f5f	32	intel	mov ecx, dr2
0f2111|223344556677885f5f5f5f5f5f	32	plan9	MOVL DR2, CX
0f2111|223344556677885f5f5f5f5f5f	64	gnu	mov %db2,%rcx
0f2111|223344556677885f5f5f5f5f5f	64	intel	mov rcx, dr2
0f2111|223344556677885f5f5f5f5f5f	64	plan9	MOVL DR2, CX
0f2211|223344556677885f5f5f5f5f5f	32	intel	mov cr2, ecx
0f2211|223344556677885f5f5f5f5f5f	32	plan9	MOVL CX, CR2
0f2211|223344556677885f5f5f5f5f5f	64	gnu	mov %rcx,%cr2
0f2211|223344556677885f5f5f5f5f5f	64	intel	mov cr2, rcx
0f2211|223344556677885f5f5f5f5f5f	64	plan9	MOVL CX, CR2
0f2311|223344556677885f5f5f5f5f5f	32	intel	mov dr2, ecx
0f2311|223344556677885f5f5f5f5f5f	32	plan9	MOVL CX, DR2
0f2311|223344556677885f5f5f5f5f5f	64	gnu	mov %rcx,%db2
0f2311|223344556677885f5f5f5f5f5f	64	intel	mov dr2, rcx
0f2311|223344556677885f5f5f5f5f5f	64	plan9	MOVL CX, DR2
0f2411|223344556677885f5f5f5f5f5f	32	intel	mov ecx, tr2
0f2411|223344556677885f5f5f5f5f5f	32	plan9	MOVL TR2, CX
0f2411|223344556677885f5f5f5f5f5f	64	gnu	mov %tr2,%rcx
0f2411|223344556677885f5f5f5f5f5f	64	intel	mov rcx, tr2
0f2411|223344556677885f5f5f5f5f5f	64	plan9	MOVL TR2, CX
0f2611|223344556677885f5f5f5f5f5f	32	intel	mov tr2, ecx
0f2611|223344556677885f5f5f5f5f5f	32	plan9	MOVL CX, TR2
0f2611|223344556677885f5f5f5f5f5f	64	gnu	mov %rcx,%tr2
0f2611|223344556677885f5f5f5f5f5f	64	intel	mov tr2, rcx
0f2611|223344556677885f5f5f5f5f5f	64	plan9	MOVL CX, TR2
0f2811|223344556677885f5f5f5f5f5f	32	intel	movaps xmm2, xmmword ptr [ecx]
0f2811|223344556677885f5f5f5f5f5f	32	plan9	MOVAPS 0(CX), X2
0f2811|223344556677885f5f5f5f5f5f	64	gnu	movaps (%rcx),%xmm2
0f2811|223344556677885f5f5f5f5f5f	64	intel	movaps xmm2, xmmword ptr [rcx]
0f2811|223344556677885f5f5f5f5f5f	64	plan9	MOVAPS 0(CX), X2
0f2911|223344556677885f5f5f5f5f5f	32	intel	movaps xmmword ptr [ecx], xmm2
0f2911|223344556677885f5f5f5f5f5f	32	plan9	MOVAPS X2, 0(CX)
0f2911|223344556677885f5f5f5f5f5f	64	gnu	movaps %xmm2,(%rcx)
0f2911|223344556677885f5f5f5f5f5f	64	intel	movaps xmmword ptr [rcx], xmm2
0f2911|223344556677885f5f5f5f5f5f	64	plan9	MOVAPS X2, 0(CX)
0f2a11|223344556677885f5f5f5f5f5f	32	intel	cvtpi2ps xmm2, qword ptr [ecx]
0f2a11|223344556677885f5f5f5f5f5f	32	plan9	CVTPI2PS 0(CX), X2
0f2a11|223344556677885f5f5f5f5f5f	64	gnu	cvtpi2ps (%rcx),%xmm2
0f2a11|223344556677885f5f5f5f5f5f	64	intel	cvtpi2ps xmm2, qword ptr [rcx]
0f2a11|223344556677885f5f5f5f5f5f	64	plan9	CVTPI2PS 0(CX), X2
0f2b11|223344556677885f5f5f5f5f5f	32	intel	movntps xmmword ptr [ecx], xmm2
0f2b11|223344556677885f5f5f5f5f5f	32	plan9	MOVNTPS X2, 0(CX)
0f2b11|223344556677885f5f5f5f5f5f	64	gnu	movntps %xmm2,(%rcx)
0f2b11|223344556677885f5f5f5f5f5f	64	intel	movntps xmmword ptr [rcx], xmm2
0f2b11|223344556677885f5f5f5f5f5f	64	plan9	MOVNTPS X2, 0(CX)
0f2c11|223344556677885f5f5f5f5f5f	32	intel	cvttps2pi mmx2, qword ptr [ecx]
0f2c11|223344556677885f5f5f5f5f5f	32	plan9	CVTTPS2PI 0(CX), M2
0f2c11|223344556677885f5f5f5f5f5f	64	gnu	cvttps2pi (%rcx),%mm2
0f2c11|223344556677885f5f5f5f5f5f	64	intel	cvttps2pi mmx2, qword ptr [rcx]
0f2c11|223344556677885f5f5f5f5f5f	64	plan9	CVTTPS2PI 0(CX), M2
0f2d11|223344556677885f5f5f5f5f5f	32	intel	cvtps2pi mmx2, qword ptr [ecx]
0f2d11|223344556677885f5f5f5f5f5f	32	plan9	CVTPS2PI 0(CX), M2
0f2d11|223344556677885f5f5f5f5f5f	64	gnu	cvtps2pi (%rcx),%mm2
0f2d11|223344556677885f5f5f5f5f5f	64	intel	cvtps2pi mmx2, qword ptr [rcx]
0f2d11|223344556677885f5f5f5f5f5f	64	plan9	CVTPS2PI 0(CX), M2
0f2e11|223344556677885f5f5f5f5f5f	32	intel	ucomiss xmm2, dword ptr [ecx]
0f2e11|223344556677885f5f5f5f5f5f	32	plan9	UCOMISS 0(CX), X2
0f2e11|223344556677885f5f5f5f5f5f	64	gnu	ucomiss (%rcx),%xmm2
0f2e11|223344556677885f5f5f5f5f5f	64	intel	ucomiss xmm2, dword ptr [rcx]
0f2e11|223344556677885f5f5f5f5f5f	64	plan9	UCOMISS 0(CX), X2
0f2f11|223344556677885f5f5f5f5f5f	32	intel	comiss xmm2, dword ptr [ecx]
0f2f11|223344556677885f5f5f5f5f5f	32	plan9	COMISS 0(CX), X2
0f2f11|223344556677885f5f5f5f5f5f	64	gnu	comiss (%rcx),%xmm2
0f2f11|223344556677885f5f5f5f5f5f	64	intel	comiss xmm2, dword ptr [rcx]
0f2f11|223344556677885f5f5f5f5f5f	64	plan9	COMISS 0(CX), X2
0f30|11223344556677885f5f5f5f5f5f	32	intel	wrmsr
0f30|11223344556677885f5f5f5f5f5f	32	plan9	WRMSR
0f30|11223344556677885f5f5f5f5f5f	64	gnu	wrmsr
0f30|11223344556677885f5f5f5f5f5f	64	intel	wrmsr
0f30|11223344556677885f5f5f5f5f5f	64	plan9	WRMSR
0f31|11223344556677885f5f5f5f5f5f	32	intel	rdtsc
0f31|11223344556677885f5f5f5f5f5f	32	plan9	RDTSC
0f31|11223344556677885f5f5f5f5f5f	64	gnu	rdtsc
0f31|11223344556677885f5f5f5f5f5f	64	intel	rdtsc
0f31|11223344556677885f5f5f5f5f5f	64	plan9	RDTSC
0f32|11223344556677885f5f5f5f5f5f	32	intel	rdmsr
0f32|11223344556677885f5f5f5f5f5f	32	plan9	RDMSR
0f32|11223344556677885f5f5f5f5f5f	64	gnu	rdmsr
0f32|11223344556677885f5f5f5f5f5f	64	intel	rdmsr
0f32|11223344556677885f5f5f5f5f5f	64	plan9	RDMSR
0f33|11223344556677885f5f5f5f5f5f	32	intel	rdpmc
0f33|11223344556677885f5f5f5f5f5f	32	plan9	RDPMC
0f33|11223344556677885f5f5f5f5f5f	64	gnu	rdpmc
0f33|11223344556677885f5f5f5f5f5f	64	intel	rdpmc
0f33|11223344556677885f5f5f5f5f5f	64	plan9	RDPMC
0f34|11223344556677885f5f5f5f5f5f	32	intel	sysenter
0f34|11223344556677885f5f5f5f5f5f	32	plan9	SYSENTER
0f34|11223344556677885f5f5f5f5f5f	64	gnu	sysenter
0f34|11223344556677885f5f5f5f5f5f	64	intel	sysenter
0f34|11223344556677885f5f5f5f5f5f	64	plan9	SYSENTER
0f35|11223344556677885f5f5f5f5f5f	32	intel	sysexit
0f35|11223344556677885f5f5f5f5f5f	32	plan9	SYSEXIT
0f35|11223344556677885f5f5f5f5f5f	64	gnu	sysexit
0f35|11223344556677885f5f5f5f5f5f	64	intel	sysexit
0f35|11223344556677885f5f5f5f5f5f	64	plan9	SYSEXIT
0f380011|223344556677885f5f5f5f5f	32	intel	pshufb mmx2, qword ptr [ecx]
0f380011|223344556677885f5f5f5f5f	32	plan9	PSHUFB 0(CX), M2
0f380011|223344556677885f5f5f5f5f	64	gnu	pshufb (%rcx),%mm2
0f380011|223344556677885f5f5f5f5f	64	intel	pshufb mmx2, qword ptr [rcx]
0f380011|223344556677885f5f5f5f5f	64	plan9	PSHUFB 0(CX), M2
0f380111|223344556677885f5f5f5f5f	32	intel	phaddw mmx2, qword ptr [ecx]
0f380111|223344556677885f5f5f5f5f	32	plan9	PHADDW 0(CX), M2
0f380111|223344556677885f5f5f5f5f	64	gnu	phaddw (%rcx),%mm2
0f380111|223344556677885f5f5f5f5f	64	intel	phaddw mmx2, qword ptr [rcx]
0f380111|223344556677885f5f5f5f5f	64	plan9	PHADDW 0(CX), M2
0f380211|223344556677885f5f5f5f5f	32	intel	phaddd mmx2, qword ptr [ecx]
0f380211|223344556677885f5f5f5f5f	32	plan9	PHADDD 0(CX), M2
0f380211|223344556677885f5f5f5f5f	64	gnu	phaddd (%rcx),%mm2
0f380211|223344556677885f5f5f5f5f	64	intel	phaddd mmx2, qword ptr [rcx]
0f380211|223344556677885f5f5f5f5f	64	plan9	PHADDD 0(CX), M2
0f380311|223344556677885f5f5f5f5f	32	intel	phaddsw mmx2, qword ptr [ecx]
0f380311|223344556677885f5f5f5f5f	32	plan9	PHADDSW 0(CX), M2
0f380311|223344556677885f5f5f5f5f	64	gnu	phaddsw (%rcx),%mm2
0f380311|223344556677885f5f5f5f5f	64	intel	phaddsw mmx2, qword ptr [rcx]
0f380311|223344556677885f5f5f5f5f	64	plan9	PHADDSW 0(CX), M2
0f380411|223344556677885f5f5f5f5f	32	intel	pmaddubsw mmx2, qword ptr [ecx]
0f380411|223344556677885f5f5f5f5f	32	plan9	PMADDUBSW 0(CX), M2
0f380411|223344556677885f5f5f5f5f	64	gnu	pmaddubsw (%rcx),%mm2
0f380411|223344556677885f5f5f5f5f	64	intel	pmaddubsw mmx2, qword ptr [rcx]
0f380411|223344556677885f5f5f5f5f	64	plan9	PMADDUBSW 0(CX), M2
0f380511|223344556677885f5f5f5f5f	32	intel	phsubw mmx2, qword ptr [ecx]
0f380511|223344556677885f5f5f5f5f	32	plan9	PHSUBW 0(CX), M2
0f380511|223344556677885f5f5f5f5f	64	gnu	phsubw (%rcx),%mm2
0f380511|223344556677885f5f5f5f5f	64	intel	phsubw mmx2, qword ptr [rcx]
0f380511|223344556677885f5f5f5f5f	64	plan9	PHSUBW 0(CX), M2
0f380611|223344556677885f5f5f5f5f	32	intel	phsubd mmx2, qword ptr [ecx]
0f380611|223344556677885f5f5f5f5f	32	plan9	PHSUBD 0(CX), M2
0f380611|223344556677885f5f5f5f5f	64	gnu	phsubd (%rcx),%mm2
0f380611|223344556677885f5f5f5f5f	64	intel	phsubd mmx2, qword ptr [rcx]
0f380611|223344556677885f5f5f5f5f	64	plan9	PHSUBD 0(CX), M2
0f380711|223344556677885f5f5f5f5f	32	intel	phsubsw mmx2, qword ptr [ecx]
0f380711|223344556677885f5f5f5f5f	32	plan9	PHSUBSW 0(CX), M2
0f380711|223344556677885f5f5f5f5f	64	gnu	phsubsw (%rcx),%mm2
0f380711|223344556677885f5f5f5f5f	64	intel	phsubsw mmx2, qword ptr [rcx]
0f380711|223344556677885f5f5f5f5f	64	plan9	PHSUBSW 0(CX), M2
0f380811|223344556677885f5f5f5f5f	32	intel	psignb mmx2, qword ptr [ecx]
0f380811|223344556677885f5f5f5f5f	32	plan9	PSIGNB 0(CX), M2
0f380811|223344556677885f5f5f5f5f	64	gnu	psignb (%rcx),%mm2
0f380811|223344556677885f5f5f5f5f	64	intel	psignb mmx2, qword ptr [rcx]
0f380811|223344556677885f5f5f5f5f	64	plan9	PSIGNB 0(CX), M2
0f380911|223344556677885f5f5f5f5f	32	intel	psignw mmx2, qword ptr [ecx]
0f380911|223344556677885f5f5f5f5f	32	plan9	PSIGNW 0(CX), M2
0f380911|223344556677885f5f5f5f5f	64	gnu	psignw (%rcx),%mm2
0f380911|223344556677885f5f5f5f5f	64	intel	psignw mmx2, qword ptr [rcx]
0f380911|223344556677885f5f5f5f5f	64	plan9	PSIGNW 0(CX), M2
0f380a11|223344556677885f5f5f5f5f	32	intel	psignd mmx2, qword ptr [ecx]
0f380a11|223344556677885f5f5f5f5f	32	plan9	PSIGND 0(CX), M2
0f380a11|223344556677885f5f5f5f5f	64	gnu	psignd (%rcx),%mm2
0f380a11|223344556677885f5f5f5f5f	64	intel	psignd mmx2, qword ptr [rcx]
0f380a11|223344556677885f5f5f5f5f	64	plan9	PSIGND 0(CX), M2
0f380b11|223344556677885f5f5f5f5f	32	intel	pmulhrsw mmx2, qword ptr [ecx]
0f380b11|223344556677885f5f5f5f5f	32	plan9	PMULHRSW 0(CX), M2
0f380b11|223344556677885f5f5f5f5f	64	gnu	pmulhrsw (%rcx),%mm2
0f380b11|223344556677885f5f5f5f5f	64	intel	pmulhrsw mmx2, qword ptr [rcx]
0f380b11|223344556677885f5f5f5f5f	64	plan9	PMULHRSW 0(CX), M2
0f3810|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f381c11|223344556677885f5f5f5f5f	32	intel	pabsb mmx2, qword ptr [ecx]
0f381c11|223344556677885f5f5f5f5f	32	plan9	PABSB 0(CX), M2
0f381c11|223344556677885f5f5f5f5f	64	gnu	pabsb (%rcx),%mm2
0f381c11|223344556677885f5f5f5f5f	64	intel	pabsb mmx2, qword ptr [rcx]
0f381c11|223344556677885f5f5f5f5f	64	plan9	PABSB 0(CX), M2
0f381d11|223344556677885f5f5f5f5f	32	intel	pabsw mmx2, qword ptr [ecx]
0f381d11|223344556677885f5f5f5f5f	32	plan9	PABSW 0(CX), M2
0f381d11|223344556677885f5f5f5f5f	64	gnu	pabsw (%rcx),%mm2
0f381d11|223344556677885f5f5f5f5f	64	intel	pabsw mmx2, qword ptr [rcx]
0f381d11|223344556677885f5f5f5f5f	64	plan9	PABSW 0(CX), M2
0f381e11|223344556677885f5f5f5f5f	32	intel	pabsd mmx2, qword ptr [ecx]
0f381e11|223344556677885f5f5f5f5f	32	plan9	PABSD 0(CX), M2
0f381e11|223344556677885f5f5f5f5f	64	gnu	pabsd (%rcx),%mm2
0f381e11|223344556677885f5f5f5f5f	64	intel	pabsd mmx2, qword ptr [rcx]
0f381e11|223344556677885f5f5f5f5f	64	plan9	PABSD 0(CX), M2
0f3820|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38f011|223344556677885f5f5f5f5f	32	intel	movbe edx, dword ptr [ecx]
0f38f011|223344556677885f5f5f5f5f	32	plan9	MOVBE 0(CX), DX
0f38f011|223344556677885f5f5f5f5f	64	gnu	movbe (%rcx),%edx
0f38f011|223344556677885f5f5f5f5f	64	intel	movbe edx, dword ptr [rcx]
0f38f011|223344556677885f5f5f5f5f	64	plan9	MOVBE 0(CX), DX
0f38f111|223344556677885f5f5f5f5f	32	intel	movbe dword ptr [ecx], edx
0f38f111|223344556677885f5f5f5f5f	32	plan9	MOVBE DX, 0(CX)
0f38f111|223344556677885f5f5f5f5f	64	gnu	movbe %edx,(%rcx)
0f38f111|223344556677885f5f5f5f5f	64	intel	movbe dword ptr [rcx], edx
0f38f111|223344556677885f5f5f5f5f	64	plan9	MOVBE DX, 0(CX)
0f3a08|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0f1122|3344556677885f5f5f5f5f	32	intel	palignr mmx2, qword ptr [ecx], 0x22
0f3a0f1122|3344556677885f5f5f5f5f	32	plan9	PALIGNR $0x22, 0(CX), M2
0f3a0f1122|3344556677885f5f5f5f5f	64	gnu	palignr $0x22,(%rcx),%mm2
0f3a0f1122|3344556677885f5f5f5f5f	64	intel	palignr mmx2, qword ptr [rcx], 0x22
0f3a0f1122|3344556677885f5f5f5f5f	64	plan9	PALIGNR $0x22, 0(CX), M2
0f3a11|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f4011|223344556677885f5f5f5f5f5f	32	intel	cmovo edx, dword ptr [ecx]
0f4011|223344556677885f5f5f5f5f5f	32	plan9	CMOVO 0(CX), DX
0f4011|223344556677885f5f5f5f5f5f	64	gnu	cmovo (%rcx),%edx
0f4011|223344556677885f5f5f5f5f5f	64	intel	cmovo edx, dword ptr [rcx]
0f4011|223344556677885f5f5f5f5f5f	64	plan9	CMOVO 0(CX), DX
0f4111|223344556677885f5f5f5f5f5f	32	intel	cmovno edx, dword ptr [ecx]
0f4111|223344556677885f5f5f5f5f5f	32	plan9	CMOVNO 0(CX), DX
0f4111|223344556677885f5f5f5f5f5f	64	gnu	cmovno (%rcx),%edx
0f4111|223344556677885f5f5f5f5f5f	64	intel	cmovno edx, dword ptr [rcx]
0f4111|223344556677885f5f5f5f5f5f	64	plan9	CMOVNO 0(CX), DX
0f4211|223344556677885f5f5f5f5f5f	32	intel	cmovb edx, dword ptr [ecx]
0f4211|223344556677885f5f5f5f5f5f	32	plan9	CMOVB 0(CX), DX
0f4211|223344556677885f5f5f5f5f5f	64	gnu	cmovb (%rcx),%edx
0f4211|223344556677885f5f5f5f5f5f	64	intel	cmovb edx, dword ptr [rcx]
0f4211|223344556677885f5f5f5f5f5f	64	plan9	CMOVB 0(CX), DX
0f4311|223344556677885f5f5f5f5f5f	32	intel	cmovnb edx, dword ptr [ecx]
0f4311|223344556677885f5f5f5f5f5f	32	plan9	CMOVAE 0(CX), DX
0f4311|223344556677885f5f5f5f5f5f	64	gnu	cmovae (%rcx),%edx
0f4311|223344556677885f5f5f5f5f5f	64	intel	cmovnb edx, dword ptr [rcx]
0f4311|223344556677885f5f5f5f5f5f	64	plan9	CMOVAE 0(CX), DX
0f4411|223344556677885f5f5f5f5f5f	32	intel	cmovz edx, dword ptr [ecx]
0f4411|223344556677885f5f5f5f5f5f	32	plan9	CMOVE 0(CX), DX
0f4411|223344556677885f5f5f5f5f5f	64	gnu	cmove (%rcx),%edx
0f4411|223344556677885f5f5f5f5f5f	64	intel	cmovz edx, dword ptr [rcx]
0f4411|223344556677885f5f5f5f5f5f	64	plan9	CMOVE 0(CX), DX
0f4511|223344556677885f5f5f5f5f5f	32	intel	cmovnz edx, dword ptr [ecx]
0f4511|223344556677885f5f5f5f5f5f	32	plan9	CMOVNE 0(CX), DX
0f4511|223344556677885f5f5f5f5f5f	64	gnu	cmovne (%rcx),%edx
0f4511|223344556677885f5f5f5f5f5f	64	intel	cmovnz edx, dword ptr [rcx]
0f4511|223344556677885f5f5f5f5f5f	64	plan9	CMOVNE 0(CX), DX
0f4611|223344556677885f5f5f5f5f5f	32	intel	cmovbe edx, dword ptr [ecx]
0f4611|223344556677885f5f5f5f5f5f	32	plan9	CMOVBE 0(CX), DX
0f4611|223344556677885f5f5f5f5f5f	64	gnu	cmovbe (%rcx),%edx
0f4611|223344556677885f5f5f5f5f5f	64	intel	cmovbe edx, dword ptr [rcx]
0f4611|223344556677885f5f5f5f5f5f	64	plan9	CMOVBE 0(CX), DX
0f4711|223344556677885f5f5f5f5f5f	32	intel	cmovnbe edx, dword ptr [ecx]
0f4711|223344556677885f5f5f5f5f5f	32	plan9	CMOVA 0(CX), DX
0f4711|223344556677885f5f5f5f5f5f	64	gnu	cmova (%rcx),%edx
0f4711|223344556677885f5f5f5f5f5f	64	intel	cmovnbe edx, dword ptr [rcx]
0f4711|223344556677885f5f5f5f5f5f	64	plan9	CMOVA 0(CX), DX
0f4811|223344556677885f5f5f5f5f5f	32	intel	cmovs edx, dword ptr [ecx]
0f4811|223344556677885f5f5f5f5f5f	32	plan9	CMOVS 0(CX), DX
0f4811|223344556677885f5f5f5f5f5f	64	gnu	cmovs (%rcx),%edx
0f4811|223344556677885f5f5f5f5f5f	64	intel	cmovs edx, dword ptr [rcx]
0f4811|223344556677885f5f5f5f5f5f	64	plan9	CMOVS 0(CX), DX
0f4911|223344556677885f5f5f5f5f5f	32	intel	cmovns edx, dword ptr [ecx]
0f4911|223344556677885f5f5f5f5f5f	32	plan9	CMOVNS 0(CX), DX
0f4911|223344556677885f5f5f5f5f5f	64	gnu	cmovns (%rcx),%edx
0f4911|223344556677885f5f5f5f5f5f	64	intel	cmovns edx, dword ptr [rcx]
0f4911|223344556677885f5f5f5f5f5f	64	plan9	CMOVNS 0(CX), DX
0f4a11|223344556677885f5f5f5f5f5f	32	intel	cmovp edx, dword ptr [ecx]
0f4a11|223344556677885f5f5f5f5f5f	32	plan9	CMOVP 0(CX), DX
0f4a11|223344556677885f5f5f5f5f5f	64	gnu	cmovp (%rcx),%edx
0f4a11|223344556677885f5f5f5f5f5f	64	intel	cmovp edx, dword ptr [rcx]
0f4a11|223344556677885f5f5f5f5f5f	64	plan9	CMOVP 0(CX), DX
0f4b11|223344556677885f5f5f5f5f5f	32	intel	cmovnp edx, dword ptr [ecx]
0f4b11|223344556677885f5f5f5f5f5f	32	plan9	CMOVNP 0(CX), DX
0f4b11|223344556677885f5f5f5f5f5f	64	gnu	cmovnp (%rcx),%edx
0f4b11|223344556677885f5f5f5f5f5f	64	intel	cmovnp edx, dword ptr [rcx]
0f4b11|223344556677885f5f5f5f5f5f	64	plan9	CMOVNP 0(CX), DX
0f4c11|223344556677885f5f5f5f5f5f	32	intel	cmovl edx, dword ptr [ecx]
0f4c11|223344556677885f5f5f5f5f5f	32	plan9	CMOVL 0(CX), DX
0f4c11|223344556677885f5f5f5f5f5f	64	gnu	cmovl (%rcx),%edx
0f4c11|223344556677885f5f5f5f5f5f	64	intel	cmovl edx, dword ptr [rcx]
0f4c11|223344556677885f5f5f5f5f5f	64	plan9	CMOVL 0(CX), DX
0f4d11|223344556677885f5f5f5f5f5f	32	intel	cmovnl edx, dword ptr [ecx]
0f4d11|223344556677885f5f5f5f5f5f	32	plan9	CMOVGE 0(CX), DX
0f4d11|223344556677885f5f5f5f5f5f	64	gnu	cmovge (%rcx),%edx
0f4d11|223344556677885f5f5f5f5f5f	64	intel	cmovnl edx, dword ptr [rcx]
0f4d11|223344556677885f5f5f5f5f5f	64	plan9	CMOVGE 0(CX), DX
0f4e11|223344556677885f5f5f5f5f5f	32	intel	cmovle edx, dword ptr [ecx]
0f4e11|223344556677885f5f5f5f5f5f	32	plan9	CMOVLE 0(CX), DX
0f4e11|223344556677885f5f5f5f5f5f	64	gnu	cmovle (%rcx),%edx
0f4e11|223344556677885f5f5f5f5f5f	64	intel	cmovle edx, dword ptr [rcx]
0f4e11|223344556677885f5f5f5f5f5f	64	plan9	CMOVLE 0(CX), DX
0f4f11|223344556677885f5f5f5f5f5f	32	intel	cmovnle edx, dword ptr [ecx]
0f4f11|223344556677885f5f5f5f5f5f	32	plan9	CMOVG 0(CX), DX
0f4f11|223344556677885f5f5f5f5f5f	64	gnu	cmovg (%rcx),%edx
0f4f11|223344556677885f5f5f5f5f5f	64	intel	cmovnle edx, dword ptr [rcx]
0f4f11|223344556677885f5f5f5f5f5f	64	plan9	CMOVG 0(CX), DX
0f5011|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f50c0|11223344556677885f5f5f5f5f	32	intel	movmskps eax, xmm0
0f50c0|11223344556677885f5f5f5f5f	32	plan9	MOVMSKPS X0, AX
0f50c0|11223344556677885f5f5f5f5f	64	gnu	movmskps %xmm0,%eax
0f50c0|11223344556677885f5f5f5f5f	64	intel	movmskps eax, xmm0
0f50c0|11223344556677885f5f5f5f5f	64	plan9	MOVMSKPS X0, AX
0f5111|223344556677885f5f5f5f5f5f	32	intel	sqrtps xmm2, xmmword ptr [ecx]
0f5111|223344556677885f5f5f5f5f5f	32	plan9	SQRTPS 0(CX), X2
0f5111|223344556677885f5f5f5f5f5f	64	gnu	sqrtps (%rcx),%xmm2
0f5111|223344556677885f5f5f5f5f5f	64	intel	sqrtps xmm2, xmmword ptr [rcx]
0f5111|223344556677885f5f5f5f5f5f	64	plan9	SQRTPS 0(CX), X2
0f5211|223344556677885f5f5f5f5f5f	32	intel	rsqrtps xmm2, xmmword ptr [ecx]
0f5211|223344556677885f5f5f5f5f5f	32	plan9	RSQRTPS 0(CX), X2
0f5211|223344556677885f5f5f5f5f5f	64	gnu	rsqrtps (%rcx),%xmm2
0f5211|223344556677885f5f5f5f5f5f	64	intel	rsqrtps xmm2, xmmword ptr [rcx]
0f5211|223344556677885f5f5f5f5f5f	64	plan9	RSQRTPS 0(CX), X2
0f5311|223344556677885f5f5f5f5f5f	32	intel	rcpps xmm2, xmmword ptr [ecx]
0f5311|223344556677885f5f5f5f5f5f	32	plan9	RCPPS 0(CX), X2
0f5311|223344556677885f5f5f5f5f5f	64	gnu	rcpps (%rcx),%xmm2
0f5311|223344556677885f5f5f5f5f5f	64	intel	rcpps xmm2, xmmword ptr [rcx]
0f5311|223344556677885f5f5f5f5f5f	64	plan9	RCPPS 0(CX), X2
0f5411|223344556677885f5f5f5f5f5f	32	intel	andps xmm2, xmmword ptr [ecx]
0f5411|223344556677885f5f5f5f5f5f	32	plan9	ANDPS 0(CX), X2
0f5411|223344556677885f5f5f5f5f5f	64	gnu	andps (%rcx),%xmm2
0f5411|223344556677885f5f5f5f5f5f	64	intel	andps xmm2, xmmword ptr [rcx]
0f5411|223344556677885f5f5f5f5f5f	64	plan9	ANDPS 0(CX), X2
0f5511|223344556677885f5f5f5f5f5f	32	intel	andnps xmm2, xmmword ptr [ecx]
0f5511|223344556677885f5f5f5f5f5f	32	plan9	ANDNPS 0(CX), X2
0f5511|223344556677885f5f5f5f5f5f	64	gnu	andnps (%rcx),%xmm2
0f5511|223344556677885f5f5f5f5f5f	64	intel	andnps xmm2, xmmword ptr [rcx]
0f5511|223344556677885f5f5f5f5f5f	64	plan9	ANDNPS 0(CX), X2
0f5611|223344556677885f5f5f5f5f5f	32	intel	orps xmm2, xmmword ptr [ecx]
0f5611|223344556677885f5f5f5f5f5f	32	plan9	ORPS 0(CX), X2
0f5611|223344556677885f5f5f5f5f5f	64	gnu	orps (%rcx),%xmm2
0f5611|223344556677885f5f5f5f5f5f	64	intel	orps xmm2, xmmword ptr [rcx]
0f5611|223344556677885f5f5f5f5f5f	64	plan9	ORPS 0(CX), X2
0f5711|223344556677885f5f5f5f5f5f	32	intel	xorps xmm2, xmmword ptr [ecx]
0f5711|223344556677885f5f5f5f5f5f	32	plan9	XORPS 0(CX), X2
0f5711|223344556677885f5f5f5f5f5f	64	gnu	xorps (%rcx),%xmm2
0f5711|223344556677885f5f5f5f5f5f	64	intel	xorps xmm2, xmmword ptr [rcx]
0f5711|223344556677885f5f5f5f5f5f	64	plan9	XORPS 0(CX), X2
0f5811|223344556677885f5f5f5f5f5f	32	intel	addps xmm2, xmmword ptr [ecx]
0f5811|223344556677885f5f5f5f5f5f	32	plan9	ADDPS 0(CX), X2
0f5811|223344556677885f5f5f5f5f5f	64	gnu	addps (%rcx),%xmm2
0f5811|223344556677885f5f5f5f5f5f	64	intel	addps xmm2, xmmword ptr [rcx]
0f5811|223344556677885f5f5f5f5f5f	64	plan9	ADDPS 0(CX), X2
0f5911|223344556677885f5f5f5f5f5f	32	intel	mulps xmm2, xmmword ptr [ecx]
0f5911|223344556677885f5f5f5f5f5f	32	plan9	MULPS 0(CX), X2
0f5911|223344556677885f5f5f5f5f5f	64	gnu	mulps (%rcx),%xmm2
0f5911|223344556677885f5f5f5f5f5f	64	intel	mulps xmm2, xmmword ptr [rcx]
0f5911|223344556677885f5f5f5f5f5f	64	plan9	MULPS 0(CX), X2
0f5a11|223344556677885f5f5f5f5f5f	32	intel	cvtps2pd xmm2, qword ptr [ecx]
0f5a11|223344556677885f5f5f5f5f5f	32	plan9	CVTPS2PD 0(CX), X2
0f5a11|223344556677885f5f5f5f5f5f	64	gnu	cvtps2pd (%rcx),%xmm2
0f5a11|223344556677885f5f5f5f5f5f	64	intel	cvtps2pd xmm2, qword ptr [rcx]
0f5a11|223344556677885f5f5f5f5f5f	64	plan9	CVTPS2PD 0(CX), X2
0f5b11|223344556677885f5f5f5f5f5f	32	intel	cvtdq2ps xmm2, xmmword ptr [ecx]
0f5b11|223344556677885f5f5f5f5f5f	32	plan9	CVTDQ2PS 0(CX), X2
0f5b11|223344556677885f5f5f5f5f5f	64	gnu	cvtdq2ps (%rcx),%xmm2
0f5b11|223344556677885f5f5f5f5f5f	64	intel	cvtdq2ps xmm2, xmmword ptr [rcx]
0f5b11|223344556677885f5f5f5f5f5f	64	plan9	CVTDQ2PS 0(CX), X2
0f5c11|223344556677885f5f5f5f5f5f	32	intel	subps xmm2, xmmword ptr [ecx]
0f5c11|223344556677885f5f5f5f5f5f	32	plan9	SUBPS 0(CX), X2
0f5c11|223344556677885f5f5f5f5f5f	64	gnu	subps (%rcx),%xmm2
0f5c11|223344556677885f5f5f5f5f5f	64	intel	subps xmm2, xmmword ptr [rcx]
0f5c11|223344556677885f5f5f5f5f5f	64	plan9	SUBPS 0(CX), X2
0f5d11|223344556677885f5f5f5f5f5f	32	intel	minps xmm2, xmmword ptr [ecx]
0f5d11|223344556677885f5f5f5f5f5f	32	plan9	MINPS 0(CX), X2
0f5d11|223344556677885f5f5f5f5f5f	64	gnu	minps (%rcx),%xmm2
0f5d11|223344556677885f5f5f5f5f5f	64	intel	minps xmm2, xmmword ptr [rcx]
0f5d11|223344556677885f5f5f5f5f5f	64	plan9	MINPS 0(CX), X2
0f5e11|223344556677885f5f5f5f5f5f	32	intel	divps xmm2, xmmword ptr [ecx]
0f5e11|223344556677885f5f5f5f5f5f	32	plan9	DIVPS 0(CX), X2
0f5e11|223344556677885f5f5f5f5f5f	64	gnu	divps (%rcx),%xmm2
0f5e11|223344556677885f5f5f5f5f5f	64	intel	divps xmm2, xmmword ptr [rcx]
0f5e11|223344556677885f5f5f5f5f5f	64	plan9	DIVPS 0(CX), X2
0f5f11|223344556677885f5f5f5f5f5f	32	intel	maxps xmm2, xmmword ptr [ecx]
0f5f11|223344556677885f5f5f5f5f5f	32	plan9	MAXPS 0(CX), X2
0f5f11|223344556677885f5f5f5f5f5f	64	gnu	maxps (%rcx),%xmm2
0f5f11|223344556677885f5f5f5f5f5f	64	intel	maxps xmm2, xmmword ptr [rcx]
0f5f11|223344556677885f5f5f5f5f5f	64	plan9	MAXPS 0(CX), X2
0f6011|223344556677885f5f5f5f5f5f	32	intel	punpcklbw mmx2, dword ptr [ecx]
0f6011|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKLBW 0(CX), M2
0f6011|223344556677885f5f5f5f5f5f	64	gnu	punpcklbw (%rcx),%mm2
0f6011|223344556677885f5f5f5f5f5f	64	intel	punpcklbw mmx2, dword ptr [rcx]
0f6011|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKLBW 0(CX), M2
0f6111|223344556677885f5f5f5f5f5f	32	intel	punpcklwd mmx2, dword ptr [ecx]
0f6111|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKLWD 0(CX), M2
0f6111|223344556677885f5f5f5f5f5f	64	gnu	punpcklwd (%rcx),%mm2
0f6111|223344556677885f5f5f5f5f5f	64	intel	punpcklwd mmx2, dword ptr [rcx]
0f6111|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKLWD 0(CX), M2
0f6211|223344556677885f5f5f5f5f5f	32	intel	punpckldq mmx2, dword ptr [ecx]
0f6211|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKLDQ 0(CX), M2
0f6211|223344556677885f5f5f5f5f5f	64	gnu	punpckldq (%rcx),%mm2
0f6211|223344556677885f5f5f5f5f5f	64	intel	punpckldq mmx2, dword ptr [rcx]
0f6211|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKLDQ 0(CX), M2
0f6311|223344556677885f5f5f5f5f5f	32	intel	packsswb mmx2, qword ptr [ecx]
0f6311|223344556677885f5f5f5f5f5f	32	plan9	PACKSSWB 0(CX), M2
0f6311|223344556677885f5f5f5f5f5f	64	gnu	packsswb (%rcx),%mm2
0f6311|223344556677885f5f5f5f5f5f	64	intel	packsswb mmx2, qword ptr [rcx]
0f6311|223344556677885f5f5f5f5f5f	64	plan9	PACKSSWB 0(CX), M2
0f6411|223344556677885f5f5f5f5f5f	32	intel	pcmpgtb mmx2, qword ptr [ecx]
0f6411|223344556677885f5f5f5f5f5f	32	plan9	PCMPGTB 0(CX), M2
0f6411|223344556677885f5f5f5f5f5f	64	gnu	pcmpgtb (%rcx),%mm2
0f6411|223344556677885f5f5f5f5f5f	64	intel	pcmpgtb mmx2, qword ptr [rcx]
0f6411|223344556677885f5f5f5f5f5f	64	plan9	PCMPGTB 0(CX), M2
0f6511|223344556677885f5f5f5f5f5f	32	intel	pcmpgtw mmx2, qword ptr [ecx]
0f6511|223344556677885f5f5f5f5f5f	32	plan9	PCMPGTW 0(CX), M2
0f6511|223344556677885f5f5f5f5f5f	64	gnu	pcmpgtw (%rcx),%mm2
0f6511|223344556677885f5f5f5f5f5f	64	intel	pcmpgtw mmx2, qword ptr [rcx]
0f6511|223344556677885f5f5f5f5f5f	64	plan9	PCMPGTW 0(CX), M2
0f6611|223344556677885f5f5f5f5f5f	32	intel	pcmpgtd mmx2, qword ptr [ecx]
0f6611|223344556677885f5f5f5f5f5f	32	plan9	PCMPGTD 0(CX), M2
0f6611|223344556677885f5f5f5f5f5f	64	gnu	pcmpgtd (%rcx),%mm2
0f6611|223344556677885f5f5f5f5f5f	64	intel	pcmpgtd mmx2, qword ptr [rcx]
0f6611|223344556677885f5f5f5f5f5f	64	plan9	PCMPGTD 0(CX), M2
0f6711|223344556677885f5f5f5f5f5f	32	intel	packuswb mmx2, qword ptr [ecx]
0f6711|223344556677885f5f5f5f5f5f	32	plan9	PACKUSWB 0(CX), M2
0f6711|223344556677885f5f5f5f5f5f	64	gnu	packuswb (%rcx),%mm2
0f6711|223344556677885f5f5f5f5f5f	64	intel	packuswb mmx2, qword ptr [rcx]
0f6711|223344556677885f5f5f5f5f5f	64	plan9	PACKUSWB 0(CX), M2
0f6811|223344556677885f5f5f5f5f5f	32	intel	punpckhbw mmx2, qword ptr [ecx]
0f6811|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKHBW 0(CX), M2
0f6811|223344556677885f5f5f5f5f5f	64	gnu	punpckhbw (%rcx),%mm2
0f6811|223344556677885f5f5f5f5f5f	64	intel	punpckhbw mmx2, qword ptr [rcx]
0f6811|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKHBW 0(CX), M2
0f6911|223344556677885f5f5f5f5f5f	32	intel	punpckhwd mmx2, qword ptr [ecx]
0f6911|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKHWD 0(CX), M2
0f6911|223344556677885f5f5f5f5f5f	64	gnu	punpckhwd (%rcx),%mm2
0f6911|223344556677885f5f5f5f5f5f	64	intel	punpckhwd mmx2, qword ptr [rcx]
0f6911|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKHWD 0(CX), M2
0f6a11|223344556677885f5f5f5f5f5f	32	intel	punpckhdq mmx2, qword ptr [ecx]
0f6a11|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKHDQ 0(CX), M2
0f6a11|223344556677885f5f5f5f5f5f	64	gnu	punpckhdq (%rcx),%mm2
0f6a11|223344556677885f5f5f5f5f5f	64	intel	punpckhdq mmx2, qword ptr [rcx]
0f6a11|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKHDQ 0(CX), M2
0f6b11|223344556677885f5f5f5f5f5f	32	intel	packssdw mmx2, qword ptr [ecx]
0f6b11|223344556677885f5f5f5f5f5f	32	plan9	PACKSSDW 0(CX), M2
0f6b11|223344556677885f5f5f5f5f5f	64	gnu	packssdw (%rcx),%mm2
0f6b11|223344556677885f5f5f5f5f5f	64	intel	packssdw mmx2, qword ptr [rcx]
0f6b11|223344556677885f5f5f5f5f5f	64	plan9	PACKSSDW 0(CX), M2
0f6c|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f6e11|223344556677885f5f5f5f5f5f	32	intel	movd mmx2, dword ptr [ecx]
0f6e11|223344556677885f5f5f5f5f5f	32	plan9	MOVD 0(CX), M2
0f6e11|223344556677885f5f5f5f5f5f	64	gnu	movd (%rcx),%mm2
0f6e11|223344556677885f5f5f5f5f5f	64	intel	movd mmx2, dword ptr [rcx]
0f6e11|223344556677885f5f5f5f5f5f	64	plan9	MOVD 0(CX), M2
0f6f11|223344556677885f5f5f5f5f5f	32	intel	movq mmx2, qword ptr [ecx]
0f6f11|223344556677885f5f5f5f5f5f	32	plan9	MOVQ 0(CX), M2
0f6f11|223344556677885f5f5f5f5f5f	64	gnu	movq (%rcx),%mm2
0f6f11|223344556677885f5f5f5f5f5f	64	intel	movq mmx2, qword ptr [rcx]
0f6f11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ 0(CX), M2
0f701122|3344556677885f5f5f5f5f5f	32	intel	pshufw mmx2, qword ptr [ecx], 0x22
0f701122|3344556677885f5f5f5f5f5f	32	plan9	PSHUFW $0x22, 0(CX), M2
0f701122|3344556677885f5f5f5f5f5f	64	gnu	pshufw $0x22,(%rcx),%mm2
0f701122|3344556677885f5f5f5f5f5f	64	intel	pshufw mmx2, qword ptr [rcx], 0x22
0f701122|3344556677885f5f5f5f5f5f	64	plan9	PSHUFW $0x22, 0(CX), M2
0f7100|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f71d011|223344556677885f5f5f5f5f	32	intel	psrlw mmx0, 0x11
0f71d011|223344556677885f5f5f5f5f	32	plan9	PSRLW $0x11, M0
0f71d011|223344556677885f5f5f5f5f	64	gnu	psrlw $0x11,%mm0
0f71d011|223344556677885f5f5f5f5f	64	intel	psrlw mmx0, 0x11
0f71d011|223344556677885f5f5f5f5f	64	plan9	PSRLW $0x11, M0
0f71e011|223344556677885f5f5f5f5f	32	intel	psraw mmx0, 0x11
0f71e011|223344556677885f5f5f5f5f	32	plan9	PSRAW $0x11, M0
0f71e011|223344556677885f5f5f5f5f	64	gnu	psraw $0x11,%mm0
0f71e011|223344556677885f5f5f5f5f	64	intel	psraw mmx0, 0x11
0f71e011|223344556677885f5f5f5f5f	64	plan9	PSRAW $0x11, M0
0f71f011|223344556677885f5f5f5f5f	32	intel	psllw mmx0, 0x11
0f71f011|223344556677885f5f5f5f5f	32	plan9	PSLLW $0x11, M0
0f71f011|223344556677885f5f5f5f5f	64	gnu	psllw $0x11,%mm0
0f71f011|223344556677885f5f5f5f5f	64	intel	psllw mmx0, 0x11
0f71f011|223344556677885f5f5f5f5f	64	plan9	PSLLW $0x11, M0
0f7200|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f72d011|223344556677885f5f5f5f5f	32	intel	psrld mmx0, 0x11
0f72d011|223344556677885f5f5f5f5f	32	plan9	PSRLD $0x11, M0
0f72d011|223344556677885f5f5f5f5f	64	gnu	psrld $0x11,%mm0
0f72d011|223344556677885f5f5f5f5f	64	intel	psrld mmx0, 0x11
0f72d011|223344556677885f5f5f5f5f	64	plan9	PSRLD $0x11, M0
0f72e011|223344556677885f5f5f5f5f	32	intel	psrad mmx0, 0x11
0f72e011|223344556677885f5f5f5f5f	32	plan9	PSRAD $0x11, M0
0f72e011|223344556677885f5f5f5f5f	64	gnu	psrad $0x11,%mm0
0f72e011|223344556677885f5f5f5f5f	64	intel	psrad mmx0, 0x11
0f72e011|223344556677885f5f5f5f5f	64	plan9	PSRAD $0x11, M0
0f72f011|223344556677885f5f5f5f5f	32	intel	pslld mmx0, 0x11
0f72f011|223344556677885f5f5f5f5f	32	plan9	PSLLD $0x11, M0
0f72f011|223344556677885f5f5f5f5f	64	gnu	pslld $0x11,%mm0
0f72f011|223344556677885f5f5f5f5f	64	intel	pslld mmx0, 0x11
0f72f011|223344556677885f5f5f5f5f	64	plan9	PSLLD $0x11, M0
0f7300|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f73d011|223344556677885f5f5f5f5f	32	intel	psrlq mmx0, 0x11
0f73d011|223344556677885f5f5f5f5f	32	plan9	PSRLQ $0x11, M0
0f73d011|223344556677885f5f5f5f5f	64	gnu	psrlq $0x11,%mm0
0f73d011|223344556677885f5f5f5f5f	64	intel	psrlq mmx0, 0x11
0f73d011|223344556677885f5f5f5f5f	64	plan9	PSRLQ $0x11, M0
0f73f011|223344556677885f5f5f5f5f	32	intel	psllq mmx0, 0x11
0f73f011|223344556677885f5f5f5f5f	32	plan9	PSLLQ $0x11, M0
0f73f011|223344556677885f5f5f5f5f	64	gnu	psllq $0x11,%mm0
0f73f011|223344556677885f5f5f5f5f	64	intel	psllq mmx0, 0x11
0f73f011|223344556677885f5f5f5f5f	64	plan9	PSLLQ $0x11, M0
0f7411|223344556677885f5f5f5f5f5f	32	intel	pcmpeqb mmx2, qword ptr [ecx]
0f7411|223344556677885f5f5f5f5f5f	32	plan9	PCMPEQB 0(CX), M2
0f7411|223344556677885f5f5f5f5f5f	64	gnu	pcmpeqb (%rcx),%mm2
0f7411|223344556677885f5f5f5f5f5f	64	intel	pcmpeqb mmx2, qword ptr [rcx]
0f7411|223344556677885f5f5f5f5f5f	64	plan9	PCMPEQB 0(CX), M2
0f7511|223344556677885f5f5f5f5f5f	32	intel	pcmpeqw mmx2, qword ptr [ecx]
0f7511|223344556677885f5f5f5f5f5f	32	plan9	PCMPEQW 0(CX), M2
0f7511|223344556677885f5f5f5f5f5f	64	gnu	pcmpeqw (%rcx),%mm2
0f7511|223344556677885f5f5f5f5f5f	64	intel	pcmpeqw mmx2, qword ptr [rcx]
0f7511|223344556677885f5f5f5f5f5f	64	plan9	PCMPEQW 0(CX), M2
0f7611|223344556677885f5f5f5f5f5f	32	intel	pcmpeqd mmx2, qword ptr [ecx]
0f7611|223344556677885f5f5f5f5f5f	32	plan9	PCMPEQD 0(CX), M2
0f7611|223344556677885f5f5f5f5f5f	64	gnu	pcmpeqd (%rcx),%mm2
0f7611|223344556677885f5f5f5f5f5f	64	intel	pcmpeqd mmx2, qword ptr [rcx]
0f7611|223344556677885f5f5f5f5f5f	64	plan9	PCMPEQD 0(CX), M2
0f77|11223344556677885f5f5f5f5f5f	32	intel	emms
0f77|11223344556677885f5f5f5f5f5f	32	plan9	EMMS
0f77|11223344556677885f5f5f5f5f5f	64	gnu	emms
0f77|11223344556677885f5f5f5f5f5f	64	intel	emms
0f77|11223344556677885f5f5f5f5f5f	64	plan9	EMMS
0f7c|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7e11|223344556677885f5f5f5f5f5f	32	intel	movd dword ptr [ecx], mmx2
0f7e11|223344556677885f5f5f5f5f5f	32	plan9	MOVD M2, 0(CX)
0f7e11|223344556677885f5f5f5f5f5f	64	gnu	movd %mm2,(%rcx)
0f7e11|223344556677885f5f5f5f5f5f	64	intel	movd dword ptr [rcx], mmx2
0f7e11|223344556677885f5f5f5f5f5f	64	plan9	MOVD M2, 0(CX)
0f7f11|223344556677885f5f5f5f5f5f	32	intel	movq qword ptr [ecx], mmx2
0f7f11|223344556677885f5f5f5f5f5f	32	plan9	MOVQ M2, 0(CX)
0f7f11|223344556677885f5f5f5f5f5f	64	gnu	movq %mm2,(%rcx)
0f7f11|223344556677885f5f5f5f5f5f	64	intel	movq qword ptr [rcx], mmx2
0f7f11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ M2, 0(CX)
0f8011223344|556677885f5f5f5f5f5f	32	intel	jo .+0x44332211
0f8011223344|556677885f5f5f5f5f5f	32	plan9	JO .+1144201745
0f8011223344|556677885f5f5f5f5f5f	64	gnu	jo .+0x44332211
0f8011223344|556677885f5f5f5f5f5f	64	intel	jo .+0x44332211
0f8011223344|556677885f5f5f5f5f5f	64	plan9	JO .+1144201745
0f8111223344|556677885f5f5f5f5f5f	32	intel	jno .+0x44332211
0f8111223344|556677885f5f5f5f5f5f	32	plan9	JNO .+1144201745
0f8111223344|556677885f5f5f5f5f5f	64	gnu	jno .+0x44332211
0f8111223344|556677885f5f5f5f5f5f	64	intel	jno .+0x44332211
0f8111223344|556677885f5f5f5f5f5f	64	plan9	JNO .+1144201745
0f8211223344|556677885f5f5f5f5f5f	32	intel	jb .+0x44332211
0f8211223344|556677885f5f5f5f5f5f	32	plan9	JB .+1144201745
0f8211223344|556677885f5f5f5f5f5f	64	gnu	jb .+0x44332211
0f8211223344|556677885f5f5f5f5f5f	64	intel	jb .+0x44332211
0f8211223344|556677885f5f5f5f5f5f	64	plan9	JB .+1144201745
0f8311223344|556677885f5f5f5f5f5f	32	intel	jnb .+0x44332211
0f8311223344|556677885f5f5f5f5f5f	32	plan9	JAE .+1144201745
0f8311223344|556677885f5f5f5f5f5f	64	gnu	jae .+0x44332211
0f8311223344|556677885f5f5f5f5f5f	64	intel	jnb .+0x44332211
0f8311223344|556677885f5f5f5f5f5f	64	plan9	JAE .+1144201745
0f8411223344|556677885f5f5f5f5f5f	32	intel	jz .+0x44332211
0f8411223344|556677885f5f5f5f5f5f	32	plan9	JE .+1144201745
0f8411223344|556677885f5f5f5f5f5f	64	gnu	je .+0x44332211
0f8411223344|556677885f5f5f5f5f5f	64	intel	jz .+0x44332211
0f8411223344|556677885f5f5f5f5f5f	64	plan9	JE .+1144201745
0f8511223344|556677885f5f5f5f5f5f	32	intel	jnz .+0x44332211
0f8511223344|556677885f5f5f5f5f5f	32	plan9	JNE .+1144201745
0f8511223344|556677885f5f5f5f5f5f	64	gnu	jne .+0x44332211
0f8511223344|556677885f5f5f5f5f5f	64	intel	jnz .+0x44332211
0f8511223344|556677885f5f5f5f5f5f	64	plan9	JNE .+1144201745
0f8611223344|556677885f5f5f5f5f5f	32	intel	jbe .+0x44332211
0f8611223344|556677885f5f5f5f5f5f	32	plan9	JBE .+1144201745
0f8611223344|556677885f5f5f5f5f5f	64	gnu	jbe .+0x44332211
0f8611223344|556677885f5f5f5f5f5f	64	intel	jbe .+0x44332211
0f8611223344|556677885f5f5f5f5f5f	64	plan9	JBE .+1144201745
0f8711223344|556677885f5f5f5f5f5f	32	intel	jnbe .+0x44332211
0f8711223344|556677885f5f5f5f5f5f	32	plan9	JA .+1144201745
0f8711223344|556677885f5f5f5f5f5f	64	gnu	ja .+0x44332211
0f8711223344|556677885f5f5f5f5f5f	64	intel	jnbe .+0x44332211
0f8711223344|556677885f5f5f5f5f5f	64	plan9	JA .+1144201745
0f8811223344|556677885f5f5f5f5f5f	32	intel	js .+0x44332211
0f8811223344|556677885f5f5f5f5f5f	32	plan9	JS .+1144201745
0f8811223344|556677885f5f5f5f5f5f	64	gnu	js .+0x44332211
0f8811223344|556677885f5f5f5f5f5f	64	intel	js .+0x44332211
0f8811223344|556677885f5f5f5f5f5f	64	plan9	JS .+1144201745
0f8911223344|556677885f5f5f5f5f5f	32	intel	jns .+0x44332211
0f8911223344|556677885f5f5f5f5f5f	32	plan9	JNS .+1144201745
0f8911223344|556677885f5f5f5f5f5f	64	gnu	jns .+0x44332211
0f8911223344|556677885f5f5f5f5f5f	64	intel	jns .+0x44332211
0f8911223344|556677885f5f5f5f5f5f	64	plan9	JNS .+1144201745
0f8a11223344|556677885f5f5f5f5f5f	32	intel	jp .+0x44332211
0f8a11223344|556677885f5f5f5f5f5f	32	plan9	JP .+1144201745
0f8a11223344|556677885f5f5f5f5f5f	64	gnu	jp .+0x44332211
0f8a11223344|556677885f5f5f5f5f5f	64	intel	jp .+0x44332211
0f8a11223344|556677885f5f5f5f5f5f	64	plan9	JP .+1144201745
0f8b11223344|556677885f5f5f5f5f5f	32	intel	jnp .+0x44332211
0f8b11223344|556677885f5f5f5f5f5f	32	plan9	JNP .+1144201745
0f8b11223344|556677885f5f5f5f5f5f	64	gnu	jnp .+0x44332211
0f8b11223344|556677885f5f5f5f5f5f	64	intel	jnp .+0x44332211
0f8b11223344|556677885f5f5f5f5f5f	64	plan9	JNP .+1144201745
0f8c11223344|556677885f5f5f5f5f5f	32	intel	jl .+0x44332211
0f8c11223344|556677885f5f5f5f5f5f	32	plan9	JL .+1144201745
0f8c11223344|556677885f5f5f5f5f5f	64	gnu	jl .+0x44332211
0f8c11223344|556677885f5f5f5f5f5f	64	intel	jl .+0x44332211
0f8c11223344|556677885f5f5f5f5f5f	64	plan9	JL .+1144201745
0f8d11223344|556677885f5f5f5f5f5f	32	intel	jnl .+0x44332211
0f8d11223344|556677885f5f5f5f5f5f	32	plan9	JGE .+1144201745
0f8d11223344|556677885f5f5f5f5f5f	64	gnu	jge .+0x44332211
0f8d11223344|556677885f5f5f5f5f5f	64	intel	jnl .+0x44332211
0f8d11223344|556677885f5f5f5f5f5f	64	plan9	JGE .+1144201745
0f8e11223344|556677885f5f5f5f5f5f	32	intel	jle .+0x44332211
0f8e11223344|556677885f5f5f5f5f5f	32	plan9	JLE .+1144201745
0f8e11223344|556677885f5f5f5f5f5f	64	gnu	jle .+0x44332211
0f8e11223344|556677885f5f5f5f5f5f	64	intel	jle .+0x44332211
0f8e11223344|556677885f5f5f5f5f5f	64	plan9	JLE .+1144201745
0f8f11223344|556677885f5f5f5f5f5f	32	intel	jnle .+0x44332211
0f8f11223344|556677885f5f5f5f5f5f	32	plan9	JG .+1144201745
0f8f11223344|556677885f5f5f5f5f5f	64	gnu	jg .+0x44332211
0f8f11223344|556677885f5f5f5f5f5f	64	intel	jnle .+0x44332211
0f8f11223344|556677885f5f5f5f5f5f	64	plan9	JG .+1144201745
0f9011|223344556677885f5f5f5f5f5f	32	intel	seto byte ptr [ecx]
0f9011|223344556677885f5f5f5f5f5f	32	plan9	SETO 0(CX)
0f9011|223344556677885f5f5f5f5f5f	64	gnu	seto (%rcx)
0f9011|223344556677885f5f5f5f5f5f	64	intel	seto byte ptr [rcx]
0f9011|223344556677885f5f5f5f5f5f	64	plan9	SETO 0(CX)
0f9111|223344556677885f5f5f5f5f5f	32	intel	setno byte ptr [ecx]
0f9111|223344556677885f5f5f5f5f5f	32	plan9	SETNO 0(CX)
0f9111|223344556677885f5f5f5f5f5f	64	gnu	setno (%rcx)
0f9111|223344556677885f5f5f5f5f5f	64	intel	setno byte ptr [rcx]
0f9111|223344556677885f5f5f5f5f5f	64	plan9	SETNO 0(CX)
0f9211|223344556677885f5f5f5f5f5f	32	intel	setb byte ptr [ecx]
0f9211|223344556677885f5f5f5f5f5f	32	plan9	SETB 0(CX)
0f9211|223344556677885f5f5f5f5f5f	64	gnu	setb (%rcx)
0f9211|223344556677885f5f5f5f5f5f	64	intel	setb byte ptr [rcx]
0f9211|223344556677885f5f5f5f5f5f	64	plan9	SETB 0(CX)
0f9311|223344556677885f5f5f5f5f5f	32	intel	setnb byte ptr [ecx]
0f9311|223344556677885f5f5f5f5f5f	32	plan9	SETAE 0(CX)
0f9311|223344556677885f5f5f5f5f5f	64	gnu	setae (%rcx)
0f9311|223344556677885f5f5f5f5f5f	64	intel	setnb byte ptr [rcx]
0f9311|223344556677885f5f5f5f5f5f	64	plan9	SETAE 0(CX)
0f9411|223344556677885f5f5f5f5f5f	32	intel	setz byte ptr [ecx]
0f9411|223344556677885f5f5f5f5f5f	32	plan9	SETE 0(CX)
0f9411|223344556677885f5f5f5f5f5f	64	gnu	sete (%rcx)
0f9411|223344556677885f5f5f5f5f5f	64	intel	setz byte ptr [rcx]
0f9411|223344556677885f5f5f5f5f5f	64	plan9	SETE 0(CX)
0f9511|223344556677885f5f5f5f5f5f	32	intel	setnz byte ptr [ecx]
0f9511|223344556677885f5f5f5f5f5f	32	plan9	SETNE 0(CX)
0f9511|223344556677885f5f5f5f5f5f	64	gnu	setne (%rcx)
0f9511|223344556677885f5f5f5f5f5f	64	intel	setnz byte ptr [rcx]
0f9511|223344556677885f5f5f5f5f5f	64	plan9	SETNE 0(CX)
0f9611|223344556677885f5f5f5f5f5f	32	intel	setbe byte ptr [ecx]
0f9611|223344556677885f5f5f5f5f5f	32	plan9	SETBE 0(CX)
0f9611|223344556677885f5f5f5f5f5f	64	gnu	setbe (%rcx)
0f9611|223344556677885f5f5f5f5f5f	64	intel	setbe byte ptr [rcx]
0f9611|223344556677885f5f5f5f5f5f	64	plan9	SETBE 0(CX)
0f9711|223344556677885f5f5f5f5f5f	32	intel	setnbe byte ptr [ecx]
0f9711|223344556677885f5f5f5f5f5f	32	plan9	SETA 0(CX)
0f9711|223344556677885f5f5f5f5f5f	64	gnu	seta (%rcx)
0f9711|223344556677885f5f5f5f5f5f	64	intel	setnbe byte ptr [rcx]
0f9711|223344556677885f5f5f5f5f5f	64	plan9	SETA 0(CX)
0f9811|223344556677885f5f5f5f5f5f	32	intel	sets byte ptr [ecx]
0f9811|223344556677885f5f5f5f5f5f	32	plan9	SETS 0(CX)
0f9811|223344556677885f5f5f5f5f5f	64	gnu	sets (%rcx)
0f9811|223344556677885f5f5f5f5f5f	64	intel	sets byte ptr [rcx]
0f9811|223344556677885f5f5f5f5f5f	64	plan9	SETS 0(CX)
0f9911|223344556677885f5f5f5f5f5f	32	intel	setns byte ptr [ecx]
0f9911|223344556677885f5f5f5f5f5f	32	plan9	SETNS 0(CX)
0f9911|223344556677885f5f5f5f5f5f	64	gnu	setns (%rcx)
0f9911|223344556677885f5f5f5f5f5f	64	intel	setns byte ptr [rcx]
0f9911|223344556677885f5f5f5f5f5f	64	plan9	SETNS 0(CX)
0f9a11|223344556677885f5f5f5f5f5f	32	intel	setp byte ptr [ecx]
0f9a11|223344556677885f5f5f5f5f5f	32	plan9	SETP 0(CX)
0f9a11|223344556677885f5f5f5f5f5f	64	gnu	setp (%rcx)
0f9a11|223344556677885f5f5f5f5f5f	64	intel	setp byte ptr [rcx]
0f9a11|223344556677885f5f5f5f5f5f	64	plan9	SETP 0(CX)
0f9b11|223344556677885f5f5f5f5f5f	32	intel	setnp byte ptr [ecx]
0f9b11|223344556677885f5f5f5f5f5f	32	plan9	SETNP 0(CX)
0f9b11|223344556677885f5f5f5f5f5f	64	gnu	setnp (%rcx)
0f9b11|223344556677885f5f5f5f5f5f	64	intel	setnp byte ptr [rcx]
0f9b11|223344556677885f5f5f5f5f5f	64	plan9	SETNP 0(CX)
0f9c11|223344556677885f5f5f5f5f5f	32	intel	setl byte ptr [ecx]
0f9c11|223344556677885f5f5f5f5f5f	32	plan9	SETL 0(CX)
0f9c11|223344556677885f5f5f5f5f5f	64	gnu	setl (%rcx)
0f9c11|223344556677885f5f5f5f5f5f	64	intel	setl byte ptr [rcx]
0f9c11|223344556677885f5f5f5f5f5f	64	plan9	SETL 0(CX)
0f9d11|223344556677885f5f5f5f5f5f	32	intel	setnl byte ptr [ecx]
0f9d11|223344556677885f5f5f5f5f5f	32	plan9	SETGE 0(CX)
0f9d11|223344556677885f5f5f5f5f5f	64	gnu	setge (%rcx)
0f9d11|223344556677885f5f5f5f5f5f	64	intel	setnl byte ptr [rcx]
0f9d11|223344556677885f5f5f5f5f5f	64	plan9	SETGE 0(CX)
0f9e11|223344556677885f5f5f5f5f5f	32	intel	setle byte ptr [ecx]
0f9e11|223344556677885f5f5f5f5f5f	32	plan9	SETLE 0(CX)
0f9e11|223344556677885f5f5f5f5f5f	64	gnu	setle (%rcx)
0f9e11|223344556677885f5f5f5f5f5f	64	intel	setle byte ptr [rcx]
0f9e11|223344556677885f5f5f5f5f5f	64	plan9	SETLE 0(CX)
0f9f11|223344556677885f5f5f5f5f5f	32	intel	setnle byte ptr [ecx]
0f9f11|223344556677885f5f5f5f5f5f	32	plan9	SETG 0(CX)
0f9f11|223344556677885f5f5f5f5f5f	64	gnu	setg (%rcx)
0f9f11|223344556677885f5f5f5f5f5f	64	intel	setnle byte ptr [rcx]
0f9f11|223344556677885f5f5f5f5f5f	64	plan9	SETG 0(CX)
0fa0|11223344556677885f5f5f5f5f5f	32	intel	push fs
0fa0|11223344556677885f5f5f5f5f5f	32	plan9	PUSHL FS
0fa0|11223344556677885f5f5f5f5f5f	64	gnu	pushq %fs
0fa0|11223344556677885f5f5f5f5f5f	64	intel	push fs
0fa0|11223344556677885f5f5f5f5f5f	64	plan9	PUSHL FS
0fa1|11223344556677885f5f5f5f5f5f	32	intel	pop fs
0fa1|11223344556677885f5f5f5f5f5f	32	plan9	POPL FS
0fa1|11223344556677885f5f5f5f5f5f	64	gnu	popq %fs
0fa1|11223344556677885f5f5f5f5f5f	64	intel	pop fs
0fa1|11223344556677885f5f5f5f5f5f	64	plan9	POPL FS
0fa2|11223344556677885f5f5f5f5f5f	32	intel	cpuid
0fa2|11223344556677885f5f5f5f5f5f	32	plan9	CPUID
0fa2|11223344556677885f5f5f5f5f5f	64	gnu	cpuid
0fa2|11223344556677885f5f5f5f5f5f	64	intel	cpuid
0fa2|11223344556677885f5f5f5f5f5f	64	plan9	CPUID
0fa311|223344556677885f5f5f5f5f5f	32	intel	bt dword ptr [ecx], edx
0fa311|223344556677885f5f5f5f5f5f	32	plan9	BTL DX, 0(CX)
0fa311|223344556677885f5f5f5f5f5f	64	gnu	bt %edx,(%rcx)
0fa311|223344556677885f5f5f5f5f5f	64	intel	bt dword ptr [rcx], edx
0fa311|223344556677885f5f5f5f5f5f	64	plan9	BTL DX, 0(CX)
0fa41122|3344556677885f5f5f5f5f5f	32	intel	shld dword ptr [ecx], edx, 0x22
0fa41122|3344556677885f5f5f5f5f5f	32	plan9	SHLDL $0x22, DX, 0(CX)
0fa41122|3344556677885f5f5f5f5f5f	64	gnu	shld $0x22,%edx,(%rcx)
0fa41122|3344556677885f5f5f5f5f5f	64	intel	shld dword ptr [rcx], edx, 0x22
0fa41122|3344556677885f5f5f5f5f5f	64	plan9	SHLDL $0x22, DX, 0(CX)
0fa511|223344556677885f5f5f5f5f5f	32	intel	shld dword ptr [ecx], edx, cl
0fa511|223344556677885f5f5f5f5f5f	32	plan9	SHLDL CL, DX, 0(CX)
0fa511|223344556677885f5f5f5f5f5f	64	gnu	shld %cl,%edx,(%rcx)
0fa511|223344556677885f5f5f5f5f5f	64	intel	shld dword ptr [rcx], edx, cl
0fa511|223344556677885f5f5f5f5f5f	64	plan9	SHLDL CL, DX, 0(CX)
0fa8|11223344556677885f5f5f5f5f5f	32	intel	push gs
0fa8|11223344556677885f5f5f5f5f5f	32	plan9	PUSHL GS
0fa8|11223344556677885f5f5f5f5f5f	64	gnu	pushq %gs
0fa8|11223344556677885f5f5f5f5f5f	64	intel	push gs
0fa8|11223344556677885f5f5f5f5f5f	64	plan9	PUSHL GS
0fa9|11223344556677885f5f5f5f5f5f	32	intel	pop gs
0fa9|11223344556677885f5f5f5f5f5f	32	plan9	POPL GS
0fa9|11223344556677885f5f5f5f5f5f	64	gnu	popq %gs
0fa9|11223344556677885f5f5f5f5f5f	64	intel	pop gs
0fa9|11223344556677885f5f5f5f5f5f	64	plan9	POPL GS
0faa|11223344556677885f5f5f5f5f5f	32	intel	rsm
0faa|11223344556677885f5f5f5f5f5f	32	plan9	RSM
0faa|11223344556677885f5f5f5f5f5f	64	gnu	rsm
0faa|11223344556677885f5f5f5f5f5f	64	intel	rsm
0faa|11223344556677885f5f5f5f5f5f	64	plan9	RSM
0fab11|223344556677885f5f5f5f5f5f	32	intel	bts dword ptr [ecx], edx
0fab11|223344556677885f5f5f5f5f5f	32	plan9	BTSL DX, 0(CX)
0fab11|223344556677885f5f5f5f5f5f	64	gnu	bts %edx,(%rcx)
0fab11|223344556677885f5f5f5f5f5f	64	intel	bts dword ptr [rcx], edx
0fab11|223344556677885f5f5f5f5f5f	64	plan9	BTSL DX, 0(CX)
0fac1122|3344556677885f5f5f5f5f5f	32	intel	shrd dword ptr [ecx], edx, 0x22
0fac1122|3344556677885f5f5f5f5f5f	32	plan9	SHRDL $0x22, DX, 0(CX)
0fac1122|3344556677885f5f5f5f5f5f	64	gnu	shrd $0x22,%edx,(%rcx)
0fac1122|3344556677885f5f5f5f5f5f	64	intel	shrd dword ptr [rcx], edx, 0x22
0fac1122|3344556677885f5f5f5f5f5f	64	plan9	SHRDL $0x22, DX, 0(CX)
0fad11|223344556677885f5f5f5f5f5f	32	intel	shrd dword ptr [ecx], edx, cl
0fad11|223344556677885f5f5f5f5f5f	32	plan9	SHRDL CL, DX, 0(CX)
0fad11|223344556677885f5f5f5f5f5f	64	gnu	shrd %cl,%edx,(%rcx)
0fad11|223344556677885f5f5f5f5f5f	64	intel	shrd dword ptr [rcx], edx, cl
0fad11|223344556677885f5f5f5f5f5f	64	plan9	SHRDL CL, DX, 0(CX)
0fae00|11223344556677885f5f5f5f5f	32	intel	fxsave ptr [eax]
0fae00|11223344556677885f5f5f5f5f	32	plan9	FXSAVE 0(AX)
0fae00|11223344556677885f5f5f5f5f	64	gnu	fxsave (%rax)
0fae00|11223344556677885f5f5f5f5f	64	intel	fxsave ptr [rax]
0fae00|11223344556677885f5f5f5f5f	64	plan9	FXSAVE 0(AX)
0fae08|11223344556677885f5f5f5f5f	32	intel	fxrstor ptr [eax]
0fae08|11223344556677885f5f5f5f5f	32	plan9	FXRSTOR 0(AX)
0fae08|11223344556677885f5f5f5f5f	64	gnu	fxrstor (%rax)
0fae08|11223344556677885f5f5f5f5f	64	intel	fxrstor ptr [rax]
0fae08|11223344556677885f5f5f5f5f	64	plan9	FXRSTOR 0(AX)
0fae11|223344556677885f5f5f5f5f5f	32	intel	ldmxcsr dword ptr [ecx]
0fae11|223344556677885f5f5f5f5f5f	32	plan9	LDMXCSR 0(CX)
0fae11|223344556677885f5f5f5f5f5f	64	gnu	ldmxcsr (%rcx)
0fae11|223344556677885f5f5f5f5f5f	64	intel	ldmxcsr dword ptr [rcx]
0fae11|223344556677885f5f5f5f5f5f	64	plan9	LDMXCSR 0(CX)
0fae18|11223344556677885f5f5f5f5f	32	intel	stmxcsr dword ptr [eax]
0fae18|11223344556677885f5f5f5f5f	32	plan9	STMXCSR 0(AX)
0fae18|11223344556677885f5f5f5f5f	64	gnu	stmxcsr (%rax)
0fae18|11223344556677885f5f5f5f5f	64	intel	stmxcsr dword ptr [rax]
0fae18|11223344556677885f5f5f5f5f	64	plan9	STMXCSR 0(AX)
0fae20|11223344556677885f5f5f5f5f	32	intel	xsave ptr [eax]
0fae20|11223344556677885f5f5f5f5f	32	plan9	XSAVE 0(AX)
0fae20|11223344556677885f5f5f5f5f	64	gnu	xsave (%rax)
0fae20|11223344556677885f5f5f5f5f	64	intel	xsave ptr [rax]
0fae20|11223344556677885f5f5f5f5f	64	plan9	XSAVE 0(AX)
0fae28|11223344556677885f5f5f5f5f	32	intel	xrstor ptr [eax]
0fae28|11223344556677885f5f5f5f5f	32	plan9	XRSTOR 0(AX)
0fae28|11223344556677885f5f5f5f5f	64	gnu	xrstor (%rax)
0fae28|11223344556677885f5f5f5f5f	64	intel	xrstor ptr [rax]
0fae28|11223344556677885f5f5f5f5f	64	plan9	XRSTOR 0(AX)
0fae30|11223344556677885f5f5f5f5f	32	intel	xsaveopt ptr [eax]
0fae30|11223344556677885f5f5f5f5f	32	plan9	XSAVEOPT 0(AX)
0fae30|11223344556677885f5f5f5f5f	64	gnu	xsaveopt (%rax)
0fae30|11223344556677885f5f5f5f5f	64	intel	xsaveopt ptr [rax]
0fae30|11223344556677885f5f5f5f5f	64	plan9	XSAVEOPT 0(AX)
0fae38|11223344556677885f5f5f5f5f	32	intel	clflush zmmword ptr [eax]
0fae38|11223344556677885f5f5f5f5f	32	plan9	CLFLUSH 0(AX)
0fae38|11223344556677885f5f5f5f5f	64	gnu	clflush (%rax)
0fae38|11223344556677885f5f5f5f5f	64	intel	clflush zmmword ptr [rax]
0fae38|11223344556677885f5f5f5f5f	64	plan9	CLFLUSH 0(AX)
0faee8|11223344556677885f5f5f5f5f	32	intel	lfence
0faee8|11223344556677885f5f5f5f5f	32	plan9	LFENCE
0faee8|11223344556677885f5f5f5f5f	64	gnu	lfence
0faee8|11223344556677885f5f5f5f5f	64	intel	lfence
0faee8|11223344556677885f5f5f5f5f	64	plan9	LFENCE
0faef0|11223344556677885f5f5f5f5f	32	intel	mfence
0faef0|11223344556677885f5f5f5f5f	32	plan9	MFENCE
0faef0|11223344556677885f5f5f5f5f	64	gnu	mfence
0faef0|11223344556677885f5f5f5f5f	64	intel	mfence
0faef0|11223344556677885f5f5f5f5f	64	plan9	MFENCE
0faef8|11223344556677885f5f5f5f5f	32	intel	sfence
0faef8|11223344556677885f5f5f5f5f	32	plan9	SFENCE
0faef8|11223344556677885f5f5f5f5f	64	gnu	sfence
0faef8|11223344556677885f5f5f5f5f	64	intel	sfence
0faef8|11223344556677885f5f5f5f5f	64	plan9	SFENCE
0faf11|223344556677885f5f5f5f5f5f	32	intel	imul edx, dword ptr [ecx]
0faf11|223344556677885f5f5f5f5f5f	32	plan9	IMULL 0(CX), DX
0faf11|223344556677885f5f5f5f5f5f	64	gnu	imul (%rcx),%edx
0faf11|223344556677885f5f5f5f5f5f	64	intel	imul edx, dword ptr [rcx]
0faf11|223344556677885f5f5f5f5f5f	64	plan9	IMULL 0(CX), DX
0fb011|223344556677885f5f5f5f5f5f	32	intel	cmpxchg byte ptr [ecx], dl
0fb011|223344556677885f5f5f5f5f5f	32	plan9	CMPXCHGL DL, 0(CX)
0fb011|223344556677885f5f5f5f5f5f	64	gnu	cmpxchg %dl,(%rcx)
0fb011|223344556677885f5f5f5f5f5f	64	intel	cmpxchg byte ptr [rcx], dl
0fb011|223344556677885f5f5f5f5f5f	64	plan9	CMPXCHGL DL, 0(CX)
0fb111|223344556677885f5f5f5f5f5f	32	intel	cmpxchg dword ptr [ecx], edx
0fb111|223344556677885f5f5f5f5f5f	32	plan9	CMPXCHGL DX, 0(CX)
0fb111|223344556677885f5f5f5f5f5f	64	gnu	cmpxchg %edx,(%rcx)
0fb111|223344556677885f5f5f5f5f5f	64	intel	cmpxchg dword ptr [rcx], edx
0fb111|223344556677885f5f5f5f5f5f	64	plan9	CMPXCHGL DX, 0(CX)
0fb211|223344556677885f5f5f5f5f5f	32	intel	lss edx, ptr [ecx]
0fb211|223344556677885f5f5f5f5f5f	32	plan9	LSS 0(CX), DX
0fb211|223344556677885f5f5f5f5f5f	64	gnu	lss (%rcx),%edx
0fb211|223344556677885f5f5f5f5f5f	64	intel	lss edx, ptr [rcx]
0fb211|223344556677885f5f5f5f5f5f	64	plan9	LSS 0(CX), DX
0fb311|223344556677885f5f5f5f5f5f	32	intel	btr dword ptr [ecx], edx
0fb311|223344556677885f5f5f5f5f5f	32	plan9	BTRL DX, 0(CX)
0fb311|223344556677885f5f5f5f5f5f	64	gnu	btr %edx,(%rcx)
0fb311|223344556677885f5f5f5f5f5f	64	intel	btr dword ptr [rcx], edx
0fb311|223344556677885f5f5f5f5f5f	64	plan9	BTRL DX, 0(CX)
0fb411|223344556677885f5f5f5f5f5f	32	intel	lfs edx, ptr [ecx]
0fb411|223344556677885f5f5f5f5f5f	32	plan9	LFS 0(CX), DX
0fb411|223344556677885f5f5f5f5f5f	64	gnu	lfs (%rcx),%edx
0fb411|223344556677885f5f5f5f5f5f	64	intel	lfs edx, ptr [rcx]
0fb411|223344556677885f5f5f5f5f5f	64	plan9	LFS 0(CX), DX
0fb511|223344556677885f5f5f5f5f5f	32	intel	lgs edx, ptr [ecx]
0fb511|223344556677885f5f5f5f5f5f	32	plan9	LGS 0(CX), DX
0fb511|223344556677885f5f5f5f5f5f	64	gnu	lgs (%rcx),%edx
0fb511|223344556677885f5f5f5f5f5f	64	intel	lgs edx, ptr [rcx]
0fb511|223344556677885f5f5f5f5f5f	64	plan9	LGS 0(CX), DX
0fb611|223344556677885f5f5f5f5f5f	32	intel	movzx edx, byte ptr [ecx]
0fb611|223344556677885f5f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
0fb611|223344556677885f5f5f5f5f5f	64	gnu	movzbl (%rcx),%edx
0fb611|223344556677885f5f5f5f5f5f	64	intel	movzx edx, byte ptr [rcx]
0fb611|223344556677885f5f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
0fb711|223344556677885f5f5f5f5f5f	32	intel	movzx edx, word ptr [ecx]
0fb711|223344556677885f5f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
0fb711|223344556677885f5f5f5f5f5f	64	gnu	movzwl (%rcx),%edx
0fb711|223344556677885f5f5f5f5f5f	64	intel	movzx edx, word ptr [rcx]
0fb711|223344556677885f5f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
0fb8|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fb9|11223344556677885f5f5f5f5f5f	32	intel	ud1
0fb9|11223344556677885f5f5f5f5f5f	32	plan9	UD1
0fb9|11223344556677885f5f5f5f5f5f	64	gnu	ud1
0fb9|11223344556677885f5f5f5f5f5f	64	intel	ud1
0fb9|11223344556677885f5f5f5f5f5f	64	plan9	UD1
0fba11|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fba2011|223344556677885f5f5f5f5f	32	intel	bt dword ptr [eax], 0x11
0fba2011|223344556677885f5f5f5f5f	32	plan9	BTL $0x11, 0(AX)
0fba2011|223344556677885f5f5f5f5f	64	gnu	btl $0x11,(%rax)
0fba2011|223344556677885f5f5f5f5f	64	intel	bt dword ptr [rax], 0x11
0fba2011|223344556677885f5f5f5f5f	64	plan9	BTL $0x11, 0(AX)
0fba2811|223344556677885f5f5f5f5f	32	intel	bts dword ptr [eax], 0x11
0fba2811|223344556677885f5f5f5f5f	32	plan9	BTSL $0x11, 0(AX)
0fba2811|223344556677885f5f5f5f5f	64	gnu	btsl $0x11,(%rax)
0fba2811|223344556677885f5f5f5f5f	64	intel	bts dword ptr [rax], 0x11
0fba2811|223344556677885f5f5f5f5f	64	plan9	BTSL $0x11, 0(AX)
0fba3011|223344556677885f5f5f5f5f	32	intel	btr dword ptr [eax], 0x11
0fba3011|223344556677885f5f5f5f5f	32	plan9	BTRL $0x11, 0(AX)
0fba3011|223344556677885f5f5f5f5f	64	gnu	btrl $0x11,(%rax)
0fba3011|223344556677885f5f5f5f5f	64	intel	btr dword ptr [rax], 0x11
0fba3011|223344556677885f5f5f5f5f	64	plan9	BTRL $0x11, 0(AX)
0fba3811|223344556677885f5f5f5f5f	32	intel	btc dword ptr [eax], 0x11
0fba3811|223344556677885f5f5f5f5f	32	plan9	BTCL $0x11, 0(AX)
0fba3811|223344556677885f5f5f5f5f	64	gnu	btcl $0x11,(%rax)
0fba3811|223344556677885f5f5f5f5f	64	intel	btc dword ptr [rax], 0x11
0fba3811|223344556677885f5f5f5f5f	64	plan9	BTCL $0x11, 0(AX)
0fbb11|223344556677885f5f5f5f5f5f	32	intel	btc dword ptr [ecx], edx
0fbb11|223344556677885f5f5f5f5f5f	32	plan9	BTCL DX, 0(CX)
0fbb11|223344556677885f5f5f5f5f5f	64	gnu	btc %edx,(%rcx)
0fbb11|223344556677885f5f5f5f5f5f	64	intel	btc dword ptr [rcx], edx
0fbb11|223344556677885f5f5f5f5f5f	64	plan9	BTCL DX, 0(CX)
0fbc11|223344556677885f5f5f5f5f5f	32	intel	bsf edx, dword ptr [ecx]
0fbc11|223344556677885f5f5f5f5f5f	32	plan9	BSFL 0(CX), DX
0fbc11|223344556677885f5f5f5f5f5f	64	gnu	bsf (%rcx),%edx
0fbc11|223344556677885f5f5f5f5f5f	64	intel	bsf edx, dword ptr [rcx]
0fbc11|223344556677885f5f5f5f5f5f	64	plan9	BSFL 0(CX), DX
0fbd11|223344556677885f5f5f5f5f5f	32	intel	bsr edx, dword ptr [ecx]
0fbd11|223344556677885f5f5f5f5f5f	32	plan9	BSRL 0(CX), DX
0fbd11|223344556677885f5f5f5f5f5f	64	gnu	bsr (%rcx),%edx
0fbd11|223344556677885f5f5f5f5f5f	64	intel	bsr edx, dword ptr [rcx]
0fbd11|223344556677885f5f5f5f5f5f	64	plan9	BSRL 0(CX), DX
0fbe11|223344556677885f5f5f5f5f5f	32	intel	movsx edx, byte ptr [ecx]
0fbe11|223344556677885f5f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
0fbe11|223344556677885f5f5f5f5f5f	64	gnu	movsbl (%rcx),%edx
0fbe11|223344556677885f5f5f5f5f5f	64	intel	movsx edx, byte ptr [rcx]
0fbe11|223344556677885f5f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
0fbf11|223344556677885f5f5f5f5f5f	32	intel	movsx edx, word ptr [ecx]
0fbf11|223344556677885f5f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
0fbf11|223344556677885f5f5f5f5f5f	64	gnu	movswl (%rcx),%edx
0fbf11|223344556677885f5f5f5f5f5f	64	intel	movsx edx, word ptr [rcx]
0fbf11|223344556677885f5f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
0fc011|223344556677885f5f5f5f5f5f	32	intel	xadd byte ptr [ecx], dl
0fc011|223344556677885f5f5f5f5f5f	32	plan9	XADDL DL, 0(CX)
0fc011|223344556677885f5f5f5f5f5f	64	gnu	xadd %dl,(%rcx)
0fc011|223344556677885f5f5f5f5f5f	64	intel	xadd byte ptr [rcx], dl
0fc011|223344556677885f5f5f5f5f5f	64	plan9	XADDL DL, 0(CX)
0fc111|223344556677885f5f5f5f5f5f	32	intel	xadd dword ptr [ecx], edx
0fc111|223344556677885f5f5f5f5f5f	32	plan9	XADDL DX, 0(CX)
0fc111|223344556677885f5f5f5f5f5f	64	gnu	xadd %edx,(%rcx)
0fc111|223344556677885f5f5f5f5f5f	64	intel	xadd dword ptr [rcx], edx
0fc111|223344556677885f5f5f5f5f5f	64	plan9	XADDL DX, 0(CX)
0fc20000|11223344556677885f5f5f5f	32	intel	cmpps xmm0, xmmword ptr [eax], 0x0
0fc20000|11223344556677885f5f5f5f	32	plan9	CMPPS $0x0, 0(AX), X0
0fc20000|11223344556677885f5f5f5f	64	gnu	cmpeqps (%rax),%xmm0
0fc20000|11223344556677885f5f5f5f	64	intel	cmpps xmm0, xmmword ptr [rax], 0x0
0fc20000|11223344556677885f5f5f5f	64	plan9	CMPPS $0x0, 0(AX), X0
0fc311|223344556677885f5f5f5f5f5f	32	intel	movnti dword ptr [ecx], edx
0fc311|223344556677885f5f5f5f5f5f	32	plan9	MOVNTIL DX, 0(CX)
0fc311|223344556677885f5f5f5f5f5f	64	gnu	movnti %edx,(%rcx)
0fc311|223344556677885f5f5f5f5f5f	64	intel	movnti dword ptr [rcx], edx
0fc311|223344556677885f5f5f5f5f5f	64	plan9	MOVNTIL DX, 0(CX)
0fc41122|3344556677885f5f5f5f5f5f	32	intel	pinsrw mmx2, word ptr [ecx], 0x22
0fc41122|3344556677885f5f5f5f5f5f	32	plan9	PINSRW $0x22, 0(CX), M2
0fc41122|3344556677885f5f5f5f5f5f	64	gnu	pinsrw $0x22,(%rcx),%mm2
0fc41122|3344556677885f5f5f5f5f5f	64	intel	pinsrw mmx2, word ptr [rcx], 0x22
0fc41122|3344556677885f5f5f5f5f5f	64	plan9	PINSRW $0x22, 0(CX), M2
0fc51122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fc5c011|223344556677885f5f5f5f5f	32	intel	pextrw eax, mmx0, 0x11
0fc5c011|223344556677885f5f5f5f5f	32	plan9	PEXTRW $0x11, M0, AX
0fc5c011|223344556677885f5f5f5f5f	64	gnu	pextrw $0x11,%mm0,%eax
0fc5c011|223344556677885f5f5f5f5f	64	intel	pextrw eax, mmx0, 0x11
0fc5c011|223344556677885f5f5f5f5f	64	plan9	PEXTRW $0x11, M0, AX
0fc61122|3344556677885f5f5f5f5f5f	32	intel	shufps xmm2, xmmword ptr [ecx], 0x22
0fc61122|3344556677885f5f5f5f5f5f	32	plan9	SHUFPS $0x22, 0(CX), X2
0fc61122|3344556677885f5f5f5f5f5f	64	gnu	shufps $0x22,(%rcx),%xmm2
0fc61122|3344556677885f5f5f5f5f5f	64	intel	shufps xmm2, xmmword ptr [rcx], 0x22
0fc61122|3344556677885f5f5f5f5f5f	64	plan9	SHUFPS $0x22, 0(CX), X2
0fc708|11223344556677885f5f5f5f5f	32	intel	cmpxchg8b qword ptr [eax]
0fc708|11223344556677885f5f5f5f5f	32	plan9	CMPXCHG8B 0(AX)
0fc708|11223344556677885f5f5f5f5f	64	gnu	cmpxchg8b (%rax)
0fc708|11223344556677885f5f5f5f5f	64	intel	cmpxchg8b qword ptr [rax]
0fc708|11223344556677885f5f5f5f5f	64	plan9	CMPXCHG8B 0(AX)
0fc718|11223344556677885f5f5f5f5f	32	intel	xrstors ptr [eax]
0fc718|11223344556677885f5f5f5f5f	32	plan9	XRSTORS 0(AX)
0fc718|11223344556677885f5f5f5f5f	64	gnu	xrstors (%rax)
0fc718|11223344556677885f5f5f5f5f	64	intel	xrstors ptr [rax]
0fc718|11223344556677885f5f5f5f5f	64	plan9	XRSTORS 0(AX)
0fc720|11223344556677885f5f5f5f5f	32	intel	xsavec ptr [eax]
0fc720|11223344556677885f5f5f5f5f	32	plan9	XSAVEC 0(AX)
0fc720|11223344556677885f5f5f5f5f	64	gnu	xsavec (%rax)
0fc720|11223344556677885f5f5f5f5f	64	intel	xsavec ptr [rax]
0fc720|11223344556677885f5f5f5f5f	64	plan9	XSAVEC 0(AX)
0fc728|11223344556677885f5f5f5f5f	32	intel	xsaves ptr [eax]
0fc728|11223344556677885f5f5f5f5f	32	plan9	XSAVES 0(AX)
0fc728|11223344556677885f5f5f5f5f	64	gnu	xsaves (%rax)
0fc728|11223344556677885f5f5f5f5f	64	intel	xsaves ptr [rax]
0fc728|11223344556677885f5f5f5f5f	64	plan9	XSAVES 0(AX)
0fc730|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0fc7f0|11223344556677885f5f5f5f5f	32	intel	rdrand eax
0fc7f0|11223344556677885f5f5f5f5f	32	plan9	RDRAND AX
0fc7f0|11223344556677885f5f5f5f5f	64	gnu	rdrand %eax
0fc7f0|11223344556677885f5f5f5f5f	64	intel	rdrand eax
0fc7f0|11223344556677885f5f5f5f5f	64	plan9	RDRAND AX
0fc8|11223344556677885f5f5f5f5f5f	32	intel	bswap eax
0fc8|11223344556677885f5f5f5f5f5f	32	plan9	BSWAP AX
0fc8|11223344556677885f5f5f5f5f5f	64	gnu	bswap %eax
0fc8|11223344556677885f5f5f5f5f5f	64	intel	bswap eax
0fc8|11223344556677885f5f5f5f5f5f	64	plan9	BSWAP AX
0fd0|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fd111|223344556677885f5f5f5f5f5f	32	intel	psrlw mmx2, qword ptr [ecx]
0fd111|223344556677885f5f5f5f5f5f	32	plan9	PSRLW 0(CX), M2
0fd111|223344556677885f5f5f5f5f5f	64	gnu	psrlw (%rcx),%mm2
0fd111|223344556677885f5f5f5f5f5f	64	intel	psrlw mmx2, qword ptr [rcx]
0fd111|223344556677885f5f5f5f5f5f	64	plan9	PSRLW 0(CX), M2
0fd211|223344556677885f5f5f5f5f5f	32	intel	psrld mmx2, qword ptr [ecx]
0fd211|223344556677885f5f5f5f5f5f	32	plan9	PSRLD 0(CX), M2
0fd211|223344556677885f5f5f5f5f5f	64	gnu	psrld (%rcx),%mm2
0fd211|223344556677885f5f5f5f5f5f	64	intel	psrld mmx2, qword ptr [rcx]
0fd211|223344556677885f5f5f5f5f5f	64	plan9	PSRLD 0(CX), M2
0fd311|223344556677885f5f5f5f5f5f	32	intel	psrlq mmx2, qword ptr [ecx]
0fd311|223344556677885f5f5f5f5f5f	32	plan9	PSRLQ 0(CX), M2
0fd311|223344556677885f5f5f5f5f5f	64	gnu	psrlq (%rcx),%mm2
0fd311|223344556677885f5f5f5f5f5f	64	intel	psrlq mmx2, qword ptr [rcx]
0fd311|223344556677885f5f5f5f5f5f	64	plan9	PSRLQ 0(CX), M2
0fd411|223344556677885f5f5f5f5f5f	32	intel	paddq mmx2, qword ptr [ecx]
0fd411|223344556677885f5f5f5f5f5f	32	plan9	PADDQ 0(CX), M2
0fd411|223344556677885f5f5f5f5f5f	64	gnu	paddq (%rcx),%mm2
0fd411|223344556677885f5f5f5f5f5f	64	intel	paddq mmx2, qword ptr [rcx]
0fd411|223344556677885f5f5f5f5f5f	64	plan9	PADDQ 0(CX), M2
0fd511|223344556677885f5f5f5f5f5f	32	intel	pmullw mmx2, qword ptr [ecx]
0fd511|223344556677885f5f5f5f5f5f	32	plan9	PMULLW 0(CX), M2
0fd511|223344556677885f5f5f5f5f5f	64	gnu	pmullw (%rcx),%mm2
0fd511|223344556677885f5f5f5f5f5f	64	intel	pmullw mmx2, qword ptr [rcx]
0fd511|223344556677885f5f5f5f5f5f	64	plan9	PMULLW 0(CX), M2
0fd6|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fd7c0|11223344556677885f5f5f5f5f	32	intel	pmovmskb eax, mmx0
0fd7c0|11223344556677885f5f5f5f5f	32	plan9	PMOVMSKB M0, AX
0fd7c0|11223344556677885f5f5f5f5f	64	gnu	pmovmskb %mm0,%eax
0fd7c0|11223344556677885f5f5f5f5f	64	intel	pmovmskb eax, mmx0
0fd7c0|11223344556677885f5f5f5f5f	64	plan9	PMOVMSKB M0, AX
0fd811|223344556677885f5f5f5f5f5f	32	intel	psubusb mmx2, qword ptr [ecx]
0fd811|223344556677885f5f5f5f5f5f	32	plan9	PSUBUSB 0(CX), M2
0fd811|223344556677885f5f5f5f5f5f	64	gnu	psubusb (%rcx),%mm2
0fd811|223344556677885f5f5f5f5f5f	64	intel	psubusb mmx2, qword ptr [rcx]
0fd811|223344556677885f5f5f5f5f5f	64	plan9	PSUBUSB 0(CX), M2
0fd911|223344556677885f5f5f5f5f5f	32	intel	psubusw mmx2, qword ptr [ecx]
0fd911|223344556677885f5f5f5f5f5f	32	plan9	PSUBUSW 0(CX), M2
0fd911|223344556677885f5f5f5f5f5f	64	gnu	psubusw (%rcx),%mm2
0fd911|223344556677885f5f5f5f5f5f	64	intel	psubusw mmx2, qword ptr [rcx]
0fd911|223344556677885f5f5f5f5f5f	64	plan9	PSUBUSW 0(CX), M2
0fda11|223344556677885f5f5f5f5f5f	32	intel	pminub mmx2, qword ptr [ecx]
0fda11|223344556677885f5f5f5f5f5f	32	plan9	PMINUB 0(CX), M2
0fda11|223344556677885f5f5f5f5f5f	64	gnu	pminub (%rcx),%mm2
0fda11|223344556677885f5f5f5f5f5f	64	intel	pminub mmx2, qword ptr [rcx]
0fda11|223344556677885f5f5f5f5f5f	64	plan9	PMINUB 0(CX), M2
0fdb11|223344556677885f5f5f5f5f5f	32	intel	pand mmx2, qword ptr [ecx]
0fdb11|223344556677885f5f5f5f5f5f	32	plan9	PAND 0(CX), M2
0fdb11|223344556677885f5f5f5f5f5f	64	gnu	pand (%rcx),%mm2
0fdb11|223344556677885f5f5f5f5f5f	64	intel	pand mmx2, qword ptr [rcx]
0fdb11|223344556677885f5f5f5f5f5f	64	plan9	PAND 0(CX), M2
0fdc11|223344556677885f5f5f5f5f5f	32	intel	paddusb mmx2, qword ptr [ecx]
0fdc11|223344556677885f5f5f5f5f5f	32	plan9	PADDUSB 0(CX), M2
0fdc11|223344556677885f5f5f5f5f5f	64	gnu	paddusb (%rcx),%mm2
0fdc11|223344556677885f5f5f5f5f5f	64	intel	paddusb mmx2, qword ptr [rcx]
0fdc11|223344556677885f5f5f5f5f5f	64	plan9	PADDUSB 0(CX), M2
0fdd11|223344556677885f5f5f5f5f5f	32	intel	paddusw mmx2, qword ptr [ecx]
0fdd11|223344556677885f5f5f5f5f5f	32	plan9	PADDUSW 0(CX), M2
0fdd11|223344556677885f5f5f5f5f5f	64	gnu	paddusw (%rcx),%mm2
0fdd11|223344556677885f5f5f5f5f5f	64	intel	paddusw mmx2, qword ptr [rcx]
0fdd11|223344556677885f5f5f5f5f5f	64	plan9	PADDUSW 0(CX), M2
0fde11|223344556677885f5f5f5f5f5f	32	intel	pmaxub mmx2, qword ptr [ecx]
0fde11|223344556677885f5f5f5f5f5f	32	plan9	PMAXUB 0(CX), M2
0fde11|223344556677885f5f5f5f5f5f	64	gnu	pmaxub (%rcx),%mm2
0fde11|223344556677885f5f5f5f5f5f	64	intel	pmaxub mmx2, qword ptr [rcx]
0fde11|223344556677885f5f5f5f5f5f	64	plan9	PMAXUB 0(CX), M2
0fdf11|223344556677885f5f5f5f5f5f	32	intel	pandn mmx2, qword ptr [ecx]
0fdf11|223344556677885f5f5f5f5f5f	32	plan9	PANDN 0(CX), M2
0fdf11|223344556677885f5f5f5f5f5f	64	gnu	pandn (%rcx),%mm2
0fdf11|223344556677885f5f5f5f5f5f	64	intel	pandn mmx2, qword ptr [rcx]
0fdf11|223344556677885f5f5f5f5f5f	64	plan9	PANDN 0(CX), M2
0fe011|223344556677885f5f5f5f5f5f	32	intel	pavgb mmx2, qword ptr [ecx]
0fe011|223344556677885f5f5f5f5f5f	32	plan9	PAVGB 0(CX), M2
0fe011|223344556677885f5f5f5f5f5f	64	gnu	pavgb (%rcx),%mm2
0fe011|223344556677885f5f5f5f5f5f	64	intel	pavgb mmx2, qword ptr [rcx]
0fe011|223344556677885f5f5f5f5f5f	64	plan9	PAVGB 0(CX), M2
0fe111|223344556677885f5f5f5f5f5f	32	intel	psraw mmx2, qword ptr [ecx]
0fe111|223344556677885f5f5f5f5f5f	32	plan9	PSRAW 0(CX), M2
0fe111|223344556677885f5f5f5f5f5f	64	gnu	psraw (%rcx),%mm2
0fe111|223344556677885f5f5f5f5f5f	64	intel	psraw mmx2, qword ptr [rcx]
0fe111|223344556677885f5f5f5f5f5f	64	plan9	PSRAW 0(CX), M2
0fe211|223344556677885f5f5f5f5f5f	32	intel	psrad mmx2, qword ptr [ecx]
0fe211|223344556677885f5f5f5f5f5f	32	plan9	PSRAD 0(CX), M2
0fe211|223344556677885f5f5f5f5f5f	64	gnu	psrad (%rcx),%mm2
0fe211|223344556677885f5f5f5f5f5f	64	intel	psrad mmx2, qword ptr [rcx]
0fe211|223344556677885f5f5f5f5f5f	64	plan9	PSRAD 0(CX), M2
0fe311|223344556677885f5f5f5f5f5f	32	intel	pavgw mmx2, qword ptr [ecx]
0fe311|223344556677885f5f5f5f5f5f	32	plan9	PAVGW 0(CX), M2
0fe311|223344556677885f5f5f5f5f5f	64	gnu	pavgw (%rcx),%mm2
0fe311|223344556677885f5f5f5f5f5f	64	intel	pavgw mmx2, qword ptr [rcx]
0fe311|223344556677885f5f5f5f5f5f	64	plan9	PAVGW 0(CX), M2
0fe411|223344556677885f5f5f5f5f5f	32	intel	pmulhuw mmx2, qword ptr [ecx]
0fe411|223344556677885f5f5f5f5f5f	32	plan9	PMULHUW 0(CX), M2
0fe411|223344556677885f5f5f5f5f5f	64	gnu	pmulhuw (%rcx),%mm2
0fe411|223344556677885f5f5f5f5f5f	64	intel	pmulhuw mmx2, qword ptr [rcx]
0fe411|223344556677885f5f5f5f5f5f	64	plan9	PMULHUW 0(CX), M2
0fe511|223344556677885f5f5f5f5f5f	32	intel	pmulhw mmx2, qword ptr [ecx]
0fe511|223344556677885f5f5f5f5f5f	32	plan9	PMULHW 0(CX), M2
0fe511|223344556677885f5f5f5f5f5f	64	gnu	pmulhw (%rcx),%mm2
0fe511|223344556677885f5f5f5f5f5f	64	intel	pmulhw mmx2, qword ptr [rcx]
0fe511|223344556677885f5f5f5f5f5f	64	plan9	PMULHW 0(CX), M2
0fe6|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fe711|223344556677885f5f5f5f5f5f	32	intel	movntq qword ptr [ecx], mmx2
0fe711|223344556677885f5f5f5f5f5f	32	plan9	MOVNTQ M2, 0(CX)
0fe711|223344556677885f5f5f5f5f5f	64	gnu	movntq %mm2,(%rcx)
0fe711|223344556677885f5f5f5f5f5f	64	intel	movntq qword ptr [rcx], mmx2
0fe711|223344556677885f5f5f5f5f5f	64	plan9	MOVNTQ M2, 0(CX)
0fe811|223344556677885f5f5f5f5f5f	32	intel	psubsb mmx2, qword ptr [ecx]
0fe811|223344556677885f5f5f5f5f5f	32	plan9	PSUBSB 0(CX), M2
0fe811|223344556677885f5f5f5f5f5f	64	gnu	psubsb (%rcx),%mm2
0fe811|223344556677885f5f5f5f5f5f	64	intel	psubsb mmx2, qword ptr [rcx]
0fe811|223344556677885f5f5f5f5f5f	64	plan9	PSUBSB 0(CX), M2
0fe911|223344556677885f5f5f5f5f5f	32	intel	psubsw mmx2, qword ptr [ecx]
0fe911|223344556677885f5f5f5f5f5f	32	plan9	PSUBSW 0(CX), M2
0fe911|223344556677885f5f5f5f5f5f	64	gnu	psubsw (%rcx),%mm2
0fe911|223344556677885f5f5f5f5f5f	64	intel	psubsw mmx2, qword ptr [rcx]
0fe911|223344556677885f5f5f5f5f5f	64	plan9	PSUBSW 0(CX), M2
0fea11|223344556677885f5f5f5f5f5f	32	intel	pminsw mmx2, qword ptr [ecx]
0fea11|223344556677885f5f5f5f5f5f	32	plan9	PMINSW 0(CX), M2
0fea11|223344556677885f5f5f5f5f5f	64	gnu	pminsw (%rcx),%mm2
0fea11|223344556677885f5f5f5f5f5f	64	intel	pminsw mmx2, qword ptr [rcx]
0fea11|223344556677885f5f5f5f5f5f	64	plan9	PMINSW 0(CX), M2
0feb11|223344556677885f5f5f5f5f5f	32	intel	por mmx2, qword ptr [ecx]
0feb11|223344556677885f5f5f5f5f5f	32	plan9	POR 0(CX), M2
0feb11|223344556677885f5f5f5f5f5f	64	gnu	por (%rcx),%mm2
0feb11|223344556677885f5f5f5f5f5f	64	intel	por mmx2, qword ptr [rcx]
0feb11|223344556677885f5f5f5f5f5f	64	plan9	POR 0(CX), M2
0fec11|223344556677885f5f5f5f5f5f	32	intel	paddsb mmx2, qword ptr [ecx]
0fec11|223344556677885f5f5f5f5f5f	32	plan9	PADDSB 0(CX), M2
0fec11|223344556677885f5f5f5f5f5f	64	gnu	paddsb (%rcx),%mm2
0fec11|223344556677885f5f5f5f5f5f	64	intel	paddsb mmx2, qword ptr [rcx]
0fec11|223344556677885f5f5f5f5f5f	64	plan9	PADDSB 0(CX), M2
0fed11|223344556677885f5f5f5f5f5f	32	intel	paddsw mmx2, qword ptr [ecx]
0fed11|223344556677885f5f5f5f5f5f	32	plan9	PADDSW 0(CX), M2
0fed11|223344556677885f5f5f5f5f5f	64	gnu	paddsw (%rcx),%mm2
0fed11|223344556677885f5f5f5f5f5f	64	intel	paddsw mmx2, qword ptr [rcx]
0fed11|223344556677885f5f5f5f5f5f	64	plan9	PADDSW 0(CX), M2
0fee11|223344556677885f5f5f5f5f5f	32	intel	pmaxsw mmx2, qword ptr [ecx]
0fee11|223344556677885f5f5f5f5f5f	32	plan9	PMAXSW 0(CX), M2
0fee11|223344556677885f5f5f5f5f5f	64	gnu	pmaxsw (%rcx),%mm2
0fee11|223344556677885f5f5f5f5f5f	64	intel	pmaxsw mmx2, qword ptr [rcx]
0fee11|223344556677885f5f5f5f5f5f	64	plan9	PMAXSW 0(CX), M2
0fef11|223344556677885f5f5f5f5f5f	32	intel	pxor mmx2, qword ptr [ecx]
0fef11|223344556677885f5f5f5f5f5f	32	plan9	PXOR 0(CX), M2
0fef11|223344556677885f5f5f5f5f5f	64	gnu	pxor (%rcx),%mm2
0fef11|223344556677885f5f5f5f5f5f	64	intel	pxor mmx2, qword ptr [rcx]
0fef11|223344556677885f5f5f5f5f5f	64	plan9	PXOR 0(CX), M2
0ff0|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0ff111|223344556677885f5f5f5f5f5f	32	intel	psllw mmx2, qword ptr [ecx]
0ff111|223344556677885f5f5f5f5f5f	32	plan9	PSLLW 0(CX), M2
0ff111|223344556677885f5f5f5f5f5f	64	gnu	psllw (%rcx),%mm2
0ff111|223344556677885f5f5f5f5f5f	64	intel	psllw mmx2, qword ptr [rcx]
0ff111|223344556677885f5f5f5f5f5f	64	plan9	PSLLW 0(CX), M2
0ff211|223344556677885f5f5f5f5f5f	32	intel	pslld mmx2, qword ptr [ecx]
0ff211|223344556677885f5f5f5f5f5f	32	plan9	PSLLD 0(CX), M2
0ff211|223344556677885f5f5f5f5f5f	64	gnu	pslld (%rcx),%mm2
0ff211|223344556677885f5f5f5f5f5f	64	intel	pslld mmx2, qword ptr [rcx]
0ff211|223344556677885f5f5f5f5f5f	64	plan9	PSLLD 0(CX), M2
0ff311|223344556677885f5f5f5f5f5f	32	intel	psllq mmx2, qword ptr [ecx]
0ff311|223344556677885f5f5f5f5f5f	32	plan9	PSLLQ 0(CX), M2
0ff311|223344556677885f5f5f5f5f5f	64	gnu	psllq (%rcx),%mm2
0ff311|223344556677885f5f5f5f5f5f	64	intel	psllq mmx2, qword ptr [rcx]
0ff311|223344556677885f5f5f5f5f5f	64	plan9	PSLLQ 0(CX), M2
0ff411|223344556677885f5f5f5f5f5f	32	intel	pmuludq mmx2, qword ptr [ecx]
0ff411|223344556677885f5f5f5f5f5f	32	plan9	PMULUDQ 0(CX), M2
0ff411|223344556677885f5f5f5f5f5f	64	gnu	pmuludq (%rcx),%mm2
0ff411|223344556677885f5f5f5f5f5f	64	intel	pmuludq mmx2, qword ptr [rcx]
0ff411|223344556677885f5f5f5f5f5f	64	plan9	PMULUDQ 0(CX), M2
0ff511|223344556677885f5f5f5f5f5f	32	intel	pmaddwd mmx2, qword ptr [ecx]
0ff511|223344556677885f5f5f5f5f5f	32	plan9	PMADDWD 0(CX), M2
0ff511|223344556677885f5f5f5f5f5f	64	gnu	pmaddwd (%rcx),%mm2
0ff511|223344556677885f5f5f5f5f5f	64	intel	pmaddwd mmx2, qword ptr [rcx]
0ff511|223344556677885f5f5f5f5f5f	64	plan9	PMADDWD 0(CX), M2
0ff611|223344556677885f5f5f5f5f5f	32	intel	psadbw mmx2, qword ptr [ecx]
0ff611|223344556677885f5f5f5f5f5f	32	plan9	PSADBW 0(CX), M2
0ff611|223344556677885f5f5f5f5f5f	64	gnu	psadbw (%rcx),%mm2
0ff611|223344556677885f5f5f5f5f5f	64	intel	psadbw mmx2, qword ptr [rcx]
0ff611|223344556677885f5f5f5f5f5f	64	plan9	PSADBW 0(CX), M2
0ff711|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0ff7c0|11223344556677885f5f5f5f5f	32	intel	maskmovq mmx0, mmx0
0ff7c0|11223344556677885f5f5f5f5f	32	plan9	MASKMOVQ M0, M0
0ff7c0|11223344556677885f5f5f5f5f	64	gnu	maskmovq %mm0,%mm0
0ff7c0|11223344556677885f5f5f5f5f	64	intel	maskmovq mmx0, mmx0
0ff7c0|11223344556677885f5f5f5f5f	64	plan9	MASKMOVQ M0, M0
0ff811|223344556677885f5f5f5f5f5f	32	intel	psubb mmx2, qword ptr [ecx]
0ff811|223344556677885f5f5f5f5f5f	32	plan9	PSUBB 0(CX), M2
0ff811|223344556677885f5f5f5f5f5f	64	gnu	psubb (%rcx),%mm2
0ff811|223344556677885f5f5f5f5f5f	64	intel	psubb mmx2, qword ptr [rcx]
0ff811|223344556677885f5f5f5f5f5f	64	plan9	PSUBB 0(CX), M2
0ff911|223344556677885f5f5f5f5f5f	32	intel	psubw mmx2, qword ptr [ecx]
0ff911|223344556677885f5f5f5f5f5f	32	plan9	PSUBW 0(CX), M2
0ff911|223344556677885f5f5f5f5f5f	64	gnu	psubw (%rcx),%mm2
0ff911|223344556677885f5f5f5f5f5f	64	intel	psubw mmx2, qword ptr [rcx]
0ff911|223344556677885f5f5f5f5f5f	64	plan9	PSUBW 0(CX), M2
0ffa11|223344556677885f5f5f5f5f5f	32	intel	psubd mmx2, qword ptr [ecx]
0ffa11|223344556677885f5f5f5f5f5f	32	plan9	PSUBD 0(CX), M2
0ffa11|223344556677885f5f5f5f5f5f	64	gnu	psubd (%rcx),%mm2
0ffa11|223344556677885f5f5f5f5f5f	64	intel	psubd mmx2, qword ptr [rcx]
0ffa11|223344556677885f5f5f5f5f5f	64	plan9	PSUBD 0(CX), M2
0ffb11|223344556677885f5f5f5f5f5f	32	intel	psubq mmx2, qword ptr [ecx]
0ffb11|223344556677885f5f5f5f5f5f	32	plan9	PSUBQ 0(CX), M2
0ffb11|223344556677885f5f5f5f5f5f	64	gnu	psubq (%rcx),%mm2
0ffb11|223344556677885f5f5f5f5f5f	64	intel	psubq mmx2, qword ptr [rcx]
0ffb11|223344556677885f5f5f5f5f5f	64	plan9	PSUBQ 0(CX), M2
0ffc11|223344556677885f5f5f5f5f5f	32	intel	paddb mmx2, qword ptr [ecx]
0ffc11|223344556677885f5f5f5f5f5f	32	plan9	PADDB 0(CX), M2
0ffc11|223344556677885f5f5f5f5f5f	64	gnu	paddb (%rcx),%mm2
0ffc11|223344556677885f5f5f5f5f5f	64	intel	paddb mmx2, qword ptr [rcx]
0ffc11|223344556677885f5f5f5f5f5f	64	plan9	PADDB 0(CX), M2
0ffd11|223344556677885f5f5f5f5f5f	32	intel	paddw mmx2, qword ptr [ecx]
0ffd11|223344556677885f5f5f5f5f5f	32	plan9	PADDW 0(CX), M2
0ffd11|223344556677885f5f5f5f5f5f	64	gnu	paddw (%rcx),%mm2
0ffd11|223344556677885f5f5f5f5f5f	64	intel	paddw mmx2, qword ptr [rcx]
0ffd11|223344556677885f5f5f5f5f5f	64	plan9	PADDW 0(CX), M2
0ffe11|223344556677885f5f5f5f5f5f	32	intel	paddd mmx2, qword ptr [ecx]
0ffe11|223344556677885f5f5f5f5f5f	32	plan9	PADDD 0(CX), M2
0ffe11|223344556677885f5f5f5f5f5f	64	gnu	paddd (%rcx),%mm2
0ffe11|223344556677885f5f5f5f5f5f	64	intel	paddd mmx2, qword ptr [rcx]
0ffe11|223344556677885f5f5f5f5f5f	64	plan9	PADDD 0(CX), M2
1011|223344556677885f5f5f5f5f5f5f	32	intel	adc byte ptr [ecx], dl
1011|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL DL, 0(CX)
1011|223344556677885f5f5f5f5f5f5f	64	gnu	adc %dl,(%rcx)
1011|223344556677885f5f5f5f5f5f5f	64	intel	adc byte ptr [rcx], dl
1011|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL DL, 0(CX)
1111|223344556677885f5f5f5f5f5f5f	32	intel	adc dword ptr [ecx], edx
1111|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL DX, 0(CX)
1111|223344556677885f5f5f5f5f5f5f	64	gnu	adc %edx,(%rcx)
1111|223344556677885f5f5f5f5f5f5f	64	intel	adc dword ptr [rcx], edx
1111|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL DX, 0(CX)
1211|223344556677885f5f5f5f5f5f5f	32	intel	adc dl, byte ptr [ecx]
1211|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL 0(CX), DL
1211|223344556677885f5f5f5f5f5f5f	64	gnu	adc (%rcx),%dl
1211|223344556677885f5f5f5f5f5f5f	64	intel	adc dl, byte ptr [rcx]
1211|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL 0(CX), DL
1311|223344556677885f5f5f5f5f5f5f	32	intel	adc edx, dword ptr [ecx]
1311|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL 0(CX), DX
1311|223344556677885f5f5f5f5f5f5f	64	gnu	adc (%rcx),%edx
1311|223344556677885f5f5f5f5f5f5f	64	intel	adc edx, dword ptr [rcx]
1311|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL 0(CX), DX
1411|223344556677885f5f5f5f5f5f5f	32	intel	adc al, 0x11
1411|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x11, AL
1411|223344556677885f5f5f5f5f5f5f	64	gnu	adc $0x11,%al
1411|223344556677885f5f5f5f5f5f5f	64	intel	adc al, 0x11
1411|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x11, AL
1511223344|556677885f5f5f5f5f5f5f	32	intel	adc eax, 0x44332211
1511223344|556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x44332211, AX
1511223344|556677885f5f5f5f5f5f5f	64	gnu	adc $0x44332211,%eax
1511223344|556677885f5f5f5f5f5f5f	64	intel	adc eax, 0x44332211
1511223344|556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x44332211, AX
16|11223344556677885f5f5f5f5f5f5f	32	intel	push ss
16|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL SS
16|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
16|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
16|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
17|11223344556677885f5f5f5f5f5f5f	32	intel	pop ss
17|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL SS
17|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
17|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
17|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
1811|223344556677885f5f5f5f5f5f5f	32	intel	sbb byte ptr [ecx], dl
1811|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL DL, 0(CX)
1811|223344556677885f5f5f5f5f5f5f	64	gnu	sbb %dl,(%rcx)
1811|223344556677885f5f5f5f5f5f5f	64	intel	sbb byte ptr [rcx], dl
1811|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL DL, 0(CX)
1911|223344556677885f5f5f5f5f5f5f	32	intel	sbb dword ptr [ecx], edx
1911|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL DX, 0(CX)
1911|223344556677885f5f5f5f5f5f5f	64	gnu	sbb %edx,(%rcx)
1911|223344556677885f5f5f5f5f5f5f	64	intel	sbb dword ptr [rcx], edx
1911|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL DX, 0(CX)
1a11|223344556677885f5f5f5f5f5f5f	32	intel	sbb dl, byte ptr [ecx]
1a11|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL 0(CX), DL
1a11|223344556677885f5f5f5f5f5f5f	64	gnu	sbb (%rcx),%dl
1a11|223344556677885f5f5f5f5f5f5f	64	intel	sbb dl, byte ptr [rcx]
1a11|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL 0(CX), DL
1b11|223344556677885f5f5f5f5f5f5f	32	intel	sbb edx, dword ptr [ecx]
1b11|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL 0(CX), DX
1b11|223344556677885f5f5f5f5f5f5f	64	gnu	sbb (%rcx),%edx
1b11|223344556677885f5f5f5f5f5f5f	64	intel	sbb edx, dword ptr [rcx]
1b11|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL 0(CX), DX
1c11|223344556677885f5f5f5f5f5f5f	32	intel	sbb al, 0x11
1c11|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL $0x11, AL
1c11|223344556677885f5f5f5f5f5f5f	64	gnu	sbb $0x11,%al
1c11|223344556677885f5f5f5f5f5f5f	64	intel	sbb al, 0x11
1c11|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL $0x11, AL
1d11223344|556677885f5f5f5f5f5f5f	32	intel	sbb eax, 0x44332211
1d11223344|556677885f5f5f5f5f5f5f	32	plan9	SBBL $0x44332211, AX
1d11223344|556677885f5f5f5f5f5f5f	64	gnu	sbb $0x44332211,%eax
1d11223344|556677885f5f5f5f5f5f5f	64	intel	sbb eax, 0x44332211
1d11223344|556677885f5f5f5f5f5f5f	64	plan9	SBBL $0x44332211, AX
1e|11223344556677885f5f5f5f5f5f5f	32	intel	push ds
1e|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL DS
1e|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
1e|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
1e|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
1f|11223344556677885f5f5f5f5f5f5f	32	intel	pop ds
1f|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL DS
1f|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
1f|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
1f|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
2011|223344556677885f5f5f5f5f5f5f	32	intel	and byte ptr [ecx], dl
2011|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL DL, 0(CX)
2011|223344556677885f5f5f5f5f5f5f	64	gnu	and %dl,(%rcx)
2011|223344556677885f5f5f5f5f5f5f	64	intel	and byte ptr [rcx], dl
2011|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL DL, 0(CX)
2111|223344556677885f5f5f5f5f5f5f	32	intel	and dword ptr [ecx], edx
2111|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL DX, 0(CX)
2111|223344556677885f5f5f5f5f5f5f	64	gnu	and %edx,(%rcx)
2111|223344556677885f5f5f5f5f5f5f	64	intel	and dword ptr [rcx], edx
2111|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL DX, 0(CX)
2211|223344556677885f5f5f5f5f5f5f	32	intel	and dl, byte ptr [ecx]
2211|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL 0(CX), DL
2211|223344556677885f5f5f5f5f5f5f	64	gnu	and (%rcx),%dl
2211|223344556677885f5f5f5f5f5f5f	64	intel	and dl, byte ptr [rcx]
2211|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL 0(CX), DL
2311|223344556677885f5f5f5f5f5f5f	32	intel	and edx, dword ptr [ecx]
2311|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL 0(CX), DX
2311|223344556677885f5f5f5f5f5f5f	64	gnu	and (%rcx),%edx
2311|223344556677885f5f5f5f5f5f5f	64	intel	and edx, dword ptr [rcx]
2311|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL 0(CX), DX
2411|223344556677885f5f5f5f5f5f5f	32	intel	and al, 0x11
2411|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL $0x11, AL
2411|223344556677885f5f5f5f5f5f5f	64	gnu	and $0x11,%al
2411|223344556677885f5f5f5f5f5f5f	64	intel	and al, 0x11
2411|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL $0x11, AL
2511223344|556677885f5f5f5f5f5f5f	32	intel	and eax, 0x44332211
2511223344|556677885f5f5f5f5f5f5f	32	plan9	ANDL $0x44332211, AX
2511223344|556677885f5f5f5f5f5f5f	64	gnu	and $0x44332211,%eax
2511223344|556677885f5f5f5f5f5f5f	64	intel	and eax, 0x44332211
2511223344|556677885f5f5f5f5f5f5f	64	plan9	ANDL $0x44332211, AX
266e|11223344556677885f5f5f5f5f5f	32	intel	outsb es
266e|11223344556677885f5f5f5f5f5f	32	plan9	ES OUTSB ES:0(SI), DX
266e|11223344556677885f5f5f5f5f5f	64	gnu	outsb %ds:%es:(%rsi),(%dx)
266e|11223344556677885f5f5f5f5f5f	64	intel	outsb
266e|11223344556677885f5f5f5f5f5f	64	plan9	ES OUTSB DS:0(SI), DX
267011|223344556677885f5f5f5f5f5f	32	intel	jo .+0x11
267011|223344556677885f5f5f5f5f5f	32	plan9	ES JO .+17
267011|223344556677885f5f5f5f5f5f	64	gnu	es jo .+0x11
267011|223344556677885f5f5f5f5f5f	64	intel	jo .+0x11
267011|223344556677885f5f5f5f5f5f	64	plan9	ES JO .+17
26a01122334455667788|5f5f5f5f5f5f	64	gnu	mov %es:-0x778899aabbccddef,%al
26a01122334455667788|5f5f5f5f5f5f	64	intel	mov al, byte ptr [0x8877665544332211]
26a01122334455667788|5f5f5f5f5f5f	64	plan9	ES MOVL -0x778899aabbccddef, AL
26a011223344|556677885f5f5f5f5f5f	32	intel	mov al, byte ptr es:[0x44332211]
26a011223344|556677885f5f5f5f5f5f	32	plan9	ES MOVL ES:0x44332211, AL
26|8211223344556677885f5f5f5f5f5f	32	intel	es
26|8211223344556677885f5f5f5f5f5f	32	plan9	ES Op(0)
26|8211223344556677885f5f5f5f5f5f	64	gnu	es
26|8211223344556677885f5f5f5f5f5f	64	intel	es
26|8211223344556677885f5f5f5f5f5f	64	plan9	ES Op(0)
27|11223344556677885f5f5f5f5f5f5f	32	intel	daa
27|11223344556677885f5f5f5f5f5f5f	32	plan9	DAA
27|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
27|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
27|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
2811|223344556677885f5f5f5f5f5f5f	32	intel	sub byte ptr [ecx], dl
2811|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL DL, 0(CX)
2811|223344556677885f5f5f5f5f5f5f	64	gnu	sub %dl,(%rcx)
2811|223344556677885f5f5f5f5f5f5f	64	intel	sub byte ptr [rcx], dl
2811|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL DL, 0(CX)
2911|223344556677885f5f5f5f5f5f5f	32	intel	sub dword ptr [ecx], edx
2911|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL DX, 0(CX)
2911|223344556677885f5f5f5f5f5f5f	64	gnu	sub %edx,(%rcx)
2911|223344556677885f5f5f5f5f5f5f	64	intel	sub dword ptr [rcx], edx
2911|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL DX, 0(CX)
2a11|223344556677885f5f5f5f5f5f5f	32	intel	sub dl, byte ptr [ecx]
2a11|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL 0(CX), DL
2a11|223344556677885f5f5f5f5f5f5f	64	gnu	sub (%rcx),%dl
2a11|223344556677885f5f5f5f5f5f5f	64	intel	sub dl, byte ptr [rcx]
2a11|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL 0(CX), DL
2b11|223344556677885f5f5f5f5f5f5f	32	intel	sub edx, dword ptr [ecx]
2b11|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL 0(CX), DX
2b11|223344556677885f5f5f5f5f5f5f	64	gnu	sub (%rcx),%edx
2b11|223344556677885f5f5f5f5f5f5f	64	intel	sub edx, dword ptr [rcx]
2b11|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL 0(CX), DX
2c11|223344556677885f5f5f5f5f5f5f	32	intel	sub al, 0x11
2c11|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL $0x11, AL
2c11|223344556677885f5f5f5f5f5f5f	64	gnu	sub $0x11,%al
2c11|223344556677885f5f5f5f5f5f5f	64	intel	sub al, 0x11
2c11|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL $0x11, AL
2d11223344|556677885f5f5f5f5f5f5f	32	intel	sub eax, 0x44332211
2d11223344|556677885f5f5f5f5f5f5f	32	plan9	SUBL $0x44332211, AX
2d11223344|556677885f5f5f5f5f5f5f	64	gnu	sub $0x44332211,%eax
2d11223344|556677885f5f5f5f5f5f5f	64	intel	sub eax, 0x44332211
2d11223344|556677885f5f5f5f5f5f5f	64	plan9	SUBL $0x44332211, AX
2f|11223344556677885f5f5f5f5f5f5f	32	intel	das
2f|11223344556677885f5f5f5f5f5f5f	32	plan9	DAS
2f|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
2f|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
2f|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
3011|223344556677885f5f5f5f5f5f5f	32	intel	xor byte ptr [ecx], dl
3011|223344556677885f5f5f5f5f5f5f	32	plan9	XORL DL, 0(CX)
3011|223344556677885f5f5f5f5f5f5f	64	gnu	xor %dl,(%rcx)
3011|223344556677885f5f5f5f5f5f5f	64	intel	xor byte ptr [rcx], dl
3011|223344556677885f5f5f5f5f5f5f	64	plan9	XORL DL, 0(CX)
3111|223344556677885f5f5f5f5f5f5f	32	intel	xor dword ptr [ecx], edx
3111|223344556677885f5f5f5f5f5f5f	32	plan9	XORL DX, 0(CX)
3111|223344556677885f5f5f5f5f5f5f	64	gnu	xor %edx,(%rcx)
3111|223344556677885f5f5f5f5f5f5f	64	intel	xor dword ptr [rcx], edx
3111|223344556677885f5f5f5f5f5f5f	64	plan9	XORL DX, 0(CX)
3211|223344556677885f5f5f5f5f5f5f	32	intel	xor dl, byte ptr [ecx]
3211|223344556677885f5f5f5f5f5f5f	32	plan9	XORL 0(CX), DL
3211|223344556677885f5f5f5f5f5f5f	64	gnu	xor (%rcx),%dl
3211|223344556677885f5f5f5f5f5f5f	64	intel	xor dl, byte ptr [rcx]
3211|223344556677885f5f5f5f5f5f5f	64	plan9	XORL 0(CX), DL
3311|223344556677885f5f5f5f5f5f5f	32	intel	xor edx, dword ptr [ecx]
3311|223344556677885f5f5f5f5f5f5f	32	plan9	XORL 0(CX), DX
3311|223344556677885f5f5f5f5f5f5f	64	gnu	xor (%rcx),%edx
3311|223344556677885f5f5f5f5f5f5f	64	intel	xor edx, dword ptr [rcx]
3311|223344556677885f5f5f5f5f5f5f	64	plan9	XORL 0(CX), DX
3411|223344556677885f5f5f5f5f5f5f	32	intel	xor al, 0x11
3411|223344556677885f5f5f5f5f5f5f	32	plan9	XORL $0x11, AL
3411|223344556677885f5f5f5f5f5f5f	64	gnu	xor $0x11,%al
3411|223344556677885f5f5f5f5f5f5f	64	intel	xor al, 0x11
3411|223344556677885f5f5f5f5f5f5f	64	plan9	XORL $0x11, AL
3511223344|556677885f5f5f5f5f5f5f	32	intel	xor eax, 0x44332211
3511223344|556677885f5f5f5f5f5f5f	32	plan9	XORL $0x44332211, AX
3511223344|556677885f5f5f5f5f5f5f	64	gnu	xor $0x44332211,%eax
3511223344|556677885f5f5f5f5f5f5f	64	intel	xor eax, 0x44332211
3511223344|556677885f5f5f5f5f5f5f	64	plan9	XORL $0x44332211, AX
3667f3660f2ac0|11223344556677885f	32	intel	addr16 cvtsi2ss xmm0, eax
3667f3660f2ac0|11223344556677885f	32	plan9	CVTSI2SSW AX, X0
3667f3660f2ac0|11223344556677885f	64	gnu	ss addr32 cvtsi2ss %ax,%xmm0
3667f3660f2ac0|11223344556677885f	64	intel	addr32 cvtsi2ss xmm0, eax
3667f3660f2ac0|11223344556677885f	64	plan9	CVTSI2SSW AX, X0
36|67f3660ff7c011223344556677885f	64	gnu	ss
36|f0f2f33e66f066f2f33e3666818411	32	intel	ss
36|f0f2f33e66f066f2f33e3666818411	32	plan9	SS Op(0)
36|f0f2f33e66f066f2f33e3666818411	64	gnu	ss
36|f0f2f33e66f066f2f33e3666818411	64	intel	ss
36|f0f2f33e66f066f2f33e3666818411	64	plan9	SS Op(0)
36|f2f33ef0f78411223344556677885f	32	intel	ss
36|f2f33ef0f78411223344556677885f	32	plan9	SS Op(0)
36|f2f33ef0f78411223344556677885f	64	gnu	ss
36|f2f33ef0f78411223344556677885f	64	intel	ss
36|f2f33ef0f78411223344556677885f	64	plan9	SS Op(0)
37|11223344556677885f5f5f5f5f5f5f	32	intel	aaa
37|11223344556677885f5f5f5f5f5f5f	32	plan9	AAA
37|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
37|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
37|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
3811|223344556677885f5f5f5f5f5f5f	32	intel	cmp byte ptr [ecx], dl
3811|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL DL, 0(CX)
3811|223344556677885f5f5f5f5f5f5f	64	gnu	cmp %dl,(%rcx)
3811|223344556677885f5f5f5f5f5f5f	64	intel	cmp byte ptr [rcx], dl
3811|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL DL, 0(CX)
3911|223344556677885f5f5f5f5f5f5f	32	intel	cmp dword ptr [ecx], edx
3911|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL DX, 0(CX)
3911|223344556677885f5f5f5f5f5f5f	64	gnu	cmp %edx,(%rcx)
3911|223344556677885f5f5f5f5f5f5f	64	intel	cmp dword ptr [rcx], edx
3911|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL DX, 0(CX)
3a11|223344556677885f5f5f5f5f5f5f	32	intel	cmp dl, byte ptr [ecx]
3a11|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL 0(CX), DL
3a11|223344556677885f5f5f5f5f5f5f	64	gnu	cmp (%rcx),%dl
3a11|223344556677885f5f5f5f5f5f5f	64	intel	cmp dl, byte ptr [rcx]
3a11|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL 0(CX), DL
3b11|223344556677885f5f5f5f5f5f5f	32	intel	cmp edx, dword ptr [ecx]
3b11|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL 0(CX), DX
3b11|223344556677885f5f5f5f5f5f5f	64	gnu	cmp (%rcx),%edx
3b11|223344556677885f5f5f5f5f5f5f	64	intel	cmp edx, dword ptr [rcx]
3b11|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL 0(CX), DX
3c11|223344556677885f5f5f5f5f5f5f	32	intel	cmp al, 0x11
3c11|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL $0x11, AL
3c11|223344556677885f5f5f5f5f5f5f	64	gnu	cmp $0x11,%al
3c11|223344556677885f5f5f5f5f5f5f	64	intel	cmp al, 0x11
3c11|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL $0x11, AL
3d11223344|556677885f5f5f5f5f5f5f	32	intel	cmp eax, 0x44332211
3d11223344|556677885f5f5f5f5f5f5f	32	plan9	CMPL $0x44332211, AX
3d11223344|556677885f5f5f5f5f5f5f	64	gnu	cmp $0x44332211,%eax
3d11223344|556677885f5f5f5f5f5f5f	64	intel	cmp eax, 0x44332211
3d11223344|556677885f5f5f5f5f5f5f	64	plan9	CMPL $0x44332211, AX
3e67e011|223344556677885f5f5f5f5f	32	intel	addr16 loopne .+0x11
3e67e011|223344556677885f5f5f5f5f	32	plan9	LOOPNE .+17
3e67e011|223344556677885f5f5f5f5f	64	gnu	loopne,pt .+0x11
3e67e011|223344556677885f5f5f5f5f	64	intel	addr32 loopne .+0x11
3e67e011|223344556677885f5f5f5f5f	64	plan9	LOOPNE .+17
3ef367660f38f011|223344556677885f	32	intel	movbe dx, word ptr [bx+di*1]
3ef367660f38f011|223344556677885f	32	plan9	MOVBE DS:0(BX)(DI*1), DX
3ef367660f38f011|223344556677885f	64	gnu	rep movbe %ds:(%ecx),%dx
3ef367660f38f011|223344556677885f	64	intel	movbe dx, word ptr [ecx]
3ef367660f38f011|223344556677885f	64	plan9	MOVBE 0(CX), DX
3f|11223344556677885f5f5f5f5f5f5f	32	intel	aas
3f|11223344556677885f5f5f5f5f5f5f	32	plan9	AAS
3f|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
3f|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
3f|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
4040|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
4040|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
4040|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
4048|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
4048|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
4048|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
40|11223344556677885f5f5f5f5f5f5f	32	intel	inc eax
40|11223344556677885f5f5f5f5f5f5f	32	plan9	INCL AX
480100|11223344556677885f5f5f5f5f	64	gnu	add %rax,(%rax)
480100|11223344556677885f5f5f5f5f	64	intel	add qword ptr [rax], rax
480100|11223344556677885f5f5f5f5f	64	plan9	ADDQ AX, 0(AX)
480311|223344556677885f5f5f5f5f5f	64	gnu	add (%rcx),%rdx
480311|223344556677885f5f5f5f5f5f	64	intel	add rdx, qword ptr [rcx]
480311|223344556677885f5f5f5f5f5f	64	plan9	ADDQ 0(CX), DX
480511223344|556677885f5f5f5f5f5f	64	gnu	add $0x44332211,%rax
480511223344|556677885f5f5f5f5f5f	64	intel	add rax, 0x44332211
480511223344|556677885f5f5f5f5f5f	64	plan9	ADDQ $0x44332211, AX
480911|223344556677885f5f5f5f5f5f	64	gnu	or %rdx,(%rcx)
480911|223344556677885f5f5f5f5f5f	64	intel	or qword ptr [rcx], rdx
480911|223344556677885f5f5f5f5f5f	64	plan9	ORQ DX, 0(CX)
480b11|223344556677885f5f5f5f5f5f	64	gnu	or (%rcx),%rdx
480b11|223344556677885f5f5f5f5f5f	64	intel	or rdx, qword ptr [rcx]
480b11|223344556677885f5f5f5f5f5f	64	plan9	ORQ 0(CX), DX
480d11223344|556677885f5f5f5f5f5f	64	gnu	or $0x44332211,%rax
480d11223344|556677885f5f5f5f5f5f	64	intel	or rax, 0x44332211
480d11223344|556677885f5f5f5f5f5f	64	plan9	ORQ $0x44332211, AX
480f0000|11223344556677885f5f5f5f	64	gnu	sldt (%rax)
480f0000|11223344556677885f5f5f5f	64	intel	sldt word ptr [rax]
480f0000|11223344556677885f5f5f5f	64	plan9	SLDT 0(AX)
480f0008|11223344556677885f5f5f5f	64	gnu	str (%rax)
480f0008|11223344556677885f5f5f5f	64	intel	str word ptr [rax]
480f0008|11223344556677885f5f5f5f	64	plan9	STR 0(AX)
480f0120|11223344556677885f5f5f5f	64	gnu	smsw (%rax)
480f0120|11223344556677885f5f5f5f	64	intel	smsw word ptr [rax]
480f0120|11223344556677885f5f5f5f	64	plan9	SMSW 0(AX)
480f0211|223344556677885f5f5f5f5f	64	gnu	lar (%rcx),%rdx
480f0211|223344556677885f5f5f5f5f	64	intel	lar rdx, word ptr [rcx]
480f0211|223344556677885f5f5f5f5f	64	plan9	LAR 0(CX), DX
480f0311|223344556677885f5f5f5f5f	64	gnu	lsl (%rcx),%rdx
480f0311|223344556677885f5f5f5f5f	64	intel	lsl rdx, word ptr [rcx]
480f0311|223344556677885f5f5f5f5f	64	plan9	LSL 0(CX), DX
480f35|11223344556677885f5f5f5f5f	64	gnu	sysexit
480f35|11223344556677885f5f5f5f5f	64	intel	sysexit
480f35|11223344556677885f5f5f5f5f	64	plan9	SYSEXIT
480f38f011|223344556677885f5f5f5f	64	gnu	movbe (%rcx),%rdx
480f38f011|223344556677885f5f5f5f	64	intel	movbe rdx, qword ptr [rcx]
480f38f011|223344556677885f5f5f5f	64	plan9	MOVBE 0(CX), DX
480f38f111|223344556677885f5f5f5f	64	gnu	movbe %rdx,(%rcx)
480f38f111|223344556677885f5f5f5f	64	intel	movbe qword ptr [rcx], rdx
480f38f111|223344556677885f5f5f5f	64	plan9	MOVBE DX, 0(CX)
480f4011|223344556677885f5f5f5f5f	64	gnu	cmovo (%rcx),%rdx
480f4011|223344556677885f5f5f5f5f	64	intel	cmovo rdx, qword ptr [rcx]
480f4011|223344556677885f5f5f5f5f	64	plan9	CMOVO 0(CX), DX
480f4111|223344556677885f5f5f5f5f	64	gnu	cmovno (%rcx),%rdx
480f4111|223344556677885f5f5f5f5f	64	intel	cmovno rdx, qword ptr [rcx]
480f4111|223344556677885f5f5f5f5f	64	plan9	CMOVNO 0(CX), DX
480f4211|223344556677885f5f5f5f5f	64	gnu	cmovb (%rcx),%rdx
480f4211|223344556677885f5f5f5f5f	64	intel	cmovb rdx, qword ptr [rcx]
480f4211|223344556677885f5f5f5f5f	64	plan9	CMOVB 0(CX), DX
480f4311|223344556677885f5f5f5f5f	64	gnu	cmovae (%rcx),%rdx
480f4311|223344556677885f5f5f5f5f	64	intel	cmovnb rdx, qword ptr [rcx]
480f4311|223344556677885f5f5f5f5f	64	plan9	CMOVAE 0(CX), DX
480f4411|223344556677885f5f5f5f5f	64	gnu	cmove (%rcx),%rdx
480f4411|223344556677885f5f5f5f5f	64	intel	cmovz rdx, qword ptr [rcx]
480f4411|223344556677885f5f5f5f5f	64	plan9	CMOVE 0(CX), DX
480f4511|223344556677885f5f5f5f5f	64	gnu	cmovne (%rcx),%rdx
480f4511|223344556677885f5f5f5f5f	64	intel	cmovnz rdx, qword ptr [rcx]
480f4511|223344556677885f5f5f5f5f	64	plan9	CMOVNE 0(CX), DX
480f4611|223344556677885f5f5f5f5f	64	gnu	cmovbe (%rcx),%rdx
480f4611|223344556677885f5f5f5f5f	64	intel	cmovbe rdx, qword ptr [rcx]
480f4611|223344556677885f5f5f5f5f	64	plan9	CMOVBE 0(CX), DX
480f4711|223344556677885f5f5f5f5f	64	gnu	cmova (%rcx),%rdx
480f4711|223344556677885f5f5f5f5f	64	intel	cmovnbe rdx, qword ptr [rcx]
480f4711|223344556677885f5f5f5f5f	64	plan9	CMOVA 0(CX), DX
480f4811|223344556677885f5f5f5f5f	64	gnu	cmovs (%rcx),%rdx
480f4811|223344556677885f5f5f5f5f	64	intel	cmovs rdx, qword ptr [rcx]
480f4811|223344556677885f5f5f5f5f	64	plan9	CMOVS 0(CX), DX
480f4911|223344556677885f5f5f5f5f	64	gnu	cmovns (%rcx),%rdx
480f4911|223344556677885f5f5f5f5f	64	intel	cmovns rdx, qword ptr [rcx]
480f4911|223344556677885f5f5f5f5f	64	plan9	CMOVNS 0(CX), DX
480f4a11|223344556677885f5f5f5f5f	64	gnu	cmovp (%rcx),%rdx
480f4a11|223344556677885f5f5f5f5f	64	intel	cmovp rdx, qword ptr [rcx]
480f4a11|223344556677885f5f5f5f5f	64	plan9	CMOVP 0(CX), DX
480f4b11|223344556677885f5f5f5f5f	64	gnu	cmovnp (%rcx),%rdx
480f4b11|223344556677885f5f5f5f5f	64	intel	cmovnp rdx, qword ptr [rcx]
480f4b11|223344556677885f5f5f5f5f	64	plan9	CMOVNP 0(CX), DX
480f4c11|223344556677885f5f5f5f5f	64	gnu	cmovl (%rcx),%rdx
480f4c11|223344556677885f5f5f5f5f	64	intel	cmovl rdx, qword ptr [rcx]
480f4c11|223344556677885f5f5f5f5f	64	plan9	CMOVL 0(CX), DX
480f4d11|223344556677885f5f5f5f5f	64	gnu	cmovge (%rcx),%rdx
480f4d11|223344556677885f5f5f5f5f	64	intel	cmovnl rdx, qword ptr [rcx]
480f4d11|223344556677885f5f5f5f5f	64	plan9	CMOVGE 0(CX), DX
480f4e11|223344556677885f5f5f5f5f	64	gnu	cmovle (%rcx),%rdx
480f4e11|223344556677885f5f5f5f5f	64	intel	cmovle rdx, qword ptr [rcx]
480f4e11|223344556677885f5f5f5f5f	64	plan9	CMOVLE 0(CX), DX
480f4f11|223344556677885f5f5f5f5f	64	gnu	cmovg (%rcx),%rdx
480f4f11|223344556677885f5f5f5f5f	64	intel	cmovnle rdx, qword ptr [rcx]
480f4f11|223344556677885f5f5f5f5f	64	plan9	CMOVG 0(CX), DX
480f6e11|223344556677885f5f5f5f5f	64	gnu	movq (%rcx),%mm2
480f6e11|223344556677885f5f5f5f5f	64	intel	movq mmx2, qword ptr [rcx]
480f6e11|223344556677885f5f5f5f5f	64	plan9	MOVQ 0(CX), M2
480f7e11|223344556677885f5f5f5f5f	64	gnu	movq %mm2,(%rcx)
480f7e11|223344556677885f5f5f5f5f	64	intel	movq qword ptr [rcx], mmx2
480f7e11|223344556677885f5f5f5f5f	64	plan9	MOVQ M2, 0(CX)
480f8011223344|556677885f5f5f5f5f	64	gnu	jo .+0x44332211
480f8011223344|556677885f5f5f5f5f	64	intel	jo .+0x44332211
480f8011223344|556677885f5f5f5f5f	64	plan9	JO .+1144201745
480f8111223344|556677885f5f5f5f5f	64	gnu	jno .+0x44332211
480f8111223344|556677885f5f5f5f5f	64	intel	jno .+0x44332211
480f8111223344|556677885f5f5f5f5f	64	plan9	JNO .+1144201745
480f8211223344|556677885f5f5f5f5f	64	gnu	jb .+0x44332211
480f8211223344|556677885f5f5f5f5f	64	intel	jb .+0x44332211
480f8211223344|556677885f5f5f5f5f	64	plan9	JB .+1144201745
480f8311223344|556677885f5f5f5f5f	64	gnu	jae .+0x44332211
480f8311223344|556677885f5f5f5f5f	64	intel	jnb .+0x44332211
480f8311223344|556677885f5f5f5f5f	64	plan9	JAE .+1144201745
480f8411223344|556677885f5f5f5f5f	64	gnu	je .+0x44332211
480f8411223344|556677885f5f5f5f5f	64	intel	jz .+0x44332211
480f8411223344|556677885f5f5f5f5f	64	plan9	JE .+1144201745
480f8511223344|556677885f5f5f5f5f	64	gnu	jne .+0x44332211
480f8511223344|556677885f5f5f5f5f	64	intel	jnz .+0x44332211
480f8511223344|556677885f5f5f5f5f	64	plan9	JNE .+1144201745
480f8611223344|556677885f5f5f5f5f	64	gnu	jbe .+0x44332211
480f8611223344|556677885f5f5f5f5f	64	intel	jbe .+0x44332211
480f8611223344|556677885f5f5f5f5f	64	plan9	JBE .+1144201745
480f8711223344|556677885f5f5f5f5f	64	gnu	ja .+0x44332211
480f8711223344|556677885f5f5f5f5f	64	intel	jnbe .+0x44332211
480f8711223344|556677885f5f5f5f5f	64	plan9	JA .+1144201745
480f8811223344|556677885f5f5f5f5f	64	gnu	js .+0x44332211
480f8811223344|556677885f5f5f5f5f	64	intel	js .+0x44332211
480f8811223344|556677885f5f5f5f5f	64	plan9	JS .+1144201745
480f8911223344|556677885f5f5f5f5f	64	gnu	jns .+0x44332211
480f8911223344|556677885f5f5f5f5f	64	intel	jns .+0x44332211
480f8911223344|556677885f5f5f5f5f	64	plan9	JNS .+1144201745
480f8a11223344|556677885f5f5f5f5f	64	gnu	jp .+0x44332211
480f8a11223344|556677885f5f5f5f5f	64	intel	jp .+0x44332211
480f8a11223344|556677885f5f5f5f5f	64	plan9	JP .+1144201745
480f8b11223344|556677885f5f5f5f5f	64	gnu	jnp .+0x44332211
480f8b11223344|556677885f5f5f5f5f	64	intel	jnp .+0x44332211
480f8b11223344|556677885f5f5f5f5f	64	plan9	JNP .+1144201745
480f8c11223344|556677885f5f5f5f5f	64	gnu	jl .+0x44332211
480f8c11223344|556677885f5f5f5f5f	64	intel	jl .+0x44332211
480f8c11223344|556677885f5f5f5f5f	64	plan9	JL .+1144201745
480f8d11223344|556677885f5f5f5f5f	64	gnu	jge .+0x44332211
480f8d11223344|556677885f5f5f5f5f	64	intel	jnl .+0x44332211
480f8d11223344|556677885f5f5f5f5f	64	plan9	JGE .+1144201745
480f8e11223344|556677885f5f5f5f5f	64	gnu	jle .+0x44332211
480f8e11223344|556677885f5f5f5f5f	64	intel	jle .+0x44332211
480f8e11223344|556677885f5f5f5f5f	64	plan9	JLE .+1144201745
480f8f11223344|556677885f5f5f5f5f	64	gnu	jg .+0x44332211
480f8f11223344|556677885f5f5f5f5f	64	intel	jnle .+0x44332211
480f8f11223344|556677885f5f5f5f5f	64	plan9	JG .+1144201745
480fa1|11223344556677885f5f5f5f5f	64	gnu	popq %fs
480fa1|11223344556677885f5f5f5f5f	64	intel	pop fs
480fa1|11223344556677885f5f5f5f5f	64	plan9	POPQ FS
480fa311|223344556677885f5f5f5f5f	64	gnu	bt %rdx,(%rcx)
480fa311|223344556677885f5f5f5f5f	64	intel	bt qword ptr [rcx], rdx
480fa311|223344556677885f5f5f5f5f	64	plan9	BTQ DX, 0(CX)
480fa41122|3344556677885f5f5f5f5f	64	gnu	shld $0x22,%rdx,(%rcx)
480fa41122|3344556677885f5f5f5f5f	64	intel	shld qword ptr [rcx], rdx, 0x22
480fa41122|3344556677885f5f5f5f5f	64	plan9	SHLDQ $0x22, DX, 0(CX)
480fa511|223344556677885f5f5f5f5f	64	gnu	shld %cl,%rdx,(%rcx)
480fa511|223344556677885f5f5f5f5f	64	intel	shld qword ptr [rcx], rdx, cl
480fa511|223344556677885f5f5f5f5f	64	plan9	SHLDQ CL, DX, 0(CX)
480fa9|11223344556677885f5f5f5f5f	64	gnu	popq %gs
480fa9|11223344556677885f5f5f5f5f	64	intel	pop gs
480fa9|11223344556677885f5f5f5f5f	64	plan9	POPQ GS
480fab11|223344556677885f5f5f5f5f	64	gnu	bts %rdx,(%rcx)
480fab11|223344556677885f5f5f5f5f	64	intel	bts qword ptr [rcx], rdx
480fab11|223344556677885f5f5f5f5f	64	plan9	BTSQ DX, 0(CX)
480fac1122|3344556677885f5f5f5f5f	64	gnu	shrd $0x22,%rdx,(%rcx)
480fac1122|3344556677885f5f5f5f5f	64	intel	shrd qword ptr [rcx], rdx, 0x22
480fac1122|3344556677885f5f5f5f5f	64	plan9	SHRDQ $0x22, DX, 0(CX)
480fad11|223344556677885f5f5f5f5f	64	gnu	shrd %cl,%rdx,(%rcx)
480fad11|223344556677885f5f5f5f5f	64	intel	shrd qword ptr [rcx], rdx, cl
480fad11|223344556677885f5f5f5f5f	64	plan9	SHRDQ CL, DX, 0(CX)
480fae00|11223344556677885f5f5f5f	64	gnu	fxsave64 (%rax)
480fae00|11223344556677885f5f5f5f	64	intel	fxsave64 ptr [rax]
480fae00|11223344556677885f5f5f5f	64	plan9	FXSAVE64 0(AX)
480fae08|11223344556677885f5f5f5f	64	gnu	fxrstor64 (%rax)
480fae08|11223344556677885f5f5f5f	64	intel	fxrstor64 ptr [rax]
480fae08|11223344556677885f5f5f5f	64	plan9	FXRSTOR64 0(AX)
480fae20|11223344556677885f5f5f5f	64	gnu	xsave64 (%rax)
480fae20|11223344556677885f5f5f5f	64	intel	xsave64 ptr [rax]
480fae20|11223344556677885f5f5f5f	64	plan9	XSAVE64 0(AX)
480fae28|11223344556677885f5f5f5f	64	gnu	xrstor64 (%rax)
480fae28|11223344556677885f5f5f5f	64	intel	xrstor64 ptr [rax]
480fae28|11223344556677885f5f5f5f	64	plan9	XRSTOR64 0(AX)
480fae30|11223344556677885f5f5f5f	64	gnu	xsaveopt64 (%rax)
480fae30|11223344556677885f5f5f5f	64	intel	xsaveopt64 ptr [rax]
480fae30|11223344556677885f5f5f5f	64	plan9	XSAVEOPT64 0(AX)
480faf11|223344556677885f5f5f5f5f	64	gnu	imul (%rcx),%rdx
480faf11|223344556677885f5f5f5f5f	64	intel	imul rdx, qword ptr [rcx]
480faf11|223344556677885f5f5f5f5f	64	plan9	IMULQ 0(CX), DX
480fb111|223344556677885f5f5f5f5f	64	gnu	cmpxchg %rdx,(%rcx)
480fb111|223344556677885f5f5f5f5f	64	intel	cmpxchg qword ptr [rcx], rdx
480fb111|223344556677885f5f5f5f5f	64	plan9	CMPXCHGQ DX, 0(CX)
480fb211|223344556677885f5f5f5f5f	64	gnu	lss (%rcx),%rdx
480fb211|223344556677885f5f5f5f5f	64	intel	lss rdx, ptr [rcx]
480fb211|223344556677885f5f5f5f5f	64	plan9	LSS 0(CX), DX
480fb311|223344556677885f5f5f5f5f	64	gnu	btr %rdx,(%rcx)
480fb311|223344556677885f5f5f5f5f	64	intel	btr qword ptr [rcx], rdx
480fb311|223344556677885f5f5f5f5f	64	plan9	BTRQ DX, 0(CX)
480fb411|223344556677885f5f5f5f5f	64	gnu	lfs (%rcx),%rdx
480fb411|223344556677885f5f5f5f5f	64	intel	lfs rdx, ptr [rcx]
480fb411|223344556677885f5f5f5f5f	64	plan9	LFS 0(CX), DX
480fb511|223344556677885f5f5f5f5f	64	gnu	lgs (%rcx),%rdx
480fb511|223344556677885f5f5f5f5f	64	intel	lgs rdx, ptr [rcx]
480fb511|223344556677885f5f5f5f5f	64	plan9	LGS 0(CX), DX
480fb611|223344556677885f5f5f5f5f	64	gnu	movzbq (%rcx),%rdx
480fb611|223344556677885f5f5f5f5f	64	intel	movzx rdx, byte ptr [rcx]
480fb611|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
480fb711|223344556677885f5f5f5f5f	64	gnu	movzwq (%rcx),%rdx
480fb711|223344556677885f5f5f5f5f	64	intel	movzx rdx, word ptr [rcx]
480fb711|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
480fba2011|223344556677885f5f5f5f	64	gnu	btq $0x11,(%rax)
480fba2011|223344556677885f5f5f5f	64	intel	bt qword ptr [rax], 0x11
480fba2011|223344556677885f5f5f5f	64	plan9	BTQ $0x11, 0(AX)
480fba2811|223344556677885f5f5f5f	64	gnu	btsq $0x11,(%rax)
480fba2811|223344556677885f5f5f5f	64	intel	bts qword ptr [rax], 0x11
480fba2811|223344556677885f5f5f5f	64	plan9	BTSQ $0x11, 0(AX)
480fba3011|223344556677885f5f5f5f	64	gnu	btrq $0x11,(%rax)
480fba3011|223344556677885f5f5f5f	64	intel	btr qword ptr [rax], 0x11
480fba3011|223344556677885f5f5f5f	64	plan9	BTRQ $0x11, 0(AX)
480fba3811|223344556677885f5f5f5f	64	gnu	btcq $0x11,(%rax)
480fba3811|223344556677885f5f5f5f	64	intel	btc qword ptr [rax], 0x11
480fba3811|223344556677885f5f5f5f	64	plan9	BTCQ $0x11, 0(AX)
480fbb11|223344556677885f5f5f5f5f	64	gnu	btc %rdx,(%rcx)
480fbb11|223344556677885f5f5f5f5f	64	intel	btc qword ptr [rcx], rdx
480fbb11|223344556677885f5f5f5f5f	64	plan9	BTCQ DX, 0(CX)
480fbc11|223344556677885f5f5f5f5f	64	gnu	bsf (%rcx),%rdx
480fbc11|223344556677885f5f5f5f5f	64	intel	bsf rdx, qword ptr [rcx]
480fbc11|223344556677885f5f5f5f5f	64	plan9	BSFQ 0(CX), DX
480fbd11|223344556677885f5f5f5f5f	64	gnu	bsr (%rcx),%rdx
480fbd11|223344556677885f5f5f5f5f	64	intel	bsr rdx, qword ptr [rcx]
480fbd11|223344556677885f5f5f5f5f	64	plan9	BSRQ 0(CX), DX
480fbe11|223344556677885f5f5f5f5f	64	gnu	movsbq (%rcx),%rdx
480fbe11|223344556677885f5f5f5f5f	64	intel	movsx rdx, byte ptr [rcx]
480fbe11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
480fbf11|223344556677885f5f5f5f5f	64	gnu	movswq (%rcx),%rdx
480fbf11|223344556677885f5f5f5f5f	64	intel	movsx rdx, word ptr [rcx]
480fbf11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
480fc111|223344556677885f5f5f5f5f	64	gnu	xadd %rdx,(%rcx)
480fc111|223344556677885f5f5f5f5f	64	intel	xadd qword ptr [rcx], rdx
480fc111|223344556677885f5f5f5f5f	64	plan9	XADDQ DX, 0(CX)
480fc311|223344556677885f5f5f5f5f	64	gnu	movnti %rdx,(%rcx)
480fc311|223344556677885f5f5f5f5f	64	intel	movnti qword ptr [rcx], rdx
480fc311|223344556677885f5f5f5f5f	64	plan9	MOVNTIQ DX, 0(CX)
480fc708|11223344556677885f5f5f5f	64	gnu	cmpxchg16b (%rax)
480fc708|11223344556677885f5f5f5f	64	intel	cmpxchg16b xmmword ptr [rax]
480fc708|11223344556677885f5f5f5f	64	plan9	CMPXCHG16B 0(AX)
480fc718|11223344556677885f5f5f5f	64	gnu	xrstors64 (%rax)
480fc718|11223344556677885f5f5f5f	64	intel	xrstors64 ptr [rax]
480fc718|11223344556677885f5f5f5f	64	plan9	XRSTORS64 0(AX)
480fc720|11223344556677885f5f5f5f	64	gnu	xsavec64 (%rax)
480fc720|11223344556677885f5f5f5f	64	intel	xsavec64 ptr [rax]
480fc720|11223344556677885f5f5f5f	64	plan9	XSAVEC64 0(AX)
480fc728|11223344556677885f5f5f5f	64	gnu	xsaves64 (%rax)
480fc728|11223344556677885f5f5f5f	64	intel	xsaves64 ptr [rax]
480fc728|11223344556677885f5f5f5f	64	plan9	XSAVES64 0(AX)
480fc730|11223344556677885f5f5f5f	64	gnu	rdrand
480fc730|11223344556677885f5f5f5f	64	intel	rdrand
480fc730|11223344556677885f5f5f5f	64	plan9	RDRAND
480fc8|11223344556677885f5f5f5f5f	64	gnu	bswap %rax
480fc8|11223344556677885f5f5f5f5f	64	intel	bswap rax
480fc8|11223344556677885f5f5f5f5f	64	plan9	BSWAP AX
481122|3344556677885f5f5f5f5f5f5f	64	gnu	adc %rsp,(%rdx)
481122|3344556677885f5f5f5f5f5f5f	64	intel	adc qword ptr [rdx], rsp
481122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCQ SP, 0(DX)
481311|223344556677885f5f5f5f5f5f	64	gnu	adc (%rcx),%rdx
481311|223344556677885f5f5f5f5f5f	64	intel	adc rdx, qword ptr [rcx]
481311|223344556677885f5f5f5f5f5f	64	plan9	ADCQ 0(CX), DX
481511223344|556677885f5f5f5f5f5f	64	gnu	adc $0x44332211,%rax
481511223344|556677885f5f5f5f5f5f	64	intel	adc rax, 0x44332211
481511223344|556677885f5f5f5f5f5f	64	plan9	ADCQ $0x44332211, AX
481911|223344556677885f5f5f5f5f5f	64	gnu	sbb %rdx,(%rcx)
481911|223344556677885f5f5f5f5f5f	64	intel	sbb qword ptr [rcx], rdx
481911|223344556677885f5f5f5f5f5f	64	plan9	SBBQ DX, 0(CX)
481b11|223344556677885f5f5f5f5f5f	64	gnu	sbb (%rcx),%rdx
481b11|223344556677885f5f5f5f5f5f	64	intel	sbb rdx, qword ptr [rcx]
481b11|223344556677885f5f5f5f5f5f	64	plan9	SBBQ 0(CX), DX
481d11223344|556677885f5f5f5f5f5f	64	gnu	sbb $0x44332211,%rax
481d11223344|556677885f5f5f5f5f5f	64	intel	sbb rax, 0x44332211
481d11223344|556677885f5f5f5f5f5f	64	plan9	SBBQ $0x44332211, AX
482111|223344556677885f5f5f5f5f5f	64	gnu	and %rdx,(%rcx)
482111|223344556677885f5f5f5f5f5f	64	intel	and qword ptr [rcx], rdx
482111|223344556677885f5f5f5f5f5f	64	plan9	ANDQ DX, 0(CX)
482311|223344556677885f5f5f5f5f5f	64	gnu	and (%rcx),%rdx
482311|223344556677885f5f5f5f5f5f	64	intel	and rdx, qword ptr [rcx]
482311|223344556677885f5f5f5f5f5f	64	plan9	ANDQ 0(CX), DX
482511223344|556677885f5f5f5f5f5f	64	gnu	and $0x44332211,%rax
482511223344|556677885f5f5f5f5f5f	64	intel	and rax, 0x44332211
482511223344|556677885f5f5f5f5f5f	64	plan9	ANDQ $0x44332211, AX
482911|223344556677885f5f5f5f5f5f	64	gnu	sub %rdx,(%rcx)
482911|223344556677885f5f5f5f5f5f	64	intel	sub qword ptr [rcx], rdx
482911|223344556677885f5f5f5f5f5f	64	plan9	SUBQ DX, 0(CX)
482b11|223344556677885f5f5f5f5f5f	64	gnu	sub (%rcx),%rdx
482b11|223344556677885f5f5f5f5f5f	64	intel	sub rdx, qword ptr [rcx]
482b11|223344556677885f5f5f5f5f5f	64	plan9	SUBQ 0(CX), DX
482d11223344|556677885f5f5f5f5f5f	64	gnu	sub $0x44332211,%rax
482d11223344|556677885f5f5f5f5f5f	64	intel	sub rax, 0x44332211
482d11223344|556677885f5f5f5f5f5f	64	plan9	SUBQ $0x44332211, AX
483111|223344556677885f5f5f5f5f5f	64	gnu	xor %rdx,(%rcx)
483111|223344556677885f5f5f5f5f5f	64	intel	xor qword ptr [rcx], rdx
483111|223344556677885f5f5f5f5f5f	64	plan9	XORQ DX, 0(CX)
483311|223344556677885f5f5f5f5f5f	64	gnu	xor (%rcx),%rdx
483311|223344556677885f5f5f5f5f5f	64	intel	xor rdx, qword ptr [rcx]
483311|223344556677885f5f5f5f5f5f	64	plan9	XORQ 0(CX), DX
483511223344|556677885f5f5f5f5f5f	64	gnu	xor $0x44332211,%rax
483511223344|556677885f5f5f5f5f5f	64	intel	xor rax, 0x44332211
483511223344|556677885f5f5f5f5f5f	64	plan9	XORQ $0x44332211, AX
483911|223344556677885f5f5f5f5f5f	64	gnu	cmp %rdx,(%rcx)
483911|223344556677885f5f5f5f5f5f	64	intel	cmp qword ptr [rcx], rdx
483911|223344556677885f5f5f5f5f5f	64	plan9	CMPQ DX, 0(CX)
483b11|223344556677885f5f5f5f5f5f	64	gnu	cmp (%rcx),%rdx
483b11|223344556677885f5f5f5f5f5f	64	intel	cmp rdx, qword ptr [rcx]
483b11|223344556677885f5f5f5f5f5f	64	plan9	CMPQ 0(CX), DX
483d11223344|556677885f5f5f5f5f5f	64	gnu	cmp $0x44332211,%rax
483d11223344|556677885f5f5f5f5f5f	64	intel	cmp rax, 0x44332211
483d11223344|556677885f5f5f5f5f5f	64	plan9	CMPQ $0x44332211, AX
4850|11223344556677885f5f5f5f5f5f	64	gnu	push %rax
4850|11223344556677885f5f5f5f5f5f	64	intel	push rax
4850|11223344556677885f5f5f5f5f5f	64	plan9	PUSHQ AX
4858|11223344556677885f5f5f5f5f5f	64	gnu	pop %rax
4858|11223344556677885f5f5f5f5f5f	64	intel	pop rax
4858|11223344556677885f5f5f5f5f5f	64	plan9	POPQ AX
486311|223344556677885f5f5f5f5f5f	64	gnu	movsxd (%rcx),%rdx
486311|223344556677885f5f5f5f5f5f	64	intel	movsxd rdx, dword ptr [rcx]
486311|223344556677885f5f5f5f5f5f	64	plan9	MOVSXD 0(CX), DX
486811223344|556677885f5f5f5f5f5f	64	gnu	pushq $0x44332211
486811223344|556677885f5f5f5f5f5f	64	intel	push 0x44332211
486811223344|556677885f5f5f5f5f5f	64	plan9	PUSHQ $0x44332211
48691122334455|6677885f5f5f5f5f5f	64	gnu	imul $0x55443322,(%rcx),%rdx
48691122334455|6677885f5f5f5f5f5f	64	intel	imul rdx, qword ptr [rcx], 0x55443322
48691122334455|6677885f5f5f5f5f5f	64	plan9	IMULQ $0x55443322, 0(CX), DX
486b1122|3344556677885f5f5f5f5f5f	64	gnu	imul $0x22,(%rcx),%rdx
486b1122|3344556677885f5f5f5f5f5f	64	intel	imul rdx, qword ptr [rcx], 0x22
486b1122|3344556677885f5f5f5f5f5f	64	plan9	IMULQ $0x22, 0(CX), DX
486d|11223344556677885f5f5f5f5f5f	64	gnu	insl (%dx),%es:(%rdi)
486d|11223344556677885f5f5f5f5f5f	64	intel	insd
486d|11223344556677885f5f5f5f5f5f	64	plan9	INSD DX, ES:0(DI)
486f|11223344556677885f5f5f5f5f5f	64	gnu	outsl %ds:(%rsi),(%dx)
486f|11223344556677885f5f5f5f5f5f	64	intel	outsd
486f|11223344556677885f5f5f5f5f5f	64	plan9	OUTSD DS:0(SI), DX
48810011223344|556677885f5f5f5f5f	64	gnu	addq $0x44332211,(%rax)
48810011223344|556677885f5f5f5f5f	64	intel	add qword ptr [rax], 0x44332211
48810011223344|556677885f5f5f5f5f	64	plan9	ADDQ $0x44332211, 0(AX)
48810811223344|556677885f5f5f5f5f	64	gnu	orq $0x44332211,(%rax)
48810811223344|556677885f5f5f5f5f	64	intel	or qword ptr [rax], 0x44332211
48810811223344|556677885f5f5f5f5f	64	plan9	ORQ $0x44332211, 0(AX)
48811122334455|6677885f5f5f5f5f5f	64	gnu	adcq $0x55443322,(%rcx)
48811122334455|6677885f5f5f5f5f5f	64	intel	adc qword ptr [rcx], 0x55443322
48811122334455|6677885f5f5f5f5f5f	64	plan9	ADCQ $0x55443322, 0(CX)
48811811223344|556677885f5f5f5f5f	64	gnu	sbbq $0x44332211,(%rax)
48811811223344|556677885f5f5f5f5f	64	intel	sbb qword ptr [rax], 0x44332211
48811811223344|556677885f5f5f5f5f	64	plan9	SBBQ $0x44332211, 0(AX)
48812011223344|556677885f5f5f5f5f	64	gnu	andq $0x44332211,(%rax)
48812011223344|556677885f5f5f5f5f	64	intel	and qword ptr [rax], 0x44332211
48812011223344|556677885f5f5f5f5f	64	plan9	ANDQ $0x44332211, 0(AX)
48812811223344|556677885f5f5f5f5f	64	gnu	subq $0x44332211,(%rax)
48812811223344|556677885f5f5f5f5f	64	intel	sub qword ptr [rax], 0x44332211
48812811223344|556677885f5f5f5f5f	64	plan9	SUBQ $0x44332211, 0(AX)
48813011223344|556677885f5f5f5f5f	64	gnu	xorq $0x44332211,(%rax)
48813011223344|556677885f5f5f5f5f	64	intel	xor qword ptr [rax], 0x44332211
48813011223344|556677885f5f5f5f5f	64	plan9	XORQ $0x44332211, 0(AX)
48813811223344|556677885f5f5f5f5f	64	gnu	cmpq $0x44332211,(%rax)
48813811223344|556677885f5f5f5f5f	64	intel	cmp qword ptr [rax], 0x44332211
48813811223344|556677885f5f5f5f5f	64	plan9	CMPQ $0x44332211, 0(AX)
48830011|223344556677885f5f5f5f5f	64	gnu	addq $0x11,(%rax)
48830011|223344556677885f5f5f5f5f	64	intel	add qword ptr [rax], 0x11
48830011|223344556677885f5f5f5f5f	64	plan9	ADDQ $0x11, 0(AX)
48830811|223344556677885f5f5f5f5f	64	gnu	orq $0x11,(%rax)
48830811|223344556677885f5f5f5f5f	64	intel	or qword ptr [rax], 0x11
48830811|223344556677885f5f5f5f5f	64	plan9	ORQ $0x11, 0(AX)
48831122|3344556677885f5f5f5f5f5f	64	gnu	adcq $0x22,(%rcx)
48831122|3344556677885f5f5f5f5f5f	64	intel	adc qword ptr [rcx], 0x22
48831122|3344556677885f5f5f5f5f5f	64	plan9	ADCQ $0x22, 0(CX)
48831811|223344556677885f5f5f5f5f	64	gnu	sbbq $0x11,(%rax)
48831811|223344556677885f5f5f5f5f	64	intel	sbb qword ptr [rax], 0x11
48831811|223344556677885f5f5f5f5f	64	plan9	SBBQ $0x11, 0(AX)
48832011|223344556677885f5f5f5f5f	64	gnu	andq $0x11,(%rax)
48832011|223344556677885f5f5f5f5f	64	intel	and qword ptr [rax], 0x11
48832011|223344556677885f5f5f5f5f	64	plan9	ANDQ $0x11, 0(AX)
48832811|223344556677885f5f5f5f5f	64	gnu	subq $0x11,(%rax)
48832811|223344556677885f5f5f5f5f	64	intel	sub qword ptr [rax], 0x11
48832811|223344556677885f5f5f5f5f	64	plan9	SUBQ $0x11, 0(AX)
48833011|223344556677885f5f5f5f5f	64	gnu	xorq $0x11,(%rax)
48833011|223344556677885f5f5f5f5f	64	intel	xor qword ptr [rax], 0x11
48833011|223344556677885f5f5f5f5f	64	plan9	XORQ $0x11, 0(AX)
48833811|223344556677885f5f5f5f5f	64	gnu	cmpq $0x11,(%rax)
48833811|223344556677885f5f5f5f5f	64	intel	cmp qword ptr [rax], 0x11
48833811|223344556677885f5f5f5f5f	64	plan9	CMPQ $0x11, 0(AX)
488511|223344556677885f5f5f5f5f5f	64	gnu	test %rdx,(%rcx)
488511|223344556677885f5f5f5f5f5f	64	intel	test qword ptr [rcx], rdx
488511|223344556677885f5f5f5f5f5f	64	plan9	TESTQ DX, 0(CX)
488711|223344556677885f5f5f5f5f5f	64	gnu	xchg %rdx,(%rcx)
488711|223344556677885f5f5f5f5f5f	64	intel	xchg qword ptr [rcx], rdx
488711|223344556677885f5f5f5f5f5f	64	plan9	XCHGQ DX, 0(CX)
488911|223344556677885f5f5f5f5f5f	64	gnu	mov %rdx,(%rcx)
488911|223344556677885f5f5f5f5f5f	64	intel	mov qword ptr [rcx], rdx
488911|223344556677885f5f5f5f5f5f	64	plan9	MOVQ DX, 0(CX)
488b11|223344556677885f5f5f5f5f5f	64	gnu	mov (%rcx),%rdx
488b11|223344556677885f5f5f5f5f5f	64	intel	mov rdx, qword ptr [rcx]
488b11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ 0(CX), DX
488c11|223344556677885f5f5f5f5f5f	64	gnu	mov %ss,(%rcx)
488c11|223344556677885f5f5f5f5f5f	64	intel	mov word ptr [rcx], ss
488c11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ SS, 0(CX)
488d11|223344556677885f5f5f5f5f5f	64	gnu	lea (%rcx),%rdx
488d11|223344556677885f5f5f5f5f5f	64	intel	lea rdx, ptr [rcx]
488d11|223344556677885f5f5f5f5f5f	64	plan9	LEAQ 0(CX), DX
488e11|223344556677885f5f5f5f5f5f	64	gnu	mov (%rcx),%ss
488e11|223344556677885f5f5f5f5f5f	64	intel	mov ss, word ptr [rcx]
488e11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ 0(CX), SS
488f00|11223344556677885f5f5f5f5f	64	gnu	popq (%rax)
488f00|11223344556677885f5f5f5f5f	64	intel	pop qword ptr [rax]
488f00|11223344556677885f5f5f5f5f	64	plan9	POPQ 0(AX)
4891|11223344556677885f5f5f5f5f5f	64	gnu	xchg %rax,%rcx
4891|11223344556677885f5f5f5f5f5f	64	intel	xchg rcx, rax
4891|11223344556677885f5f5f5f5f5f	64	plan9	XCHGQ AX, CX
4898|11223344556677885f5f5f5f5f5f	64	gnu	cdqe
4898|11223344556677885f5f5f5f5f5f	64	intel	cdqe
4898|11223344556677885f5f5f5f5f5f	64	plan9	CDQE
4899|11223344556677885f5f5f5f5f5f	64	gnu	cqto
4899|11223344556677885f5f5f5f5f5f	64	intel	cqo
4899|11223344556677885f5f5f5f5f5f	64	plan9	CQO
489c|11223344556677885f5f5f5f5f5f	64	gnu	pushfq
489c|11223344556677885f5f5f5f5f5f	64	intel	pushfq
489c|11223344556677885f5f5f5f5f5f	64	plan9	PUSHFQ
489d|11223344556677885f5f5f5f5f5f	64	gnu	popfq
489d|11223344556677885f5f5f5f5f5f	64	intel	popfq
489d|11223344556677885f5f5f5f5f5f	64	plan9	POPFQ
48a01122334455667788|5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%al
48a01122334455667788|5f5f5f5f5f5f	64	intel	mov al, byte ptr [0x8877665544332211]
48a01122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ -0x778899aabbccddef, AL
48a11122334455667788|5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%rax
48a11122334455667788|5f5f5f5f5f5f	64	intel	mov rax, qword ptr [0x8877665544332211]
48a11122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ -0x778899aabbccddef, AX
48a21122334455667788|5f5f5f5f5f5f	64	gnu	mov %al,-0x778899aabbccddef
48a21122334455667788|5f5f5f5f5f5f	64	intel	mov byte ptr [0x8877665544332211], al
48a21122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ AL, -0x778899aabbccddef
48a31122334455667788|5f5f5f5f5f5f	64	gnu	mov %rax,-0x778899aabbccddef
48a31122334455667788|5f5f5f5f5f5f	64	intel	mov qword ptr [0x8877665544332211], rax
48a31122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ AX, -0x778899aabbccddef
48a5|11223344556677885f5f5f5f5f5f	64	gnu	movsq %ds:(%rsi),%es:(%rdi)
48a5|11223344556677885f5f5f5f5f5f	64	intel	movsq qword ptr [rdi], qword ptr [rsi]
48a5|11223344556677885f5f5f5f5f5f	64	plan9	MOVSQ DS:0(SI), ES:0(DI)
48a7|11223344556677885f5f5f5f5f5f	64	gnu	cmpsq %es:(%rdi),%ds:(%rsi)
48a7|11223344556677885f5f5f5f5f5f	64	intel	cmpsq qword ptr [rsi], qword ptr [rdi]
48a7|11223344556677885f5f5f5f5f5f	64	plan9	CMPSQ ES:0(DI), DS:0(SI)
48a911223344|556677885f5f5f5f5f5f	64	gnu	test $0x44332211,%rax
48a911223344|556677885f5f5f5f5f5f	64	intel	test rax, 0x44332211
48a911223344|556677885f5f5f5f5f5f	64	plan9	TESTQ $0x44332211, AX
48ab|11223344556677885f5f5f5f5f5f	64	gnu	stos %rax,%es:(%rdi)
48ab|11223344556677885f5f5f5f5f5f	64	intel	stosq qword ptr [rdi]
48ab|11223344556677885f5f5f5f5f5f	64	plan9	STOSQ AX, ES:0(DI)
48ad|11223344556677885f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%rax
48ad|11223344556677885f5f5f5f5f5f	64	intel	lodsq qword ptr [rsi]
48ad|11223344556677885f5f5f5f5f5f	64	plan9	LODSQ DS:0(SI), AX
48af|11223344556677885f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%rax
48af|11223344556677885f5f5f5f5f5f	64	intel	scasq qword ptr [rdi]
48af|11223344556677885f5f5f5f5f5f	64	plan9	SCASQ ES:0(DI), AX
48b81122334455667788|5f5f5f5f5f5f	64	gnu	mov $-0x778899aabbccddef,%rax
48b81122334455667788|5f5f5f5f5f5f	64	intel	mov rax, 0x8877665544332211
48b81122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ $0x8877665544332211, AX
48c10011|223344556677885f5f5f5f5f	64	gnu	rolq $0x11,(%rax)
48c10011|223344556677885f5f5f5f5f	64	intel	rol qword ptr [rax], 0x11
48c10011|223344556677885f5f5f5f5f	64	plan9	ROLQ $0x11, 0(AX)
48c10811|223344556677885f5f5f5f5f	64	gnu	rorq $0x11,(%rax)
48c10811|223344556677885f5f5f5f5f	64	intel	ror qword ptr [rax], 0x11
48c10811|223344556677885f5f5f5f5f	64	plan9	RORQ $0x11, 0(AX)
48c11122|3344556677885f5f5f5f5f5f	64	gnu	rclq $0x22,(%rcx)
48c11122|3344556677885f5f5f5f5f5f	64	intel	rcl qword ptr [rcx], 0x22
48c11122|3344556677885f5f5f5f5f5f	64	plan9	RCLQ $0x22, 0(CX)
48c11811|223344556677885f5f5f5f5f	64	gnu	rcrq $0x11,(%rax)
48c11811|223344556677885f5f5f5f5f	64	intel	rcr qword ptr [rax], 0x11
48c11811|223344556677885f5f5f5f5f	64	plan9	RCRQ $0x11, 0(AX)
48c12011|223344556677885f5f5f5f5f	64	gnu	shlq $0x11,(%rax)
48c12011|223344556677885f5f5f5f5f	64	intel	shl qword ptr [rax], 0x11
48c12011|223344556677885f5f5f5f5f	64	plan9	SHLQ $0x11, 0(AX)
48c12811|223344556677885f5f5f5f5f	64	gnu	shrq $0x11,(%rax)
48c12811|223344556677885f5f5f5f5f	64	intel	shr qword ptr [rax], 0x11
48c12811|223344556677885f5f5f5f5f	64	plan9	SHRQ $0x11, 0(AX)
48c13811|223344556677885f5f5f5f5f	64	gnu	sarq $0x11,(%rax)
48c13811|223344556677885f5f5f5f5f	64	intel	sar qword ptr [rax], 0x11
48c13811|223344556677885f5f5f5f5f	64	plan9	SARQ $0x11, 0(AX)
48c70011223344|556677885f5f5f5f5f	64	gnu	movq $0x44332211,(%rax)
48c70011223344|556677885f5f5f5f5f	64	intel	mov qword ptr [rax], 0x44332211
48c70011223344|556677885f5f5f5f5f	64	plan9	MOVQ $0x44332211, 0(AX)
48c7f811223344|556677885f5f5f5f5f	64	gnu	xbeginq .+0x44332211
48c7f811223344|556677885f5f5f5f5f	64	intel	xbegin .+0x44332211
48c7f811223344|556677885f5f5f5f5f	64	plan9	XBEGIN .+1144201745
48c9|11223344556677885f5f5f5f5f5f	64	gnu	leaveq
48c9|11223344556677885f5f5f5f5f5f	64	intel	leave
48c9|11223344556677885f5f5f5f5f5f	64	plan9	LEAVE
48cf|11223344556677885f5f5f5f5f5f	64	gnu	iretq
48cf|11223344556677885f5f5f5f5f5f	64	intel	iretq
48cf|11223344556677885f5f5f5f5f5f	64	plan9	IRETQ
48d100|11223344556677885f5f5f5f5f	64	gnu	rolq (%rax)
48d100|11223344556677885f5f5f5f5f	64	intel	rol qword ptr [rax], 0x1
48d100|11223344556677885f5f5f5f5f	64	plan9	ROLQ $0x1, 0(AX)
48d108|11223344556677885f5f5f5f5f	64	gnu	rorq (%rax)
48d108|11223344556677885f5f5f5f5f	64	intel	ror qword ptr [rax], 0x1
48d108|11223344556677885f5f5f5f5f	64	plan9	RORQ $0x1, 0(AX)
48d111|223344556677885f5f5f5f5f5f	64	gnu	rclq (%rcx)
48d111|223344556677885f5f5f5f5f5f	64	intel	rcl qword ptr [rcx], 0x1
48d111|223344556677885f5f5f5f5f5f	64	plan9	RCLQ $0x1, 0(CX)
48d118|11223344556677885f5f5f5f5f	64	gnu	rcrq (%rax)
48d118|11223344556677885f5f5f5f5f	64	intel	rcr qword ptr [rax], 0x1
48d118|11223344556677885f5f5f5f5f	64	plan9	RCRQ $0x1, 0(AX)
48d120|11223344556677885f5f5f5f5f	64	gnu	shlq (%rax)
48d120|11223344556677885f5f5f5f5f	64	intel	shl qword ptr [rax], 0x1
48d120|11223344556677885f5f5f5f5f	64	plan9	SHLQ $0x1, 0(AX)
48d128|11223344556677885f5f5f5f5f	64	gnu	shrq (%rax)
48d128|11223344556677885f5f5f5f5f	64	intel	shr qword ptr [rax], 0x1
48d128|11223344556677885f5f5f5f5f	64	plan9	SHRQ $0x1, 0(AX)
48d138|11223344556677885f5f5f5f5f	64	gnu	sarq (%rax)
48d138|11223344556677885f5f5f5f5f	64	intel	sar qword ptr [rax], 0x1
48d138|11223344556677885f5f5f5f5f	64	plan9	SARQ $0x1, 0(AX)
48d300|11223344556677885f5f5f5f5f	64	gnu	rolq %cl,(%rax)
48d300|11223344556677885f5f5f5f5f	64	intel	rol qword ptr [rax], cl
48d300|11223344556677885f5f5f5f5f	64	plan9	ROLQ CL, 0(AX)
48d308|11223344556677885f5f5f5f5f	64	gnu	rorq %cl,(%rax)
48d308|11223344556677885f5f5f5f5f	64	intel	ror qword ptr [rax], cl
48d308|11223344556677885f5f5f5f5f	64	plan9	RORQ CL, 0(AX)
48d311|223344556677885f5f5f5f5f5f	64	gnu	rclq %cl,(%rcx)
48d311|223344556677885f5f5f5f5f5f	64	intel	rcl qword ptr [rcx], cl
48d311|223344556677885f5f5f5f5f5f	64	plan9	RCLQ CL, 0(CX)
48d318|11223344556677885f5f5f5f5f	64	gnu	rcrq %cl,(%rax)
48d318|11223344556677885f5f5f5f5f	64	intel	rcr qword ptr [rax], cl
48d318|11223344556677885f5f5f5f5f	64	plan9	RCRQ CL, 0(AX)
48d320|11223344556677885f5f5f5f5f	64	gnu	shlq %cl,(%rax)
48d320|11223344556677885f5f5f5f5f	64	intel	shl qword ptr [rax], cl
48d320|11223344556677885f5f5f5f5f	64	plan9	SHLQ CL, 0(AX)
48d328|11223344556677885f5f5f5f5f	64	gnu	shrq %cl,(%rax)
48d328|11223344556677885f5f5f5f5f	64	intel	shr qword ptr [rax], cl
48d328|11223344556677885f5f5f5f5f	64	plan9	SHRQ CL, 0(AX)
48d338|11223344556677885f5f5f5f5f	64	gnu	sarq %cl,(%rax)
48d338|11223344556677885f5f5f5f5f	64	intel	sar qword ptr [rax], cl
48d338|11223344556677885f5f5f5f5f	64	plan9	SARQ CL, 0(AX)
48d7|11223344556677885f5f5f5f5f5f	64	gnu	xlat %ds:(%rbx)
48d7|11223344556677885f5f5f5f5f5f	64	intel	xlat
48d7|11223344556677885f5f5f5f5f5f	64	plan9	XLATB DS:0(BX)
48e511|223344556677885f5f5f5f5f5f	64	gnu	in $0x11,%eax
48e511|223344556677885f5f5f5f5f5f	64	intel	in eax, 0x11
48e511|223344556677885f5f5f5f5f5f	64	plan9	INQ $0x11, AX
48e711|223344556677885f5f5f5f5f5f	64	gnu	out %eax,$0x11
48e711|223344556677885f5f5f5f5f5f	64	intel	out 0x11, eax
48e711|223344556677885f5f5f5f5f5f	64	plan9	OUTQ AX, $0x11
48e811223344|556677885f5f5f5f5f5f	64	gnu	callq .+0x44332211
48e811223344|556677885f5f5f5f5f5f	64	intel	call .+0x44332211
48e811223344|556677885f5f5f5f5f5f	64	plan9	CALL .+1144201745
48e911223344|556677885f5f5f5f5f5f	64	gnu	jmpq .+0x44332211
48e911223344|556677885f5f5f5f5f5f	64	intel	jmp .+0x44332211
48e911223344|556677885f5f5f5f5f5f	64	plan9	JMP .+1144201745
48ed|11223344556677885f5f5f5f5f5f	64	gnu	in (%dx),%eax
48ed|11223344556677885f5f5f5f5f5f	64	intel	in eax, dx
48ed|11223344556677885f5f5f5f5f5f	64	plan9	INQ DX, AX
48ef|11223344556677885f5f5f5f5f5f	64	gnu	out %eax,(%dx)
48ef|11223344556677885f5f5f5f5f5f	64	intel	out dx, eax
48ef|11223344556677885f5f5f5f5f5f	64	plan9	OUTQ AX, DX
48f70011223344|556677885f5f5f5f5f	64	gnu	testq $0x44332211,(%rax)
48f70011223344|556677885f5f5f5f5f	64	intel	test qword ptr [rax], 0x44332211
48f70011223344|556677885f5f5f5f5f	64	plan9	TESTQ $0x44332211, 0(AX)
48f711|223344556677885f5f5f5f5f5f	64	gnu	notq (%rcx)
48f711|223344556677885f5f5f5f5f5f	64	intel	not qword ptr [rcx]
48f711|223344556677885f5f5f5f5f5f	64	plan9	NOTQ 0(CX)
48f718|11223344556677885f5f5f5f5f	64	gnu	negq (%rax)
48f718|11223344556677885f5f5f5f5f	64	intel	neg qword ptr [rax]
48f718|11223344556677885f5f5f5f5f	64	plan9	NEGQ 0(AX)
48f720|11223344556677885f5f5f5f5f	64	gnu	mulq (%rax)
48f720|11223344556677885f5f5f5f5f	64	intel	mul qword ptr [rax]
48f720|11223344556677885f5f5f5f5f	64	plan9	MULQ 0(AX)
48f728|11223344556677885f5f5f5f5f	64	gnu	imulq (%rax)
48f728|11223344556677885f5f5f5f5f	64	intel	imul qword ptr [rax]
48f728|11223344556677885f5f5f5f5f	64	plan9	IMULQ 0(AX)
48f730|11223344556677885f5f5f5f5f	64	gnu	divq (%rax)
48f730|11223344556677885f5f5f5f5f	64	intel	div qword ptr [rax]
48f730|11223344556677885f5f5f5f5f	64	plan9	DIVQ 0(AX)
48f738|11223344556677885f5f5f5f5f	64	gnu	idivq (%rax)
48f738|11223344556677885f5f5f5f5f	64	intel	idiv qword ptr [rax]
48f738|11223344556677885f5f5f5f5f	64	plan9	IDIVQ 0(AX)
48ff00|11223344556677885f5f5f5f5f	64	gnu	incq (%rax)
48ff00|11223344556677885f5f5f5f5f	64	intel	inc qword ptr [rax]
48ff00|11223344556677885f5f5f5f5f	64	plan9	INCQ 0(AX)
48ff08|11223344556677885f5f5f5f5f	64	gnu	decq (%rax)
48ff08|11223344556677885f5f5f5f5f	64	intel	dec qword ptr [rax]
48ff08|11223344556677885f5f5f5f5f	64	plan9	DECQ 0(AX)
48ff18|11223344556677885f5f5f5f5f	64	gnu	lcallq *(%rax)
48ff18|11223344556677885f5f5f5f5f	64	intel	call far ptr [rax]
48ff18|11223344556677885f5f5f5f5f	64	plan9	LCALL 0(AX)
48ff28|11223344556677885f5f5f5f5f	64	gnu	ljmpq *(%rax)
48ff28|11223344556677885f5f5f5f5f	64	intel	jmp far ptr [rax]
48ff28|11223344556677885f5f5f5f5f	64	plan9	LJMP 0(AX)
48ff30|11223344556677885f5f5f5f5f	64	gnu	pushq (%rax)
48ff30|11223344556677885f5f5f5f5f	64	intel	push qword ptr [rax]
48ff30|11223344556677885f5f5f5f5f	64	plan9	PUSHQ 0(AX)
48|010011223344556677885f5f5f5f5f	32	intel	dec eax
48|010011223344556677885f5f5f5f5f	32	plan9	DECL AX
50|11223344556677885f5f5f5f5f5f5f	32	intel	push eax
50|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL AX
50|11223344556677885f5f5f5f5f5f5f	64	gnu	push %rax
50|11223344556677885f5f5f5f5f5f5f	64	intel	push rax
50|11223344556677885f5f5f5f5f5f5f	64	plan9	PUSHL AX
58|11223344556677885f5f5f5f5f5f5f	32	intel	pop eax
58|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL AX
58|11223344556677885f5f5f5f5f5f5f	64	gnu	pop %rax
58|11223344556677885f5f5f5f5f5f5f	64	intel	pop rax
58|11223344556677885f5f5f5f5f5f5f	64	plan9	POPL AX
60|11223344556677885f5f5f5f5f5f5f	32	intel	pushad
60|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHAD
60|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
60|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
60|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
61|11223344556677885f5f5f5f5f5f5f	32	intel	popad
61|11223344556677885f5f5f5f5f5f5f	32	plan9	POPAD
61|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
61|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
61|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
6211|223344556677885f5f5f5f5f5f5f	32	intel	bound edx, qword ptr [ecx]
6211|223344556677885f5f5f5f5f5f5f	32	plan9	BOUND 0(CX), DX
62|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
62|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
62|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
6311|223344556677885f5f5f5f5f5f5f	32	intel	arpl word ptr [ecx], dx
6311|223344556677885f5f5f5f5f5f5f	32	plan9	ARPL DX, 0(CX)
6311|223344556677885f5f5f5f5f5f5f	64	gnu	movsxd (%rcx),%edx
6311|223344556677885f5f5f5f5f5f5f	64	intel	movsxd edx, dword ptr [rcx]
6311|223344556677885f5f5f5f5f5f5f	64	plan9	MOVSXD 0(CX), DX
660111|223344556677885f5f5f5f5f5f	32	intel	add word ptr [ecx], dx
660111|223344556677885f5f5f5f5f5f	32	plan9	ADDW DX, 0(CX)
660111|223344556677885f5f5f5f5f5f	64	gnu	add %dx,(%rcx)
660111|223344556677885f5f5f5f5f5f	64	intel	add word ptr [rcx], dx
660111|223344556677885f5f5f5f5f5f	64	plan9	ADDW DX, 0(CX)
660311|223344556677885f5f5f5f5f5f	32	intel	add dx, word ptr [ecx]
660311|223344556677885f5f5f5f5f5f	32	plan9	ADDW 0(CX), DX
660311|223344556677885f5f5f5f5f5f	64	gnu	add (%rcx),%dx
660311|223344556677885f5f5f5f5f5f	64	intel	add dx, word ptr [rcx]
660311|223344556677885f5f5f5f5f5f	64	plan9	ADDW 0(CX), DX
66051122|3344556677885f5f5f5f5f5f	32	intel	add ax, 0x2211
66051122|3344556677885f5f5f5f5f5f	32	plan9	ADDW $0x2211, AX
66051122|3344556677885f5f5f5f5f5f	64	gnu	add $0x2211,%ax
66051122|3344556677885f5f5f5f5f5f	64	intel	add ax, 0x2211
66051122|3344556677885f5f5f5f5f5f	64	plan9	ADDW $0x2211, AX
660911|223344556677885f5f5f5f5f5f	32	intel	or word ptr [ecx], dx
660911|223344556677885f5f5f5f5f5f	32	plan9	ORW DX, 0(CX)
660911|223344556677885f5f5f5f5f5f	64	gnu	or %dx,(%rcx)
660911|223344556677885f5f5f5f5f5f	64	intel	or word ptr [rcx], dx
660911|223344556677885f5f5f5f5f5f	64	plan9	ORW DX, 0(CX)
660b11|223344556677885f5f5f5f5f5f	32	intel	or dx, word ptr [ecx]
660b11|223344556677885f5f5f5f5f5f	32	plan9	ORW 0(CX), DX
660b11|223344556677885f5f5f5f5f5f	64	gnu	or (%rcx),%dx
660b11|223344556677885f5f5f5f5f5f	64	intel	or dx, word ptr [rcx]
660b11|223344556677885f5f5f5f5f5f	64	plan9	ORW 0(CX), DX
660d1122|3344556677885f5f5f5f5f5f	32	intel	or ax, 0x2211
660d1122|3344556677885f5f5f5f5f5f	32	plan9	ORW $0x2211, AX
660d1122|3344556677885f5f5f5f5f5f	64	gnu	or $0x2211,%ax
660d1122|3344556677885f5f5f5f5f5f	64	intel	or ax, 0x2211
660d1122|3344556677885f5f5f5f5f5f	64	plan9	ORW $0x2211, AX
660f0000|11223344556677885f5f5f5f	32	intel	sldt word ptr [eax]
660f0000|11223344556677885f5f5f5f	32	plan9	SLDT 0(AX)
660f0000|11223344556677885f5f5f5f	64	gnu	data16 sldt (%rax)
660f0000|11223344556677885f5f5f5f	64	intel	sldt word ptr [rax]
660f0000|11223344556677885f5f5f5f	64	plan9	SLDT 0(AX)
660f0008|11223344556677885f5f5f5f	32	intel	str word ptr [eax]
660f0008|11223344556677885f5f5f5f	32	plan9	STR 0(AX)
660f0008|11223344556677885f5f5f5f	64	gnu	data16 str (%rax)
660f0008|11223344556677885f5f5f5f	64	intel	str word ptr [rax]
660f0008|11223344556677885f5f5f5f	64	plan9	STR 0(AX)
660f01a611223344|556677885f5f5f5f	32	intel	smsw word ptr [esi+0x44332211]
660f01a611223344|556677885f5f5f5f	32	plan9	SMSW 0x44332211(SI)
660f01a611223344|556677885f5f5f5f	64	gnu	data16 smsw 0x44332211(%rsi)
660f01a611223344|556677885f5f5f5f	64	intel	smsw word ptr [rsi+0x44332211]
660f01a611223344|556677885f5f5f5f	64	plan9	SMSW 0x44332211(SI)
660f0211|223344556677885f5f5f5f5f	32	intel	lar dx, word ptr [ecx]
660f0211|223344556677885f5f5f5f5f	32	plan9	LAR 0(CX), DX
660f0211|223344556677885f5f5f5f5f	64	gnu	lar (%rcx),%dx
660f0211|223344556677885f5f5f5f5f	64	intel	lar dx, word ptr [rcx]
660f0211|223344556677885f5f5f5f5f	64	plan9	LAR 0(CX), DX
660f0311|223344556677885f5f5f5f5f	32	intel	lsl dx, word ptr [ecx]
660f0311|223344556677885f5f5f5f5f	32	plan9	LSL 0(CX), DX
660f0311|223344556677885f5f5f5f5f	64	gnu	lsl (%rcx),%dx
660f0311|223344556677885f5f5f5f5f	64	intel	lsl dx, word ptr [rcx]
660f0311|223344556677885f5f5f5f5f	64	plan9	LSL 0(CX), DX
660f1011|223344556677885f5f5f5f5f	32	intel	movupd xmm2, xmmword ptr [ecx]
660f1011|223344556677885f5f5f5f5f	32	plan9	MOVUPD 0(CX), X2
660f1011|223344556677885f5f5f5f5f	64	gnu	movupd (%rcx),%xmm2
660f1011|223344556677885f5f5f5f5f	64	intel	movupd xmm2, xmmword ptr [rcx]
660f1011|223344556677885f5f5f5f5f	64	plan9	MOVUPD 0(CX), X2
660f1122|3344556677885f5f5f5f5f5f	32	intel	movupd xmmword ptr [edx], xmm4
660f1122|3344556677885f5f5f5f5f5f	32	plan9	MOVUPD X4, 0(DX)
660f1122|3344556677885f5f5f5f5f5f	64	gnu	movupd %xmm4,(%rdx)
660f1122|3344556677885f5f5f5f5f5f	64	intel	movupd xmmword ptr [rdx], xmm4
660f1122|3344556677885f5f5f5f5f5f	64	plan9	MOVUPD X4, 0(DX)
660f1211|223344556677885f5f5f5f5f	32	intel	movlpd xmm2, qword ptr [ecx]
660f1211|223344556677885f5f5f5f5f	32	plan9	MOVLPD 0(CX), X2
660f1211|223344556677885f5f5f5f5f	64	gnu	movlpd (%rcx),%xmm2
660f1211|223344556677885f5f5f5f5f	64	intel	movlpd xmm2, qword ptr [rcx]
660f1211|223344556677885f5f5f5f5f	64	plan9	MOVLPD 0(CX), X2
660f1311|223344556677885f5f5f5f5f	32	intel	movlpd qword ptr [ecx], xmm2
660f1311|223344556677885f5f5f5f5f	32	plan9	MOVLPD X2, 0(CX)
660f1311|223344556677885f5f5f5f5f	64	gnu	movlpd %xmm2,(%rcx)
660f1311|223344556677885f5f5f5f5f	64	intel	movlpd qword ptr [rcx], xmm2
660f1311|223344556677885f5f5f5f5f	64	plan9	MOVLPD X2, 0(CX)
660f1411|223344556677885f5f5f5f5f	32	intel	unpcklpd xmm2, xmmword ptr [ecx]
660f1411|223344556677885f5f5f5f5f	32	plan9	UNPCKLPD 0(CX), X2
660f1411|223344556677885f5f5f5f5f	64	gnu	unpcklpd (%rcx),%xmm2
660f1411|223344556677885f5f5f5f5f	64	intel	unpcklpd xmm2, xmmword ptr [rcx]
660f1411|223344556677885f5f5f5f5f	64	plan9	UNPCKLPD 0(CX), X2
660f1511|223344556677885f5f5f5f5f	32	intel	unpckhpd xmm2, xmmword ptr [ecx]
660f1511|223344556677885f5f5f5f5f	32	plan9	UNPCKHPD 0(CX), X2
660f1511|223344556677885f5f5f5f5f	64	gnu	unpckhpd (%rcx),%xmm2
660f1511|223344556677885f5f5f5f5f	64	intel	unpckhpd xmm2, xmmword ptr [rcx]
660f1511|223344556677885f5f5f5f5f	64	plan9	UNPCKHPD 0(CX), X2
660f1611|223344556677885f5f5f5f5f	32	intel	movhpd xmm2, qword ptr [ecx]
660f1611|223344556677885f5f5f5f5f	32	plan9	MOVHPD 0(CX), X2
660f1611|223344556677885f5f5f5f5f	64	gnu	movhpd (%rcx),%xmm2
660f1611|223344556677885f5f5f5f5f	64	intel	movhpd xmm2, qword ptr [rcx]
660f1611|223344556677885f5f5f5f5f	64	plan9	MOVHPD 0(CX), X2
660f1711|223344556677885f5f5f5f5f	32	intel	movhpd qword ptr [ecx], xmm2
660f1711|223344556677885f5f5f5f5f	32	plan9	MOVHPD X2, 0(CX)
660f1711|223344556677885f5f5f5f5f	64	gnu	movhpd %xmm2,(%rcx)
660f1711|223344556677885f5f5f5f5f	64	intel	movhpd qword ptr [rcx], xmm2
660f1711|223344556677885f5f5f5f5f	64	plan9	MOVHPD X2, 0(CX)
660f1f00|11223344556677885f5f5f5f	32	intel	nop word ptr [eax], ax
660f1f00|11223344556677885f5f5f5f	32	plan9	NOPW 0(AX)
660f1f00|11223344556677885f5f5f5f	64	gnu	nopw (%rax)
660f1f00|11223344556677885f5f5f5f	64	intel	nop word ptr [rax], ax
660f1f00|11223344556677885f5f5f5f	64	plan9	NOPW 0(AX)
660f2811|223344556677885f5f5f5f5f	32	intel	movapd xmm2, xmmword ptr [ecx]
660f2811|223344556677885f5f5f5f5f	32	plan9	MOVAPD 0(CX), X2
660f2811|223344556677885f5f5f5f5f	64	gnu	movapd (%rcx),%xmm2
660f2811|223344556677885f5f5f5f5f	64	intel	movapd xmm2, xmmword ptr [rcx]
660f2811|223344556677885f5f5f5f5f	64	plan9	MOVAPD 0(CX), X2
660f2911|223344556677885f5f5f5f5f	32	intel	movapd xmmword ptr [ecx], xmm2
660f2911|223344556677885f5f5f5f5f	32	plan9	MOVAPD X2, 0(CX)
660f2911|223344556677885f5f5f5f5f	64	gnu	movapd %xmm2,(%rcx)
660f2911|223344556677885f5f5f5f5f	64	intel	movapd xmmword ptr [rcx], xmm2
660f2911|223344556677885f5f5f5f5f	64	plan9	MOVAPD X2, 0(CX)
660f2a11|223344556677885f5f5f5f5f	32	intel	cvtpi2pd xmm2, qword ptr [ecx]
660f2a11|223344556677885f5f5f5f5f	32	plan9	CVTPI2PD 0(CX), X2
660f2a11|223344556677885f5f5f5f5f	64	gnu	cvtpi2pd (%rcx),%xmm2
660f2a11|223344556677885f5f5f5f5f	64	intel	cvtpi2pd xmm2, qword ptr [rcx]
660f2a11|223344556677885f5f5f5f5f	64	plan9	CVTPI2PD 0(CX), X2
660f2b11|223344556677885f5f5f5f5f	32	intel	movntpd xmmword ptr [ecx], xmm2
660f2b11|223344556677885f5f5f5f5f	32	plan9	MOVNTPD X2, 0(CX)
660f2b11|223344556677885f5f5f5f5f	64	gnu	movntpd %xmm2,(%rcx)
660f2b11|223344556677885f5f5f5f5f	64	intel	movntpd xmmword ptr [rcx], xmm2
660f2b11|223344556677885f5f5f5f5f	64	plan9	MOVNTPD X2, 0(CX)
660f2c11|223344556677885f5f5f5f5f	32	intel	cvttpd2pi mmx2, xmmword ptr [ecx]
660f2c11|223344556677885f5f5f5f5f	32	plan9	CVTTPD2PI 0(CX), M2
660f2c11|223344556677885f5f5f5f5f	64	gnu	cvttpd2pi (%rcx),%mm2
660f2c11|223344556677885f5f5f5f5f	64	intel	cvttpd2pi mmx2, xmmword ptr [rcx]
660f2c11|223344556677885f5f5f5f5f	64	plan9	CVTTPD2PI 0(CX), M2
660f2d11|223344556677885f5f5f5f5f	32	intel	cvtpd2pi mmx2, xmmword ptr [ecx]
660f2d11|223344556677885f5f5f5f5f	32	plan9	CVTPD2PI 0(CX), M2
660f2d11|223344556677885f5f5f5f5f	64	gnu	cvtpd2pi (%rcx),%mm2
660f2d11|223344556677885f5f5f5f5f	64	intel	cvtpd2pi mmx2, xmmword ptr [rcx]
660f2d11|223344556677885f5f5f5f5f	64	plan9	CVTPD2PI 0(CX), M2
660f2e11|223344556677885f5f5f5f5f	32	intel	ucomisd xmm2, qword ptr [ecx]
660f2e11|223344556677885f5f5f5f5f	32	plan9	UCOMISD 0(CX), X2
660f2e11|223344556677885f5f5f5f5f	64	gnu	ucomisd (%rcx),%xmm2
660f2e11|223344556677885f5f5f5f5f	64	intel	ucomisd xmm2, qword ptr [rcx]
660f2e11|223344556677885f5f5f5f5f	64	plan9	UCOMISD 0(CX), X2
660f2f11|223344556677885f5f5f5f5f	32	intel	comisd xmm2, qword ptr [ecx]
660f2f11|223344556677885f5f5f5f5f	32	plan9	COMISD 0(CX), X2
660f2f11|223344556677885f5f5f5f5f	64	gnu	comisd (%rcx),%xmm2
660f2f11|223344556677885f5f5f5f5f	64	intel	comisd xmm2, qword ptr [rcx]
660f2f11|223344556677885f5f5f5f5f	64	plan9	COMISD 0(CX), X2
660f380011|223344556677885f5f5f5f	32	intel	pshufb xmm2, xmmword ptr [ecx]
660f380011|223344556677885f5f5f5f	32	plan9	PSHUFB 0(CX), X2
660f380011|223344556677885f5f5f5f	64	gnu	pshufb (%rcx),%xmm2
660f380011|223344556677885f5f5f5f	64	intel	pshufb xmm2, xmmword ptr [rcx]
660f380011|223344556677885f5f5f5f	64	plan9	PSHUFB 0(CX), X2
660f380111|223344556677885f5f5f5f	32	intel	phaddw xmm2, xmmword ptr [ecx]
660f380111|223344556677885f5f5f5f	32	plan9	PHADDW 0(CX), X2
660f380111|223344556677885f5f5f5f	64	gnu	phaddw (%rcx),%xmm2
660f380111|223344556677885f5f5f5f	64	intel	phaddw xmm2, xmmword ptr [rcx]
660f380111|223344556677885f5f5f5f	64	plan9	PHADDW 0(CX), X2
660f380211|223344556677885f5f5f5f	32	intel	phaddd xmm2, xmmword ptr [ecx]
660f380211|223344556677885f5f5f5f	32	plan9	PHADDD 0(CX), X2
660f380211|223344556677885f5f5f5f	64	gnu	phaddd (%rcx),%xmm2
660f380211|223344556677885f5f5f5f	64	intel	phaddd xmm2, xmmword ptr [rcx]
660f380211|223344556677885f5f5f5f	64	plan9	PHADDD 0(CX), X2
660f380311|223344556677885f5f5f5f	32	intel	phaddsw xmm2, xmmword ptr [ecx]
660f380311|223344556677885f5f5f5f	32	plan9	PHADDSW 0(CX), X2
660f380311|223344556677885f5f5f5f	64	gnu	phaddsw (%rcx),%xmm2
660f380311|223344556677885f5f5f5f	64	intel	phaddsw xmm2, xmmword ptr [rcx]
660f380311|223344556677885f5f5f5f	64	plan9	PHADDSW 0(CX), X2
660f380411|223344556677885f5f5f5f	32	intel	pmaddubsw xmm2, xmmword ptr [ecx]
660f380411|223344556677885f5f5f5f	32	plan9	PMADDUBSW 0(CX), X2
660f380411|223344556677885f5f5f5f	64	gnu	pmaddubsw (%rcx),%xmm2
660f380411|223344556677885f5f5f5f	64	intel	pmaddubsw xmm2, xmmword ptr [rcx]
660f380411|223344556677885f5f5f5f	64	plan9	PMADDUBSW 0(CX), X2
660f380511|223344556677885f5f5f5f	32	intel	phsubw xmm2, xmmword ptr [ecx]
660f380511|223344556677885f5f5f5f	32	plan9	PHSUBW 0(CX), X2
660f380511|223344556677885f5f5f5f	64	gnu	phsubw (%rcx),%xmm2
660f380511|223344556677885f5f5f5f	64	intel	phsubw xmm2, xmmword ptr [rcx]
660f380511|223344556677885f5f5f5f	64	plan9	PHSUBW 0(CX), X2
660f380611|223344556677885f5f5f5f	32	intel	phsubd xmm2, xmmword ptr [ecx]
660f380611|223344556677885f5f5f5f	32	plan9	PHSUBD 0(CX), X2
660f380611|223344556677885f5f5f5f	64	gnu	phsubd (%rcx),%xmm2
660f380611|223344556677885f5f5f5f	64	intel	phsubd xmm2, xmmword ptr [rcx]
660f380611|223344556677885f5f5f5f	64	plan9	PHSUBD 0(CX), X2
660f380711|223344556677885f5f5f5f	32	intel	phsubsw xmm2, xmmword ptr [ecx]
660f380711|223344556677885f5f5f5f	32	plan9	PHSUBSW 0(CX), X2
660f380711|223344556677885f5f5f5f	64	gnu	phsubsw (%rcx),%xmm2
660f380711|223344556677885f5f5f5f	64	intel	phsubsw xmm2, xmmword ptr [rcx]
660f380711|223344556677885f5f5f5f	64	plan9	PHSUBSW 0(CX), X2
660f380811|223344556677885f5f5f5f	32	intel	psignb xmm2, xmmword ptr [ecx]
660f380811|223344556677885f5f5f5f	32	plan9	PSIGNB 0(CX), X2
660f380811|223344556677885f5f5f5f	64	gnu	psignb (%rcx),%xmm2
660f380811|223344556677885f5f5f5f	64	intel	psignb xmm2, xmmword ptr [rcx]
660f380811|223344556677885f5f5f5f	64	plan9	PSIGNB 0(CX), X2
660f380911|223344556677885f5f5f5f	32	intel	psignw xmm2, xmmword ptr [ecx]
660f380911|223344556677885f5f5f5f	32	plan9	PSIGNW 0(CX), X2
660f380911|223344556677885f5f5f5f	64	gnu	psignw (%rcx),%xmm2
660f380911|223344556677885f5f5f5f	64	intel	psignw xmm2, xmmword ptr [rcx]
660f380911|223344556677885f5f5f5f	64	plan9	PSIGNW 0(CX), X2
660f380a11|223344556677885f5f5f5f	32	intel	psignd xmm2, xmmword ptr [ecx]
660f380a11|223344556677885f5f5f5f	32	plan9	PSIGND 0(CX), X2
660f380a11|223344556677885f5f5f5f	64	gnu	psignd (%rcx),%xmm2
660f380a11|223344556677885f5f5f5f	64	intel	psignd xmm2, xmmword ptr [rcx]
660f380a11|223344556677885f5f5f5f	64	plan9	PSIGND 0(CX), X2
660f380b11|223344556677885f5f5f5f	32	intel	pmulhrsw xmm2, xmmword ptr [ecx]
660f380b11|223344556677885f5f5f5f	32	plan9	PMULHRSW 0(CX), X2
660f380b11|223344556677885f5f5f5f	64	gnu	pmulhrsw (%rcx),%xmm2
660f380b11|223344556677885f5f5f5f	64	intel	pmulhrsw xmm2, xmmword ptr [rcx]
660f380b11|223344556677885f5f5f5f	64	plan9	PMULHRSW 0(CX), X2
660f381011|223344556677885f5f5f5f	32	intel	pblendvb xmm2, xmmword ptr [ecx]
660f381011|223344556677885f5f5f5f	32	plan9	PBLENDVB X0, 0(CX), X2
660f381011|223344556677885f5f5f5f	64	gnu	pblendvb %xmm0,(%rcx),%xmm2
660f381011|223344556677885f5f5f5f	64	intel	pblendvb xmm2, xmmword ptr [rcx]
660f381011|223344556677885f5f5f5f	64	plan9	PBLENDVB X0, 0(CX), X2
660f381411|223344556677885f5f5f5f	32	intel	blendvps xmm2, xmmword ptr [ecx]
660f381411|223344556677885f5f5f5f	32	plan9	BLENDVPS X0, 0(CX), X2
660f381411|223344556677885f5f5f5f	64	gnu	blendvps %xmm0,(%rcx),%xmm2
660f381411|223344556677885f5f5f5f	64	intel	blendvps xmm2, xmmword ptr [rcx]
660f381411|223344556677885f5f5f5f	64	plan9	BLENDVPS X0, 0(CX), X2
660f381511|223344556677885f5f5f5f	32	intel	blendvpd xmm2, xmmword ptr [ecx]
660f381511|223344556677885f5f5f5f	32	plan9	BLENDVPD X0, 0(CX), X2
660f381511|223344556677885f5f5f5f	64	gnu	blendvpd %xmm0,(%rcx),%xmm2
660f381511|223344556677885f5f5f5f	64	intel	blendvpd xmm2, xmmword ptr [rcx]
660f381511|223344556677885f5f5f5f	64	plan9	BLENDVPD X0, 0(CX), X2
660f381711|223344556677885f5f5f5f	32	intel	ptest xmm2, xmmword ptr [ecx]
660f381711|223344556677885f5f5f5f	32	plan9	PTEST 0(CX), X2
660f381711|223344556677885f5f5f5f	64	gnu	ptest (%rcx),%xmm2
660f381711|223344556677885f5f5f5f	64	intel	ptest xmm2, xmmword ptr [rcx]
660f381711|223344556677885f5f5f5f	64	plan9	PTEST 0(CX), X2
660f381c11|223344556677885f5f5f5f	32	intel	pabsb xmm2, xmmword ptr [ecx]
660f381c11|223344556677885f5f5f5f	32	plan9	PABSB 0(CX), X2
660f381c11|223344556677885f5f5f5f	64	gnu	pabsb (%rcx),%xmm2
660f381c11|223344556677885f5f5f5f	64	intel	pabsb xmm2, xmmword ptr [rcx]
660f381c11|223344556677885f5f5f5f	64	plan9	PABSB 0(CX), X2
660f381d11|223344556677885f5f5f5f	32	intel	pabsw xmm2, xmmword ptr [ecx]
660f381d11|223344556677885f5f5f5f	32	plan9	PABSW 0(CX), X2
660f381d11|223344556677885f5f5f5f	64	gnu	pabsw (%rcx),%xmm2
660f381d11|223344556677885f5f5f5f	64	intel	pabsw xmm2, xmmword ptr [rcx]
660f381d11|223344556677885f5f5f5f	64	plan9	PABSW 0(CX), X2
660f381e11|223344556677885f5f5f5f	32	intel	pabsd xmm2, xmmword ptr [ecx]
660f381e11|223344556677885f5f5f5f	32	plan9	PABSD 0(CX), X2
660f381e11|223344556677885f5f5f5f	64	gnu	pabsd (%rcx),%xmm2
660f381e11|223344556677885f5f5f5f	64	intel	pabsd xmm2, xmmword ptr [rcx]
660f381e11|223344556677885f5f5f5f	64	plan9	PABSD 0(CX), X2
660f382011|223344556677885f5f5f5f	32	intel	pmovsxbw xmm2, qword ptr [ecx]
660f382011|223344556677885f5f5f5f	32	plan9	PMOVSXBW 0(CX), X2
660f382011|223344556677885f5f5f5f	64	gnu	pmovsxbw (%rcx),%xmm2
660f382011|223344556677885f5f5f5f	64	intel	pmovsxbw xmm2, qword ptr [rcx]
660f382011|223344556677885f5f5f5f	64	plan9	PMOVSXBW 0(CX), X2
660f382111|223344556677885f5f5f5f	32	intel	pmovsxbd xmm2, dword ptr [ecx]
660f382111|223344556677885f5f5f5f	32	plan9	PMOVSXBD 0(CX), X2
660f382111|223344556677885f5f5f5f	64	gnu	pmovsxbd (%rcx),%xmm2
660f382111|223344556677885f5f5f5f	64	intel	pmovsxbd xmm2, dword ptr [rcx]
660f382111|223344556677885f5f5f5f	64	plan9	PMOVSXBD 0(CX), X2
660f382211|223344556677885f5f5f5f	32	intel	pmovsxbq xmm2, word ptr [ecx]
660f382211|223344556677885f5f5f5f	32	plan9	PMOVSXBQ 0(CX), X2
660f382211|223344556677885f5f5f5f	64	gnu	pmovsxbq (%rcx),%xmm2
660f382211|223344556677885f5f5f5f	64	intel	pmovsxbq xmm2, word ptr [rcx]
660f382211|223344556677885f5f5f5f	64	plan9	PMOVSXBQ 0(CX), X2
660f382311|223344556677885f5f5f5f	32	intel	pmovsxwd xmm2, qword ptr [ecx]
660f382311|223344556677885f5f5f5f	32	plan9	PMOVSXWD 0(CX), X2
660f382311|223344556677885f5f5f5f	64	gnu	pmovsxwd (%rcx),%xmm2
660f382311|223344556677885f5f5f5f	64	intel	pmovsxwd xmm2, qword ptr [rcx]
660f382311|223344556677885f5f5f5f	64	plan9	PMOVSXWD 0(CX), X2
660f382411|223344556677885f5f5f5f	32	intel	pmovsxwq xmm2, dword ptr [ecx]
660f382411|223344556677885f5f5f5f	32	plan9	PMOVSXWQ 0(CX), X2
660f382411|223344556677885f5f5f5f	64	gnu	pmovsxwq (%rcx),%xmm2
660f382411|223344556677885f5f5f5f	64	intel	pmovsxwq xmm2, dword ptr [rcx]
660f382411|223344556677885f5f5f5f	64	plan9	PMOVSXWQ 0(CX), X2
660f382511|223344556677885f5f5f5f	32	intel	pmovsxdq xmm2, qword ptr [ecx]
660f382511|223344556677885f5f5f5f	32	plan9	PMOVSXDQ 0(CX), X2
660f382511|223344556677885f5f5f5f	64	gnu	pmovsxdq (%rcx),%xmm2
660f382511|223344556677885f5f5f5f	64	intel	pmovsxdq xmm2, qword ptr [rcx]
660f382511|223344556677885f5f5f5f	64	plan9	PMOVSXDQ 0(CX), X2
660f382811|223344556677885f5f5f5f	32	intel	pmuldq xmm2, xmmword ptr [ecx]
660f382811|223344556677885f5f5f5f	32	plan9	PMULDQ 0(CX), X2
660f382811|223344556677885f5f5f5f	64	gnu	pmuldq (%rcx),%xmm2
660f382811|223344556677885f5f5f5f	64	intel	pmuldq xmm2, xmmword ptr [rcx]
660f382811|223344556677885f5f5f5f	64	plan9	PMULDQ 0(CX), X2
660f382911|223344556677885f5f5f5f	32	intel	pcmpeqq xmm2, xmmword ptr [ecx]
660f382911|223344556677885f5f5f5f	32	plan9	PCMPEQQ 0(CX), X2
660f382911|223344556677885f5f5f5f	64	gnu	pcmpeqq (%rcx),%xmm2
660f382911|223344556677885f5f5f5f	64	intel	pcmpeqq xmm2, xmmword ptr [rcx]
660f382911|223344556677885f5f5f5f	64	plan9	PCMPEQQ 0(CX), X2
660f382a11|223344556677885f5f5f5f	32	intel	movntdqa xmm2, xmmword ptr [ecx]
660f382a11|223344556677885f5f5f5f	32	plan9	MOVNTDQA 0(CX), X2
660f382a11|223344556677885f5f5f5f	64	gnu	movntdqa (%rcx),%xmm2
660f382a11|223344556677885f5f5f5f	64	intel	movntdqa xmm2, xmmword ptr [rcx]
660f382a11|223344556677885f5f5f5f	64	plan9	MOVNTDQA 0(CX), X2
660f382b11|223344556677885f5f5f5f	32	intel	packusdw xmm2, xmmword ptr [ecx]
660f382b11|223344556677885f5f5f5f	32	plan9	PACKUSDW 0(CX), X2
660f382b11|223344556677885f5f5f5f	64	gnu	packusdw (%rcx),%xmm2
660f382b11|223344556677885f5f5f5f	64	intel	packusdw xmm2, xmmword ptr [rcx]
660f382b11|223344556677885f5f5f5f	64	plan9	PACKUSDW 0(CX), X2
660f383011|223344556677885f5f5f5f	32	intel	pmovzxbw xmm2, qword ptr [ecx]
660f383011|223344556677885f5f5f5f	32	plan9	PMOVZXBW 0(CX), X2
660f383011|223344556677885f5f5f5f	64	gnu	pmovzxbw (%rcx),%xmm2
660f383011|223344556677885f5f5f5f	64	intel	pmovzxbw xmm2, qword ptr [rcx]
660f383011|223344556677885f5f5f5f	64	plan9	PMOVZXBW 0(CX), X2
660f383111|223344556677885f5f5f5f	32	intel	pmovzxbd xmm2, dword ptr [ecx]
660f383111|223344556677885f5f5f5f	32	plan9	PMOVZXBD 0(CX), X2
660f383111|223344556677885f5f5f5f	64	gnu	pmovzxbd (%rcx),%xmm2
660f383111|223344556677885f5f5f5f	64	intel	pmovzxbd xmm2, dword ptr [rcx]
660f383111|223344556677885f5f5f5f	64	plan9	PMOVZXBD 0(CX), X2
660f383211|223344556677885f5f5f5f	32	intel	pmovzxbq xmm2, word ptr [ecx]
660f383211|223344556677885f5f5f5f	32	plan9	PMOVZXBQ 0(CX), X2
660f383211|223344556677885f5f5f5f	64	gnu	pmovzxbq (%rcx),%xmm2
660f383211|223344556677885f5f5f5f	64	intel	pmovzxbq xmm2, word ptr [rcx]
660f383211|223344556677885f5f5f5f	64	plan9	PMOVZXBQ 0(CX), X2
660f383311|223344556677885f5f5f5f	32	intel	pmovzxwd xmm2, qword ptr [ecx]
660f383311|223344556677885f5f5f5f	32	plan9	PMOVZXWD 0(CX), X2
660f383311|223344556677885f5f5f5f	64	gnu	pmovzxwd (%rcx),%xmm2
660f383311|223344556677885f5f5f5f	64	intel	pmovzxwd xmm2, qword ptr [rcx]
660f383311|223344556677885f5f5f5f	64	plan9	PMOVZXWD 0(CX), X2
660f383411|223344556677885f5f5f5f	32	intel	pmovzxwq xmm2, dword ptr [ecx]
660f383411|223344556677885f5f5f5f	32	plan9	PMOVZXWQ 0(CX), X2
660f383411|223344556677885f5f5f5f	64	gnu	pmovzxwq (%rcx),%xmm2
660f383411|223344556677885f5f5f5f	64	intel	pmovzxwq xmm2, dword ptr [rcx]
660f383411|223344556677885f5f5f5f	64	plan9	PMOVZXWQ 0(CX), X2
660f383511|223344556677885f5f5f5f	32	intel	pmovzxdq xmm2, qword ptr [ecx]
660f383511|223344556677885f5f5f5f	32	plan9	PMOVZXDQ 0(CX), X2
660f383511|223344556677885f5f5f5f	64	gnu	pmovzxdq (%rcx),%xmm2
660f383511|223344556677885f5f5f5f	64	intel	pmovzxdq xmm2, qword ptr [rcx]
660f383511|223344556677885f5f5f5f	64	plan9	PMOVZXDQ 0(CX), X2
660f383711|223344556677885f5f5f5f	32	intel	pcmpgtq xmm2, xmmword ptr [ecx]
660f383711|223344556677885f5f5f5f	32	plan9	PCMPGTQ 0(CX), X2
660f383711|223344556677885f5f5f5f	64	gnu	pcmpgtq (%rcx),%xmm2
660f383711|223344556677885f5f5f5f	64	intel	pcmpgtq xmm2, xmmword ptr [rcx]
660f383711|223344556677885f5f5f5f	64	plan9	PCMPGTQ 0(CX), X2
660f383811|223344556677885f5f5f5f	32	intel	pminsb xmm2, xmmword ptr [ecx]
660f383811|223344556677885f5f5f5f	32	plan9	PMINSB 0(CX), X2
660f383811|223344556677885f5f5f5f	64	gnu	pminsb (%rcx),%xmm2
660f383811|223344556677885f5f5f5f	64	intel	pminsb xmm2, xmmword ptr [rcx]
660f383811|223344556677885f5f5f5f	64	plan9	PMINSB 0(CX), X2
660f383911|223344556677885f5f5f5f	32	intel	pminsd xmm2, xmmword ptr [ecx]
660f383911|223344556677885f5f5f5f	32	plan9	PMINSD 0(CX), X2
660f383911|223344556677885f5f5f5f	64	gnu	pminsd (%rcx),%xmm2
660f383911|223344556677885f5f5f5f	64	intel	pminsd xmm2, xmmword ptr [rcx]
660f383911|223344556677885f5f5f5f	64	plan9	PMINSD 0(CX), X2
660f383a11|223344556677885f5f5f5f	32	intel	pminuw xmm2, xmmword ptr [ecx]
660f383a11|223344556677885f5f5f5f	32	plan9	PMINUW 0(CX), X2
660f383a11|223344556677885f5f5f5f	64	gnu	pminuw (%rcx),%xmm2
660f383a11|223344556677885f5f5f5f	64	intel	pminuw xmm2, xmmword ptr [rcx]
660f383a11|223344556677885f5f5f5f	64	plan9	PMINUW 0(CX), X2
660f383b11|223344556677885f5f5f5f	32	intel	pminud xmm2, xmmword ptr [ecx]
660f383b11|223344556677885f5f5f5f	32	plan9	PMINUD 0(CX), X2
660f383b11|223344556677885f5f5f5f	64	gnu	pminud (%rcx),%xmm2
660f383b11|223344556677885f5f5f5f	64	intel	pminud xmm2, xmmword ptr [rcx]
660f383b11|223344556677885f5f5f5f	64	plan9	PMINUD 0(CX), X2
660f383c11|223344556677885f5f5f5f	32	intel	pmaxsb xmm2, xmmword ptr [ecx]
660f383c11|223344556677885f5f5f5f	32	plan9	PMAXSB 0(CX), X2
660f383c11|223344556677885f5f5f5f	64	gnu	pmaxsb (%rcx),%xmm2
660f383c11|223344556677885f5f5f5f	64	intel	pmaxsb xmm2, xmmword ptr [rcx]
660f383c11|223344556677885f5f5f5f	64	plan9	PMAXSB 0(CX), X2
660f383d11|223344556677885f5f5f5f	32	intel	pmaxsd xmm2, xmmword ptr [ecx]
660f383d11|223344556677885f5f5f5f	32	plan9	PMAXSD 0(CX), X2
660f383d11|223344556677885f5f5f5f	64	gnu	pmaxsd (%rcx),%xmm2
660f383d11|223344556677885f5f5f5f	64	intel	pmaxsd xmm2, xmmword ptr [rcx]
660f383d11|223344556677885f5f5f5f	64	plan9	PMAXSD 0(CX), X2
660f383e11|223344556677885f5f5f5f	32	intel	pmaxuw xmm2, xmmword ptr [ecx]
660f383e11|223344556677885f5f5f5f	32	plan9	PMAXUW 0(CX), X2
660f383e11|223344556677885f5f5f5f	64	gnu	pmaxuw (%rcx),%xmm2
660f383e11|223344556677885f5f5f5f	64	intel	pmaxuw xmm2, xmmword ptr [rcx]
660f383e11|223344556677885f5f5f5f	64	plan9	PMAXUW 0(CX), X2
660f383f11|223344556677885f5f5f5f	32	intel	pmaxud xmm2, xmmword ptr [ecx]
660f383f11|223344556677885f5f5f5f	32	plan9	PMAXUD 0(CX), X2
660f383f11|223344556677885f5f5f5f	64	gnu	pmaxud (%rcx),%xmm2
660f383f11|223344556677885f5f5f5f	64	intel	pmaxud xmm2, xmmword ptr [rcx]
660f383f11|223344556677885f5f5f5f	64	plan9	PMAXUD 0(CX), X2
660f384011|223344556677885f5f5f5f	32	intel	pmulld xmm2, xmmword ptr [ecx]
660f384011|223344556677885f5f5f5f	32	plan9	PMULLD 0(CX), X2
660f384011|223344556677885f5f5f5f	64	gnu	pmulld (%rcx),%xmm2
660f384011|223344556677885f5f5f5f	64	intel	pmulld xmm2, xmmword ptr [rcx]
660f384011|223344556677885f5f5f5f	64	plan9	PMULLD 0(CX), X2
660f384111|223344556677885f5f5f5f	32	intel	phminposuw xmm2, xmmword ptr [ecx]
660f384111|223344556677885f5f5f5f	32	plan9	PHMINPOSUW 0(CX), X2
660f384111|223344556677885f5f5f5f	64	gnu	phminposuw (%rcx),%xmm2
660f384111|223344556677885f5f5f5f	64	intel	phminposuw xmm2, xmmword ptr [rcx]
660f384111|223344556677885f5f5f5f	64	plan9	PHMINPOSUW 0(CX), X2
660f388211|223344556677885f5f5f5f	32	intel	invpcid edx, xmmword ptr [ecx]
660f388211|223344556677885f5f5f5f	32	plan9	INVPCID 0(CX), DX
660f388211|223344556677885f5f5f5f	64	gnu	invpcid (%rcx),%rdx
660f388211|223344556677885f5f5f5f	64	intel	invpcid rdx, xmmword ptr [rcx]
660f388211|223344556677885f5f5f5f	64	plan9	INVPCID 0(CX), DX
660f38db11|223344556677885f5f5f5f	32	intel	aesimc xmm2, xmmword ptr [ecx]
660f38db11|223344556677885f5f5f5f	32	plan9	AESIMC 0(CX), X2
660f38db11|223344556677885f5f5f5f	64	gnu	aesimc (%rcx),%xmm2
660f38db11|223344556677885f5f5f5f	64	intel	aesimc xmm2, xmmword ptr [rcx]
660f38db11|223344556677885f5f5f5f	64	plan9	AESIMC 0(CX), X2
660f38dc11|223344556677885f5f5f5f	32	intel	aesenc xmm2, xmmword ptr [ecx]
660f38dc11|223344556677885f5f5f5f	32	plan9	AESENC 0(CX), X2
660f38dc11|223344556677885f5f5f5f	64	gnu	aesenc (%rcx),%xmm2
660f38dc11|223344556677885f5f5f5f	64	intel	aesenc xmm2, xmmword ptr [rcx]
660f38dc11|223344556677885f5f5f5f	64	plan9	AESENC 0(CX), X2
660f38dd11|223344556677885f5f5f5f	32	intel	aesenclast xmm2, xmmword ptr [ecx]
660f38dd11|223344556677885f5f5f5f	32	plan9	AESENCLAST 0(CX), X2
660f38dd11|223344556677885f5f5f5f	64	gnu	aesenclast (%rcx),%xmm2
660f38dd11|223344556677885f5f5f5f	64	intel	aesenclast xmm2, xmmword ptr [rcx]
660f38dd11|223344556677885f5f5f5f	64	plan9	AESENCLAST 0(CX), X2
660f38de11|223344556677885f5f5f5f	32	intel	aesdec xmm2, xmmword ptr [ecx]
660f38de11|223344556677885f5f5f5f	32	plan9	AESDEC 0(CX), X2
660f38de11|223344556677885f5f5f5f	64	gnu	aesdec (%rcx),%xmm2
660f38de11|223344556677885f5f5f5f	64	intel	aesdec xmm2, xmmword ptr [rcx]
660f38de11|223344556677885f5f5f5f	64	plan9	AESDEC 0(CX), X2
660f38df11|223344556677885f5f5f5f	32	intel	aesdeclast xmm2, xmmword ptr [ecx]
660f38df11|223344556677885f5f5f5f	32	plan9	AESDECLAST 0(CX), X2
660f38df11|223344556677885f5f5f5f	64	gnu	aesdeclast (%rcx),%xmm2
660f38df11|223344556677885f5f5f5f	64	intel	aesdeclast xmm2, xmmword ptr [rcx]
660f38df11|223344556677885f5f5f5f	64	plan9	AESDECLAST 0(CX), X2
660f3a081122|3344556677885f5f5f5f	32	intel	roundps xmm2, xmmword ptr [ecx], 0x22
660f3a081122|3344556677885f5f5f5f	32	plan9	ROUNDPS $0x22, 0(CX), X2
660f3a081122|3344556677885f5f5f5f	64	gnu	roundps $0x22,(%rcx),%xmm2
660f3a081122|3344556677885f5f5f5f	64	intel	roundps xmm2, xmmword ptr [rcx], 0x22
660f3a081122|3344556677885f5f5f5f	64	plan9	ROUNDPS $0x22, 0(CX), X2
660f3a091122|3344556677885f5f5f5f	32	intel	roundpd xmm2, xmmword ptr [ecx], 0x22
660f3a091122|3344556677885f5f5f5f	32	plan9	ROUNDPD $0x22, 0(CX), X2
660f3a091122|3344556677885f5f5f5f	64	gnu	roundpd $0x22,(%rcx),%xmm2
660f3a091122|3344556677885f5f5f5f	64	intel	roundpd xmm2, xmmword ptr [rcx], 0x22
660f3a091122|3344556677885f5f5f5f	64	plan9	ROUNDPD $0x22, 0(CX), X2
660f3a0a1122|3344556677885f5f5f5f	32	intel	roundss xmm2, dword ptr [ecx], 0x22
660f3a0a1122|3344556677885f5f5f5f	32	plan9	ROUNDSS $0x22, 0(CX), X2
660f3a0a1122|3344556677885f5f5f5f	64	gnu	roundss $0x22,(%rcx),%xmm2
660f3a0a1122|3344556677885f5f5f5f	64	intel	roundss xmm2, dword ptr [rcx], 0x22
660f3a0a1122|3344556677885f5f5f5f	64	plan9	ROUNDSS $0x22, 0(CX), X2
660f3a0b1122|3344556677885f5f5f5f	32	intel	roundsd xmm2, qword ptr [ecx], 0x22
660f3a0b1122|3344556677885f5f5f5f	32	plan9	ROUNDSD $0x22, 0(CX), X2
660f3a0b1122|3344556677885f5f5f5f	64	gnu	roundsd $0x22,(%rcx),%xmm2
660f3a0b1122|3344556677885f5f5f5f	64	intel	roundsd xmm2, qword ptr [rcx], 0x22
660f3a0b1122|3344556677885f5f5f5f	64	plan9	ROUNDSD $0x22, 0(CX), X2
660f3a0c1122|3344556677885f5f5f5f	32	intel	blendps xmm2, xmmword ptr [ecx], 0x22
660f3a0c1122|3344556677885f5f5f5f	32	plan9	BLENDPS $0x22, 0(CX), X2
660f3a0c1122|3344556677885f5f5f5f	64	gnu	blendps $0x22,(%rcx),%xmm2
660f3a0c1122|3344556677885f5f5f5f	64	intel	blendps xmm2, xmmword ptr [rcx], 0x22
660f3a0c1122|3344556677885f5f5f5f	64	plan9	BLENDPS $0x22, 0(CX), X2
660f3a0d1122|3344556677885f5f5f5f	32	intel	blendpd xmm2, xmmword ptr [ecx], 0x22
660f3a0d1122|3344556677885f5f5f5f	32	plan9	BLENDPD $0x22, 0(CX), X2
660f3a0d1122|3344556677885f5f5f5f	64	gnu	blendpd $0x22,(%rcx),%xmm2
660f3a0d1122|3344556677885f5f5f5f	64	intel	blendpd xmm2, xmmword ptr [rcx], 0x22
660f3a0d1122|3344556677885f5f5f5f	64	plan9	BLENDPD $0x22, 0(CX), X2
660f3a0e1122|3344556677885f5f5f5f	32	intel	pblendw xmm2, xmmword ptr [ecx], 0x22
660f3a0e1122|3344556677885f5f5f5f	32	plan9	PBLENDW $0x22, 0(CX), X2
660f3a0e1122|3344556677885f5f5f5f	64	gnu	pblendw $0x22,(%rcx),%xmm2
660f3a0e1122|3344556677885f5f5f5f	64	intel	pblendw xmm2, xmmword ptr [rcx], 0x22
660f3a0e1122|3344556677885f5f5f5f	64	plan9	PBLENDW $0x22, 0(CX), X2
660f3a0f1122|3344556677885f5f5f5f	32	intel	palignr xmm2, xmmword ptr [ecx], 0x22
660f3a0f1122|3344556677885f5f5f5f	32	plan9	PALIGNR $0x22, 0(CX), X2
660f3a0f1122|3344556677885f5f5f5f	64	gnu	palignr $0x22,(%rcx),%xmm2
660f3a0f1122|3344556677885f5f5f5f	64	intel	palignr xmm2, xmmword ptr [rcx], 0x22
660f3a0f1122|3344556677885f5f5f5f	64	plan9	PALIGNR $0x22, 0(CX), X2
660f3a141122|3344556677885f5f5f5f	32	intel	pextrb byte ptr [ecx], xmm2, 0x22
660f3a141122|3344556677885f5f5f5f	32	plan9	PEXTRB $0x22, X2, 0(CX)
660f3a141122|3344556677885f5f5f5f	64	gnu	pextrb $0x22,%xmm2,(%rcx)
660f3a141122|3344556677885f5f5f5f	64	intel	pextrb byte ptr [rcx], xmm2, 0x22
660f3a141122|3344556677885f5f5f5f	64	plan9	PEXTRB $0x22, X2, 0(CX)
660f3a151122|3344556677885f5f5f5f	32	intel	pextrw word ptr [ecx], xmm2, 0x22
660f3a151122|3344556677885f5f5f5f	32	plan9	PEXTRW $0x22, X2, 0(CX)
660f3a151122|3344556677885f5f5f5f	64	gnu	pextrw $0x22,%xmm2,(%rcx)
660f3a151122|3344556677885f5f5f5f	64	intel	pextrw word ptr [rcx], xmm2, 0x22
660f3a151122|3344556677885f5f5f5f	64	plan9	PEXTRW $0x22, X2, 0(CX)
660f3a161122|3344556677885f5f5f5f	32	intel	pextrd dword ptr [ecx], xmm2, 0x22
660f3a161122|3344556677885f5f5f5f	32	plan9	PEXTRD $0x22, X2, 0(CX)
660f3a161122|3344556677885f5f5f5f	64	gnu	pextrd $0x22,%xmm2,(%rcx)
660f3a161122|3344556677885f5f5f5f	64	intel	pextrd dword ptr [rcx], xmm2, 0x22
660f3a161122|3344556677885f5f5f5f	64	plan9	PEXTRD $0x22, X2, 0(CX)
660f3a171122|3344556677885f5f5f5f	32	intel	extractps dword ptr [ecx], xmm2, 0x22
660f3a171122|3344556677885f5f5f5f	32	plan9	EXTRACTPS $0x22, X2, 0(CX)
660f3a171122|3344556677885f5f5f5f	64	gnu	extractps $0x22,%xmm2,(%rcx)
660f3a171122|3344556677885f5f5f5f	64	intel	extractps dword ptr [rcx], xmm2, 0x22
660f3a171122|3344556677885f5f5f5f	64	plan9	EXTRACTPS $0x22, X2, 0(CX)
660f3a201122|3344556677885f5f5f5f	32	intel	pinsrb xmm2, byte ptr [ecx], 0x22
660f3a201122|3344556677885f5f5f5f	32	plan9	PINSRB $0x22, 0(CX), X2
660f3a201122|3344556677885f5f5f5f	64	gnu	pinsrb $0x22,(%rcx),%xmm2
660f3a201122|3344556677885f5f5f5f	64	intel	pinsrb xmm2, byte ptr [rcx], 0x22
660f3a201122|3344556677885f5f5f5f	64	plan9	PINSRB $0x22, 0(CX), X2
660f3a211122|3344556677885f5f5f5f	32	intel	insertps xmm2, dword ptr [ecx], 0x22
660f3a211122|3344556677885f5f5f5f	32	plan9	INSERTPS $0x22, 0(CX), X2
660f3a211122|3344556677885f5f5f5f	64	gnu	insertps $0x22,(%rcx),%xmm2
660f3a211122|3344556677885f5f5f5f	64	intel	insertps xmm2, dword ptr [rcx], 0x22
660f3a211122|3344556677885f5f5f5f	64	plan9	INSERTPS $0x22, 0(CX), X2
660f3a221122|3344556677885f5f5f5f	32	intel	pinsrd xmm2, dword ptr [ecx], 0x22
660f3a221122|3344556677885f5f5f5f	32	plan9	PINSRD $0x22, 0(CX), X2
660f3a221122|3344556677885f5f5f5f	64	gnu	pinsrd $0x22,(%rcx),%xmm2
660f3a221122|3344556677885f5f5f5f	64	intel	pinsrd xmm2, dword ptr [rcx], 0x22
660f3a221122|3344556677885f5f5f5f	64	plan9	PINSRD $0x22, 0(CX), X2
660f3a401122|3344556677885f5f5f5f	32	intel	dpps xmm2, xmmword ptr [ecx], 0x22
660f3a401122|3344556677885f5f5f5f	32	plan9	DPPS $0x22, 0(CX), X2
660f3a401122|3344556677885f5f5f5f	64	gnu	dpps $0x22,(%rcx),%xmm2
660f3a401122|3344556677885f5f5f5f	64	intel	dpps xmm2, xmmword ptr [rcx], 0x22
660f3a401122|3344556677885f5f5f5f	64	plan9	DPPS $0x22, 0(CX), X2
660f3a411122|3344556677885f5f5f5f	32	intel	dppd xmm2, xmmword ptr [ecx], 0x22
660f3a411122|3344556677885f5f5f5f	32	plan9	DPPD $0x22, 0(CX), X2
660f3a411122|3344556677885f5f5f5f	64	gnu	dppd $0x22,(%rcx),%xmm2
660f3a411122|3344556677885f5f5f5f	64	intel	dppd xmm2, xmmword ptr [rcx], 0x22
660f3a411122|3344556677885f5f5f5f	64	plan9	DPPD $0x22, 0(CX), X2
660f3a421122|3344556677885f5f5f5f	32	intel	mpsadbw xmm2, xmmword ptr [ecx], 0x22
660f3a421122|3344556677885f5f5f5f	32	plan9	MPSADBW $0x22, 0(CX), X2
660f3a421122|3344556677885f5f5f5f	64	gnu	mpsadbw $0x22,(%rcx),%xmm2
660f3a421122|3344556677885f5f5f5f	64	intel	mpsadbw xmm2, xmmword ptr [rcx], 0x22
660f3a421122|3344556677885f5f5f5f	64	plan9	MPSADBW $0x22, 0(CX), X2
660f3a441122|3344556677885f5f5f5f	32	intel	pclmulqdq xmm2, xmmword ptr [ecx], 0x22
660f3a441122|3344556677885f5f5f5f	32	plan9	PCLMULQDQ $0x22, 0(CX), X2
660f3a441122|3344556677885f5f5f5f	64	gnu	pclmulqdq $0x22,(%rcx),%xmm2
660f3a441122|3344556677885f5f5f5f	64	intel	pclmulqdq xmm2, xmmword ptr [rcx], 0x22
660f3a441122|3344556677885f5f5f5f	64	plan9	PCLMULQDQ $0x22, 0(CX), X2
660f3a601122|3344556677885f5f5f5f	32	intel	pcmpestrm xmm2, xmmword ptr [ecx], 0x22
660f3a601122|3344556677885f5f5f5f	32	plan9	PCMPESTRM $0x22, 0(CX), X2
660f3a601122|3344556677885f5f5f5f	64	gnu	pcmpestrm $0x22,(%rcx),%xmm2
660f3a601122|3344556677885f5f5f5f	64	intel	pcmpestrm xmm2, xmmword ptr [rcx], 0x22
660f3a601122|3344556677885f5f5f5f	64	plan9	PCMPESTRM $0x22, 0(CX), X2
660f3a611122|3344556677885f5f5f5f	32	intel	pcmpestri xmm2, xmmword ptr [ecx], 0x22
660f3a611122|3344556677885f5f5f5f	32	plan9	PCMPESTRI $0x22, 0(CX), X2
660f3a611122|3344556677885f5f5f5f	64	gnu	pcmpestri $0x22,(%rcx),%xmm2
660f3a611122|3344556677885f5f5f5f	64	intel	pcmpestri xmm2, xmmword ptr [rcx], 0x22
660f3a611122|3344556677885f5f5f5f	64	plan9	PCMPESTRI $0x22, 0(CX), X2
660f3a621122|3344556677885f5f5f5f	32	intel	pcmpistrm xmm2, xmmword ptr [ecx], 0x22
660f3a621122|3344556677885f5f5f5f	32	plan9	PCMPISTRM $0x22, 0(CX), X2
660f3a621122|3344556677885f5f5f5f	64	gnu	pcmpistrm $0x22,(%rcx),%xmm2
660f3a621122|3344556677885f5f5f5f	64	intel	pcmpistrm xmm2, xmmword ptr [rcx], 0x22
660f3a621122|3344556677885f5f5f5f	64	plan9	PCMPISTRM $0x22, 0(CX), X2
660f3a631122|3344556677885f5f5f5f	32	intel	pcmpistri xmm2, xmmword ptr [ecx], 0x22
660f3a631122|3344556677885f5f5f5f	32	plan9	PCMPISTRI $0x22, 0(CX), X2
660f3a631122|3344556677885f5f5f5f	64	gnu	pcmpistri $0x22,(%rcx),%xmm2
660f3a631122|3344556677885f5f5f5f	64	intel	pcmpistri xmm2, xmmword ptr [rcx], 0x22
660f3a631122|3344556677885f5f5f5f	64	plan9	PCMPISTRI $0x22, 0(CX), X2
660f3adf1122|3344556677885f5f5f5f	32	intel	aeskeygenassist xmm2, xmmword ptr [ecx], 0x22
660f3adf1122|3344556677885f5f5f5f	32	plan9	AESKEYGENASSIST $0x22, 0(CX), X2
660f3adf1122|3344556677885f5f5f5f	64	gnu	aeskeygenassist $0x22,(%rcx),%xmm2
660f3adf1122|3344556677885f5f5f5f	64	intel	aeskeygenassist xmm2, xmmword ptr [rcx], 0x22
660f3adf1122|3344556677885f5f5f5f	64	plan9	AESKEYGENASSIST $0x22, 0(CX), X2
660f4011|223344556677885f5f5f5f5f	32	intel	cmovo dx, word ptr [ecx]
660f4011|223344556677885f5f5f5f5f	32	plan9	CMOVO 0(CX), DX
660f4011|223344556677885f5f5f5f5f	64	gnu	cmovo (%rcx),%dx
660f4011|223344556677885f5f5f5f5f	64	intel	cmovo dx, word ptr [rcx]
660f4011|223344556677885f5f5f5f5f	64	plan9	CMOVO 0(CX), DX
660f4111|223344556677885f5f5f5f5f	32	intel	cmovno dx, word ptr [ecx]
660f4111|223344556677885f5f5f5f5f	32	plan9	CMOVNO 0(CX), DX
660f4111|223344556677885f5f5f5f5f	64	gnu	cmovno (%rcx),%dx
660f4111|223344556677885f5f5f5f5f	64	intel	cmovno dx, word ptr [rcx]
660f4111|223344556677885f5f5f5f5f	64	plan9	CMOVNO 0(CX), DX
660f4211|223344556677885f5f5f5f5f	32	intel	cmovb dx, word ptr [ecx]
660f4211|223344556677885f5f5f5f5f	32	plan9	CMOVB 0(CX), DX
660f4211|223344556677885f5f5f5f5f	64	gnu	cmovb (%rcx),%dx
660f4211|223344556677885f5f5f5f5f	64	intel	cmovb dx, word ptr [rcx]
660f4211|223344556677885f5f5f5f5f	64	plan9	CMOVB 0(CX), DX
660f4311|223344556677885f5f5f5f5f	32	intel	cmovnb dx, word ptr [ecx]
660f4311|223344556677885f5f5f5f5f	32	plan9	CMOVAE 0(CX), DX
660f4311|223344556677885f5f5f5f5f	64	gnu	cmovae (%rcx),%dx
660f4311|223344556677885f5f5f5f5f	64	intel	cmovnb dx, word ptr [rcx]
660f4311|223344556677885f5f5f5f5f	64	plan9	CMOVAE 0(CX), DX
660f4411|223344556677885f5f5f5f5f	32	intel	cmovz dx, word ptr [ecx]
660f4411|223344556677885f5f5f5f5f	32	plan9	CMOVE 0(CX), DX
660f4411|223344556677885f5f5f5f5f	64	gnu	cmove (%rcx),%dx
660f4411|223344556677885f5f5f5f5f	64	intel	cmovz dx, word ptr [rcx]
660f4411|223344556677885f5f5f5f5f	64	plan9	CMOVE 0(CX), DX
660f4511|223344556677885f5f5f5f5f	32	intel	cmovnz dx, word ptr [ecx]
660f4511|223344556677885f5f5f5f5f	32	plan9	CMOVNE 0(CX), DX
660f4511|223344556677885f5f5f5f5f	64	gnu	cmovne (%rcx),%dx
660f4511|223344556677885f5f5f5f5f	64	intel	cmovnz dx, word ptr [rcx]
660f4511|223344556677885f5f5f5f5f	64	plan9	CMOVNE 0(CX), DX
660f4611|223344556677885f5f5f5f5f	32	intel	cmovbe dx, word ptr [ecx]
660f4611|223344556677885f5f5f5f5f	32	plan9	CMOVBE 0(CX), DX
660f4611|223344556677885f5f5f5f5f	64	gnu	cmovbe (%rcx),%dx
660f4611|223344556677885f5f5f5f5f	64	intel	cmovbe dx, word ptr [rcx]
660f4611|223344556677885f5f5f5f5f	64	plan9	CMOVBE 0(CX), DX
660f4711|223344556677885f5f5f5f5f	32	intel	cmovnbe dx, word ptr [ecx]
660f4711|223344556677885f5f5f5f5f	32	plan9	CMOVA 0(CX), DX
660f4711|223344556677885f5f5f5f5f	64	gnu	cmova (%rcx),%dx
660f4711|223344556677885f5f5f5f5f	64	intel	cmovnbe dx, word ptr [rcx]
660f4711|223344556677885f5f5f5f5f	64	plan9	CMOVA 0(CX), DX
660f4811|223344556677885f5f5f5f5f	32	intel	cmovs dx, word ptr [ecx]
660f4811|223344556677885f5f5f5f5f	32	plan9	CMOVS 0(CX), DX
660f4811|223344556677885f5f5f5f5f	64	gnu	cmovs (%rcx),%dx
660f4811|223344556677885f5f5f5f5f	64	intel	cmovs dx, word ptr [rcx]
660f4811|223344556677885f5f5f5f5f	64	plan9	CMOVS 0(CX), DX
660f4911|223344556677885f5f5f5f5f	32	intel	cmovns dx, word ptr [ecx]
660f4911|223344556677885f5f5f5f5f	32	plan9	CMOVNS 0(CX), DX
660f4911|223344556677885f5f5f5f5f	64	gnu	cmovns (%rcx),%dx
660f4911|223344556677885f5f5f5f5f	64	intel	cmovns dx, word ptr [rcx]
660f4911|223344556677885f5f5f5f5f	64	plan9	CMOVNS 0(CX), DX
660f4a11|223344556677885f5f5f5f5f	32	intel	cmovp dx, word ptr [ecx]
660f4a11|223344556677885f5f5f5f5f	32	plan9	CMOVP 0(CX), DX
660f4a11|223344556677885f5f5f5f5f	64	gnu	cmovp (%rcx),%dx
660f4a11|223344556677885f5f5f5f5f	64	intel	cmovp dx, word ptr [rcx]
660f4a11|223344556677885f5f5f5f5f	64	plan9	CMOVP 0(CX), DX
660f4b11|223344556677885f5f5f5f5f	32	intel	cmovnp dx, word ptr [ecx]
660f4b11|223344556677885f5f5f5f5f	32	plan9	CMOVNP 0(CX), DX
660f4b11|223344556677885f5f5f5f5f	64	gnu	cmovnp (%rcx),%dx
660f4b11|223344556677885f5f5f5f5f	64	intel	cmovnp dx, word ptr [rcx]
660f4b11|223344556677885f5f5f5f5f	64	plan9	CMOVNP 0(CX), DX
660f4c11|223344556677885f5f5f5f5f	32	intel	cmovl dx, word ptr [ecx]
660f4c11|223344556677885f5f5f5f5f	32	plan9	CMOVL 0(CX), DX
660f4c11|223344556677885f5f5f5f5f	64	gnu	cmovl (%rcx),%dx
660f4c11|223344556677885f5f5f5f5f	64	intel	cmovl dx, word ptr [rcx]
660f4c11|223344556677885f5f5f5f5f	64	plan9	CMOVL 0(CX), DX
660f4d11|223344556677885f5f5f5f5f	32	intel	cmovnl dx, word ptr [ecx]
660f4d11|223344556677885f5f5f5f5f	32	plan9	CMOVGE 0(CX), DX
660f4d11|223344556677885f5f5f5f5f	64	gnu	cmovge (%rcx),%dx
660f4d11|223344556677885f5f5f5f5f	64	intel	cmovnl dx, word ptr [rcx]
660f4d11|223344556677885f5f5f5f5f	64	plan9	CMOVGE 0(CX), DX
660f4e11|223344556677885f5f5f5f5f	32	intel	cmovle dx, word ptr [ecx]
660f4e11|223344556677885f5f5f5f5f	32	plan9	CMOVLE 0(CX), DX
660f4e11|223344556677885f5f5f5f5f	64	gnu	cmovle (%rcx),%dx
660f4e11|223344556677885f5f5f5f5f	64	intel	cmovle dx, word ptr [rcx]
660f4e11|223344556677885f5f5f5f5f	64	plan9	CMOVLE 0(CX), DX
660f4f11|223344556677885f5f5f5f5f	32	intel	cmovnle dx, word ptr [ecx]
660f4f11|223344556677885f5f5f5f5f	32	plan9	CMOVG 0(CX), DX
660f4f11|223344556677885f5f5f5f5f	64	gnu	cmovg (%rcx),%dx
660f4f11|223344556677885f5f5f5f5f	64	intel	cmovnle dx, word ptr [rcx]
660f4f11|223344556677885f5f5f5f5f	64	plan9	CMOVG 0(CX), DX
660f50c0|11223344556677885f5f5f5f	32	intel	movmskpd eax, xmm0
660f50c0|11223344556677885f5f5f5f	32	plan9	MOVMSKPD X0, AX
660f50c0|11223344556677885f5f5f5f	64	gnu	movmskpd %xmm0,%eax
660f50c0|11223344556677885f5f5f5f	64	intel	movmskpd eax, xmm0
660f50c0|11223344556677885f5f5f5f	64	plan9	MOVMSKPD X0, AX
660f5111|223344556677885f5f5f5f5f	32	intel	sqrtpd xmm2, xmmword ptr [ecx]
660f5111|223344556677885f5f5f5f5f	32	plan9	SQRTPD 0(CX), X2
660f5111|223344556677885f5f5f5f5f	64	gnu	sqrtpd (%rcx),%xmm2
660f5111|223344556677885f5f5f5f5f	64	intel	sqrtpd xmm2, xmmword ptr [rcx]
660f5111|223344556677885f5f5f5f5f	64	plan9	SQRTPD 0(CX), X2
660f5411|223344556677885f5f5f5f5f	32	intel	andpd xmm2, xmmword ptr [ecx]
660f5411|223344556677885f5f5f5f5f	32	plan9	ANDPD 0(CX), X2
660f5411|223344556677885f5f5f5f5f	64	gnu	andpd (%rcx),%xmm2
660f5411|223344556677885f5f5f5f5f	64	intel	andpd xmm2, xmmword ptr [rcx]
660f5411|223344556677885f5f5f5f5f	64	plan9	ANDPD 0(CX), X2
660f5511|223344556677885f5f5f5f5f	32	intel	andnpd xmm2, xmmword ptr [ecx]
660f5511|223344556677885f5f5f5f5f	32	plan9	ANDNPD 0(CX), X2
660f5511|223344556677885f5f5f5f5f	64	gnu	andnpd (%rcx),%xmm2
660f5511|223344556677885f5f5f5f5f	64	intel	andnpd xmm2, xmmword ptr [rcx]
660f5511|223344556677885f5f5f5f5f	64	plan9	ANDNPD 0(CX), X2
660f5611|223344556677885f5f5f5f5f	32	intel	orpd xmm2, xmmword ptr [ecx]
660f5611|223344556677885f5f5f5f5f	32	plan9	ORPD 0(CX), X2
660f5611|223344556677885f5f5f5f5f	64	gnu	orpd (%rcx),%xmm2
660f5611|223344556677885f5f5f5f5f	64	intel	orpd xmm2, xmmword ptr [rcx]
660f5611|223344556677885f5f5f5f5f	64	plan9	ORPD 0(CX), X2
660f5711|223344556677885f5f5f5f5f	32	intel	xorpd xmm2, xmmword ptr [ecx]
660f5711|223344556677885f5f5f5f5f	32	plan9	XORPD 0(CX), X2
660f5711|223344556677885f5f5f5f5f	64	gnu	xorpd (%rcx),%xmm2
660f5711|223344556677885f5f5f5f5f	64	intel	xorpd xmm2, xmmword ptr [rcx]
660f5711|223344556677885f5f5f5f5f	64	plan9	XORPD 0(CX), X2
660f5811|223344556677885f5f5f5f5f	32	intel	addpd xmm2, xmmword ptr [ecx]
660f5811|223344556677885f5f5f5f5f	32	plan9	ADDPD 0(CX), X2
660f5811|223344556677885f5f5f5f5f	64	gnu	addpd (%rcx),%xmm2
660f5811|223344556677885f5f5f5f5f	64	intel	addpd xmm2, xmmword ptr [rcx]
660f5811|223344556677885f5f5f5f5f	64	plan9	ADDPD 0(CX), X2
660f5911|223344556677885f5f5f5f5f	32	intel	mulpd xmm2, xmmword ptr [ecx]
660f5911|223344556677885f5f5f5f5f	32	plan9	MULPD 0(CX), X2
660f5911|223344556677885f5f5f5f5f	64	gnu	mulpd (%rcx),%xmm2
660f5911|223344556677885f5f5f5f5f	64	intel	mulpd xmm2, xmmword ptr [rcx]
660f5911|223344556677885f5f5f5f5f	64	plan9	MULPD 0(CX), X2
660f5a11|223344556677885f5f5f5f5f	32	intel	cvtpd2ps xmm2, xmmword ptr [ecx]
660f5a11|223344556677885f5f5f5f5f	32	plan9	CVTPD2PS 0(CX), X2
660f5a11|223344556677885f5f5f5f5f	64	gnu	cvtpd2ps (%rcx),%xmm2
660f5a11|223344556677885f5f5f5f5f	64	intel	cvtpd2ps xmm2, xmmword ptr [rcx]
660f5a11|223344556677885f5f5f5f5f	64	plan9	CVTPD2PS 0(CX), X2
660f5b11|223344556677885f5f5f5f5f	32	intel	cvtps2dq xmm2, xmmword ptr [ecx]
660f5b11|223344556677885f5f5f5f5f	32	plan9	CVTPS2DQ 0(CX), X2
660f5b11|223344556677885f5f5f5f5f	64	gnu	cvtps2dq (%rcx),%xmm2
660f5b11|223344556677885f5f5f5f5f	64	intel	cvtps2dq xmm2, xmmword ptr [rcx]
660f5b11|223344556677885f5f5f5f5f	64	plan9	CVTPS2DQ 0(CX), X2
660f5c11|223344556677885f5f5f5f5f	32	intel	subpd xmm2, xmmword ptr [ecx]
660f5c11|223344556677885f5f5f5f5f	32	plan9	SUBPD 0(CX), X2
660f5c11|223344556677885f5f5f5f5f	64	gnu	subpd (%rcx),%xmm2
660f5c11|223344556677885f5f5f5f5f	64	intel	subpd xmm2, xmmword ptr [rcx]
660f5c11|223344556677885f5f5f5f5f	64	plan9	SUBPD 0(CX), X2
660f5d11|223344556677885f5f5f5f5f	32	intel	minpd xmm2, xmmword ptr [ecx]
660f5d11|223344556677885f5f5f5f5f	32	plan9	MINPD 0(CX), X2
660f5d11|223344556677885f5f5f5f5f	64	gnu	minpd (%rcx),%xmm2
660f5d11|223344556677885f5f5f5f5f	64	intel	minpd xmm2, xmmword ptr [rcx]
660f5d11|223344556677885f5f5f5f5f	64	plan9	MINPD 0(CX), X2
660f5e11|223344556677885f5f5f5f5f	32	intel	divpd xmm2, xmmword ptr [ecx]
660f5e11|223344556677885f5f5f5f5f	32	plan9	DIVPD 0(CX), X2
660f5e11|223344556677885f5f5f5f5f	64	gnu	divpd (%rcx),%xmm2
660f5e11|223344556677885f5f5f5f5f	64	intel	divpd xmm2, xmmword ptr [rcx]
660f5e11|223344556677885f5f5f5f5f	64	plan9	DIVPD 0(CX), X2
660f5f11|223344556677885f5f5f5f5f	32	intel	maxpd xmm2, xmmword ptr [ecx]
660f5f11|223344556677885f5f5f5f5f	32	plan9	MAXPD 0(CX), X2
660f5f11|223344556677885f5f5f5f5f	64	gnu	maxpd (%rcx),%xmm2
660f5f11|223344556677885f5f5f5f5f	64	intel	maxpd xmm2, xmmword ptr [rcx]
660f5f11|223344556677885f5f5f5f5f	64	plan9	MAXPD 0(CX), X2
660f6011|223344556677885f5f5f5f5f	32	intel	punpcklbw xmm2, xmmword ptr [ecx]
660f6011|223344556677885f5f5f5f5f	32	plan9	PUNPCKLBW 0(CX), X2
660f6011|223344556677885f5f5f5f5f	64	gnu	punpcklbw (%rcx),%xmm2
660f6011|223344556677885f5f5f5f5f	64	intel	punpcklbw xmm2, xmmword ptr [rcx]
660f6011|223344556677885f5f5f5f5f	64	plan9	PUNPCKLBW 0(CX), X2
660f6111|223344556677885f5f5f5f5f	32	intel	punpcklwd xmm2, xmmword ptr [ecx]
660f6111|223344556677885f5f5f5f5f	32	plan9	PUNPCKLWD 0(CX), X2
660f6111|223344556677885f5f5f5f5f	64	gnu	punpcklwd (%rcx),%xmm2
660f6111|223344556677885f5f5f5f5f	64	intel	punpcklwd xmm2, xmmword ptr [rcx]
660f6111|223344556677885f5f5f5f5f	64	plan9	PUNPCKLWD 0(CX), X2
660f6211|223344556677885f5f5f5f5f	32	intel	punpckldq xmm2, xmmword ptr [ecx]
660f6211|223344556677885f5f5f5f5f	32	plan9	PUNPCKLDQ 0(CX), X2
660f6211|223344556677885f5f5f5f5f	64	gnu	punpckldq (%rcx),%xmm2
660f6211|223344556677885f5f5f5f5f	64	intel	punpckldq xmm2, xmmword ptr [rcx]
660f6211|223344556677885f5f5f5f5f	64	plan9	PUNPCKLDQ 0(CX), X2
660f6311|223344556677885f5f5f5f5f	32	intel	packsswb xmm2, xmmword ptr [ecx]
660f6311|223344556677885f5f5f5f5f	32	plan9	PACKSSWB 0(CX), X2
660f6311|223344556677885f5f5f5f5f	64	gnu	packsswb (%rcx),%xmm2
660f6311|223344556677885f5f5f5f5f	64	intel	packsswb xmm2, xmmword ptr [rcx]
660f6311|223344556677885f5f5f5f5f	64	plan9	PACKSSWB 0(CX), X2
660f6411|223344556677885f5f5f5f5f	32	intel	pcmpgtb xmm2, xmmword ptr [ecx]
660f6411|223344556677885f5f5f5f5f	32	plan9	PCMPGTB 0(CX), X2
660f6411|223344556677885f5f5f5f5f	64	gnu	pcmpgtb (%rcx),%xmm2
660f6411|223344556677885f5f5f5f5f	64	intel	pcmpgtb xmm2, xmmword ptr [rcx]
660f6411|223344556677885f5f5f5f5f	64	plan9	PCMPGTB 0(CX), X2
660f6511|223344556677885f5f5f5f5f	32	intel	pcmpgtw xmm2, xmmword ptr [ecx]
660f6511|223344556677885f5f5f5f5f	32	plan9	PCMPGTW 0(CX), X2
660f6511|223344556677885f5f5f5f5f	64	gnu	pcmpgtw (%rcx),%xmm2
660f6511|223344556677885f5f5f5f5f	64	intel	pcmpgtw xmm2, xmmword ptr [rcx]
660f6511|223344556677885f5f5f5f5f	64	plan9	PCMPGTW 0(CX), X2
660f6611|223344556677885f5f5f5f5f	32	intel	pcmpgtd xmm2, xmmword ptr [ecx]
660f6611|223344556677885f5f5f5f5f	32	plan9	PCMPGTD 0(CX), X2
660f6611|223344556677885f5f5f5f5f	64	gnu	pcmpgtd (%rcx),%xmm2
660f6611|223344556677885f5f5f5f5f	64	intel	pcmpgtd xmm2, xmmword ptr [rcx]
660f6611|223344556677885f5f5f5f5f	64	plan9	PCMPGTD 0(CX), X2
660f6711|223344556677885f5f5f5f5f	32	intel	packuswb xmm2, xmmword ptr [ecx]
660f6711|223344556677885f5f5f5f5f	32	plan9	PACKUSWB 0(CX), X2
660f6711|223344556677885f5f5f5f5f	64	gnu	packuswb (%rcx),%xmm2
660f6711|223344556677885f5f5f5f5f	64	intel	packuswb xmm2, xmmword ptr [rcx]
660f6711|223344556677885f5f5f5f5f	64	plan9	PACKUSWB 0(CX), X2
660f6811|223344556677885f5f5f5f5f	32	intel	punpckhbw xmm2, xmmword ptr [ecx]
660f6811|223344556677885f5f5f5f5f	32	plan9	PUNPCKHBW 0(CX), X2
660f6811|223344556677885f5f5f5f5f	64	gnu	punpckhbw (%rcx),%xmm2
660f6811|223344556677885f5f5f5f5f	64	intel	punpckhbw xmm2, xmmword ptr [rcx]
660f6811|223344556677885f5f5f5f5f	64	plan9	PUNPCKHBW 0(CX), X2
660f6911|223344556677885f5f5f5f5f	32	intel	punpckhwd xmm2, xmmword ptr [ecx]
660f6911|223344556677885f5f5f5f5f	32	plan9	PUNPCKHWD 0(CX), X2
660f6911|223344556677885f5f5f5f5f	64	gnu	punpckhwd (%rcx),%xmm2
660f6911|223344556677885f5f5f5f5f	64	intel	punpckhwd xmm2, xmmword ptr [rcx]
660f6911|223344556677885f5f5f5f5f	64	plan9	PUNPCKHWD 0(CX), X2
660f6a11|223344556677885f5f5f5f5f	32	intel	punpckhdq xmm2, xmmword ptr [ecx]
660f6a11|223344556677885f5f5f5f5f	32	plan9	PUNPCKHDQ 0(CX), X2
660f6a11|223344556677885f5f5f5f5f	64	gnu	punpckhdq (%rcx),%xmm2
660f6a11|223344556677885f5f5f5f5f	64	intel	punpckhdq xmm2, xmmword ptr [rcx]
660f6a11|223344556677885f5f5f5f5f	64	plan9	PUNPCKHDQ 0(CX), X2
660f6b11|223344556677885f5f5f5f5f	32	intel	packssdw xmm2, xmmword ptr [ecx]
660f6b11|223344556677885f5f5f5f5f	32	plan9	PACKSSDW 0(CX), X2
660f6b11|223344556677885f5f5f5f5f	64	gnu	packssdw (%rcx),%xmm2
660f6b11|223344556677885f5f5f5f5f	64	intel	packssdw xmm2, xmmword ptr [rcx]
660f6b11|223344556677885f5f5f5f5f	64	plan9	PACKSSDW 0(CX), X2
660f6c11|223344556677885f5f5f5f5f	32	intel	punpcklqdq xmm2, xmmword ptr [ecx]
660f6c11|223344556677885f5f5f5f5f	32	plan9	PUNPCKLQDQ 0(CX), X2
660f6c11|223344556677885f5f5f5f5f	64	gnu	punpcklqdq (%rcx),%xmm2
660f6c11|223344556677885f5f5f5f5f	64	intel	punpcklqdq xmm2, xmmword ptr [rcx]
660f6c11|223344556677885f5f5f5f5f	64	plan9	PUNPCKLQDQ 0(CX), X2
660f6d11|223344556677885f5f5f5f5f	32	intel	punpckhqdq xmm2, xmmword ptr [ecx]
660f6d11|223344556677885f5f5f5f5f	32	plan9	PUNPCKHQDQ 0(CX), X2
660f6d11|223344556677885f5f5f5f5f	64	gnu	punpckhqdq (%rcx),%xmm2
660f6d11|223344556677885f5f5f5f5f	64	intel	punpckhqdq xmm2, xmmword ptr [rcx]
660f6d11|223344556677885f5f5f5f5f	64	plan9	PUNPCKHQDQ 0(CX), X2
660f6e11|223344556677885f5f5f5f5f	32	intel	movd xmm2, dword ptr [ecx]
660f6e11|223344556677885f5f5f5f5f	32	plan9	MOVD 0(CX), X2
660f6e11|223344556677885f5f5f5f5f	64	gnu	movd (%rcx),%xmm2
660f6e11|223344556677885f5f5f5f5f	64	intel	movd xmm2, dword ptr [rcx]
660f6e11|223344556677885f5f5f5f5f	64	plan9	MOVD 0(CX), X2
660f6f11|223344556677885f5f5f5f5f	32	intel	movdqa xmm2, xmmword ptr [ecx]
660f6f11|223344556677885f5f5f5f5f	32	plan9	MOVDQA 0(CX), X2
660f6f11|223344556677885f5f5f5f5f	64	gnu	movdqa (%rcx),%xmm2
660f6f11|223344556677885f5f5f5f5f	64	intel	movdqa xmm2, xmmword ptr [rcx]
660f6f11|223344556677885f5f5f5f5f	64	plan9	MOVDQA 0(CX), X2
660f701122|3344556677885f5f5f5f5f	32	intel	pshufd xmm2, xmmword ptr [ecx], 0x22
660f701122|3344556677885f5f5f5f5f	32	plan9	PSHUFD $0x22, 0(CX), X2
660f701122|3344556677885f5f5f5f5f	64	gnu	pshufd $0x22,(%rcx),%xmm2
660f701122|3344556677885f5f5f5f5f	64	intel	pshufd xmm2, xmmword ptr [rcx], 0x22
660f701122|3344556677885f5f5f5f5f	64	plan9	PSHUFD $0x22, 0(CX), X2
660f71d011|223344556677885f5f5f5f	32	intel	psrlw xmm0, 0x11
660f71d011|223344556677885f5f5f5f	32	plan9	PSRLW $0x11, X0
660f71d011|223344556677885f5f5f5f	64	gnu	psrlw $0x11,%xmm0
660f71d011|223344556677885f5f5f5f	64	intel	psrlw xmm0, 0x11
660f71d011|223344556677885f5f5f5f	64	plan9	PSRLW $0x11, X0
660f71e011|223344556677885f5f5f5f	32	intel	psraw xmm0, 0x11
660f71e011|223344556677885f5f5f5f	32	plan9	PSRAW $0x11, X0
660f71e011|223344556677885f5f5f5f	64	gnu	psraw $0x11,%xmm0
660f71e011|223344556677885f5f5f5f	64	intel	psraw xmm0, 0x11
660f71e011|223344556677885f5f5f5f	64	plan9	PSRAW $0x11, X0
660f71f011|223344556677885f5f5f5f	32	intel	psllw xmm0, 0x11
660f71f011|223344556677885f5f5f5f	32	plan9	PSLLW $0x11, X0
660f71f011|223344556677885f5f5f5f	64	gnu	psllw $0x11,%xmm0
660f71f011|223344556677885f5f5f5f	64	intel	psllw xmm0, 0x11
660f71f011|223344556677885f5f5f5f	64	plan9	PSLLW $0x11, X0
660f72d011|223344556677885f5f5f5f	32	intel	psrld xmm0, 0x11
660f72d011|223344556677885f5f5f5f	32	plan9	PSRLD $0x11, X0
660f72d011|223344556677885f5f5f5f	64	gnu	psrld $0x11,%xmm0
660f72d011|223344556677885f5f5f5f	64	intel	psrld xmm0, 0x11
660f72d011|223344556677885f5f5f5f	64	plan9	PSRLD $0x11, X0
660f72e011|223344556677885f5f5f5f	32	intel	psrad xmm0, 0x11
660f72e011|223344556677885f5f5f5f	32	plan9	PSRAD $0x11, X0
660f72e011|223344556677885f5f5f5f	64	gnu	psrad $0x11,%xmm0
660f72e011|223344556677885f5f5f5f	64	intel	psrad xmm0, 0x11
660f72e011|223344556677885f5f5f5f	64	plan9	PSRAD $0x11, X0
660f72f011|223344556677885f5f5f5f	32	intel	pslld xmm0, 0x11
660f72f011|223344556677885f5f5f5f	32	plan9	PSLLD $0x11, X0
660f72f011|223344556677885f5f5f5f	64	gnu	pslld $0x11,%xmm0
660f72f011|223344556677885f5f5f5f	64	intel	pslld xmm0, 0x11
660f72f011|223344556677885f5f5f5f	64	plan9	PSLLD $0x11, X0
660f73d011|223344556677885f5f5f5f	32	intel	psrlq xmm0, 0x11
660f73d011|223344556677885f5f5f5f	32	plan9	PSRLQ $0x11, X0
660f73d011|223344556677885f5f5f5f	64	gnu	psrlq $0x11,%xmm0
660f73d011|223344556677885f5f5f5f	64	intel	psrlq xmm0, 0x11
660f73d011|223344556677885f5f5f5f	64	plan9	PSRLQ $0x11, X0
660f73d811|223344556677885f5f5f5f	32	intel	psrldq xmm0, 0x11
660f73d811|223344556677885f5f5f5f	32	plan9	PSRLDQ $0x11, X0
660f73d811|223344556677885f5f5f5f	64	gnu	psrldq $0x11,%xmm0
660f73d811|223344556677885f5f5f5f	64	intel	psrldq xmm0, 0x11
660f73d811|223344556677885f5f5f5f	64	plan9	PSRLDQ $0x11, X0
660f73f011|223344556677885f5f5f5f	32	intel	psllq xmm0, 0x11
660f73f011|223344556677885f5f5f5f	32	plan9	PSLLQ $0x11, X0
660f73f011|223344556677885f5f5f5f	64	gnu	psllq $0x11,%xmm0
660f73f011|223344556677885f5f5f5f	64	intel	psllq xmm0, 0x11
660f73f011|223344556677885f5f5f5f	64	plan9	PSLLQ $0x11, X0
660f73f811|223344556677885f5f5f5f	32	intel	pslldq xmm0, 0x11
660f73f811|223344556677885f5f5f5f	32	plan9	PSLLDQ $0x11, X0
660f73f811|223344556677885f5f5f5f	64	gnu	pslldq $0x11,%xmm0
660f73f811|223344556677885f5f5f5f	64	intel	pslldq xmm0, 0x11
660f73f811|223344556677885f5f5f5f	64	plan9	PSLLDQ $0x11, X0
660f7411|223344556677885f5f5f5f5f	32	intel	pcmpeqb xmm2, xmmword ptr [ecx]
660f7411|223344556677885f5f5f5f5f	32	plan9	PCMPEQB 0(CX), X2
660f7411|223344556677885f5f5f5f5f	64	gnu	pcmpeqb (%rcx),%xmm2
660f7411|223344556677885f5f5f5f5f	64	intel	pcmpeqb xmm2, xmmword ptr [rcx]
660f7411|223344556677885f5f5f5f5f	64	plan9	PCMPEQB 0(CX), X2
660f7511|223344556677885f5f5f5f5f	32	intel	pcmpeqw xmm2, xmmword ptr [ecx]
660f7511|223344556677885f5f5f5f5f	32	plan9	PCMPEQW 0(CX), X2
660f7511|223344556677885f5f5f5f5f	64	gnu	pcmpeqw (%rcx),%xmm2
660f7511|223344556677885f5f5f5f5f	64	intel	pcmpeqw xmm2, xmmword ptr [rcx]
660f7511|223344556677885f5f5f5f5f	64	plan9	PCMPEQW 0(CX), X2
660f7611|223344556677885f5f5f5f5f	32	intel	pcmpeqd xmm2, xmmword ptr [ecx]
660f7611|223344556677885f5f5f5f5f	32	plan9	PCMPEQD 0(CX), X2
660f7611|223344556677885f5f5f5f5f	64	gnu	pcmpeqd (%rcx),%xmm2
660f7611|223344556677885f5f5f5f5f	64	intel	pcmpeqd xmm2, xmmword ptr [rcx]
660f7611|223344556677885f5f5f5f5f	64	plan9	PCMPEQD 0(CX), X2
660f7c11|223344556677885f5f5f5f5f	32	intel	haddpd xmm2, xmmword ptr [ecx]
660f7c11|223344556677885f5f5f5f5f	32	plan9	HADDPD 0(CX), X2
660f7c11|223344556677885f5f5f5f5f	64	gnu	haddpd (%rcx),%xmm2
660f7c11|223344556677885f5f5f5f5f	64	intel	haddpd xmm2, xmmword ptr [rcx]
660f7c11|223344556677885f5f5f5f5f	64	plan9	HADDPD 0(CX), X2
660f7d11|223344556677885f5f5f5f5f	32	intel	hsubpd xmm2, xmmword ptr [ecx]
660f7d11|223344556677885f5f5f5f5f	32	plan9	HSUBPD 0(CX), X2
660f7d11|223344556677885f5f5f5f5f	64	gnu	hsubpd (%rcx),%xmm2
660f7d11|223344556677885f5f5f5f5f	64	intel	hsubpd xmm2, xmmword ptr [rcx]
660f7d11|223344556677885f5f5f5f5f	64	plan9	HSUBPD 0(CX), X2
660f7e11|223344556677885f5f5f5f5f	32	intel	movd dword ptr [ecx], xmm2
660f7e11|223344556677885f5f5f5f5f	32	plan9	MOVD X2, 0(CX)
660f7e11|223344556677885f5f5f5f5f	64	gnu	movd %xmm2,(%rcx)
660f7e11|223344556677885f5f5f5f5f	64	intel	movd dword ptr [rcx], xmm2
660f7e11|223344556677885f5f5f5f5f	64	plan9	MOVD X2, 0(CX)
660f7f11|223344556677885f5f5f5f5f	32	intel	movdqa xmmword ptr [ecx], xmm2
660f7f11|223344556677885f5f5f5f5f	32	plan9	MOVDQA X2, 0(CX)
660f7f11|223344556677885f5f5f5f5f	64	gnu	movdqa %xmm2,(%rcx)
660f7f11|223344556677885f5f5f5f5f	64	intel	movdqa xmmword ptr [rcx], xmm2
660f7f11|223344556677885f5f5f5f5f	64	plan9	MOVDQA X2, 0(CX)
660f8011223344|556677885f5f5f5f5f	64	gnu	jo .+0x44332211
660f8011223344|556677885f5f5f5f5f	64	intel	jo .+0x44332211
660f8011223344|556677885f5f5f5f5f	64	plan9	JO .+1144201745
660f801122|3344556677885f5f5f5f5f	32	intel	jo .+0x2211
660f801122|3344556677885f5f5f5f5f	32	plan9	JO .+8721
660f8111223344|556677885f5f5f5f5f	64	gnu	jno .+0x44332211
660f8111223344|556677885f5f5f5f5f	64	intel	jno .+0x44332211
660f8111223344|556677885f5f5f5f5f	64	plan9	JNO .+1144201745
660f811122|3344556677885f5f5f5f5f	32	intel	jno .+0x2211
660f811122|3344556677885f5f5f5f5f	32	plan9	JNO .+8721
660f8211223344|556677885f5f5f5f5f	64	gnu	jb .+0x44332211
660f8211223344|556677885f5f5f5f5f	64	intel	jb .+0x44332211
660f8211223344|556677885f5f5f5f5f	64	plan9	JB .+1144201745
660f821122|3344556677885f5f5f5f5f	32	intel	jb .+0x2211
660f821122|3344556677885f5f5f5f5f	32	plan9	JB .+8721
660f8311223344|556677885f5f5f5f5f	64	gnu	jae .+0x44332211
660f8311223344|556677885f5f5f5f5f	64	intel	jnb .+0x44332211
660f8311223344|556677885f5f5f5f5f	64	plan9	JAE .+1144201745
660f831122|3344556677885f5f5f5f5f	32	intel	jnb .+0x2211
660f831122|3344556677885f5f5f5f5f	32	plan9	JAE .+8721
660f8411223344|556677885f5f5f5f5f	64	gnu	je .+0x44332211
660f8411223344|556677885f5f5f5f5f	64	intel	jz .+0x44332211
660f8411223344|556677885f5f5f5f5f	64	plan9	JE .+1144201745
660f841122|3344556677885f5f5f5f5f	32	intel	jz .+0x2211
660f841122|3344556677885f5f5f5f5f	32	plan9	JE .+8721
660f8511223344|556677885f5f5f5f5f	64	gnu	jne .+0x44332211
660f8511223344|556677885f5f5f5f5f	64	intel	jnz .+0x44332211
660f8511223344|556677885f5f5f5f5f	64	plan9	JNE .+1144201745
660f851122|3344556677885f5f5f5f5f	32	intel	jnz .+0x2211
660f851122|3344556677885f5f5f5f5f	32	plan9	JNE .+8721
660f8611223344|556677885f5f5f5f5f	64	gnu	jbe .+0x44332211
660f8611223344|556677885f5f5f5f5f	64	intel	jbe .+0x44332211
660f8611223344|556677885f5f5f5f5f	64	plan9	JBE .+1144201745
660f861122|3344556677885f5f5f5f5f	32	intel	jbe .+0x2211
660f861122|3344556677885f5f5f5f5f	32	plan9	JBE .+8721
660f8711223344|556677885f5f5f5f5f	64	gnu	ja .+0x44332211
660f8711223344|556677885f5f5f5f5f	64	intel	jnbe .+0x44332211
660f8711223344|556677885f5f5f5f5f	64	plan9	JA .+1144201745
660f871122|3344556677885f5f5f5f5f	32	intel	jnbe .+0x2211
660f871122|3344556677885f5f5f5f5f	32	plan9	JA .+8721
660f8811223344|556677885f5f5f5f5f	64	gnu	js .+0x44332211
660f8811223344|556677885f5f5f5f5f	64	intel	js .+0x44332211
660f8811223344|556677885f5f5f5f5f	64	plan9	JS .+1144201745
660f881122|3344556677885f5f5f5f5f	32	intel	js .+0x2211
660f881122|3344556677885f5f5f5f5f	32	plan9	JS .+8721
660f8911223344|556677885f5f5f5f5f	64	gnu	jns .+0x44332211
660f8911223344|556677885f5f5f5f5f	64	intel	jns .+0x44332211
660f8911223344|556677885f5f5f5f5f	64	plan9	JNS .+1144201745
660f891122|3344556677885f5f5f5f5f	32	intel	jns .+0x2211
660f891122|3344556677885f5f5f5f5f	32	plan9	JNS .+8721
660f8a11223344|556677885f5f5f5f5f	64	gnu	jp .+0x44332211
660f8a11223344|556677885f5f5f5f5f	64	intel	jp .+0x44332211
660f8a11223344|556677885f5f5f5f5f	64	plan9	JP .+1144201745
660f8a1122|3344556677885f5f5f5f5f	32	intel	jp .+0x2211
660f8a1122|3344556677885f5f5f5f5f	32	plan9	JP .+8721
660f8b11223344|556677885f5f5f5f5f	64	gnu	jnp .+0x44332211
660f8b11223344|556677885f5f5f5f5f	64	intel	jnp .+0x44332211
660f8b11223344|556677885f5f5f5f5f	64	plan9	JNP .+1144201745
660f8b1122|3344556677885f5f5f5f5f	32	intel	jnp .+0x2211
660f8b1122|3344556677885f5f5f5f5f	32	plan9	JNP .+8721
660f8c11223344|556677885f5f5f5f5f	64	gnu	jl .+0x44332211
660f8c11223344|556677885f5f5f5f5f	64	intel	jl .+0x44332211
660f8c11223344|556677885f5f5f5f5f	64	plan9	JL .+1144201745
660f8c1122|3344556677885f5f5f5f5f	32	intel	jl .+0x2211
660f8c1122|3344556677885f5f5f5f5f	32	plan9	JL .+8721
660f8d11223344|556677885f5f5f5f5f	64	gnu	jge .+0x44332211
660f8d11223344|556677885f5f5f5f5f	64	intel	jnl .+0x44332211
660f8d11223344|556677885f5f5f5f5f	64	plan9	JGE .+1144201745
660f8d1122|3344556677885f5f5f5f5f	32	intel	jnl .+0x2211
660f8d1122|3344556677885f5f5f5f5f	32	plan9	JGE .+8721
660f8e11223344|556677885f5f5f5f5f	64	gnu	jle .+0x44332211
660f8e11223344|556677885f5f5f5f5f	64	intel	jle .+0x44332211
660f8e11223344|556677885f5f5f5f5f	64	plan9	JLE .+1144201745
660f8e1122|3344556677885f5f5f5f5f	32	intel	jle .+0x2211
660f8e1122|3344556677885f5f5f5f5f	32	plan9	JLE .+8721
660f8f11223344|556677885f5f5f5f5f	64	gnu	jg .+0x44332211
660f8f11223344|556677885f5f5f5f5f	64	intel	jnle .+0x44332211
660f8f11223344|556677885f5f5f5f5f	64	plan9	JG .+1144201745
660f8f1122|3344556677885f5f5f5f5f	32	intel	jnle .+0x2211
660f8f1122|3344556677885f5f5f5f5f	32	plan9	JG .+8721
660fa1|11223344556677885f5f5f5f5f	32	intel	pop fs
660fa1|11223344556677885f5f5f5f5f	32	plan9	POPW FS
660fa1|11223344556677885f5f5f5f5f	64	gnu	popw %fs
660fa1|11223344556677885f5f5f5f5f	64	intel	pop fs
660fa1|11223344556677885f5f5f5f5f	64	plan9	POPW FS
660fa311|223344556677885f5f5f5f5f	32	intel	bt word ptr [ecx], dx
660fa311|223344556677885f5f5f5f5f	32	plan9	BTW DX, 0(CX)
660fa311|223344556677885f5f5f5f5f	64	gnu	bt %dx,(%rcx)
660fa311|223344556677885f5f5f5f5f	64	intel	bt word ptr [rcx], dx
660fa311|223344556677885f5f5f5f5f	64	plan9	BTW DX, 0(CX)
660fa41122|3344556677885f5f5f5f5f	32	intel	shld word ptr [ecx], dx, 0x22
660fa41122|3344556677885f5f5f5f5f	32	plan9	SHLDW $0x22, DX, 0(CX)
660fa41122|3344556677885f5f5f5f5f	64	gnu	shld $0x22,%dx,(%rcx)
660fa41122|3344556677885f5f5f5f5f	64	intel	shld word ptr [rcx], dx, 0x22
660fa41122|3344556677885f5f5f5f5f	64	plan9	SHLDW $0x22, DX, 0(CX)
660fa511|223344556677885f5f5f5f5f	32	intel	shld word ptr [ecx], dx, cl
660fa511|223344556677885f5f5f5f5f	32	plan9	SHLDW CL, DX, 0(CX)
660fa511|223344556677885f5f5f5f5f	64	gnu	shld %cl,%dx,(%rcx)
660fa511|223344556677885f5f5f5f5f	64	intel	shld word ptr [rcx], dx, cl
660fa511|223344556677885f5f5f5f5f	64	plan9	SHLDW CL, DX, 0(CX)
660fa9|11223344556677885f5f5f5f5f	32	intel	pop gs
660fa9|11223344556677885f5f5f5f5f	32	plan9	POPW GS
660fa9|11223344556677885f5f5f5f5f	64	gnu	popw %gs
660fa9|11223344556677885f5f5f5f5f	64	intel	pop gs
660fa9|11223344556677885f5f5f5f5f	64	plan9	POPW GS
660fab11|223344556677885f5f5f5f5f	32	intel	bts word ptr [ecx], dx
660fab11|223344556677885f5f5f5f5f	32	plan9	BTSW DX, 0(CX)
660fab11|223344556677885f5f5f5f5f	64	gnu	bts %dx,(%rcx)
660fab11|223344556677885f5f5f5f5f	64	intel	bts word ptr [rcx], dx
660fab11|223344556677885f5f5f5f5f	64	plan9	BTSW DX, 0(CX)
660fac1122|3344556677885f5f5f5f5f	32	intel	shrd word ptr [ecx], dx, 0x22
660fac1122|3344556677885f5f5f5f5f	32	plan9	SHRDW $0x22, DX, 0(CX)
660fac1122|3344556677885f5f5f5f5f	64	gnu	shrd $0x22,%dx,(%rcx)
660fac1122|3344556677885f5f5f5f5f	64	intel	shrd word ptr [rcx], dx, 0x22
660fac1122|3344556677885f5f5f5f5f	64	plan9	SHRDW $0x22, DX, 0(CX)
660fad11|223344556677885f5f5f5f5f	32	intel	shrd word ptr [ecx], dx, cl
660fad11|223344556677885f5f5f5f5f	32	plan9	SHRDW CL, DX, 0(CX)
660fad11|223344556677885f5f5f5f5f	64	gnu	shrd %cl,%dx,(%rcx)
660fad11|223344556677885f5f5f5f5f	64	intel	shrd word ptr [rcx], dx, cl
660fad11|223344556677885f5f5f5f5f	64	plan9	SHRDW CL, DX, 0(CX)
660fae00|11223344556677885f5f5f5f	32	intel	fxsave ptr [eax]
660fae00|11223344556677885f5f5f5f	32	plan9	FXSAVE 0(AX)
660fae00|11223344556677885f5f5f5f	64	gnu	fxsave (%rax)
660fae00|11223344556677885f5f5f5f	64	intel	fxsave ptr [rax]
660fae00|11223344556677885f5f5f5f	64	plan9	FXSAVE 0(AX)
660fae08|11223344556677885f5f5f5f	32	intel	fxrstor ptr [eax]
660fae08|11223344556677885f5f5f5f	32	plan9	FXRSTOR 0(AX)
660fae08|11223344556677885f5f5f5f	64	gnu	data16 fxrstor (%rax)
660fae08|11223344556677885f5f5f5f	64	intel	fxrstor ptr [rax]
660fae08|11223344556677885f5f5f5f	64	plan9	FXRSTOR 0(AX)
660fae20|11223344556677885f5f5f5f	32	intel	xsave ptr [eax]
660fae20|11223344556677885f5f5f5f	32	plan9	XSAVE 0(AX)
660fae20|11223344556677885f5f5f5f	64	gnu	data16 xsave (%rax)
660fae20|11223344556677885f5f5f5f	64	intel	xsave ptr [rax]
660fae20|11223344556677885f5f5f5f	64	plan9	XSAVE 0(AX)
660fae28|11223344556677885f5f5f5f	32	intel	xrstor ptr [eax]
660fae28|11223344556677885f5f5f5f	32	plan9	XRSTOR 0(AX)
660fae28|11223344556677885f5f5f5f	64	gnu	data16 xrstor (%rax)
660fae28|11223344556677885f5f5f5f	64	intel	xrstor ptr [rax]
660fae28|11223344556677885f5f5f5f	64	plan9	XRSTOR 0(AX)
660fae30|11223344556677885f5f5f5f	32	intel	xsaveopt ptr [eax]
660fae30|11223344556677885f5f5f5f	32	plan9	XSAVEOPT 0(AX)
660fae30|11223344556677885f5f5f5f	64	gnu	data16 xsaveopt (%rax)
660fae30|11223344556677885f5f5f5f	64	intel	xsaveopt ptr [rax]
660fae30|11223344556677885f5f5f5f	64	plan9	XSAVEOPT 0(AX)
660faf11|223344556677885f5f5f5f5f	32	intel	imul dx, word ptr [ecx]
660faf11|223344556677885f5f5f5f5f	32	plan9	IMULW 0(CX), DX
660faf11|223344556677885f5f5f5f5f	64	gnu	imul (%rcx),%dx
660faf11|223344556677885f5f5f5f5f	64	intel	imul dx, word ptr [rcx]
660faf11|223344556677885f5f5f5f5f	64	plan9	IMULW 0(CX), DX
660fb111|223344556677885f5f5f5f5f	32	intel	cmpxchg word ptr [ecx], dx
660fb111|223344556677885f5f5f5f5f	32	plan9	CMPXCHGW DX, 0(CX)
660fb111|223344556677885f5f5f5f5f	64	gnu	cmpxchg %dx,(%rcx)
660fb111|223344556677885f5f5f5f5f	64	intel	cmpxchg word ptr [rcx], dx
660fb111|223344556677885f5f5f5f5f	64	plan9	CMPXCHGW DX, 0(CX)
660fb211|223344556677885f5f5f5f5f	32	intel	lss dx, dword ptr [ecx]
660fb211|223344556677885f5f5f5f5f	32	plan9	LSS 0(CX), DX
660fb211|223344556677885f5f5f5f5f	64	gnu	lss (%rcx),%dx
660fb211|223344556677885f5f5f5f5f	64	intel	lss dx, dword ptr [rcx]
660fb211|223344556677885f5f5f5f5f	64	plan9	LSS 0(CX), DX
660fb311|223344556677885f5f5f5f5f	32	intel	btr word ptr [ecx], dx
660fb311|223344556677885f5f5f5f5f	32	plan9	BTRW DX, 0(CX)
660fb311|223344556677885f5f5f5f5f	64	gnu	btr %dx,(%rcx)
660fb311|223344556677885f5f5f5f5f	64	intel	btr word ptr [rcx], dx
660fb311|223344556677885f5f5f5f5f	64	plan9	BTRW DX, 0(CX)
660fb411|223344556677885f5f5f5f5f	32	intel	lfs dx, dword ptr [ecx]
660fb411|223344556677885f5f5f5f5f	32	plan9	LFS 0(CX), DX
660fb411|223344556677885f5f5f5f5f	64	gnu	lfs (%rcx),%dx
660fb411|223344556677885f5f5f5f5f	64	intel	lfs dx, dword ptr [rcx]
660fb411|223344556677885f5f5f5f5f	64	plan9	LFS 0(CX), DX
660fb511|223344556677885f5f5f5f5f	32	intel	lgs dx, dword ptr [ecx]
660fb511|223344556677885f5f5f5f5f	32	plan9	LGS 0(CX), DX
660fb511|223344556677885f5f5f5f5f	64	gnu	lgs (%rcx),%dx
660fb511|223344556677885f5f5f5f5f	64	intel	lgs dx, dword ptr [rcx]
660fb511|223344556677885f5f5f5f5f	64	plan9	LGS 0(CX), DX
660fb611|223344556677885f5f5f5f5f	32	intel	movzx dx, byte ptr [ecx]
660fb611|223344556677885f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
660fb611|223344556677885f5f5f5f5f	64	gnu	movzbw (%rcx),%dx
660fb611|223344556677885f5f5f5f5f	64	intel	movzx dx, byte ptr [rcx]
660fb611|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
660fb711|223344556677885f5f5f5f5f	32	intel	movzx dx, word ptr [ecx]
660fb711|223344556677885f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
660fb711|223344556677885f5f5f5f5f	64	gnu	movzww (%rcx),%dx
660fb711|223344556677885f5f5f5f5f	64	intel	movzx dx, word ptr [rcx]
660fb711|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
660fba2011|223344556677885f5f5f5f	32	intel	bt word ptr [eax], 0x11
660fba2011|223344556677885f5f5f5f	32	plan9	BTW $0x11, 0(AX)
660fba2011|223344556677885f5f5f5f	64	gnu	btw $0x11,(%rax)
660fba2011|223344556677885f5f5f5f	64	intel	bt word ptr [rax], 0x11
660fba2011|223344556677885f5f5f5f	64	plan9	BTW $0x11, 0(AX)
660fba2811|223344556677885f5f5f5f	32	intel	bts word ptr [eax], 0x11
660fba2811|223344556677885f5f5f5f	32	plan9	BTSW $0x11, 0(AX)
660fba2811|223344556677885f5f5f5f	64	gnu	btsw $0x11,(%rax)
660fba2811|223344556677885f5f5f5f	64	intel	bts word ptr [rax], 0x11
660fba2811|223344556677885f5f5f5f	64	plan9	BTSW $0x11, 0(AX)
660fba3011|223344556677885f5f5f5f	32	intel	btr word ptr [eax], 0x11
660fba3011|223344556677885f5f5f5f	32	plan9	BTRW $0x11, 0(AX)
660fba3011|223344556677885f5f5f5f	64	gnu	btrw $0x11,(%rax)
660fba3011|223344556677885f5f5f5f	64	intel	btr word ptr [rax], 0x11
660fba3011|223344556677885f5f5f5f	64	plan9	BTRW $0x11, 0(AX)
660fba3811|223344556677885f5f5f5f	32	intel	btc word ptr [eax], 0x11
660fba3811|223344556677885f5f5f5f	32	plan9	BTCW $0x11, 0(AX)
660fba3811|223344556677885f5f5f5f	64	gnu	btcw $0x11,(%rax)
660fba3811|223344556677885f5f5f5f	64	intel	btc word ptr [rax], 0x11
660fba3811|223344556677885f5f5f5f	64	plan9	BTCW $0x11, 0(AX)
660fbb11|223344556677885f5f5f5f5f	32	intel	btc word ptr [ecx], dx
660fbb11|223344556677885f5f5f5f5f	32	plan9	BTCW DX, 0(CX)
660fbb11|223344556677885f5f5f5f5f	64	gnu	btc %dx,(%rcx)
660fbb11|223344556677885f5f5f5f5f	64	intel	btc word ptr [rcx], dx
660fbb11|223344556677885f5f5f5f5f	64	plan9	BTCW DX, 0(CX)
660fbc11|223344556677885f5f5f5f5f	32	intel	bsf dx, word ptr [ecx]
660fbc11|223344556677885f5f5f5f5f	32	plan9	BSFW 0(CX), DX
660fbc11|223344556677885f5f5f5f5f	64	gnu	bsf (%rcx),%dx
660fbc11|223344556677885f5f5f5f5f	64	intel	bsf dx, word ptr [rcx]
660fbc11|223344556677885f5f5f5f5f	64	plan9	BSFW 0(CX), DX
660fbd11|223344556677885f5f5f5f5f	32	intel	bsr dx, word ptr [ecx]
660fbd11|223344556677885f5f5f5f5f	32	plan9	BSRW 0(CX), DX
660fbd11|223344556677885f5f5f5f5f	64	gnu	bsr (%rcx),%dx
660fbd11|223344556677885f5f5f5f5f	64	intel	bsr dx, word ptr [rcx]
660fbd11|223344556677885f5f5f5f5f	64	plan9	BSRW 0(CX), DX
660fbe11|223344556677885f5f5f5f5f	32	intel	movsx dx, byte ptr [ecx]
660fbe11|223344556677885f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
660fbe11|223344556677885f5f5f5f5f	64	gnu	movsbw (%rcx),%dx
660fbe11|223344556677885f5f5f5f5f	64	intel	movsx dx, byte ptr [rcx]
660fbe11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
660fbf11|223344556677885f5f5f5f5f	32	intel	movsx dx, word ptr [ecx]
660fbf11|223344556677885f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
660fbf11|223344556677885f5f5f5f5f	64	gnu	movsww (%rcx),%dx
660fbf11|223344556677885f5f5f5f5f	64	intel	movsx dx, word ptr [rcx]
660fbf11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
660fc111|223344556677885f5f5f5f5f	32	intel	xadd word ptr [ecx], dx
660fc111|223344556677885f5f5f5f5f	32	plan9	XADDW DX, 0(CX)
660fc111|223344556677885f5f5f5f5f	64	gnu	xadd %dx,(%rcx)
660fc111|223344556677885f5f5f5f5f	64	intel	xadd word ptr [rcx], dx
660fc111|223344556677885f5f5f5f5f	64	plan9	XADDW DX, 0(CX)
660fc21122|3344556677885f5f5f5f5f	32	intel	cmppd xmm2, xmmword ptr [ecx], 0x22
660fc21122|3344556677885f5f5f5f5f	32	plan9	CMPPD $0x22, 0(CX), X2
660fc21122|3344556677885f5f5f5f5f	64	gnu	cmppd $0x22,(%rcx),%xmm2
660fc21122|3344556677885f5f5f5f5f	64	intel	cmppd xmm2, xmmword ptr [rcx], 0x22
660fc21122|3344556677885f5f5f5f5f	64	plan9	CMPPD $0x22, 0(CX), X2
660fc311|223344556677885f5f5f5f5f	32	intel	movnti dword ptr [ecx], edx
660fc311|223344556677885f5f5f5f5f	32	plan9	MOVNTIW DX, 0(CX)
660fc311|223344556677885f5f5f5f5f	64	gnu	movnti %edx,(%rcx)
660fc311|223344556677885f5f5f5f5f	64	intel	movnti dword ptr [rcx], edx
660fc311|223344556677885f5f5f5f5f	64	plan9	MOVNTIW DX, 0(CX)
660fc41122|3344556677885f5f5f5f5f	32	intel	pinsrw xmm2, word ptr [ecx], 0x22
660fc41122|3344556677885f5f5f5f5f	32	plan9	PINSRW $0x22, 0(CX), X2
660fc41122|3344556677885f5f5f5f5f	64	gnu	pinsrw $0x22,(%rcx),%xmm2
660fc41122|3344556677885f5f5f5f5f	64	intel	pinsrw xmm2, word ptr [rcx], 0x22
660fc41122|3344556677885f5f5f5f5f	64	plan9	PINSRW $0x22, 0(CX), X2
660fc5c011|223344556677885f5f5f5f	32	intel	pextrw eax, xmm0, 0x11
660fc5c011|223344556677885f5f5f5f	32	plan9	PEXTRW $0x11, X0, AX
660fc5c011|223344556677885f5f5f5f	64	gnu	pextrw $0x11,%xmm0,%eax
660fc5c011|223344556677885f5f5f5f	64	intel	pextrw eax, xmm0, 0x11
660fc5c011|223344556677885f5f5f5f	64	plan9	PEXTRW $0x11, X0, AX
660fc61122|3344556677885f5f5f5f5f	32	intel	shufpd xmm2, xmmword ptr [ecx], 0x22
660fc61122|3344556677885f5f5f5f5f	32	plan9	SHUFPD $0x22, 0(CX), X2
660fc61122|3344556677885f5f5f5f5f	64	gnu	shufpd $0x22,(%rcx),%xmm2
660fc61122|3344556677885f5f5f5f5f	64	intel	shufpd xmm2, xmmword ptr [rcx], 0x22
660fc61122|3344556677885f5f5f5f5f	64	plan9	SHUFPD $0x22, 0(CX), X2
660fc708|11223344556677885f5f5f5f	32	intel	cmpxchg8b qword ptr [eax]
660fc708|11223344556677885f5f5f5f	32	plan9	CMPXCHG8B 0(AX)
660fc708|11223344556677885f5f5f5f	64	gnu	data16 cmpxchg8b (%rax)
660fc708|11223344556677885f5f5f5f	64	intel	cmpxchg8b qword ptr [rax]
660fc708|11223344556677885f5f5f5f	64	plan9	CMPXCHG8B 0(AX)
660fc718|11223344556677885f5f5f5f	32	intel	xrstors ptr [eax]
660fc718|11223344556677885f5f5f5f	32	plan9	XRSTORS 0(AX)
660fc718|11223344556677885f5f5f5f	64	gnu	xrstors (%rax)
660fc718|11223344556677885f5f5f5f	64	intel	xrstors ptr [rax]
660fc718|11223344556677885f5f5f5f	64	plan9	XRSTORS 0(AX)
660fc720|11223344556677885f5f5f5f	32	intel	xsavec ptr [eax]
660fc720|11223344556677885f5f5f5f	32	plan9	XSAVEC 0(AX)
660fc720|11223344556677885f5f5f5f	64	gnu	xsavec (%rax)
660fc720|11223344556677885f5f5f5f	64	intel	xsavec ptr [rax]
660fc720|11223344556677885f5f5f5f	64	plan9	XSAVEC 0(AX)
660fc728|11223344556677885f5f5f5f	32	intel	xsaves ptr [eax]
660fc728|11223344556677885f5f5f5f	32	plan9	XSAVES 0(AX)
660fc728|11223344556677885f5f5f5f	64	gnu	xsaves (%rax)
660fc728|11223344556677885f5f5f5f	64	intel	xsaves ptr [rax]
660fc728|11223344556677885f5f5f5f	64	plan9	XSAVES 0(AX)
660fc7f2|11223344556677885f5f5f5f	32	intel	rdrand dx
660fc7f2|11223344556677885f5f5f5f	32	plan9	RDRAND DX
660fc7f2|11223344556677885f5f5f5f	64	gnu	rdrand %dx
660fc7f2|11223344556677885f5f5f5f	64	intel	rdrand dx
660fc7f2|11223344556677885f5f5f5f	64	plan9	RDRAND DX
660fc8|11223344556677885f5f5f5f5f	32	intel	bswap ax
660fc8|11223344556677885f5f5f5f5f	32	plan9	BSWAP AX
660fc8|11223344556677885f5f5f5f5f	64	gnu	bswap %ax
660fc8|11223344556677885f5f5f5f5f	64	intel	bswap ax
660fc8|11223344556677885f5f5f5f5f	64	plan9	BSWAP AX
660fd011|223344556677885f5f5f5f5f	32	intel	addsubpd xmm2, xmmword ptr [ecx]
660fd011|223344556677885f5f5f5f5f	32	plan9	ADDSUBPD 0(CX), X2
660fd011|223344556677885f5f5f5f5f	64	gnu	addsubpd (%rcx),%xmm2
660fd011|223344556677885f5f5f5f5f	64	intel	addsubpd xmm2, xmmword ptr [rcx]
660fd011|223344556677885f5f5f5f5f	64	plan9	ADDSUBPD 0(CX), X2
660fd111|223344556677885f5f5f5f5f	32	intel	psrlw xmm2, xmmword ptr [ecx]
660fd111|223344556677885f5f5f5f5f	32	plan9	PSRLW 0(CX), X2
660fd111|223344556677885f5f5f5f5f	64	gnu	psrlw (%rcx),%xmm2
660fd111|223344556677885f5f5f5f5f	64	intel	psrlw xmm2, xmmword ptr [rcx]
660fd111|223344556677885f5f5f5f5f	64	plan9	PSRLW 0(CX), X2
660fd211|223344556677885f5f5f5f5f	32	intel	psrld xmm2, xmmword ptr [ecx]
660fd211|223344556677885f5f5f5f5f	32	plan9	PSRLD 0(CX), X2
660fd211|223344556677885f5f5f5f5f	64	gnu	psrld (%rcx),%xmm2
660fd211|223344556677885f5f5f5f5f	64	intel	psrld xmm2, xmmword ptr [rcx]
660fd211|223344556677885f5f5f5f5f	64	plan9	PSRLD 0(CX), X2
660fd311|223344556677885f5f5f5f5f	32	intel	psrlq xmm2, xmmword ptr [ecx]
660fd311|223344556677885f5f5f5f5f	32	plan9	PSRLQ 0(CX), X2
660fd311|223344556677885f5f5f5f5f	64	gnu	psrlq (%rcx),%xmm2
660fd311|223344556677885f5f5f5f5f	64	intel	psrlq xmm2, xmmword ptr [rcx]
660fd311|223344556677885f5f5f5f5f	64	plan9	PSRLQ 0(CX), X2
660fd411|223344556677885f5f5f5f5f	32	intel	paddq xmm2, xmmword ptr [ecx]
660fd411|223344556677885f5f5f5f5f	32	plan9	PADDQ 0(CX), X2
660fd411|223344556677885f5f5f5f5f	64	gnu	paddq (%rcx),%xmm2
660fd411|223344556677885f5f5f5f5f	64	intel	paddq xmm2, xmmword ptr [rcx]
660fd411|223344556677885f5f5f5f5f	64	plan9	PADDQ 0(CX), X2
660fd511|223344556677885f5f5f5f5f	32	intel	pmullw xmm2, xmmword ptr [ecx]
660fd511|223344556677885f5f5f5f5f	32	plan9	PMULLW 0(CX), X2
660fd511|223344556677885f5f5f5f5f	64	gnu	pmullw (%rcx),%xmm2
660fd511|223344556677885f5f5f5f5f	64	intel	pmullw xmm2, xmmword ptr [rcx]
660fd511|223344556677885f5f5f5f5f	64	plan9	PMULLW 0(CX), X2
660fd611|223344556677885f5f5f5f5f	32	intel	movq qword ptr [ecx], xmm2
660fd611|223344556677885f5f5f5f5f	32	plan9	MOVQ X2, 0(CX)
660fd611|223344556677885f5f5f5f5f	64	gnu	movq %xmm2,(%rcx)
660fd611|223344556677885f5f5f5f5f	64	intel	movq qword ptr [rcx], xmm2
660fd611|223344556677885f5f5f5f5f	64	plan9	MOVQ X2, 0(CX)
660fd7c0|11223344556677885f5f5f5f	32	intel	pmovmskb eax, xmm0
660fd7c0|11223344556677885f5f5f5f	32	plan9	PMOVMSKB X0, AX
660fd7c0|11223344556677885f5f5f5f	64	gnu	pmovmskb %xmm0,%eax
660fd7c0|11223344556677885f5f5f5f	64	intel	pmovmskb eax, xmm0
660fd7c0|11223344556677885f5f5f5f	64	plan9	PMOVMSKB X0, AX
660fd811|223344556677885f5f5f5f5f	32	intel	psubusb xmm2, xmmword ptr [ecx]
660fd811|223344556677885f5f5f5f5f	32	plan9	PSUBUSB 0(CX), X2
660fd811|223344556677885f5f5f5f5f	64	gnu	psubusb (%rcx),%xmm2
660fd811|223344556677885f5f5f5f5f	64	intel	psubusb xmm2, xmmword ptr [rcx]
660fd811|223344556677885f5f5f5f5f	64	plan9	PSUBUSB 0(CX), X2
660fd911|223344556677885f5f5f5f5f	32	intel	psubusw xmm2, xmmword ptr [ecx]
660fd911|223344556677885f5f5f5f5f	32	plan9	PSUBUSW 0(CX), X2
660fd911|223344556677885f5f5f5f5f	64	gnu	psubusw (%rcx),%xmm2
660fd911|223344556677885f5f5f5f5f	64	intel	psubusw xmm2, xmmword ptr [rcx]
660fd911|223344556677885f5f5f5f5f	64	plan9	PSUBUSW 0(CX), X2
660fda11|223344556677885f5f5f5f5f	32	intel	pminub xmm2, xmmword ptr [ecx]
660fda11|223344556677885f5f5f5f5f	32	plan9	PMINUB 0(CX), X2
660fda11|223344556677885f5f5f5f5f	64	gnu	pminub (%rcx),%xmm2
660fda11|223344556677885f5f5f5f5f	64	intel	pminub xmm2, xmmword ptr [rcx]
660fda11|223344556677885f5f5f5f5f	64	plan9	PMINUB 0(CX), X2
660fdb11|223344556677885f5f5f5f5f	32	intel	pand xmm2, xmmword ptr [ecx]
660fdb11|223344556677885f5f5f5f5f	32	plan9	PAND 0(CX), X2
660fdb11|223344556677885f5f5f5f5f	64	gnu	pand (%rcx),%xmm2
660fdb11|223344556677885f5f5f5f5f	64	intel	pand xmm2, xmmword ptr [rcx]
660fdb11|223344556677885f5f5f5f5f	64	plan9	PAND 0(CX), X2
660fdc11|223344556677885f5f5f5f5f	32	intel	paddusb xmm2, xmmword ptr [ecx]
660fdc11|223344556677885f5f5f5f5f	32	plan9	PADDUSB 0(CX), X2
660fdc11|223344556677885f5f5f5f5f	64	gnu	paddusb (%rcx),%xmm2
660fdc11|223344556677885f5f5f5f5f	64	intel	paddusb xmm2, xmmword ptr [rcx]
660fdc11|223344556677885f5f5f5f5f	64	plan9	PADDUSB 0(CX), X2
660fdd11|223344556677885f5f5f5f5f	32	intel	paddusw xmm2, xmmword ptr [ecx]
660fdd11|223344556677885f5f5f5f5f	32	plan9	PADDUSW 0(CX), X2
660fdd11|223344556677885f5f5f5f5f	64	gnu	paddusw (%rcx),%xmm2
660fdd11|223344556677885f5f5f5f5f	64	intel	paddusw xmm2, xmmword ptr [rcx]
660fdd11|223344556677885f5f5f5f5f	64	plan9	PADDUSW 0(CX), X2
660fde11|223344556677885f5f5f5f5f	32	intel	pmaxub xmm2, xmmword ptr [ecx]
660fde11|223344556677885f5f5f5f5f	32	plan9	PMAXUB 0(CX), X2
660fde11|223344556677885f5f5f5f5f	64	gnu	pmaxub (%rcx),%xmm2
660fde11|223344556677885f5f5f5f5f	64	intel	pmaxub xmm2, xmmword ptr [rcx]
660fde11|223344556677885f5f5f5f5f	64	plan9	PMAXUB 0(CX), X2
660fdf11|223344556677885f5f5f5f5f	32	intel	pandn xmm2, xmmword ptr [ecx]
660fdf11|223344556677885f5f5f5f5f	32	plan9	PANDN 0(CX), X2
660fdf11|223344556677885f5f5f5f5f	64	gnu	pandn (%rcx),%xmm2
660fdf11|223344556677885f5f5f5f5f	64	intel	pandn xmm2, xmmword ptr [rcx]
660fdf11|223344556677885f5f5f5f5f	64	plan9	PANDN 0(CX), X2
660fe011|223344556677885f5f5f5f5f	32	intel	pavgb xmm2, xmmword ptr [ecx]
660fe011|223344556677885f5f5f5f5f	32	plan9	PAVGB 0(CX), X2
660fe011|223344556677885f5f5f5f5f	64	gnu	pavgb (%rcx),%xmm2
660fe011|223344556677885f5f5f5f5f	64	intel	pavgb xmm2, xmmword ptr [rcx]
660fe011|223344556677885f5f5f5f5f	64	plan9	PAVGB 0(CX), X2
660fe111|223344556677885f5f5f5f5f	32	intel	psraw xmm2, xmmword ptr [ecx]
660fe111|223344556677885f5f5f5f5f	32	plan9	PSRAW 0(CX), X2
660fe111|223344556677885f5f5f5f5f	64	gnu	psraw (%rcx),%xmm2
660fe111|223344556677885f5f5f5f5f	64	intel	psraw xmm2, xmmword ptr [rcx]
660fe111|223344556677885f5f5f5f5f	64	plan9	PSRAW 0(CX), X2
660fe211|223344556677885f5f5f5f5f	32	intel	psrad xmm2, xmmword ptr [ecx]
660fe211|223344556677885f5f5f5f5f	32	plan9	PSRAD 0(CX), X2
660fe211|223344556677885f5f5f5f5f	64	gnu	psrad (%rcx),%xmm2
660fe211|223344556677885f5f5f5f5f	64	intel	psrad xmm2, xmmword ptr [rcx]
660fe211|223344556677885f5f5f5f5f	64	plan9	PSRAD 0(CX), X2
660fe311|223344556677885f5f5f5f5f	32	intel	pavgw xmm2, xmmword ptr [ecx]
660fe311|223344556677885f5f5f5f5f	32	plan9	PAVGW 0(CX), X2
660fe311|223344556677885f5f5f5f5f	64	gnu	pavgw (%rcx),%xmm2
660fe311|223344556677885f5f5f5f5f	64	intel	pavgw xmm2, xmmword ptr [rcx]
660fe311|223344556677885f5f5f5f5f	64	plan9	PAVGW 0(CX), X2
660fe411|223344556677885f5f5f5f5f	32	intel	pmulhuw xmm2, xmmword ptr [ecx]
660fe411|223344556677885f5f5f5f5f	32	plan9	PMULHUW 0(CX), X2
660fe411|223344556677885f5f5f5f5f	64	gnu	pmulhuw (%rcx),%xmm2
660fe411|223344556677885f5f5f5f5f	64	intel	pmulhuw xmm2, xmmword ptr [rcx]
660fe411|223344556677885f5f5f5f5f	64	plan9	PMULHUW 0(CX), X2
660fe511|223344556677885f5f5f5f5f	32	intel	pmulhw xmm2, xmmword ptr [ecx]
660fe511|223344556677885f5f5f5f5f	32	plan9	PMULHW 0(CX), X2
660fe511|223344556677885f5f5f5f5f	64	gnu	pmulhw (%rcx),%xmm2
660fe511|223344556677885f5f5f5f5f	64	intel	pmulhw xmm2, xmmword ptr [rcx]
660fe511|223344556677885f5f5f5f5f	64	plan9	PMULHW 0(CX), X2
660fe611|223344556677885f5f5f5f5f	32	intel	cvttpd2dq xmm2, xmmword ptr [ecx]
660fe611|223344556677885f5f5f5f5f	32	plan9	CVTTPD2DQ 0(CX), X2
660fe611|223344556677885f5f5f5f5f	64	gnu	cvttpd2dq (%rcx),%xmm2
660fe611|223344556677885f5f5f5f5f	64	intel	cvttpd2dq xmm2, xmmword ptr [rcx]
660fe611|223344556677885f5f5f5f5f	64	plan9	CVTTPD2DQ 0(CX), X2
660fe711|223344556677885f5f5f5f5f	32	intel	movntdq xmmword ptr [ecx], xmm2
660fe711|223344556677885f5f5f5f5f	32	plan9	MOVNTDQ X2, 0(CX)
660fe711|223344556677885f5f5f5f5f	64	gnu	movntdq %xmm2,(%rcx)
660fe711|223344556677885f5f5f5f5f	64	intel	movntdq xmmword ptr [rcx], xmm2
660fe711|223344556677885f5f5f5f5f	64	plan9	MOVNTDQ X2, 0(CX)
660fe811|223344556677885f5f5f5f5f	32	intel	psubsb xmm2, xmmword ptr [ecx]
660fe811|223344556677885f5f5f5f5f	32	plan9	PSUBSB 0(CX), X2
660fe811|223344556677885f5f5f5f5f	64	gnu	psubsb (%rcx),%xmm2
660fe811|223344556677885f5f5f5f5f	64	intel	psubsb xmm2, xmmword ptr [rcx]
660fe811|223344556677885f5f5f5f5f	64	plan9	PSUBSB 0(CX), X2
660fe911|223344556677885f5f5f5f5f	32	intel	psubsw xmm2, xmmword ptr [ecx]
660fe911|223344556677885f5f5f5f5f	32	plan9	PSUBSW 0(CX), X2
660fe911|223344556677885f5f5f5f5f	64	gnu	psubsw (%rcx),%xmm2
660fe911|223344556677885f5f5f5f5f	64	intel	psubsw xmm2, xmmword ptr [rcx]
660fe911|223344556677885f5f5f5f5f	64	plan9	PSUBSW 0(CX), X2
660fea11|223344556677885f5f5f5f5f	32	intel	pminsw xmm2, xmmword ptr [ecx]
660fea11|223344556677885f5f5f5f5f	32	plan9	PMINSW 0(CX), X2
660fea11|223344556677885f5f5f5f5f	64	gnu	pminsw (%rcx),%xmm2
660fea11|223344556677885f5f5f5f5f	64	intel	pminsw xmm2, xmmword ptr [rcx]
660fea11|223344556677885f5f5f5f5f	64	plan9	PMINSW 0(CX), X2
660feb11|223344556677885f5f5f5f5f	32	intel	por xmm2, xmmword ptr [ecx]
660feb11|223344556677885f5f5f5f5f	32	plan9	POR 0(CX), X2
660feb11|223344556677885f5f5f5f5f	64	gnu	por (%rcx),%xmm2
660feb11|223344556677885f5f5f5f5f	64	intel	por xmm2, xmmword ptr [rcx]
660feb11|223344556677885f5f5f5f5f	64	plan9	POR 0(CX), X2
660fec11|223344556677885f5f5f5f5f	32	intel	paddsb xmm2, xmmword ptr [ecx]
660fec11|223344556677885f5f5f5f5f	32	plan9	PADDSB 0(CX), X2
660fec11|223344556677885f5f5f5f5f	64	gnu	paddsb (%rcx),%xmm2
660fec11|223344556677885f5f5f5f5f	64	intel	paddsb xmm2, xmmword ptr [rcx]
660fec11|223344556677885f5f5f5f5f	64	plan9	PADDSB 0(CX), X2
660fed11|223344556677885f5f5f5f5f	32	intel	paddsw xmm2, xmmword ptr [ecx]
660fed11|223344556677885f5f5f5f5f	32	plan9	PADDSW 0(CX), X2
660fed11|223344556677885f5f5f5f5f	64	gnu	paddsw (%rcx),%xmm2
660fed11|223344556677885f5f5f5f5f	64	intel	paddsw xmm2, xmmword ptr [rcx]
660fed11|223344556677885f5f5f5f5f	64	plan9	PADDSW 0(CX), X2
660fee11|223344556677885f5f5f5f5f	32	intel	pmaxsw xmm2, xmmword ptr [ecx]
660fee11|223344556677885f5f5f5f5f	32	plan9	PMAXSW 0(CX), X2
660fee11|223344556677885f5f5f5f5f	64	gnu	pmaxsw (%rcx),%xmm2
660fee11|223344556677885f5f5f5f5f	64	intel	pmaxsw xmm2, xmmword ptr [rcx]
660fee11|223344556677885f5f5f5f5f	64	plan9	PMAXSW 0(CX), X2
660fef11|223344556677885f5f5f5f5f	32	intel	pxor xmm2, xmmword ptr [ecx]
660fef11|223344556677885f5f5f5f5f	32	plan9	PXOR 0(CX), X2
660fef11|223344556677885f5f5f5f5f	64	gnu	pxor (%rcx),%xmm2
660fef11|223344556677885f5f5f5f5f	64	intel	pxor xmm2, xmmword ptr [rcx]
660fef11|223344556677885f5f5f5f5f	64	plan9	PXOR 0(CX), X2
660ff111|223344556677885f5f5f5f5f	32	intel	psllw xmm2, xmmword ptr [ecx]
660ff111|223344556677885f5f5f5f5f	32	plan9	PSLLW 0(CX), X2
660ff111|223344556677885f5f5f5f5f	64	gnu	psllw (%rcx),%xmm2
660ff111|223344556677885f5f5f5f5f	64	intel	psllw xmm2, xmmword ptr [rcx]
660ff111|223344556677885f5f5f5f5f	64	plan9	PSLLW 0(CX), X2
660ff211|223344556677885f5f5f5f5f	32	intel	pslld xmm2, xmmword ptr [ecx]
660ff211|223344556677885f5f5f5f5f	32	plan9	PSLLD 0(CX), X2
660ff211|223344556677885f5f5f5f5f	64	gnu	pslld (%rcx),%xmm2
660ff211|223344556677885f5f5f5f5f	64	intel	pslld xmm2, xmmword ptr [rcx]
660ff211|223344556677885f5f5f5f5f	64	plan9	PSLLD 0(CX), X2
660ff311|223344556677885f5f5f5f5f	32	intel	psllq xmm2, xmmword ptr [ecx]
660ff311|223344556677885f5f5f5f5f	32	plan9	PSLLQ 0(CX), X2
660ff311|223344556677885f5f5f5f5f	64	gnu	psllq (%rcx),%xmm2
660ff311|223344556677885f5f5f5f5f	64	intel	psllq xmm2, xmmword ptr [rcx]
660ff311|223344556677885f5f5f5f5f	64	plan9	PSLLQ 0(CX), X2
660ff411|223344556677885f5f5f5f5f	32	intel	pmuludq xmm2, xmmword ptr [ecx]
660ff411|223344556677885f5f5f5f5f	32	plan9	PMULUDQ 0(CX), X2
660ff411|223344556677885f5f5f5f5f	64	gnu	pmuludq (%rcx),%xmm2
660ff411|223344556677885f5f5f5f5f	64	intel	pmuludq xmm2, xmmword ptr [rcx]
660ff411|223344556677885f5f5f5f5f	64	plan9	PMULUDQ 0(CX), X2
660ff511|223344556677885f5f5f5f5f	32	intel	pmaddwd xmm2, xmmword ptr [ecx]
660ff511|223344556677885f5f5f5f5f	32	plan9	PMADDWD 0(CX), X2
660ff511|223344556677885f5f5f5f5f	64	gnu	pmaddwd (%rcx),%xmm2
660ff511|223344556677885f5f5f5f5f	64	intel	pmaddwd xmm2, xmmword ptr [rcx]
660ff511|223344556677885f5f5f5f5f	64	plan9	PMADDWD 0(CX), X2
660ff611|223344556677885f5f5f5f5f	32	intel	psadbw xmm2, xmmword ptr [ecx]
660ff611|223344556677885f5f5f5f5f	32	plan9	PSADBW 0(CX), X2
660ff611|223344556677885f5f5f5f5f	64	gnu	psadbw (%rcx),%xmm2
660ff611|223344556677885f5f5f5f5f	64	intel	psadbw xmm2, xmmword ptr [rcx]
660ff611|223344556677885f5f5f5f5f	64	plan9	PSADBW 0(CX), X2
660ff7c0|11223344556677885f5f5f5f	32	intel	maskmovdqu xmm0, xmm0
660ff7c0|11223344556677885f5f5f5f	32	plan9	MASKMOVDQU X0, X0
660ff7c0|11223344556677885f5f5f5f	64	intel	maskmovdqu xmm0, xmm0
660ff7c0|11223344556677885f5f5f5f	64	plan9	MASKMOVDQU X0, X0
660ff811|223344556677885f5f5f5f5f	32	intel	psubb xmm2, xmmword ptr [ecx]
660ff811|223344556677885f5f5f5f5f	32	plan9	PSUBB 0(CX), X2
660ff811|223344556677885f5f5f5f5f	64	gnu	psubb (%rcx),%xmm2
660ff811|223344556677885f5f5f5f5f	64	intel	psubb xmm2, xmmword ptr [rcx]
660ff811|223344556677885f5f5f5f5f	64	plan9	PSUBB 0(CX), X2
660ff911|223344556677885f5f5f5f5f	32	intel	psubw xmm2, xmmword ptr [ecx]
660ff911|223344556677885f5f5f5f5f	32	plan9	PSUBW 0(CX), X2
660ff911|223344556677885f5f5f5f5f	64	gnu	psubw (%rcx),%xmm2
660ff911|223344556677885f5f5f5f5f	64	intel	psubw xmm2, xmmword ptr [rcx]
660ff911|223344556677885f5f5f5f5f	64	plan9	PSUBW 0(CX), X2
660ffa11|223344556677885f5f5f5f5f	32	intel	psubd xmm2, xmmword ptr [ecx]
660ffa11|223344556677885f5f5f5f5f	32	plan9	PSUBD 0(CX), X2
660ffa11|223344556677885f5f5f5f5f	64	gnu	psubd (%rcx),%xmm2
660ffa11|223344556677885f5f5f5f5f	64	intel	psubd xmm2, xmmword ptr [rcx]
660ffa11|223344556677885f5f5f5f5f	64	plan9	PSUBD 0(CX), X2
660ffb11|223344556677885f5f5f5f5f	32	intel	psubq xmm2, xmmword ptr [ecx]
660ffb11|223344556677885f5f5f5f5f	32	plan9	PSUBQ 0(CX), X2
660ffb11|223344556677885f5f5f5f5f	64	gnu	psubq (%rcx),%xmm2
660ffb11|223344556677885f5f5f5f5f	64	intel	psubq xmm2, xmmword ptr [rcx]
660ffb11|223344556677885f5f5f5f5f	64	plan9	PSUBQ 0(CX), X2
660ffc11|223344556677885f5f5f5f5f	32	intel	paddb xmm2, xmmword ptr [ecx]
660ffc11|223344556677885f5f5f5f5f	32	plan9	PADDB 0(CX), X2
660ffc11|223344556677885f5f5f5f5f	64	gnu	paddb (%rcx),%xmm2
660ffc11|223344556677885f5f5f5f5f	64	intel	paddb xmm2, xmmword ptr [rcx]
660ffc11|223344556677885f5f5f5f5f	64	plan9	PADDB 0(CX), X2
660ffd11|223344556677885f5f5f5f5f	32	intel	paddw xmm2, xmmword ptr [ecx]
660ffd11|223344556677885f5f5f5f5f	32	plan9	PADDW 0(CX), X2
660ffd11|223344556677885f5f5f5f5f	64	gnu	paddw (%rcx),%xmm2
660ffd11|223344556677885f5f5f5f5f	64	intel	paddw xmm2, xmmword ptr [rcx]
660ffd11|223344556677885f5f5f5f5f	64	plan9	PADDW 0(CX), X2
660ffe11|223344556677885f5f5f5f5f	32	intel	paddd xmm2, xmmword ptr [ecx]
660ffe11|223344556677885f5f5f5f5f	32	plan9	PADDD 0(CX), X2
660ffe11|223344556677885f5f5f5f5f	64	gnu	paddd (%rcx),%xmm2
660ffe11|223344556677885f5f5f5f5f	64	intel	paddd xmm2, xmmword ptr [rcx]
660ffe11|223344556677885f5f5f5f5f	64	plan9	PADDD 0(CX), X2
661122|3344556677885f5f5f5f5f5f5f	32	intel	adc word ptr [edx], sp
661122|3344556677885f5f5f5f5f5f5f	32	plan9	ADCW SP, 0(DX)
661122|3344556677885f5f5f5f5f5f5f	64	gnu	adc %sp,(%rdx)
661122|3344556677885f5f5f5f5f5f5f	64	intel	adc word ptr [rdx], sp
661122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCW SP, 0(DX)
661311|223344556677885f5f5f5f5f5f	32	intel	adc dx, word ptr [ecx]
661311|223344556677885f5f5f5f5f5f	32	plan9	ADCW 0(CX), DX
661311|223344556677885f5f5f5f5f5f	64	gnu	adc (%rcx),%dx
661311|223344556677885f5f5f5f5f5f	64	intel	adc dx, word ptr [rcx]
661311|223344556677885f5f5f5f5f5f	64	plan9	ADCW 0(CX), DX
66151122|3344556677885f5f5f5f5f5f	32	intel	adc ax, 0x2211
66151122|3344556677885f5f5f5f5f5f	32	plan9	ADCW $0x2211, AX
66151122|3344556677885f5f5f5f5f5f	64	gnu	adc $0x2211,%ax
66151122|3344556677885f5f5f5f5f5f	64	intel	adc ax, 0x2211
66151122|3344556677885f5f5f5f5f5f	64	plan9	ADCW $0x2211, AX
661911|223344556677885f5f5f5f5f5f	32	intel	sbb word ptr [ecx], dx
661911|223344556677885f5f5f5f5f5f	32	plan9	SBBW DX, 0(CX)
661911|223344556677885f5f5f5f5f5f	64	gnu	sbb %dx,(%rcx)
661911|223344556677885f5f5f5f5f5f	64	intel	sbb word ptr [rcx], dx
661911|223344556677885f5f5f5f5f5f	64	plan9	SBBW DX, 0(CX)
661b11|223344556677885f5f5f5f5f5f	32	intel	sbb dx, word ptr [ecx]
661b11|223344556677885f5f5f5f5f5f	32	plan9	SBBW 0(CX), DX
661b11|223344556677885f5f5f5f5f5f	64	gnu	sbb (%rcx),%dx
661b11|223344556677885f5f5f5f5f5f	64	intel	sbb dx, word ptr [rcx]
661b11|223344556677885f5f5f5f5f5f	64	plan9	SBBW 0(CX), DX
661d1122|3344556677885f5f5f5f5f5f	32	intel	sbb ax, 0x2211
661d1122|3344556677885f5f5f5f5f5f	32	plan9	SBBW $0x2211, AX
661d1122|3344556677885f5f5f5f5f5f	64	gnu	sbb $0x2211,%ax
661d1122|3344556677885f5f5f5f5f5f	64	intel	sbb ax, 0x2211
661d1122|3344556677885f5f5f5f5f5f	64	plan9	SBBW $0x2211, AX
662111|223344556677885f5f5f5f5f5f	32	intel	and word ptr [ecx], dx
662111|223344556677885f5f5f5f5f5f	32	plan9	ANDW DX, 0(CX)
662111|223344556677885f5f5f5f5f5f	64	gnu	and %dx,(%rcx)
662111|223344556677885f5f5f5f5f5f	64	intel	and word ptr [rcx], dx
662111|223344556677885f5f5f5f5f5f	64	plan9	ANDW DX, 0(CX)
662311|223344556677885f5f5f5f5f5f	32	intel	and dx, word ptr [ecx]
662311|223344556677885f5f5f5f5f5f	32	plan9	ANDW 0(CX), DX
662311|223344556677885f5f5f5f5f5f	64	gnu	and (%rcx),%dx
662311|223344556677885f5f5f5f5f5f	64	intel	and dx, word ptr [rcx]
662311|223344556677885f5f5f5f5f5f	64	plan9	ANDW 0(CX), DX
66251122|3344556677885f5f5f5f5f5f	32	intel	and ax, 0x2211
66251122|3344556677885f5f5f5f5f5f	32	plan9	ANDW $0x2211, AX
66251122|3344556677885f5f5f5f5f5f	64	gnu	and $0x2211,%ax
66251122|3344556677885f5f5f5f5f5f	64	intel	and ax, 0x2211
66251122|3344556677885f5f5f5f5f5f	64	plan9	ANDW $0x2211, AX
662911|223344556677885f5f5f5f5f5f	32	intel	sub word ptr [ecx], dx
662911|223344556677885f5f5f5f5f5f	32	plan9	SUBW DX, 0(CX)
662911|223344556677885f5f5f5f5f5f	64	gnu	sub %dx,(%rcx)
662911|223344556677885f5f5f5f5f5f	64	intel	sub word ptr [rcx], dx
662911|223344556677885f5f5f5f5f5f	64	plan9	SUBW DX, 0(CX)
662b11|223344556677885f5f5f5f5f5f	32	intel	sub dx, word ptr [ecx]
662b11|223344556677885f5f5f5f5f5f	32	plan9	SUBW 0(CX), DX
662b11|223344556677885f5f5f5f5f5f	64	gnu	sub (%rcx),%dx
662b11|223344556677885f5f5f5f5f5f	64	intel	sub dx, word ptr [rcx]
662b11|223344556677885f5f5f5f5f5f	64	plan9	SUBW 0(CX), DX
662d1122|3344556677885f5f5f5f5f5f	32	intel	sub ax, 0x2211
662d1122|3344556677885f5f5f5f5f5f	32	plan9	SUBW $0x2211, AX
662d1122|3344556677885f5f5f5f5f5f	64	gnu	sub $0x2211,%ax
662d1122|3344556677885f5f5f5f5f5f	64	intel	sub ax, 0x2211
662d1122|3344556677885f5f5f5f5f5f	64	plan9	SUBW $0x2211, AX
663111|223344556677885f5f5f5f5f5f	32	intel	xor word ptr [ecx], dx
663111|223344556677885f5f5f5f5f5f	32	plan9	XORW DX, 0(CX)
663111|223344556677885f5f5f5f5f5f	64	gnu	xor %dx,(%rcx)
663111|223344556677885f5f5f5f5f5f	64	intel	xor word ptr [rcx], dx
663111|223344556677885f5f5f5f5f5f	64	plan9	XORW DX, 0(CX)
663311|223344556677885f5f5f5f5f5f	32	intel	xor dx, word ptr [ecx]
663311|223344556677885f5f5f5f5f5f	32	plan9	XORW 0(CX), DX
663311|223344556677885f5f5f5f5f5f	64	gnu	xor (%rcx),%dx
663311|223344556677885f5f5f5f5f5f	64	intel	xor dx, word ptr [rcx]
663311|223344556677885f5f5f5f5f5f	64	plan9	XORW 0(CX), DX
66351122|3344556677885f5f5f5f5f5f	32	intel	xor ax, 0x2211
66351122|3344556677885f5f5f5f5f5f	32	plan9	XORW $0x2211, AX
66351122|3344556677885f5f5f5f5f5f	64	gnu	xor $0x2211,%ax
66351122|3344556677885f5f5f5f5f5f	64	intel	xor ax, 0x2211
66351122|3344556677885f5f5f5f5f5f	64	plan9	XORW $0x2211, AX
663911|223344556677885f5f5f5f5f5f	32	intel	cmp word ptr [ecx], dx
663911|223344556677885f5f5f5f5f5f	32	plan9	CMPW DX, 0(CX)
663911|223344556677885f5f5f5f5f5f	64	gnu	cmp %dx,(%rcx)
663911|223344556677885f5f5f5f5f5f	64	intel	cmp word ptr [rcx], dx
663911|223344556677885f5f5f5f5f5f	64	plan9	CMPW DX, 0(CX)
663b11|223344556677885f5f5f5f5f5f	32	intel	cmp dx, word ptr [ecx]
663b11|223344556677885f5f5f5f5f5f	32	plan9	CMPW 0(CX), DX
663b11|223344556677885f5f5f5f5f5f	64	gnu	cmp (%rcx),%dx
663b11|223344556677885f5f5f5f5f5f	64	intel	cmp dx, word ptr [rcx]
663b11|223344556677885f5f5f5f5f5f	64	plan9	CMPW 0(CX), DX
663d1122|3344556677885f5f5f5f5f5f	32	intel	cmp ax, 0x2211
663d1122|3344556677885f5f5f5f5f5f	32	plan9	CMPW $0x2211, AX
663d1122|3344556677885f5f5f5f5f5f	64	gnu	cmp $0x2211,%ax
663d1122|3344556677885f5f5f5f5f5f	64	intel	cmp ax, 0x2211
663d1122|3344556677885f5f5f5f5f5f	64	plan9	CMPW $0x2211, AX
6640|11223344556677885f5f5f5f5f5f	32	intel	inc ax
6640|11223344556677885f5f5f5f5f5f	32	plan9	INCW AX
66480f3a161122|3344556677885f5f5f	64	gnu	pextrq $0x22,%xmm2,(%rcx)
66480f3a161122|3344556677885f5f5f	64	intel	pextrq qword ptr [rcx], xmm2, 0x22
66480f3a161122|3344556677885f5f5f	64	plan9	PEXTRQ $0x22, X2, 0(CX)
66480f3a221122|3344556677885f5f5f	64	gnu	pinsrq $0x22,(%rcx),%xmm2
66480f3a221122|3344556677885f5f5f	64	intel	pinsrq xmm2, qword ptr [rcx], 0x22
66480f3a221122|3344556677885f5f5f	64	plan9	PINSRQ $0x22, 0(CX), X2
66480f6e11|223344556677885f5f5f5f	64	gnu	movq (%rcx),%xmm2
66480f6e11|223344556677885f5f5f5f	64	intel	movq xmm2, qword ptr [rcx]
66480f6e11|223344556677885f5f5f5f	64	plan9	MOVQ 0(CX), X2
66480f7e11|223344556677885f5f5f5f	64	gnu	movq %xmm2,(%rcx)
66480f7e11|223344556677885f5f5f5f	64	intel	movq qword ptr [rcx], xmm2
66480f7e11|223344556677885f5f5f5f	64	plan9	MOVQ X2, 0(CX)
6648|0f3a1611223344556677885f5f5f	32	intel	dec ax
6648|0f3a1611223344556677885f5f5f	32	plan9	DECW AX
6650|11223344556677885f5f5f5f5f5f	32	intel	push ax
6650|11223344556677885f5f5f5f5f5f	32	plan9	PUSHW AX
6650|11223344556677885f5f5f5f5f5f	64	gnu	push %ax
6650|11223344556677885f5f5f5f5f5f	64	intel	push ax
6650|11223344556677885f5f5f5f5f5f	64	plan9	PUSHW AX
6658|11223344556677885f5f5f5f5f5f	32	intel	pop ax
6658|11223344556677885f5f5f5f5f5f	32	plan9	POPW AX
6658|11223344556677885f5f5f5f5f5f	64	gnu	pop %ax
6658|11223344556677885f5f5f5f5f5f	64	intel	pop ax
6658|11223344556677885f5f5f5f5f5f	64	plan9	POPW AX
6660|11223344556677885f5f5f5f5f5f	32	intel	data16 pusha
6660|11223344556677885f5f5f5f5f5f	32	plan9	PUSHAW
6661|11223344556677885f5f5f5f5f5f	32	intel	data16 popa
6661|11223344556677885f5f5f5f5f5f	32	plan9	POPAW
666211|223344556677885f5f5f5f5f5f	32	intel	bound dx, qword ptr [ecx]
666211|223344556677885f5f5f5f5f5f	32	plan9	BOUND 0(CX), DX
666311|223344556677885f5f5f5f5f5f	64	gnu	movsxd (%rcx),%dx
666311|223344556677885f5f5f5f5f5f	64	intel	movsxd dx, dword ptr [rcx]
666311|223344556677885f5f5f5f5f5f	64	plan9	MOVSXD 0(CX), DX
66681122|3344556677885f5f5f5f5f5f	32	intel	push 0x2211
66681122|3344556677885f5f5f5f5f5f	32	plan9	PUSHW $0x2211
66681122|3344556677885f5f5f5f5f5f	64	gnu	pushw $0x2211
66681122|3344556677885f5f5f5f5f5f	64	intel	push 0x2211
66681122|3344556677885f5f5f5f5f5f	64	plan9	PUSHW $0x2211
6669112233|44556677885f5f5f5f5f5f	32	intel	imul dx, word ptr [ecx], 0x3322
6669112233|44556677885f5f5f5f5f5f	32	plan9	IMULW $0x3322, 0(CX), DX
6669112233|44556677885f5f5f5f5f5f	64	gnu	imul $0x3322,(%rcx),%dx
6669112233|44556677885f5f5f5f5f5f	64	intel	imul dx, word ptr [rcx], 0x3322
6669112233|44556677885f5f5f5f5f5f	64	plan9	IMULW $0x3322, 0(CX), DX
666b1122|3344556677885f5f5f5f5f5f	32	intel	imul dx, word ptr [ecx], 0x22
666b1122|3344556677885f5f5f5f5f5f	32	plan9	IMULW $0x22, 0(CX), DX
666b1122|3344556677885f5f5f5f5f5f	64	gnu	imul $0x22,(%rcx),%dx
666b1122|3344556677885f5f5f5f5f5f	64	intel	imul dx, word ptr [rcx], 0x22
666b1122|3344556677885f5f5f5f5f5f	64	plan9	IMULW $0x22, 0(CX), DX
666d|11223344556677885f5f5f5f5f5f	32	intel	data16 insw
666d|11223344556677885f5f5f5f5f5f	32	plan9	INSW DX, ES:0(DI)
666d|11223344556677885f5f5f5f5f5f	64	gnu	insw (%dx),%es:(%rdi)
666d|11223344556677885f5f5f5f5f5f	64	intel	data16 insw
666d|11223344556677885f5f5f5f5f5f	64	plan9	INSW DX, ES:0(DI)
666f|11223344556677885f5f5f5f5f5f	32	intel	data16 outsw
666f|11223344556677885f5f5f5f5f5f	32	plan9	OUTSW DS:0(SI), DX
666f|11223344556677885f5f5f5f5f5f	64	gnu	outsw %ds:(%rsi),(%dx)
666f|11223344556677885f5f5f5f5f5f	64	intel	data16 outsw
666f|11223344556677885f5f5f5f5f5f	64	plan9	OUTSW DS:0(SI), DX
6681001122|3344556677885f5f5f5f5f	32	intel	add word ptr [eax], 0x2211
6681001122|3344556677885f5f5f5f5f	32	plan9	ADDW $0x2211, 0(AX)
6681001122|3344556677885f5f5f5f5f	64	gnu	addw $0x2211,(%rax)
6681001122|3344556677885f5f5f5f5f	64	intel	add word ptr [rax], 0x2211
6681001122|3344556677885f5f5f5f5f	64	plan9	ADDW $0x2211, 0(AX)
6681081122|3344556677885f5f5f5f5f	32	intel	or word ptr [eax], 0x2211
6681081122|3344556677885f5f5f5f5f	32	plan9	ORW $0x2211, 0(AX)
6681081122|3344556677885f5f5f5f5f	64	gnu	orw $0x2211,(%rax)
6681081122|3344556677885f5f5f5f5f	64	intel	or word ptr [rax], 0x2211
6681081122|3344556677885f5f5f5f5f	64	plan9	ORW $0x2211, 0(AX)
6681112233|44556677885f5f5f5f5f5f	32	intel	adc word ptr [ecx], 0x3322
6681112233|44556677885f5f5f5f5f5f	32	plan9	ADCW $0x3322, 0(CX)
6681112233|44556677885f5f5f5f5f5f	64	gnu	adcw $0x3322,(%rcx)
6681112233|44556677885f5f5f5f5f5f	64	intel	adc word ptr [rcx], 0x3322
6681112233|44556677885f5f5f5f5f5f	64	plan9	ADCW $0x3322, 0(CX)
6681181122|3344556677885f5f5f5f5f	32	intel	sbb word ptr [eax], 0x2211
6681181122|3344556677885f5f5f5f5f	32	plan9	SBBW $0x2211, 0(AX)
6681181122|3344556677885f5f5f5f5f	64	gnu	sbbw $0x2211,(%rax)
6681181122|3344556677885f5f5f5f5f	64	intel	sbb word ptr [rax], 0x2211
6681181122|3344556677885f5f5f5f5f	64	plan9	SBBW $0x2211, 0(AX)
6681201122|3344556677885f5f5f5f5f	32	intel	and word ptr [eax], 0x2211
6681201122|3344556677885f5f5f5f5f	32	plan9	ANDW $0x2211, 0(AX)
6681201122|3344556677885f5f5f5f5f	64	gnu	andw $0x2211,(%rax)
6681201122|3344556677885f5f5f5f5f	64	intel	and word ptr [rax], 0x2211
6681201122|3344556677885f5f5f5f5f	64	plan9	ANDW $0x2211, 0(AX)
6681281122|3344556677885f5f5f5f5f	32	intel	sub word ptr [eax], 0x2211
6681281122|3344556677885f5f5f5f5f	32	plan9	SUBW $0x2211, 0(AX)
6681281122|3344556677885f5f5f5f5f	64	gnu	subw $0x2211,(%rax)
6681281122|3344556677885f5f5f5f5f	64	intel	sub word ptr [rax], 0x2211
6681281122|3344556677885f5f5f5f5f	64	plan9	SUBW $0x2211, 0(AX)
6681301122|3344556677885f5f5f5f5f	32	intel	xor word ptr [eax], 0x2211
6681301122|3344556677885f5f5f5f5f	32	plan9	XORW $0x2211, 0(AX)
6681301122|3344556677885f5f5f5f5f	64	gnu	xorw $0x2211,(%rax)
6681301122|3344556677885f5f5f5f5f	64	intel	xor word ptr [rax], 0x2211
6681301122|3344556677885f5f5f5f5f	64	plan9	XORW $0x2211, 0(AX)
6681381122|3344556677885f5f5f5f5f	32	intel	cmp word ptr [eax], 0x2211
6681381122|3344556677885f5f5f5f5f	32	plan9	CMPW $0x2211, 0(AX)
6681381122|3344556677885f5f5f5f5f	64	gnu	cmpw $0x2211,(%rax)
6681381122|3344556677885f5f5f5f5f	64	intel	cmp word ptr [rax], 0x2211
6681381122|3344556677885f5f5f5f5f	64	plan9	CMPW $0x2211, 0(AX)
66830011|223344556677885f5f5f5f5f	32	intel	add word ptr [eax], 0x11
66830011|223344556677885f5f5f5f5f	32	plan9	ADDW $0x11, 0(AX)
66830011|223344556677885f5f5f5f5f	64	gnu	addw $0x11,(%rax)
66830011|223344556677885f5f5f5f5f	64	intel	add word ptr [rax], 0x11
66830011|223344556677885f5f5f5f5f	64	plan9	ADDW $0x11, 0(AX)
66830811|223344556677885f5f5f5f5f	32	intel	or word ptr [eax], 0x11
66830811|223344556677885f5f5f5f5f	32	plan9	ORW $0x11, 0(AX)
66830811|223344556677885f5f5f5f5f	64	gnu	orw $0x11,(%rax)
66830811|223344556677885f5f5f5f5f	64	intel	or word ptr [rax], 0x11
66830811|223344556677885f5f5f5f5f	64	plan9	ORW $0x11, 0(AX)
66831122|3344556677885f5f5f5f5f5f	32	intel	adc word ptr [ecx], 0x22
66831122|3344556677885f5f5f5f5f5f	32	plan9	ADCW $0x22, 0(CX)
66831122|3344556677885f5f5f5f5f5f	64	gnu	adcw $0x22,(%rcx)
66831122|3344556677885f5f5f5f5f5f	64	intel	adc word ptr [rcx], 0x22
66831122|3344556677885f5f5f5f5f5f	64	plan9	ADCW $0x22, 0(CX)
66831811|223344556677885f5f5f5f5f	32	intel	sbb word ptr [eax], 0x11
66831811|223344556677885f5f5f5f5f	32	plan9	SBBW $0x11, 0(AX)
66831811|223344556677885f5f5f5f5f	64	gnu	sbbw $0x11,(%rax)
66831811|223344556677885f5f5f5f5f	64	intel	sbb word ptr [rax], 0x11
66831811|223344556677885f5f5f5f5f	64	plan9	SBBW $0x11, 0(AX)
66832011|223344556677885f5f5f5f5f	32	intel	and word ptr [eax], 0x11
66832011|223344556677885f5f5f5f5f	32	plan9	ANDW $0x11, 0(AX)
66832011|223344556677885f5f5f5f5f	64	gnu	andw $0x11,(%rax)
66832011|223344556677885f5f5f5f5f	64	intel	and word ptr [rax], 0x11
66832011|223344556677885f5f5f5f5f	64	plan9	ANDW $0x11, 0(AX)
66832811|223344556677885f5f5f5f5f	32	intel	sub word ptr [eax], 0x11
66832811|223344556677885f5f5f5f5f	32	plan9	SUBW $0x11, 0(AX)
66832811|223344556677885f5f5f5f5f	64	gnu	subw $0x11,(%rax)
66832811|223344556677885f5f5f5f5f	64	intel	sub word ptr [rax], 0x11
66832811|223344556677885f5f5f5f5f	64	plan9	SUBW $0x11, 0(AX)
66833011|223344556677885f5f5f5f5f	32	intel	xor word ptr [eax], 0x11
66833011|223344556677885f5f5f5f5f	32	plan9	XORW $0x11, 0(AX)
66833011|223344556677885f5f5f5f5f	64	gnu	xorw $0x11,(%rax)
66833011|223344556677885f5f5f5f5f	64	intel	xor word ptr [rax], 0x11
66833011|223344556677885f5f5f5f5f	64	plan9	XORW $0x11, 0(AX)
66833811|223344556677885f5f5f5f5f	32	intel	cmp word ptr [eax], 0x11
66833811|223344556677885f5f5f5f5f	32	plan9	CMPW $0x11, 0(AX)
66833811|223344556677885f5f5f5f5f	64	gnu	cmpw $0x11,(%rax)
66833811|223344556677885f5f5f5f5f	64	intel	cmp word ptr [rax], 0x11
66833811|223344556677885f5f5f5f5f	64	plan9	CMPW $0x11, 0(AX)
668511|223344556677885f5f5f5f5f5f	32	intel	test word ptr [ecx], dx
668511|223344556677885f5f5f5f5f5f	32	plan9	TESTW DX, 0(CX)
668511|223344556677885f5f5f5f5f5f	64	gnu	test %dx,(%rcx)
668511|223344556677885f5f5f5f5f5f	64	intel	test word ptr [rcx], dx
668511|223344556677885f5f5f5f5f5f	64	plan9	TESTW DX, 0(CX)
668711|223344556677885f5f5f5f5f5f	32	intel	xchg word ptr [ecx], dx
668711|223344556677885f5f5f5f5f5f	32	plan9	XCHGW DX, 0(CX)
668711|223344556677885f5f5f5f5f5f	64	gnu	xchg %dx,(%rcx)
668711|223344556677885f5f5f5f5f5f	64	intel	xchg word ptr [rcx], dx
668711|223344556677885f5f5f5f5f5f	64	plan9	XCHGW DX, 0(CX)
668911|223344556677885f5f5f5f5f5f	32	intel	mov word ptr [ecx], dx
668911|223344556677885f5f5f5f5f5f	32	plan9	MOVW DX, 0(CX)
668911|223344556677885f5f5f5f5f5f	64	gnu	mov %dx,(%rcx)
668911|223344556677885f5f5f5f5f5f	64	intel	mov word ptr [rcx], dx
668911|223344556677885f5f5f5f5f5f	64	plan9	MOVW DX, 0(CX)
668b11|223344556677885f5f5f5f5f5f	32	intel	mov dx, word ptr [ecx]
668b11|223344556677885f5f5f5f5f5f	32	plan9	MOVW 0(CX), DX
668b11|223344556677885f5f5f5f5f5f	64	gnu	mov (%rcx),%dx
668b11|223344556677885f5f5f5f5f5f	64	intel	mov dx, word ptr [rcx]
668b11|223344556677885f5f5f5f5f5f	64	plan9	MOVW 0(CX), DX
668c11|223344556677885f5f5f5f5f5f	32	intel	mov word ptr [ecx], ss
668c11|223344556677885f5f5f5f5f5f	32	plan9	MOVW SS, 0(CX)
668c11|223344556677885f5f5f5f5f5f	64	gnu	data16 mov %ss,(%rcx)
668c11|223344556677885f5f5f5f5f5f	64	intel	mov word ptr [rcx], ss
668c11|223344556677885f5f5f5f5f5f	64	plan9	MOVW SS, 0(CX)
668d11|223344556677885f5f5f5f5f5f	32	intel	lea dx, ptr [ecx]
668d11|223344556677885f5f5f5f5f5f	32	plan9	LEAW 0(CX), DX
668d11|223344556677885f5f5f5f5f5f	64	gnu	lea (%rcx),%dx
668d11|223344556677885f5f5f5f5f5f	64	intel	lea dx, ptr [rcx]
668d11|223344556677885f5f5f5f5f5f	64	plan9	LEAW 0(CX), DX
668ec0|11223344556677885f5f5f5f5f	32	intel	mov es, ax
668ec0|11223344556677885f5f5f5f5f	32	plan9	MOVW AX, ES
668ec0|11223344556677885f5f5f5f5f	64	gnu	mov %ax,%es
668ec0|11223344556677885f5f5f5f5f	64	intel	mov es, ax
668ec0|11223344556677885f5f5f5f5f	64	plan9	MOVW AX, ES
668f00|11223344556677885f5f5f5f5f	32	intel	pop word ptr [eax]
668f00|11223344556677885f5f5f5f5f	32	plan9	POPW 0(AX)
668f00|11223344556677885f5f5f5f5f	64	gnu	popw (%rax)
668f00|11223344556677885f5f5f5f5f	64	intel	pop word ptr [rax]
668f00|11223344556677885f5f5f5f5f	64	plan9	POPW 0(AX)
6690|11223344556677885f5f5f5f5f5f	32	plan9	NOPW
6690|11223344556677885f5f5f5f5f5f	64	gnu	data16 nop
6690|11223344556677885f5f5f5f5f5f	64	plan9	NOPW
6698|11223344556677885f5f5f5f5f5f	32	intel	data16 cbw
6698|11223344556677885f5f5f5f5f5f	32	plan9	CBW
6698|11223344556677885f5f5f5f5f5f	64	gnu	cbtw
6698|11223344556677885f5f5f5f5f5f	64	intel	data16 cbw
6698|11223344556677885f5f5f5f5f5f	64	plan9	CBW
6699|11223344556677885f5f5f5f5f5f	32	intel	data16 cwd
6699|11223344556677885f5f5f5f5f5f	32	plan9	CWD
6699|11223344556677885f5f5f5f5f5f	64	gnu	cwtd
6699|11223344556677885f5f5f5f5f5f	64	intel	data16 cwd
6699|11223344556677885f5f5f5f5f5f	64	plan9	CWD
669a11223344|556677885f5f5f5f5f5f	32	intel	call far 0x2211, 0x4433
669a11223344|556677885f5f5f5f5f5f	32	plan9	LCALL $0x2211, $0x4433
669c|11223344556677885f5f5f5f5f5f	32	intel	data16 pushf
669c|11223344556677885f5f5f5f5f5f	32	plan9	PUSHF
669c|11223344556677885f5f5f5f5f5f	64	gnu	pushfw
669c|11223344556677885f5f5f5f5f5f	64	intel	data16 pushf
669c|11223344556677885f5f5f5f5f5f	64	plan9	PUSHF
669d|11223344556677885f5f5f5f5f5f	32	intel	data16 popf
669d|11223344556677885f5f5f5f5f5f	32	plan9	POPF
669d|11223344556677885f5f5f5f5f5f	64	gnu	popfw
669d|11223344556677885f5f5f5f5f5f	64	intel	data16 popf
669d|11223344556677885f5f5f5f5f5f	64	plan9	POPF
66a11122334455667788|5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%ax
66a11122334455667788|5f5f5f5f5f5f	64	intel	mov ax, word ptr [0x8877665544332211]
66a11122334455667788|5f5f5f5f5f5f	64	plan9	MOVW -0x778899aabbccddef, AX
66a111223344|556677885f5f5f5f5f5f	32	intel	mov ax, word ptr [0x44332211]
66a111223344|556677885f5f5f5f5f5f	32	plan9	MOVW 0x44332211, AX
66a31122334455667788|5f5f5f5f5f5f	64	gnu	mov %ax,-0x778899aabbccddef
66a31122334455667788|5f5f5f5f5f5f	64	intel	mov word ptr [0x8877665544332211], ax
66a31122334455667788|5f5f5f5f5f5f	64	plan9	MOVW AX, -0x778899aabbccddef
66a311223344|556677885f5f5f5f5f5f	32	intel	mov word ptr [0x44332211], ax
66a311223344|556677885f5f5f5f5f5f	32	plan9	MOVW AX, 0x44332211
66a5|11223344556677885f5f5f5f5f5f	32	intel	movsw word ptr [edi], word ptr [esi]
66a5|11223344556677885f5f5f5f5f5f	32	plan9	MOVSW DS:0(SI), ES:0(DI)
66a5|11223344556677885f5f5f5f5f5f	64	gnu	movsw %ds:(%rsi),%es:(%rdi)
66a5|11223344556677885f5f5f5f5f5f	64	intel	movsw word ptr [rdi], word ptr [rsi]
66a5|11223344556677885f5f5f5f5f5f	64	plan9	MOVSW DS:0(SI), ES:0(DI)
66a7|11223344556677885f5f5f5f5f5f	32	intel	cmpsw word ptr [esi], word ptr [edi]
66a7|11223344556677885f5f5f5f5f5f	32	plan9	CMPSW ES:0(DI), DS:0(SI)
66a7|11223344556677885f5f5f5f5f5f	64	gnu	cmpsw %es:(%rdi),%ds:(%rsi)
66a7|11223344556677885f5f5f5f5f5f	64	intel	cmpsw word ptr [rsi], word ptr [rdi]
66a7|11223344556677885f5f5f5f5f5f	64	plan9	CMPSW ES:0(DI), DS:0(SI)
66a91122|3344556677885f5f5f5f5f5f	32	intel	test ax, 0x2211
66a91122|3344556677885f5f5f5f5f5f	32	plan9	TESTW $0x2211, AX
66a91122|3344556677885f5f5f5f5f5f	64	gnu	test $0x2211,%ax
66a91122|3344556677885f5f5f5f5f5f	64	intel	test ax, 0x2211
66a91122|3344556677885f5f5f5f5f5f	64	plan9	TESTW $0x2211, AX
66ab|11223344556677885f5f5f5f5f5f	32	intel	stosw word ptr [edi]
66ab|11223344556677885f5f5f5f5f5f	32	plan9	STOSW AX, ES:0(DI)
66ab|11223344556677885f5f5f5f5f5f	64	gnu	stos %ax,%es:(%rdi)
66ab|11223344556677885f5f5f5f5f5f	64	intel	stosw word ptr [rdi]
66ab|11223344556677885f5f5f5f5f5f	64	plan9	STOSW AX, ES:0(DI)
66ad|11223344556677885f5f5f5f5f5f	32	intel	lodsw word ptr [esi]
66ad|11223344556677885f5f5f5f5f5f	32	plan9	LODSW DS:0(SI), AX
66ad|11223344556677885f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%ax
66ad|11223344556677885f5f5f5f5f5f	64	intel	lodsw word ptr [rsi]
66ad|11223344556677885f5f5f5f5f5f	64	plan9	LODSW DS:0(SI), AX
66af|11223344556677885f5f5f5f5f5f	32	intel	scasw word ptr [edi]
66af|11223344556677885f5f5f5f5f5f	32	plan9	SCASW ES:0(DI), AX
66af|11223344556677885f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%ax
66af|11223344556677885f5f5f5f5f5f	64	intel	scasw word ptr [rdi]
66af|11223344556677885f5f5f5f5f5f	64	plan9	SCASW ES:0(DI), AX
66b81122|3344556677885f5f5f5f5f5f	32	intel	mov ax, 0x2211
66b81122|3344556677885f5f5f5f5f5f	32	plan9	MOVW $0x2211, AX
66b81122|3344556677885f5f5f5f5f5f	64	gnu	mov $0x2211,%ax
66b81122|3344556677885f5f5f5f5f5f	64	intel	mov ax, 0x2211
66b81122|3344556677885f5f5f5f5f5f	64	plan9	MOVW $0x2211, AX
66c10011|223344556677885f5f5f5f5f	32	intel	rol word ptr [eax], 0x11
66c10011|223344556677885f5f5f5f5f	32	plan9	ROLW $0x11, 0(AX)
66c10011|223344556677885f5f5f5f5f	64	gnu	rolw $0x11,(%rax)
66c10011|223344556677885f5f5f5f5f	64	intel	rol word ptr [rax], 0x11
66c10011|223344556677885f5f5f5f5f	64	plan9	ROLW $0x11, 0(AX)
66c10811|223344556677885f5f5f5f5f	32	intel	ror word ptr [eax], 0x11
66c10811|223344556677885f5f5f5f5f	32	plan9	RORW $0x11, 0(AX)
66c10811|223344556677885f5f5f5f5f	64	gnu	rorw $0x11,(%rax)
66c10811|223344556677885f5f5f5f5f	64	intel	ror word ptr [rax], 0x11
66c10811|223344556677885f5f5f5f5f	64	plan9	RORW $0x11, 0(AX)
66c11122|3344556677885f5f5f5f5f5f	32	intel	rcl word ptr [ecx], 0x22
66c11122|3344556677885f5f5f5f5f5f	32	plan9	RCLW $0x22, 0(CX)
66c11122|3344556677885f5f5f5f5f5f	64	gnu	rclw $0x22,(%rcx)
66c11122|3344556677885f5f5f5f5f5f	64	intel	rcl word ptr [rcx], 0x22
66c11122|3344556677885f5f5f5f5f5f	64	plan9	RCLW $0x22, 0(CX)
66c11811|223344556677885f5f5f5f5f	32	intel	rcr word ptr [eax], 0x11
66c11811|223344556677885f5f5f5f5f	32	plan9	RCRW $0x11, 0(AX)
66c11811|223344556677885f5f5f5f5f	64	gnu	rcrw $0x11,(%rax)
66c11811|223344556677885f5f5f5f5f	64	intel	rcr word ptr [rax], 0x11
66c11811|223344556677885f5f5f5f5f	64	plan9	RCRW $0x11, 0(AX)
66c12011|223344556677885f5f5f5f5f	32	intel	shl word ptr [eax], 0x11
66c12011|223344556677885f5f5f5f5f	32	plan9	SHLW $0x11, 0(AX)
66c12011|223344556677885f5f5f5f5f	64	gnu	shlw $0x11,(%rax)
66c12011|223344556677885f5f5f5f5f	64	intel	shl word ptr [rax], 0x11
66c12011|223344556677885f5f5f5f5f	64	plan9	SHLW $0x11, 0(AX)
66c12811|223344556677885f5f5f5f5f	32	intel	shr word ptr [eax], 0x11
66c12811|223344556677885f5f5f5f5f	32	plan9	SHRW $0x11, 0(AX)
66c12811|223344556677885f5f5f5f5f	64	gnu	shrw $0x11,(%rax)
66c12811|223344556677885f5f5f5f5f	64	intel	shr word ptr [rax], 0x11
66c12811|223344556677885f5f5f5f5f	64	plan9	SHRW $0x11, 0(AX)
66c13811|223344556677885f5f5f5f5f	32	intel	sar word ptr [eax], 0x11
66c13811|223344556677885f5f5f5f5f	32	plan9	SARW $0x11, 0(AX)
66c13811|223344556677885f5f5f5f5f	64	gnu	sarw $0x11,(%rax)
66c13811|223344556677885f5f5f5f5f	64	intel	sar word ptr [rax], 0x11
66c13811|223344556677885f5f5f5f5f	64	plan9	SARW $0x11, 0(AX)
66c21122|3344556677885f5f5f5f5f5f	32	intel	ret 0x2211
66c21122|3344556677885f5f5f5f5f5f	32	plan9	RET $0x2211
66c21122|3344556677885f5f5f5f5f5f	64	gnu	retw $0x2211
66c21122|3344556677885f5f5f5f5f5f	64	intel	ret 0x2211
66c21122|3344556677885f5f5f5f5f5f	64	plan9	RET $0x2211
66c411|223344556677885f5f5f5f5f5f	32	intel	les dx, dword ptr [ecx]
66c411|223344556677885f5f5f5f5f5f	32	plan9	LES 0(CX), DX
66c511|223344556677885f5f5f5f5f5f	32	intel	lds dx, dword ptr [ecx]
66c511|223344556677885f5f5f5f5f5f	32	plan9	LDS 0(CX), DX
66c7001122|3344556677885f5f5f5f5f	32	intel	mov word ptr [eax], 0x2211
66c7001122|3344556677885f5f5f5f5f	32	plan9	MOVW $0x2211, 0(AX)
66c7001122|3344556677885f5f5f5f5f	64	gnu	movw $0x2211,(%rax)
66c7001122|3344556677885f5f5f5f5f	64	intel	mov word ptr [rax], 0x2211
66c7001122|3344556677885f5f5f5f5f	64	plan9	MOVW $0x2211, 0(AX)
66c7f81122|3344556677885f5f5f5f5f	32	intel	xbegin .+0x2211
66c7f81122|3344556677885f5f5f5f5f	32	plan9	XBEGIN .+8721
66c7f81122|3344556677885f5f5f5f5f	64	gnu	xbeginw .+0x2211
66c7f81122|3344556677885f5f5f5f5f	64	intel	xbegin .+0x2211
66c7f81122|3344556677885f5f5f5f5f	64	plan9	XBEGIN .+8721
66c9|11223344556677885f5f5f5f5f5f	32	intel	data16 leave
66c9|11223344556677885f5f5f5f5f5f	32	plan9	LEAVE
66c9|11223344556677885f5f5f5f5f5f	64	gnu	leavew
66c9|11223344556677885f5f5f5f5f5f	64	intel	data16 leave
66c9|11223344556677885f5f5f5f5f5f	64	plan9	LEAVE
66cf|11223344556677885f5f5f5f5f5f	32	intel	data16 iret
66cf|11223344556677885f5f5f5f5f5f	32	plan9	IRET
66cf|11223344556677885f5f5f5f5f5f	64	gnu	iretw
66cf|11223344556677885f5f5f5f5f5f	64	intel	data16 iret
66cf|11223344556677885f5f5f5f5f5f	64	plan9	IRET
66d100|11223344556677885f5f5f5f5f	32	intel	rol word ptr [eax], 0x1
66d100|11223344556677885f5f5f5f5f	32	plan9	ROLW $0x1, 0(AX)
66d100|11223344556677885f5f5f5f5f	64	gnu	rolw (%rax)
66d100|11223344556677885f5f5f5f5f	64	intel	rol word ptr [rax], 0x1
66d100|11223344556677885f5f5f5f5f	64	plan9	ROLW $0x1, 0(AX)
66d108|11223344556677885f5f5f5f5f	32	intel	ror word ptr [eax], 0x1
66d108|11223344556677885f5f5f5f5f	32	plan9	RORW $0x1, 0(AX)
66d108|11223344556677885f5f5f5f5f	64	gnu	rorw (%rax)
66d108|11223344556677885f5f5f5f5f	64	intel	ror word ptr [rax], 0x1
66d108|11223344556677885f5f5f5f5f	64	plan9	RORW $0x1, 0(AX)
66d111|223344556677885f5f5f5f5f5f	32	intel	rcl word ptr [ecx], 0x1
66d111|223344556677885f5f5f5f5f5f	32	plan9	RCLW $0x1, 0(CX)
66d111|223344556677885f5f5f5f5f5f	64	gnu	rclw (%rcx)
66d111|223344556677885f5f5f5f5f5f	64	intel	rcl word ptr [rcx], 0x1
66d111|223344556677885f5f5f5f5f5f	64	plan9	RCLW $0x1, 0(CX)
66d118|11223344556677885f5f5f5f5f	32	intel	rcr word ptr [eax], 0x1
66d118|11223344556677885f5f5f5f5f	32	plan9	RCRW $0x1, 0(AX)
66d118|11223344556677885f5f5f5f5f	64	gnu	rcrw (%rax)
66d118|11223344556677885f5f5f5f5f	64	intel	rcr word ptr [rax], 0x1
66d118|11223344556677885f5f5f5f5f	64	plan9	RCRW $0x1, 0(AX)
66d120|11223344556677885f5f5f5f5f	32	intel	shl word ptr [eax], 0x1
66d120|11223344556677885f5f5f5f5f	32	plan9	SHLW $0x1, 0(AX)
66d120|11223344556677885f5f5f5f5f	64	gnu	shlw (%rax)
66d120|11223344556677885f5f5f5f5f	64	intel	shl word ptr [rax], 0x1
66d120|11223344556677885f5f5f5f5f	64	plan9	SHLW $0x1, 0(AX)
66d128|11223344556677885f5f5f5f5f	32	intel	shr word ptr [eax], 0x1
66d128|11223344556677885f5f5f5f5f	32	plan9	SHRW $0x1, 0(AX)
66d128|11223344556677885f5f5f5f5f	64	gnu	shrw (%rax)
66d128|11223344556677885f5f5f5f5f	64	intel	shr word ptr [rax], 0x1
66d128|11223344556677885f5f5f5f5f	64	plan9	SHRW $0x1, 0(AX)
66d138|11223344556677885f5f5f5f5f	32	intel	sar word ptr [eax], 0x1
66d138|11223344556677885f5f5f5f5f	32	plan9	SARW $0x1, 0(AX)
66d138|11223344556677885f5f5f5f5f	64	gnu	sarw (%rax)
66d138|11223344556677885f5f5f5f5f	64	intel	sar word ptr [rax], 0x1
66d138|11223344556677885f5f5f5f5f	64	plan9	SARW $0x1, 0(AX)
66d300|11223344556677885f5f5f5f5f	32	intel	rol word ptr [eax], cl
66d300|11223344556677885f5f5f5f5f	32	plan9	ROLW CL, 0(AX)
66d300|11223344556677885f5f5f5f5f	64	gnu	rolw %cl,(%rax)
66d300|11223344556677885f5f5f5f5f	64	intel	rol word ptr [rax], cl
66d300|11223344556677885f5f5f5f5f	64	plan9	ROLW CL, 0(AX)
66d308|11223344556677885f5f5f5f5f	32	intel	ror word ptr [eax], cl
66d308|11223344556677885f5f5f5f5f	32	plan9	RORW CL, 0(AX)
66d308|11223344556677885f5f5f5f5f	64	gnu	rorw %cl,(%rax)
66d308|11223344556677885f5f5f5f5f	64	intel	ror word ptr [rax], cl
66d308|11223344556677885f5f5f5f5f	64	plan9	RORW CL, 0(AX)
66d311|223344556677885f5f5f5f5f5f	32	intel	rcl word ptr [ecx], cl
66d311|223344556677885f5f5f5f5f5f	32	plan9	RCLW CL, 0(CX)
66d311|223344556677885f5f5f5f5f5f	64	gnu	rclw %cl,(%rcx)
66d311|223344556677885f5f5f5f5f5f	64	intel	rcl word ptr [rcx], cl
66d311|223344556677885f5f5f5f5f5f	64	plan9	RCLW CL, 0(CX)
66d318|11223344556677885f5f5f5f5f	32	intel	rcr word ptr [eax], cl
66d318|11223344556677885f5f5f5f5f	32	plan9	RCRW CL, 0(AX)
66d318|11223344556677885f5f5f5f5f	64	gnu	rcrw %cl,(%rax)
66d318|11223344556677885f5f5f5f5f	64	intel	rcr word ptr [rax], cl
66d318|11223344556677885f5f5f5f5f	64	plan9	RCRW CL, 0(AX)
66d320|11223344556677885f5f5f5f5f	32	intel	shl word ptr [eax], cl
66d320|11223344556677885f5f5f5f5f	32	plan9	SHLW CL, 0(AX)
66d320|11223344556677885f5f5f5f5f	64	gnu	shlw %cl,(%rax)
66d320|11223344556677885f5f5f5f5f	64	intel	shl word ptr [rax], cl
66d320|11223344556677885f5f5f5f5f	64	plan9	SHLW CL, 0(AX)
66d328|11223344556677885f5f5f5f5f	32	intel	shr word ptr [eax], cl
66d328|11223344556677885f5f5f5f5f	32	plan9	SHRW CL, 0(AX)
66d328|11223344556677885f5f5f5f5f	64	gnu	shrw %cl,(%rax)
66d328|11223344556677885f5f5f5f5f	64	intel	shr word ptr [rax], cl
66d328|11223344556677885f5f5f5f5f	64	plan9	SHRW CL, 0(AX)
66d338|11223344556677885f5f5f5f5f	32	intel	sar word ptr [eax], cl
66d338|11223344556677885f5f5f5f5f	32	plan9	SARW CL, 0(AX)
66d338|11223344556677885f5f5f5f5f	64	gnu	sarw %cl,(%rax)
66d338|11223344556677885f5f5f5f5f	64	intel	sar word ptr [rax], cl
66d338|11223344556677885f5f5f5f5f	64	plan9	SARW CL, 0(AX)
66d411|223344556677885f5f5f5f5f5f	32	intel	aam 0x11
66d411|223344556677885f5f5f5f5f5f	32	plan9	AAM $0x11
66d920|11223344556677885f5f5f5f5f	32	intel	fldenv ptr [eax]
66d920|11223344556677885f5f5f5f5f	32	plan9	FLDENVW 0(AX)
66d920|11223344556677885f5f5f5f5f	64	gnu	fldenvs (%rax)
66d920|11223344556677885f5f5f5f5f	64	intel	fldenv ptr [rax]
66d920|11223344556677885f5f5f5f5f	64	plan9	FLDENVW 0(AX)
66e511|223344556677885f5f5f5f5f5f	32	intel	in ax, 0x11
66e511|223344556677885f5f5f5f5f5f	32	plan9	INW $0x11, AX
66e511|223344556677885f5f5f5f5f5f	64	gnu	in $0x11,%ax
66e511|223344556677885f5f5f5f5f5f	64	intel	in ax, 0x11
66e511|223344556677885f5f5f5f5f5f	64	plan9	INW $0x11, AX
66e711|223344556677885f5f5f5f5f5f	32	intel	out 0x11, ax
66e711|223344556677885f5f5f5f5f5f	32	plan9	OUTW AX, $0x11
66e711|223344556677885f5f5f5f5f5f	64	gnu	out %ax,$0x11
66e711|223344556677885f5f5f5f5f5f	64	intel	out 0x11, ax
66e711|223344556677885f5f5f5f5f5f	64	plan9	OUTW AX, $0x11
66e811223344|556677885f5f5f5f5f5f	64	gnu	callw .+0x44332211
66e811223344|556677885f5f5f5f5f5f	64	intel	call .+0x44332211
66e811223344|556677885f5f5f5f5f5f	64	plan9	CALL .+1144201745
66e81122|3344556677885f5f5f5f5f5f	32	intel	call .+0x2211
66e81122|3344556677885f5f5f5f5f5f	32	plan9	CALL .+8721
66e911223344|556677885f5f5f5f5f5f	64	gnu	jmpw .+0x44332211
66e911223344|556677885f5f5f5f5f5f	64	intel	jmp .+0x44332211
66e911223344|556677885f5f5f5f5f5f	64	plan9	JMP .+1144201745
66e91122|3344556677885f5f5f5f5f5f	32	intel	jmp .+0x2211
66e91122|3344556677885f5f5f5f5f5f	32	plan9	JMP .+8721
66ea11223344|556677885f5f5f5f5f5f	32	intel	jmp far 0x2211, 0x4433
66ea11223344|556677885f5f5f5f5f5f	32	plan9	LJMP $0x2211, $0x4433
66ed|11223344556677885f5f5f5f5f5f	32	intel	in ax, dx
66ed|11223344556677885f5f5f5f5f5f	32	plan9	INW DX, AX
66ed|11223344556677885f5f5f5f5f5f	64	gnu	in (%dx),%ax
66ed|11223344556677885f5f5f5f5f5f	64	intel	in ax, dx
66ed|11223344556677885f5f5f5f5f5f	64	plan9	INW DX, AX
66ef|11223344556677885f5f5f5f5f5f	32	intel	out dx, ax
66ef|11223344556677885f5f5f5f5f5f	32	plan9	OUTW AX, DX
66ef|11223344556677885f5f5f5f5f5f	64	gnu	out %ax,(%dx)
66ef|11223344556677885f5f5f5f5f5f	64	intel	out dx, ax
66ef|11223344556677885f5f5f5f5f5f	64	plan9	OUTW AX, DX
66f20f2a11|223344556677885f5f5f5f	32	intel	cvtsi2sd xmm2, dword ptr [ecx]
66f20f2a11|223344556677885f5f5f5f	32	plan9	REPNE CVTSI2SDW 0(CX), X2
66f20f2a11|223344556677885f5f5f5f	64	gnu	cvtsi2sdl (%rcx),%xmm2
66f20f2a11|223344556677885f5f5f5f	64	intel	cvtsi2sd xmm2, dword ptr [rcx]
66f20f2a11|223344556677885f5f5f5f	64	plan9	REPNE CVTSI2SDW 0(CX), X2
66f20f2c11|223344556677885f5f5f5f	32	intel	cvttsd2si edx, qword ptr [ecx]
66f20f2c11|223344556677885f5f5f5f	32	plan9	REPNE CVTTSD2SIW 0(CX), DX
66f20f2c11|223344556677885f5f5f5f	64	gnu	cvttsd2si (%rcx),%dx
66f20f2c11|223344556677885f5f5f5f	64	intel	cvttsd2si edx, qword ptr [rcx]
66f20f2c11|223344556677885f5f5f5f	64	plan9	REPNE CVTTSD2SIW 0(CX), DX
66f20f2d11|223344556677885f5f5f5f	32	intel	cvtsd2si edx, qword ptr [ecx]
66f20f2d11|223344556677885f5f5f5f	32	plan9	REPNE CVTSD2SIW 0(CX), DX
66f20f2d11|223344556677885f5f5f5f	64	gnu	cvtsd2si (%rcx),%dx
66f20f2d11|223344556677885f5f5f5f	64	intel	cvtsd2si edx, qword ptr [rcx]
66f20f2d11|223344556677885f5f5f5f	64	plan9	REPNE CVTSD2SIW 0(CX), DX
66f20f38f011|223344556677885f5f5f	32	intel	crc32 edx, byte ptr [ecx]
66f20f38f011|223344556677885f5f5f	32	plan9	REPNE CRC32 0(CX), DX
66f20f38f011|223344556677885f5f5f	64	gnu	crc32b (%rcx),%edx
66f20f38f011|223344556677885f5f5f	64	intel	crc32 edx, byte ptr [rcx]
66f20f38f011|223344556677885f5f5f	64	plan9	REPNE CRC32 0(CX), DX
66f30f2c11|223344556677885f5f5f5f	32	intel	cvttss2si edx, dword ptr [ecx]
66f30f2c11|223344556677885f5f5f5f	32	plan9	REP CVTTSS2SIW 0(CX), DX
66f30f2c11|223344556677885f5f5f5f	64	gnu	cvttss2si (%rcx),%dx
66f30f2c11|223344556677885f5f5f5f	64	intel	cvttss2si edx, dword ptr [rcx]
66f30f2c11|223344556677885f5f5f5f	64	plan9	REP CVTTSS2SIW 0(CX), DX
66f30f2d11|223344556677885f5f5f5f	32	intel	cvtss2si edx, dword ptr [ecx]
66f30f2d11|223344556677885f5f5f5f	32	plan9	REP CVTSS2SIW 0(CX), DX
66f30f2d11|223344556677885f5f5f5f	64	gnu	cvtss2si (%rcx),%dx
66f30f2d11|223344556677885f5f5f5f	64	intel	cvtss2si edx, dword ptr [rcx]
66f30f2d11|223344556677885f5f5f5f	64	plan9	REP CVTSS2SIW 0(CX), DX
66f30fae11|223344556677885f5f5f5f	64	gnu	wrfsbasel (%rcx)
66f30fae11|223344556677885f5f5f5f	64	intel	wrfsbase dword ptr [rcx]
66f30fae11|223344556677885f5f5f5f	64	plan9	REP WRFSBASE 0(CX)
66f30fae18|11223344556677885f5f5f	64	gnu	wrgsbasel (%rax)
66f30fae18|11223344556677885f5f5f	64	intel	wrgsbase dword ptr [rax]
66f30fae18|11223344556677885f5f5f	64	plan9	REP WRGSBASE 0(AX)
66f30faec0|11223344556677885f5f5f	64	gnu	rdfsbase %eax
66f30faec0|11223344556677885f5f5f	64	intel	rdfsbase eax
66f30faec0|11223344556677885f5f5f	64	plan9	REP RDFSBASE AX
66f30faec8|11223344556677885f5f5f	64	gnu	rdgsbase %eax
66f30faec8|11223344556677885f5f5f	64	intel	rdgsbase eax
66f30faec8|11223344556677885f5f5f	64	plan9	REP RDGSBASE AX
66f30fd6c5|11223344556677885f5f5f	32	intel	movq2dq xmm0, mmx5
66f30fd6c5|11223344556677885f5f5f	32	plan9	REP MOVQ2DQ M5, X0
66f30fd6c5|11223344556677885f5f5f	64	gnu	movq2dq %mm5,%xmm0
66f30fd6c5|11223344556677885f5f5f	64	intel	movq2dq xmm0, mmx5
66f30fd6c5|11223344556677885f5f5f	64	plan9	REP MOVQ2DQ M5, X0
66f7001122|3344556677885f5f5f5f5f	32	intel	test word ptr [eax], 0x2211
66f7001122|3344556677885f5f5f5f5f	32	plan9	TESTW $0x2211, 0(AX)
66f7001122|3344556677885f5f5f5f5f	64	gnu	testw $0x2211,(%rax)
66f7001122|3344556677885f5f5f5f5f	64	intel	test word ptr [rax], 0x2211
66f7001122|3344556677885f5f5f5f5f	64	plan9	TESTW $0x2211, 0(AX)
66f711|223344556677885f5f5f5f5f5f	32	intel	not word ptr [ecx]
66f711|223344556677885f5f5f5f5f5f	32	plan9	NOTW 0(CX)
66f711|223344556677885f5f5f5f5f5f	64	gnu	notw (%rcx)
66f711|223344556677885f5f5f5f5f5f	64	intel	not word ptr [rcx]
66f711|223344556677885f5f5f5f5f5f	64	plan9	NOTW 0(CX)
66f718|11223344556677885f5f5f5f5f	32	intel	neg word ptr [eax]
66f718|11223344556677885f5f5f5f5f	32	plan9	NEGW 0(AX)
66f718|11223344556677885f5f5f5f5f	64	gnu	negw (%rax)
66f718|11223344556677885f5f5f5f5f	64	intel	neg word ptr [rax]
66f718|11223344556677885f5f5f5f5f	64	plan9	NEGW 0(AX)
66f720|11223344556677885f5f5f5f5f	32	intel	mul word ptr [eax]
66f720|11223344556677885f5f5f5f5f	32	plan9	MULW 0(AX)
66f720|11223344556677885f5f5f5f5f	64	gnu	mulw (%rax)
66f720|11223344556677885f5f5f5f5f	64	intel	mul word ptr [rax]
66f720|11223344556677885f5f5f5f5f	64	plan9	MULW 0(AX)
66f728|11223344556677885f5f5f5f5f	32	intel	imul word ptr [eax]
66f728|11223344556677885f5f5f5f5f	32	plan9	IMULW 0(AX)
66f728|11223344556677885f5f5f5f5f	64	gnu	imulw (%rax)
66f728|11223344556677885f5f5f5f5f	64	intel	imul word ptr [rax]
66f728|11223344556677885f5f5f5f5f	64	plan9	IMULW 0(AX)
66f730|11223344556677885f5f5f5f5f	32	intel	div word ptr [eax]
66f730|11223344556677885f5f5f5f5f	32	plan9	DIVW 0(AX)
66f730|11223344556677885f5f5f5f5f	64	gnu	divw (%rax)
66f730|11223344556677885f5f5f5f5f	64	intel	div word ptr [rax]
66f730|11223344556677885f5f5f5f5f	64	plan9	DIVW 0(AX)
66f738|11223344556677885f5f5f5f5f	32	intel	idiv word ptr [eax]
66f738|11223344556677885f5f5f5f5f	32	plan9	IDIVW 0(AX)
66f738|11223344556677885f5f5f5f5f	64	gnu	idivw (%rax)
66f738|11223344556677885f5f5f5f5f	64	intel	idiv word ptr [rax]
66f738|11223344556677885f5f5f5f5f	64	plan9	IDIVW 0(AX)
66ff00|11223344556677885f5f5f5f5f	32	intel	inc word ptr [eax]
66ff00|11223344556677885f5f5f5f5f	32	plan9	INCW 0(AX)
66ff00|11223344556677885f5f5f5f5f	64	gnu	incw (%rax)
66ff00|11223344556677885f5f5f5f5f	64	intel	inc word ptr [rax]
66ff00|11223344556677885f5f5f5f5f	64	plan9	INCW 0(AX)
66ff08|11223344556677885f5f5f5f5f	32	intel	dec word ptr [eax]
66ff08|11223344556677885f5f5f5f5f	32	plan9	DECW 0(AX)
66ff08|11223344556677885f5f5f5f5f	64	gnu	decw (%rax)
66ff08|11223344556677885f5f5f5f5f	64	intel	dec word ptr [rax]
66ff08|11223344556677885f5f5f5f5f	64	plan9	DECW 0(AX)
66ff11|223344556677885f5f5f5f5f5f	32	intel	call word ptr [ecx]
66ff11|223344556677885f5f5f5f5f5f	32	plan9	CALL 0(CX)
66ff11|223344556677885f5f5f5f5f5f	64	gnu	callw *(%rcx)
66ff11|223344556677885f5f5f5f5f5f	64	intel	call qword ptr [rcx]
66ff11|223344556677885f5f5f5f5f5f	64	plan9	CALL 0(CX)
66ff18|11223344556677885f5f5f5f5f	32	intel	call far dword ptr [eax]
66ff18|11223344556677885f5f5f5f5f	32	plan9	LCALL 0(AX)
66ff18|11223344556677885f5f5f5f5f	64	gnu	lcallw *(%rax)
66ff18|11223344556677885f5f5f5f5f	64	intel	call far dword ptr [rax]
66ff18|11223344556677885f5f5f5f5f	64	plan9	LCALL 0(AX)
66ff20|11223344556677885f5f5f5f5f	32	intel	jmp word ptr [eax]
66ff20|11223344556677885f5f5f5f5f	32	plan9	JMP 0(AX)
66ff20|11223344556677885f5f5f5f5f	64	gnu	jmpw *(%rax)
66ff20|11223344556677885f5f5f5f5f	64	intel	jmp qword ptr [rax]
66ff20|11223344556677885f5f5f5f5f	64	plan9	JMP 0(AX)
66ff28|11223344556677885f5f5f5f5f	32	intel	jmp far dword ptr [eax]
66ff28|11223344556677885f5f5f5f5f	32	plan9	LJMP 0(AX)
66ff28|11223344556677885f5f5f5f5f	64	gnu	ljmpw *(%rax)
66ff28|11223344556677885f5f5f5f5f	64	intel	jmp far dword ptr [rax]
66ff28|11223344556677885f5f5f5f5f	64	plan9	LJMP 0(AX)
66ff30|11223344556677885f5f5f5f5f	32	intel	push word ptr [eax]
66ff30|11223344556677885f5f5f5f5f	32	plan9	PUSHW 0(AX)
66ff30|11223344556677885f5f5f5f5f	64	gnu	pushw (%rax)
66ff30|11223344556677885f5f5f5f5f	64	intel	push word ptr [rax]
66ff30|11223344556677885f5f5f5f5f	64	plan9	PUSHW 0(AX)
66|9a11223344556677885f5f5f5f5f5f	64	gnu	data16
66|9a11223344556677885f5f5f5f5f5f	64	intel	data16
66|9a11223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|c411223344556677885f5f5f5f5f5f	64	gnu	data16
66|c411223344556677885f5f5f5f5f5f	64	intel	data16
66|c411223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|c511223344556677885f5f5f5f5f5f	64	gnu	data16
66|c511223344556677885f5f5f5f5f5f	64	intel	data16
66|c511223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|d411223344556677885f5f5f5f5f5f	64	gnu	data16
66|d411223344556677885f5f5f5f5f5f	64	intel	data16
66|d411223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|ea11223344556677885f5f5f5f5f5f	64	gnu	data16
66|ea11223344556677885f5f5f5f5f5f	64	intel	data16
66|ea11223344556677885f5f5f5f5f5f	64	plan9	Op(0)
676c|11223344556677885f5f5f5f5f5f	32	intel	addr16 insb
676c|11223344556677885f5f5f5f5f5f	32	plan9	INSB DX, ES:0(DI)
676c|11223344556677885f5f5f5f5f5f	64	gnu	insb (%dx),%es:(%edi)
676c|11223344556677885f5f5f5f5f5f	64	intel	addr32 insb
676c|11223344556677885f5f5f5f5f5f	64	plan9	INSB DX, ES:0(DI)
67d7|11223344556677885f5f5f5f5f5f	32	intel	addr16 xlat
67d7|11223344556677885f5f5f5f5f5f	32	plan9	XLATB DS:0(BX)
67d7|11223344556677885f5f5f5f5f5f	64	gnu	xlat %ds:(%ebx)
67d7|11223344556677885f5f5f5f5f5f	64	intel	addr32 xlat
67d7|11223344556677885f5f5f5f5f5f	64	plan9	XLATB DS:0(BX)
67e311|223344556677885f5f5f5f5f5f	32	intel	addr16 jcxz .+0x11
67e311|223344556677885f5f5f5f5f5f	32	plan9	JCXZ .+17
67e311|223344556677885f5f5f5f5f5f	64	gnu	jecxz .+0x11
67e311|223344556677885f5f5f5f5f5f	64	intel	addr32 jecxz .+0x11
67e311|223344556677885f5f5f5f5f5f	64	plan9	JECXZ .+17
6811223344|556677885f5f5f5f5f5f5f	32	intel	push 0x44332211
6811223344|556677885f5f5f5f5f5f5f	32	plan9	PUSHL $0x44332211
6811223344|556677885f5f5f5f5f5f5f	64	gnu	pushq $0x44332211
6811223344|556677885f5f5f5f5f5f5f	64	intel	push 0x44332211
6811223344|556677885f5f5f5f5f5f5f	64	plan9	PUSHL $0x44332211
691122334455|6677885f5f5f5f5f5f5f	32	intel	imul edx, dword ptr [ecx], 0x55443322
691122334455|6677885f5f5f5f5f5f5f	32	plan9	IMULL $0x55443322, 0(CX), DX
691122334455|6677885f5f5f5f5f5f5f	64	gnu	imul $0x55443322,(%rcx),%edx
691122334455|6677885f5f5f5f5f5f5f	64	intel	imul edx, dword ptr [rcx], 0x55443322
691122334455|6677885f5f5f5f5f5f5f	64	plan9	IMULL $0x55443322, 0(CX), DX
6a11|223344556677885f5f5f5f5f5f5f	32	intel	push 0x11
6a11|223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL $0x11
6a11|223344556677885f5f5f5f5f5f5f	64	gnu	pushq $0x11
6a11|223344556677885f5f5f5f5f5f5f	64	intel	push 0x11
6a11|223344556677885f5f5f5f5f5f5f	64	plan9	PUSHL $0x11
6b1122|3344556677885f5f5f5f5f5f5f	32	intel	imul edx, dword ptr [ecx], 0x22
6b1122|3344556677885f5f5f5f5f5f5f	32	plan9	IMULL $0x22, 0(CX), DX
6b1122|3344556677885f5f5f5f5f5f5f	64	gnu	imul $0x22,(%rcx),%edx
6b1122|3344556677885f5f5f5f5f5f5f	64	intel	imul edx, dword ptr [rcx], 0x22
6b1122|3344556677885f5f5f5f5f5f5f	64	plan9	IMULL $0x22, 0(CX), DX
6d|11223344556677885f5f5f5f5f5f5f	32	intel	insd
6d|11223344556677885f5f5f5f5f5f5f	32	plan9	INSD DX, ES:0(DI)
6d|11223344556677885f5f5f5f5f5f5f	64	gnu	insl (%dx),%es:(%rdi)
6d|11223344556677885f5f5f5f5f5f5f	64	intel	insd
6d|11223344556677885f5f5f5f5f5f5f	64	plan9	INSD DX, ES:0(DI)
6f|11223344556677885f5f5f5f5f5f5f	32	intel	outsd
6f|11223344556677885f5f5f5f5f5f5f	32	plan9	OUTSD DS:0(SI), DX
6f|11223344556677885f5f5f5f5f5f5f	64	gnu	outsl %ds:(%rsi),(%dx)
6f|11223344556677885f5f5f5f5f5f5f	64	intel	outsd
6f|11223344556677885f5f5f5f5f5f5f	64	plan9	OUTSD DS:0(SI), DX
7111|223344556677885f5f5f5f5f5f5f	32	intel	jno .+0x11
7111|223344556677885f5f5f5f5f5f5f	32	plan9	JNO .+17
7111|223344556677885f5f5f5f5f5f5f	64	gnu	jno .+0x11
7111|223344556677885f5f5f5f5f5f5f	64	intel	jno .+0x11
7111|223344556677885f5f5f5f5f5f5f	64	plan9	JNO .+17
7211|223344556677885f5f5f5f5f5f5f	32	intel	jb .+0x11
7211|223344556677885f5f5f5f5f5f5f	32	plan9	JB .+17
7211|223344556677885f5f5f5f5f5f5f	64	gnu	jb .+0x11
7211|223344556677885f5f5f5f5f5f5f	64	intel	jb .+0x11
7211|223344556677885f5f5f5f5f5f5f	64	plan9	JB .+17
7311|223344556677885f5f5f5f5f5f5f	32	intel	jnb .+0x11
7311|223344556677885f5f5f5f5f5f5f	32	plan9	JAE .+17
7311|223344556677885f5f5f5f5f5f5f	64	gnu	jae .+0x11
7311|223344556677885f5f5f5f5f5f5f	64	intel	jnb .+0x11
7311|223344556677885f5f5f5f5f5f5f	64	plan9	JAE .+17
7411|223344556677885f5f5f5f5f5f5f	32	intel	jz .+0x11
7411|223344556677885f5f5f5f5f5f5f	32	plan9	JE .+17
7411|223344556677885f5f5f5f5f5f5f	64	gnu	je .+0x11
7411|223344556677885f5f5f5f5f5f5f	64	intel	jz .+0x11
7411|223344556677885f5f5f5f5f5f5f	64	plan9	JE .+17
7511|223344556677885f5f5f5f5f5f5f	32	intel	jnz .+0x11
7511|223344556677885f5f5f5f5f5f5f	32	plan9	JNE .+17
7511|223344556677885f5f5f5f5f5f5f	64	gnu	jne .+0x11
7511|223344556677885f5f5f5f5f5f5f	64	intel	jnz .+0x11
7511|223344556677885f5f5f5f5f5f5f	64	plan9	JNE .+17
7611|223344556677885f5f5f5f5f5f5f	32	intel	jbe .+0x11
7611|223344556677885f5f5f5f5f5f5f	32	plan9	JBE .+17
7611|223344556677885f5f5f5f5f5f5f	64	gnu	jbe .+0x11
7611|223344556677885f5f5f5f5f5f5f	64	intel	jbe .+0x11
7611|223344556677885f5f5f5f5f5f5f	64	plan9	JBE .+17
7711|223344556677885f5f5f5f5f5f5f	32	intel	jnbe .+0x11
7711|223344556677885f5f5f5f5f5f5f	32	plan9	JA .+17
7711|223344556677885f5f5f5f5f5f5f	64	gnu	ja .+0x11
7711|223344556677885f5f5f5f5f5f5f	64	intel	jnbe .+0x11
7711|223344556677885f5f5f5f5f5f5f	64	plan9	JA .+17
7811|223344556677885f5f5f5f5f5f5f	32	intel	js .+0x11
7811|223344556677885f5f5f5f5f5f5f	32	plan9	JS .+17
7811|223344556677885f5f5f5f5f5f5f	64	gnu	js .+0x11
7811|223344556677885f5f5f5f5f5f5f	64	intel	js .+0x11
7811|223344556677885f5f5f5f5f5f5f	64	plan9	JS .+17
7911|223344556677885f5f5f5f5f5f5f	32	intel	jns .+0x11
7911|223344556677885f5f5f5f5f5f5f	32	plan9	JNS .+17
7911|223344556677885f5f5f5f5f5f5f	64	gnu	jns .+0x11
7911|223344556677885f5f5f5f5f5f5f	64	intel	jns .+0x11
7911|223344556677885f5f5f5f5f5f5f	64	plan9	JNS .+17
7a11|223344556677885f5f5f5f5f5f5f	32	intel	jp .+0x11
7a11|223344556677885f5f5f5f5f5f5f	32	plan9	JP .+17
7a11|223344556677885f5f5f5f5f5f5f	64	gnu	jp .+0x11
7a11|223344556677885f5f5f5f5f5f5f	64	intel	jp .+0x11
7a11|223344556677885f5f5f5f5f5f5f	64	plan9	JP .+17
7b11|223344556677885f5f5f5f5f5f5f	32	intel	jnp .+0x11
7b11|223344556677885f5f5f5f5f5f5f	32	plan9	JNP .+17
7b11|223344556677885f5f5f5f5f5f5f	64	gnu	jnp .+0x11
7b11|223344556677885f5f5f5f5f5f5f	64	intel	jnp .+0x11
7b11|223344556677885f5f5f5f5f5f5f	64	plan9	JNP .+17
7c11|223344556677885f5f5f5f5f5f5f	32	intel	jl .+0x11
7c11|223344556677885f5f5f5f5f5f5f	32	plan9	JL .+17
7c11|223344556677885f5f5f5f5f5f5f	64	gnu	jl .+0x11
7c11|223344556677885f5f5f5f5f5f5f	64	intel	jl .+0x11
7c11|223344556677885f5f5f5f5f5f5f	64	plan9	JL .+17
7d11|223344556677885f5f5f5f5f5f5f	32	intel	jnl .+0x11
7d11|223344556677885f5f5f5f5f5f5f	32	plan9	JGE .+17
7d11|223344556677885f5f5f5f5f5f5f	64	gnu	jge .+0x11
7d11|223344556677885f5f5f5f5f5f5f	64	intel	jnl .+0x11
7d11|223344556677885f5f5f5f5f5f5f	64	plan9	JGE .+17
7e11|223344556677885f5f5f5f5f5f5f	32	intel	jle .+0x11
7e11|223344556677885f5f5f5f5f5f5f	32	plan9	JLE .+17
7e11|223344556677885f5f5f5f5f5f5f	64	gnu	jle .+0x11
7e11|223344556677885f5f5f5f5f5f5f	64	intel	jle .+0x11
7e11|223344556677885f5f5f5f5f5f5f	64	plan9	JLE .+17
7f11|223344556677885f5f5f5f5f5f5f	32	intel	jnle .+0x11
7f11|223344556677885f5f5f5f5f5f5f	32	plan9	JG .+17
7f11|223344556677885f5f5f5f5f5f5f	64	gnu	jg .+0x11
7f11|223344556677885f5f5f5f5f5f5f	64	intel	jnle .+0x11
7f11|223344556677885f5f5f5f5f5f5f	64	plan9	JG .+17
800011|223344556677885f5f5f5f5f5f	32	intel	add byte ptr [eax], 0x11
800011|223344556677885f5f5f5f5f5f	32	plan9	ADDL $0x11, 0(AX)
800011|223344556677885f5f5f5f5f5f	64	gnu	addb $0x11,(%rax)
800011|223344556677885f5f5f5f5f5f	64	intel	add byte ptr [rax], 0x11
800011|223344556677885f5f5f5f5f5f	64	plan9	ADDL $0x11, 0(AX)
800811|223344556677885f5f5f5f5f5f	32	intel	or byte ptr [eax], 0x11
800811|223344556677885f5f5f5f5f5f	32	plan9	ORL $0x11, 0(AX)
800811|223344556677885f5f5f5f5f5f	64	gnu	orb $0x11,(%rax)
800811|223344556677885f5f5f5f5f5f	64	intel	or byte ptr [rax], 0x11
800811|223344556677885f5f5f5f5f5f	64	plan9	ORL $0x11, 0(AX)
801122|3344556677885f5f5f5f5f5f5f	32	intel	adc byte ptr [ecx], 0x22
801122|3344556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x22, 0(CX)
801122|3344556677885f5f5f5f5f5f5f	64	gnu	adcb $0x22,(%rcx)
801122|3344556677885f5f5f5f5f5f5f	64	intel	adc byte ptr [rcx], 0x22
801122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x22, 0(CX)
801811|223344556677885f5f5f5f5f5f	32	intel	sbb byte ptr [eax], 0x11
801811|223344556677885f5f5f5f5f5f	32	plan9	SBBL $0x11, 0(AX)
801811|223344556677885f5f5f5f5f5f	64	gnu	sbbb $0x11,(%rax)
801811|223344556677885f5f5f5f5f5f	64	intel	sbb byte ptr [rax], 0x11
801811|223344556677885f5f5f5f5f5f	64	plan9	SBBL $0x11, 0(AX)
802011|223344556677885f5f5f5f5f5f	32	intel	and byte ptr [eax], 0x11
802011|223344556677885f5f5f5f5f5f	32	plan9	ANDL $0x11, 0(AX)
802011|223344556677885f5f5f5f5f5f	64	gnu	andb $0x11,(%rax)
802011|223344556677885f5f5f5f5f5f	64	intel	and byte ptr [rax], 0x11
802011|223344556677885f5f5f5f5f5f	64	plan9	ANDL $0x11, 0(AX)
802811|223344556677885f5f5f5f5f5f	32	intel	sub byte ptr [eax], 0x11
802811|223344556677885f5f5f5f5f5f	32	plan9	SUBL $0x11, 0(AX)
802811|223344556677885f5f5f5f5f5f	64	gnu	subb $0x11,(%rax)
802811|223344556677885f5f5f5f5f5f	64	intel	sub byte ptr [rax], 0x11
802811|223344556677885f5f5f5f5f5f	64	plan9	SUBL $0x11, 0(AX)
803011|223344556677885f5f5f5f5f5f	32	intel	xor byte ptr [eax], 0x11
803011|223344556677885f5f5f5f5f5f	32	plan9	XORL $0x11, 0(AX)
803011|223344556677885f5f5f5f5f5f	64	gnu	xorb $0x11,(%rax)
803011|223344556677885f5f5f5f5f5f	64	intel	xor byte ptr [rax], 0x11
803011|223344556677885f5f5f5f5f5f	64	plan9	XORL $0x11, 0(AX)
803811|223344556677885f5f5f5f5f5f	32	intel	cmp byte ptr [eax], 0x11
803811|223344556677885f5f5f5f5f5f	32	plan9	CMPL $0x11, 0(AX)
803811|223344556677885f5f5f5f5f5f	64	gnu	cmpb $0x11,(%rax)
803811|223344556677885f5f5f5f5f5f	64	intel	cmp byte ptr [rax], 0x11
803811|223344556677885f5f5f5f5f5f	64	plan9	CMPL $0x11, 0(AX)
810011223344|556677885f5f5f5f5f5f	32	intel	add dword ptr [eax], 0x44332211
810011223344|556677885f5f5f5f5f5f	32	plan9	ADDL $0x44332211, 0(AX)
810011223344|556677885f5f5f5f5f5f	64	gnu	addl $0x44332211,(%rax)
810011223344|556677885f5f5f5f5f5f	64	intel	add dword ptr [rax], 0x44332211
810011223344|556677885f5f5f5f5f5f	64	plan9	ADDL $0x44332211, 0(AX)
810811223344|556677885f5f5f5f5f5f	32	intel	or dword ptr [eax], 0x44332211
810811223344|556677885f5f5f5f5f5f	32	plan9	ORL $0x44332211, 0(AX)
810811223344|556677885f5f5f5f5f5f	64	gnu	orl $0x44332211,(%rax)
810811223344|556677885f5f5f5f5f5f	64	intel	or dword ptr [rax], 0x44332211
810811223344|556677885f5f5f5f5f5f	64	plan9	ORL $0x44332211, 0(AX)
811122334455|6677885f5f5f5f5f5f5f	32	intel	adc dword ptr [ecx], 0x55443322
811122334455|6677885f5f5f5f5f5f5f	32	plan9	ADCL $0x55443322, 0(CX)
811122334455|6677885f5f5f5f5f5f5f	64	gnu	adcl $0x55443322,(%rcx)
811122334455|6677885f5f5f5f5f5f5f	64	intel	adc dword ptr [rcx], 0x55443322
811122334455|6677885f5f5f5f5f5f5f	64	plan9	ADCL $0x55443322, 0(CX)
811811223344|556677885f5f5f5f5f5f	32	intel	sbb dword ptr [eax], 0x44332211
811811223344|556677885f5f5f5f5f5f	32	plan9	SBBL $0x44332211, 0(AX)
811811223344|556677885f5f5f5f5f5f	64	gnu	sbbl $0x44332211,(%rax)
811811223344|556677885f5f5f5f5f5f	64	intel	sbb dword ptr [rax], 0x44332211
811811223344|556677885f5f5f5f5f5f	64	plan9	SBBL $0x44332211, 0(AX)
812011223344|556677885f5f5f5f5f5f	32	intel	and dword ptr [eax], 0x44332211
812011223344|556677885f5f5f5f5f5f	32	plan9	ANDL $0x44332211, 0(AX)
812011223344|556677885f5f5f5f5f5f	64	gnu	andl $0x44332211,(%rax)
812011223344|556677885f5f5f5f5f5f	64	intel	and dword ptr [rax], 0x44332211
812011223344|556677885f5f5f5f5f5f	64	plan9	ANDL $0x44332211, 0(AX)
812811223344|556677885f5f5f5f5f5f	32	intel	sub dword ptr [eax], 0x44332211
812811223344|556677885f5f5f5f5f5f	32	plan9	SUBL $0x44332211, 0(AX)
812811223344|556677885f5f5f5f5f5f	64	gnu	subl $0x44332211,(%rax)
812811223344|556677885f5f5f5f5f5f	64	intel	sub dword ptr [rax], 0x44332211
812811223344|556677885f5f5f5f5f5f	64	plan9	SUBL $0x44332211, 0(AX)
813011223344|556677885f5f5f5f5f5f	32	intel	xor dword ptr [eax], 0x44332211
813011223344|556677885f5f5f5f5f5f	32	plan9	XORL $0x44332211, 0(AX)
813011223344|556677885f5f5f5f5f5f	64	gnu	xorl $0x44332211,(%rax)
813011223344|556677885f5f5f5f5f5f	64	intel	xor dword ptr [rax], 0x44332211
813011223344|556677885f5f5f5f5f5f	64	plan9	XORL $0x44332211, 0(AX)
813811223344|556677885f5f5f5f5f5f	32	intel	cmp dword ptr [eax], 0x44332211
813811223344|556677885f5f5f5f5f5f	32	plan9	CMPL $0x44332211, 0(AX)
813811223344|556677885f5f5f5f5f5f	64	gnu	cmpl $0x44332211,(%rax)
813811223344|556677885f5f5f5f5f5f	64	intel	cmp dword ptr [rax], 0x44332211
813811223344|556677885f5f5f5f5f5f	64	plan9	CMPL $0x44332211, 0(AX)
830011|223344556677885f5f5f5f5f5f	32	intel	add dword ptr [eax], 0x11
830011|223344556677885f5f5f5f5f5f	32	plan9	ADDL $0x11, 0(AX)
830011|223344556677885f5f5f5f5f5f	64	gnu	addl $0x11,(%rax)
830011|223344556677885f5f5f5f5f5f	64	intel	add dword ptr [rax], 0x11
830011|223344556677885f5f5f5f5f5f	64	plan9	ADDL $0x11, 0(AX)
830811|223344556677885f5f5f5f5f5f	32	intel	or dword ptr [eax], 0x11
830811|223344556677885f5f5f5f5f5f	32	plan9	ORL $0x11, 0(AX)
830811|223344556677885f5f5f5f5f5f	64	gnu	orl $0x11,(%rax)
830811|223344556677885f5f5f5f5f5f	64	intel	or dword ptr [rax], 0x11
830811|223344556677885f5f5f5f5f5f	64	plan9	ORL $0x11, 0(AX)
831122|3344556677885f5f5f5f5f5f5f	32	intel	adc dword ptr [ecx], 0x22
831122|3344556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x22, 0(CX)
831122|3344556677885f5f5f5f5f5f5f	64	gnu	adcl $0x22,(%rcx)
831122|3344556677885f5f5f5f5f5f5f	64	intel	adc dword ptr [rcx], 0x22
831122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x22, 0(CX)
831811|223344556677885f5f5f5f5f5f	32	intel	sbb dword ptr [eax], 0x11
831811|223344556677885f5f5f5f5f5f	32	plan9	SBBL $0x11, 0(AX)
831811|223344556677885f5f5f5f5f5f	64	gnu	sbbl $0x11,(%rax)
831811|223344556677885f5f5f5f5f5f	64	intel	sbb dword ptr [rax], 0x11
831811|223344556677885f5f5f5f5f5f	64	plan9	SBBL $0x11, 0(AX)
832011|223344556677885f5f5f5f5f5f	32	intel	and dword ptr [eax], 0x11
832011|223344556677885f5f5f5f5f5f	32	plan9	ANDL $0x11, 0(AX)
832011|223344556677885f5f5f5f5f5f	64	gnu	andl $0x11,(%rax)
832011|223344556677885f5f5f5f5f5f	64	intel	and dword ptr [rax], 0x11
832011|223344556677885f5f5f5f5f5f	64	plan9	ANDL $0x11, 0(AX)
832811|223344556677885f5f5f5f5f5f	32	intel	sub dword ptr [eax], 0x11
832811|223344556677885f5f5f5f5f5f	32	plan9	SUBL $0x11, 0(AX)
832811|223344556677885f5f5f5f5f5f	64	gnu	subl $0x11,(%rax)
832811|223344556677885f5f5f5f5f5f	64	intel	sub dword ptr [rax], 0x11
832811|223344556677885f5f5f5f5f5f	64	plan9	SUBL $0x11, 0(AX)
833011|223344556677885f5f5f5f5f5f	32	intel	xor dword ptr [eax], 0x11
833011|223344556677885f5f5f5f5f5f	32	plan9	XORL $0x11, 0(AX)
833011|223344556677885f5f5f5f5f5f	64	gnu	xorl $0x11,(%rax)
833011|223344556677885f5f5f5f5f5f	64	intel	xor dword ptr [rax], 0x11
833011|223344556677885f5f5f5f5f5f	64	plan9	XORL $0x11, 0(AX)
833811|223344556677885f5f5f5f5f5f	32	intel	cmp dword ptr [eax], 0x11
833811|223344556677885f5f5f5f5f5f	32	plan9	CMPL $0x11, 0(AX)
833811|223344556677885f5f5f5f5f5f	64	gnu	cmpl $0x11,(%rax)
833811|223344556677885f5f5f5f5f5f	64	intel	cmp dword ptr [rax], 0x11
833811|223344556677885f5f5f5f5f5f	64	plan9	CMPL $0x11, 0(AX)
8411|223344556677885f5f5f5f5f5f5f	32	intel	test byte ptr [ecx], dl
8411|223344556677885f5f5f5f5f5f5f	32	plan9	TESTL DL, 0(CX)
8411|223344556677885f5f5f5f5f5f5f	64	gnu	test %dl,(%rcx)
8411|223344556677885f5f5f5f5f5f5f	64	intel	test byte ptr [rcx], dl
8411|223344556677885f5f5f5f5f5f5f	64	plan9	TESTL DL, 0(CX)
8511|223344556677885f5f5f5f5f5f5f	32	intel	test dword ptr [ecx], edx
8511|223344556677885f5f5f5f5f5f5f	32	plan9	TESTL DX, 0(CX)
8511|223344556677885f5f5f5f5f5f5f	64	gnu	test %edx,(%rcx)
8511|223344556677885f5f5f5f5f5f5f	64	intel	test dword ptr [rcx], edx
8511|223344556677885f5f5f5f5f5f5f	64	plan9	TESTL DX, 0(CX)
8611|223344556677885f5f5f5f5f5f5f	32	intel	xchg byte ptr [ecx], dl
8611|223344556677885f5f5f5f5f5f5f	32	plan9	XCHGL DL, 0(CX)
8611|223344556677885f5f5f5f5f5f5f	64	gnu	xchg %dl,(%rcx)
8611|223344556677885f5f5f5f5f5f5f	64	intel	xchg byte ptr [rcx], dl
8611|223344556677885f5f5f5f5f5f5f	64	plan9	XCHGL DL, 0(CX)
8711|223344556677885f5f5f5f5f5f5f	32	intel	xchg dword ptr [ecx], edx
8711|223344556677885f5f5f5f5f5f5f	32	plan9	XCHGL DX, 0(CX)
8711|223344556677885f5f5f5f5f5f5f	64	gnu	xchg %edx,(%rcx)
8711|223344556677885f5f5f5f5f5f5f	64	intel	xchg dword ptr [rcx], edx
8711|223344556677885f5f5f5f5f5f5f	64	plan9	XCHGL DX, 0(CX)
8811|223344556677885f5f5f5f5f5f5f	32	intel	mov byte ptr [ecx], dl
8811|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL DL, 0(CX)
8811|223344556677885f5f5f5f5f5f5f	64	gnu	mov %dl,(%rcx)
8811|223344556677885f5f5f5f5f5f5f	64	intel	mov byte ptr [rcx], dl
8811|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL DL, 0(CX)
8911|223344556677885f5f5f5f5f5f5f	32	intel	mov dword ptr [ecx], edx
8911|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL DX, 0(CX)
8911|223344556677885f5f5f5f5f5f5f	64	gnu	mov %edx,(%rcx)
8911|223344556677885f5f5f5f5f5f5f	64	intel	mov dword ptr [rcx], edx
8911|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL DX, 0(CX)
8a11|223344556677885f5f5f5f5f5f5f	32	intel	mov dl, byte ptr [ecx]
8a11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL 0(CX), DL
8a11|223344556677885f5f5f5f5f5f5f	64	gnu	mov (%rcx),%dl
8a11|223344556677885f5f5f5f5f5f5f	64	intel	mov dl, byte ptr [rcx]
8a11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL 0(CX), DL
8b11|223344556677885f5f5f5f5f5f5f	32	intel	mov edx, dword ptr [ecx]
8b11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL 0(CX), DX
8b11|223344556677885f5f5f5f5f5f5f	64	gnu	mov (%rcx),%edx
8b11|223344556677885f5f5f5f5f5f5f	64	intel	mov edx, dword ptr [rcx]
8b11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL 0(CX), DX
8c11|223344556677885f5f5f5f5f5f5f	32	intel	mov word ptr [ecx], ss
8c11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL SS, 0(CX)
8c11|223344556677885f5f5f5f5f5f5f	64	gnu	mov %ss,(%rcx)
8c11|223344556677885f5f5f5f5f5f5f	64	intel	mov word ptr [rcx], ss
8c11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL SS, 0(CX)
8d11|223344556677885f5f5f5f5f5f5f	32	intel	lea edx, ptr [ecx]
8d11|223344556677885f5f5f5f5f5f5f	32	plan9	LEAL 0(CX), DX
8d11|223344556677885f5f5f5f5f5f5f	64	gnu	lea (%rcx),%edx
8d11|223344556677885f5f5f5f5f5f5f	64	intel	lea edx, ptr [rcx]
8d11|223344556677885f5f5f5f5f5f5f	64	plan9	LEAL 0(CX), DX
8e11|223344556677885f5f5f5f5f5f5f	32	intel	mov ss, word ptr [ecx]
8e11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL 0(CX), SS
8e11|223344556677885f5f5f5f5f5f5f	64	gnu	mov (%rcx),%ss
8e11|223344556677885f5f5f5f5f5f5f	64	intel	mov ss, word ptr [rcx]
8e11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL 0(CX), SS
8f00|11223344556677885f5f5f5f5f5f	32	intel	pop dword ptr [eax]
8f00|11223344556677885f5f5f5f5f5f	32	plan9	POPL 0(AX)
8f00|11223344556677885f5f5f5f5f5f	64	gnu	popq (%rax)
8f00|11223344556677885f5f5f5f5f5f	64	intel	pop qword ptr [rax]
8f00|11223344556677885f5f5f5f5f5f	64	plan9	POPL 0(AX)
91|11223344556677885f5f5f5f5f5f5f	32	intel	xchg ecx, eax
91|11223344556677885f5f5f5f5f5f5f	32	plan9	XCHGL AX, CX
91|11223344556677885f5f5f5f5f5f5f	64	intel	xchg ecx, eax
91|11223344556677885f5f5f5f5f5f5f	64	plan9	XCHGL AX, CX
98|11223344556677885f5f5f5f5f5f5f	32	intel	cwde
98|11223344556677885f5f5f5f5f5f5f	32	plan9	CWDE
98|11223344556677885f5f5f5f5f5f5f	64	gnu	cwtl
98|11223344556677885f5f5f5f5f5f5f	64	intel	cwde
98|11223344556677885f5f5f5f5f5f5f	64	plan9	CWDE
99|11223344556677885f5f5f5f5f5f5f	32	intel	cdq
99|11223344556677885f5f5f5f5f5f5f	32	plan9	CDQ
99|11223344556677885f5f5f5f5f5f5f	64	gnu	cltd
99|11223344556677885f5f5f5f5f5f5f	64	intel	cdq
99|11223344556677885f5f5f5f5f5f5f	64	plan9	CDQ
9a112233445566|77885f5f5f5f5f5f5f	32	intel	call far 0x44332211, 0x6655
9a112233445566|77885f5f5f5f5f5f5f	32	plan9	LCALL $0x44332211, $0x6655
9b|11223344556677885f5f5f5f5f5f5f	32	intel	fwait
9b|11223344556677885f5f5f5f5f5f5f	32	plan9	FWAIT
9b|11223344556677885f5f5f5f5f5f5f	64	gnu	fwait
9b|11223344556677885f5f5f5f5f5f5f	64	intel	fwait
9b|11223344556677885f5f5f5f5f5f5f	64	plan9	FWAIT
9c|11223344556677885f5f5f5f5f5f5f	32	intel	pushfd
9c|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHFD
9c|11223344556677885f5f5f5f5f5f5f	64	gnu	pushfq
9c|11223344556677885f5f5f5f5f5f5f	64	intel	pushfq
9c|11223344556677885f5f5f5f5f5f5f	64	plan9	PUSHFQ
9d|11223344556677885f5f5f5f5f5f5f	32	intel	popfd
9d|11223344556677885f5f5f5f5f5f5f	32	plan9	POPFD
9d|11223344556677885f5f5f5f5f5f5f	64	gnu	popfq
9d|11223344556677885f5f5f5f5f5f5f	64	intel	popfq
9d|11223344556677885f5f5f5f5f5f5f	64	plan9	POPFQ
9e|11223344556677885f5f5f5f5f5f5f	32	intel	sahf
9e|11223344556677885f5f5f5f5f5f5f	32	plan9	SAHF
9e|11223344556677885f5f5f5f5f5f5f	64	gnu	sahf
9e|11223344556677885f5f5f5f5f5f5f	64	intel	sahf
9e|11223344556677885f5f5f5f5f5f5f	64	plan9	SAHF
9f|11223344556677885f5f5f5f5f5f5f	32	intel	lahf
9f|11223344556677885f5f5f5f5f5f5f	32	plan9	LAHF
9f|11223344556677885f5f5f5f5f5f5f	64	gnu	lahf
9f|11223344556677885f5f5f5f5f5f5f	64	intel	lahf
9f|11223344556677885f5f5f5f5f5f5f	64	plan9	LAHF
a11122334455667788|5f5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%eax
a11122334455667788|5f5f5f5f5f5f5f	64	intel	mov eax, dword ptr [0x8877665544332211]
a11122334455667788|5f5f5f5f5f5f5f	64	plan9	MOVL -0x778899aabbccddef, AX
a111223344|556677885f5f5f5f5f5f5f	32	intel	mov eax, dword ptr [0x44332211]
a111223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL 0x44332211, AX
a21122334455667788|5f5f5f5f5f5f5f	64	gnu	mov %al,-0x778899aabbccddef
a21122334455667788|5f5f5f5f5f5f5f	64	intel	mov byte ptr [0x8877665544332211], al
a21122334455667788|5f5f5f5f5f5f5f	64	plan9	MOVL AL, -0x778899aabbccddef
a211223344|556677885f5f5f5f5f5f5f	32	intel	mov byte ptr [0x44332211], al
a211223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL AL, 0x44332211
a31122334455667788|5f5f5f5f5f5f5f	64	gnu	mov %eax,-0x778899aabbccddef
a31122334455667788|5f5f5f5f5f5f5f	64	intel	mov dword ptr [0x8877665544332211], eax
a31122334455667788|5f5f5f5f5f5f5f	64	plan9	MOVL AX, -0x778899aabbccddef
a311223344|556677885f5f5f5f5f5f5f	32	intel	mov dword ptr [0x44332211], eax
a311223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL AX, 0x44332211
a4|11223344556677885f5f5f5f5f5f5f	32	intel	movsb byte ptr [edi], byte ptr [esi]
a4|11223344556677885f5f5f5f5f5f5f	32	plan9	MOVSB DS:0(SI), ES:0(DI)
a4|11223344556677885f5f5f5f5f5f5f	64	gnu	movsb %ds:(%rsi),%es:(%rdi)
a4|11223344556677885f5f5f5f5f5f5f	64	intel	movsb byte ptr [rdi], byte ptr [rsi]
a4|11223344556677885f5f5f5f5f5f5f	64	plan9	MOVSB DS:0(SI), ES:0(DI)
a5|11223344556677885f5f5f5f5f5f5f	32	intel	movsd dword ptr [edi], dword ptr [esi]
a5|11223344556677885f5f5f5f5f5f5f	32	plan9	MOVSD DS:0(SI), ES:0(DI)
a5|11223344556677885f5f5f5f5f5f5f	64	gnu	movsl %ds:(%rsi),%es:(%rdi)
a5|11223344556677885f5f5f5f5f5f5f	64	intel	movsd dword ptr [rdi], dword ptr [rsi]
a5|11223344556677885f5f5f5f5f5f5f	64	plan9	MOVSD DS:0(SI), ES:0(DI)
a6|11223344556677885f5f5f5f5f5f5f	32	intel	cmpsb byte ptr [esi], byte ptr [edi]
a6|11223344556677885f5f5f5f5f5f5f	32	plan9	CMPSB ES:0(DI), DS:0(SI)
a6|11223344556677885f5f5f5f5f5f5f	64	gnu	cmpsb %es:(%rdi),%ds:(%rsi)
a6|11223344556677885f5f5f5f5f5f5f	64	intel	cmpsb byte ptr [rsi], byte ptr [rdi]
a6|11223344556677885f5f5f5f5f5f5f	64	plan9	CMPSB ES:0(DI), DS:0(SI)
a7|11223344556677885f5f5f5f5f5f5f	32	intel	cmpsd dword ptr [esi], dword ptr [edi]
a7|11223344556677885f5f5f5f5f5f5f	32	plan9	CMPSD ES:0(DI), DS:0(SI)
a7|11223344556677885f5f5f5f5f5f5f	64	gnu	cmpsl %es:(%rdi),%ds:(%rsi)
a7|11223344556677885f5f5f5f5f5f5f	64	intel	cmpsd dword ptr [rsi], dword ptr [rdi]
a7|11223344556677885f5f5f5f5f5f5f	64	plan9	CMPSD ES:0(DI), DS:0(SI)
a811|223344556677885f5f5f5f5f5f5f	32	intel	test al, 0x11
a811|223344556677885f5f5f5f5f5f5f	32	plan9	TESTL $0x11, AL
a811|223344556677885f5f5f5f5f5f5f	64	gnu	test $0x11,%al
a811|223344556677885f5f5f5f5f5f5f	64	intel	test al, 0x11
a811|223344556677885f5f5f5f5f5f5f	64	plan9	TESTL $0x11, AL
a911223344|556677885f5f5f5f5f5f5f	32	intel	test eax, 0x44332211
a911223344|556677885f5f5f5f5f5f5f	32	plan9	TESTL $0x44332211, AX
a911223344|556677885f5f5f5f5f5f5f	64	gnu	test $0x44332211,%eax
a911223344|556677885f5f5f5f5f5f5f	64	intel	test eax, 0x44332211
a911223344|556677885f5f5f5f5f5f5f	64	plan9	TESTL $0x44332211, AX
aa|11223344556677885f5f5f5f5f5f5f	32	intel	stosb byte ptr [edi]
aa|11223344556677885f5f5f5f5f5f5f	32	plan9	STOSB AL, ES:0(DI)
aa|11223344556677885f5f5f5f5f5f5f	64	gnu	stos %al,%es:(%rdi)
aa|11223344556677885f5f5f5f5f5f5f	64	intel	stosb byte ptr [rdi]
aa|11223344556677885f5f5f5f5f5f5f	64	plan9	STOSB AL, ES:0(DI)
ab|11223344556677885f5f5f5f5f5f5f	32	intel	stosd dword ptr [edi]
ab|11223344556677885f5f5f5f5f5f5f	32	plan9	STOSD AX, ES:0(DI)
ab|11223344556677885f5f5f5f5f5f5f	64	gnu	stos %eax,%es:(%rdi)
ab|11223344556677885f5f5f5f5f5f5f	64	intel	stosd dword ptr [rdi]
ab|11223344556677885f5f5f5f5f5f5f	64	plan9	STOSD AX, ES:0(DI)
ac|11223344556677885f5f5f5f5f5f5f	32	intel	lodsb byte ptr [esi]
ac|11223344556677885f5f5f5f5f5f5f	32	plan9	LODSB DS:0(SI), AL
ac|11223344556677885f5f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%al
ac|11223344556677885f5f5f5f5f5f5f	64	intel	lodsb byte ptr [rsi]
ac|11223344556677885f5f5f5f5f5f5f	64	plan9	LODSB DS:0(SI), AL
ad|11223344556677885f5f5f5f5f5f5f	32	intel	lodsd dword ptr [esi]
ad|11223344556677885f5f5f5f5f5f5f	32	plan9	LODSD DS:0(SI), AX
ad|11223344556677885f5f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%eax
ad|11223344556677885f5f5f5f5f5f5f	64	intel	lodsd dword ptr [rsi]
ad|11223344556677885f5f5f5f5f5f5f	64	plan9	LODSD DS:0(SI), AX
ae|11223344556677885f5f5f5f5f5f5f	32	intel	scasb byte ptr [edi]
ae|11223344556677885f5f5f5f5f5f5f	32	plan9	SCASB ES:0(DI), AL
ae|11223344556677885f5f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%al
ae|11223344556677885f5f5f5f5f5f5f	64	intel	scasb byte ptr [rdi]
ae|11223344556677885f5f5f5f5f5f5f	64	plan9	SCASB ES:0(DI), AL
af|11223344556677885f5f5f5f5f5f5f	32	intel	scasd dword ptr [edi]
af|11223344556677885f5f5f5f5f5f5f	32	plan9	SCASD ES:0(DI), AX
af|11223344556677885f5f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%eax
af|11223344556677885f5f5f5f5f5f5f	64	intel	scasd dword ptr [rdi]
af|11223344556677885f5f5f5f5f5f5f	64	plan9	SCASD ES:0(DI), AX
b011|223344556677885f5f5f5f5f5f5f	32	intel	mov al, 0x11
b011|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL $0x11, AL
b011|223344556677885f5f5f5f5f5f5f	64	gnu	mov $0x11,%al
b011|223344556677885f5f5f5f5f5f5f	64	intel	mov al, 0x11
b011|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL $0x11, AL
b811223344|556677885f5f5f5f5f5f5f	32	intel	mov eax, 0x44332211
b811223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL $0x44332211, AX
b811223344|556677885f5f5f5f5f5f5f	64	gnu	mov $0x44332211,%eax
b811223344|556677885f5f5f5f5f5f5f	64	intel	mov eax, 0x44332211
b811223344|556677885f5f5f5f5f5f5f	64	plan9	MOVL $0x44332211, AX
c00011|223344556677885f5f5f5f5f5f	32	intel	rol byte ptr [eax], 0x11
c00011|223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x11, 0(AX)
c00011|223344556677885f5f5f5f5f5f	64	gnu	rolb $0x11,(%rax)
c00011|223344556677885f5f5f5f5f5f	64	intel	rol byte ptr [rax], 0x11
c00011|223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x11, 0(AX)
c00811|223344556677885f5f5f5f5f5f	32	intel	ror byte ptr [eax], 0x11
c00811|223344556677885f5f5f5f5f5f	32	plan9	RORL $0x11, 0(AX)
c00811|223344556677885f5f5f5f5f5f	64	gnu	rorb $0x11,(%rax)
c00811|223344556677885f5f5f5f5f5f	64	intel	ror byte ptr [rax], 0x11
c00811|223344556677885f5f5f5f5f5f	64	plan9	RORL $0x11, 0(AX)
c01122|3344556677885f5f5f5f5f5f5f	32	intel	rcl byte ptr [ecx], 0x22
c01122|3344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x22, 0(CX)
c01122|3344556677885f5f5f5f5f5f5f	64	gnu	rclb $0x22,(%rcx)
c01122|3344556677885f5f5f5f5f5f5f	64	intel	rcl byte ptr [rcx], 0x22
c01122|3344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x22, 0(CX)
c01811|223344556677885f5f5f5f5f5f	32	intel	rcr byte ptr [eax], 0x11
c01811|223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x11, 0(AX)
c01811|223344556677885f5f5f5f5f5f	64	gnu	rcrb $0x11,(%rax)
c01811|223344556677885f5f5f5f5f5f	64	intel	rcr byte ptr [rax], 0x11
c01811|223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x11, 0(AX)
c02011|223344556677885f5f5f5f5f5f	32	intel	shl byte ptr [eax], 0x11
c02011|223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x11, 0(AX)
c02011|223344556677885f5f5f5f5f5f	64	gnu	shlb $0x11,(%rax)
c02011|223344556677885f5f5f5f5f5f	64	intel	shl byte ptr [rax], 0x11
c02011|223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x11, 0(AX)
c02811|223344556677885f5f5f5f5f5f	32	intel	shr byte ptr [eax], 0x11
c02811|223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x11, 0(AX)
c02811|223344556677885f5f5f5f5f5f	64	gnu	shrb $0x11,(%rax)
c02811|223344556677885f5f5f5f5f5f	64	intel	shr byte ptr [rax], 0x11
c02811|223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x11, 0(AX)
c03811|223344556677885f5f5f5f5f5f	32	intel	sar byte ptr [eax], 0x11
c03811|223344556677885f5f5f5f5f5f	32	plan9	SARL $0x11, 0(AX)
c03811|223344556677885f5f5f5f5f5f	64	gnu	sarb $0x11,(%rax)
c03811|223344556677885f5f5f5f5f5f	64	intel	sar byte ptr [rax], 0x11
c03811|223344556677885f5f5f5f5f5f	64	plan9	SARL $0x11, 0(AX)
c10011|223344556677885f5f5f5f5f5f	32	intel	rol dword ptr [eax], 0x11
c10011|223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x11, 0(AX)
c10011|223344556677885f5f5f5f5f5f	64	gnu	roll $0x11,(%rax)
c10011|223344556677885f5f5f5f5f5f	64	intel	rol dword ptr [rax], 0x11
c10011|223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x11, 0(AX)
c10811|223344556677885f5f5f5f5f5f	32	intel	ror dword ptr [eax], 0x11
c10811|223344556677885f5f5f5f5f5f	32	plan9	RORL $0x11, 0(AX)
c10811|223344556677885f5f5f5f5f5f	64	gnu	rorl $0x11,(%rax)
c10811|223344556677885f5f5f5f5f5f	64	intel	ror dword ptr [rax], 0x11
c10811|223344556677885f5f5f5f5f5f	64	plan9	RORL $0x11, 0(AX)
c11122|3344556677885f5f5f5f5f5f5f	32	intel	rcl dword ptr [ecx], 0x22
c11122|3344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x22, 0(CX)
c11122|3344556677885f5f5f5f5f5f5f	64	gnu	rcll $0x22,(%rcx)
c11122|3344556677885f5f5f5f5f5f5f	64	intel	rcl dword ptr [rcx], 0x22
c11122|3344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x22, 0(CX)
c11811|223344556677885f5f5f5f5f5f	32	intel	rcr dword ptr [eax], 0x11
c11811|223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x11, 0(AX)
c11811|223344556677885f5f5f5f5f5f	64	gnu	rcrl $0x11,(%rax)
c11811|223344556677885f5f5f5f5f5f	64	intel	rcr dword ptr [rax], 0x11
c11811|223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x11, 0(AX)
c12011|223344556677885f5f5f5f5f5f	32	intel	shl dword ptr [eax], 0x11
c12011|223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x11, 0(AX)
c12011|223344556677885f5f5f5f5f5f	64	gnu	shll $0x11,(%rax)
c12011|223344556677885f5f5f5f5f5f	64	intel	shl dword ptr [rax], 0x11
c12011|223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x11, 0(AX)
c12811|223344556677885f5f5f5f5f5f	32	intel	shr dword ptr [eax], 0x11
c12811|223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x11, 0(AX)
c12811|223344556677885f5f5f5f5f5f	64	gnu	shrl $0x11,(%rax)
c12811|223344556677885f5f5f5f5f5f	64	intel	shr dword ptr [rax], 0x11
c12811|223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x11, 0(AX)
c13811|223344556677885f5f5f5f5f5f	32	intel	sar dword ptr [eax], 0x11
c13811|223344556677885f5f5f5f5f5f	32	plan9	SARL $0x11, 0(AX)
c13811|223344556677885f5f5f5f5f5f	64	gnu	sarl $0x11,(%rax)
c13811|223344556677885f5f5f5f5f5f	64	intel	sar dword ptr [rax], 0x11
c13811|223344556677885f5f5f5f5f5f	64	plan9	SARL $0x11, 0(AX)
c3|11223344556677885f5f5f5f5f5f5f	32	intel	ret
c3|11223344556677885f5f5f5f5f5f5f	32	plan9	RET
c3|11223344556677885f5f5f5f5f5f5f	64	gnu	retq
c3|11223344556677885f5f5f5f5f5f5f	64	intel	ret
c3|11223344556677885f5f5f5f5f5f5f	64	plan9	RET
c411|223344556677885f5f5f5f5f5f5f	32	intel	les edx, ptr [ecx]
c411|223344556677885f5f5f5f5f5f5f	32	plan9	LES 0(CX), DX
c511|223344556677885f5f5f5f5f5f5f	32	intel	lds edx, ptr [ecx]
c511|223344556677885f5f5f5f5f5f5f	32	plan9	LDS 0(CX), DX
c60011|223344556677885f5f5f5f5f5f	32	intel	mov byte ptr [eax], 0x11
c60011|223344556677885f5f5f5f5f5f	32	plan9	MOVL $0x11, 0(AX)
c60011|223344556677885f5f5f5f5f5f	64	gnu	movb $0x11,(%rax)
c60011|223344556677885f5f5f5f5f5f	64	intel	mov byte ptr [rax], 0x11
c60011|223344556677885f5f5f5f5f5f	64	plan9	MOVL $0x11, 0(AX)
c6f811|223344556677885f5f5f5f5f5f	32	intel	xabort 0x11
c6f811|223344556677885f5f5f5f5f5f	32	plan9	XABORT $0x11
c6f811|223344556677885f5f5f5f5f5f	64	gnu	xabort $0x11
c6f811|223344556677885f5f5f5f5f5f	64	intel	xabort 0x11
c6f811|223344556677885f5f5f5f5f5f	64	plan9	XABORT $0x11
c70011223344|556677885f5f5f5f5f5f	32	intel	mov dword ptr [eax], 0x44332211
c70011223344|556677885f5f5f5f5f5f	32	plan9	MOVL $0x44332211, 0(AX)
c70011223344|556677885f5f5f5f5f5f	64	gnu	movl $0x44332211,(%rax)
c70011223344|556677885f5f5f5f5f5f	64	intel	mov dword ptr [rax], 0x44332211
c70011223344|556677885f5f5f5f5f5f	64	plan9	MOVL $0x44332211, 0(AX)
c7f811223344|556677885f5f5f5f5f5f	32	intel	xbegin .+0x44332211
c7f811223344|556677885f5f5f5f5f5f	32	plan9	XBEGIN .+1144201745
c7f811223344|556677885f5f5f5f5f5f	64	gnu	xbeginq .+0x44332211
c7f811223344|556677885f5f5f5f5f5f	64	intel	xbegin .+0x44332211
c7f811223344|556677885f5f5f5f5f5f	64	plan9	XBEGIN .+1144201745
c8112233|44556677885f5f5f5f5f5f5f	32	intel	enter 0x2211, 0x33
c8112233|44556677885f5f5f5f5f5f5f	32	plan9	ENTER $0x33, $0x2211
c8112233|44556677885f5f5f5f5f5f5f	64	gnu	enterq $0x2211,$0x33
c8112233|44556677885f5f5f5f5f5f5f	64	intel	enter 0x2211, 0x33
c8112233|44556677885f5f5f5f5f5f5f	64	plan9	ENTER $0x33, $0x2211
c9|11223344556677885f5f5f5f5f5f5f	32	intel	leave
c9|11223344556677885f5f5f5f5f5f5f	32	plan9	LEAVE
c9|11223344556677885f5f5f5f5f5f5f	64	gnu	leaveq
c9|11223344556677885f5f5f5f5f5f5f	64	intel	leave
c9|11223344556677885f5f5f5f5f5f5f	64	plan9	LEAVE
ca1122|3344556677885f5f5f5f5f5f5f	32	intel	ret far 0x2211
ca1122|3344556677885f5f5f5f5f5f5f	32	plan9	LRET $0x2211
ca1122|3344556677885f5f5f5f5f5f5f	64	gnu	lretq $0x2211
ca1122|3344556677885f5f5f5f5f5f5f	64	intel	ret far 0x2211
ca1122|3344556677885f5f5f5f5f5f5f	64	plan9	LRET $0x2211
cb|11223344556677885f5f5f5f5f5f5f	32	intel	ret far
cb|11223344556677885f5f5f5f5f5f5f	32	plan9	LRET
cb|11223344556677885f5f5f5f5f5f5f	64	gnu	lretq
cb|11223344556677885f5f5f5f5f5f5f	64	intel	ret far
cb|11223344556677885f5f5f5f5f5f5f	64	plan9	LRET
cc|11223344556677885f5f5f5f5f5f5f	32	intel	int3
cc|11223344556677885f5f5f5f5f5f5f	32	plan9	INT $0x3
cc|11223344556677885f5f5f5f5f5f5f	64	gnu	int3
cc|11223344556677885f5f5f5f5f5f5f	64	intel	int3
cc|11223344556677885f5f5f5f5f5f5f	64	plan9	INT $0x3
cd11|223344556677885f5f5f5f5f5f5f	32	intel	int 0x11
cd11|223344556677885f5f5f5f5f5f5f	32	plan9	INT $0x11
cd11|223344556677885f5f5f5f5f5f5f	64	gnu	int $0x11
cd11|223344556677885f5f5f5f5f5f5f	64	intel	int 0x11
cd11|223344556677885f5f5f5f5f5f5f	64	plan9	INT $0x11
ce|11223344556677885f5f5f5f5f5f5f	32	intel	into
ce|11223344556677885f5f5f5f5f5f5f	32	plan9	INTO
ce|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
ce|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
ce|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
cf|11223344556677885f5f5f5f5f5f5f	32	intel	iretd
cf|11223344556677885f5f5f5f5f5f5f	32	plan9	IRETD
cf|11223344556677885f5f5f5f5f5f5f	64	gnu	iret
cf|11223344556677885f5f5f5f5f5f5f	64	intel	iretd
cf|11223344556677885f5f5f5f5f5f5f	64	plan9	IRETD
d000|11223344556677885f5f5f5f5f5f	32	intel	rol byte ptr [eax], 0x1
d000|11223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x1, 0(AX)
d000|11223344556677885f5f5f5f5f5f	64	gnu	rolb (%rax)
d000|11223344556677885f5f5f5f5f5f	64	intel	rol byte ptr [rax], 0x1
d000|11223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x1, 0(AX)
d008|11223344556677885f5f5f5f5f5f	32	intel	ror byte ptr [eax], 0x1
d008|11223344556677885f5f5f5f5f5f	32	plan9	RORL $0x1, 0(AX)
d008|11223344556677885f5f5f5f5f5f	64	gnu	rorb (%rax)
d008|11223344556677885f5f5f5f5f5f	64	intel	ror byte ptr [rax], 0x1
d008|11223344556677885f5f5f5f5f5f	64	plan9	RORL $0x1, 0(AX)
d011|223344556677885f5f5f5f5f5f5f	32	intel	rcl byte ptr [ecx], 0x1
d011|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x1, 0(CX)
d011|223344556677885f5f5f5f5f5f5f	64	gnu	rclb (%rcx)
d011|223344556677885f5f5f5f5f5f5f	64	intel	rcl byte ptr [rcx], 0x1
d011|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x1, 0(CX)
d018|11223344556677885f5f5f5f5f5f	32	intel	rcr byte ptr [eax], 0x1
d018|11223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x1, 0(AX)
d018|11223344556677885f5f5f5f5f5f	64	gnu	rcrb (%rax)
d018|11223344556677885f5f5f5f5f5f	64	intel	rcr byte ptr [rax], 0x1
d018|11223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x1, 0(AX)
d020|11223344556677885f5f5f5f5f5f	32	intel	shl byte ptr [eax], 0x1
d020|11223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x1, 0(AX)
d020|11223344556677885f5f5f5f5f5f	64	gnu	shlb (%rax)
d020|11223344556677885f5f5f5f5f5f	64	intel	shl byte ptr [rax], 0x1
d020|11223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x1, 0(AX)
d028|11223344556677885f5f5f5f5f5f	32	intel	shr byte ptr [eax], 0x1
d028|11223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x1, 0(AX)
d028|11223344556677885f5f5f5f5f5f	64	gnu	shrb (%rax)
d028|11223344556677885f5f5f5f5f5f	64	intel	shr byte ptr [rax], 0x1
d028|11223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x1, 0(AX)
d038|11223344556677885f5f5f5f5f5f	32	intel	sar byte ptr [eax], 0x1
d038|11223344556677885f5f5f5f5f5f	32	plan9	SARL $0x1, 0(AX)
d038|11223344556677885f5f5f5f5f5f	64	gnu	sarb (%rax)
d038|11223344556677885f5f5f5f5f5f	64	intel	sar byte ptr [rax], 0x1
d038|11223344556677885f5f5f5f5f5f	64	plan9	SARL $0x1, 0(AX)
d100|11223344556677885f5f5f5f5f5f	32	intel	rol dword ptr [eax], 0x1
d100|11223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x1, 0(AX)
d100|11223344556677885f5f5f5f5f5f	64	gnu	roll (%rax)
d100|11223344556677885f5f5f5f5f5f	64	intel	rol dword ptr [rax], 0x1
d100|11223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x1, 0(AX)
d108|11223344556677885f5f5f5f5f5f	32	intel	ror dword ptr [eax], 0x1
d108|11223344556677885f5f5f5f5f5f	32	plan9	RORL $0x1, 0(AX)
d108|11223344556677885f5f5f5f5f5f	64	gnu	rorl (%rax)
d108|11223344556677885f5f5f5f5f5f	64	intel	ror dword ptr [rax], 0x1
d108|11223344556677885f5f5f5f5f5f	64	plan9	RORL $0x1, 0(AX)
d111|223344556677885f5f5f5f5f5f5f	32	intel	rcl dword ptr [ecx], 0x1
d111|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x1, 0(CX)
d111|223344556677885f5f5f5f5f5f5f	64	gnu	rcll (%rcx)
d111|223344556677885f5f5f5f5f5f5f	64	intel	rcl dword ptr [rcx], 0x1
d111|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x1, 0(CX)
d118|11223344556677885f5f5f5f5f5f	32	intel	rcr dword ptr [eax], 0x1
d118|11223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x1, 0(AX)
d118|11223344556677885f5f5f5f5f5f	64	gnu	rcrl (%rax)
d118|11223344556677885f5f5f5f5f5f	64	intel	rcr dword ptr [rax], 0x1
d118|11223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x1, 0(AX)
d120|11223344556677885f5f5f5f5f5f	32	intel	shl dword ptr [eax], 0x1
d120|11223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x1, 0(AX)
d120|11223344556677885f5f5f5f5f5f	64	gnu	shll (%rax)
d120|11223344556677885f5f5f5f5f5f	64	intel	shl dword ptr [rax], 0x1
d120|11223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x1, 0(AX)
d128|11223344556677885f5f5f5f5f5f	32	intel	shr dword ptr [eax], 0x1
d128|11223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x1, 0(AX)
d128|11223344556677885f5f5f5f5f5f	64	gnu	shrl (%rax)
d128|11223344556677885f5f5f5f5f5f	64	intel	shr dword ptr [rax], 0x1
d128|11223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x1, 0(AX)
d138|11223344556677885f5f5f5f5f5f	32	intel	sar dword ptr [eax], 0x1
d138|11223344556677885f5f5f5f5f5f	32	plan9	SARL $0x1, 0(AX)
d138|11223344556677885f5f5f5f5f5f	64	gnu	sarl (%rax)
d138|11223344556677885f5f5f5f5f5f	64	intel	sar dword ptr [rax], 0x1
d138|11223344556677885f5f5f5f5f5f	64	plan9	SARL $0x1, 0(AX)
d200|11223344556677885f5f5f5f5f5f	32	intel	rol byte ptr [eax], cl
d200|11223344556677885f5f5f5f5f5f	32	plan9	ROLL CL, 0(AX)
d200|11223344556677885f5f5f5f5f5f	64	gnu	rolb %cl,(%rax)
d200|11223344556677885f5f5f5f5f5f	64	intel	rol byte ptr [rax], cl
d200|11223344556677885f5f5f5f5f5f	64	plan9	ROLL CL, 0(AX)
d208|11223344556677885f5f5f5f5f5f	32	intel	ror byte ptr [eax], cl
d208|11223344556677885f5f5f5f5f5f	32	plan9	RORL CL, 0(AX)
d208|11223344556677885f5f5f5f5f5f	64	gnu	rorb %cl,(%rax)
d208|11223344556677885f5f5f5f5f5f	64	intel	ror byte ptr [rax], cl
d208|11223344556677885f5f5f5f5f5f	64	plan9	RORL CL, 0(AX)
d211|223344556677885f5f5f5f5f5f5f	32	intel	rcl byte ptr [ecx], cl
d211|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL CL, 0(CX)
d211|223344556677885f5f5f5f5f5f5f	64	gnu	rclb %cl,(%rcx)
d211|223344556677885f5f5f5f5f5f5f	64	intel	rcl byte ptr [rcx], cl
d211|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL CL, 0(CX)
d218|11223344556677885f5f5f5f5f5f	32	intel	rcr byte ptr [eax], cl
d218|11223344556677885f5f5f5f5f5f	32	plan9	RCRL CL, 0(AX)
d218|11223344556677885f5f5f5f5f5f	64	gnu	rcrb %cl,(%rax)
d218|11223344556677885f5f5f5f5f5f	64	intel	rcr byte ptr [rax], cl
d218|11223344556677885f5f5f5f5f5f	64	plan9	RCRL CL, 0(AX)
d220|11223344556677885f5f5f5f5f5f	32	intel	shl byte ptr [eax], cl
d220|11223344556677885f5f5f5f5f5f	32	plan9	SHLL CL, 0(AX)
d220|11223344556677885f5f5f5f5f5f	64	gnu	shlb %cl,(%rax)
d220|11223344556677885f5f5f5f5f5f	64	intel	shl byte ptr [rax], cl
d220|11223344556677885f5f5f5f5f5f	64	plan9	SHLL CL, 0(AX)
d228|11223344556677885f5f5f5f5f5f	32	intel	shr byte ptr [eax], cl
d228|11223344556677885f5f5f5f5f5f	32	plan9	SHRL CL, 0(AX)
d228|11223344556677885f5f5f5f5f5f	64	gnu	shrb %cl,(%rax)
d228|11223344556677885f5f5f5f5f5f	64	intel	shr byte ptr [rax], cl
d228|11223344556677885f5f5f5f5f5f	64	plan9	SHRL CL, 0(AX)
d238|11223344556677885f5f5f5f5f5f	32	intel	sar byte ptr [eax], cl
d238|11223344556677885f5f5f5f5f5f	32	plan9	SARL CL, 0(AX)
d238|11223344556677885f5f5f5f5f5f	64	gnu	sarb %cl,(%rax)
d238|11223344556677885f5f5f5f5f5f	64	intel	sar byte ptr [rax], cl
d238|11223344556677885f5f5f5f5f5f	64	plan9	SARL CL, 0(AX)
d300|11223344556677885f5f5f5f5f5f	32	intel	rol dword ptr [eax], cl
d300|11223344556677885f5f5f5f5f5f	32	plan9	ROLL CL, 0(AX)
d300|11223344556677885f5f5f5f5f5f	64	gnu	roll %cl,(%rax)
d300|11223344556677885f5f5f5f5f5f	64	intel	rol dword ptr [rax], cl
d300|11223344556677885f5f5f5f5f5f	64	plan9	ROLL CL, 0(AX)
d308|11223344556677885f5f5f5f5f5f	32	intel	ror dword ptr [eax], cl
d308|11223344556677885f5f5f5f5f5f	32	plan9	RORL CL, 0(AX)
d308|11223344556677885f5f5f5f5f5f	64	gnu	rorl %cl,(%rax)
d308|11223344556677885f5f5f5f5f5f	64	intel	ror dword ptr [rax], cl
d308|11223344556677885f5f5f5f5f5f	64	plan9	RORL CL, 0(AX)
d311|223344556677885f5f5f5f5f5f5f	32	intel	rcl dword ptr [ecx], cl
d311|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL CL, 0(CX)
d311|223344556677885f5f5f5f5f5f5f	64	gnu	rcll %cl,(%rcx)
d311|223344556677885f5f5f5f5f5f5f	64	intel	rcl dword ptr [rcx], cl
d311|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL CL, 0(CX)
d318|11223344556677885f5f5f5f5f5f	32	intel	rcr dword ptr [eax], cl
d318|11223344556677885f5f5f5f5f5f	32	plan9	RCRL CL, 0(AX)
d318|11223344556677885f5f5f5f5f5f	64	gnu	rcrl %cl,(%rax)
d318|11223344556677885f5f5f5f5f5f	64	intel	rcr dword ptr [rax], cl
d318|11223344556677885f5f5f5f5f5f	64	plan9	RCRL CL, 0(AX)
d320|11223344556677885f5f5f5f5f5f	32	intel	shl dword ptr [eax], cl
d320|11223344556677885f5f5f5f5f5f	32	plan9	SHLL CL, 0(AX)
d320|11223344556677885f5f5f5f5f5f	64	gnu	shll %cl,(%rax)
d320|11223344556677885f5f5f5f5f5f	64	intel	shl dword ptr [rax], cl
d320|11223344556677885f5f5f5f5f5f	64	plan9	SHLL CL, 0(AX)
d328|11223344556677885f5f5f5f5f5f	32	intel	shr dword ptr [eax], cl
d328|11223344556677885f5f5f5f5f5f	32	plan9	SHRL CL, 0(AX)
d328|11223344556677885f5f5f5f5f5f	64	gnu	shrl %cl,(%rax)
d328|11223344556677885f5f5f5f5f5f	64	intel	shr dword ptr [rax], cl
d328|11223344556677885f5f5f5f5f5f	64	plan9	SHRL CL, 0(AX)
d338|11223344556677885f5f5f5f5f5f	32	intel	sar dword ptr [eax], cl
d338|11223344556677885f5f5f5f5f5f	32	plan9	SARL CL, 0(AX)
d338|11223344556677885f5f5f5f5f5f	64	gnu	sarl %cl,(%rax)
d338|11223344556677885f5f5f5f5f5f	64	intel	sar dword ptr [rax], cl
d338|11223344556677885f5f5f5f5f5f	64	plan9	SARL CL, 0(AX)
d511|223344556677885f5f5f5f5f5f5f	32	intel	aad 0x11
d511|223344556677885f5f5f5f5f5f5f	32	plan9	AAD $0x11
d5|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
d5|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
d5|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
d800|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, dword ptr [eax]
d800|11223344556677885f5f5f5f5f5f	32	plan9	FADD 0(AX)
d800|11223344556677885f5f5f5f5f5f	64	gnu	fadds (%rax)
d800|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, dword ptr [rax]
d800|11223344556677885f5f5f5f5f5f	64	plan9	FADD 0(AX)
d808|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, dword ptr [eax]
d808|11223344556677885f5f5f5f5f5f	32	plan9	FMUL 0(AX)
d808|11223344556677885f5f5f5f5f5f	64	gnu	fmuls (%rax)
d808|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, dword ptr [rax]
d808|11223344556677885f5f5f5f5f5f	64	plan9	FMUL 0(AX)
d811|223344556677885f5f5f5f5f5f5f	32	intel	fcom st0, dword ptr [ecx]
d811|223344556677885f5f5f5f5f5f5f	32	plan9	FCOM 0(CX)
d811|223344556677885f5f5f5f5f5f5f	64	gnu	fcoms (%rcx)
d811|223344556677885f5f5f5f5f5f5f	64	intel	fcom st0, dword ptr [rcx]
d811|223344556677885f5f5f5f5f5f5f	64	plan9	FCOM 0(CX)
d818|11223344556677885f5f5f5f5f5f	32	intel	fcomp st0, dword ptr [eax]
d818|11223344556677885f5f5f5f5f5f	32	plan9	FCOMP 0(AX)
d818|11223344556677885f5f5f5f5f5f	64	gnu	fcomps (%rax)
d818|11223344556677885f5f5f5f5f5f	64	intel	fcomp st0, dword ptr [rax]
d818|11223344556677885f5f5f5f5f5f	64	plan9	FCOMP 0(AX)
d820|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, dword ptr [eax]
d820|11223344556677885f5f5f5f5f5f	32	plan9	FSUB 0(AX)
d820|11223344556677885f5f5f5f5f5f	64	gnu	fsubs (%rax)
d820|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, dword ptr [rax]
d820|11223344556677885f5f5f5f5f5f	64	plan9	FSUB 0(AX)
d828|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, dword ptr [eax]
d828|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR 0(AX)
d828|11223344556677885f5f5f5f5f5f	64	gnu	fsubrs (%rax)
d828|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, dword ptr [rax]
d828|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR 0(AX)
d830|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, dword ptr [eax]
d830|11223344556677885f5f5f5f5f5f	32	plan9	FDIV 0(AX)
d830|11223344556677885f5f5f5f5f5f	64	gnu	fdivs (%rax)
d830|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, dword ptr [rax]
d830|11223344556677885f5f5f5f5f5f	64	plan9	FDIV 0(AX)
d838|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, dword ptr [eax]
d838|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR 0(AX)
d838|11223344556677885f5f5f5f5f5f	64	gnu	fdivrs (%rax)
d838|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, dword ptr [rax]
d838|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR 0(AX)
d8c0|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, st0
d8c0|11223344556677885f5f5f5f5f5f	32	plan9	FADD F0, F0
d8c0|11223344556677885f5f5f5f5f5f	64	gnu	fadd %st,%st
d8c0|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, st0
d8c0|11223344556677885f5f5f5f5f5f	64	plan9	FADD F0, F0
d8c8|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, st0
d8c8|11223344556677885f5f5f5f5f5f	32	plan9	FMUL F0, F0
d8c8|11223344556677885f5f5f5f5f5f	64	gnu	fmul %st,%st
d8c8|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, st0
d8c8|11223344556677885f5f5f5f5f5f	64	plan9	FMUL F0, F0
d8d0|11223344556677885f5f5f5f5f5f	32	intel	fcom st0, st0
d8d0|11223344556677885f5f5f5f5f5f	32	plan9	FCOM F0
d8d0|11223344556677885f5f5f5f5f5f	64	gnu	fcom %st
d8d0|11223344556677885f5f5f5f5f5f	64	intel	fcom st0, st0
d8d0|11223344556677885f5f5f5f5f5f	64	plan9	FCOM F0
d8d8|11223344556677885f5f5f5f5f5f	32	intel	fcomp st0, st0
d8d8|11223344556677885f5f5f5f5f5f	32	plan9	FCOMP F0
d8d8|11223344556677885f5f5f5f5f5f	64	gnu	fcomp %st
d8d8|11223344556677885f5f5f5f5f5f	64	intel	fcomp st0, st0
d8d8|11223344556677885f5f5f5f5f5f	64	plan9	FCOMP F0
d8e0|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, st0
d8e0|11223344556677885f5f5f5f5f5f	32	plan9	FSUB F0, F0
d8e0|11223344556677885f5f5f5f5f5f	64	gnu	fsub %st,%st
d8e0|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, st0
d8e0|11223344556677885f5f5f5f5f5f	64	plan9	FSUB F0, F0
d8e8|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, st0
d8e8|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR F0, F0
d8e8|11223344556677885f5f5f5f5f5f	64	gnu	fsubr %st,%st
d8e8|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, st0
d8e8|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR F0, F0
d8f0|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, st0
d8f0|11223344556677885f5f5f5f5f5f	32	plan9	FDIV F0, F0
d8f0|11223344556677885f5f5f5f5f5f	64	gnu	fdiv %st,%st
d8f0|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, st0
d8f0|11223344556677885f5f5f5f5f5f	64	plan9	FDIV F0, F0
d8f8|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, st0
d8f8|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR F0, F0
d8f8|11223344556677885f5f5f5f5f5f	64	gnu	fdivr %st,%st
d8f8|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, st0
d8f8|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR F0, F0
d900|11223344556677885f5f5f5f5f5f	32	intel	fld st0, dword ptr [eax]
d900|11223344556677885f5f5f5f5f5f	32	plan9	FLD 0(AX)
d900|11223344556677885f5f5f5f5f5f	64	gnu	flds (%rax)
d900|11223344556677885f5f5f5f5f5f	64	intel	fld st0, dword ptr [rax]
d900|11223344556677885f5f5f5f5f5f	64	plan9	FLD 0(AX)
d911|223344556677885f5f5f5f5f5f5f	32	intel	fst dword ptr [ecx], st0
d911|223344556677885f5f5f5f5f5f5f	32	plan9	FST 0(CX)
d911|223344556677885f5f5f5f5f5f5f	64	gnu	fsts (%rcx)
d911|223344556677885f5f5f5f5f5f5f	64	intel	fst dword ptr [rcx], st0
d911|223344556677885f5f5f5f5f5f5f	64	plan9	FST 0(CX)
d918|11223344556677885f5f5f5f5f5f	32	intel	fstp dword ptr [eax], st0
d918|11223344556677885f5f5f5f5f5f	32	plan9	FSTP 0(AX)
d918|11223344556677885f5f5f5f5f5f	64	gnu	fstps (%rax)
d918|11223344556677885f5f5f5f5f5f	64	intel	fstp dword ptr [rax], st0
d918|11223344556677885f5f5f5f5f5f	64	plan9	FSTP 0(AX)
d928|11223344556677885f5f5f5f5f5f	32	intel	fldcw word ptr [eax]
d928|11223344556677885f5f5f5f5f5f	32	plan9	FLDCW 0(AX)
d928|11223344556677885f5f5f5f5f5f	64	gnu	fldcw (%rax)
d928|11223344556677885f5f5f5f5f5f	64	intel	fldcw word ptr [rax]
d928|11223344556677885f5f5f5f5f5f	64	plan9	FLDCW 0(AX)
d930|11223344556677885f5f5f5f5f5f	32	intel	fnstenv ptr [eax]
d930|11223344556677885f5f5f5f5f5f	32	plan9	FNSTENV 0(AX)
d930|11223344556677885f5f5f5f5f5f	64	gnu	fnstenv (%rax)
d930|11223344556677885f5f5f5f5f5f	64	intel	fnstenv ptr [rax]
d930|11223344556677885f5f5f5f5f5f	64	plan9	FNSTENV 0(AX)
d938|11223344556677885f5f5f5f5f5f	32	intel	fnstcw word ptr [eax]
d938|11223344556677885f5f5f5f5f5f	32	plan9	FNSTCW 0(AX)
d938|11223344556677885f5f5f5f5f5f	64	gnu	fnstcw (%rax)
d938|11223344556677885f5f5f5f5f5f	64	intel	fnstcw word ptr [rax]
d938|11223344556677885f5f5f5f5f5f	64	plan9	FNSTCW 0(AX)
d9c0|11223344556677885f5f5f5f5f5f	32	intel	fld st0, st0
d9c0|11223344556677885f5f5f5f5f5f	32	plan9	FLD F0
d9c0|11223344556677885f5f5f5f5f5f	64	gnu	fld %st
d9c0|11223344556677885f5f5f5f5f5f	64	intel	fld st0, st0
d9c0|11223344556677885f5f5f5f5f5f	64	plan9	FLD F0
d9c8|11223344556677885f5f5f5f5f5f	32	intel	fxch st0, st0
d9c8|11223344556677885f5f5f5f5f5f	32	plan9	FXCH F0
d9c8|11223344556677885f5f5f5f5f5f	64	gnu	fxch %st
d9c8|11223344556677885f5f5f5f5f5f	64	intel	fxch st0, st0
d9c8|11223344556677885f5f5f5f5f5f	64	plan9	FXCH F0
d9d0|11223344556677885f5f5f5f5f5f	32	intel	fnop
d9d0|11223344556677885f5f5f5f5f5f	32	plan9	FNOP
d9d0|11223344556677885f5f5f5f5f5f	64	gnu	fnop
d9d0|11223344556677885f5f5f5f5f5f	64	intel	fnop
d9d0|11223344556677885f5f5f5f5f5f	64	plan9	FNOP
d9e0|11223344556677885f5f5f5f5f5f	32	intel	fchs st0
d9e0|11223344556677885f5f5f5f5f5f	32	plan9	FCHS
d9e0|11223344556677885f5f5f5f5f5f	64	gnu	fchs
d9e0|11223344556677885f5f5f5f5f5f	64	intel	fchs st0
d9e0|11223344556677885f5f5f5f5f5f	64	plan9	FCHS
d9e1|11223344556677885f5f5f5f5f5f	32	intel	fabs st0
d9e1|11223344556677885f5f5f5f5f5f	32	plan9	FABS
d9e1|11223344556677885f5f5f5f5f5f	64	gnu	fabs
d9e1|11223344556677885f5f5f5f5f5f	64	intel	fabs st0
d9e1|11223344556677885f5f5f5f5f5f	64	plan9	FABS
d9e4|11223344556677885f5f5f5f5f5f	32	intel	ftst st0
d9e4|11223344556677885f5f5f5f5f5f	32	plan9	FTST
d9e4|11223344556677885f5f5f5f5f5f	64	gnu	ftst
d9e4|11223344556677885f5f5f5f5f5f	64	intel	ftst st0
d9e4|11223344556677885f5f5f5f5f5f	64	plan9	FTST
d9e5|11223344556677885f5f5f5f5f5f	32	intel	fxam st0
d9e5|11223344556677885f5f5f5f5f5f	32	plan9	FXAM
d9e5|11223344556677885f5f5f5f5f5f	64	gnu	fxam
d9e5|11223344556677885f5f5f5f5f5f	64	intel	fxam st0
d9e5|11223344556677885f5f5f5f5f5f	64	plan9	FXAM
d9e8|11223344556677885f5f5f5f5f5f	32	intel	fld1 st0
d9e8|11223344556677885f5f5f5f5f5f	32	plan9	FLD1
d9e8|11223344556677885f5f5f5f5f5f	64	gnu	fld1
d9e8|11223344556677885f5f5f5f5f5f	64	intel	fld1 st0
d9e8|11223344556677885f5f5f5f5f5f	64	plan9	FLD1
d9e9|11223344556677885f5f5f5f5f5f	32	intel	fldl2t st0
d9e9|11223344556677885f5f5f5f5f5f	32	plan9	FLDL2T
d9e9|11223344556677885f5f5f5f5f5f	64	gnu	fldl2t
d9e9|11223344556677885f5f5f5f5f5f	64	intel	fldl2t st0
d9e9|11223344556677885f5f5f5f5f5f	64	plan9	FLDL2T
d9ea|11223344556677885f5f5f5f5f5f	32	intel	fldl2e st0
d9ea|11223344556677885f5f5f5f5f5f	32	plan9	FLDL2E
d9ea|11223344556677885f5f5f5f5f5f	64	gnu	fldl2e
d9ea|11223344556677885f5f5f5f5f5f	64	intel	fldl2e st0
d9ea|11223344556677885f5f5f5f5f5f	64	plan9	FLDL2E
d9eb|11223344556677885f5f5f5f5f5f	32	intel	fldpi st0
d9eb|11223344556677885f5f5f5f5f5f	32	plan9	FLDPI
d9eb|11223344556677885f5f5f5f5f5f	64	gnu	fldpi
d9eb|11223344556677885f5f5f5f5f5f	64	intel	fldpi st0
d9eb|11223344556677885f5f5f5f5f5f	64	plan9	FLDPI
d9ec|11223344556677885f5f5f5f5f5f	32	intel	fldlg2 st0
d9ec|11223344556677885f5f5f5f5f5f	32	plan9	FLDLG2
d9ec|11223344556677885f5f5f5f5f5f	64	gnu	fldlg2
d9ec|11223344556677885f5f5f5f5f5f	64	intel	fldlg2 st0
d9ec|11223344556677885f5f5f5f5f5f	64	plan9	FLDLG2
d9f0|11223344556677885f5f5f5f5f5f	32	intel	f2xm1 st0
d9f0|11223344556677885f5f5f5f5f5f	32	plan9	F2XM1
d9f0|11223344556677885f5f5f5f5f5f	64	gnu	f2xm1
d9f0|11223344556677885f5f5f5f5f5f	64	intel	f2xm1 st0
d9f0|11223344556677885f5f5f5f5f5f	64	plan9	F2XM1
d9f1|11223344556677885f5f5f5f5f5f	32	intel	fyl2x st0, st1
d9f1|11223344556677885f5f5f5f5f5f	32	plan9	FYL2X
d9f1|11223344556677885f5f5f5f5f5f	64	gnu	fyl2x
d9f1|11223344556677885f5f5f5f5f5f	64	intel	fyl2x st0, st1
d9f1|11223344556677885f5f5f5f5f5f	64	plan9	FYL2X
d9f2|11223344556677885f5f5f5f5f5f	32	intel	fptan st0, st1
d9f2|11223344556677885f5f5f5f5f5f	32	plan9	FPTAN
d9f2|11223344556677885f5f5f5f5f5f	64	gnu	fptan
d9f2|11223344556677885f5f5f5f5f5f	64	intel	fptan st0, st1
d9f2|11223344556677885f5f5f5f5f5f	64	plan9	FPTAN
d9f3|11223344556677885f5f5f5f5f5f	32	intel	fpatan st0, st1
d9f3|11223344556677885f5f5f5f5f5f	32	plan9	FPATAN
d9f3|11223344556677885f5f5f5f5f5f	64	gnu	fpatan
d9f3|11223344556677885f5f5f5f5f5f	64	intel	fpatan st0, st1
d9f3|11223344556677885f5f5f5f5f5f	64	plan9	FPATAN
d9f4|11223344556677885f5f5f5f5f5f	32	intel	fxtract st0, st1
d9f4|11223344556677885f5f5f5f5f5f	32	plan9	FXTRACT
d9f4|11223344556677885f5f5f5f5f5f	64	gnu	fxtract
d9f4|11223344556677885f5f5f5f5f5f	64	intel	fxtract st0, st1
d9f4|11223344556677885f5f5f5f5f5f	64	plan9	FXTRACT
d9f5|11223344556677885f5f5f5f5f5f	32	intel	fprem1 st0, st1
d9f5|11223344556677885f5f5f5f5f5f	32	plan9	FPREM1
d9f5|11223344556677885f5f5f5f5f5f	64	gnu	fprem1
d9f5|11223344556677885f5f5f5f5f5f	64	intel	fprem1 st0, st1
d9f5|11223344556677885f5f5f5f5f5f	64	plan9	FPREM1
d9f6|11223344556677885f5f5f5f5f5f	32	intel	fdecstp
d9f6|11223344556677885f5f5f5f5f5f	32	plan9	FDECSTP
d9f6|11223344556677885f5f5f5f5f5f	64	gnu	fdecstp
d9f6|11223344556677885f5f5f5f5f5f	64	intel	fdecstp
d9f6|11223344556677885f5f5f5f5f5f	64	plan9	FDECSTP
d9f7|11223344556677885f5f5f5f5f5f	32	intel	fincstp
d9f7|11223344556677885f5f5f5f5f5f	32	plan9	FINCSTP
d9f7|11223344556677885f5f5f5f5f5f	64	gnu	fincstp
d9f7|11223344556677885f5f5f5f5f5f	64	intel	fincstp
d9f7|11223344556677885f5f5f5f5f5f	64	plan9	FINCSTP
d9f8|11223344556677885f5f5f5f5f5f	32	intel	fprem st0, st1
d9f8|11223344556677885f5f5f5f5f5f	32	plan9	FPREM
d9f8|11223344556677885f5f5f5f5f5f	64	gnu	fprem
d9f8|11223344556677885f5f5f5f5f5f	64	intel	fprem st0, st1
d9f8|11223344556677885f5f5f5f5f5f	64	plan9	FPREM
d9f9|11223344556677885f5f5f5f5f5f	32	intel	fyl2xp1 st0, st1
d9f9|11223344556677885f5f5f5f5f5f	32	plan9	FYL2XP1
d9f9|11223344556677885f5f5f5f5f5f	64	gnu	fyl2xp1
d9f9|11223344556677885f5f5f5f5f5f	64	intel	fyl2xp1 st0, st1
d9f9|11223344556677885f5f5f5f5f5f	64	plan9	FYL2XP1
d9fa|11223344556677885f5f5f5f5f5f	32	intel	fsqrt st0
d9fa|11223344556677885f5f5f5f5f5f	32	plan9	FSQRT
d9fa|11223344556677885f5f5f5f5f5f	64	gnu	fsqrt
d9fa|11223344556677885f5f5f5f5f5f	64	intel	fsqrt st0
d9fa|11223344556677885f5f5f5f5f5f	64	plan9	FSQRT
d9fb|11223344556677885f5f5f5f5f5f	32	intel	fsincos st0, st1
d9fb|11223344556677885f5f5f5f5f5f	32	plan9	FSINCOS
d9fb|11223344556677885f5f5f5f5f5f	64	gnu	fsincos
d9fb|11223344556677885f5f5f5f5f5f	64	intel	fsincos st0, st1
d9fb|11223344556677885f5f5f5f5f5f	64	plan9	FSINCOS
d9fc|11223344556677885f5f5f5f5f5f	32	intel	frndint st0
d9fc|11223344556677885f5f5f5f5f5f	32	plan9	FRNDINT
d9fc|11223344556677885f5f5f5f5f5f	64	gnu	frndint
d9fc|11223344556677885f5f5f5f5f5f	64	intel	frndint st0
d9fc|11223344556677885f5f5f5f5f5f	64	plan9	FRNDINT
d9fd|11223344556677885f5f5f5f5f5f	32	intel	fscale st0, st1
d9fd|11223344556677885f5f5f5f5f5f	32	plan9	FSCALE
d9fd|11223344556677885f5f5f5f5f5f	64	gnu	fscale
d9fd|11223344556677885f5f5f5f5f5f	64	intel	fscale st0, st1
d9fd|11223344556677885f5f5f5f5f5f	64	plan9	FSCALE
d9fe|11223344556677885f5f5f5f5f5f	32	intel	fsin st0
d9fe|11223344556677885f5f5f5f5f5f	32	plan9	FSIN
d9fe|11223344556677885f5f5f5f5f5f	64	gnu	fsin
d9fe|11223344556677885f5f5f5f5f5f	64	intel	fsin st0
d9fe|11223344556677885f5f5f5f5f5f	64	plan9	FSIN
d9ff|11223344556677885f5f5f5f5f5f	32	intel	fcos st0
d9ff|11223344556677885f5f5f5f5f5f	32	plan9	FCOS
d9ff|11223344556677885f5f5f5f5f5f	64	gnu	fcos
d9ff|11223344556677885f5f5f5f5f5f	64	intel	fcos st0
d9ff|11223344556677885f5f5f5f5f5f	64	plan9	FCOS
da00|11223344556677885f5f5f5f5f5f	32	intel	fiadd st0, dword ptr [eax]
da00|11223344556677885f5f5f5f5f5f	32	plan9	FIADD 0(AX)
da00|11223344556677885f5f5f5f5f5f	64	gnu	fiaddl (%rax)
da00|11223344556677885f5f5f5f5f5f	64	intel	fiadd st0, dword ptr [rax]
da00|11223344556677885f5f5f5f5f5f	64	plan9	FIADD 0(AX)
da08|11223344556677885f5f5f5f5f5f	32	intel	fimul st0, dword ptr [eax]
da08|11223344556677885f5f5f5f5f5f	32	plan9	FIMUL 0(AX)
da08|11223344556677885f5f5f5f5f5f	64	gnu	fimull (%rax)
da08|11223344556677885f5f5f5f5f5f	64	intel	fimul st0, dword ptr [rax]
da08|11223344556677885f5f5f5f5f5f	64	plan9	FIMUL 0(AX)
da11|223344556677885f5f5f5f5f5f5f	32	intel	ficom st0, dword ptr [ecx]
da11|223344556677885f5f5f5f5f5f5f	32	plan9	FICOM 0(CX)
da11|223344556677885f5f5f5f5f5f5f	64	gnu	ficoml (%rcx)
da11|223344556677885f5f5f5f5f5f5f	64	intel	ficom st0, dword ptr [rcx]
da11|223344556677885f5f5f5f5f5f5f	64	plan9	FICOM 0(CX)
da18|11223344556677885f5f5f5f5f5f	32	intel	ficomp st0, dword ptr [eax]
da18|11223344556677885f5f5f5f5f5f	32	plan9	FICOMP 0(AX)
da18|11223344556677885f5f5f5f5f5f	64	gnu	ficompl (%rax)
da18|11223344556677885f5f5f5f5f5f	64	intel	ficomp st0, dword ptr [rax]
da18|11223344556677885f5f5f5f5f5f	64	plan9	FICOMP 0(AX)
da20|11223344556677885f5f5f5f5f5f	32	intel	fisub st0, dword ptr [eax]
da20|11223344556677885f5f5f5f5f5f	32	plan9	FISUB 0(AX)
da20|11223344556677885f5f5f5f5f5f	64	gnu	fisubl (%rax)
da20|11223344556677885f5f5f5f5f5f	64	intel	fisub st0, dword ptr [rax]
da20|11223344556677885f5f5f5f5f5f	64	plan9	FISUB 0(AX)
da28|11223344556677885f5f5f5f5f5f	32	intel	fisubr st0, dword ptr [eax]
da28|11223344556677885f5f5f5f5f5f	32	plan9	FISUBR 0(AX)
da28|11223344556677885f5f5f5f5f5f	64	gnu	fisubrl (%rax)
da28|11223344556677885f5f5f5f5f5f	64	intel	fisubr st0, dword ptr [rax]
da28|11223344556677885f5f5f5f5f5f	64	plan9	FISUBR 0(AX)
da30|11223344556677885f5f5f5f5f5f	32	intel	fidiv st0, dword ptr [eax]
da30|11223344556677885f5f5f5f5f5f	32	plan9	FIDIV 0(AX)
da30|11223344556677885f5f5f5f5f5f	64	gnu	fidivl (%rax)
da30|11223344556677885f5f5f5f5f5f	64	intel	fidiv st0, dword ptr [rax]
da30|11223344556677885f5f5f5f5f5f	64	plan9	FIDIV 0(AX)
da38|11223344556677885f5f5f5f5f5f	32	intel	fidivr st0, dword ptr [eax]
da38|11223344556677885f5f5f5f5f5f	32	plan9	FIDIVR 0(AX)
da38|11223344556677885f5f5f5f5f5f	64	gnu	fidivrl (%rax)
da38|11223344556677885f5f5f5f5f5f	64	intel	fidivr st0, dword ptr [rax]
da38|11223344556677885f5f5f5f5f5f	64	plan9	FIDIVR 0(AX)
dac0|11223344556677885f5f5f5f5f5f	32	intel	fcmovb st0, st0
dac0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVB F0, F0
dac0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovb %st,%st
dac0|11223344556677885f5f5f5f5f5f	64	intel	fcmovb st0, st0
dac0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVB F0, F0
dac8|11223344556677885f5f5f5f5f5f	32	intel	fcmove st0, st0
dac8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVE F0, F0
dac8|11223344556677885f5f5f5f5f5f	64	gnu	fcmove %st,%st
dac8|11223344556677885f5f5f5f5f5f	64	intel	fcmove st0, st0
dac8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVE F0, F0
dad0|11223344556677885f5f5f5f5f5f	32	intel	fcmovbe st0, st0
dad0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVBE F0, F0
dad0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovbe %st,%st
dad0|11223344556677885f5f5f5f5f5f	64	intel	fcmovbe st0, st0
dad0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVBE F0, F0
dad8|11223344556677885f5f5f5f5f5f	32	intel	fcmovu st0, st0
dad8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVU F0, F0
dad8|11223344556677885f5f5f5f5f5f	64	gnu	fcmovu %st,%st
dad8|11223344556677885f5f5f5f5f5f	64	intel	fcmovu st0, st0
dad8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVU F0, F0
dae9|11223344556677885f5f5f5f5f5f	32	intel	fucompp st0, st1
dae9|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMPP
dae9|11223344556677885f5f5f5f5f5f	64	gnu	fucompp
dae9|11223344556677885f5f5f5f5f5f	64	intel	fucompp st0, st1
dae9|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMPP
db00|11223344556677885f5f5f5f5f5f	32	intel	fild st0, dword ptr [eax]
db00|11223344556677885f5f5f5f5f5f	32	plan9	FILD 0(AX)
db00|11223344556677885f5f5f5f5f5f	64	gnu	fildl (%rax)
db00|11223344556677885f5f5f5f5f5f	64	intel	fild st0, dword ptr [rax]
db00|11223344556677885f5f5f5f5f5f	64	plan9	FILD 0(AX)
db08|11223344556677885f5f5f5f5f5f	32	intel	fisttp dword ptr [eax], st0
db08|11223344556677885f5f5f5f5f5f	32	plan9	FISTTP 0(AX)
db08|11223344556677885f5f5f5f5f5f	64	gnu	fisttpl (%rax)
db08|11223344556677885f5f5f5f5f5f	64	intel	fisttp dword ptr [rax], st0
db08|11223344556677885f5f5f5f5f5f	64	plan9	FISTTP 0(AX)
db11|223344556677885f5f5f5f5f5f5f	32	intel	fist dword ptr [ecx], st0
db11|223344556677885f5f5f5f5f5f5f	32	plan9	FIST 0(CX)
db11|223344556677885f5f5f5f5f5f5f	64	gnu	fistl (%rcx)
db11|223344556677885f5f5f5f5f5f5f	64	intel	fist dword ptr [rcx], st0
db11|223344556677885f5f5f5f5f5f5f	64	plan9	FIST 0(CX)
db18|11223344556677885f5f5f5f5f5f	32	intel	fistp dword ptr [eax], st0
db18|11223344556677885f5f5f5f5f5f	32	plan9	FISTP 0(AX)
db18|11223344556677885f5f5f5f5f5f	64	gnu	fistpl (%rax)
db18|11223344556677885f5f5f5f5f5f	64	intel	fistp dword ptr [rax], st0
db18|11223344556677885f5f5f5f5f5f	64	plan9	FISTP 0(AX)
db28|11223344556677885f5f5f5f5f5f	32	intel	fld st0, ptr [eax]
db28|11223344556677885f5f5f5f5f5f	32	plan9	FLD 0(AX)
db28|11223344556677885f5f5f5f5f5f	64	gnu	fldt (%rax)
db28|11223344556677885f5f5f5f5f5f	64	intel	fld st0, ptr [rax]
db28|11223344556677885f5f5f5f5f5f	64	plan9	FLD 0(AX)
db38|11223344556677885f5f5f5f5f5f	32	intel	fstp ptr [eax], st0
db38|11223344556677885f5f5f5f5f5f	32	plan9	FSTP 0(AX)
db38|11223344556677885f5f5f5f5f5f	64	gnu	fstpt (%rax)
db38|11223344556677885f5f5f5f5f5f	64	intel	fstp ptr [rax], st0
db38|11223344556677885f5f5f5f5f5f	64	plan9	FSTP 0(AX)
dbc0|11223344556677885f5f5f5f5f5f	32	intel	fcmovnb st0, st0
dbc0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNB F0, F0
dbc0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovnb %st,%st
dbc0|11223344556677885f5f5f5f5f5f	64	intel	fcmovnb st0, st0
dbc0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNB F0, F0
dbc8|11223344556677885f5f5f5f5f5f	32	intel	fcmovne st0, st0
dbc8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNE F0, F0
dbc8|11223344556677885f5f5f5f5f5f	64	gnu	fcmovne %st,%st
dbc8|11223344556677885f5f5f5f5f5f	64	intel	fcmovne st0, st0
dbc8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNE F0, F0
dbd0|11223344556677885f5f5f5f5f5f	32	intel	fcmovnbe st0, st0
dbd0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNBE F0, F0
dbd0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovnbe %st,%st
dbd0|11223344556677885f5f5f5f5f5f	64	intel	fcmovnbe st0, st0
dbd0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNBE F0, F0
dbd8|11223344556677885f5f5f5f5f5f	32	intel	fcmovnu st0, st0
dbd8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNU F0, F0
dbd8|11223344556677885f5f5f5f5f5f	64	gnu	fcmovnu %st,%st
dbd8|11223344556677885f5f5f5f5f5f	64	intel	fcmovnu st0, st0
dbd8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNU F0, F0
dbe2|11223344556677885f5f5f5f5f5f	32	intel	fnclex
dbe2|11223344556677885f5f5f5f5f5f	32	plan9	FNCLEX
dbe2|11223344556677885f5f5f5f5f5f	64	gnu	fnclex
dbe2|11223344556677885f5f5f5f5f5f	64	intel	fnclex
dbe2|11223344556677885f5f5f5f5f5f	64	plan9	FNCLEX
dbe3|11223344556677885f5f5f5f5f5f	32	intel	fninit
dbe3|11223344556677885f5f5f5f5f5f	32	plan9	FNINIT
dbe3|11223344556677885f5f5f5f5f5f	64	gnu	fninit
dbe3|11223344556677885f5f5f5f5f5f	64	intel	fninit
dbe3|11223344556677885f5f5f5f5f5f	64	plan9	FNINIT
dbe8|11223344556677885f5f5f5f5f5f	32	intel	fucomi st0, st0
dbe8|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMI F0, F0
dbe8|11223344556677885f5f5f5f5f5f	64	gnu	fucomi %st,%st
dbe8|11223344556677885f5f5f5f5f5f	64	intel	fucomi st0, st0
dbe8|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMI F0, F0
dbf0|11223344556677885f5f5f5f5f5f	32	intel	fcomi st0, st0
dbf0|11223344556677885f5f5f5f5f5f	32	plan9	FCOMI F0, F0
dbf0|11223344556677885f5f5f5f5f5f	64	gnu	fcomi %st,%st
dbf0|11223344556677885f5f5f5f5f5f	64	intel	fcomi st0, st0
dbf0|11223344556677885f5f5f5f5f5f	64	plan9	FCOMI F0, F0
dc00|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, qword ptr [eax]
dc00|11223344556677885f5f5f5f5f5f	32	plan9	FADD 0(AX)
dc00|11223344556677885f5f5f5f5f5f	64	gnu	faddl (%rax)
dc00|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, qword ptr [rax]
dc00|11223344556677885f5f5f5f5f5f	64	plan9	FADD 0(AX)
dc08|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, qword ptr [eax]
dc08|11223344556677885f5f5f5f5f5f	32	plan9	FMUL 0(AX)
dc08|11223344556677885f5f5f5f5f5f	64	gnu	fmull (%rax)
dc08|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, qword ptr [rax]
dc08|11223344556677885f5f5f5f5f5f	64	plan9	FMUL 0(AX)
dc11|223344556677885f5f5f5f5f5f5f	32	intel	fcom st0, qword ptr [ecx]
dc11|223344556677885f5f5f5f5f5f5f	32	plan9	FCOM 0(CX)
dc11|223344556677885f5f5f5f5f5f5f	64	gnu	fcoml (%rcx)
dc11|223344556677885f5f5f5f5f5f5f	64	intel	fcom st0, qword ptr [rcx]
dc11|223344556677885f5f5f5f5f5f5f	64	plan9	FCOM 0(CX)
dc18|11223344556677885f5f5f5f5f5f	32	intel	fcomp st0, qword ptr [eax]
dc18|11223344556677885f5f5f5f5f5f	32	plan9	FCOMP 0(AX)
dc18|11223344556677885f5f5f5f5f5f	64	gnu	fcompl (%rax)
dc18|11223344556677885f5f5f5f5f5f	64	intel	fcomp st0, qword ptr [rax]
dc18|11223344556677885f5f5f5f5f5f	64	plan9	FCOMP 0(AX)
dc20|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, qword ptr [eax]
dc20|11223344556677885f5f5f5f5f5f	32	plan9	FSUB 0(AX)
dc20|11223344556677885f5f5f5f5f5f	64	gnu	fsubl (%rax)
dc20|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, qword ptr [rax]
dc20|11223344556677885f5f5f5f5f5f	64	plan9	FSUB 0(AX)
dc28|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, qword ptr [eax]
dc28|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR 0(AX)
dc28|11223344556677885f5f5f5f5f5f	64	gnu	fsubrl (%rax)
dc28|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, qword ptr [rax]
dc28|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR 0(AX)
dc30|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, qword ptr [eax]
dc30|11223344556677885f5f5f5f5f5f	32	plan9	FDIV 0(AX)
dc30|11223344556677885f5f5f5f5f5f	64	gnu	fdivl (%rax)
dc30|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, qword ptr [rax]
dc30|11223344556677885f5f5f5f5f5f	64	plan9	FDIV 0(AX)
dc38|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, qword ptr [eax]
dc38|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR 0(AX)
dc38|11223344556677885f5f5f5f5f5f	64	gnu	fdivrl (%rax)
dc38|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, qword ptr [rax]
dc38|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR 0(AX)
dcc0|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, st0
dcc0|11223344556677885f5f5f5f5f5f	32	plan9	FADD F0, F0
dcc0|11223344556677885f5f5f5f5f5f	64	gnu	fadd %st,%st
dcc0|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, st0
dcc0|11223344556677885f5f5f5f5f5f	64	plan9	FADD F0, F0
dcc8|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, st0
dcc8|11223344556677885f5f5f5f5f5f	32	plan9	FMUL F0, F0
dcc8|11223344556677885f5f5f5f5f5f	64	gnu	fmul %st,%st
dcc8|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, st0
dcc8|11223344556677885f5f5f5f5f5f	64	plan9	FMUL F0, F0
dce0|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, st0
dce0|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR F0, F0
dce0|11223344556677885f5f5f5f5f5f	64	gnu	fsub %st,%st
dce0|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, st0
dce0|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR F0, F0
dce8|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, st0
dce8|11223344556677885f5f5f5f5f5f	32	plan9	FSUB F0, F0
dce8|11223344556677885f5f5f5f5f5f	64	gnu	fsubr %st,%st
dce8|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, st0
dce8|11223344556677885f5f5f5f5f5f	64	plan9	FSUB F0, F0
dcf0|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, st0
dcf0|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR F0, F0
dcf0|11223344556677885f5f5f5f5f5f	64	gnu	fdiv %st,%st
dcf0|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, st0
dcf0|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR F0, F0
dcf8|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, st0
dcf8|11223344556677885f5f5f5f5f5f	32	plan9	FDIV F0, F0
dcf8|11223344556677885f5f5f5f5f5f	64	gnu	fdivr %st,%st
dcf8|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, st0
dcf8|11223344556677885f5f5f5f5f5f	64	plan9	FDIV F0, F0
dd00|11223344556677885f5f5f5f5f5f	32	intel	fld st0, qword ptr [eax]
dd00|11223344556677885f5f5f5f5f5f	32	plan9	FLD 0(AX)
dd00|11223344556677885f5f5f5f5f5f	64	gnu	fldl (%rax)
dd00|11223344556677885f5f5f5f5f5f	64	intel	fld st0, qword ptr [rax]
dd00|11223344556677885f5f5f5f5f5f	64	plan9	FLD 0(AX)
dd08|11223344556677885f5f5f5f5f5f	32	intel	fisttp qword ptr [eax], st0
dd08|11223344556677885f5f5f5f5f5f	32	plan9	FISTTP 0(AX)
dd08|11223344556677885f5f5f5f5f5f	64	gnu	fisttpll (%rax)
dd08|11223344556677885f5f5f5f5f5f	64	intel	fisttp qword ptr [rax], st0
dd08|11223344556677885f5f5f5f5f5f	64	plan9	FISTTP 0(AX)
dd11|223344556677885f5f5f5f5f5f5f	32	intel	fst qword ptr [ecx], st0
dd11|223344556677885f5f5f5f5f5f5f	32	plan9	FST 0(CX)
dd11|223344556677885f5f5f5f5f5f5f	64	gnu	fstl (%rcx)
dd11|223344556677885f5f5f5f5f5f5f	64	intel	fst qword ptr [rcx], st0
dd11|223344556677885f5f5f5f5f5f5f	64	plan9	FST 0(CX)
dd18|11223344556677885f5f5f5f5f5f	32	intel	fstp qword ptr [eax], st0
dd18|11223344556677885f5f5f5f5f5f	32	plan9	FSTP 0(AX)
dd18|11223344556677885f5f5f5f5f5f	64	gnu	fstpl (%rax)
dd18|11223344556677885f5f5f5f5f5f	64	intel	fstp qword ptr [rax], st0
dd18|11223344556677885f5f5f5f5f5f	64	plan9	FSTP 0(AX)
dd20|11223344556677885f5f5f5f5f5f	32	intel	frstor ptr [eax]
dd20|11223344556677885f5f5f5f5f5f	32	plan9	FRSTORL 0(AX)
dd20|11223344556677885f5f5f5f5f5f	64	gnu	frstor (%rax)
dd20|11223344556677885f5f5f5f5f5f	64	intel	frstor ptr [rax]
dd20|11223344556677885f5f5f5f5f5f	64	plan9	FRSTORL 0(AX)
dd30|11223344556677885f5f5f5f5f5f	32	intel	fnsave ptr [eax]
dd30|11223344556677885f5f5f5f5f5f	32	plan9	FNSAVE 0(AX)
dd30|11223344556677885f5f5f5f5f5f	64	gnu	fnsave (%rax)
dd30|11223344556677885f5f5f5f5f5f	64	intel	fnsave ptr [rax]
dd30|11223344556677885f5f5f5f5f5f	64	plan9	FNSAVE 0(AX)
dd38|11223344556677885f5f5f5f5f5f	32	intel	fnstsw word ptr [eax]
dd38|11223344556677885f5f5f5f5f5f	32	plan9	FNSTSW 0(AX)
dd38|11223344556677885f5f5f5f5f5f	64	gnu	fnstsw (%rax)
dd38|11223344556677885f5f5f5f5f5f	64	intel	fnstsw word ptr [rax]
dd38|11223344556677885f5f5f5f5f5f	64	plan9	FNSTSW 0(AX)
ddc0|11223344556677885f5f5f5f5f5f	32	intel	ffree st0
ddc0|11223344556677885f5f5f5f5f5f	32	plan9	FFREE F0
ddc0|11223344556677885f5f5f5f5f5f	64	gnu	ffree %st
ddc0|11223344556677885f5f5f5f5f5f	64	intel	ffree st0
ddc0|11223344556677885f5f5f5f5f5f	64	plan9	FFREE F0
ddd0|11223344556677885f5f5f5f5f5f	32	intel	fst st0, st0
ddd0|11223344556677885f5f5f5f5f5f	32	plan9	FST F0
ddd0|11223344556677885f5f5f5f5f5f	64	gnu	fst %st
ddd0|11223344556677885f5f5f5f5f5f	64	intel	fst st0, st0
ddd0|11223344556677885f5f5f5f5f5f	64	plan9	FST F0
ddd8|11223344556677885f5f5f5f5f5f	32	intel	fstp st0, st0
ddd8|11223344556677885f5f5f5f5f5f	32	plan9	FSTP F0
ddd8|11223344556677885f5f5f5f5f5f	64	gnu	fstp %st
ddd8|11223344556677885f5f5f5f5f5f	64	intel	fstp st0, st0
ddd8|11223344556677885f5f5f5f5f5f	64	plan9	FSTP F0
dde0|11223344556677885f5f5f5f5f5f	32	intel	fucom st0, st0
dde0|11223344556677885f5f5f5f5f5f	32	plan9	FUCOM F0
dde0|11223344556677885f5f5f5f5f5f	64	gnu	fucom %st
dde0|11223344556677885f5f5f5f5f5f	64	intel	fucom st0, st0
dde0|11223344556677885f5f5f5f5f5f	64	plan9	FUCOM F0
dde8|11223344556677885f5f5f5f5f5f	32	intel	fucomp st0, st0
dde8|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMP F0
dde8|11223344556677885f5f5f5f5f5f	64	gnu	fucomp %st
dde8|11223344556677885f5f5f5f5f5f	64	intel	fucomp st0, st0
dde8|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMP F0
de00|11223344556677885f5f5f5f5f5f	32	intel	fiadd st0, word ptr [eax]
de00|11223344556677885f5f5f5f5f5f	32	plan9	FIADD 0(AX)
de00|11223344556677885f5f5f5f5f5f	64	gnu	fiadd (%rax)
de00|11223344556677885f5f5f5f5f5f	64	intel	fiadd st0, word ptr [rax]
de00|11223344556677885f5f5f5f5f5f	64	plan9	FIADD 0(AX)
de08|11223344556677885f5f5f5f5f5f	32	intel	fimul st0, word ptr [eax]
de08|11223344556677885f5f5f5f5f5f	32	plan9	FIMUL 0(AX)
de08|11223344556677885f5f5f5f5f5f	64	gnu	fimul (%rax)
de08|11223344556677885f5f5f5f5f5f	64	intel	fimul st0, word ptr [rax]
de08|11223344556677885f5f5f5f5f5f	64	plan9	FIMUL 0(AX)
de11|223344556677885f5f5f5f5f5f5f	32	intel	ficom st0, word ptr [ecx]
de11|223344556677885f5f5f5f5f5f5f	32	plan9	FICOM 0(CX)
de11|223344556677885f5f5f5f5f5f5f	64	gnu	ficom (%rcx)
de11|223344556677885f5f5f5f5f5f5f	64	intel	ficom st0, word ptr [rcx]
de11|223344556677885f5f5f5f5f5f5f	64	plan9	FICOM 0(CX)
de18|11223344556677885f5f5f5f5f5f	32	intel	ficomp st0, word ptr [eax]
de18|11223344556677885f5f5f5f5f5f	32	plan9	FICOMP 0(AX)
de18|11223344556677885f5f5f5f5f5f	64	gnu	ficomp (%rax)
de18|11223344556677885f5f5f5f5f5f	64	intel	ficomp st0, word ptr [rax]
de18|11223344556677885f5f5f5f5f5f	64	plan9	FICOMP 0(AX)
de20|11223344556677885f5f5f5f5f5f	32	intel	fisub st0, word ptr [eax]
de20|11223344556677885f5f5f5f5f5f	32	plan9	FISUB 0(AX)
de20|11223344556677885f5f5f5f5f5f	64	gnu	fisub (%rax)
de20|11223344556677885f5f5f5f5f5f	64	intel	fisub st0, word ptr [rax]
de20|11223344556677885f5f5f5f5f5f	64	plan9	FISUB 0(AX)
de28|11223344556677885f5f5f5f5f5f	32	intel	fisubr st0, word ptr [eax]
de28|11223344556677885f5f5f5f5f5f	32	plan9	FISUBR 0(AX)
de28|11223344556677885f5f5f5f5f5f	64	gnu	fisubr (%rax)
de28|11223344556677885f5f5f5f5f5f	64	intel	fisubr st0, word ptr [rax]
de28|11223344556677885f5f5f5f5f5f	64	plan9	FISUBR 0(AX)
de30|11223344556677885f5f5f5f5f5f	32	intel	fidiv st0, word ptr [eax]
de30|11223344556677885f5f5f5f5f5f	32	plan9	FIDIV 0(AX)
de30|11223344556677885f5f5f5f5f5f	64	gnu	fidiv (%rax)
de30|11223344556677885f5f5f5f5f5f	64	intel	fidiv st0, word ptr [rax]
de30|11223344556677885f5f5f5f5f5f	64	plan9	FIDIV 0(AX)
de38|11223344556677885f5f5f5f5f5f	32	intel	fidivr st0, word ptr [eax]
de38|11223344556677885f5f5f5f5f5f	32	plan9	FIDIVR 0(AX)
de38|11223344556677885f5f5f5f5f5f	64	gnu	fidivr (%rax)
de38|11223344556677885f5f5f5f5f5f	64	intel	fidivr st0, word ptr [rax]
de38|11223344556677885f5f5f5f5f5f	64	plan9	FIDIVR 0(AX)
dec0|11223344556677885f5f5f5f5f5f	32	intel	faddp st0, st0
dec0|11223344556677885f5f5f5f5f5f	32	plan9	FADDP F0, F0
dec0|11223344556677885f5f5f5f5f5f	64	gnu	faddp %st,%st
dec0|11223344556677885f5f5f5f5f5f	64	intel	faddp st0, st0
dec0|11223344556677885f5f5f5f5f5f	64	plan9	FADDP F0, F0
dec8|11223344556677885f5f5f5f5f5f	32	intel	fmulp st0, st0
dec8|11223344556677885f5f5f5f5f5f	32	plan9	FMULP F0, F0
dec8|11223344556677885f5f5f5f5f5f	64	gnu	fmulp %st,%st
dec8|11223344556677885f5f5f5f5f5f	64	intel	fmulp st0, st0
dec8|11223344556677885f5f5f5f5f5f	64	plan9	FMULP F0, F0
ded9|11223344556677885f5f5f5f5f5f	32	intel	fcompp st0, st1
ded9|11223344556677885f5f5f5f5f5f	32	plan9	FCOMPP
ded9|11223344556677885f5f5f5f5f5f	64	gnu	fcompp
ded9|11223344556677885f5f5f5f5f5f	64	intel	fcompp st0, st1
ded9|11223344556677885f5f5f5f5f5f	64	plan9	FCOMPP
dee0|11223344556677885f5f5f5f5f5f	32	intel	fsubrp st0, st0
dee0|11223344556677885f5f5f5f5f5f	32	plan9	FSUBRP F0, F0
dee0|11223344556677885f5f5f5f5f5f	64	gnu	fsubp %st,%st
dee0|11223344556677885f5f5f5f5f5f	64	intel	fsubrp st0, st0
dee0|11223344556677885f5f5f5f5f5f	64	plan9	FSUBRP F0, F0
dee8|11223344556677885f5f5f5f5f5f	32	intel	fsubp st0, st0
dee8|11223344556677885f5f5f5f5f5f	32	plan9	FSUBP F0, F0
dee8|11223344556677885f5f5f5f5f5f	64	gnu	fsubrp %st,%st
dee8|11223344556677885f5f5f5f5f5f	64	intel	fsubp st0, st0
dee8|11223344556677885f5f5f5f5f5f	64	plan9	FSUBP F0, F0
def0|11223344556677885f5f5f5f5f5f	32	intel	fdivrp st0, st0
def0|11223344556677885f5f5f5f5f5f	32	plan9	FDIVRP F0, F0
def0|11223344556677885f5f5f5f5f5f	64	gnu	fdivp %st,%st
def0|11223344556677885f5f5f5f5f5f	64	intel	fdivrp st0, st0
def0|11223344556677885f5f5f5f5f5f	64	plan9	FDIVRP F0, F0
def8|11223344556677885f5f5f5f5f5f	32	intel	fdivp st0, st0
def8|11223344556677885f5f5f5f5f5f	32	plan9	FDIVP F0, F0
def8|11223344556677885f5f5f5f5f5f	64	gnu	fdivrp %st,%st
def8|11223344556677885f5f5f5f5f5f	64	intel	fdivp st0, st0
def8|11223344556677885f5f5f5f5f5f	64	plan9	FDIVP F0, F0
df00|11223344556677885f5f5f5f5f5f	32	intel	fild st0, word ptr [eax]
df00|11223344556677885f5f5f5f5f5f	32	plan9	FILD 0(AX)
df00|11223344556677885f5f5f5f5f5f	64	gnu	fild (%rax)
df00|11223344556677885f5f5f5f5f5f	64	intel	fild st0, word ptr [rax]
df00|11223344556677885f5f5f5f5f5f	64	plan9	FILD 0(AX)
df08|11223344556677885f5f5f5f5f5f	32	intel	fisttp word ptr [eax], st0
df08|11223344556677885f5f5f5f5f5f	32	plan9	FISTTP 0(AX)
df08|11223344556677885f5f5f5f5f5f	64	gnu	fisttp (%rax)
df08|11223344556677885f5f5f5f5f5f	64	intel	fisttp word ptr [rax], st0
df08|11223344556677885f5f5f5f5f5f	64	plan9	FISTTP 0(AX)
df11|223344556677885f5f5f5f5f5f5f	32	intel	fist word ptr [ecx], st0
df11|223344556677885f5f5f5f5f5f5f	32	plan9	FIST 0(CX)
df11|223344556677885f5f5f5f5f5f5f	64	gnu	fist (%rcx)
df11|223344556677885f5f5f5f5f5f5f	64	intel	fist word ptr [rcx], st0
df11|223344556677885f5f5f5f5f5f5f	64	plan9	FIST 0(CX)
df18|11223344556677885f5f5f5f5f5f	32	intel	fistp word ptr [eax], st0
df18|11223344556677885f5f5f5f5f5f	32	plan9	FISTP 0(AX)
df18|11223344556677885f5f5f5f5f5f	64	gnu	fistp (%rax)
df18|11223344556677885f5f5f5f5f5f	64	intel	fistp word ptr [rax], st0
df18|11223344556677885f5f5f5f5f5f	64	plan9	FISTP 0(AX)
df20|11223344556677885f5f5f5f5f5f	32	intel	fbld st0, ptr [eax]
df20|11223344556677885f5f5f5f5f5f	32	plan9	FBLD 0(AX)
df20|11223344556677885f5f5f5f5f5f	64	gnu	fbld (%rax)
df20|11223344556677885f5f5f5f5f5f	64	intel	fbld st0, ptr [rax]
df20|11223344556677885f5f5f5f5f5f	64	plan9	FBLD 0(AX)
df28|11223344556677885f5f5f5f5f5f	32	intel	fild st0, qword ptr [eax]
df28|11223344556677885f5f5f5f5f5f	32	plan9	FILD 0(AX)
df28|11223344556677885f5f5f5f5f5f	64	gnu	fildll (%rax)
df28|11223344556677885f5f5f5f5f5f	64	intel	fild st0, qword ptr [rax]
df28|11223344556677885f5f5f5f5f5f	64	plan9	FILD 0(AX)
df30|11223344556677885f5f5f5f5f5f	32	intel	fbstp ptr [eax], st0
df30|11223344556677885f5f5f5f5f5f	32	plan9	FBSTP 0(AX)
df30|11223344556677885f5f5f5f5f5f	64	gnu	fbstp (%rax)
df30|11223344556677885f5f5f5f5f5f	64	intel	fbstp ptr [rax], st0
df30|11223344556677885f5f5f5f5f5f	64	plan9	FBSTP 0(AX)
df38|11223344556677885f5f5f5f5f5f	32	intel	fistp qword ptr [eax], st0
df38|11223344556677885f5f5f5f5f5f	32	plan9	FISTP 0(AX)
df38|11223344556677885f5f5f5f5f5f	64	gnu	fistpll (%rax)
df38|11223344556677885f5f5f5f5f5f	64	intel	fistp qword ptr [rax], st0
df38|11223344556677885f5f5f5f5f5f	64	plan9	FISTP 0(AX)
dfc0|11223344556677885f5f5f5f5f5f	32	intel	ffreep st0
dfc0|11223344556677885f5f5f5f5f5f	32	plan9	FFREEP F0
dfc0|11223344556677885f5f5f5f5f5f	64	gnu	ffreep %st
dfc0|11223344556677885f5f5f5f5f5f	64	intel	ffreep st0
dfc0|11223344556677885f5f5f5f5f5f	64	plan9	FFREEP F0
dfe0|11223344556677885f5f5f5f5f5f	32	intel	fnstsw ax
dfe0|11223344556677885f5f5f5f5f5f	32	plan9	FNSTSW AX
dfe0|11223344556677885f5f5f5f5f5f	64	gnu	fnstsw %ax
dfe0|11223344556677885f5f5f5f5f5f	64	intel	fnstsw ax
dfe0|11223344556677885f5f5f5f5f5f	64	plan9	FNSTSW AX
dfe8|11223344556677885f5f5f5f5f5f	32	intel	fucomip st0, st0
dfe8|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMIP F0, F0
dfe8|11223344556677885f5f5f5f5f5f	64	gnu	fucomip %st,%st
dfe8|11223344556677885f5f5f5f5f5f	64	intel	fucomip st0, st0
dfe8|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMIP F0, F0
dff0|11223344556677885f5f5f5f5f5f	32	intel	fcomip st0, st0
dff0|11223344556677885f5f5f5f5f5f	32	plan9	FCOMIP F0, F0
dff0|11223344556677885f5f5f5f5f5f	64	gnu	fcomip %st,%st
dff0|11223344556677885f5f5f5f5f5f	64	intel	fcomip st0, st0
dff0|11223344556677885f5f5f5f5f5f	64	plan9	FCOMIP F0, F0
e111|223344556677885f5f5f5f5f5f5f	32	intel	loope .+0x11
e111|223344556677885f5f5f5f5f5f5f	32	plan9	LOOPE .+17
e111|223344556677885f5f5f5f5f5f5f	64	gnu	loope .+0x11
e111|223344556677885f5f5f5f5f5f5f	64	intel	loope .+0x11
e111|223344556677885f5f5f5f5f5f5f	64	plan9	LOOPE .+17
e211|223344556677885f5f5f5f5f5f5f	32	intel	loop .+0x11
e211|223344556677885f5f5f5f5f5f5f	32	plan9	LOOP .+17
e211|223344556677885f5f5f5f5f5f5f	64	gnu	loop .+0x11
e211|223344556677885f5f5f5f5f5f5f	64	intel	loop .+0x11
e211|223344556677885f5f5f5f5f5f5f	64	plan9	LOOP .+17
e311|223344556677885f5f5f5f5f5f5f	32	intel	jecxz .+0x11
e311|223344556677885f5f5f5f5f5f5f	32	plan9	JECXZ .+17
e311|223344556677885f5f5f5f5f5f5f	64	gnu	jrcxz .+0x11
e311|223344556677885f5f5f5f5f5f5f	64	intel	jrcxz .+0x11
e311|223344556677885f5f5f5f5f5f5f	64	plan9	JRCXZ .+17
e411|223344556677885f5f5f5f5f5f5f	32	intel	in al, 0x11
e411|223344556677885f5f5f5f5f5f5f	32	plan9	INL $0x11, AL
e411|223344556677885f5f5f5f5f5f5f	64	gnu	in $0x11,%al
e411|223344556677885f5f5f5f5f5f5f	64	intel	in al, 0x11
e411|223344556677885f5f5f5f5f5f5f	64	plan9	INL $0x11, AL
e511|223344556677885f5f5f5f5f5f5f	32	intel	in eax, 0x11
e511|223344556677885f5f5f5f5f5f5f	32	plan9	INL $0x11, AX
e511|223344556677885f5f5f5f5f5f5f	64	gnu	in $0x11,%eax
e511|223344556677885f5f5f5f5f5f5f	64	intel	in eax, 0x11
e511|223344556677885f5f5f5f5f5f5f	64	plan9	INL $0x11, AX
e611|223344556677885f5f5f5f5f5f5f	32	intel	out 0x11, al
e611|223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AL, $0x11
e611|223344556677885f5f5f5f5f5f5f	64	gnu	out %al,$0x11
e611|223344556677885f5f5f5f5f5f5f	64	intel	out 0x11, al
e611|223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AL, $0x11
e711|223344556677885f5f5f5f5f5f5f	32	intel	out 0x11, eax
e711|223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AX, $0x11
e711|223344556677885f5f5f5f5f5f5f	64	gnu	out %eax,$0x11
e711|223344556677885f5f5f5f5f5f5f	64	intel	out 0x11, eax
e711|223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AX, $0x11
e811223344|556677885f5f5f5f5f5f5f	32	intel	call .+0x44332211
e811223344|556677885f5f5f5f5f5f5f	32	plan9	CALL .+1144201745
e811223344|556677885f5f5f5f5f5f5f	64	gnu	callq .+0x44332211
e811223344|556677885f5f5f5f5f5f5f	64	intel	call .+0x44332211
e811223344|556677885f5f5f5f5f5f5f	64	plan9	CALL .+1144201745
e911223344|556677885f5f5f5f5f5f5f	32	intel	jmp .+0x44332211
e911223344|556677885f5f5f5f5f5f5f	32	plan9	JMP .+1144201745
e911223344|556677885f5f5f5f5f5f5f	64	gnu	jmpq .+0x44332211
e911223344|556677885f5f5f5f5f5f5f	64	intel	jmp .+0x44332211
e911223344|556677885f5f5f5f5f5f5f	64	plan9	JMP .+1144201745
ea112233445566|77885f5f5f5f5f5f5f	32	intel	jmp far 0x44332211, 0x6655
ea112233445566|77885f5f5f5f5f5f5f	32	plan9	LJMP $0x44332211, $0x6655
eb11|223344556677885f5f5f5f5f5f5f	32	intel	jmp .+0x11
eb11|223344556677885f5f5f5f5f5f5f	32	plan9	JMP .+17
eb11|223344556677885f5f5f5f5f5f5f	64	gnu	jmp .+0x11
eb11|223344556677885f5f5f5f5f5f5f	64	intel	jmp .+0x11
eb11|223344556677885f5f5f5f5f5f5f	64	plan9	JMP .+17
ec|11223344556677885f5f5f5f5f5f5f	32	intel	in al, dx
ec|11223344556677885f5f5f5f5f5f5f	32	plan9	INL DX, AL
ec|11223344556677885f5f5f5f5f5f5f	64	gnu	in (%dx),%al
ec|11223344556677885f5f5f5f5f5f5f	64	intel	in al, dx
ec|11223344556677885f5f5f5f5f5f5f	64	plan9	INL DX, AL
ed|11223344556677885f5f5f5f5f5f5f	32	intel	in eax, dx
ed|11223344556677885f5f5f5f5f5f5f	32	plan9	INL DX, AX
ed|11223344556677885f5f5f5f5f5f5f	64	gnu	in (%dx),%eax
ed|11223344556677885f5f5f5f5f5f5f	64	intel	in eax, dx
ed|11223344556677885f5f5f5f5f5f5f	64	plan9	INL DX, AX
ee|11223344556677885f5f5f5f5f5f5f	32	intel	out dx, al
ee|11223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AL, DX
ee|11223344556677885f5f5f5f5f5f5f	64	gnu	out %al,(%dx)
ee|11223344556677885f5f5f5f5f5f5f	64	intel	out dx, al
ee|11223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AL, DX
ef|11223344556677885f5f5f5f5f5f5f	32	intel	out dx, eax
ef|11223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AX, DX
ef|11223344556677885f5f5f5f5f5f5f	64	gnu	out %eax,(%dx)
ef|11223344556677885f5f5f5f5f5f5f	64	intel	out dx, eax
ef|11223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AX, DX
f1|11223344556677885f5f5f5f5f5f5f	32	intel	int1
f1|11223344556677885f5f5f5f5f5f5f	32	plan9	ICEBP
f1|11223344556677885f5f5f5f5f5f5f	64	gnu	icebp
f1|11223344556677885f5f5f5f5f5f5f	64	intel	int1
f1|11223344556677885f5f5f5f5f5f5f	64	plan9	ICEBP
f20f1011|223344556677885f5f5f5f5f	32	intel	movsd xmm2, qword ptr [ecx]
f20f1011|223344556677885f5f5f5f5f	32	plan9	REPNE MOVSD_XMM 0(CX), X2
f20f1011|223344556677885f5f5f5f5f	64	gnu	movsd (%rcx),%xmm2
f20f1011|223344556677885f5f5f5f5f	64	intel	movsd xmm2, qword ptr [rcx]
f20f1011|223344556677885f5f5f5f5f	64	plan9	REPNE MOVSD_XMM 0(CX), X2
f20f1122|3344556677885f5f5f5f5f5f	32	intel	movsd qword ptr [edx], xmm4
f20f1122|3344556677885f5f5f5f5f5f	32	plan9	REPNE MOVSD_XMM X4, 0(DX)
f20f1122|3344556677885f5f5f5f5f5f	64	gnu	movsd %xmm4,(%rdx)
f20f1122|3344556677885f5f5f5f5f5f	64	intel	movsd qword ptr [rdx], xmm4
f20f1122|3344556677885f5f5f5f5f5f	64	plan9	REPNE MOVSD_XMM X4, 0(DX)
f20f1211|223344556677885f5f5f5f5f	32	intel	movddup xmm2, qword ptr [ecx]
f20f1211|223344556677885f5f5f5f5f	32	plan9	REPNE MOVDDUP 0(CX), X2
f20f1211|223344556677885f5f5f5f5f	64	gnu	movddup (%rcx),%xmm2
f20f1211|223344556677885f5f5f5f5f	64	intel	movddup xmm2, qword ptr [rcx]
f20f1211|223344556677885f5f5f5f5f	64	plan9	REPNE MOVDDUP 0(CX), X2
f20f2a11|223344556677885f5f5f5f5f	32	intel	cvtsi2sd xmm2, dword ptr [ecx]
f20f2a11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTSI2SDL 0(CX), X2
f20f2a11|223344556677885f5f5f5f5f	64	gnu	cvtsi2sdl (%rcx),%xmm2
f20f2a11|223344556677885f5f5f5f5f	64	intel	cvtsi2sd xmm2, dword ptr [rcx]
f20f2a11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTSI2SDL 0(CX), X2
f20f2c11|223344556677885f5f5f5f5f	32	intel	cvttsd2si edx, qword ptr [ecx]
f20f2c11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTTSD2SIL 0(CX), DX
f20f2c11|223344556677885f5f5f5f5f	64	gnu	cvttsd2si (%rcx),%edx
f20f2c11|223344556677885f5f5f5f5f	64	intel	cvttsd2si edx, qword ptr [rcx]
f20f2c11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTTSD2SIL 0(CX), DX
f20f2d11|223344556677885f5f5f5f5f	32	intel	cvtsd2si edx, qword ptr [ecx]
f20f2d11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTSD2SIL 0(CX), DX
f20f2d11|223344556677885f5f5f5f5f	64	gnu	cvtsd2si (%rcx),%edx
f20f2d11|223344556677885f5f5f5f5f	64	intel	cvtsd2si edx, qword ptr [rcx]
f20f2d11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTSD2SIL 0(CX), DX
f20f38f011|223344556677885f5f5f5f	32	intel	crc32 edx, byte ptr [ecx]
f20f38f011|223344556677885f5f5f5f	32	plan9	REPNE CRC32 0(CX), DX
f20f38f011|223344556677885f5f5f5f	64	gnu	crc32b (%rcx),%edx
f20f38f011|223344556677885f5f5f5f	64	intel	crc32 edx, byte ptr [rcx]
f20f38f011|223344556677885f5f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f20f38f111|223344556677885f5f5f5f	32	intel	crc32 edx, dword ptr [ecx]
f20f38f111|223344556677885f5f5f5f	32	plan9	REPNE CRC32 0(CX), DX
f20f38f111|223344556677885f5f5f5f	64	gnu	crc32l (%rcx),%edx
f20f38f111|223344556677885f5f5f5f	64	intel	crc32 edx, dword ptr [rcx]
f20f38f111|223344556677885f5f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f20f5111|223344556677885f5f5f5f5f	32	intel	sqrtsd xmm2, qword ptr [ecx]
f20f5111|223344556677885f5f5f5f5f	32	plan9	REPNE SQRTSD 0(CX), X2
f20f5111|223344556677885f5f5f5f5f	64	gnu	sqrtsd (%rcx),%xmm2
f20f5111|223344556677885f5f5f5f5f	64	intel	sqrtsd xmm2, qword ptr [rcx]
f20f5111|223344556677885f5f5f5f5f	64	plan9	REPNE SQRTSD 0(CX), X2
f20f5811|223344556677885f5f5f5f5f	32	intel	addsd xmm2, qword ptr [ecx]
f20f5811|223344556677885f5f5f5f5f	32	plan9	REPNE ADDSD 0(CX), X2
f20f5811|223344556677885f5f5f5f5f	64	gnu	addsd (%rcx),%xmm2
f20f5811|223344556677885f5f5f5f5f	64	intel	addsd xmm2, qword ptr [rcx]
f20f5811|223344556677885f5f5f5f5f	64	plan9	REPNE ADDSD 0(CX), X2
f20f5911|223344556677885f5f5f5f5f	32	intel	mulsd xmm2, qword ptr [ecx]
f20f5911|223344556677885f5f5f5f5f	32	plan9	REPNE MULSD 0(CX), X2
f20f5911|223344556677885f5f5f5f5f	64	gnu	mulsd (%rcx),%xmm2
f20f5911|223344556677885f5f5f5f5f	64	intel	mulsd xmm2, qword ptr [rcx]
f20f5911|223344556677885f5f5f5f5f	64	plan9	REPNE MULSD 0(CX), X2
f20f5a11|223344556677885f5f5f5f5f	32	intel	cvtsd2ss xmm2, qword ptr [ecx]
f20f5a11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTSD2SS 0(CX), X2
f20f5a11|223344556677885f5f5f5f5f	64	gnu	cvtsd2ss (%rcx),%xmm2
f20f5a11|223344556677885f5f5f5f5f	64	intel	cvtsd2ss xmm2, qword ptr [rcx]
f20f5a11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTSD2SS 0(CX), X2
f20f5c11|223344556677885f5f5f5f5f	32	intel	subsd xmm2, qword ptr [ecx]
f20f5c11|223344556677885f5f5f5f5f	32	plan9	REPNE SUBSD 0(CX), X2
f20f5c11|223344556677885f5f5f5f5f	64	gnu	subsd (%rcx),%xmm2
f20f5c11|223344556677885f5f5f5f5f	64	intel	subsd xmm2, qword ptr [rcx]
f20f5c11|223344556677885f5f5f5f5f	64	plan9	REPNE SUBSD 0(CX), X2
f20f5d11|223344556677885f5f5f5f5f	32	intel	minsd xmm2, qword ptr [ecx]
f20f5d11|223344556677885f5f5f5f5f	32	plan9	REPNE MINSD 0(CX), X2
f20f5d11|223344556677885f5f5f5f5f	64	gnu	minsd (%rcx),%xmm2
f20f5d11|223344556677885f5f5f5f5f	64	intel	minsd xmm2, qword ptr [rcx]
f20f5d11|223344556677885f5f5f5f5f	64	plan9	REPNE MINSD 0(CX), X2
f20f5e11|223344556677885f5f5f5f5f	32	intel	divsd xmm2, qword ptr [ecx]
f20f5e11|223344556677885f5f5f5f5f	32	plan9	REPNE DIVSD 0(CX), X2
f20f5e11|223344556677885f5f5f5f5f	64	gnu	divsd (%rcx),%xmm2
f20f5e11|223344556677885f5f5f5f5f	64	intel	divsd xmm2, qword ptr [rcx]
f20f5e11|223344556677885f5f5f5f5f	64	plan9	REPNE DIVSD 0(CX), X2
f20f5f11|223344556677885f5f5f5f5f	32	intel	maxsd xmm2, qword ptr [ecx]
f20f5f11|223344556677885f5f5f5f5f	32	plan9	REPNE MAXSD 0(CX), X2
f20f5f11|223344556677885f5f5f5f5f	64	gnu	maxsd (%rcx),%xmm2
f20f5f11|223344556677885f5f5f5f5f	64	intel	maxsd xmm2, qword ptr [rcx]
f20f5f11|223344556677885f5f5f5f5f	64	plan9	REPNE MAXSD 0(CX), X2
f20f701122|3344556677885f5f5f5f5f	32	intel	pshuflw xmm2, xmmword ptr [ecx], 0x22
f20f701122|3344556677885f5f5f5f5f	32	plan9	REPNE PSHUFLW $0x22, 0(CX), X2
f20f701122|3344556677885f5f5f5f5f	64	gnu	pshuflw $0x22,(%rcx),%xmm2
f20f701122|3344556677885f5f5f5f5f	64	intel	pshuflw xmm2, xmmword ptr [rcx], 0x22
f20f701122|3344556677885f5f5f5f5f	64	plan9	REPNE PSHUFLW $0x22, 0(CX), X2
f20f7c11|223344556677885f5f5f5f5f	32	intel	haddps xmm2, xmmword ptr [ecx]
f20f7c11|223344556677885f5f5f5f5f	32	plan9	REPNE HADDPS 0(CX), X2
f20f7c11|223344556677885f5f5f5f5f	64	gnu	haddps (%rcx),%xmm2
f20f7c11|223344556677885f5f5f5f5f	64	intel	haddps xmm2, xmmword ptr [rcx]
f20f7c11|223344556677885f5f5f5f5f	64	plan9	REPNE HADDPS 0(CX), X2
f20f7d11|223344556677885f5f5f5f5f	32	intel	hsubps xmm2, xmmword ptr [ecx]
f20f7d11|223344556677885f5f5f5f5f	32	plan9	REPNE HSUBPS 0(CX), X2
f20f7d11|223344556677885f5f5f5f5f	64	gnu	hsubps (%rcx),%xmm2
f20f7d11|223344556677885f5f5f5f5f	64	intel	hsubps xmm2, xmmword ptr [rcx]
f20f7d11|223344556677885f5f5f5f5f	64	plan9	REPNE HSUBPS 0(CX), X2
f20fc21122|3344556677885f5f5f5f5f	32	intel	cmpsd_xmm xmm2, qword ptr [ecx], 0x22
f20fc21122|3344556677885f5f5f5f5f	32	plan9	REPNE CMPSD_XMM $0x22, 0(CX), X2
f20fc21122|3344556677885f5f5f5f5f	64	gnu	cmpsd $0x22,(%rcx),%xmm2
f20fc21122|3344556677885f5f5f5f5f	64	intel	cmpsd_xmm xmm2, qword ptr [rcx], 0x22
f20fc21122|3344556677885f5f5f5f5f	64	plan9	REPNE CMPSD_XMM $0x22, 0(CX), X2
f20fd011|223344556677885f5f5f5f5f	32	intel	addsubps xmm2, xmmword ptr [ecx]
f20fd011|223344556677885f5f5f5f5f	32	plan9	REPNE ADDSUBPS 0(CX), X2
f20fd011|223344556677885f5f5f5f5f	64	gnu	addsubps (%rcx),%xmm2
f20fd011|223344556677885f5f5f5f5f	64	intel	addsubps xmm2, xmmword ptr [rcx]
f20fd011|223344556677885f5f5f5f5f	64	plan9	REPNE ADDSUBPS 0(CX), X2
f20fd6c0|11223344556677885f5f5f5f	32	intel	movdq2q mmx0, xmm0
f20fd6c0|11223344556677885f5f5f5f	32	plan9	REPNE MOVDQ2Q X0, M0
f20fd6c0|11223344556677885f5f5f5f	64	gnu	movdq2q %xmm0,%mm0
f20fd6c0|11223344556677885f5f5f5f	64	intel	movdq2q mmx0, xmm0
f20fd6c0|11223344556677885f5f5f5f	64	plan9	REPNE MOVDQ2Q X0, M0
f20fe611|223344556677885f5f5f5f5f	32	intel	cvtpd2dq xmm2, xmmword ptr [ecx]
f20fe611|223344556677885f5f5f5f5f	32	plan9	REPNE CVTPD2DQ 0(CX), X2
f20fe611|223344556677885f5f5f5f5f	64	gnu	cvtpd2dq (%rcx),%xmm2
f20fe611|223344556677885f5f5f5f5f	64	intel	cvtpd2dq xmm2, xmmword ptr [rcx]
f20fe611|223344556677885f5f5f5f5f	64	plan9	REPNE CVTPD2DQ 0(CX), X2
f20ff011|223344556677885f5f5f5f5f	32	intel	lddqu xmm2, xmmword ptr [ecx]
f20ff011|223344556677885f5f5f5f5f	32	plan9	REPNE LDDQU 0(CX), X2
f20ff011|223344556677885f5f5f5f5f	64	gnu	lddqu (%rcx),%xmm2
f20ff011|223344556677885f5f5f5f5f	64	intel	lddqu xmm2, xmmword ptr [rcx]
f20ff011|223344556677885f5f5f5f5f	64	plan9	REPNE LDDQU 0(CX), X2
f2480f2a11|223344556677885f5f5f5f	64	gnu	cvtsi2sdq (%rcx),%xmm2
f2480f2a11|223344556677885f5f5f5f	64	intel	cvtsi2sd xmm2, qword ptr [rcx]
f2480f2a11|223344556677885f5f5f5f	64	plan9	REPNE CVTSI2SDQ 0(CX), X2
f2480f2c11|223344556677885f5f5f5f	64	gnu	cvttsd2si (%rcx),%rdx
f2480f2c11|223344556677885f5f5f5f	64	intel	cvttsd2si rdx, qword ptr [rcx]
f2480f2c11|223344556677885f5f5f5f	64	plan9	REPNE CVTTSD2SIQ 0(CX), DX
f2480f2d11|223344556677885f5f5f5f	64	gnu	cvtsd2si (%rcx),%rdx
f2480f2d11|223344556677885f5f5f5f	64	intel	cvtsd2si rdx, qword ptr [rcx]
f2480f2d11|223344556677885f5f5f5f	64	plan9	REPNE CVTSD2SIQ 0(CX), DX
f2480f38f011|223344556677885f5f5f	64	gnu	crc32b (%rcx),%rdx
f2480f38f011|223344556677885f5f5f	64	intel	crc32 rdx, byte ptr [rcx]
f2480f38f011|223344556677885f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f2480f38f111|223344556677885f5f5f	64	gnu	crc32q (%rcx),%rdx
f2480f38f111|223344556677885f5f5f	64	intel	crc32 rdx, qword ptr [rcx]
f2480f38f111|223344556677885f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f267f0663e360f38f111|223344556677	32	intel	lock crc32 edx, word ptr ss:[bx+di*1]
f267f0663e360f38f111|223344556677	32	plan9	SS CRC32 SS:0(BX)(DI*1), DX
f267f0663e360f38f111|223344556677	64	gnu	lock crc32w %ds:%ss:(%ecx),%edx
f267f0663e360f38f111|223344556677	64	intel	lock crc32 edx, word ptr [ecx]
f267f0663e360f38f111|223344556677	64	plan9	SS CRC32 0(CX), DX
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	intel	movntss dword ptr [ecx], xmm2
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	plan9	REP MOVNTSS X2, 0(CX)
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	gnu	repn movntss %xmm2,(%rcx)
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	intel	movntss dword ptr [rcx], xmm2
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	plan9	REP MOVNTSS X2, 0(CX)
f30f1011|223344556677885f5f5f5f5f	32	intel	movss xmm2, dword ptr [ecx]
f30f1011|223344556677885f5f5f5f5f	32	plan9	REP MOVSS 0(CX), X2
f30f1011|223344556677885f5f5f5f5f	64	gnu	movss (%rcx),%xmm2
f30f1011|223344556677885f5f5f5f5f	64	intel	movss xmm2, dword ptr [rcx]
f30f1011|223344556677885f5f5f5f5f	64	plan9	REP MOVSS 0(CX), X2
f30f1122|3344556677885f5f5f5f5f5f	32	intel	movss dword ptr [edx], xmm4
f30f1122|3344556677885f5f5f5f5f5f	32	plan9	REP MOVSS X4, 0(DX)
f30f1122|3344556677885f5f5f5f5f5f	64	gnu	movss %xmm4,(%rdx)
f30f1122|3344556677885f5f5f5f5f5f	64	intel	movss dword ptr [rdx], xmm4
f30f1122|3344556677885f5f5f5f5f5f	64	plan9	REP MOVSS X4, 0(DX)
f30f1211|223344556677885f5f5f5f5f	32	intel	movsldup xmm2, xmmword ptr [ecx]
f30f1211|223344556677885f5f5f5f5f	32	plan9	REP MOVSLDUP 0(CX), X2
f30f1211|223344556677885f5f5f5f5f	64	gnu	movsldup (%rcx),%xmm2
f30f1211|223344556677885f5f5f5f5f	64	intel	movsldup xmm2, xmmword ptr [rcx]
f30f1211|223344556677885f5f5f5f5f	64	plan9	REP MOVSLDUP 0(CX), X2
f30f1611|223344556677885f5f5f5f5f	32	intel	movshdup xmm2, xmmword ptr [ecx]
f30f1611|223344556677885f5f5f5f5f	32	plan9	REP MOVSHDUP 0(CX), X2
f30f1611|223344556677885f5f5f5f5f	64	gnu	movshdup (%rcx),%xmm2
f30f1611|223344556677885f5f5f5f5f	64	intel	movshdup xmm2, xmmword ptr [rcx]
f30f1611|223344556677885f5f5f5f5f	64	plan9	REP MOVSHDUP 0(CX), X2
f30f2a11|223344556677885f5f5f5f5f	32	intel	cvtsi2ss xmm2, dword ptr [ecx]
f30f2a11|223344556677885f5f5f5f5f	32	plan9	REP CVTSI2SSL 0(CX), X2
f30f2a11|223344556677885f5f5f5f5f	64	gnu	cvtsi2ssl (%rcx),%xmm2
f30f2a11|223344556677885f5f5f5f5f	64	intel	cvtsi2ss xmm2, dword ptr [rcx]
f30f2a11|223344556677885f5f5f5f5f	64	plan9	REP CVTSI2SSL 0(CX), X2
f30f2c11|223344556677885f5f5f5f5f	32	intel	cvttss2si edx, dword ptr [ecx]
f30f2c11|223344556677885f5f5f5f5f	32	plan9	REP CVTTSS2SIL 0(CX), DX
f30f2c11|223344556677885f5f5f5f5f	64	gnu	cvttss2si (%rcx),%edx
f30f2c11|223344556677885f5f5f5f5f	64	intel	cvttss2si edx, dword ptr [rcx]
f30f2c11|223344556677885f5f5f5f5f	64	plan9	REP CVTTSS2SIL 0(CX), DX
f30f2d11|223344556677885f5f5f5f5f	32	intel	cvtss2si edx, dword ptr [ecx]
f30f2d11|223344556677885f5f5f5f5f	32	plan9	REP CVTSS2SIL 0(CX), DX
f30f2d11|223344556677885f5f5f5f5f	64	gnu	cvtss2si (%rcx),%edx
f30f2d11|223344556677885f5f5f5f5f	64	intel	cvtss2si edx, dword ptr [rcx]
f30f2d11|223344556677885f5f5f5f5f	64	plan9	REP CVTSS2SIL 0(CX), DX
f30f5111|223344556677885f5f5f5f5f	32	intel	sqrtss xmm2, dword ptr [ecx]
f30f5111|223344556677885f5f5f5f5f	32	plan9	REP SQRTSS 0(CX), X2
f30f5111|223344556677885f5f5f5f5f	64	gnu	sqrtss (%rcx),%xmm2
f30f5111|223344556677885f5f5f5f5f	64	intel	sqrtss xmm2, dword ptr [rcx]
f30f5111|223344556677885f5f5f5f5f	64	plan9	REP SQRTSS 0(CX), X2
f30f5211|223344556677885f5f5f5f5f	32	intel	rsqrtss xmm2, dword ptr [ecx]
f30f5211|223344556677885f5f5f5f5f	32	plan9	REP RSQRTSS 0(CX), X2
f30f5211|223344556677885f5f5f5f5f	64	gnu	rsqrtss (%rcx),%xmm2
f30f5211|223344556677885f5f5f5f5f	64	intel	rsqrtss xmm2, dword ptr [rcx]
f30f5211|223344556677885f5f5f5f5f	64	plan9	REP RSQRTSS 0(CX), X2
f30f5311|223344556677885f5f5f5f5f	32	intel	rcpss xmm2, dword ptr [ecx]
f30f5311|223344556677885f5f5f5f5f	32	plan9	REP RCPSS 0(CX), X2
f30f5311|223344556677885f5f5f5f5f	64	gnu	rcpss (%rcx),%xmm2
f30f5311|223344556677885f5f5f5f5f	64	intel	rcpss xmm2, dword ptr [rcx]
f30f5311|223344556677885f5f5f5f5f	64	plan9	REP RCPSS 0(CX), X2
f30f5811|223344556677885f5f5f5f5f	32	intel	addss xmm2, dword ptr [ecx]
f30f5811|223344556677885f5f5f5f5f	32	plan9	REP ADDSS 0(CX), X2
f30f5811|223344556677885f5f5f5f5f	64	gnu	addss (%rcx),%xmm2
f30f5811|223344556677885f5f5f5f5f	64	intel	addss xmm2, dword ptr [rcx]
f30f5811|223344556677885f5f5f5f5f	64	plan9	REP ADDSS 0(CX), X2
f30f5911|223344556677885f5f5f5f5f	32	intel	mulss xmm2, dword ptr [ecx]
f30f5911|223344556677885f5f5f5f5f	32	plan9	REP MULSS 0(CX), X2
f30f5911|223344556677885f5f5f5f5f	64	gnu	mulss (%rcx),%xmm2
f30f5911|223344556677885f5f5f5f5f	64	intel	mulss xmm2, dword ptr [rcx]
f30f5911|223344556677885f5f5f5f5f	64	plan9	REP MULSS 0(CX), X2
f30f5a11|223344556677885f5f5f5f5f	32	intel	cvtss2sd xmm2, dword ptr [ecx]
f30f5a11|223344556677885f5f5f5f5f	32	plan9	REP CVTSS2SD 0(CX), X2
f30f5a11|223344556677885f5f5f5f5f	64	gnu	cvtss2sd (%rcx),%xmm2
f30f5a11|223344556677885f5f5f5f5f	64	intel	cvtss2sd xmm2, dword ptr [rcx]
f30f5a11|223344556677885f5f5f5f5f	64	plan9	REP CVTSS2SD 0(CX), X2
f30f5b11|223344556677885f5f5f5f5f	32	intel	cvttps2dq xmm2, xmmword ptr [ecx]
f30f5b11|223344556677885f5f5f5f5f	32	plan9	REP CVTTPS2DQ 0(CX), X2
f30f5b11|223344556677885f5f5f5f5f	64	gnu	cvttps2dq (%rcx),%xmm2
f30f5b11|223344556677885f5f5f5f5f	64	intel	cvttps2dq xmm2, xmmword ptr [rcx]
f30f5b11|223344556677885f5f5f5f5f	64	plan9	REP CVTTPS2DQ 0(CX), X2
f30f5c11|223344556677885f5f5f5f5f	32	intel	subss xmm2, dword ptr [ecx]
f30f5c11|223344556677885f5f5f5f5f	32	plan9	REP SUBSS 0(CX), X2
f30f5c11|223344556677885f5f5f5f5f	64	gnu	subss (%rcx),%xmm2
f30f5c11|223344556677885f5f5f5f5f	64	intel	subss xmm2, dword ptr [rcx]
f30f5c11|223344556677885f5f5f5f5f	64	plan9	REP SUBSS 0(CX), X2
f30f5d11|223344556677885f5f5f5f5f	32	intel	minss xmm2, dword ptr [ecx]
f30f5d11|223344556677885f5f5f5f5f	32	plan9	REP MINSS 0(CX), X2
f30f5d11|223344556677885f5f5f5f5f	64	gnu	minss (%rcx),%xmm2
f30f5d11|223344556677885f5f5f5f5f	64	intel	minss xmm2, dword ptr [rcx]
f30f5d11|223344556677885f5f5f5f5f	64	plan9	REP MINSS 0(CX), X2
f30f5e11|223344556677885f5f5f5f5f	32	intel	divss xmm2, dword ptr [ecx]
f30f5e11|223344556677885f5f5f5f5f	32	plan9	REP DIVSS 0(CX), X2
f30f5e11|223344556677885f5f5f5f5f	64	gnu	divss (%rcx),%xmm2
f30f5e11|223344556677885f5f5f5f5f	64	intel	divss xmm2, dword ptr [rcx]
f30f5e11|223344556677885f5f5f5f5f	64	plan9	REP DIVSS 0(CX), X2
f30f5f11|223344556677885f5f5f5f5f	32	intel	maxss xmm2, dword ptr [ecx]
f30f5f11|223344556677885f5f5f5f5f	32	plan9	REP MAXSS 0(CX), X2
f30f5f11|223344556677885f5f5f5f5f	64	gnu	maxss (%rcx),%xmm2
f30f5f11|223344556677885f5f5f5f5f	64	intel	maxss xmm2, dword ptr [rcx]
f30f5f11|223344556677885f5f5f5f5f	64	plan9	REP MAXSS 0(CX), X2
f30f6f11|223344556677885f5f5f5f5f	32	intel	movdqu xmm2, xmmword ptr [ecx]
f30f6f11|223344556677885f5f5f5f5f	32	plan9	REP MOVDQU 0(CX), X2
f30f6f11|223344556677885f5f5f5f5f	64	gnu	movdqu (%rcx),%xmm2
f30f6f11|223344556677885f5f5f5f5f	64	intel	movdqu xmm2, xmmword ptr [rcx]
f30f6f11|223344556677885f5f5f5f5f	64	plan9	REP MOVDQU 0(CX), X2
f30f701122|3344556677885f5f5f5f5f	32	intel	pshufhw xmm2, xmmword ptr [ecx], 0x22
f30f701122|3344556677885f5f5f5f5f	32	plan9	REP PSHUFHW $0x22, 0(CX), X2
f30f701122|3344556677885f5f5f5f5f	64	gnu	pshufhw $0x22,(%rcx),%xmm2
f30f701122|3344556677885f5f5f5f5f	64	intel	pshufhw xmm2, xmmword ptr [rcx], 0x22
f30f701122|3344556677885f5f5f5f5f	64	plan9	REP PSHUFHW $0x22, 0(CX), X2
f30f7e11|223344556677885f5f5f5f5f	32	intel	movq xmm2, qword ptr [ecx]
f30f7e11|223344556677885f5f5f5f5f	32	plan9	REP MOVQ 0(CX), X2
f30f7e11|223344556677885f5f5f5f5f	64	gnu	movq (%rcx),%xmm2
f30f7e11|223344556677885f5f5f5f5f	64	intel	movq xmm2, qword ptr [rcx]
f30f7e11|223344556677885f5f5f5f5f	64	plan9	REP MOVQ 0(CX), X2
f30f7f11|223344556677885f5f5f5f5f	32	intel	movdqu xmmword ptr [ecx], xmm2
f30f7f11|223344556677885f5f5f5f5f	32	plan9	REP MOVDQU X2, 0(CX)
f30f7f11|223344556677885f5f5f5f5f	64	gnu	movdqu %xmm2,(%rcx)
f30f7f11|223344556677885f5f5f5f5f	64	intel	movdqu xmmword ptr [rcx], xmm2
f30f7f11|223344556677885f5f5f5f5f	64	plan9	REP MOVDQU X2, 0(CX)
f30fae11|223344556677885f5f5f5f5f	64	gnu	wrfsbasel (%rcx)
f30fae11|223344556677885f5f5f5f5f	64	intel	wrfsbase dword ptr [rcx]
f30fae11|223344556677885f5f5f5f5f	64	plan9	REP WRFSBASE 0(CX)
f30fae18|11223344556677885f5f5f5f	64	gnu	wrgsbasel (%rax)
f30fae18|11223344556677885f5f5f5f	64	intel	wrgsbase dword ptr [rax]
f30fae18|11223344556677885f5f5f5f	64	plan9	REP WRGSBASE 0(AX)
f30faec0|11223344556677885f5f5f5f	64	gnu	rdfsbase %eax
f30faec0|11223344556677885f5f5f5f	64	intel	rdfsbase eax
f30faec0|11223344556677885f5f5f5f	64	plan9	REP RDFSBASE AX
f30faec8|11223344556677885f5f5f5f	64	gnu	rdgsbase %eax
f30faec8|11223344556677885f5f5f5f	64	intel	rdgsbase eax
f30faec8|11223344556677885f5f5f5f	64	plan9	REP RDGSBASE AX
f30fb811|223344556677885f5f5f5f5f	32	intel	popcnt edx, dword ptr [ecx]
f30fb811|223344556677885f5f5f5f5f	32	plan9	REP POPCNT 0(CX), DX
f30fb811|223344556677885f5f5f5f5f	64	gnu	popcnt (%rcx),%edx
f30fb811|223344556677885f5f5f5f5f	64	intel	popcnt edx, dword ptr [rcx]
f30fb811|223344556677885f5f5f5f5f	64	plan9	REP POPCNT 0(CX), DX
f30fbc11|223344556677885f5f5f5f5f	32	intel	tzcnt edx, dword ptr [ecx]
f30fbc11|223344556677885f5f5f5f5f	32	plan9	REP TZCNT 0(CX), DX
f30fbc11|223344556677885f5f5f5f5f	64	gnu	tzcnt (%rcx),%edx
f30fbc11|223344556677885f5f5f5f5f	64	intel	tzcnt edx, dword ptr [rcx]
f30fbc11|223344556677885f5f5f5f5f	64	plan9	REP TZCNT 0(CX), DX
f30fbd11|223344556677885f5f5f5f5f	32	intel	lzcnt edx, dword ptr [ecx]
f30fbd11|223344556677885f5f5f5f5f	32	plan9	REP LZCNT 0(CX), DX
f30fbd11|223344556677885f5f5f5f5f	64	gnu	lzcnt (%rcx),%edx
f30fbd11|223344556677885f5f5f5f5f	64	intel	lzcnt edx, dword ptr [rcx]
f30fbd11|223344556677885f5f5f5f5f	64	plan9	REP LZCNT 0(CX), DX
f30fc21122|3344556677885f5f5f5f5f	32	intel	cmpss xmm2, dword ptr [ecx], 0x22
f30fc21122|3344556677885f5f5f5f5f	32	plan9	REP CMPSS $0x22, 0(CX), X2
f30fc21122|3344556677885f5f5f5f5f	64	gnu	cmpss $0x22,(%rcx),%xmm2
f30fc21122|3344556677885f5f5f5f5f	64	intel	cmpss xmm2, dword ptr [rcx], 0x22
f30fc21122|3344556677885f5f5f5f5f	64	plan9	REP CMPSS $0x22, 0(CX), X2
f30fe611|223344556677885f5f5f5f5f	32	intel	cvtdq2pd xmm2, qword ptr [ecx]
f30fe611|223344556677885f5f5f5f5f	32	plan9	REP CVTDQ2PD 0(CX), X2
f30fe611|223344556677885f5f5f5f5f	64	gnu	cvtdq2pd (%rcx),%xmm2
f30fe611|223344556677885f5f5f5f5f	64	intel	cvtdq2pd xmm2, qword ptr [rcx]
f30fe611|223344556677885f5f5f5f5f	64	plan9	REP CVTDQ2PD 0(CX), X2
f3480f2a11|223344556677885f5f5f5f	64	gnu	cvtsi2ssq (%rcx),%xmm2
f3480f2a11|223344556677885f5f5f5f	64	intel	cvtsi2ss xmm2, qword ptr [rcx]
f3480f2a11|223344556677885f5f5f5f	64	plan9	REP CVTSI2SSQ 0(CX), X2
f3480f2c11|223344556677885f5f5f5f	64	gnu	cvttss2si (%rcx),%rdx
f3480f2c11|223344556677885f5f5f5f	64	intel	cvttss2si rdx, dword ptr [rcx]
f3480f2c11|223344556677885f5f5f5f	64	plan9	REP CVTTSS2SIQ 0(CX), DX
f3480f2d11|223344556677885f5f5f5f	64	gnu	cvtss2si (%rcx),%rdx
f3480f2d11|223344556677885f5f5f5f	64	intel	cvtss2si rdx, dword ptr [rcx]
f3480f2d11|223344556677885f5f5f5f	64	plan9	REP CVTSS2SIQ 0(CX), DX
f3480fae11|223344556677885f5f5f5f	64	gnu	wrfsbaseq (%rcx)
f3480fae11|223344556677885f5f5f5f	64	intel	wrfsbase qword ptr [rcx]
f3480fae11|223344556677885f5f5f5f	64	plan9	REP WRFSBASE 0(CX)
f3480fae18|11223344556677885f5f5f	64	gnu	wrgsbaseq (%rax)
f3480fae18|11223344556677885f5f5f	64	intel	wrgsbase qword ptr [rax]
f3480fae18|11223344556677885f5f5f	64	plan9	REP WRGSBASE 0(AX)
f3480faec0|11223344556677885f5f5f	64	gnu	rdfsbase %rax
f3480faec0|11223344556677885f5f5f	64	intel	rdfsbase rax
f3480faec0|11223344556677885f5f5f	64	plan9	REP RDFSBASE AX
f3480faec8|11223344556677885f5f5f	64	gnu	rdgsbase %rax
f3480faec8|11223344556677885f5f5f	64	intel	rdgsbase rax
f3480faec8|11223344556677885f5f5f	64	plan9	REP RDGSBASE AX
f3480fb811|223344556677885f5f5f5f	64	gnu	popcnt (%rcx),%rdx
f3480fb811|223344556677885f5f5f5f	64	intel	popcnt rdx, qword ptr [rcx]
f3480fb811|223344556677885f5f5f5f	64	plan9	REP POPCNT 0(CX), DX
f3480fbc11|223344556677885f5f5f5f	64	gnu	tzcnt (%rcx),%rdx
f3480fbc11|223344556677885f5f5f5f	64	intel	tzcnt rdx, qword ptr [rcx]
f3480fbc11|223344556677885f5f5f5f	64	plan9	REP TZCNT 0(CX), DX
f3480fbd11|223344556677885f5f5f5f	64	gnu	lzcnt (%rcx),%rdx
f3480fbd11|223344556677885f5f5f5f	64	intel	lzcnt rdx, qword ptr [rcx]
f3480fbd11|223344556677885f5f5f5f	64	plan9	REP LZCNT 0(CX), DX
f3660fb811|223344556677885f5f5f5f	32	intel	popcnt dx, word ptr [ecx]
f3660fb811|223344556677885f5f5f5f	32	plan9	POPCNT 0(CX), DX
f3660fb811|223344556677885f5f5f5f	64	gnu	popcnt (%rcx),%dx
f3660fb811|223344556677885f5f5f5f	64	intel	popcnt dx, word ptr [rcx]
f3660fb811|223344556677885f5f5f5f	64	plan9	POPCNT 0(CX), DX
f3660fbc11|223344556677885f5f5f5f	32	intel	tzcnt dx, word ptr [ecx]
f3660fbc11|223344556677885f5f5f5f	32	plan9	TZCNT 0(CX), DX
f3660fbc11|223344556677885f5f5f5f	64	gnu	tzcnt (%rcx),%dx
f3660fbc11|223344556677885f5f5f5f	64	intel	tzcnt dx, word ptr [rcx]
f3660fbc11|223344556677885f5f5f5f	64	plan9	TZCNT 0(CX), DX
f3660fbd11|223344556677885f5f5f5f	32	intel	lzcnt dx, word ptr [ecx]
f3660fbd11|223344556677885f5f5f5f	32	plan9	LZCNT 0(CX), DX
f3660fbd11|223344556677885f5f5f5f	64	gnu	lzcnt (%rcx),%dx
f3660fbd11|223344556677885f5f5f5f	64	intel	lzcnt dx, word ptr [rcx]
f3660fbd11|223344556677885f5f5f5f	64	plan9	LZCNT 0(CX), DX
f3f0673e660f38f111|22334455667788	32	intel	lock movbe word ptr [bx+di*1], dx
f3f0673e660f38f111|22334455667788	32	plan9	MOVBE DX, DS:0(BX)(DI*1)
f3f0673e660f38f111|22334455667788	64	gnu	rep lock movbe %dx,%ds:(%ecx)
f3f0673e660f38f111|22334455667788	64	intel	lock movbe word ptr [ecx], dx
f3f0673e660f38f111|22334455667788	64	plan9	MOVBE DX, 0(CX)
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	intel	movntsd qword ptr [ecx], xmm2
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	plan9	REPNE MOVNTSD X2, 0(CX)
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	gnu	repn movntss %xmm2,(%rcx)
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	intel	movntsd qword ptr [rcx], xmm2
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	plan9	REPNE MOVNTSD X2, 0(CX)
f4|11223344556677885f5f5f5f5f5f5f	32	intel	hlt
f4|11223344556677885f5f5f5f5f5f5f	32	plan9	HLT
f4|11223344556677885f5f5f5f5f5f5f	64	gnu	hlt
f4|11223344556677885f5f5f5f5f5f5f	64	intel	hlt
f4|11223344556677885f5f5f5f5f5f5f	64	plan9	HLT
f5|11223344556677885f5f5f5f5f5f5f	32	intel	cmc
f5|11223344556677885f5f5f5f5f5f5f	32	plan9	CMC
f5|11223344556677885f5f5f5f5f5f5f	64	gnu	cmc
f5|11223344556677885f5f5f5f5f5f5f	64	intel	cmc
f5|11223344556677885f5f5f5f5f5f5f	64	plan9	CMC
f60011|223344556677885f5f5f5f5f5f	32	intel	test byte ptr [eax], 0x11
f60011|223344556677885f5f5f5f5f5f	32	plan9	TESTL $0x11, 0(AX)
f60011|223344556677885f5f5f5f5f5f	64	gnu	testb $0x11,(%rax)
f60011|223344556677885f5f5f5f5f5f	64	intel	test byte ptr [rax], 0x11
f60011|223344556677885f5f5f5f5f5f	64	plan9	TESTL $0x11, 0(AX)
f611|223344556677885f5f5f5f5f5f5f	32	intel	not byte ptr [ecx]
f611|223344556677885f5f5f5f5f5f5f	32	plan9	NOTL 0(CX)
f611|223344556677885f5f5f5f5f5f5f	64	gnu	notb (%rcx)
f611|223344556677885f5f5f5f5f5f5f	64	intel	not byte ptr [rcx]
f611|223344556677885f5f5f5f5f5f5f	64	plan9	NOTL 0(CX)
f618|11223344556677885f5f5f5f5f5f	32	intel	neg byte ptr [eax]
f618|11223344556677885f5f5f5f5f5f	32	plan9	NEGL 0(AX)
f618|11223344556677885f5f5f5f5f5f	64	gnu	negb (%rax)
f618|11223344556677885f5f5f5f5f5f	64	intel	neg byte ptr [rax]
f618|11223344556677885f5f5f5f5f5f	64	plan9	NEGL 0(AX)
f620|11223344556677885f5f5f5f5f5f	32	intel	mul byte ptr [eax]
f620|11223344556677885f5f5f5f5f5f	32	plan9	MULL 0(AX)
f620|11223344556677885f5f5f5f5f5f	64	gnu	mulb (%rax)
f620|11223344556677885f5f5f5f5f5f	64	intel	mul byte ptr [rax]
f620|11223344556677885f5f5f5f5f5f	64	plan9	MULL 0(AX)
f628|11223344556677885f5f5f5f5f5f	32	intel	imul byte ptr [eax]
f628|11223344556677885f5f5f5f5f5f	32	plan9	IMULL 0(AX)
f628|11223344556677885f5f5f5f5f5f	64	gnu	imulb (%rax)
f628|11223344556677885f5f5f5f5f5f	64	intel	imul byte ptr [rax]
f628|11223344556677885f5f5f5f5f5f	64	plan9	IMULL 0(AX)
f630|11223344556677885f5f5f5f5f5f	32	intel	div byte ptr [eax]
f630|11223344556677885f5f5f5f5f5f	32	plan9	DIVL 0(AX)
f630|11223344556677885f5f5f5f5f5f	64	gnu	divb (%rax)
f630|11223344556677885f5f5f5f5f5f	64	intel	div byte ptr [rax]
f630|11223344556677885f5f5f5f5f5f	64	plan9	DIVL 0(AX)
f638|11223344556677885f5f5f5f5f5f	32	intel	idiv byte ptr [eax]
f638|11223344556677885f5f5f5f5f5f	32	plan9	IDIVL 0(AX)
f638|11223344556677885f5f5f5f5f5f	64	gnu	idivb (%rax)
f638|11223344556677885f5f5f5f5f5f	64	intel	idiv byte ptr [rax]
f638|11223344556677885f5f5f5f5f5f	64	plan9	IDIVL 0(AX)
f70011223344|556677885f5f5f5f5f5f	32	intel	test dword ptr [eax], 0x44332211
f70011223344|556677885f5f5f5f5f5f	32	plan9	TESTL $0x44332211, 0(AX)
f70011223344|556677885f5f5f5f5f5f	64	gnu	testl $0x44332211,(%rax)
f70011223344|556677885f5f5f5f5f5f	64	intel	test dword ptr [rax], 0x44332211
f70011223344|556677885f5f5f5f5f5f	64	plan9	TESTL $0x44332211, 0(AX)
f711|223344556677885f5f5f5f5f5f5f	32	intel	not dword ptr [ecx]
f711|223344556677885f5f5f5f5f5f5f	32	plan9	NOTL 0(CX)
f711|223344556677885f5f5f5f5f5f5f	64	gnu	notl (%rcx)
f711|223344556677885f5f5f5f5f5f5f	64	intel	not dword ptr [rcx]
f711|223344556677885f5f5f5f5f5f5f	64	plan9	NOTL 0(CX)
f718|11223344556677885f5f5f5f5f5f	32	intel	neg dword ptr [eax]
f718|11223344556677885f5f5f5f5f5f	32	plan9	NEGL 0(AX)
f718|11223344556677885f5f5f5f5f5f	64	gnu	negl (%rax)
f718|11223344556677885f5f5f5f5f5f	64	intel	neg dword ptr [rax]
f718|11223344556677885f5f5f5f5f5f	64	plan9	NEGL 0(AX)
f720|11223344556677885f5f5f5f5f5f	32	intel	mul dword ptr [eax]
f720|11223344556677885f5f5f5f5f5f	32	plan9	MULL 0(AX)
f720|11223344556677885f5f5f5f5f5f	64	gnu	mull (%rax)
f720|11223344556677885f5f5f5f5f5f	64	intel	mul dword ptr [rax]
f720|11223344556677885f5f5f5f5f5f	64	plan9	MULL 0(AX)
f728|11223344556677885f5f5f5f5f5f	32	intel	imul dword ptr [eax]
f728|11223344556677885f5f5f5f5f5f	32	plan9	IMULL 0(AX)
f728|11223344556677885f5f5f5f5f5f	64	gnu	imull (%rax)
f728|11223344556677885f5f5f5f5f5f	64	intel	imul dword ptr [rax]
f728|11223344556677885f5f5f5f5f5f	64	plan9	IMULL 0(AX)
f730|11223344556677885f5f5f5f5f5f	32	intel	div dword ptr [eax]
f730|11223344556677885f5f5f5f5f5f	32	plan9	DIVL 0(AX)
f730|11223344556677885f5f5f5f5f5f	64	gnu	divl (%rax)
f730|11223344556677885f5f5f5f5f5f	64	intel	div dword ptr [rax]
f730|11223344556677885f5f5f5f5f5f	64	plan9	DIVL 0(AX)
f738|11223344556677885f5f5f5f5f5f	32	intel	idiv dword ptr [eax]
f738|11223344556677885f5f5f5f5f5f	32	plan9	IDIVL 0(AX)
f738|11223344556677885f5f5f5f5f5f	64	gnu	idivl (%rax)
f738|11223344556677885f5f5f5f5f5f	64	intel	idiv dword ptr [rax]
f738|11223344556677885f5f5f5f5f5f	64	plan9	IDIVL 0(AX)
f8|11223344556677885f5f5f5f5f5f5f	32	intel	clc
f8|11223344556677885f5f5f5f5f5f5f	32	plan9	CLC
f8|11223344556677885f5f5f5f5f5f5f	64	gnu	clc
f8|11223344556677885f5f5f5f5f5f5f	64	intel	clc
f8|11223344556677885f5f5f5f5f5f5f	64	plan9	CLC
f9|11223344556677885f5f5f5f5f5f5f	32	intel	stc
f9|11223344556677885f5f5f5f5f5f5f	32	plan9	STC
f9|11223344556677885f5f5f5f5f5f5f	64	gnu	stc
f9|11223344556677885f5f5f5f5f5f5f	64	intel	stc
f9|11223344556677885f5f5f5f5f5f5f	64	plan9	STC
fa|11223344556677885f5f5f5f5f5f5f	32	intel	cli
fa|11223344556677885f5f5f5f5f5f5f	32	plan9	CLI
fa|11223344556677885f5f5f5f5f5f5f	64	gnu	cli
fa|11223344556677885f5f5f5f5f5f5f	64	intel	cli
fa|11223344556677885f5f5f5f5f5f5f	64	plan9	CLI
fb|11223344556677885f5f5f5f5f5f5f	32	intel	sti
fb|11223344556677885f5f5f5f5f5f5f	32	plan9	STI
fb|11223344556677885f5f5f5f5f5f5f	64	gnu	sti
fb|11223344556677885f5f5f5f5f5f5f	64	intel	sti
fb|11223344556677885f5f5f5f5f5f5f	64	plan9	STI
fc|11223344556677885f5f5f5f5f5f5f	32	intel	cld
fc|11223344556677885f5f5f5f5f5f5f	32	plan9	CLD
fc|11223344556677885f5f5f5f5f5f5f	64	gnu	cld
fc|11223344556677885f5f5f5f5f5f5f	64	intel	cld
fc|11223344556677885f5f5f5f5f5f5f	64	plan9	CLD
fd|11223344556677885f5f5f5f5f5f5f	32	intel	std
fd|11223344556677885f5f5f5f5f5f5f	32	plan9	STD
fd|11223344556677885f5f5f5f5f5f5f	64	gnu	std
fd|11223344556677885f5f5f5f5f5f5f	64	intel	std
fd|11223344556677885f5f5f5f5f5f5f	64	plan9	STD
fe00|11223344556677885f5f5f5f5f5f	32	intel	inc byte ptr [eax]
fe00|11223344556677885f5f5f5f5f5f	32	plan9	INCL 0(AX)
fe00|11223344556677885f5f5f5f5f5f	64	gnu	incb (%rax)
fe00|11223344556677885f5f5f5f5f5f	64	intel	inc byte ptr [rax]
fe00|11223344556677885f5f5f5f5f5f	64	plan9	INCL 0(AX)
fe08|11223344556677885f5f5f5f5f5f	32	intel	dec byte ptr [eax]
fe08|11223344556677885f5f5f5f5f5f	32	plan9	DECL 0(AX)
fe08|11223344556677885f5f5f5f5f5f	64	gnu	decb (%rax)
fe08|11223344556677885f5f5f5f5f5f	64	intel	dec byte ptr [rax]
fe08|11223344556677885f5f5f5f5f5f	64	plan9	DECL 0(AX)
ff00|11223344556677885f5f5f5f5f5f	32	intel	inc dword ptr [eax]
ff00|11223344556677885f5f5f5f5f5f	32	plan9	INCL 0(AX)
ff00|11223344556677885f5f5f5f5f5f	64	gnu	incl (%rax)
ff00|11223344556677885f5f5f5f5f5f	64	intel	inc dword ptr [rax]
ff00|11223344556677885f5f5f5f5f5f	64	plan9	INCL 0(AX)
ff08|11223344556677885f5f5f5f5f5f	32	intel	dec dword ptr [eax]
ff08|11223344556677885f5f5f5f5f5f	32	plan9	DECL 0(AX)
ff08|11223344556677885f5f5f5f5f5f	64	gnu	decl (%rax)
ff08|11223344556677885f5f5f5f5f5f	64	intel	dec dword ptr [rax]
ff08|11223344556677885f5f5f5f5f5f	64	plan9	DECL 0(AX)
ff11|223344556677885f5f5f5f5f5f5f	32	intel	call dword ptr [ecx]
ff11|223344556677885f5f5f5f5f5f5f	32	plan9	CALL 0(CX)
ff18|11223344556677885f5f5f5f5f5f	32	intel	call far ptr [eax]
ff18|11223344556677885f5f5f5f5f5f	32	plan9	LCALL 0(AX)
ff18|11223344556677885f5f5f5f5f5f	64	gnu	lcallq *(%rax)
ff18|11223344556677885f5f5f5f5f5f	64	intel	call far ptr [rax]
ff18|11223344556677885f5f5f5f5f5f	64	plan9	LCALL 0(AX)
ff20|11223344556677885f5f5f5f5f5f	32	intel	jmp dword ptr [eax]
ff20|11223344556677885f5f5f5f5f5f	32	plan9	JMP 0(AX)
ff28|11223344556677885f5f5f5f5f5f	32	intel	jmp far ptr [eax]
ff28|11223344556677885f5f5f5f5f5f	32	plan9	LJMP 0(AX)
ff28|11223344556677885f5f5f5f5f5f	64	gnu	ljmpq *(%rax)
ff28|11223344556677885f5f5f5f5f5f	64	intel	jmp far ptr [rax]
ff28|11223344556677885f5f5f5f5f5f	64	plan9	LJMP 0(AX)
ff30|11223344556677885f5f5f5f5f5f	32	intel	push dword ptr [eax]
ff30|11223344556677885f5f5f5f5f5f	32	plan9	PUSHL 0(AX)
ff30|11223344556677885f5f5f5f5f5f	64	gnu	pushq (%rax)
ff30|11223344556677885f5f5f5f5f5f	64	intel	push qword ptr [rax]
ff30|11223344556677885f5f5f5f5f5f	64	plan9	PUSHL 0(AX)
                                                                                                                                                                                       usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/testdata/libmach8db.c           0100644 0000000 0000000 00000152466 13020111412 027530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // 9c libmach8db.c && 9l -o libmach8db libmach8db.o; rm libmach8db.o

// Libmach-based disassembler for use in reference tests.

// Inferno libmach/8db.c
// http://code.google.com/p/inferno-os/source/browse/utils/libmach/8db.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.
//	Power PC support Copyright  1995-2004 C H Forsyth (forsyth@terzarima.net).
//	Portions Copyright  1997-1999 Vita Nuova Limited.
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com).
//	Revisions Copyright  2000-2004 Lucent Technologies Inc. and others.
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#include <u.h>
#include <libc.h>
#include <bio.h>

typedef struct Map Map;
struct Map
{
	int (*get1)(Map*, uvlong, uchar*, int);
	uchar *p;
	uchar *ep;
	uchar *startp;
	uvlong startpc;
};

static int
get1(Map *m, uvlong addr, uchar *p, int n)
{
	return m->get1(m, addr, p, n);
}

/*
 * i386-specific debugger interface
 * also amd64 extensions
 */

static	int	i386inst(Map*, uvlong, int, char, char*, int);
//static	int	i386das(Map*, uvlong, char*, int);
//static	int	i386instlen(Map*, uvlong);

	/* I386/486 - Disassembler and related functions */

/*
 *  an instruction
 */
typedef struct Instr Instr;
struct	Instr
{
	uchar	mem[1+1+1+1+2+1+1+4+4];		/* raw instruction */
	uvlong	addr;		/* address of start of instruction */
	int	n;		/* number of bytes in instruction */
	char	*prefix;	/* instr prefix */
	char	*segment;	/* segment override */
	uchar	jumptype;	/* set to the operand type for jump/ret/call */
	uchar	amd64;
	uchar	rex;		/* REX prefix (or zero) */
	uchar	op;
	char	osize;		/* 'W' or 'L' (or 'Q' on amd64) */
	char	asize;		/* address size 'W' or 'L' (or 'Q' or amd64) */
	uchar	mod;		/* bits 6-7 of mod r/m field */
	uchar	reg;		/* bits 3-5 of mod r/m field */
	char	ss;		/* bits 6-7 of SIB */
	schar	index;		/* bits 3-5 of SIB */
	schar	base;		/* bits 0-2 of SIB */
	char	rip;		/* RIP-relative in amd64 mode */
	uchar	opre;		/* f2/f3 could introduce media */
	short	seg;		/* segment of far address */
	uint32	disp;		/* displacement */
	uint32 	imm;		/* immediate */
	uint32 	imm2;		/* second immediate operand */
	uvlong	imm64;		/* big immediate */
	char	*curr;		/* fill level in output buffer */
	char	*end;		/* end of output buffer */
	char	*err;		/* error message */
};

	/* 386 register (ha!) set */
enum{
	AX=0,
	CX,
	DX,
	BX,
	SP,
	BP,
	SI,
	DI,

	/* amd64 */
	/* be careful: some unix system headers #define R8, R9, etc */
	AMD64_R8,
	AMD64_R9,
	AMD64_R10,
	AMD64_R11,
	AMD64_R12,
	AMD64_R13,
	AMD64_R14,
	AMD64_R15
};

	/* amd64 rex extension byte */
enum{
	REXW		= 1<<3,	/* =1, 64-bit operand size */
	REXR		= 1<<2,	/* extend modrm reg */
	REXX		= 1<<1,	/* extend sib index */
	REXB		= 1<<0	/* extend modrm r/m, sib base, or opcode reg */
};

	/* Operand Format codes */
/*
%A	-	address size register modifier (!asize -> 'E')
%C	-	Control register CR0/CR1/CR2
%D	-	Debug register DR0/DR1/DR2/DR3/DR6/DR7
%I	-	second immediate operand
%O	-	Operand size register modifier (!osize -> 'E')
%T	-	Test register TR6/TR7
%S	-	size code ('W' or 'L')
%W	-	Weird opcode: OSIZE == 'W' => "CBW"; else => "CWDE"
%d	-	displacement 16-32 bits
%e	-	effective address - Mod R/M value
%f	-	floating point register F0-F7 - from Mod R/M register
%g	-	segment register
%i	-	immediate operand 8-32 bits
%o	- 	register from opcode and REX.B
%p	-	PC-relative - signed displacement in immediate field
%r	-	Reg from Mod R/M
%w	-	Weird opcode: OSIZE == 'W' => "CWD"; else => "CDQ"
*/

typedef struct Optable Optable;
struct Optable
{
	char	operand[2];
	void	*proto;		/* actually either (char*) or (Optable*) */
};
	/* Operand decoding codes */
enum {
	Ib = 1,			/* 8-bit immediate - (no sign extension)*/
	Ibs,			/* 8-bit immediate (sign extended) */
	Jbs,			/* 8-bit sign-extended immediate in jump or call */
	Iw,			/* 16-bit immediate -> imm */
	Iw2,			/* 16-bit immediate -> imm2 */
	Iwd,			/* Operand-sized immediate (no sign extension)*/
	Iwdq,			/* Operand-sized immediate, possibly 64 bits */
	Awd,			/* Address offset */
	Iwds,			/* Operand-sized immediate (sign extended) */
	RM,			/* Word or int32 R/M field with register (/r) */
	RMB,			/* Byte R/M field with register (/r) */
	RMOP,			/* Word or int32 R/M field with op code (/digit) */
	RMOPB,			/* Byte R/M field with op code (/digit) */
	RMR,			/* R/M register only (mod = 11) */
	RMM,			/* R/M memory only (mod = 0/1/2) */
	Op_R0,			/* Base reg of Mod R/M is literal 0x00 */
	Op_R1,			/* Base reg of Mod R/M is literal 0x01 */
	FRMOP,			/* Floating point R/M field with opcode */
	FRMEX,			/* Extended floating point R/M field with opcode */
	JUMP,			/* Jump or Call flag - no operand */
	RET,			/* Return flag - no operand */
	OA,			/* literal 0x0a byte */
	PTR,			/* Seg:Displacement addr (ptr16:16 or ptr16:32) */
	AUX,			/* Multi-byte op code - Auxiliary table */
	AUXMM,			/* multi-byte op code - auxiliary table chosen by prefix */
	PRE,			/* Instr Prefix */
	OPRE,			/* Instr Prefix or media op extension */
	SEG,			/* Segment Prefix */
	OPOVER,			/* Operand size override */
	ADDOVER,		/* Address size override */
};

static Optable optab0F00[8]=
{
[0x00] =	{ 0,0,		"MOVW	LDT,%e" },
[0x01] =	{ 0,0,		"MOVW	TR,%e" },
[0x02] =	{ 0,0,		"MOVW	%e,LDT" },
[0x03] =	{ 0,0,		"MOVW	%e,TR" },
[0x04] =	{ 0,0,		"VERR	%e" },
[0x05] =	{ 0,0,		"VERW	%e" },
};

static Optable optab0F01[8]=
{
[0x00] =	{ 0,0,		"MOVL	GDTR,%e" },
[0x01] =	{ 0,0,		"MOVL	IDTR,%e" },
[0x02] =	{ 0,0,		"MOVL	%e,GDTR" },
[0x03] =	{ 0,0,		"MOVL	%e,IDTR" },
[0x04] =	{ 0,0,		"MOVW	MSW,%e" },	/* word */
[0x06] =	{ 0,0,		"MOVW	%e,MSW" },	/* word */
[0x07] =	{ 0,0,		"INVLPG	%e" },		/* or SWAPGS */
};

static Optable optab0F01F8[1]=
{
[0x00] =	{ 0,0,		"SWAPGS" },
};

/* 0F71 */
/* 0F72 */
/* 0F73 */

static Optable optab0FAE[8]=
{
[0x00] =	{ 0,0,		"FXSAVE	%e" },
[0x01] =	{ 0,0,		"FXRSTOR	%e" },
[0x02] =	{ 0,0,		"LDMXCSR	%e" },
[0x03] =	{ 0,0,		"STMXCSR	%e" },
[0x05] =	{ 0,0,		"LFENCE" },
[0x06] =	{ 0,0,		"MFENCE" },
[0x07] =	{ 0,0,		"SFENCE" },
};

/* 0F18 */
/* 0F0D */

static Optable optab0FBA[8]=
{
[0x04] =	{ Ib,0,		"BT%S	%i,%e" },
[0x05] =	{ Ib,0,		"BTS%S	%i,%e" },
[0x06] =	{ Ib,0,		"BTR%S	%i,%e" },
[0x07] =	{ Ib,0,		"BTC%S	%i,%e" },
};

static Optable optab0F0F[256]=
{
[0x0c] =	{ 0,0,		"PI2FW	%m,%M" },
[0x0d] =	{ 0,0,		"PI2L	%m,%M" },
[0x1c] =	{ 0,0,		"PF2IW	%m,%M" },
[0x1d] =	{ 0,0,		"PF2IL	%m,%M" },
[0x8a] =	{ 0,0,		"PFNACC	%m,%M" },
[0x8e] =	{ 0,0,		"PFPNACC	%m,%M" },
[0x90] =	{ 0,0,		"PFCMPGE	%m,%M" },
[0x94] =	{ 0,0,		"PFMIN	%m,%M" },
[0x96] =	{ 0,0,		"PFRCP	%m,%M" },
[0x97] =	{ 0,0,		"PFRSQRT	%m,%M" },
[0x9a] =	{ 0,0,		"PFSUB	%m,%M" },
[0x9e] =	{ 0,0,		"PFADD	%m,%M" },
[0xa0] =	{ 0,0,		"PFCMPGT	%m,%M" },
[0xa4] =	{ 0,0,		"PFMAX	%m,%M" },
[0xa6] =	{ 0,0,		"PFRCPIT1	%m,%M" },
[0xa7] =	{ 0,0,		"PFRSQIT1	%m,%M" },
[0xaa] =	{ 0,0,		"PFSUBR	%m,%M" },
[0xae] =	{ 0,0,		"PFACC	%m,%M" },
[0xb0] =	{ 0,0,		"PFCMPEQ	%m,%M" },
[0xb4] =	{ 0,0,		"PFMUL	%m,%M" },
[0xb6] =	{ 0,0,		"PFRCPI2T	%m,%M" },
[0xb7] =	{ 0,0,		"PMULHRW	%m,%M" },
[0xbb] =	{ 0,0,		"PSWAPL	%m,%M" },
};

static Optable optab0FC7[8]=
{
[0x01] =	{ 0,0,		"CMPXCHG8B	%e" },
};

static Optable optab660F71[8]=
{
[0x02] =	{ Ib,0,		"PSRLW	%i,%X" },
[0x04] =	{ Ib,0,		"PSRAW	%i,%X" },
[0x06] =	{ Ib,0,		"PSLLW	%i,%X" },
};

static Optable optab660F72[8]=
{
[0x02] =	{ Ib,0,		"PSRLL	%i,%X" },
[0x04] =	{ Ib,0,		"PSRAL	%i,%X" },
[0x06] =	{ Ib,0,		"PSLLL	%i,%X" },
};

static Optable optab660F73[8]=
{
[0x02] =	{ Ib,0,		"PSRLQ	%i,%X" },
[0x03] =	{ Ib,0,		"PSRLO	%i,%X" },
[0x06] =	{ Ib,0,		"PSLLQ	%i,%X" },
[0x07] =	{ Ib,0,		"PSLLO	%i,%X" },
};

static Optable optab660F[256]=
{
[0x2B] =	{ RM,0,		"MOVNTPD	%x,%e" },
[0x2E] =	{ RM,0,		"UCOMISD	%x,%X" },
[0x2F] =	{ RM,0,		"COMISD	%x,%X" },
[0x5A] =	{ RM,0,		"CVTPD2PS	%x,%X" },
[0x5B] =	{ RM,0,		"CVTPS2PL	%x,%X" },
[0x6A] =	{ RM,0,		"PUNPCKHLQ %x,%X" },
[0x6B] =	{ RM,0,		"PACKSSLW %x,%X" },
[0x6C] =	{ RM,0,		"PUNPCKLQDQ %x,%X" },
[0x6D] =	{ RM,0,		"PUNPCKHQDQ %x,%X" },
[0x6E] =	{ RM,0,		"MOV%S	%e,%X" },
[0x6F] =	{ RM,0,		"MOVO	%x,%X" },		/* MOVDQA */
[0x70] =	{ RM,Ib,		"PSHUFL	%i,%x,%X" },
[0x71] =	{ RMOP,0,		optab660F71 },
[0x72] =	{ RMOP,0,		optab660F72 },
[0x73] =	{ RMOP,0,		optab660F73 },
[0x7E] =	{ RM,0,		"MOV%S	%X,%e" },
[0x7F] =	{ RM,0,		"MOVO	%X,%x" },
[0xC4] =	{ RM,Ib,		"PINSRW	%i,%e,%X" },
[0xC5] =	{ RMR,Ib,		"PEXTRW	%i,%X,%e" },
[0xD4] =	{ RM,0,		"PADDQ	%x,%X" },
[0xD5] =	{ RM,0,		"PMULLW	%x,%X" },
[0xD6] =	{ RM,0,		"MOVQ	%X,%x" },
[0xE6] =	{ RM,0,		"CVTTPD2PL	%x,%X" },
[0xE7] =	{ RM,0,		"MOVNTO	%X,%e" },
[0xF7] =	{ RM,0,		"MASKMOVOU	%x,%X" },
};

static Optable optabF20F[256]=
{
[0x10] =	{ RM,0,		"MOVSD	%x,%X" },
[0x11] =	{ RM,0,		"MOVSD	%X,%x" },
[0x2A] =	{ RM,0,		"CVTS%S2SD	%e,%X" },
[0x2C] =	{ RM,0,		"CVTTSD2S%S	%x,%r" },
[0x2D] =	{ RM,0,		"CVTSD2S%S	%x,%r" },
[0x5A] =	{ RM,0,		"CVTSD2SS	%x,%X" },
[0x6F] =	{ RM,0,		"MOVOU	%x,%X" },
[0x70] =	{ RM,Ib,		"PSHUFLW	%i,%x,%X" },
[0x7F] =	{ RM,0,		"MOVOU	%X,%x" },
[0xD6] =	{ RM,0,		"MOVQOZX	%M,%X" },
[0xE6] =	{ RM,0,		"CVTPD2PL	%x,%X" },
};

static Optable optabF30F[256]=
{
[0x10] =	{ RM,0,		"MOVSS	%x,%X" },
[0x11] =	{ RM,0,		"MOVSS	%X,%x" },
[0x2A] =	{ RM,0,		"CVTS%S2SS	%e,%X" },
[0x2C] =	{ RM,0,		"CVTTSS2S%S	%x,%r" },
[0x2D] =	{ RM,0,		"CVTSS2S%S	%x,%r" },
[0x5A] =	{ RM,0,		"CVTSS2SD	%x,%X" },
[0x5B] =	{ RM,0,		"CVTTPS2PL	%x,%X" },
[0x6F] =	{ RM,0,		"MOVOU	%x,%X" },
[0x70] =	{ RM,Ib,		"PSHUFHW	%i,%x,%X" },
[0x7E] =	{ RM,0,		"MOVQOZX	%x,%X" },
[0x7F] =	{ RM,0,		"MOVOU	%X,%x" },
[0xD6] =	{ RM,0,		"MOVQOZX	%m*,%X" },
[0xE6] =	{ RM,0,		"CVTPL2PD	%x,%X" },
};

static Optable optab0F[256]=
{
[0x00] =	{ RMOP,0,		optab0F00 },
[0x01] =	{ RMOP,0,		optab0F01 },
[0x02] =	{ RM,0,		"LAR	%e,%r" },
[0x03] =	{ RM,0,		"LSL	%e,%r" },
[0x05] =	{ 0,0,		"SYSCALL" },
[0x06] =	{ 0,0,		"CLTS" },
[0x07] =	{ 0,0,		"SYSRET" },
[0x08] =	{ 0,0,		"INVD" },
[0x09] =	{ 0,0,		"WBINVD" },
[0x0B] =	{ 0,0,		"UD2" },
[0x0F] =	{ RM,AUX,		optab0F0F },		/* 3DNow! */
[0x10] =	{ RM,0,		"MOVU%s	%x,%X" },
[0x11] =	{ RM,0,		"MOVU%s	%X,%x" },
[0x12] =	{ RM,0,		"MOV[H]L%s	%x,%X" },	/* TO DO: H if source is XMM */
[0x13] =	{ RM,0,		"MOVL%s	%X,%e" },
[0x14] =	{ RM,0,		"UNPCKL%s	%x,%X" },
[0x15] =	{ RM,0,		"UNPCKH%s	%x,%X" },
[0x16] =	{ RM,0,		"MOV[L]H%s	%x,%X" },	/* TO DO: L if source is XMM */
[0x17] =	{ RM,0,		"MOVH%s	%X,%x" },
[0x1F] =	{ RM,0,		"NOP%S	%e" },
[0x20] =	{ RMR,0,		"MOVL	%C,%e" },
[0x21] =	{ RMR,0,		"MOVL	%D,%e" },
[0x22] =	{ RMR,0,		"MOVL	%e,%C" },
[0x23] =	{ RMR,0,		"MOVL	%e,%D" },
[0x24] =	{ RMR,0,		"MOVL	%T,%e" },
[0x26] =	{ RMR,0,		"MOVL	%e,%T" },
[0x28] =	{ RM,0,		"MOVA%s	%x,%X" },
[0x29] =	{ RM,0,		"MOVA%s	%X,%x" },
[0x2A] =	{ RM,0,		"CVTPL2%s	%m*,%X" },
[0x2B] =	{ RM,0,		"MOVNT%s	%X,%e" },
[0x2C] =	{ RM,0,		"CVTT%s2PL	%x,%M" },
[0x2D] =	{ RM,0,		"CVT%s2PL	%x,%M" },
[0x2E] =	{ RM,0,		"UCOMISS	%x,%X" },
[0x2F] =	{ RM,0,		"COMISS	%x,%X" },
[0x30] =	{ 0,0,		"WRMSR" },
[0x31] =	{ 0,0,		"RDTSC" },
[0x32] =	{ 0,0,		"RDMSR" },
[0x33] =	{ 0,0,		"RDPMC" },
[0x42] =	{ RM,0,		"CMOVC	%e,%r" },		/* CF */
[0x43] =	{ RM,0,		"CMOVNC	%e,%r" },		/*  CF */
[0x44] =	{ RM,0,		"CMOVZ	%e,%r" },		/* ZF */
[0x45] =	{ RM,0,		"CMOVNZ	%e,%r" },		/*  ZF */
[0x46] =	{ RM,0,		"CMOVBE	%e,%r" },		/* CF  ZF */
[0x47] =	{ RM,0,		"CMOVA	%e,%r" },		/* CF  ZF */
[0x48] =	{ RM,0,		"CMOVS	%e,%r" },		/* SF */
[0x49] =	{ RM,0,		"CMOVNS	%e,%r" },		/*  SF */
[0x4A] =	{ RM,0,		"CMOVP	%e,%r" },		/* PF */
[0x4B] =	{ RM,0,		"CMOVNP	%e,%r" },		/*  PF */
[0x4C] =	{ RM,0,		"CMOVLT	%e,%r" },		/* LT  OF  SF */
[0x4D] =	{ RM,0,		"CMOVGE	%e,%r" },		/* GE  ZF  SF */
[0x4E] =	{ RM,0,		"CMOVLE	%e,%r" },		/* LE  ZF  LT */
[0x4F] =	{ RM,0,		"CMOVGT	%e,%r" },		/* GT  ZF  GE */
[0x50] =	{ RM,0,		"MOVMSK%s	%X,%r" },	/* TO DO: check */
[0x51] =	{ RM,0,		"SQRT%s	%x,%X" },
[0x52] =	{ RM,0,		"RSQRT%s	%x,%X" },
[0x53] =	{ RM,0,		"RCP%s	%x,%X" },
[0x54] =	{ RM,0,		"AND%s	%x,%X" },
[0x55] =	{ RM,0,		"ANDN%s	%x,%X" },
[0x56] =	{ RM,0,		"OR%s	%x,%X" },		/* TO DO: S/D */
[0x57] =	{ RM,0,		"XOR%s	%x,%X" },		/* S/D */
[0x58] =	{ RM,0,		"ADD%s	%x,%X" },		/* S/P S/D */
[0x59] =	{ RM,0,		"MUL%s	%x,%X" },
[0x5A] =	{ RM,0,		"CVTPS2PD	%x,%X" },
[0x5B] =	{ RM,0,		"CVTPL2PS	%x,%X" },
[0x5C] =	{ RM,0,		"SUB%s	%x,%X" },
[0x5D] =	{ RM,0,		"MIN%s	%x,%X" },
[0x5E] =	{ RM,0,		"DIV%s	%x,%X" },		/* TO DO: S/P S/D */
[0x5F] =	{ RM,0,		"MAX%s	%x,%X" },
[0x60] =	{ RM,0,		"PUNPCKLBW %m,%M" },
[0x61] =	{ RM,0,		"PUNPCKLWL %m,%M" },
[0x62] =	{ RM,0,		"PUNPCKLLQ %m,%M" },
[0x63] =	{ RM,0,		"PACKSSWB %m,%M" },
[0x64] =	{ RM,0,		"PCMPGTB %m,%M" },
[0x65] =	{ RM,0,		"PCMPGTW %m,%M" },
[0x66] =	{ RM,0,		"PCMPGTL %m,%M" },
[0x67] =	{ RM,0,		"PACKUSWB %m,%M" },
[0x68] =	{ RM,0,		"PUNPCKHBW %m,%M" },
[0x69] =	{ RM,0,		"PUNPCKHWL %m,%M" },
[0x6A] =	{ RM,0,		"PUNPCKHLQ %m,%M" },
[0x6B] =	{ RM,0,		"PACKSSLW %m,%M" },
[0x6E] =	{ RM,0,		"MOV%S %e,%M" },
[0x6F] =	{ RM,0,		"MOVQ %m,%M" },
[0x70] =	{ RM,Ib,		"PSHUFW	%i,%m,%M" },
[0x74] =	{ RM,0,		"PCMPEQB %m,%M" },
[0x75] =	{ RM,0,		"PCMPEQW %m,%M" },
[0x76] =	{ RM,0,		"PCMPEQL %m,%M" },
[0x77] =	{ 0,0,		"EMMS" },
[0x7E] =	{ RM,0,		"MOV%S %M,%e" },
[0x7F] =	{ RM,0,		"MOVQ %M,%m" },
[0xAE] =	{ RMOP,0,		optab0FAE },
[0xAA] =	{ 0,0,		"RSM" },
[0xB0] =	{ RM,0,		"CMPXCHGB	%r,%e" },
[0xB1] =	{ RM,0,		"CMPXCHG%S	%r,%e" },
[0xC0] =	{ RMB,0,		"XADDB	%r,%e" },
[0xC1] =	{ RM,0,		"XADD%S	%r,%e" },
[0xC2] =	{ RM,Ib,		"CMP%s	%x,%X,%#i" },
[0xC3] =	{ RM,0,		"MOVNTI%S	%r,%e" },
[0xC6] =	{ RM,Ib,		"SHUF%s	%i,%x,%X" },
[0xC8] =	{ 0,0,		"BSWAP	AX" },
[0xC9] =	{ 0,0,		"BSWAP	CX" },
[0xCA] =	{ 0,0,		"BSWAP	DX" },
[0xCB] =	{ 0,0,		"BSWAP	BX" },
[0xCC] =	{ 0,0,		"BSWAP	SP" },
[0xCD] =	{ 0,0,		"BSWAP	BP" },
[0xCE] =	{ 0,0,		"BSWAP	SI" },
[0xCF] =	{ 0,0,		"BSWAP	DI" },
[0xD1] =	{ RM,0,		"PSRLW %m,%M" },
[0xD2] =	{ RM,0,		"PSRLL %m,%M" },
[0xD3] =	{ RM,0,		"PSRLQ %m,%M" },
[0xD5] =	{ RM,0,		"PMULLW %m,%M" },
[0xD6] =	{ RM,0,		"MOVQOZX	%m*,%X" },
[0xD7] =	{ RM,0,		"PMOVMSKB %m,%r" },
[0xD8] =	{ RM,0,		"PSUBUSB %m,%M" },
[0xD9] =	{ RM,0,		"PSUBUSW %m,%M" },
[0xDA] =	{ RM,0,		"PMINUB %m,%M" },
[0xDB] =	{ RM,0,		"PAND %m,%M" },
[0xDC] =	{ RM,0,		"PADDUSB %m,%M" },
[0xDD] =	{ RM,0,		"PADDUSW %m,%M" },
[0xDE] =	{ RM,0,		"PMAXUB %m,%M" },
[0xDF] =	{ RM,0,		"PANDN %m,%M" },
[0xE0] =	{ RM,0,		"PAVGB %m,%M" },
[0xE1] =	{ RM,0,		"PSRAW %m,%M" },
[0xE2] =	{ RM,0,		"PSRAL %m,%M" },
[0xE3] =	{ RM,0,		"PAVGW %m,%M" },
[0xE4] =	{ RM,0,		"PMULHUW %m,%M" },
[0xE5] =	{ RM,0,		"PMULHW %m,%M" },
[0xE7] =	{ RM,0,		"MOVNTQ	%M,%e" },
[0xE8] =	{ RM,0,		"PSUBSB %m,%M" },
[0xE9] =	{ RM,0,		"PSUBSW %m,%M" },
[0xEA] =	{ RM,0,		"PMINSW %m,%M" },
[0xEB] =	{ RM,0,		"POR %m,%M" },
[0xEC] =	{ RM,0,		"PADDSB %m,%M" },
[0xED] =	{ RM,0,		"PADDSW %m,%M" },
[0xEE] =	{ RM,0,		"PMAXSW %m,%M" },
[0xEF] =	{ RM,0,		"PXOR %m,%M" },
[0xF1] =	{ RM,0,		"PSLLW %m,%M" },
[0xF2] =	{ RM,0,		"PSLLL %m,%M" },
[0xF3] =	{ RM,0,		"PSLLQ %m,%M" },
[0xF4] =	{ RM,0,		"PMULULQ	%m,%M" },
[0xF5] =	{ RM,0,		"PMADDWL %m,%M" },
[0xF6] =	{ RM,0,		"PSADBW %m,%M" },
[0xF7] =	{ RMR,0,		"MASKMOVQ	%m,%M" },
[0xF8] =	{ RM,0,		"PSUBB %m,%M" },
[0xF9] =	{ RM,0,		"PSUBW %m,%M" },
[0xFA] =	{ RM,0,		"PSUBL %m,%M" },
[0xFC] =	{ RM,0,		"PADDB %m,%M" },
[0xFD] =	{ RM,0,		"PADDW %m,%M" },
[0xFE] =	{ RM,0,		"PADDL %m,%M" },

[0x80] =	{ Iwds,0,		"JOS	%p" },
[0x81] =	{ Iwds,0,		"JOC	%p" },
[0x82] =	{ Iwds,0,		"JCS	%p" },
[0x83] =	{ Iwds,0,		"JCC	%p" },
[0x84] =	{ Iwds,0,		"JEQ	%p" },
[0x85] =	{ Iwds,0,		"JNE	%p" },
[0x86] =	{ Iwds,0,		"JLS	%p" },
[0x87] =	{ Iwds,0,		"JHI	%p" },
[0x88] =	{ Iwds,0,		"JMI	%p" },
[0x89] =	{ Iwds,0,		"JPL	%p" },
[0x8a] =	{ Iwds,0,		"JPS	%p" },
[0x8b] =	{ Iwds,0,		"JPC	%p" },
[0x8c] =	{ Iwds,0,		"JLT	%p" },
[0x8d] =	{ Iwds,0,		"JGE	%p" },
[0x8e] =	{ Iwds,0,		"JLE	%p" },
[0x8f] =	{ Iwds,0,		"JGT	%p" },
[0x90] =	{ RMB,0,		"SETOS	%e" },
[0x91] =	{ RMB,0,		"SETOC	%e" },
[0x92] =	{ RMB,0,		"SETCS	%e" },
[0x93] =	{ RMB,0,		"SETCC	%e" },
[0x94] =	{ RMB,0,		"SETEQ	%e" },
[0x95] =	{ RMB,0,		"SETNE	%e" },
[0x96] =	{ RMB,0,		"SETLS	%e" },
[0x97] =	{ RMB,0,		"SETHI	%e" },
[0x98] =	{ RMB,0,		"SETMI	%e" },
[0x99] =	{ RMB,0,		"SETPL	%e" },
[0x9a] =	{ RMB,0,		"SETPS	%e" },
[0x9b] =	{ RMB,0,		"SETPC	%e" },
[0x9c] =	{ RMB,0,		"SETLT	%e" },
[0x9d] =	{ RMB,0,		"SETGE	%e" },
[0x9e] =	{ RMB,0,		"SETLE	%e" },
[0x9f] =	{ RMB,0,		"SETGT	%e" },
[0xa0] =	{ 0,0,		"PUSHL	FS" },
[0xa1] =	{ 0,0,		"POPL	FS" },
[0xa2] =	{ 0,0,		"CPUID" },
[0xa3] =	{ RM,0,		"BT%S	%r,%e" },
[0xa4] =	{ RM,Ib,		"SHLD%S	%r,%i,%e" },
[0xa5] =	{ RM,0,		"SHLD%S	%r,CL,%e" },
[0xa8] =	{ 0,0,		"PUSHL	GS" },
[0xa9] =	{ 0,0,		"POPL	GS" },
[0xab] =	{ RM,0,		"BTS%S	%r,%e" },
[0xac] =	{ RM,Ib,		"SHRD%S	%r,%i,%e" },
[0xad] =	{ RM,0,		"SHRD%S	%r,CL,%e" },
[0xaf] =	{ RM,0,		"IMUL%S	%e,%r" },
[0xb2] =	{ RMM,0,		"LSS	%e,%r" },
[0xb3] =	{ RM,0,		"BTR%S	%r,%e" },
[0xb4] =	{ RMM,0,		"LFS	%e,%r" },
[0xb5] =	{ RMM,0,		"LGS	%e,%r" },
[0xb6] =	{ RMB,0,		"MOVBZX	%e,%R" },
[0xb7] =	{ RM,0,		"MOVWZX	%e,%R" },
[0xba] =	{ RMOP,0,		optab0FBA },
[0xbb] =	{ RM,0,		"BTC%S	%e,%r" },
[0xbc] =	{ RM,0,		"BSF%S	%e,%r" },
[0xbd] =	{ RM,0,		"BSR%S	%e,%r" },
[0xbe] =	{ RMB,0,		"MOVBSX	%e,%R" },
[0xbf] =	{ RM,0,		"MOVWSX	%e,%R" },
[0xc7] =	{ RMOP,0,		optab0FC7 },
};

static Optable optab80[8]=
{
[0x00] =	{ Ib,0,		"ADDB	%i,%e" },
[0x01] =	{ Ib,0,		"ORB	%i,%e" },
[0x02] =	{ Ib,0,		"ADCB	%i,%e" },
[0x03] =	{ Ib,0,		"SBBB	%i,%e" },
[0x04] =	{ Ib,0,		"ANDB	%i,%e" },
[0x05] =	{ Ib,0,		"SUBB	%i,%e" },
[0x06] =	{ Ib,0,		"XORB	%i,%e" },
[0x07] =	{ Ib,0,		"CMPB	%e,%i" },
};

static Optable optab81[8]=
{
[0x00] =	{ Iwd,0,		"ADD%S	%i,%e" },
[0x01] =	{ Iwd,0,		"OR%S	%i,%e" },
[0x02] =	{ Iwd,0,		"ADC%S	%i,%e" },
[0x03] =	{ Iwd,0,		"SBB%S	%i,%e" },
[0x04] =	{ Iwd,0,		"AND%S	%i,%e" },
[0x05] =	{ Iwd,0,		"SUB%S	%i,%e" },
[0x06] =	{ Iwd,0,		"XOR%S	%i,%e" },
[0x07] =	{ Iwd,0,		"CMP%S	%e,%i" },
};

static Optable optab83[8]=
{
[0x00] =	{ Ibs,0,		"ADD%S	%i,%e" },
[0x01] =	{ Ibs,0,		"OR%S	%i,%e" },
[0x02] =	{ Ibs,0,		"ADC%S	%i,%e" },
[0x03] =	{ Ibs,0,		"SBB%S	%i,%e" },
[0x04] =	{ Ibs,0,		"AND%S	%i,%e" },
[0x05] =	{ Ibs,0,		"SUB%S	%i,%e" },
[0x06] =	{ Ibs,0,		"XOR%S	%i,%e" },
[0x07] =	{ Ibs,0,		"CMP%S	%e,%i" },
};

static Optable optabC0[8] =
{
[0x00] =	{ Ib,0,		"ROLB	%i,%e" },
[0x01] =	{ Ib,0,		"RORB	%i,%e" },
[0x02] =	{ Ib,0,		"RCLB	%i,%e" },
[0x03] =	{ Ib,0,		"RCRB	%i,%e" },
[0x04] =	{ Ib,0,		"SHLB	%i,%e" },
[0x05] =	{ Ib,0,		"SHRB	%i,%e" },
[0x07] =	{ Ib,0,		"SARB	%i,%e" },
};

static Optable optabC1[8] =
{
[0x00] =	{ Ib,0,		"ROL%S	%i,%e" },
[0x01] =	{ Ib,0,		"ROR%S	%i,%e" },
[0x02] =	{ Ib,0,		"RCL%S	%i,%e" },
[0x03] =	{ Ib,0,		"RCR%S	%i,%e" },
[0x04] =	{ Ib,0,		"SHL%S	%i,%e" },
[0x05] =	{ Ib,0,		"SHR%S	%i,%e" },
[0x07] =	{ Ib,0,		"SAR%S	%i,%e" },
};

static Optable optabD0[8] =
{
[0x00] =	{ 0,0,		"ROLB	%e" },
[0x01] =	{ 0,0,		"RORB	%e" },
[0x02] =	{ 0,0,		"RCLB	%e" },
[0x03] =	{ 0,0,		"RCRB	%e" },
[0x04] =	{ 0,0,		"SHLB	%e" },
[0x05] =	{ 0,0,		"SHRB	%e" },
[0x07] =	{ 0,0,		"SARB	%e" },
};

static Optable optabD1[8] =
{
[0x00] =	{ 0,0,		"ROL%S	%e" },
[0x01] =	{ 0,0,		"ROR%S	%e" },
[0x02] =	{ 0,0,		"RCL%S	%e" },
[0x03] =	{ 0,0,		"RCR%S	%e" },
[0x04] =	{ 0,0,		"SHL%S	%e" },
[0x05] =	{ 0,0,		"SHR%S	%e" },
[0x07] =	{ 0,0,		"SAR%S	%e" },
};

static Optable optabD2[8] =
{
[0x00] =	{ 0,0,		"ROLB	CL,%e" },
[0x01] =	{ 0,0,		"RORB	CL,%e" },
[0x02] =	{ 0,0,		"RCLB	CL,%e" },
[0x03] =	{ 0,0,		"RCRB	CL,%e" },
[0x04] =	{ 0,0,		"SHLB	CL,%e" },
[0x05] =	{ 0,0,		"SHRB	CL,%e" },
[0x07] =	{ 0,0,		"SARB	CL,%e" },
};

static Optable optabD3[8] =
{
[0x00] =	{ 0,0,		"ROL%S	CL,%e" },
[0x01] =	{ 0,0,		"ROR%S	CL,%e" },
[0x02] =	{ 0,0,		"RCL%S	CL,%e" },
[0x03] =	{ 0,0,		"RCR%S	CL,%e" },
[0x04] =	{ 0,0,		"SHL%S	CL,%e" },
[0x05] =	{ 0,0,		"SHR%S	CL,%e" },
[0x07] =	{ 0,0,		"SAR%S	CL,%e" },
};

static Optable optabD8[8+8] =
{
[0x00] =	{ 0,0,		"FADDF	%e,F0" },
[0x01] =	{ 0,0,		"FMULF	%e,F0" },
[0x02] =	{ 0,0,		"FCOMF	%e,F0" },
[0x03] =	{ 0,0,		"FCOMFP	%e,F0" },
[0x04] =	{ 0,0,		"FSUBF	%e,F0" },
[0x05] =	{ 0,0,		"FSUBRF	%e,F0" },
[0x06] =	{ 0,0,		"FDIVF	%e,F0" },
[0x07] =	{ 0,0,		"FDIVRF	%e,F0" },
[0x08] =	{ 0,0,		"FADDD	%f,F0" },
[0x09] =	{ 0,0,		"FMULD	%f,F0" },
[0x0a] =	{ 0,0,		"FCOMD	%f,F0" },
[0x0b] =	{ 0,0,		"FCOMPD	%f,F0" },
[0x0c] =	{ 0,0,		"FSUBD	%f,F0" },
[0x0d] =	{ 0,0,		"FSUBRD	%f,F0" },
[0x0e] =	{ 0,0,		"FDIVD	%f,F0" },
[0x0f] =	{ 0,0,		"FDIVRD	%f,F0" },
};
/*
 *	optabD9 and optabDB use the following encoding:
 *	if (0 <= modrm <= 2) instruction = optabDx[modrm&0x07];
 *	else instruction = optabDx[(modrm&0x3f)+8];
 *
 *	the instructions for MOD == 3, follow the 8 instructions
 *	for the other MOD values stored at the front of the table.
 */
static Optable optabD9[64+8] =
{
[0x00] =	{ 0,0,		"FMOVF	%e,F0" },
[0x02] =	{ 0,0,		"FMOVF	F0,%e" },
[0x03] =	{ 0,0,		"FMOVFP	F0,%e" },
[0x04] =	{ 0,0,		"FLDENV%S %e" },
[0x05] =	{ 0,0,		"FLDCW	%e" },
[0x06] =	{ 0,0,		"FSTENV%S %e" },
[0x07] =	{ 0,0,		"FSTCW	%e" },
[0x08] =	{ 0,0,		"FMOVD	F0,F0" },		/* Mod R/M = 11xx xxxx*/
[0x09] =	{ 0,0,		"FMOVD	F1,F0" },
[0x0a] =	{ 0,0,		"FMOVD	F2,F0" },
[0x0b] =	{ 0,0,		"FMOVD	F3,F0" },
[0x0c] =	{ 0,0,		"FMOVD	F4,F0" },
[0x0d] =	{ 0,0,		"FMOVD	F5,F0" },
[0x0e] =	{ 0,0,		"FMOVD	F6,F0" },
[0x0f] =	{ 0,0,		"FMOVD	F7,F0" },
[0x10] =	{ 0,0,		"FXCHD	F0,F0" },
[0x11] =	{ 0,0,		"FXCHD	F1,F0" },
[0x12] =	{ 0,0,		"FXCHD	F2,F0" },
[0x13] =	{ 0,0,		"FXCHD	F3,F0" },
[0x14] =	{ 0,0,		"FXCHD	F4,F0" },
[0x15] =	{ 0,0,		"FXCHD	F5,F0" },
[0x16] =	{ 0,0,		"FXCHD	F6,F0" },
[0x17] =	{ 0,0,		"FXCHD	F7,F0" },
[0x18] =	{ 0,0,		"FNOP" },
[0x28] =	{ 0,0,		"FCHS" },
[0x29] =	{ 0,0,		"FABS" },
[0x2c] =	{ 0,0,		"FTST" },
[0x2d] =	{ 0,0,		"FXAM" },
[0x30] =	{ 0,0,		"FLD1" },
[0x31] =	{ 0,0,		"FLDL2T" },
[0x32] =	{ 0,0,		"FLDL2E" },
[0x33] =	{ 0,0,		"FLDPI" },
[0x34] =	{ 0,0,		"FLDLG2" },
[0x35] =	{ 0,0,		"FLDLN2" },
[0x36] =	{ 0,0,		"FLDZ" },
[0x38] =	{ 0,0,		"F2XM1" },
[0x39] =	{ 0,0,		"FYL2X" },
[0x3a] =	{ 0,0,		"FPTAN" },
[0x3b] =	{ 0,0,		"FPATAN" },
[0x3c] =	{ 0,0,		"FXTRACT" },
[0x3d] =	{ 0,0,		"FPREM1" },
[0x3e] =	{ 0,0,		"FDECSTP" },
[0x3f] =	{ 0,0,		"FNCSTP" },
[0x40] =	{ 0,0,		"FPREM" },
[0x41] =	{ 0,0,		"FYL2XP1" },
[0x42] =	{ 0,0,		"FSQRT" },
[0x43] =	{ 0,0,		"FSINCOS" },
[0x44] =	{ 0,0,		"FRNDINT" },
[0x45] =	{ 0,0,		"FSCALE" },
[0x46] =	{ 0,0,		"FSIN" },
[0x47] =	{ 0,0,		"FCOS" },
};

static Optable optabDA[8+8] =
{
[0x00] =	{ 0,0,		"FADDL	%e,F0" },
[0x01] =	{ 0,0,		"FMULL	%e,F0" },
[0x02] =	{ 0,0,		"FCOML	%e,F0" },
[0x03] =	{ 0,0,		"FCOMLP	%e,F0" },
[0x04] =	{ 0,0,		"FSUBL	%e,F0" },
[0x05] =	{ 0,0,		"FSUBRL	%e,F0" },
[0x06] =	{ 0,0,		"FDIVL	%e,F0" },
[0x07] =	{ 0,0,		"FDIVRL	%e,F0" },
[0x08] =	{ 0,0,		"FCMOVCS	%f,F0" },
[0x09] =	{ 0,0,		"FCMOVEQ	%f,F0" },
[0x0a] =	{ 0,0,		"FCMOVLS	%f,F0" },
[0x0b] =	{ 0,0,		"FCMOVUN	%f,F0" },
[0x0d] =	{ Op_R1,0,		"FUCOMPP" },
};

static Optable optabDB[8+64] =
{
[0x00] =	{ 0,0,		"FMOVL	%e,F0" },
[0x02] =	{ 0,0,		"FMOVL	F0,%e" },
[0x03] =	{ 0,0,		"FMOVLP	F0,%e" },
[0x05] =	{ 0,0,		"FMOVX	%e,F0" },
[0x07] =	{ 0,0,		"FMOVXP	F0,%e" },
[0x08] =	{ 0,0,		"FCMOVCC	F0,F0" },	/* Mod R/M = 11xx xxxx*/
[0x09] =	{ 0,0,		"FCMOVCC	F1,F0" },
[0x0a] =	{ 0,0,		"FCMOVCC	F2,F0" },
[0x0b] =	{ 0,0,		"FCMOVCC	F3,F0" },
[0x0c] =	{ 0,0,		"FCMOVCC	F4,F0" },
[0x0d] =	{ 0,0,		"FCMOVCC	F5,F0" },
[0x0e] =	{ 0,0,		"FCMOVCC	F6,F0" },
[0x0f] =	{ 0,0,		"FCMOVCC	F7,F0" },
[0x10] =	{ 0,0,		"FCMOVNE	F0,F0" },
[0x11] =	{ 0,0,		"FCMOVNE	F1,F0" },
[0x12] =	{ 0,0,		"FCMOVNE	F2,F0" },
[0x13] =	{ 0,0,		"FCMOVNE	F3,F0" },
[0x14] =	{ 0,0,		"FCMOVNE	F4,F0" },
[0x15] =	{ 0,0,		"FCMOVNE	F5,F0" },
[0x16] =	{ 0,0,		"FCMOVNE	F6,F0" },
[0x17] =	{ 0,0,		"FCMOVNE	F7,F0" },
[0x18] =	{ 0,0,		"FCMOVHI	F0,F0" },
[0x19] =	{ 0,0,		"FCMOVHI	F1,F0" },
[0x1a] =	{ 0,0,		"FCMOVHI	F2,F0" },
[0x1b] =	{ 0,0,		"FCMOVHI	F3,F0" },
[0x1c] =	{ 0,0,		"FCMOVHI	F4,F0" },
[0x1d] =	{ 0,0,		"FCMOVHI	F5,F0" },
[0x1e] =	{ 0,0,		"FCMOVHI	F6,F0" },
[0x1f] =	{ 0,0,		"FCMOVHI	F7,F0" },
[0x20] =	{ 0,0,		"FCMOVNU	F0,F0" },
[0x21] =	{ 0,0,		"FCMOVNU	F1,F0" },
[0x22] =	{ 0,0,		"FCMOVNU	F2,F0" },
[0x23] =	{ 0,0,		"FCMOVNU	F3,F0" },
[0x24] =	{ 0,0,		"FCMOVNU	F4,F0" },
[0x25] =	{ 0,0,		"FCMOVNU	F5,F0" },
[0x26] =	{ 0,0,		"FCMOVNU	F6,F0" },
[0x27] =	{ 0,0,		"FCMOVNU	F7,F0" },
[0x2a] =	{ 0,0,		"FCLEX" },
[0x2b] =	{ 0,0,		"FINIT" },
[0x30] =	{ 0,0,		"FUCOMI	F0,F0" },
[0x31] =	{ 0,0,		"FUCOMI	F1,F0" },
[0x32] =	{ 0,0,		"FUCOMI	F2,F0" },
[0x33] =	{ 0,0,		"FUCOMI	F3,F0" },
[0x34] =	{ 0,0,		"FUCOMI	F4,F0" },
[0x35] =	{ 0,0,		"FUCOMI	F5,F0" },
[0x36] =	{ 0,0,		"FUCOMI	F6,F0" },
[0x37] =	{ 0,0,		"FUCOMI	F7,F0" },
[0x38] =	{ 0,0,		"FCOMI	F0,F0" },
[0x39] =	{ 0,0,		"FCOMI	F1,F0" },
[0x3a] =	{ 0,0,		"FCOMI	F2,F0" },
[0x3b] =	{ 0,0,		"FCOMI	F3,F0" },
[0x3c] =	{ 0,0,		"FCOMI	F4,F0" },
[0x3d] =	{ 0,0,		"FCOMI	F5,F0" },
[0x3e] =	{ 0,0,		"FCOMI	F6,F0" },
[0x3f] =	{ 0,0,		"FCOMI	F7,F0" },
};

static Optable optabDC[8+8] =
{
[0x00] =	{ 0,0,		"FADDD	%e,F0" },
[0x01] =	{ 0,0,		"FMULD	%e,F0" },
[0x02] =	{ 0,0,		"FCOMD	%e,F0" },
[0x03] =	{ 0,0,		"FCOMDP	%e,F0" },
[0x04] =	{ 0,0,		"FSUBD	%e,F0" },
[0x05] =	{ 0,0,		"FSUBRD	%e,F0" },
[0x06] =	{ 0,0,		"FDIVD	%e,F0" },
[0x07] =	{ 0,0,		"FDIVRD	%e,F0" },
[0x08] =	{ 0,0,		"FADDD	F0,%f" },
[0x09] =	{ 0,0,		"FMULD	F0,%f" },
[0x0c] =	{ 0,0,		"FSUBRD	F0,%f" },
[0x0d] =	{ 0,0,		"FSUBD	F0,%f" },
[0x0e] =	{ 0,0,		"FDIVRD	F0,%f" },
[0x0f] =	{ 0,0,		"FDIVD	F0,%f" },
};

static Optable optabDD[8+8] =
{
[0x00] =	{ 0,0,		"FMOVD	%e,F0" },
[0x02] =	{ 0,0,		"FMOVD	F0,%e" },
[0x03] =	{ 0,0,		"FMOVDP	F0,%e" },
[0x04] =	{ 0,0,		"FRSTOR%S %e" },
[0x06] =	{ 0,0,		"FSAVE%S %e" },
[0x07] =	{ 0,0,		"FSTSW	%e" },
[0x08] =	{ 0,0,		"FFREED	%f" },
[0x0a] =	{ 0,0,		"FMOVD	%f,F0" },
[0x0b] =	{ 0,0,		"FMOVDP	%f,F0" },
[0x0c] =	{ 0,0,		"FUCOMD	%f,F0" },
[0x0d] =	{ 0,0,		"FUCOMDP %f,F0" },
};

static Optable optabDE[8+8] =
{
[0x00] =	{ 0,0,		"FADDW	%e,F0" },
[0x01] =	{ 0,0,		"FMULW	%e,F0" },
[0x02] =	{ 0,0,		"FCOMW	%e,F0" },
[0x03] =	{ 0,0,		"FCOMWP	%e,F0" },
[0x04] =	{ 0,0,		"FSUBW	%e,F0" },
[0x05] =	{ 0,0,		"FSUBRW	%e,F0" },
[0x06] =	{ 0,0,		"FDIVW	%e,F0" },
[0x07] =	{ 0,0,		"FDIVRW	%e,F0" },
[0x08] =	{ 0,0,		"FADDDP	F0,%f" },
[0x09] =	{ 0,0,		"FMULDP	F0,%f" },
[0x0b] =	{ Op_R1,0,		"FCOMPDP" },
[0x0c] =	{ 0,0,		"FSUBRDP F0,%f" },
[0x0d] =	{ 0,0,		"FSUBDP	F0,%f" },
[0x0e] =	{ 0,0,		"FDIVRDP F0,%f" },
[0x0f] =	{ 0,0,		"FDIVDP	F0,%f" },
};

static Optable optabDF[8+8] =
{
[0x00] =	{ 0,0,		"FMOVW	%e,F0" },
[0x02] =	{ 0,0,		"FMOVW	F0,%e" },
[0x03] =	{ 0,0,		"FMOVWP	F0,%e" },
[0x04] =	{ 0,0,		"FBLD	%e" },
[0x05] =	{ 0,0,		"FMOVL	%e,F0" },
[0x06] =	{ 0,0,		"FBSTP	%e" },
[0x07] =	{ 0,0,		"FMOVLP	F0,%e" },
[0x0c] =	{ Op_R0,0,		"FSTSW	%OAX" },
[0x0d] =	{ 0,0,		"FUCOMIP	F0,%f" },
[0x0e] =	{ 0,0,		"FCOMIP	F0,%f" },
};

static Optable optabF6[8] =
{
[0x00] =	{ Ib,0,		"TESTB	%i,%e" },
[0x02] =	{ 0,0,		"NOTB	%e" },
[0x03] =	{ 0,0,		"NEGB	%e" },
[0x04] =	{ 0,0,		"MULB	AL,%e" },
[0x05] =	{ 0,0,		"IMULB	AL,%e" },
[0x06] =	{ 0,0,		"DIVB	AL,%e" },
[0x07] =	{ 0,0,		"IDIVB	AL,%e" },
};

static Optable optabF7[8] =
{
[0x00] =	{ Iwd,0,		"TEST%S	%i,%e" },
[0x02] =	{ 0,0,		"NOT%S	%e" },
[0x03] =	{ 0,0,		"NEG%S	%e" },
[0x04] =	{ 0,0,		"MUL%S	%OAX,%e" },
[0x05] =	{ 0,0,		"IMUL%S	%OAX,%e" },
[0x06] =	{ 0,0,		"DIV%S	%OAX,%e" },
[0x07] =	{ 0,0,		"IDIV%S	%OAX,%e" },
};

static Optable optabFE[8] =
{
[0x00] =	{ 0,0,		"INCB	%e" },
[0x01] =	{ 0,0,		"DECB	%e" },
};

static Optable optabFF[8] =
{
[0x00] =	{ 0,0,		"INC%S	%e" },
[0x01] =	{ 0,0,		"DEC%S	%e" },
[0x02] =	{ JUMP,0,		"CALL*	%e" },
[0x03] =	{ JUMP,0,		"CALLF*	%e" },
[0x04] =	{ JUMP,0,		"JMP*	%e" },
[0x05] =	{ JUMP,0,		"JMPF*	%e" },
[0x06] =	{ 0,0,		"PUSHL	%e" },
};

static Optable optable[256+2] =
{
[0x00] =	{ RMB,0,		"ADDB	%r,%e" },
[0x01] =	{ RM,0,		"ADD%S	%r,%e" },
[0x02] =	{ RMB,0,		"ADDB	%e,%r" },
[0x03] =	{ RM,0,		"ADD%S	%e,%r" },
[0x04] =	{ Ib,0,		"ADDB	%i,AL" },
[0x05] =	{ Iwd,0,		"ADD%S	%i,%OAX" },
[0x06] =	{ 0,0,		"PUSHL	ES" },
[0x07] =	{ 0,0,		"POPL	ES" },
[0x08] =	{ RMB,0,		"ORB	%r,%e" },
[0x09] =	{ RM,0,		"OR%S	%r,%e" },
[0x0a] =	{ RMB,0,		"ORB	%e,%r" },
[0x0b] =	{ RM,0,		"OR%S	%e,%r" },
[0x0c] =	{ Ib,0,		"ORB	%i,AL" },
[0x0d] =	{ Iwd,0,		"OR%S	%i,%OAX" },
[0x0e] =	{ 0,0,		"PUSHL	CS" },
[0x0f] =	{ AUXMM,0,	optab0F },
[0x10] =	{ RMB,0,		"ADCB	%r,%e" },
[0x11] =	{ RM,0,		"ADC%S	%r,%e" },
[0x12] =	{ RMB,0,		"ADCB	%e,%r" },
[0x13] =	{ RM,0,		"ADC%S	%e,%r" },
[0x14] =	{ Ib,0,		"ADCB	%i,AL" },
[0x15] =	{ Iwd,0,		"ADC%S	%i,%OAX" },
[0x16] =	{ 0,0,		"PUSHL	SS" },
[0x17] =	{ 0,0,		"POPL	SS" },
[0x18] =	{ RMB,0,		"SBBB	%r,%e" },
[0x19] =	{ RM,0,		"SBB%S	%r,%e" },
[0x1a] =	{ RMB,0,		"SBBB	%e,%r" },
[0x1b] =	{ RM,0,		"SBB%S	%e,%r" },
[0x1c] =	{ Ib,0,		"SBBB	%i,AL" },
[0x1d] =	{ Iwd,0,		"SBB%S	%i,%OAX" },
[0x1e] =	{ 0,0,		"PUSHL	DS" },
[0x1f] =	{ 0,0,		"POPL	DS" },
[0x20] =	{ RMB,0,		"ANDB	%r,%e" },
[0x21] =	{ RM,0,		"AND%S	%r,%e" },
[0x22] =	{ RMB,0,		"ANDB	%e,%r" },
[0x23] =	{ RM,0,		"AND%S	%e,%r" },
[0x24] =	{ Ib,0,		"ANDB	%i,AL" },
[0x25] =	{ Iwd,0,		"AND%S	%i,%OAX" },
[0x26] =	{ SEG,0,		"ES:" },
[0x27] =	{ 0,0,		"DAA" },
[0x28] =	{ RMB,0,		"SUBB	%r,%e" },
[0x29] =	{ RM,0,		"SUB%S	%r,%e" },
[0x2a] =	{ RMB,0,		"SUBB	%e,%r" },
[0x2b] =	{ RM,0,		"SUB%S	%e,%r" },
[0x2c] =	{ Ib,0,		"SUBB	%i,AL" },
[0x2d] =	{ Iwd,0,		"SUB%S	%i,%OAX" },
[0x2e] =	{ SEG,0,		"CS:" },
[0x2f] =	{ 0,0,		"DAS" },
[0x30] =	{ RMB,0,		"XORB	%r,%e" },
[0x31] =	{ RM,0,		"XOR%S	%r,%e" },
[0x32] =	{ RMB,0,		"XORB	%e,%r" },
[0x33] =	{ RM,0,		"XOR%S	%e,%r" },
[0x34] =	{ Ib,0,		"XORB	%i,AL" },
[0x35] =	{ Iwd,0,		"XOR%S	%i,%OAX" },
[0x36] =	{ SEG,0,		"SS:" },
[0x37] =	{ 0,0,		"AAA" },
[0x38] =	{ RMB,0,		"CMPB	%r,%e" },
[0x39] =	{ RM,0,		"CMP%S	%r,%e" },
[0x3a] =	{ RMB,0,		"CMPB	%e,%r" },
[0x3b] =	{ RM,0,		"CMP%S	%e,%r" },
[0x3c] =	{ Ib,0,		"CMPB	%i,AL" },
[0x3d] =	{ Iwd,0,		"CMP%S	%i,%OAX" },
[0x3e] =	{ SEG,0,		"DS:" },
[0x3f] =	{ 0,0,		"AAS" },
[0x40] =	{ 0,0,		"INC%S	%OAX" },
[0x41] =	{ 0,0,		"INC%S	%OCX" },
[0x42] =	{ 0,0,		"INC%S	%ODX" },
[0x43] =	{ 0,0,		"INC%S	%OBX" },
[0x44] =	{ 0,0,		"INC%S	%OSP" },
[0x45] =	{ 0,0,		"INC%S	%OBP" },
[0x46] =	{ 0,0,		"INC%S	%OSI" },
[0x47] =	{ 0,0,		"INC%S	%ODI" },
[0x48] =	{ 0,0,		"DEC%S	%OAX" },
[0x49] =	{ 0,0,		"DEC%S	%OCX" },
[0x4a] =	{ 0,0,		"DEC%S	%ODX" },
[0x4b] =	{ 0,0,		"DEC%S	%OBX" },
[0x4c] =	{ 0,0,		"DEC%S	%OSP" },
[0x4d] =	{ 0,0,		"DEC%S	%OBP" },
[0x4e] =	{ 0,0,		"DEC%S	%OSI" },
[0x4f] =	{ 0,0,		"DEC%S	%ODI" },
[0x50] =	{ 0,0,		"PUSH%S	%OAX" },
[0x51] =	{ 0,0,		"PUSH%S	%OCX" },
[0x52] =	{ 0,0,		"PUSH%S	%ODX" },
[0x53] =	{ 0,0,		"PUSH%S	%OBX" },
[0x54] =	{ 0,0,		"PUSH%S	%OSP" },
[0x55] =	{ 0,0,		"PUSH%S	%OBP" },
[0x56] =	{ 0,0,		"PUSH%S	%OSI" },
[0x57] =	{ 0,0,		"PUSH%S	%ODI" },
[0x58] =	{ 0,0,		"POP%S	%OAX" },
[0x59] =	{ 0,0,		"POP%S	%OCX" },
[0x5a] =	{ 0,0,		"POP%S	%ODX" },
[0x5b] =	{ 0,0,		"POP%S	%OBX" },
[0x5c] =	{ 0,0,		"POP%S	%OSP" },
[0x5d] =	{ 0,0,		"POP%S	%OBP" },
[0x5e] =	{ 0,0,		"POP%S	%OSI" },
[0x5f] =	{ 0,0,		"POP%S	%ODI" },
[0x60] =	{ 0,0,		"PUSHA%S" },
[0x61] =	{ 0,0,		"POPA%S" },
[0x62] =	{ RMM,0,		"BOUND	%e,%r" },
[0x63] =	{ RM,0,		"ARPL	%r,%e" },
[0x64] =	{ SEG,0,		"FS:" },
[0x65] =	{ SEG,0,		"GS:" },
[0x66] =	{ OPOVER,0,	"" },
[0x67] =	{ ADDOVER,0,	"" },
[0x68] =	{ Iwd,0,		"PUSH%S	%i" },
[0x69] =	{ RM,Iwd,		"IMUL%S	%e,%i,%r" },
[0x6a] =	{ Ib,0,		"PUSH%S	%i" },
[0x6b] =	{ RM,Ibs,		"IMUL%S	%e,%i,%r" },
[0x6c] =	{ 0,0,		"INSB	DX,(%ODI)" },
[0x6d] =	{ 0,0,		"INS%S	DX,(%ODI)" },
[0x6e] =	{ 0,0,		"OUTSB	(%ASI),DX" },
[0x6f] =	{ 0,0,		"OUTS%S	(%ASI),DX" },
[0x70] =	{ Jbs,0,		"JOS	%p" },
[0x71] =	{ Jbs,0,		"JOC	%p" },
[0x72] =	{ Jbs,0,		"JCS	%p" },
[0x73] =	{ Jbs,0,		"JCC	%p" },
[0x74] =	{ Jbs,0,		"JEQ	%p" },
[0x75] =	{ Jbs,0,		"JNE	%p" },
[0x76] =	{ Jbs,0,		"JLS	%p" },
[0x77] =	{ Jbs,0,		"JHI	%p" },
[0x78] =	{ Jbs,0,		"JMI	%p" },
[0x79] =	{ Jbs,0,		"JPL	%p" },
[0x7a] =	{ Jbs,0,		"JPS	%p" },
[0x7b] =	{ Jbs,0,		"JPC	%p" },
[0x7c] =	{ Jbs,0,		"JLT	%p" },
[0x7d] =	{ Jbs,0,		"JGE	%p" },
[0x7e] =	{ Jbs,0,		"JLE	%p" },
[0x7f] =	{ Jbs,0,		"JGT	%p" },
[0x80] =	{ RMOPB,0,	optab80 },
[0x81] =	{ RMOP,0,		optab81 },
[0x83] =	{ RMOP,0,		optab83 },
[0x84] =	{ RMB,0,		"TESTB	%r,%e" },
[0x85] =	{ RM,0,		"TEST%S	%r,%e" },
[0x86] =	{ RMB,0,		"XCHGB	%r,%e" },
[0x87] =	{ RM,0,		"XCHG%S	%r,%e" },
[0x88] =	{ RMB,0,		"MOVB	%r,%e" },
[0x89] =	{ RM,0,		"MOV%S	%r,%e" },
[0x8a] =	{ RMB,0,		"MOVB	%e,%r" },
[0x8b] =	{ RM,0,		"MOV%S	%e,%r" },
[0x8c] =	{ RM,0,		"MOVW	%g,%e" },
[0x8d] =	{ RM,0,		"LEA%S	%e,%r" },
[0x8e] =	{ RM,0,		"MOVW	%e,%g" },
[0x8f] =	{ RM,0,		"POP%S	%e" },
[0x90] =	{ 0,0,		"NOP" },
[0x91] =	{ 0,0,		"XCHG	%OCX,%OAX" },
[0x92] =	{ 0,0,		"XCHG	%ODX,%OAX" },
[0x93] =	{ 0,0,		"XCHG	%OBX,%OAX" },
[0x94] =	{ 0,0,		"XCHG	%OSP,%OAX" },
[0x95] =	{ 0,0,		"XCHG	%OBP,%OAX" },
[0x96] =	{ 0,0,		"XCHG	%OSI,%OAX" },
[0x97] =	{ 0,0,		"XCHG	%ODI,%OAX" },
[0x98] =	{ 0,0,		"%W" },			/* miserable CBW or CWDE */
[0x99] =	{ 0,0,		"%w" },			/* idiotic CWD or CDQ */
[0x9a] =	{ PTR,0,		"CALL%S	%d" },
[0x9b] =	{ 0,0,		"WAIT" },
[0x9c] =	{ 0,0,		"PUSHF" },
[0x9d] =	{ 0,0,		"POPF" },
[0x9e] =	{ 0,0,		"SAHF" },
[0x9f] =	{ 0,0,		"LAHF" },
[0xa0] =	{ Awd,0,		"MOVB	%i,AL" },
[0xa1] =	{ Awd,0,		"MOV%S	%i,%OAX" },
[0xa2] =	{ Awd,0,		"MOVB	AL,%i" },
[0xa3] =	{ Awd,0,		"MOV%S	%OAX,%i" },
[0xa4] =	{ 0,0,		"MOVSB	(%ASI),(%ADI)" },
[0xa5] =	{ 0,0,		"MOVS%S	(%ASI),(%ADI)" },
[0xa6] =	{ 0,0,		"CMPSB	(%ASI),(%ADI)" },
[0xa7] =	{ 0,0,		"CMPS%S	(%ASI),(%ADI)" },
[0xa8] =	{ Ib,0,		"TESTB	%i,AL" },
[0xa9] =	{ Iwd,0,		"TEST%S	%i,%OAX" },
[0xaa] =	{ 0,0,		"STOSB	AL,(%ADI)" },
[0xab] =	{ 0,0,		"STOS%S	%OAX,(%ADI)" },
[0xac] =	{ 0,0,		"LODSB	(%ASI),AL" },
[0xad] =	{ 0,0,		"LODS%S	(%ASI),%OAX" },
[0xae] =	{ 0,0,		"SCASB	(%ADI),AL" },
[0xaf] =	{ 0,0,		"SCAS%S	(%ADI),%OAX" },
[0xb0] =	{ Ib,0,		"MOVB	%i,AL" },
[0xb1] =	{ Ib,0,		"MOVB	%i,CL" },
[0xb2] =	{ Ib,0,		"MOVB	%i,DL" },
[0xb3] =	{ Ib,0,		"MOVB	%i,BL" },
[0xb4] =	{ Ib,0,		"MOVB	%i,AH" },
[0xb5] =	{ Ib,0,		"MOVB	%i,CH" },
[0xb6] =	{ Ib,0,		"MOVB	%i,DH" },
[0xb7] =	{ Ib,0,		"MOVB	%i,BH" },
[0xb8] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xb9] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xba] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xbb] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xbc] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xbd] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xbe] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xbf] =	{ Iwdq,0,		"MOV%S	%i,%o" },
[0xc0] =	{ RMOPB,0,	optabC0 },
[0xc1] =	{ RMOP,0,		optabC1 },
[0xc2] =	{ Iw,0,		"RET	%i" },
[0xc3] =	{ RET,0,		"RET" },
[0xc4] =	{ RM,0,		"LES	%e,%r" },
[0xc5] =	{ RM,0,		"LDS	%e,%r" },
[0xc6] =	{ RMB,Ib,		"MOVB	%i,%e" },
[0xc7] =	{ RM,Iwd,		"MOV%S	%i,%e" },
[0xc8] =	{ Iw2,Ib,		"ENTER	%i,%I" },		/* loony ENTER */
[0xc9] =	{ RET,0,		"LEAVE" },		/* bizarre LEAVE */
[0xca] =	{ Iw,0,		"RETF	%i" },
[0xcb] =	{ RET,0,		"RETF" },
[0xcc] =	{ 0,0,		"INT	3" },
[0xcd] =	{ Ib,0,		"INTB	%i" },
[0xce] =	{ 0,0,		"INTO" },
[0xcf] =	{ 0,0,		"IRET" },
[0xd0] =	{ RMOPB,0,	optabD0 },
[0xd1] =	{ RMOP,0,		optabD1 },
[0xd2] =	{ RMOPB,0,	optabD2 },
[0xd3] =	{ RMOP,0,		optabD3 },
[0xd4] =	{ OA,0,		"AAM" },
[0xd5] =	{ OA,0,		"AAD" },
[0xd7] =	{ 0,0,		"XLAT" },
[0xd8] =	{ FRMOP,0,	optabD8 },
[0xd9] =	{ FRMEX,0,	optabD9 },
[0xda] =	{ FRMOP,0,	optabDA },
[0xdb] =	{ FRMEX,0,	optabDB },
[0xdc] =	{ FRMOP,0,	optabDC },
[0xdd] =	{ FRMOP,0,	optabDD },
[0xde] =	{ FRMOP,0,	optabDE },
[0xdf] =	{ FRMOP,0,	optabDF },
[0xe0] =	{ Jbs,0,		"LOOPNE	%p" },
[0xe1] =	{ Jbs,0,		"LOOPE	%p" },
[0xe2] =	{ Jbs,0,		"LOOP	%p" },
[0xe3] =	{ Jbs,0,		"JCXZ	%p" },
[0xe4] =	{ Ib,0,		"INB	%i,AL" },
[0xe5] =	{ Ib,0,		"IN%S	%i,%OAX" },
[0xe6] =	{ Ib,0,		"OUTB	AL,%i" },
[0xe7] =	{ Ib,0,		"OUT%S	%OAX,%i" },
[0xe8] =	{ Iwds,0,		"CALL	%p" },
[0xe9] =	{ Iwds,0,		"JMP	%p" },
[0xea] =	{ PTR,0,		"JMP	%d" },
[0xeb] =	{ Jbs,0,		"JMP	%p" },
[0xec] =	{ 0,0,		"INB	DX,AL" },
[0xed] =	{ 0,0,		"IN%S	DX,%OAX" },
[0xee] =	{ 0,0,		"OUTB	AL,DX" },
[0xef] =	{ 0,0,		"OUT%S	%OAX,DX" },
[0xf0] =	{ PRE,0,		"LOCK" },
[0xf2] =	{ OPRE,0,		"REPNE" },
[0xf3] =	{ OPRE,0,		"REP" },
[0xf4] =	{ 0,0,		"HLT" },
[0xf5] =	{ 0,0,		"CMC" },
[0xf6] =	{ RMOPB,0,	optabF6 },
[0xf7] =	{ RMOP,0,		optabF7 },
[0xf8] =	{ 0,0,		"CLC" },
[0xf9] =	{ 0,0,		"STC" },
[0xfa] =	{ 0,0,		"CLI" },
[0xfb] =	{ 0,0,		"STI" },
[0xfc] =	{ 0,0,		"CLD" },
[0xfd] =	{ 0,0,		"STD" },
[0xfe] =	{ RMOPB,0,	optabFE },
[0xff] =	{ RMOP,0,		optabFF },
[0x100] =	{ RM,0,		"MOVLQSX	%e,%r" },
[0x101] =	{ RM,0,		"MOVLQZX	%e,%r" },
};

/*
 *  get a byte of the instruction
 */
static int
igetc(Map *map, Instr *ip, uchar *c)
{
	if(ip->n+1 > sizeof(ip->mem)){
		werrstr("instruction too long");
		return -1;
	}
	if (get1(map, ip->addr+ip->n, c, 1) < 0) {
		werrstr("can't read instruction: %r");
		return -1;
	}
	ip->mem[ip->n++] = *c;
	return 1;
}

/*
 *  get two bytes of the instruction
 */
static int
igets(Map *map, Instr *ip, ushort *sp)
{
	uchar c;
	ushort s;

	if (igetc(map, ip, &c) < 0)
		return -1;
	s = c;
	if (igetc(map, ip, &c) < 0)
		return -1;
	s |= (c<<8);
	*sp = s;
	return 1;
}

/*
 *  get 4 bytes of the instruction
 */
static int
igetl(Map *map, Instr *ip, uint32 *lp)
{
	ushort s;
	int32	l;

	if (igets(map, ip, &s) < 0)
		return -1;
	l = s;
	if (igets(map, ip, &s) < 0)
		return -1;
	l |= (s<<16);
	*lp = l;
	return 1;
}

/*
 *  get 8 bytes of the instruction
 *
static int
igetq(Map *map, Instr *ip, vlong *qp)
{
	uint32	l;
	uvlong q;

	if (igetl(map, ip, &l) < 0)
		return -1;
	q = l;
	if (igetl(map, ip, &l) < 0)
		return -1;
	q |= ((uvlong)l<<32);
	*qp = q;
	return 1;
}
 */

static int
getdisp(Map *map, Instr *ip, int mod, int rm, int code, int pcrel)
{
	uchar c;
	ushort s;

	if (mod > 2)
		return 1;
	if (mod == 1) {
		if (igetc(map, ip, &c) < 0)
			return -1;
		if (c&0x80)
			ip->disp = c|0xffffff00;
		else
			ip->disp = c&0xff;
	} else if (mod == 2 || rm == code) {
		if (ip->asize == 'E') {
			if (igetl(map, ip, &ip->disp) < 0)
				return -1;
			if (mod == 0)
				ip->rip = pcrel;
		} else {
			if (igets(map, ip, &s) < 0)
				return -1;
			if (s&0x8000)
				ip->disp = s|0xffff0000;
			else
				ip->disp = s;
		}
		if (mod == 0)
			ip->base = -1;
	}
	return 1;
}

static int
modrm(Map *map, Instr *ip, uchar c)
{
	uchar rm, mod;

	mod = (c>>6)&3;
	rm = c&7;
	ip->mod = mod;
	ip->base = rm;
	ip->reg = (c>>3)&7;
	ip->rip = 0;
	if (mod == 3)			/* register */
		return 1;
	if (ip->asize == 0) {		/* 16-bit mode */
		switch(rm) {
		case 0:
			ip->base = BX; ip->index = SI;
			break;
		case 1:
			ip->base = BX; ip->index = DI;
			break;
		case 2:
			ip->base = BP; ip->index = SI;
			break;
		case 3:
			ip->base = BP; ip->index = DI;
			break;
		case 4:
			ip->base = SI;
			break;
		case 5:
			ip->base = DI;
			break;
		case 6:
			ip->base = BP;
			break;
		case 7:
			ip->base = BX;
			break;
		default:
			break;
		}
		return getdisp(map, ip, mod, rm, 6, 0);
	}
	if (rm == 4) {	/* scummy sib byte */
		if (igetc(map, ip, &c) < 0)
			return -1;
		ip->ss = (c>>6)&0x03;
		ip->index = (c>>3)&0x07;
		if (ip->index == 4)
			ip->index = -1;
		ip->base = c&0x07;
		return getdisp(map, ip, mod, ip->base, 5, 0);
	}
	return getdisp(map, ip, mod, rm, 5, ip->amd64);
}

static char *
_hexify(char *buf, uint32 p, int zeros)
{
	uint32 d;

	d = p/16;
	if(d)
		buf = _hexify(buf, d, zeros-1);
	else
		while(zeros--)
			*buf++ = '0';
	*buf++ = "0123456789abcdef"[p&0x0f];
	return buf;
}

static Optable *
mkinstr(Map *map, Instr *ip, uvlong pc, int is64)
{
	int i, n, norex;
	uchar c;
	ushort s;
	Optable *op, *obase;
	char buf[128];

	memset(ip, 0, sizeof(*ip));
	norex = 1;
	ip->base = -1;
	ip->index = -1;
	ip->osize = 'L';
	ip->asize = 'E';
	ip->amd64 = is64;
	norex = 0;
	ip->addr = pc;
	if (igetc(map, ip, &c) < 0)
		return 0;
	obase = optable;
newop:
	if(ip->amd64 && !norex){
		if(c >= 0x40 && c <= 0x4f) {
			ip->rex = c;
			if(igetc(map, ip, &c) < 0)
				return 0;
		}
		if(c == 0x63){
			if(ip->rex&REXW)
				op = &obase[0x100];	/* MOVLQSX */
			else
				op = &obase[0x101];	/* MOVLQZX */
			goto hack;
		}
	}
	if(obase == optable)
		ip->op = c;
	op = &obase[c];
hack:
	if (op->proto == 0) {
badop:
		n = snprint(buf, sizeof(buf), "opcode: ??");
		for (i = 0; i < ip->n && n < sizeof(buf)-3; i++, n+=2)
			_hexify(buf+n, ip->mem[i], 1);
		strcpy(buf+n, "??");
		werrstr(buf);
		return 0;
	}
	for(i = 0; i < 2 && op->operand[i]; i++) {
		switch(op->operand[i]) {
		case Ib:	/* 8-bit immediate - (no sign extension)*/
			if (igetc(map, ip, &c) < 0)
				return 0;
			ip->imm = c&0xff;
			ip->imm64 = ip->imm;
			break;
		case Jbs:	/* 8-bit jump immediate (sign extended) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (c&0x80)
				ip->imm = c|0xffffff00;
			else
				ip->imm = c&0xff;
			ip->imm64 = (int32)ip->imm;
			ip->jumptype = Jbs;
			break;
		case Ibs:	/* 8-bit immediate (sign extended) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (c&0x80)
				if (ip->osize == 'L')
					ip->imm = c|0xffffff00;
				else
					ip->imm = c|0xff00;
			else
				ip->imm = c&0xff;
			ip->imm64 = (int32)ip->imm;
			break;
		case Iw:	/* 16-bit immediate -> imm */
			if (igets(map, ip, &s) < 0)
				return 0;
			ip->imm = s&0xffff;
			ip->imm64 = ip->imm;
			ip->jumptype = Iw;
			break;
		case Iw2:	/* 16-bit immediate -> in imm2*/
			if (igets(map, ip, &s) < 0)
				return 0;
			ip->imm2 = s&0xffff;
			break;
		case Iwd:	/* Operand-sized immediate (no sign extension unless 64 bits)*/
			if (ip->osize == 'L') {
				if (igetl(map, ip, &ip->imm) < 0)
					return 0;
				ip->imm64 = ip->imm;
				if(ip->rex&REXW && (ip->imm & (1<<31)) != 0)
					ip->imm64 |= (vlong)~0 << 32;
			} else {
				if (igets(map, ip, &s)< 0)
					return 0;
				ip->imm = s&0xffff;
				ip->imm64 = ip->imm;
			}
			break;
		case Iwdq:	/* Operand-sized immediate, possibly big */
			if (ip->osize == 'L') {
				if (igetl(map, ip, &ip->imm) < 0)
					return 0;
				ip->imm64 = ip->imm;
				if (ip->rex & REXW) {
					uint32 l;
					if (igetl(map, ip, &l) < 0)
						return 0;
					ip->imm64 |= (uvlong)l << 32;
				}
			} else {
				if (igets(map, ip, &s)< 0)
					return 0;
				ip->imm = s&0xffff;
			}
			break;
		case Awd:	/* Address-sized immediate (no sign extension)*/
			if (ip->asize == 'E') {
				if (igetl(map, ip, &ip->imm) < 0)
					return 0;
				/* TO DO: REX */
			} else {
				if (igets(map, ip, &s)< 0)
					return 0;
				ip->imm = s&0xffff;
			}
			break;
		case Iwds:	/* Operand-sized immediate (sign extended) */
			if (ip->osize == 'L') {
				if (igetl(map, ip, &ip->imm) < 0)
					return 0;
			} else {
				if (igets(map, ip, &s)< 0)
					return 0;
				if (s&0x8000)
					ip->imm = s|0xffff0000;
				else
					ip->imm = s&0xffff;
			}
			ip->jumptype = Iwds;
			break;
		case OA:	/* literal 0x0a byte */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (c != 0x0a)
				goto badop;
			break;
		case Op_R0:	/* base register must be R0 */
			if (ip->base != 0)
				goto badop;
			break;
		case Op_R1:	/* base register must be R1 */
			if (ip->base != 1)
				goto badop;
			break;
		case RMB:	/* R/M field with byte register (/r)*/
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (modrm(map, ip, c) < 0)
				return 0;
			ip->osize = 'B';
			break;
		case RM:	/* R/M field with register (/r) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (modrm(map, ip, c) < 0)
				return 0;
			break;
		case RMOPB:	/* R/M field with op code (/digit) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (modrm(map, ip, c) < 0)
				return 0;
			c = ip->reg;		/* secondary op code */
			obase = (Optable*)op->proto;
			ip->osize = 'B';
			goto newop;
		case RMOP:	/* R/M field with op code (/digit) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (modrm(map, ip, c) < 0)
				return 0;
			obase = (Optable*)op->proto;
			if(ip->amd64 && obase == optab0F01 && c == 0xF8)
				return optab0F01F8;
			c = ip->reg;
			goto newop;
		case FRMOP:	/* FP R/M field with op code (/digit) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (modrm(map, ip, c) < 0)
				return 0;
			if ((c&0xc0) == 0xc0)
				c = ip->reg+8;		/* 16 entry table */
			else
				c = ip->reg;
			obase = (Optable*)op->proto;
			goto newop;
		case FRMEX:	/* Extended FP R/M field with op code (/digit) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (modrm(map, ip, c) < 0)
				return 0;
			if ((c&0xc0) == 0xc0)
				c = (c&0x3f)+8;		/* 64-entry table */
			else
				c = ip->reg;
			obase = (Optable*)op->proto;
			goto newop;
		case RMR:	/* R/M register only (mod = 11) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if ((c&0xc0) != 0xc0) {
				werrstr("invalid R/M register: %#x", c);
				return 0;
			}
			if (modrm(map, ip, c) < 0)
				return 0;
			break;
		case RMM:	/* R/M register only (mod = 11) */
			if (igetc(map, ip, &c) < 0)
				return 0;
			if ((c&0xc0) == 0xc0) {
				werrstr("invalid R/M memory mode: %#x", c);
				return 0;
			}
			if (modrm(map, ip, c) < 0)
				return 0;
			break;
		case PTR:	/* Seg:Displacement addr (ptr16:16 or ptr16:32) */
			if (ip->osize == 'L') {
				if (igetl(map, ip, &ip->disp) < 0)
					return 0;
			} else {
				if (igets(map, ip, &s)< 0)
					return 0;
				ip->disp = s&0xffff;
			}
			if (igets(map, ip, (ushort*)&ip->seg) < 0)
				return 0;
			ip->jumptype = PTR;
			break;
		case AUXMM:	/* Multi-byte op code; prefix determines table selection */
			if (igetc(map, ip, &c) < 0)
				return 0;
			obase = (Optable*)op->proto;
			switch (ip->opre) {
			case 0x66:	op = optab660F; break;
			case 0xF2:	op = optabF20F; break;
			case 0xF3:	op = optabF30F; break;
			default:	op = nil; break;
			}
			if(op != nil && op[c].proto != nil)
				obase = op;
			norex = 1;	/* no more rex prefixes */
			/* otherwise the optab entry captures it */
			goto newop;
		case AUX:	/* Multi-byte op code - Auxiliary table */
			obase = (Optable*)op->proto;
			if (igetc(map, ip, &c) < 0)
				return 0;
			goto newop;
		case OPRE:	/* Instr Prefix or media op */
			ip->opre = c;
			/* fall through */
		case PRE:	/* Instr Prefix */
			ip->prefix = (char*)op->proto;
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (ip->opre && c == 0x0F)
				ip->prefix = 0;
			goto newop;
		case SEG:	/* Segment Prefix */
			ip->segment = (char*)op->proto;
			if (igetc(map, ip, &c) < 0)
				return 0;
			goto newop;
		case OPOVER:	/* Operand size override */
			ip->opre = c;
			ip->osize = 'W';
			if (igetc(map, ip, &c) < 0)
				return 0;
			if (c == 0x0F)
				ip->osize = 'L';
			else if (ip->amd64 && (c&0xF0) == 0x40)
				ip->osize = 'Q';
			goto newop;
		case ADDOVER:	/* Address size override */
			ip->asize = 0;
			if (igetc(map, ip, &c) < 0)
				return 0;
			goto newop;
		case JUMP:	/* mark instruction as JUMP or RET */
		case RET:
			ip->jumptype = op->operand[i];
			break;
		default:
			werrstr("bad operand type %d", op->operand[i]);
			return 0;
		}
	}
	return op;
}

static void
bprint(Instr *ip, char *fmt, ...)
{
	va_list arg;

	va_start(arg, fmt);
	ip->curr = vseprint(ip->curr, ip->end, fmt, arg);
	va_end(arg);
}

/*
 *  if we want to call 16 bit regs AX,BX,CX,...
 *  and 32 bit regs EAX,EBX,ECX,... then
 *  change the defs of ANAME and ONAME to:
 *  #define	ANAME(ip)	((ip->asize == 'E' ? "E" : "")
 *  #define	ONAME(ip)	((ip)->osize == 'L' ? "E" : "")
 */
#define	ANAME(ip)	""
#define	ONAME(ip)	""

static char *reg[] =  {
[AX] =	"AX",
[CX] =	"CX",
[DX] =	"DX",
[BX] =	"BX",
[SP] =	"SP",
[BP] =	"BP",
[SI] =	"SI",
[DI] =	"DI",

	/* amd64 */
[AMD64_R8] =	"R8",
[AMD64_R9] =	"R9",
[AMD64_R10] =	"R10",
[AMD64_R11] =	"R11",
[AMD64_R12] =	"R12",
[AMD64_R13] =	"R13",
[AMD64_R14] =	"R14",
[AMD64_R15] =	"R15",
};

static char *breg[] = { "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH" };
static char *breg64[] = { "AL", "CL", "DL", "BL", "SPB", "BPB", "SIB", "DIB",
	"R8B", "R9B", "R10B", "R11B", "R12B", "R13B", "R14B", "R15B" };
static char *sreg[] = { "ES", "CS", "SS", "DS", "FS", "GS" };

static void
immediate(Instr *ip, vlong val)
{
	// TODO: Translate known names.
	if((ip->rex & REXW) == 0)
		bprint(ip, "%#lux", (long)val);
	else
		bprint(ip, "%#llux", val);
}

static void
pea(Instr *ip)
{
	int base;

	base = ip->base;
	if(base >= 0 && (ip->rex & REXB))
		base += 8;

	if (ip->mod == 3) {
		if (ip->osize == 'B')
			bprint(ip, (ip->rex & REXB? breg64: breg)[(uchar)ip->base]);
		else
			bprint(ip, "%s%s", ANAME(ip), reg[base]);
		return;
	}

	if (ip->segment)
		bprint(ip, ip->segment);
	if (1) {
		if (ip->base < 0)
			immediate(ip, ip->disp);
		else {
			bprint(ip, "%#ux", ip->disp);
			if(ip->rip)
				bprint(ip, "(RIP)");
			bprint(ip,"(%s%s)", ANAME(ip), reg[ip->rex&REXB? ip->base+8: ip->base]);
		}
	}
	if (ip->index >= 0)
		bprint(ip,"(%s%s*%d)", ANAME(ip), reg[ip->rex&REXX? ip->index+8: ip->index], 1<<ip->ss);
}

static void
prinstr(Instr *ip, char *fmt)
{
	int sharp, i;
	vlong v;

	if (ip->prefix)
		bprint(ip, "%s ", ip->prefix);
	for (; *fmt && ip->curr < ip->end; fmt++) {
		if (*fmt != '%'){
			*ip->curr++ = *fmt;
			continue;
		}
		sharp = 0;
		if(*++fmt == '#') {
			sharp = 1;
			++fmt;
		}
		switch(*fmt){
		case '%':
			*ip->curr++ = '%';
			break;
		case 'A':
			bprint(ip, "%s", ANAME(ip));
			break;
		case 'C':
			bprint(ip, "CR%d", ip->reg);
			break;
		case 'D':
			if (ip->reg < 4 || ip->reg == 6 || ip->reg == 7)
				bprint(ip, "DR%d",ip->reg);
			else
				bprint(ip, "???");
			break;
		case 'I':
			bprint(ip, "$");
			immediate(ip, ip->imm2);
			break;
		case 'O':
			bprint(ip,"%s", ONAME(ip));
			break;
		case 'o':
			i = ip->op & 7;
			if(ip->rex & REXB)
				i += 8;
			bprint(ip, "%s", reg[i]);
			break;
		case 'i':
			if(!sharp)
				bprint(ip, "$");
			v = ip->imm;
			if(ip->rex & REXW)
				v = ip->imm64;
			immediate(ip, v);
			break;
		case 'R':
			bprint(ip, "%s%s", ONAME(ip), reg[ip->rex&REXR? ip->reg+8: ip->reg]);
			break;
		case 'S':
			if(ip->osize == 'Q' || (ip->osize == 'L' && ip->rex & REXW))
				bprint(ip, "Q");
			else
				bprint(ip, "%c", ip->osize);
			break;
		case 's':
			if(ip->opre == 0 || ip->opre == 0x66)
				bprint(ip, "P");
			else
				bprint(ip, "S");
			if(ip->opre == 0xf2 || ip->opre == 0x66)
				bprint(ip, "D");
			else
				bprint(ip, "S");
			break;
		case 'T':
			if (ip->reg == 6 || ip->reg == 7)
				bprint(ip, "TR%d",ip->reg);
			else
				bprint(ip, "???");
			break;
		case 'W':
			if (ip->osize == 'Q' || (ip->osize == 'L' && ip->rex & REXW))
				bprint(ip, "CDQE");
			else if (ip->osize == 'L')
				bprint(ip,"CWDE");
			else
				bprint(ip, "CBW");
			break;
		case 'd':
			bprint(ip,"%#ux:%#ux", ip->seg, ip->disp);
			break;
		case 'm':
			if (ip->mod == 3 && ip->osize != 'B') {
				if(fmt[1] != '*'){
					if(ip->opre != 0) {
						bprint(ip, "X%d", ip->rex&REXB? ip->base+8: ip->base);
						break;
					}
				} else
					fmt++;
				bprint(ip, "M%d", ip->base);
				break;
			}
			pea(ip);
			break;
		case 'e':
			pea(ip);
			break;
		case 'f':
			bprint(ip, "F%d", ip->base);
			break;
		case 'g':
			if (ip->reg < 6)
				bprint(ip,"%s",sreg[ip->reg]);
			else
				bprint(ip,"???");
			break;
		case 'p':
			/*
			 * signed immediate in the uint32 ip->imm.
			 */
			v = (int32)ip->imm;
			immediate(ip, v+ip->addr+ip->n);
			break;
		case 'r':
			if (ip->osize == 'B')
				bprint(ip,"%s", (ip->rex? breg64: breg)[ip->rex&REXR? ip->reg+8: ip->reg]);
			else
				bprint(ip, reg[ip->rex&REXR? ip->reg+8: ip->reg]);
			break;
		case 'w':
			if (ip->osize == 'Q' || ip->rex & REXW)
				bprint(ip, "CQO");
			else if (ip->osize == 'L')
				bprint(ip,"CDQ");
			else
				bprint(ip, "CWD");
			break;
		case 'M':
			if(ip->opre != 0)
				bprint(ip, "X%d", ip->rex&REXR? ip->reg+8: ip->reg);
			else
				bprint(ip, "M%d", ip->reg);
			break;
		case 'x':
			if (ip->mod == 3 && ip->osize != 'B') {
				bprint(ip, "X%d", ip->rex&REXB? ip->base+8: ip->base);
				break;
			}
			pea(ip);
			break;
		case 'X':
			bprint(ip, "X%d", ip->rex&REXR? ip->reg+8: ip->reg);
			break;
		default:
			bprint(ip, "%%%c", *fmt);
			break;
		}
	}
	*ip->curr = 0;		/* there's always room for 1 byte */
}

static int
i386inst(Map *map, uvlong pc, int is64, char modifier, char *buf, int n)
{
	Instr instr;
	Optable *op;

	USED(modifier);
	op = mkinstr(map, &instr, pc, is64);
	if (op == 0)
		return -1;
	instr.curr = buf;
	instr.end = buf+n-1;
	prinstr(&instr, op->proto);
	return instr.n;
}

/*
static int
i386das(Map *map, uvlong pc, char *buf, int n)
{
	Instr instr;
	int i;

	if (mkinstr(map, &instr, pc) == 0) {
		errstr(buf, n);
		return -1;
	}
	for(i = 0; i < instr.n && n > 2; i++) {
		_hexify(buf, instr.mem[i], 1);
		buf += 2;
		n -= 2;
	}
	*buf = 0;
	return instr.n;
}

static int
i386instlen(Map *map, uvlong pc)
{
	Instr i;

	if (mkinstr(map, &i, pc))
		return i.n;
	return -1;
}
*/

static int
getmem(Map *m, uvlong addr, uchar *dst, int ndst)
{
	uchar *p;
	
	p = m->startp + (addr - m->startpc);
	if(p < m->p || p >= m->ep || m->ep - p < ndst) {
		werrstr("out of bounds");
		return -1;
	}
	memmove(dst, p, ndst);
	return ndst;
}

int
x86disasm(uchar *p, uchar *end, uvlong pc, int is64, char *buf, int n)
{
	Map m;
	
	m.p = p;
	m.ep = end;
	m.startp = p;
	m.startpc = pc;
	m.get1 = getmem;
	return i386inst(&m, pc, is64, 0, buf, n);
}

void
usage(void)
{
	fprint(2, "usage: libmach8db file\n");
	exits("usage");
}

void
main(int argc, char **argv)
{
	uchar data[10000], *p, *ep;
	int fd, n, eof, addr, is64;
	Biobuf bstdout;
	char buf[1000];

	fmtinstall('H', encodefmt);

	is64 = 0;
	ARGBEGIN{
	case '8':
		is64 = 0;
		break;
	case '6':
		is64 = 1;
		break;
	default:
		usage();
	}ARGEND
	
	if(argc != 1)
		usage();
	
	fd = open(argv[0], OREAD);
	if(fd < 0)
		sysfatal("open %s: %r", argv[0]);
	
	Binit(&bstdout, 1, OWRITE);
	p = data;
	ep = data;
	eof = 0;
	addr = 0;
	for(;;) {
		if(!eof && ep-p < 64) {
			memmove(data, p, ep-p);
			ep = data + (ep-p);
			p = data;
			n = readn(fd, ep, data+sizeof data-ep);
			if(n <= 0)
				eof = 1;
			else
				ep += n;
		}
		if(p == ep)
			break;
		n = x86disasm(p, ep, addr, is64, buf, sizeof buf);
		if(n < 0) {
			Bprint(&bstdout, "0x%x %.*H error: %r\n", addr, 1, p);
			n = 1;
		} else {
			Bprint(&bstdout, "0x%x %.*H %s\n", addr, n, p, buf);
		}
		addr += n;
		p += n;
	}
	Bflush(&bstdout);
	exits(0);
}
                                                                                                                                                                                                          usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/xed_test.go                     0100644 0000000 0000000 00000017255 13020111412 025720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"strings"
	"testing"
)

func TestXed32Manual(t *testing.T)   { testXed32(t, hexCases(t, xedManualTests)) }
func TestXed32Testdata(t *testing.T) { testXed32(t, concat(basicPrefixes, testdataCases(t))) }
func TestXed32ModRM(t *testing.T)    { testXed32(t, concat(basicPrefixes, enumModRM)) }
func TestXed32OneByte(t *testing.T)  { testBasic(t, testXed32) }
func TestXed320F(t *testing.T)       { testBasic(t, testXed32, 0x0F) }
func TestXed320F38(t *testing.T)     { testBasic(t, testXed32, 0x0F, 0x38) }
func TestXed320F3A(t *testing.T)     { testBasic(t, testXed32, 0x0F, 0x3A) }
func TestXed32Prefix(t *testing.T)   { testPrefix(t, testXed32) }

func TestXed64Manual(t *testing.T)   { testXed64(t, hexCases(t, xedManualTests)) }
func TestXed64Testdata(t *testing.T) { testXed64(t, concat(basicPrefixes, testdataCases(t))) }
func TestXed64ModRM(t *testing.T)    { testXed64(t, concat(basicPrefixes, enumModRM)) }
func TestXed64OneByte(t *testing.T)  { testBasic(t, testXed64) }
func TestXed640F(t *testing.T)       { testBasic(t, testXed64, 0x0F) }
func TestXed640F38(t *testing.T)     { testBasic(t, testXed64, 0x0F, 0x38) }
func TestXed640F3A(t *testing.T)     { testBasic(t, testXed64, 0x0F, 0x3A) }
func TestXed64Prefix(t *testing.T)   { testPrefix(t, testXed64) }

func TestXed64REXTestdata(t *testing.T) {
	testXed64(t, filter(concat3(basicPrefixes, rexPrefixes, testdataCases(t)), isValidREX))
}
func TestXed64REXModRM(t *testing.T)   { testXed64(t, concat3(basicPrefixes, rexPrefixes, enumModRM)) }
func TestXed64REXOneByte(t *testing.T) { testBasicREX(t, testXed64) }
func TestXed64REX0F(t *testing.T)      { testBasicREX(t, testXed64, 0x0F) }
func TestXed64REX0F38(t *testing.T)    { testBasicREX(t, testXed64, 0x0F, 0x38) }
func TestXed64REX0F3A(t *testing.T)    { testBasicREX(t, testXed64, 0x0F, 0x3A) }
func TestXed64REXPrefix(t *testing.T)  { testPrefixREX(t, testXed64) }

// xedManualTests holds test cases that will be run by TestXedManual32 and TestXedManual64.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=XedManual, particularly with tracing enabled.
var xedManualTests = `
6690
`

// allowedMismatchXed reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchXed(text string, size int, inst *Inst, dec ExtInst) bool {
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "GENERAL_ERROR", "INSTR_TOO_LONG", "BAD_LOCK_PREFIX") {
		return true
	}

	if contains(dec.text, "BAD_LOCK_PREFIX") && countExactPrefix(inst, PrefixLOCK|PrefixInvalid) > 0 {
		return true
	}

	if contains(dec.text, "BAD_LOCK_PREFIX", "GENERAL_ERROR") && countExactPrefix(inst, PrefixLOCK|PrefixImplicit) > 0 {
		return true
	}

	if text == "lock" && size == 1 && contains(dec.text, "BAD_LOCK_PREFIX") {
		return true
	}

	// Instructions not known to us.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, unsupported...) {
		return true
	}

	// Instructions not known to xed.
	if contains(text, xedUnsupported...) && contains(dec.text, "ERROR") {
		return true
	}

	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "shl ") && (inst.Opcode>>16)&0xEC38 == 0xC030 {
		return true
	}

	// 82 11 22: xed says 'adc byte ptr [ecx], 0x22' but there is no justification in the manuals for that.
	// C0 30 11: xed says 'shl byte ptr [eax], 0x11' but there is no justification in the manuals for that.
	// F6 08 11: xed says 'test byte ptr [eax], 0x11' but there is no justification in the manuals for that.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && hasByte(dec.enc[:dec.nenc], 0x82, 0xC0, 0xC1, 0xD0, 0xD1, 0xD2, 0xD3, 0xF6, 0xF7) {
		return true
	}

	// F3 11 22 and many others: xed allows and drops misused rep/repn prefix.
	if (text == "rep" && dec.enc[0] == 0xF3 || (text == "repn" || text == "repne") && dec.enc[0] == 0xF2) && (!contains(dec.text, "ins", "outs", "movs", "lods", "cmps", "scas") || contains(dec.text, "xmm")) {
		return true
	}

	// 0F C7 30: xed says vmptrld qword ptr [eax]; we say rdrand eax.
	// TODO(rsc): Fix, since we are probably wrong, but we don't have vmptrld in the manual.
	if contains(text, "rdrand") && contains(dec.text, "vmptrld", "vmxon", "vmclear") {
		return true
	}

	// F3 0F AE 00: we say 'rdfsbase dword ptr [eax]' but RDFSBASE needs a register.
	// Also, this is a 64-bit only instruction.
	// TODO(rsc): Fix to reject this encoding.
	if contains(text, "rdfsbase", "rdgsbase", "wrfsbase", "wrgsbase") && contains(dec.text, "ERROR") {
		return true
	}

	// 0F 01 F8: we say swapgs but that's only valid in 64-bit mode.
	// TODO(rsc): Fix.
	if contains(text, "swapgs") {
		return true
	}

	// 0F 24 11: 'mov ecx, tr2' except there is no TR2.
	// Or maybe the MOV to TR registers doesn't use RMF.
	if contains(text, "cr1", "cr5", "cr6", "cr7", "tr0", "tr1", "tr2", "tr3", "tr4", "tr5", "tr6", "tr7") && contains(dec.text, "ERROR") {
		return true
	}

	// 0F 19 11, 0F 1C 11, 0F 1D 11, 0F 1E 11, 0F 1F 11: xed says nop,
	// but the Intel manuals say that the only NOP there is 0F 1F /0.
	// Perhaps xed is reporting an older encoding.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "nop ") && (inst.Opcode>>8)&0xFFFF38 != 0x0F1F00 {
		return true
	}

	// 66 0F AE 38: clflushopt but we only know clflush
	if contains(text, "clflush") && contains(dec.text, "clflushopt") {
		return true
	}

	// 0F 20 04 11: MOV SP, CR0 but has mod!=3 despite register argument.
	// (This encoding ignores the mod bits.) The decoder sees the non-register
	// mod and reads farther ahead to decode the memory reference that
	// isn't really there, causing the size to be too large.
	// TODO(rsc): Fix.
	if text == dec.text && size > dec.nenc && contains(text, " cr", " dr", " tr") {
		return true
	}

	// 0F AE E9: xed says lfence, which is wrong (only 0F AE E8 is lfence). And so on.
	if contains(dec.text, "fence") && hasByte(dec.enc[:dec.nenc], 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF) {
		return true
	}

	// DD C9, DF C9: xed says 'fxch st0, st1' but that instruction is D9 C9.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fxch ") && hasByte(dec.enc[:dec.nenc], 0xDD, 0xDF) {
		return true
	}

	// DC D4: xed says 'fcom st0, st4' but that instruction is D8 D4.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fcom ") && hasByte(dec.enc[:dec.nenc], 0xD8, 0xDC) {
		return true
	}

	// DE D4: xed says 'fcomp st0, st4' but that instruction is D8 D4.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fcomp ") && hasByte(dec.enc[:dec.nenc], 0xDC, 0xDE) {
		return true
	}

	// DF D4: xed says 'fstp st4, st0' but that instruction is DD D4.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fstp ") && hasByte(dec.enc[:dec.nenc], 0xDF) {
		return true
	}

	return false
}

func countExactPrefix(inst *Inst, target Prefix) int {
	n := 0
	for _, p := range inst.Prefix {
		if p == target {
			n++
		}
	}
	return n
}

func hasByte(src []byte, target ...byte) bool {
	for _, b := range target {
		if bytes.IndexByte(src, b) >= 0 {
			return true
		}
	}
	return false
}

// Instructions known to us but not to xed.
var xedUnsupported = strings.Fields(`
	xrstor
	xsave
	xsave
	ud1
	xgetbv
	xsetbv
	fxsave
	fxrstor
	clflush
	lfence
	mfence
	sfence
	rsqrtps
	rcpps
	emms
	ldmxcsr
	stmxcsr
	movhpd
	movnti
	rdrand
	movbe
	movlpd
	sysret
`)
                                                                                                                                                                                                                                                                                                                                                   usr/local/go/src/cmd/internal/unvendor/golang.org/x/arch/x86/x86asm/xedext_test.go                  0100644 0000000 0000000 00000010657 13020111412 026440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package x86asm

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"testing"
)

// xed binary from Intel sde-external-6.22.0-2014-03-06.
const xedPath = "/Users/rsc/bin/xed"

func testXedArch(t *testing.T, arch int, generate func(func([]byte))) {
	if testing.Short() {
		t.Skip("skipping xed test in short mode")
	}
	if _, err := os.Stat(xedPath); err != nil {
		t.Skip(err)
	}

	testExtDis(t, "intel", arch, xed, generate, allowedMismatchXed)
}

func testXed32(t *testing.T, generate func(func([]byte))) {
	testXedArch(t, 32, generate)
}

func testXed64(t *testing.T, generate func(func([]byte))) {
	testXedArch(t, 64, generate)
}

func xed(ext *ExtDis) error {
	b, err := ext.Run(xedPath, fmt.Sprintf("-%d", ext.Arch), "-n", "1G", "-ir", ext.File.Name())
	if err != nil {
		return err
	}

	nmatch := 0
	next := uint32(start)
	var (
		addr   uint32
		encbuf [32]byte
		enc    []byte
		text   string
	)

	var xedEnd = []byte("# end of text section")
	var xedEnd1 = []byte("# Errors")

	eof := false
	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading objdump output: %v", err)
		}
		if debug {
			os.Stdout.Write(line)
		}
		if bytes.HasPrefix(line, xedEnd) || bytes.HasPrefix(line, xedEnd1) {
			eof = true
		}
		if eof {
			continue
		}
		nmatch++
		addr, enc, text = parseLineXed(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
		if addr < next {
			continue
		}
		switch text {
		case "repz":
			text = "rep"
		case "repnz":
			text = "repn"
		default:
			text = strings.Replace(text, "repz ", "rep ", -1)
			text = strings.Replace(text, "repnz ", "repn ", -1)
		}
		if m := pcrelw.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int16(uint32(targ)-uint32(uint16(addr))-uint32(len(enc))))
		}
		if m := pcrel.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
		}
		ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
		encbuf = [32]byte{}
		enc = nil
		next += 32
	}
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

var (
	xedInRaw    = []byte("In raw...")
	xedDots     = []byte("...")
	xdis        = []byte("XDIS ")
	xedError    = []byte("ERROR: ")
	xedNoDecode = []byte("Could not decode at offset: 0x")
)

func parseLineXed(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	oline := line
	if bytes.HasPrefix(line, xedInRaw) || bytes.HasPrefix(line, xedDots) {
		return 0, nil, ""
	}
	if bytes.HasPrefix(line, xedError) {
		i := bytes.IndexByte(line[len(xedError):], ' ')
		if i < 0 {
			log.Fatalf("cannot parse error: %q", oline)
		}
		errstr := string(line[len(xedError):])
		i = bytes.Index(line, xedNoDecode)
		if i < 0 {
			log.Fatalf("cannot parse error: %q", oline)
		}
		i += len(xedNoDecode)
		j := bytes.IndexByte(line[i:], ' ')
		if j < 0 {
			log.Fatalf("cannot parse error: %q", oline)
		}
		x, err := strconv.ParseUint(string(trimSpace(line[i:i+j])), 16, 32)
		if err != nil {
			log.Fatalf("cannot parse disassembly: %q", oline)
		}
		addr = uint32(x)
		return addr, nil, errstr
	}

	if !bytes.HasPrefix(line, xdis) {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}

	i := bytes.IndexByte(line, ':')
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	x, err := strconv.ParseUint(string(trimSpace(line[len(xdis):i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	addr = uint32(x)

	// spaces
	i++
	for i < len(line) && line[i] == ' ' {
		i++
	}
	// instruction class, spaces
	for i < len(line) && line[i] != ' ' {
		i++
	}
	for i < len(line) && line[i] == ' ' {
		i++
	}
	// instruction set, spaces
	for i < len(line) && line[i] != ' ' {
		i++
	}
	for i < len(line) && line[i] == ' ' {
		i++
	}

	// hex
	hexStart := i
	for i < len(line) && line[i] != ' ' {
		i++
	}
	hexEnd := i
	for i < len(line) && line[i] == ' ' {
		i++
	}

	// text
	textStart := i
	for i < len(line) && line[i] != '\n' {
		i++
	}
	textEnd := i

	enc, ok := parseHex(line[hexStart:hexEnd], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}

	return addr, enc, string(fixSpace(line[textStart:textEnd]))
}
                                                                                 usr/local/go/src/cmd/internal/unvendor/vendor.json                                                  0100644 0000000 0000000 00000000650 13020111412 020735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
	"package": [
		{
			"canonical": "golang.org/x/arch/x86/x86asm",
			"local": "golang.org/x/arch/x86/x86asm",
			"revision": "ad6a463afcf9bd5b38c81fa9ba612dae11859d40",
			"revisionTime": "2015-08-28T15:42:14Z"
		},
		{
			"canonical": "golang.org/x/arch/arm/armasm",
			"local": "golang.org/x/arch/arm/armasm",
			"revision": "ad6a463afcf9bd5b38c81fa9ba612dae11859d40",
			"revisionTime": "2015-08-28T15:42:14Z"
		}
	]
}
                                                                                        usr/local/go/src/cmd/link/                                                                          0040755 0000000 0000000 00000000000 13020111412 014030  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/link/doc.go                                                                    0100644 0000000 0000000 00000006305 13020111412 015125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
Link, typically invoked as ``go tool link,'' reads the Go archive or object
for a package main, along with its dependencies, and combines them
into an executable binary.

Command Line

Usage:

	go tool link [flags] main.a

Flags:

	-B note
		Add an ELF_NT_GNU_BUILD_ID note when using ELF.
		The value should start with 0x and be an even number of hex digits.
	-D address
		Set data segment address.
	-E entry
		Set entry symbol name.
	-H type
		Set executable format type.
		The default format is inferred from GOOS and GOARCH.
		On Windows, -H windowsgui writes a "GUI binary" instead of a "console binary."
	-I interpreter
		Set the ELF dynamic linker to use.
	-L dir1 -L dir2
		Search for imported packages in dir1, dir2, etc,
		after consulting $GOROOT/pkg/$GOOS_$GOARCH.
	-R quantum
		Set address rounding quantum.
	-T address
		Set text segment address.
	-V
		Print the linker version and exit.
	-X importpath.name=value
		Set the value of the string variable in importpath named name to value.
		Note that before Go 1.5 this option took two separate arguments.
		Now it takes one argument split on the first = sign.
	-buildmode mode
		Set build mode (default exe).
	-cpuprofile file
		Write CPU profile to file.
	-d
		Disable generation of dynamic executables.
		The emitted code is the same in either case; the option
		controls only whether a dynamic header is included.
		The dynamic header is on by default, even without any
		references to dynamic libraries, because many common
		system tools now assume the presence of the header.
	-extar ar
		Set the external archive program (default "ar").
		Used only for -buildmode=c-archive.
	-extld linker
		Set the external linker (default "clang" or "gcc").
	-extldflags flags
		Set space-separated flags to pass to the external linker.
	-f
		Ignore version mismatch in the linked archives.
	-g
		Disable Go package data checks.
	-installsuffix suffix
		Look for packages in $GOROOT/pkg/$GOOS_$GOARCH_suffix
		instead of $GOROOT/pkg/$GOOS_$GOARCH.
	-libgcc file
		Set name of compiler support library.
		This is only used in internal link mode.
		If not set, default value comes from running the compiler,
		which may be set by the -extld option.
		Set to "none" to use no support library.
	-linkmode mode
		Set link mode (internal, external, auto).
		This sets the linking mode as described in cmd/cgo/doc.go.
	-linkshared
		Link against installed Go shared libraries (experimental).
	-memprofile file
		Write memory profile to file.
	-memprofilerate rate
		Set runtime.MemProfileRate to rate.
	-msan
		Link with C/C++ memory sanitizer support.
	-o file
		Write output to file (default a.out, or a.out.exe on Windows).
	-r dir1:dir2:...
		Set the ELF dynamic linker search path.
	-race
		Link with race detection libraries.
	-s
		Omit the symbol table and debug information.
	-shared
		Generated shared object (implies -linkmode external; experimental).
	-tmpdir dir
		Write temporary files to dir.
		Temporary files are only used in external linking mode.
	-v
		Print trace of linker operations.
	-w
		Omit the DWARF symbol table.
*/
package main
                                                                                                                                                                                                                                                                                                                           usr/local/go/src/cmd/link/internal/                                                                 0040755 0000000 0000000 00000000000 13020111412 015644  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/link/internal/amd64/                                                           0040755 0000000 0000000 00000000000 13020111412 016557  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/link/internal/amd64/asm.go                                                     0100644 0000000 0000000 00000047423 13020111412 017675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/6l/asm.c
// http://code.google.com/p/inferno-os/source/browse/utils/6l/asm.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package amd64

import (
	"cmd/internal/obj"
	"cmd/link/internal/ld"
	"debug/elf"
	"fmt"
	"log"
)

func PADDR(x uint32) uint32 {
	return x &^ 0x80000000
}

func Addcall(ctxt *ld.Link, s *ld.LSym, t *ld.LSym) int64 {
	s.Reachable = true
	i := s.Size
	s.Size += 4
	ld.Symgrow(ctxt, s, s.Size)
	r := ld.Addrel(s)
	r.Sym = t
	r.Off = int32(i)
	r.Type = obj.R_CALL
	r.Siz = 4
	return i + int64(r.Siz)
}

func gentext() {
	if !ld.DynlinkingGo() {
		return
	}
	addmoduledata := ld.Linklookup(ld.Ctxt, "runtime.addmoduledata", 0)
	if addmoduledata.Type == obj.STEXT {
		// we're linking a module containing the runtime -> no need for
		// an init function
		return
	}
	addmoduledata.Reachable = true
	initfunc := ld.Linklookup(ld.Ctxt, "go.link.addmoduledata", 0)
	initfunc.Type = obj.STEXT
	initfunc.Local = true
	initfunc.Reachable = true
	o := func(op ...uint8) {
		for _, op1 := range op {
			ld.Adduint8(ld.Ctxt, initfunc, op1)
		}
	}
	// 0000000000000000 <local.dso_init>:
	//    0:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 7 <local.dso_init+0x7>
	// 			3: R_X86_64_PC32	runtime.firstmoduledata-0x4
	o(0x48, 0x8d, 0x3d)
	ld.Addpcrelplus(ld.Ctxt, initfunc, ld.Ctxt.Moduledata, 0)
	//    7:	e8 00 00 00 00       	callq  c <local.dso_init+0xc>
	// 			8: R_X86_64_PLT32	runtime.addmoduledata-0x4
	o(0xe8)
	Addcall(ld.Ctxt, initfunc, addmoduledata)
	//    c:	c3                   	retq
	o(0xc3)
	if ld.Ctxt.Etextp != nil {
		ld.Ctxt.Etextp.Next = initfunc
	} else {
		ld.Ctxt.Textp = initfunc
	}
	ld.Ctxt.Etextp = initfunc
	initarray_entry := ld.Linklookup(ld.Ctxt, "go.link.addmoduledatainit", 0)
	initarray_entry.Reachable = true
	initarray_entry.Local = true
	initarray_entry.Type = obj.SINITARR
	ld.Addaddr(ld.Ctxt, initarray_entry, initfunc)
}

func adddynrela(rela *ld.LSym, s *ld.LSym, r *ld.Reloc) {
	ld.Addaddrplus(ld.Ctxt, rela, s, int64(r.Off))
	ld.Adduint64(ld.Ctxt, rela, ld.R_X86_64_RELATIVE)
	ld.Addaddrplus(ld.Ctxt, rela, r.Sym, r.Add) // Addend
}

func adddynrel(s *ld.LSym, r *ld.Reloc) {
	targ := r.Sym
	ld.Ctxt.Cursym = s

	switch r.Type {
	default:
		if r.Type >= 256 {
			ld.Diag("unexpected relocation type %d", r.Type)
			return
		}

		// Handle relocations found in ELF object files.
	case 256 + ld.R_X86_64_PC32:
		if targ.Type == obj.SDYNIMPORT {
			ld.Diag("unexpected R_X86_64_PC32 relocation for dynamic symbol %s", targ.Name)
		}
		if targ.Type == 0 || targ.Type == obj.SXREF {
			ld.Diag("unknown symbol %s in pcrel", targ.Name)
		}
		r.Type = obj.R_PCREL
		r.Add += 4
		return

	case 256 + ld.R_X86_64_PLT32:
		r.Type = obj.R_PCREL
		r.Add += 4
		if targ.Type == obj.SDYNIMPORT {
			addpltsym(targ)
			r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
			r.Add += int64(targ.Plt)
		}

		return

	case 256 + ld.R_X86_64_GOTPCREL, 256 + ld.R_X86_64_GOTPCRELX, 256 + ld.R_X86_64_REX_GOTPCRELX:
		if targ.Type != obj.SDYNIMPORT {
			// have symbol
			if r.Off >= 2 && s.P[r.Off-2] == 0x8b {
				// turn MOVQ of GOT entry into LEAQ of symbol itself
				s.P[r.Off-2] = 0x8d

				r.Type = obj.R_PCREL
				r.Add += 4
				return
			}
		}

		// fall back to using GOT and hope for the best (CMOV*)
		// TODO: just needs relocation, no need to put in .dynsym
		addgotsym(targ)

		r.Type = obj.R_PCREL
		r.Sym = ld.Linklookup(ld.Ctxt, ".got", 0)
		r.Add += 4
		r.Add += int64(targ.Got)
		return

	case 256 + ld.R_X86_64_64:
		if targ.Type == obj.SDYNIMPORT {
			ld.Diag("unexpected R_X86_64_64 relocation for dynamic symbol %s", targ.Name)
		}
		r.Type = obj.R_ADDR
		return

	// Handle relocations found in Mach-O object files.
	case 512 + ld.MACHO_X86_64_RELOC_UNSIGNED*2 + 0,
		512 + ld.MACHO_X86_64_RELOC_SIGNED*2 + 0,
		512 + ld.MACHO_X86_64_RELOC_BRANCH*2 + 0:
		// TODO: What is the difference between all these?
		r.Type = obj.R_ADDR

		if targ.Type == obj.SDYNIMPORT {
			ld.Diag("unexpected reloc for dynamic symbol %s", targ.Name)
		}
		return

	case 512 + ld.MACHO_X86_64_RELOC_BRANCH*2 + 1:
		if targ.Type == obj.SDYNIMPORT {
			addpltsym(targ)
			r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
			r.Add = int64(targ.Plt)
			r.Type = obj.R_PCREL
			return
		}
		fallthrough

		// fall through
	case 512 + ld.MACHO_X86_64_RELOC_UNSIGNED*2 + 1,
		512 + ld.MACHO_X86_64_RELOC_SIGNED*2 + 1,
		512 + ld.MACHO_X86_64_RELOC_SIGNED_1*2 + 1,
		512 + ld.MACHO_X86_64_RELOC_SIGNED_2*2 + 1,
		512 + ld.MACHO_X86_64_RELOC_SIGNED_4*2 + 1:
		r.Type = obj.R_PCREL

		if targ.Type == obj.SDYNIMPORT {
			ld.Diag("unexpected pc-relative reloc for dynamic symbol %s", targ.Name)
		}
		return

	case 512 + ld.MACHO_X86_64_RELOC_GOT_LOAD*2 + 1:
		if targ.Type != obj.SDYNIMPORT {
			// have symbol
			// turn MOVQ of GOT entry into LEAQ of symbol itself
			if r.Off < 2 || s.P[r.Off-2] != 0x8b {
				ld.Diag("unexpected GOT_LOAD reloc for non-dynamic symbol %s", targ.Name)
				return
			}

			s.P[r.Off-2] = 0x8d
			r.Type = obj.R_PCREL
			return
		}
		fallthrough

		// fall through
	case 512 + ld.MACHO_X86_64_RELOC_GOT*2 + 1:
		if targ.Type != obj.SDYNIMPORT {
			ld.Diag("unexpected GOT reloc for non-dynamic symbol %s", targ.Name)
		}
		addgotsym(targ)
		r.Type = obj.R_PCREL
		r.Sym = ld.Linklookup(ld.Ctxt, ".got", 0)
		r.Add += int64(targ.Got)
		return
	}

	// Handle references to ELF symbols from our own object files.
	if targ.Type != obj.SDYNIMPORT {
		return
	}

	switch r.Type {
	case obj.R_CALL,
		obj.R_PCREL:
		if ld.HEADTYPE == obj.Hwindows {
			// nothing to do, the relocation will be laid out in pereloc1
			return
		} else {
			// for both ELF and Mach-O
			addpltsym(targ)
			r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
			r.Add = int64(targ.Plt)
			return
		}

	case obj.R_ADDR:
		if s.Type == obj.STEXT && ld.Iself {
			if ld.HEADTYPE == obj.Hsolaris {
				addpltsym(targ)
				r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
				r.Add += int64(targ.Plt)
				return
			}
			// The code is asking for the address of an external
			// function.  We provide it with the address of the
			// correspondent GOT symbol.
			addgotsym(targ)

			r.Sym = ld.Linklookup(ld.Ctxt, ".got", 0)
			r.Add += int64(targ.Got)
			return
		}

		if s.Type != obj.SDATA {
			break
		}
		if ld.Iself {
			ld.Adddynsym(ld.Ctxt, targ)
			rela := ld.Linklookup(ld.Ctxt, ".rela", 0)
			ld.Addaddrplus(ld.Ctxt, rela, s, int64(r.Off))
			if r.Siz == 8 {
				ld.Adduint64(ld.Ctxt, rela, ld.ELF64_R_INFO(uint32(targ.Dynid), ld.R_X86_64_64))
			} else {
				ld.Adduint64(ld.Ctxt, rela, ld.ELF64_R_INFO(uint32(targ.Dynid), ld.R_X86_64_32))
			}
			ld.Adduint64(ld.Ctxt, rela, uint64(r.Add))
			r.Type = 256 // ignore during relocsym
			return
		}

		if ld.HEADTYPE == obj.Hdarwin && s.Size == int64(ld.Thearch.Ptrsize) && r.Off == 0 {
			// Mach-O relocations are a royal pain to lay out.
			// They use a compact stateful bytecode representation
			// that is too much bother to deal with.
			// Instead, interpret the C declaration
			//	void *_Cvar_stderr = &stderr;
			// as making _Cvar_stderr the name of a GOT entry
			// for stderr.  This is separate from the usual GOT entry,
			// just in case the C code assigns to the variable,
			// and of course it only works for single pointers,
			// but we only need to support cgo and that's all it needs.
			ld.Adddynsym(ld.Ctxt, targ)

			got := ld.Linklookup(ld.Ctxt, ".got", 0)
			s.Type = got.Type | obj.SSUB
			s.Outer = got
			s.Sub = got.Sub
			got.Sub = s
			s.Value = got.Size
			ld.Adduint64(ld.Ctxt, got, 0)
			ld.Adduint32(ld.Ctxt, ld.Linklookup(ld.Ctxt, ".linkedit.got", 0), uint32(targ.Dynid))
			r.Type = 256 // ignore during relocsym
			return
		}

		if ld.HEADTYPE == obj.Hwindows {
			// nothing to do, the relocation will be laid out in pereloc1
			return
		}
	}

	ld.Ctxt.Cursym = s
	ld.Diag("unsupported relocation for dynamic symbol %s (type=%d stype=%d)", targ.Name, r.Type, targ.Type)
}

func elfreloc1(r *ld.Reloc, sectoff int64) int {
	ld.Thearch.Vput(uint64(sectoff))

	elfsym := r.Xsym.ElfsymForReloc()
	switch r.Type {
	default:
		return -1

	case obj.R_ADDR:
		if r.Siz == 4 {
			ld.Thearch.Vput(ld.R_X86_64_32 | uint64(elfsym)<<32)
		} else if r.Siz == 8 {
			ld.Thearch.Vput(ld.R_X86_64_64 | uint64(elfsym)<<32)
		} else {
			return -1
		}

	case obj.R_TLS_LE:
		if r.Siz == 4 {
			ld.Thearch.Vput(ld.R_X86_64_TPOFF32 | uint64(elfsym)<<32)
		} else {
			return -1
		}

	case obj.R_TLS_IE:
		if r.Siz == 4 {
			ld.Thearch.Vput(ld.R_X86_64_GOTTPOFF | uint64(elfsym)<<32)
		} else {
			return -1
		}

	case obj.R_CALL:
		if r.Siz == 4 {
			if r.Xsym.Type == obj.SDYNIMPORT {
				if ld.DynlinkingGo() {
					ld.Thearch.Vput(ld.R_X86_64_PLT32 | uint64(elfsym)<<32)
				} else {
					ld.Thearch.Vput(ld.R_X86_64_GOTPCREL | uint64(elfsym)<<32)
				}
			} else {
				ld.Thearch.Vput(ld.R_X86_64_PC32 | uint64(elfsym)<<32)
			}
		} else {
			return -1
		}

	case obj.R_PCREL:
		if r.Siz == 4 {
			if r.Xsym.Type == obj.SDYNIMPORT && r.Xsym.ElfType == elf.STT_FUNC {
				ld.Thearch.Vput(ld.R_X86_64_PLT32 | uint64(elfsym)<<32)
			} else {
				ld.Thearch.Vput(ld.R_X86_64_PC32 | uint64(elfsym)<<32)
			}
		} else {
			return -1
		}

	case obj.R_GOTPCREL:
		if r.Siz == 4 {
			ld.Thearch.Vput(ld.R_X86_64_GOTPCREL | uint64(elfsym)<<32)
		} else {
			return -1
		}
	}

	ld.Thearch.Vput(uint64(r.Xadd))
	return 0
}

func machoreloc1(r *ld.Reloc, sectoff int64) int {
	var v uint32

	rs := r.Xsym

	if rs.Type == obj.SHOSTOBJ || r.Type == obj.R_PCREL {
		if rs.Dynid < 0 {
			ld.Diag("reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
			return -1
		}

		v = uint32(rs.Dynid)
		v |= 1 << 27 // external relocation
	} else {
		v = uint32(rs.Sect.Extnum)
		if v == 0 {
			ld.Diag("reloc %d to symbol %s in non-macho section %s type=%d", r.Type, rs.Name, rs.Sect.Name, rs.Type)
			return -1
		}
	}

	switch r.Type {
	default:
		return -1

	case obj.R_ADDR:
		v |= ld.MACHO_X86_64_RELOC_UNSIGNED << 28

	case obj.R_CALL:
		v |= 1 << 24 // pc-relative bit
		v |= ld.MACHO_X86_64_RELOC_BRANCH << 28

		// NOTE: Only works with 'external' relocation. Forced above.
	case obj.R_PCREL:
		v |= 1 << 24 // pc-relative bit
		v |= ld.MACHO_X86_64_RELOC_SIGNED << 28
	}

	switch r.Siz {
	default:
		return -1

	case 1:
		v |= 0 << 25

	case 2:
		v |= 1 << 25

	case 4:
		v |= 2 << 25

	case 8:
		v |= 3 << 25
	}

	ld.Thearch.Lput(uint32(sectoff))
	ld.Thearch.Lput(v)
	return 0
}

func pereloc1(r *ld.Reloc, sectoff int64) bool {
	var v uint32

	rs := r.Xsym

	if rs.Dynid < 0 {
		ld.Diag("reloc %d to non-coff symbol %s type=%d", r.Type, rs.Name, rs.Type)
		return false
	}

	ld.Thearch.Lput(uint32(sectoff))
	ld.Thearch.Lput(uint32(rs.Dynid))

	switch r.Type {
	default:
		return false

	case obj.R_ADDR:
		if r.Siz == 8 {
			v = ld.IMAGE_REL_AMD64_ADDR64
		} else {
			v = ld.IMAGE_REL_AMD64_ADDR32
		}

	case obj.R_CALL,
		obj.R_PCREL:
		v = ld.IMAGE_REL_AMD64_REL32
	}

	ld.Thearch.Wput(uint16(v))

	return true
}

func archreloc(r *ld.Reloc, s *ld.LSym, val *int64) int {
	return -1
}

func archrelocvariant(r *ld.Reloc, s *ld.LSym, t int64) int64 {
	log.Fatalf("unexpected relocation variant")
	return t
}

func elfsetupplt() {
	plt := ld.Linklookup(ld.Ctxt, ".plt", 0)
	got := ld.Linklookup(ld.Ctxt, ".got.plt", 0)
	if plt.Size == 0 {
		// pushq got+8(IP)
		ld.Adduint8(ld.Ctxt, plt, 0xff)

		ld.Adduint8(ld.Ctxt, plt, 0x35)
		ld.Addpcrelplus(ld.Ctxt, plt, got, 8)

		// jmpq got+16(IP)
		ld.Adduint8(ld.Ctxt, plt, 0xff)

		ld.Adduint8(ld.Ctxt, plt, 0x25)
		ld.Addpcrelplus(ld.Ctxt, plt, got, 16)

		// nopl 0(AX)
		ld.Adduint32(ld.Ctxt, plt, 0x00401f0f)

		// assume got->size == 0 too
		ld.Addaddrplus(ld.Ctxt, got, ld.Linklookup(ld.Ctxt, ".dynamic", 0), 0)

		ld.Adduint64(ld.Ctxt, got, 0)
		ld.Adduint64(ld.Ctxt, got, 0)
	}
}

func addpltsym(s *ld.LSym) {
	if s.Plt >= 0 {
		return
	}

	ld.Adddynsym(ld.Ctxt, s)

	if ld.Iself {
		plt := ld.Linklookup(ld.Ctxt, ".plt", 0)
		got := ld.Linklookup(ld.Ctxt, ".got.plt", 0)
		rela := ld.Linklookup(ld.Ctxt, ".rela.plt", 0)
		if plt.Size == 0 {
			elfsetupplt()
		}

		// jmpq *got+size(IP)
		ld.Adduint8(ld.Ctxt, plt, 0xff)

		ld.Adduint8(ld.Ctxt, plt, 0x25)
		ld.Addpcrelplus(ld.Ctxt, plt, got, got.Size)

		// add to got: pointer to current pos in plt
		ld.Addaddrplus(ld.Ctxt, got, plt, plt.Size)

		// pushq $x
		ld.Adduint8(ld.Ctxt, plt, 0x68)

		ld.Adduint32(ld.Ctxt, plt, uint32((got.Size-24-8)/8))

		// jmpq .plt
		ld.Adduint8(ld.Ctxt, plt, 0xe9)

		ld.Adduint32(ld.Ctxt, plt, uint32(-(plt.Size + 4)))

		// rela
		ld.Addaddrplus(ld.Ctxt, rela, got, got.Size-8)

		ld.Adduint64(ld.Ctxt, rela, ld.ELF64_R_INFO(uint32(s.Dynid), ld.R_X86_64_JMP_SLOT))
		ld.Adduint64(ld.Ctxt, rela, 0)

		s.Plt = int32(plt.Size - 16)
	} else if ld.HEADTYPE == obj.Hdarwin {
		// To do lazy symbol lookup right, we're supposed
		// to tell the dynamic loader which library each
		// symbol comes from and format the link info
		// section just so.  I'm too lazy (ha!) to do that
		// so for now we'll just use non-lazy pointers,
		// which don't need to be told which library to use.
		//
		// http://networkpx.blogspot.com/2009/09/about-lcdyldinfoonly-command.html
		// has details about what we're avoiding.

		addgotsym(s)
		plt := ld.Linklookup(ld.Ctxt, ".plt", 0)

		ld.Adduint32(ld.Ctxt, ld.Linklookup(ld.Ctxt, ".linkedit.plt", 0), uint32(s.Dynid))

		// jmpq *got+size(IP)
		s.Plt = int32(plt.Size)

		ld.Adduint8(ld.Ctxt, plt, 0xff)
		ld.Adduint8(ld.Ctxt, plt, 0x25)
		ld.Addpcrelplus(ld.Ctxt, plt, ld.Linklookup(ld.Ctxt, ".got", 0), int64(s.Got))
	} else {
		ld.Diag("addpltsym: unsupported binary format")
	}
}

func addgotsym(s *ld.LSym) {
	if s.Got >= 0 {
		return
	}

	ld.Adddynsym(ld.Ctxt, s)
	got := ld.Linklookup(ld.Ctxt, ".got", 0)
	s.Got = int32(got.Size)
	ld.Adduint64(ld.Ctxt, got, 0)

	if ld.Iself {
		rela := ld.Linklookup(ld.Ctxt, ".rela", 0)
		ld.Addaddrplus(ld.Ctxt, rela, got, int64(s.Got))
		ld.Adduint64(ld.Ctxt, rela, ld.ELF64_R_INFO(uint32(s.Dynid), ld.R_X86_64_GLOB_DAT))
		ld.Adduint64(ld.Ctxt, rela, 0)
	} else if ld.HEADTYPE == obj.Hdarwin {
		ld.Adduint32(ld.Ctxt, ld.Linklookup(ld.Ctxt, ".linkedit.got", 0), uint32(s.Dynid))
	} else {
		ld.Diag("addgotsym: unsupported binary format")
	}
}

func asmb() {
	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f asmb\n", obj.Cputime())
	}
	ld.Bso.Flush()

	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f codeblk\n", obj.Cputime())
	}
	ld.Bso.Flush()

	if ld.Iself {
		ld.Asmbelfsetup()
	}

	sect := ld.Segtext.Sect
	ld.Cseek(int64(sect.Vaddr - ld.Segtext.Vaddr + ld.Segtext.Fileoff))
	ld.Codeblk(int64(sect.Vaddr), int64(sect.Length))
	for sect = sect.Next; sect != nil; sect = sect.Next {
		ld.Cseek(int64(sect.Vaddr - ld.Segtext.Vaddr + ld.Segtext.Fileoff))
		ld.Datblk(int64(sect.Vaddr), int64(sect.Length))
	}

	if ld.Segrodata.Filelen > 0 {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f rodatblk\n", obj.Cputime())
		}
		ld.Bso.Flush()

		ld.Cseek(int64(ld.Segrodata.Fileoff))
		ld.Datblk(int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
	}

	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f datblk\n", obj.Cputime())
	}
	ld.Bso.Flush()

	ld.Cseek(int64(ld.Segdata.Fileoff))
	ld.Datblk(int64(ld.Segdata.Vaddr), int64(ld.Segdata.Filelen))

	machlink := int64(0)
	if ld.HEADTYPE == obj.Hdarwin {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
		}

		dwarfoff := ld.Rnd(int64(uint64(ld.HEADR)+ld.Segtext.Length), int64(ld.INITRND)) + ld.Rnd(int64(ld.Segdata.Filelen), int64(ld.INITRND))
		ld.Cseek(dwarfoff)

		ld.Segdwarf.Fileoff = uint64(ld.Cpos())
		ld.Dwarfemitdebugsections()
		ld.Segdwarf.Filelen = uint64(ld.Cpos()) - ld.Segdwarf.Fileoff

		machlink = ld.Domacholink()
	}

	switch ld.HEADTYPE {
	default:
		ld.Diag("unknown header type %d", ld.HEADTYPE)
		fallthrough

	case obj.Hplan9,
		obj.Helf:
		break

	case obj.Hdarwin:
		ld.Debug['8'] = 1 /* 64-bit addresses */

	case obj.Hlinux,
		obj.Hfreebsd,
		obj.Hnetbsd,
		obj.Hopenbsd,
		obj.Hdragonfly,
		obj.Hsolaris:
		ld.Debug['8'] = 1 /* 64-bit addresses */

	case obj.Hnacl,
		obj.Hwindows:
		break
	}

	ld.Symsize = 0
	ld.Spsize = 0
	ld.Lcsize = 0
	symo := int64(0)
	if ld.Debug['s'] == 0 {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f sym\n", obj.Cputime())
		}
		ld.Bso.Flush()
		switch ld.HEADTYPE {
		default:
		case obj.Hplan9,
			obj.Helf:
			ld.Debug['s'] = 1
			symo = int64(ld.Segdata.Fileoff + ld.Segdata.Filelen)

		case obj.Hdarwin:
			symo = int64(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(ld.INITRND))) + uint64(machlink))

		case obj.Hlinux,
			obj.Hfreebsd,
			obj.Hnetbsd,
			obj.Hopenbsd,
			obj.Hdragonfly,
			obj.Hsolaris,
			obj.Hnacl:
			symo = int64(ld.Segdata.Fileoff + ld.Segdata.Filelen)
			symo = ld.Rnd(symo, int64(ld.INITRND))

		case obj.Hwindows:
			symo = int64(ld.Segdata.Fileoff + ld.Segdata.Filelen)
			symo = ld.Rnd(symo, ld.PEFILEALIGN)
		}

		ld.Cseek(symo)
		switch ld.HEADTYPE {
		default:
			if ld.Iself {
				ld.Cseek(symo)
				ld.Asmelfsym()
				ld.Cflush()
				ld.Cwrite(ld.Elfstrdat)

				if ld.Debug['v'] != 0 {
					fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
				}

				ld.Dwarfemitdebugsections()

				if ld.Linkmode == ld.LinkExternal {
					ld.Elfemitreloc()
				}
			}

		case obj.Hplan9:
			ld.Asmplan9sym()
			ld.Cflush()

			sym := ld.Linklookup(ld.Ctxt, "pclntab", 0)
			if sym != nil {
				ld.Lcsize = int32(len(sym.P))
				for i := 0; int32(i) < ld.Lcsize; i++ {
					ld.Cput(uint8(sym.P[i]))
				}

				ld.Cflush()
			}

		case obj.Hwindows:
			if ld.Debug['v'] != 0 {
				fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
			}

			ld.Dwarfemitdebugsections()

		case obj.Hdarwin:
			if ld.Linkmode == ld.LinkExternal {
				ld.Machoemitreloc()
			}
		}
	}

	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f headr\n", obj.Cputime())
	}
	ld.Bso.Flush()
	ld.Cseek(0)
	switch ld.HEADTYPE {
	default:
	case obj.Hplan9: /* plan9 */
		magic := int32(4*26*26 + 7)

		magic |= 0x00008000                  /* fat header */
		ld.Lputb(uint32(magic))              /* magic */
		ld.Lputb(uint32(ld.Segtext.Filelen)) /* sizes */
		ld.Lputb(uint32(ld.Segdata.Filelen))
		ld.Lputb(uint32(ld.Segdata.Length - ld.Segdata.Filelen))
		ld.Lputb(uint32(ld.Symsize)) /* nsyms */
		vl := ld.Entryvalue()
		ld.Lputb(PADDR(uint32(vl))) /* va of entry */
		ld.Lputb(uint32(ld.Spsize)) /* sp offsets */
		ld.Lputb(uint32(ld.Lcsize)) /* line offsets */
		ld.Vputb(uint64(vl))        /* va of entry */

	case obj.Hdarwin:
		ld.Asmbmacho()

	case obj.Hlinux,
		obj.Hfreebsd,
		obj.Hnetbsd,
		obj.Hopenbsd,
		obj.Hdragonfly,
		obj.Hsolaris,
		obj.Hnacl:
		ld.Asmbelf(symo)

	case obj.Hwindows:
		ld.Asmbpe()
	}

	ld.Cflush()
}
                                                                                                                                                                                                                                             usr/local/go/src/cmd/link/internal/amd64/l.go                                                       0100644 0000000 0000000 00000003565 13020111412 017347  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/6l/l.h
// http://code.google.com/p/inferno-os/source/browse/utils/6l/l.h
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package amd64

const (
	thechar   = '6'
	MaxAlign  = 32 // max data alignment
	FuncAlign = 16
)

const (
	MINLC = 1
)

/* Used by ../internal/ld/dwarf.go */
const (
	DWARFREGSP = 7
	DWARFREGLR = 16
)
                                                                                                                                           usr/local/go/src/cmd/link/internal/amd64/obj.go                                                     0100644 0000000 0000000 00000013263 13020111412 017662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/6l/obj.c
// http://code.google.com/p/inferno-os/source/browse/utils/6l/obj.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package amd64

import (
	"cmd/internal/obj"
	"cmd/link/internal/ld"
	"fmt"
	"log"
)

// Reading object files.

func Main() {
	linkarchinit()
	ld.Ldmain()
}

func linkarchinit() {
	ld.Thestring = "amd64"
	ld.Thelinkarch = &ld.Linkamd64
	if obj.Getgoarch() == "amd64p32" {
		ld.Thelinkarch = &ld.Linkamd64p32
	}

	ld.Thearch.Thechar = thechar
	ld.Thearch.Ptrsize = ld.Thelinkarch.Ptrsize
	ld.Thearch.Intsize = ld.Thelinkarch.Ptrsize
	ld.Thearch.Regsize = ld.Thelinkarch.Regsize
	ld.Thearch.Funcalign = FuncAlign
	ld.Thearch.Maxalign = MaxAlign
	ld.Thearch.Minlc = MINLC
	ld.Thearch.Dwarfregsp = DWARFREGSP
	ld.Thearch.Dwarfreglr = DWARFREGLR

	ld.Thearch.Adddynrel = adddynrel
	ld.Thearch.Archinit = archinit
	ld.Thearch.Archreloc = archreloc
	ld.Thearch.Archrelocvariant = archrelocvariant
	ld.Thearch.Asmb = asmb
	ld.Thearch.Elfreloc1 = elfreloc1
	ld.Thearch.Elfsetupplt = elfsetupplt
	ld.Thearch.Gentext = gentext
	ld.Thearch.Machoreloc1 = machoreloc1
	ld.Thearch.PEreloc1 = pereloc1
	ld.Thearch.Lput = ld.Lputl
	ld.Thearch.Wput = ld.Wputl
	ld.Thearch.Vput = ld.Vputl

	ld.Thearch.Linuxdynld = "/lib64/ld-linux-x86-64.so.2"
	ld.Thearch.Freebsddynld = "/libexec/ld-elf.so.1"
	ld.Thearch.Openbsddynld = "/usr/libexec/ld.so"
	ld.Thearch.Netbsddynld = "/libexec/ld.elf_so"
	ld.Thearch.Dragonflydynld = "/usr/libexec/ld-elf.so.2"
	ld.Thearch.Solarisdynld = "/lib/amd64/ld.so.1"
}

func archinit() {
	// getgoextlinkenabled is based on GO_EXTLINK_ENABLED when
	// Go was built; see ../../make.bash.
	if ld.Linkmode == ld.LinkAuto && obj.Getgoextlinkenabled() == "0" {
		ld.Linkmode = ld.LinkInternal
	}

	if ld.Buildmode == ld.BuildmodeCArchive || ld.Buildmode == ld.BuildmodeCShared || ld.DynlinkingGo() {
		ld.Linkmode = ld.LinkExternal
	}

	switch ld.HEADTYPE {
	default:
		if ld.Linkmode == ld.LinkAuto {
			ld.Linkmode = ld.LinkInternal
		}
		if ld.Linkmode == ld.LinkExternal && obj.Getgoextlinkenabled() != "1" {
			log.Fatalf("cannot use -linkmode=external with -H %s", ld.Headstr(int(ld.HEADTYPE)))
		}

	case obj.Hdarwin,
		obj.Hdragonfly,
		obj.Hfreebsd,
		obj.Hlinux,
		obj.Hnacl,
		obj.Hnetbsd,
		obj.Hopenbsd,
		obj.Hsolaris,
		obj.Hwindows:
		break
	}

	switch ld.HEADTYPE {
	default:
		ld.Exitf("unknown -H option: %v", ld.HEADTYPE)

	case obj.Hplan9: /* plan 9 */
		ld.HEADR = 32 + 8

		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x200000 + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 0x200000
		}

	case obj.Helf: /* elf32 executable */
		ld.HEADR = int32(ld.Rnd(52+3*32, 16))

		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x80110000
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}

	case obj.Hdarwin: /* apple MACH */
		ld.Machoinit()

		ld.HEADR = ld.INITIAL_MACHO_HEADR
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 4096 + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}

	case obj.Hlinux, /* elf64 executable */
		obj.Hfreebsd,   /* freebsd */
		obj.Hnetbsd,    /* netbsd */
		obj.Hopenbsd,   /* openbsd */
		obj.Hdragonfly, /* dragonfly */
		obj.Hsolaris:   /* solaris */
		ld.Elfinit()

		ld.HEADR = ld.ELFRESERVE
		if ld.INITTEXT == -1 {
			ld.INITTEXT = (1 << 22) + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}

	case obj.Hnacl:
		ld.Elfinit()
		ld.Debug['w']++ // disable dwarf, which gets confused and is useless anyway
		ld.HEADR = 0x10000
		ld.Funcalign = 32
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x20000
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 0x10000
		}

	case obj.Hwindows: /* PE executable */
		ld.Peinit()

		ld.HEADR = ld.PEFILEHEADR
		if ld.INITTEXT == -1 {
			ld.INITTEXT = ld.PEBASE + int64(ld.PESECTHEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = ld.PESECTALIGN
		}
	}

	if ld.INITDAT != 0 && ld.INITRND != 0 {
		fmt.Printf("warning: -D0x%x is ignored because of -R0x%x\n", uint64(ld.INITDAT), uint32(ld.INITRND))
	}
}
                                                                                                                                                                                                                                                                                                                                             usr/local/go/src/cmd/link/internal/amd64/z.go                                                       0100644 0000000 0000000 00000000016 13020111412 017351  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package amd64
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/go/src/cmd/link/internal/arm/                                                             0040755 0000000 0000000 00000000000 13020111412 016423  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/link/internal/arm/asm.go                                                       0100644 0000000 0000000 00000043402 13020111412 017532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5l/asm.c
// http://code.google.com/p/inferno-os/source/browse/utils/5l/asm.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm

import (
	"cmd/internal/obj"
	"cmd/link/internal/ld"
	"fmt"
	"log"
)

// This assembler:
//
//         .align 2
// local.dso_init:
//         ldr r0, .Lmoduledata
// .Lloadfrom:
//         ldr r0, [r0]
//         b runtime.addmoduledata@plt
// .align 2
// .Lmoduledata:
//         .word local.moduledata(GOT_PREL) + (. - (.Lloadfrom + 4))
// assembles to:
//
// 00000000 <local.dso_init>:
//    0:        e59f0004        ldr     r0, [pc, #4]    ; c <local.dso_init+0xc>
//    4:        e5900000        ldr     r0, [r0]
//    8:        eafffffe        b       0 <runtime.addmoduledata>
//                      8: R_ARM_JUMP24 runtime.addmoduledata
//    c:        00000004        .word   0x00000004
//                      c: R_ARM_GOT_PREL       local.moduledata

func gentext() {
	if !ld.DynlinkingGo() {
		return
	}
	addmoduledata := ld.Linklookup(ld.Ctxt, "runtime.addmoduledata", 0)
	if addmoduledata.Type == obj.STEXT {
		// we're linking a module containing the runtime -> no need for
		// an init function
		return
	}
	addmoduledata.Reachable = true
	initfunc := ld.Linklookup(ld.Ctxt, "go.link.addmoduledata", 0)
	initfunc.Type = obj.STEXT
	initfunc.Local = true
	initfunc.Reachable = true
	o := func(op uint32) {
		ld.Adduint32(ld.Ctxt, initfunc, op)
	}
	o(0xe59f0004)
	o(0xe08f0000)

	o(0xeafffffe)
	rel := ld.Addrel(initfunc)
	rel.Off = 8
	rel.Siz = 4
	rel.Sym = ld.Linklookup(ld.Ctxt, "runtime.addmoduledata", 0)
	rel.Type = obj.R_CALLARM
	rel.Add = 0xeafffffe // vomit

	o(0x00000000)
	rel = ld.Addrel(initfunc)
	rel.Off = 12
	rel.Siz = 4
	rel.Sym = ld.Ctxt.Moduledata
	rel.Type = obj.R_PCREL
	rel.Add = 4

	if ld.Ctxt.Etextp != nil {
		ld.Ctxt.Etextp.Next = initfunc
	} else {
		ld.Ctxt.Textp = initfunc
	}
	ld.Ctxt.Etextp = initfunc
	initarray_entry := ld.Linklookup(ld.Ctxt, "go.link.addmoduledatainit", 0)
	initarray_entry.Reachable = true
	initarray_entry.Local = true
	initarray_entry.Type = obj.SINITARR
	ld.Addaddr(ld.Ctxt, initarray_entry, initfunc)
}

// Preserve highest 8 bits of a, and do addition to lower 24-bit
// of a and b; used to adjust ARM branch intruction's target
func braddoff(a int32, b int32) int32 {
	return int32((uint32(a))&0xff000000 | 0x00ffffff&uint32(a+b))
}

func adddynrela(rel *ld.LSym, s *ld.LSym, r *ld.Reloc) {
	ld.Addaddrplus(ld.Ctxt, rel, s, int64(r.Off))
	ld.Adduint32(ld.Ctxt, rel, ld.R_ARM_RELATIVE)
}

func adddynrel(s *ld.LSym, r *ld.Reloc) {
	targ := r.Sym
	ld.Ctxt.Cursym = s

	switch r.Type {
	default:
		if r.Type >= 256 {
			ld.Diag("unexpected relocation type %d", r.Type)
			return
		}

		// Handle relocations found in ELF object files.
	case 256 + ld.R_ARM_PLT32:
		r.Type = obj.R_CALLARM

		if targ.Type == obj.SDYNIMPORT {
			addpltsym(ld.Ctxt, targ)
			r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
			r.Add = int64(braddoff(int32(r.Add), targ.Plt/4))
		}

		return

	case 256 + ld.R_ARM_THM_PC22: // R_ARM_THM_CALL
		ld.Exitf("R_ARM_THM_CALL, are you using -marm?")
		return

	case 256 + ld.R_ARM_GOT32: // R_ARM_GOT_BREL
		if targ.Type != obj.SDYNIMPORT {
			addgotsyminternal(ld.Ctxt, targ)
		} else {
			addgotsym(ld.Ctxt, targ)
		}

		r.Type = obj.R_CONST // write r->add during relocsym
		r.Sym = nil
		r.Add += int64(targ.Got)
		return

	case 256 + ld.R_ARM_GOT_PREL: // GOT(nil) + A - nil
		if targ.Type != obj.SDYNIMPORT {
			addgotsyminternal(ld.Ctxt, targ)
		} else {
			addgotsym(ld.Ctxt, targ)
		}

		r.Type = obj.R_PCREL
		r.Sym = ld.Linklookup(ld.Ctxt, ".got", 0)
		r.Add += int64(targ.Got) + 4
		return

	case 256 + ld.R_ARM_GOTOFF: // R_ARM_GOTOFF32
		r.Type = obj.R_GOTOFF

		return

	case 256 + ld.R_ARM_GOTPC: // R_ARM_BASE_PREL
		r.Type = obj.R_PCREL

		r.Sym = ld.Linklookup(ld.Ctxt, ".got", 0)
		r.Add += 4
		return

	case 256 + ld.R_ARM_CALL:
		r.Type = obj.R_CALLARM
		if targ.Type == obj.SDYNIMPORT {
			addpltsym(ld.Ctxt, targ)
			r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
			r.Add = int64(braddoff(int32(r.Add), targ.Plt/4))
		}

		return

	case 256 + ld.R_ARM_REL32: // R_ARM_REL32
		r.Type = obj.R_PCREL

		r.Add += 4
		return

	case 256 + ld.R_ARM_ABS32:
		if targ.Type == obj.SDYNIMPORT {
			ld.Diag("unexpected R_ARM_ABS32 relocation for dynamic symbol %s", targ.Name)
		}
		r.Type = obj.R_ADDR
		return

		// we can just ignore this, because we are targeting ARM V5+ anyway
	case 256 + ld.R_ARM_V4BX:
		if r.Sym != nil {
			// R_ARM_V4BX is ABS relocation, so this symbol is a dummy symbol, ignore it
			r.Sym.Type = 0
		}

		r.Sym = nil
		return

	case 256 + ld.R_ARM_PC24,
		256 + ld.R_ARM_JUMP24:
		r.Type = obj.R_CALLARM
		if targ.Type == obj.SDYNIMPORT {
			addpltsym(ld.Ctxt, targ)
			r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
			r.Add = int64(braddoff(int32(r.Add), targ.Plt/4))
		}

		return
	}

	// Handle references to ELF symbols from our own object files.
	if targ.Type != obj.SDYNIMPORT {
		return
	}

	switch r.Type {
	case obj.R_CALLARM:
		addpltsym(ld.Ctxt, targ)
		r.Sym = ld.Linklookup(ld.Ctxt, ".plt", 0)
		r.Add = int64(targ.Plt)
		return

	case obj.R_ADDR:
		if s.Type != obj.SDATA {
			break
		}
		if ld.Iself {
			ld.Adddynsym(ld.Ctxt, targ)
			rel := ld.Linklookup(ld.Ctxt, ".rel", 0)
			ld.Addaddrplus(ld.Ctxt, rel, s, int64(r.Off))
			ld.Adduint32(ld.Ctxt, rel, ld.ELF32_R_INFO(uint32(targ.Dynid), ld.R_ARM_GLOB_DAT)) // we need a nil + A dynamic reloc
			r.Type = obj.R_CONST                                                               // write r->add during relocsym
			r.Sym = nil
			return
		}
	}

	ld.Ctxt.Cursym = s
	ld.Diag("unsupported relocation for dynamic symbol %s (type=%d stype=%d)", targ.Name, r.Type, targ.Type)
}

func elfreloc1(r *ld.Reloc, sectoff int64) int {
	ld.Thearch.Lput(uint32(sectoff))

	elfsym := r.Xsym.ElfsymForReloc()
	switch r.Type {
	default:
		return -1

	case obj.R_ADDR:
		if r.Siz == 4 {
			ld.Thearch.Lput(ld.R_ARM_ABS32 | uint32(elfsym)<<8)
		} else {
			return -1
		}

	case obj.R_PCREL:
		if r.Siz == 4 {
			ld.Thearch.Lput(ld.R_ARM_REL32 | uint32(elfsym)<<8)
		} else {
			return -1
		}

	case obj.R_CALLARM:
		if r.Siz == 4 {
			if r.Add&0xff000000 == 0xeb000000 { // BL
				ld.Thearch.Lput(ld.R_ARM_CALL | uint32(elfsym)<<8)
			} else {
				ld.Thearch.Lput(ld.R_ARM_JUMP24 | uint32(elfsym)<<8)
			}
		} else {
			return -1
		}

	case obj.R_TLS_LE:
		ld.Thearch.Lput(ld.R_ARM_TLS_LE32 | uint32(elfsym)<<8)

	case obj.R_TLS_IE:
		ld.Thearch.Lput(ld.R_ARM_TLS_IE32 | uint32(elfsym)<<8)

	case obj.R_GOTPCREL:
		if r.Siz == 4 {
			ld.Thearch.Lput(ld.R_ARM_GOT_PREL | uint32(elfsym)<<8)
		} else {
			return -1
		}
	}

	return 0
}

func elfsetupplt() {
	plt := ld.Linklookup(ld.Ctxt, ".plt", 0)
	got := ld.Linklookup(ld.Ctxt, ".got.plt", 0)
	if plt.Size == 0 {
		// str lr, [sp, #-4]!
		ld.Adduint32(ld.Ctxt, plt, 0xe52de004)

		// ldr lr, [pc, #4]
		ld.Adduint32(ld.Ctxt, plt, 0xe59fe004)

		// add lr, pc, lr
		ld.Adduint32(ld.Ctxt, plt, 0xe08fe00e)

		// ldr pc, [lr, #8]!
		ld.Adduint32(ld.Ctxt, plt, 0xe5bef008)

		// .word &GLOBAL_OFFSET_TABLE[0] - .
		ld.Addpcrelplus(ld.Ctxt, plt, got, 4)

		// the first .plt entry requires 3 .plt.got entries
		ld.Adduint32(ld.Ctxt, got, 0)

		ld.Adduint32(ld.Ctxt, got, 0)
		ld.Adduint32(ld.Ctxt, got, 0)
	}
}

func machoreloc1(r *ld.Reloc, sectoff int64) int {
	var v uint32

	rs := r.Xsym

	if rs.Type == obj.SHOSTOBJ || r.Type == obj.R_CALLARM {
		if rs.Dynid < 0 {
			ld.Diag("reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
			return -1
		}

		v = uint32(rs.Dynid)
		v |= 1 << 27 // external relocation
	} else {
		v = uint32(rs.Sect.Extnum)
		if v == 0 {
			ld.Diag("reloc %d to symbol %s in non-macho section %s type=%d", r.Type, rs.Name, rs.Sect.Name, rs.Type)
			return -1
		}
	}

	switch r.Type {
	default:
		return -1

	case obj.R_ADDR:
		v |= ld.MACHO_GENERIC_RELOC_VANILLA << 28

	case obj.R_CALLARM:
		v |= 1 << 24 // pc-relative bit
		v |= ld.MACHO_ARM_RELOC_BR24 << 28
	}

	switch r.Siz {
	default:
		return -1

	case 1:
		v |= 0 << 25

	case 2:
		v |= 1 << 25

	case 4:
		v |= 2 << 25

	case 8:
		v |= 3 << 25
	}

	ld.Thearch.Lput(uint32(sectoff))
	ld.Thearch.Lput(v)
	return 0
}

func archreloc(r *ld.Reloc, s *ld.LSym, val *int64) int {
	if ld.Linkmode == ld.LinkExternal {
		switch r.Type {
		case obj.R_CALLARM:
			r.Done = 0

			// set up addend for eventual relocation via outer symbol.
			rs := r.Sym

			r.Xadd = r.Add
			if r.Xadd&0x800000 != 0 {
				r.Xadd |= ^0xffffff
			}
			r.Xadd *= 4
			for rs.Outer != nil {
				r.Xadd += ld.Symaddr(rs) - ld.Symaddr(rs.Outer)
				rs = rs.Outer
			}

			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
				ld.Diag("missing section for %s", rs.Name)
			}
			r.Xsym = rs

			// ld64 for arm seems to want the symbol table to contain offset
			// into the section rather than pseudo virtual address that contains
			// the section load address.
			// we need to compensate that by removing the instruction's address
			// from addend.
			if ld.HEADTYPE == obj.Hdarwin {
				r.Xadd -= ld.Symaddr(s) + int64(r.Off)
			}

			*val = int64(braddoff(int32(0xff000000&uint32(r.Add)), int32(0xffffff&uint32(r.Xadd/4))))
			return 0
		}

		return -1
	}

	switch r.Type {
	case obj.R_CONST:
		*val = r.Add
		return 0

	case obj.R_GOTOFF:
		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ld.Linklookup(ld.Ctxt, ".got", 0))
		return 0

		// The following three arch specific relocations are only for generation of
	// Linux/ARM ELF's PLT entry (3 assembler instruction)
	case obj.R_PLT0: // add ip, pc, #0xXX00000
		if ld.Symaddr(ld.Linklookup(ld.Ctxt, ".got.plt", 0)) < ld.Symaddr(ld.Linklookup(ld.Ctxt, ".plt", 0)) {
			ld.Diag(".got.plt should be placed after .plt section.")
		}
		*val = 0xe28fc600 + (0xff & (int64(uint32(ld.Symaddr(r.Sym)-(ld.Symaddr(ld.Linklookup(ld.Ctxt, ".plt", 0))+int64(r.Off))+r.Add)) >> 20))
		return 0

	case obj.R_PLT1: // add ip, ip, #0xYY000
		*val = 0xe28cca00 + (0xff & (int64(uint32(ld.Symaddr(r.Sym)-(ld.Symaddr(ld.Linklookup(ld.Ctxt, ".plt", 0))+int64(r.Off))+r.Add+4)) >> 12))

		return 0

	case obj.R_PLT2: // ldr pc, [ip, #0xZZZ]!
		*val = 0xe5bcf000 + (0xfff & int64(uint32(ld.Symaddr(r.Sym)-(ld.Symaddr(ld.Linklookup(ld.Ctxt, ".plt", 0))+int64(r.Off))+r.Add+8)))

		return 0

	case obj.R_CALLARM: // bl XXXXXX or b YYYYYY
		*val = int64(braddoff(int32(0xff000000&uint32(r.Add)), int32(0xffffff&uint32((ld.Symaddr(r.Sym)+int64((uint32(r.Add))*4)-(s.Value+int64(r.Off)))/4))))

		return 0
	}

	return -1
}

func archrelocvariant(r *ld.Reloc, s *ld.LSym, t int64) int64 {
	log.Fatalf("unexpected relocation variant")
	return t
}

func addpltreloc(ctxt *ld.Link, plt *ld.LSym, got *ld.LSym, sym *ld.LSym, typ int) *ld.Reloc {
	r := ld.Addrel(plt)
	r.Sym = got
	r.Off = int32(plt.Size)
	r.Siz = 4
	r.Type = int32(typ)
	r.Add = int64(sym.Got) - 8

	plt.Reachable = true
	plt.Size += 4
	ld.Symgrow(ctxt, plt, plt.Size)

	return r
}

func addpltsym(ctxt *ld.Link, s *ld.LSym) {
	if s.Plt >= 0 {
		return
	}

	ld.Adddynsym(ctxt, s)

	if ld.Iself {
		plt := ld.Linklookup(ctxt, ".plt", 0)
		got := ld.Linklookup(ctxt, ".got.plt", 0)
		rel := ld.Linklookup(ctxt, ".rel.plt", 0)
		if plt.Size == 0 {
			elfsetupplt()
		}

		// .got entry
		s.Got = int32(got.Size)

		// In theory, all GOT should point to the first PLT entry,
		// Linux/ARM's dynamic linker will do that for us, but FreeBSD/ARM's
		// dynamic linker won't, so we'd better do it ourselves.
		ld.Addaddrplus(ctxt, got, plt, 0)

		// .plt entry, this depends on the .got entry
		s.Plt = int32(plt.Size)

		addpltreloc(ctxt, plt, got, s, obj.R_PLT0) // add lr, pc, #0xXX00000
		addpltreloc(ctxt, plt, got, s, obj.R_PLT1) // add lr, lr, #0xYY000
		addpltreloc(ctxt, plt, got, s, obj.R_PLT2) // ldr pc, [lr, #0xZZZ]!

		// rel
		ld.Addaddrplus(ctxt, rel, got, int64(s.Got))

		ld.Adduint32(ctxt, rel, ld.ELF32_R_INFO(uint32(s.Dynid), ld.R_ARM_JUMP_SLOT))
	} else {
		ld.Diag("addpltsym: unsupported binary format")
	}
}

func addgotsyminternal(ctxt *ld.Link, s *ld.LSym) {
	if s.Got >= 0 {
		return
	}

	got := ld.Linklookup(ctxt, ".got", 0)
	s.Got = int32(got.Size)

	ld.Addaddrplus(ctxt, got, s, 0)

	if ld.Iself {
	} else {
		ld.Diag("addgotsyminternal: unsupported binary format")
	}
}

func addgotsym(ctxt *ld.Link, s *ld.LSym) {
	if s.Got >= 0 {
		return
	}

	ld.Adddynsym(ctxt, s)
	got := ld.Linklookup(ctxt, ".got", 0)
	s.Got = int32(got.Size)
	ld.Adduint32(ctxt, got, 0)

	if ld.Iself {
		rel := ld.Linklookup(ctxt, ".rel", 0)
		ld.Addaddrplus(ctxt, rel, got, int64(s.Got))
		ld.Adduint32(ctxt, rel, ld.ELF32_R_INFO(uint32(s.Dynid), ld.R_ARM_GLOB_DAT))
	} else {
		ld.Diag("addgotsym: unsupported binary format")
	}
}

func asmb() {
	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f asmb\n", obj.Cputime())
	}
	ld.Bso.Flush()

	if ld.Iself {
		ld.Asmbelfsetup()
	}

	sect := ld.Segtext.Sect
	ld.Cseek(int64(sect.Vaddr - ld.Segtext.Vaddr + ld.Segtext.Fileoff))
	ld.Codeblk(int64(sect.Vaddr), int64(sect.Length))
	for sect = sect.Next; sect != nil; sect = sect.Next {
		ld.Cseek(int64(sect.Vaddr - ld.Segtext.Vaddr + ld.Segtext.Fileoff))
		ld.Datblk(int64(sect.Vaddr), int64(sect.Length))
	}

	if ld.Segrodata.Filelen > 0 {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f rodatblk\n", obj.Cputime())
		}
		ld.Bso.Flush()

		ld.Cseek(int64(ld.Segrodata.Fileoff))
		ld.Datblk(int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
	}

	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f datblk\n", obj.Cputime())
	}
	ld.Bso.Flush()

	ld.Cseek(int64(ld.Segdata.Fileoff))
	ld.Datblk(int64(ld.Segdata.Vaddr), int64(ld.Segdata.Filelen))

	machlink := uint32(0)
	if ld.HEADTYPE == obj.Hdarwin {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
		}

		dwarfoff := uint32(ld.Rnd(int64(uint64(ld.HEADR)+ld.Segtext.Length), int64(ld.INITRND)) + ld.Rnd(int64(ld.Segdata.Filelen), int64(ld.INITRND)))
		ld.Cseek(int64(dwarfoff))

		ld.Segdwarf.Fileoff = uint64(ld.Cpos())
		ld.Dwarfemitdebugsections()
		ld.Segdwarf.Filelen = uint64(ld.Cpos()) - ld.Segdwarf.Fileoff

		machlink = uint32(ld.Domacholink())
	}

	/* output symbol table */
	ld.Symsize = 0

	ld.Lcsize = 0
	symo := uint32(0)
	if ld.Debug['s'] == 0 {
		// TODO: rationalize
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f sym\n", obj.Cputime())
		}
		ld.Bso.Flush()
		switch ld.HEADTYPE {
		default:
			if ld.Iself {
				symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
				symo = uint32(ld.Rnd(int64(symo), int64(ld.INITRND)))
			}

		case obj.Hplan9:
			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)

		case obj.Hdarwin:
			symo = uint32(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(ld.INITRND))) + uint64(machlink))
		}

		ld.Cseek(int64(symo))
		switch ld.HEADTYPE {
		default:
			if ld.Iself {
				if ld.Debug['v'] != 0 {
					fmt.Fprintf(&ld.Bso, "%5.2f elfsym\n", obj.Cputime())
				}
				ld.Asmelfsym()
				ld.Cflush()
				ld.Cwrite(ld.Elfstrdat)

				if ld.Debug['v'] != 0 {
					fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
				}
				ld.Dwarfemitdebugsections()

				if ld.Linkmode == ld.LinkExternal {
					ld.Elfemitreloc()
				}
			}

		case obj.Hplan9:
			ld.Asmplan9sym()
			ld.Cflush()

			sym := ld.Linklookup(ld.Ctxt, "pclntab", 0)
			if sym != nil {
				ld.Lcsize = int32(len(sym.P))
				for i := 0; int32(i) < ld.Lcsize; i++ {
					ld.Cput(uint8(sym.P[i]))
				}

				ld.Cflush()
			}

		case obj.Hdarwin:
			if ld.Linkmode == ld.LinkExternal {
				ld.Machoemitreloc()
			}
		}
	}

	ld.Ctxt.Cursym = nil
	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f header\n", obj.Cputime())
	}
	ld.Bso.Flush()
	ld.Cseek(0)
	switch ld.HEADTYPE {
	default:
	case obj.Hplan9: /* plan 9 */
		ld.Lputb(0x647)                      /* magic */
		ld.Lputb(uint32(ld.Segtext.Filelen)) /* sizes */
		ld.Lputb(uint32(ld.Segdata.Filelen))
		ld.Lputb(uint32(ld.Segdata.Length - ld.Segdata.Filelen))
		ld.Lputb(uint32(ld.Symsize))      /* nsyms */
		ld.Lputb(uint32(ld.Entryvalue())) /* va of entry */
		ld.Lputb(0)
		ld.Lputb(uint32(ld.Lcsize))

	case obj.Hlinux,
		obj.Hfreebsd,
		obj.Hnetbsd,
		obj.Hopenbsd,
		obj.Hnacl:
		ld.Asmbelf(int64(symo))

	case obj.Hdarwin:
		ld.Asmbmacho()
	}

	ld.Cflush()
	if ld.Debug['c'] != 0 {
		fmt.Printf("textsize=%d\n", ld.Segtext.Filelen)
		fmt.Printf("datsize=%d\n", ld.Segdata.Filelen)
		fmt.Printf("bsssize=%d\n", ld.Segdata.Length-ld.Segdata.Filelen)
		fmt.Printf("symsize=%d\n", ld.Symsize)
		fmt.Printf("lcsize=%d\n", ld.Lcsize)
		fmt.Printf("total=%d\n", ld.Segtext.Filelen+ld.Segdata.Length+uint64(ld.Symsize)+uint64(ld.Lcsize))
	}
}
                                                                                                                                                                                                                                                              usr/local/go/src/cmd/link/internal/arm/l.go                                                         0100644 0000000 0000000 00000007126 13020111412 017210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5l/asm.c
// http://code.google.com/p/inferno-os/source/browse/utils/5l/asm.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm

// Writing object files.

// Inferno utils/5l/l.h
// http://code.google.com/p/inferno-os/source/browse/utils/5l/l.h
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

const (
	thechar   = '5'
	MaxAlign  = 8 // max data alignment
	FuncAlign = 4 // single-instruction alignment
	MINLC     = 4
)

/* Used by ../internal/ld/dwarf.go */
const (
	DWARFREGSP = 13
	DWARFREGLR = 14
)
                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/go/src/cmd/link/internal/arm/obj.go                                                       0100644 0000000 0000000 00000011540 13020111412 017522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5l/obj.c
// http://code.google.com/p/inferno-os/source/browse/utils/5l/obj.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm

import (
	"cmd/internal/obj"
	"cmd/link/internal/ld"
	"fmt"
	"log"
)

// Reading object files.

func Main() {
	linkarchinit()
	ld.Ldmain()
}

func linkarchinit() {
	ld.Thestring = "arm"
	ld.Thelinkarch = &ld.Linkarm

	ld.Thearch.Thechar = thechar
	ld.Thearch.Ptrsize = ld.Thelinkarch.Ptrsize
	ld.Thearch.Intsize = ld.Thelinkarch.Ptrsize
	ld.Thearch.Regsize = ld.Thelinkarch.Regsize
	ld.Thearch.Funcalign = FuncAlign
	ld.Thearch.Maxalign = MaxAlign
	ld.Thearch.Minlc = MINLC
	ld.Thearch.Dwarfregsp = DWARFREGSP
	ld.Thearch.Dwarfreglr = DWARFREGLR

	ld.Thearch.Adddynrel = adddynrel
	ld.Thearch.Archinit = archinit
	ld.Thearch.Archreloc = archreloc
	ld.Thearch.Archrelocvariant = archrelocvariant
	ld.Thearch.Asmb = asmb
	ld.Thearch.Elfreloc1 = elfreloc1
	ld.Thearch.Elfsetupplt = elfsetupplt
	ld.Thearch.Gentext = gentext
	ld.Thearch.Machoreloc1 = machoreloc1
	ld.Thearch.Lput = ld.Lputl
	ld.Thearch.Wput = ld.Wputl
	ld.Thearch.Vput = ld.Vputl

	ld.Thearch.Linuxdynld = "/lib/ld-linux.so.3" // 2 for OABI, 3 for EABI
	ld.Thearch.Freebsddynld = "/usr/libexec/ld-elf.so.1"
	ld.Thearch.Openbsddynld = "/usr/libexec/ld.so"
	ld.Thearch.Netbsddynld = "/libexec/ld.elf_so"
	ld.Thearch.Dragonflydynld = "XXX"
	ld.Thearch.Solarisdynld = "XXX"
}

func archinit() {
	// getgoextlinkenabled is based on GO_EXTLINK_ENABLED when
	// Go was built; see ../../make.bash.
	if ld.Linkmode == ld.LinkAuto && obj.Getgoextlinkenabled() == "0" {
		ld.Linkmode = ld.LinkInternal
	}

	if ld.Buildmode == ld.BuildmodeCArchive || ld.Buildmode == ld.BuildmodeCShared || ld.DynlinkingGo() {
		ld.Linkmode = ld.LinkExternal
	}

	switch ld.HEADTYPE {
	default:
		if ld.Linkmode == ld.LinkAuto {
			ld.Linkmode = ld.LinkInternal
		}
		if ld.Linkmode == ld.LinkExternal && obj.Getgoextlinkenabled() != "1" {
			log.Fatalf("cannot use -linkmode=external with -H %s", ld.Headstr(int(ld.HEADTYPE)))
		}

	case obj.Hlinux,
		obj.Hfreebsd,
		obj.Hnacl,
		obj.Hdarwin:
		break
	}

	switch ld.HEADTYPE {
	default:
		ld.Exitf("unknown -H option: %v", ld.HEADTYPE)

	case obj.Hplan9: /* plan 9 */
		ld.HEADR = 32

		if ld.INITTEXT == -1 {
			ld.INITTEXT = 4128
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}

	case obj.Hlinux, /* arm elf */
		obj.Hfreebsd,
		obj.Hnetbsd,
		obj.Hopenbsd:
		ld.Debug['d'] = 0
		// with dynamic linking
		ld.Elfinit()
		ld.HEADR = ld.ELFRESERVE
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x10000 + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}

	case obj.Hnacl:
		ld.Elfinit()
		ld.HEADR = 0x10000
		ld.Funcalign = 16
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x20000
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 0x10000
		}

	case obj.Hdarwin: /* apple MACH */
		ld.Debug['w'] = 1 // disable DWARF generataion
		ld.Machoinit()
		ld.HEADR = ld.INITIAL_MACHO_HEADR
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 4096 + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}
	}

	if ld.INITDAT != 0 && ld.INITRND != 0 {
		fmt.Printf("warning: -D0x%x is ignored because of -R0x%x\n", uint64(ld.INITDAT), uint32(ld.INITRND))
	}
}
                                                                                                                                                                usr/local/go/src/cmd/link/internal/arm64/                                                           0040755 0000000 0000000 00000000000 13020111412 016575  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/link/internal/arm64/asm.go                                                     0100644 0000000 0000000 00000036556 13020111412 017720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5l/asm.c
// http://code.google.com/p/inferno-os/source/browse/utils/5l/asm.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm64

import (
	"cmd/internal/obj"
	"cmd/link/internal/ld"
	"encoding/binary"
	"fmt"
	"log"
)

func gentext() {
	if !ld.DynlinkingGo() {
		return
	}
	addmoduledata := ld.Linklookup(ld.Ctxt, "runtime.addmoduledata", 0)
	if addmoduledata.Type == obj.STEXT {
		// we're linking a module containing the runtime -> no need for
		// an init function
		return
	}
	addmoduledata.Reachable = true
	initfunc := ld.Linklookup(ld.Ctxt, "go.link.addmoduledata", 0)
	initfunc.Type = obj.STEXT
	initfunc.Local = true
	initfunc.Reachable = true
	o := func(op uint32) {
		ld.Adduint32(ld.Ctxt, initfunc, op)
	}
	// 0000000000000000 <local.dso_init>:
	// 0:	90000000 	adrp	x0, 0 <runtime.firstmoduledata>
	// 	0: R_AARCH64_ADR_PREL_PG_HI21	local.moduledata
	// 4:	91000000 	add	x0, x0, #0x0
	// 	4: R_AARCH64_ADD_ABS_LO12_NC	local.moduledata
	o(0x90000000)
	o(0x91000000)
	rel := ld.Addrel(initfunc)
	rel.Off = 0
	rel.Siz = 8
	rel.Sym = ld.Ctxt.Moduledata
	rel.Type = obj.R_ADDRARM64

	// 8:	14000000 	bl	0 <runtime.addmoduledata>
	// 	8: R_AARCH64_CALL26	runtime.addmoduledata
	o(0x14000000)
	rel = ld.Addrel(initfunc)
	rel.Off = 8
	rel.Siz = 4
	rel.Sym = ld.Linklookup(ld.Ctxt, "runtime.addmoduledata", 0)
	rel.Type = obj.R_CALLARM64 // Really should be R_AARCH64_JUMP26 but doesn't seem to make any difference

	if ld.Ctxt.Etextp != nil {
		ld.Ctxt.Etextp.Next = initfunc
	} else {
		ld.Ctxt.Textp = initfunc
	}
	ld.Ctxt.Etextp = initfunc
	initarray_entry := ld.Linklookup(ld.Ctxt, "go.link.addmoduledatainit", 0)
	initarray_entry.Reachable = true
	initarray_entry.Local = true
	initarray_entry.Type = obj.SINITARR
	ld.Addaddr(ld.Ctxt, initarray_entry, initfunc)
}

func adddynrela(rel *ld.LSym, s *ld.LSym, r *ld.Reloc) {
	log.Fatalf("adddynrela not implemented")
}

func adddynrel(s *ld.LSym, r *ld.Reloc) {
	log.Fatalf("adddynrel not implemented")
}

func elfreloc1(r *ld.Reloc, sectoff int64) int {
	ld.Thearch.Vput(uint64(sectoff))

	elfsym := r.Xsym.ElfsymForReloc()
	switch r.Type {
	default:
		return -1

	case obj.R_ADDR:
		switch r.Siz {
		case 4:
			ld.Thearch.Vput(ld.R_AARCH64_ABS32 | uint64(elfsym)<<32)
		case 8:
			ld.Thearch.Vput(ld.R_AARCH64_ABS64 | uint64(elfsym)<<32)
		default:
			return -1
		}

	case obj.R_ADDRARM64:
		// two relocations: R_AARCH64_ADR_PREL_PG_HI21 and R_AARCH64_ADD_ABS_LO12_NC
		ld.Thearch.Vput(ld.R_AARCH64_ADR_PREL_PG_HI21 | uint64(elfsym)<<32)
		ld.Thearch.Vput(uint64(r.Xadd))
		ld.Thearch.Vput(uint64(sectoff + 4))
		ld.Thearch.Vput(ld.R_AARCH64_ADD_ABS_LO12_NC | uint64(elfsym)<<32)

	case obj.R_ARM64_TLS_LE:
		ld.Thearch.Vput(ld.R_AARCH64_TLSLE_MOVW_TPREL_G0 | uint64(elfsym)<<32)

	case obj.R_ARM64_TLS_IE:
		ld.Thearch.Vput(ld.R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 | uint64(elfsym)<<32)
		ld.Thearch.Vput(uint64(r.Xadd))
		ld.Thearch.Vput(uint64(sectoff + 4))
		ld.Thearch.Vput(ld.R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC | uint64(elfsym)<<32)

	case obj.R_ARM64_GOTPCREL:
		ld.Thearch.Vput(ld.R_AARCH64_ADR_GOT_PAGE | uint64(elfsym)<<32)
		ld.Thearch.Vput(uint64(r.Xadd))
		ld.Thearch.Vput(uint64(sectoff + 4))
		ld.Thearch.Vput(ld.R_AARCH64_LD64_GOT_LO12_NC | uint64(elfsym)<<32)

	case obj.R_CALLARM64:
		if r.Siz != 4 {
			return -1
		}
		ld.Thearch.Vput(ld.R_AARCH64_CALL26 | uint64(elfsym)<<32)

	}
	ld.Thearch.Vput(uint64(r.Xadd))

	return 0
}

func elfsetupplt() {
	// TODO(aram)
	return
}

func machoreloc1(r *ld.Reloc, sectoff int64) int {
	var v uint32

	rs := r.Xsym

	// ld64 has a bug handling MACHO_ARM64_RELOC_UNSIGNED with !extern relocation.
	// see cmd/internal/ld/data.go for details. The workarond is that don't use !extern
	// UNSIGNED relocation at all.
	if rs.Type == obj.SHOSTOBJ || r.Type == obj.R_CALLARM64 || r.Type == obj.R_ADDRARM64 || r.Type == obj.R_ADDR {
		if rs.Dynid < 0 {
			ld.Diag("reloc %d to non-macho symbol %s type=%d", r.Type, rs.Name, rs.Type)
			return -1
		}

		v = uint32(rs.Dynid)
		v |= 1 << 27 // external relocation
	} else {
		v = uint32(rs.Sect.Extnum)
		if v == 0 {
			ld.Diag("reloc %d to symbol %s in non-macho section %s type=%d", r.Type, rs.Name, rs.Sect.Name, rs.Type)
			return -1
		}
	}

	switch r.Type {
	default:
		return -1

	case obj.R_ADDR:
		v |= ld.MACHO_ARM64_RELOC_UNSIGNED << 28

	case obj.R_CALLARM64:
		if r.Xadd != 0 {
			ld.Diag("ld64 doesn't allow BR26 reloc with non-zero addend: %s+%d", rs.Name, r.Xadd)
		}

		v |= 1 << 24 // pc-relative bit
		v |= ld.MACHO_ARM64_RELOC_BRANCH26 << 28

	case obj.R_ADDRARM64:
		r.Siz = 4
		// Two relocation entries: MACHO_ARM64_RELOC_PAGEOFF12 MACHO_ARM64_RELOC_PAGE21
		// if r.Xadd is non-zero, add two MACHO_ARM64_RELOC_ADDEND.
		if r.Xadd != 0 {
			ld.Thearch.Lput(uint32(sectoff + 4))
			ld.Thearch.Lput((ld.MACHO_ARM64_RELOC_ADDEND << 28) | (2 << 25) | uint32(r.Xadd&0xffffff))
		}
		ld.Thearch.Lput(uint32(sectoff + 4))
		ld.Thearch.Lput(v | (ld.MACHO_ARM64_RELOC_PAGEOFF12 << 28) | (2 << 25))
		if r.Xadd != 0 {
			ld.Thearch.Lput(uint32(sectoff))
			ld.Thearch.Lput((ld.MACHO_ARM64_RELOC_ADDEND << 28) | (2 << 25) | uint32(r.Xadd&0xffffff))
		}
		v |= 1 << 24 // pc-relative bit
		v |= ld.MACHO_ARM64_RELOC_PAGE21 << 28
	}

	switch r.Siz {
	default:
		return -1

	case 1:
		v |= 0 << 25

	case 2:
		v |= 1 << 25

	case 4:
		v |= 2 << 25

	case 8:
		v |= 3 << 25
	}

	ld.Thearch.Lput(uint32(sectoff))
	ld.Thearch.Lput(v)
	return 0
}

func archreloc(r *ld.Reloc, s *ld.LSym, val *int64) int {
	if ld.Linkmode == ld.LinkExternal {
		switch r.Type {
		default:
			return -1

		case obj.R_ARM64_GOTPCREL:
			var o1, o2 uint32
			if ld.Ctxt.Arch.ByteOrder == binary.BigEndian {
				o1 = uint32(*val >> 32)
				o2 = uint32(*val)
			} else {
				o1 = uint32(*val)
				o2 = uint32(*val >> 32)
			}
			// Any relocation against a function symbol is redirected to
			// be against a local symbol instead (see putelfsym in
			// symtab.go) but unfortunately the system linker was buggy
			// when confronted with a R_AARCH64_ADR_GOT_PAGE relocation
			// against a local symbol until May 2015
			// (https://sourceware.org/bugzilla/show_bug.cgi?id=18270). So
			// we convert the adrp; ld64 + R_ARM64_GOTPCREL into adrp;
			// add + R_ADDRARM64.
			if !(r.Sym.Version != 0 || (r.Sym.Type&obj.SHIDDEN != 0) || r.Sym.Local) && r.Sym.Type == obj.STEXT && ld.DynlinkingGo() {
				if o2&0xffc00000 != 0xf9400000 {
					ld.Ctxt.Diag("R_ARM64_GOTPCREL against unexpected instruction %x", o2)
				}
				o2 = 0x91000000 | (o2 & 0x000003ff)
				r.Type = obj.R_ADDRARM64
			}
			if ld.Ctxt.Arch.ByteOrder == binary.BigEndian {
				*val = int64(o1)<<32 | int64(o2)
			} else {
				*val = int64(o2)<<32 | int64(o1)
			}
			fallthrough

		case obj.R_ADDRARM64:
			r.Done = 0

			// set up addend for eventual relocation via outer symbol.
			rs := r.Sym
			r.Xadd = r.Add
			for rs.Outer != nil {
				r.Xadd += ld.Symaddr(rs) - ld.Symaddr(rs.Outer)
				rs = rs.Outer
			}

			if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
				ld.Diag("missing section for %s", rs.Name)
			}
			r.Xsym = rs

			// Note: ld64 currently has a bug that any non-zero addend for BR26 relocation
			// will make the linking fail because it thinks the code is not PIC even though
			// the BR26 relocation should be fully resolved at link time.
			// That is the reason why the next if block is disabled. When the bug in ld64
			// is fixed, we can enable this block and also enable duff's device in cmd/7g.
			if false && ld.HEADTYPE == obj.Hdarwin {
				var o0, o1 uint32

				if ld.Ctxt.Arch.ByteOrder == binary.BigEndian {
					o0 = uint32(*val >> 32)
					o1 = uint32(*val)
				} else {
					o0 = uint32(*val)
					o1 = uint32(*val >> 32)
				}
				// Mach-O wants the addend to be encoded in the instruction
				// Note that although Mach-O supports ARM64_RELOC_ADDEND, it
				// can only encode 24-bit of signed addend, but the instructions
				// supports 33-bit of signed addend, so we always encode the
				// addend in place.
				o0 |= (uint32((r.Xadd>>12)&3) << 29) | (uint32((r.Xadd>>12>>2)&0x7ffff) << 5)
				o1 |= uint32(r.Xadd&0xfff) << 10
				r.Xadd = 0

				// when laid out, the instruction order must always be o1, o2.
				if ld.Ctxt.Arch.ByteOrder == binary.BigEndian {
					*val = int64(o0)<<32 | int64(o1)
				} else {
					*val = int64(o1)<<32 | int64(o0)
				}
			}

			return 0

		case obj.R_CALLARM64,
			obj.R_ARM64_TLS_LE,
			obj.R_ARM64_TLS_IE:
			r.Done = 0
			r.Xsym = r.Sym
			r.Xadd = r.Add
			return 0
		}
	}

	switch r.Type {
	case obj.R_CONST:
		*val = r.Add
		return 0

	case obj.R_GOTOFF:
		*val = ld.Symaddr(r.Sym) + r.Add - ld.Symaddr(ld.Linklookup(ld.Ctxt, ".got", 0))
		return 0

	case obj.R_ADDRARM64:
		t := ld.Symaddr(r.Sym) + r.Add - ((s.Value + int64(r.Off)) &^ 0xfff)
		if t >= 1<<32 || t < -1<<32 {
			ld.Diag("program too large, address relocation distance = %d", t)
		}

		var o0, o1 uint32

		if ld.Ctxt.Arch.ByteOrder == binary.BigEndian {
			o0 = uint32(*val >> 32)
			o1 = uint32(*val)
		} else {
			o0 = uint32(*val)
			o1 = uint32(*val >> 32)
		}

		o0 |= (uint32((t>>12)&3) << 29) | (uint32((t>>12>>2)&0x7ffff) << 5)
		o1 |= uint32(t&0xfff) << 10

		// when laid out, the instruction order must always be o1, o2.
		if ld.Ctxt.Arch.ByteOrder == binary.BigEndian {
			*val = int64(o0)<<32 | int64(o1)
		} else {
			*val = int64(o1)<<32 | int64(o0)
		}
		return 0

	case obj.R_ARM64_TLS_LE:
		r.Done = 0
		if ld.HEADTYPE != obj.Hlinux {
			ld.Diag("TLS reloc on unsupported OS %s", ld.Headstr(int(ld.HEADTYPE)))
		}
		// The TCB is two pointers. This is not documented anywhere, but is
		// de facto part of the ABI.
		v := r.Sym.Value + int64(2*ld.Thearch.Ptrsize)
		if v < 0 || v >= 32678 {
			ld.Diag("TLS offset out of range %d", v)
		}
		*val |= v << 5
		return 0

	case obj.R_CALLARM64:
		t := (ld.Symaddr(r.Sym) + r.Add) - (s.Value + int64(r.Off))
		if t >= 1<<27 || t < -1<<27 {
			ld.Diag("program too large, call relocation distance = %d", t)
		}
		*val |= (t >> 2) & 0x03ffffff
		return 0
	}

	return -1
}

func archrelocvariant(r *ld.Reloc, s *ld.LSym, t int64) int64 {
	log.Fatalf("unexpected relocation variant")
	return -1
}

func asmb() {
	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f asmb\n", obj.Cputime())
	}
	ld.Bso.Flush()

	if ld.Iself {
		ld.Asmbelfsetup()
	}

	sect := ld.Segtext.Sect
	ld.Cseek(int64(sect.Vaddr - ld.Segtext.Vaddr + ld.Segtext.Fileoff))
	ld.Codeblk(int64(sect.Vaddr), int64(sect.Length))
	for sect = sect.Next; sect != nil; sect = sect.Next {
		ld.Cseek(int64(sect.Vaddr - ld.Segtext.Vaddr + ld.Segtext.Fileoff))
		ld.Datblk(int64(sect.Vaddr), int64(sect.Length))
	}

	if ld.Segrodata.Filelen > 0 {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f rodatblk\n", obj.Cputime())
		}
		ld.Bso.Flush()

		ld.Cseek(int64(ld.Segrodata.Fileoff))
		ld.Datblk(int64(ld.Segrodata.Vaddr), int64(ld.Segrodata.Filelen))
	}

	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f datblk\n", obj.Cputime())
	}
	ld.Bso.Flush()

	ld.Cseek(int64(ld.Segdata.Fileoff))
	ld.Datblk(int64(ld.Segdata.Vaddr), int64(ld.Segdata.Filelen))

	machlink := uint32(0)
	if ld.HEADTYPE == obj.Hdarwin {
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
		}

		dwarfoff := uint32(ld.Rnd(int64(uint64(ld.HEADR)+ld.Segtext.Length), int64(ld.INITRND)) + ld.Rnd(int64(ld.Segdata.Filelen), int64(ld.INITRND)))
		ld.Cseek(int64(dwarfoff))

		ld.Segdwarf.Fileoff = uint64(ld.Cpos())
		ld.Dwarfemitdebugsections()
		ld.Segdwarf.Filelen = uint64(ld.Cpos()) - ld.Segdwarf.Fileoff

		machlink = uint32(ld.Domacholink())
	}

	/* output symbol table */
	ld.Symsize = 0

	ld.Lcsize = 0
	symo := uint32(0)
	if ld.Debug['s'] == 0 {
		// TODO: rationalize
		if ld.Debug['v'] != 0 {
			fmt.Fprintf(&ld.Bso, "%5.2f sym\n", obj.Cputime())
		}
		ld.Bso.Flush()
		switch ld.HEADTYPE {
		default:
			if ld.Iself {
				symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)
				symo = uint32(ld.Rnd(int64(symo), int64(ld.INITRND)))
			}

		case obj.Hplan9:
			symo = uint32(ld.Segdata.Fileoff + ld.Segdata.Filelen)

		case obj.Hdarwin:
			symo = uint32(ld.Segdwarf.Fileoff + uint64(ld.Rnd(int64(ld.Segdwarf.Filelen), int64(ld.INITRND))) + uint64(machlink))
		}

		ld.Cseek(int64(symo))
		switch ld.HEADTYPE {
		default:
			if ld.Iself {
				if ld.Debug['v'] != 0 {
					fmt.Fprintf(&ld.Bso, "%5.2f elfsym\n", obj.Cputime())
				}
				ld.Asmelfsym()
				ld.Cflush()
				ld.Cwrite(ld.Elfstrdat)

				if ld.Debug['v'] != 0 {
					fmt.Fprintf(&ld.Bso, "%5.2f dwarf\n", obj.Cputime())
				}
				ld.Dwarfemitdebugsections()

				if ld.Linkmode == ld.LinkExternal {
					ld.Elfemitreloc()
				}
			}

		case obj.Hplan9:
			ld.Asmplan9sym()
			ld.Cflush()

			sym := ld.Linklookup(ld.Ctxt, "pclntab", 0)
			if sym != nil {
				ld.Lcsize = int32(len(sym.P))
				for i := 0; int32(i) < ld.Lcsize; i++ {
					ld.Cput(uint8(sym.P[i]))
				}

				ld.Cflush()
			}

		case obj.Hdarwin:
			if ld.Linkmode == ld.LinkExternal {
				ld.Machoemitreloc()
			}
		}
	}

	ld.Ctxt.Cursym = nil
	if ld.Debug['v'] != 0 {
		fmt.Fprintf(&ld.Bso, "%5.2f header\n", obj.Cputime())
	}
	ld.Bso.Flush()
	ld.Cseek(0)
	switch ld.HEADTYPE {
	default:
	case obj.Hplan9: /* plan 9 */
		ld.Thearch.Lput(0x647)                      /* magic */
		ld.Thearch.Lput(uint32(ld.Segtext.Filelen)) /* sizes */
		ld.Thearch.Lput(uint32(ld.Segdata.Filelen))
		ld.Thearch.Lput(uint32(ld.Segdata.Length - ld.Segdata.Filelen))
		ld.Thearch.Lput(uint32(ld.Symsize))      /* nsyms */
		ld.Thearch.Lput(uint32(ld.Entryvalue())) /* va of entry */
		ld.Thearch.Lput(0)
		ld.Thearch.Lput(uint32(ld.Lcsize))

	case obj.Hlinux,
		obj.Hfreebsd,
		obj.Hnetbsd,
		obj.Hopenbsd,
		obj.Hnacl:
		ld.Asmbelf(int64(symo))

	case obj.Hdarwin:
		ld.Asmbmacho()
	}

	ld.Cflush()
	if ld.Debug['c'] != 0 {
		fmt.Printf("textsize=%d\n", ld.Segtext.Filelen)
		fmt.Printf("datsize=%d\n", ld.Segdata.Filelen)
		fmt.Printf("bsssize=%d\n", ld.Segdata.Length-ld.Segdata.Filelen)
		fmt.Printf("symsize=%d\n", ld.Symsize)
		fmt.Printf("lcsize=%d\n", ld.Lcsize)
		fmt.Printf("total=%d\n", ld.Segtext.Filelen+ld.Segdata.Length+uint64(ld.Symsize)+uint64(ld.Lcsize))
	}
}
                                                                                                                                                  usr/local/go/src/cmd/link/internal/arm64/l.go                                                       0100644 0000000 0000000 00000006776 13020111412 017374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5l/asm.c
// http://code.google.com/p/inferno-os/source/browse/utils/5l/asm.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm64

// Writing object files.

// cmd/9l/l.h from Vita Nuova.
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2008 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2008 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

const (
	thechar   = '7'
	MaxAlign  = 32 // max data alignment
	FuncAlign = 8
	MINLC     = 4
)

/* Used by ../internal/ld/dwarf.go */
const (
	DWARFREGSP = 31
	DWARFREGLR = 30
)
  usr/local/go/src/cmd/link/internal/arm64/obj.go                                                     0100644 0000000 0000000 00000011376 13020111412 017703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5l/obj.c
// http://code.google.com/p/inferno-os/source/browse/utils/5l/obj.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm64

import (
	"cmd/internal/obj"
	"cmd/link/internal/ld"
	"fmt"
	"log"
)

// Reading object files.

func Main() {
	linkarchinit()
	ld.Ldmain()
}

func linkarchinit() {
	ld.Thestring = obj.Getgoarch()
	ld.Thelinkarch = &ld.Linkarm64

	ld.Thearch.Thechar = thechar
	ld.Thearch.Ptrsize = ld.Thelinkarch.Ptrsize
	ld.Thearch.Intsize = ld.Thelinkarch.Ptrsize
	ld.Thearch.Regsize = ld.Thelinkarch.Regsize
	ld.Thearch.Funcalign = FuncAlign
	ld.Thearch.Maxalign = MaxAlign
	ld.Thearch.Minlc = MINLC
	ld.Thearch.Dwarfregsp = DWARFREGSP
	ld.Thearch.Dwarfreglr = DWARFREGLR

	ld.Thearch.Adddynrel = adddynrel
	ld.Thearch.Archinit = archinit
	ld.Thearch.Archreloc = archreloc
	ld.Thearch.Archrelocvariant = archrelocvariant
	ld.Thearch.Asmb = asmb
	ld.Thearch.Elfreloc1 = elfreloc1
	ld.Thearch.Elfsetupplt = elfsetupplt
	ld.Thearch.Gentext = gentext
	ld.Thearch.Machoreloc1 = machoreloc1
	ld.Thearch.Lput = ld.Lputl
	ld.Thearch.Wput = ld.Wputl
	ld.Thearch.Vput = ld.Vputl

	ld.Thearch.Linuxdynld = "/lib/ld-linux-aarch64.so.1"

	ld.Thearch.Freebsddynld = "XXX"
	ld.Thearch.Openbsddynld = "XXX"
	ld.Thearch.Netbsddynld = "XXX"
	ld.Thearch.Dragonflydynld = "XXX"
	ld.Thearch.Solarisdynld = "XXX"
}

func archinit() {
	// getgoextlinkenabled is based on GO_EXTLINK_ENABLED when
	// Go was built; see ../../make.bash.
	if ld.Linkmode == ld.LinkAuto && obj.Getgoextlinkenabled() == "0" {
		ld.Linkmode = ld.LinkInternal
	}

	// Darwin/arm64 only supports external linking
	if ld.HEADTYPE == obj.Hdarwin {
		ld.Linkmode = ld.LinkExternal
	}

	switch ld.HEADTYPE {
	default:
		if ld.Linkmode == ld.LinkAuto {
			ld.Linkmode = ld.LinkInternal
		}
		if ld.Linkmode == ld.LinkExternal && obj.Getgoextlinkenabled() != "1" {
			log.Fatalf("cannot use -linkmode=external with -H %s", ld.Headstr(int(ld.HEADTYPE)))
		}
	case obj.Hlinux, obj.Hdarwin:
		break
	}

	if ld.Buildmode == ld.BuildmodeCShared || ld.DynlinkingGo() {
		ld.Linkmode = ld.LinkExternal
	}

	switch ld.HEADTYPE {
	default:
		ld.Exitf("unknown -H option: %v", ld.HEADTYPE)

	case obj.Hplan9: /* plan 9 */
		ld.HEADR = 32

		if ld.INITTEXT == -1 {
			ld.INITTEXT = 4128
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}

	case obj.Hlinux: /* arm64 elf */
		ld.Elfinit()
		ld.HEADR = ld.ELFRESERVE
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x10000 + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 0x10000
		}

	case obj.Hdarwin: /* apple MACH */
		ld.Debug['w'] = 1 // disable DWARF generation
		ld.Machoinit()
		ld.HEADR = ld.INITIAL_MACHO_HEADR
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 4096 + int64(ld.HEADR)
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 4096
		}

	case obj.Hnacl:
		ld.Elfinit()
		ld.HEADR = 0x10000
		ld.Funcalign = 16
		if ld.INITTEXT == -1 {
			ld.INITTEXT = 0x20000
		}
		if ld.INITDAT == -1 {
			ld.INITDAT = 0
		}
		if ld.INITRND == -1 {
			ld.INITRND = 0x10000
		}
	}

	if ld.INITDAT != 0 && ld.INITRND != 0 {
		fmt.Printf("warning: -D0x%x is ignored because of -R0x%x\n", uint64(ld.INITDAT), uint32(ld.INITRND))
	}
}
                                                                                                                                                                                                                                                                  usr/local/go/src/cmd/link/internal/ld/                                                              0040755 0000000 0000000 00000000000 13020111412 016243  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/link/internal/ld/ar.go                                                         0100644 0000000 0000000 00000011545 13020111412 017177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/include/ar.h
// http://code.google.com/p/inferno-os/source/browse/utils/include/ar.h
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package ld

import (
	"cmd/internal/obj"
	"encoding/binary"
	"fmt"
	"os"
)

const (
	SARMAG  = 8
	SAR_HDR = 16 + 44
)

const (
	ARMAG = "!<arch>\n"
)

type ArHdr struct {
	name string
	date string
	uid  string
	gid  string
	mode string
	size string
	fmag string
}

// hostArchive reads an archive file holding host objects and links in
// required objects.  The general format is the same as a Go archive
// file, but it has an armap listing symbols and the objects that
// define them.  This is used for the compiler support library
// libgcc.a.
func hostArchive(name string) {
	f, err := obj.Bopenr(name)
	if err != nil {
		if os.IsNotExist(err) {
			// It's OK if we don't have a libgcc file at all.
			if Debug['v'] != 0 {
				fmt.Fprintf(&Bso, "skipping libgcc file: %v\n", err)
			}
			return
		}
		Exitf("cannot open file %s: %v", name, err)
	}
	defer obj.Bterm(f)

	magbuf := make([]byte, len(ARMAG))
	if obj.Bread(f, magbuf) != len(magbuf) {
		Exitf("file %s too short", name)
	}

	var arhdr ArHdr
	l := nextar(f, obj.Boffset(f), &arhdr)
	if l <= 0 {
		Exitf("%s missing armap", name)
	}

	var armap archiveMap
	if arhdr.name == "/" || arhdr.name == "/SYM64/" {
		armap = readArmap(name, f, arhdr)
	} else {
		Exitf("%s missing armap", name)
	}

	loaded := make(map[uint64]bool)
	any := true
	for any {
		var load []uint64
		for s := Ctxt.Allsym; s != nil; s = s.Allsym {
			for _, r := range s.R {
				if r.Sym != nil && r.Sym.Type&obj.SMASK == obj.SXREF {
					if off := armap[r.Sym.Name]; off != 0 && !loaded[off] {
						load = append(load, off)
						loaded[off] = true
					}
				}
			}
		}

		for _, off := range load {
			l := nextar(f, int64(off), &arhdr)
			if l <= 0 {
				Exitf("%s missing archive entry at offset %d", name, off)
			}
			pname := fmt.Sprintf("%s(%s)", name, arhdr.name)
			l = atolwhex(arhdr.size)

			h := ldobj(f, "libgcc", l, pname, name, ArchiveObj)
			obj.Bseek(f, h.off, 0)
			h.ld(f, h.pkg, h.length, h.pn)
		}

		any = len(load) > 0
	}
}

// archiveMap is an archive symbol map: a mapping from symbol name to
// offset within the archive file.
type archiveMap map[string]uint64

// readArmap reads the archive symbol map.
func readArmap(filename string, f *obj.Biobuf, arhdr ArHdr) archiveMap {
	is64 := arhdr.name == "/SYM64/"
	wordSize := 4
	if is64 {
		wordSize = 8
	}

	l := atolwhex(arhdr.size)
	contents := make([]byte, l)
	if obj.Bread(f, contents) != int(l) {
		Exitf("short read from %s", filename)
	}

	var c uint64
	if is64 {
		c = binary.BigEndian.Uint64(contents)
	} else {
		c = uint64(binary.BigEndian.Uint32(contents))
	}
	contents = contents[wordSize:]

	ret := make(archiveMap)

	names := contents[c*uint64(wordSize):]
	for i := uint64(0); i < c; i++ {
		n := 0
		for names[n] != 0 {
			n++
		}
		name := string(names[:n])
		names = names[n+1:]

		// For Mach-O and PE/386 files we strip a leading
		// underscore from the symbol name.
		if goos == "darwin" || (goos == "windows" && goarch == "386") {
			if name[0] == '_' && len(name) > 1 {
				name = name[1:]
			}
		}

		var off uint64
		if is64 {
			off = binary.BigEndian.Uint64(contents)
		} else {
			off = uint64(binary.BigEndian.Uint32(contents))
		}
		contents = contents[wordSize:]

		ret[name] = off
	}

	return ret
}
                                                                                                                                                           usr/local/go/src/cmd/link/internal/ld/arch.go                                                       0100644 0000000 0000000 00000002743 13020111412 017512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ld

import "encoding/binary"

var Linkarm = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "arm",
	Thechar:   '5',
	Minlc:     4,
	Ptrsize:   4,
	Regsize:   4,
}

var Linkarm64 = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "arm64",
	Thechar:   '7',
	Minlc:     4,
	Ptrsize:   8,
	Regsize:   8,
}

var Linkamd64 = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "amd64",
	Thechar:   '6',
	Minlc:     1,
	Ptrsize:   8,
	Regsize:   8,
}

var Linkamd64p32 = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "amd64p32",
	Thechar:   '6',
	Minlc:     1,
	Ptrsize:   4,
	Regsize:   8,
}

var Link386 = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "386",
	Thechar:   '8',
	Minlc:     1,
	Ptrsize:   4,
	Regsize:   4,
}

var Linkppc64 = LinkArch{
	ByteOrder: binary.BigEndian,
	Name:      "ppc64",
	Thechar:   '9',
	Minlc:     4,
	Ptrsize:   8,
	Regsize:   8,
}

var Linkppc64le = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "ppc64le",
	Thechar:   '9',
	Minlc:     4,
	Ptrsize:   8,
	Regsize:   8,
}

var Linkmips64 = LinkArch{
	ByteOrder: binary.BigEndian,
	Name:      "mips64",
	Thechar:   '0',
	Minlc:     4,
	Ptrsize:   8,
	Regsize:   8,
}

var Linkmips64le = LinkArch{
	ByteOrder: binary.LittleEndian,
	Name:      "mips64le",
	Thechar:   '0',
	Minlc:     4,
	Ptrsize:   8,
	Regsize:   8,
}
                             usr/local/go/src/cmd/link/internal/ld/data.go                                                       0100644 0000000 0000000 00000132273 13020111412 017510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6l/obj.c and utils/6l/span.c
// http://code.google.com/p/inferno-os/source/browse/utils/6l/obj.c
// http://code.google.com/p/inferno-os/source/browse/utils/6l/span.c
//
//	Copyright  1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright  1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright  1997-1999 Vita Nuova Limited
//	Portions Copyright  2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright  2004,2006 Bruce Ellis
//	Portions Copyright  2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright  2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright  2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package ld

import (
	"cmd/internal/gcprog"
	"cmd/internal/obj"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

func Symgrow(ctxt *Link, s *LSym, siz int64) {
	if int64(int(siz)) != siz {
		log.Fatalf("symgrow size %d too long", siz)
	}
	if int64(len(s.P)) >= siz {
		return
	}
	for cap(s.P) < int(siz) {
		s.P = append(s.P[:len(s.P)], 0)
	}
	s.P = s.P[:siz]
}

func Addrel(s *LSym) *Reloc {
	s.R = append(s.R, Reloc{})
	return &s.R[len(s.R)-1]
}

func setuintxx(ctxt *Link, s *LSym, off int64, v uint64, wid int64) int64 {
	if s.Type == 0 {
		s.Type = obj.SDATA
	}
	s.Reachable = true
	if s.Size < off+wid {
		s.Size = off + wid
		Symgrow(ctxt, s, s.Size)
	}

	switch wid {
	case 1:
		s.P[off] = uint8(v)
	case 2:
		ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(v))
	case 4:
		ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(v))
	case 8:
		ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(v))
	}

	return off + wid
}

func adduintxx(ctxt *Link, s *LSym, v uint64, wid int) int64 {
	off := s.Size
	setuintxx(ctxt, s, off, v, int64(wid))
	return off
}

func Adduint8(ctxt *Link, s *LSym, v uint8) int64 {
	return adduintxx(ctxt, s, uint64(v), 1)
}

func Adduint16(ctxt *Link, s *LSym, v uint16) int64 {
	return adduintxx(ctxt, s, uint64(v), 2)
}

func Adduint32(ctxt *Link, s *LSym, v uint32) int64 {
	return adduintxx(ctxt, s, uint64(v), 4)
}

func Adduint64(ctxt *Link, s *LSym, v uint64) int64 {
	return adduintxx(ctxt, s, v, 8)
}

func adduint(ctxt *Link, s *LSym, v uint64) int64 {
	return adduintxx(ctxt, s, v, Thearch.Intsize)
}

func setuint8(ctxt *Link, s *LSym, r int64, v uint8) int64 {
	return setuintxx(ctxt, s, r, uint64(v), 1)
}

func setuint32(ctxt *Link, s *LSym, r int64, v uint32) int64 {
	return setuintxx(ctxt, s, r, uint64(v), 4)
}

func Addaddrplus(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
	if s.Type == 0 {
		s.Type = obj.SDATA
	}
	s.Reachable = true
	i := s.Size
	s.Size += int64(ctxt.Arch.Ptrsize)
	Symgrow(ctxt, s, s.Size)
	r := Addrel(s)
	r.Sym = t
	r.Off = int32(i)
	r.Siz = uint8(ctxt.Arch.Ptrsize)
	r.Type = obj.R_ADDR
	r.Add = add
	return i + int64(r.Siz)
}

func Addpcrelplus(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
	if s.Type == 0 {
		s.Type = obj.SDATA
	}
	s.Reachable = true
	i := s.Size
	s.Size += 4
	Symgrow(ctxt, s, s.Size)
	r := Addrel(s)
	r.Sym = t
	r.Off = int32(i)
	r.Add = add
	r.Type = obj.R_PCREL
	r.Siz = 4
	return i + int64(r.Siz)
}

func Addaddr(ctxt *Link, s *LSym, t *LSym) int64 {
	return Addaddrplus(ctxt, s, t, 0)
}

func setaddrplus(ctxt *Link, s *LSym, off int64, t *LSym, add int64) int64 {
	if s.Type == 0 {
		s.Type = obj.SDATA
	}
	s.Reachable = true
	if off+int64(ctxt.Arch.Ptrsize) > s.Size {
		s.Size = off + int64(ctxt.Arch.Ptrsize)
		Symgrow(ctxt, s, s.Size)
	}

	r := Addrel(s)
	r.Sym = t
	r.Off = int32(off)
	r.Siz = uint8(ctxt.Arch.Ptrsize)
	r.Type = obj.R_ADDR
	r.Add = add
	return off + int64(r.Siz)
}

func setaddr(ctxt *Link, s *LSym, off int64, t *LSym) int64 {
	return setaddrplus(ctxt, s, off, t, 0)
}

func addsize(ctxt *Link, s *LSym, t *LSym) int64 {
	if s.Type == 0 {
		s.Type = obj.SDATA
	}
	s.Reachable = true
	i := s.Size
	s.Size += int64(ctxt.Arch.Ptrsize)
	Symgrow(ctxt, s, s.Size)
	r := Addrel(s)
	r.Sym = t
	r.Off = int32(i)
	r.Siz = uint8(ctxt.Arch.Ptrsize)
	r.Type = obj.R_SIZE
	return i + int64(r.Siz)
}

func addaddrplus4(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
	if s.Type == 0 {
		s.Type = obj.SDATA
	}
	s.Reachable = true
	i := s.Size
	s.Size += 4
	Symgrow(ctxt, s, s.Size)
	r := Addrel(s)
	r.Sym = t
	r.Off = int32(i)
	r.Siz = 4
	r.Type = obj.R_ADDR
	r.Add = add
	return i + int64(r.Siz)
}

/*
 * divide-and-conquer list-link
 * sort of LSym* structures.
 * Used for the data block.
 */
func datcmp(s1 *LSym, s2 *LSym) int {
	if s1.Type != s2.Type {
		return int(s1.Type) - int(s2.Type)
	}

	// For ppc64, we want to interleave the .got and .toc sections
	// from input files.  Both are type SELFGOT, so in that case
	// fall through to the name comparison (conveniently, .got
	// sorts before .toc).
	if s1.Type != obj.SELFGOT && s1.Size != s2.Size {
		if s1.Size < s2.Size {
			return -1
		}
		return +1
	}

	return stringsCompare(s1.Name, s2.Name)
}

func listnextp(s *LSym) **LSym {
	return &s.Next
}

func listsubp(s *LSym) **LSym {
	return &s.Sub
}

func listsort(l *LSym, cmp func(*LSym, *LSym) int, nextp func(*LSym) **LSym) *LSym {
	if l == nil || *nextp(l) == nil {
		return l
	}

	l1 := l
	l2 := l
	for {
		l2 = *nextp(l2)
		if l2 == nil {
			break
		}
		l2 = *nextp(l2)
		if l2 == nil {
			break
		}
		l1 = *nextp(l1)
	}

	l2 = *nextp(l1)
	*nextp(l1) = nil
	l1 = listsort(l, cmp, nextp)
	l2 = listsort(l2, cmp, nextp)

	/* set up lead element */
	if cmp(l1, l2) < 0 {
		l = l1
		l1 = *nextp(l1)
	} else {
		l = l2
		l2 = *nextp(l2)
	}

	le := l

	for {
		if l1 == nil {
			for l2 != nil {
				*nextp(le) = l2
				le = l2
				l2 = *nextp(l2)
			}

			*nextp(le) = nil
			break
		}

		if l2 == nil {
			for l1 != nil {
				*nextp(le) = l1
				le = l1
				l1 = *nextp(l1)
			}

			break
		}

		if cmp(l1, l2) < 0 {
			*nextp(le) = l1
			le = l1
			l1 = *nextp(l1)
		} else {
			*nextp(le) = l2
			le = l2
			l2 = *nextp(l2)
		}
	}

	*nextp(le) = nil
	return l
}

func relocsym(s *LSym) {
	var r *Reloc
	var rs *LSym
	var i16 int16
	var off int32
	var siz int32
	var fl int32
	var o int64

	Ctxt.Cursym = s
	for ri := int32(0); ri < int32(len(s.R)); ri++ {
		r = &s.R[ri]
		r.Done = 1
		off = r.Off
		siz = int32(r.Siz)
		if off < 0 || off+siz > int32(len(s.P)) {
			Diag("%s: invalid relocation %d+%d not in [%d,%d)", s.Name, off, siz, 0, len(s.P))
			continue
		}

		if r.Sym != nil && (r.Sym.Type&(obj.SMASK|obj.SHIDDEN) == 0 || r.Sym.Type&obj.SMASK == obj.SXREF) {
			// When putting the runtime but not main into a shared library
			// these symbols are undefined and that's OK.
			if Buildmode == BuildmodeShared && (r.Sym.Name == "main.main" || r.Sym.Name == "main.init") {
				r.Sym.Type = obj.SDYNIMPORT
			} else {
				Diag("%s: not defined", r.Sym.Name)
				continue
			}
		}

		if r.Type >= 256 {
			continue
		}
		if r.Siz == 0 { // informational relocation - no work to do
			continue
		}

		// We need to be able to reference dynimport symbols when linking against
		// shared libraries, and Solaris needs it always
		if HEADTYPE != obj.Hsolaris && r.Sym != nil && r.Sym.Type == obj.SDYNIMPORT && !DynlinkingGo() {
			if !(Thearch.Thechar == '9' && Linkmode == LinkExternal && r.Sym.Name == ".TOC.") {
				Diag("unhandled relocation for %s (type %d rtype %d)", r.Sym.Name, r.Sym.Type, r.Type)
			}
		}
		if r.Sym != nil && r.Sym.Type != obj.STLSBSS && !r.Sym.Reachable {
			Diag("unreachable sym in relocation: %s %s", s.Name, r.Sym.Name)
		}

		switch r.Type {
		default:
			switch siz {
			default:
				Diag("bad reloc size %#x for %s", uint32(siz), r.Sym.Name)
			case 1:
				o = int64(s.P[off])
			case 2:
				o = int64(Ctxt.Arch.ByteOrder.Uint16(s.P[off:]))
			case 4:
				o = int64(Ctxt.Arch.ByteOrder.Uint32(s.P[off:]))
			case 8:
				o = int64(Ctxt.Arch.ByteOrder.Uint64(s.P[off:]))
			}
			if Thearch.Archreloc(r, s, &o) < 0 {
				Diag("unknown reloc %d", r.Type)
			}

		case obj.R_TLS_LE:
			isAndroidX86 := goos == "android" && (Thearch.Thechar == '6' || Thearch.Thechar == '8')

			if Linkmode == LinkExternal && Iself && HEADTYPE != obj.Hopenbsd && !isAndroidX86 {
				r.Done = 0
				if r.Sym == nil {
					r.Sym = Ctxt.Tlsg
				}
				r.Xsym = r.Sym
				r.Xadd = r.Add
				o = 0
				if Thearch.Thechar != '6' {
					o = r.Add
				}
				break
			}

			if Iself && Thearch.Thechar == '5' {
				// On ELF ARM, the thread pointer is 8 bytes before
				// the start of the thread-local data block, so add 8
				// to the actual TLS offset (r->sym->value).
				// This 8 seems to be a fundamental constant of
				// ELF on ARM (or maybe Glibc on ARM); it is not
				// related to the fact that our own TLS storage happens
				// to take up 8 bytes.
				o = 8 + r.Sym.Value
			} else if Iself || Ctxt.Headtype == obj.Hplan9 || Ctxt.Headtype == obj.Hdarwin || isAndroidX86 {
				o = int64(Ctxt.Tlsoffset) + r.Add
			} else if Ctxt.Headtype == obj.Hwindows {
				o = r.Add
			} else {
				log.Fatalf("unexpected R_TLS_LE relocation for %s", Headstr(Ctxt.Headtype))
			}

		case obj.R_TLS_IE:
			isAndroidX86 := goos == "android" && (Thearch.Thechar == '6' || Thearch.Thechar == '8')

			if Linkmode == LinkExternal && Iself && HEADTYPE != obj.Hopenbsd && !isAndroidX86 {
				r.Done = 0
				if r.Sym == nil {
					r.Sym = Ctxt.Tlsg
				}
				r.Xsym = r.Sym
				r.Xadd = r.Add
				o = 0
				if Thearch.Thechar != '6' {
					o = r.Add
				}
				break
			}
			log.Fatalf("cannot handle R_TLS_IE when linking internally")

		case obj.R_ADDR:
			if Linkmode == LinkExternal && r.Sym.Type != obj.SCONST {
				r.Done = 0

				// set up addend for eventual relocation via outer symbol.
				rs = r.Sym

				r.Xadd = r.Add
				for rs.Outer != nil {
					r.Xadd += Symaddr(rs) - Symaddr(rs.Outer)
					rs = rs.Outer
				}

				if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
					Diag("missing section for %s", rs.Name)
				}
				r.Xsym = rs

				o = r.Xadd
				if Iself {
					if Thearch.Thechar == '6' {
						o = 0
					}
				} else if HEADTYPE == obj.Hdarwin {
					// ld64 for arm64 has a bug where if the address pointed to by o exists in the
					// symbol table (dynid >= 0), or is inside a symbol that exists in the symbol
					// table, then it will add o twice into the relocated value.
					// The workaround is that on arm64 don't ever add symaddr to o and always use
					// extern relocation by requiring rs->dynid >= 0.
					if rs.Type != obj.SHOSTOBJ {
						if Thearch.Thechar == '7' && rs.Dynid < 0 {
							Diag("R_ADDR reloc to %s+%d is not supported on darwin/arm64", rs.Name, o)
						}
						if Thearch.Thechar != '7' {
							o += Symaddr(rs)
						}
					}
				} else if HEADTYPE == obj.Hwindows {
					// nothing to do
				} else {
					Diag("unhandled pcrel relocation for %s", headstring)
				}

				break
			}

			o = Symaddr(r.Sym) + r.Add

			// On amd64, 4-byte offsets will be sign-extended, so it is impossible to
			// access more than 2GB of static data; fail at link time is better than
			// fail at runtime. See https://golang.org/issue/7980.
			// Instead of special casing only amd64, we treat this as an error on all
			// 64-bit architectures so as to be future-proof.
			if int32(o) < 0 && Thearch.Ptrsize > 4 && siz == 4 {
				Diag("non-pc-relative relocation address is too big: %#x (%#x + %#x)", uint64(o), Symaddr(r.Sym), r.Add)
				errorexit()
			}

			// r->sym can be null when CALL $(constant) is transformed from absolute PC to relative PC call.
		case obj.R_CALL, obj.R_GOTPCREL, obj.R_PCREL:
			if Linkmode == LinkExternal && r.Sym != nil && r.Sym.Type != obj.SCONST && (r.Sym.Sect != Ctxt.Cursym.Sect || r.Type == obj.R_GOTPCREL) {
				r.Done = 0

				// set up addend for eventual relocation via outer symbol.
				rs = r.Sym

				r.Xadd = r.Add
				for rs.Outer != nil {
					r.Xadd += Symaddr(rs) - Symaddr(rs.Outer)
					rs = rs.Outer
				}

				r.Xadd -= int64(r.Siz) // relative to address after the relocated chunk
				if rs.Type != obj.SHOSTOBJ && rs.Type != obj.SDYNIMPORT && rs.Sect == nil {
					Diag("missing section for %s", rs.Name)
				}
				r.Xsym = rs

				o = r.Xadd
				if Iself {
					if Thearch.Thechar == '6' {
						o = 0
					}
				} else if HEADTYPE == obj.Hdarwin {
					if r.Type == obj.R_CALL {
						if rs.Type != obj.SHOSTOBJ {
							o += int64(uint64(Symaddr(rs)) - rs.Sect.Vaddr)
						}
						o -= int64(r.Off) // relative to section offset, not symbol
					} else {
						o += int64(r.Siz)
					}
				} else if HEADTYPE == obj.Hwindows && Thearch.Thechar == '6' { // only amd64 needs PCREL
					// PE/COFF's PC32 relocation uses the address after the relocated
					// bytes as the base. Compensate by skewing the addend.
					o += int64(r.Siz)
					// GNU ld always add VirtualAddress of the .text section to the
					// relocated address, compensate that.
					o -= int64(s.Sect.Vaddr - PEBASE)
				} else {
					Diag("unhandled pcrel relocation for %s", headstring)
				}

				break
			}

			o = 0
			if r.Sym != nil {
				o += Symaddr(r.Sym)
			}

			// NOTE: The (int32) cast on the next line works around a bug in Plan 9's 8c
			// compiler. The expression s->value + r->off + r->siz is int32 + int32 +
			// uchar, and Plan 9 8c incorrectly treats the expression as type uint32
			// instead of int32, causing incorrect values when sign extended for adding
			// to o. The bug only occurs on Plan 9, because this C program is compiled by
			// the standard host compiler (gcc on most other systems).
			o += r.Add - (s.Value + int64(r.Off) + int64(int32(r.Siz)))

		case obj.R_SIZE:
			o = r.Sym.Size + r.Add
		}

		if r.Variant != RV_NONE {
			o = Thearch.Archrelocvariant(r, s, o)
		}

		if false {
			nam := "<nil>"
			if r.Sym != nil {
				nam = r.Sym.Name
			}
			fmt.Printf("relocate %s %#x (%#x+%#x, size %d) => %s %#x +%#x [type %d/%d, %x]\n", s.Name, s.Value+int64(off), s.Value, r.Off, r.Siz, nam, Symaddr(r.Sym), r.Add, r.Type, r.Variant, o)
		}
		switch siz {
		default:
			Ctxt.Cursym = s
			Diag("bad reloc size %#x for %s", uint32(siz), r.Sym.Name)
			fallthrough

			// TODO(rsc): Remove.
		case 1:
			s.P[off] = byte(int8(o))

		case 2:
			if o != int64(int16(o)) {
				Diag("relocation address is too big: %#x", o)
			}
			i16 = int16(o)
			Ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(i16))

		case 4:
			if r.Type == obj.R_PCREL || r.Type == obj.R_CALL {
				if o != int64(int32(o)) {
					Diag("pc-relative relocation address is too big: %#x", o)
				}
			} else {
				if o != int64(int32(o)) && o != int64(uint32(o)) {
					Diag("non-pc-relative relocation address is too big: %#x", uint64(o))
				}
			}

			fl = int32(o)
			Ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(fl))

		case 8:
			Ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(o))
		}
	}
}

func reloc() {
	if Debug['v'] != 0 {
		fmt.Fprintf(&Bso, "%5.2f reloc\n", obj.Cputime())
	}
	Bso.Flush()

	for s := Ctxt.Textp; s != nil; s = s.Next {
		relocsym(s)
	}
	for s := datap; s != nil; s = s.Next {
		relocsym(s)
	}
}

func dynrelocsym(s *LSym) {
	if HEADTYPE == obj.Hwindows && Linkmode != LinkExternal {
		rel := Linklookup(Ctxt, ".rel", 0)
		if s == rel {
			return
		}
		var r *Reloc
		var targ *LSym
		for ri := 0; ri < len(s.R); ri++ {
			r = &s.R[ri]
			targ = r.Sym
			if targ == nil {
				continue
			}
			if !targ.Reachable {
				Diag("internal inconsistency: dynamic symbol %s is not reachable.", targ.Name)
			}
			if r.Sym.Plt == -2 && r.Sym.Got != -2 { // make dynimport JMP table for PE object files.
				targ.Plt = int32(rel.Size)
				r.Sym = rel
				r.Add = int64(targ.Plt)

				// jmp *addr
				if Thearch.Thechar == '8' {
					Adduint8(Ctxt, rel, 0xff)
					Adduint8(Ctxt, rel, 0x25)
					Addaddr(Ctxt, rel, targ)
					Adduint8(Ctxt, rel, 0x90)
					Adduint8(Ctxt, rel, 0x90)
				} else {
					Adduint8(Ctxt, rel, 0xff)
					Adduint8(Ctxt, rel, 0x24)
					Adduint8(Ctxt, rel, 0x25)
					addaddrplus4(Ctxt, rel, targ, 0)
					Adduint8(Ctxt, rel, 0x90)
				}
			} else if r.Sym.Plt >= 0 {
				r.Sym = rel
				r.Add = int64(targ.Plt)
			}
		}

		return
	}

	var r *Reloc
	for ri := 0; ri < len(s.R); ri++ {
		r = &s.R[ri]
		if r.Sym != nil && r.Sym.Type == obj.SDYNIMPORT || r.Type >= 256 {
			if r.Sym != nil && !r.Sym.Reachable {
				Diag("internal inconsistency: dynamic symbol %s is not reachable.", r.Sym.Name)
			}
			Thearch.Adddynrel(s, r)
		}
	}
}

func dynreloc() {
	// -d suppresses dynamic loader format, so we may as well not
	// compute these sections or mark their symbols as reachable.
	if Debug['d'] != 0 && HEADTYPE != obj.Hwindows {
		return
	}
	if Debug['v'] != 0 {
		fmt.Fprintf(&Bso, "%5.2f reloc\n", obj.Cputime())
	}
	Bso.Flush()

	for s := Ctxt.Textp; s != nil; s = s.Next {
		dynrelocsym(s)
	}
	for s := datap; s != nil; s = s.Next {
		dynrelocsym(s)
	}
	if Iself {
		elfdynhash()
	}
}

func blk(start *LSym, addr int64, size int64) {
	var sym *LSym

	for sym = start; sym != nil; sym = sym.Next {
		if sym.Type&obj.SSUB == 0 && sym.Value >= addr {
			break
		}
	}

	eaddr := addr + size
	var ep []byte
	var p []byte
	for ; sym != nil; sym = sym.Next {
		if sym.Type&obj.SSUB != 0 {
			continue
		}
		if sym.Value >= eaddr {
			break
		}
		Ctxt.Cursym = sym
		if sym.Value < addr {
			Diag("phase error: addr=%#x but sym=%#x type=%d", int64(addr), int64(sym.Value), sym.Type)
			errorexit()
		}

		for ; addr < sym.Value; addr++ {
			Cput(0)
		}
		p = sym.P
		ep = p[len(sym.P):]
		for -cap(p) < -cap(ep) {
			Cput(uint8(p[0]))
			p = p[1:]
		}
		addr += int64(len(sym.P))
		for ; addr < sym.Value+sym.Size; addr++ {
			Cput(0)
		}
		if addr != sym.Value+sym.Size {
			Diag("phase error: addr=%#x value+size=%#x", int64(addr), int64(sym.Value)+sym.Size)
			errorexit()
		}

		if sym.Value+sym.Size >= eaddr {
			break
		}
	}

	for ; addr < eaddr; addr++ {
		Cput(0)
	}
	Cflush()
}

func Codeblk(addr int64, size int64) {
	if Debug['a'] != 0 {
		fmt.Fprintf(&Bso, "codeblk [%#x,%#x) at offset %#x\n", addr, addr+size, Cpos())
	}

	blk(Ctxt.Textp, addr, size)

	/* again for printing */
	if Debug['a'] == 0 {
		return
	}

	var sym *LSym
	for sym = Ctxt.Textp; sym != nil; sym = sym.Next {
		if !sym.Reachable {
			continue
		}
		if sym.Value >= addr {
			break
		}
	}

	eaddr := addr + size
	var q []byte
	for ; sym != nil; sym = sym.Next {
		if !sym.Reachable {
			continue
		}
		if sym.Value >= eaddr {
			break
		}

		if addr < sym.Value {
			fmt.Fprintf(&Bso, "%-20s %.8x|", "_", uint64(int64(addr)))
			for ; addr < sym.Value; addr++ {
				fmt.Fprintf(&Bso, " %.2x", 0)
			}
			fmt.Fprintf(&Bso, "\n")
		}

		fmt.Fprintf(&Bso, "%.6x\t%-20s\n", uint64(int64(addr)), sym.Name)
		q = sym.P

		for len(q) >= 16 {
			fmt.Fprintf(&Bso, "%.6x\t% x\n", uint64(addr), q[:16])
			addr += 16
			q = q[16:]
		}

		if len(q) > 0 {
			fmt.Fprintf(&Bso, "%.6x\t% x\n", uint64(addr), q)
			addr += int64(len(q))
		}
	}

	if addr < eaddr {
		fmt.Fprintf(&Bso, "%-20s %.8x|", "_", uint64(int64(addr)))
		for ; addr < eaddr; addr++ {
			fmt.Fprintf(&Bso, " %.2x", 0)
		}
	}

	Bso.Flush()
}

func Datblk(addr int64, size int64) {
	if Debug['a'] != 0 {
		fmt.Fprintf(&Bso, "datblk [%#x,%#x) at offset %#x\n", addr, addr+size, Cpos())
	}

	blk(datap, addr, size)

	/* again for printing */
	if Debug['a'] == 0 {
		return
	}

	var sym *LSym
	for sym = datap; sym != nil; sym = sym.Next {
		if sym.Value >= addr {
			break
		}
	}

	eaddr := addr + size
	var ep []byte
	var i int64
	var p []byte
	var r *Reloc
	var rsname string
	var typ string
	for ; sym != nil; sym = sym.Next {
		if sym.Value >= eaddr {
			break
		}
		if addr < sym.Value {
			fmt.Fprintf(&Bso, "\t%.8x| 00 ...\n", uint64(addr))
			addr = sym.Value
		}

		fmt.Fprintf(&Bso, "%s\n\t%.8x|", sym.Name, uint(addr))
		p = sym.P
		ep = p[len(sym.P):]
		for -cap(p) < -cap(ep) {
			if -cap(p) > -cap(sym.P) && int(-cap(p)+cap(sym.P))%16 == 0 {
				fmt.Fprintf(&Bso, "\n\t%.8x|", uint(addr+int64(-cap(p)+cap(sym.P))))
			}
			fmt.Fprintf(&Bso, " %.2x", p[0])
			p = p[1:]
		}

		addr += int64(len(sym.P))
		for ; addr < sym.Value+sym.Size; addr++ {
			fmt.Fprintf(&Bso, " %.2x", 0)
		}
		fmt.Fprintf(&Bso, "\n")

		if Linkmode == LinkExternal {
			for i = 0; i < int64(len(sym.R)); i++ {
				r = &sym.R[i]
				rsname = ""
				if r.Sym != nil {
					rsname = r.Sym.Name
				}
				typ = "?"
				switch r.Type {
				case obj.R_ADDR:
					typ = "addr"

				case obj.R_PCREL:
					typ = "pcrel"

				case obj.R_CALL:
					typ = "call"
				}

				fmt.Fprintf(&Bso, "\treloc %.8x/%d %s %s+%#x [%#x]\n", uint(sym.Value+int64(r.Off)), r.Siz, typ, rsname, int64(r.Add), int64(r.Sym.Value+r.Add))
			}
		}
	}

	if addr < eaddr {
		fmt.Fprintf(&Bso, "\t%.8x| 00 ...\n", uint(addr))
	}
	fmt.Fprintf(&Bso, "\t%.8x|\n", uint(eaddr))
}

func strnput(s string, n int) {
	for ; n > 0 && s != ""; s = s[1:] {
		Cput(uint8(s[0]))
		n--
	}

	for n > 0 {
		Cput(0)
		n--
	}
}

var strdata []*LSym

func addstrdata1(arg string) {
	i := strings.Index(arg, "=")
	if i < 0 {
		Exitf("-X flag requires argument of the form importpath.name=value")
	}
	addstrdata(arg[:i], arg[i+1:])
}

func addstrdata(name string, value string) {
	p := fmt.Sprintf("%s.str", name)
	sp := Linklookup(Ctxt, p, 0)

	Addstring(sp, value)
	sp.Type = obj.SRODATA

	s := Linklookup(Ctxt, name, 0)
	s.Size = 0
	s.Dupok = 1
	reachable := s.Reachable
	Addaddr(Ctxt, s, sp)
	adduintxx(Ctxt, s, uint64(len(value)), Thearch.Ptrsize)

	// addstring, addaddr, etc., mark the symbols as reachable.
	// In this case that is not necessarily true, so stick to what
	// we know before entering this function.
	s.Reachable = reachable

	strdata = append(strdata, s)

	sp.Reachable = reachable
}

func checkstrdata() {
	for _, s := range strdata {
		if s.Type == obj.STEXT {
			Diag("cannot use -X with text symbol %s", s.Name)
		} else if s.Gotype != nil && s.Gotype.Name != "type.string" {
			Diag("cannot use -X with non-string symbol %s", s.Name)
		}
	}
}

func Addstring(s *LSym, str string) int64 {
	if s.Type == 0 {
		s.Type = obj.SNOPTRDATA
	}
	s.Reachable = true
	r := int32(s.Size)
	n := len(str) + 1
	if s.Name == ".shstrtab" {
		elfsetstring(str, int(r))
	}
	Symgrow(Ctxt, s, int64(r)+int64(n))
	copy(s.P[r:], str)
	s.P[int(r)+len(str)] = 0
	s.Size += int64(n)
	return int64(r)
}

// addgostring adds str, as a Go string value, to s. symname is the name of the
// symbol used to define the string data and must be unique per linked object.
func addgostring(s *LSym, symname, str string) {
	sym := Linklookup(Ctxt, symname, 0)
	if sym.Type != obj.Sxxx {
		Diag("duplicate symname in addgostring: %s", symname)
	}
	sym.Reachable = true
	sym.Local = true
	sym.Type = obj.SRODATA
	sym.Size = int64(len(str))
	sym.P = []byte(str)
	Addaddr(Ctxt, s, sym)
	adduint(Ctxt, s, uint64(len(str)))
}

func addinitarrdata(s *LSym) {
	p := s.Name + ".ptr"
	sp := Linklookup(Ctxt, p, 0)
	sp.Type = obj.SINITARR
	sp.Size = 0
	sp.Dupok = 1
	Addaddr(Ctxt, sp, s)
}

func dosymtype() {
	for s := Ctxt.Allsym; s != nil; s = s.Allsym {
		if len(s.P) > 0 {
			if s.Type == obj.SBSS {
				s.Type = obj.SDATA
			}
			if s.Type == obj.SNOPTRBSS {
				s.Type = obj.SNOPTRDATA
			}
		}
		// Create a new entry in the .init_array section that points to the
		// library initializer function.
		switch Buildmode {
		case BuildmodeCArchive, BuildmodeCShared:
			if s.Name == INITENTRY {
				addinitarrdata(s)
			}
		}
	}
}

func symalign(s *LSym) int32 {
	if s.Align != 0 {
		return s.Align
	}

	align := int32(Thearch.Maxalign)
	for int64(align) > s.Size && align > 1 {
		align >>= 1
	}
	if align < s.Align {
		align = s.Align
	}
	return align
}

func aligndatsize(datsize int64, s *LSym) int64 {
	return Rnd(datsize, int64(symalign(s)))
}

// maxalign returns the maximum required alignment for
// the list of symbols s; the list stops when s->type exceeds type.
func maxalign(s *LSym, type_ int) int32 {
	var align int32

	max := int32(0)
	for ; s != nil && int(s.Type) <= type_; s = s.Next {
		align = symalign(s)
		if max < align {
			max = align
		}
	}

	return max
}

const debugGCProg = false

type GCProg struct {
	sym *LSym
	w   gcprog.Writer
}

func (p *GCProg) Init(name string) {
	p.sym = Linklookup(Ctxt, name, 0)
	p.w.Init(p.writeByte)
	if debugGCProg {
		fmt.Fprintf(os.Stderr, "ld: start GCProg %s\n", name)
		p.w.Debug(os.Stderr)
	}
}

func (p *GCProg) writeByte(x byte) {
	Adduint8(Ctxt, p.sym, x)
}

func (p *GCProg) End(size int64) {
	p.w.ZeroUntil(size / int64(Thearch.Ptrsize))
	p.w.End()
	if debugGCProg {
		fmt.Fprintf(os.Stderr, "ld: end GCProg\n")
	}
}

func (p *GCProg) AddSym(s *LSym) {
	typ := s.Gotype
	// Things without pointers should be in SNOPTRDATA or SNOPTRBSS;
	// everything we see should have pointers and should therefore have a type.
	if typ == nil {
		Diag("missing Go type information for global symbol: %s size %d", s.Name, int(s.Size))
		return
	}

	ptrsize := int64(Thearch.Ptrsize)
	nptr := decodetype_ptrdata(typ) / ptrsize

	if debugGCProg {
		fmt.Fprintf(os.Stderr, "gcprog sym: %s at %d (ptr=%d+%d)\n", s.Name, s.Value, s.Value/ptrsize, nptr)
	}

	if decodetype_usegcprog(typ) == 0 {
		// Copy pointers from mask into program.
		mask := decodetype_gcmask(typ)
		for i := int64(0); i < nptr; i++ {
			if (mask[i/8]>>uint(i%8))&1 != 0 {
				p.w.Ptr(s.Value/ptrsize + i)
			}
		}
		return
	}

	// Copy program.
	prog := decodetype_gcprog(typ)
	p.w.ZeroUntil(s.Value / ptrsize)
	p.w.Append(prog[4:], nptr)
}

func growdatsize(datsizep *int64, s *LSym) {
	datsize := *datsizep
	const cutoff int64 = 2e9 // 2 GB (or so; looks better in errors than 2^31)
	switch {
	case s.Size < 0:
		Diag("%s: negative size (%d bytes)", s.Name, s.Size)
	case s.Size > cutoff:
		Diag("%s: symbol too large (%d bytes)", s.Name, s.Size)
	case datsize <= cutoff && datsize+s.Size > cutoff:
		Diag("%s: too much data (over %d bytes)", s.Name, cutoff)
	}
	*datsizep = datsize + s.Size
}

func dodata() {
	if Debug['v'] != 0 {
		fmt.Fprintf(&Bso, "%5.2f dodata\n", obj.Cputime())
	}
	Bso.Flush()

	var last *LSym
	datap = nil

	for s := Ctxt.Allsym; s != nil; s = s.Allsym {
		if !s.Reachable || s.Special != 0 {
			continue
		}
		if obj.STEXT < s.Type && s.Type < obj.SXREF {
			if s.Onlist != 0 {
				log.Fatalf("symbol %s listed multiple times", s.Name)
			}
			s.Onlist = 1
			if last == nil {
				datap = s
			} else {
				last.Next = s
			}
			s.Next = nil
			last = s
		}
	}

	for s := datap; s != nil; s = s.Next {
		if int64(len(s.P)) > s.Size {
			Diag("%s: initialize bounds (%d < %d)", s.Name, int64(s.Size), len(s.P))
		}
	}

	/*
	 * now that we have the datap list, but before we start
	 * to assign addresses, record all the necessary
	 * dynamic relocations.  these will grow the relocation
	 * symbol, which is itself data.
	 *
	 * on darwin, we need the symbol table numbers for dynreloc.
	 */
	if HEADTYPE == obj.Hdarwin {
		machosymorder()
	}
	dynreloc()

	/* some symbols may no longer belong in datap (Mach-O) */
	var l **LSym
	var s *LSym
	for l = &datap; ; {
		s = *l
		if s == nil {
			break
		}

		if s.Type <= obj.STEXT || obj.SXREF <= s.Type {
			*l = s.Next
		} else {
			l = &s.Next
		}
	}

	*l = nil

	if UseRelro() {
		// "read only" data with relocations needs to go in its own section
		// when building a shared library. We do this by boosting objects of
		// type SXXX with relocations to type SXXXRELRO.
		for s := datap; s != nil; s = s.Next {
			if (s.Type >= obj.STYPE && s.Type <= obj.SFUNCTAB && len(s.R) > 0) || s.Type == obj.SGOSTRING {
				s.Type += (obj.STYPERELRO - obj.STYPE)
				if s.Outer != nil {
					s.Outer.Type = s.Type
				}
			}
		}
		// Check that we haven't made two symbols with the same .Outer into
		// different types (because references two symbols with non-nil Outer
		// become references to the outer symbol + offset it's vital that the
		// symbol and the outer end up in the same section).
		for s := datap; s != nil; s = s.Next {
			if s.Outer != nil && s.Outer.Type != s.Type {
				Diag("inconsistent types for %s and its Outer %s (%d != %d)",
					s.Name, s.Outer.Name, s.Type, s.Outer.Type)
			}
		}

	}

	datap = listsort(datap, datcmp, listnextp)

	if Iself {
		// Make .rela and .rela.plt contiguous, the ELF ABI requires this
		// and Solaris actually cares.
		var relplt *LSym
		for l = &datap; *l != nil; l = &(*l).Next {
			if (*l).Name == ".rel.plt" || (*l).Name == ".rela.plt" {
				relplt = (*l)
				*l = (*l).Next
				break
			}
		}
		if relplt != nil {
			for s = datap; s != nil; s = s.Next {
				if s.Name == ".rel" || s.Name == ".rela" {
					relplt.Next = s.Next
					s.Next = relplt
				}
			}
		}
	}

	/*
	 * allocate sections.  list is sorted by type,
	 * so we can just walk it for each piece we want to emit.
	 * segdata is processed before segtext, because we need
	 * to see all symbols in the .data and .bss sections in order
	 * to generate garbage collection information.
	 */

	/* begin segdata */

	/* skip symbols belonging to segtext */
	s = datap

	for ; s != nil && s.Type < obj.SELFSECT; s = s.Next {
	}

	/* writable ELF sections */
	datsize := int64(0)

	var sect *Section
	for ; s != nil && s.Type < obj.SELFGOT; s = s.Next {
		sect = addsection(&Segdata, s.Name, 06)
		sect.Align = symalign(s)
		datsize = Rnd(datsize, int64(sect.Align))
		sect.Vaddr = uint64(datsize)
		s.Sect = sect
		s.Type = obj.SDATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
		sect.Length = uint64(datsize) - sect.Vaddr
	}

	/* .got (and .toc on ppc64) */
	if s.Type == obj.SELFGOT {
		sect := addsection(&Segdata, ".got", 06)
		sect.Align = maxalign(s, obj.SELFGOT)
		datsize = Rnd(datsize, int64(sect.Align))
		sect.Vaddr = uint64(datsize)
		var toc *LSym
		for ; s != nil && s.Type == obj.SELFGOT; s = s.Next {
			datsize = aligndatsize(datsize, s)
			s.Sect = sect
			s.Type = obj.SDATA
			s.Value = int64(uint64(datsize) - sect.Vaddr)

			// Resolve .TOC. symbol for this object file (ppc64)
			toc = Linkrlookup(Ctxt, ".TOC.", int(s.Version))

			if toc != nil {
				toc.Sect = sect
				toc.Outer = s
				toc.Sub = s.Sub
				s.Sub = toc

				toc.Value = 0x8000
			}

			growdatsize(&datsize, s)
		}

		sect.Length = uint64(datsize) - sect.Vaddr
	}

	/* pointer-free data */
	sect = addsection(&Segdata, ".noptrdata", 06)

	sect.Align = maxalign(s, obj.SINITARR-1)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.noptrdata", 0).Sect = sect
	Linklookup(Ctxt, "runtime.enoptrdata", 0).Sect = sect
	for ; s != nil && s.Type < obj.SINITARR; s = s.Next {
		datsize = aligndatsize(datsize, s)
		s.Sect = sect
		s.Type = obj.SDATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
	}

	sect.Length = uint64(datsize) - sect.Vaddr

	hasinitarr := Linkshared

	/* shared library initializer */
	switch Buildmode {
	case BuildmodeCArchive, BuildmodeCShared, BuildmodeShared:
		hasinitarr = true
	}

	if hasinitarr {
		sect := addsection(&Segdata, ".init_array", 06)
		sect.Align = maxalign(s, obj.SINITARR)
		datsize = Rnd(datsize, int64(sect.Align))
		sect.Vaddr = uint64(datsize)
		for ; s != nil && s.Type == obj.SINITARR; s = s.Next {
			datsize = aligndatsize(datsize, s)
			s.Sect = sect
			s.Value = int64(uint64(datsize) - sect.Vaddr)
			growdatsize(&datsize, s)
		}

		sect.Length = uint64(datsize) - sect.Vaddr
	}

	/* data */
	sect = addsection(&Segdata, ".data", 06)
	sect.Align = maxalign(s, obj.SBSS-1)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.data", 0).Sect = sect
	Linklookup(Ctxt, "runtime.edata", 0).Sect = sect
	var gc GCProg
	gc.Init("runtime.gcdata")
	for ; s != nil && s.Type < obj.SBSS; s = s.Next {
		if s.Type == obj.SINITARR {
			Ctxt.Cursym = s
			Diag("unexpected symbol type %d", s.Type)
		}

		s.Sect = sect
		s.Type = obj.SDATA
		datsize = aligndatsize(datsize, s)
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		gc.AddSym(s)
		growdatsize(&datsize, s)
	}
	sect.Length = uint64(datsize) - sect.Vaddr
	gc.End(int64(sect.Length))

	/* bss */
	sect = addsection(&Segdata, ".bss", 06)
	sect.Align = maxalign(s, obj.SNOPTRBSS-1)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.bss", 0).Sect = sect
	Linklookup(Ctxt, "runtime.ebss", 0).Sect = sect
	gc = GCProg{}
	gc.Init("runtime.gcbss")
	for ; s != nil && s.Type < obj.SNOPTRBSS; s = s.Next {
		s.Sect = sect
		datsize = aligndatsize(datsize, s)
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		gc.AddSym(s)
		growdatsize(&datsize, s)
	}
	sect.Length = uint64(datsize) - sect.Vaddr
	gc.End(int64(sect.Length))

	/* pointer-free bss */
	sect = addsection(&Segdata, ".noptrbss", 06)

	sect.Align = maxalign(s, obj.SNOPTRBSS)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.noptrbss", 0).Sect = sect
	Linklookup(Ctxt, "runtime.enoptrbss", 0).Sect = sect
	for ; s != nil && s.Type == obj.SNOPTRBSS; s = s.Next {
		datsize = aligndatsize(datsize, s)
		s.Sect = sect
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
	}

	sect.Length = uint64(datsize) - sect.Vaddr
	Linklookup(Ctxt, "runtime.end", 0).Sect = sect

	// 6g uses 4-byte relocation offsets, so the entire segment must fit in 32 bits.
	if datsize != int64(uint32(datsize)) {
		Diag("data or bss segment too large")
	}

	if s != nil && s.Type == obj.STLSBSS {
		if Iself && (Linkmode == LinkExternal || Debug['d'] == 0) && HEADTYPE != obj.Hopenbsd {
			sect = addsection(&Segdata, ".tbss", 06)
			sect.Align = int32(Thearch.Ptrsize)
			sect.Vaddr = 0
		} else {
			sect = nil
		}
		datsize = 0

		for ; s != nil && s.Type == obj.STLSBSS; s = s.Next {
			datsize = aligndatsize(datsize, s)
			s.Sect = sect
			s.Value = datsize
			growdatsize(&datsize, s)
		}

		if sect != nil {
			sect.Length = uint64(datsize)
		}
	}

	if s != nil {
		Ctxt.Cursym = nil
		Diag("unexpected symbol type %d for %s", s.Type, s.Name)
	}

	/*
	 * We finished data, begin read-only data.
	 * Not all systems support a separate read-only non-executable data section.
	 * ELF systems do.
	 * OS X and Plan 9 do not.
	 * Windows PE may, but if so we have not implemented it.
	 * And if we're using external linking mode, the point is moot,
	 * since it's not our decision; that code expects the sections in
	 * segtext.
	 */
	var segro *Segment
	if Iself && Linkmode == LinkInternal {
		segro = &Segrodata
	} else {
		segro = &Segtext
	}

	s = datap

	datsize = 0

	/* read-only executable ELF, Mach-O sections */
	for ; s != nil && s.Type < obj.STYPE; s = s.Next {
		sect = addsection(&Segtext, s.Name, 04)
		sect.Align = symalign(s)
		datsize = Rnd(datsize, int64(sect.Align))
		sect.Vaddr = uint64(datsize)
		s.Sect = sect
		s.Type = obj.SRODATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
		sect.Length = uint64(datsize) - sect.Vaddr
	}

	/* read-only data */
	sect = addsection(segro, ".rodata", 04)

	sect.Align = maxalign(s, obj.STYPERELRO-1)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = 0
	Linklookup(Ctxt, "runtime.rodata", 0).Sect = sect
	Linklookup(Ctxt, "runtime.erodata", 0).Sect = sect
	for ; s != nil && s.Type < obj.STYPERELRO; s = s.Next {
		datsize = aligndatsize(datsize, s)
		s.Sect = sect
		s.Type = obj.SRODATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
	}

	sect.Length = uint64(datsize) - sect.Vaddr

	// There is some data that are conceptually read-only but are written to by
	// relocations. On GNU systems, we can arrange for the dynamic linker to
	// mprotect sections after relocations are applied by giving them write
	// permissions in the object file and calling them ".data.rel.ro.FOO". We
	// divide the .rodata section between actual .rodata and .data.rel.ro.rodata,
	// but for the other sections that this applies to, we just write a read-only
	// .FOO section or a read-write .data.rel.ro.FOO section depending on the
	// situation.
	// TODO(mwhudson): It would make sense to do this more widely, but it makes
	// the system linker segfault on darwin.
	relro_perms := 04
	relro_prefix := ""

	if UseRelro() {
		relro_perms = 06
		relro_prefix = ".data.rel.ro"
		/* data only written by relocations */
		sect = addsection(segro, ".data.rel.ro", 06)

		sect.Align = maxalign(s, obj.STYPELINK-1)
		datsize = Rnd(datsize, int64(sect.Align))
		sect.Vaddr = 0
		for ; s != nil && s.Type < obj.STYPELINK; s = s.Next {
			datsize = aligndatsize(datsize, s)
			if s.Outer != nil && s.Outer.Sect != nil && s.Outer.Sect != sect {
				Diag("s.Outer (%s) in different section from s (%s)", s.Outer.Name, s.Name)
			}
			s.Sect = sect
			s.Type = obj.SRODATA
			s.Value = int64(uint64(datsize) - sect.Vaddr)
			growdatsize(&datsize, s)
		}

		sect.Length = uint64(datsize) - sect.Vaddr

	}

	/* typelink */
	sect = addsection(segro, relro_prefix+".typelink", relro_perms)

	sect.Align = maxalign(s, obj.STYPELINK)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.typelink", 0).Sect = sect
	Linklookup(Ctxt, "runtime.etypelink", 0).Sect = sect
	for ; s != nil && s.Type == obj.STYPELINK; s = s.Next {
		datsize = aligndatsize(datsize, s)
		s.Sect = sect
		s.Type = obj.SRODATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
	}

	sect.Length = uint64(datsize) - sect.Vaddr

	/* gosymtab */
	sect = addsection(segro, relro_prefix+".gosymtab", relro_perms)

	sect.Align = maxalign(s, obj.SPCLNTAB-1)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.symtab", 0).Sect = sect
	Linklookup(Ctxt, "runtime.esymtab", 0).Sect = sect
	for ; s != nil && s.Type < obj.SPCLNTAB; s = s.Next {
		datsize = aligndatsize(datsize, s)
		s.Sect = sect
		s.Type = obj.SRODATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
	}

	sect.Length = uint64(datsize) - sect.Vaddr

	/* gopclntab */
	sect = addsection(segro, relro_prefix+".gopclntab", relro_perms)

	sect.Align = maxalign(s, obj.SELFROSECT-1)
	datsize = Rnd(datsize, int64(sect.Align))
	sect.Vaddr = uint64(datsize)
	Linklookup(Ctxt, "runtime.pclntab", 0).Sect = sect
	Linklookup(Ctxt, "runtime.epclntab", 0).Sect = sect
	for ; s != nil && s.Type < obj.SELFROSECT; s = s.Next {
		datsize = aligndatsize(datsize, s)
		s.Sect = sect
		s.Type = obj.SRODATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
	}

	sect.Length = uint64(datsize) - sect.Vaddr

	/* read-only ELF, Mach-O sections */
	for ; s != nil && s.Type < obj.SELFSECT; s = s.Next {
		sect = addsection(segro, s.Name, 04)
		sect.Align = symalign(s)
		datsize = Rnd(datsize, int64(sect.Align))
		sect.Vaddr = uint64(datsize)
		s.Sect = sect
		s.Type = obj.SRODATA
		s.Value = int64(uint64(datsize) - sect.Vaddr)
		growdatsize(&datsize, s)
		sect.Length = uint64(datsize) - sect.Vaddr
	}

	// 6g uses 4-byte relocation offsets, so the entire segment must fit in 32 bits.
	if datsize != int64(uint32(datsize)) {
		Diag("read-only data segment too large")
	}

	/* number the sections */
	n := int32(1)

	for sect := Segtext.Sect; sect != nil; sect = sect.Next {
		sect.Extnum = int16(n)
		n++
	}
	for sect := Segrodata.Sect; sect != nil; sect = sect.Next {
		sect.Extnum = int16(n)
		n++
	}
	for sect := Segdata.Sect; sect != nil; sect = sect.Next {
		sect.Extnum = int16(n)
		n++
	}
}

// Add buildid to beginning of text segment, on non-ELF systems.
// Non-ELF binary formats are not always flexible enough to
// give us a place to put the Go build ID. On those systems, we put it
// at the very beginning of the text segment.
// This ``header'' is read by cmd/go.
func textbuildid() {
	if Iself || buildid == "" {
		return
	}

	sym := Linklookup(Ctxt, "go.buildid", 0)
	sym.Reachable = true
	// The \xff is invalid UTF-8, meant to make it less likely
	// to find one of these accidentally.
	data := "\xff Go build ID: " + strconv.Quote(buildid) + "\n \xff"
	sym.Type = obj.STEXT
	sym.P = []byte(data)
	sym.Size = int64(len(sym.P))

	sym.Next = Ctxt.Textp
	Ctxt.Textp = sym
}

// assign addresses to text
func textaddress() {
	var sub *LSym

	addsection(&Segtext, ".text", 05)

	// Assign PCs in text segment.
	// Could parallelize, by assigning to text
	// and then letting threads copy down, but probably not worth it.
	sect := Segtext.Sect

	sect.Align = int32(Funcalign)
	Linklookup(Ctxt, "runtime.text", 0).Sect = sect
	Linklookup(Ctxt, "runtime.etext", 0).Sect = sect
	va := uint64(INITTEXT)
	sect.Vaddr = va
	for sym := Ctxt.Textp; sym != nil; sym = sym.Next {
		sym.Sect = sect
		if sym.Type&obj.SSUB != 0 {
			continue
		}
		if sym.Align != 0 {
			va = uint64(Rnd(int64(va), int64(sym.Align)))
		} else {
			va = uint64(Rnd(int64(va), int64(Funcalign)))
		}
		sym.Value = 0
		for sub = sym; sub != nil; sub = sub.Sub {
			sub.Value += int64(va)
		}
		if sym.Size == 0 && sym.Sub != nil {
			Ctxt.Cursym = sym
		}
		if sym.Size < MINFUNC {
			va += MINFUNC // spacing required for findfunctab
		} else {
			va += uint64(sym.Size)
		}
	}

	sect.Length = va - sect.Vaddr
}

// assign addresses
func address() {
	va := uint64(INITTEXT)
	Segtext.Rwx = 05
	Segtext.Vaddr = va
	Segtext.Fileoff = uint64(HEADR)
	for s := Segtext.Sect; s != nil; s = s.Next {
		va = uint64(Rnd(int64(va), int64(s.Align)))
		s.Vaddr = va
		va += s.Length
	}

	Segtext.Length = va - uint64(INITTEXT)
	Segtext.Filelen = Segtext.Length
	if HEADTYPE == obj.Hnacl {
		va += 32 // room for the "halt sled"
	}

	if Segrodata.Sect != nil {
		// align to page boundary so as not to mix
		// rodata and executable text.
		va = uint64(Rnd(int64(va), int64(INITRND)))

		Segrodata.Rwx = 04
		Segrodata.Vaddr = va
		Segrodata.Fileoff = va - Segtext.Vaddr + Segtext.Fileoff
		Segrodata.Filelen = 0
		for s := Segrodata.Sect; s != nil; s = s.Next {
			va = uint64(Rnd(int64(va), int64(s.Align)))
			s.Vaddr = va
			va += s.Length
		}

		Segrodata.Length = va - Segrodata.Vaddr
		Segrodata.Filelen = Segrodata.Length
	}

	va = uint64(Rnd(int64(va), int64(INITRND)))
	Segdata.Rwx = 06
	Segdata.Vaddr = va
	Segdata.Fileoff = va - Segtext.Vaddr + Segtext.Fileoff
	Segdata.Filelen = 0
	if HEADTYPE == obj.Hwindows {
		Segdata.Fileoff = Segtext.Fileoff + uint64(Rnd(int64(Segtext.Length), PEFILEALIGN))
	}
	if HEADTYPE == obj.Hplan9 {
		Segdata.Fileoff = Segtext.Fileoff + Segtext.Filelen
	}
	var data *Section
	var noptr *Section
	var bss *Section
	var noptrbss *Section
	var vlen int64
	for s := Segdata.Sect; s != nil; s = s.Next {
		if Iself && s.Name == ".tbss" {
			continue
		}
		vlen = int64(s.Length)
		if s.Next != nil && !(Iself && s.Next.Name == ".tbss") {
			vlen = int64(s.Next.Vaddr - s.Vaddr)
		}
		s.Vaddr = va
		va += uint64(vlen)
		Segdata.Length = va - Segdata.Vaddr
		if s.Name == ".data" {
			data = s
		}
		if s.Name == ".noptrdata" {
			noptr = s
		}
		if s.Name == ".bss" {
			bss = s
		}
		if s.Name == ".noptrbss" {
			noptrbss = s
		}
	}

	Segdata.Filelen = bss.Vaddr - Segdata.Vaddr

	text := Segtext.Sect
	var rodata *Section
	if Segrodata.Sect != nil {
		rodata = Segrodata.Sect
	} else {
		rodata = text.Next
	}
	typelink := rodata.Next
	if UseRelro() {
		// There is another section (.data.rel.ro) when building a shared
		// object on elf systems.
		typelink = typelink.Next
	}
	symtab := typelink.Next
	pclntab := symtab.Next

	var sub *LSym
	for sym := datap; sym != nil; sym = sym.Next {
		Ctxt.Cursym = sym
		if sym.Sect != nil {
			sym.Value += int64(sym.Sect.Vaddr)
		}
		for sub = sym.Sub; sub != nil; sub = sub.Sub {
			sub.Value += sym.Value
		}
	}

	if Buildmode == BuildmodeShared {
		s := Linklookup(Ctxt, "go.link.abihashbytes", 0)
		sectSym := Linklookup(Ctxt, ".note.go.abihash", 0)
		s.Sect = sectSym.Sect
		s.Value = int64(sectSym.Sect.Vaddr + 16)
	}

	xdefine("runtime.text", obj.STEXT, int64(text.Vaddr))
	xdefine("runtime.etext", obj.STEXT, int64(text.Vaddr+text.Length))
	xdefine("runtime.rodata", obj.SRODATA, int64(rodata.Vaddr))
	xdefine("runtime.erodata", obj.SRODATA, int64(rodata.Vaddr+rodata.Length))
	xdefine("runtime.typelink", obj.SRODATA, int64(typelink.Vaddr))
	xdefine("runtime.etypelink", obj.SRODATA, int64(typelink.Vaddr+typelink.Length))

	sym := Linklookup(Ctxt, "runtime.gcdata", 