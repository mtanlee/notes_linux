ourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPOLICY 1"
.TH PERLPOLICY 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpolicy \- Various and sundry policies and commitments related to the Perl core
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is the master document which records all written
policies about how the Perl 5 Porters collectively develop and maintain
the Perl core.
.SH "GOVERNANCE"
.IX Header "GOVERNANCE"
.SS "Perl 5 Porters"
.IX Subsection "Perl 5 Porters"
Subscribers to perl5\-porters (the porters themselves) come in several flavours.
Some are quiet curious lurkers, who rarely pitch in and instead watch
the ongoing development to ensure they're forewarned of new changes or
features in Perl.  Some are representatives of vendors, who are there
to make sure that Perl continues to compile and work on their
platforms.  Some patch any reported bug that they know how to fix,
some are actively patching their pet area (threads, Win32, the regexp
\&\-engine), while others seem to do nothing but complain.  In other
words, it's your usual mix of technical people.
.PP
Over this group of porters presides Larry Wall.  He has the final word
in what does and does not change in any of the Perl programming languages.
These days, Larry spends most of his time on Perl 6, while Perl 5 is
shepherded by a \*(L"pumpking\*(R", a porter responsible for deciding what
goes into each release and ensuring that releases happen on a regular
basis.
.PP
Larry sees Perl development along the lines of the \s-1US\s0 government:
there's the Legislature (the porters), the Executive branch (the
\&\-pumpking), and the Supreme Court (Larry).  The legislature can
discuss and submit patches to the executive branch all they like, but
the executive branch is free to veto them.  Rarely, the Supreme Court
will side with the executive branch over the legislature, or the
legislature over the executive branch.  Mostly, however, the
legislature and the executive branch are supposed to get along and
work out their differences without impeachment or court cases.
.PP
You might sometimes see reference to Rule 1 and Rule 2.  Larry's power
as Supreme Court is expressed in The Rules:
.IP "1." 4
Larry is always by definition right about how Perl should behave.
This means he has final veto power on the core functionality.
.IP "2." 4
Larry is allowed to change his mind about any matter at a later date,
regardless of whether he previously invoked Rule 1.
.PP
Got that?  Larry is always right, even when he was wrong.  It's rare
to see either Rule exercised, but they are often alluded to.
.SH "MAINTENANCE AND SUPPORT"
.IX Header "MAINTENANCE AND SUPPORT"
Perl 5 is developed by a community, not a corporate entity. Every change
contributed to the Perl core is the result of a donation. Typically, these
donations are contributions of code or time by individual members of our
community. On occasion, these donations come in the form of corporate
or organizational sponsorship of a particular individual or project.
.PP
As a volunteer organization, the commitments we make are heavily dependent
on the goodwill and hard work of individuals who have no obligation to
contribute to Perl.
.PP
That being said, we value Perl's stability and security and have long
had an unwritten covenant with the broader Perl community to support
and maintain releases of Perl.
.PP
This document codifies the support and maintenance commitments that
the Perl community should expect from Perl's developers:
.IP "\(bu" 4
We \*(L"officially\*(R" support the two most recent stable release series.  5.12.x
and earlier are now out of support.  As of the release of 5.18.0, we will
\&\*(L"officially\*(R" end support for Perl 5.14.x, other than providing security
updates as described below.
.IP "\(bu" 4
To the best of our ability, we will attempt to fix critical issues
in the two most recent stable 5.x release series.  Fixes for the
current release series take precedence over fixes for the previous
release series.
.IP "\(bu" 4
To the best of our ability, we will provide \*(L"critical\*(R" security patches
/ releases for any major version of Perl whose 5.x.0 release was within
the past three years.  We can only commit to providing these for the
most recent .y release in any 5.x.y series.
.IP "\(bu" 4
We will not provide security updates or bug fixes for development
releases of Perl.
.IP "\(bu" 4
We encourage vendors to ship the most recent supported release of
Perl at the time of their code freeze.
.IP "\(bu" 4
As a vendor, you may have a requirement to backport security fixes
beyond our 3 year support commitment.  We can provide limited support and
advice to you as you do so and, where possible will try to apply
those patches to the relevant \-maint branches in git, though we may or
may not choose to make numbered releases or \*(L"official\*(R" patches
available.  Contact us at <perl5\-security\-report@perl.org>
to begin that process.
.SH "BACKWARD COMPATIBILITY AND DEPRECATION"
.IX Header "BACKWARD COMPATIBILITY AND DEPRECATION"
Our community has a long-held belief that backward-compatibility is a
virtue, even when the functionality in question is a design flaw.
.PP
We would all love to unmake some mistakes we've made over the past
decades.  Living with every design error we've ever made can lead
to painful stagnation.  Unwinding our mistakes is very, very
difficult.  Doing so without actively harming our users is
nearly impossible.
.PP
Lately, ignoring or actively opposing compatibility with earlier versions
of Perl has come into vogue.  Sometimes, a change is proposed which
wants to usurp syntax which previously had another meaning.  Sometimes,
a change wants to improve previously-crazy semantics.
.PP
Down this road lies madness.
.PP
Requiring end-user programmers to change just a few language constructs,
even language constructs which no well-educated developer would ever
intentionally use is tantamount to saying \*(L"you should not upgrade to
a new release of Perl unless you have 100% test coverage and can do a
full manual audit of your codebase.\*(R"  If we were to have tools capable of
reliably upgrading Perl source code from one version of Perl to another,
this concern could be significantly mitigated.
.PP
We want to ensure that Perl continues to grow and flourish in the coming
years and decades, but not at the expense of our user community.
.PP
Existing syntax and semantics should only be marked for destruction in
very limited circumstances.  If a given language feature's continued
inclusion in the language will cause significant harm to the language
or prevent us from making needed changes to the runtime, then it may
be considered for deprecation.
.PP
Any language change which breaks backward-compatibility should be able to
be enabled or disabled lexically.  Unless code at a given scope declares
that it wants the new behavior, that new behavior should be disabled.
Which backward-incompatible changes are controlled implicitly by a
\&'use v5.x.y' is a decision which should be made by the pumpking in
consultation with the community.
.PP
When a backward-incompatible change can't be toggled lexically, the decision
to change the language must be considered very, very carefully.  If it's
possible to move the old syntax or semantics out of the core language
and into XS-land, that \s-1XS\s0 module should be enabled by default unless
the user declares that they want a newer revision of Perl.
.PP
Historically, we've held ourselves to a far higher standard than
backward-compatibility \*(-- bugward-compatibility.  Any accident of
implementation or unintentional side-effect of running some bit of code
has been considered to be a feature of the language to be defended with
the same zeal as any other feature or functionality.  No matter how
frustrating these unintentional features may be to us as we continue
to improve Perl, these unintentional features often deserve our
protection.  It is very important that existing software written in
Perl continue to work correctly.  If end-user developers have adopted a
bug as a feature, we need to treat it as such.
.PP
New syntax and semantics which don't break existing language constructs
and syntax have a much lower bar.  They merely need to prove themselves
to be useful, elegant, well designed, and well tested.
.SS "Terminology"
.IX Subsection "Terminology"
To make sure we're talking about the same thing when we discuss the removal
of features or functionality from the Perl core, we have specific definitions
for a few words and phrases.
.IP "experimental" 4
.IX Item "experimental"
If something in the Perl core is marked as \fBexperimental\fR, we may change
its behaviour, deprecate or remove it without notice. While we'll always
do our best to smooth the transition path for users of experimental
features, you should contact the perl5\-porters mailinglist if you find
an experimental feature useful and want to help shape its future.
.IP "deprecated" 4
.IX Item "deprecated"
If something in the Perl core is marked as \fBdeprecated\fR, we may remove it
from the core in the next stable release series, though we may not. As of
Perl 5.12, deprecated features and modules warn the user as they're used.
When a module is deprecated, it will also be made available on \s-1CPAN.\s0
Installing it from \s-1CPAN\s0 will silence deprecation warnings for that module.
.Sp
If you use a deprecated feature or module and believe that its removal from
the Perl core would be a mistake, please contact the perl5\-porters
mailinglist and plead your case.  We don't deprecate things without a good
reason, but sometimes there's a counterargument we haven't considered.
Historically, we did not distinguish between \*(L"deprecated\*(R" and \*(L"discouraged\*(R"
features.
.IP "discouraged" 4
.IX Item "discouraged"
From time to time, we may mark language constructs and features which we
consider to have been mistakes as \fBdiscouraged\fR.  Discouraged features
aren't candidates for removal in the next major release series, but
we may later deprecate them if they're found to stand in the way of a
significant improvement to the Perl core.
.IP "removed" 4
.IX Item "removed"
Once a feature, construct or module has been marked as deprecated for a
stable release cycle, we may remove it from the Perl core.  Unsurprisingly,
we say we've \fBremoved\fR these things.  When a module is removed, it will
no longer ship with Perl, but will continue to be available on \s-1CPAN.\s0
.SH "MAINTENANCE BRANCHES"
.IX Header "MAINTENANCE BRANCHES"
.IP "\(bu" 4
New releases of maint should contain as few changes as possible.
If there is any question about whether a given patch might merit
inclusion in a maint release, then it almost certainly should not
be included.
.IP "\(bu" 4
Portability fixes, such as changes to Configure and the files in
hints/ are acceptable. Ports of Perl to a new platform, architecture
or \s-1OS\s0 release that involve changes to the implementation are \s-1NOT\s0
acceptable.
.IP "\(bu" 4
Acceptable documentation updates are those that correct factual errors,
explain significant bugs or deficiencies in the current implementation, 
or fix broken markup.
.IP "\(bu" 4
Patches that add new warnings or errors or deprecate features
are not acceptable.
.IP "\(bu" 4
Patches that fix crashing bugs that do not otherwise change Perl's
functionality or negatively impact performance are acceptable.
.IP "\(bu" 4
Patches that fix CVEs or security issues are acceptable, but should
be run through the perl5\-security\-report@perl.org mailing list
rather than applied directly.
.IP "\(bu" 4
Patches that fix regressions in perl's behavior relative to previous
releases are acceptable.
.IP "\(bu" 4
Updates to dual-life modules should consist of minimal patches to 
fix crashing or security issues (as above).
.IP "\(bu" 4
Minimal patches that fix platform-specific test failures or
installation issues are acceptable. When these changes are made
to dual-life modules for which \s-1CPAN\s0 is canonical, any changes
should be coordinated with the upstream author.
.IP "\(bu" 4
New versions of dual-life modules should \s-1NOT\s0 be imported into maint.
Those belong in the next stable series.
.IP "\(bu" 4
Patches that add or remove features are not acceptable.
.IP "\(bu" 4
Patches that break binary compatibility are not acceptable.  (Please
talk to a pumpking.)
.SS "Getting changes into a maint branch"
.IX Subsection "Getting changes into a maint branch"
Historically, only the pumpking cherry-picked changes from bleadperl
into maintperl.  This has scaling problems.  At the same time,
maintenance branches of stable versions of Perl need to be treated with
great care. To that end, as of Perl 5.12, we have a new process for
maint branches.
.PP
Any committer may cherry-pick any commit from blead to a maint branch if
they send mail to perl5\-porters announcing their intent to cherry-pick
a specific commit along with a rationale for doing so and at least two 
other committers respond to the list giving their assent. (This policy
applies to current and former pumpkings, as well as other committers.)
.SH "CONTRIBUTED MODULES"
.IX Header "CONTRIBUTED MODULES"
.SS "A Social Contract about Artistic Control"
.IX Subsection "A Social Contract about Artistic Control"
What follows is a statement about artistic control, defined as the ability
of authors of packages to guide the future of their code and maintain
control over their work.  It is a recognition that authors should have
control over their work, and that it is a responsibility of the rest of
the Perl community to ensure that they retain this control.  It is an
attempt to document the standards to which we, as Perl developers, intend
to hold ourselves.  It is an attempt to write down rough guidelines about
the respect we owe each other as Perl developers.
.PP
This statement is not a legal contract.  This statement is not a legal
document in any way, shape, or form.  Perl is distributed under the \s-1GNU\s0
Public License and under the Artistic License; those are the precise legal
terms.  This statement isn't about the law or licenses.  It's about
community, mutual respect, trust, and good-faith cooperation.
.PP
We recognize that the Perl core, defined as the software distributed with
the heart of Perl itself, is a joint project on the part of all of us.
From time to time, a script, module, or set of modules (hereafter referred
to simply as a \*(L"module\*(R") will prove so widely useful and/or so integral to
the correct functioning of Perl itself that it should be distributed with
the Perl core.  This should never be done without the author's explicit
consent, and a clear recognition on all parts that this means the module
is being distributed under the same terms as Perl itself.  A module author
should realize that inclusion of a module into the Perl core will
necessarily mean some loss of control over it, since changes may
occasionally have to be made on short notice or for consistency with the
rest of Perl.
.PP
Once a module has been included in the Perl core, however, everyone
involved in maintaining Perl should be aware that the module is still the
property of the original author unless the original author explicitly
gives up their ownership of it.  In particular:
.IP "\(bu" 4
The version of the module in the Perl core should still be considered the
work of the original author.  All patches, bug reports, and so
forth should be fed back to them.  Their development directions
should be respected whenever possible.
.IP "\(bu" 4
Patches may be applied by the pumpkin holder without the explicit
cooperation of the module author if and only if they are very minor,
time-critical in some fashion (such as urgent security fixes), or if
the module author cannot be reached.  Those patches must still be
given back to the author when possible, and if the author decides on
an alternate fix in their version, that fix should be strongly
preferred unless there is a serious problem with it.  Any changes not
endorsed by the author should be marked as such, and the contributor
of the change acknowledged.
.IP "\(bu" 4
The version of the module distributed with Perl should, whenever
possible, be the latest version of the module as distributed by the
author (the latest non-beta version in the case of public Perl
releases), although the pumpkin holder may hold off on upgrading the
version of the module distributed with Perl to the latest version
until the latest version has had sufficient testing.
.PP
In other words, the author of a module should be considered to have final
say on modifications to their module whenever possible (bearing in mind
that it's expected that everyone involved will work together and arrive at
reasonable compromises when there are disagreements).
.PP
As a last resort, however:
.PP
If the author's vision of the future of their module is sufficiently
different from the vision of the pumpkin holder and perl5\-porters as a
whole so as to cause serious problems for Perl, the pumpkin holder may
choose to formally fork the version of the module in the Perl core from the
one maintained by the author.  This should not be done lightly and
should \fBalways\fR if at all possible be done only after direct input
from Larry.  If this is done, it must then be made explicit in the
module as distributed with the Perl core that it is a forked version and
that while it is based on the original author's work, it is no longer
maintained by them.  This must be noted in both the documentation and
in the comments in the source of the module.
.PP
Again, this should be a last resort only.  Ideally, this should never
happen, and every possible effort at cooperation and compromise should be
made before doing this.  If it does prove necessary to fork a module for
the overall health of Perl, proper credit must be given to the original
author in perpetuity and the decision should be constantly re-evaluated to
see if a remerging of the two branches is possible down the road.
.PP
In all dealings with contributed modules, everyone maintaining Perl should
keep in mind that the code belongs to the original author, that they may
not be on perl5\-porters at any given time, and that a patch is not
official unless it has been integrated into the author's copy of the
module.  To aid with this, and with points #1, #2, and #3 above, contact
information for the authors of all contributed modules should be kept with
the Perl distribution.
.PP
Finally, the Perl community as a whole recognizes that respect for
ownership of code, respect for artistic control, proper credit, and active
effort to prevent unintentional code skew or communication gaps is vital
to the health of the community and Perl itself.  Members of a community
should not normally have to resort to rules and laws to deal with each
other, and this document, although it contains rules so as to be clear, is
about an attitude and general approach.  The first step in any dispute
should be open communication, respect for opposing views, and an attempt
at a compromise.  In nearly every circumstance nothing more will be
necessary, and certainly no more drastic measure should be used until
every avenue of communication and discussion has failed.
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
Perl's documentation is an important resource for our users. It's
incredibly important for Perl's documentation to be reasonably coherent
and to accurately reflect the current implementation.
.PP
Just as P5P collectively maintains the codebase, we collectively
maintain the documentation.  Writing a particular bit of documentation
doesn't give an author control of the future of that documentation.
At the same time, just as source code changes should match the style
of their surrounding blocks, so should documentation changes.
.PP
Examples in documentation should be illustrative of the concept
they're explaining.  Sometimes, the best way to show how a
language feature works is with a small program the reader can
run without modification.  More often, examples will consist
of a snippet of code containing only the \*(L"important\*(R" bits.
The definition of \*(L"important\*(R" varies from snippet to snippet.
Sometimes it's important to declare \f(CW\*(C`use strict\*(C'\fR and \f(CW\*(C`use warnings\*(C'\fR,
initialize all variables and fully catch every error condition.
More often than not, though, those things obscure the lesson
the example was intended to teach.
.PP
As Perl is developed by a global team of volunteers, our
documentation often contains spellings which look funny
to \fIsomebody\fR.  Choice of American/British/Other spellings
is left as an exercise for the author of each bit of
documentation.  When patching documentation, try to emulate
the documentation around you, rather than changing the existing
prose.
.PP
In general, documentation should describe what Perl does \*(L"now\*(R" rather
than what it used to do.  It's perfectly reasonable to include notes
in documentation about how behaviour has changed from previous releases,
but, with very few exceptions, documentation isn't \*(L"dual-life\*(R" \*(--
it doesn't need to fully describe how all old versions used to work.
.SH "CREDITS"
.IX Header "CREDITS"
\&\*(L"Social Contract about Contributed Modules\*(R" originally by Russ Allbery <rra@stanford.edu> and the perl5\-porters.
                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlport.1                                   0100644 0001750 0001750 00000311212 12566207443 022610  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPORT 1"
.TH PERLPORT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlport \- Writing portable Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl runs on numerous operating systems.  While most of them share
much in common, they also have their own unique features.
.PP
This document is meant to help you to find out what constitutes portable
Perl code.  That way once you make a decision to write portably,
you know where the lines are drawn, and you can stay within them.
.PP
There is a tradeoff between taking full advantage of one particular
type of computer and taking advantage of a full range of them.
Naturally, as you broaden your range and become more diverse, the
common factors drop, and you are left with an increasingly smaller
area of common ground in which you can operate to accomplish a
particular task.  Thus, when you begin attacking a problem, it is
important to consider under which part of the tradeoff curve you
want to operate.  Specifically, you must decide whether it is
important that the task that you are coding have the full generality
of being portable, or whether to just get the job done right now.
This is the hardest choice to be made.  The rest is easy, because
Perl provides many choices, whichever way you want to approach your
problem.
.PP
Looking at it another way, writing portable code is usually about
willfully limiting your available choices.  Naturally, it takes
discipline and sacrifice to do that.  The product of portability
and convenience may be a constant.  You have been warned.
.PP
Be aware of two important points:
.IP "Not all Perl programs have to be portable" 4
.IX Item "Not all Perl programs have to be portable"
There is no reason you should not use Perl as a language to glue Unix
tools together, or to prototype a Macintosh application, or to manage the
Windows registry.  If it makes no sense to aim for portability for one
reason or another in a given program, then don't bother.
.IP "Nearly all of Perl already \fIis\fR portable" 4
.IX Item "Nearly all of Perl already is portable"
Don't be fooled into thinking that it is hard to create portable Perl
code.  It isn't.  Perl tries its level-best to bridge the gaps between
what's available on different platforms, and all the means available to
use those features.  Thus almost all Perl code runs on any machine
without modification.  But there are some significant issues in
writing portable code, and this document is entirely about those issues.
.PP
Here's the general rule: When you approach a task commonly done
using a whole range of platforms, think about writing portable
code.  That way, you don't sacrifice much by way of the implementation
choices you can avail yourself of, and at the same time you can give
your users lots of platform choices.  On the other hand, when you have to
take advantage of some unique feature of a particular platform, as is
often the case with systems programming (whether for Unix, Windows,
\&\s-1VMS,\s0 etc.), consider writing platform-specific code.
.PP
When the code will run on only two or three operating systems, you
may need to consider only the differences of those particular systems.
The important thing is to decide where the code will run and to be
deliberate in your decision.
.PP
The material below is separated into three main sections: main issues of
portability (\*(L"\s-1ISSUES\*(R"\s0), platform-specific issues (\*(L"\s-1PLATFORMS\*(R"\s0), and
built-in perl functions that behave differently on various ports
(\*(L"\s-1FUNCTION IMPLEMENTATIONS\*(R"\s0).
.PP
This information should not be considered complete; it includes possibly
transient information about idiosyncrasies of some of the ports, almost
all of which are in a state of constant evolution.  Thus, this material
should be considered a perpetual work in progress
(\f(CW\*(C`<IMG SRC="yellow_sign.gif" ALT="Under Construction">\*(C'\fR).
.SH "ISSUES"
.IX Header "ISSUES"
.SS "Newlines"
.IX Subsection "Newlines"
In most operating systems, lines in files are terminated by newlines.
Just what is used as a newline may vary from \s-1OS\s0 to \s-1OS. \s0 Unix
traditionally uses \f(CW\*(C`\e012\*(C'\fR, one type of DOSish I/O uses \f(CW\*(C`\e015\e012\*(C'\fR,
and Mac\ \s-1OS\s0 uses \f(CW\*(C`\e015\*(C'\fR.
.PP
Perl uses \f(CW\*(C`\en\*(C'\fR to represent the \*(L"logical\*(R" newline, where what is
logical may depend on the platform in use.  In MacPerl, \f(CW\*(C`\en\*(C'\fR always
means \f(CW\*(C`\e015\*(C'\fR.  In DOSish perls, \f(CW\*(C`\en\*(C'\fR usually means \f(CW\*(C`\e012\*(C'\fR, but when
accessing a file in \*(L"text\*(R" mode, perl uses the \f(CW\*(C`:crlf\*(C'\fR layer that
translates it to (or from) \f(CW\*(C`\e015\e012\*(C'\fR, depending on whether you're
reading or writing. Unix does the same thing on ttys in canonical
mode.  \f(CW\*(C`\e015\e012\*(C'\fR is commonly referred to as \s-1CRLF.\s0
.PP
To trim trailing newlines from text lines use \fIchomp()\fR.  With default 
settings that function looks for a trailing \f(CW\*(C`\en\*(C'\fR character and thus 
trims in a portable way.
.PP
When dealing with binary files (or text files in binary mode) be sure
to explicitly set $/ to the appropriate value for your file format
before using \fIchomp()\fR.
.PP
Because of the \*(L"text\*(R" mode translation, DOSish perls have limitations
in using \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR on a file accessed in \*(L"text\*(R" mode.
Stick to \f(CW\*(C`seek\*(C'\fR\-ing to locations you got from \f(CW\*(C`tell\*(C'\fR (and no
others), and you are usually free to use \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR even
in \*(L"text\*(R" mode.  Using \f(CW\*(C`seek\*(C'\fR or \f(CW\*(C`tell\*(C'\fR or other file operations
may be non-portable.  If you use \f(CW\*(C`binmode\*(C'\fR on a file, however, you
can usually \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR with arbitrary values in safety.
.PP
A common misconception in socket programming is that \f(CW\*(C`\en\*(C'\fR eq \f(CW\*(C`\e012\*(C'\fR
everywhere.  When using protocols such as common Internet protocols,
\&\f(CW\*(C`\e012\*(C'\fR and \f(CW\*(C`\e015\*(C'\fR are called for specifically, and the values of
the logical \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR (carriage return) are not reliable.
.PP
.Vb 2
\&    print SOCKET "Hi there, client!\er\en";      # WRONG
\&    print SOCKET "Hi there, client!\e015\e012";  # RIGHT
.Ve
.PP
However, using \f(CW\*(C`\e015\e012\*(C'\fR (or \f(CW\*(C`\ecM\ecJ\*(C'\fR, or \f(CW\*(C`\ex0D\ex0A\*(C'\fR) can be tedious
and unsightly, as well as confusing to those maintaining the code.  As
such, the Socket module supplies the Right Thing for those who want it.
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    print SOCKET "Hi there, client!$CRLF"      # RIGHT
.Ve
.PP
When reading from a socket, remember that the default input record
separator \f(CW$/\fR is \f(CW\*(C`\en\*(C'\fR, but robust socket code will recognize as
either \f(CW\*(C`\e012\*(C'\fR or \f(CW\*(C`\e015\e012\*(C'\fR as end of line:
.PP
.Vb 3
\&    while (<SOCKET>) {
\&        # ...
\&    }
.Ve
.PP
Because both \s-1CRLF\s0 and \s-1LF\s0 end in \s-1LF,\s0 the input record separator can
be set to \s-1LF\s0 and any \s-1CR\s0 stripped later.  Better to write:
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    local($/) = LF;      # not needed if $/ is already \e012
\&
\&    while (<SOCKET>) {
\&        s/$CR?$LF/\en/;   # not sure if socket uses LF or CRLF, OK
\&    #   s/\e015?\e012/\en/; # same thing
\&    }
.Ve
.PP
This example is preferred over the previous one\*(--even for Unix
platforms\*(--because now any \f(CW\*(C`\e015\*(C'\fR's (\f(CW\*(C`\ecM\*(C'\fR's) are stripped out
(and there was much rejoicing).
.PP
Similarly, functions that return text data\*(--such as a function that
fetches a web page\*(--should sometimes translate newlines before
returning the data, if they've not yet been translated to the local
newline representation.  A single line of code will often suffice:
.PP
.Vb 2
\&    $data =~ s/\e015?\e012/\en/g;
\&    return $data;
.Ve
.PP
Some of this may be confusing.  Here's a handy reference to the \s-1ASCII CR\s0
and \s-1LF\s0 characters.  You can print it out and stick it in your wallet.
.PP
.Vb 2
\&    LF  eq  \e012  eq  \ex0A  eq  \ecJ  eq  chr(10)  eq  ASCII 10
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  ASCII 13
\&
\&             | Unix | DOS  | Mac  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF  |  CR  |
\&        \er   |  CR  |  CR  |  LF  |
\&        \en * |  LF  | CRLF |  CR  |
\&        \er * |  CR  |  CR  |  LF  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.PP
The Unix column assumes that you are not accessing a serial line
(like a tty) in canonical mode.  If you are, then \s-1CR\s0 on input becomes
\&\*(L"\en\*(R", and \*(L"\en\*(R" on output becomes \s-1CRLF.\s0
.PP
These are just the most common definitions of \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR in Perl.
There may well be others.  For example, on an \s-1EBCDIC\s0 implementation
such as z/OS (\s-1OS/390\s0) or \s-1OS/400 \s0(using the \s-1ILE,\s0 the \s-1PASE\s0 is ASCII-based)
the above material is similar to \*(L"Unix\*(R" but the code numbers change:
.PP
.Vb 4
\&    LF  eq  \e025  eq  \ex15  eq  \ecU  eq  chr(21)  eq  CP\-1047 21
\&    LF  eq  \e045  eq  \ex25  eq           chr(37)  eq  CP\-0037 37
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-1047 13
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-0037 13
\&
\&             | z/OS | OS/400 |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF    |
\&        \er   |  CR  |  CR    |
\&        \en * |  LF  |  LF    |
\&        \er * |  CR  |  CR    |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.SS "Numbers endianness and Width"
.IX Subsection "Numbers endianness and Width"
Different CPUs store integers and floating point numbers in different
orders (called \fIendianness\fR) and widths (32\-bit and 64\-bit being the
most common today).  This affects your programs when they attempt to transfer
numbers in binary format from one \s-1CPU\s0 architecture to another,
usually either \*(L"live\*(R" via network connection, or by storing the
numbers to secondary storage such as a disk file or tape.
.PP
Conflicting storage orders make utter mess out of the numbers.  If a
little-endian host (Intel, \s-1VAX\s0) stores 0x12345678 (305419896 in
decimal), a big-endian host (Motorola, Sparc, \s-1PA\s0) reads it as
0x78563412 (2018915346 in decimal).  Alpha and \s-1MIPS\s0 can be either:
Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses
them in big-endian mode.  To avoid this problem in network (socket)
connections use the \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR formats \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`N\*(C'\fR, the
\&\*(L"network\*(R" orders.  These are guaranteed to be portable.
.PP
As of perl 5.10.0, you can also use the \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`<\*(C'\fR modifiers
to force big\- or little-endian byte-order.  This is useful if you want
to store signed integers or 64\-bit integers, for example.
.PP
You can explore the endianness of your platform by unpacking a
data structure packed in native format such as:
.PP
.Vb 3
\&    print unpack("h*", pack("s2", 1, 2)), "\en";
\&    # \*(Aq10002000\*(Aq on e.g. Intel x86 or Alpha 21064 in little\-endian mode
\&    # \*(Aq00100020\*(Aq on e.g. Motorola 68040
.Ve
.PP
If you need to distinguish between endian architectures you could use
either of the variables set like so:
.PP
.Vb 2
\&    $is_big_endian   = unpack("h*", pack("s", 1)) =~ /01/;
\&    $is_little_endian = unpack("h*", pack("s", 1)) =~ /^1/;
.Ve
.PP
Differing widths can cause truncation even between platforms of equal
endianness.  The platform of shorter width loses the upper parts of the
number.  There is no good solution for this problem except to avoid
transferring or storing raw binary numbers.
.PP
One can circumnavigate both these problems in two ways.  Either
transfer and store numbers always in text format, instead of raw
binary, or else consider using modules like Data::Dumper and Storable
(included as of perl 5.8).  Keeping all data as text significantly
simplifies matters.
.PP
The v\-strings are portable only up to v2147483647 (0x7FFFFFFF), that's
how far \s-1EBCDIC,\s0 or more precisely UTF-EBCDIC will go.
.SS "Files and Filesystems"
.IX Subsection "Files and Filesystems"
Most platforms these days structure files in a hierarchical fashion.
So, it is reasonably safe to assume that all platforms support the
notion of a \*(L"path\*(R" to uniquely identify a file on the system.  How
that path is really written, though, differs considerably.
.PP
Although similar, file path specifications differ between Unix,
Windows, Mac\ \s-1OS, OS/2, VMS, VOS, RISC\s0\ \s-1OS,\s0 and probably others.
Unix, for example, is one of the few OSes that has the elegant idea
of a single root directory.
.PP
\&\s-1DOS, OS/2, VMS, VOS,\s0 and Windows can work similarly to Unix with \f(CW\*(C`/\*(C'\fR
as path separator, or in their own idiosyncratic ways (such as having
several root directories and various \*(L"unrooted\*(R" device files such \s-1NIL:\s0
and \s-1LPT:\s0).
.PP
Mac\ \s-1OS 9\s0 and earlier used \f(CW\*(C`:\*(C'\fR as a path separator instead of \f(CW\*(C`/\*(C'\fR.
.PP
The filesystem may support neither hard links (\f(CW\*(C`link\*(C'\fR) nor
symbolic links (\f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR).
.PP
The filesystem may support neither access timestamp nor change
timestamp (meaning that about the only portable timestamp is the
modification timestamp), or one second granularity of any timestamps
(e.g. the \s-1FAT\s0 filesystem limits the time granularity to two seconds).
.PP
The \*(L"inode change timestamp\*(R" (the \f(CW\*(C`\-C\*(C'\fR filetest) may really be the
\&\*(L"creation timestamp\*(R" (which it is not in Unix).
.PP
\&\s-1VOS\s0 perl can emulate Unix filenames with \f(CW\*(C`/\*(C'\fR as path separator.  The
native pathname characters greater-than, less-than, number-sign, and
percent-sign are always accepted.
.PP
\&\s-1RISC\s0\ \s-1OS\s0 perl can emulate Unix filenames with \f(CW\*(C`/\*(C'\fR as path
separator, or go native and use \f(CW\*(C`.\*(C'\fR for path separator and \f(CW\*(C`:\*(C'\fR to
signal filesystems and disk names.
.PP
Don't assume Unix filesystem access semantics: that read, write,
and execute are all the permissions there are, and even if they exist,
that their semantics (for example what do r, w, and x mean on
a directory) are the Unix ones.  The various Unix/POSIX compatibility
layers usually try to make interfaces like \fIchmod()\fR work, but sometimes
there simply is no good mapping.
.PP
If all this is intimidating, have no (well, maybe only a little)
fear.  There are modules that can help.  The File::Spec modules
provide methods to do the Right Thing on whatever platform happens
to be running the program.
.PP
.Vb 6
\&    use File::Spec::Functions;
\&    chdir(updir());        # go up one directory
\&    my $file = catfile(curdir(), \*(Aqtemp\*(Aq, \*(Aqfile.txt\*(Aq);
\&    # on Unix and Win32, \*(Aq./temp/file.txt\*(Aq
\&    # on Mac OS Classic, \*(Aq:temp:file.txt\*(Aq
\&    # on VMS, \*(Aq[.temp]file.txt\*(Aq
.Ve
.PP
File::Spec is available in the standard distribution as of version
5.004_05.  File::Spec::Functions is only in File::Spec 0.7 and later,
and some versions of perl come with version 0.6.  If File::Spec
is not updated to 0.7 or later, you must use the object-oriented
interface from File::Spec (or upgrade File::Spec).
.PP
In general, production code should not have file paths hardcoded.
Making them user-supplied or read from a configuration file is
better, keeping in mind that file path syntax varies on different
machines.
.PP
This is especially noticeable in scripts like Makefiles and test suites,
which often assume \f(CW\*(C`/\*(C'\fR as a path separator for subdirectories.
.PP
Also of use is File::Basename from the standard distribution, which
splits a pathname into pieces (base filename, full path to directory,
and file suffix).
.PP
Even when on a single platform (if you can call Unix a single platform),
remember not to count on the existence or the contents of particular
system-specific files or directories, like \fI/etc/passwd\fR,
\&\fI/etc/sendmail.conf\fR, \fI/etc/resolv.conf\fR, or even \fI/tmp/\fR.  For
example, \fI/etc/passwd\fR may exist but not contain the encrypted
passwords, because the system is using some form of enhanced security.
Or it may not contain all the accounts, because the system is using \s-1NIS. \s0
If code does need to rely on such a file, include a description of the
file and its format in the code's documentation, then make it easy for
the user to override the default location of the file.
.PP
Don't assume a text file will end with a newline.  They should,
but people forget.
.PP
Do not have two files or directories of the same name with different
case, like \fItest.pl\fR and \fITest.pl\fR, as many platforms have
case-insensitive (or at least case-forgiving) filenames.  Also, try
not to have non-word characters (except for \f(CW\*(C`.\*(C'\fR) in the names, and
keep them to the 8.3 convention, for maximum portability, onerous a
burden though this may appear.
.PP
Likewise, when using the AutoSplit module, try to keep your functions to
8.3 naming and case-insensitive conventions; or, at the least,
make it so the resulting files have a unique (case-insensitively)
first 8 characters.
.PP
Whitespace in filenames is tolerated on most systems, but not all,
and even on systems where it might be tolerated, some utilities
might become confused by such whitespace.
.PP
Many systems (\s-1DOS, VMS ODS\-2\s0) cannot have more than one \f(CW\*(C`.\*(C'\fR in their
filenames.
.PP
Don't assume \f(CW\*(C`>\*(C'\fR won't be the first character of a filename.
Always use \f(CW\*(C`<\*(C'\fR explicitly to open a file for reading, or even
better, use the three-arg version of open, unless you want the user to
be able to specify a pipe open.
.PP
.Vb 1
\&    open my $fh, \*(Aq<\*(Aq, $existing_file) or die $!;
.Ve
.PP
If filenames might use strange characters, it is safest to open it
with \f(CW\*(C`sysopen\*(C'\fR instead of \f(CW\*(C`open\*(C'\fR.  \f(CW\*(C`open\*(C'\fR is magic and can
translate characters like \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`<\*(C'\fR, and \f(CW\*(C`|\*(C'\fR, which may
be the wrong thing to do.  (Sometimes, though, it's the right thing.)
Three-arg open can also help protect against this translation in cases
where it is undesirable.
.PP
Don't use \f(CW\*(C`:\*(C'\fR as a part of a filename since many systems use that for
their own semantics (Mac \s-1OS\s0 Classic for separating pathname components,
many networking schemes and utilities for separating the nodename and
the pathname, and so on).  For the same reasons, avoid \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`;\*(C'\fR and
\&\f(CW\*(C`|\*(C'\fR.
.PP
Don't assume that in pathnames you can collapse two leading slashes
\&\f(CW\*(C`//\*(C'\fR into one: some networking and clustering filesystems have special
semantics for that.  Let the operating system to sort it out.
.PP
The \fIportable filename characters\fR as defined by \s-1ANSI C\s0 are
.PP
.Vb 4
\& a b c d e f g h i j k l m n o p q r t u v w x y z
\& A B C D E F G H I J K L M N O P Q R T U V W X Y Z
\& 0 1 2 3 4 5 6 7 8 9
\& . _ \-
.Ve
.PP
and the \*(L"\-\*(R" shouldn't be the first character.  If you want to be
hypercorrect, stay case-insensitive and within the 8.3 naming
convention (all the files and directories have to be unique within one
directory if their names are lowercased and truncated to eight
characters before the \f(CW\*(C`.\*(C'\fR, if any, and to three characters after the
\&\f(CW\*(C`.\*(C'\fR, if any).  (And do not use \f(CW\*(C`.\*(C'\fRs in directory names.)
.SS "System Interaction"
.IX Subsection "System Interaction"
Not all platforms provide a command line.  These are usually platforms
that rely primarily on a Graphical User Interface (\s-1GUI\s0) for user
interaction.  A program requiring a command line interface might
not work everywhere.  This is probably for the user of the program
to deal with, so don't stay up late worrying about it.
.PP
Some platforms can't delete or rename files held open by the system,
this limitation may also apply to changing filesystem metainformation
like file permissions or owners.  Remember to \f(CW\*(C`close\*(C'\fR files when you
are done with them.  Don't \f(CW\*(C`unlink\*(C'\fR or \f(CW\*(C`rename\*(C'\fR an open file.  Don't
\&\f(CW\*(C`tie\*(C'\fR or \f(CW\*(C`open\*(C'\fR a file already tied or opened; \f(CW\*(C`untie\*(C'\fR or \f(CW\*(C`close\*(C'\fR
it first.
.PP
Don't open the same file more than once at a time for writing, as some
operating systems put mandatory locks on such files.
.PP
Don't assume that write/modify permission on a directory gives the
right to add or delete files/directories in that directory.  That is
filesystem specific: in some filesystems you need write/modify
permission also (or even just) in the file/directory itself.  In some
filesystems (\s-1AFS, DFS\s0) the permission to add/delete directory entries
is a completely separate permission.
.PP
Don't assume that a single \f(CW\*(C`unlink\*(C'\fR completely gets rid of the file:
some filesystems (most notably the ones in \s-1VMS\s0) have versioned
filesystems, and \fIunlink()\fR removes only the most recent one (it doesn't
remove all the versions because by default the native tools on those
platforms remove just the most recent version, too).  The portable
idiom to remove all the versions of a file is
.PP
.Vb 1
\&    1 while unlink "file";
.Ve
.PP
This will terminate if the file is undeleteable for some reason
(protected, not there, and so on).
.PP
Don't count on a specific environment variable existing in \f(CW%ENV\fR.
Don't count on \f(CW%ENV\fR entries being case-sensitive, or even
case-preserving.  Don't try to clear \f(CW%ENV\fR by saying \f(CW\*(C`%ENV = ();\*(C'\fR, or,
if you really have to, make it conditional on \f(CW\*(C`$^O ne \*(AqVMS\*(Aq\*(C'\fR since in
\&\s-1VMS\s0 the \f(CW%ENV\fR table is much more than a per-process key-value string
table.
.PP
On \s-1VMS,\s0 some entries in the \f(CW%ENV\fR hash are dynamically created when
their key is used on a read if they did not previously exist.  The
values for \f(CW$ENV{HOME}\fR, \f(CW$ENV{TERM}\fR, \f(CW$ENV{HOME}\fR, and \f(CW$ENV{USER}\fR,
are known to be dynamically generated.  The specific names that are
dynamically generated may vary with the version of the C library on \s-1VMS,\s0
and more may exist than is documented.
.PP
On \s-1VMS\s0 by default, changes to the \f(CW%ENV\fR hash are persistent after the process
exits.  This can cause unintended issues.
.PP
Don't count on signals or \f(CW%SIG\fR for anything.
.PP
Don't count on filename globbing.  Use \f(CW\*(C`opendir\*(C'\fR, \f(CW\*(C`readdir\*(C'\fR, and
\&\f(CW\*(C`closedir\*(C'\fR instead.
.PP
Don't count on per-program environment variables, or per-program current
directories.
.PP
Don't count on specific values of \f(CW$!\fR, neither numeric nor
especially the strings values. Users may switch their locales causing
error messages to be translated into their languages.  If you can
trust a POSIXish environment, you can portably use the symbols defined
by the Errno module, like \s-1ENOENT. \s0 And don't trust on the values of \f(CW$!\fR
at all except immediately after a failed system call.
.SS "Command names versus file pathnames"
.IX Subsection "Command names versus file pathnames"
Don't assume that the name used to invoke a command or program with
\&\f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR can also be used to test for the existence of the
file that holds the executable code for that command or program.
First, many systems have \*(L"internal\*(R" commands that are built-in to the
shell or \s-1OS\s0 and while these commands can be invoked, there is no
corresponding file.  Second, some operating systems (e.g., Cygwin,
\&\s-1DJGPP, OS/2,\s0 and \s-1VOS\s0) have required suffixes for executable files;
these suffixes are generally permitted on the command name but are not
required.  Thus, a command like \*(L"perl\*(R" might exist in a file named
\&\*(L"perl\*(R", \*(L"perl.exe\*(R", or \*(L"perl.pm\*(R", depending on the operating system.
The variable \*(L"_exe\*(R" in the Config module holds the executable suffix,
if any.  Third, the \s-1VMS\s0 port carefully sets up $^X and
\&\f(CW$Config\fR{perlpath} so that no further processing is required.  This is
just as well, because the matching regular expression used below would
then have to deal with a possible trailing version number in the \s-1VMS\s0
file name.
.PP
To convert $^X to a file pathname, taking account of the requirements
of the various operating system possibilities, say:
.PP
.Vb 4
\& use Config;
\& my $thisperl = $^X;
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.PP
To convert \f(CW$Config\fR{perlpath} to a file pathname, say:
.PP
.Vb 4
\& use Config;
\& my $thisperl = $Config{perlpath};
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.SS "Networking"
.IX Subsection "Networking"
Don't assume that you can reach the public Internet.
.PP
Don't assume that there is only one way to get through firewalls
to the public Internet.
.PP
Don't assume that you can reach outside world through any other port
than 80, or some web proxy.  ftp is blocked by many firewalls.
.PP
Don't assume that you can send email by connecting to the local \s-1SMTP\s0 port.
.PP
Don't assume that you can reach yourself or any node by the name
\&'localhost'.  The same goes for '127.0.0.1'.  You will have to try both.
.PP
Don't assume that the host has only one network card, or that it
can't bind to many virtual \s-1IP\s0 addresses.
.PP
Don't assume a particular network device name.
.PP
Don't assume a particular set of \fIioctl()\fRs will work.
.PP
Don't assume that you can ping hosts and get replies.
.PP
Don't assume that any particular port (service) will respond.
.PP
Don't assume that Sys::Hostname (or any other \s-1API\s0 or command) returns
either a fully qualified hostname or a non-qualified hostname: it all
depends on how the system had been configured.  Also remember that for
things such as \s-1DHCP\s0 and \s-1NAT,\s0 the hostname you get back might not be
very useful.
.PP
All the above \*(L"don't\*(R":s may look daunting, and they are, but the key
is to degrade gracefully if one cannot reach the particular network
service one wants.  Croaking or hanging do not look very professional.
.SS "Interprocess Communication (\s-1IPC\s0)"
.IX Subsection "Interprocess Communication (IPC)"
In general, don't directly access the system in code meant to be
portable.  That means, no \f(CW\*(C`system\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`pipe\*(C'\fR,
\&\f(CW\*(C`\`\`\*(C'\fR, \f(CW\*(C`qx//\*(C'\fR, \f(CW\*(C`open\*(C'\fR with a \f(CW\*(C`|\*(C'\fR, nor any of the other things
that makes being a perl hacker worth being.
.PP
Commands that launch external processes are generally supported on
most platforms (though many of them do not support any type of
forking).  The problem with using them arises from what you invoke
them on.  External tools are often named differently on different
platforms, may not be available in the same location, might accept
different arguments, can behave differently, and often present their
results in a platform-dependent way.  Thus, you should seldom depend
on them to produce consistent results. (Then again, if you're calling 
\&\fInetstat \-a\fR, you probably don't expect it to run on both Unix and \s-1CP/M.\s0)
.PP
One especially common bit of Perl code is opening a pipe to \fBsendmail\fR:
.PP
.Vb 2
\&    open(MAIL, \*(Aq|/usr/lib/sendmail \-t\*(Aq) 
\&        or die "cannot fork sendmail: $!";
.Ve
.PP
This is fine for systems programming when sendmail is known to be
available.  But it is not fine for many non-Unix systems, and even
some Unix systems that may not have sendmail installed.  If a portable
solution is needed, see the various distributions on \s-1CPAN\s0 that deal
with it.  Mail::Mailer and Mail::Send in the MailTools distribution are
commonly used, and provide several mailing methods, including mail,
sendmail, and direct \s-1SMTP \s0(via Net::SMTP) if a mail transfer agent is
not available.  Mail::Sendmail is a standalone module that provides
simple, platform-independent mailing.
.PP
The Unix System V \s-1IPC \s0(\f(CW\*(C`msg*(), sem*(), shm*()\*(C'\fR) is not available
even on all Unix platforms.
.PP
Do not use either the bare result of \f(CW\*(C`pack("N", 10, 20, 30, 40)\*(C'\fR or
bare v\-strings (such as \f(CW\*(C`v10.20.30.40\*(C'\fR) to represent IPv4 addresses:
both forms just pack the four bytes into network order.  That this
would be equal to the C language \f(CW\*(C`in_addr\*(C'\fR struct (which is what the
socket code internally uses) is not guaranteed.  To be portable use
the routines of the Socket extension, such as \f(CW\*(C`inet_aton()\*(C'\fR,
\&\f(CW\*(C`inet_ntoa()\*(C'\fR, and \f(CW\*(C`sockaddr_in()\*(C'\fR.
.PP
The rule of thumb for portable code is: Do it all in portable Perl, or
use a module (that may internally implement it with platform-specific
code, but expose a common interface).
.SS "External Subroutines (\s-1XS\s0)"
.IX Subsection "External Subroutines (XS)"
\&\s-1XS\s0 code can usually be made to work with any platform, but dependent
libraries, header files, etc., might not be readily available or
portable, or the \s-1XS\s0 code itself might be platform-specific, just as Perl
code might be.  If the libraries and headers are portable, then it is
normally reasonable to make sure the \s-1XS\s0 code is portable, too.
.PP
A different type of portability issue arises when writing \s-1XS\s0 code:
availability of a C compiler on the end-user's system.  C brings
with it its own portability issues, and writing \s-1XS\s0 code will expose
you to some of those.  Writing purely in Perl is an easier way to
achieve portability.
.SS "Standard Modules"
.IX Subsection "Standard Modules"
In general, the standard modules work across platforms.  Notable
exceptions are the \s-1CPAN\s0 module (which currently makes connections to external
programs that may not be available), platform-specific modules (like
ExtUtils::MM_VMS), and \s-1DBM\s0 modules.
.PP
There is no one \s-1DBM\s0 module available on all platforms.
SDBM_File and the others are generally available on all Unix and DOSish
ports, but not in MacPerl, where only NBDM_File and DB_File are
available.
.PP
The good news is that at least some \s-1DBM\s0 module should be available, and
AnyDBM_File will use whichever module it can find.  Of course, then
the code needs to be fairly strict, dropping to the greatest common
factor (e.g., not exceeding 1K for each record), so that it will
work with any \s-1DBM\s0 module.  See AnyDBM_File for more details.
.SS "Time and Date"
.IX Subsection "Time and Date"
The system's notion of time of day and calendar date is controlled in
widely different ways.  Don't assume the timezone is stored in \f(CW$ENV{TZ}\fR,
and even if it is, don't assume that you can control the timezone through
that variable.  Don't assume anything about the three-letter timezone
abbreviations (for example that \s-1MST\s0 would be the Mountain Standard Time,
it's been known to stand for Moscow Standard Time).  If you need to
use timezones, express them in some unambiguous format like the
exact number of minutes offset from \s-1UTC,\s0 or the \s-1POSIX\s0 timezone
format.
.PP
Don't assume that the epoch starts at 00:00:00, January 1, 1970,
because that is \s-1OS\-\s0 and implementation-specific.  It is better to
store a date in an unambiguous representation.  The \s-1ISO 8601\s0 standard
defines YYYY-MM-DD as the date format, or \s-1YYYY\-MM\-DDTHH:MM:SS
\&\s0(that's a literal \*(L"T\*(R" separating the date from the time).
Please do use the \s-1ISO 8601\s0 instead of making us guess what
date 02/03/04 might be.  \s-1ISO 8601\s0 even sorts nicely as-is.
A text representation (like \*(L"1987\-12\-18\*(R") can be easily converted
into an OS-specific value using a module like Date::Parse.
An array of values, such as those returned by \f(CW\*(C`localtime\*(C'\fR, can be
converted to an OS-specific representation using Time::Local.
.PP
When calculating specific times, such as for tests in time or date modules,
it may be appropriate to calculate an offset for the epoch.
.PP
.Vb 2
\&    require Time::Local;
\&    my $offset = Time::Local::timegm(0, 0, 0, 1, 0, 70);
.Ve
.PP
The value for \f(CW$offset\fR in Unix will be \f(CW0\fR, but in Mac \s-1OS\s0 Classic
will be some large number.  \f(CW$offset\fR can then be added to a Unix time
value to get what should be the proper value on any system.
.SS "Character sets and character encoding"
.IX Subsection "Character sets and character encoding"
Assume very little about character sets.
.PP
Assume nothing about numerical values (\f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`chr\*(C'\fR) of characters.
Do not use explicit code point ranges (like \exHH\-\exHH); use for
example symbolic character classes like \f(CW\*(C`[:print:]\*(C'\fR.
.PP
Do not assume that the alphabetic characters are encoded contiguously
(in the numeric sense).  There may be gaps.
.PP
Do not assume anything about the ordering of the characters.
The lowercase letters may come before or after the uppercase letters;
the lowercase and uppercase may be interlaced so that both \*(L"a\*(R" and \*(L"A\*(R"
come before \*(L"b\*(R"; the accented and other international characters may
be interlaced so that a\*: comes before \*(L"b\*(R".
.SS "Internationalisation"
.IX Subsection "Internationalisation"
If you may assume \s-1POSIX \s0(a rather large assumption), you may read
more about the \s-1POSIX\s0 locale system from perllocale.  The locale
system at least attempts to make things a little bit more portable,
or at least more convenient and native-friendly for non-English
users.  The system affects character sets and encoding, and date
and time formatting\*(--amongst other things.
.PP
If you really want to be international, you should consider Unicode.
See perluniintro and perlunicode for more information.
.PP
If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in
the \*(L"source code\*(R" of your code, to be portable you have to be explicit
about what bytes they are.  Someone might for example be using your
code under a \s-1UTF\-8\s0 locale, in which case random native bytes might be
illegal (\*(L"Malformed \s-1UTF\-8 ...\*(R"\s0)  This means that for example embedding
\&\s-1ISO 8859\-1\s0 bytes beyond 0x7f into your strings might cause trouble
later.  If the bytes are native 8\-bit bytes, you can use the \f(CW\*(C`bytes\*(C'\fR
pragma.  If the bytes are in a string (regular expression being a
curious string), you can often also use the \f(CW\*(C`\exHH\*(C'\fR notation instead
of embedding the bytes as-is.  If you want to write your code in \s-1UTF\-8,\s0
you can use the \f(CW\*(C`utf8\*(C'\fR.
.SS "System Resources"
.IX Subsection "System Resources"
If your code is destined for systems with severely constrained (or
missing!) virtual memory systems then you want to be \fIespecially\fR mindful
of avoiding wasteful constructs such as:
.PP
.Vb 1
\&    my @lines = <$very_large_file>;            # bad
\&
\&    while (<$fh>) {$file .= $_}                # sometimes bad
\&    my $file = join(\*(Aq\*(Aq, <$fh>);                # better
.Ve
.PP
The last two constructs may appear unintuitive to most people.  The
first repeatedly grows a string, whereas the second allocates a
large chunk of memory in one go.  On some systems, the second is
more efficient that the first.
.SS "Security"
.IX Subsection "Security"
Most multi-user platforms provide basic levels of security, usually
implemented at the filesystem level.  Some, however, unfortunately do
not.  Thus the notion of user id, or \*(L"home\*(R" directory,
or even the state of being logged-in, may be unrecognizable on many
platforms.  If you write programs that are security-conscious, it
is usually best to know what type of system you will be running
under so that you can write code explicitly for that platform (or
class of platforms).
.PP
Don't assume the Unix filesystem access semantics: the operating
system or the filesystem may be using some \s-1ACL\s0 systems, which are
richer languages than the usual rwx.  Even if the rwx exist,
their semantics might be different.
.PP
(From security viewpoint testing for permissions before attempting to
do something is silly anyway: if one tries this, there is potential
for race conditions. Someone or something might change the
permissions between the permissions check and the actual operation.
Just try the operation.)
.PP
Don't assume the Unix user and group semantics: especially, don't
expect the \f(CW$<\fR and \f(CW$>\fR (or the \f(CW$(\fR and \f(CW$)\fR) to work
for switching identities (or memberships).
.PP
Don't assume set-uid and set-gid semantics. (And even if you do,
think twice: set-uid and set-gid are a known can of security worms.)
.SS "Style"
.IX Subsection "Style"
For those times when it is necessary to have platform-specific code,
consider keeping the platform-specific code in one place, making porting
to other platforms easier.  Use the Config module and the special
variable \f(CW$^O\fR to differentiate platforms, as described in
\&\*(L"\s-1PLATFORMS\*(R"\s0.
.PP
Be careful in the tests you supply with your module or programs.
Module code may be fully portable, but its tests might not be.  This
often happens when tests spawn off other processes or call external
programs to aid in the testing, or when (as noted above) the tests
assume certain things about the filesystem and paths.  Be careful not
to depend on a specific output style for errors, such as when checking
\&\f(CW$!\fR after a failed system call.  Using \f(CW$!\fR for anything else than
displaying it as output is doubtful (though see the Errno module for
testing reasonably portably for error value). Some platforms expect
a certain output format, and Perl on those platforms may have been
adjusted accordingly.  Most specifically, don't anchor a regex when
testing an error value.
.SH "CPAN Testers"
.IX Header "CPAN Testers"
Modules uploaded to \s-1CPAN\s0 are tested by a variety of volunteers on
different platforms.  These \s-1CPAN\s0 testers are notified by mail of each
new upload, and reply to the list with \s-1PASS, FAIL, NA \s0(not applicable to
this platform), or \s-1UNKNOWN \s0(unknown), along with any relevant notations.
.PP
The purpose of the testing is twofold: one, to help developers fix any
problems in their code that crop up because of lack of testing on other
platforms; two, to provide users with information about whether
a given module works on a given platform.
.PP
Also see:
.IP "\(bu" 4
Mailing list: cpan\-testers\-discuss@perl.org
.IP "\(bu" 4
Testing results: <http://www.cpantesters.org/>
.SH "PLATFORMS"
.IX Header "PLATFORMS"
Perl is built with a \f(CW$^O\fR variable that indicates the operating
system it was built on.  This was implemented
to help speed up code that would otherwise have to \f(CW\*(C`use Config\*(C'\fR
and use the value of \f(CW$Config{osname}\fR.  Of course, to get more
detailed information about the system, looking into \f(CW%Config\fR is
certainly recommended.
.PP
\&\f(CW%Config\fR cannot always be trusted, however, because it was built
at compile time.  If perl was built in one place, then transferred
elsewhere, some values may be wrong.  The values may even have been
edited after the fact.
.SS "Unix"
.IX Subsection "Unix"
Perl works on a bewildering variety of Unix and Unix-like platforms (see
e.g. most of the files in the \fIhints/\fR directory in the source code kit).
On most of these systems, the value of \f(CW$^O\fR (hence \f(CW$Config{\*(Aqosname\*(Aq}\fR,
too) is determined either by lowercasing and stripping punctuation from the
first field of the string returned by typing \f(CW\*(C`uname \-a\*(C'\fR (or a similar command)
at the shell prompt or by testing the file system for the presence of
uniquely named files such as a kernel or header file.  Here, for example,
are a few of the more popular Unix flavors:
.PP
.Vb 10
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    AIX           aix        aix
\&    BSD/OS        bsdos      i386\-bsdos
\&    Darwin        darwin     darwin
\&    dgux          dgux       AViiON\-dgux
\&    DYNIX/ptx     dynixptx   i386\-dynixptx
\&    FreeBSD       freebsd    freebsd\-i386    
\&    Haiku         haiku      BePC\-haiku
\&    Linux         linux      arm\-linux
\&    Linux         linux      i386\-linux
\&    Linux         linux      i586\-linux
\&    Linux         linux      ppc\-linux
\&    HP\-UX         hpux       PA\-RISC1.1
\&    IRIX          irix       irix
\&    Mac OS X      darwin     darwin
\&    NeXT 3        next       next\-fat
\&    NeXT 4        next       OPENSTEP\-Mach
\&    openbsd       openbsd    i386\-openbsd
\&    OSF1          dec_osf    alpha\-dec_osf
\&    reliantunix\-n svr4       RM400\-svr4
\&    SCO_SV        sco_sv     i386\-sco_sv
\&    SINIX\-N       svr4       RM400\-svr4
\&    sn4609        unicos     CRAY_C90\-unicos
\&    sn6521        unicosmk   t3e\-unicosmk
\&    sn9617        unicos     CRAY_J90\-unicos
\&    SunOS         solaris    sun4\-solaris
\&    SunOS         solaris    i86pc\-solaris
\&    SunOS4        sunos      sun4\-sunos
.Ve
.PP
Because the value of \f(CW$Config{archname}\fR may depend on the
hardware architecture, it can vary more than the value of \f(CW$^O\fR.
.SS "\s-1DOS\s0 and Derivatives"
.IX Subsection "DOS and Derivatives"
Perl has long been ported to Intel-style microcomputers running under
systems like PC-DOS, MS-DOS, \s-1OS/2,\s0 and most Windows platforms you can
bring yourself to mention (except for Windows \s-1CE,\s0 if you count that).
Users familiar with \fI\s-1COMMAND.COM\s0\fR or \fI\s-1CMD.EXE\s0\fR style shells should
be aware that each of these file specifications may have subtle
differences:
.PP
.Vb 4
\&    my $filespec0 = "c:/foo/bar/file.txt";
\&    my $filespec1 = "c:\e\efoo\e\ebar\e\efile.txt";
\&    my $filespec2 = \*(Aqc:\efoo\ebar\efile.txt\*(Aq;
\&    my $filespec3 = \*(Aqc:\e\efoo\e\ebar\e\efile.txt\*(Aq;
.Ve
.PP
System calls accept either \f(CW\*(C`/\*(C'\fR or \f(CW\*(C`\e\*(C'\fR as the path separator.
However, many command-line utilities of \s-1DOS\s0 vintage treat \f(CW\*(C`/\*(C'\fR as
the option prefix, so may get confused by filenames containing \f(CW\*(C`/\*(C'\fR.
Aside from calling any external programs, \f(CW\*(C`/\*(C'\fR will work just fine,
and probably better, as it is more consistent with popular usage,
and avoids the problem of remembering what to backwhack and what
not to.
.PP
The \s-1DOS FAT\s0 filesystem can accommodate only \*(L"8.3\*(R" style filenames.  Under
the \*(L"case-insensitive, but case-preserving\*(R" \s-1HPFS \s0(\s-1OS/2\s0) and \s-1NTFS \s0(\s-1NT\s0)
filesystems you may have to be careful about case returned with functions
like \f(CW\*(C`readdir\*(C'\fR or used with functions like \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`opendir\*(C'\fR.
.PP
\&\s-1DOS\s0 also treats several filenames as special, such as \s-1AUX, PRN,
NUL, CON, COM1, LPT1, LPT2,\s0 etc.  Unfortunately, sometimes these
filenames won't even work if you include an explicit directory
prefix.  It is best to avoid such filenames, if you want your code
to be portable to \s-1DOS\s0 and its derivatives.  It's hard to know what
these all are, unfortunately.
.PP
Users of these operating systems may also wish to make use of
scripts such as \fIpl2bat.bat\fR or \fIpl2cmd\fR to
put wrappers around your scripts.
.PP
Newline (\f(CW\*(C`\en\*(C'\fR) is translated as \f(CW\*(C`\e015\e012\*(C'\fR by \s-1STDIO\s0 when reading from
and writing to files (see \*(L"Newlines\*(R").  \f(CW\*(C`binmode(FILEHANDLE)\*(C'\fR
will keep \f(CW\*(C`\en\*(C'\fR translated as \f(CW\*(C`\e012\*(C'\fR for that filehandle.  Since it is a
no-op on other systems, \f(CW\*(C`binmode\*(C'\fR should be used for cross-platform code
that deals with binary data.  That's assuming you realize in advance
that your data is in binary.  General-purpose programs should
often assume nothing about their data.
.PP
The \f(CW$^O\fR variable and the \f(CW$Config{archname}\fR values for various
DOSish perls are as follows:
.PP
.Vb 10
\&     OS            $^O      $Config{archname}   ID    Version
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MS\-DOS        dos        ?                 
\&     PC\-DOS        dos        ?                 
\&     OS/2          os2        ?
\&     Windows 3.1   ?          ?                 0      3 01
\&     Windows 95    MSWin32    MSWin32\-x86       1      4 00
\&     Windows 98    MSWin32    MSWin32\-x86       1      4 10
\&     Windows ME    MSWin32    MSWin32\-x86       1      ?
\&     Windows NT    MSWin32    MSWin32\-x86       2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ALPHA     2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ppc       2      4 xx
\&     Windows 2000  MSWin32    MSWin32\-x86       2      5 00
\&     Windows XP    MSWin32    MSWin32\-x86       2      5 01
\&     Windows 2003  MSWin32    MSWin32\-x86       2      5 02
\&     Windows Vista MSWin32    MSWin32\-x86       2      6 00
\&     Windows 7     MSWin32    MSWin32\-x86       2      6 01
\&     Windows 7     MSWin32    MSWin32\-x64       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x86       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x64       2      6 01
\&     Windows CE    MSWin32    ?                 3           
\&     Cygwin        cygwin     cygwin
.Ve
.PP
The various MSWin32 Perl's can distinguish the \s-1OS\s0 they are running on
via the value of the fifth element of the list returned from 
\&\fIWin32::GetOSVersion()\fR.  For example:
.PP
.Vb 4
\&    if ($^O eq \*(AqMSWin32\*(Aq) {
\&        my @os_version_info = Win32::GetOSVersion();
\&        print +(\*(Aq3.1\*(Aq,\*(Aq95\*(Aq,\*(AqNT\*(Aq)[$os_version_info[4]],"\en";
\&    }
.Ve
.PP
There are also \fIWin32::IsWinNT()\fR and \fIWin32::IsWin95()\fR, try \f(CW\*(C`perldoc Win32\*(C'\fR,
and as of libwin32 0.19 (not part of the core Perl distribution)
\&\fIWin32::GetOSName()\fR.  The very portable \fIPOSIX::uname()\fR will work too:
.PP
.Vb 2
\&    c:\e> perl \-MPOSIX \-we "print join \*(Aq|\*(Aq, uname"
\&    Windows NT|moonru|5.0|Build 2195 (Service Pack 2)|x86
.Ve
.PP
Also see:
.IP "\(bu" 4
The djgpp environment for \s-1DOS, \s0<http://www.delorie.com/djgpp/>
and perldos.
.IP "\(bu" 4
The \s-1EMX\s0 environment for \s-1DOS, OS/2,\s0 etc. emx@iaehv.nl,
<ftp://hobbes.nmsu.edu/pub/os2/dev/emx/>  Also perlos2.
.IP "\(bu" 4
Build instructions for Win32 in perlwin32, or under the Cygnus environment
in perlcygwin.
.IP "\(bu" 4
The \f(CW\*(C`Win32::*\*(C'\fR modules in Win32.
.IP "\(bu" 4
The ActiveState Pages, <http://www.activestate.com/>
.IP "\(bu" 4
The Cygwin environment for Win32; \fI\s-1README\s0.cygwin\fR (installed 
as perlcygwin), <http://www.cygwin.com/>
.IP "\(bu" 4
The U/WIN environment for Win32,
<http://www.research.att.com/sw/tools/uwin/>
.IP "\(bu" 4
Build instructions for \s-1OS/2, \s0perlos2
.SS "\s-1VMS\s0"
.IX Subsection "VMS"
Perl on \s-1VMS\s0 is discussed in perlvms in the perl distribution.
.PP
The official name of \s-1VMS\s0 as of this writing is OpenVMS.
.PP
Perl on \s-1VMS\s0 can accept either \s-1VMS\-\s0 or Unix-style file
specifications as in either of the following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" SYS$LOGIN:LOGIN.COM
\&    $ perl \-ne "print if /perl_setup/i" /sys$login/login.com
.Ve
.PP
but not a mixture of both as in:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" sys$login:/login.com
\&    Can\*(Aqt open sys$login:/login.com: file specification syntax error
.Ve
.PP
Interacting with Perl from the Digital Command Language (\s-1DCL\s0) shell
often requires a different set of quotation marks than Unix shells do.
For example:
.PP
.Vb 2
\&    $ perl \-e "print ""Hello, world.\en"""
\&    Hello, world.
.Ve
.PP
There are several ways to wrap your perl scripts in \s-1DCL \s0\fI.COM\fR files, if
you are so inclined.  For example:
.PP
.Vb 6
\&    $ write sys$output "Hello from DCL!"
\&    $ if p1 .eqs. ""
\&    $ then perl \-x \*(Aqf$environment("PROCEDURE")
\&    $ else perl \-x \- \*(Aqp1 \*(Aqp2 \*(Aqp3 \*(Aqp4 \*(Aqp5 \*(Aqp6 \*(Aqp7 \*(Aqp8
\&    $ deck/dollars="_\|_END_\|_"
\&    #!/usr/bin/perl
\&
\&    print "Hello from Perl!\en";
\&
\&    _\|_END_\|_
\&    $ endif
.Ve
.PP
Do take care with \f(CW\*(C`$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT\*(C'\fR if your
perl-in-DCL script expects to do things like \f(CW\*(C`$read = <STDIN>;\*(C'\fR.
.PP
The \s-1VMS\s0 operating system has two filesystems, known as \s-1ODS\-2\s0 and \s-1ODS\-5.\s0
.PP
For \s-1ODS\-2,\s0 filenames are in the format \*(L"name.extension;version\*(R".  The
maximum length for filenames is 39 characters, and the maximum length for
extensions is also 39 characters.  Version is a number from 1 to
32767.  Valid characters are \f(CW\*(C`/[A\-Z0\-9$_\-]/\*(C'\fR.
.PP
The \s-1ODS\-2\s0 filesystem is case-insensitive and does not preserve case.
Perl simulates this by converting all filenames to lowercase internally.
.PP
For \s-1ODS\-5,\s0 filenames may have almost any character in them and can include
Unicode characters.  Characters that could be misinterpreted by the \s-1DCL\s0
shell or file parsing utilities need to be prefixed with the \f(CW\*(C`^\*(C'\fR
character, or replaced with hexadecimal characters prefixed with the
\&\f(CW\*(C`^\*(C'\fR character.  Such prefixing is only needed with the pathnames are
in \s-1VMS\s0 format in applications.  Programs that can accept the Unix format
of pathnames do not need the escape characters.  The maximum length for
filenames is 255 characters.  The \s-1ODS\-5\s0 file system can handle both
a case preserved and a case sensitive mode.
.PP
\&\s-1ODS\-5\s0 is only available on the OpenVMS for 64 bit platforms.
.PP
Support for the extended file specifications is being done as optional
settings to preserve backward compatibility with Perl scripts that
assume the previous \s-1VMS\s0 limitations.
.PP
In general routines on \s-1VMS\s0 that get a Unix format file specification
should return it in a Unix format, and when they get a \s-1VMS\s0 format
specification they should return a \s-1VMS\s0 format unless they are documented
to do a conversion.
.PP
For routines that generate return a file specification, \s-1VMS\s0 allows setting
if the C library which Perl is built on if it will be returned in \s-1VMS\s0
format or in Unix format.
.PP
With the \s-1ODS\-2\s0 file system, there is not much difference in syntax of
filenames without paths for \s-1VMS\s0 or Unix.  With the extended character
set available with \s-1ODS\-5\s0 there can be a significant difference.
.PP
Because of this, existing Perl scripts written for \s-1VMS\s0 were sometimes
treating \s-1VMS\s0 and Unix filenames interchangeably.  Without the extended
character set enabled, this behavior will mostly be maintained for
backwards compatibility.
.PP
When extended characters are enabled with \s-1ODS\-5,\s0 the handling of
Unix formatted file specifications is to that of a Unix system.
.PP
\&\s-1VMS\s0 file specifications without extensions have a trailing dot.  An
equivalent Unix file specification should not show the trailing dot.
.PP
The result of all of this, is that for \s-1VMS,\s0 for portable scripts, you
can not depend on Perl to present the filenames in lowercase, to be
case sensitive, and that the filenames could be returned in either
Unix or \s-1VMS\s0 format.
.PP
And if a routine returns a file specification, unless it is intended to
convert it, it should return it in the same format as it found it.
.PP
\&\f(CW\*(C`readdir\*(C'\fR by default has traditionally returned lowercased filenames.
When the \s-1ODS\-5\s0 support is enabled, it will return the exact case of the
filename on the disk.
.PP
Files without extensions have a trailing period on them, so doing a
\&\f(CW\*(C`readdir\*(C'\fR in the default mode with a file named \fIA.;5\fR will
return \fIa.\fR when \s-1VMS\s0 is (though that file could be opened with
\&\f(CW\*(C`open(FH, \*(AqA\*(Aq)\*(C'\fR).
.PP
With support for extended file specifications and if \f(CW\*(C`opendir\*(C'\fR was
given a Unix format directory, a file named \fIA.;5\fR will return \fIa\fR
and optionally in the exact case on the disk.  When \f(CW\*(C`opendir\*(C'\fR is given
a \s-1VMS\s0 format directory, then \f(CW\*(C`readdir\*(C'\fR should return \fIa.\fR, and
again with the optionally the exact case.
.PP
\&\s-1RMS\s0 had an eight level limit on directory depths from any rooted logical
(allowing 16 levels overall) prior to \s-1VMS 7.2,\s0 and even with versions of
\&\s-1VMS\s0 on \s-1VAX\s0 up through 7.3.  Hence \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8]\*(C'\fR is a
valid directory specification but \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8.9]\*(C'\fR is
not.  \fIMakefile.PL\fR authors might have to take this into account, but at
least they can refer to the former as \f(CW\*(C`/PERL_ROOT/lib/2/3/4/5/6/7/8/\*(C'\fR.
.PP
Pumpkings and module integrators can easily see whether files with too many
directory levels have snuck into the core by running the following in the
top-level source directory:
.PP
.Vb 1
\& $ perl \-ne "$_=~s/\es+.*//; print if scalar(split /\e//) > 8;" < MANIFEST
.Ve
.PP
The VMS::Filespec module, which gets installed as part of the build
process on \s-1VMS,\s0 is a pure Perl module that can easily be installed on
non-VMS platforms and can be helpful for conversions to and from \s-1RMS\s0
native formats.  It is also now the only way that you should check to
see if \s-1VMS\s0 is in a case sensitive mode.
.PP
What \f(CW\*(C`\en\*(C'\fR represents depends on the type of file opened.  It usually
represents \f(CW\*(C`\e012\*(C'\fR but it could also be \f(CW\*(C`\e015\*(C'\fR, \f(CW\*(C`\e012\*(C'\fR, \f(CW\*(C`\e015\e012\*(C'\fR, 
\&\f(CW\*(C`\e000\*(C'\fR, \f(CW\*(C`\e040\*(C'\fR, or nothing depending on the file organization and 
record format.  The VMS::Stdio module provides access to the 
special \fIfopen()\fR requirements of files with unusual attributes on \s-1VMS.\s0
.PP
\&\s-1TCP/IP\s0 stacks are optional on \s-1VMS,\s0 so socket routines might not be
implemented.  \s-1UDP\s0 sockets may not be supported.
.PP
The \s-1TCP/IP\s0 library support for all current versions of \s-1VMS\s0 is dynamically
loaded if present, so even if the routines are configured, they may
return a status indicating that they are not implemented.
.PP
The value of \f(CW$^O\fR on OpenVMS is \*(L"\s-1VMS\*(R". \s0 To determine the architecture
that you are running on without resorting to loading all of \f(CW%Config\fR
you can examine the content of the \f(CW@INC\fR array like so:
.PP
.Vb 2
\&    if (grep(/VMS_AXP/, @INC)) {
\&        print "I\*(Aqm on Alpha!\en";
\&
\&    } elsif (grep(/VMS_VAX/, @INC)) {
\&        print "I\*(Aqm on VAX!\en";
\&
\&    } elsif (grep(/VMS_IA64/, @INC)) {
\&        print "I\*(Aqm on IA64!\en";
\&
\&    } else {
\&        print "I\*(Aqm not so sure about where $^O is...\en";
\&    }
.Ve
.PP
In general, the significant differences should only be if Perl is running
on \s-1VMS_VAX\s0 or one of the 64 bit OpenVMS platforms.
.PP
On \s-1VMS,\s0 perl determines the \s-1UTC\s0 offset from the \f(CW\*(C`SYS$TIMEZONE_DIFFERENTIAL\*(C'\fR
logical name.  Although the \s-1VMS\s0 epoch began at 17\-NOV\-1858 00:00:00.00,
calls to \f(CW\*(C`localtime\*(C'\fR are adjusted to count offsets from
01\-JAN\-1970 00:00:00.00, just like Unix.
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vms\fR (installed as \fIREADME_vms\fR), perlvms
.IP "\(bu" 4
vmsperl list, vmsperl\-subscribe@perl.org
.IP "\(bu" 4
vmsperl on the web, <http://www.sidhe.org/vmsperl/index.html>
.SS "\s-1VOS\s0"
.IX Subsection "VOS"
Perl on \s-1VOS \s0(also known as OpenVOS) is discussed in \fI\s-1README\s0.vos\fR
in the perl distribution (installed as perlvos).  Perl on \s-1VOS\s0
can accept either \s-1VOS\-\s0 or Unix-style file specifications as in
either of the following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" >system>notices
\&    $ perl \-ne "print if /perl_setup/i" /system/notices
.Ve
.PP
or even a mixture of both as in:
.PP
.Vb 1
\&    $ perl \-ne "print if /perl_setup/i" >system/notices
.Ve
.PP
Even though \s-1VOS\s0 allows the slash character to appear in object
names, because the \s-1VOS\s0 port of Perl interprets it as a pathname
delimiting character, \s-1VOS\s0 files, directories, or links whose
names contain a slash character cannot be processed.  Such files
must be renamed before they can be processed by Perl.
.PP
Older releases of \s-1VOS \s0(prior to OpenVOS Release 17.0) limit file
names to 32 or fewer characters, prohibit file names from
starting with a \f(CW\*(C`\-\*(C'\fR character, and prohibit file names from
containing any character matching \f(CW\*(C`tr/ !#%&\*(Aq()*;<=>?//\*(C'\fR.
.PP
Newer releases of \s-1VOS \s0(OpenVOS Release 17.0 or later) support a
feature known as extended names.  On these releases, file names
can contain up to 255 characters, are prohibited from starting
with a \f(CW\*(C`\-\*(C'\fR character, and the set of prohibited characters is
reduced to any character matching \f(CW\*(C`tr/#%*<>?//\*(C'\fR.  There are
restrictions involving spaces and apostrophes:  these characters
must not begin or end a name, nor can they immediately precede or
follow a period.  Additionally, a space must not immediately
precede another space or hyphen.  Specifically, the following
character combinations are prohibited:  space-space,
space-hyphen, period-space, space-period, period-apostrophe,
apostrophe-period, leading or trailing space, and leading or
trailing apostrophe.  Although an extended file name is limited
to 255 characters, a path name is still limited to 256
characters.
.PP
The value of \f(CW$^O\fR on \s-1VOS\s0 is \*(L"vos\*(R".  To determine the
architecture that you are running on without resorting to loading
all of \f(CW%Config\fR you can examine the content of the \f(CW@INC\fR array
like so:
.PP
.Vb 6
\&    if ($^O =~ /vos/) {
\&        print "I\*(Aqm on a Stratus box!\en";
\&    } else {
\&        print "I\*(Aqm not on a Stratus box!\en";
\&        die;
\&    }
.Ve
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vos\fR (installed as perlvos)
.IP "\(bu" 4
The \s-1VOS\s0 mailing list.
.Sp
There is no specific mailing list for Perl on \s-1VOS. \s0 You can contact
the Stratus Technologies Customer Assistance Center (\s-1CAC\s0) for your
region, or you can use the contact information located in the
distribution files on the Stratus Anonymous \s-1FTP\s0 site.
.IP "\(bu" 4
Stratus Technologies on the web at <http://www.stratus.com>
.IP "\(bu" 4
\&\s-1VOS\s0 Open-Source Software on the web at <http://ftp.stratus.com/pub/vos/vos.html>
.SS "\s-1EBCDIC\s0 Platforms"
.IX Subsection "EBCDIC Platforms"
Recent versions of Perl have been ported to platforms such as \s-1OS/400\s0 on
\&\s-1AS/400\s0 minicomputers as well as \s-1OS/390, VM/ESA,\s0 and \s-1BS2000\s0 for S/390
Mainframes.  Such computers use \s-1EBCDIC\s0 character sets internally (usually
Character Code Set \s-1ID 0037\s0 for \s-1OS/400\s0 and either 1047 or POSIX-BC for S/390
systems).  On the mainframe perl currently works under the \*(L"Unix system
services for \s-1OS/390\*(R" \s0(formerly known as OpenEdition), \s-1VM/ESA\s0 OpenEdition, or
the \s-1BS200\s0 POSIX-BC system (\s-1BS2000\s0 is supported in perl 5.6 and greater).
See perlos390 for details.  Note that for \s-1OS/400\s0 there is also a port of
Perl 5.8.1/5.10.0 or later to the \s-1PASE\s0 which is ASCII-based (as opposed to
\&\s-1ILE\s0 which is EBCDIC-based), see perlos400.
.PP
As of R2.5 of \s-1USS\s0 for \s-1OS/390\s0 and Version 2.3 of \s-1VM/ESA\s0 these Unix
sub-systems do not support the \f(CW\*(C`#!\*(C'\fR shebang trick for script invocation.
Hence, on \s-1OS/390\s0 and \s-1VM/ESA\s0 perl scripts can be executed with a header
similar to the following simple script:
.PP
.Vb 4
\&    : # use perl
\&        eval \*(Aqexec /usr/local/bin/perl \-S $0 ${1+"$@"}\*(Aq
\&            if 0;
\&    #!/usr/local/bin/perl     # just a comment really
\&
\&    print "Hello from perl!\en";
.Ve
.PP
\&\s-1OS/390\s0 will support the \f(CW\*(C`#!\*(C'\fR shebang trick in release 2.8 and beyond.
Calls to \f(CW\*(C`system\*(C'\fR and backticks can use \s-1POSIX\s0 shell syntax on all
S/390 systems.
.PP
On the \s-1AS/400,\s0 if \s-1PERL5\s0 is in your library list, you may need
to wrap your perl scripts in a \s-1CL\s0 procedure to invoke them like so:
.PP
.Vb 3
\&    BEGIN
\&      CALL PGM(PERL5/PERL) PARM(\*(Aq/QOpenSys/hello.pl\*(Aq)
\&    ENDPGM
.Ve
.PP
This will invoke the perl script \fIhello.pl\fR in the root of the
QOpenSys file system.  On the \s-1AS/400\s0 calls to \f(CW\*(C`system\*(C'\fR or backticks
must use \s-1CL\s0 syntax.
.PP
On these platforms, bear in mind that the \s-1EBCDIC\s0 character set may have
an effect on what happens with some perl functions (such as \f(CW\*(C`chr\*(C'\fR,
\&\f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR), as
well as bit-fiddling with \s-1ASCII\s0 constants using operators like \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`&\*(C'\fR
and \f(CW\*(C`|\*(C'\fR, not to mention dealing with socket interfaces to \s-1ASCII\s0 computers
(see \*(L"Newlines\*(R").
.PP
Fortunately, most web servers for the mainframe will correctly
translate the \f(CW\*(C`\en\*(C'\fR in the following statement to its \s-1ASCII\s0 equivalent
(\f(CW\*(C`\er\*(C'\fR is the same under both Unix and \s-1OS/390\s0):
.PP
.Vb 1
\&    print "Content\-type: text/html\er\en\er\en";
.Ve
.PP
The values of \f(CW$^O\fR on some of these platforms includes:
.PP
.Vb 5
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    OS/390        os390      os390
\&    OS400         os400      os400
\&    POSIX\-BC      posix\-bc   BS2000\-posix\-bc
.Ve
.PP
Some simple tricks for determining if you are running on an \s-1EBCDIC\s0
platform could include any of the following (perhaps all):
.PP
.Vb 1
\&    if ("\et" eq "\e005")   { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (ord(\*(AqA\*(Aq) == 193) { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (chr(169) eq \*(Aqz\*(Aq) { print "EBCDIC may be spoken here!\en"; }
.Ve
.PP
One thing you may not want to rely on is the \s-1EBCDIC\s0 encoding
of punctuation characters since these may differ from code page to code
page (and once your module or script is rumoured to work with \s-1EBCDIC,\s0
folks will want it to work with all \s-1EBCDIC\s0 character sets).
.PP
Also see:
.IP "\(bu" 4
perlos390, \fI\s-1README\s0.os390\fR, \fIperlbs2000\fR, perlebcdic.
.IP "\(bu" 4
The perl\-mvs@perl.org list is for discussion of porting issues as well as
general usage issues for all \s-1EBCDIC\s0 Perls.  Send a message body of
\&\*(L"subscribe perl-mvs\*(R" to majordomo@perl.org.
.IP "\(bu" 4
\&\s-1AS/400\s0 Perl information at
<http://as400.rochester.ibm.com/>
as well as on \s-1CPAN\s0 in the \fIports/\fR directory.
.SS "Acorn \s-1RISC OS\s0"
.IX Subsection "Acorn RISC OS"
Because Acorns use \s-1ASCII\s0 with newlines (\f(CW\*(C`\en\*(C'\fR) in text files as \f(CW\*(C`\e012\*(C'\fR like
Unix, and because Unix filename emulation is turned on by default, 
most simple scripts will probably work \*(L"out of the box\*(R".  The native
filesystem is modular, and individual filesystems are free to be
case-sensitive or insensitive, and are usually case-preserving.  Some
native filesystems have name length limits, which file and directory
names are silently truncated to fit.  Scripts should be aware that the
standard filesystem currently has a name length limit of \fB10\fR
characters, with up to 77 items in a directory, but other filesystems
may not impose such limitations.
.PP
Native filenames are of the form
.PP
.Vb 1
\&    Filesystem#Special_Field::DiskName.$.Directory.Directory.File
.Ve
.PP
where
.PP
.Vb 8
\&    Special_Field is not usually present, but may contain . and $ .
\&    Filesystem =~ m|[A\-Za\-z0\-9_]|
\&    DsicName   =~ m|[A\-Za\-z0\-9_/]|
\&    $ represents the root directory
\&    . is the path separator
\&    @ is the current directory (per filesystem but machine global)
\&    ^ is the parent directory
\&    Directory and File =~ m|[^\e0\- "\e.\e$\e%\e&:\e@\e\e^\e|\e177]+|
.Ve
.PP
The default filename translation is roughly \f(CW\*(C`tr|/.|./|;\*(C'\fR
.PP
Note that \f(CW\*(C`"ADFS::HardDisk.$.File" ne \*(AqADFS::HardDisk.$.File\*(Aq\*(C'\fR and that
the second stage of \f(CW\*(C`$\*(C'\fR interpolation in regular expressions will fall
foul of the \f(CW$.\fR if scripts are not careful.
.PP
Logical paths specified by system variables containing comma-separated
search lists are also allowed; hence \f(CW\*(C`System:Modules\*(C'\fR is a valid
filename, and the filesystem will prefix \f(CW\*(C`Modules\*(C'\fR with each section of
\&\f(CW\*(C`System$Path\*(C'\fR until a name is made that points to an object on disk.
Writing to a new file \f(CW\*(C`System:Modules\*(C'\fR would be allowed only if
\&\f(CW\*(C`System$Path\*(C'\fR contains a single item list.  The filesystem will also
expand system variables in filenames if enclosed in angle brackets, so
\&\f(CW\*(C`<System$Dir>.Modules\*(C'\fR would look for the file
\&\f(CW\*(C`$ENV{\*(AqSystem$Dir\*(Aq}\ .\ \*(AqModules\*(Aq\*(C'\fR.  The obvious implication of this is
that \fBfully qualified filenames can start with \f(CB\*(C`<>\*(C'\fB\fR and should
be protected when \f(CW\*(C`open\*(C'\fR is used for input.
.PP
Because \f(CW\*(C`.\*(C'\fR was in use as a directory separator and filenames could not
be assumed to be unique after 10 characters, Acorn implemented the C
compiler to strip the trailing \f(CW\*(C`.c\*(C'\fR \f(CW\*(C`.h\*(C'\fR \f(CW\*(C`.s\*(C'\fR and \f(CW\*(C`.o\*(C'\fR suffix from
filenames specified in source code and store the respective files in
subdirectories named after the suffix.  Hence files are translated:
.PP
.Vb 6
\&    foo.h           h.foo
\&    C:foo.h         C:h.foo        (logical path variable)
\&    sys/os.h        sys.h.os       (C compiler groks Unix\-speak)
\&    10charname.c    c.10charname
\&    10charname.o    o.10charname
\&    11charname_.c   c.11charname   (assuming filesystem truncates at 10)
.Ve
.PP
The Unix emulation library's translation of filenames to native assumes
that this sort of translation is required, and it allows a user-defined list
of known suffixes that it will transpose in this fashion.  This may
seem transparent, but consider that with these rules \fIfoo/bar/baz.h\fR
and \fIfoo/bar/h/baz\fR both map to \fIfoo.bar.h.baz\fR, and that \f(CW\*(C`readdir\*(C'\fR and
\&\f(CW\*(C`glob\*(C'\fR cannot and do not attempt to emulate the reverse mapping.  Other
\&\f(CW\*(C`.\*(C'\fR's in filenames are translated to \f(CW\*(C`/\*(C'\fR.
.PP
As implied above, the environment accessed through \f(CW%ENV\fR is global, and
the convention is that program specific environment variables are of the
form \f(CW\*(C`Program$Name\*(C'\fR.  Each filesystem maintains a current directory,
and the current filesystem's current directory is the \fBglobal\fR current
directory.  Consequently, sociable programs don't change the current
directory but rely on full pathnames, and programs (and Makefiles) cannot
assume that they can spawn a child process which can change the current
directory without affecting its parent (and everyone else for that
matter).
.PP
Because native operating system filehandles are global and are currently 
allocated down from 255, with 0 being a reserved value, the Unix emulation
library emulates Unix filehandles.  Consequently, you can't rely on
passing \f(CW\*(C`STDIN\*(C'\fR, \f(CW\*(C`STDOUT\*(C'\fR, or \f(CW\*(C`STDERR\*(C'\fR to your children.
.PP
The desire of users to express filenames of the form
\&\f(CW\*(C`<Foo$Dir>.Bar\*(C'\fR on the command line unquoted causes problems,
too: \f(CW\*(C`\`\`\*(C'\fR command output capture has to perform a guessing game.  It
assumes that a string \f(CW\*(C`<[^<>]+\e$[^<>]>\*(C'\fR is a
reference to an environment variable, whereas anything else involving
\&\f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR is redirection, and generally manages to be 99%
right.  Of course, the problem remains that scripts cannot rely on any
Unix tools being available, or that any tools found have Unix-like command
line arguments.
.PP
Extensions and \s-1XS\s0 are, in theory, buildable by anyone using free
tools.  In practice, many don't, as users of the Acorn platform are
used to binary distributions.  MakeMaker does run, but no available
make currently copes with MakeMaker's makefiles; even if and when
this should be fixed, the lack of a Unix-like shell will cause
problems with makefile rules, especially lines of the form \f(CW\*(C`cd
sdbm && make all\*(C'\fR, and anything using quoting.
.PP
\&\*(L"\s-1RISC\s0\ \s-1OS\*(R"\s0 is the proper name for the operating system, but the value
in \f(CW$^O\fR is \*(L"riscos\*(R" (because we don't like shouting).
.SS "Other perls"
.IX Subsection "Other perls"
Perl has been ported to many platforms that do not fit into any of
the categories listed above.  Some, such as AmigaOS,
\&\s-1QNX,\s0 Plan 9, and \s-1VOS,\s0 have been well-integrated into the standard
Perl source code kit.  You may need to see the \fIports/\fR directory
on \s-1CPAN\s0 for information, and possibly binaries, for the likes of:
aos, Atari \s-1ST,\s0 lynxos, riscos, Novell Netware, Tandem Guardian,
\&\fIetc.\fR  (Yes, we know that some of these OSes may fall under the
Unix category, but we are not a standards body.)
.PP
Some approximate operating system names and their \f(CW$^O\fR values
in the \*(L"\s-1OTHER\*(R"\s0 category include:
.PP
.Vb 3
\&    OS            $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Amiga DOS     amigaos    m68k\-amigos
.Ve
.PP
See also:
.IP "\(bu" 4
Amiga, \fI\s-1README\s0.amiga\fR (installed as perlamiga).
.IP "\(bu" 4
A free perl5\-based \s-1PERL.NLM\s0 for Novell Netware is available in
precompiled binary and source code form from <http://www.novell.com/>
as well as from \s-1CPAN.\s0
.IP "\(bu" 4
Plan\ 9, \fI\s-1README\s0.plan9\fR
.SH "FUNCTION IMPLEMENTATIONS"
.IX Header "FUNCTION IMPLEMENTATIONS"
Listed below are functions that are either completely unimplemented
or else have been implemented differently on various platforms.
Following each description will be, in parentheses, a list of
platforms that the description applies to.
.PP
The list may well be incomplete, or even wrong in some places.  When
in doubt, consult the platform-specific \s-1README\s0 files in the Perl
source distribution, and any other documentation resources accompanying
a given port.
.PP
Be aware, moreover, that even among Unix-ish systems there are variations.
.PP
For many functions, you can also query \f(CW%Config\fR, exported by
default from the Config module.  For example, to check whether the
platform has the \f(CW\*(C`lstat\*(C'\fR call, check \f(CW$Config{d_lstat}\fR.  See
Config for a full description of available variables.
.SS "Alphabetical Listing of Perl Functions"
.IX Subsection "Alphabetical Listing of Perl Functions"
.IP "\-X" 8
.IX Item "-X"
\&\f(CW\*(C`\-w\*(C'\fR only inspects the read-only file attribute (\s-1FILE_ATTRIBUTE_READONLY\s0),
which determines whether the directory can be deleted, not whether it can
be written to. Directories always have read and write access unless denied
by discretionary access control lists (DACLs).  (Win32)
.Sp
\&\f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, and \f(CW\*(C`\-o\*(C'\fR tell whether the file is accessible,
which may not reflect UIC-based file protections.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-s\*(C'\fR by name on an open file will return the space reserved on disk,
rather than the current extent.  \f(CW\*(C`\-s\*(C'\fR on an open filehandle returns the
current size.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR, \f(CW\*(C`\-X\*(C'\fR, \f(CW\*(C`\-O\*(C'\fR are indistinguishable from \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR,
\&\f(CW\*(C`\-x\*(C'\fR, \f(CW\*(C`\-o\*(C'\fR. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-g\*(C'\fR, \f(CW\*(C`\-k\*(C'\fR, \f(CW\*(C`\-l\*(C'\fR, \f(CW\*(C`\-u\*(C'\fR, \f(CW\*(C`\-A\*(C'\fR are not particularly meaningful.
(Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-p\*(C'\fR is not particularly meaningful. (\s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-d\*(C'\fR is true if passed a device spec without an explicit directory.
(\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a file ends in one of the executable
suffixes.  \f(CW\*(C`\-S\*(C'\fR is meaningless.  (Win32)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a file has an executable file type.
(\s-1RISC\s0\ \s-1OS\s0)
.IP "alarm" 8
.IX Item "alarm"
Emulated using timers that must be explicitly polled whenever Perl
wants to dispatch \*(L"safe signals\*(R" and therefore cannot interrupt
blocking system calls.  (Win32)
.IP "atan2" 8
.IX Item "atan2"
Due to issues with various CPUs, math libraries, compilers, and standards,
results for \f(CW\*(C`atan2()\*(C'\fR may vary depending on any combination of the above.
Perl attempts to conform to the Open Group/IEEE standards for the results
returned from \f(CW\*(C`atan2()\*(C'\fR, but cannot force the issue if the system Perl is
run on does not allow it.  (Tru64, HP-UX 10.20)
.Sp
The current version of the standards for \f(CW\*(C`atan2()\*(C'\fR is available at 
<http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html>.
.IP "binmode" 8
.IX Item "binmode"
Meaningless.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Reopens file and restores pointer; if function fails, underlying
filehandle may be closed, or pointer may be in a different position.
(\s-1VMS\s0)
.Sp
The value returned by \f(CW\*(C`tell\*(C'\fR may be affected after the call, and
the filehandle may be flushed. (Win32)
.IP "chmod" 8
.IX Item "chmod"
Only good for changing \*(L"owner\*(R" read-write access, \*(L"group\*(R", and \*(L"other\*(R"
bits are meaningless. (Win32)
.Sp
Only good for changing \*(L"owner\*(R" and \*(L"other\*(R" read-write access. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Access permissions are mapped onto \s-1VOS\s0 access-control list changes. (\s-1VOS\s0)
.Sp
The actual permissions set depend on the value of the \f(CW\*(C`CYGWIN\*(C'\fR
in the \s-1SYSTEM\s0 environment settings.  (Cygwin)
.IP "chown" 8
.IX Item "chown"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Does nothing, but won't fail. (Win32)
.Sp
A little funky, because \s-1VOS\s0's notion of ownership is a little funky (\s-1VOS\s0).
.IP "chroot" 8
.IX Item "chroot"
Not implemented. (Win32, \s-1VMS,\s0 Plan\ 9, \s-1RISC\s0\ \s-1OS, VOS\s0)
.IP "crypt" 8
.IX Item "crypt"
May not be available if library or source was not provided when building
perl. (Win32)
.IP "dbmclose" 8
.IX Item "dbmclose"
Not implemented. (\s-1VMS,\s0 Plan\ 9, \s-1VOS\s0)
.IP "dbmopen" 8
.IX Item "dbmopen"
Not implemented. (\s-1VMS,\s0 Plan\ 9, \s-1VOS\s0)
.IP "dump" 8
.IX Item "dump"
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Not supported. (Cygwin, Win32)
.Sp
Invokes \s-1VMS\s0 debugger. (\s-1VMS\s0)
.IP "exec" 8
.IX Item "exec"
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
Not supported. (Symbian \s-1OS\s0)
.IP "exit" 8
.IX Item "exit"
Emulates Unix \fIexit()\fR (which considers \f(CW\*(C`exit 1\*(C'\fR to indicate an error) by
mapping the \f(CW1\fR to \s-1SS$_ABORT \s0(\f(CW44\fR).  This behavior may be overridden
with the pragma \f(CW\*(C`use vmsish \*(Aqexit\*(Aq\*(C'\fR.  As with the \s-1CRTL\s0's \fIexit()\fR
function, \f(CW\*(C`exit 0\*(C'\fR is also mapped to an exit status of \s-1SS$_NORMAL
\&\s0(\f(CW1\fR); this mapping cannot be overridden.  Any other argument to \fIexit()\fR
is used directly as Perl's exit status.  On \s-1VMS,\s0 unless the future
\&\s-1POSIX_EXIT\s0 mode is enabled, the exit code should always be a valid
\&\s-1VMS\s0 exit code and not a generic number.  When the \s-1POSIX_EXIT\s0 mode is
enabled, a generic number will be encoded in a method compatible with
the C library _POSIX_EXIT macro so that it can be decoded by other
programs, particularly ones written in C, like the \s-1GNV\s0 package.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`exit()\*(C'\fR resets file pointers, which is a problem when called 
from a child process (created by \f(CW\*(C`fork()\*(C'\fR) in \f(CW\*(C`BEGIN\*(C'\fR.  
A workaround is to use \f(CW\*(C`POSIX::_exit\*(C'\fR.  (Solaris)
.Sp
.Vb 2
\&    exit unless $Config{archname} =~ /\ebsolaris\eb/;
\&    require POSIX and POSIX::_exit(0);
.Ve
.IP "fcntl" 8
.IX Item "fcntl"
Not implemented. (Win32)
.Sp
Some functions available based on the version of \s-1VMS. \s0(\s-1VMS\s0)
.IP "flock" 8
.IX Item "flock"
Not implemented (\s-1VMS, RISC\s0\ \s-1OS, VOS\s0).
.IP "fork" 8
.IX Item "fork"
Not implemented. (AmigaOS, \s-1RISC\s0\ \s-1OS, VMS\s0)
.Sp
Emulated using multiple interpreters.  See perlfork.  (Win32)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.IP "getlogin" 8
.IX Item "getlogin"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getpgrp" 8
.IX Item "getpgrp"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getppid" 8
.IX Item "getppid"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "getpriority" 8
.IX Item "getpriority"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "getpwnam" 8
.IX Item "getpwnam"
Not implemented. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrnam" 8
.IX Item "getgrnam"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getnetbyname" 8
.IX Item "getnetbyname"
Not implemented. (Win32, Plan\ 9)
.IP "getpwuid" 8
.IX Item "getpwuid"
Not implemented. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrgid" 8
.IX Item "getgrgid"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getnetbyaddr" 8
.IX Item "getnetbyaddr"
Not implemented. (Win32, Plan\ 9)
.IP "getprotobynumber" 8
.IX Item "getprotobynumber"
.PD 0
.IP "getservbyport" 8
.IX Item "getservbyport"
.IP "getpwent" 8
.IX Item "getpwent"
.PD
Not implemented. (Win32)
.IP "getgrent" 8
.IX Item "getgrent"
Not implemented. (Win32, \s-1VMS\s0)
.IP "gethostbyname" 8
.IX Item "gethostbyname"
\&\f(CW\*(C`gethostbyname(\*(Aqlocalhost\*(Aq)\*(C'\fR does not work everywhere: you may have
to use \f(CW\*(C`gethostbyname(\*(Aq127.0.0.1\*(Aq)\*(C'\fR. (Irix\ 5)
.IP "gethostent" 8
.IX Item "gethostent"
Not implemented. (Win32)
.IP "getnetent" 8
.IX Item "getnetent"
Not implemented. (Win32, Plan\ 9)
.IP "getprotoent" 8
.IX Item "getprotoent"
Not implemented. (Win32, Plan\ 9)
.IP "getservent" 8
.IX Item "getservent"
Not implemented. (Win32, Plan\ 9)
.IP "sethostent" 8
.IX Item "sethostent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setnetent" 8
.IX Item "setnetent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setprotoent" 8
.IX Item "setprotoent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setservent" 8
.IX Item "setservent"
Not implemented. (Plan\ 9, Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "endpwent" 8
.IX Item "endpwent"
Not implemented. (Win32)
.IP "endgrent" 8
.IX Item "endgrent"
Not implemented. (\s-1RISC\s0\ \s-1OS, VMS,\s0 Win32)
.IP "endhostent" 8
.IX Item "endhostent"
Not implemented. (Win32)
.IP "endnetent" 8
.IX Item "endnetent"
Not implemented. (Win32, Plan\ 9)
.IP "endprotoent" 8
.IX Item "endprotoent"
Not implemented. (Win32, Plan\ 9)
.IP "endservent" 8
.IX Item "endservent"
Not implemented. (Plan\ 9, Win32)
.IP "getsockopt \s-1SOCKET,LEVEL,OPTNAME\s0" 8
.IX Item "getsockopt SOCKET,LEVEL,OPTNAME"
Not implemented. (Plan\ 9)
.IP "glob" 8
.IX Item "glob"
This operator is implemented via the File::Glob extension on most
platforms.  See File::Glob for portability information.
.IP "gmtime" 8
.IX Item "gmtime"
In theory, \fIgmtime()\fR is reliable from \-2**63 to 2**63\-1.  However,
because work arounds in the implementation use floating point numbers,
it will become inaccurate as the time gets larger.  This is a bug and
will be fixed in the future.
.Sp
On \s-1VOS,\s0 time values are 32\-bit quantities.
.IP "ioctl \s-1FILEHANDLE,FUNCTION,SCALAR\s0" 8
.IX Item "ioctl FILEHANDLE,FUNCTION,SCALAR"
Not implemented. (\s-1VMS\s0)
.Sp
Available only for socket handles, and it does what the \fIioctlsocket()\fR call
in the Winsock \s-1API\s0 does. (Win32)
.Sp
Available only for socket handles. (\s-1RISC\s0\ \s-1OS\s0)
.IP "kill" 8
.IX Item "kill"
Not implemented, hence not useful for taint checking. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`kill()\*(C'\fR doesn't have the semantics of \f(CW\*(C`raise()\*(C'\fR, i.e. it doesn't send
a signal to the identified process like it does on Unix platforms.
Instead \f(CW\*(C`kill($sig, $pid)\*(C'\fR terminates the process identified by \f(CW$pid\fR,
and makes it exit immediately with exit status \f(CW$sig\fR.  As in Unix, if
\&\f(CW$sig\fR is 0 and the specified process exists, it returns true without
actually terminating it. (Win32)
.Sp
\&\f(CW\*(C`kill(\-9, $pid)\*(C'\fR will terminate the process specified by \f(CW$pid\fR and
recursively all child processes owned by it.  This is different from
the Unix semantics, where the signal will be delivered to all
processes in the same process group as the process specified by
\&\f(CW$pid\fR. (Win32)
.Sp
Is not supported for process identification number of 0 or negative
numbers. (\s-1VMS\s0)
.IP "link" 8
.IX Item "link"
Not implemented. (\s-1RISC\s0\ \s-1OS, VOS\s0)
.Sp
Link count not updated because hard links are not quite that hard
(They are sort of half-way between hard and soft links). (AmigaOS)
.Sp
Hard links are implemented on Win32 under \s-1NTFS\s0 only. They are
natively supported on Windows 2000 and later.  On Windows \s-1NT\s0 they
are implemented using the Windows \s-1POSIX\s0 subsystem support and the
Perl process will need Administrator or Backup Operator privileges
to create hard links.
.Sp
Available on 64 bit OpenVMS 8.2 and later.  (\s-1VMS\s0)
.IP "localtime" 8
.IX Item "localtime"
\&\fIlocaltime()\fR has the same range as \*(L"gmtime\*(R", but because time zone
rules change its accuracy for historical and future times may degrade
but usually by no more than an hour.
.IP "lstat" 8
.IX Item "lstat"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Return values (especially for device and inode) may be bogus. (Win32)
.IP "msgctl" 8
.IX Item "msgctl"
.PD 0
.IP "msgget" 8
.IX Item "msgget"
.IP "msgsnd" 8
.IX Item "msgsnd"
.IP "msgrcv" 8
.IX Item "msgrcv"
.PD
Not implemented. (Win32, \s-1VMS,\s0 Plan\ 9, \s-1RISC\s0\ \s-1OS, VOS\s0)
.IP "open" 8
.IX Item "open"
open to \f(CW\*(C`|\-\*(C'\fR and \f(CW\*(C`\-|\*(C'\fR are unsupported. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Opening a process does not automatically flush output handles on some
platforms.  (SunOS, Solaris, HP-UX)
.IP "readlink" 8
.IX Item "readlink"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "rename" 8
.IX Item "rename"
Can't move directories between directories on different logical volumes. (Win32)
.IP "rewinddir" 8
.IX Item "rewinddir"
Will not cause \fIreaddir()\fR to re-read the directory stream.  The entries
already read before the \fIrewinddir()\fR call will just be returned again
from a cache buffer. (Win32)
.IP "select" 8
.IX Item "select"
Only implemented on sockets. (Win32, \s-1VMS\s0)
.Sp
Only reliable on sockets. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Note that the \f(CW\*(C`select FILEHANDLE\*(C'\fR form is generally portable.
.IP "semctl" 8
.IX Item "semctl"
.PD 0
.IP "semget" 8
.IX Item "semget"
.IP "semop" 8
.IX Item "semop"
.PD
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "setgrent" 8
.IX Item "setgrent"
Not implemented. (\s-1VMS,\s0 Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setpgrp" 8
.IX Item "setpgrp"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "setpriority" 8
.IX Item "setpriority"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "setpwent" 8
.IX Item "setpwent"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setsockopt" 8
.IX Item "setsockopt"
Not implemented. (Plan\ 9)
.IP "shmctl" 8
.IX Item "shmctl"
.PD 0
.IP "shmget" 8
.IX Item "shmget"
.IP "shmread" 8
.IX Item "shmread"
.IP "shmwrite" 8
.IX Item "shmwrite"
.PD
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "sleep" 8
.IX Item "sleep"
Emulated using synchronization functions such that it can be
interrupted by \fIalarm()\fR, and limited to a maximum of 4294967 seconds,
approximately 49 days. (Win32)
.IP "sockatmark" 8
.IX Item "sockatmark"
A relatively recent addition to socket functions, may not
be implemented even in Unix platforms.
.IP "socketpair" 8
.IX Item "socketpair"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Available on 64 bit OpenVMS 8.2 and later.  (\s-1VMS\s0)
.IP "stat" 8
.IX Item "stat"
Platforms that do not have rdev, blksize, or blocks will return these
as '', so numeric comparison or manipulation of these fields may cause
\&'not numeric' warnings.
.Sp
ctime not supported on \s-1UFS \s0(Mac\ \s-1OS\s0\ X).
.Sp
ctime is creation time instead of inode change time  (Win32).
.Sp
device and inode are not meaningful.  (Win32)
.Sp
device and inode are not necessarily reliable.  (\s-1VMS\s0)
.Sp
mtime, atime and ctime all return the last modification time.  Device and
inode are not necessarily reliable.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
dev, rdev, blksize, and blocks are not available.  inode is not
meaningful and will differ between stat calls on the same file.  (os2)
.Sp
some versions of cygwin when doing a stat(\*(L"foo\*(R") and if not finding it
may then attempt to stat(\*(L"foo.exe\*(R") (Cygwin)
.Sp
On Win32 \fIstat()\fR needs to open the file to determine the link count
and update attributes that may have been changed through hard links.
Setting ${^WIN32_SLOPPY_STAT} to a true value speeds up \fIstat()\fR by
not performing this operation. (Win32)
.IP "symlink" 8
.IX Item "symlink"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Implemented on 64 bit \s-1VMS 8.3.  VMS\s0 requires the symbolic link to be in Unix
syntax if it is intended to resolve to a valid path.
.IP "syscall" 8
.IX Item "syscall"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "sysopen" 8
.IX Item "sysopen"
The traditional \*(L"0\*(R", \*(L"1\*(R", and \*(L"2\*(R" MODEs are implemented with different
numeric values on some systems.  The flags exported by \f(CW\*(C`Fcntl\*(C'\fR
(O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though.  (Mac\ \s-1OS, OS/390\s0)
.IP "system" 8
.IX Item "system"
As an optimization, may not call the command shell specified in
\&\f(CW$ENV{PERL5SHELL}\fR.  \f(CW\*(C`system(1, @args)\*(C'\fR spawns an external
process and immediately returns its process designator, without
waiting for it to terminate.  Return value may be used subsequently
in \f(CW\*(C`wait\*(C'\fR or \f(CW\*(C`waitpid\*(C'\fR.  Failure to \fIspawn()\fR a subprocess is indicated
by setting $? to \*(L"255 << 8\*(R".  \f(CW$?\fR is set in a way compatible with
Unix (i.e. the exitstatus of the subprocess is obtained by \*(L"$? >> 8\*(R",
as described in the documentation).  (Win32)
.Sp
There is no shell to process metacharacters, and the native standard is
to pass a command line terminated by \*(L"\en\*(R" \*(L"\er\*(R" or \*(L"\e0\*(R" to the spawned
program.  Redirection such as \f(CW\*(C`> foo\*(C'\fR is performed (if at all) by
the run time library of the spawned program.  \f(CW\*(C`system\*(C'\fR \fIlist\fR will call
the Unix emulation library's \f(CW\*(C`exec\*(C'\fR emulation, which attempts to provide
emulation of the stdin, stdout, stderr in force in the parent, providing
the child program uses a compatible version of the emulation library.
\&\fIscalar\fR will call the native command line direct and no such emulation
of a child Unix program will exists.  Mileage \fBwill\fR vary.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
The return value is POSIX-like (shifted up by 8 bits), which only allows
room for a made-up value derived from the severity bits of the native
32\-bit condition code (unless overridden by \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR). 
If the native condition code is one that has a \s-1POSIX\s0 value encoded, the
\&\s-1POSIX\s0 value will be decoded to extract the expected exit value.
For more details see \*(L"$?\*(R" in perlvms. (\s-1VMS\s0)
.IP "times" 8
.IX Item "times"
\&\*(L"cumulative\*(R" times will be bogus.  On anything other than Windows \s-1NT\s0
or Windows 2000, \*(L"system\*(R" time will be bogus, and \*(L"user\*(R" time is
actually the time returned by the \fIclock()\fR function in the C runtime
library. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "truncate" 8
.IX Item "truncate"
Not implemented. (Older versions of \s-1VMS\s0)
.Sp
Truncation to same-or-shorter lengths only. (\s-1VOS\s0)
.Sp
If a \s-1FILEHANDLE\s0 is supplied, it must be writable and opened in append
mode (i.e., use \f(CW\*(C`open(FH, \*(Aq>>filename\*(Aq)\*(C'\fR
or \f(CW\*(C`sysopen(FH,...,O_APPEND|O_RDWR)\*(C'\fR.  If a filename is supplied, it
should not be held open elsewhere. (Win32)
.IP "umask" 8
.IX Item "umask"
Returns undef where unavailable.
.Sp
\&\f(CW\*(C`umask\*(C'\fR works but the correct permissions are set only when the file
is finally closed. (AmigaOS)
.IP "utime" 8
.IX Item "utime"
Only the modification time is updated. (\s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
May not behave as expected.  Behavior depends on the C runtime
library's implementation of \fIutime()\fR, and the filesystem being
used.  The \s-1FAT\s0 filesystem typically does not support an \*(L"access
time\*(R" field, and it may limit timestamps to a granularity of
two seconds. (Win32)
.IP "wait" 8
.IX Item "wait"
.PD 0
.IP "waitpid" 8
.IX Item "waitpid"
.PD
Can only be applied to process handles returned for processes spawned
using \f(CW\*(C`system(1, ...)\*(C'\fR or pseudo processes created with \f(CW\*(C`fork()\*(C'\fR. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.SH "Supported Platforms"
.IX Header "Supported Platforms"
The following platforms are known to build Perl 5.12 (as of April 2010,
its release date) from the standard source code distribution available
at <http://www.cpan.org/src>
.IP "Linux (x86, \s-1ARM, IA64\s0)" 4
.IX Item "Linux (x86, ARM, IA64)"
.PD 0
.IP "HP-UX" 4
.IX Item "HP-UX"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.IP "Win32" 4
.IX Item "Win32"
.RS 4
.IP "Windows 2000" 4
.IX Item "Windows 2000"
.IP "Windows \s-1XP\s0" 4
.IX Item "Windows XP"
.IP "Windows Server 2003" 4
.IX Item "Windows Server 2003"
.IP "Windows Vista" 4
.IX Item "Windows Vista"
.IP "Windows Server 2008" 4
.IX Item "Windows Server 2008"
.IP "Windows 7" 4
.IX Item "Windows 7"
.RE
.RS 4
.RE
.IP "Cygwin" 4
.IX Item "Cygwin"
.IP "Solaris (x86, \s-1SPARC\s0)" 4
.IX Item "Solaris (x86, SPARC)"
.IP "OpenVMS" 4
.IX Item "OpenVMS"
.RS 4
.IP "Alpha (7.2 and later)" 4
.IX Item "Alpha (7.2 and later)"
.IP "I64 (8.2 and later)" 4
.IX Item "I64 (8.2 and later)"
.RE
.RS 4
.RE
.IP "Symbian" 4
.IX Item "Symbian"
.IP "NetBSD" 4
.IX Item "NetBSD"
.IP "FreeBSD" 4
.IX Item "FreeBSD"
.IP "Debian GNU/kFreeBSD" 4
.IX Item "Debian GNU/kFreeBSD"
.IP "Haiku" 4
.IX Item "Haiku"
.IP "Irix (6.5. What else?)" 4
.IX Item "Irix (6.5. What else?)"
.IP "OpenBSD" 4
.IX Item "OpenBSD"
.IP "Dragonfly \s-1BSD\s0" 4
.IX Item "Dragonfly BSD"
.IP "Midnight \s-1BSD\s0" 4
.IX Item "Midnight BSD"
.IP "\s-1QNX\s0 Neutrino \s-1RTOS \s0(6.5.0)" 4
.IX Item "QNX Neutrino RTOS (6.5.0)"
.IP "MirOS \s-1BSD\s0" 4
.IX Item "MirOS BSD"
.IP "Stratus OpenVOS (17.0 or later)" 4
.IX Item "Stratus OpenVOS (17.0 or later)"
.PD
Caveats:
.RS 4
.IP "time_t issues that may or may not be fixed" 4
.IX Item "time_t issues that may or may not be fixed"
.RE
.RS 4
.RE
.PD 0
.IP "Symbian (Series 60 v3, 3.2 and 5 \- what else?)" 4
.IX Item "Symbian (Series 60 v3, 3.2 and 5 - what else?)"
.IP "Stratus \s-1VOS /\s0 OpenVOS" 4
.IX Item "Stratus VOS / OpenVOS"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.PD
.SH "EOL Platforms (Perl 5.14)"
.IX Header "EOL Platforms (Perl 5.14)"
The following platforms were supported by a previous version of
Perl but have been officially removed from Perl's source code
as of 5.12:
.IP "Atari MiNT" 4
.IX Item "Atari MiNT"
.PD 0
.IP "Apollo Domain/OS" 4
.IX Item "Apollo Domain/OS"
.IP "Apple Mac \s-1OS 8/9\s0" 4
.IX Item "Apple Mac OS 8/9"
.IP "Tenon Machten" 4
.IX Item "Tenon Machten"
.PD
.PP
The following platforms were supported up to 5.10.  They may still
have worked in 5.12, but supporting code has been removed for 5.14:
.IP "Windows 95" 4
.IX Item "Windows 95"
.PD 0
.IP "Windows 98" 4
.IX Item "Windows 98"
.IP "Windows \s-1ME\s0" 4
.IX Item "Windows ME"
.IP "Windows \s-1NT4\s0" 4
.IX Item "Windows NT4"
.PD
.SH "Supported Platforms (Perl 5.8)"
.IX Header "Supported Platforms (Perl 5.8)"
As of July 2002 (the Perl release 5.8.0), the following platforms were
able to build Perl from the standard source code distribution
available at <http://www.cpan.org/src/>
.PP
.Vb 10
\&        AIX
\&        BeOS
\&        BSD/OS          (BSDi)
\&        Cygwin
\&        DG/UX
\&        DOS DJGPP       1)
\&        DYNIX/ptx
\&        EPOC R5
\&        FreeBSD
\&        HI\-UXMPP        (Hitachi) (5.8.0 worked but we didn\*(Aqt know it)
\&        HP\-UX
\&        IRIX
\&        Linux
\&        Mac OS Classic
\&        Mac OS X        (Darwin)
\&        MPE/iX
\&        NetBSD
\&        NetWare
\&        NonStop\-UX
\&        ReliantUNIX     (formerly SINIX)
\&        OpenBSD
\&        OpenVMS         (formerly VMS)
\&        Open UNIX       (Unixware) (since Perl 5.8.1/5.9.0)
\&        OS/2
\&        OS/400          (using the PASE) (since Perl 5.8.1/5.9.0)
\&        PowerUX
\&        POSIX\-BC        (formerly BS2000)
\&        QNX
\&        Solaris
\&        SunOS 4
\&        SUPER\-UX        (NEC)
\&        Tru64 UNIX      (formerly DEC OSF/1, Digital UNIX)
\&        UNICOS
\&        UNICOS/mk
\&        UTS
\&        VOS / OpenVOS
\&        Win95/98/ME/2K/XP 2)
\&        WinCE
\&        z/OS            (formerly OS/390)
\&        VM/ESA
\&
\&        1) in DOS mode either the DOS or OS/2 ports can be used
\&        2) compilers: Borland, MinGW (GCC), VC6
.Ve
.PP
The following platforms worked with the previous releases (5.6 and
5.7), but we did not manage either to fix or to test these in time
for the 5.8.0 release.  There is a very good chance that many of these
will work fine with the 5.8.0.
.PP
.Vb 10
\&        BSD/OS
\&        DomainOS
\&        Hurd
\&        LynxOS
\&        MachTen
\&        PowerMAX
\&        SCO SV
\&        SVR4
\&        Unixware
\&        Windows 3.1
.Ve
.PP
Known to be broken for 5.8.0 (but 5.6.1 and 5.7.2 can be used):
.PP
.Vb 1
\&        AmigaOS
.Ve
.PP
The following platforms have been known to build Perl from source in
the past (5.005_03 and earlier), but we haven't been able to verify
their status for the current release, either because the
hardware/software platforms are rare or because we don't have an
active champion on these platforms\*(--or both.  They used to work,
though, so go ahead and try compiling them, and let perlbug@perl.org
of any trouble.
.PP
.Vb 10
\&        3b1
\&        A/UX
\&        ConvexOS
\&        CX/UX
\&        DC/OSx
\&        DDE SMES
\&        DOS EMX
\&        Dynix
\&        EP/IX
\&        ESIX
\&        FPS
\&        GENIX
\&        Greenhills
\&        ISC
\&        MachTen 68k
\&        MPC
\&        NEWS\-OS
\&        NextSTEP
\&        OpenSTEP
\&        Opus
\&        Plan 9
\&        RISC/os
\&        SCO ODT/OSR
\&        Stellar
\&        SVR2
\&        TI1500
\&        TitanOS
\&        Ultrix
\&        Unisys Dynix
.Ve
.PP
The following platforms have their own source code distributions and
binaries available via <http://www.cpan.org/ports/>
.PP
.Vb 1
\&                                Perl release
\&
\&        OS/400 (ILE)            5.005_02
\&        Tandem Guardian         5.004
.Ve
.PP
The following platforms have only binaries available via
<http://www.cpan.org/ports/index.html> :
.PP
.Vb 1
\&                                Perl release
\&
\&        Acorn RISCOS            5.005_02
\&        AOS                     5.002
\&        LynxOS                  5.004_02
.Ve
.PP
Although we do suggest that you always build your own Perl from
the source code, both for maximal configurability and for security,
in case you are in a hurry you can check
<http://www.cpan.org/ports/index.html> for binary distributions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlaix, perlamiga, perlbs2000,
perlce, perlcygwin, perldgux, perldos,
perlebcdic, perlfreebsd, perlhurd, perlhpux, perlirix,
perlmacos, perlmacosx,
perlnetware, perlos2, perlos390, perlos400,
perlplan9, perlqnx, perlsolaris, perltru64,
perlunicode, perlvms, perlvos, perlwin32, and Win32.
.SH "AUTHORS / CONTRIBUTORS"
.IX Header "AUTHORS / CONTRIBUTORS"
Abigail <abigail@foad.org>,
Charles Bailey <bailey@newman.upenn.edu>,
Graham Barr <gbarr@pobox.com>,
Tom Christiansen <tchrist@perl.com>,
Nicholas Clark <nick@ccl4.org>,
Thomas Dorner <Thomas.Dorner@start.de>,
Andy Dougherty <doughera@lafayette.edu>,
Dominic Dunlop <domo@computer.org>,
Neale Ferguson <neale@vma.tabnsw.com.au>,
David J. Fiander <davidf@mks.com>,
Paul Green <Paul.Green@stratus.com>,
M.J.T. Guy <mjtg@cam.ac.uk>,
Jarkko Hietaniemi <jhi@iki.fi>,
Luther Huffman <lutherh@stratcom.com>,
Nick Ing-Simmons <nick@ing\-simmons.net>,
Andreas J. Ko\*:nig <a.koenig@mind.de>,
Markus Laker <mlaker@contax.co.uk>,
Andrew M. Langmead <aml@world.std.com>,
Larry Moore <ljmoore@freespace.net>,
Paul Moore <Paul.Moore@uk.origin\-it.com>,
Chris Nandor <pudge@pobox.com>,
Matthias Neeracher <neeracher@mac.com>,
Philip Newton <pne@cpan.org>,
Gary Ng <71564.1743@CompuServe.COM>,
Tom Phoenix <rootbeer@teleport.com>,
Andre\*' Pirard <A.Pirard@ulg.ac.be>,
Peter Prymmer <pvhp@forte.com>,
Hugo van der Sanden <hv@crypt0.demon.co.uk>,
Gurusamy Sarathy <gsar@activestate.com>,
Paul J. Schinder <schinder@pobox.com>,
Michael G Schwern <schwern@pobox.com>,
Dan Sugalski <dan@sidhe.org>,
Nathan Torkington <gnat@frii.com>,
John Malmberg <wb8tyw@qsl.net>
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlport5.16.1                               0100644 0001750 0001750 00000312337 12566207423 023131  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPORT 1"
.TH PERLPORT 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlport \- Writing portable Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl runs on numerous operating systems.  While most of them share
much in common, they also have their own unique features.
.PP
This document is meant to help you to find out what constitutes portable
Perl code.  That way once you make a decision to write portably,
you know where the lines are drawn, and you can stay within them.
.PP
There is a tradeoff between taking full advantage of one particular
type of computer and taking advantage of a full range of them.
Naturally, as you broaden your range and become more diverse, the
common factors drop, and you are left with an increasingly smaller
area of common ground in which you can operate to accomplish a
particular task.  Thus, when you begin attacking a problem, it is
important to consider under which part of the tradeoff curve you
want to operate.  Specifically, you must decide whether it is
important that the task that you are coding have the full generality
of being portable, or whether to just get the job done right now.
This is the hardest choice to be made.  The rest is easy, because
Perl provides many choices, whichever way you want to approach your
problem.
.PP
Looking at it another way, writing portable code is usually about
willfully limiting your available choices.  Naturally, it takes
discipline and sacrifice to do that.  The product of portability
and convenience may be a constant.  You have been warned.
.PP
Be aware of two important points:
.IP "Not all Perl programs have to be portable" 4
.IX Item "Not all Perl programs have to be portable"
There is no reason you should not use Perl as a language to glue Unix
tools together, or to prototype a Macintosh application, or to manage the
Windows registry.  If it makes no sense to aim for portability for one
reason or another in a given program, then don't bother.
.IP "Nearly all of Perl already \fIis\fR portable" 4
.IX Item "Nearly all of Perl already is portable"
Don't be fooled into thinking that it is hard to create portable Perl
code.  It isn't.  Perl tries its level-best to bridge the gaps between
what's available on different platforms, and all the means available to
use those features.  Thus almost all Perl code runs on any machine
without modification.  But there are some significant issues in
writing portable code, and this document is entirely about those issues.
.PP
Here's the general rule: When you approach a task commonly done
using a whole range of platforms, think about writing portable
code.  That way, you don't sacrifice much by way of the implementation
choices you can avail yourself of, and at the same time you can give
your users lots of platform choices.  On the other hand, when you have to
take advantage of some unique feature of a particular platform, as is
often the case with systems programming (whether for Unix, Windows,
\&\s-1VMS\s0, etc.), consider writing platform-specific code.
.PP
When the code will run on only two or three operating systems, you
may need to consider only the differences of those particular systems.
The important thing is to decide where the code will run and to be
deliberate in your decision.
.PP
The material below is separated into three main sections: main issues of
portability (\*(L"\s-1ISSUES\s0\*(R"), platform-specific issues (\*(L"\s-1PLATFORMS\s0\*(R"), and
built-in perl functions that behave differently on various ports
(\*(L"\s-1FUNCTION\s0 \s-1IMPLEMENTATIONS\s0\*(R").
.PP
This information should not be considered complete; it includes possibly
transient information about idiosyncrasies of some of the ports, almost
all of which are in a state of constant evolution.  Thus, this material
should be considered a perpetual work in progress
(\f(CW\*(C`<IMG SRC="yellow_sign.gif" ALT="Under Construction">\*(C'\fR).
.SH "ISSUES"
.IX Header "ISSUES"
.SS "Newlines"
.IX Subsection "Newlines"
In most operating systems, lines in files are terminated by newlines.
Just what is used as a newline may vary from \s-1OS\s0 to \s-1OS\s0.  Unix
traditionally uses \f(CW\*(C`\e012\*(C'\fR, one type of DOSish I/O uses \f(CW\*(C`\e015\e012\*(C'\fR,
and Mac\ \s-1OS\s0 uses \f(CW\*(C`\e015\*(C'\fR.
.PP
Perl uses \f(CW\*(C`\en\*(C'\fR to represent the \*(L"logical\*(R" newline, where what is
logical may depend on the platform in use.  In MacPerl, \f(CW\*(C`\en\*(C'\fR always
means \f(CW\*(C`\e015\*(C'\fR.  In DOSish perls, \f(CW\*(C`\en\*(C'\fR usually means \f(CW\*(C`\e012\*(C'\fR, but when
accessing a file in \*(L"text\*(R" mode, perl uses the \f(CW\*(C`:crlf\*(C'\fR layer that
translates it to (or from) \f(CW\*(C`\e015\e012\*(C'\fR, depending on whether you're
reading or writing. Unix does the same thing on ttys in canonical
mode.  \f(CW\*(C`\e015\e012\*(C'\fR is commonly referred to as \s-1CRLF\s0.
.PP
To trim trailing newlines from text lines use \fIchomp()\fR.  With default 
settings that function looks for a trailing \f(CW\*(C`\en\*(C'\fR character and thus 
trims in a portable way.
.PP
When dealing with binary files (or text files in binary mode) be sure
to explicitly set $/ to the appropriate value for your file format
before using \fIchomp()\fR.
.PP
Because of the \*(L"text\*(R" mode translation, DOSish perls have limitations
in using \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR on a file accessed in \*(L"text\*(R" mode.
Stick to \f(CW\*(C`seek\*(C'\fR\-ing to locations you got from \f(CW\*(C`tell\*(C'\fR (and no
others), and you are usually free to use \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR even
in \*(L"text\*(R" mode.  Using \f(CW\*(C`seek\*(C'\fR or \f(CW\*(C`tell\*(C'\fR or other file operations
may be non-portable.  If you use \f(CW\*(C`binmode\*(C'\fR on a file, however, you
can usually \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR with arbitrary values in safety.
.PP
A common misconception in socket programming is that \f(CW\*(C`\en\*(C'\fR eq \f(CW\*(C`\e012\*(C'\fR
everywhere.  When using protocols such as common Internet protocols,
\&\f(CW\*(C`\e012\*(C'\fR and \f(CW\*(C`\e015\*(C'\fR are called for specifically, and the values of
the logical \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR (carriage return) are not reliable.
.PP
.Vb 2
\&    print SOCKET "Hi there, client!\er\en";      # WRONG
\&    print SOCKET "Hi there, client!\e015\e012";  # RIGHT
.Ve
.PP
However, using \f(CW\*(C`\e015\e012\*(C'\fR (or \f(CW\*(C`\ecM\ecJ\*(C'\fR, or \f(CW\*(C`\ex0D\ex0A\*(C'\fR) can be tedious
and unsightly, as well as confusing to those maintaining the code.  As
such, the Socket module supplies the Right Thing for those who want it.
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    print SOCKET "Hi there, client!$CRLF"      # RIGHT
.Ve
.PP
When reading from a socket, remember that the default input record
separator \f(CW$/\fR is \f(CW\*(C`\en\*(C'\fR, but robust socket code will recognize as
either \f(CW\*(C`\e012\*(C'\fR or \f(CW\*(C`\e015\e012\*(C'\fR as end of line:
.PP
.Vb 3
\&    while (<SOCKET>) {
\&        # ...
\&    }
.Ve
.PP
Because both \s-1CRLF\s0 and \s-1LF\s0 end in \s-1LF\s0, the input record separator can
be set to \s-1LF\s0 and any \s-1CR\s0 stripped later.  Better to write:
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    local($/) = LF;      # not needed if $/ is already \e012
\&
\&    while (<SOCKET>) {
\&        s/$CR?$LF/\en/;   # not sure if socket uses LF or CRLF, OK
\&    #   s/\e015?\e012/\en/; # same thing
\&    }
.Ve
.PP
This example is preferred over the previous one\*(--even for Unix
platforms\*(--because now any \f(CW\*(C`\e015\*(C'\fR's (\f(CW\*(C`\ecM\*(C'\fR's) are stripped out
(and there was much rejoicing).
.PP
Similarly, functions that return text data\*(--such as a function that
fetches a web page\*(--should sometimes translate newlines before
returning the data, if they've not yet been translated to the local
newline representation.  A single line of code will often suffice:
.PP
.Vb 2
\&    $data =~ s/\e015?\e012/\en/g;
\&    return $data;
.Ve
.PP
Some of this may be confusing.  Here's a handy reference to the \s-1ASCII\s0 \s-1CR\s0
and \s-1LF\s0 characters.  You can print it out and stick it in your wallet.
.PP
.Vb 2
\&    LF  eq  \e012  eq  \ex0A  eq  \ecJ  eq  chr(10)  eq  ASCII 10
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  ASCII 13
\&
\&             | Unix | DOS  | Mac  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF  |  CR  |
\&        \er   |  CR  |  CR  |  LF  |
\&        \en * |  LF  | CRLF |  CR  |
\&        \er * |  CR  |  CR  |  LF  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.PP
The Unix column assumes that you are not accessing a serial line
(like a tty) in canonical mode.  If you are, then \s-1CR\s0 on input becomes
\&\*(L"\en\*(R", and \*(L"\en\*(R" on output becomes \s-1CRLF\s0.
.PP
These are just the most common definitions of \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR in Perl.
There may well be others.  For example, on an \s-1EBCDIC\s0 implementation
such as z/OS (\s-1OS/390\s0) or \s-1OS/400\s0 (using the \s-1ILE\s0, the \s-1PASE\s0 is ASCII-based)
the above material is similar to \*(L"Unix\*(R" but the code numbers change:
.PP
.Vb 4
\&    LF  eq  \e025  eq  \ex15  eq  \ecU  eq  chr(21)  eq  CP\-1047 21
\&    LF  eq  \e045  eq  \ex25  eq           chr(37)  eq  CP\-0037 37
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-1047 13
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-0037 13
\&
\&             | z/OS | OS/400 |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF    |
\&        \er   |  CR  |  CR    |
\&        \en * |  LF  |  LF    |
\&        \er * |  CR  |  CR    |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.SS "Numbers endianness and Width"
.IX Subsection "Numbers endianness and Width"
Different CPUs store integers and floating point numbers in different
orders (called \fIendianness\fR) and widths (32\-bit and 64\-bit being the
most common today).  This affects your programs when they attempt to transfer
numbers in binary format from one \s-1CPU\s0 architecture to another,
usually either \*(L"live\*(R" via network connection, or by storing the
numbers to secondary storage such as a disk file or tape.
.PP
Conflicting storage orders make utter mess out of the numbers.  If a
little-endian host (Intel, \s-1VAX\s0) stores 0x12345678 (305419896 in
decimal), a big-endian host (Motorola, Sparc, \s-1PA\s0) reads it as
0x78563412 (2018915346 in decimal).  Alpha and \s-1MIPS\s0 can be either:
Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses
them in big-endian mode.  To avoid this problem in network (socket)
connections use the \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR formats \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`N\*(C'\fR, the
\&\*(L"network\*(R" orders.  These are guaranteed to be portable.
.PP
As of perl 5.9.2, you can also use the \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`<\*(C'\fR modifiers
to force big\- or little-endian byte-order.  This is useful if you want
to store signed integers or 64\-bit integers, for example.
.PP
You can explore the endianness of your platform by unpacking a
data structure packed in native format such as:
.PP
.Vb 3
\&    print unpack("h*", pack("s2", 1, 2)), "\en";
\&    # \*(Aq10002000\*(Aq on e.g. Intel x86 or Alpha 21064 in little\-endian mode
\&    # \*(Aq00100020\*(Aq on e.g. Motorola 68040
.Ve
.PP
If you need to distinguish between endian architectures you could use
either of the variables set like so:
.PP
.Vb 2
\&    $is_big_endian   = unpack("h*", pack("s", 1)) =~ /01/;
\&    $is_little_endian = unpack("h*", pack("s", 1)) =~ /^1/;
.Ve
.PP
Differing widths can cause truncation even between platforms of equal
endianness.  The platform of shorter width loses the upper parts of the
number.  There is no good solution for this problem except to avoid
transferring or storing raw binary numbers.
.PP
One can circumnavigate both these problems in two ways.  Either
transfer and store numbers always in text format, instead of raw
binary, or else consider using modules like Data::Dumper (included in
the standard distribution as of Perl 5.005) and Storable (included as
of perl 5.8).  Keeping all data as text significantly simplifies matters.
.PP
The v\-strings are portable only up to v2147483647 (0x7FFFFFFF), that's
how far \s-1EBCDIC\s0, or more precisely UTF-EBCDIC will go.
.SS "Files and Filesystems"
.IX Subsection "Files and Filesystems"
Most platforms these days structure files in a hierarchical fashion.
So, it is reasonably safe to assume that all platforms support the
notion of a \*(L"path\*(R" to uniquely identify a file on the system.  How
that path is really written, though, differs considerably.
.PP
Although similar, file path specifications differ between Unix,
Windows, Mac\ \s-1OS\s0, \s-1OS/2\s0, \s-1VMS\s0, \s-1VOS\s0, \s-1RISC\s0\ \s-1OS\s0, and probably others.
Unix, for example, is one of the few OSes that has the elegant idea
of a single root directory.
.PP
\&\s-1DOS\s0, \s-1OS/2\s0, \s-1VMS\s0, \s-1VOS\s0, and Windows can work similarly to Unix with \f(CW\*(C`/\*(C'\fR
as path separator, or in their own idiosyncratic ways (such as having
several root directories and various \*(L"unrooted\*(R" device files such \s-1NIL:\s0
and \s-1LPT:\s0).
.PP
Mac\ \s-1OS\s0 9 and earlier used \f(CW\*(C`:\*(C'\fR as a path separator instead of \f(CW\*(C`/\*(C'\fR.
.PP
The filesystem may support neither hard links (\f(CW\*(C`link\*(C'\fR) nor
symbolic links (\f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR).
.PP
The filesystem may support neither access timestamp nor change
timestamp (meaning that about the only portable timestamp is the
modification timestamp), or one second granularity of any timestamps
(e.g. the \s-1FAT\s0 filesystem limits the time granularity to two seconds).
.PP
The \*(L"inode change timestamp\*(R" (the \f(CW\*(C`\-C\*(C'\fR filetest) may really be the
\&\*(L"creation timestamp\*(R" (which it is not in Unix).
.PP
\&\s-1VOS\s0 perl can emulate Unix filenames with \f(CW\*(C`/\*(C'\fR as path separator.  The
native pathname characters greater-than, less-than, number-sign, and
percent-sign are always accepted.
.PP
\&\s-1RISC\s0\ \s-1OS\s0 perl can emulate Unix filenames with \f(CW\*(C`/\*(C'\fR as path
separator, or go native and use \f(CW\*(C`.\*(C'\fR for path separator and \f(CW\*(C`:\*(C'\fR to
signal filesystems and disk names.
.PP
Don't assume Unix filesystem access semantics: that read, write,
and execute are all the permissions there are, and even if they exist,
that their semantics (for example what do r, w, and x mean on
a directory) are the Unix ones.  The various Unix/POSIX compatibility
layers usually try to make interfaces like \fIchmod()\fR work, but sometimes
there simply is no good mapping.
.PP
If all this is intimidating, have no (well, maybe only a little)
fear.  There are modules that can help.  The File::Spec modules
provide methods to do the Right Thing on whatever platform happens
to be running the program.
.PP
.Vb 6
\&    use File::Spec::Functions;
\&    chdir(updir());        # go up one directory
\&    my $file = catfile(curdir(), \*(Aqtemp\*(Aq, \*(Aqfile.txt\*(Aq);
\&    # on Unix and Win32, \*(Aq./temp/file.txt\*(Aq
\&    # on Mac OS Classic, \*(Aq:temp:file.txt\*(Aq
\&    # on VMS, \*(Aq[.temp]file.txt\*(Aq
.Ve
.PP
File::Spec is available in the standard distribution as of version
5.004_05.  File::Spec::Functions is only in File::Spec 0.7 and later,
and some versions of perl come with version 0.6.  If File::Spec
is not updated to 0.7 or later, you must use the object-oriented
interface from File::Spec (or upgrade File::Spec).
.PP
In general, production code should not have file paths hardcoded.
Making them user-supplied or read from a configuration file is
better, keeping in mind that file path syntax varies on different
machines.
.PP
This is especially noticeable in scripts like Makefiles and test suites,
which often assume \f(CW\*(C`/\*(C'\fR as a path separator for subdirectories.
.PP
Also of use is File::Basename from the standard distribution, which
splits a pathname into pieces (base filename, full path to directory,
and file suffix).
.PP
Even when on a single platform (if you can call Unix a single platform),
remember not to count on the existence or the contents of particular
system-specific files or directories, like \fI/etc/passwd\fR,
\&\fI/etc/sendmail.conf\fR, \fI/etc/resolv.conf\fR, or even \fI/tmp/\fR.  For
example, \fI/etc/passwd\fR may exist but not contain the encrypted
passwords, because the system is using some form of enhanced security.
Or it may not contain all the accounts, because the system is using \s-1NIS\s0. 
If code does need to rely on such a file, include a description of the
file and its format in the code's documentation, then make it easy for
the user to override the default location of the file.
.PP
Don't assume a text file will end with a newline.  They should,
but people forget.
.PP
Do not have two files or directories of the same name with different
case, like \fItest.pl\fR and \fITest.pl\fR, as many platforms have
case-insensitive (or at least case-forgiving) filenames.  Also, try
not to have non-word characters (except for \f(CW\*(C`.\*(C'\fR) in the names, and
keep them to the 8.3 convention, for maximum portability, onerous a
burden though this may appear.
.PP
Likewise, when using the AutoSplit module, try to keep your functions to
8.3 naming and case-insensitive conventions; or, at the least,
make it so the resulting files have a unique (case-insensitively)
first 8 characters.
.PP
Whitespace in filenames is tolerated on most systems, but not all,
and even on systems where it might be tolerated, some utilities
might become confused by such whitespace.
.PP
Many systems (\s-1DOS\s0, \s-1VMS\s0 \s-1ODS\-2\s0) cannot have more than one \f(CW\*(C`.\*(C'\fR in their
filenames.
.PP
Don't assume \f(CW\*(C`>\*(C'\fR won't be the first character of a filename.
Always use \f(CW\*(C`<\*(C'\fR explicitly to open a file for reading, or even
better, use the three-arg version of open, unless you want the user to
be able to specify a pipe open.
.PP
.Vb 1
\&    open my $fh, \*(Aq<\*(Aq, $existing_file) or die $!;
.Ve
.PP
If filenames might use strange characters, it is safest to open it
with \f(CW\*(C`sysopen\*(C'\fR instead of \f(CW\*(C`open\*(C'\fR.  \f(CW\*(C`open\*(C'\fR is magic and can
translate characters like \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`<\*(C'\fR, and \f(CW\*(C`|\*(C'\fR, which may
be the wrong thing to do.  (Sometimes, though, it's the right thing.)
Three-arg open can also help protect against this translation in cases
where it is undesirable.
.PP
Don't use \f(CW\*(C`:\*(C'\fR as a part of a filename since many systems use that for
their own semantics (Mac \s-1OS\s0 Classic for separating pathname components,
many networking schemes and utilities for separating the nodename and
the pathname, and so on).  For the same reasons, avoid \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`;\*(C'\fR and
\&\f(CW\*(C`|\*(C'\fR.
.PP
Don't assume that in pathnames you can collapse two leading slashes
\&\f(CW\*(C`//\*(C'\fR into one: some networking and clustering filesystems have special
semantics for that.  Let the operating system to sort it out.
.PP
The \fIportable filename characters\fR as defined by \s-1ANSI\s0 C are
.PP
.Vb 4
\& a b c d e f g h i j k l m n o p q r t u v w x y z
\& A B C D E F G H I J K L M N O P Q R T U V W X Y Z
\& 0 1 2 3 4 5 6 7 8 9
\& . _ \-
.Ve
.PP
and the \*(L"\-\*(R" shouldn't be the first character.  If you want to be
hypercorrect, stay case-insensitive and within the 8.3 naming
convention (all the files and directories have to be unique within one
directory if their names are lowercased and truncated to eight
characters before the \f(CW\*(C`.\*(C'\fR, if any, and to three characters after the
\&\f(CW\*(C`.\*(C'\fR, if any).  (And do not use \f(CW\*(C`.\*(C'\fRs in directory names.)
.SS "System Interaction"
.IX Subsection "System Interaction"
Not all platforms provide a command line.  These are usually platforms
that rely primarily on a Graphical User Interface (\s-1GUI\s0) for user
interaction.  A program requiring a command line interface might
not work everywhere.  This is probably for the user of the program
to deal with, so don't stay up late worrying about it.
.PP
Some platforms can't delete or rename files held open by the system,
this limitation may also apply to changing filesystem metainformation
like file permissions or owners.  Remember to \f(CW\*(C`close\*(C'\fR files when you
are done with them.  Don't \f(CW\*(C`unlink\*(C'\fR or \f(CW\*(C`rename\*(C'\fR an open file.  Don't
\&\f(CW\*(C`tie\*(C'\fR or \f(CW\*(C`open\*(C'\fR a file already tied or opened; \f(CW\*(C`untie\*(C'\fR or \f(CW\*(C`close\*(C'\fR
it first.
.PP
Don't open the same file more than once at a time for writing, as some
operating systems put mandatory locks on such files.
.PP
Don't assume that write/modify permission on a directory gives the
right to add or delete files/directories in that directory.  That is
filesystem specific: in some filesystems you need write/modify
permission also (or even just) in the file/directory itself.  In some
filesystems (\s-1AFS\s0, \s-1DFS\s0) the permission to add/delete directory entries
is a completely separate permission.
.PP
Don't assume that a single \f(CW\*(C`unlink\*(C'\fR completely gets rid of the file:
some filesystems (most notably the ones in \s-1VMS\s0) have versioned
filesystems, and \fIunlink()\fR removes only the most recent one (it doesn't
remove all the versions because by default the native tools on those
platforms remove just the most recent version, too).  The portable
idiom to remove all the versions of a file is
.PP
.Vb 1
\&    1 while unlink "file";
.Ve
.PP
This will terminate if the file is undeleteable for some reason
(protected, not there, and so on).
.PP
Don't count on a specific environment variable existing in \f(CW%ENV\fR.
Don't count on \f(CW%ENV\fR entries being case-sensitive, or even
case-preserving.  Don't try to clear \f(CW%ENV\fR by saying \f(CW\*(C`%ENV = ();\*(C'\fR, or,
if you really have to, make it conditional on \f(CW\*(C`$^O ne \*(AqVMS\*(Aq\*(C'\fR since in
\&\s-1VMS\s0 the \f(CW%ENV\fR table is much more than a per-process key-value string
table.
.PP
On \s-1VMS\s0, some entries in the \f(CW%ENV\fR hash are dynamically created when
their key is used on a read if they did not previously exist.  The
values for \f(CW$ENV{HOME}\fR, \f(CW$ENV{TERM}\fR, \f(CW$ENV{HOME}\fR, and \f(CW$ENV{USER}\fR,
are known to be dynamically generated.  The specific names that are
dynamically generated may vary with the version of the C library on \s-1VMS\s0,
and more may exist than is documented.
.PP
On \s-1VMS\s0 by default, changes to the \f(CW%ENV\fR hash are persistent after the process
exits.  This can cause unintended issues.
.PP
Don't count on signals or \f(CW%SIG\fR for anything.
.PP
Don't count on filename globbing.  Use \f(CW\*(C`opendir\*(C'\fR, \f(CW\*(C`readdir\*(C'\fR, and
\&\f(CW\*(C`closedir\*(C'\fR instead.
.PP
Don't count on per-program environment variables, or per-program current
directories.
.PP
Don't count on specific values of \f(CW$!\fR, neither numeric nor
especially the strings values. Users may switch their locales causing
error messages to be translated into their languages.  If you can
trust a POSIXish environment, you can portably use the symbols defined
by the Errno module, like \s-1ENOENT\s0.  And don't trust on the values of \f(CW$!\fR
at all except immediately after a failed system call.
.SS "Command names versus file pathnames"
.IX Subsection "Command names versus file pathnames"
Don't assume that the name used to invoke a command or program with
\&\f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR can also be used to test for the existence of the
file that holds the executable code for that command or program.
First, many systems have \*(L"internal\*(R" commands that are built-in to the
shell or \s-1OS\s0 and while these commands can be invoked, there is no
corresponding file.  Second, some operating systems (e.g., Cygwin,
\&\s-1DJGPP\s0, \s-1OS/2\s0, and \s-1VOS\s0) have required suffixes for executable files;
these suffixes are generally permitted on the command name but are not
required.  Thus, a command like \*(L"perl\*(R" might exist in a file named
\&\*(L"perl\*(R", \*(L"perl.exe\*(R", or \*(L"perl.pm\*(R", depending on the operating system.
The variable \*(L"_exe\*(R" in the Config module holds the executable suffix,
if any.  Third, the \s-1VMS\s0 port carefully sets up $^X and
\&\f(CW$Config\fR{perlpath} so that no further processing is required.  This is
just as well, because the matching regular expression used below would
then have to deal with a possible trailing version number in the \s-1VMS\s0
file name.
.PP
To convert $^X to a file pathname, taking account of the requirements
of the various operating system possibilities, say:
.PP
.Vb 4
\& use Config;
\& my $thisperl = $^X;
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.PP
To convert \f(CW$Config\fR{perlpath} to a file pathname, say:
.PP
.Vb 4
\& use Config;
\& my $thisperl = $Config{perlpath};
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.SS "Networking"
.IX Subsection "Networking"
Don't assume that you can reach the public Internet.
.PP
Don't assume that there is only one way to get through firewalls
to the public Internet.
.PP
Don't assume that you can reach outside world through any other port
than 80, or some web proxy.  ftp is blocked by many firewalls.
.PP
Don't assume that you can send email by connecting to the local \s-1SMTP\s0 port.
.PP
Don't assume that you can reach yourself or any node by the name
\&'localhost'.  The same goes for '127.0.0.1'.  You will have to try both.
.PP
Don't assume that the host has only one network card, or that it
can't bind to many virtual \s-1IP\s0 addresses.
.PP
Don't assume a particular network device name.
.PP
Don't assume a particular set of \fIioctl()\fRs will work.
.PP
Don't assume that you can ping hosts and get replies.
.PP
Don't assume that any particular port (service) will respond.
.PP
Don't assume that Sys::Hostname (or any other \s-1API\s0 or command) returns
either a fully qualified hostname or a non-qualified hostname: it all
depends on how the system had been configured.  Also remember that for
things such as \s-1DHCP\s0 and \s-1NAT\s0, the hostname you get back might not be
very useful.
.PP
All the above \*(L"don't\*(R":s may look daunting, and they are, but the key
is to degrade gracefully if one cannot reach the particular network
service one wants.  Croaking or hanging do not look very professional.
.SS "Interprocess Communication (\s-1IPC\s0)"
.IX Subsection "Interprocess Communication (IPC)"
In general, don't directly access the system in code meant to be
portable.  That means, no \f(CW\*(C`system\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`pipe\*(C'\fR,
\&\f(CW\*(C`\`\`\*(C'\fR, \f(CW\*(C`qx//\*(C'\fR, \f(CW\*(C`open\*(C'\fR with a \f(CW\*(C`|\*(C'\fR, nor any of the other things
that makes being a perl hacker worth being.
.PP
Commands that launch external processes are generally supported on
most platforms (though many of them do not support any type of
forking).  The problem with using them arises from what you invoke
them on.  External tools are often named differently on different
platforms, may not be available in the same location, might accept
different arguments, can behave differently, and often present their
results in a platform-dependent way.  Thus, you should seldom depend
on them to produce consistent results. (Then again, if you're calling 
\&\fInetstat \-a\fR, you probably don't expect it to run on both Unix and \s-1CP/M\s0.)
.PP
One especially common bit of Perl code is opening a pipe to \fBsendmail\fR:
.PP
.Vb 2
\&    open(MAIL, \*(Aq|/usr/lib/sendmail \-t\*(Aq) 
\&        or die "cannot fork sendmail: $!";
.Ve
.PP
This is fine for systems programming when sendmail is known to be
available.  But it is not fine for many non-Unix systems, and even
some Unix systems that may not have sendmail installed.  If a portable
solution is needed, see the various distributions on \s-1CPAN\s0 that deal
with it.  Mail::Mailer and Mail::Send in the MailTools distribution are
commonly used, and provide several mailing methods, including mail,
sendmail, and direct \s-1SMTP\s0 (via Net::SMTP) if a mail transfer agent is
not available.  Mail::Sendmail is a standalone module that provides
simple, platform-independent mailing.
.PP
The Unix System V \s-1IPC\s0 (\f(CW\*(C`msg*(), sem*(), shm*()\*(C'\fR) is not available
even on all Unix platforms.
.PP
Do not use either the bare result of \f(CW\*(C`pack("N", 10, 20, 30, 40)\*(C'\fR or
bare v\-strings (such as \f(CW\*(C`v10.20.30.40\*(C'\fR) to represent IPv4 addresses:
both forms just pack the four bytes into network order.  That this
would be equal to the C language \f(CW\*(C`in_addr\*(C'\fR struct (which is what the
socket code internally uses) is not guaranteed.  To be portable use
the routines of the Socket extension, such as \f(CW\*(C`inet_aton()\*(C'\fR,
\&\f(CW\*(C`inet_ntoa()\*(C'\fR, and \f(CW\*(C`sockaddr_in()\*(C'\fR.
.PP
The rule of thumb for portable code is: Do it all in portable Perl, or
use a module (that may internally implement it with platform-specific
code, but expose a common interface).
.SS "External Subroutines (\s-1XS\s0)"
.IX Subsection "External Subroutines (XS)"
\&\s-1XS\s0 code can usually be made to work with any platform, but dependent
libraries, header files, etc., might not be readily available or
portable, or the \s-1XS\s0 code itself might be platform-specific, just as Perl
code might be.  If the libraries and headers are portable, then it is
normally reasonable to make sure the \s-1XS\s0 code is portable, too.
.PP
A different type of portability issue arises when writing \s-1XS\s0 code:
availability of a C compiler on the end-user's system.  C brings
with it its own portability issues, and writing \s-1XS\s0 code will expose
you to some of those.  Writing purely in Perl is an easier way to
achieve portability.
.SS "Standard Modules"
.IX Subsection "Standard Modules"
In general, the standard modules work across platforms.  Notable
exceptions are the \s-1CPAN\s0 module (which currently makes connections to external
programs that may not be available), platform-specific modules (like
ExtUtils::MM_VMS), and \s-1DBM\s0 modules.
.PP
There is no one \s-1DBM\s0 module available on all platforms.
SDBM_File and the others are generally available on all Unix and DOSish
ports, but not in MacPerl, where only NBDM_File and DB_File are
available.
.PP
The good news is that at least some \s-1DBM\s0 module should be available, and
AnyDBM_File will use whichever module it can find.  Of course, then
the code needs to be fairly strict, dropping to the greatest common
factor (e.g., not exceeding 1K for each record), so that it will
work with any \s-1DBM\s0 module.  See AnyDBM_File for more details.
.SS "Time and Date"
.IX Subsection "Time and Date"
The system's notion of time of day and calendar date is controlled in
widely different ways.  Don't assume the timezone is stored in \f(CW$ENV{TZ}\fR,
and even if it is, don't assume that you can control the timezone through
that variable.  Don't assume anything about the three-letter timezone
abbreviations (for example that \s-1MST\s0 would be the Mountain Standard Time,
it's been known to stand for Moscow Standard Time).  If you need to
use timezones, express them in some unambiguous format like the
exact number of minutes offset from \s-1UTC\s0, or the \s-1POSIX\s0 timezone
format.
.PP
Don't assume that the epoch starts at 00:00:00, January 1, 1970,
because that is \s-1OS\-\s0 and implementation-specific.  It is better to
store a date in an unambiguous representation.  The \s-1ISO\s0 8601 standard
defines YYYY-MM-DD as the date format, or \s-1YYYY\-MM\-DDTHH:MM:SS\s0
(that's a literal \*(L"T\*(R" separating the date from the time).
Please do use the \s-1ISO\s0 8601 instead of making us guess what
date 02/03/04 might be.  \s-1ISO\s0 8601 even sorts nicely as-is.
A text representation (like \*(L"1987\-12\-18\*(R") can be easily converted
into an OS-specific value using a module like Date::Parse.
An array of values, such as those returned by \f(CW\*(C`localtime\*(C'\fR, can be
converted to an OS-specific representation using Time::Local.
.PP
When calculating specific times, such as for tests in time or date modules,
it may be appropriate to calculate an offset for the epoch.
.PP
.Vb 2
\&    require Time::Local;
\&    my $offset = Time::Local::timegm(0, 0, 0, 1, 0, 70);
.Ve
.PP
The value for \f(CW$offset\fR in Unix will be \f(CW0\fR, but in Mac \s-1OS\s0 Classic
will be some large number.  \f(CW$offset\fR can then be added to a Unix time
value to get what should be the proper value on any system.
.SS "Character sets and character encoding"
.IX Subsection "Character sets and character encoding"
Assume very little about character sets.
.PP
Assume nothing about numerical values (\f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`chr\*(C'\fR) of characters.
Do not use explicit code point ranges (like \exHH\-\exHH); use for
example symbolic character classes like \f(CW\*(C`[:print:]\*(C'\fR.
.PP
Do not assume that the alphabetic characters are encoded contiguously
(in the numeric sense).  There may be gaps.
.PP
Do not assume anything about the ordering of the characters.
The lowercase letters may come before or after the uppercase letters;
the lowercase and uppercase may be interlaced so that both \*(L"a\*(R" and \*(L"A\*(R"
come before \*(L"b\*(R"; the accented and other international characters may
be interlaced so that a\*: comes before \*(L"b\*(R".
.SS "Internationalisation"
.IX Subsection "Internationalisation"
If you may assume \s-1POSIX\s0 (a rather large assumption), you may read
more about the \s-1POSIX\s0 locale system from perllocale.  The locale
system at least attempts to make things a little bit more portable,
or at least more convenient and native-friendly for non-English
users.  The system affects character sets and encoding, and date
and time formatting\*(--amongst other things.
.PP
If you really want to be international, you should consider Unicode.
See perluniintro and perlunicode for more information.
.PP
If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in
the \*(L"source code\*(R" of your code, to be portable you have to be explicit
about what bytes they are.  Someone might for example be using your
code under a \s-1UTF\-8\s0 locale, in which case random native bytes might be
illegal (\*(L"Malformed \s-1UTF\-8\s0 ...\*(R")  This means that for example embedding
\&\s-1ISO\s0 8859\-1 bytes beyond 0x7f into your strings might cause trouble
later.  If the bytes are native 8\-bit bytes, you can use the \f(CW\*(C`bytes\*(C'\fR
pragma.  If the bytes are in a string (regular expression being a
curious string), you can often also use the \f(CW\*(C`\exHH\*(C'\fR notation instead
of embedding the bytes as-is.  (If you want to write your code in \s-1UTF\-8\s0,
you can use the \f(CW\*(C`utf8\*(C'\fR.) The \f(CW\*(C`bytes\*(C'\fR and \f(CW\*(C`utf8\*(C'\fR pragmata are
available since Perl 5.6.0.
.SS "System Resources"
.IX Subsection "System Resources"
If your code is destined for systems with severely constrained (or
missing!) virtual memory systems then you want to be \fIespecially\fR mindful
of avoiding wasteful constructs such as:
.PP
.Vb 1
\&    my @lines = <$very_large_file>;            # bad
\&
\&    while (<$fh>) {$file .= $_}                # sometimes bad
\&    my $file = join(\*(Aq\*(Aq, <$fh>);                # better
.Ve
.PP
The last two constructs may appear unintuitive to most people.  The
first repeatedly grows a string, whereas the second allocates a
large chunk of memory in one go.  On some systems, the second is
more efficient that the first.
.SS "Security"
.IX Subsection "Security"
Most multi-user platforms provide basic levels of security, usually
implemented at the filesystem level.  Some, however, unfortunately do
not.  Thus the notion of user id, or \*(L"home\*(R" directory,
or even the state of being logged-in, may be unrecognizable on many
platforms.  If you write programs that are security-conscious, it
is usually best to know what type of system you will be running
under so that you can write code explicitly for that platform (or
class of platforms).
.PP
Don't assume the Unix filesystem access semantics: the operating
system or the filesystem may be using some \s-1ACL\s0 systems, which are
richer languages than the usual rwx.  Even if the rwx exist,
their semantics might be different.
.PP
(From security viewpoint testing for permissions before attempting to
do something is silly anyway: if one tries this, there is potential
for race conditions. Someone or something might change the
permissions between the permissions check and the actual operation.
Just try the operation.)
.PP
Don't assume the Unix user and group semantics: especially, don't
expect the \f(CW$<\fR and \f(CW$>\fR (or the \f(CW$(\fR and \f(CW$)\fR) to work
for switching identities (or memberships).
.PP
Don't assume set-uid and set-gid semantics. (And even if you do,
think twice: set-uid and set-gid are a known can of security worms.)
.SS "Style"
.IX Subsection "Style"
For those times when it is necessary to have platform-specific code,
consider keeping the platform-specific code in one place, making porting
to other platforms easier.  Use the Config module and the special
variable \f(CW$^O\fR to differentiate platforms, as described in
\&\*(L"\s-1PLATFORMS\s0\*(R".
.PP
Be careful in the tests you supply with your module or programs.
Module code may be fully portable, but its tests might not be.  This
often happens when tests spawn off other processes or call external
programs to aid in the testing, or when (as noted above) the tests
assume certain things about the filesystem and paths.  Be careful not
to depend on a specific output style for errors, such as when checking
\&\f(CW$!\fR after a failed system call.  Using \f(CW$!\fR for anything else than
displaying it as output is doubtful (though see the Errno module for
testing reasonably portably for error value). Some platforms expect
a certain output format, and Perl on those platforms may have been
adjusted accordingly.  Most specifically, don't anchor a regex when
testing an error value.
.SH "CPAN Testers"
.IX Header "CPAN Testers"
Modules uploaded to \s-1CPAN\s0 are tested by a variety of volunteers on
different platforms.  These \s-1CPAN\s0 testers are notified by mail of each
new upload, and reply to the list with \s-1PASS\s0, \s-1FAIL\s0, \s-1NA\s0 (not applicable to
this platform), or \s-1UNKNOWN\s0 (unknown), along with any relevant notations.
.PP
The purpose of the testing is twofold: one, to help developers fix any
problems in their code that crop up because of lack of testing on other
platforms; two, to provide users with information about whether
a given module works on a given platform.
.PP
Also see:
.IP "\(bu" 4
Mailing list: cpan\-testers\-discuss@perl.org
.IP "\(bu" 4
Testing results: <http://www.cpantesters.org/>
.SH "PLATFORMS"
.IX Header "PLATFORMS"
As of version 5.002, Perl is built with a \f(CW$^O\fR variable that
indicates the operating system it was built on.  This was implemented
to help speed up code that would otherwise have to \f(CW\*(C`use Config\*(C'\fR
and use the value of \f(CW$Config{osname}\fR.  Of course, to get more
detailed information about the system, looking into \f(CW%Config\fR is
certainly recommended.
.PP
\&\f(CW%Config\fR cannot always be trusted, however, because it was built
at compile time.  If perl was built in one place, then transferred
elsewhere, some values may be wrong.  The values may even have been
edited after the fact.
.SS "Unix"
.IX Subsection "Unix"
Perl works on a bewildering variety of Unix and Unix-like platforms (see
e.g. most of the files in the \fIhints/\fR directory in the source code kit).
On most of these systems, the value of \f(CW$^O\fR (hence \f(CW$Config{\*(Aqosname\*(Aq}\fR,
too) is determined either by lowercasing and stripping punctuation from the
first field of the string returned by typing \f(CW\*(C`uname \-a\*(C'\fR (or a similar command)
at the shell prompt or by testing the file system for the presence of
uniquely named files such as a kernel or header file.  Here, for example,
are a few of the more popular Unix flavors:
.PP
.Vb 10
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    AIX           aix        aix
\&    BSD/OS        bsdos      i386\-bsdos
\&    Darwin        darwin     darwin
\&    dgux          dgux       AViiON\-dgux
\&    DYNIX/ptx     dynixptx   i386\-dynixptx
\&    FreeBSD       freebsd    freebsd\-i386    
\&    Haiku         haiku      BePC\-haiku
\&    Linux         linux      arm\-linux
\&    Linux         linux      i386\-linux
\&    Linux         linux      i586\-linux
\&    Linux         linux      ppc\-linux
\&    HP\-UX         hpux       PA\-RISC1.1
\&    IRIX          irix       irix
\&    Mac OS X      darwin     darwin
\&    NeXT 3        next       next\-fat
\&    NeXT 4        next       OPENSTEP\-Mach
\&    openbsd       openbsd    i386\-openbsd
\&    OSF1          dec_osf    alpha\-dec_osf
\&    reliantunix\-n svr4       RM400\-svr4
\&    SCO_SV        sco_sv     i386\-sco_sv
\&    SINIX\-N       svr4       RM400\-svr4
\&    sn4609        unicos     CRAY_C90\-unicos
\&    sn6521        unicosmk   t3e\-unicosmk
\&    sn9617        unicos     CRAY_J90\-unicos
\&    SunOS         solaris    sun4\-solaris
\&    SunOS         solaris    i86pc\-solaris
\&    SunOS4        sunos      sun4\-sunos
.Ve
.PP
Because the value of \f(CW$Config{archname}\fR may depend on the
hardware architecture, it can vary more than the value of \f(CW$^O\fR.
.SS "\s-1DOS\s0 and Derivatives"
.IX Subsection "DOS and Derivatives"
Perl has long been ported to Intel-style microcomputers running under
systems like PC-DOS, MS-DOS, \s-1OS/2\s0, and most Windows platforms you can
bring yourself to mention (except for Windows \s-1CE\s0, if you count that).
Users familiar with \fI\s-1COMMAND\s0.COM\fR or \fI\s-1CMD\s0.EXE\fR style shells should
be aware that each of these file specifications may have subtle
differences:
.PP
.Vb 4
\&    my $filespec0 = "c:/foo/bar/file.txt";
\&    my $filespec1 = "c:\e\efoo\e\ebar\e\efile.txt";
\&    my $filespec2 = \*(Aqc:\efoo\ebar\efile.txt\*(Aq;
\&    my $filespec3 = \*(Aqc:\e\efoo\e\ebar\e\efile.txt\*(Aq;
.Ve
.PP
System calls accept either \f(CW\*(C`/\*(C'\fR or \f(CW\*(C`\e\*(C'\fR as the path separator.
However, many command-line utilities of \s-1DOS\s0 vintage treat \f(CW\*(C`/\*(C'\fR as
the option prefix, so may get confused by filenames containing \f(CW\*(C`/\*(C'\fR.
Aside from calling any external programs, \f(CW\*(C`/\*(C'\fR will work just fine,
and probably better, as it is more consistent with popular usage,
and avoids the problem of remembering what to backwhack and what
not to.
.PP
The \s-1DOS\s0 \s-1FAT\s0 filesystem can accommodate only \*(L"8.3\*(R" style filenames.  Under
the \*(L"case-insensitive, but case-preserving\*(R" \s-1HPFS\s0 (\s-1OS/2\s0) and \s-1NTFS\s0 (\s-1NT\s0)
filesystems you may have to be careful about case returned with functions
like \f(CW\*(C`readdir\*(C'\fR or used with functions like \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`opendir\*(C'\fR.
.PP
\&\s-1DOS\s0 also treats several filenames as special, such as \s-1AUX\s0, \s-1PRN\s0,
\&\s-1NUL\s0, \s-1CON\s0, \s-1COM1\s0, \s-1LPT1\s0, \s-1LPT2\s0, etc.  Unfortunately, sometimes these
filenames won't even work if you include an explicit directory
prefix.  It is best to avoid such filenames, if you want your code
to be portable to \s-1DOS\s0 and its derivatives.  It's hard to know what
these all are, unfortunately.
.PP
Users of these operating systems may also wish to make use of
scripts such as \fIpl2bat.bat\fR or \fIpl2cmd\fR to
put wrappers around your scripts.
.PP
Newline (\f(CW\*(C`\en\*(C'\fR) is translated as \f(CW\*(C`\e015\e012\*(C'\fR by \s-1STDIO\s0 when reading from
and writing to files (see \*(L"Newlines\*(R").  \f(CW\*(C`binmode(FILEHANDLE)\*(C'\fR
will keep \f(CW\*(C`\en\*(C'\fR translated as \f(CW\*(C`\e012\*(C'\fR for that filehandle.  Since it is a
no-op on other systems, \f(CW\*(C`binmode\*(C'\fR should be used for cross-platform code
that deals with binary data.  That's assuming you realize in advance
that your data is in binary.  General-purpose programs should
often assume nothing about their data.
.PP
The \f(CW$^O\fR variable and the \f(CW$Config{archname}\fR values for various
DOSish perls are as follows:
.PP
.Vb 10
\&     OS            $^O      $Config{archname}   ID    Version
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MS\-DOS        dos        ?                 
\&     PC\-DOS        dos        ?                 
\&     OS/2          os2        ?
\&     Windows 3.1   ?          ?                 0      3 01
\&     Windows 95    MSWin32    MSWin32\-x86       1      4 00
\&     Windows 98    MSWin32    MSWin32\-x86       1      4 10
\&     Windows ME    MSWin32    MSWin32\-x86       1      ?
\&     Windows NT    MSWin32    MSWin32\-x86       2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ALPHA     2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ppc       2      4 xx
\&     Windows 2000  MSWin32    MSWin32\-x86       2      5 00
\&     Windows XP    MSWin32    MSWin32\-x86       2      5 01
\&     Windows 2003  MSWin32    MSWin32\-x86       2      5 02
\&     Windows Vista MSWin32    MSWin32\-x86       2      6 00
\&     Windows 7     MSWin32    MSWin32\-x86       2      6 01
\&     Windows 7     MSWin32    MSWin32\-x64       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x86       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x64       2      6 01
\&     Windows CE    MSWin32    ?                 3           
\&     Cygwin        cygwin     cygwin
.Ve
.PP
The various MSWin32 Perl's can distinguish the \s-1OS\s0 they are running on
via the value of the fifth element of the list returned from 
\&\fIWin32::GetOSVersion()\fR.  For example:
.PP
.Vb 4
\&    if ($^O eq \*(AqMSWin32\*(Aq) {
\&        my @os_version_info = Win32::GetOSVersion();
\&        print +(\*(Aq3.1\*(Aq,\*(Aq95\*(Aq,\*(AqNT\*(Aq)[$os_version_info[4]],"\en";
\&    }
.Ve
.PP
There are also \fIWin32::IsWinNT()\fR and \fIWin32::IsWin95()\fR, try \f(CW\*(C`perldoc Win32\*(C'\fR,
and as of libwin32 0.19 (not part of the core Perl distribution)
\&\fIWin32::GetOSName()\fR.  The very portable \fIPOSIX::uname()\fR will work too:
.PP
.Vb 2
\&    c:\e> perl \-MPOSIX \-we "print join \*(Aq|\*(Aq, uname"
\&    Windows NT|moonru|5.0|Build 2195 (Service Pack 2)|x86
.Ve
.PP
Also see:
.IP "\(bu" 4
The djgpp environment for \s-1DOS\s0, <http://www.delorie.com/djgpp/>
and perldos.
.IP "\(bu" 4
The \s-1EMX\s0 environment for \s-1DOS\s0, \s-1OS/2\s0, etc. emx@iaehv.nl,
<ftp://hobbes.nmsu.edu/pub/os2/dev/emx/>  Also perlos2.
.IP "\(bu" 4
Build instructions for Win32 in perlwin32, or under the Cygnus environment
in perlcygwin.
.IP "\(bu" 4
The \f(CW\*(C`Win32::*\*(C'\fR modules in Win32.
.IP "\(bu" 4
The ActiveState Pages, <http://www.activestate.com/>
.IP "\(bu" 4
The Cygwin environment for Win32; \fI\s-1README\s0.cygwin\fR (installed 
as perlcygwin), <http://www.cygwin.com/>
.IP "\(bu" 4
The U/WIN environment for Win32,
<http://www.research.att.com/sw/tools/uwin/>
.IP "\(bu" 4
Build instructions for \s-1OS/2\s0, perlos2
.SS "\s-1VMS\s0"
.IX Subsection "VMS"
Perl on \s-1VMS\s0 is discussed in perlvms in the perl distribution.
.PP
The official name of \s-1VMS\s0 as of this writing is OpenVMS.
.PP
Perl on \s-1VMS\s0 can accept either \s-1VMS\-\s0 or Unix-style file
specifications as in either of the following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" SYS$LOGIN:LOGIN.COM
\&    $ perl \-ne "print if /perl_setup/i" /sys$login/login.com
.Ve
.PP
but not a mixture of both as in:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" sys$login:/login.com
\&    Can\*(Aqt open sys$login:/login.com: file specification syntax error
.Ve
.PP
Interacting with Perl from the Digital Command Language (\s-1DCL\s0) shell
often requires a different set of quotation marks than Unix shells do.
For example:
.PP
.Vb 2
\&    $ perl \-e "print ""Hello, world.\en"""
\&    Hello, world.
.Ve
.PP
There are several ways to wrap your perl scripts in \s-1DCL\s0 \fI.COM\fR files, if
you are so inclined.  For example:
.PP
.Vb 6
\&    $ write sys$output "Hello from DCL!"
\&    $ if p1 .eqs. ""
\&    $ then perl \-x \*(Aqf$environment("PROCEDURE")
\&    $ else perl \-x \- \*(Aqp1 \*(Aqp2 \*(Aqp3 \*(Aqp4 \*(Aqp5 \*(Aqp6 \*(Aqp7 \*(Aqp8
\&    $ deck/dollars="_\|_END_\|_"
\&    #!/usr/bin/perl
\&
\&    print "Hello from Perl!\en";
\&
\&    _\|_END_\|_
\&    $ endif
.Ve
.PP
Do take care with \f(CW\*(C`$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT\*(C'\fR if your
perl-in-DCL script expects to do things like \f(CW\*(C`$read = <STDIN>;\*(C'\fR.
.PP
The \s-1VMS\s0 operating system has two filesystems, known as \s-1ODS\-2\s0 and \s-1ODS\-5\s0.
.PP
For \s-1ODS\-2\s0, filenames are in the format \*(L"name.extension;version\*(R".  The
maximum length for filenames is 39 characters, and the maximum length for
extensions is also 39 characters.  Version is a number from 1 to
32767.  Valid characters are \f(CW\*(C`/[A\-Z0\-9$_\-]/\*(C'\fR.
.PP
The \s-1ODS\-2\s0 filesystem is case-insensitive and does not preserve case.
Perl simulates this by converting all filenames to lowercase internally.
.PP
For \s-1ODS\-5\s0, filenames may have almost any character in them and can include
Unicode characters.  Characters that could be misinterpreted by the \s-1DCL\s0
shell or file parsing utilities need to be prefixed with the \f(CW\*(C`^\*(C'\fR
character, or replaced with hexadecimal characters prefixed with the
\&\f(CW\*(C`^\*(C'\fR character.  Such prefixing is only needed with the pathnames are
in \s-1VMS\s0 format in applications.  Programs that can accept the Unix format
of pathnames do not need the escape characters.  The maximum length for
filenames is 255 characters.  The \s-1ODS\-5\s0 file system can handle both
a case preserved and a case sensitive mode.
.PP
\&\s-1ODS\-5\s0 is only available on the OpenVMS for 64 bit platforms.
.PP
Support for the extended file specifications is being done as optional
settings to preserve backward compatibility with Perl scripts that
assume the previous \s-1VMS\s0 limitations.
.PP
In general routines on \s-1VMS\s0 that get a Unix format file specification
should return it in a Unix format, and when they get a \s-1VMS\s0 format
specification they should return a \s-1VMS\s0 format unless they are documented
to do a conversion.
.PP
For routines that generate return a file specification, \s-1VMS\s0 allows setting
if the C library which Perl is built on if it will be returned in \s-1VMS\s0
format or in Unix format.
.PP
With the \s-1ODS\-2\s0 file system, there is not much difference in syntax of
filenames without paths for \s-1VMS\s0 or Unix.  With the extended character
set available with \s-1ODS\-5\s0 there can be a significant difference.
.PP
Because of this, existing Perl scripts written for \s-1VMS\s0 were sometimes
treating \s-1VMS\s0 and Unix filenames interchangeably.  Without the extended
character set enabled, this behavior will mostly be maintained for
backwards compatibility.
.PP
When extended characters are enabled with \s-1ODS\-5\s0, the handling of
Unix formatted file specifications is to that of a Unix system.
.PP
\&\s-1VMS\s0 file specifications without extensions have a trailing dot.  An
equivalent Unix file specification should not show the trailing dot.
.PP
The result of all of this, is that for \s-1VMS\s0, for portable scripts, you
can not depend on Perl to present the filenames in lowercase, to be
case sensitive, and that the filenames could be returned in either
Unix or \s-1VMS\s0 format.
.PP
And if a routine returns a file specification, unless it is intended to
convert it, it should return it in the same format as it found it.
.PP
\&\f(CW\*(C`readdir\*(C'\fR by default has traditionally returned lowercased filenames.
When the \s-1ODS\-5\s0 support is enabled, it will return the exact case of the
filename on the disk.
.PP
Files without extensions have a trailing period on them, so doing a
\&\f(CW\*(C`readdir\*(C'\fR in the default mode with a file named \fIA.;5\fR will
return \fIa.\fR when \s-1VMS\s0 is (though that file could be opened with
\&\f(CW\*(C`open(FH, \*(AqA\*(Aq)\*(C'\fR).
.PP
With support for extended file specifications and if \f(CW\*(C`opendir\*(C'\fR was
given a Unix format directory, a file named \fIA.;5\fR will return \fIa\fR
and optionally in the exact case on the disk.  When \f(CW\*(C`opendir\*(C'\fR is given
a \s-1VMS\s0 format directory, then \f(CW\*(C`readdir\*(C'\fR should return \fIa.\fR, and
again with the optionally the exact case.
.PP
\&\s-1RMS\s0 had an eight level limit on directory depths from any rooted logical
(allowing 16 levels overall) prior to \s-1VMS\s0 7.2, and even with versions of
\&\s-1VMS\s0 on \s-1VAX\s0 up through 7.3.  Hence \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8]\*(C'\fR is a
valid directory specification but \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8.9]\*(C'\fR is
not.  \fIMakefile.PL\fR authors might have to take this into account, but at
least they can refer to the former as \f(CW\*(C`/PERL_ROOT/lib/2/3/4/5/6/7/8/\*(C'\fR.
.PP
Pumpkings and module integrators can easily see whether files with too many
directory levels have snuck into the core by running the following in the
top-level source directory:
.PP
.Vb 1
\& $ perl \-ne "$_=~s/\es+.*//; print if scalar(split /\e//) > 8;" < MANIFEST
.Ve
.PP
The VMS::Filespec module, which gets installed as part of the build
process on \s-1VMS\s0, is a pure Perl module that can easily be installed on
non-VMS platforms and can be helpful for conversions to and from \s-1RMS\s0
native formats.  It is also now the only way that you should check to
see if \s-1VMS\s0 is in a case sensitive mode.
.PP
What \f(CW\*(C`\en\*(C'\fR represents depends on the type of file opened.  It usually
represents \f(CW\*(C`\e012\*(C'\fR but it could also be \f(CW\*(C`\e015\*(C'\fR, \f(CW\*(C`\e012\*(C'\fR, \f(CW\*(C`\e015\e012\*(C'\fR, 
\&\f(CW\*(C`\e000\*(C'\fR, \f(CW\*(C`\e040\*(C'\fR, or nothing depending on the file organization and 
record format.  The VMS::Stdio module provides access to the 
special \fIfopen()\fR requirements of files with unusual attributes on \s-1VMS\s0.
.PP
\&\s-1TCP/IP\s0 stacks are optional on \s-1VMS\s0, so socket routines might not be
implemented.  \s-1UDP\s0 sockets may not be supported.
.PP
The \s-1TCP/IP\s0 library support for all current versions of \s-1VMS\s0 is dynamically
loaded if present, so even if the routines are configured, they may
return a status indicating that they are not implemented.
.PP
The value of \f(CW$^O\fR on OpenVMS is \*(L"\s-1VMS\s0\*(R".  To determine the architecture
that you are running on without resorting to loading all of \f(CW%Config\fR
you can examine the content of the \f(CW@INC\fR array like so:
.PP
.Vb 2
\&    if (grep(/VMS_AXP/, @INC)) {
\&        print "I\*(Aqm on Alpha!\en";
\&
\&    } elsif (grep(/VMS_VAX/, @INC)) {
\&        print "I\*(Aqm on VAX!\en";
\&
\&    } elsif (grep(/VMS_IA64/, @INC)) {
\&        print "I\*(Aqm on IA64!\en";
\&
\&    } else {
\&        print "I\*(Aqm not so sure about where $^O is...\en";
\&    }
.Ve
.PP
In general, the significant differences should only be if Perl is running
on \s-1VMS_VAX\s0 or one of the 64 bit OpenVMS platforms.
.PP
On \s-1VMS\s0, perl determines the \s-1UTC\s0 offset from the \f(CW\*(C`SYS$TIMEZONE_DIFFERENTIAL\*(C'\fR
logical name.  Although the \s-1VMS\s0 epoch began at 17\-NOV\-1858 00:00:00.00,
calls to \f(CW\*(C`localtime\*(C'\fR are adjusted to count offsets from
01\-JAN\-1970 00:00:00.00, just like Unix.
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vms\fR (installed as \fIREADME_vms\fR), perlvms
.IP "\(bu" 4
vmsperl list, vmsperl\-subscribe@perl.org
.IP "\(bu" 4
vmsperl on the web, <http://www.sidhe.org/vmsperl/index.html>
.SS "\s-1VOS\s0"
.IX Subsection "VOS"
Perl on \s-1VOS\s0 (also known as OpenVOS) is discussed in \fI\s-1README\s0.vos\fR
in the perl distribution (installed as perlvos).  Perl on \s-1VOS\s0
can accept either \s-1VOS\-\s0 or Unix-style file specifications as in
either of the following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" >system>notices
\&    $ perl \-ne "print if /perl_setup/i" /system/notices
.Ve
.PP
or even a mixture of both as in:
.PP
.Vb 1
\&    $ perl \-ne "print if /perl_setup/i" >system/notices
.Ve
.PP
Even though \s-1VOS\s0 allows the slash character to appear in object
names, because the \s-1VOS\s0 port of Perl interprets it as a pathname
delimiting character, \s-1VOS\s0 files, directories, or links whose
names contain a slash character cannot be processed.  Such files
must be renamed before they can be processed by Perl.
.PP
Older releases of \s-1VOS\s0 (prior to OpenVOS Release 17.0) limit file
names to 32 or fewer characters, prohibit file names from
starting with a \f(CW\*(C`\-\*(C'\fR character, and prohibit file names from
containing any character matching \f(CW\*(C`tr/ !#%&\*(Aq()*;<=>?//\*(C'\fR.
.PP
Newer releases of \s-1VOS\s0 (OpenVOS Release 17.0 or later) support a
feature known as extended names.  On these releases, file names
can contain up to 255 characters, are prohibited from starting
with a \f(CW\*(C`\-\*(C'\fR character, and the set of prohibited characters is
reduced to any character matching \f(CW\*(C`tr/#%*<>?//\*(C'\fR.  There are
restrictions involving spaces and apostrophes:  these characters
must not begin or end a name, nor can they immediately precede or
follow a period.  Additionally, a space must not immediately
precede another space or hyphen.  Specifically, the following
character combinations are prohibited:  space-space,
space-hyphen, period-space, space-period, period-apostrophe,
apostrophe-period, leading or trailing space, and leading or
trailing apostrophe.  Although an extended file name is limited
to 255 characters, a path name is still limited to 256
characters.
.PP
The value of \f(CW$^O\fR on \s-1VOS\s0 is \*(L"\s-1VOS\s0\*(R".  To determine the
architecture that you are running on without resorting to loading
all of \f(CW%Config\fR you can examine the content of the \f(CW@INC\fR array
like so:
.PP
.Vb 6
\&    if ($^O =~ /VOS/) {
\&        print "I\*(Aqm on a Stratus box!\en";
\&    } else {
\&        print "I\*(Aqm not on a Stratus box!\en";
\&        die;
\&    }
.Ve
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vos\fR (installed as perlvos)
.IP "\(bu" 4
The \s-1VOS\s0 mailing list.
.Sp
There is no specific mailing list for Perl on \s-1VOS\s0.  You can post
comments to the comp.sys.stratus newsgroup, or use the contact
information located in the distribution files on the Stratus
Anonymous \s-1FTP\s0 site.
.IP "\(bu" 4
\&\s-1VOS\s0 Perl on the web at <http://ftp.stratus.com/pub/vos/posix/posix.html>
.SS "\s-1EBCDIC\s0 Platforms"
.IX Subsection "EBCDIC Platforms"
Recent versions of Perl have been ported to platforms such as \s-1OS/400\s0 on
\&\s-1AS/400\s0 minicomputers as well as \s-1OS/390\s0, \s-1VM/ESA\s0, and \s-1BS2000\s0 for S/390
Mainframes.  Such computers use \s-1EBCDIC\s0 character sets internally (usually
Character Code Set \s-1ID\s0 0037 for \s-1OS/400\s0 and either 1047 or POSIX-BC for S/390
systems).  On the mainframe perl currently works under the \*(L"Unix system
services for \s-1OS/390\s0\*(R" (formerly known as OpenEdition), \s-1VM/ESA\s0 OpenEdition, or
the \s-1BS200\s0 POSIX-BC system (\s-1BS2000\s0 is supported in perl 5.6 and greater).
See perlos390 for details.  Note that for \s-1OS/400\s0 there is also a port of
Perl 5.8.1/5.9.0 or later to the \s-1PASE\s0 which is ASCII-based (as opposed to
\&\s-1ILE\s0 which is EBCDIC-based), see perlos400.
.PP
As of R2.5 of \s-1USS\s0 for \s-1OS/390\s0 and Version 2.3 of \s-1VM/ESA\s0 these Unix
sub-systems do not support the \f(CW\*(C`#!\*(C'\fR shebang trick for script invocation.
Hence, on \s-1OS/390\s0 and \s-1VM/ESA\s0 perl scripts can be executed with a header
similar to the following simple script:
.PP
.Vb 4
\&    : # use perl
\&        eval \*(Aqexec /usr/local/bin/perl \-S $0 ${1+"$@"}\*(Aq
\&            if 0;
\&    #!/usr/local/bin/perl     # just a comment really
\&
\&    print "Hello from perl!\en";
.Ve
.PP
\&\s-1OS/390\s0 will support the \f(CW\*(C`#!\*(C'\fR shebang trick in release 2.8 and beyond.
Calls to \f(CW\*(C`system\*(C'\fR and backticks can use \s-1POSIX\s0 shell syntax on all
S/390 systems.
.PP
On the \s-1AS/400\s0, if \s-1PERL5\s0 is in your library list, you may need
to wrap your perl scripts in a \s-1CL\s0 procedure to invoke them like so:
.PP
.Vb 3
\&    BEGIN
\&      CALL PGM(PERL5/PERL) PARM(\*(Aq/QOpenSys/hello.pl\*(Aq)
\&    ENDPGM
.Ve
.PP
This will invoke the perl script \fIhello.pl\fR in the root of the
QOpenSys file system.  On the \s-1AS/400\s0 calls to \f(CW\*(C`system\*(C'\fR or backticks
must use \s-1CL\s0 syntax.
.PP
On these platforms, bear in mind that the \s-1EBCDIC\s0 character set may have
an effect on what happens with some perl functions (such as \f(CW\*(C`chr\*(C'\fR,
\&\f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR), as
well as bit-fiddling with \s-1ASCII\s0 constants using operators like \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`&\*(C'\fR
and \f(CW\*(C`|\*(C'\fR, not to mention dealing with socket interfaces to \s-1ASCII\s0 computers
(see \*(L"Newlines\*(R").
.PP
Fortunately, most web servers for the mainframe will correctly
translate the \f(CW\*(C`\en\*(C'\fR in the following statement to its \s-1ASCII\s0 equivalent
(\f(CW\*(C`\er\*(C'\fR is the same under both Unix and \s-1OS/390\s0 & \s-1VM/ESA\s0):
.PP
.Vb 1
\&    print "Content\-type: text/html\er\en\er\en";
.Ve
.PP
The values of \f(CW$^O\fR on some of these platforms includes:
.PP
.Vb 6
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    OS/390        os390      os390
\&    OS400         os400      os400
\&    POSIX\-BC      posix\-bc   BS2000\-posix\-bc
\&    VM/ESA        vmesa      vmesa
.Ve
.PP
Some simple tricks for determining if you are running on an \s-1EBCDIC\s0
platform could include any of the following (perhaps all):
.PP
.Vb 1
\&    if ("\et" eq "\e005")   { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (ord(\*(AqA\*(Aq) == 193) { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (chr(169) eq \*(Aqz\*(Aq) { print "EBCDIC may be spoken here!\en"; }
.Ve
.PP
One thing you may not want to rely on is the \s-1EBCDIC\s0 encoding
of punctuation characters since these may differ from code page to code
page (and once your module or script is rumoured to work with \s-1EBCDIC\s0,
folks will want it to work with all \s-1EBCDIC\s0 character sets).
.PP
Also see:
.IP "\(bu" 4
perlos390, \fI\s-1README\s0.os390\fR, \fIperlbs2000\fR, \fI\s-1README\s0.vmesa\fR,
perlebcdic.
.IP "\(bu" 4
The perl\-mvs@perl.org list is for discussion of porting issues as well as
general usage issues for all \s-1EBCDIC\s0 Perls.  Send a message body of
\&\*(L"subscribe perl-mvs\*(R" to majordomo@perl.org.
.IP "\(bu" 4
\&\s-1AS/400\s0 Perl information at
<http://as400.rochester.ibm.com/>
as well as on \s-1CPAN\s0 in the \fIports/\fR directory.
.SS "Acorn \s-1RISC\s0 \s-1OS\s0"
.IX Subsection "Acorn RISC OS"
Because Acorns use \s-1ASCII\s0 with newlines (\f(CW\*(C`\en\*(C'\fR) in text files as \f(CW\*(C`\e012\*(C'\fR like
Unix, and because Unix filename emulation is turned on by default, 
most simple scripts will probably work \*(L"out of the box\*(R".  The native
filesystem is modular, and individual filesystems are free to be
case-sensitive or insensitive, and are usually case-preserving.  Some
native filesystems have name length limits, which file and directory
names are silently truncated to fit.  Scripts should be aware that the
standard filesystem currently has a name length limit of \fB10\fR
characters, with up to 77 items in a directory, but other filesystems
may not impose such limitations.
.PP
Native filenames are of the form
.PP
.Vb 1
\&    Filesystem#Special_Field::DiskName.$.Directory.Directory.File
.Ve
.PP
where
.PP
.Vb 8
\&    Special_Field is not usually present, but may contain . and $ .
\&    Filesystem =~ m|[A\-Za\-z0\-9_]|
\&    DsicName   =~ m|[A\-Za\-z0\-9_/]|
\&    $ represents the root directory
\&    . is the path separator
\&    @ is the current directory (per filesystem but machine global)
\&    ^ is the parent directory
\&    Directory and File =~ m|[^\e0\- "\e.\e$\e%\e&:\e@\e\e^\e|\e177]+|
.Ve
.PP
The default filename translation is roughly \f(CW\*(C`tr|/.|./|;\*(C'\fR
.PP
Note that \f(CW\*(C`"ADFS::HardDisk.$.File" ne \*(AqADFS::HardDisk.$.File\*(Aq\*(C'\fR and that
the second stage of \f(CW\*(C`$\*(C'\fR interpolation in regular expressions will fall
foul of the \f(CW$.\fR if scripts are not careful.
.PP
Logical paths specified by system variables containing comma-separated
search lists are also allowed; hence \f(CW\*(C`System:Modules\*(C'\fR is a valid
filename, and the filesystem will prefix \f(CW\*(C`Modules\*(C'\fR with each section of
\&\f(CW\*(C`System$Path\*(C'\fR until a name is made that points to an object on disk.
Writing to a new file \f(CW\*(C`System:Modules\*(C'\fR would be allowed only if
\&\f(CW\*(C`System$Path\*(C'\fR contains a single item list.  The filesystem will also
expand system variables in filenames if enclosed in angle brackets, so
\&\f(CW\*(C`<System$Dir>.Modules\*(C'\fR would look for the file
\&\f(CW\*(C`$ENV{\*(AqSystem$Dir\*(Aq}\ .\ \*(AqModules\*(Aq\*(C'\fR.  The obvious implication of this is
that \fBfully qualified filenames can start with \f(CB\*(C`<>\*(C'\fB\fR and should
be protected when \f(CW\*(C`open\*(C'\fR is used for input.
.PP
Because \f(CW\*(C`.\*(C'\fR was in use as a directory separator and filenames could not
be assumed to be unique after 10 characters, Acorn implemented the C
compiler to strip the trailing \f(CW\*(C`.c\*(C'\fR \f(CW\*(C`.h\*(C'\fR \f(CW\*(C`.s\*(C'\fR and \f(CW\*(C`.o\*(C'\fR suffix from
filenames specified in source code and store the respective files in
subdirectories named after the suffix.  Hence files are translated:
.PP
.Vb 6
\&    foo.h           h.foo
\&    C:foo.h         C:h.foo        (logical path variable)
\&    sys/os.h        sys.h.os       (C compiler groks Unix\-speak)
\&    10charname.c    c.10charname
\&    10charname.o    o.10charname
\&    11charname_.c   c.11charname   (assuming filesystem truncates at 10)
.Ve
.PP
The Unix emulation library's translation of filenames to native assumes
that this sort of translation is required, and it allows a user-defined list
of known suffixes that it will transpose in this fashion.  This may
seem transparent, but consider that with these rules \fIfoo/bar/baz.h\fR
and \fIfoo/bar/h/baz\fR both map to \fIfoo.bar.h.baz\fR, and that \f(CW\*(C`readdir\*(C'\fR and
\&\f(CW\*(C`glob\*(C'\fR cannot and do not attempt to emulate the reverse mapping.  Other
\&\f(CW\*(C`.\*(C'\fR's in filenames are translated to \f(CW\*(C`/\*(C'\fR.
.PP
As implied above, the environment accessed through \f(CW%ENV\fR is global, and
the convention is that program specific environment variables are of the
form \f(CW\*(C`Program$Name\*(C'\fR.  Each filesystem maintains a current directory,
and the current filesystem's current directory is the \fBglobal\fR current
directory.  Consequently, sociable programs don't change the current
directory but rely on full pathnames, and programs (and Makefiles) cannot
assume that they can spawn a child process which can change the current
directory without affecting its parent (and everyone else for that
matter).
.PP
Because native operating system filehandles are global and are currently 
allocated down from 255, with 0 being a reserved value, the Unix emulation
library emulates Unix filehandles.  Consequently, you can't rely on
passing \f(CW\*(C`STDIN\*(C'\fR, \f(CW\*(C`STDOUT\*(C'\fR, or \f(CW\*(C`STDERR\*(C'\fR to your children.
.PP
The desire of users to express filenames of the form
\&\f(CW\*(C`<Foo$Dir>.Bar\*(C'\fR on the command line unquoted causes problems,
too: \f(CW\*(C`\`\`\*(C'\fR command output capture has to perform a guessing game.  It
assumes that a string \f(CW\*(C`<[^<>]+\e$[^<>]>\*(C'\fR is a
reference to an environment variable, whereas anything else involving
\&\f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR is redirection, and generally manages to be 99%
right.  Of course, the problem remains that scripts cannot rely on any
Unix tools being available, or that any tools found have Unix-like command
line arguments.
.PP
Extensions and \s-1XS\s0 are, in theory, buildable by anyone using free
tools.  In practice, many don't, as users of the Acorn platform are
used to binary distributions.  MakeMaker does run, but no available
make currently copes with MakeMaker's makefiles; even if and when
this should be fixed, the lack of a Unix-like shell will cause
problems with makefile rules, especially lines of the form \f(CW\*(C`cd
sdbm && make all\*(C'\fR, and anything using quoting.
.PP
\&\*(L"\s-1RISC\s0\ \s-1OS\s0\*(R" is the proper name for the operating system, but the value
in \f(CW$^O\fR is \*(L"riscos\*(R" (because we don't like shouting).
.SS "Other perls"
.IX Subsection "Other perls"
Perl has been ported to many platforms that do not fit into any of
the categories listed above.  Some, such as AmigaOS, BeOS, \s-1HP\s0 MPE/iX,
\&\s-1QNX\s0, Plan 9, and \s-1VOS\s0, have been well-integrated into the standard
Perl source code kit.  You may need to see the \fIports/\fR directory
on \s-1CPAN\s0 for information, and possibly binaries, for the likes of:
aos, Atari \s-1ST\s0, lynxos, riscos, Novell Netware, Tandem Guardian,
\&\fIetc.\fR  (Yes, we know that some of these OSes may fall under the
Unix category, but we are not a standards body.)
.PP
Some approximate operating system names and their \f(CW$^O\fR values
in the \*(L"\s-1OTHER\s0\*(R" category include:
.PP
.Vb 5
\&    OS            $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Amiga DOS     amigaos    m68k\-amigos
\&    BeOS          beos
\&    MPE/iX        mpeix      PA\-RISC1.1
.Ve
.PP
See also:
.IP "\(bu" 4
Amiga, \fI\s-1README\s0.amiga\fR (installed as perlamiga).
.IP "\(bu" 4
Be \s-1OS\s0, \fI\s-1README\s0.beos\fR
.IP "\(bu" 4
\&\s-1HP\s0 300 MPE/iX, \fI\s-1README\s0.mpeix\fR and Mark Bixby's web page
<http://www.bixby.org/mark/porting.html>
.IP "\(bu" 4
A free perl5\-based \s-1PERL\s0.NLM for Novell Netware is available in
precompiled binary and source code form from <http://www.novell.com/>
as well as from \s-1CPAN\s0.
.IP "\(bu" 4
Plan\ 9, \fI\s-1README\s0.plan9\fR
.SH "FUNCTION IMPLEMENTATIONS"
.IX Header "FUNCTION IMPLEMENTATIONS"
Listed below are functions that are either completely unimplemented
or else have been implemented differently on various platforms.
Following each description will be, in parentheses, a list of
platforms that the description applies to.
.PP
The list may well be incomplete, or even wrong in some places.  When
in doubt, consult the platform-specific \s-1README\s0 files in the Perl
source distribution, and any other documentation resources accompanying
a given port.
.PP
Be aware, moreover, that even among Unix-ish systems there are variations.
.PP
For many functions, you can also query \f(CW%Config\fR, exported by
default from the Config module.  For example, to check whether the
platform has the \f(CW\*(C`lstat\*(C'\fR call, check \f(CW$Config{d_lstat}\fR.  See
Config for a full description of available variables.
.SS "Alphabetical Listing of Perl Functions"
.IX Subsection "Alphabetical Listing of Perl Functions"
.IP "\-X" 8
.IX Item "-X"
\&\f(CW\*(C`\-w\*(C'\fR only inspects the read-only file attribute (\s-1FILE_ATTRIBUTE_READONLY\s0),
which determines whether the directory can be deleted, not whether it can
be written to. Directories always have read and write access unless denied
by discretionary access control lists (DACLs).  (Win32)
.Sp
\&\f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, and \f(CW\*(C`\-o\*(C'\fR tell whether the file is accessible,
which may not reflect UIC-based file protections.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-s\*(C'\fR by name on an open file will return the space reserved on disk,
rather than the current extent.  \f(CW\*(C`\-s\*(C'\fR on an open filehandle returns the
current size.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR, \f(CW\*(C`\-X\*(C'\fR, \f(CW\*(C`\-O\*(C'\fR are indistinguishable from \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR,
\&\f(CW\*(C`\-x\*(C'\fR, \f(CW\*(C`\-o\*(C'\fR. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-g\*(C'\fR, \f(CW\*(C`\-k\*(C'\fR, \f(CW\*(C`\-l\*(C'\fR, \f(CW\*(C`\-u\*(C'\fR, \f(CW\*(C`\-A\*(C'\fR are not particularly meaningful.
(Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-p\*(C'\fR is not particularly meaningful. (\s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-d\*(C'\fR is true if passed a device spec without an explicit directory.
(\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a file ends in one of the executable
suffixes.  \f(CW\*(C`\-S\*(C'\fR is meaningless.  (Win32)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a file has an executable file type.
(\s-1RISC\s0\ \s-1OS\s0)
.IP "alarm" 8
.IX Item "alarm"
Emulated using timers that must be explicitly polled whenever Perl
wants to dispatch \*(L"safe signals\*(R" and therefore cannot interrupt
blocking system calls.  (Win32)
.IP "atan2" 8
.IX Item "atan2"
Due to issues with various CPUs, math libraries, compilers, and standards,
results for \f(CW\*(C`atan2()\*(C'\fR may vary depending on any combination of the above.
Perl attempts to conform to the Open Group/IEEE standards for the results
returned from \f(CW\*(C`atan2()\*(C'\fR, but cannot force the issue if the system Perl is
run on does not allow it.  (Tru64, HP-UX 10.20)
.Sp
The current version of the standards for \f(CW\*(C`atan2()\*(C'\fR is available at 
<http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html>.
.IP "binmode" 8
.IX Item "binmode"
Meaningless.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Reopens file and restores pointer; if function fails, underlying
filehandle may be closed, or pointer may be in a different position.
(\s-1VMS\s0)
.Sp
The value returned by \f(CW\*(C`tell\*(C'\fR may be affected after the call, and
the filehandle may be flushed. (Win32)
.IP "chmod" 8
.IX Item "chmod"
Only good for changing \*(L"owner\*(R" read-write access, \*(L"group\*(R", and \*(L"other\*(R"
bits are meaningless. (Win32)
.Sp
Only good for changing \*(L"owner\*(R" and \*(L"other\*(R" read-write access. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Access permissions are mapped onto \s-1VOS\s0 access-control list changes. (\s-1VOS\s0)
.Sp
The actual permissions set depend on the value of the \f(CW\*(C`CYGWIN\*(C'\fR
in the \s-1SYSTEM\s0 environment settings.  (Cygwin)
.IP "chown" 8
.IX Item "chown"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Does nothing, but won't fail. (Win32)
.Sp
A little funky, because \s-1VOS\s0's notion of ownership is a little funky (\s-1VOS\s0).
.IP "chroot" 8
.IX Item "chroot"
Not implemented. (Win32, \s-1VMS\s0, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0, \s-1VM/ESA\s0)
.IP "crypt" 8
.IX Item "crypt"
May not be available if library or source was not provided when building
perl. (Win32)
.IP "dbmclose" 8
.IX Item "dbmclose"
Not implemented. (\s-1VMS\s0, Plan\ 9, \s-1VOS\s0)
.IP "dbmopen" 8
.IX Item "dbmopen"
Not implemented. (\s-1VMS\s0, Plan\ 9, \s-1VOS\s0)
.IP "dump" 8
.IX Item "dump"
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Not supported. (Cygwin, Win32)
.Sp
Invokes \s-1VMS\s0 debugger. (\s-1VMS\s0)
.IP "exec" 8
.IX Item "exec"
Implemented via Spawn. (\s-1VM/ESA\s0)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
Not supported. (Symbian \s-1OS\s0)
.IP "exit" 8
.IX Item "exit"
Emulates Unix \fIexit()\fR (which considers \f(CW\*(C`exit 1\*(C'\fR to indicate an error) by
mapping the \f(CW1\fR to \s-1SS$_ABORT\s0 (\f(CW44\fR).  This behavior may be overridden
with the pragma \f(CW\*(C`use vmsish \*(Aqexit\*(Aq\*(C'\fR.  As with the \s-1CRTL\s0's \fIexit()\fR
function, \f(CW\*(C`exit 0\*(C'\fR is also mapped to an exit status of \s-1SS$_NORMAL\s0
(\f(CW1\fR); this mapping cannot be overridden.  Any other argument to \fIexit()\fR
is used directly as Perl's exit status.  On \s-1VMS\s0, unless the future
\&\s-1POSIX_EXIT\s0 mode is enabled, the exit code should always be a valid
\&\s-1VMS\s0 exit code and not a generic number.  When the \s-1POSIX_EXIT\s0 mode is
enabled, a generic number will be encoded in a method compatible with
the C library _POSIX_EXIT macro so that it can be decoded by other
programs, particularly ones written in C, like the \s-1GNV\s0 package.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`exit()\*(C'\fR resets file pointers, which is a problem when called 
from a child process (created by \f(CW\*(C`fork()\*(C'\fR) in \f(CW\*(C`BEGIN\*(C'\fR.  
A workaround is to use \f(CW\*(C`POSIX::_exit\*(C'\fR.  (Solaris)
.Sp
.Vb 2
\&    exit unless $Config{archname} =~ /\ebsolaris\eb/;
\&    require POSIX and POSIX::_exit(0);
.Ve
.IP "fcntl" 8
.IX Item "fcntl"
Not implemented. (Win32)
.Sp
Some functions available based on the version of \s-1VMS\s0. (\s-1VMS\s0)
.IP "flock" 8
.IX Item "flock"
Not implemented (\s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0).
.IP "fork" 8
.IX Item "fork"
Not implemented. (AmigaOS, \s-1RISC\s0\ \s-1OS\s0, \s-1VM/ESA\s0, \s-1VMS\s0)
.Sp
Emulated using multiple interpreters.  See perlfork.  (Win32)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.IP "getlogin" 8
.IX Item "getlogin"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getpgrp" 8
.IX Item "getpgrp"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.IP "getppid" 8
.IX Item "getppid"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "getpriority" 8
.IX Item "getpriority"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0, \s-1VM/ESA\s0)
.IP "getpwnam" 8
.IX Item "getpwnam"
Not implemented. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrnam" 8
.IX Item "getgrnam"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.IP "getnetbyname" 8
.IX Item "getnetbyname"
Not implemented. (Win32, Plan\ 9)
.IP "getpwuid" 8
.IX Item "getpwuid"
Not implemented. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrgid" 8
.IX Item "getgrgid"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.IP "getnetbyaddr" 8
.IX Item "getnetbyaddr"
Not implemented. (Win32, Plan\ 9)
.IP "getprotobynumber" 8
.IX Item "getprotobynumber"
.PD 0
.IP "getservbyport" 8
.IX Item "getservbyport"
.IP "getpwent" 8
.IX Item "getpwent"
.PD
Not implemented. (Win32, \s-1VM/ESA\s0)
.IP "getgrent" 8
.IX Item "getgrent"
Not implemented. (Win32, \s-1VMS\s0, \s-1VM/ESA\s0)
.IP "gethostbyname" 8
.IX Item "gethostbyname"
\&\f(CW\*(C`gethostbyname(\*(Aqlocalhost\*(Aq)\*(C'\fR does not work everywhere: you may have
to use \f(CW\*(C`gethostbyname(\*(Aq127.0.0.1\*(Aq)\*(C'\fR. (Irix\ 5)
.IP "gethostent" 8
.IX Item "gethostent"
Not implemented. (Win32)
.IP "getnetent" 8
.IX Item "getnetent"
Not implemented. (Win32, Plan\ 9)
.IP "getprotoent" 8
.IX Item "getprotoent"
Not implemented. (Win32, Plan\ 9)
.IP "getservent" 8
.IX Item "getservent"
Not implemented. (Win32, Plan\ 9)
.IP "sethostent" 8
.IX Item "sethostent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setnetent" 8
.IX Item "setnetent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setprotoent" 8
.IX Item "setprotoent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setservent" 8
.IX Item "setservent"
Not implemented. (Plan\ 9, Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "endpwent" 8
.IX Item "endpwent"
Not implemented. (MPE/iX, \s-1VM/ESA\s0, Win32)
.IP "endgrent" 8
.IX Item "endgrent"
Not implemented. (MPE/iX, \s-1RISC\s0\ \s-1OS\s0, \s-1VM/ESA\s0, \s-1VMS\s0, Win32)
.IP "endhostent" 8
.IX Item "endhostent"
Not implemented. (Win32)
.IP "endnetent" 8
.IX Item "endnetent"
Not implemented. (Win32, Plan\ 9)
.IP "endprotoent" 8
.IX Item "endprotoent"
Not implemented. (Win32, Plan\ 9)
.IP "endservent" 8
.IX Item "endservent"
Not implemented. (Plan\ 9, Win32)
.IP "getsockopt \s-1SOCKET\s0,LEVEL,OPTNAME" 8
.IX Item "getsockopt SOCKET,LEVEL,OPTNAME"
Not implemented. (Plan\ 9)
.IP "glob" 8
.IX Item "glob"
This operator is implemented via the File::Glob extension on most
platforms.  See File::Glob for portability information.
.IP "gmtime" 8
.IX Item "gmtime"
In theory, \fIgmtime()\fR is reliable from \-2**63 to 2**63\-1.  However,
because work arounds in the implementation use floating point numbers,
it will become inaccurate as the time gets larger.  This is a bug and
will be fixed in the future.
.Sp
On \s-1VOS\s0, time values are 32\-bit quantities.
.IP "ioctl \s-1FILEHANDLE\s0,FUNCTION,SCALAR" 8
.IX Item "ioctl FILEHANDLE,FUNCTION,SCALAR"
Not implemented. (\s-1VMS\s0)
.Sp
Available only for socket handles, and it does what the \fIioctlsocket()\fR call
in the Winsock \s-1API\s0 does. (Win32)
.Sp
Available only for socket handles. (\s-1RISC\s0\ \s-1OS\s0)
.IP "kill" 8
.IX Item "kill"
Not implemented, hence not useful for taint checking. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`kill()\*(C'\fR doesn't have the semantics of \f(CW\*(C`raise()\*(C'\fR, i.e. it doesn't send
a signal to the identified process like it does on Unix platforms.
Instead \f(CW\*(C`kill($sig, $pid)\*(C'\fR terminates the process identified by \f(CW$pid\fR,
and makes it exit immediately with exit status \f(CW$sig\fR.  As in Unix, if
\&\f(CW$sig\fR is 0 and the specified process exists, it returns true without
actually terminating it. (Win32)
.Sp
\&\f(CW\*(C`kill(\-9, $pid)\*(C'\fR will terminate the process specified by \f(CW$pid\fR and
recursively all child processes owned by it.  This is different from
the Unix semantics, where the signal will be delivered to all
processes in the same process group as the process specified by
\&\f(CW$pid\fR. (Win32)
.Sp
Is not supported for process identification number of 0 or negative
numbers. (\s-1VMS\s0)
.IP "link" 8
.IX Item "link"
Not implemented. (MPE/iX, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0)
.Sp
Link count not updated because hard links are not quite that hard
(They are sort of half-way between hard and soft links). (AmigaOS)
.Sp
Hard links are implemented on Win32 under \s-1NTFS\s0 only. They are
natively supported on Windows 2000 and later.  On Windows \s-1NT\s0 they
are implemented using the Windows \s-1POSIX\s0 subsystem support and the
Perl process will need Administrator or Backup Operator privileges
to create hard links.
.Sp
Available on 64 bit OpenVMS 8.2 and later.  (\s-1VMS\s0)
.IP "localtime" 8
.IX Item "localtime"
\&\fIlocaltime()\fR has the same range as \*(L"gmtime\*(R", but because time zone
rules change its accuracy for historical and future times may degrade
but usually by no more than an hour.
.IP "lstat" 8
.IX Item "lstat"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Return values (especially for device and inode) may be bogus. (Win32)
.IP "msgctl" 8
.IX Item "msgctl"
.PD 0
.IP "msgget" 8
.IX Item "msgget"
.IP "msgsnd" 8
.IX Item "msgsnd"
.IP "msgrcv" 8
.IX Item "msgrcv"
.PD
Not implemented. (Win32, \s-1VMS\s0, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0)
.IP "open" 8
.IX Item "open"
open to \f(CW\*(C`|\-\*(C'\fR and \f(CW\*(C`\-|\*(C'\fR are unsupported. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Opening a process does not automatically flush output handles on some
platforms.  (SunOS, Solaris, HP-UX)
.IP "readlink" 8
.IX Item "readlink"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.IP "rename" 8
.IX Item "rename"
Can't move directories between directories on different logical volumes. (Win32)
.IP "rewinddir" 8
.IX Item "rewinddir"
Will not cause \fIreaddir()\fR to re-read the directory stream.  The entries
already read before the \fIrewinddir()\fR call will just be returned again
from a cache buffer. (Win32)
.IP "select" 8
.IX Item "select"
Only implemented on sockets. (Win32, \s-1VMS\s0)
.Sp
Only reliable on sockets. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Note that the \f(CW\*(C`select FILEHANDLE\*(C'\fR form is generally portable.
.IP "semctl" 8
.IX Item "semctl"
.PD 0
.IP "semget" 8
.IX Item "semget"
.IP "semop" 8
.IX Item "semop"
.PD
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.IP "setgrent" 8
.IX Item "setgrent"
Not implemented. (MPE/iX, \s-1VMS\s0, Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setpgrp" 8
.IX Item "setpgrp"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0)
.IP "setpriority" 8
.IX Item "setpriority"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0)
.IP "setpwent" 8
.IX Item "setpwent"
Not implemented. (MPE/iX, Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setsockopt" 8
.IX Item "setsockopt"
Not implemented. (Plan\ 9)
.IP "shmctl" 8
.IX Item "shmctl"
.PD 0
.IP "shmget" 8
.IX Item "shmget"
.IP "shmread" 8
.IX Item "shmread"
.IP "shmwrite" 8
.IX Item "shmwrite"
.PD
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0)
.IP "sockatmark" 8
.IX Item "sockatmark"
A relatively recent addition to socket functions, may not
be implemented even in Unix platforms.
.IP "socketpair" 8
.IX Item "socketpair"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0, \s-1VM/ESA\s0)
.Sp
Available on OpenVOS Release 17.0 or later. (\s-1VOS\s0)
.Sp
Available on 64 bit OpenVMS 8.2 and later.  (\s-1VMS\s0)
.IP "stat" 8
.IX Item "stat"
Platforms that do not have rdev, blksize, or blocks will return these
as '', so numeric comparison or manipulation of these fields may cause
\&'not numeric' warnings.
.Sp
ctime not supported on \s-1UFS\s0 (Mac\ \s-1OS\s0\ X).
.Sp
ctime is creation time instead of inode change time  (Win32).
.Sp
device and inode are not meaningful.  (Win32)
.Sp
device and inode are not necessarily reliable.  (\s-1VMS\s0)
.Sp
mtime, atime and ctime all return the last modification time.  Device and
inode are not necessarily reliable.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
dev, rdev, blksize, and blocks are not available.  inode is not
meaningful and will differ between stat calls on the same file.  (os2)
.Sp
some versions of cygwin when doing a stat(\*(L"foo\*(R") and if not finding it
may then attempt to stat(\*(L"foo.exe\*(R") (Cygwin)
.Sp
On Win32 \fIstat()\fR needs to open the file to determine the link count
and update attributes that may have been changed through hard links.
Setting ${^WIN32_SLOPPY_STAT} to a true value speeds up \fIstat()\fR by
not performing this operation. (Win32)
.IP "symlink" 8
.IX Item "symlink"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Implemented on 64 bit \s-1VMS\s0 8.3.  \s-1VMS\s0 requires the symbolic link to be in Unix
syntax if it is intended to resolve to a valid path.
.IP "syscall" 8
.IX Item "syscall"
Not implemented. (Win32, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0, \s-1VOS\s0, \s-1VM/ESA\s0)
.IP "sysopen" 8
.IX Item "sysopen"
The traditional \*(L"0\*(R", \*(L"1\*(R", and \*(L"2\*(R" MODEs are implemented with different
numeric values on some systems.  The flags exported by \f(CW\*(C`Fcntl\*(C'\fR
(O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though.  (Mac\ \s-1OS\s0, \s-1OS/390\s0, \s-1VM/ESA\s0)
.IP "system" 8
.IX Item "system"
As an optimization, may not call the command shell specified in
\&\f(CW$ENV{PERL5SHELL}\fR.  \f(CW\*(C`system(1, @args)\*(C'\fR spawns an external
process and immediately returns its process designator, without
waiting for it to terminate.  Return value may be used subsequently
in \f(CW\*(C`wait\*(C'\fR or \f(CW\*(C`waitpid\*(C'\fR.  Failure to \fIspawn()\fR a subprocess is indicated
by setting $? to \*(L"255 << 8\*(R".  \f(CW$?\fR is set in a way compatible with
Unix (i.e. the exitstatus of the subprocess is obtained by \*(L"$? >> 8\*(R",
as described in the documentation).  (Win32)
.Sp
There is no shell to process metacharacters, and the native standard is
to pass a command line terminated by \*(L"\en\*(R" \*(L"\er\*(R" or \*(L"\e0\*(R" to the spawned
program.  Redirection such as \f(CW\*(C`> foo\*(C'\fR is performed (if at all) by
the run time library of the spawned program.  \f(CW\*(C`system\*(C'\fR \fIlist\fR will call
the Unix emulation library's \f(CW\*(C`exec\*(C'\fR emulation, which attempts to provide
emulation of the stdin, stdout, stderr in force in the parent, providing
the child program uses a compatible version of the emulation library.
\&\fIscalar\fR will call the native command line direct and no such emulation
of a child Unix program will exists.  Mileage \fBwill\fR vary.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
The return value is POSIX-like (shifted up by 8 bits), which only allows
room for a made-up value derived from the severity bits of the native
32\-bit condition code (unless overridden by \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR). 
If the native condition code is one that has a \s-1POSIX\s0 value encoded, the
\&\s-1POSIX\s0 value will be decoded to extract the expected exit value.
For more details see \*(L"$?\*(R" in perlvms. (\s-1VMS\s0)
.IP "times" 8
.IX Item "times"
\&\*(L"cumulative\*(R" times will be bogus.  On anything other than Windows \s-1NT\s0
or Windows 2000, \*(L"system\*(R" time will be bogus, and \*(L"user\*(R" time is
actually the time returned by the \fIclock()\fR function in the C runtime
library. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "truncate" 8
.IX Item "truncate"
Not implemented. (Older versions of \s-1VMS\s0)
.Sp
Truncation to same-or-shorter lengths only. (\s-1VOS\s0)
.Sp
If a \s-1FILEHANDLE\s0 is supplied, it must be writable and opened in append
mode (i.e., use \f(CW\*(C`open(FH, \*(Aq>>filename\*(Aq)\*(C'\fR
or \f(CW\*(C`sysopen(FH,...,O_APPEND|O_RDWR)\*(C'\fR.  If a filename is supplied, it
should not be held open elsewhere. (Win32)
.IP "umask" 8
.IX Item "umask"
Returns undef where unavailable, as of version 5.005.
.Sp
\&\f(CW\*(C`umask\*(C'\fR works but the correct permissions are set only when the file
is finally closed. (AmigaOS)
.IP "utime" 8
.IX Item "utime"
Only the modification time is updated. (BeOS, \s-1VMS\s0, \s-1RISC\s0\ \s-1OS\s0)
.Sp
May not behave as expected.  Behavior depends on the C runtime
library's implementation of \fIutime()\fR, and the filesystem being
used.  The \s-1FAT\s0 filesystem typically does not support an \*(L"access
time\*(R" field, and it may limit timestamps to a granularity of
two seconds. (Win32)
.IP "wait" 8
.IX Item "wait"
.PD 0
.IP "waitpid" 8
.IX Item "waitpid"
.PD
Can only be applied to process handles returned for processes spawned
using \f(CW\*(C`system(1, ...)\*(C'\fR or pseudo processes created with \f(CW\*(C`fork()\*(C'\fR. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.SH "Supported Platforms"
.IX Header "Supported Platforms"
The following platforms are known to build Perl 5.12 (as of April 2010,
its release date) from the standard source code distribution available
at <http://www.cpan.org/src>
.IP "Linux (x86, \s-1ARM\s0, \s-1IA64\s0)" 4
.IX Item "Linux (x86, ARM, IA64)"
.PD 0
.IP "HP-UX" 4
.IX Item "HP-UX"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.IP "Win32" 4
.IX Item "Win32"
.RS 4
.IP "Windows 2000" 4
.IX Item "Windows 2000"
.IP "Windows \s-1XP\s0" 4
.IX Item "Windows XP"
.IP "Windows Server 2003" 4
.IX Item "Windows Server 2003"
.IP "Windows Vista" 4
.IX Item "Windows Vista"
.IP "Windows Server 2008" 4
.IX Item "Windows Server 2008"
.IP "Windows 7" 4
.IX Item "Windows 7"
.RE
.RS 4
.RE
.IP "Cygwin" 4
.IX Item "Cygwin"
.IP "Solaris (x86, \s-1SPARC\s0)" 4
.IX Item "Solaris (x86, SPARC)"
.IP "OpenVMS" 4
.IX Item "OpenVMS"
.RS 4
.IP "Alpha (7.2 and later)" 4
.IX Item "Alpha (7.2 and later)"
.IP "I64 (8.2 and later)" 4
.IX Item "I64 (8.2 and later)"
.RE
.RS 4
.RE
.IP "Symbian" 4
.IX Item "Symbian"
.IP "NetBSD" 4
.IX Item "NetBSD"
.IP "FreeBSD" 4
.IX Item "FreeBSD"
.IP "Debian GNU/kFreeBSD" 4
.IX Item "Debian GNU/kFreeBSD"
.IP "Haiku" 4
.IX Item "Haiku"
.IP "Irix (6.5. What else?)" 4
.IX Item "Irix (6.5. What else?)"
.IP "OpenBSD" 4
.IX Item "OpenBSD"
.IP "Dragonfly \s-1BSD\s0" 4
.IX Item "Dragonfly BSD"
.IP "\s-1QNX\s0 Neutrino \s-1RTOS\s0 (6.5.0)" 4
.IX Item "QNX Neutrino RTOS (6.5.0)"
.IP "MirOS \s-1BSD\s0" 4
.IX Item "MirOS BSD"
.PD
Caveats:
.RS 4
.IP "time_t issues that may or may not be fixed" 4
.IX Item "time_t issues that may or may not be fixed"
.RE
.RS 4
.RE
.PD 0
.IP "Symbian (Series 60 v3, 3.2 and 5 \- what else?)" 4
.IX Item "Symbian (Series 60 v3, 3.2 and 5 - what else?)"
.IP "Stratus \s-1VOS\s0 / OpenVOS" 4
.IX Item "Stratus VOS / OpenVOS"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.PD
.SH "EOL Platforms (Perl 5.14)"
.IX Header "EOL Platforms (Perl 5.14)"
The following platforms were supported by a previous version of
Perl but have been officially removed from Perl's source code
as of 5.12:
.IP "Atari MiNT" 4
.IX Item "Atari MiNT"
.PD 0
.IP "Apollo Domain/OS" 4
.IX Item "Apollo Domain/OS"
.IP "Apple Mac \s-1OS\s0 8/9" 4
.IX Item "Apple Mac OS 8/9"
.IP "Tenon Machten" 4
.IX Item "Tenon Machten"
.PD
.PP
The following platforms were supported up to 5.10.  They may still
have worked in 5.12, but supporting code has been removed for 5.14:
.IP "Windows 95" 4
.IX Item "Windows 95"
.PD 0
.IP "Windows 98" 4
.IX Item "Windows 98"
.IP "Windows \s-1ME\s0" 4
.IX Item "Windows ME"
.IP "Windows \s-1NT4\s0" 4
.IX Item "Windows NT4"
.PD
.SH "Supported Platforms (Perl 5.8)"
.IX Header "Supported Platforms (Perl 5.8)"
As of July 2002 (the Perl release 5.8.0), the following platforms were
able to build Perl from the standard source code distribution
available at <http://www.cpan.org/src/>
.PP
.Vb 10
\&        AIX
\&        BeOS
\&        BSD/OS          (BSDi)
\&        Cygwin
\&        DG/UX
\&        DOS DJGPP       1)
\&        DYNIX/ptx
\&        EPOC R5
\&        FreeBSD
\&        HI\-UXMPP        (Hitachi) (5.8.0 worked but we didn\*(Aqt know it)
\&        HP\-UX
\&        IRIX
\&        Linux
\&        Mac OS Classic
\&        Mac OS X        (Darwin)
\&        MPE/iX
\&        NetBSD
\&        NetWare
\&        NonStop\-UX
\&        ReliantUNIX     (formerly SINIX)
\&        OpenBSD
\&        OpenVMS         (formerly VMS)
\&        Open UNIX       (Unixware) (since Perl 5.8.1/5.9.0)
\&        OS/2
\&        OS/400          (using the PASE) (since Perl 5.8.1/5.9.0)
\&        PowerUX
\&        POSIX\-BC        (formerly BS2000)
\&        QNX
\&        Solaris
\&        SunOS 4
\&        SUPER\-UX        (NEC)
\&        Tru64 UNIX      (formerly DEC OSF/1, Digital UNIX)
\&        UNICOS
\&        UNICOS/mk
\&        UTS
\&        VOS
\&        Win95/98/ME/2K/XP 2)
\&        WinCE
\&        z/OS            (formerly OS/390)
\&        VM/ESA
\&
\&        1) in DOS mode either the DOS or OS/2 ports can be used
\&        2) compilers: Borland, MinGW (GCC), VC6
.Ve
.PP
The following platforms worked with the previous releases (5.6 and
5.7), but we did not manage either to fix or to test these in time
for the 5.8.0 release.  There is a very good chance that many of these
will work fine with the 5.8.0.
.PP
.Vb 10
\&        BSD/OS
\&        DomainOS
\&        Hurd
\&        LynxOS
\&        MachTen
\&        PowerMAX
\&        SCO SV
\&        SVR4
\&        Unixware
\&        Windows 3.1
.Ve
.PP
Known to be broken for 5.8.0 (but 5.6.1 and 5.7.2 can be used):
.PP
.Vb 1
\&        AmigaOS
.Ve
.PP
The following platforms have been known to build Perl from source in
the past (5.005_03 and earlier), but we haven't been able to verify
their status for the current release, either because the
hardware/software platforms are rare or because we don't have an
active champion on these platforms\*(--or both.  They used to work,
though, so go ahead and try compiling them, and let perlbug@perl.org
of any trouble.
.PP
.Vb 10
\&        3b1
\&        A/UX
\&        ConvexOS
\&        CX/UX
\&        DC/OSx
\&        DDE SMES
\&        DOS EMX
\&        Dynix
\&        EP/IX
\&        ESIX
\&        FPS
\&        GENIX
\&        Greenhills
\&        ISC
\&        MachTen 68k
\&        MPC
\&        NEWS\-OS
\&        NextSTEP
\&        OpenSTEP
\&        Opus
\&        Plan 9
\&        RISC/os
\&        SCO ODT/OSR
\&        Stellar
\&        SVR2
\&        TI1500
\&        TitanOS
\&        Ultrix
\&        Unisys Dynix
.Ve
.PP
The following platforms have their own source code distributions and
binaries available via <http://www.cpan.org/ports/>
.PP
.Vb 1
\&                                Perl release
\&
\&        OS/400 (ILE)            5.005_02
\&        Tandem Guardian         5.004
.Ve
.PP
The following platforms have only binaries available via
<http://www.cpan.org/ports/index.html> :
.PP
.Vb 1
\&                                Perl release
\&
\&        Acorn RISCOS            5.005_02
\&        AOS                     5.002
\&        LynxOS                  5.004_02
.Ve
.PP
Although we do suggest that you always build your own Perl from
the source code, both for maximal configurability and for security,
in case you are in a hurry you can check
<http://www.cpan.org/ports/index.html> for binary distributions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlaix, perlamiga, perlbeos, perlbs2000,
perlce, perlcygwin, perldgux, perldos, perlepoc,
perlebcdic, perlfreebsd, perlhurd, perlhpux, perlirix,
perlmacos, perlmacosx, perlmpeix,
perlnetware, perlos2, perlos390, perlos400,
perlplan9, perlqnx, perlsolaris, perltru64,
perlunicode, perlvmesa, perlvms, perlvos,
perlwin32, and Win32.
.SH "AUTHORS / CONTRIBUTORS"
.IX Header "AUTHORS / CONTRIBUTORS"
Abigail <abigail@foad.org>,
Charles Bailey <bailey@newman.upenn.edu>,
Graham Barr <gbarr@pobox.com>,
Tom Christiansen <tchrist@perl.com>,
Nicholas Clark <nick@ccl4.org>,
Thomas Dorner <Thomas.Dorner@start.de>,
Andy Dougherty <doughera@lafayette.edu>,
Dominic Dunlop <domo@computer.org>,
Neale Ferguson <neale@vma.tabnsw.com.au>,
David J. Fiander <davidf@mks.com>,
Paul Green <Paul.Green@stratus.com>,
M.J.T. Guy <mjtg@cam.ac.uk>,
Jarkko Hietaniemi <jhi@iki.fi>,
Luther Huffman <lutherh@stratcom.com>,
Nick Ing-Simmons <nick@ing\-simmons.net>,
Andreas J. Ko\*:nig <a.koenig@mind.de>,
Markus Laker <mlaker@contax.co.uk>,
Andrew M. Langmead <aml@world.std.com>,
Larry Moore <ljmoore@freespace.net>,
Paul Moore <Paul.Moore@uk.origin\-it.com>,
Chris Nandor <pudge@pobox.com>,
Matthias Neeracher <neeracher@mac.com>,
Philip Newton <pne@cpan.org>,
Gary Ng <71564.1743@CompuServe.COM>,
Tom Phoenix <rootbeer@teleport.com>,
Andre\*' Pirard <A.Pirard@ulg.ac.be>,
Peter Prymmer <pvhp@forte.com>,
Hugo van der Sanden <hv@crypt0.demon.co.uk>,
Gurusamy Sarathy <gsar@activestate.com>,
Paul J. Schinder <schinder@pobox.com>,
Michael G Schwern <schwern@pobox.com>,
Dan Sugalski <dan@sidhe.org>,
Nathan Torkington <gnat@frii.com>,
John Malmberg <wb8tyw@qsl.net>
                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlport5.18.1                               0100644 0001750 0001750 00000311212 12566207443 023124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPORT 1"
.TH PERLPORT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlport \- Writing portable Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl runs on numerous operating systems.  While most of them share
much in common, they also have their own unique features.
.PP
This document is meant to help you to find out what constitutes portable
Perl code.  That way once you make a decision to write portably,
you know where the lines are drawn, and you can stay within them.
.PP
There is a tradeoff between taking full advantage of one particular
type of computer and taking advantage of a full range of them.
Naturally, as you broaden your range and become more diverse, the
common factors drop, and you are left with an increasingly smaller
area of common ground in which you can operate to accomplish a
particular task.  Thus, when you begin attacking a problem, it is
important to consider under which part of the tradeoff curve you
want to operate.  Specifically, you must decide whether it is
important that the task that you are coding have the full generality
of being portable, or whether to just get the job done right now.
This is the hardest choice to be made.  The rest is easy, because
Perl provides many choices, whichever way you want to approach your
problem.
.PP
Looking at it another way, writing portable code is usually about
willfully limiting your available choices.  Naturally, it takes
discipline and sacrifice to do that.  The product of portability
and convenience may be a constant.  You have been warned.
.PP
Be aware of two important points:
.IP "Not all Perl programs have to be portable" 4
.IX Item "Not all Perl programs have to be portable"
There is no reason you should not use Perl as a language to glue Unix
tools together, or to prototype a Macintosh application, or to manage the
Windows registry.  If it makes no sense to aim for portability for one
reason or another in a given program, then don't bother.
.IP "Nearly all of Perl already \fIis\fR portable" 4
.IX Item "Nearly all of Perl already is portable"
Don't be fooled into thinking that it is hard to create portable Perl
code.  It isn't.  Perl tries its level-best to bridge the gaps between
what's available on different platforms, and all the means available to
use those features.  Thus almost all Perl code runs on any machine
without modification.  But there are some significant issues in
writing portable code, and this document is entirely about those issues.
.PP
Here's the general rule: When you approach a task commonly done
using a whole range of platforms, think about writing portable
code.  That way, you don't sacrifice much by way of the implementation
choices you can avail yourself of, and at the same time you can give
your users lots of platform choices.  On the other hand, when you have to
take advantage of some unique feature of a particular platform, as is
often the case with systems programming (whether for Unix, Windows,
\&\s-1VMS,\s0 etc.), consider writing platform-specific code.
.PP
When the code will run on only two or three operating systems, you
may need to consider only the differences of those particular systems.
The important thing is to decide where the code will run and to be
deliberate in your decision.
.PP
The material below is separated into three main sections: main issues of
portability (\*(L"\s-1ISSUES\*(R"\s0), platform-specific issues (\*(L"\s-1PLATFORMS\*(R"\s0), and
built-in perl functions that behave differently on various ports
(\*(L"\s-1FUNCTION IMPLEMENTATIONS\*(R"\s0).
.PP
This information should not be considered complete; it includes possibly
transient information about idiosyncrasies of some of the ports, almost
all of which are in a state of constant evolution.  Thus, this material
should be considered a perpetual work in progress
(\f(CW\*(C`<IMG SRC="yellow_sign.gif" ALT="Under Construction">\*(C'\fR).
.SH "ISSUES"
.IX Header "ISSUES"
.SS "Newlines"
.IX Subsection "Newlines"
In most operating systems, lines in files are terminated by newlines.
Just what is used as a newline may vary from \s-1OS\s0 to \s-1OS. \s0 Unix
traditionally uses \f(CW\*(C`\e012\*(C'\fR, one type of DOSish I/O uses \f(CW\*(C`\e015\e012\*(C'\fR,
and Mac\ \s-1OS\s0 uses \f(CW\*(C`\e015\*(C'\fR.
.PP
Perl uses \f(CW\*(C`\en\*(C'\fR to represent the \*(L"logical\*(R" newline, where what is
logical may depend on the platform in use.  In MacPerl, \f(CW\*(C`\en\*(C'\fR always
means \f(CW\*(C`\e015\*(C'\fR.  In DOSish perls, \f(CW\*(C`\en\*(C'\fR usually means \f(CW\*(C`\e012\*(C'\fR, but when
accessing a file in \*(L"text\*(R" mode, perl uses the \f(CW\*(C`:crlf\*(C'\fR layer that
translates it to (or from) \f(CW\*(C`\e015\e012\*(C'\fR, depending on whether you're
reading or writing. Unix does the same thing on ttys in canonical
mode.  \f(CW\*(C`\e015\e012\*(C'\fR is commonly referred to as \s-1CRLF.\s0
.PP
To trim trailing newlines from text lines use \fIchomp()\fR.  With default 
settings that function looks for a trailing \f(CW\*(C`\en\*(C'\fR character and thus 
trims in a portable way.
.PP
When dealing with binary files (or text files in binary mode) be sure
to explicitly set $/ to the appropriate value for your file format
before using \fIchomp()\fR.
.PP
Because of the \*(L"text\*(R" mode translation, DOSish perls have limitations
in using \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR on a file accessed in \*(L"text\*(R" mode.
Stick to \f(CW\*(C`seek\*(C'\fR\-ing to locations you got from \f(CW\*(C`tell\*(C'\fR (and no
others), and you are usually free to use \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR even
in \*(L"text\*(R" mode.  Using \f(CW\*(C`seek\*(C'\fR or \f(CW\*(C`tell\*(C'\fR or other file operations
may be non-portable.  If you use \f(CW\*(C`binmode\*(C'\fR on a file, however, you
can usually \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`tell\*(C'\fR with arbitrary values in safety.
.PP
A common misconception in socket programming is that \f(CW\*(C`\en\*(C'\fR eq \f(CW\*(C`\e012\*(C'\fR
everywhere.  When using protocols such as common Internet protocols,
\&\f(CW\*(C`\e012\*(C'\fR and \f(CW\*(C`\e015\*(C'\fR are called for specifically, and the values of
the logical \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR (carriage return) are not reliable.
.PP
.Vb 2
\&    print SOCKET "Hi there, client!\er\en";      # WRONG
\&    print SOCKET "Hi there, client!\e015\e012";  # RIGHT
.Ve
.PP
However, using \f(CW\*(C`\e015\e012\*(C'\fR (or \f(CW\*(C`\ecM\ecJ\*(C'\fR, or \f(CW\*(C`\ex0D\ex0A\*(C'\fR) can be tedious
and unsightly, as well as confusing to those maintaining the code.  As
such, the Socket module supplies the Right Thing for those who want it.
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    print SOCKET "Hi there, client!$CRLF"      # RIGHT
.Ve
.PP
When reading from a socket, remember that the default input record
separator \f(CW$/\fR is \f(CW\*(C`\en\*(C'\fR, but robust socket code will recognize as
either \f(CW\*(C`\e012\*(C'\fR or \f(CW\*(C`\e015\e012\*(C'\fR as end of line:
.PP
.Vb 3
\&    while (<SOCKET>) {
\&        # ...
\&    }
.Ve
.PP
Because both \s-1CRLF\s0 and \s-1LF\s0 end in \s-1LF,\s0 the input record separator can
be set to \s-1LF\s0 and any \s-1CR\s0 stripped later.  Better to write:
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    local($/) = LF;      # not needed if $/ is already \e012
\&
\&    while (<SOCKET>) {
\&        s/$CR?$LF/\en/;   # not sure if socket uses LF or CRLF, OK
\&    #   s/\e015?\e012/\en/; # same thing
\&    }
.Ve
.PP
This example is preferred over the previous one\*(--even for Unix
platforms\*(--because now any \f(CW\*(C`\e015\*(C'\fR's (\f(CW\*(C`\ecM\*(C'\fR's) are stripped out
(and there was much rejoicing).
.PP
Similarly, functions that return text data\*(--such as a function that
fetches a web page\*(--should sometimes translate newlines before
returning the data, if they've not yet been translated to the local
newline representation.  A single line of code will often suffice:
.PP
.Vb 2
\&    $data =~ s/\e015?\e012/\en/g;
\&    return $data;
.Ve
.PP
Some of this may be confusing.  Here's a handy reference to the \s-1ASCII CR\s0
and \s-1LF\s0 characters.  You can print it out and stick it in your wallet.
.PP
.Vb 2
\&    LF  eq  \e012  eq  \ex0A  eq  \ecJ  eq  chr(10)  eq  ASCII 10
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  ASCII 13
\&
\&             | Unix | DOS  | Mac  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF  |  CR  |
\&        \er   |  CR  |  CR  |  LF  |
\&        \en * |  LF  | CRLF |  CR  |
\&        \er * |  CR  |  CR  |  LF  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.PP
The Unix column assumes that you are not accessing a serial line
(like a tty) in canonical mode.  If you are, then \s-1CR\s0 on input becomes
\&\*(L"\en\*(R", and \*(L"\en\*(R" on output becomes \s-1CRLF.\s0
.PP
These are just the most common definitions of \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR in Perl.
There may well be others.  For example, on an \s-1EBCDIC\s0 implementation
such as z/OS (\s-1OS/390\s0) or \s-1OS/400 \s0(using the \s-1ILE,\s0 the \s-1PASE\s0 is ASCII-based)
the above material is similar to \*(L"Unix\*(R" but the code numbers change:
.PP
.Vb 4
\&    LF  eq  \e025  eq  \ex15  eq  \ecU  eq  chr(21)  eq  CP\-1047 21
\&    LF  eq  \e045  eq  \ex25  eq           chr(37)  eq  CP\-0037 37
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-1047 13
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-0037 13
\&
\&             | z/OS | OS/400 |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF    |
\&        \er   |  CR  |  CR    |
\&        \en * |  LF  |  LF    |
\&        \er * |  CR  |  CR    |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.SS "Numbers endianness and Width"
.IX Subsection "Numbers endianness and Width"
Different CPUs store integers and floating point numbers in different
orders (called \fIendianness\fR) and widths (32\-bit and 64\-bit being the
most common today).  This affects your programs when they attempt to transfer
numbers in binary format from one \s-1CPU\s0 architecture to another,
usually either \*(L"live\*(R" via network connection, or by storing the
numbers to secondary storage such as a disk file or tape.
.PP
Conflicting storage orders make utter mess out of the numbers.  If a
little-endian host (Intel, \s-1VAX\s0) stores 0x12345678 (305419896 in
decimal), a big-endian host (Motorola, Sparc, \s-1PA\s0) reads it as
0x78563412 (2018915346 in decimal).  Alpha and \s-1MIPS\s0 can be either:
Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses
them in big-endian mode.  To avoid this problem in network (socket)
connections use the \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR formats \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`N\*(C'\fR, the
\&\*(L"network\*(R" orders.  These are guaranteed to be portable.
.PP
As of perl 5.10.0, you can also use the \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`<\*(C'\fR modifiers
to force big\- or little-endian byte-order.  This is useful if you want
to store signed integers or 64\-bit integers, for example.
.PP
You can explore the endianness of your platform by unpacking a
data structure packed in native format such as:
.PP
.Vb 3
\&    print unpack("h*", pack("s2", 1, 2)), "\en";
\&    # \*(Aq10002000\*(Aq on e.g. Intel x86 or Alpha 21064 in little\-endian mode
\&    # \*(Aq00100020\*(Aq on e.g. Motorola 68040
.Ve
.PP
If you need to distinguish between endian architectures you could use
either of the variables set like so:
.PP
.Vb 2
\&    $is_big_endian   = unpack("h*", pack("s", 1)) =~ /01/;
\&    $is_little_endian = unpack("h*", pack("s", 1)) =~ /^1/;
.Ve
.PP
Differing widths can cause truncation even between platforms of equal
endianness.  The platform of shorter width loses the upper parts of the
number.  There is no good solution for this problem except to avoid
transferring or storing raw binary numbers.
.PP
One can circumnavigate both these problems in two ways.  Either
transfer and store numbers always in text format, instead of raw
binary, or else consider using modules like Data::Dumper and Storable
(included as of perl 5.8).  Keeping all data as text significantly
simplifies matters.
.PP
The v\-strings are portable only up to v2147483647 (0x7FFFFFFF), that's
how far \s-1EBCDIC,\s0 or more precisely UTF-EBCDIC will go.
.SS "Files and Filesystems"
.IX Subsection "Files and Filesystems"
Most platforms these days structure files in a hierarchical fashion.
So, it is reasonably safe to assume that all platforms support the
notion of a \*(L"path\*(R" to uniquely identify a file on the system.  How
that path is really written, though, differs considerably.
.PP
Although similar, file path specifications differ between Unix,
Windows, Mac\ \s-1OS, OS/2, VMS, VOS, RISC\s0\ \s-1OS,\s0 and probably others.
Unix, for example, is one of the few OSes that has the elegant idea
of a single root directory.
.PP
\&\s-1DOS, OS/2, VMS, VOS,\s0 and Windows can work similarly to Unix with \f(CW\*(C`/\*(C'\fR
as path separator, or in their own idiosyncratic ways (such as having
several root directories and various \*(L"unrooted\*(R" device files such \s-1NIL:\s0
and \s-1LPT:\s0).
.PP
Mac\ \s-1OS 9\s0 and earlier used \f(CW\*(C`:\*(C'\fR as a path separator instead of \f(CW\*(C`/\*(C'\fR.
.PP
The filesystem may support neither hard links (\f(CW\*(C`link\*(C'\fR) nor
symbolic links (\f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR).
.PP
The filesystem may support neither access timestamp nor change
timestamp (meaning that about the only portable timestamp is the
modification timestamp), or one second granularity of any timestamps
(e.g. the \s-1FAT\s0 filesystem limits the time granularity to two seconds).
.PP
The \*(L"inode change timestamp\*(R" (the \f(CW\*(C`\-C\*(C'\fR filetest) may really be the
\&\*(L"creation timestamp\*(R" (which it is not in Unix).
.PP
\&\s-1VOS\s0 perl can emulate Unix filenames with \f(CW\*(C`/\*(C'\fR as path separator.  The
native pathname characters greater-than, less-than, number-sign, and
percent-sign are always accepted.
.PP
\&\s-1RISC\s0\ \s-1OS\s0 perl can emulate Unix filenames with \f(CW\*(C`/\*(C'\fR as path
separator, or go native and use \f(CW\*(C`.\*(C'\fR for path separator and \f(CW\*(C`:\*(C'\fR to
signal filesystems and disk names.
.PP
Don't assume Unix filesystem access semantics: that read, write,
and execute are all the permissions there are, and even if they exist,
that their semantics (for example what do r, w, and x mean on
a directory) are the Unix ones.  The various Unix/POSIX compatibility
layers usually try to make interfaces like \fIchmod()\fR work, but sometimes
there simply is no good mapping.
.PP
If all this is intimidating, have no (well, maybe only a little)
fear.  There are modules that can help.  The File::Spec modules
provide methods to do the Right Thing on whatever platform happens
to be running the program.
.PP
.Vb 6
\&    use File::Spec::Functions;
\&    chdir(updir());        # go up one directory
\&    my $file = catfile(curdir(), \*(Aqtemp\*(Aq, \*(Aqfile.txt\*(Aq);
\&    # on Unix and Win32, \*(Aq./temp/file.txt\*(Aq
\&    # on Mac OS Classic, \*(Aq:temp:file.txt\*(Aq
\&    # on VMS, \*(Aq[.temp]file.txt\*(Aq
.Ve
.PP
File::Spec is available in the standard distribution as of version
5.004_05.  File::Spec::Functions is only in File::Spec 0.7 and later,
and some versions of perl come with version 0.6.  If File::Spec
is not updated to 0.7 or later, you must use the object-oriented
interface from File::Spec (or upgrade File::Spec).
.PP
In general, production code should not have file paths hardcoded.
Making them user-supplied or read from a configuration file is
better, keeping in mind that file path syntax varies on different
machines.
.PP
This is especially noticeable in scripts like Makefiles and test suites,
which often assume \f(CW\*(C`/\*(C'\fR as a path separator for subdirectories.
.PP
Also of use is File::Basename from the standard distribution, which
splits a pathname into pieces (base filename, full path to directory,
and file suffix).
.PP
Even when on a single platform (if you can call Unix a single platform),
remember not to count on the existence or the contents of particular
system-specific files or directories, like \fI/etc/passwd\fR,
\&\fI/etc/sendmail.conf\fR, \fI/etc/resolv.conf\fR, or even \fI/tmp/\fR.  For
example, \fI/etc/passwd\fR may exist but not contain the encrypted
passwords, because the system is using some form of enhanced security.
Or it may not contain all the accounts, because the system is using \s-1NIS. \s0
If code does need to rely on such a file, include a description of the
file and its format in the code's documentation, then make it easy for
the user to override the default location of the file.
.PP
Don't assume a text file will end with a newline.  They should,
but people forget.
.PP
Do not have two files or directories of the same name with different
case, like \fItest.pl\fR and \fITest.pl\fR, as many platforms have
case-insensitive (or at least case-forgiving) filenames.  Also, try
not to have non-word characters (except for \f(CW\*(C`.\*(C'\fR) in the names, and
keep them to the 8.3 convention, for maximum portability, onerous a
burden though this may appear.
.PP
Likewise, when using the AutoSplit module, try to keep your functions to
8.3 naming and case-insensitive conventions; or, at the least,
make it so the resulting files have a unique (case-insensitively)
first 8 characters.
.PP
Whitespace in filenames is tolerated on most systems, but not all,
and even on systems where it might be tolerated, some utilities
might become confused by such whitespace.
.PP
Many systems (\s-1DOS, VMS ODS\-2\s0) cannot have more than one \f(CW\*(C`.\*(C'\fR in their
filenames.
.PP
Don't assume \f(CW\*(C`>\*(C'\fR won't be the first character of a filename.
Always use \f(CW\*(C`<\*(C'\fR explicitly to open a file for reading, or even
better, use the three-arg version of open, unless you want the user to
be able to specify a pipe open.
.PP
.Vb 1
\&    open my $fh, \*(Aq<\*(Aq, $existing_file) or die $!;
.Ve
.PP
If filenames might use strange characters, it is safest to open it
with \f(CW\*(C`sysopen\*(C'\fR instead of \f(CW\*(C`open\*(C'\fR.  \f(CW\*(C`open\*(C'\fR is magic and can
translate characters like \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`<\*(C'\fR, and \f(CW\*(C`|\*(C'\fR, which may
be the wrong thing to do.  (Sometimes, though, it's the right thing.)
Three-arg open can also help protect against this translation in cases
where it is undesirable.
.PP
Don't use \f(CW\*(C`:\*(C'\fR as a part of a filename since many systems use that for
their own semantics (Mac \s-1OS\s0 Classic for separating pathname components,
many networking schemes and utilities for separating the nodename and
the pathname, and so on).  For the same reasons, avoid \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`;\*(C'\fR and
\&\f(CW\*(C`|\*(C'\fR.
.PP
Don't assume that in pathnames you can collapse two leading slashes
\&\f(CW\*(C`//\*(C'\fR into one: some networking and clustering filesystems have special
semantics for that.  Let the operating system to sort it out.
.PP
The \fIportable filename characters\fR as defined by \s-1ANSI C\s0 are
.PP
.Vb 4
\& a b c d e f g h i j k l m n o p q r t u v w x y z
\& A B C D E F G H I J K L M N O P Q R T U V W X Y Z
\& 0 1 2 3 4 5 6 7 8 9
\& . _ \-
.Ve
.PP
and the \*(L"\-\*(R" shouldn't be the first character.  If you want to be
hypercorrect, stay case-insensitive and within the 8.3 naming
convention (all the files and directories have to be unique within one
directory if their names are lowercased and truncated to eight
characters before the \f(CW\*(C`.\*(C'\fR, if any, and to three characters after the
\&\f(CW\*(C`.\*(C'\fR, if any).  (And do not use \f(CW\*(C`.\*(C'\fRs in directory names.)
.SS "System Interaction"
.IX Subsection "System Interaction"
Not all platforms provide a command line.  These are usually platforms
that rely primarily on a Graphical User Interface (\s-1GUI\s0) for user
interaction.  A program requiring a command line interface might
not work everywhere.  This is probably for the user of the program
to deal with, so don't stay up late worrying about it.
.PP
Some platforms can't delete or rename files held open by the system,
this limitation may also apply to changing filesystem metainformation
like file permissions or owners.  Remember to \f(CW\*(C`close\*(C'\fR files when you
are done with them.  Don't \f(CW\*(C`unlink\*(C'\fR or \f(CW\*(C`rename\*(C'\fR an open file.  Don't
\&\f(CW\*(C`tie\*(C'\fR or \f(CW\*(C`open\*(C'\fR a file already tied or opened; \f(CW\*(C`untie\*(C'\fR or \f(CW\*(C`close\*(C'\fR
it first.
.PP
Don't open the same file more than once at a time for writing, as some
operating systems put mandatory locks on such files.
.PP
Don't assume that write/modify permission on a directory gives the
right to add or delete files/directories in that directory.  That is
filesystem specific: in some filesystems you need write/modify
permission also (or even just) in the file/directory itself.  In some
filesystems (\s-1AFS, DFS\s0) the permission to add/delete directory entries
is a completely separate permission.
.PP
Don't assume that a single \f(CW\*(C`unlink\*(C'\fR completely gets rid of the file:
some filesystems (most notably the ones in \s-1VMS\s0) have versioned
filesystems, and \fIunlink()\fR removes only the most recent one (it doesn't
remove all the versions because by default the native tools on those
platforms remove just the most recent version, too).  The portable
idiom to remove all the versions of a file is
.PP
.Vb 1
\&    1 while unlink "file";
.Ve
.PP
This will terminate if the file is undeleteable for some reason
(protected, not there, and so on).
.PP
Don't count on a specific environment variable existing in \f(CW%ENV\fR.
Don't count on \f(CW%ENV\fR entries being case-sensitive, or even
case-preserving.  Don't try to clear \f(CW%ENV\fR by saying \f(CW\*(C`%ENV = ();\*(C'\fR, or,
if you really have to, make it conditional on \f(CW\*(C`$^O ne \*(AqVMS\*(Aq\*(C'\fR since in
\&\s-1VMS\s0 the \f(CW%ENV\fR table is much more than a per-process key-value string
table.
.PP
On \s-1VMS,\s0 some entries in the \f(CW%ENV\fR hash are dynamically created when
their key is used on a read if they did not previously exist.  The
values for \f(CW$ENV{HOME}\fR, \f(CW$ENV{TERM}\fR, \f(CW$ENV{HOME}\fR, and \f(CW$ENV{USER}\fR,
are known to be dynamically generated.  The specific names that are
dynamically generated may vary with the version of the C library on \s-1VMS,\s0
and more may exist than is documented.
.PP
On \s-1VMS\s0 by default, changes to the \f(CW%ENV\fR hash are persistent after the process
exits.  This can cause unintended issues.
.PP
Don't count on signals or \f(CW%SIG\fR for anything.
.PP
Don't count on filename globbing.  Use \f(CW\*(C`opendir\*(C'\fR, \f(CW\*(C`readdir\*(C'\fR, and
\&\f(CW\*(C`closedir\*(C'\fR instead.
.PP
Don't count on per-program environment variables, or per-program current
directories.
.PP
Don't count on specific values of \f(CW$!\fR, neither numeric nor
especially the strings values. Users may switch their locales causing
error messages to be translated into their languages.  If you can
trust a POSIXish environment, you can portably use the symbols defined
by the Errno module, like \s-1ENOENT. \s0 And don't trust on the values of \f(CW$!\fR
at all except immediately after a failed system call.
.SS "Command names versus file pathnames"
.IX Subsection "Command names versus file pathnames"
Don't assume that the name used to invoke a command or program with
\&\f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR can also be used to test for the existence of the
file that holds the executable code for that command or program.
First, many systems have \*(L"internal\*(R" commands that are built-in to the
shell or \s-1OS\s0 and while these commands can be invoked, there is no
corresponding file.  Second, some operating systems (e.g., Cygwin,
\&\s-1DJGPP, OS/2,\s0 and \s-1VOS\s0) have required suffixes for executable files;
these suffixes are generally permitted on the command name but are not
required.  Thus, a command like \*(L"perl\*(R" might exist in a file named
\&\*(L"perl\*(R", \*(L"perl.exe\*(R", or \*(L"perl.pm\*(R", depending on the operating system.
The variable \*(L"_exe\*(R" in the Config module holds the executable suffix,
if any.  Third, the \s-1VMS\s0 port carefully sets up $^X and
\&\f(CW$Config\fR{perlpath} so that no further processing is required.  This is
just as well, because the matching regular expression used below would
then have to deal with a possible trailing version number in the \s-1VMS\s0
file name.
.PP
To convert $^X to a file pathname, taking account of the requirements
of the various operating system possibilities, say:
.PP
.Vb 4
\& use Config;
\& my $thisperl = $^X;
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.PP
To convert \f(CW$Config\fR{perlpath} to a file pathname, say:
.PP
.Vb 4
\& use Config;
\& my $thisperl = $Config{perlpath};
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.SS "Networking"
.IX Subsection "Networking"
Don't assume that you can reach the public Internet.
.PP
Don't assume that there is only one way to get through firewalls
to the public Internet.
.PP
Don't assume that you can reach outside world through any other port
than 80, or some web proxy.  ftp is blocked by many firewalls.
.PP
Don't assume that you can send email by connecting to the local \s-1SMTP\s0 port.
.PP
Don't assume that you can reach yourself or any node by the name
\&'localhost'.  The same goes for '127.0.0.1'.  You will have to try both.
.PP
Don't assume that the host has only one network card, or that it
can't bind to many virtual \s-1IP\s0 addresses.
.PP
Don't assume a particular network device name.
.PP
Don't assume a particular set of \fIioctl()\fRs will work.
.PP
Don't assume that you can ping hosts and get replies.
.PP
Don't assume that any particular port (service) will respond.
.PP
Don't assume that Sys::Hostname (or any other \s-1API\s0 or command) returns
either a fully qualified hostname or a non-qualified hostname: it all
depends on how the system had been configured.  Also remember that for
things such as \s-1DHCP\s0 and \s-1NAT,\s0 the hostname you get back might not be
very useful.
.PP
All the above \*(L"don't\*(R":s may look daunting, and they are, but the key
is to degrade gracefully if one cannot reach the particular network
service one wants.  Croaking or hanging do not look very professional.
.SS "Interprocess Communication (\s-1IPC\s0)"
.IX Subsection "Interprocess Communication (IPC)"
In general, don't directly access the system in code meant to be
portable.  That means, no \f(CW\*(C`system\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`pipe\*(C'\fR,
\&\f(CW\*(C`\`\`\*(C'\fR, \f(CW\*(C`qx//\*(C'\fR, \f(CW\*(C`open\*(C'\fR with a \f(CW\*(C`|\*(C'\fR, nor any of the other things
that makes being a perl hacker worth being.
.PP
Commands that launch external processes are generally supported on
most platforms (though many of them do not support any type of
forking).  The problem with using them arises from what you invoke
them on.  External tools are often named differently on different
platforms, may not be available in the same location, might accept
different arguments, can behave differently, and often present their
results in a platform-dependent way.  Thus, you should seldom depend
on them to produce consistent results. (Then again, if you're calling 
\&\fInetstat \-a\fR, you probably don't expect it to run on both Unix and \s-1CP/M.\s0)
.PP
One especially common bit of Perl code is opening a pipe to \fBsendmail\fR:
.PP
.Vb 2
\&    open(MAIL, \*(Aq|/usr/lib/sendmail \-t\*(Aq) 
\&        or die "cannot fork sendmail: $!";
.Ve
.PP
This is fine for systems programming when sendmail is known to be
available.  But it is not fine for many non-Unix systems, and even
some Unix systems that may not have sendmail installed.  If a portable
solution is needed, see the various distributions on \s-1CPAN\s0 that deal
with it.  Mail::Mailer and Mail::Send in the MailTools distribution are
commonly used, and provide several mailing methods, including mail,
sendmail, and direct \s-1SMTP \s0(via Net::SMTP) if a mail transfer agent is
not available.  Mail::Sendmail is a standalone module that provides
simple, platform-independent mailing.
.PP
The Unix System V \s-1IPC \s0(\f(CW\*(C`msg*(), sem*(), shm*()\*(C'\fR) is not available
even on all Unix platforms.
.PP
Do not use either the bare result of \f(CW\*(C`pack("N", 10, 20, 30, 40)\*(C'\fR or
bare v\-strings (such as \f(CW\*(C`v10.20.30.40\*(C'\fR) to represent IPv4 addresses:
both forms just pack the four bytes into network order.  That this
would be equal to the C language \f(CW\*(C`in_addr\*(C'\fR struct (which is what the
socket code internally uses) is not guaranteed.  To be portable use
the routines of the Socket extension, such as \f(CW\*(C`inet_aton()\*(C'\fR,
\&\f(CW\*(C`inet_ntoa()\*(C'\fR, and \f(CW\*(C`sockaddr_in()\*(C'\fR.
.PP
The rule of thumb for portable code is: Do it all in portable Perl, or
use a module (that may internally implement it with platform-specific
code, but expose a common interface).
.SS "External Subroutines (\s-1XS\s0)"
.IX Subsection "External Subroutines (XS)"
\&\s-1XS\s0 code can usually be made to work with any platform, but dependent
libraries, header files, etc., might not be readily available or
portable, or the \s-1XS\s0 code itself might be platform-specific, just as Perl
code might be.  If the libraries and headers are portable, then it is
normally reasonable to make sure the \s-1XS\s0 code is portable, too.
.PP
A different type of portability issue arises when writing \s-1XS\s0 code:
availability of a C compiler on the end-user's system.  C brings
with it its own portability issues, and writing \s-1XS\s0 code will expose
you to some of those.  Writing purely in Perl is an easier way to
achieve portability.
.SS "Standard Modules"
.IX Subsection "Standard Modules"
In general, the standard modules work across platforms.  Notable
exceptions are the \s-1CPAN\s0 module (which currently makes connections to external
programs that may not be available), platform-specific modules (like
ExtUtils::MM_VMS), and \s-1DBM\s0 modules.
.PP
There is no one \s-1DBM\s0 module available on all platforms.
SDBM_File and the others are generally available on all Unix and DOSish
ports, but not in MacPerl, where only NBDM_File and DB_File are
available.
.PP
The good news is that at least some \s-1DBM\s0 module should be available, and
AnyDBM_File will use whichever module it can find.  Of course, then
the code needs to be fairly strict, dropping to the greatest common
factor (e.g., not exceeding 1K for each record), so that it will
work with any \s-1DBM\s0 module.  See AnyDBM_File for more details.
.SS "Time and Date"
.IX Subsection "Time and Date"
The system's notion of time of day and calendar date is controlled in
widely different ways.  Don't assume the timezone is stored in \f(CW$ENV{TZ}\fR,
and even if it is, don't assume that you can control the timezone through
that variable.  Don't assume anything about the three-letter timezone
abbreviations (for example that \s-1MST\s0 would be the Mountain Standard Time,
it's been known to stand for Moscow Standard Time).  If you need to
use timezones, express them in some unambiguous format like the
exact number of minutes offset from \s-1UTC,\s0 or the \s-1POSIX\s0 timezone
format.
.PP
Don't assume that the epoch starts at 00:00:00, January 1, 1970,
because that is \s-1OS\-\s0 and implementation-specific.  It is better to
store a date in an unambiguous representation.  The \s-1ISO 8601\s0 standard
defines YYYY-MM-DD as the date format, or \s-1YYYY\-MM\-DDTHH:MM:SS
\&\s0(that's a literal \*(L"T\*(R" separating the date from the time).
Please do use the \s-1ISO 8601\s0 instead of making us guess what
date 02/03/04 might be.  \s-1ISO 8601\s0 even sorts nicely as-is.
A text representation (like \*(L"1987\-12\-18\*(R") can be easily converted
into an OS-specific value using a module like Date::Parse.
An array of values, such as those returned by \f(CW\*(C`localtime\*(C'\fR, can be
converted to an OS-specific representation using Time::Local.
.PP
When calculating specific times, such as for tests in time or date modules,
it may be appropriate to calculate an offset for the epoch.
.PP
.Vb 2
\&    require Time::Local;
\&    my $offset = Time::Local::timegm(0, 0, 0, 1, 0, 70);
.Ve
.PP
The value for \f(CW$offset\fR in Unix will be \f(CW0\fR, but in Mac \s-1OS\s0 Classic
will be some large number.  \f(CW$offset\fR can then be added to a Unix time
value to get what should be the proper value on any system.
.SS "Character sets and character encoding"
.IX Subsection "Character sets and character encoding"
Assume very little about character sets.
.PP
Assume nothing about numerical values (\f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`chr\*(C'\fR) of characters.
Do not use explicit code point ranges (like \exHH\-\exHH); use for
example symbolic character classes like \f(CW\*(C`[:print:]\*(C'\fR.
.PP
Do not assume that the alphabetic characters are encoded contiguously
(in the numeric sense).  There may be gaps.
.PP
Do not assume anything about the ordering of the characters.
The lowercase letters may come before or after the uppercase letters;
the lowercase and uppercase may be interlaced so that both \*(L"a\*(R" and \*(L"A\*(R"
come before \*(L"b\*(R"; the accented and other international characters may
be interlaced so that a\*: comes before \*(L"b\*(R".
.SS "Internationalisation"
.IX Subsection "Internationalisation"
If you may assume \s-1POSIX \s0(a rather large assumption), you may read
more about the \s-1POSIX\s0 locale system from perllocale.  The locale
system at least attempts to make things a little bit more portable,
or at least more convenient and native-friendly for non-English
users.  The system affects character sets and encoding, and date
and time formatting\*(--amongst other things.
.PP
If you really want to be international, you should consider Unicode.
See perluniintro and perlunicode for more information.
.PP
If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in
the \*(L"source code\*(R" of your code, to be portable you have to be explicit
about what bytes they are.  Someone might for example be using your
code under a \s-1UTF\-8\s0 locale, in which case random native bytes might be
illegal (\*(L"Malformed \s-1UTF\-8 ...\*(R"\s0)  This means that for example embedding
\&\s-1ISO 8859\-1\s0 bytes beyond 0x7f into your strings might cause trouble
later.  If the bytes are native 8\-bit bytes, you can use the \f(CW\*(C`bytes\*(C'\fR
pragma.  If the bytes are in a string (regular expression being a
curious string), you can often also use the \f(CW\*(C`\exHH\*(C'\fR notation instead
of embedding the bytes as-is.  If you want to write your code in \s-1UTF\-8,\s0
you can use the \f(CW\*(C`utf8\*(C'\fR.
.SS "System Resources"
.IX Subsection "System Resources"
If your code is destined for systems with severely constrained (or
missing!) virtual memory systems then you want to be \fIespecially\fR mindful
of avoiding wasteful constructs such as:
.PP
.Vb 1
\&    my @lines = <$very_large_file>;            # bad
\&
\&    while (<$fh>) {$file .= $_}                # sometimes bad
\&    my $file = join(\*(Aq\*(Aq, <$fh>);                # better
.Ve
.PP
The last two constructs may appear unintuitive to most people.  The
first repeatedly grows a string, whereas the second allocates a
large chunk of memory in one go.  On some systems, the second is
more efficient that the first.
.SS "Security"
.IX Subsection "Security"
Most multi-user platforms provide basic levels of security, usually
implemented at the filesystem level.  Some, however, unfortunately do
not.  Thus the notion of user id, or \*(L"home\*(R" directory,
or even the state of being logged-in, may be unrecognizable on many
platforms.  If you write programs that are security-conscious, it
is usually best to know what type of system you will be running
under so that you can write code explicitly for that platform (or
class of platforms).
.PP
Don't assume the Unix filesystem access semantics: the operating
system or the filesystem may be using some \s-1ACL\s0 systems, which are
richer languages than the usual rwx.  Even if the rwx exist,
their semantics might be different.
.PP
(From security viewpoint testing for permissions before attempting to
do something is silly anyway: if one tries this, there is potential
for race conditions. Someone or something might change the
permissions between the permissions check and the actual operation.
Just try the operation.)
.PP
Don't assume the Unix user and group semantics: especially, don't
expect the \f(CW$<\fR and \f(CW$>\fR (or the \f(CW$(\fR and \f(CW$)\fR) to work
for switching identities (or memberships).
.PP
Don't assume set-uid and set-gid semantics. (And even if you do,
think twice: set-uid and set-gid are a known can of security worms.)
.SS "Style"
.IX Subsection "Style"
For those times when it is necessary to have platform-specific code,
consider keeping the platform-specific code in one place, making porting
to other platforms easier.  Use the Config module and the special
variable \f(CW$^O\fR to differentiate platforms, as described in
\&\*(L"\s-1PLATFORMS\*(R"\s0.
.PP
Be careful in the tests you supply with your module or programs.
Module code may be fully portable, but its tests might not be.  This
often happens when tests spawn off other processes or call external
programs to aid in the testing, or when (as noted above) the tests
assume certain things about the filesystem and paths.  Be careful not
to depend on a specific output style for errors, such as when checking
\&\f(CW$!\fR after a failed system call.  Using \f(CW$!\fR for anything else than
displaying it as output is doubtful (though see the Errno module for
testing reasonably portably for error value). Some platforms expect
a certain output format, and Perl on those platforms may have been
adjusted accordingly.  Most specifically, don't anchor a regex when
testing an error value.
.SH "CPAN Testers"
.IX Header "CPAN Testers"
Modules uploaded to \s-1CPAN\s0 are tested by a variety of volunteers on
different platforms.  These \s-1CPAN\s0 testers are notified by mail of each
new upload, and reply to the list with \s-1PASS, FAIL, NA \s0(not applicable to
this platform), or \s-1UNKNOWN \s0(unknown), along with any relevant notations.
.PP
The purpose of the testing is twofold: one, to help developers fix any
problems in their code that crop up because of lack of testing on other
platforms; two, to provide users with information about whether
a given module works on a given platform.
.PP
Also see:
.IP "\(bu" 4
Mailing list: cpan\-testers\-discuss@perl.org
.IP "\(bu" 4
Testing results: <http://www.cpantesters.org/>
.SH "PLATFORMS"
.IX Header "PLATFORMS"
Perl is built with a \f(CW$^O\fR variable that indicates the operating
system it was built on.  This was implemented
to help speed up code that would otherwise have to \f(CW\*(C`use Config\*(C'\fR
and use the value of \f(CW$Config{osname}\fR.  Of course, to get more
detailed information about the system, looking into \f(CW%Config\fR is
certainly recommended.
.PP
\&\f(CW%Config\fR cannot always be trusted, however, because it was built
at compile time.  If perl was built in one place, then transferred
elsewhere, some values may be wrong.  The values may even have been
edited after the fact.
.SS "Unix"
.IX Subsection "Unix"
Perl works on a bewildering variety of Unix and Unix-like platforms (see
e.g. most of the files in the \fIhints/\fR directory in the source code kit).
On most of these systems, the value of \f(CW$^O\fR (hence \f(CW$Config{\*(Aqosname\*(Aq}\fR,
too) is determined either by lowercasing and stripping punctuation from the
first field of the string returned by typing \f(CW\*(C`uname \-a\*(C'\fR (or a similar command)
at the shell prompt or by testing the file system for the presence of
uniquely named files such as a kernel or header file.  Here, for example,
are a few of the more popular Unix flavors:
.PP
.Vb 10
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    AIX           aix        aix
\&    BSD/OS        bsdos      i386\-bsdos
\&    Darwin        darwin     darwin
\&    dgux          dgux       AViiON\-dgux
\&    DYNIX/ptx     dynixptx   i386\-dynixptx
\&    FreeBSD       freebsd    freebsd\-i386    
\&    Haiku         haiku      BePC\-haiku
\&    Linux         linux      arm\-linux
\&    Linux         linux      i386\-linux
\&    Linux         linux      i586\-linux
\&    Linux         linux      ppc\-linux
\&    HP\-UX         hpux       PA\-RISC1.1
\&    IRIX          irix       irix
\&    Mac OS X      darwin     darwin
\&    NeXT 3        next       next\-fat
\&    NeXT 4        next       OPENSTEP\-Mach
\&    openbsd       openbsd    i386\-openbsd
\&    OSF1          dec_osf    alpha\-dec_osf
\&    reliantunix\-n svr4       RM400\-svr4
\&    SCO_SV        sco_sv     i386\-sco_sv
\&    SINIX\-N       svr4       RM400\-svr4
\&    sn4609        unicos     CRAY_C90\-unicos
\&    sn6521        unicosmk   t3e\-unicosmk
\&    sn9617        unicos     CRAY_J90\-unicos
\&    SunOS         solaris    sun4\-solaris
\&    SunOS         solaris    i86pc\-solaris
\&    SunOS4        sunos      sun4\-sunos
.Ve
.PP
Because the value of \f(CW$Config{archname}\fR may depend on the
hardware architecture, it can vary more than the value of \f(CW$^O\fR.
.SS "\s-1DOS\s0 and Derivatives"
.IX Subsection "DOS and Derivatives"
Perl has long been ported to Intel-style microcomputers running under
systems like PC-DOS, MS-DOS, \s-1OS/2,\s0 and most Windows platforms you can
bring yourself to mention (except for Windows \s-1CE,\s0 if you count that).
Users familiar with \fI\s-1COMMAND.COM\s0\fR or \fI\s-1CMD.EXE\s0\fR style shells should
be aware that each of these file specifications may have subtle
differences:
.PP
.Vb 4
\&    my $filespec0 = "c:/foo/bar/file.txt";
\&    my $filespec1 = "c:\e\efoo\e\ebar\e\efile.txt";
\&    my $filespec2 = \*(Aqc:\efoo\ebar\efile.txt\*(Aq;
\&    my $filespec3 = \*(Aqc:\e\efoo\e\ebar\e\efile.txt\*(Aq;
.Ve
.PP
System calls accept either \f(CW\*(C`/\*(C'\fR or \f(CW\*(C`\e\*(C'\fR as the path separator.
However, many command-line utilities of \s-1DOS\s0 vintage treat \f(CW\*(C`/\*(C'\fR as
the option prefix, so may get confused by filenames containing \f(CW\*(C`/\*(C'\fR.
Aside from calling any external programs, \f(CW\*(C`/\*(C'\fR will work just fine,
and probably better, as it is more consistent with popular usage,
and avoids the problem of remembering what to backwhack and what
not to.
.PP
The \s-1DOS FAT\s0 filesystem can accommodate only \*(L"8.3\*(R" style filenames.  Under
the \*(L"case-insensitive, but case-preserving\*(R" \s-1HPFS \s0(\s-1OS/2\s0) and \s-1NTFS \s0(\s-1NT\s0)
filesystems you may have to be careful about case returned with functions
like \f(CW\*(C`readdir\*(C'\fR or used with functions like \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`opendir\*(C'\fR.
.PP
\&\s-1DOS\s0 also treats several filenames as special, such as \s-1AUX, PRN,
NUL, CON, COM1, LPT1, LPT2,\s0 etc.  Unfortunately, sometimes these
filenames won't even work if you include an explicit directory
prefix.  It is best to avoid such filenames, if you want your code
to be portable to \s-1DOS\s0 and its derivatives.  It's hard to know what
these all are, unfortunately.
.PP
Users of these operating systems may also wish to make use of
scripts such as \fIpl2bat.bat\fR or \fIpl2cmd\fR to
put wrappers around your scripts.
.PP
Newline (\f(CW\*(C`\en\*(C'\fR) is translated as \f(CW\*(C`\e015\e012\*(C'\fR by \s-1STDIO\s0 when reading from
and writing to files (see \*(L"Newlines\*(R").  \f(CW\*(C`binmode(FILEHANDLE)\*(C'\fR
will keep \f(CW\*(C`\en\*(C'\fR translated as \f(CW\*(C`\e012\*(C'\fR for that filehandle.  Since it is a
no-op on other systems, \f(CW\*(C`binmode\*(C'\fR should be used for cross-platform code
that deals with binary data.  That's assuming you realize in advance
that your data is in binary.  General-purpose programs should
often assume nothing about their data.
.PP
The \f(CW$^O\fR variable and the \f(CW$Config{archname}\fR values for various
DOSish perls are as follows:
.PP
.Vb 10
\&     OS            $^O      $Config{archname}   ID    Version
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MS\-DOS        dos        ?                 
\&     PC\-DOS        dos        ?                 
\&     OS/2          os2        ?
\&     Windows 3.1   ?          ?                 0      3 01
\&     Windows 95    MSWin32    MSWin32\-x86       1      4 00
\&     Windows 98    MSWin32    MSWin32\-x86       1      4 10
\&     Windows ME    MSWin32    MSWin32\-x86       1      ?
\&     Windows NT    MSWin32    MSWin32\-x86       2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ALPHA     2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ppc       2      4 xx
\&     Windows 2000  MSWin32    MSWin32\-x86       2      5 00
\&     Windows XP    MSWin32    MSWin32\-x86       2      5 01
\&     Windows 2003  MSWin32    MSWin32\-x86       2      5 02
\&     Windows Vista MSWin32    MSWin32\-x86       2      6 00
\&     Windows 7     MSWin32    MSWin32\-x86       2      6 01
\&     Windows 7     MSWin32    MSWin32\-x64       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x86       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x64       2      6 01
\&     Windows CE    MSWin32    ?                 3           
\&     Cygwin        cygwin     cygwin
.Ve
.PP
The various MSWin32 Perl's can distinguish the \s-1OS\s0 they are running on
via the value of the fifth element of the list returned from 
\&\fIWin32::GetOSVersion()\fR.  For example:
.PP
.Vb 4
\&    if ($^O eq \*(AqMSWin32\*(Aq) {
\&        my @os_version_info = Win32::GetOSVersion();
\&        print +(\*(Aq3.1\*(Aq,\*(Aq95\*(Aq,\*(AqNT\*(Aq)[$os_version_info[4]],"\en";
\&    }
.Ve
.PP
There are also \fIWin32::IsWinNT()\fR and \fIWin32::IsWin95()\fR, try \f(CW\*(C`perldoc Win32\*(C'\fR,
and as of libwin32 0.19 (not part of the core Perl distribution)
\&\fIWin32::GetOSName()\fR.  The very portable \fIPOSIX::uname()\fR will work too:
.PP
.Vb 2
\&    c:\e> perl \-MPOSIX \-we "print join \*(Aq|\*(Aq, uname"
\&    Windows NT|moonru|5.0|Build 2195 (Service Pack 2)|x86
.Ve
.PP
Also see:
.IP "\(bu" 4
The djgpp environment for \s-1DOS, \s0<http://www.delorie.com/djgpp/>
and perldos.
.IP "\(bu" 4
The \s-1EMX\s0 environment for \s-1DOS, OS/2,\s0 etc. emx@iaehv.nl,
<ftp://hobbes.nmsu.edu/pub/os2/dev/emx/>  Also perlos2.
.IP "\(bu" 4
Build instructions for Win32 in perlwin32, or under the Cygnus environment
in perlcygwin.
.IP "\(bu" 4
The \f(CW\*(C`Win32::*\*(C'\fR modules in Win32.
.IP "\(bu" 4
The ActiveState Pages, <http://www.activestate.com/>
.IP "\(bu" 4
The Cygwin environment for Win32; \fI\s-1README\s0.cygwin\fR (installed 
as perlcygwin), <http://www.cygwin.com/>
.IP "\(bu" 4
The U/WIN environment for Win32,
<http://www.research.att.com/sw/tools/uwin/>
.IP "\(bu" 4
Build instructions for \s-1OS/2, \s0perlos2
.SS "\s-1VMS\s0"
.IX Subsection "VMS"
Perl on \s-1VMS\s0 is discussed in perlvms in the perl distribution.
.PP
The official name of \s-1VMS\s0 as of this writing is OpenVMS.
.PP
Perl on \s-1VMS\s0 can accept either \s-1VMS\-\s0 or Unix-style file
specifications as in either of the following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" SYS$LOGIN:LOGIN.COM
\&    $ perl \-ne "print if /perl_setup/i" /sys$login/login.com
.Ve
.PP
but not a mixture of both as in:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" sys$login:/login.com
\&    Can\*(Aqt open sys$login:/login.com: file specification syntax error
.Ve
.PP
Interacting with Perl from the Digital Command Language (\s-1DCL\s0) shell
often requires a different set of quotation marks than Unix shells do.
For example:
.PP
.Vb 2
\&    $ perl \-e "print ""Hello, world.\en"""
\&    Hello, world.
.Ve
.PP
There are several ways to wrap your perl scripts in \s-1DCL \s0\fI.COM\fR files, if
you are so inclined.  For example:
.PP
.Vb 6
\&    $ write sys$output "Hello from DCL!"
\&    $ if p1 .eqs. ""
\&    $ then perl \-x \*(Aqf$environment("PROCEDURE")
\&    $ else perl \-x \- \*(Aqp1 \*(Aqp2 \*(Aqp3 \*(Aqp4 \*(Aqp5 \*(Aqp6 \*(Aqp7 \*(Aqp8
\&    $ deck/dollars="_\|_END_\|_"
\&    #!/usr/bin/perl
\&
\&    print "Hello from Perl!\en";
\&
\&    _\|_END_\|_
\&    $ endif
.Ve
.PP
Do take care with \f(CW\*(C`$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT\*(C'\fR if your
perl-in-DCL script expects to do things like \f(CW\*(C`$read = <STDIN>;\*(C'\fR.
.PP
The \s-1VMS\s0 operating system has two filesystems, known as \s-1ODS\-2\s0 and \s-1ODS\-5.\s0
.PP
For \s-1ODS\-2,\s0 filenames are in the format \*(L"name.extension;version\*(R".  The
maximum length for filenames is 39 characters, and the maximum length for
extensions is also 39 characters.  Version is a number from 1 to
32767.  Valid characters are \f(CW\*(C`/[A\-Z0\-9$_\-]/\*(C'\fR.
.PP
The \s-1ODS\-2\s0 filesystem is case-insensitive and does not preserve case.
Perl simulates this by converting all filenames to lowercase internally.
.PP
For \s-1ODS\-5,\s0 filenames may have almost any character in them and can include
Unicode characters.  Characters that could be misinterpreted by the \s-1DCL\s0
shell or file parsing utilities need to be prefixed with the \f(CW\*(C`^\*(C'\fR
character, or replaced with hexadecimal characters prefixed with the
\&\f(CW\*(C`^\*(C'\fR character.  Such prefixing is only needed with the pathnames are
in \s-1VMS\s0 format in applications.  Programs that can accept the Unix format
of pathnames do not need the escape characters.  The maximum length for
filenames is 255 characters.  The \s-1ODS\-5\s0 file system can handle both
a case preserved and a case sensitive mode.
.PP
\&\s-1ODS\-5\s0 is only available on the OpenVMS for 64 bit platforms.
.PP
Support for the extended file specifications is being done as optional
settings to preserve backward compatibility with Perl scripts that
assume the previous \s-1VMS\s0 limitations.
.PP
In general routines on \s-1VMS\s0 that get a Unix format file specification
should return it in a Unix format, and when they get a \s-1VMS\s0 format
specification they should return a \s-1VMS\s0 format unless they are documented
to do a conversion.
.PP
For routines that generate return a file specification, \s-1VMS\s0 allows setting
if the C library which Perl is built on if it will be returned in \s-1VMS\s0
format or in Unix format.
.PP
With the \s-1ODS\-2\s0 file system, there is not much difference in syntax of
filenames without paths for \s-1VMS\s0 or Unix.  With the extended character
set available with \s-1ODS\-5\s0 there can be a significant difference.
.PP
Because of this, existing Perl scripts written for \s-1VMS\s0 were sometimes
treating \s-1VMS\s0 and Unix filenames interchangeably.  Without the extended
character set enabled, this behavior will mostly be maintained for
backwards compatibility.
.PP
When extended characters are enabled with \s-1ODS\-5,\s0 the handling of
Unix formatted file specifications is to that of a Unix system.
.PP
\&\s-1VMS\s0 file specifications without extensions have a trailing dot.  An
equivalent Unix file specification should not show the trailing dot.
.PP
The result of all of this, is that for \s-1VMS,\s0 for portable scripts, you
can not depend on Perl to present the filenames in lowercase, to be
case sensitive, and that the filenames could be returned in either
Unix or \s-1VMS\s0 format.
.PP
And if a routine returns a file specification, unless it is intended to
convert it, it should return it in the same format as it found it.
.PP
\&\f(CW\*(C`readdir\*(C'\fR by default has traditionally returned lowercased filenames.
When the \s-1ODS\-5\s0 support is enabled, it will return the exact case of the
filename on the disk.
.PP
Files without extensions have a trailing period on them, so doing a
\&\f(CW\*(C`readdir\*(C'\fR in the default mode with a file named \fIA.;5\fR will
return \fIa.\fR when \s-1VMS\s0 is (though that file could be opened with
\&\f(CW\*(C`open(FH, \*(AqA\*(Aq)\*(C'\fR).
.PP
With support for extended file specifications and if \f(CW\*(C`opendir\*(C'\fR was
given a Unix format directory, a file named \fIA.;5\fR will return \fIa\fR
and optionally in the exact case on the disk.  When \f(CW\*(C`opendir\*(C'\fR is given
a \s-1VMS\s0 format directory, then \f(CW\*(C`readdir\*(C'\fR should return \fIa.\fR, and
again with the optionally the exact case.
.PP
\&\s-1RMS\s0 had an eight level limit on directory depths from any rooted logical
(allowing 16 levels overall) prior to \s-1VMS 7.2,\s0 and even with versions of
\&\s-1VMS\s0 on \s-1VAX\s0 up through 7.3.  Hence \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8]\*(C'\fR is a
valid directory specification but \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8.9]\*(C'\fR is
not.  \fIMakefile.PL\fR authors might have to take this into account, but at
least they can refer to the former as \f(CW\*(C`/PERL_ROOT/lib/2/3/4/5/6/7/8/\*(C'\fR.
.PP
Pumpkings and module integrators can easily see whether files with too many
directory levels have snuck into the core by running the following in the
top-level source directory:
.PP
.Vb 1
\& $ perl \-ne "$_=~s/\es+.*//; print if scalar(split /\e//) > 8;" < MANIFEST
.Ve
.PP
The VMS::Filespec module, which gets installed as part of the build
process on \s-1VMS,\s0 is a pure Perl module that can easily be installed on
non-VMS platforms and can be helpful for conversions to and from \s-1RMS\s0
native formats.  It is also now the only way that you should check to
see if \s-1VMS\s0 is in a case sensitive mode.
.PP
What \f(CW\*(C`\en\*(C'\fR represents depends on the type of file opened.  It usually
represents \f(CW\*(C`\e012\*(C'\fR but it could also be \f(CW\*(C`\e015\*(C'\fR, \f(CW\*(C`\e012\*(C'\fR, \f(CW\*(C`\e015\e012\*(C'\fR, 
\&\f(CW\*(C`\e000\*(C'\fR, \f(CW\*(C`\e040\*(C'\fR, or nothing depending on the file organization and 
record format.  The VMS::Stdio module provides access to the 
special \fIfopen()\fR requirements of files with unusual attributes on \s-1VMS.\s0
.PP
\&\s-1TCP/IP\s0 stacks are optional on \s-1VMS,\s0 so socket routines might not be
implemented.  \s-1UDP\s0 sockets may not be supported.
.PP
The \s-1TCP/IP\s0 library support for all current versions of \s-1VMS\s0 is dynamically
loaded if present, so even if the routines are configured, they may
return a status indicating that they are not implemented.
.PP
The value of \f(CW$^O\fR on OpenVMS is \*(L"\s-1VMS\*(R". \s0 To determine the architecture
that you are running on without resorting to loading all of \f(CW%Config\fR
you can examine the content of the \f(CW@INC\fR array like so:
.PP
.Vb 2
\&    if (grep(/VMS_AXP/, @INC)) {
\&        print "I\*(Aqm on Alpha!\en";
\&
\&    } elsif (grep(/VMS_VAX/, @INC)) {
\&        print "I\*(Aqm on VAX!\en";
\&
\&    } elsif (grep(/VMS_IA64/, @INC)) {
\&        print "I\*(Aqm on IA64!\en";
\&
\&    } else {
\&        print "I\*(Aqm not so sure about where $^O is...\en";
\&    }
.Ve
.PP
In general, the significant differences should only be if Perl is running
on \s-1VMS_VAX\s0 or one of the 64 bit OpenVMS platforms.
.PP
On \s-1VMS,\s0 perl determines the \s-1UTC\s0 offset from the \f(CW\*(C`SYS$TIMEZONE_DIFFERENTIAL\*(C'\fR
logical name.  Although the \s-1VMS\s0 epoch began at 17\-NOV\-1858 00:00:00.00,
calls to \f(CW\*(C`localtime\*(C'\fR are adjusted to count offsets from
01\-JAN\-1970 00:00:00.00, just like Unix.
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vms\fR (installed as \fIREADME_vms\fR), perlvms
.IP "\(bu" 4
vmsperl list, vmsperl\-subscribe@perl.org
.IP "\(bu" 4
vmsperl on the web, <http://www.sidhe.org/vmsperl/index.html>
.SS "\s-1VOS\s0"
.IX Subsection "VOS"
Perl on \s-1VOS \s0(also known as OpenVOS) is discussed in \fI\s-1README\s0.vos\fR
in the perl distribution (installed as perlvos).  Perl on \s-1VOS\s0
can accept either \s-1VOS\-\s0 or Unix-style file specifications as in
either of the following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" >system>notices
\&    $ perl \-ne "print if /perl_setup/i" /system/notices
.Ve
.PP
or even a mixture of both as in:
.PP
.Vb 1
\&    $ perl \-ne "print if /perl_setup/i" >system/notices
.Ve
.PP
Even though \s-1VOS\s0 allows the slash character to appear in object
names, because the \s-1VOS\s0 port of Perl interprets it as a pathname
delimiting character, \s-1VOS\s0 files, directories, or links whose
names contain a slash character cannot be processed.  Such files
must be renamed before they can be processed by Perl.
.PP
Older releases of \s-1VOS \s0(prior to OpenVOS Release 17.0) limit file
names to 32 or fewer characters, prohibit file names from
starting with a \f(CW\*(C`\-\*(C'\fR character, and prohibit file names from
containing any character matching \f(CW\*(C`tr/ !#%&\*(Aq()*;<=>?//\*(C'\fR.
.PP
Newer releases of \s-1VOS \s0(OpenVOS Release 17.0 or later) support a
feature known as extended names.  On these releases, file names
can contain up to 255 characters, are prohibited from starting
with a \f(CW\*(C`\-\*(C'\fR character, and the set of prohibited characters is
reduced to any character matching \f(CW\*(C`tr/#%*<>?//\*(C'\fR.  There are
restrictions involving spaces and apostrophes:  these characters
must not begin or end a name, nor can they immediately precede or
follow a period.  Additionally, a space must not immediately
precede another space or hyphen.  Specifically, the following
character combinations are prohibited:  space-space,
space-hyphen, period-space, space-period, period-apostrophe,
apostrophe-period, leading or trailing space, and leading or
trailing apostrophe.  Although an extended file name is limited
to 255 characters, a path name is still limited to 256
characters.
.PP
The value of \f(CW$^O\fR on \s-1VOS\s0 is \*(L"vos\*(R".  To determine the
architecture that you are running on without resorting to loading
all of \f(CW%Config\fR you can examine the content of the \f(CW@INC\fR array
like so:
.PP
.Vb 6
\&    if ($^O =~ /vos/) {
\&        print "I\*(Aqm on a Stratus box!\en";
\&    } else {
\&        print "I\*(Aqm not on a Stratus box!\en";
\&        die;
\&    }
.Ve
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vos\fR (installed as perlvos)
.IP "\(bu" 4
The \s-1VOS\s0 mailing list.
.Sp
There is no specific mailing list for Perl on \s-1VOS. \s0 You can contact
the Stratus Technologies Customer Assistance Center (\s-1CAC\s0) for your
region, or you can use the contact information located in the
distribution files on the Stratus Anonymous \s-1FTP\s0 site.
.IP "\(bu" 4
Stratus Technologies on the web at <http://www.stratus.com>
.IP "\(bu" 4
\&\s-1VOS\s0 Open-Source Software on the web at <http://ftp.stratus.com/pub/vos/vos.html>
.SS "\s-1EBCDIC\s0 Platforms"
.IX Subsection "EBCDIC Platforms"
Recent versions of Perl have been ported to platforms such as \s-1OS/400\s0 on
\&\s-1AS/400\s0 minicomputers as well as \s-1OS/390, VM/ESA,\s0 and \s-1BS2000\s0 for S/390
Mainframes.  Such computers use \s-1EBCDIC\s0 character sets internally (usually
Character Code Set \s-1ID 0037\s0 for \s-1OS/400\s0 and either 1047 or POSIX-BC for S/390
systems).  On the mainframe perl currently works under the \*(L"Unix system
services for \s-1OS/390\*(R" \s0(formerly known as OpenEdition), \s-1VM/ESA\s0 OpenEdition, or
the \s-1BS200\s0 POSIX-BC system (\s-1BS2000\s0 is supported in perl 5.6 and greater).
See perlos390 for details.  Note that for \s-1OS/400\s0 there is also a port of
Perl 5.8.1/5.10.0 or later to the \s-1PASE\s0 which is ASCII-based (as opposed to
\&\s-1ILE\s0 which is EBCDIC-based), see perlos400.
.PP
As of R2.5 of \s-1USS\s0 for \s-1OS/390\s0 and Version 2.3 of \s-1VM/ESA\s0 these Unix
sub-systems do not support the \f(CW\*(C`#!\*(C'\fR shebang trick for script invocation.
Hence, on \s-1OS/390\s0 and \s-1VM/ESA\s0 perl scripts can be executed with a header
similar to the following simple script:
.PP
.Vb 4
\&    : # use perl
\&        eval \*(Aqexec /usr/local/bin/perl \-S $0 ${1+"$@"}\*(Aq
\&            if 0;
\&    #!/usr/local/bin/perl     # just a comment really
\&
\&    print "Hello from perl!\en";
.Ve
.PP
\&\s-1OS/390\s0 will support the \f(CW\*(C`#!\*(C'\fR shebang trick in release 2.8 and beyond.
Calls to \f(CW\*(C`system\*(C'\fR and backticks can use \s-1POSIX\s0 shell syntax on all
S/390 systems.
.PP
On the \s-1AS/400,\s0 if \s-1PERL5\s0 is in your library list, you may need
to wrap your perl scripts in a \s-1CL\s0 procedure to invoke them like so:
.PP
.Vb 3
\&    BEGIN
\&      CALL PGM(PERL5/PERL) PARM(\*(Aq/QOpenSys/hello.pl\*(Aq)
\&    ENDPGM
.Ve
.PP
This will invoke the perl script \fIhello.pl\fR in the root of the
QOpenSys file system.  On the \s-1AS/400\s0 calls to \f(CW\*(C`system\*(C'\fR or backticks
must use \s-1CL\s0 syntax.
.PP
On these platforms, bear in mind that the \s-1EBCDIC\s0 character set may have
an effect on what happens with some perl functions (such as \f(CW\*(C`chr\*(C'\fR,
\&\f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR), as
well as bit-fiddling with \s-1ASCII\s0 constants using operators like \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`&\*(C'\fR
and \f(CW\*(C`|\*(C'\fR, not to mention dealing with socket interfaces to \s-1ASCII\s0 computers
(see \*(L"Newlines\*(R").
.PP
Fortunately, most web servers for the mainframe will correctly
translate the \f(CW\*(C`\en\*(C'\fR in the following statement to its \s-1ASCII\s0 equivalent
(\f(CW\*(C`\er\*(C'\fR is the same under both Unix and \s-1OS/390\s0):
.PP
.Vb 1
\&    print "Content\-type: text/html\er\en\er\en";
.Ve
.PP
The values of \f(CW$^O\fR on some of these platforms includes:
.PP
.Vb 5
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    OS/390        os390      os390
\&    OS400         os400      os400
\&    POSIX\-BC      posix\-bc   BS2000\-posix\-bc
.Ve
.PP
Some simple tricks for determining if you are running on an \s-1EBCDIC\s0
platform could include any of the following (perhaps all):
.PP
.Vb 1
\&    if ("\et" eq "\e005")   { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (ord(\*(AqA\*(Aq) == 193) { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (chr(169) eq \*(Aqz\*(Aq) { print "EBCDIC may be spoken here!\en"; }
.Ve
.PP
One thing you may not want to rely on is the \s-1EBCDIC\s0 encoding
of punctuation characters since these may differ from code page to code
page (and once your module or script is rumoured to work with \s-1EBCDIC,\s0
folks will want it to work with all \s-1EBCDIC\s0 character sets).
.PP
Also see:
.IP "\(bu" 4
perlos390, \fI\s-1README\s0.os390\fR, \fIperlbs2000\fR, perlebcdic.
.IP "\(bu" 4
The perl\-mvs@perl.org list is for discussion of porting issues as well as
general usage issues for all \s-1EBCDIC\s0 Perls.  Send a message body of
\&\*(L"subscribe perl-mvs\*(R" to majordomo@perl.org.
.IP "\(bu" 4
\&\s-1AS/400\s0 Perl information at
<http://as400.rochester.ibm.com/>
as well as on \s-1CPAN\s0 in the \fIports/\fR directory.
.SS "Acorn \s-1RISC OS\s0"
.IX Subsection "Acorn RISC OS"
Because Acorns use \s-1ASCII\s0 with newlines (\f(CW\*(C`\en\*(C'\fR) in text files as \f(CW\*(C`\e012\*(C'\fR like
Unix, and because Unix filename emulation is turned on by default, 
most simple scripts will probably work \*(L"out of the box\*(R".  The native
filesystem is modular, and individual filesystems are free to be
case-sensitive or insensitive, and are usually case-preserving.  Some
native filesystems have name length limits, which file and directory
names are silently truncated to fit.  Scripts should be aware that the
standard filesystem currently has a name length limit of \fB10\fR
characters, with up to 77 items in a directory, but other filesystems
may not impose such limitations.
.PP
Native filenames are of the form
.PP
.Vb 1
\&    Filesystem#Special_Field::DiskName.$.Directory.Directory.File
.Ve
.PP
where
.PP
.Vb 8
\&    Special_Field is not usually present, but may contain . and $ .
\&    Filesystem =~ m|[A\-Za\-z0\-9_]|
\&    DsicName   =~ m|[A\-Za\-z0\-9_/]|
\&    $ represents the root directory
\&    . is the path separator
\&    @ is the current directory (per filesystem but machine global)
\&    ^ is the parent directory
\&    Directory and File =~ m|[^\e0\- "\e.\e$\e%\e&:\e@\e\e^\e|\e177]+|
.Ve
.PP
The default filename translation is roughly \f(CW\*(C`tr|/.|./|;\*(C'\fR
.PP
Note that \f(CW\*(C`"ADFS::HardDisk.$.File" ne \*(AqADFS::HardDisk.$.File\*(Aq\*(C'\fR and that
the second stage of \f(CW\*(C`$\*(C'\fR interpolation in regular expressions will fall
foul of the \f(CW$.\fR if scripts are not careful.
.PP
Logical paths specified by system variables containing comma-separated
search lists are also allowed; hence \f(CW\*(C`System:Modules\*(C'\fR is a valid
filename, and the filesystem will prefix \f(CW\*(C`Modules\*(C'\fR with each section of
\&\f(CW\*(C`System$Path\*(C'\fR until a name is made that points to an object on disk.
Writing to a new file \f(CW\*(C`System:Modules\*(C'\fR would be allowed only if
\&\f(CW\*(C`System$Path\*(C'\fR contains a single item list.  The filesystem will also
expand system variables in filenames if enclosed in angle brackets, so
\&\f(CW\*(C`<System$Dir>.Modules\*(C'\fR would look for the file
\&\f(CW\*(C`$ENV{\*(AqSystem$Dir\*(Aq}\ .\ \*(AqModules\*(Aq\*(C'\fR.  The obvious implication of this is
that \fBfully qualified filenames can start with \f(CB\*(C`<>\*(C'\fB\fR and should
be protected when \f(CW\*(C`open\*(C'\fR is used for input.
.PP
Because \f(CW\*(C`.\*(C'\fR was in use as a directory separator and filenames could not
be assumed to be unique after 10 characters, Acorn implemented the C
compiler to strip the trailing \f(CW\*(C`.c\*(C'\fR \f(CW\*(C`.h\*(C'\fR \f(CW\*(C`.s\*(C'\fR and \f(CW\*(C`.o\*(C'\fR suffix from
filenames specified in source code and store the respective files in
subdirectories named after the suffix.  Hence files are translated:
.PP
.Vb 6
\&    foo.h           h.foo
\&    C:foo.h         C:h.foo        (logical path variable)
\&    sys/os.h        sys.h.os       (C compiler groks Unix\-speak)
\&    10charname.c    c.10charname
\&    10charname.o    o.10charname
\&    11charname_.c   c.11charname   (assuming filesystem truncates at 10)
.Ve
.PP
The Unix emulation library's translation of filenames to native assumes
that this sort of translation is required, and it allows a user-defined list
of known suffixes that it will transpose in this fashion.  This may
seem transparent, but consider that with these rules \fIfoo/bar/baz.h\fR
and \fIfoo/bar/h/baz\fR both map to \fIfoo.bar.h.baz\fR, and that \f(CW\*(C`readdir\*(C'\fR and
\&\f(CW\*(C`glob\*(C'\fR cannot and do not attempt to emulate the reverse mapping.  Other
\&\f(CW\*(C`.\*(C'\fR's in filenames are translated to \f(CW\*(C`/\*(C'\fR.
.PP
As implied above, the environment accessed through \f(CW%ENV\fR is global, and
the convention is that program specific environment variables are of the
form \f(CW\*(C`Program$Name\*(C'\fR.  Each filesystem maintains a current directory,
and the current filesystem's current directory is the \fBglobal\fR current
directory.  Consequently, sociable programs don't change the current
directory but rely on full pathnames, and programs (and Makefiles) cannot
assume that they can spawn a child process which can change the current
directory without affecting its parent (and everyone else for that
matter).
.PP
Because native operating system filehandles are global and are currently 
allocated down from 255, with 0 being a reserved value, the Unix emulation
library emulates Unix filehandles.  Consequently, you can't rely on
passing \f(CW\*(C`STDIN\*(C'\fR, \f(CW\*(C`STDOUT\*(C'\fR, or \f(CW\*(C`STDERR\*(C'\fR to your children.
.PP
The desire of users to express filenames of the form
\&\f(CW\*(C`<Foo$Dir>.Bar\*(C'\fR on the command line unquoted causes problems,
too: \f(CW\*(C`\`\`\*(C'\fR command output capture has to perform a guessing game.  It
assumes that a string \f(CW\*(C`<[^<>]+\e$[^<>]>\*(C'\fR is a
reference to an environment variable, whereas anything else involving
\&\f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR is redirection, and generally manages to be 99%
right.  Of course, the problem remains that scripts cannot rely on any
Unix tools being available, or that any tools found have Unix-like command
line arguments.
.PP
Extensions and \s-1XS\s0 are, in theory, buildable by anyone using free
tools.  In practice, many don't, as users of the Acorn platform are
used to binary distributions.  MakeMaker does run, but no available
make currently copes with MakeMaker's makefiles; even if and when
this should be fixed, the lack of a Unix-like shell will cause
problems with makefile rules, especially lines of the form \f(CW\*(C`cd
sdbm && make all\*(C'\fR, and anything using quoting.
.PP
\&\*(L"\s-1RISC\s0\ \s-1OS\*(R"\s0 is the proper name for the operating system, but the value
in \f(CW$^O\fR is \*(L"riscos\*(R" (because we don't like shouting).
.SS "Other perls"
.IX Subsection "Other perls"
Perl has been ported to many platforms that do not fit into any of
the categories listed above.  Some, such as AmigaOS,
\&\s-1QNX,\s0 Plan 9, and \s-1VOS,\s0 have been well-integrated into the standard
Perl source code kit.  You may need to see the \fIports/\fR directory
on \s-1CPAN\s0 for information, and possibly binaries, for the likes of:
aos, Atari \s-1ST,\s0 lynxos, riscos, Novell Netware, Tandem Guardian,
\&\fIetc.\fR  (Yes, we know that some of these OSes may fall under the
Unix category, but we are not a standards body.)
.PP
Some approximate operating system names and their \f(CW$^O\fR values
in the \*(L"\s-1OTHER\*(R"\s0 category include:
.PP
.Vb 3
\&    OS            $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Amiga DOS     amigaos    m68k\-amigos
.Ve
.PP
See also:
.IP "\(bu" 4
Amiga, \fI\s-1README\s0.amiga\fR (installed as perlamiga).
.IP "\(bu" 4
A free perl5\-based \s-1PERL.NLM\s0 for Novell Netware is available in
precompiled binary and source code form from <http://www.novell.com/>
as well as from \s-1CPAN.\s0
.IP "\(bu" 4
Plan\ 9, \fI\s-1README\s0.plan9\fR
.SH "FUNCTION IMPLEMENTATIONS"
.IX Header "FUNCTION IMPLEMENTATIONS"
Listed below are functions that are either completely unimplemented
or else have been implemented differently on various platforms.
Following each description will be, in parentheses, a list of
platforms that the description applies to.
.PP
The list may well be incomplete, or even wrong in some places.  When
in doubt, consult the platform-specific \s-1README\s0 files in the Perl
source distribution, and any other documentation resources accompanying
a given port.
.PP
Be aware, moreover, that even among Unix-ish systems there are variations.
.PP
For many functions, you can also query \f(CW%Config\fR, exported by
default from the Config module.  For example, to check whether the
platform has the \f(CW\*(C`lstat\*(C'\fR call, check \f(CW$Config{d_lstat}\fR.  See
Config for a full description of available variables.
.SS "Alphabetical Listing of Perl Functions"
.IX Subsection "Alphabetical Listing of Perl Functions"
.IP "\-X" 8
.IX Item "-X"
\&\f(CW\*(C`\-w\*(C'\fR only inspects the read-only file attribute (\s-1FILE_ATTRIBUTE_READONLY\s0),
which determines whether the directory can be deleted, not whether it can
be written to. Directories always have read and write access unless denied
by discretionary access control lists (DACLs).  (Win32)
.Sp
\&\f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, and \f(CW\*(C`\-o\*(C'\fR tell whether the file is accessible,
which may not reflect UIC-based file protections.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-s\*(C'\fR by name on an open file will return the space reserved on disk,
rather than the current extent.  \f(CW\*(C`\-s\*(C'\fR on an open filehandle returns the
current size.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR, \f(CW\*(C`\-X\*(C'\fR, \f(CW\*(C`\-O\*(C'\fR are indistinguishable from \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR,
\&\f(CW\*(C`\-x\*(C'\fR, \f(CW\*(C`\-o\*(C'\fR. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-g\*(C'\fR, \f(CW\*(C`\-k\*(C'\fR, \f(CW\*(C`\-l\*(C'\fR, \f(CW\*(C`\-u\*(C'\fR, \f(CW\*(C`\-A\*(C'\fR are not particularly meaningful.
(Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-p\*(C'\fR is not particularly meaningful. (\s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-d\*(C'\fR is true if passed a device spec without an explicit directory.
(\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a file ends in one of the executable
suffixes.  \f(CW\*(C`\-S\*(C'\fR is meaningless.  (Win32)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a file has an executable file type.
(\s-1RISC\s0\ \s-1OS\s0)
.IP "alarm" 8
.IX Item "alarm"
Emulated using timers that must be explicitly polled whenever Perl
wants to dispatch \*(L"safe signals\*(R" and therefore cannot interrupt
blocking system calls.  (Win32)
.IP "atan2" 8
.IX Item "atan2"
Due to issues with various CPUs, math libraries, compilers, and standards,
results for \f(CW\*(C`atan2()\*(C'\fR may vary depending on any combination of the above.
Perl attempts to conform to the Open Group/IEEE standards for the results
returned from \f(CW\*(C`atan2()\*(C'\fR, but cannot force the issue if the system Perl is
run on does not allow it.  (Tru64, HP-UX 10.20)
.Sp
The current version of the standards for \f(CW\*(C`atan2()\*(C'\fR is available at 
<http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html>.
.IP "binmode" 8
.IX Item "binmode"
Meaningless.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Reopens file and restores pointer; if function fails, underlying
filehandle may be closed, or pointer may be in a different position.
(\s-1VMS\s0)
.Sp
The value returned by \f(CW\*(C`tell\*(C'\fR may be affected after the call, and
the filehandle may be flushed. (Win32)
.IP "chmod" 8
.IX Item "chmod"
Only good for changing \*(L"owner\*(R" read-write access, \*(L"group\*(R", and \*(L"other\*(R"
bits are meaningless. (Win32)
.Sp
Only good for changing \*(L"owner\*(R" and \*(L"other\*(R" read-write access. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Access permissions are mapped onto \s-1VOS\s0 access-control list changes. (\s-1VOS\s0)
.Sp
The actual permissions set depend on the value of the \f(CW\*(C`CYGWIN\*(C'\fR
in the \s-1SYSTEM\s0 environment settings.  (Cygwin)
.IP "chown" 8
.IX Item "chown"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Does nothing, but won't fail. (Win32)
.Sp
A little funky, because \s-1VOS\s0's notion of ownership is a little funky (\s-1VOS\s0).
.IP "chroot" 8
.IX Item "chroot"
Not implemented. (Win32, \s-1VMS,\s0 Plan\ 9, \s-1RISC\s0\ \s-1OS, VOS\s0)
.IP "crypt" 8
.IX Item "crypt"
May not be available if library or source was not provided when building
perl. (Win32)
.IP "dbmclose" 8
.IX Item "dbmclose"
Not implemented. (\s-1VMS,\s0 Plan\ 9, \s-1VOS\s0)
.IP "dbmopen" 8
.IX Item "dbmopen"
Not implemented. (\s-1VMS,\s0 Plan\ 9, \s-1VOS\s0)
.IP "dump" 8
.IX Item "dump"
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Not supported. (Cygwin, Win32)
.Sp
Invokes \s-1VMS\s0 debugger. (\s-1VMS\s0)
.IP "exec" 8
.IX Item "exec"
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
Not supported. (Symbian \s-1OS\s0)
.IP "exit" 8
.IX Item "exit"
Emulates Unix \fIexit()\fR (which considers \f(CW\*(C`exit 1\*(C'\fR to indicate an error) by
mapping the \f(CW1\fR to \s-1SS$_ABORT \s0(\f(CW44\fR).  This behavior may be overridden
with the pragma \f(CW\*(C`use vmsish \*(Aqexit\*(Aq\*(C'\fR.  As with the \s-1CRTL\s0's \fIexit()\fR
function, \f(CW\*(C`exit 0\*(C'\fR is also mapped to an exit status of \s-1SS$_NORMAL
\&\s0(\f(CW1\fR); this mapping cannot be overridden.  Any other argument to \fIexit()\fR
is used directly as Perl's exit status.  On \s-1VMS,\s0 unless the future
\&\s-1POSIX_EXIT\s0 mode is enabled, the exit code should always be a valid
\&\s-1VMS\s0 exit code and not a generic number.  When the \s-1POSIX_EXIT\s0 mode is
enabled, a generic number will be encoded in a method compatible with
the C library _POSIX_EXIT macro so that it can be decoded by other
programs, particularly ones written in C, like the \s-1GNV\s0 package.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`exit()\*(C'\fR resets file pointers, which is a problem when called 
from a child process (created by \f(CW\*(C`fork()\*(C'\fR) in \f(CW\*(C`BEGIN\*(C'\fR.  
A workaround is to use \f(CW\*(C`POSIX::_exit\*(C'\fR.  (Solaris)
.Sp
.Vb 2
\&    exit unless $Config{archname} =~ /\ebsolaris\eb/;
\&    require POSIX and POSIX::_exit(0);
.Ve
.IP "fcntl" 8
.IX Item "fcntl"
Not implemented. (Win32)
.Sp
Some functions available based on the version of \s-1VMS. \s0(\s-1VMS\s0)
.IP "flock" 8
.IX Item "flock"
Not implemented (\s-1VMS, RISC\s0\ \s-1OS, VOS\s0).
.IP "fork" 8
.IX Item "fork"
Not implemented. (AmigaOS, \s-1RISC\s0\ \s-1OS, VMS\s0)
.Sp
Emulated using multiple interpreters.  See perlfork.  (Win32)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.IP "getlogin" 8
.IX Item "getlogin"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getpgrp" 8
.IX Item "getpgrp"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getppid" 8
.IX Item "getppid"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "getpriority" 8
.IX Item "getpriority"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "getpwnam" 8
.IX Item "getpwnam"
Not implemented. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrnam" 8
.IX Item "getgrnam"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getnetbyname" 8
.IX Item "getnetbyname"
Not implemented. (Win32, Plan\ 9)
.IP "getpwuid" 8
.IX Item "getpwuid"
Not implemented. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrgid" 8
.IX Item "getgrgid"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getnetbyaddr" 8
.IX Item "getnetbyaddr"
Not implemented. (Win32, Plan\ 9)
.IP "getprotobynumber" 8
.IX Item "getprotobynumber"
.PD 0
.IP "getservbyport" 8
.IX Item "getservbyport"
.IP "getpwent" 8
.IX Item "getpwent"
.PD
Not implemented. (Win32)
.IP "getgrent" 8
.IX Item "getgrent"
Not implemented. (Win32, \s-1VMS\s0)
.IP "gethostbyname" 8
.IX Item "gethostbyname"
\&\f(CW\*(C`gethostbyname(\*(Aqlocalhost\*(Aq)\*(C'\fR does not work everywhere: you may have
to use \f(CW\*(C`gethostbyname(\*(Aq127.0.0.1\*(Aq)\*(C'\fR. (Irix\ 5)
.IP "gethostent" 8
.IX Item "gethostent"
Not implemented. (Win32)
.IP "getnetent" 8
.IX Item "getnetent"
Not implemented. (Win32, Plan\ 9)
.IP "getprotoent" 8
.IX Item "getprotoent"
Not implemented. (Win32, Plan\ 9)
.IP "getservent" 8
.IX Item "getservent"
Not implemented. (Win32, Plan\ 9)
.IP "sethostent" 8
.IX Item "sethostent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setnetent" 8
.IX Item "setnetent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setprotoent" 8
.IX Item "setprotoent"
Not implemented. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setservent" 8
.IX Item "setservent"
Not implemented. (Plan\ 9, Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "endpwent" 8
.IX Item "endpwent"
Not implemented. (Win32)
.IP "endgrent" 8
.IX Item "endgrent"
Not implemented. (\s-1RISC\s0\ \s-1OS, VMS,\s0 Win32)
.IP "endhostent" 8
.IX Item "endhostent"
Not implemented. (Win32)
.IP "endnetent" 8
.IX Item "endnetent"
Not implemented. (Win32, Plan\ 9)
.IP "endprotoent" 8
.IX Item "endprotoent"
Not implemented. (Win32, Plan\ 9)
.IP "endservent" 8
.IX Item "endservent"
Not implemented. (Plan\ 9, Win32)
.IP "getsockopt \s-1SOCKET,LEVEL,OPTNAME\s0" 8
.IX Item "getsockopt SOCKET,LEVEL,OPTNAME"
Not implemented. (Plan\ 9)
.IP "glob" 8
.IX Item "glob"
This operator is implemented via the File::Glob extension on most
platforms.  See File::Glob for portability information.
.IP "gmtime" 8
.IX Item "gmtime"
In theory, \fIgmtime()\fR is reliable from \-2**63 to 2**63\-1.  However,
because work arounds in the implementation use floating point numbers,
it will become inaccurate as the time gets larger.  This is a bug and
will be fixed in the future.
.Sp
On \s-1VOS,\s0 time values are 32\-bit quantities.
.IP "ioctl \s-1FILEHANDLE,FUNCTION,SCALAR\s0" 8
.IX Item "ioctl FILEHANDLE,FUNCTION,SCALAR"
Not implemented. (\s-1VMS\s0)
.Sp
Available only for socket handles, and it does what the \fIioctlsocket()\fR call
in the Winsock \s-1API\s0 does. (Win32)
.Sp
Available only for socket handles. (\s-1RISC\s0\ \s-1OS\s0)
.IP "kill" 8
.IX Item "kill"
Not implemented, hence not useful for taint checking. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`kill()\*(C'\fR doesn't have the semantics of \f(CW\*(C`raise()\*(C'\fR, i.e. it doesn't send
a signal to the identified process like it does on Unix platforms.
Instead \f(CW\*(C`kill($sig, $pid)\*(C'\fR terminates the process identified by \f(CW$pid\fR,
and makes it exit immediately with exit status \f(CW$sig\fR.  As in Unix, if
\&\f(CW$sig\fR is 0 and the specified process exists, it returns true without
actually terminating it. (Win32)
.Sp
\&\f(CW\*(C`kill(\-9, $pid)\*(C'\fR will terminate the process specified by \f(CW$pid\fR and
recursively all child processes owned by it.  This is different from
the Unix semantics, where the signal will be delivered to all
processes in the same process group as the process specified by
\&\f(CW$pid\fR. (Win32)
.Sp
Is not supported for process identification number of 0 or negative
numbers. (\s-1VMS\s0)
.IP "link" 8
.IX Item "link"
Not implemented. (\s-1RISC\s0\ \s-1OS, VOS\s0)
.Sp
Link count not updated because hard links are not quite that hard
(They are sort of half-way between hard and soft links). (AmigaOS)
.Sp
Hard links are implemented on Win32 under \s-1NTFS\s0 only. They are
natively supported on Windows 2000 and later.  On Windows \s-1NT\s0 they
are implemented using the Windows \s-1POSIX\s0 subsystem support and the
Perl process will need Administrator or Backup Operator privileges
to create hard links.
.Sp
Available on 64 bit OpenVMS 8.2 and later.  (\s-1VMS\s0)
.IP "localtime" 8
.IX Item "localtime"
\&\fIlocaltime()\fR has the same range as \*(L"gmtime\*(R", but because time zone
rules change its accuracy for historical and future times may degrade
but usually by no more than an hour.
.IP "lstat" 8
.IX Item "lstat"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Return values (especially for device and inode) may be bogus. (Win32)
.IP "msgctl" 8
.IX Item "msgctl"
.PD 0
.IP "msgget" 8
.IX Item "msgget"
.IP "msgsnd" 8
.IX Item "msgsnd"
.IP "msgrcv" 8
.IX Item "msgrcv"
.PD
Not implemented. (Win32, \s-1VMS,\s0 Plan\ 9, \s-1RISC\s0\ \s-1OS, VOS\s0)
.IP "open" 8
.IX Item "open"
open to \f(CW\*(C`|\-\*(C'\fR and \f(CW\*(C`\-|\*(C'\fR are unsupported. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Opening a process does not automatically flush output handles on some
platforms.  (SunOS, Solaris, HP-UX)
.IP "readlink" 8
.IX Item "readlink"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "rename" 8
.IX Item "rename"
Can't move directories between directories on different logical volumes. (Win32)
.IP "rewinddir" 8
.IX Item "rewinddir"
Will not cause \fIreaddir()\fR to re-read the directory stream.  The entries
already read before the \fIrewinddir()\fR call will just be returned again
from a cache buffer. (Win32)
.IP "select" 8
.IX Item "select"
Only implemented on sockets. (Win32, \s-1VMS\s0)
.Sp
Only reliable on sockets. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Note that the \f(CW\*(C`select FILEHANDLE\*(C'\fR form is generally portable.
.IP "semctl" 8
.IX Item "semctl"
.PD 0
.IP "semget" 8
.IX Item "semget"
.IP "semop" 8
.IX Item "semop"
.PD
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "setgrent" 8
.IX Item "setgrent"
Not implemented. (\s-1VMS,\s0 Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setpgrp" 8
.IX Item "setpgrp"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "setpriority" 8
.IX Item "setpriority"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "setpwent" 8
.IX Item "setpwent"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setsockopt" 8
.IX Item "setsockopt"
Not implemented. (Plan\ 9)
.IP "shmctl" 8
.IX Item "shmctl"
.PD 0
.IP "shmget" 8
.IX Item "shmget"
.IP "shmread" 8
.IX Item "shmread"
.IP "shmwrite" 8
.IX Item "shmwrite"
.PD
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "sleep" 8
.IX Item "sleep"
Emulated using synchronization functions such that it can be
interrupted by \fIalarm()\fR, and limited to a maximum of 4294967 seconds,
approximately 49 days. (Win32)
.IP "sockatmark" 8
.IX Item "sockatmark"
A relatively recent addition to socket functions, may not
be implemented even in Unix platforms.
.IP "socketpair" 8
.IX Item "socketpair"
Not implemented. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Available on 64 bit OpenVMS 8.2 and later.  (\s-1VMS\s0)
.IP "stat" 8
.IX Item "stat"
Platforms that do not have rdev, blksize, or blocks will return these
as '', so numeric comparison or manipulation of these fields may cause
\&'not numeric' warnings.
.Sp
ctime not supported on \s-1UFS \s0(Mac\ \s-1OS\s0\ X).
.Sp
ctime is creation time instead of inode change time  (Win32).
.Sp
device and inode are not meaningful.  (Win32)
.Sp
device and inode are not necessarily reliable.  (\s-1VMS\s0)
.Sp
mtime, atime and ctime all return the last modification time.  Device and
inode are not necessarily reliable.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
dev, rdev, blksize, and blocks are not available.  inode is not
meaningful and will differ between stat calls on the same file.  (os2)
.Sp
some versions of cygwin when doing a stat(\*(L"foo\*(R") and if not finding it
may then attempt to stat(\*(L"foo.exe\*(R") (Cygwin)
.Sp
On Win32 \fIstat()\fR needs to open the file to determine the link count
and update attributes that may have been changed through hard links.
Setting ${^WIN32_SLOPPY_STAT} to a true value speeds up \fIstat()\fR by
not performing this operation. (Win32)
.IP "symlink" 8
.IX Item "symlink"
Not implemented. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Implemented on 64 bit \s-1VMS 8.3.  VMS\s0 requires the symbolic link to be in Unix
syntax if it is intended to resolve to a valid path.
.IP "syscall" 8
.IX Item "syscall"
Not implemented. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "sysopen" 8
.IX Item "sysopen"
The traditional \*(L"0\*(R", \*(L"1\*(R", and \*(L"2\*(R" MODEs are implemented with different
numeric values on some systems.  The flags exported by \f(CW\*(C`Fcntl\*(C'\fR
(O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though.  (Mac\ \s-1OS, OS/390\s0)
.IP "system" 8
.IX Item "system"
As an optimization, may not call the command shell specified in
\&\f(CW$ENV{PERL5SHELL}\fR.  \f(CW\*(C`system(1, @args)\*(C'\fR spawns an external
process and immediately returns its process designator, without
waiting for it to terminate.  Return value may be used subsequently
in \f(CW\*(C`wait\*(C'\fR or \f(CW\*(C`waitpid\*(C'\fR.  Failure to \fIspawn()\fR a subprocess is indicated
by setting $? to \*(L"255 << 8\*(R".  \f(CW$?\fR is set in a way compatible with
Unix (i.e. the exitstatus of the subprocess is obtained by \*(L"$? >> 8\*(R",
as described in the documentation).  (Win32)
.Sp
There is no shell to process metacharacters, and the native standard is
to pass a command line terminated by \*(L"\en\*(R" \*(L"\er\*(R" or \*(L"\e0\*(R" to the spawned
program.  Redirection such as \f(CW\*(C`> foo\*(C'\fR is performed (if at all) by
the run time library of the spawned program.  \f(CW\*(C`system\*(C'\fR \fIlist\fR will call
the Unix emulation library's \f(CW\*(C`exec\*(C'\fR emulation, which attempts to provide
emulation of the stdin, stdout, stderr in force in the parent, providing
the child program uses a compatible version of the emulation library.
\&\fIscalar\fR will call the native command line direct and no such emulation
of a child Unix program will exists.  Mileage \fBwill\fR vary.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Does not automatically flush output handles on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
The return value is POSIX-like (shifted up by 8 bits), which only allows
room for a made-up value derived from the severity bits of the native
32\-bit condition code (unless overridden by \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR). 
If the native condition code is one that has a \s-1POSIX\s0 value encoded, the
\&\s-1POSIX\s0 value will be decoded to extract the expected exit value.
For more details see \*(L"$?\*(R" in perlvms. (\s-1VMS\s0)
.IP "times" 8
.IX Item "times"
\&\*(L"cumulative\*(R" times will be bogus.  On anything other than Windows \s-1NT\s0
or Windows 2000, \*(L"system\*(R" time will be bogus, and \*(L"user\*(R" time is
actually the time returned by the \fIclock()\fR function in the C runtime
library. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.IP "truncate" 8
.IX Item "truncate"
Not implemented. (Older versions of \s-1VMS\s0)
.Sp
Truncation to same-or-shorter lengths only. (\s-1VOS\s0)
.Sp
If a \s-1FILEHANDLE\s0 is supplied, it must be writable and opened in append
mode (i.e., use \f(CW\*(C`open(FH, \*(Aq>>filename\*(Aq)\*(C'\fR
or \f(CW\*(C`sysopen(FH,...,O_APPEND|O_RDWR)\*(C'\fR.  If a filename is supplied, it
should not be held open elsewhere. (Win32)
.IP "umask" 8
.IX Item "umask"
Returns undef where unavailable.
.Sp
\&\f(CW\*(C`umask\*(C'\fR works but the correct permissions are set only when the file
is finally closed. (AmigaOS)
.IP "utime" 8
.IX Item "utime"
Only the modification time is updated. (\s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
May not behave as expected.  Behavior depends on the C runtime
library's implementation of \fIutime()\fR, and the filesystem being
used.  The \s-1FAT\s0 filesystem typically does not support an \*(L"access
time\*(R" field, and it may limit timestamps to a granularity of
two seconds. (Win32)
.IP "wait" 8
.IX Item "wait"
.PD 0
.IP "waitpid" 8
.IX Item "waitpid"
.PD
Can only be applied to process handles returned for processes spawned
using \f(CW\*(C`system(1, ...)\*(C'\fR or pseudo processes created with \f(CW\*(C`fork()\*(C'\fR. (Win32)
.Sp
Not useful. (\s-1RISC\s0\ \s-1OS\s0)
.SH "Supported Platforms"
.IX Header "Supported Platforms"
The following platforms are known to build Perl 5.12 (as of April 2010,
its release date) from the standard source code distribution available
at <http://www.cpan.org/src>
.IP "Linux (x86, \s-1ARM, IA64\s0)" 4
.IX Item "Linux (x86, ARM, IA64)"
.PD 0
.IP "HP-UX" 4
.IX Item "HP-UX"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.IP "Win32" 4
.IX Item "Win32"
.RS 4
.IP "Windows 2000" 4
.IX Item "Windows 2000"
.IP "Windows \s-1XP\s0" 4
.IX Item "Windows XP"
.IP "Windows Server 2003" 4
.IX Item "Windows Server 2003"
.IP "Windows Vista" 4
.IX Item "Windows Vista"
.IP "Windows Server 2008" 4
.IX Item "Windows Server 2008"
.IP "Windows 7" 4
.IX Item "Windows 7"
.RE
.RS 4
.RE
.IP "Cygwin" 4
.IX Item "Cygwin"
.IP "Solaris (x86, \s-1SPARC\s0)" 4
.IX Item "Solaris (x86, SPARC)"
.IP "OpenVMS" 4
.IX Item "OpenVMS"
.RS 4
.IP "Alpha (7.2 and later)" 4
.IX Item "Alpha (7.2 and later)"
.IP "I64 (8.2 and later)" 4
.IX Item "I64 (8.2 and later)"
.RE
.RS 4
.RE
.IP "Symbian" 4
.IX Item "Symbian"
.IP "NetBSD" 4
.IX Item "NetBSD"
.IP "FreeBSD" 4
.IX Item "FreeBSD"
.IP "Debian GNU/kFreeBSD" 4
.IX Item "Debian GNU/kFreeBSD"
.IP "Haiku" 4
.IX Item "Haiku"
.IP "Irix (6.5. What else?)" 4
.IX Item "Irix (6.5. What else?)"
.IP "OpenBSD" 4
.IX Item "OpenBSD"
.IP "Dragonfly \s-1BSD\s0" 4
.IX Item "Dragonfly BSD"
.IP "Midnight \s-1BSD\s0" 4
.IX Item "Midnight BSD"
.IP "\s-1QNX\s0 Neutrino \s-1RTOS \s0(6.5.0)" 4
.IX Item "QNX Neutrino RTOS (6.5.0)"
.IP "MirOS \s-1BSD\s0" 4
.IX Item "MirOS BSD"
.IP "Stratus OpenVOS (17.0 or later)" 4
.IX Item "Stratus OpenVOS (17.0 or later)"
.PD
Caveats:
.RS 4
.IP "time_t issues that may or may not be fixed" 4
.IX Item "time_t issues that may or may not be fixed"
.RE
.RS 4
.RE
.PD 0
.IP "Symbian (Series 60 v3, 3.2 and 5 \- what else?)" 4
.IX Item "Symbian (Series 60 v3, 3.2 and 5 - what else?)"
.IP "Stratus \s-1VOS /\s0 OpenVOS" 4
.IX Item "Stratus VOS / OpenVOS"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.PD
.SH "EOL Platforms (Perl 5.14)"
.IX Header "EOL Platforms (Perl 5.14)"
The following platforms were supported by a previous version of
Perl but have been officially removed from Perl's source code
as of 5.12:
.IP "Atari MiNT" 4
.IX Item "Atari MiNT"
.PD 0
.IP "Apollo Domain/OS" 4
.IX Item "Apollo Domain/OS"
.IP "Apple Mac \s-1OS 8/9\s0" 4
.IX Item "Apple Mac OS 8/9"
.IP "Tenon Machten" 4
.IX Item "Tenon Machten"
.PD
.PP
The following platforms were supported up to 5.10.  They may still
have worked in 5.12, but supporting code has been removed for 5.14:
.IP "Windows 95" 4
.IX Item "Windows 95"
.PD 0
.IP "Windows 98" 4
.IX Item "Windows 98"
.IP "Windows \s-1ME\s0" 4
.IX Item "Windows ME"
.IP "Windows \s-1NT4\s0" 4
.IX Item "Windows NT4"
.PD
.SH "Supported Platforms (Perl 5.8)"
.IX Header "Supported Platforms (Perl 5.8)"
As of July 2002 (the Perl release 5.8.0), the following platforms were
able to build Perl from the standard source code distribution
available at <http://www.cpan.org/src/>
.PP
.Vb 10
\&        AIX
\&        BeOS
\&        BSD/OS          (BSDi)
\&        Cygwin
\&        DG/UX
\&        DOS DJGPP       1)
\&        DYNIX/ptx
\&        EPOC R5
\&        FreeBSD
\&        HI\-UXMPP        (Hitachi) (5.8.0 worked but we didn\*(Aqt know it)
\&        HP\-UX
\&        IRIX
\&        Linux
\&        Mac OS Classic
\&        Mac OS X        (Darwin)
\&        MPE/iX
\&        NetBSD
\&        NetWare
\&        NonStop\-UX
\&        ReliantUNIX     (formerly SINIX)
\&        OpenBSD
\&        OpenVMS         (formerly VMS)
\&        Open UNIX       (Unixware) (since Perl 5.8.1/5.9.0)
\&        OS/2
\&        OS/400          (using the PASE) (since Perl 5.8.1/5.9.0)
\&        PowerUX
\&        POSIX\-BC        (formerly BS2000)
\&        QNX
\&        Solaris
\&        SunOS 4
\&        SUPER\-UX        (NEC)
\&        Tru64 UNIX      (formerly DEC OSF/1, Digital UNIX)
\&        UNICOS
\&        UNICOS/mk
\&        UTS
\&        VOS / OpenVOS
\&        Win95/98/ME/2K/XP 2)
\&        WinCE
\&        z/OS            (formerly OS/390)
\&        VM/ESA
\&
\&        1) in DOS mode either the DOS or OS/2 ports can be used
\&        2) compilers: Borland, MinGW (GCC), VC6
.Ve
.PP
The following platforms worked with the previous releases (5.6 and
5.7), but we did not manage either to fix or to test these in time
for the 5.8.0 release.  There is a very good chance that many of these
will work fine with the 5.8.0.
.PP
.Vb 10
\&        BSD/OS
\&        DomainOS
\&        Hurd
\&        LynxOS
\&        MachTen
\&        PowerMAX
\&        SCO SV
\&        SVR4
\&        Unixware
\&        Windows 3.1
.Ve
.PP
Known to be broken for 5.8.0 (but 5.6.1 and 5.7.2 can be used):
.PP
.Vb 1
\&        AmigaOS
.Ve
.PP
The following platforms have been known to build Perl from source in
the past (5.005_03 and earlier), but we haven't been able to verify
their status for the current release, either because the
hardware/software platforms are rare or because we don't have an
active champion on these platforms\*(--or both.  They used to work,
though, so go ahead and try compiling them, and let perlbug@perl.org
of any trouble.
.PP
.Vb 10
\&        3b1
\&        A/UX
\&        ConvexOS
\&        CX/UX
\&        DC/OSx
\&        DDE SMES
\&        DOS EMX
\&        Dynix
\&        EP/IX
\&        ESIX
\&        FPS
\&        GENIX
\&        Greenhills
\&        ISC
\&        MachTen 68k
\&        MPC
\&        NEWS\-OS
\&        NextSTEP
\&        OpenSTEP
\&        Opus
\&        Plan 9
\&        RISC/os
\&        SCO ODT/OSR
\&        Stellar
\&        SVR2
\&        TI1500
\&        TitanOS
\&        Ultrix
\&        Unisys Dynix
.Ve
.PP
The following platforms have their own source code distributions and
binaries available via <http://www.cpan.org/ports/>
.PP
.Vb 1
\&                                Perl release
\&
\&        OS/400 (ILE)            5.005_02
\&        Tandem Guardian         5.004
.Ve
.PP
The following platforms have only binaries available via
<http://www.cpan.org/ports/index.html> :
.PP
.Vb 1
\&                                Perl release
\&
\&        Acorn RISCOS            5.005_02
\&        AOS                     5.002
\&        LynxOS                  5.004_02
.Ve
.PP
Although we do suggest that you always build your own Perl from
the source code, both for maximal configurability and for security,
in case you are in a hurry you can check
<http://www.cpan.org/ports/index.html> for binary distributions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlaix, perlamiga, perlbs2000,
perlce, perlcygwin, perldgux, perldos,
perlebcdic, perlfreebsd, perlhurd, perlhpux, perlirix,
perlmacos, perlmacosx,
perlnetware, perlos2, perlos390, perlos400,
perlplan9, perlqnx, perlsolaris, perltru64,
perlunicode, perlvms, perlvos, perlwin32, and Win32.
.SH "AUTHORS / CONTRIBUTORS"
.IX Header "AUTHORS / CONTRIBUTORS"
Abigail <abigail@foad.org>,
Charles Bailey <bailey@newman.upenn.edu>,
Graham Barr <gbarr@pobox.com>,
Tom Christiansen <tchrist@perl.com>,
Nicholas Clark <nick@ccl4.org>,
Thomas Dorner <Thomas.Dorner@start.de>,
Andy Dougherty <doughera@lafayette.edu>,
Dominic Dunlop <domo@computer.org>,
Neale Ferguson <neale@vma.tabnsw.com.au>,
David J. Fiander <davidf@mks.com>,
Paul Green <Paul.Green@stratus.com>,
M.J.T. Guy <mjtg@cam.ac.uk>,
Jarkko Hietaniemi <jhi@iki.fi>,
Luther Huffman <lutherh@stratcom.com>,
Nick Ing-Simmons <nick@ing\-simmons.net>,
Andreas J. Ko\*:nig <a.koenig@mind.de>,
Markus Laker <mlaker@contax.co.uk>,
Andrew M. Langmead <aml@world.std.com>,
Larry Moore <ljmoore@freespace.net>,
Paul Moore <Paul.Moore@uk.origin\-it.com>,
Chris Nandor <pudge@pobox.com>,
Matthias Neeracher <neeracher@mac.com>,
Philip Newton <pne@cpan.org>,
Gary Ng <71564.1743@CompuServe.COM>,
Tom Phoenix <rootbeer@teleport.com>,
Andre\*' Pirard <A.Pirard@ulg.ac.be>,
Peter Prymmer <pvhp@forte.com>,
Hugo van der Sanden <hv@crypt0.demon.co.uk>,
Gurusamy Sarathy <gsar@activestate.com>,
Paul J. Schinder <schinder@pobox.com>,
Michael G Schwern <schwern@pobox.com>,
Dan Sugalski <dan@sidhe.org>,
Nathan Torkington <gnat@frii.com>,
John Malmberg <wb8tyw@qsl.net>
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpragma.1                                 0100644 0001750 0001750 00000023476 12566207443 023107  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPRAGMA 1"
.TH PERLPRAGMA 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpragma \- how to write a user pragma
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A pragma is a module which influences some aspect of the compile time or run
time behaviour of Perl, such as \f(CW\*(C`strict\*(C'\fR or \f(CW\*(C`warnings\*(C'\fR. With Perl 5.10 you
are no longer limited to the built in pragmata; you can now create user
pragmata that modify the behaviour of user functions within a lexical scope.
.SH "A basic example"
.IX Header "A basic example"
For example, say you need to create a class implementing overloaded
mathematical operators, and would like to provide your own pragma that
functions much like \f(CW\*(C`use integer;\*(C'\fR You'd like this code
.PP
.Vb 1
\&    use MyMaths;
\&
\&    my $l = MyMaths\->new(1.2);
\&    my $r = MyMaths\->new(3.4);
\&
\&    print "A: ", $l + $r, "\en";
\&
\&    use myint;
\&    print "B: ", $l + $r, "\en";
\&
\&    {
\&        no myint;
\&        print "C: ", $l + $r, "\en";
\&    }
\&
\&    print "D: ", $l + $r, "\en";
\&
\&    no myint;
\&    print "E: ", $l + $r, "\en";
.Ve
.PP
to give the output
.PP
.Vb 5
\&    A: 4.6
\&    B: 4
\&    C: 4.6
\&    D: 4
\&    E: 4.6
.Ve
.PP
\&\fIi.e.\fR, where \f(CW\*(C`use myint;\*(C'\fR is in effect, addition operations are forced
to integer, whereas by default they are not, with the default behaviour being
restored via \f(CW\*(C`no myint;\*(C'\fR
.PP
The minimal implementation of the package \f(CW\*(C`MyMaths\*(C'\fR would be something like
this:
.PP
.Vb 10
\&    package MyMaths;
\&    use warnings;
\&    use strict;
\&    use myint();
\&    use overload \*(Aq+\*(Aq => sub {
\&        my ($l, $r) = @_;
\&        # Pass 1 to check up one call level from here
\&        if (myint::in_effect(1)) {
\&            int($$l) + int($$r);
\&        } else {
\&            $$l + $$r;
\&        }
\&    };
\&
\&    sub new {
\&        my ($class, $value) = @_;
\&        bless \e$value, $class;
\&    }
\&
\&    1;
.Ve
.PP
Note how we load the user pragma \f(CW\*(C`myint\*(C'\fR with an empty list \f(CW\*(C`()\*(C'\fR to
prevent its \f(CW\*(C`import\*(C'\fR being called.
.PP
The interaction with the Perl compilation happens inside package \f(CW\*(C`myint\*(C'\fR:
.PP
.Vb 1
\&    package myint;
\&
\&    use strict;
\&    use warnings;
\&
\&    sub import {
\&        $^H{"myint/in_effect"} = 1;
\&    }
\&
\&    sub unimport {
\&        $^H{"myint/in_effect"} = 0;
\&    }
\&
\&    sub in_effect {
\&        my $level = shift // 0;
\&        my $hinthash = (caller($level))[10];
\&        return $hinthash\->{"myint/in_effect"};
\&    }
\&
\&    1;
.Ve
.PP
As pragmata are implemented as modules, like any other module, \f(CW\*(C`use myint;\*(C'\fR
becomes
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->import();
\&    }
.Ve
.PP
and \f(CW\*(C`no myint;\*(C'\fR is
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->unimport();
\&    }
.Ve
.PP
Hence the \f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR routines are called at \fBcompile time\fR
for the user's code.
.PP
User pragmata store their state by writing to the magical hash \f(CW\*(C`%^H\*(C'\fR,
hence these two routines manipulate it. The state information in \f(CW\*(C`%^H\*(C'\fR is
stored in the optree, and can be retrieved read-only at runtime with \f(CW\*(C`caller()\*(C'\fR,
at index 10 of the list of returned results. In the example pragma, retrieval
is encapsulated into the routine \f(CW\*(C`in_effect()\*(C'\fR, which takes as parameter
the number of call frames to go up to find the value of the pragma in the
user's script. This uses \f(CW\*(C`caller()\*(C'\fR to determine the value of
\&\f(CW$^H{"myint/in_effect"}\fR when each line of the user's script was called, and
therefore provide the correct semantics in the subroutine implementing the
overloaded addition.
.SH "Key naming"
.IX Header "Key naming"
There is only a single \f(CW\*(C`%^H\*(C'\fR, but arbitrarily many modules that want
to use its scoping semantics.  To avoid stepping on each other's toes,
they need to be sure to use different keys in the hash.  It is therefore
conventional for a module to use only keys that begin with the module's
name (the name of its main package) and a \*(L"/\*(R" character.  After this
module-identifying prefix, the rest of the key is entirely up to the
module: it may include any characters whatsoever.  For example, a module
\&\f(CW\*(C`Foo::Bar\*(C'\fR should use keys such as \f(CW\*(C`Foo::Bar/baz\*(C'\fR and \f(CW\*(C`Foo::Bar/$%/_!\*(C'\fR.
Modules following this convention all play nicely with each other.
.PP
The Perl core uses a handful of keys in \f(CW\*(C`%^H\*(C'\fR which do not follow this
convention, because they predate it.  Keys that follow the convention
won't conflict with the core's historical keys.
.SH "Implementation details"
.IX Header "Implementation details"
The optree is shared between threads.  This means there is a possibility that
the optree will outlive the particular thread (and therefore the interpreter
instance) that created it, so true Perl scalars cannot be stored in the
optree.  Instead a compact form is used, which can only store values that are
integers (signed and unsigned), strings or \f(CW\*(C`undef\*(C'\fR \- references and
floating point values are stringified.  If you need to store multiple values
or complex structures, you should serialise them, for example with \f(CW\*(C`pack\*(C'\fR.
The deletion of a hash key from \f(CW\*(C`%^H\*(C'\fR is recorded, and as ever can be
distinguished from the existence of a key with value \f(CW\*(C`undef\*(C'\fR with
\&\f(CW\*(C`exists\*(C'\fR.
.PP
\&\fBDon't\fR attempt to store references to data structures as integers which
are retrieved via \f(CW\*(C`caller\*(C'\fR and converted back, as this will not be threadsafe.
Accesses would be to the structure without locking (which is not safe for
Perl's scalars), and either the structure has to leak, or it has to be
freed when its creating thread terminates, which may be before the optree
referencing it is deleted, if other threads outlive it.
                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpragma5.16.1                             0100644 0001750 0001750 00000023241 12566207423 023405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPRAGMA 1"
.TH PERLPRAGMA 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpragma \- how to write a user pragma
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A pragma is a module which influences some aspect of the compile time or run
time behaviour of Perl, such as \f(CW\*(C`strict\*(C'\fR or \f(CW\*(C`warnings\*(C'\fR. With Perl 5.10 you
are no longer limited to the built in pragmata; you can now create user
pragmata that modify the behaviour of user functions within a lexical scope.
.SH "A basic example"
.IX Header "A basic example"
For example, say you need to create a class implementing overloaded
mathematical operators, and would like to provide your own pragma that
functions much like \f(CW\*(C`use integer;\*(C'\fR You'd like this code
.PP
.Vb 1
\&    use MyMaths;
\&    
\&    my $l = MyMaths\->new(1.2);
\&    my $r = MyMaths\->new(3.4);
\&    
\&    print "A: ", $l + $r, "\en";
\&    
\&    use myint;
\&    print "B: ", $l + $r, "\en";
\&    
\&    {
\&        no myint;
\&        print "C: ", $l + $r, "\en";
\&    }
\&    
\&    print "D: ", $l + $r, "\en";
\&    
\&    no myint;
\&    print "E: ", $l + $r, "\en";
.Ve
.PP
to give the output
.PP
.Vb 5
\&    A: 4.6
\&    B: 4
\&    C: 4.6
\&    D: 4
\&    E: 4.6
.Ve
.PP
\&\fIi.e.\fR, where \f(CW\*(C`use myint;\*(C'\fR is in effect, addition operations are forced
to integer, whereas by default they are not, with the default behaviour being
restored via \f(CW\*(C`no myint;\*(C'\fR
.PP
The minimal implementation of the package \f(CW\*(C`MyMaths\*(C'\fR would be something like
this:
.PP
.Vb 10
\&    package MyMaths;
\&    use warnings;
\&    use strict;
\&    use myint();
\&    use overload \*(Aq+\*(Aq => sub {
\&        my ($l, $r) = @_;
\&        # Pass 1 to check up one call level from here
\&        if (myint::in_effect(1)) {
\&            int($$l) + int($$r);
\&        } else {
\&            $$l + $$r;
\&        }
\&    };
\&    
\&    sub new {
\&        my ($class, $value) = @_;
\&        bless \e$value, $class;
\&    }
\&    
\&    1;
.Ve
.PP
Note how we load the user pragma \f(CW\*(C`myint\*(C'\fR with an empty list \f(CW\*(C`()\*(C'\fR to
prevent its \f(CW\*(C`import\*(C'\fR being called.
.PP
The interaction with the Perl compilation happens inside package \f(CW\*(C`myint\*(C'\fR:
.PP
.Vb 1
\&    package myint;
\&    
\&    use strict;
\&    use warnings;
\&    
\&    sub import {
\&        $^H{"myint/in_effect"} = 1;
\&    }
\&    
\&    sub unimport {
\&        $^H{"myint/in_effect"} = 0;
\&    }
\&    
\&    sub in_effect {
\&        my $level = shift // 0;
\&        my $hinthash = (caller($level))[10];
\&        return $hinthash\->{"myint/in_effect"};
\&    }
\&    
\&    1;
.Ve
.PP
As pragmata are implemented as modules, like any other module, \f(CW\*(C`use myint;\*(C'\fR
becomes
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->import();
\&    }
.Ve
.PP
and \f(CW\*(C`no myint;\*(C'\fR is
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->unimport();
\&    }
.Ve
.PP
Hence the \f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR routines are called at \fBcompile time\fR
for the user's code.
.PP
User pragmata store their state by writing to the magical hash \f(CW\*(C`%^H\*(C'\fR,
hence these two routines manipulate it. The state information in \f(CW\*(C`%^H\*(C'\fR is
stored in the optree, and can be retrieved read-only at runtime with \f(CW\*(C`caller()\*(C'\fR,
at index 10 of the list of returned results. In the example pragma, retrieval
is encapsulated into the routine \f(CW\*(C`in_effect()\*(C'\fR, which takes as parameter
the number of call frames to go up to find the value of the pragma in the
user's script. This uses \f(CW\*(C`caller()\*(C'\fR to determine the value of
\&\f(CW$^H{"myint/in_effect"}\fR when each line of the user's script was called, and
therefore provide the correct semantics in the subroutine implementing the
overloaded addition.
.SH "Key naming"
.IX Header "Key naming"
There is only a single \f(CW\*(C`%^H\*(C'\fR, but arbitrarily many modules that want
to use its scoping semantics.  To avoid stepping on each other's toes,
they need to be sure to use different keys in the hash.  It is therefore
conventional for a module to use only keys that begin with the module's
name (the name of its main package) and a \*(L"/\*(R" character.  After this
module-identifying prefix, the rest of the key is entirely up to the
module: it may include any characters whatsoever.  For example, a module
\&\f(CW\*(C`Foo::Bar\*(C'\fR should use keys such as \f(CW\*(C`Foo::Bar/baz\*(C'\fR and \f(CW\*(C`Foo::Bar/$%/_!\*(C'\fR.
Modules following this convention all play nicely with each other.
.PP
The Perl core uses a handful of keys in \f(CW\*(C`%^H\*(C'\fR which do not follow this
convention, because they predate it.  Keys that follow the convention
won't conflict with the core's historical keys.
.SH "Implementation details"
.IX Header "Implementation details"
The optree is shared between threads.  This means there is a possibility that
the optree will outlive the particular thread (and therefore the interpreter
instance) that created it, so true Perl scalars cannot be stored in the
optree.  Instead a compact form is used, which can only store values that are
integers (signed and unsigned), strings or \f(CW\*(C`undef\*(C'\fR \- references and
floating point values are stringified.  If you need to store multiple values
or complex structures, you should serialise them, for example with \f(CW\*(C`pack\*(C'\fR.
The deletion of a hash key from \f(CW\*(C`%^H\*(C'\fR is recorded, and as ever can be
distinguished from the existence of a key with value \f(CW\*(C`undef\*(C'\fR with
\&\f(CW\*(C`exists\*(C'\fR.
.PP
\&\fBDon't\fR attempt to store references to data structures as integers which
are retrieved via \f(CW\*(C`caller\*(C'\fR and converted back, as this will not be threadsafe.
Accesses would be to the structure without locking (which is not safe for
Perl's scalars), and either the structure has to leak, or it has to be
freed when its creating thread terminates, which may be before the optree
referencing it is deleted, if other threads outlive it.
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpragma5.18.1                             0100644 0001750 0001750 00000023476 12566207443 023423  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPRAGMA 1"
.TH PERLPRAGMA 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpragma \- how to write a user pragma
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A pragma is a module which influences some aspect of the compile time or run
time behaviour of Perl, such as \f(CW\*(C`strict\*(C'\fR or \f(CW\*(C`warnings\*(C'\fR. With Perl 5.10 you
are no longer limited to the built in pragmata; you can now create user
pragmata that modify the behaviour of user functions within a lexical scope.
.SH "A basic example"
.IX Header "A basic example"
For example, say you need to create a class implementing overloaded
mathematical operators, and would like to provide your own pragma that
functions much like \f(CW\*(C`use integer;\*(C'\fR You'd like this code
.PP
.Vb 1
\&    use MyMaths;
\&
\&    my $l = MyMaths\->new(1.2);
\&    my $r = MyMaths\->new(3.4);
\&
\&    print "A: ", $l + $r, "\en";
\&
\&    use myint;
\&    print "B: ", $l + $r, "\en";
\&
\&    {
\&        no myint;
\&        print "C: ", $l + $r, "\en";
\&    }
\&
\&    print "D: ", $l + $r, "\en";
\&
\&    no myint;
\&    print "E: ", $l + $r, "\en";
.Ve
.PP
to give the output
.PP
.Vb 5
\&    A: 4.6
\&    B: 4
\&    C: 4.6
\&    D: 4
\&    E: 4.6
.Ve
.PP
\&\fIi.e.\fR, where \f(CW\*(C`use myint;\*(C'\fR is in effect, addition operations are forced
to integer, whereas by default they are not, with the default behaviour being
restored via \f(CW\*(C`no myint;\*(C'\fR
.PP
The minimal implementation of the package \f(CW\*(C`MyMaths\*(C'\fR would be something like
this:
.PP
.Vb 10
\&    package MyMaths;
\&    use warnings;
\&    use strict;
\&    use myint();
\&    use overload \*(Aq+\*(Aq => sub {
\&        my ($l, $r) = @_;
\&        # Pass 1 to check up one call level from here
\&        if (myint::in_effect(1)) {
\&            int($$l) + int($$r);
\&        } else {
\&            $$l + $$r;
\&        }
\&    };
\&
\&    sub new {
\&        my ($class, $value) = @_;
\&        bless \e$value, $class;
\&    }
\&
\&    1;
.Ve
.PP
Note how we load the user pragma \f(CW\*(C`myint\*(C'\fR with an empty list \f(CW\*(C`()\*(C'\fR to
prevent its \f(CW\*(C`import\*(C'\fR being called.
.PP
The interaction with the Perl compilation happens inside package \f(CW\*(C`myint\*(C'\fR:
.PP
.Vb 1
\&    package myint;
\&
\&    use strict;
\&    use warnings;
\&
\&    sub import {
\&        $^H{"myint/in_effect"} = 1;
\&    }
\&
\&    sub unimport {
\&        $^H{"myint/in_effect"} = 0;
\&    }
\&
\&    sub in_effect {
\&        my $level = shift // 0;
\&        my $hinthash = (caller($level))[10];
\&        return $hinthash\->{"myint/in_effect"};
\&    }
\&
\&    1;
.Ve
.PP
As pragmata are implemented as modules, like any other module, \f(CW\*(C`use myint;\*(C'\fR
becomes
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->import();
\&    }
.Ve
.PP
and \f(CW\*(C`no myint;\*(C'\fR is
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->unimport();
\&    }
.Ve
.PP
Hence the \f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR routines are called at \fBcompile time\fR
for the user's code.
.PP
User pragmata store their state by writing to the magical hash \f(CW\*(C`%^H\*(C'\fR,
hence these two routines manipulate it. The state information in \f(CW\*(C`%^H\*(C'\fR is
stored in the optree, and can be retrieved read-only at runtime with \f(CW\*(C`caller()\*(C'\fR,
at index 10 of the list of returned results. In the example pragma, retrieval
is encapsulated into the routine \f(CW\*(C`in_effect()\*(C'\fR, which takes as parameter
the number of call frames to go up to find the value of the pragma in the
user's script. This uses \f(CW\*(C`caller()\*(C'\fR to determine the value of
\&\f(CW$^H{"myint/in_effect"}\fR when each line of the user's script was called, and
therefore provide the correct semantics in the subroutine implementing the
overloaded addition.
.SH "Key naming"
.IX Header "Key naming"
There is only a single \f(CW\*(C`%^H\*(C'\fR, but arbitrarily many modules that want
to use its scoping semantics.  To avoid stepping on each other's toes,
they need to be sure to use different keys in the hash.  It is therefore
conventional for a module to use only keys that begin with the module's
name (the name of its main package) and a \*(L"/\*(R" character.  After this
module-identifying prefix, the rest of the key is entirely up to the
module: it may include any characters whatsoever.  For example, a module
\&\f(CW\*(C`Foo::Bar\*(C'\fR should use keys such as \f(CW\*(C`Foo::Bar/baz\*(C'\fR and \f(CW\*(C`Foo::Bar/$%/_!\*(C'\fR.
Modules following this convention all play nicely with each other.
.PP
The Perl core uses a handful of keys in \f(CW\*(C`%^H\*(C'\fR which do not follow this
convention, because they predate it.  Keys that follow the convention
won't conflict with the core's historical keys.
.SH "Implementation details"
.IX Header "Implementation details"
The optree is shared between threads.  This means there is a possibility that
the optree will outlive the particular thread (and therefore the interpreter
instance) that created it, so true Perl scalars cannot be stored in the
optree.  Instead a compact form is used, which can only store values that are
integers (signed and unsigned), strings or \f(CW\*(C`undef\*(C'\fR \- references and
floating point values are stringified.  If you need to store multiple values
or complex structures, you should serialise them, for example with \f(CW\*(C`pack\*(C'\fR.
The deletion of a hash key from \f(CW\*(C`%^H\*(C'\fR is recorded, and as ever can be
distinguished from the existence of a key with value \f(CW\*(C`undef\*(C'\fR with
\&\f(CW\*(C`exists\*(C'\fR.
.PP
\&\fBDon't\fR attempt to store references to data structures as integers which
are retrieved via \f(CW\*(C`caller\*(C'\fR and converted back, as this will not be threadsafe.
Accesses would be to the structure without locking (which is not safe for
Perl's scalars), and either the structure has to leak, or it has to be
freed when its creating thread terminates, which may be before the optree
referencing it is deleted, if other threads outlive it.
                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlqnx.1                                    0100644 0001750 0001750 00000020730 12566207443 022434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLQNX 1"
.TH PERLQNX 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlqnx \- Perl version 5 on QNX
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As of perl5.7.2 all tests pass under:
.PP
.Vb 3
\&  QNX 4.24G
\&  Watcom 10.6 with Beta/970211.wcc.update.tar.F
\&  socket3r.lib Nov21 1996.
.Ve
.PP
As of perl5.8.1 there is at least one test still failing.
.PP
Some tests may complain under known circumstances.
.PP
See below and hints/qnx.sh for more information.
.PP
Under \s-1QNX 6.2.0\s0 there are still a few tests which fail.
See below and hints/qnx.sh for more information.
.SS "Required Software for Compiling Perl on \s-1QNX4\s0"
.IX Subsection "Required Software for Compiling Perl on QNX4"
As with many unix ports, this one depends on a few \*(L"standard\*(R"
unix utilities which are not necessarily standard for \s-1QNX4.\s0
.IP "/bin/sh" 4
.IX Item "/bin/sh"
This is used heavily by Configure and then by
perl itself. \s-1QNX4\s0's version is fine, but Configure
will choke on the 16\-bit version, so if you are
running \s-1QNX 4.22,\s0 link /bin/sh to /bin32/ksh
.IP "ar" 4
.IX Item "ar"
This is the standard unix library builder.
We use wlib. With Watcom 10.6, when wlib is
linked as \*(L"ar\*(R", it behaves like ar and all is
fine. Under 9.5, a cover is required. One is
included in ../qnx
.IP "nm" 4
.IX Item "nm"
This is used (optionally) by configure to list
the contents of libraries. I will generate
a cover function on the fly in the \s-1UU\s0 directory.
.IP "cpp" 4
.IX Item "cpp"
Configure and perl need a way to invoke a C
preprocessor. I have created a simple cover
for cc which does the right thing. Without this,
Configure will create its own wrapper which works,
but it doesn't handle some of the command line arguments
that perl will throw at it.
.IP "make" 4
.IX Item "make"
You really need \s-1GNU\s0 make to compile this. \s-1GNU\s0 make
ships by default with \s-1QNX 4.23,\s0 but you can get it
from quics for earlier versions.
.SS "Outstanding Issues with Perl on \s-1QNX4\s0"
.IX Subsection "Outstanding Issues with Perl on QNX4"
There is no support for dynamically linked libraries in \s-1QNX4.\s0
.PP
If you wish to compile with the Socket extension, you need
to have the \s-1TCP/IP\s0 toolkit, and you need to make sure that
\&\-lsocket locates the correct copy of socket3r.lib. Beware
that the Watcom compiler ships with a stub version of
socket3r.lib which has very little functionality. Also
beware the order in which wlink searches directories for
libraries. You may have /usr/lib/socket3r.lib pointing to
the correct library, but wlink may pick up
/usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure
they both point to the correct library, that is,
/usr/tcptk/current/usr/lib/socket3r.lib.
.PP
The following tests may report errors under \s-1QNX4:\s0
.PP
dist/Cwd/Cwd.t will complain if `pwd` and cwd don't give
the same results. cwd calls `fullpath \-t`, so if you
cd `fullpath \-t` before running the test, it will
pass.
.PP
lib/File/Find/taint.t will complain if '.' is in your
\&\s-1PATH.\s0 The \s-1PATH\s0 test is triggered because cwd calls
`fullpath \-t`.
.PP
ext/IO/lib/IO/t/io_sock.t: Subtests 14 and 22 are skipped due to
the fact that the functionality to read back the non-blocking
status of a socket is not implemented in \s-1QNX\s0's \s-1TCP/IP.\s0 This has
been reported to \s-1QNX\s0 and it may work with later versions of
\&\s-1TCP/IP.\s0
.PP
t/io/tell.t: Subtest 27 is failing. We are still investigating.
.SS "\s-1QNX\s0 auxiliary files"
.IX Subsection "QNX auxiliary files"
The files in the \*(L"qnx\*(R" directory are:
.IP "qnx/ar" 4
.IX Item "qnx/ar"
A script that emulates the standard unix archive (aka library)
utility.  Under Watcom 10.6, ar is linked to wlib and provides the
expected interface. With Watcom 9.5, a cover function is
required. This one is fairly crude but has proved adequate for
compiling perl.
.IP "qnx/cpp" 4
.IX Item "qnx/cpp"
A script that provides C preprocessing functionality.  Configure can
generate a similar cover, but it doesn't handle all the command-line
options that perl throws at it. This might be reasonably placed in
/usr/local/bin.
.SS "Outstanding issues with perl under \s-1QNX6\s0"
.IX Subsection "Outstanding issues with perl under QNX6"
The following tests are still failing for Perl 5.8.1 under \s-1QNX 6.2.0:\s0
.PP
.Vb 2
\&  op/sprintf.........................FAILED at test 91
\&  lib/Benchmark......................FAILED at test 26
.Ve
.PP
This is due to a bug in the C library's printf routine.
printf(\*(L"'%e'\*(R", 0. ) produces '0.000000e+0', but \s-1ANSI\s0 requires
\&'0.000000e+00'. \s-1QNX\s0 has acknowledged the bug.
.SH "AUTHOR"
.IX Header "AUTHOR"
Norton T. Allen (allen@huarp.harvard.edu)
                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlqnx5.16.1                                0100644 0001750 0001750 00000020407 12566207423 022745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLQNX 1"
.TH PERLQNX 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlqnx \- Perl version 5 on QNX
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As of perl5.7.2 all tests pass under:
.PP
.Vb 3
\&  QNX 4.24G
\&  Watcom 10.6 with Beta/970211.wcc.update.tar.F
\&  socket3r.lib Nov21 1996.
.Ve
.PP
As of perl5.8.1 there is at least one test still failing.
.PP
Some tests may complain under known circumstances.
.PP
See below and hints/qnx.sh for more information.
.PP
Under \s-1QNX\s0 6.2.0 there are still a few tests which fail.
See below and hints/qnx.sh for more information.
.SS "Required Software for Compiling Perl on \s-1QNX4\s0"
.IX Subsection "Required Software for Compiling Perl on QNX4"
As with many unix ports, this one depends on a few \*(L"standard\*(R"
unix utilities which are not necessarily standard for \s-1QNX4\s0.
.IP "/bin/sh" 4
.IX Item "/bin/sh"
This is used heavily by Configure and then by
perl itself. \s-1QNX4\s0's version is fine, but Configure
will choke on the 16\-bit version, so if you are
running \s-1QNX\s0 4.22, link /bin/sh to /bin32/ksh
.IP "ar" 4
.IX Item "ar"
This is the standard unix library builder.
We use wlib. With Watcom 10.6, when wlib is
linked as \*(L"ar\*(R", it behaves like ar and all is
fine. Under 9.5, a cover is required. One is
included in ../qnx
.IP "nm" 4
.IX Item "nm"
This is used (optionally) by configure to list
the contents of libraries. I will generate
a cover function on the fly in the \s-1UU\s0 directory.
.IP "cpp" 4
.IX Item "cpp"
Configure and perl need a way to invoke a C
preprocessor. I have created a simple cover
for cc which does the right thing. Without this,
Configure will create its own wrapper which works,
but it doesn't handle some of the command line arguments
that perl will throw at it.
.IP "make" 4
.IX Item "make"
You really need \s-1GNU\s0 make to compile this. \s-1GNU\s0 make
ships by default with \s-1QNX\s0 4.23, but you can get it
from quics for earlier versions.
.SS "Outstanding Issues with Perl on \s-1QNX4\s0"
.IX Subsection "Outstanding Issues with Perl on QNX4"
There is no support for dynamically linked libraries in \s-1QNX4\s0.
.PP
If you wish to compile with the Socket extension, you need
to have the \s-1TCP/IP\s0 toolkit, and you need to make sure that
\&\-lsocket locates the correct copy of socket3r.lib. Beware
that the Watcom compiler ships with a stub version of
socket3r.lib which has very little functionality. Also
beware the order in which wlink searches directories for
libraries. You may have /usr/lib/socket3r.lib pointing to
the correct library, but wlink may pick up
/usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure
they both point to the correct library, that is,
/usr/tcptk/current/usr/lib/socket3r.lib.
.PP
The following tests may report errors under \s-1QNX4:\s0
.PP
dist/Cwd/Cwd.t will complain if `pwd` and cwd don't give
the same results. cwd calls `fullpath \-t`, so if you
cd `fullpath \-t` before running the test, it will
pass.
.PP
lib/File/Find/taint.t will complain if '.' is in your
\&\s-1PATH\s0. The \s-1PATH\s0 test is triggered because cwd calls
`fullpath \-t`.
.PP
ext/IO/lib/IO/t/io_sock.t: Subtests 14 and 22 are skipped due to
the fact that the functionality to read back the non-blocking
status of a socket is not implemented in \s-1QNX\s0's \s-1TCP/IP\s0. This has
been reported to \s-1QNX\s0 and it may work with later versions of
\&\s-1TCP/IP\s0.
.PP
t/io/tell.t: Subtest 27 is failing. We are still investigating.
.SS "\s-1QNX\s0 auxiliary files"
.IX Subsection "QNX auxiliary files"
The files in the \*(L"qnx\*(R" directory are:
.IP "qnx/ar" 4
.IX Item "qnx/ar"
A script that emulates the standard unix archive (aka library)
utility.  Under Watcom 10.6, ar is linked to wlib and provides the
expected interface. With Watcom 9.5, a cover function is
required. This one is fairly crude but has proved adequate for
compiling perl.
.IP "qnx/cpp" 4
.IX Item "qnx/cpp"
A script that provides C preprocessing functionality.  Configure can
generate a similar cover, but it doesn't handle all the command-line
options that perl throws at it. This might be reasonably placed in
/usr/local/bin.
.SS "Outstanding issues with perl under \s-1QNX6\s0"
.IX Subsection "Outstanding issues with perl under QNX6"
The following tests are still failing for Perl 5.8.1 under \s-1QNX\s0 6.2.0:
.PP
.Vb 2
\&  op/sprintf.........................FAILED at test 91
\&  lib/Benchmark......................FAILED at test 26
.Ve
.PP
This is due to a bug in the C library's printf routine.
printf(\*(L"'%e'\*(R", 0. ) produces '0.000000e+0', but \s-1ANSI\s0 requires
\&'0.000000e+00'. \s-1QNX\s0 has acknowledged the bug.
.SH "AUTHOR"
.IX Header "AUTHOR"
Norton T. Allen (allen@huarp.harvard.edu)
                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlqnx5.18.1                                0100644 0001750 0001750 00000020730 12566207443 022750  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLQNX 1"
.TH PERLQNX 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlqnx \- Perl version 5 on QNX
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As of perl5.7.2 all tests pass under:
.PP
.Vb 3
\&  QNX 4.24G
\&  Watcom 10.6 with Beta/970211.wcc.update.tar.F
\&  socket3r.lib Nov21 1996.
.Ve
.PP
As of perl5.8.1 there is at least one test still failing.
.PP
Some tests may complain under known circumstances.
.PP
See below and hints/qnx.sh for more information.
.PP
Under \s-1QNX 6.2.0\s0 there are still a few tests which fail.
See below and hints/qnx.sh for more information.
.SS "Required Software for Compiling Perl on \s-1QNX4\s0"
.IX Subsection "Required Software for Compiling Perl on QNX4"
As with many unix ports, this one depends on a few \*(L"standard\*(R"
unix utilities which are not necessarily standard for \s-1QNX4.\s0
.IP "/bin/sh" 4
.IX Item "/bin/sh"
This is used heavily by Configure and then by
perl itself. \s-1QNX4\s0's version is fine, but Configure
will choke on the 16\-bit version, so if you are
running \s-1QNX 4.22,\s0 link /bin/sh to /bin32/ksh
.IP "ar" 4
.IX Item "ar"
This is the standard unix library builder.
We use wlib. With Watcom 10.6, when wlib is
linked as \*(L"ar\*(R", it behaves like ar and all is
fine. Under 9.5, a cover is required. One is
included in ../qnx
.IP "nm" 4
.IX Item "nm"
This is used (optionally) by configure to list
the contents of libraries. I will generate
a cover function on the fly in the \s-1UU\s0 directory.
.IP "cpp" 4
.IX Item "cpp"
Configure and perl need a way to invoke a C
preprocessor. I have created a simple cover
for cc which does the right thing. Without this,
Configure will create its own wrapper which works,
but it doesn't handle some of the command line arguments
that perl will throw at it.
.IP "make" 4
.IX Item "make"
You really need \s-1GNU\s0 make to compile this. \s-1GNU\s0 make
ships by default with \s-1QNX 4.23,\s0 but you can get it
from quics for earlier versions.
.SS "Outstanding Issues with Perl on \s-1QNX4\s0"
.IX Subsection "Outstanding Issues with Perl on QNX4"
There is no support for dynamically linked libraries in \s-1QNX4.\s0
.PP
If you wish to compile with the Socket extension, you need
to have the \s-1TCP/IP\s0 toolkit, and you need to make sure that
\&\-lsocket locates the correct copy of socket3r.lib. Beware
that the Watcom compiler ships with a stub version of
socket3r.lib which has very little functionality. Also
beware the order in which wlink searches directories for
libraries. You may have /usr/lib/socket3r.lib pointing to
the correct library, but wlink may pick up
/usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure
they both point to the correct library, that is,
/usr/tcptk/current/usr/lib/socket3r.lib.
.PP
The following tests may report errors under \s-1QNX4:\s0
.PP
dist/Cwd/Cwd.t will complain if `pwd` and cwd don't give
the same results. cwd calls `fullpath \-t`, so if you
cd `fullpath \-t` before running the test, it will
pass.
.PP
lib/File/Find/taint.t will complain if '.' is in your
\&\s-1PATH.\s0 The \s-1PATH\s0 test is triggered because cwd calls
`fullpath \-t`.
.PP
ext/IO/lib/IO/t/io_sock.t: Subtests 14 and 22 are skipped due to
the fact that the functionality to read back the non-blocking
status of a socket is not implemented in \s-1QNX\s0's \s-1TCP/IP.\s0 This has
been reported to \s-1QNX\s0 and it may work with later versions of
\&\s-1TCP/IP.\s0
.PP
t/io/tell.t: Subtest 27 is failing. We are still investigating.
.SS "\s-1QNX\s0 auxiliary files"
.IX Subsection "QNX auxiliary files"
The files in the \*(L"qnx\*(R" directory are:
.IP "qnx/ar" 4
.IX Item "qnx/ar"
A script that emulates the standard unix archive (aka library)
utility.  Under Watcom 10.6, ar is linked to wlib and provides the
expected interface. With Watcom 9.5, a cover function is
required. This one is fairly crude but has proved adequate for
compiling perl.
.IP "qnx/cpp" 4
.IX Item "qnx/cpp"
A script that provides C preprocessing functionality.  Configure can
generate a similar cover, but it doesn't handle all the command-line
options that perl throws at it. This might be reasonably placed in
/usr/local/bin.
.SS "Outstanding issues with perl under \s-1QNX6\s0"
.IX Subsection "Outstanding issues with perl under QNX6"
The following tests are still failing for Perl 5.8.1 under \s-1QNX 6.2.0:\s0
.PP
.Vb 2
\&  op/sprintf.........................FAILED at test 91
\&  lib/Benchmark......................FAILED at test 26
.Ve
.PP
This is due to a bug in the C library's printf routine.
printf(\*(L"'%e'\*(R", 0. ) produces '0.000000e+0', but \s-1ANSI\s0 requires
\&'0.000000e+00'. \s-1QNX\s0 has acknowledged the bug.
.SH "AUTHOR"
.IX Header "AUTHOR"
Norton T. Allen (allen@huarp.harvard.edu)
                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlre.1                                     0100644 0001750 0001750 00000370126 12566207443 022243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRE 1"
.TH PERLRE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlre \- Perl regular expressions
.IX Xref "regular expression regex regexp"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page describes the syntax of regular expressions in Perl.
.PP
If you haven't used regular expressions before, a quick-start
introduction is available in perlrequick, and a longer tutorial
introduction is available in perlretut.
.PP
For reference on how regular expressions are used in matching
operations, plus various examples of the same, see discussions of
\&\f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR and \f(CW\*(C`??\*(C'\fR in \*(L"Regexp Quote-Like
Operators\*(R" in perlop.
.SS "Modifiers"
.IX Subsection "Modifiers"
Matching operations can have various modifiers.  Modifiers
that relate to the interpretation of the regular expression inside
are listed below.  Modifiers that alter the way a regular expression
is used by Perl are detailed in \*(L"Regexp Quote-Like Operators\*(R" in perlop and
\&\*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.IP "m" 4
.IX Xref " m regex, multiline regexp, multiline regular expression, multiline"
.IX Item "m"
Treat string as multiple lines.  That is, change \*(L"^\*(R" and \*(L"$\*(R" from matching
the start or end of line only at the left and right ends of the string to
matching them anywhere within the string.
.IP "s" 4
.IX Xref " s regex, single-line regexp, single-line regular expression, single-line"
.IX Item "s"
Treat string as single line.  That is, change \*(L".\*(R" to match any character
whatsoever, even a newline, which normally it would not match.
.Sp
Used together, as \f(CW\*(C`/ms\*(C'\fR, they let the \*(L".\*(R" match any character whatsoever,
while still allowing \*(L"^\*(R" and \*(L"$\*(R" to match, respectively, just after
and just before newlines within the string.
.IP "i" 4
.IX Xref " i regex, case-insensitive regexp, case-insensitive regular expression, case-insensitive"
.IX Item "i"
Do case-insensitive pattern matching.
.Sp
If locale matching rules are in effect, the case map is taken from the
current
locale for code points less than 255, and from Unicode rules for larger
code points.  However, matches that would cross the Unicode
rules/non\-Unicode rules boundary (ords 255/256) will not succeed.  See
perllocale.
.Sp
There are a number of Unicode characters that match multiple characters
under \f(CW\*(C`/i\*(C'\fR.  For example, \f(CW\*(C`LATIN SMALL LIGATURE FI\*(C'\fR
should match the sequence \f(CW\*(C`fi\*(C'\fR.  Perl is not
currently able to do this when the multiple characters are in the pattern and
are split between groupings, or when one or more are quantified.  Thus
.Sp
.Vb 3
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi/i;          # Matches
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /[fi][fi]/i;    # Doesn\*(Aqt match!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi*/i;         # Doesn\*(Aqt match!
\&
\& # The below doesn\*(Aqt match, and it isn\*(Aqt clear what $1 and $2 would
\& # be even if it did!!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /(f)(i)/i;      # Doesn\*(Aqt match!
.Ve
.Sp
Perl doesn't match multiple characters in a bracketed
character class unless the character that maps to them is explicitly
mentioned, and it doesn't match them at all if the character class is
inverted, which otherwise could be highly confusing.  See
\&\*(L"Bracketed Character Classes\*(R" in perlrecharclass, and
\&\*(L"Negation\*(R" in perlrecharclass.
.IP "x" 4
.IX Xref " x"
.IX Item "x"
Extend your pattern's legibility by permitting whitespace and comments.
Details in \*(L"/x\*(R"
.IP "p" 4
.IX Xref " p regex, preserve regexp, preserve"
.IX Item "p"
Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and
${^POSTMATCH} are available for use after matching.
.IP "g and c" 4
.IX Xref " g c"
.IX Item "g and c"
Global matching, and keep the Current position after failed matching.
Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself. See
\&\*(L"Using regular expressions in Perl\*(R" in perlretut for further explanation
of the g and c modifiers.
.IP "a, d, l and u" 4
.IX Xref " a d l u"
.IX Item "a, d, l and u"
These modifiers, all new in 5.14, affect which character-set semantics
(Unicode, etc.) are used, as described below in
\&\*(L"Character set modifiers\*(R".
.PP
Regular expression modifiers are usually written in documentation
as e.g., "the \f(CW\*(C`/x\*(C'\fR modifier", even though the delimiter
in question might not really be a slash.  The modifiers \f(CW\*(C`/imsxadlup\*(C'\fR
may also be embedded within the regular expression itself using
the \f(CW\*(C`(?...)\*(C'\fR construct, see \*(L"Extended Patterns\*(R" below.
.PP
\fI/x\fR
.IX Subsection "/x"
.PP
\&\f(CW\*(C`/x\*(C'\fR tells
the regular expression parser to ignore most whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The \f(CW\*(C`#\*(C'\fR
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or \f(CW\*(C`#\*(C'\fR characters in the pattern (outside a character
class, where they are unaffected by \f(CW\*(C`/x\*(C'\fR), then you'll either have to
escape them (using backslashes or \f(CW\*(C`\eQ...\eE\*(C'\fR) or encode them using octal,
hex, or \f(CW\*(C`\eN{}\*(C'\fR escapes.  Taken together, these features go a long way towards
making Perl's regular expressions more readable.  Note that you have to
be careful not to include the pattern delimiter in the comment\*(--perl has
no way of knowing you did not intend to close the pattern early.  See
the C\-comment deletion code in perlop.  Also note that anything inside
a \f(CW\*(C`\eQ...\eE\*(C'\fR stays unaffected by \f(CW\*(C`/x\*(C'\fR.  And note that \f(CW\*(C`/x\*(C'\fR doesn't affect
space interpretation within a single multi-character construct.  For
example in \f(CW\*(C`\ex{...}\*(C'\fR, regardless of the \f(CW\*(C`/x\*(C'\fR modifier, there can be no
spaces.  Same for a quantifier such as \f(CW\*(C`{3}\*(C'\fR or
\&\f(CW\*(C`{5,}\*(C'\fR.  Similarly, \f(CW\*(C`(?:...)\*(C'\fR can't have a space between the \f(CW\*(C`(\*(C'\fR,
\&\f(CW\*(C`?\*(C'\fR, and \f(CW\*(C`:\*(C'\fR.  Within any delimiters for such a
construct, allowed spaces are not affected by \f(CW\*(C`/x\*(C'\fR, and depend on the
construct.  For example, \f(CW\*(C`\ex{...}\*(C'\fR can't have spaces because hexadecimal
numbers don't have spaces in them.  But, Unicode properties can have spaces, so
in \f(CW\*(C`\ep{...}\*(C'\fR there can be spaces that follow the Unicode rules, for which see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops.
.IX Xref " x"
.PP
\fICharacter set modifiers\fR
.IX Subsection "Character set modifiers"
.PP
\&\f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, \f(CW\*(C`/a\*(C'\fR, and \f(CW\*(C`/l\*(C'\fR, available starting in 5.14, are called
the character set modifiers; they affect the character set semantics
used for the regular expression.
.PP
The \f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, and \f(CW\*(C`/l\*(C'\fR modifiers are not likely to be of much use
to you, and so you need not worry about them very much.  They exist for
Perl's internal use, so that complex regular expression data structures
can be automatically serialized and later exactly reconstituted,
including all their nuances.  But, since Perl can't keep a secret, and
there may be rare instances where they are useful, they are documented
here.
.PP
The \f(CW\*(C`/a\*(C'\fR modifier, on the other hand, may be useful.  Its purpose is to
allow code that is to work mostly on \s-1ASCII\s0 data to not have to concern
itself with Unicode.
.PP
Briefly, \f(CW\*(C`/l\*(C'\fR sets the character set to that of whatever \fBL\fRocale is in
effect at the time of the execution of the pattern match.
.PP
\&\f(CW\*(C`/u\*(C'\fR sets the character set to \fBU\fRnicode.
.PP
\&\f(CW\*(C`/a\*(C'\fR also sets the character set to Unicode, \s-1BUT\s0 adds several
restrictions for \fBA\fRSCII-safe matching.
.PP
\&\f(CW\*(C`/d\*(C'\fR is the old, problematic, pre\-5.14 \fBD\fRefault character set
behavior.  Its only use is to force that old behavior.
.PP
At any given time, exactly one of these modifiers is in effect.  Their
existence allows Perl to keep the originally compiled behavior of a
regular expression, regardless of what rules are in effect when it is
actually executed.  And if it is interpolated into a larger regex, the
original's rules continue to apply to it, and only it.
.PP
The \f(CW\*(C`/l\*(C'\fR and \f(CW\*(C`/u\*(C'\fR modifiers are automatically selected for
regular expressions compiled within the scope of various pragmas,
and we recommend that in general, you use those pragmas instead of
specifying these modifiers explicitly.  For one thing, the modifiers
affect only pattern matching, and do not extend to even any replacement
done, whereas using the pragmas give consistent results for all
appropriate operations within their scopes.  For example,
.PP
.Vb 1
\& s/foo/\eUbar/il
.Ve
.PP
will match \*(L"foo\*(R" using the locale's rules for case-insensitive matching,
but the \f(CW\*(C`/l\*(C'\fR does not affect how the \f(CW\*(C`\eU\*(C'\fR operates.  Most likely you
want both of them to use locale rules.  To do this, instead compile the
regular expression within the scope of \f(CW\*(C`use locale\*(C'\fR.  This both
implicitly adds the \f(CW\*(C`/l\*(C'\fR and applies locale rules to the \f(CW\*(C`\eU\*(C'\fR.   The
lesson is to \f(CW\*(C`use locale\*(C'\fR and not \f(CW\*(C`/l\*(C'\fR explicitly.
.PP
Similarly, it would be better to use \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR
instead of,
.PP
.Vb 1
\& s/foo/\eLbar/iu
.Ve
.PP
to get Unicode rules, as the \f(CW\*(C`\eL\*(C'\fR in the former (but not necessarily
the latter) would also use Unicode rules.
.PP
More detail on each of the modifiers follows.  Most likely you don't
need to know this detail for \f(CW\*(C`/l\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, and \f(CW\*(C`/d\*(C'\fR, and can skip ahead
to /a.
.PP
/l
.IX Subsection "/l"
.PP
means to use the current locale's rules (see perllocale) when pattern
matching.  For example, \f(CW\*(C`\ew\*(C'\fR will match the \*(L"word\*(R" characters of that
locale, and \f(CW"/i"\fR case-insensitive matching will match according to
the locale's case folding rules.  The locale used will be the one in
effect at the time of execution of the pattern match.  This may not be
the same as the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
\&\fIsetlocale()\fR function.
.PP
Perl only supports single-byte locales.  This means that code points
above 255 are treated as Unicode no matter what locale is in effect.
Under Unicode rules, there are a few case-insensitive matches that cross
the 255/256 boundary.  These are disallowed under \f(CW\*(C`/l\*(C'\fR.  For example,
0xFF (on \s-1ASCII\s0 platforms) does not caselessly match the character at
0x178, \f(CW\*(C`LATIN CAPITAL LETTER Y WITH DIAERESIS\*(C'\fR, because 0xFF may not be
\&\f(CW\*(C`LATIN SMALL LETTER Y WITH DIAERESIS\*(C'\fR in the current locale, and Perl
has no way of knowing if that character even exists in the locale, much
less what code point it is.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use locale\*(C'\fR, but
see \*(L"Which character set modifier is in effect?\*(R".
.IX Xref " l"
.PP
/u
.IX Subsection "/u"
.PP
means to use Unicode rules when pattern matching.  On \s-1ASCII\s0 platforms,
this means that the code points between 128 and 255 take on their
Latin\-1 (\s-1ISO\-8859\-1\s0) meanings (which are the same as Unicode's).
(Otherwise Perl considers their meanings to be undefined.)  Thus,
under this modifier, the \s-1ASCII\s0 platform effectively becomes a Unicode
platform; and hence, for example, \f(CW\*(C`\ew\*(C'\fR will match any of the more than
100_000 word characters in Unicode.
.PP
Unlike most locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters \fIsomewhere\fR in
the world as
\&\f(CW\*(C`\ew\*(C'\fR.  For example, your locale might not think that \f(CW\*(C`LATIN SMALL
LETTER ETH\*(C'\fR is a letter (unless you happen to speak Icelandic), but
Unicode does.  Similarly, all the characters that are decimal digits
somewhere in the world will match \f(CW\*(C`\ed\*(C'\fR; this is hundreds, not 10,
possible matches.  And some of those digits look like some of the 10
\&\s-1ASCII\s0 digits, but mean a different number, so a human could easily think
a number is a different quantity than it really is.  For example,
\&\f(CW\*(C`BENGALI DIGIT FOUR\*(C'\fR (U+09EA) looks very much like an
\&\f(CW\*(C`ASCII DIGIT EIGHT\*(C'\fR (U+0038).  And, \f(CW\*(C`\ed+\*(C'\fR, may match strings of digits
that are a mixture from different writing systems, creating a security
issue.  \*(L"\fInum()\fR\*(R" in Unicode::UCD can be used to sort
this out.  Or the \f(CW\*(C`/a\*(C'\fR modifier can be used to force \f(CW\*(C`\ed\*(C'\fR to match
just the \s-1ASCII 0\s0 through 9.
.PP
Also, under this modifier, case-insensitive matching works on the full
set of Unicode
characters.  The \f(CW\*(C`KELVIN SIGN\*(C'\fR, for example matches the letters \*(L"k\*(R" and
\&\*(L"K\*(R"; and \f(CW\*(C`LATIN SMALL LIGATURE FF\*(C'\fR matches the sequence \*(L"ff\*(R", which,
if you're not prepared, might make it look like a hexadecimal constant,
presenting another potential security issue.  See
<http://unicode.org/reports/tr36> for a detailed discussion of Unicode
security issues.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use feature
\&\*(Aqunicode_strings\*(C'\fR, \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher),
but see \*(L"Which character set modifier is in effect?\*(R".
.IX Xref " u"
.PP
/d
.IX Subsection "/d"
.PP
This modifier means to use the \*(L"Default\*(R" native rules of the platform
except when there is cause to use Unicode rules instead, as follows:
.IP "1." 4
the target string is encoded in \s-1UTF\-8\s0; or
.IP "2." 4
the pattern is encoded in \s-1UTF\-8\s0; or
.IP "3." 4
the pattern explicitly mentions a code point that is above 255 (say by
\&\f(CW\*(C`\ex{100}\*(C'\fR); or
.IP "4." 4
the pattern uses a Unicode name (\f(CW\*(C`\eN{...}\*(C'\fR);  or
.IP "5." 4
the pattern uses a Unicode property (\f(CW\*(C`\ep{...}\*(C'\fR); or
.IP "6." 4
the pattern uses "\f(CW\*(C`(?[ ])\*(C'\fR"
.PP
Another mnemonic for this modifier is \*(L"Depends\*(R", as the rules actually
used depend on various things, and as a result you can get unexpected
results.  See \*(L"The \*(R"Unicode Bug"" in perlunicode.  The Unicode Bug has
become rather infamous, leading to yet another (printable) name for this
modifier, \*(L"Dodgy\*(R".
.PP
Unless the pattern or string are encoded in \s-1UTF\-8,\s0 only \s-1ASCII\s0 characters
can match positively.
.PP
Here are some examples of how that works on an \s-1ASCII\s0 platform:
.PP
.Vb 6
\& $str =  "\exDF";      # $str is not in UTF\-8 format.
\& $str =~ /^\ew/;       # No match, as $str isn\*(Aqt in UTF\-8 format.
\& $str .= "\ex{0e0b}";  # Now $str is in UTF\-8 format.
\& $str =~ /^\ew/;       # Match! $str is now in UTF\-8 format.
\& chop $str;
\& $str =~ /^\ew/;       # Still a match! $str remains in UTF\-8 format.
.Ve
.PP
This modifier is automatically selected by default when none of the
others are, so yet another name for it is \*(L"Default\*(R".
.PP
Because of the unexpected behaviors associated with this modifier, you
probably should only use it to maintain weird backward compatibilities.
.PP
/a (and /aa)
.IX Subsection "/a (and /aa)"
.PP
This modifier stands for ASCII-restrict (or ASCII-safe).  This modifier,
unlike the others, may be doubled-up to increase its effect.
.PP
When it appears singly, it causes the sequences \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and
the Posix character classes to match only in the \s-1ASCII\s0 range.  They thus
revert to their pre\-5.6, pre-Unicode meanings.  Under \f(CW\*(C`/a\*(C'\fR,  \f(CW\*(C`\ed\*(C'\fR
always means precisely the digits \f(CW"0"\fR to \f(CW"9"\fR; \f(CW\*(C`\es\*(C'\fR means the five
characters \f(CW\*(C`[ \ef\en\er\et]\*(C'\fR, and starting in Perl v5.18, experimentally,
the vertical tab; \f(CW\*(C`\ew\*(C'\fR means the 63 characters
\&\f(CW\*(C`[A\-Za\-z0\-9_]\*(C'\fR; and likewise, all the Posix classes such as
\&\f(CW\*(C`[[:print:]]\*(C'\fR match only the appropriate ASCII-range characters.
.PP
This modifier is useful for people who only incidentally use Unicode,
and who do not wish to be burdened with its complexities and security
concerns.
.PP
With \f(CW\*(C`/a\*(C'\fR, one can write \f(CW\*(C`\ed\*(C'\fR with confidence that it will only match
\&\s-1ASCII\s0 characters, and should the need arise to match beyond \s-1ASCII,\s0 you
can instead use \f(CW\*(C`\ep{Digit}\*(C'\fR (or \f(CW\*(C`\ep{Word}\*(C'\fR for \f(CW\*(C`\ew\*(C'\fR).  There are
similar \f(CW\*(C`\ep{...}\*(C'\fR constructs that can match beyond \s-1ASCII\s0 both white
space (see \*(L"Whitespace\*(R" in perlrecharclass), and Posix classes (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass).  Thus, this modifier
doesn't mean you can't use Unicode, it means that to get Unicode
matching you must explicitly use a construct (\f(CW\*(C`\ep{}\*(C'\fR, \f(CW\*(C`\eP{}\*(C'\fR) that
signals Unicode.
.PP
As you would expect, this modifier causes, for example, \f(CW\*(C`\eD\*(C'\fR to mean
the same thing as \f(CW\*(C`[^0\-9]\*(C'\fR; in fact, all non-ASCII characters match
\&\f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, and \f(CW\*(C`\eW\*(C'\fR.  \f(CW\*(C`\eb\*(C'\fR still means to match at the boundary
between \f(CW\*(C`\ew\*(C'\fR and \f(CW\*(C`\eW\*(C'\fR, using the \f(CW\*(C`/a\*(C'\fR definitions of them (similarly
for \f(CW\*(C`\eB\*(C'\fR).
.PP
Otherwise, \f(CW\*(C`/a\*(C'\fR behaves like the \f(CW\*(C`/u\*(C'\fR modifier, in that
case-insensitive matching uses Unicode semantics; for example, \*(L"k\*(R" will
match the Unicode \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching, and code
points in the Latin1 range, above \s-1ASCII\s0 will have Unicode rules when it
comes to case-insensitive matching.
.PP
To forbid ASCII/non\-ASCII matches (like \*(L"k\*(R" with \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR),
specify the \*(L"a\*(R" twice, for example \f(CW\*(C`/aai\*(C'\fR or \f(CW\*(C`/aia\*(C'\fR.  (The first
occurrence of \*(L"a\*(R" restricts the \f(CW\*(C`\ed\*(C'\fR, etc., and the second occurrence
adds the \f(CW\*(C`/i\*(C'\fR restrictions.)  But, note that code points outside the
\&\s-1ASCII\s0 range will use Unicode rules for \f(CW\*(C`/i\*(C'\fR matching, so the modifier
doesn't really restrict things to just \s-1ASCII\s0; it just forbids the
intermixing of \s-1ASCII\s0 and non-ASCII.
.PP
To summarize, this modifier provides protection for applications that
don't wish to be exposed to all of Unicode.  Specifying it twice
gives added protection.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use re \*(Aq/a\*(Aq\*(C'\fR
or \f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR.  If you do so, you may actually have occasion to use
the \f(CW\*(C`/u\*(C'\fR modifier explictly if there are a few regular expressions
where you do want full Unicode rules (but even here, it's best if
everything were under feature \f(CW"unicode_strings"\fR, along with the
\&\f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR).  Also see \*(L"Which character set modifier is in
effect?\*(R".
.IX Xref " a aa"
.PP
Which character set modifier is in effect?
.IX Subsection "Which character set modifier is in effect?"
.PP
Which of these modifiers is in effect at any given point in a regular
expression depends on a fairly complex set of interactions.  These have
been designed so that in general you don't have to worry about it, but
this section gives the gory details.  As
explained below in \*(L"Extended Patterns\*(R" it is possible to explicitly
specify modifiers that apply only to portions of a regular expression.
The innermost always has priority over any outer ones, and one applying
to the whole expression has priority over any of the default settings that are
described in the remainder of this section.
.PP
The \f(CW\*(C`use re \*(Aq/foo\*(Aq\*(C'\fR pragma can be used to set
default modifiers (including these) for regular expressions compiled
within its scope.  This pragma has precedence over the other pragmas
listed below that also change the defaults.
.PP
Otherwise, \f(CW\*(C`use locale\*(C'\fR sets the default modifier to \f(CW\*(C`/l\*(C'\fR;
and \f(CW\*(C`use feature \*(Aqunicode_strings\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher) set the default to
\&\f(CW\*(C`/u\*(C'\fR when not in the same scope as either \f(CW\*(C`use locale\*(C'\fR
or \f(CW\*(C`use bytes\*(C'\fR.
(\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR also
sets the default to \f(CW\*(C`/u\*(C'\fR, overriding any plain \f(CW\*(C`use locale\*(C'\fR.)
Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern matching, and so
give more consistent results with other operators, including using
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, etc. in substitution replacements.
.PP
If none of the above apply, for backwards compatibility reasons, the
\&\f(CW\*(C`/d\*(C'\fR modifier is the one in effect by default.  As this can lead to
unexpected results, it is best to specify which other rule set should be
used.
.PP
Character set modifier behavior prior to Perl 5.14
.IX Subsection "Character set modifier behavior prior to Perl 5.14"
.PP
Prior to 5.14, there were no explicit modifiers, but \f(CW\*(C`/l\*(C'\fR was implied
for regexes compiled within the scope of \f(CW\*(C`use locale\*(C'\fR, and \f(CW\*(C`/d\*(C'\fR was
implied otherwise.  However, interpolating a regex into a larger regex
would ignore the original compilation in favor of whatever was in effect
at the time of the second compilation.  There were a number of
inconsistencies (bugs) with the \f(CW\*(C`/d\*(C'\fR modifier, where Unicode rules
would be used when inappropriate, and vice versa.  \f(CW\*(C`\ep{}\*(C'\fR did not imply
Unicode rules, and neither did all occurrences of \f(CW\*(C`\eN{}\*(C'\fR, until 5.12.
.SS "Regular Expressions"
.IX Subsection "Regular Expressions"
\fIMetacharacters\fR
.IX Subsection "Metacharacters"
.PP
The patterns used in Perl pattern matching evolved from those supplied in
the Version 8 regex routines.  (The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See \*(L"Version 8 Regular Expressions\*(R" for
details.
.PP
In particular the following metacharacters have their standard \fIegrep\fR\-ish
meanings:
.IX Xref "metacharacter \\ ^ . $ | ( () [ []"
.PP
.Vb 7
\&    \e        Quote the next metacharacter
\&    ^        Match the beginning of the line
\&    .        Match any character (except newline)
\&    $        Match the end of the line (or before newline at the end)
\&    |        Alternation
\&    ()       Grouping
\&    []       Bracketed Character class
.Ve
.PP
By default, the \*(L"^\*(R" character is guaranteed to match only the
beginning of the string, the \*(L"$\*(R" character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by \*(L"^\*(R" or \*(L"$\*(R".  You may, however, wish to treat a
string as a multi-line buffer, such that the \*(L"^\*(R" will match after any
newline within the string (except if the newline is the last character in
the string), and \*(L"$\*(R" will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting \f(CW$*\fR,
but this option was removed in perl 5.10.)
.IX Xref "^ $ m"
.PP
To simplify multi-line substitutions, the \*(L".\*(R" character never matches a
newline unless you use the \f(CW\*(C`/s\*(C'\fR modifier, which in effect tells Perl to pretend
the string is a single line\*(--even if it isn't.
.IX Xref ". s"
.PP
\fIQuantifiers\fR
.IX Subsection "Quantifiers"
.PP
The following standard quantifiers are recognized:
.IX Xref "metacharacter quantifier * + ? {n} {n,} {n,m}"
.PP
.Vb 6
\&    *           Match 0 or more times
\&    +           Match 1 or more times
\&    ?           Match 1 or 0 times
\&    {n}         Match exactly n times
\&    {n,}        Match at least n times
\&    {n,m}       Match at least n but not more than m times
.Ve
.PP
(If a curly bracket occurs in any other context and does not form part of
a backslashed sequence like \f(CW\*(C`\ex{...}\*(C'\fR, it is treated as a regular
character.  In particular, the lower quantifier bound is not optional,
and a typo in a quantifier silently causes it to be treated as the
literal characters.  For example,
.PP
.Vb 1
\&    /o{4,3}/
.Ve
.PP
looks like a quantifier that matches 0 times, since 4 is greater than 3,
but it really means to match the sequence of six characters
\&\f(CW"o\ {\ 4\ ,\ 3\ }"\fR.  It is planned to eventually require literal uses
of curly brackets to be escaped, say by preceding them with a backslash
or enclosing them within square brackets, (\f(CW"\e{"\fR or \f(CW"[{]"\fR).  This
change will allow for future syntax extensions (like making the lower
bound of a quantifier optional), and better error checking.  In the
meantime, you should get in the habit of escaping all instances where
you mean a literal \*(L"{\*(R".)
.PP
The \*(L"*\*(R" quantifier is equivalent to \f(CW\*(C`{0,}\*(C'\fR, the \*(L"+\*(R"
quantifier to \f(CW\*(C`{1,}\*(C'\fR, and the \*(L"?\*(R" quantifier to \f(CW\*(C`{0,1}\*(C'\fR.  n and m are limited
to non-negative integral values less than a preset limit defined when perl is built.
This is usually 32766 on the most common platforms.  The actual limit can
be seen in the error message generated by code such as this:
.PP
.Vb 1
\&    $_ **= $_ , / {$_} / for 2 .. 42;
.Ve
.PP
By default, a quantified subpattern is \*(L"greedy\*(R", that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.  If you want it to match the
minimum number of times possible, follow the quantifier with a \*(L"?\*(R".  Note
that the meanings don't change, just the \*(L"greediness\*(R":
.IX Xref "metacharacter greedy greediness ? *? +? ?? {n}? {n,}? {n,m}?"
.PP
.Vb 6
\&    *?        Match 0 or more times, not greedily
\&    +?        Match 1 or more times, not greedily
\&    ??        Match 0 or 1 time, not greedily
\&    {n}?      Match exactly n times, not greedily (redundant)
\&    {n,}?     Match at least n times, not greedily
\&    {n,m}?    Match at least n but not more than m times, not greedily
.Ve
.PP
By default, when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl provides the \*(L"possessive\*(R" quantifier form
as well.
.PP
.Vb 6
\& *+     Match 0 or more times and give nothing back
\& ++     Match 1 or more times and give nothing back
\& ?+     Match 0 or 1 time and give nothing back
\& {n}+   Match exactly n times and give nothing back (redundant)
\& {n,}+  Match at least n times and give nothing back
\& {n,m}+ Match at least n but not more than m times and give nothing back
.Ve
.PP
For instance,
.PP
.Vb 1
\&   \*(Aqaaaa\*(Aq =~ /a++a/
.Ve
.PP
will never match, as the \f(CW\*(C`a++\*(C'\fR will gobble up all the \f(CW\*(C`a\*(C'\fR's in the
string and won't leave any for the remaining part of the pattern. This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack. For instance, the typical \*(L"match a double-quoted
string\*(R" problem can be most efficiently performed when written as:
.PP
.Vb 1
\&   /"(?:[^"\e\e]++|\e\e.)*+"/
.Ve
.PP
as we know that if the final quote does not match, backtracking will not
help. See the independent subexpression
"\f(CW\*(C`(?>pattern)\*(C'\fR" for more details;
possessive quantifiers are just syntactic sugar for that construct. For
instance the above example could also be written as follows:
.PP
.Vb 1
\&   /"(?>(?:(?>[^"\e\e]+)|\e\e.)*)"/
.Ve
.PP
\fIEscape sequences\fR
.IX Subsection "Escape sequences"
.PP
Because patterns are processed as double-quoted strings, the following
also work:
.PP
.Vb 10
\& \et          tab                   (HT, TAB)
\& \en          newline               (LF, NL)
\& \er          return                (CR)
\& \ef          form feed             (FF)
\& \ea          alarm (bell)          (BEL)
\& \ee          escape (think troff)  (ESC)
\& \ecK         control char          (example: VT)
\& \ex{}, \ex00  character whose ordinal is the given hexadecimal number
\& \eN{name}    named Unicode character or character sequence
\& \eN{U+263D}  Unicode character     (example: FIRST QUARTER MOON)
\& \eo{}, \e000  character whose ordinal is the given octal number
\& \el          lowercase next char (think vi)
\& \eu          uppercase next char (think vi)
\& \eL          lowercase till \eE (think vi)
\& \eU          uppercase till \eE (think vi)
\& \eQ          quote (disable) pattern metacharacters till \eE
\& \eE          end either case modification or quoted section, think vi
.Ve
.PP
Details are in \*(L"Quote and Quote-like Operators\*(R" in perlop.
.PP
\fICharacter Classes and other Special Escapes\fR
.IX Subsection "Character Classes and other Special Escapes"
.PP
In addition, Perl defines the following:
.IX Xref "\\g \\k \\K backreference"
.PP
.Vb 10
\& Sequence   Note    Description
\&  [...]     [1]  Match a character according to the rules of the
\&                   bracketed character class defined by the "...".
\&                   Example: [a\-z] matches "a" or "b" or "c" ... or "z"
\&  [[:...:]] [2]  Match a character according to the rules of the POSIX
\&                   character class "..." within the outer bracketed
\&                   character class.  Example: [[:upper:]] matches any
\&                   uppercase character.
\&  (?[...])  [8]  Extended bracketed character class
\&  \ew        [3]  Match a "word" character (alphanumeric plus "_", plus
\&                   other connector punctuation chars plus Unicode
\&                   marks)
\&  \eW        [3]  Match a non\-"word" character
\&  \es        [3]  Match a whitespace character
\&  \eS        [3]  Match a non\-whitespace character
\&  \ed        [3]  Match a decimal digit character
\&  \eD        [3]  Match a non\-digit character
\&  \epP       [3]  Match P, named property.  Use \ep{Prop} for longer names
\&  \ePP       [3]  Match non\-P
\&  \eX        [4]  Match Unicode "eXtended grapheme cluster"
\&  \eC             Match a single C\-language char (octet) even if that is
\&                   part of a larger UTF\-8 character.  Thus it breaks up
\&                   characters into their UTF\-8 bytes, so you may end up
\&                   with malformed pieces of UTF\-8.  Unsupported in
\&                   lookbehind.
\&  \e1        [5]  Backreference to a specific capture group or buffer.
\&                   \*(Aq1\*(Aq may actually be any positive integer.
\&  \eg1       [5]  Backreference to a specific or previous group,
\&  \eg{\-1}    [5]  The number may be negative indicating a relative
\&                   previous group and may optionally be wrapped in
\&                   curly brackets for safer parsing.
\&  \eg{name}  [5]  Named backreference
\&  \ek<name>  [5]  Named backreference
\&  \eK        [6]  Keep the stuff left of the \eK, don\*(Aqt include it in $&
\&  \eN        [7]  Any character but \en.  Not affected by /s modifier
\&  \ev        [3]  Vertical whitespace
\&  \eV        [3]  Not vertical whitespace
\&  \eh        [3]  Horizontal whitespace
\&  \eH        [3]  Not horizontal whitespace
\&  \eR        [4]  Linebreak
.Ve
.IP "[1]" 4
.IX Item "[1]"
See \*(L"Bracketed Character Classes\*(R" in perlrecharclass for details.
.IP "[2]" 4
.IX Item "[2]"
See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass for details.
.IP "[3]" 4
.IX Item "[3]"
See \*(L"Backslash sequences\*(R" in perlrecharclass for details.
.IP "[4]" 4
.IX Item "[4]"
See \*(L"Misc\*(R" in perlrebackslash for details.
.IP "[5]" 4
.IX Item "[5]"
See \*(L"Capture groups\*(R" below for details.
.IP "[6]" 4
.IX Item "[6]"
See \*(L"Extended Patterns\*(R" below for details.
.IP "[7]" 4
.IX Item "[7]"
Note that \f(CW\*(C`\eN\*(C'\fR has two meanings.  When of the form \f(CW\*(C`\eN{NAME}\*(C'\fR, it matches the
character or character sequence whose name is \f(CW\*(C`NAME\*(C'\fR; and similarly
when of the form \f(CW\*(C`\eN{U+\f(CIhex\f(CW}\*(C'\fR, it matches the character whose Unicode
code point is \fIhex\fR.  Otherwise it matches any character but \f(CW\*(C`\en\*(C'\fR.
.IP "[8]" 4
.IX Item "[8]"
See \*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass for details.
.PP
\fIAssertions\fR
.IX Subsection "Assertions"
.PP
Perl defines the following zero-width assertions:
.IX Xref "zero-width assertion assertion regex, zero-width assertion regexp, zero-width assertion regular expression, zero-width assertion \\b \\B \\A \\Z \\z \\G"
.PP
.Vb 7
\&    \eb  Match a word boundary
\&    \eB  Match except at a word boundary
\&    \eA  Match only at beginning of string
\&    \eZ  Match only at end of string, or before newline at the end
\&    \ez  Match only at end of string
\&    \eG  Match only at pos() (e.g. at the end\-of\-match position
\&        of prior m//g)
.Ve
.PP
A word boundary (\f(CW\*(C`\eb\*(C'\fR) is a spot between two characters
that has a \f(CW\*(C`\ew\*(C'\fR on one side of it and a \f(CW\*(C`\eW\*(C'\fR on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a \f(CW\*(C`\eW\*(C'\fR.  (Within
character classes \f(CW\*(C`\eb\*(C'\fR represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The \f(CW\*(C`\eA\*(C'\fR and \f(CW\*(C`\eZ\*(C'\fR are just like \*(L"^\*(R" and \*(L"$\*(R", except that they
won't match multiple times when the \f(CW\*(C`/m\*(C'\fR modifier is used, while
\&\*(L"^\*(R" and \*(L"$\*(R" will match at every internal line boundary.  To match
the actual end of the string and not ignore an optional trailing
newline, use \f(CW\*(C`\ez\*(C'\fR.
.IX Xref "\\b \\A \\Z \\z m"
.PP
The \f(CW\*(C`\eG\*(C'\fR assertion can be used to chain global matches (using
\&\f(CW\*(C`m//g\*(C'\fR), as described in \*(L"Regexp Quote-Like Operators\*(R" in perlop.
It is also useful when writing \f(CW\*(C`lex\*(C'\fR\-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string; see the previous reference.  The actual location
where \f(CW\*(C`\eG\*(C'\fR will match can also be influenced by using \f(CW\*(C`pos()\*(C'\fR as
an lvalue: see \*(L"pos\*(R" in perlfunc. Note that the rule for zero-length
matches (see \*(L"Repeated Patterns Matching a Zero-length Substring\*(R")
is modified somewhat, in that contents to the left of \f(CW\*(C`\eG\*(C'\fR are
not counted when determining the length of the match. Thus the following
will not match forever:
.IX Xref "\\G"
.PP
.Vb 5
\&     my $string = \*(AqABC\*(Aq;
\&     pos($string) = 1;
\&     while ($string =~ /(.\eG)/g) {
\&         print $1;
\&     }
.Ve
.PP
It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.
.PP
It is worth noting that \f(CW\*(C`\eG\*(C'\fR improperly used can result in an infinite
loop. Take care when using patterns that include \f(CW\*(C`\eG\*(C'\fR in an alternation.
.PP
\fICapture groups\fR
.IX Subsection "Capture groups"
.PP
The bracketing construct \f(CW\*(C`( ... )\*(C'\fR creates capture groups (also referred to as
capture buffers). To refer to the current contents of a group later on, within
the same pattern, use \f(CW\*(C`\eg1\*(C'\fR (or \f(CW\*(C`\eg{1}\*(C'\fR) for the first, \f(CW\*(C`\eg2\*(C'\fR (or \f(CW\*(C`\eg{2}\*(C'\fR)
for the second, and so on.
This is called a \fIbackreference\fR.
 
 
 
 
    
 
 
  
There is no limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being number 1, etc.  If
a group did not match, the associated backreference won't match either. (This
can happen if the group is optional, or in a different branch of an
alternation.)
You can omit the \f(CW"g"\fR, and write \f(CW"\e1"\fR, etc, but there are some issues with
this form, described below.
.IX Xref "regex, capture buffer regexp, capture buffer regex, capture group regexp, capture group regular expression, capture buffer backreference regular expression, capture group backreference \\g{1} \\g{-1} \\g{name} relative backreference named backreference named capture buffer regular expression, named capture buffer named capture group regular expression, named capture group %+ $+{name} \\k<name>"
.PP
You can also refer to capture groups relatively, by using a negative number, so
that \f(CW\*(C`\eg\-1\*(C'\fR and \f(CW\*(C`\eg{\-1}\*(C'\fR both refer to the immediately preceding capture
group, and \f(CW\*(C`\eg\-2\*(C'\fR and \f(CW\*(C`\eg{\-2}\*(C'\fR both refer to the group before it.  For
example:
.PP
.Vb 8
\&        /
\&         (Y)            # group 1
\&         (              # group 2
\&            (X)         # group 3
\&            \eg{\-1}      # backref to group 3
\&            \eg{\-3}      # backref to group 1
\&         )
\&        /x
.Ve
.PP
would match the same as \f(CW\*(C`/(Y) ( (X) \eg3 \eg1 )/x\*(C'\fR.  This allows you to
interpolate regexes into larger regexes and not have to worry about the
capture groups being renumbered.
.PP
You can dispense with numbers altogether and create named capture groups.
The notation is \f(CW\*(C`(?<\f(CIname\f(CW>...)\*(C'\fR to declare and \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR to
reference.  (To be compatible with .Net regular expressions, \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR may
also be written as \f(CW\*(C`\ek{\f(CIname\f(CW}\*(C'\fR, \f(CW\*(C`\ek<\f(CIname\f(CW>\*(C'\fR or \f(CW\*(C`\ek\*(Aq\f(CIname\f(CW\*(Aq\*(C'\fR.)
\&\fIname\fR must not begin with a number, nor contain hyphens.
When different groups within the same pattern have the same name, any reference
to that name assumes the leftmost defined group.  Named groups count in
absolute and relative numbering, and so can also be referred to by those
numbers.
(It's possible to do things with named capture groups that would otherwise
require \f(CW\*(C`(??{})\*(C'\fR.)
.PP
Capture group contents are dynamically scoped and available to you outside the
pattern until the end of the enclosing block or until the next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" in perlsyn.)
You can refer to them by absolute number (using \f(CW"$1"\fR instead of \f(CW"\eg1"\fR,
etc); or by name via the \f(CW\*(C`%+\*(C'\fR hash, using \f(CW"$+{\f(CIname\f(CW}"\fR.
.PP
Braces are required in referring to named capture groups, but are optional for
absolute or relative numbered ones.  Braces are safer when creating a regex by
concatenating smaller strings.  For example if you have \f(CW\*(C`qr/$a$b/\*(C'\fR, and \f(CW$a\fR
contained \f(CW"\eg1"\fR, and \f(CW$b\fR contained \f(CW"37"\fR, you would get \f(CW\*(C`/\eg137/\*(C'\fR which
is probably not what you intended.
.PP
The \f(CW\*(C`\eg\*(C'\fR and \f(CW\*(C`\ek\*(C'\fR notations were introduced in Perl 5.10.0.  Prior to that
there were no named nor relative numbered capture groups.  Absolute numbered
groups were referred to using \f(CW\*(C`\e1\*(C'\fR,
\&\f(CW\*(C`\e2\*(C'\fR, etc., and this notation is still
accepted (and likely always will be).  But it leads to some ambiguities if
there are more than 9 capture groups, as \f(CW\*(C`\e10\*(C'\fR could mean either the tenth
capture group, or the character whose ordinal in octal is 010 (a backspace in
\&\s-1ASCII\s0).  Perl resolves this ambiguity by interpreting \f(CW\*(C`\e10\*(C'\fR as a backreference
only if at least 10 left parentheses have opened before it.  Likewise \f(CW\*(C`\e11\*(C'\fR is
a backreference only if at least 11 left parentheses have opened before it.
And so on.  \f(CW\*(C`\e1\*(C'\fR through \f(CW\*(C`\e9\*(C'\fR are always interpreted as backreferences.
There are several examples below that illustrate these perils.  You can avoid
the ambiguity by always using \f(CW\*(C`\eg{}\*(C'\fR or \f(CW\*(C`\eg\*(C'\fR if you mean capturing groups;
and for octal constants always using \f(CW\*(C`\eo{}\*(C'\fR, or for \f(CW\*(C`\e077\*(C'\fR and below, using 3
digits padded with leading zeros, since a leading zero implies an octal
constant.
.PP
The \f(CW\*(C`\e\f(CIdigit\f(CW\*(C'\fR notation also works in certain circumstances outside
the pattern.  See \*(L"Warning on \e1 Instead of \f(CW$1\fR\*(R" below for details.
.PP
Examples:
.PP
.Vb 1
\&    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
\&
\&    /(.)\eg1/                        # find first doubled char
\&         and print "\*(Aq$1\*(Aq is the first doubled character\en";
\&
\&    /(?<char>.)\ek<char>/            # ... a different way
\&         and print "\*(Aq$+{char}\*(Aq is the first doubled character\en";
\&
\&    /(?\*(Aqchar\*(Aq.)\eg1/                 # ... mix and match
\&         and print "\*(Aq$1\*(Aq is the first doubled character\en";
\&
\&    if (/Time: (..):(..):(..)/) {   # parse out values
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
\&
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\eg10/   # \eg10 is a backreference
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\e10/    # \e10 is octal
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e10/  # \e10 is a backreference
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e010/ # \e010 is octal
\&
\&    $a = \*(Aq(.)\e1\*(Aq;        # Creates problems when concatenated.
\&    $b = \*(Aq(.)\eg{1}\*(Aq;     # Avoids the problems.
\&    "aa" =~ /${a}/;      # True
\&    "aa" =~ /${b}/;      # True
\&    "aa0" =~ /${a}0/;    # False!
\&    "aa0" =~ /${b}0/;    # True
\&    "aa\ex08" =~ /${a}0/;  # True!
\&    "aa\ex08" =~ /${b}0/;  # False
.Ve
.PP
Several special variables also refer back to portions of the previous
match.  \f(CW$+\fR returns whatever the last bracket match matched.
\&\f(CW$&\fR returns the entire matched string.  (At one point \f(CW$0\fR did
also, but now it returns the name of the program.)  \f(CW\*(C`$\`\*(C'\fR returns
everything before the matched string.  \f(CW\*(C`$\*(Aq\*(C'\fR returns everything
after the matched string. And \f(CW$^N\fR contains whatever was matched by
the most-recently closed group (submatch). \f(CW$^N\fR can be used in
extended patterns (see below), for example to assign a submatch to a
variable.
.IX Xref "$+ $^N $& $` $'"
.PP
These special variables, like the \f(CW\*(C`%+\*(C'\fR hash and the numbered match variables
(\f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR, etc.) are dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" in perlsyn.)
.IX Xref "$+ $^N $& $` $' $1 $2 $3 $4 $5 $6 $7 $8 $9"
.PP
\&\fB\s-1NOTE\s0\fR: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.
.PP
\&\fB\s-1WARNING\s0\fR: Once Perl sees that you need one of \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR, or
\&\f(CW\*(C`$\*(Aq\*(C'\fR anywhere in the program, it has to provide them for every
pattern match.  This may substantially slow your program.  Perl
uses the same mechanism to produce \f(CW$1\fR, \f(CW$2\fR, etc, so you also pay a
price for each pattern that contains capturing parentheses.  (To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression \f(CW\*(C`(?: ... )\*(C'\fR instead.)  But if you never
use \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR or \f(CW\*(C`$\*(Aq\*(C'\fR, then patterns \fIwithout\fR capturing
parentheses will not be penalized.  So avoid \f(CW$&\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, and \f(CW\*(C`$\`\*(C'\fR
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.  As of 5.17.4, the presence of each of the three
variables in a program is recorded separately, and depending on
circumstances, perl may be able be more efficient knowing that only \f(CW$&\fR
rather than all three have been seen, for example.
.IX Xref "$& $` $'"
.PP
As a workaround for this problem, Perl 5.10.0 introduces \f(CW\*(C`${^PREMATCH}\*(C'\fR,
\&\f(CW\*(C`${^MATCH}\*(C'\fR and \f(CW\*(C`${^POSTMATCH}\*(C'\fR, which are equivalent to \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR
and \f(CW\*(C`$\*(Aq\*(C'\fR, \fBexcept\fR that they are only guaranteed to be defined after a
successful match that was executed with the \f(CW\*(C`/p\*(C'\fR (preserve) modifier.
The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.
.IX Xref " p p modifier"
.SS "Quoting metacharacters"
.IX Subsection "Quoting metacharacters"
Backslashed metacharacters in Perl are alphanumeric, such as \f(CW\*(C`\eb\*(C'\fR,
\&\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\en\*(C'\fR.  Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.  So anything
that looks like \e\e, \e(, \e), \e[, \e], \e{, or \e} is always
interpreted as a literal character, not a metacharacter.  This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern. Simply quote all non\-\*(L"word\*(R" characters:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e$1/g;
.Ve
.PP
(If \f(CW\*(C`use locale\*(C'\fR is set, then this depends on the current locale.)
Today it is more common to use the \fIquotemeta()\fR function or the \f(CW\*(C`\eQ\*(C'\fR
metaquoting escape sequence to disable all metacharacters' special
meanings like this:
.PP
.Vb 1
\&    /$unquoted\eQ$quoted\eE$unquoted/
.Ve
.PP
Beware that if you put literal backslashes (those not inside
interpolated variables) between \f(CW\*(C`\eQ\*(C'\fR and \f(CW\*(C`\eE\*(C'\fR, double-quotish
backslash interpolation may lead to confusing results.  If you
\&\fIneed\fR to use literal backslashes within \f(CW\*(C`\eQ...\eE\*(C'\fR,
consult \*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.PP
\&\f(CW\*(C`quotemeta()\*(C'\fR and \f(CW\*(C`\eQ\*(C'\fR are fully described in \*(L"quotemeta\*(R" in perlfunc.
.SS "Extended Patterns"
.IX Subsection "Extended Patterns"
Perl also defines a consistent extension syntax for features not
found in standard tools like \fBawk\fR and
\&\fBlex\fR.  The syntax for most of these is a
pair of parentheses with a question mark as the first thing within
the parentheses.  The character after the question mark indicates
the extension.
.PP
The stability of these extensions varies widely.  Some have been
part of the core language for many years.  Others are experimental
and may change without warning or be completely removed.  Check
the documentation on an individual feature to verify its current
status.
.PP
A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
\&\*(L"question\*(R" exactly what is going on.  That's psychology....
.ie n .IP """(?#text)""" 4
.el .IP "\f(CW(?#text)\fR" 4
.IX Xref "(?#)"
.IX Item "(?#text)"
A comment.  The text is ignored.  If the \f(CW\*(C`/x\*(C'\fR modifier enables
whitespace formatting, a simple \f(CW\*(C`#\*(C'\fR will suffice.  Note that Perl closes
the comment as soon as it sees a \f(CW\*(C`)\*(C'\fR, so there is no way to put a literal
\&\f(CW\*(C`)\*(C'\fR in the comment.
.ie n .IP """(?adlupimsx\-imsx)""" 4
.el .IP "\f(CW(?adlupimsx\-imsx)\fR" 4
.IX Item "(?adlupimsx-imsx)"
.PD 0
.ie n .IP """(?^alupimsx)""" 4
.el .IP "\f(CW(?^alupimsx)\fR" 4
.IX Xref "(?) (?^)"
.IX Item "(?^alupimsx)"
.PD
One or more embedded pattern-match modifiers, to be turned on (or
turned off, if preceded by \f(CW\*(C`\-\*(C'\fR) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).
.Sp
This is particularly useful for dynamic patterns, such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.  Consider the case where some patterns want to be
case-sensitive and some do not:  The case-insensitive ones merely need to
include \f(CW\*(C`(?i)\*(C'\fR at the front of the pattern.  For example:
.Sp
.Vb 2
\&    $pattern = "foobar";
\&    if ( /$pattern/i ) { }
\&
\&    # more flexible:
\&
\&    $pattern = "(?i)foobar";
\&    if ( /$pattern/ ) { }
.Ve
.Sp
These modifiers are restored at the end of the enclosing group. For example,
.Sp
.Vb 1
\&    ( (?i) blah ) \es+ \eg1
.Ve
.Sp
will match \f(CW\*(C`blah\*(C'\fR in any case, some spaces, and an exact (\fIincluding the case\fR!)
repetition of the previous word, assuming the \f(CW\*(C`/x\*(C'\fR modifier, and no \f(CW\*(C`/i\*(C'\fR
modifier outside this group.
.Sp
These modifiers do not carry over into named subpatterns called in the
enclosing group. In other words, a pattern such as \f(CW\*(C`((?i)(?&NAME))\*(C'\fR does not
change the case-sensitivity of the \*(L"\s-1NAME\*(R"\s0 pattern.
.Sp
Any of these modifiers can be set to apply globally to all regular
expressions compiled within the scope of a \f(CW\*(C`use re\*(C'\fR.  See
\&\*(L"'/flags' mode\*(R" in re.
.Sp
Starting in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
after the \f(CW"?"\fR is a shorthand equivalent to \f(CW\*(C`d\-imsx\*(C'\fR.  Flags (except
\&\f(CW"d"\fR) may follow the caret to override it.
But a minus sign is not legal with it.
.Sp
Note that the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR, and \f(CW\*(C`u\*(C'\fR modifiers are special in
that they can only be enabled, not disabled, and the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, and
\&\f(CW\*(C`u\*(C'\fR modifiers are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two \f(CW\*(C`a\*(C'\fR's) may appear in the
construct.  Thus, for
example, \f(CW\*(C`(?\-p)\*(C'\fR will warn when compiled under \f(CW\*(C`use warnings\*(C'\fR;
\&\f(CW\*(C`(?\-d:...)\*(C'\fR and \f(CW\*(C`(?dl:...)\*(C'\fR are fatal errors.
.Sp
Note also that the \f(CW\*(C`p\*(C'\fR modifier is special in that its presence
anywhere in a pattern has a global effect.
.ie n .IP """(?:pattern)""" 4
.el .IP "\f(CW(?:pattern)\fR" 4
.IX Xref "(?:)"
.IX Item "(?:pattern)"
.PD 0
.ie n .IP """(?adluimsx\-imsx:pattern)""" 4
.el .IP "\f(CW(?adluimsx\-imsx:pattern)\fR" 4
.IX Item "(?adluimsx-imsx:pattern)"
.ie n .IP """(?^aluimsx:pattern)""" 4
.el .IP "\f(CW(?^aluimsx:pattern)\fR" 4
.IX Xref "(?^:)"
.IX Item "(?^aluimsx:pattern)"
.PD
This is for clustering, not capturing; it groups subexpressions like
\&\*(L"()\*(R", but doesn't make backreferences as \*(L"()\*(R" does.  So
.Sp
.Vb 1
\&    @fields = split(/\eb(?:a|b|c)\eb/)
.Ve
.Sp
is like
.Sp
.Vb 1
\&    @fields = split(/\eb(a|b|c)\eb/)
.Ve
.Sp
but doesn't spit out extra fields.  It's also cheaper not to capture
characters if you don't need to.
.Sp
Any letters between \f(CW\*(C`?\*(C'\fR and \f(CW\*(C`:\*(C'\fR act as flags modifiers as with
\&\f(CW\*(C`(?adluimsx\-imsx)\*(C'\fR.  For example,
.Sp
.Vb 1
\&    /(?s\-i:more.*than).*million/i
.Ve
.Sp
is equivalent to the more verbose
.Sp
.Vb 1
\&    /(?:(?s\-i)more.*than).*million/i
.Ve
.Sp
Starting in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
after the \f(CW"?"\fR is a shorthand equivalent to \f(CW\*(C`d\-imsx\*(C'\fR.  Any positive
flags (except \f(CW"d"\fR) may follow the caret, so
.Sp
.Vb 1
\&    (?^x:foo)
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    (?x\-ims:foo)
.Ve
.Sp
The caret tells Perl that this cluster doesn't inherit the flags of any
surrounding pattern, but uses the system defaults (\f(CW\*(C`d\-imsx\*(C'\fR),
modified by any flags specified.
.Sp
The caret allows for simpler stringification of compiled regular
expressions.  These look like
.Sp
.Vb 1
\&    (?^:pattern)
.Ve
.Sp
with any non-default flags appearing between the caret and the colon.
A test that looks at such stringification thus doesn't need to have the
system default flags hard-coded in it, just the caret.  If new flags are
added to Perl, the meaning of the caret's expansion will change to include
the default for those flags, so the test will still work, unchanged.
.Sp
Specifying a negative flag after the caret is an error, as the flag is
redundant.
.Sp
Mnemonic for \f(CW\*(C`(?^...)\*(C'\fR:  A fresh beginning since the usual use of a caret is
to match at the beginning.
.ie n .IP """(?|pattern)""" 4
.el .IP "\f(CW(?|pattern)\fR" 4
.IX Xref "(?|) Branch reset"
.IX Item "(?|pattern)"
This is the \*(L"branch reset\*(R" pattern, which has the special property
that the capture groups are numbered from the same starting point
in each alternation branch. It is available starting from perl 5.10.0.
.Sp
Capture groups are numbered from left to right, but inside this
construct the numbering is restarted for each branch.
.Sp
The numbering within each branch will be as normal, and any groups
following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
groups in it.
.Sp
This construct is useful when you want to capture one of a
number of alternative matches.
.Sp
Consider the following pattern.  The numbers underneath show in
which group the captured content will be stored.
.Sp
.Vb 3
\&    # before  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-branch\-reset\-\-\-\-\-\-\-\-\-\-\- after        
\&    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
\&    # 1            2         2  3        2     3     4
.Ve
.Sp
Be careful when using the branch reset pattern in combination with 
named captures. Named captures are implemented as being aliases to 
numbered groups holding the captures, and that interferes with the
implementation of the branch reset pattern. If you are using named
captures in a branch reset pattern, it's best to use the same names,
in the same order, in each of the alternations:
.Sp
.Vb 2
\&   /(?|  (?<a> x ) (?<b> y )
\&      |  (?<a> z ) (?<b> w )) /x
.Ve
.Sp
Not doing so may lead to surprises:
.Sp
.Vb 3
\&  "12" =~ /(?| (?<a> \ed+ ) | (?<b> \eD+))/x;
\&  say $+ {a};   # Prints \*(Aq12\*(Aq
\&  say $+ {b};   # *Also* prints \*(Aq12\*(Aq.
.Ve
.Sp
The problem here is that both the group named \f(CW\*(C`a\*(C'\fR and the group
named \f(CW\*(C`b\*(C'\fR are aliases for the group belonging to \f(CW$1\fR.
.IP "Look-Around Assertions" 4
.IX Xref "look-around assertion lookaround assertion look-around lookaround"
.IX Item "Look-Around Assertions"
Look-around assertions are zero-width patterns which match a specific
pattern without including it in \f(CW$&\fR. Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.
.RS 4
.ie n .IP """(?=pattern)""" 4
.el .IP "\f(CW(?=pattern)\fR" 4
.IX Xref "(?=) look-ahead, positive lookahead, positive"
.IX Item "(?=pattern)"
A zero-width positive look-ahead assertion.  For example, \f(CW\*(C`/\ew+(?=\et)/\*(C'\fR
matches a word followed by a tab, without including the tab in \f(CW$&\fR.
.ie n .IP """(?!pattern)""" 4
.el .IP "\f(CW(?!pattern)\fR" 4
.IX Xref "(?!) look-ahead, negative lookahead, negative"
.IX Item "(?!pattern)"
A zero-width negative look-ahead assertion.  For example \f(CW\*(C`/foo(?!bar)/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" that isn't followed by \*(L"bar\*(R".  Note
however that look-ahead and look-behind are \s-1NOT\s0 the same thing.  You cannot
use this for look-behind.
.Sp
If you are looking for a \*(L"bar\*(R" that isn't preceded by a \*(L"foo\*(R", \f(CW\*(C`/(?!foo)bar/\*(C'\fR
will not do what you want.  That's because the \f(CW\*(C`(?!foo)\*(C'\fR is just saying that
the next thing cannot be \*(L"foo\*(R"\-\-and it's not, it's a \*(L"bar\*(R", so \*(L"foobar\*(R" will
match.  Use look-behind instead (see below).
.ie n .IP """(?<=pattern)"" ""\eK""" 4
.el .IP "\f(CW(?<=pattern)\fR \f(CW\eK\fR" 4
.IX Xref "(?<=) look-behind, positive lookbehind, positive \\K"
.IX Item "(?<=pattern) K"
A zero-width positive look-behind assertion.  For example, \f(CW\*(C`/(?<=\et)\ew+/\*(C'\fR
matches a word that follows a tab, without including the tab in \f(CW$&\fR.
Works only for fixed-width look-behind.
.Sp
There is a special form of this construct, called \f(CW\*(C`\eK\*(C'\fR, which causes the
regex engine to \*(L"keep\*(R" everything it had matched prior to the \f(CW\*(C`\eK\*(C'\fR and
not include it in \f(CW$&\fR. This effectively provides variable-length
look-behind. The use of \f(CW\*(C`\eK\*(C'\fR inside of another look-around assertion
is allowed, but the behaviour is currently not well defined.
.Sp
For various reasons \f(CW\*(C`\eK\*(C'\fR may be significantly more efficient than the
equivalent \f(CW\*(C`(?<=...)\*(C'\fR construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string. For instance
.Sp
.Vb 1
\&  s/(foo)bar/$1/g;
.Ve
.Sp
can be rewritten as the much more efficient
.Sp
.Vb 1
\&  s/foo\eKbar//g;
.Ve
.ie n .IP """(?<!pattern)""" 4
.el .IP "\f(CW(?<!pattern)\fR" 4
.IX Xref "(?<!) look-behind, negative lookbehind, negative"
.IX Item "(?<!pattern)"
A zero-width negative look-behind assertion.  For example \f(CW\*(C`/(?<!bar)foo/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" that does not follow \*(L"bar\*(R".  Works
only for fixed-width look-behind.
.RE
.RS 4
.RE
.ie n .IP """(?\*(AqNAME\*(Aqpattern)""" 4
.el .IP "\f(CW(?\*(AqNAME\*(Aqpattern)\fR" 4
.IX Item "(?NAMEpattern)"
.PD 0
.ie n .IP """(?<NAME>pattern)""" 4
.el .IP "\f(CW(?<NAME>pattern)\fR" 4
.IX Xref "(?<NAME>) (?'NAME') named capture capture"
.IX Item "(?<NAME>pattern)"
.PD
A named capture group. Identical in every respect to normal capturing
parentheses \f(CW\*(C`()\*(C'\fR but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like \f(CW\*(C`\eg{NAME}\*(C'\fR) and can be accessed by name
after a successful match via \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR. See perlvar
for more details on the \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR hashes.
.Sp
If multiple distinct capture groups have the same name then the
$+{\s-1NAME\s0} will refer to the leftmost defined group in the match.
.Sp
The forms \f(CW\*(C`(?\*(AqNAME\*(Aqpattern)\*(C'\fR and \f(CW\*(C`(?<NAME>pattern)\*(C'\fR are equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR While the notation of this construct is the same as the similar
function in .NET regexes, the behavior is not. In Perl the groups are
numbered sequentially regardless of being named or not. Thus in the
pattern
.Sp
.Vb 1
\&  /(x)(?<foo>y)(z)/
.Ve
.Sp
$+{foo} will be the same as \f(CW$2\fR, and \f(CW$3\fR will contain 'z' instead of
the opposite which is what a .NET regex hacker might expect.
.Sp
Currently \s-1NAME\s0 is restricted to simple identifiers only.
In other words, it must match \f(CW\*(C`/^[_A\-Za\-z][_A\-Za\-z0\-9]*\ez/\*(C'\fR or
its Unicode extension (see utf8),
though it isn't extended by the locale (see perllocale).
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines, the pattern \f(CW\*(C`(?P<NAME>pattern)\*(C'\fR
may be used instead of \f(CW\*(C`(?<NAME>pattern)\*(C'\fR; however this form does not
support the use of single quotes as a delimiter for the name.
.ie n .IP """\ek<NAME>""" 4
.el .IP "\f(CW\ek<NAME>\fR" 4
.IX Item "k<NAME>"
.PD 0
.ie n .IP """\ek\*(AqNAME\*(Aq""" 4
.el .IP "\f(CW\ek\*(AqNAME\*(Aq\fR" 4
.IX Item "kNAME"
.PD
Named backreference. Similar to numeric backreferences, except that
the group is designated by name and not number. If multiple groups
have the same name then it refers to the leftmost defined group in
the current match.
.Sp
It is an error to refer to a name not defined by a \f(CW\*(C`(?<NAME>)\*(C'\fR
earlier in the pattern.
.Sp
Both forms are equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines, the pattern \f(CW\*(C`(?P=NAME)\*(C'\fR
may be used instead of \f(CW\*(C`\ek<NAME>\*(C'\fR.
.ie n .IP """(?{ code })""" 4
.el .IP "\f(CW(?{ code })\fR" 4
.IX Xref "(?{}) regex, code in regexp, code in regular expression, code in"
.IX Item "(?{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine. The
implementation of this feature was radically overhauled for the 5.18.0
release, and its behaviour in earlier versions of perl was much buggier,
especially in relation to parsing, lexical vars, scoping, recursion and
reentrancy.
.Sp
This zero-width assertion executes any embedded Perl code.  It always
succeeds, and its return value is set as \f(CW$^R\fR.
.Sp
In literal patterns, the code is parsed at the same time as the
surrounding code. While within the pattern, control is passed temporarily
back to the perl parser, until the logically-balancing closing brace is
encountered. This is similar to the way that an array index expression in
a literal string is handled, for example
.Sp
.Vb 1
\&    "abc$array[ 1 + f(\*(Aq[\*(Aq) + g()]def"
.Ve
.Sp
In particular, braces do not need to be balanced:
.Sp
.Vb 1
\&    s/abc(?{ f(\*(Aq{\*(Aq); })/def/
.Ve
.Sp
Even in a pattern that is interpolated and compiled at run-time, literal
code blocks will be compiled once, at perl compile time; the following
prints \*(L"\s-1ABCD\*(R":\s0
.Sp
.Vb 5
\&    print "D";
\&    my $qr = qr/(?{ BEGIN { print "A" } })/;
\&    my $foo = "foo";
\&    /$foo$qr(?{ BEGIN { print "B" } })/;
\&    BEGIN { print "C" }
.Ve
.Sp
In patterns where the text of the code is derived from run-time
information rather than appearing literally in a source code /pattern/,
the code is compiled at the same time that the pattern is compiled, and
for reasons of security, \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR must be in scope. This is to
stop user-supplied patterns containing code snippets from being
executable.
.Sp
In situations where you need to enable this with \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR, you should
also have taint checking enabled.  Better yet, use the carefully
constrained evaluation within a Safe compartment.  See perlsec for
details about both these mechanisms.
.Sp
From the viewpoint of parsing, lexical variable scope and closures,
.Sp
.Vb 1
\&    /AAA(?{ BBB })CCC/
.Ve
.Sp
behaves approximately like
.Sp
.Vb 1
\&    /AAA/ && do { BBB } && /CCC/
.Ve
.Sp
Similarly,
.Sp
.Vb 1
\&    qr/AAA(?{ BBB })CCC/
.Ve
.Sp
behaves approximately like
.Sp
.Vb 1
\&    sub { /AAA/ && do { BBB } && /CCC/ }
.Ve
.Sp
In particular:
.Sp
.Vb 3
\&    { my $i = 1; $r = qr/(?{ print $i })/ }
\&    my $i = 2;
\&    /$r/; # prints "1"
.Ve
.Sp
Inside a \f(CW\*(C`(?{...})\*(C'\fR block, \f(CW$_\fR refers to the string the regular
expression is matching against. You can also use \f(CW\*(C`pos()\*(C'\fR to know what is
the current position of matching within this string.
.Sp
The code block introduces a new scope from the perspective of lexical
variable declarations, but \fBnot\fR from the perspective of \f(CW\*(C`local\*(C'\fR and
similar localizing behaviours. So later code blocks within the same
pattern will still see the values which were localized in earlier blocks.
These accumulated localizations are undone either at the end of a
successful match, or if the assertion is backtracked (compare
\&\*(L"Backtracking\*(R"). For example,
.Sp
.Vb 10
\&  $_ = \*(Aqa\*(Aq x 8;
\&  m<
\&     (?{ $cnt = 0 })               # Initialize $cnt.
\&     (
\&       a
\&       (?{
\&           local $cnt = $cnt + 1;  # Update $cnt,
\&                                   # backtracking\-safe.
\&       })
\&     )*
\&     aaaa
\&     (?{ $res = $cnt })            # On success copy to
\&                                   # non\-localized location.
\&   >x;
.Ve
.Sp
will initially increment \f(CW$cnt\fR up to 8; then during backtracking, its
value will be unwound back to 4, which is the value assigned to \f(CW$res\fR.
At the end of the regex execution, \f(CW$cnt\fR will be wound back to its initial
value of 0.
.Sp
This assertion may be used as the condition in a
.Sp
.Vb 1
\&    (?(condition)yes\-pattern|no\-pattern)
.Ve
.Sp
switch.  If \fInot\fR used in this way, the result of evaluation of \f(CW\*(C`code\*(C'\fR
is put into the special variable \f(CW$^R\fR.  This happens immediately, so
\&\f(CW$^R\fR can be used from other \f(CW\*(C`(?{ code })\*(C'\fR assertions inside the same
regular expression.
.Sp
The assignment to \f(CW$^R\fR above is properly localized, so the old
value of \f(CW$^R\fR is restored if the assertion is backtracked; compare
\&\*(L"Backtracking\*(R".
.Sp
Note that the special variable \f(CW$^N\fR  is particularly useful with code
blocks to capture the results of submatches in variables without having to
keep track of the number of nested parentheses. For example:
.Sp
.Vb 3
\&  $_ = "The brown fox jumps over the lazy dog";
\&  /the (\eS+)(?{ $color = $^N }) (\eS+)(?{ $animal = $^N })/i;
\&  print "color = $color, animal = $animal\en";
.Ve
.ie n .IP """(??{ code })""" 4
.el .IP "\f(CW(??{ code })\fR" 4
.IX Xref "(??{}) regex, postponed regexp, postponed regular expression, postponed"
.IX Item "(??{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.
.Sp
This is a \*(L"postponed\*(R" regular subexpression.  It behaves in \fIexactly\fR the
same way as a \f(CW\*(C`(?{ code })\*(C'\fR code block as described above, except that
its return value, rather than being assigned to \f(CW$^R\fR, is treated as a
pattern, compiled if it's a string (or used as-is if its a qr// object),
then matched as if it were inserted instead of this construct.
.Sp
During the matching of this sub-pattern, it has its own set of
captures which are valid during the sub-match, but are discarded once
control returns to the main pattern. For example, the following matches,
with the inner pattern capturing \*(L"B\*(R" and matching \*(L"\s-1BB\*(R",\s0 while the outer
pattern captures \*(L"A\*(R";
.Sp
.Vb 3
\&    my $inner = \*(Aq(.)\e1\*(Aq;
\&    "ABBA" =~ /^(.)(??{ $inner })\e1/;
\&    print $1; # prints "A";
.Ve
.Sp
Note that this means that  there is no way for the inner pattern to refer
to a capture group defined outside.  (The code block itself can use \f(CW$1\fR,
etc., to refer to the enclosing pattern's capture groups.)  Thus, although
.Sp
.Vb 1
\&    (\*(Aqa\*(Aq x 100)=~/(??{\*(Aq(.)\*(Aq x 100})/
.Ve
.Sp
\&\fIwill\fR match, it will \fInot\fR set \f(CW$1\fR on exit.
.Sp
The following pattern matches a parenthesized group:
.Sp
.Vb 9
\& $re = qr{
\&            \e(
\&            (?:
\&               (?> [^()]+ )  # Non\-parens without backtracking
\&             |
\&               (??{ $re })   # Group with matching parens
\&            )*
\&            \e)
\&         }x;
.Ve
.Sp
See also
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR
for a different, more efficient way to accomplish
the same task.
.Sp
Executing a postponed regular expression 50 times without consuming any
input string will result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.
.ie n .IP """(?\f(CIPARNO\f(CW)"" ""(?\-\f(CIPARNO\f(CW)"" ""(?+\f(CIPARNO\f(CW)"" ""(?R)"" ""(?0)""" 4
.el .IP "\f(CW(?\f(CIPARNO\f(CW)\fR \f(CW(?\-\f(CIPARNO\f(CW)\fR \f(CW(?+\f(CIPARNO\f(CW)\fR \f(CW(?R)\fR \f(CW(?0)\fR" 4
.IX Xref "(?PARNO) (?1) (?R) (?0) (?-1) (?+1) (?-PARNO) (?+PARNO) regex, recursive regexp, recursive regular expression, recursive regex, relative recursion"
.IX Item "(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)"
Similar to \f(CW\*(C`(??{ code })\*(C'\fR except that it does not involve executing any
code or potentially compiling a returned pattern string; instead it treats
the part of the current pattern contained within a specified capture group
as an independent pattern that must match at the current position.
Capture groups contained by the pattern will have the value as determined
by the outermost recursion.
.Sp
\&\fI\s-1PARNO\s0\fR is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture group to recurse to. \f(CW\*(C`(?R)\*(C'\fR recurses to
the beginning of the whole pattern. \f(CW\*(C`(?0)\*(C'\fR is an alternate syntax for
\&\f(CW\*(C`(?R)\*(C'\fR. If \fI\s-1PARNO\s0\fR is preceded by a plus or minus sign then it is assumed
to be relative, with negative numbers indicating preceding capture groups
and positive ones following. Thus \f(CW\*(C`(?\-1)\*(C'\fR refers to the most recently
declared group, and \f(CW\*(C`(?+1)\*(C'\fR indicates the next group to be declared.
Note that the counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed groups \fBare\fR
included.
.Sp
The following pattern matches a function \fIfoo()\fR which may contain
balanced parentheses as the argument.
.Sp
.Vb 10
\&  $re = qr{ (                   # paren group 1 (full function)
\&              foo
\&              (                 # paren group 2 (parens)
\&                \e(
\&                  (             # paren group 3 (contents of parens)
\&                  (?:
\&                   (?> [^()]+ ) # Non\-parens without backtracking
\&                  |
\&                   (?2)         # Recurse to start of paren group 2
\&                  )*
\&                  )
\&                \e)
\&              )
\&            )
\&          }x;
.Ve
.Sp
If the pattern was used as follows
.Sp
.Vb 4
\&    \*(Aqfoo(bar(baz)+baz(bop))\*(Aq=~/$re/
\&        and print "\e$1 = $1\en",
\&                  "\e$2 = $2\en",
\&                  "\e$3 = $3\en";
.Ve
.Sp
the output produced should be the following:
.Sp
.Vb 3
\&    $1 = foo(bar(baz)+baz(bop))
\&    $2 = (bar(baz)+baz(bop))
\&    $3 = bar(baz)+baz(bop)
.Ve
.Sp
If there is no corresponding capture group defined, then it is a
fatal error.  Recursing deeper than 50 times without consuming any input
string will also result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.
.Sp
The following shows how using negative indexing can make it
easier to embed recursive patterns inside of a \f(CW\*(C`qr//\*(C'\fR construct
for later use:
.Sp
.Vb 4
\&    my $parens = qr/(\e((?:[^()]++|(?\-1))*+\e))/;
\&    if (/foo $parens \es+ \e+ \es+ bar $parens/x) {
\&       # do something here...
\&    }
.Ve
.Sp
\&\fBNote\fR that this pattern does not behave the same way as the equivalent
\&\s-1PCRE\s0 or Python construct of the same form. In Perl you can backtrack into
a recursed group, in \s-1PCRE\s0 and Python the recursed into group is treated
as atomic. Also, modifiers are resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will
be processed.
.ie n .IP """(?&NAME)""" 4
.el .IP "\f(CW(?&NAME)\fR" 4
.IX Xref "(?&NAME)"
.IX Item "(?&NAME)"
Recurse to a named subpattern. Identical to \f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR except that the
parenthesis to recurse to is determined by name. If multiple parentheses have
the same name, then it recurses to the leftmost.
.Sp
It is an error to refer to a name that is not declared somewhere in the
pattern.
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines the pattern \f(CW\*(C`(?P>NAME)\*(C'\fR
may be used instead of \f(CW\*(C`(?&NAME)\*(C'\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Xref "(?()"
.IX Item "(?(condition)yes-pattern|no-pattern)"
.PD 0
.ie n .IP """(?(condition)yes\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern)"
.PD
Conditional expression. Matches \f(CW\*(C`yes\-pattern\*(C'\fR if \f(CW\*(C`condition\*(C'\fR yields
a true value, matches \f(CW\*(C`no\-pattern\*(C'\fR otherwise. A missing pattern always
matches.
.Sp
\&\f(CW\*(C`(condition)\*(C'\fR should be one of: 1) an integer in
parentheses (which is valid if the corresponding pair of parentheses
matched); 2) a look\-ahead/look\-behind/evaluate zero-width assertion; 3) a
name in angle brackets or single quotes (which is valid if a group
with the given name matched); or 4) the special symbol (R) (true when
evaluated inside of recursion or eval). Additionally the R may be
followed by a number, (which will be true when evaluated when recursing
inside of the appropriate group), or by \f(CW&NAME\fR, in which case it will
be true only when evaluated during recursion in the named group.
.Sp
Here's a summary of the possible predicates:
.RS 4
.IP "(1) (2) ..." 4
.IX Item "(1) (2) ..."
Checks if the numbered capturing group has matched something.
.IP "(<\s-1NAME\s0>) ('\s-1NAME\s0')" 4
.IX Item "(<NAME>) ('NAME')"
Checks if a group with the given name has matched something.
.IP "(?=...) (?!...) (?<=...) (?<!...)" 4
Checks whether the pattern matches (or does not match, for the '!'
variants).
.IP "(?{ \s-1CODE \s0})" 4
.IX Item "(?{ CODE })"
Treats the return value of the code block as the condition.
.IP "(R)" 4
.IX Item "(R)"
Checks if the expression has been evaluated inside of recursion.
.IP "(R1) (R2) ..." 4
.IX Item "(R1) (R2) ..."
Checks if the expression has been evaluated while executing directly
inside of the n\-th capture group. This check is the regex equivalent of
.Sp
.Vb 1
\&  if ((caller(0))[3] eq \*(Aqsubname\*(Aq) { ... }
.Ve
.Sp
In other words, it does not check the full recursion stack.
.IP "(R&NAME)" 4
.IX Item "(R&NAME)"
Similar to \f(CW\*(C`(R1)\*(C'\fR, this predicate checks to see if we're executing
directly inside of the leftmost group with a given name (this is the same
logic used by \f(CW\*(C`(?&NAME)\*(C'\fR to disambiguate). It does not check the full
stack, but only the name of the innermost active recursion.
.IP "(\s-1DEFINE\s0)" 4
.IX Item "(DEFINE)"
In this case, the yes-pattern is never directly executed, and no
no-pattern is allowed. Similar in spirit to \f(CW\*(C`(?{0})\*(C'\fR but more efficient.
See below for details.
.RE
.RS 4
.Sp
For example:
.Sp
.Vb 4
\&    m{ ( \e( )?
\&       [^()]+
\&       (?(1) \e) )
\&     }x
.Ve
.Sp
matches a chunk of non-parentheses, possibly included in parentheses
themselves.
.Sp
A special form is the \f(CW\*(C`(DEFINE)\*(C'\fR predicate, which never executes its
yes-pattern directly, and does not allow a no-pattern. This allows one to
define subpatterns which will be executed only by the recursion mechanism.
This way, you can define a set of regular expression rules that can be
bundled into any pattern you choose.
.Sp
It is recommended that for this usage you put the \s-1DEFINE\s0 block at the
end of the pattern, and that you name any subpatterns defined within it.
.Sp
Also, it's worth noting that patterns defined this way probably will
not be as efficient, as the optimiser is not very clever about
handling them.
.Sp
An example of how this might be used is as follows:
.Sp
.Vb 5
\&  /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
\&   (?(DEFINE)
\&     (?<NAME_PAT>....)
\&     (?<ADRESS_PAT>....)
\&   )/x
.Ve
.Sp
Note that capture groups matched inside of recursion are not accessible
after the recursion returns, so the extra layer of capturing groups is
necessary. Thus \f(CW$+{NAME_PAT}\fR would not be defined even though
\&\f(CW$+{NAME}\fR would be.
.Sp
Finally, keep in mind that subpatterns created inside a \s-1DEFINE\s0 block
count towards the absolute and relative number of captures, so this:
.Sp
.Vb 5
\&    my @captures = "a" =~ /(.)                  # First capture
\&                           (?(DEFINE)
\&                               (?<EXAMPLE> 1 )  # Second capture
\&                           )/x;
\&    say scalar @captures;
.Ve
.Sp
Will output 2, not 1. This is particularly important if you intend to
compile the definitions with the \f(CW\*(C`qr//\*(C'\fR operator, and later
interpolate them in another pattern.
.RE
.ie n .IP """(?>pattern)""" 4
.el .IP "\f(CW(?>pattern)\fR" 4
.IX Xref "backtrack backtracking atomic possessive"
.IX Item "(?>pattern)"
An \*(L"independent\*(R" subexpression, one which matches the substring
that a \fIstandalone\fR \f(CW\*(C`pattern\*(C'\fR would match if anchored at the given
position, and it matches \fInothing other than this substring\fR.  This
construct is useful for optimizations of what would otherwise be
\&\*(L"eternal\*(R" matches, because it will not backtrack (see \*(L"Backtracking\*(R").
It may also be useful in places where the \*(L"grab all you can, and do not
give anything back\*(R" semantic is desirable.
.Sp
For example: \f(CW\*(C`^(?>a*)ab\*(C'\fR will never match, since \f(CW\*(C`(?>a*)\*(C'\fR
(anchored at the beginning of string, as above) will match \fIall\fR
characters \f(CW\*(C`a\*(C'\fR at the beginning of string, leaving no \f(CW\*(C`a\*(C'\fR for
\&\f(CW\*(C`ab\*(C'\fR to match.  In contrast, \f(CW\*(C`a*ab\*(C'\fR will match the same as \f(CW\*(C`a+b\*(C'\fR,
since the match of the subgroup \f(CW\*(C`a*\*(C'\fR is influenced by the following
group \f(CW\*(C`ab\*(C'\fR (see \*(L"Backtracking\*(R").  In particular, \f(CW\*(C`a*\*(C'\fR inside
\&\f(CW\*(C`a*ab\*(C'\fR will match fewer characters than a standalone \f(CW\*(C`a*\*(C'\fR, since
this makes the tail match.
.Sp
\&\f(CW\*(C`(?>pattern)\*(C'\fR does not disable backtracking altogether once it has
matched. It is still possible to backtrack past the construct, but not
into it. So \f(CW\*(C`((?>a*)|(?>b*))ar\*(C'\fR will still match \*(L"bar\*(R".
.Sp
An effect similar to \f(CW\*(C`(?>pattern)\*(C'\fR may be achieved by writing
\&\f(CW\*(C`(?=(pattern))\eg{\-1}\*(C'\fR.  This matches the same substring as a standalone
\&\f(CW\*(C`a+\*(C'\fR, and the following \f(CW\*(C`\eg{\-1}\*(C'\fR eats the matched string; it therefore
makes a zero-length assertion into an analogue of \f(CW\*(C`(?>...)\*(C'\fR.
(The difference between these two constructs is that the second one
uses a capturing group, thus shifting ordinals of backreferences
in the rest of a regular expression.)
.Sp
Consider this pattern:
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            [^()]+           # x+
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
That will efficiently match a nonempty group with matching parentheses
two levels deep or less.  However, if there is no such group, it
will take virtually forever on a long string.  That's because there
are so many different ways to split a long string into several
substrings.  This is what \f(CW\*(C`(.+)+\*(C'\fR is doing, and \f(CW\*(C`(.+)+\*(C'\fR is similar
to a subpattern of the above pattern.  Consider how the pattern
above detects no-match on \f(CW\*(C`((()aaaaaaaaaaaaaaaaaa\*(C'\fR in several
seconds, but that each extra letter doubles this time.  This
exponential performance will make it appear that your program has
hung.  However, a tiny change to this pattern
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            (?> [^()]+ )        # change x+ above to (?> x+ )
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
which uses \f(CW\*(C`(?>...)\*(C'\fR matches exactly when the one above does (verifying
this yourself would be a productive exercise), but finishes in a fourth
the time when used on a similar string with 1000000 \f(CW\*(C`a\*(C'\fRs.  Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the \f(CW\*(C`use warnings\*(C'\fR pragma or \fB\-w\fR switch saying it
\&\f(CW"matches null string many times in regex"\fR.
.Sp
On simple groups, such as the pattern \f(CW\*(C`(?> [^()]+ )\*(C'\fR, a comparable
effect may be achieved by negative look-ahead, as in \f(CW\*(C`[^()]+ (?! [^()] )\*(C'\fR.
This was only 4 times slower on a string with 1000000 \f(CW\*(C`a\*(C'\fRs.
.Sp
The \*(L"grab all you can, and do not give anything back\*(R" semantic is desirable
in many situations where on the first sight a simple \f(CW\*(C`()*\*(C'\fR looks like
the correct solution.  Suppose we parse text with comments being delimited
by \f(CW\*(C`#\*(C'\fR followed by some optional (horizontal) whitespace.  Contrary to
its appearance, \f(CW\*(C`#[ \et]*\*(C'\fR \fIis not\fR the correct subexpression to match
the comment delimiter, because it may \*(L"give up\*(R" some whitespace if
the remainder of the pattern can be made to match that way.  The correct
answer is either one of these:
.Sp
.Vb 2
\&    (?>#[ \et]*)
\&    #[ \et]*(?![ \et])
.Ve
.Sp
For example, to grab non-empty comments into \f(CW$1\fR, one should use either
one of these:
.Sp
.Vb 2
\&    / (?> \e# [ \et]* ) (        .+ ) /x;
\&    /     \e# [ \et]*   ( [^ \et] .* ) /x;
.Ve
.Sp
Which one you pick depends on which of these expressions better reflects
the above specification of comments.
.Sp
In some literature this construct is called \*(L"atomic matching\*(R" or
\&\*(L"possessive matching\*(R".
.Sp
Possessive quantifiers are equivalent to putting the item they are applied
to inside of one of these constructs. The following equivalences apply:
.Sp
.Vb 6
\&    Quantifier Form     Bracketing Form
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PAT*+               (?>PAT*)
\&    PAT++               (?>PAT+)
\&    PAT?+               (?>PAT?)
\&    PAT{min,max}+       (?>PAT{min,max})
.Ve
.ie n .IP """(?[ ])""" 4
.el .IP "\f(CW(?[ ])\fR" 4
.IX Item "(?[ ])"
See \*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass.
.SS "Special Backtracking Control Verbs"
.IX Subsection "Special Backtracking Control Verbs"
\&\fB\s-1WARNING:\s0\fR These patterns are experimental and subject to change or
removal in a future version of Perl. Their usage in production code should
be noted to avoid problems during upgrades.
.PP
These special patterns are generally of the form \f(CW\*(C`(*VERB:ARG)\*(C'\fR. Unless
otherwise stated the \s-1ARG\s0 argument is optional; in some cases, it is
forbidden.
.PP
Any pattern containing a special backtracking verb that allows an argument
has the special behaviour that when executed it sets the current package's
\&\f(CW$REGERROR\fR and \f(CW$REGMARK\fR variables. When doing so the following
rules apply:
.PP
On failure, the \f(CW$REGERROR\fR variable will be set to the \s-1ARG\s0 value of the
verb pattern, if the verb was involved in the failure of the match. If the
\&\s-1ARG\s0 part of the pattern was omitted, then \f(CW$REGERROR\fR will be set to the
name of the last \f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed, or to \s-1TRUE\s0 if there was
none. Also, the \f(CW$REGMARK\fR variable will be set to \s-1FALSE.\s0
.PP
On a successful match, the \f(CW$REGERROR\fR variable will be set to \s-1FALSE,\s0 and
the \f(CW$REGMARK\fR variable will be set to the name of the last
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed.  See the explanation for the
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR verb below for more details.
.PP
\&\fB\s-1NOTE:\s0\fR \f(CW$REGERROR\fR and \f(CW$REGMARK\fR are not magic variables like \f(CW$1\fR
and most other regex-related variables. They are not local to a scope, nor
readonly, but instead are volatile package variables similar to \f(CW$AUTOLOAD\fR.
Use \f(CW\*(C`local\*(C'\fR to localize changes to them to a specific scope if necessary.
.PP
If a pattern does not contain a special backtracking verb that allows an
argument, then \f(CW$REGERROR\fR and \f(CW$REGMARK\fR are not touched at all.
.IP "Verbs that take an argument" 3
.IX Item "Verbs that take an argument"
.RS 3
.PD 0
.ie n .IP """(*PRUNE)"" ""(*PRUNE:NAME)""" 4
.el .IP "\f(CW(*PRUNE)\fR \f(CW(*PRUNE:NAME)\fR" 4
.IX Xref "(*PRUNE) (*PRUNE:NAME)"
.IX Item "(*PRUNE) (*PRUNE:NAME)"
.PD
This zero-width pattern prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern \f(CW\*(C`A (*PRUNE) B\*(C'\fR,
where A and B are complex patterns. Until the \f(CW\*(C`(*PRUNE)\*(C'\fR verb is reached,
A may backtrack as necessary to match. Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.
.Sp
The following example counts all the possible matching strings in a
pattern (without actually matching any of them).
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
which produces:
.Sp
.Vb 10
\&    aaab
\&    aaa
\&    aa
\&    a
\&    aab
\&    aa
\&    a
\&    ab
\&    a
\&    Count=9
.Ve
.Sp
If we add a \f(CW\*(C`(*PRUNE)\*(C'\fR before the count like the following
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(*PRUNE)(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
we prevent backtracking and find the count of the longest matching string
at each matching starting point like so:
.Sp
.Vb 4
\&    aaab
\&    aab
\&    ab
\&    Count=3
.Ve
.Sp
Any number of \f(CW\*(C`(*PRUNE)\*(C'\fR assertions may be used in a pattern.
.Sp
See also \f(CW\*(C`(?>pattern)\*(C'\fR and possessive quantifiers for other ways to
control backtracking. In some cases, the use of \f(CW\*(C`(*PRUNE)\*(C'\fR can be
replaced with a \f(CW\*(C`(?>pattern)\*(C'\fR with no functional difference; however,
\&\f(CW\*(C`(*PRUNE)\*(C'\fR can be used to handle cases that cannot be expressed using a
\&\f(CW\*(C`(?>pattern)\*(C'\fR alone.
.ie n .IP """(*SKIP)"" ""(*SKIP:NAME)""" 4
.el .IP "\f(CW(*SKIP)\fR \f(CW(*SKIP:NAME)\fR" 4
.IX Xref "(*SKIP)"
.IX Item "(*SKIP) (*SKIP:NAME)"
This zero-width pattern is similar to \f(CW\*(C`(*PRUNE)\*(C'\fR, except that on
failure it also signifies that whatever text that was matched leading up
to the \f(CW\*(C`(*SKIP)\*(C'\fR pattern being executed cannot be part of \fIany\fR match
of this pattern. This effectively means that the regex engine \*(L"skips\*(R" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).
.Sp
The name of the \f(CW\*(C`(*SKIP:NAME)\*(C'\fR pattern has special significance. If a
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR was encountered while matching, then it is that position
which is used as the \*(L"skip point\*(R". If no \f(CW\*(C`(*MARK)\*(C'\fR of that name was
encountered, then the \f(CW\*(C`(*SKIP)\*(C'\fR operator has no effect. When used
without a name the \*(L"skip point\*(R" is where the match point was when
executing the (*SKIP) pattern.
.Sp
Compare the following to the examples in \f(CW\*(C`(*PRUNE)\*(C'\fR; note the string
is twice as long:
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*SKIP)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 3
\&    aaab
\&    aaab
\&    Count=2
.Ve
.Sp
Once the 'aaab' at the start of the string has matched, and the \f(CW\*(C`(*SKIP)\*(C'\fR
executed, the next starting point will be where the cursor was when the
\&\f(CW\*(C`(*SKIP)\*(C'\fR was executed.
.ie n .IP """(*MARK:NAME)"" ""(*:NAME)""" 4
.el .IP "\f(CW(*MARK:NAME)\fR \f(CW(*:NAME)\fR" 4
.IX Xref "(*MARK) (*MARK:NAME) (*:NAME)"
.IX Item "(*MARK:NAME) (*:NAME)"
This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later \f(CW\*(C`(*SKIP)\*(C'\fR pattern will then skip
forward to that point if backtracked into on failure. Any number of
\&\f(CW\*(C`(*MARK)\*(C'\fR patterns are allowed, and the \s-1NAME\s0 portion may be duplicated.
.Sp
In addition to interacting with the \f(CW\*(C`(*SKIP)\*(C'\fR pattern, \f(CW\*(C`(*MARK:NAME)\*(C'\fR
can be used to \*(L"label\*(R" a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.
.Sp
When a match is successful, the \f(CW$REGMARK\fR variable will be set to the
name of the most recently executed \f(CW\*(C`(*MARK:NAME)\*(C'\fR that was involved
in the match.
.Sp
This can be used to determine which branch of a pattern was matched
without using a separate capture group for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
\&\f(CW\*(C`/(?:(x)|(y)|(z))/\*(C'\fR as efficiently as something like
\&\f(CW\*(C`/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/\*(C'\fR.
.Sp
When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the \f(CW$REGERROR\fR
variable will be set to the name of the most recently executed
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR.
.Sp
See \*(L"(*SKIP)\*(R" for more details.
.Sp
As a shortcut \f(CW\*(C`(*MARK:NAME)\*(C'\fR can be written \f(CW\*(C`(*:NAME)\*(C'\fR.
.ie n .IP """(*THEN)"" ""(*THEN:NAME)""" 4
.el .IP "\f(CW(*THEN)\fR \f(CW(*THEN:NAME)\fR" 4
.IX Item "(*THEN) (*THEN:NAME)"
This is similar to the \*(L"cut group\*(R" operator \f(CW\*(C`::\*(C'\fR from Perl 6.  Like
\&\f(CW\*(C`(*PRUNE)\*(C'\fR, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise) that has alternations.
The two branches of a \f(CW\*(C`(?(condition)yes\-pattern|no\-pattern)\*(C'\fR do not
count as an alternation, as far as \f(CW\*(C`(*THEN)\*(C'\fR is concerned.
.Sp
Its name comes from the observation that this operation combined with the
alternation operator (\f(CW\*(C`|\*(C'\fR) can be used to create what is essentially a
pattern-based if/then/else block:
.Sp
.Vb 1
\&  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )
.Ve
.Sp
Note that if this operator is used and \s-1NOT\s0 inside of an alternation then
it acts exactly like the \f(CW\*(C`(*PRUNE)\*(C'\fR operator.
.Sp
.Vb 1
\&  / A (*PRUNE) B /
.Ve
.Sp
is the same as
.Sp
.Vb 1
\&  / A (*THEN) B /
.Ve
.Sp
but
.Sp
.Vb 1
\&  / ( A (*THEN) B | C ) /
.Ve
.Sp
is not the same as
.Sp
.Vb 1
\&  / ( A (*PRUNE) B | C ) /
.Ve
.Sp
as after matching the A but failing on the B the \f(CW\*(C`(*THEN)\*(C'\fR verb will
backtrack and try C; but the \f(CW\*(C`(*PRUNE)\*(C'\fR verb will simply fail.
.RE
.RS 3
.RE
.IP "Verbs without an argument" 3
.IX Item "Verbs without an argument"
.RS 3
.PD 0
.ie n .IP """(*COMMIT)""" 4
.el .IP "\f(CW(*COMMIT)\fR" 4
.IX Xref "(*COMMIT)"
.IX Item "(*COMMIT)"
.PD
This is the Perl 6 \*(L"commit pattern\*(R" \f(CW\*(C`<commit>\*(C'\fR or \f(CW\*(C`:::\*(C'\fR. It's a
zero-width pattern similar to \f(CW\*(C`(*SKIP)\*(C'\fR, except that when backtracked
into on failure it causes the match to fail outright. No further attempts
to find a valid match by advancing the start pointer will occur again.
For example,
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*COMMIT)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 2
\&    aaab
\&    Count=1
.Ve
.Sp
In other words, once the \f(CW\*(C`(*COMMIT)\*(C'\fR has been entered, and if the pattern
does not match, the regex engine will not try any further matching on the
rest of the string.
.ie n .IP """(*FAIL)"" ""(*F)""" 4
.el .IP "\f(CW(*FAIL)\fR \f(CW(*F)\fR" 4
.IX Xref "(*FAIL) (*F)"
.IX Item "(*FAIL) (*F)"
This pattern matches nothing and always fails. It can be used to force the
engine to backtrack. It is equivalent to \f(CW\*(C`(?!)\*(C'\fR, but easier to read. In
fact, \f(CW\*(C`(?!)\*(C'\fR gets optimised into \f(CW\*(C`(*FAIL)\*(C'\fR internally.
.Sp
It is probably useful only when combined with \f(CW\*(C`(?{})\*(C'\fR or \f(CW\*(C`(??{})\*(C'\fR.
.ie n .IP """(*ACCEPT)""" 4
.el .IP "\f(CW(*ACCEPT)\fR" 4
.IX Xref "(*ACCEPT)"
.IX Item "(*ACCEPT)"
\&\fB\s-1WARNING:\s0\fR This feature is highly experimental. It is not recommended
for production code.
.Sp
This pattern matches nothing and causes the end of successful matching at
the point at which the \f(CW\*(C`(*ACCEPT)\*(C'\fR pattern was encountered, regardless of
whether there is actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via \f(CW\*(C`(??{})\*(C'\fR, only the innermost pattern is ended immediately.
.Sp
If the \f(CW\*(C`(*ACCEPT)\*(C'\fR is inside of capturing groups then the groups are
marked as ended at the point at which the \f(CW\*(C`(*ACCEPT)\*(C'\fR was encountered.
For instance:
.Sp
.Vb 1
\&  \*(AqAB\*(Aq =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;
.Ve
.Sp
will match, and \f(CW$1\fR will be \f(CW\*(C`AB\*(C'\fR and \f(CW$2\fR will be \f(CW\*(C`B\*(C'\fR, \f(CW$3\fR will not
be set. If another branch in the inner parentheses was matched, such as in the
string '\s-1ACDE\s0', then the \f(CW\*(C`D\*(C'\fR and \f(CW\*(C`E\*(C'\fR would have to be matched as well.
.RE
.RS 3
.RE
.SS "Backtracking"
.IX Xref "backtrack backtracking"
.IX Subsection "Backtracking"
\&\s-1NOTE:\s0 This section presents an abstract approximation of regular
expression behavior.  For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see \*(L"Combining \s-1RE\s0 Pieces\*(R".
.PP
A fundamental feature of regular expression matching involves the
notion called \fIbacktracking\fR, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}\*(C'\fR, and \f(CW\*(C`{n,m}?\*(C'\fR.  Backtracking is often optimized
internally, but the general principle outlined here is valid.
.PP
For a regular expression to match, the \fIentire\fR regular expression must
match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part\*(--that's why it's called backtracking.
.PP
Here is an example of backtracking:  Let's say you want to find the
word following \*(L"foo\*(R" in the string \*(L"Food is on the foo table.\*(R":
.PP
.Vb 4
\&    $_ = "Food is on the foo table.";
\&    if ( /\eb(foo)\es+(\ew+)/i ) {
\&        print "$2 follows $1.\en";
\&    }
.Ve
.PP
When the match runs, the first part of the regular expression (\f(CW\*(C`\eb(foo)\*(C'\fR)
finds a possible match right at the beginning of the string, and loads up
\&\f(CW$1\fR with \*(L"Foo\*(R".  However, as soon as the matching engine sees that there's
no whitespace following the \*(L"Foo\*(R" that it had saved in \f(CW$1\fR, it realizes its
mistake and starts over again one character after where it had the
tentative match.  This time it goes all the way until the next occurrence
of \*(L"foo\*(R". The complete regular expression matches this time, and you get
the expected output of \*(L"table follows foo.\*(R"
.PP
Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between \*(L"foo\*(R" and \*(L"bar\*(R".  Initially, you write something
like this:
.PP
.Vb 4
\&    $_ =  "The food is under the bar in the barn.";
\&    if ( /foo(.*)bar/ ) {
\&        print "got <$1>\en";
\&    }
.Ve
.PP
Which perhaps unexpectedly yields:
.PP
.Vb 1
\&  got <d is under the bar in the >
.Ve
.PP
That's because \f(CW\*(C`.*\*(C'\fR was greedy, so you get everything between the
\&\fIfirst\fR \*(L"foo\*(R" and the \fIlast\fR \*(L"bar\*(R".  Here it's more effective
to use minimal matching to make sure you get the text between a \*(L"foo\*(R"
and the first \*(L"bar\*(R" thereafter.
.PP
.Vb 2
\&    if ( /foo(.*?)bar/ ) { print "got <$1>\en" }
\&  got <d is under the >
.Ve
.PP
Here's another example. Let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part of the match.
So you write this:
.PP
.Vb 4
\&    $_ = "I have 2 numbers: 53147";
\&    if ( /(.*)(\ed*)/ ) {                                # Wrong!
\&        print "Beginning is <$1>, number is <$2>.\en";
\&    }
.Ve
.PP
That won't work at all, because \f(CW\*(C`.*\*(C'\fR was greedy and gobbled up the
whole string. As \f(CW\*(C`\ed*\*(C'\fR can match on an empty string the complete
regular expression matched successfully.
.PP
.Vb 1
\&    Beginning is <I have 2 numbers: 53147>, number is <>.
.Ve
.PP
Here are some variants, most of which don't work:
.PP
.Vb 11
\&    $_ = "I have 2 numbers: 53147";
\&    @pats = qw{
\&        (.*)(\ed*)
\&        (.*)(\ed+)
\&        (.*?)(\ed*)
\&        (.*?)(\ed+)
\&        (.*)(\ed+)$
\&        (.*?)(\ed+)$
\&        (.*)\eb(\ed+)$
\&        (.*\eD)(\ed+)$
\&    };
\&
\&    for $pat (@pats) {
\&        printf "%\-12s ", $pat;
\&        if ( /$pat/ ) {
\&            print "<$1> <$2>\en";
\&        } else {
\&            print "FAIL\en";
\&        }
\&    }
.Ve
.PP
That will print out:
.PP
.Vb 8
\&    (.*)(\ed*)    <I have 2 numbers: 53147> <>
\&    (.*)(\ed+)    <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed*)   <> <>
\&    (.*?)(\ed+)   <I have > <2>
\&    (.*)(\ed+)$   <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed+)$  <I have 2 numbers: > <53147>
\&    (.*)\eb(\ed+)$ <I have 2 numbers: > <53147>
\&    (.*\eD)(\ed+)$ <I have 2 numbers: > <53147>
.Ve
.PP
As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.
.PP
When using look-ahead assertions and negations, this can all get even
trickier.  Imagine you'd like to find a sequence of non-digits not
followed by \*(L"123\*(R".  You might try to write that as
.PP
.Vb 4
\&    $_ = "ABC123";
\&    if ( /^\eD*(?!123)/ ) {                # Wrong!
\&        print "Yup, no 123 in $_\en";
\&    }
.Ve
.PP
But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why that pattern matches, contrary to popular expectations:
.PP
.Vb 2
\&    $x = \*(AqABC123\*(Aq;
\&    $y = \*(AqABC445\*(Aq;
\&
\&    print "1: got $1\en" if $x =~ /^(ABC)(?!123)/;
\&    print "2: got $1\en" if $y =~ /^(ABC)(?!123)/;
\&
\&    print "3: got $1\en" if $x =~ /^(\eD*)(?!123)/;
\&    print "4: got $1\en" if $y =~ /^(\eD*)(?!123)/;
.Ve
.PP
This prints
.PP
.Vb 3
\&    2: got ABC
\&    3: got AB
\&    4: got ABC
.Ve
.PP
You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (\f(CW\*(C`\eD*\*(C'\fR) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked \*(L"Is it true that at the start of \f(CW$x\fR, following 0 or more
non-digits, you have something that's not 123?\*(R"  If the pattern matcher had
let \f(CW\*(C`\eD*\*(C'\fR expand to \*(L"\s-1ABC\*(R",\s0 this would have caused the whole pattern to
fail.
.PP
The search engine will initially match \f(CW\*(C`\eD*\*(C'\fR with \*(L"\s-1ABC\*(R". \s0 Then it will
try to match \f(CW\*(C`(?!123)\*(C'\fR with \*(L"123\*(R", which fails.  But because
a quantifier (\f(CW\*(C`\eD*\*(C'\fR) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.
.PP
The pattern really, \fIreally\fR wants to succeed, so it uses the
standard pattern back-off-and-retry and lets \f(CW\*(C`\eD*\*(C'\fR expand to just \*(L"\s-1AB\*(R"\s0 this
time.  Now there's indeed something following \*(L"\s-1AB\*(R"\s0 that is not
\&\*(L"123\*(R".  It's \*(L"C123\*(R", which suffices.
.PP
We can deal with this by using both an assertion and a negation.
We'll say that the first part in \f(CW$1\fR must be followed both by a digit
and by something that's not \*(L"123\*(R".  Remember that the look-aheads
are zero-width expressions\*(--they only look, but don't consume any
of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:
.PP
.Vb 2
\&    print "5: got $1\en" if $x =~ /^(\eD*)(?=\ed)(?!123)/;
\&    print "6: got $1\en" if $y =~ /^(\eD*)(?=\ed)(?!123)/;
\&
\&    6: got ABC
.Ve
.PP
In other words, the two zero-width assertions next to each other work as though
they're ANDed together, just as you'd use any built-in assertions:  \f(CW\*(C`/^$/\*(C'\fR
matches only if you're at the beginning of the line \s-1AND\s0 the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means \s-1AND,\s0 except when you write an explicit \s-1OR\s0
using the vertical bar.  \f(CW\*(C`/ab/\*(C'\fR means match \*(L"a\*(R" \s-1AND \s0(then) match \*(L"b\*(R",
although the attempted matches are made at different positions because \*(L"a\*(R"
is not a zero-width assertion, but a one-width assertion.
.PP
\&\fB\s-1WARNING\s0\fR: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.  For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:
.PP
.Vb 1
\&    \*(Aqaaaaaaaaaaaa\*(Aq =~ /((a{0,5}){0,5})*[c]/
.Ve
.PP
And if you used \f(CW\*(C`*\*(C'\fR's in the internal groups instead of limiting them
to 0 through 5 matches, then it would take forever\*(--or until you ran
out of stack space.  Moreover, these internal optimizations are not
always applicable.  For example, if you put \f(CW\*(C`{0,5}\*(C'\fR instead of \f(CW\*(C`*\*(C'\fR
on the external group, no current optimization is applicable, and the
match takes a long time to finish.
.PP
A powerful tool for optimizing such beasts is what is known as an
\&\*(L"independent group\*(R",
which does not backtrack (see "\f(CW\*(C`(?>pattern)\*(C'\fR").  Note also that
zero-length look\-ahead/look\-behind assertions will not backtrack to make
the tail match, since they are in \*(L"logical\*(R" context: only
whether they match is considered relevant.  For an example
where side-effects of look-ahead \fImight\fR have influenced the
following match, see "\f(CW\*(C`(?>pattern)\*(C'\fR".
.SS "Version 8 Regular Expressions"
.IX Xref "regular expression, version 8 regex, version 8 regexp, version 8"
.IX Subsection "Version 8 Regular Expressions"
In case you're not familiar with the \*(L"regular\*(R" Version 8 regex
routines, here are the pattern-matching rules not described above.
.PP
Any single character matches itself, unless it is a \fImetacharacter\fR
with a special meaning described here or above.  You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a \*(L"\e\*(R" (e.g., \*(L"\e.\*(R" matches a \*(L".\*(R", not any
character; \*(L"\e\e\*(R" matches a \*(L"\e\*(R"). This escape mechanism is also required
for the character used as the pattern delimiter.
.PP
A series of characters matches that series of characters in the target
string, so the pattern \f(CW\*(C`blurfl\*(C'\fR would match \*(L"blurfl\*(R" in the target
string.
.PP
You can specify a character class, by enclosing a list of characters
in \f(CW\*(C`[]\*(C'\fR, which will match any character from the list.  If the
first character after the \*(L"[\*(R" is \*(L"^\*(R", the class matches any character not
in the list.  Within a list, the \*(L"\-\*(R" character specifies a
range, so that \f(CW\*(C`a\-z\*(C'\fR represents all characters between \*(L"a\*(R" and \*(L"z\*(R",
inclusive.  If you want either \*(L"\-\*(R" or \*(L"]\*(R" itself to be a member of a
class, put it at the start of the list (possibly after a \*(L"^\*(R"), or
escape it with a backslash.  \*(L"\-\*(R" is also taken literally when it is
at the end of the list, just before the closing \*(L"]\*(R".  (The
following all specify the same class of three characters: \f(CW\*(C`[\-az]\*(C'\fR,
\&\f(CW\*(C`[az\-]\*(C'\fR, and \f(CW\*(C`[a\e\-z]\*(C'\fR.  All are different from \f(CW\*(C`[a\-z]\*(C'\fR, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, or \f(CW\*(C`\eD\*(C'\fR as endpoints of
a range, the \*(L"\-\*(R" is understood literally.
.PP
Note also that the whole range idea is rather unportable between
character sets\*(--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a\-e],
[A\-E]), or digits ([0\-9]).  Anything else is unsafe.  If in doubt,
spell out the character sets in full.
.PP
Characters may be specified using a metacharacter syntax much like that
used in C: \*(L"\en\*(R" matches a newline, \*(L"\et\*(R" a tab, \*(L"\er\*(R" a carriage return,
\&\*(L"\ef\*(R" a form feed, etc.  More generally, \e\fInnn\fR, where \fInnn\fR is a string
of three octal digits, matches the character whose coded character set value
is \fInnn\fR.  Similarly, \ex\fInn\fR, where \fInn\fR are hexadecimal digits,
matches the character whose ordinal is \fInn\fR. The expression \ec\fIx\fR
matches the character control\-\fIx\fR.  Finally, the \*(L".\*(R" metacharacter
matches any character except \*(L"\en\*(R" (unless you use \f(CW\*(C`/s\*(C'\fR).
.PP
You can specify a series of alternatives for a pattern using \*(L"|\*(R" to
separate them, so that \f(CW\*(C`fee|fie|foe\*(C'\fR will match any of \*(L"fee\*(R", \*(L"fie\*(R",
or \*(L"foe\*(R" in the target string (as would \f(CW\*(C`f(e|i|o)e\*(C'\fR).  The
first alternative includes everything from the last pattern delimiter
(\*(L"(\*(R", \*(L"(?:\*(R", etc. or the beginning of the pattern) up to the first \*(L"|\*(R", and
the last alternative contains everything from the last \*(L"|\*(R" to the next
closing pattern delimiter.  That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.
.PP
Alternatives are tried from left to right, so the first
alternative found for which the entire expression matches, is the one that
is chosen. This means that alternatives are not necessarily greedy. For
example: when matching \f(CW\*(C`foo|foot\*(C'\fR against \*(L"barefoot\*(R", only the \*(L"foo\*(R"
part will match, as that is the first alternative tried, and it successfully
matches the target string. (This might not seem important, but it is
important when you are capturing matched text using parentheses.)
.PP
Also remember that \*(L"|\*(R" is interpreted as a literal within square brackets,
so if you write \f(CW\*(C`[fee|fie|foe]\*(C'\fR you're really only matching \f(CW\*(C`[feio|]\*(C'\fR.
.PP
Within a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to the
\&\fIn\fRth subpattern later in the pattern using the metacharacter
\&\e\fIn\fR or \eg\fIn\fR.  Subpatterns are numbered based on the left to right order
of their opening parenthesis.  A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.  Therefore, \f(CW\*(C`(0|0x)\ed*\es\eg1\ed*\*(C'\fR will
match \*(L"0x1234 0x4321\*(R", but not \*(L"0x1234 01234\*(R", because subpattern
1 matched \*(L"0x\*(R", even though the rule \f(CW\*(C`0|0x\*(C'\fR could potentially match
the leading 0 in the second number.
.ie n .SS "Warning on \e1 Instead of $1"
.el .SS "Warning on \e1 Instead of \f(CW$1\fP"
.IX Subsection "Warning on 1 Instead of $1"
Some people get too used to writing things like:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e\e1/g;
.Ve
.PP
This is grandfathered (for \e1 to \e9) for the \s-1RHS\s0 of a substitute to avoid
shocking the
\&\fBsed\fR addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of an \f(CW\*(C`s///\*(C'\fR is a double-quoted string.  \f(CW\*(C`\e1\*(C'\fR in
the usual double-quoted string means a control-A.  The customary Unix
meaning of \f(CW\*(C`\e1\*(C'\fR is kludged in for \f(CW\*(C`s///\*(C'\fR.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an \f(CW\*(C`/e\*(C'\fR
modifier.
.PP
.Vb 1
\&    s/(\ed+)/ \e1 + 1 /eg;            # causes warning under \-w
.Ve
.PP
Or if you try to do
.PP
.Vb 1
\&    s/(\ed+)/\e1000/;
.Ve
.PP
You can't disambiguate that by saying \f(CW\*(C`\e{1}000\*(C'\fR, whereas you can fix it with
\&\f(CW\*(C`${1}000\*(C'\fR.  The operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the \fIleft\fR side of the \f(CW\*(C`s///\*(C'\fR.
.SS "Repeated Patterns Matching a Zero-length Substring"
.IX Subsection "Repeated Patterns Matching a Zero-length Substring"
\&\fB\s-1WARNING\s0\fR: Difficult material (and prose) ahead.  This section needs a rewrite.
.PP
Regular expressions provide a terse and powerful programming language.  As
with most other power tools, power comes together with the ability
to wreak havoc.
.PP
A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:
.PP
.Vb 1
\&    \*(Aqfoo\*(Aq =~ m{ ( o? )* }x;
.Ve
.PP
The \f(CW\*(C`o?\*(C'\fR matches at the beginning of \f(CW\*(Aqfoo\*(Aq\fR, and since the position
in the string is not moved by the match, \f(CW\*(C`o?\*(C'\fR would match again and again
because of the \f(CW\*(C`*\*(C'\fR quantifier.  Another common way to create a similar cycle
is with the looping modifier \f(CW\*(C`//g\*(C'\fR:
.PP
.Vb 1
\&    @matches = ( \*(Aqfoo\*(Aq =~ m{ o? }xg );
.Ve
.PP
or
.PP
.Vb 1
\&    print "match: <$&>\en" while \*(Aqfoo\*(Aq =~ m{ o? }xg;
.Ve
.PP
or the loop implied by \fIsplit()\fR.
.PP
However, long experience has shown that many programming tasks may
be significantly simplified by using repeated subexpressions that
may match zero-length substrings.  Here's a simple example being:
.PP
.Vb 2
\&    @chars = split //, $string;           # // is not magic in split
\&    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /
.Ve
.PP
Thus Perl allows such constructs, by \fIforcefully breaking
the infinite loop\fR.  The rules for this are different for lower-level
loops given by the greedy quantifiers \f(CW\*(C`*+{}\*(C'\fR, and for higher-level
ones like the \f(CW\*(C`/g\*(C'\fR modifier or \fIsplit()\fR operator.
.PP
The lower-level loops are \fIinterrupted\fR (that is, the loop is
broken) when Perl detects that a repeated expression matched a
zero-length substring.   Thus
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
.Ve
.PP
is made equivalent to
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;
.Ve
.PP
For example, this program
.PP
.Vb 12
\&   #!perl \-l
\&   "aaaaab" =~ /
\&     (?:
\&        a                 # non\-zero
\&        |                 # or
\&       (?{print "hello"}) # print hello whenever this
\&                          #    branch is tried
\&       (?=(b))            # zero\-width assertion
\&     )*  # any number of times
\&    /x;
\&   print $&;
\&   print $1;
.Ve
.PP
prints
.PP
.Vb 3
\&   hello
\&   aaaaa
\&   b
.Ve
.PP
Notice that \*(L"hello\*(R" is only printed once, as when Perl sees that the sixth
iteration of the outermost \f(CW\*(C`(?:)*\*(C'\fR matches a zero-length string, it stops
the \f(CW\*(C`*\*(C'\fR.
.PP
The higher-level loops preserve an additional state between iterations:
whether the last match was zero-length.  To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.
This prohibition interacts with backtracking (see \*(L"Backtracking\*(R"),
and so the \fIsecond best\fR match is chosen if the \fIbest\fR match is of
zero length.
.PP
For example:
.PP
.Vb 2
\&    $_ = \*(Aqbar\*(Aq;
\&    s/\ew??/<$&>/g;
.Ve
.PP
results in \f(CW\*(C`<><b><><a><><r><>\*(C'\fR.  At each position of the string the best
match given by non-greedy \f(CW\*(C`??\*(C'\fR is the zero-length match, and the \fIsecond
best\fR match is what is matched by \f(CW\*(C`\ew\*(C'\fR.  Thus zero-length matches
alternate with one-character-long matches.
.PP
Similarly, for repeated \f(CW\*(C`m/()/g\*(C'\fR the second-best match is the match at the
position one notch further in the string.
.PP
The additional state of being \fImatched with zero-length\fR is associated with
the matched string, and is reset by each assignment to \fIpos()\fR.
Zero-length matches at the end of the previous match are ignored
during \f(CW\*(C`split\*(C'\fR.
.SS "Combining \s-1RE\s0 Pieces"
.IX Subsection "Combining RE Pieces"
Each of the elementary pieces of regular expressions which were described
before (such as \f(CW\*(C`ab\*(C'\fR or \f(CW\*(C`\eZ\*(C'\fR) could match at most one substring
at the given position of the input string.  However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators \f(CW\*(C`ST\*(C'\fR, \f(CW\*(C`S|T\*(C'\fR, \f(CW\*(C`S*\*(C'\fR etc.
(in these examples \f(CW\*(C`S\*(C'\fR and \f(CW\*(C`T\*(C'\fR are regular subexpressions).
.PP
Such combinations can include alternatives, leading to a problem of choice:
if we match a regular expression \f(CW\*(C`a|ab\*(C'\fR against \f(CW"abc"\fR, will it match
substring \f(CW"a"\fR or \f(CW"ab"\fR?  One way to describe which substring is
actually matched is the concept of backtracking (see \*(L"Backtracking\*(R").
However, this description is too low-level and makes you think
in terms of a particular implementation.
.PP
Another description starts with notions of \*(L"better\*(R"/\*(L"worse\*(R".  All the
substrings which may be matched by the given regular expression can be
sorted from the \*(L"best\*(R" match to the \*(L"worst\*(R" match, and it is the \*(L"best\*(R"
match which is chosen.  This substitutes the question of \*(L"what is chosen?\*(R"
by the question of \*(L"which matches are better, and which are worse?\*(R".
.PP
Again, for elementary pieces there is no such question, since at most
one match at a given position is possible.  This section describes the
notion of better/worse for combining operators.  In the description
below \f(CW\*(C`S\*(C'\fR and \f(CW\*(C`T\*(C'\fR are regular subexpressions.
.ie n .IP """ST""" 4
.el .IP "\f(CWST\fR" 4
.IX Item "ST"
Consider two possible matches, \f(CW\*(C`AB\*(C'\fR and \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR, \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`A\*(Aq\*(C'\fR are
substrings which can be matched by \f(CW\*(C`S\*(C'\fR, \f(CW\*(C`B\*(C'\fR and \f(CW\*(C`B\*(Aq\*(C'\fR are substrings
which can be matched by \f(CW\*(C`T\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR is a better match for \f(CW\*(C`S\*(C'\fR than \f(CW\*(C`A\*(Aq\*(C'\fR, \f(CW\*(C`AB\*(C'\fR is a better
match than \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`A\*(Aq\*(C'\fR coincide: \f(CW\*(C`AB\*(C'\fR is a better match than \f(CW\*(C`AB\*(Aq\*(C'\fR if
\&\f(CW\*(C`B\*(C'\fR is a better match for \f(CW\*(C`T\*(C'\fR than \f(CW\*(C`B\*(Aq\*(C'\fR.
.ie n .IP """S|T""" 4
.el .IP "\f(CWS|T\fR" 4
.IX Item "S|T"
When \f(CW\*(C`S\*(C'\fR can match, it is a better match than when only \f(CW\*(C`T\*(C'\fR can match.
.Sp
Ordering of two matches for \f(CW\*(C`S\*(C'\fR is the same as for \f(CW\*(C`S\*(C'\fR.  Similar for
two matches for \f(CW\*(C`T\*(C'\fR.
.ie n .IP """S{REPEAT_COUNT}""" 4
.el .IP "\f(CWS{REPEAT_COUNT}\fR" 4
.IX Item "S{REPEAT_COUNT}"
Matches as \f(CW\*(C`SSS...S\*(C'\fR (repeated as many times as necessary).
.ie n .IP """S{min,max}""" 4
.el .IP "\f(CWS{min,max}\fR" 4
.IX Item "S{min,max}"
Matches as \f(CW\*(C`S{max}|S{max\-1}|...|S{min+1}|S{min}\*(C'\fR.
.ie n .IP """S{min,max}?""" 4
.el .IP "\f(CWS{min,max}?\fR" 4
.IX Item "S{min,max}?"
Matches as \f(CW\*(C`S{min}|S{min+1}|...|S{max\-1}|S{max}\*(C'\fR.
.ie n .IP """S?"", ""S*"", ""S+""" 4
.el .IP "\f(CWS?\fR, \f(CWS*\fR, \f(CWS+\fR" 4
.IX Item "S?, S*, S+"
Same as \f(CW\*(C`S{0,1}\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}\*(C'\fR respectively.
.ie n .IP """S??"", ""S*?"", ""S+?""" 4
.el .IP "\f(CWS??\fR, \f(CWS*?\fR, \f(CWS+?\fR" 4
.IX Item "S??, S*?, S+?"
Same as \f(CW\*(C`S{0,1}?\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}?\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}?\*(C'\fR respectively.
.ie n .IP """(?>S)""" 4
.el .IP "\f(CW(?>S)\fR" 4
.IX Item "(?>S)"
Matches the best match for \f(CW\*(C`S\*(C'\fR and only that.
.ie n .IP """(?=S)"", ""(?<=S)""" 4
.el .IP "\f(CW(?=S)\fR, \f(CW(?<=S)\fR" 4
.IX Item "(?=S), (?<=S)"
Only the best match for \f(CW\*(C`S\*(C'\fR is considered.  (This is important only if
\&\f(CW\*(C`S\*(C'\fR has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)
.ie n .IP """(?!S)"", ""(?<!S)""" 4
.el .IP "\f(CW(?!S)\fR, \f(CW(?<!S)\fR" 4
.IX Item "(?!S), (?<!S)"
For this grouping operator there is no need to describe the ordering, since
only whether or not \f(CW\*(C`S\*(C'\fR can match is important.
.ie n .IP """(??{ EXPR })"", ""(?\f(CIPARNO\f(CW)""" 4
.el .IP "\f(CW(??{ EXPR })\fR, \f(CW(?\f(CIPARNO\f(CW)\fR" 4
.IX Item "(??{ EXPR }), (?PARNO)"
The ordering is the same as for the regular expression which is
the result of \s-1EXPR,\s0 or the pattern contained by capture group \fI\s-1PARNO\s0\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern|no-pattern)"
Recall that which of \f(CW\*(C`yes\-pattern\*(C'\fR or \f(CW\*(C`no\-pattern\*(C'\fR actually matches is
already determined.  The ordering of the matches is the same as for the
chosen subexpression.
.PP
The above recipes describe the ordering of matches \fIat a given position\fR.
One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.
.SS "Creating Custom \s-1RE\s0 Engines"
.IX Subsection "Creating Custom RE Engines"
As of Perl 5.10.0, one can create custom regular expression engines.  This
is not for the faint of heart, as they have to plug in at the C level.  See
perlreapi for more details.
.PP
As an alternative, overloaded constants (see overload) provide a simple
way to extend the functionality of the \s-1RE\s0 engine, by substituting one
pattern for another.
.PP
Suppose that we want to enable a new \s-1RE\s0 escape-sequence \f(CW\*(C`\eY|\*(C'\fR which
matches at a boundary between whitespace characters and non-whitespace
characters.  Note that \f(CW\*(C`(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)\*(C'\fR matches exactly
at these positions, so we want to have each \f(CW\*(C`\eY|\*(C'\fR in the place of the
more complicated version.  We can create a module \f(CW\*(C`customre\*(C'\fR to do
this:
.PP
.Vb 2
\&    package customre;
\&    use overload;
\&
\&    sub import {
\&      shift;
\&      die "No argument to customre::import allowed" if @_;
\&      overload::constant \*(Aqqr\*(Aq => \e&convert;
\&    }
\&
\&    sub invalid { die "/$_[0]/: invalid escape \*(Aq\e\e$_[1]\*(Aq"}
\&
\&    # We must also take care of not escaping the legitimate \e\eY|
\&    # sequence, hence the presence of \*(Aq\e\e\*(Aq in the conversion rules.
\&    my %rules = ( \*(Aq\e\e\*(Aq => \*(Aq\e\e\e\e\*(Aq,
\&                  \*(AqY|\*(Aq => qr/(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)/ );
\&    sub convert {
\&      my $re = shift;
\&      $re =~ s{
\&                \e\e ( \e\e | Y . )
\&              }
\&              { $rules{$1} or invalid($re,$1) }sgex;
\&      return $re;
\&    }
.Ve
.PP
Now \f(CW\*(C`use customre\*(C'\fR enables the new escape in constant regular
expressions, i.e., those without any runtime variable interpolations.
As documented in overload, this conversion will work only over
literal parts of regular expressions.  For \f(CW\*(C`\eY|$re\eY|\*(C'\fR the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of \f(CW\*(C`\eY|\*(C'\fR should be enabled inside \f(CW$re\fR):
.PP
.Vb 5
\&    use customre;
\&    $re = <>;
\&    chomp $re;
\&    $re = customre::convert $re;
\&    /\eY|$re\eY|/;
.Ve
.SS "PCRE/Python Support"
.IX Subsection "PCRE/Python Support"
As of Perl 5.10.0, Perl supports several Python/PCRE\-specific extensions
to the regex syntax. While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted:
.ie n .IP """(?P<NAME>pattern)""" 4
.el .IP "\f(CW(?P<NAME>pattern)\fR" 4
.IX Item "(?P<NAME>pattern)"
Define a named capture group. Equivalent to \f(CW\*(C`(?<NAME>pattern)\*(C'\fR.
.ie n .IP """(?P=NAME)""" 4
.el .IP "\f(CW(?P=NAME)\fR" 4
.IX Item "(?P=NAME)"
Backreference to a named capture group. Equivalent to \f(CW\*(C`\eg{NAME}\*(C'\fR.
.ie n .IP """(?P>NAME)""" 4
.el .IP "\f(CW(?P>NAME)\fR" 4
.IX Item "(?P>NAME)"
Subroutine call to a named capture group. Equivalent to \f(CW\*(C`(?&NAME)\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Many regular expression constructs don't work on \s-1EBCDIC\s0 platforms.
.PP
There are a number of issues with regard to case-insensitive matching
in Unicode rules.  See \f(CW\*(C`i\*(C'\fR under \*(L"Modifiers\*(R" above.
.PP
This document varies from difficult to understand to completely
and utterly opaque.  The wandering prose riddled with jargon is
hard to fathom in several places.
.PP
This document needs a rewrite that separates the tutorial content
from the reference content.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlrequick.
.PP
perlretut.
.PP
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop.
.PP
\&\*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.PP
perlfaq6.
.PP
\&\*(L"pos\*(R" in perlfunc.
.PP
perllocale.
.PP
perlebcdic.
.PP
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl, published
by O'Reilly and Associates.
                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlre5.16.1                                 0100644 0001750 0001750 00000367677 12566207423 022574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRE 1"
.TH PERLRE 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlre \- Perl regular expressions
.IX Xref "regular expression regex regexp"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page describes the syntax of regular expressions in Perl.
.PP
If you haven't used regular expressions before, a quick-start
introduction is available in perlrequick, and a longer tutorial
introduction is available in perlretut.
.PP
For reference on how regular expressions are used in matching
operations, plus various examples of the same, see discussions of
\&\f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR and \f(CW\*(C`??\*(C'\fR in \*(L"Regexp Quote-Like
Operators\*(R" in perlop.
.SS "Modifiers"
.IX Subsection "Modifiers"
Matching operations can have various modifiers.  Modifiers
that relate to the interpretation of the regular expression inside
are listed below.  Modifiers that alter the way a regular expression
is used by Perl are detailed in \*(L"Regexp Quote-Like Operators\*(R" in perlop and
\&\*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.IP "m" 4
.IX Xref " m regex, multiline regexp, multiline regular expression, multiline"
.IX Item "m"
Treat string as multiple lines.  That is, change \*(L"^\*(R" and \*(L"$\*(R" from matching
the start or end of the string to matching the start or end of any
line anywhere within the string.
.IP "s" 4
.IX Xref " s regex, single-line regexp, single-line regular expression, single-line"
.IX Item "s"
Treat string as single line.  That is, change \*(L".\*(R" to match any character
whatsoever, even a newline, which normally it would not match.
.Sp
Used together, as \f(CW\*(C`/ms\*(C'\fR, they let the \*(L".\*(R" match any character whatsoever,
while still allowing \*(L"^\*(R" and \*(L"$\*(R" to match, respectively, just after
and just before newlines within the string.
.IP "i" 4
.IX Xref " i regex, case-insensitive regexp, case-insensitive regular expression, case-insensitive"
.IX Item "i"
Do case-insensitive pattern matching.
.Sp
If locale matching rules are in effect, the case map is taken from the
current
locale for code points less than 255, and from Unicode rules for larger
code points.  However, matches that would cross the Unicode
rules/non\-Unicode rules boundary (ords 255/256) will not succeed.  See
perllocale.
.Sp
There are a number of Unicode characters that match multiple characters
under \f(CW\*(C`/i\*(C'\fR.  For example, \f(CW\*(C`LATIN SMALL LIGATURE FI\*(C'\fR
should match the sequence \f(CW\*(C`fi\*(C'\fR.  Perl is not
currently able to do this when the multiple characters are in the pattern and
are split between groupings, or when one or more are quantified.  Thus
.Sp
.Vb 3
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi/i;          # Matches
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /[fi][fi]/i;    # Doesn\*(Aqt match!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi*/i;         # Doesn\*(Aqt match!
\&
\& # The below doesn\*(Aqt match, and it isn\*(Aqt clear what $1 and $2 would
\& # be even if it did!!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /(f)(i)/i;      # Doesn\*(Aqt match!
.Ve
.Sp
Perl doesn't match multiple characters in an inverted bracketed
character class, which otherwise could be highly confusing.  See
\&\*(L"Negation\*(R" in perlrecharclass.
.Sp
Another bug involves character classes that match both a sequence of
multiple characters, and an initial sub-string of that sequence.  For
example,
.Sp
.Vb 1
\& /[s\exDF]/i
.Ve
.Sp
should match both a single and a double \*(L"s\*(R", since \f(CW\*(C`\exDF\*(C'\fR (on \s-1ASCII\s0
platforms) matches \*(L"ss\*(R".  However, this bug
([perl #89774] <https://rt.perl.org/rt3/Ticket/Display.html?id=89774>)
causes it to only match a single \*(L"s\*(R", even if the final larger match
fails, and matching the double \*(L"ss\*(R" would have succeeded.
.Sp
Also, Perl matching doesn't fully conform to the current Unicode \f(CW\*(C`/i\*(C'\fR
recommendations, which ask that the matching be made upon the \s-1NFD\s0
(Normalization Form Decomposed) of the text.  However, Unicode is
in the process of reconsidering and revising their recommendations.
.IP "x" 4
.IX Xref " x"
.IX Item "x"
Extend your pattern's legibility by permitting whitespace and comments.
Details in \*(L"/x\*(R"
.IP "p" 4
.IX Xref " p regex, preserve regexp, preserve"
.IX Item "p"
Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and
${^POSTMATCH} are available for use after matching.
.IP "g and c" 4
.IX Xref " g  c"
.IX Item "g and c"
Global matching, and keep the Current position after failed matching.
Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself. See
\&\*(L"Using regular expressions in Perl\*(R" in perlretut for further explanation
of the g and c modifiers.
.IP "a, d, l and u" 4
.IX Xref " a  d  l  u"
.IX Item "a, d, l and u"
These modifiers, all new in 5.14, affect which character-set semantics
(Unicode, etc.) are used, as described below in
\&\*(L"Character set modifiers\*(R".
.PP
Regular expression modifiers are usually written in documentation
as e.g., "the \f(CW\*(C`/x\*(C'\fR modifier", even though the delimiter
in question might not really be a slash.  The modifiers \f(CW\*(C`/imsxadlup\*(C'\fR
may also be embedded within the regular expression itself using
the \f(CW\*(C`(?...)\*(C'\fR construct, see \*(L"Extended Patterns\*(R" below.
.PP
\fI/x\fR
.IX Subsection "/x"
.PP
\&\f(CW\*(C`/x\*(C'\fR tells
the regular expression parser to ignore most whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The \f(CW\*(C`#\*(C'\fR
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or \f(CW\*(C`#\*(C'\fR characters in the pattern (outside a character
class, where they are unaffected by \f(CW\*(C`/x\*(C'\fR), then you'll either have to
escape them (using backslashes or \f(CW\*(C`\eQ...\eE\*(C'\fR) or encode them using octal,
hex, or \f(CW\*(C`\eN{}\*(C'\fR escapes.  Taken together, these features go a long way towards
making Perl's regular expressions more readable.  Note that you have to
be careful not to include the pattern delimiter in the comment\*(--perl has
no way of knowing you did not intend to close the pattern early.  See
the C\-comment deletion code in perlop.  Also note that anything inside
a \f(CW\*(C`\eQ...\eE\*(C'\fR stays unaffected by \f(CW\*(C`/x\*(C'\fR.  And note that \f(CW\*(C`/x\*(C'\fR doesn't affect
space interpretation within a single multi-character construct.  For
example in \f(CW\*(C`\ex{...}\*(C'\fR, regardless of the \f(CW\*(C`/x\*(C'\fR modifier, there can be no
spaces.  Same for a quantifier such as \f(CW\*(C`{3}\*(C'\fR or
\&\f(CW\*(C`{5,}\*(C'\fR.  Similarly, \f(CW\*(C`(?:...)\*(C'\fR can't have a space between the \f(CW\*(C`?\*(C'\fR and \f(CW\*(C`:\*(C'\fR,
but can between the \f(CW\*(C`(\*(C'\fR and \f(CW\*(C`?\*(C'\fR.  Within any delimiters for such a
construct, allowed spaces are not affected by \f(CW\*(C`/x\*(C'\fR, and depend on the
construct.  For example, \f(CW\*(C`\ex{...}\*(C'\fR can't have spaces because hexadecimal
numbers don't have spaces in them.  But, Unicode properties can have spaces, so
in \f(CW\*(C`\ep{...}\*(C'\fR there can be spaces that follow the Unicode rules, for which see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops.
.IX Xref " x"
.PP
\fICharacter set modifiers\fR
.IX Subsection "Character set modifiers"
.PP
\&\f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, \f(CW\*(C`/a\*(C'\fR, and \f(CW\*(C`/l\*(C'\fR, available starting in 5.14, are called
the character set modifiers; they affect the character set semantics
used for the regular expression.
.PP
The \f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, and \f(CW\*(C`/l\*(C'\fR modifiers are not likely to be of much use
to you, and so you need not worry about them very much.  They exist for
Perl's internal use, so that complex regular expression data structures
can be automatically serialized and later exactly reconstituted,
including all their nuances.  But, since Perl can't keep a secret, and
there may be rare instances where they are useful, they are documented
here.
.PP
The \f(CW\*(C`/a\*(C'\fR modifier, on the other hand, may be useful.  Its purpose is to
allow code that is to work mostly on \s-1ASCII\s0 data to not have to concern
itself with Unicode.
.PP
Briefly, \f(CW\*(C`/l\*(C'\fR sets the character set to that of whatever \fBL\fRocale is in
effect at the time of the execution of the pattern match.
.PP
\&\f(CW\*(C`/u\*(C'\fR sets the character set to \fBU\fRnicode.
.PP
\&\f(CW\*(C`/a\*(C'\fR also sets the character set to Unicode, \s-1BUT\s0 adds several
restrictions for \fBA\fRSCII-safe matching.
.PP
\&\f(CW\*(C`/d\*(C'\fR is the old, problematic, pre\-5.14 \fBD\fRefault character set
behavior.  Its only use is to force that old behavior.
.PP
At any given time, exactly one of these modifiers is in effect.  Their
existence allows Perl to keep the originally compiled behavior of a
regular expression, regardless of what rules are in effect when it is
actually executed.  And if it is interpolated into a larger regex, the
original's rules continue to apply to it, and only it.
.PP
The \f(CW\*(C`/l\*(C'\fR and \f(CW\*(C`/u\*(C'\fR modifiers are automatically selected for
regular expressions compiled within the scope of various pragmas,
and we recommend that in general, you use those pragmas instead of
specifying these modifiers explicitly.  For one thing, the modifiers
affect only pattern matching, and do not extend to even any replacement
done, whereas using the pragmas give consistent results for all
appropriate operations within their scopes.  For example,
.PP
.Vb 1
\& s/foo/\eUbar/il
.Ve
.PP
will match \*(L"foo\*(R" using the locale's rules for case-insensitive matching,
but the \f(CW\*(C`/l\*(C'\fR does not affect how the \f(CW\*(C`\eU\*(C'\fR operates.  Most likely you
want both of them to use locale rules.  To do this, instead compile the
regular expression within the scope of \f(CW\*(C`use locale\*(C'\fR.  This both
implicitly adds the \f(CW\*(C`/l\*(C'\fR and applies locale rules to the \f(CW\*(C`\eU\*(C'\fR.   The
lesson is to \f(CW\*(C`use locale\*(C'\fR and not \f(CW\*(C`/l\*(C'\fR explicitly.
.PP
Similarly, it would be better to use \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR
instead of,
.PP
.Vb 1
\& s/foo/\eLbar/iu
.Ve
.PP
to get Unicode rules, as the \f(CW\*(C`\eL\*(C'\fR in the former (but not necessarily
the latter) would also use Unicode rules.
.PP
More detail on each of the modifiers follows.  Most likely you don't
need to know this detail for \f(CW\*(C`/l\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, and \f(CW\*(C`/d\*(C'\fR, and can skip ahead
to /a.
.PP
/l
.IX Subsection "/l"
.PP
means to use the current locale's rules (see perllocale) when pattern
matching.  For example, \f(CW\*(C`\ew\*(C'\fR will match the \*(L"word\*(R" characters of that
locale, and \f(CW"/i"\fR case-insensitive matching will match according to
the locale's case folding rules.  The locale used will be the one in
effect at the time of execution of the pattern match.  This may not be
the same as the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
\&\fIsetlocale()\fR function.
.PP
Perl only supports single-byte locales.  This means that code points
above 255 are treated as Unicode no matter what locale is in effect.
Under Unicode rules, there are a few case-insensitive matches that cross
the 255/256 boundary.  These are disallowed under \f(CW\*(C`/l\*(C'\fR.  For example,
0xFF (on \s-1ASCII\s0 platforms) does not caselessly match the character at
0x178, \f(CW\*(C`LATIN CAPITAL LETTER Y WITH DIAERESIS\*(C'\fR, because 0xFF may not be
\&\f(CW\*(C`LATIN SMALL LETTER Y WITH DIAERESIS\*(C'\fR in the current locale, and Perl
has no way of knowing if that character even exists in the locale, much
less what code point it is.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use locale\*(C'\fR, but
see \*(L"Which character set modifier is in effect?\*(R".
.IX Xref " l"
.PP
/u
.IX Subsection "/u"
.PP
means to use Unicode rules when pattern matching.  On \s-1ASCII\s0 platforms,
this means that the code points between 128 and 255 take on their
Latin\-1 (\s-1ISO\-8859\-1\s0) meanings (which are the same as Unicode's).
(Otherwise Perl considers their meanings to be undefined.)  Thus,
under this modifier, the \s-1ASCII\s0 platform effectively becomes a Unicode
platform; and hence, for example, \f(CW\*(C`\ew\*(C'\fR will match any of the more than
100_000 word characters in Unicode.
.PP
Unlike most locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters \fIsomewhere\fR in
the world as
\&\f(CW\*(C`\ew\*(C'\fR.  For example, your locale might not think that \f(CW\*(C`LATIN SMALL
LETTER ETH\*(C'\fR is a letter (unless you happen to speak Icelandic), but
Unicode does.  Similarly, all the characters that are decimal digits
somewhere in the world will match \f(CW\*(C`\ed\*(C'\fR; this is hundreds, not 10,
possible matches.  And some of those digits look like some of the 10
\&\s-1ASCII\s0 digits, but mean a different number, so a human could easily think
a number is a different quantity than it really is.  For example,
\&\f(CW\*(C`BENGALI DIGIT FOUR\*(C'\fR (U+09EA) looks very much like an
\&\f(CW\*(C`ASCII DIGIT EIGHT\*(C'\fR (U+0038).  And, \f(CW\*(C`\ed+\*(C'\fR, may match strings of digits
that are a mixture from different writing systems, creating a security
issue.  \*(L"\fInum()\fR\*(R" in Unicode::UCD can be used to sort
this out.  Or the \f(CW\*(C`/a\*(C'\fR modifier can be used to force \f(CW\*(C`\ed\*(C'\fR to match
just the \s-1ASCII\s0 0 through 9.
.PP
Also, under this modifier, case-insensitive matching works on the full
set of Unicode
characters.  The \f(CW\*(C`KELVIN SIGN\*(C'\fR, for example matches the letters \*(L"k\*(R" and
\&\*(L"K\*(R"; and \f(CW\*(C`LATIN SMALL LIGATURE FF\*(C'\fR matches the sequence \*(L"ff\*(R", which,
if you're not prepared, might make it look like a hexadecimal constant,
presenting another potential security issue.  See
<http://unicode.org/reports/tr36> for a detailed discussion of Unicode
security issues.
.PP
On the \s-1EBCDIC\s0 platforms that Perl handles, the native character set is
equivalent to Latin\-1.  Thus this modifier changes behavior only when
the \f(CW"/i"\fR modifier is also specified, and it turns out it affects only
two characters, giving them full Unicode semantics: the \f(CW\*(C`MICRO SIGN\*(C'\fR
will match the Greek capital and small letters \f(CW\*(C`MU\*(C'\fR, otherwise not; and
the \f(CW\*(C`LATIN CAPITAL LETTER SHARP S\*(C'\fR will match any of \f(CW\*(C`SS\*(C'\fR, \f(CW\*(C`Ss\*(C'\fR,
\&\f(CW\*(C`sS\*(C'\fR, and \f(CW\*(C`ss\*(C'\fR, otherwise not.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use feature
\&\*(Aqunicode_strings\*(C'\fR, \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher),
but see \*(L"Which character set modifier is in effect?\*(R".
.IX Xref " u"
.PP
/d
.IX Subsection "/d"
.PP
This modifier means to use the \*(L"Default\*(R" native rules of the platform
except when there is cause to use Unicode rules instead, as follows:
.IP "1." 4
the target string is encoded in \s-1UTF\-8\s0; or
.IP "2." 4
the pattern is encoded in \s-1UTF\-8\s0; or
.IP "3." 4
the pattern explicitly mentions a code point that is above 255 (say by
\&\f(CW\*(C`\ex{100}\*(C'\fR); or
.IP "4." 4
the pattern uses a Unicode name (\f(CW\*(C`\eN{...}\*(C'\fR);  or
.IP "5." 4
the pattern uses a Unicode property (\f(CW\*(C`\ep{...}\*(C'\fR)
.PP
Another mnemonic for this modifier is \*(L"Depends\*(R", as the rules actually
used depend on various things, and as a result you can get unexpected
results.  See \*(L"The \*(R"Unicode Bug"" in perlunicode.  The Unicode Bug has
become rather infamous, leading to yet another (printable) name for this
modifier, \*(L"Dodgy\*(R".
.PP
On \s-1ASCII\s0 platforms, the native rules are \s-1ASCII\s0, and on \s-1EBCDIC\s0 platforms
(at least the ones that Perl handles), they are Latin\-1.
.PP
Here are some examples of how that works on an \s-1ASCII\s0 platform:
.PP
.Vb 6
\& $str =  "\exDF";      # $str is not in UTF\-8 format.
\& $str =~ /^\ew/;       # No match, as $str isn\*(Aqt in UTF\-8 format.
\& $str .= "\ex{0e0b}";  # Now $str is in UTF\-8 format.
\& $str =~ /^\ew/;       # Match! $str is now in UTF\-8 format.
\& chop $str;
\& $str =~ /^\ew/;       # Still a match! $str remains in UTF\-8 format.
.Ve
.PP
This modifier is automatically selected by default when none of the
others are, so yet another name for it is \*(L"Default\*(R".
.PP
Because of the unexpected behaviors associated with this modifier, you
probably should only use it to maintain weird backward compatibilities.
.PP
/a (and /aa)
.IX Subsection "/a (and /aa)"
.PP
This modifier stands for ASCII-restrict (or ASCII-safe).  This modifier,
unlike the others, may be doubled-up to increase its effect.
.PP
When it appears singly, it causes the sequences \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and
the Posix character classes to match only in the \s-1ASCII\s0 range.  They thus
revert to their pre\-5.6, pre-Unicode meanings.  Under \f(CW\*(C`/a\*(C'\fR,  \f(CW\*(C`\ed\*(C'\fR
always means precisely the digits \f(CW"0"\fR to \f(CW"9"\fR; \f(CW\*(C`\es\*(C'\fR means the five
characters \f(CW\*(C`[ \ef\en\er\et]\*(C'\fR; \f(CW\*(C`\ew\*(C'\fR means the 63 characters
\&\f(CW\*(C`[A\-Za\-z0\-9_]\*(C'\fR; and likewise, all the Posix classes such as
\&\f(CW\*(C`[[:print:]]\*(C'\fR match only the appropriate ASCII-range characters.
.PP
This modifier is useful for people who only incidentally use Unicode,
and who do not wish to be burdened with its complexities and security
concerns.
.PP
With \f(CW\*(C`/a\*(C'\fR, one can write \f(CW\*(C`\ed\*(C'\fR with confidence that it will only match
\&\s-1ASCII\s0 characters, and should the need arise to match beyond \s-1ASCII\s0, you
can instead use \f(CW\*(C`\ep{Digit}\*(C'\fR (or \f(CW\*(C`\ep{Word}\*(C'\fR for \f(CW\*(C`\ew\*(C'\fR).  There are
similar \f(CW\*(C`\ep{...}\*(C'\fR constructs that can match beyond \s-1ASCII\s0 both white
space (see \*(L"Whitespace\*(R" in perlrecharclass), and Posix classes (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass).  Thus, this modifier
doesn't mean you can't use Unicode, it means that to get Unicode
matching you must explicitly use a construct (\f(CW\*(C`\ep{}\*(C'\fR, \f(CW\*(C`\eP{}\*(C'\fR) that
signals Unicode.
.PP
As you would expect, this modifier causes, for example, \f(CW\*(C`\eD\*(C'\fR to mean
the same thing as \f(CW\*(C`[^0\-9]\*(C'\fR; in fact, all non-ASCII characters match
\&\f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, and \f(CW\*(C`\eW\*(C'\fR.  \f(CW\*(C`\eb\*(C'\fR still means to match at the boundary
between \f(CW\*(C`\ew\*(C'\fR and \f(CW\*(C`\eW\*(C'\fR, using the \f(CW\*(C`/a\*(C'\fR definitions of them (similarly
for \f(CW\*(C`\eB\*(C'\fR).
.PP
Otherwise, \f(CW\*(C`/a\*(C'\fR behaves like the \f(CW\*(C`/u\*(C'\fR modifier, in that
case-insensitive matching uses Unicode semantics; for example, \*(L"k\*(R" will
match the Unicode \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching, and code
points in the Latin1 range, above \s-1ASCII\s0 will have Unicode rules when it
comes to case-insensitive matching.
.PP
To forbid ASCII/non\-ASCII matches (like \*(L"k\*(R" with \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR),
specify the \*(L"a\*(R" twice, for example \f(CW\*(C`/aai\*(C'\fR or \f(CW\*(C`/aia\*(C'\fR.  (The first
occurrence of \*(L"a\*(R" restricts the \f(CW\*(C`\ed\*(C'\fR, etc., and the second occurrence
adds the \f(CW\*(C`/i\*(C'\fR restrictions.)  But, note that code points outside the
\&\s-1ASCII\s0 range will use Unicode rules for \f(CW\*(C`/i\*(C'\fR matching, so the modifier
doesn't really restrict things to just \s-1ASCII\s0; it just forbids the
intermixing of \s-1ASCII\s0 and non-ASCII.
.PP
To summarize, this modifier provides protection for applications that
don't wish to be exposed to all of Unicode.  Specifying it twice
gives added protection.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use re \*(Aq/a\*(Aq\*(C'\fR
or \f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR.  If you do so, you may actually have occasion to use
the \f(CW\*(C`/u\*(C'\fR modifier explictly if there are a few regular expressions
where you do want full Unicode rules (but even here, it's best if
everything were under feature \f(CW"unicode_strings"\fR, along with the
\&\f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR).  Also see \*(L"Which character set modifier is in
effect?\*(R".
.IX Xref " a  aa"
.PP
Which character set modifier is in effect?
.IX Subsection "Which character set modifier is in effect?"
.PP
Which of these modifiers is in effect at any given point in a regular
expression depends on a fairly complex set of interactions.  These have
been designed so that in general you don't have to worry about it, but
this section gives the gory details.  As
explained below in \*(L"Extended Patterns\*(R" it is possible to explicitly
specify modifiers that apply only to portions of a regular expression.
The innermost always has priority over any outer ones, and one applying
to the whole expression has priority over any of the default settings that are
described in the remainder of this section.
.PP
The \f(CW\*(C`use re \*(Aq/foo\*(Aq\*(C'\fR pragma can be used to set
default modifiers (including these) for regular expressions compiled
within its scope.  This pragma has precedence over the other pragmas
listed below that also change the defaults.
.PP
Otherwise, \f(CW\*(C`use locale\*(C'\fR sets the default modifier to \f(CW\*(C`/l\*(C'\fR;
and \f(CW\*(C`use feature \*(Aqunicode_strings\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher) set the default to
\&\f(CW\*(C`/u\*(C'\fR when not in the same scope as either \f(CW\*(C`use locale\*(C'\fR
or \f(CW\*(C`use bytes\*(C'\fR.
(\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR also
sets the default to \f(CW\*(C`/u\*(C'\fR, overriding any plain \f(CW\*(C`use locale\*(C'\fR.)
Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern matching, and so
give more consistent results with other operators, including using
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, etc. in substitution replacements.
.PP
If none of the above apply, for backwards compatibility reasons, the
\&\f(CW\*(C`/d\*(C'\fR modifier is the one in effect by default.  As this can lead to
unexpected results, it is best to specify which other rule set should be
used.
.PP
Character set modifier behavior prior to Perl 5.14
.IX Subsection "Character set modifier behavior prior to Perl 5.14"
.PP
Prior to 5.14, there were no explicit modifiers, but \f(CW\*(C`/l\*(C'\fR was implied
for regexes compiled within the scope of \f(CW\*(C`use locale\*(C'\fR, and \f(CW\*(C`/d\*(C'\fR was
implied otherwise.  However, interpolating a regex into a larger regex
would ignore the original compilation in favor of whatever was in effect
at the time of the second compilation.  There were a number of
inconsistencies (bugs) with the \f(CW\*(C`/d\*(C'\fR modifier, where Unicode rules
would be used when inappropriate, and vice versa.  \f(CW\*(C`\ep{}\*(C'\fR did not imply
Unicode rules, and neither did all occurrences of \f(CW\*(C`\eN{}\*(C'\fR, until 5.12.
.SS "Regular Expressions"
.IX Subsection "Regular Expressions"
\fIMetacharacters\fR
.IX Subsection "Metacharacters"
.PP
The patterns used in Perl pattern matching evolved from those supplied in
the Version 8 regex routines.  (The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See \*(L"Version 8 Regular Expressions\*(R" for
details.
.PP
In particular the following metacharacters have their standard \fIegrep\fR\-ish
meanings:
.IX Xref "metacharacter \\ ^ . $ | ( () [ []"
.PP
.Vb 7
\&    \e        Quote the next metacharacter
\&    ^        Match the beginning of the line
\&    .        Match any character (except newline)
\&    $        Match the end of the line (or before newline at the end)
\&    |        Alternation
\&    ()       Grouping
\&    []       Bracketed Character class
.Ve
.PP
By default, the \*(L"^\*(R" character is guaranteed to match only the
beginning of the string, the \*(L"$\*(R" character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by \*(L"^\*(R" or \*(L"$\*(R".  You may, however, wish to treat a
string as a multi-line buffer, such that the \*(L"^\*(R" will match after any
newline within the string (except if the newline is the last character in
the string), and \*(L"$\*(R" will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting \f(CW$*\fR,
but this option was removed in perl 5.9.)
.IX Xref "^ $  m"
.PP
To simplify multi-line substitutions, the \*(L".\*(R" character never matches a
newline unless you use the \f(CW\*(C`/s\*(C'\fR modifier, which in effect tells Perl to pretend
the string is a single line\*(--even if it isn't.
.IX Xref ".  s"
.PP
\fIQuantifiers\fR
.IX Subsection "Quantifiers"
.PP
The following standard quantifiers are recognized:
.IX Xref "metacharacter quantifier * + ? {n} {n,} {n,m}"
.PP
.Vb 6
\&    *           Match 0 or more times
\&    +           Match 1 or more times
\&    ?           Match 1 or 0 times
\&    {n}         Match exactly n times
\&    {n,}        Match at least n times
\&    {n,m}       Match at least n but not more than m times
.Ve
.PP
(If a curly bracket occurs in any other context and does not form part of
a backslashed sequence like \f(CW\*(C`\ex{...}\*(C'\fR, it is treated
as a regular character.  In particular, the lower quantifier bound
is not optional.  However, in Perl v5.18, it is planned to issue a
deprecation warning for all such occurrences, and in Perl v5.20 to
require literal uses of a curly bracket to be escaped, say by preceding
them with a backslash or enclosing them within square brackets, (\f(CW"\e{"\fR
or \f(CW"[{]"\fR).  This change will allow for future syntax extensions (like
making the lower bound of a quantifier optional), and better error
checking of quantifiers.  Now, a typo in a quantifier silently causes
it to be treated as the literal characters.  For example,
.PP
.Vb 1
\&    /o{4,3}/
.Ve
.PP
looks like a quantifier that matches 0 times, since 4 is greater than 3,
but it really means to match the sequence of six characters
\&\f(CW"o\ {\ 4\ ,\ 3\ }"\fR.)
.PP
The \*(L"*\*(R" quantifier is equivalent to \f(CW\*(C`{0,}\*(C'\fR, the \*(L"+\*(R"
quantifier to \f(CW\*(C`{1,}\*(C'\fR, and the \*(L"?\*(R" quantifier to \f(CW\*(C`{0,1}\*(C'\fR.  n and m are limited
to non-negative integral values less than a preset limit defined when perl is built.
This is usually 32766 on the most common platforms.  The actual limit can
be seen in the error message generated by code such as this:
.PP
.Vb 1
\&    $_ **= $_ , / {$_} / for 2 .. 42;
.Ve
.PP
By default, a quantified subpattern is \*(L"greedy\*(R", that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.  If you want it to match the
minimum number of times possible, follow the quantifier with a \*(L"?\*(R".  Note
that the meanings don't change, just the \*(L"greediness\*(R":
.IX Xref "metacharacter greedy greediness ? *? +? ?? {n}? {n,}? {n,m}?"
.PP
.Vb 6
\&    *?        Match 0 or more times, not greedily
\&    +?        Match 1 or more times, not greedily
\&    ??        Match 0 or 1 time, not greedily
\&    {n}?      Match exactly n times, not greedily (redundant)
\&    {n,}?     Match at least n times, not greedily
\&    {n,m}?    Match at least n but not more than m times, not greedily
.Ve
.PP
By default, when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl provides the \*(L"possessive\*(R" quantifier form
as well.
.PP
.Vb 6
\& *+     Match 0 or more times and give nothing back
\& ++     Match 1 or more times and give nothing back
\& ?+     Match 0 or 1 time and give nothing back
\& {n}+   Match exactly n times and give nothing back (redundant)
\& {n,}+  Match at least n times and give nothing back
\& {n,m}+ Match at least n but not more than m times and give nothing back
.Ve
.PP
For instance,
.PP
.Vb 1
\&   \*(Aqaaaa\*(Aq =~ /a++a/
.Ve
.PP
will never match, as the \f(CW\*(C`a++\*(C'\fR will gobble up all the \f(CW\*(C`a\*(C'\fR's in the
string and won't leave any for the remaining part of the pattern. This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack. For instance, the typical \*(L"match a double-quoted
string\*(R" problem can be most efficiently performed when written as:
.PP
.Vb 1
\&   /"(?:[^"\e\e]++|\e\e.)*+"/
.Ve
.PP
as we know that if the final quote does not match, backtracking will not
help. See the independent subexpression
"\f(CW\*(C`(?>pattern)\*(C'\fR" for more details;
possessive quantifiers are just syntactic sugar for that construct. For
instance the above example could also be written as follows:
.PP
.Vb 1
\&   /"(?>(?:(?>[^"\e\e]+)|\e\e.)*)"/
.Ve
.PP
\fIEscape sequences\fR
.IX Subsection "Escape sequences"
.PP
Because patterns are processed as double-quoted strings, the following
also work:
.PP
.Vb 10
\& \et          tab                   (HT, TAB)
\& \en          newline               (LF, NL)
\& \er          return                (CR)
\& \ef          form feed             (FF)
\& \ea          alarm (bell)          (BEL)
\& \ee          escape (think troff)  (ESC)
\& \ecK         control char          (example: VT)
\& \ex{}, \ex00  character whose ordinal is the given hexadecimal number
\& \eN{name}    named Unicode character or character sequence
\& \eN{U+263D}  Unicode character     (example: FIRST QUARTER MOON)
\& \eo{}, \e000  character whose ordinal is the given octal number
\& \el          lowercase next char (think vi)
\& \eu          uppercase next char (think vi)
\& \eL          lowercase till \eE (think vi)
\& \eU          uppercase till \eE (think vi)
\& \eQ          quote (disable) pattern metacharacters till \eE
\& \eE          end either case modification or quoted section, think vi
.Ve
.PP
Details are in \*(L"Quote and Quote-like Operators\*(R" in perlop.
.PP
\fICharacter Classes and other Special Escapes\fR
.IX Subsection "Character Classes and other Special Escapes"
.PP
In addition, Perl defines the following:
.IX Xref "\\g \\k \\K backreference"
.PP
.Vb 10
\& Sequence   Note    Description
\&  [...]     [1]  Match a character according to the rules of the
\&                   bracketed character class defined by the "...".
\&                   Example: [a\-z] matches "a" or "b" or "c" ... or "z"
\&  [[:...:]] [2]  Match a character according to the rules of the POSIX
\&                   character class "..." within the outer bracketed
\&                   character class.  Example: [[:upper:]] matches any
\&                   uppercase character.
\&  \ew        [3]  Match a "word" character (alphanumeric plus "_", plus
\&                   other connector punctuation chars plus Unicode
\&                   marks)
\&  \eW        [3]  Match a non\-"word" character
\&  \es        [3]  Match a whitespace character
\&  \eS        [3]  Match a non\-whitespace character
\&  \ed        [3]  Match a decimal digit character
\&  \eD        [3]  Match a non\-digit character
\&  \epP       [3]  Match P, named property.  Use \ep{Prop} for longer names
\&  \ePP       [3]  Match non\-P
\&  \eX        [4]  Match Unicode "eXtended grapheme cluster"
\&  \eC             Match a single C\-language char (octet) even if that is
\&                   part of a larger UTF\-8 character.  Thus it breaks up
\&                   characters into their UTF\-8 bytes, so you may end up
\&                   with malformed pieces of UTF\-8.  Unsupported in
\&                   lookbehind.
\&  \e1        [5]  Backreference to a specific capture group or buffer.
\&                   \*(Aq1\*(Aq may actually be any positive integer.
\&  \eg1       [5]  Backreference to a specific or previous group,
\&  \eg{\-1}    [5]  The number may be negative indicating a relative
\&                   previous group and may optionally be wrapped in
\&                   curly brackets for safer parsing.
\&  \eg{name}  [5]  Named backreference
\&  \ek<name>  [5]  Named backreference
\&  \eK        [6]  Keep the stuff left of the \eK, don\*(Aqt include it in $&
\&  \eN        [7]  Any character but \en (experimental).  Not affected by
\&                   /s modifier
\&  \ev        [3]  Vertical whitespace
\&  \eV        [3]  Not vertical whitespace
\&  \eh        [3]  Horizontal whitespace
\&  \eH        [3]  Not horizontal whitespace
\&  \eR        [4]  Linebreak
.Ve
.IP "[1]" 4
.IX Item "[1]"
See \*(L"Bracketed Character Classes\*(R" in perlrecharclass for details.
.IP "[2]" 4
.IX Item "[2]"
See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass for details.
.IP "[3]" 4
.IX Item "[3]"
See \*(L"Backslash sequences\*(R" in perlrecharclass for details.
.IP "[4]" 4
.IX Item "[4]"
See \*(L"Misc\*(R" in perlrebackslash for details.
.IP "[5]" 4
.IX Item "[5]"
See \*(L"Capture groups\*(R" below for details.
.IP "[6]" 4
.IX Item "[6]"
See \*(L"Extended Patterns\*(R" below for details.
.IP "[7]" 4
.IX Item "[7]"
Note that \f(CW\*(C`\eN\*(C'\fR has two meanings.  When of the form \f(CW\*(C`\eN{NAME}\*(C'\fR, it matches the
character or character sequence whose name is \f(CW\*(C`NAME\*(C'\fR; and similarly
when of the form \f(CW\*(C`\eN{U+\f(CIhex\f(CW}\*(C'\fR, it matches the character whose Unicode
code point is \fIhex\fR.  Otherwise it matches any character but \f(CW\*(C`\en\*(C'\fR.
.PP
\fIAssertions\fR
.IX Subsection "Assertions"
.PP
Perl defines the following zero-width assertions:
.IX Xref "zero-width assertion assertion regex, zero-width assertion regexp, zero-width assertion regular expression, zero-width assertion \\b \\B \\A \\Z \\z \\G"
.PP
.Vb 7
\&    \eb  Match a word boundary
\&    \eB  Match except at a word boundary
\&    \eA  Match only at beginning of string
\&    \eZ  Match only at end of string, or before newline at the end
\&    \ez  Match only at end of string
\&    \eG  Match only at pos() (e.g. at the end\-of\-match position
\&        of prior m//g)
.Ve
.PP
A word boundary (\f(CW\*(C`\eb\*(C'\fR) is a spot between two characters
that has a \f(CW\*(C`\ew\*(C'\fR on one side of it and a \f(CW\*(C`\eW\*(C'\fR on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a \f(CW\*(C`\eW\*(C'\fR.  (Within
character classes \f(CW\*(C`\eb\*(C'\fR represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The \f(CW\*(C`\eA\*(C'\fR and \f(CW\*(C`\eZ\*(C'\fR are just like \*(L"^\*(R" and \*(L"$\*(R", except that they
won't match multiple times when the \f(CW\*(C`/m\*(C'\fR modifier is used, while
\&\*(L"^\*(R" and \*(L"$\*(R" will match at every internal line boundary.  To match
the actual end of the string and not ignore an optional trailing
newline, use \f(CW\*(C`\ez\*(C'\fR.
.IX Xref "\\b \\A \\Z \\z  m"
.PP
The \f(CW\*(C`\eG\*(C'\fR assertion can be used to chain global matches (using
\&\f(CW\*(C`m//g\*(C'\fR), as described in \*(L"Regexp Quote-Like Operators\*(R" in perlop.
It is also useful when writing \f(CW\*(C`lex\*(C'\fR\-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string; see the previous reference.  The actual location
where \f(CW\*(C`\eG\*(C'\fR will match can also be influenced by using \f(CW\*(C`pos()\*(C'\fR as
an lvalue: see \*(L"pos\*(R" in perlfunc. Note that the rule for zero-length
matches (see \*(L"Repeated Patterns Matching a Zero-length Substring\*(R")
is modified somewhat, in that contents to the left of \f(CW\*(C`\eG\*(C'\fR are
not counted when determining the length of the match. Thus the following
will not match forever:
.IX Xref "\\G"
.PP
.Vb 5
\&     my $string = \*(AqABC\*(Aq;
\&     pos($string) = 1;
\&     while ($string =~ /(.\eG)/g) {
\&         print $1;
\&     }
.Ve
.PP
It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.
.PP
It is worth noting that \f(CW\*(C`\eG\*(C'\fR improperly used can result in an infinite
loop. Take care when using patterns that include \f(CW\*(C`\eG\*(C'\fR in an alternation.
.PP
\fICapture groups\fR
.IX Subsection "Capture groups"
.PP
The bracketing construct \f(CW\*(C`( ... )\*(C'\fR creates capture groups (also referred to as
capture buffers). To refer to the current contents of a group later on, within
the same pattern, use \f(CW\*(C`\eg1\*(C'\fR (or \f(CW\*(C`\eg{1}\*(C'\fR) for the first, \f(CW\*(C`\eg2\*(C'\fR (or \f(CW\*(C`\eg{2}\*(C'\fR)
for the second, and so on.
This is called a \fIbackreference\fR.
 
 
 
 
    
 
 
  
There is no limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being number 1, etc.  If
a group did not match, the associated backreference won't match either. (This
can happen if the group is optional, or in a different branch of an
alternation.)
You can omit the \f(CW"g"\fR, and write \f(CW"\e1"\fR, etc, but there are some issues with
this form, described below.
.IX Xref "regex, capture buffer regexp, capture buffer regex, capture group regexp, capture group regular expression, capture buffer backreference regular expression, capture group backreference \\g{1} \\g{-1} \\g{name} relative backreference named backreference named capture buffer regular expression, named capture buffer named capture group regular expression, named capture group %+ $+{name} \\k<name>"
.PP
You can also refer to capture groups relatively, by using a negative number, so
that \f(CW\*(C`\eg\-1\*(C'\fR and \f(CW\*(C`\eg{\-1}\*(C'\fR both refer to the immediately preceding capture
group, and \f(CW\*(C`\eg\-2\*(C'\fR and \f(CW\*(C`\eg{\-2}\*(C'\fR both refer to the group before it.  For
example:
.PP
.Vb 8
\&        /
\&         (Y)            # group 1
\&         (              # group 2
\&            (X)         # group 3
\&            \eg{\-1}      # backref to group 3
\&            \eg{\-3}      # backref to group 1
\&         )
\&        /x
.Ve
.PP
would match the same as \f(CW\*(C`/(Y) ( (X) \eg3 \eg1 )/x\*(C'\fR.  This allows you to
interpolate regexes into larger regexes and not have to worry about the
capture groups being renumbered.
.PP
You can dispense with numbers altogether and create named capture groups.
The notation is \f(CW\*(C`(?<\f(CIname\f(CW>...)\*(C'\fR to declare and \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR to
reference.  (To be compatible with .Net regular expressions, \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR may
also be written as \f(CW\*(C`\ek{\f(CIname\f(CW}\*(C'\fR, \f(CW\*(C`\ek<\f(CIname\f(CW>\*(C'\fR or \f(CW\*(C`\ek\*(Aq\f(CIname\f(CW\*(Aq\*(C'\fR.)
\&\fIname\fR must not begin with a number, nor contain hyphens.
When different groups within the same pattern have the same name, any reference
to that name assumes the leftmost defined group.  Named groups count in
absolute and relative numbering, and so can also be referred to by those
numbers.
(It's possible to do things with named capture groups that would otherwise
require \f(CW\*(C`(??{})\*(C'\fR.)
.PP
Capture group contents are dynamically scoped and available to you outside the
pattern until the end of the enclosing block or until the next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" in perlsyn.)
You can refer to them by absolute number (using \f(CW"$1"\fR instead of \f(CW"\eg1"\fR,
etc); or by name via the \f(CW\*(C`%+\*(C'\fR hash, using \f(CW"$+{\f(CIname\f(CW}"\fR.
.PP
Braces are required in referring to named capture groups, but are optional for
absolute or relative numbered ones.  Braces are safer when creating a regex by
concatenating smaller strings.  For example if you have \f(CW\*(C`qr/$a$b/\*(C'\fR, and \f(CW$a\fR
contained \f(CW"\eg1"\fR, and \f(CW$b\fR contained \f(CW"37"\fR, you would get \f(CW\*(C`/\eg137/\*(C'\fR which
is probably not what you intended.
.PP
The \f(CW\*(C`\eg\*(C'\fR and \f(CW\*(C`\ek\*(C'\fR notations were introduced in Perl 5.10.0.  Prior to that
there were no named nor relative numbered capture groups.  Absolute numbered
groups were referred to using \f(CW\*(C`\e1\*(C'\fR,
\&\f(CW\*(C`\e2\*(C'\fR, etc., and this notation is still
accepted (and likely always will be).  But it leads to some ambiguities if
there are more than 9 capture groups, as \f(CW\*(C`\e10\*(C'\fR could mean either the tenth
capture group, or the character whose ordinal in octal is 010 (a backspace in
\&\s-1ASCII\s0).  Perl resolves this ambiguity by interpreting \f(CW\*(C`\e10\*(C'\fR as a backreference
only if at least 10 left parentheses have opened before it.  Likewise \f(CW\*(C`\e11\*(C'\fR is
a backreference only if at least 11 left parentheses have opened before it.
And so on.  \f(CW\*(C`\e1\*(C'\fR through \f(CW\*(C`\e9\*(C'\fR are always interpreted as backreferences.
There are several examples below that illustrate these perils.  You can avoid
the ambiguity by always using \f(CW\*(C`\eg{}\*(C'\fR or \f(CW\*(C`\eg\*(C'\fR if you mean capturing groups;
and for octal constants always using \f(CW\*(C`\eo{}\*(C'\fR, or for \f(CW\*(C`\e077\*(C'\fR and below, using 3
digits padded with leading zeros, since a leading zero implies an octal
constant.
.PP
The \f(CW\*(C`\e\f(CIdigit\f(CW\*(C'\fR notation also works in certain circumstances outside
the pattern.  See \*(L"Warning on \e1 Instead of \f(CW$1\fR\*(R" below for details.
.PP
Examples:
.PP
.Vb 1
\&    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
\&
\&    /(.)\eg1/                        # find first doubled char
\&         and print "\*(Aq$1\*(Aq is the first doubled character\en";
\&
\&    /(?<char>.)\ek<char>/            # ... a different way
\&         and print "\*(Aq$+{char}\*(Aq is the first doubled character\en";
\&
\&    /(?\*(Aqchar\*(Aq.)\eg1/                 # ... mix and match
\&         and print "\*(Aq$1\*(Aq is the first doubled character\en";
\&
\&    if (/Time: (..):(..):(..)/) {   # parse out values
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
\&
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\eg10/   # \eg10 is a backreference
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\e10/    # \e10 is octal
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e10/  # \e10 is a backreference
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e010/ # \e010 is octal
\&
\&    $a = \*(Aq(.)\e1\*(Aq;        # Creates problems when concatenated.
\&    $b = \*(Aq(.)\eg{1}\*(Aq;     # Avoids the problems.
\&    "aa" =~ /${a}/;      # True
\&    "aa" =~ /${b}/;      # True
\&    "aa0" =~ /${a}0/;    # False!
\&    "aa0" =~ /${b}0/;    # True
\&    "aa\ex08" =~ /${a}0/;  # True!
\&    "aa\ex08" =~ /${b}0/;  # False
.Ve
.PP
Several special variables also refer back to portions of the previous
match.  \f(CW$+\fR returns whatever the last bracket match matched.
\&\f(CW$&\fR returns the entire matched string.  (At one point \f(CW$0\fR did
also, but now it returns the name of the program.)  \f(CW\*(C`$\`\*(C'\fR returns
everything before the matched string.  \f(CW\*(C`$\*(Aq\*(C'\fR returns everything
after the matched string. And \f(CW$^N\fR contains whatever was matched by
the most-recently closed group (submatch). \f(CW$^N\fR can be used in
extended patterns (see below), for example to assign a submatch to a
variable.
.IX Xref "$+ $^N $& $` $'"
.PP
These special variables, like the \f(CW\*(C`%+\*(C'\fR hash and the numbered match variables
(\f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR, etc.) are dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" in perlsyn.)
.IX Xref "$+ $^N $& $` $' $1 $2 $3 $4 $5 $6 $7 $8 $9"
.PP
\&\fB\s-1NOTE\s0\fR: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.
.PP
\&\fB\s-1WARNING\s0\fR: Once Perl sees that you need one of \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR, or
\&\f(CW\*(C`$\*(Aq\*(C'\fR anywhere in the program, it has to provide them for every
pattern match.  This may substantially slow your program.  Perl
uses the same mechanism to produce \f(CW$1\fR, \f(CW$2\fR, etc, so you also pay a
price for each pattern that contains capturing parentheses.  (To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression \f(CW\*(C`(?: ... )\*(C'\fR instead.)  But if you never
use \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR or \f(CW\*(C`$\*(Aq\*(C'\fR, then patterns \fIwithout\fR capturing
parentheses will not be penalized.  So avoid \f(CW$&\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, and \f(CW\*(C`$\`\*(C'\fR
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.  As of 5.005, \f(CW$&\fR is not so costly as the
other two.
.IX Xref "$& $` $'"
.PP
As a workaround for this problem, Perl 5.10.0 introduces \f(CW\*(C`${^PREMATCH}\*(C'\fR,
\&\f(CW\*(C`${^MATCH}\*(C'\fR and \f(CW\*(C`${^POSTMATCH}\*(C'\fR, which are equivalent to \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR
and \f(CW\*(C`$\*(Aq\*(C'\fR, \fBexcept\fR that they are only guaranteed to be defined after a
successful match that was executed with the \f(CW\*(C`/p\*(C'\fR (preserve) modifier.
The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.
.IX Xref " p p modifier"
.SS "Quoting metacharacters"
.IX Subsection "Quoting metacharacters"
Backslashed metacharacters in Perl are alphanumeric, such as \f(CW\*(C`\eb\*(C'\fR,
\&\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\en\*(C'\fR.  Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.  So anything
that looks like \e\e, \e(, \e), \e<, \e>, \e{, or \e} is always
interpreted as a literal character, not a metacharacter.  This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern. Simply quote all non\-\*(L"word\*(R" characters:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e$1/g;
.Ve
.PP
(If \f(CW\*(C`use locale\*(C'\fR is set, then this depends on the current locale.)
Today it is more common to use the \fIquotemeta()\fR function or the \f(CW\*(C`\eQ\*(C'\fR
metaquoting escape sequence to disable all metacharacters' special
meanings like this:
.PP
.Vb 1
\&    /$unquoted\eQ$quoted\eE$unquoted/
.Ve
.PP
Beware that if you put literal backslashes (those not inside
interpolated variables) between \f(CW\*(C`\eQ\*(C'\fR and \f(CW\*(C`\eE\*(C'\fR, double-quotish
backslash interpolation may lead to confusing results.  If you
\&\fIneed\fR to use literal backslashes within \f(CW\*(C`\eQ...\eE\*(C'\fR,
consult \*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.PP
\&\f(CW\*(C`quotemeta()\*(C'\fR and \f(CW\*(C`\eQ\*(C'\fR are fully described in \*(L"quotemeta\*(R" in perlfunc.
.SS "Extended Patterns"
.IX Subsection "Extended Patterns"
Perl also defines a consistent extension syntax for features not
found in standard tools like \fBawk\fR and
\&\fBlex\fR.  The syntax for most of these is a
pair of parentheses with a question mark as the first thing within
the parentheses.  The character after the question mark indicates
the extension.
.PP
The stability of these extensions varies widely.  Some have been
part of the core language for many years.  Others are experimental
and may change without warning or be completely removed.  Check
the documentation on an individual feature to verify its current
status.
.PP
A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
\&\*(L"question\*(R" exactly what is going on.  That's psychology....
.ie n .IP """(?#text)""" 4
.el .IP "\f(CW(?#text)\fR" 4
.IX Xref "(?#)"
.IX Item "(?#text)"
A comment.  The text is ignored.  If the \f(CW\*(C`/x\*(C'\fR modifier enables
whitespace formatting, a simple \f(CW\*(C`#\*(C'\fR will suffice.  Note that Perl closes
the comment as soon as it sees a \f(CW\*(C`)\*(C'\fR, so there is no way to put a literal
\&\f(CW\*(C`)\*(C'\fR in the comment.
.ie n .IP """(?adlupimsx\-imsx)""" 4
.el .IP "\f(CW(?adlupimsx\-imsx)\fR" 4
.IX Item "(?adlupimsx-imsx)"
.PD 0
.ie n .IP """(?^alupimsx)""" 4
.el .IP "\f(CW(?^alupimsx)\fR" 4
.IX Xref "(?) (?^)"
.IX Item "(?^alupimsx)"
.PD
One or more embedded pattern-match modifiers, to be turned on (or
turned off, if preceded by \f(CW\*(C`\-\*(C'\fR) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).
.Sp
This is particularly useful for dynamic patterns, such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.  Consider the case where some patterns want to be
case-sensitive and some do not:  The case-insensitive ones merely need to
include \f(CW\*(C`(?i)\*(C'\fR at the front of the pattern.  For example:
.Sp
.Vb 2
\&    $pattern = "foobar";
\&    if ( /$pattern/i ) { }
\&
\&    # more flexible:
\&
\&    $pattern = "(?i)foobar";
\&    if ( /$pattern/ ) { }
.Ve
.Sp
These modifiers are restored at the end of the enclosing group. For example,
.Sp
.Vb 1
\&    ( (?i) blah ) \es+ \eg1
.Ve
.Sp
will match \f(CW\*(C`blah\*(C'\fR in any case, some spaces, and an exact (\fIincluding the case\fR!)
repetition of the previous word, assuming the \f(CW\*(C`/x\*(C'\fR modifier, and no \f(CW\*(C`/i\*(C'\fR
modifier outside this group.
.Sp
These modifiers do not carry over into named subpatterns called in the
enclosing group. In other words, a pattern such as \f(CW\*(C`((?i)(?&NAME))\*(C'\fR does not
change the case-sensitivity of the \*(L"\s-1NAME\s0\*(R" pattern.
.Sp
Any of these modifiers can be set to apply globally to all regular
expressions compiled within the scope of a \f(CW\*(C`use re\*(C'\fR.  See
\&\*(L"'/flags' mode\*(R" in re.
.Sp
Starting in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
after the \f(CW"?"\fR is a shorthand equivalent to \f(CW\*(C`d\-imsx\*(C'\fR.  Flags (except
\&\f(CW"d"\fR) may follow the caret to override it.
But a minus sign is not legal with it.
.Sp
Note that the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR, and \f(CW\*(C`u\*(C'\fR modifiers are special in
that they can only be enabled, not disabled, and the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, and
\&\f(CW\*(C`u\*(C'\fR modifiers are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two \f(CW\*(C`a\*(C'\fR's) may appear in the
construct.  Thus, for
example, \f(CW\*(C`(?\-p)\*(C'\fR will warn when compiled under \f(CW\*(C`use warnings\*(C'\fR;
\&\f(CW\*(C`(?\-d:...)\*(C'\fR and \f(CW\*(C`(?dl:...)\*(C'\fR are fatal errors.
.Sp
Note also that the \f(CW\*(C`p\*(C'\fR modifier is special in that its presence
anywhere in a pattern has a global effect.
.ie n .IP """(?:pattern)""" 4
.el .IP "\f(CW(?:pattern)\fR" 4
.IX Xref "(?:)"
.IX Item "(?:pattern)"
.PD 0
.ie n .IP """(?adluimsx\-imsx:pattern)""" 4
.el .IP "\f(CW(?adluimsx\-imsx:pattern)\fR" 4
.IX Item "(?adluimsx-imsx:pattern)"
.ie n .IP """(?^aluimsx:pattern)""" 4
.el .IP "\f(CW(?^aluimsx:pattern)\fR" 4
.IX Xref "(?^:)"
.IX Item "(?^aluimsx:pattern)"
.PD
This is for clustering, not capturing; it groups subexpressions like
\&\*(L"()\*(R", but doesn't make backreferences as \*(L"()\*(R" does.  So
.Sp
.Vb 1
\&    @fields = split(/\eb(?:a|b|c)\eb/)
.Ve
.Sp
is like
.Sp
.Vb 1
\&    @fields = split(/\eb(a|b|c)\eb/)
.Ve
.Sp
but doesn't spit out extra fields.  It's also cheaper not to capture
characters if you don't need to.
.Sp
Any letters between \f(CW\*(C`?\*(C'\fR and \f(CW\*(C`:\*(C'\fR act as flags modifiers as with
\&\f(CW\*(C`(?adluimsx\-imsx)\*(C'\fR.  For example,
.Sp
.Vb 1
\&    /(?s\-i:more.*than).*million/i
.Ve
.Sp
is equivalent to the more verbose
.Sp
.Vb 1
\&    /(?:(?s\-i)more.*than).*million/i
.Ve
.Sp
Starting in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
after the \f(CW"?"\fR is a shorthand equivalent to \f(CW\*(C`d\-imsx\*(C'\fR.  Any positive
flags (except \f(CW"d"\fR) may follow the caret, so
.Sp
.Vb 1
\&    (?^x:foo)
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    (?x\-ims:foo)
.Ve
.Sp
The caret tells Perl that this cluster doesn't inherit the flags of any
surrounding pattern, but uses the system defaults (\f(CW\*(C`d\-imsx\*(C'\fR),
modified by any flags specified.
.Sp
The caret allows for simpler stringification of compiled regular
expressions.  These look like
.Sp
.Vb 1
\&    (?^:pattern)
.Ve
.Sp
with any non-default flags appearing between the caret and the colon.
A test that looks at such stringification thus doesn't need to have the
system default flags hard-coded in it, just the caret.  If new flags are
added to Perl, the meaning of the caret's expansion will change to include
the default for those flags, so the test will still work, unchanged.
.Sp
Specifying a negative flag after the caret is an error, as the flag is
redundant.
.Sp
Mnemonic for \f(CW\*(C`(?^...)\*(C'\fR:  A fresh beginning since the usual use of a caret is
to match at the beginning.
.ie n .IP """(?|pattern)""" 4
.el .IP "\f(CW(?|pattern)\fR" 4
.IX Xref "(?|) Branch reset"
.IX Item "(?|pattern)"
This is the \*(L"branch reset\*(R" pattern, which has the special property
that the capture groups are numbered from the same starting point
in each alternation branch. It is available starting from perl 5.10.0.
.Sp
Capture groups are numbered from left to right, but inside this
construct the numbering is restarted for each branch.
.Sp
The numbering within each branch will be as normal, and any groups
following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
groups in it.
.Sp
This construct is useful when you want to capture one of a
number of alternative matches.
.Sp
Consider the following pattern.  The numbers underneath show in
which group the captured content will be stored.
.Sp
.Vb 3
\&    # before  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-branch\-reset\-\-\-\-\-\-\-\-\-\-\- after        
\&    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
\&    # 1            2         2  3        2     3     4
.Ve
.Sp
Be careful when using the branch reset pattern in combination with 
named captures. Named captures are implemented as being aliases to 
numbered groups holding the captures, and that interferes with the
implementation of the branch reset pattern. If you are using named
captures in a branch reset pattern, it's best to use the same names,
in the same order, in each of the alternations:
.Sp
.Vb 2
\&   /(?|  (?<a> x ) (?<b> y )
\&      |  (?<a> z ) (?<b> w )) /x
.Ve
.Sp
Not doing so may lead to surprises:
.Sp
.Vb 3
\&  "12" =~ /(?| (?<a> \ed+ ) | (?<b> \eD+))/x;
\&  say $+ {a};   # Prints \*(Aq12\*(Aq
\&  say $+ {b};   # *Also* prints \*(Aq12\*(Aq.
.Ve
.Sp
The problem here is that both the group named \f(CW\*(C`a\*(C'\fR and the group
named \f(CW\*(C`b\*(C'\fR are aliases for the group belonging to \f(CW$1\fR.
.IP "Look-Around Assertions" 4
.IX Xref "look-around assertion lookaround assertion look-around lookaround"
.IX Item "Look-Around Assertions"
Look-around assertions are zero-width patterns which match a specific
pattern without including it in \f(CW$&\fR. Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.
.RS 4
.ie n .IP """(?=pattern)""" 4
.el .IP "\f(CW(?=pattern)\fR" 4
.IX Xref "(?=) look-ahead, positive lookahead, positive"
.IX Item "(?=pattern)"
A zero-width positive look-ahead assertion.  For example, \f(CW\*(C`/\ew+(?=\et)/\*(C'\fR
matches a word followed by a tab, without including the tab in \f(CW$&\fR.
.ie n .IP """(?!pattern)""" 4
.el .IP "\f(CW(?!pattern)\fR" 4
.IX Xref "(?!) look-ahead, negative lookahead, negative"
.IX Item "(?!pattern)"
A zero-width negative look-ahead assertion.  For example \f(CW\*(C`/foo(?!bar)/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" that isn't followed by \*(L"bar\*(R".  Note
however that look-ahead and look-behind are \s-1NOT\s0 the same thing.  You cannot
use this for look-behind.
.Sp
If you are looking for a \*(L"bar\*(R" that isn't preceded by a \*(L"foo\*(R", \f(CW\*(C`/(?!foo)bar/\*(C'\fR
will not do what you want.  That's because the \f(CW\*(C`(?!foo)\*(C'\fR is just saying that
the next thing cannot be \*(L"foo\*(R"\-\-and it's not, it's a \*(L"bar\*(R", so \*(L"foobar\*(R" will
match.  Use look-behind instead (see below).
.ie n .IP """(?<=pattern)"" ""\eK""" 4
.el .IP "\f(CW(?<=pattern)\fR \f(CW\eK\fR" 4
.IX Xref "(?<=) look-behind, positive lookbehind, positive \\K"
.IX Item "(?<=pattern) K"
A zero-width positive look-behind assertion.  For example, \f(CW\*(C`/(?<=\et)\ew+/\*(C'\fR
matches a word that follows a tab, without including the tab in \f(CW$&\fR.
Works only for fixed-width look-behind.
.Sp
There is a special form of this construct, called \f(CW\*(C`\eK\*(C'\fR, which causes the
regex engine to \*(L"keep\*(R" everything it had matched prior to the \f(CW\*(C`\eK\*(C'\fR and
not include it in \f(CW$&\fR. This effectively provides variable-length
look-behind. The use of \f(CW\*(C`\eK\*(C'\fR inside of another look-around assertion
is allowed, but the behaviour is currently not well defined.
.Sp
For various reasons \f(CW\*(C`\eK\*(C'\fR may be significantly more efficient than the
equivalent \f(CW\*(C`(?<=...)\*(C'\fR construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string. For instance
.Sp
.Vb 1
\&  s/(foo)bar/$1/g;
.Ve
.Sp
can be rewritten as the much more efficient
.Sp
.Vb 1
\&  s/foo\eKbar//g;
.Ve
.ie n .IP """(?<!pattern)""" 4
.el .IP "\f(CW(?<!pattern)\fR" 4
.IX Xref "(?<!) look-behind, negative lookbehind, negative"
.IX Item "(?<!pattern)"
A zero-width negative look-behind assertion.  For example \f(CW\*(C`/(?<!bar)foo/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" that does not follow \*(L"bar\*(R".  Works
only for fixed-width look-behind.
.RE
.RS 4
.RE
.ie n .IP """(?\*(AqNAME\*(Aqpattern)""" 4
.el .IP "\f(CW(?\*(AqNAME\*(Aqpattern)\fR" 4
.IX Item "(?NAMEpattern)"
.PD 0
.ie n .IP """(?<NAME>pattern)""" 4
.el .IP "\f(CW(?<NAME>pattern)\fR" 4
.IX Xref "(?<NAME>) (?'NAME') named capture capture"
.IX Item "(?<NAME>pattern)"
.PD
A named capture group. Identical in every respect to normal capturing
parentheses \f(CW\*(C`()\*(C'\fR but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like \f(CW\*(C`\eg{NAME}\*(C'\fR) and can be accessed by name
after a successful match via \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR. See perlvar
for more details on the \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR hashes.
.Sp
If multiple distinct capture groups have the same name then the
$+{\s-1NAME\s0} will refer to the leftmost defined group in the match.
.Sp
The forms \f(CW\*(C`(?\*(AqNAME\*(Aqpattern)\*(C'\fR and \f(CW\*(C`(?<NAME>pattern)\*(C'\fR are equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR While the notation of this construct is the same as the similar
function in .NET regexes, the behavior is not. In Perl the groups are
numbered sequentially regardless of being named or not. Thus in the
pattern
.Sp
.Vb 1
\&  /(x)(?<foo>y)(z)/
.Ve
.Sp
$+{foo} will be the same as \f(CW$2\fR, and \f(CW$3\fR will contain 'z' instead of
the opposite which is what a .NET regex hacker might expect.
.Sp
Currently \s-1NAME\s0 is restricted to simple identifiers only.
In other words, it must match \f(CW\*(C`/^[_A\-Za\-z][_A\-Za\-z0\-9]*\ez/\*(C'\fR or
its Unicode extension (see utf8),
though it isn't extended by the locale (see perllocale).
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines, the pattern \f(CW\*(C`(?P<NAME>pattern)\*(C'\fR
may be used instead of \f(CW\*(C`(?<NAME>pattern)\*(C'\fR; however this form does not
support the use of single quotes as a delimiter for the name.
.ie n .IP """\ek<NAME>""" 4
.el .IP "\f(CW\ek<NAME>\fR" 4
.IX Item "k<NAME>"
.PD 0
.ie n .IP """\ek\*(AqNAME\*(Aq""" 4
.el .IP "\f(CW\ek\*(AqNAME\*(Aq\fR" 4
.IX Item "kNAME"
.PD
Named backreference. Similar to numeric backreferences, except that
the group is designated by name and not number. If multiple groups
have the same name then it refers to the leftmost defined group in
the current match.
.Sp
It is an error to refer to a name not defined by a \f(CW\*(C`(?<NAME>)\*(C'\fR
earlier in the pattern.
.Sp
Both forms are equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines, the pattern \f(CW\*(C`(?P=NAME)\*(C'\fR
may be used instead of \f(CW\*(C`\ek<NAME>\*(C'\fR.
.ie n .IP """(?{ code })""" 4
.el .IP "\f(CW(?{ code })\fR" 4
.IX Xref "(?{}) regex, code in regexp, code in regular expression, code in"
.IX Item "(?{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.
.Sp
This zero-width assertion evaluates any embedded Perl code.  It
always succeeds, and its \f(CW\*(C`code\*(C'\fR is not interpolated.  Currently,
the rules to determine where the \f(CW\*(C`code\*(C'\fR ends are somewhat convoluted.
.Sp
This feature can be used together with the special variable \f(CW$^N\fR to
capture the results of submatches in variables without having to keep
track of the number of nested parentheses. For example:
.Sp
.Vb 3
\&  $_ = "The brown fox jumps over the lazy dog";
\&  /the (\eS+)(?{ $color = $^N }) (\eS+)(?{ $animal = $^N })/i;
\&  print "color = $color, animal = $animal\en";
.Ve
.Sp
Inside the \f(CW\*(C`(?{...})\*(C'\fR block, \f(CW$_\fR refers to the string the regular
expression is matching against. You can also use \f(CW\*(C`pos()\*(C'\fR to know what is
the current position of matching within this string.
.Sp
The \f(CW\*(C`code\*(C'\fR is properly scoped in the following sense: If the assertion
is backtracked (compare \*(L"Backtracking\*(R"), all changes introduced after
\&\f(CW\*(C`local\*(C'\fRization are undone, so that
.Sp
.Vb 10
\&  $_ = \*(Aqa\*(Aq x 8;
\&  m<
\&     (?{ $cnt = 0 })               # Initialize $cnt.
\&     (
\&       a
\&       (?{
\&           local $cnt = $cnt + 1;  # Update $cnt,
\&                                   # backtracking\-safe.
\&       })
\&     )*
\&     aaaa
\&     (?{ $res = $cnt })            # On success copy to
\&                                   # non\-localized location.
\&   >x;
.Ve
.Sp
will set \f(CW\*(C`$res = 4\*(C'\fR.  Note that after the match, \f(CW$cnt\fR returns to the globally
introduced value, because the scopes that restrict \f(CW\*(C`local\*(C'\fR operators
are unwound.
.Sp
This assertion may be used as a \f(CW\*(C`(?(condition)yes\-pattern|no\-pattern)\*(C'\fR
switch.  If \fInot\fR used in this way, the result of evaluation of
\&\f(CW\*(C`code\*(C'\fR is put into the special variable \f(CW$^R\fR.  This happens
immediately, so \f(CW$^R\fR can be used from other \f(CW\*(C`(?{ code })\*(C'\fR assertions
inside the same regular expression.
.Sp
The assignment to \f(CW$^R\fR above is properly localized, so the old
value of \f(CW$^R\fR is restored if the assertion is backtracked; compare
\&\*(L"Backtracking\*(R".
.Sp
For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR pragma has been used (see re), or the
variables contain results of the \f(CW\*(C`qr//\*(C'\fR operator (see
\&\*(L"qr/STRING/msixpodual\*(R" in perlop).
.Sp
This restriction is due to the wide-spread and remarkably convenient
custom of using run-time determined strings as patterns.  For example:
.Sp
.Vb 3
\&    $re = <>;
\&    chomp $re;
\&    $string =~ /$re/;
.Ve
.Sp
Before Perl knew how to execute interpolated code within a pattern,
this operation was completely safe from a security point of view,
although it could raise an exception from an illegal pattern.  If
you turn on the \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR, though, it is no longer secure,
so you should only do so if you are also using taint checking.
Better yet, use the carefully constrained evaluation within a Safe
compartment.  See perlsec for details about both these mechanisms.
.Sp
\&\fB\s-1WARNING\s0\fR: Use of lexical (\f(CW\*(C`my\*(C'\fR) variables in these blocks is
broken. The result is unpredictable and will make perl unstable. The
workaround is to use global (\f(CW\*(C`our\*(C'\fR) variables.
.Sp
\&\fB\s-1WARNING\s0\fR: In perl 5.12.x and earlier, the regex engine
was not re-entrant, so interpolated code could not
safely invoke the regex engine either directly with
\&\f(CW\*(C`m//\*(C'\fR or \f(CW\*(C`s///\*(C'\fR), or indirectly with functions such as
\&\f(CW\*(C`split\*(C'\fR. Invoking the regex engine in these blocks would make perl
unstable.
.ie n .IP """(??{ code })""" 4
.el .IP "\f(CW(??{ code })\fR" 4
.IX Xref "(??{}) regex, postponed regexp, postponed regular expression, postponed"
.IX Item "(??{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.
.Sp
This is a \*(L"postponed\*(R" regular subexpression.  The \f(CW\*(C`code\*(C'\fR is evaluated
at run time, at the moment this subexpression may match.  The result
of evaluation is considered a regular expression and matched as
if it were inserted instead of this construct.  Note that this means
that the contents of capture groups defined inside an eval'ed pattern
are not available outside of the pattern, and vice versa, there is no
way for the inner pattern returned from the code block to refer to a
capture group defined outside.  (The code block itself can use \f(CW$1\fR, etc.,
to refer to the enclosing pattern's capture groups.)  Thus,
.Sp
.Vb 1
\&    (\*(Aqa\*(Aq x 100)=~/(??{\*(Aq(.)\*(Aq x 100})/
.Ve
.Sp
\&\fBwill\fR match, it will \fBnot\fR set \f(CW$1\fR.
.Sp
The \f(CW\*(C`code\*(C'\fR is not interpolated.  As before, the rules to determine
where the \f(CW\*(C`code\*(C'\fR ends are currently somewhat convoluted.
.Sp
The following pattern matches a parenthesized group:
.Sp
.Vb 9
\& $re = qr{
\&            \e(
\&            (?:
\&               (?> [^()]+ )  # Non\-parens without backtracking
\&             |
\&               (??{ $re })   # Group with matching parens
\&            )*
\&            \e)
\&         }x;
.Ve
.Sp
See also \f(CW\*(C`(?PARNO)\*(C'\fR for a different, more efficient way to accomplish
the same task.
.Sp
For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR pragma has been used (see re), or the
variables contain results of the \f(CW\*(C`qr//\*(C'\fR operator (see
\&\*(L"qr/STRING/msixpodual\*(R" in perlop).
.Sp
In perl 5.12.x and earlier, because the regex engine was not re-entrant,
delayed code could not safely invoke the regex engine either directly with
\&\f(CW\*(C`m//\*(C'\fR or \f(CW\*(C`s///\*(C'\fR), or indirectly with functions such as \f(CW\*(C`split\*(C'\fR.
.Sp
Recursing deeper than 50 times without consuming any input string will
result in a fatal error.  The maximum depth is compiled into perl, so
changing it requires a custom build.
.ie n .IP """(?PARNO)"" ""(?\-PARNO)"" ""(?+PARNO)"" ""(?R)"" ""(?0)""" 4
.el .IP "\f(CW(?PARNO)\fR \f(CW(?\-PARNO)\fR \f(CW(?+PARNO)\fR \f(CW(?R)\fR \f(CW(?0)\fR" 4
.IX Xref "(?PARNO) (?1) (?R) (?0) (?-1) (?+1) (?-PARNO) (?+PARNO) regex, recursive regexp, recursive regular expression, recursive regex, relative recursion"
.IX Item "(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)"
Similar to \f(CW\*(C`(??{ code })\*(C'\fR except it does not involve compiling any code,
instead it treats the contents of a capture group as an independent
pattern that must match at the current position.  Capture groups
contained by the pattern will have the value as determined by the
outermost recursion.
.Sp
\&\s-1PARNO\s0 is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture group to recurse to. \f(CW\*(C`(?R)\*(C'\fR recurses to
the beginning of the whole pattern. \f(CW\*(C`(?0)\*(C'\fR is an alternate syntax for
\&\f(CW\*(C`(?R)\*(C'\fR. If \s-1PARNO\s0 is preceded by a plus or minus sign then it is assumed
to be relative, with negative numbers indicating preceding capture groups
and positive ones following. Thus \f(CW\*(C`(?\-1)\*(C'\fR refers to the most recently
declared group, and \f(CW\*(C`(?+1)\*(C'\fR indicates the next group to be declared.
Note that the counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed groups \fBare\fR
included.
.Sp
The following pattern matches a function \fIfoo()\fR which may contain
balanced parentheses as the argument.
.Sp
.Vb 10
\&  $re = qr{ (                   # paren group 1 (full function)
\&              foo
\&              (                 # paren group 2 (parens)
\&                \e(
\&                  (             # paren group 3 (contents of parens)
\&                  (?:
\&                   (?> [^()]+ ) # Non\-parens without backtracking
\&                  |
\&                   (?2)         # Recurse to start of paren group 2
\&                  )*
\&                  )
\&                \e)
\&              )
\&            )
\&          }x;
.Ve
.Sp
If the pattern was used as follows
.Sp
.Vb 4
\&    \*(Aqfoo(bar(baz)+baz(bop))\*(Aq=~/$re/
\&        and print "\e$1 = $1\en",
\&                  "\e$2 = $2\en",
\&                  "\e$3 = $3\en";
.Ve
.Sp
the output produced should be the following:
.Sp
.Vb 3
\&    $1 = foo(bar(baz)+baz(bop))
\&    $2 = (bar(baz)+baz(bop))
\&    $3 = bar(baz)+baz(bop)
.Ve
.Sp
If there is no corresponding capture group defined, then it is a
fatal error.  Recursing deeper than 50 times without consuming any input
string will also result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.
.Sp
The following shows how using negative indexing can make it
easier to embed recursive patterns inside of a \f(CW\*(C`qr//\*(C'\fR construct
for later use:
.Sp
.Vb 4
\&    my $parens = qr/(\e((?:[^()]++|(?\-1))*+\e))/;
\&    if (/foo $parens \es+ + \es+ bar $parens/x) {
\&       # do something here...
\&    }
.Ve
.Sp
\&\fBNote\fR that this pattern does not behave the same way as the equivalent
\&\s-1PCRE\s0 or Python construct of the same form. In Perl you can backtrack into
a recursed group, in \s-1PCRE\s0 and Python the recursed into group is treated
as atomic. Also, modifiers are resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will
be processed.
.ie n .IP """(?&NAME)""" 4
.el .IP "\f(CW(?&NAME)\fR" 4
.IX Xref "(?&NAME)"
.IX Item "(?&NAME)"
Recurse to a named subpattern. Identical to \f(CW\*(C`(?PARNO)\*(C'\fR except that the
parenthesis to recurse to is determined by name. If multiple parentheses have
the same name, then it recurses to the leftmost.
.Sp
It is an error to refer to a name that is not declared somewhere in the
pattern.
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines the pattern \f(CW\*(C`(?P>NAME)\*(C'\fR
may be used instead of \f(CW\*(C`(?&NAME)\*(C'\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Xref "(?()"
.IX Item "(?(condition)yes-pattern|no-pattern)"
.PD 0
.ie n .IP """(?(condition)yes\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern)"
.PD
Conditional expression. Matches \f(CW\*(C`yes\-pattern\*(C'\fR if \f(CW\*(C`condition\*(C'\fR yields
a true value, matches \f(CW\*(C`no\-pattern\*(C'\fR otherwise. A missing pattern always
matches.
.Sp
\&\f(CW\*(C`(condition)\*(C'\fR should be either an integer in
parentheses (which is valid if the corresponding pair of parentheses
matched), a look\-ahead/look\-behind/evaluate zero-width assertion, a
name in angle brackets or single quotes (which is valid if a group
with the given name matched), or the special symbol (R) (true when
evaluated inside of recursion or eval). Additionally the R may be
followed by a number, (which will be true when evaluated when recursing
inside of the appropriate group), or by \f(CW&NAME\fR, in which case it will
be true only when evaluated during recursion in the named group.
.Sp
Here's a summary of the possible predicates:
.RS 4
.IP "(1) (2) ..." 4
.IX Item "(1) (2) ..."
Checks if the numbered capturing group has matched something.
.IP "(<\s-1NAME\s0>) ('\s-1NAME\s0')" 4
.IX Item "(<NAME>) ('NAME')"
Checks if a group with the given name has matched something.
.IP "(?=...) (?!...) (?<=...) (?<!...)" 4
Checks whether the pattern matches (or does not match, for the '!'
variants).
.IP "(?{ \s-1CODE\s0 })" 4
.IX Item "(?{ CODE })"
Treats the return value of the code block as the condition.
.IP "(R)" 4
.IX Item "(R)"
Checks if the expression has been evaluated inside of recursion.
.IP "(R1) (R2) ..." 4
.IX Item "(R1) (R2) ..."
Checks if the expression has been evaluated while executing directly
inside of the n\-th capture group. This check is the regex equivalent of
.Sp
.Vb 1
\&  if ((caller(0))[3] eq \*(Aqsubname\*(Aq) { ... }
.Ve
.Sp
In other words, it does not check the full recursion stack.
.IP "(R&NAME)" 4
.IX Item "(R&NAME)"
Similar to \f(CW\*(C`(R1)\*(C'\fR, this predicate checks to see if we're executing
directly inside of the leftmost group with a given name (this is the same
logic used by \f(CW\*(C`(?&NAME)\*(C'\fR to disambiguate). It does not check the full
stack, but only the name of the innermost active recursion.
.IP "(\s-1DEFINE\s0)" 4
.IX Item "(DEFINE)"
In this case, the yes-pattern is never directly executed, and no
no-pattern is allowed. Similar in spirit to \f(CW\*(C`(?{0})\*(C'\fR but more efficient.
See below for details.
.RE
.RS 4
.Sp
For example:
.Sp
.Vb 4
\&    m{ ( \e( )?
\&       [^()]+
\&       (?(1) \e) )
\&     }x
.Ve
.Sp
matches a chunk of non-parentheses, possibly included in parentheses
themselves.
.Sp
A special form is the \f(CW\*(C`(DEFINE)\*(C'\fR predicate, which never executes its
yes-pattern directly, and does not allow a no-pattern. This allows one to
define subpatterns which will be executed only by the recursion mechanism.
This way, you can define a set of regular expression rules that can be
bundled into any pattern you choose.
.Sp
It is recommended that for this usage you put the \s-1DEFINE\s0 block at the
end of the pattern, and that you name any subpatterns defined within it.
.Sp
Also, it's worth noting that patterns defined this way probably will
not be as efficient, as the optimiser is not very clever about
handling them.
.Sp
An example of how this might be used is as follows:
.Sp
.Vb 5
\&  /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
\&   (?(DEFINE)
\&     (?<NAME_PAT>....)
\&     (?<ADRESS_PAT>....)
\&   )/x
.Ve
.Sp
Note that capture groups matched inside of recursion are not accessible
after the recursion returns, so the extra layer of capturing groups is
necessary. Thus \f(CW$+{NAME_PAT}\fR would not be defined even though
\&\f(CW$+{NAME}\fR would be.
.Sp
Finally, keep in mind that subpatterns created inside a \s-1DEFINE\s0 block
count towards the absolute and relative number of captures, so this:
.Sp
.Vb 5
\&    my @captures = "a" =~ /(.)                  # First capture
\&                           (?(DEFINE)
\&                               (?<EXAMPLE> 1 )  # Second capture
\&                           )/x;
\&    say scalar @captures;
.Ve
.Sp
Will output 2, not 1. This is particularly important if you intend to
compile the definitions with the \f(CW\*(C`qr//\*(C'\fR operator, and later
interpolate them in another pattern.
.RE
.ie n .IP """(?>pattern)""" 4
.el .IP "\f(CW(?>pattern)\fR" 4
.IX Xref "backtrack backtracking atomic possessive"
.IX Item "(?>pattern)"
An \*(L"independent\*(R" subexpression, one which matches the substring
that a \fIstandalone\fR \f(CW\*(C`pattern\*(C'\fR would match if anchored at the given
position, and it matches \fInothing other than this substring\fR.  This
construct is useful for optimizations of what would otherwise be
\&\*(L"eternal\*(R" matches, because it will not backtrack (see \*(L"Backtracking\*(R").
It may also be useful in places where the \*(L"grab all you can, and do not
give anything back\*(R" semantic is desirable.
.Sp
For example: \f(CW\*(C`^(?>a*)ab\*(C'\fR will never match, since \f(CW\*(C`(?>a*)\*(C'\fR
(anchored at the beginning of string, as above) will match \fIall\fR
characters \f(CW\*(C`a\*(C'\fR at the beginning of string, leaving no \f(CW\*(C`a\*(C'\fR for
\&\f(CW\*(C`ab\*(C'\fR to match.  In contrast, \f(CW\*(C`a*ab\*(C'\fR will match the same as \f(CW\*(C`a+b\*(C'\fR,
since the match of the subgroup \f(CW\*(C`a*\*(C'\fR is influenced by the following
group \f(CW\*(C`ab\*(C'\fR (see \*(L"Backtracking\*(R").  In particular, \f(CW\*(C`a*\*(C'\fR inside
\&\f(CW\*(C`a*ab\*(C'\fR will match fewer characters than a standalone \f(CW\*(C`a*\*(C'\fR, since
this makes the tail match.
.Sp
\&\f(CW\*(C`(?>pattern)\*(C'\fR does not disable backtracking altogether once it has
matched. It is still possible to backtrack past the construct, but not
into it. So \f(CW\*(C`((?>a*)|(?>b*))ar\*(C'\fR will still match \*(L"bar\*(R".
.Sp
An effect similar to \f(CW\*(C`(?>pattern)\*(C'\fR may be achieved by writing
\&\f(CW\*(C`(?=(pattern))\eg{\-1}\*(C'\fR.  This matches the same substring as a standalone
\&\f(CW\*(C`a+\*(C'\fR, and the following \f(CW\*(C`\eg{\-1}\*(C'\fR eats the matched string; it therefore
makes a zero-length assertion into an analogue of \f(CW\*(C`(?>...)\*(C'\fR.
(The difference between these two constructs is that the second one
uses a capturing group, thus shifting ordinals of backreferences
in the rest of a regular expression.)
.Sp
Consider this pattern:
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            [^()]+           # x+
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
That will efficiently match a nonempty group with matching parentheses
two levels deep or less.  However, if there is no such group, it
will take virtually forever on a long string.  That's because there
are so many different ways to split a long string into several
substrings.  This is what \f(CW\*(C`(.+)+\*(C'\fR is doing, and \f(CW\*(C`(.+)+\*(C'\fR is similar
to a subpattern of the above pattern.  Consider how the pattern
above detects no-match on \f(CW\*(C`((()aaaaaaaaaaaaaaaaaa\*(C'\fR in several
seconds, but that each extra letter doubles this time.  This
exponential performance will make it appear that your program has
hung.  However, a tiny change to this pattern
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            (?> [^()]+ )        # change x+ above to (?> x+ )
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
which uses \f(CW\*(C`(?>...)\*(C'\fR matches exactly when the one above does (verifying
this yourself would be a productive exercise), but finishes in a fourth
the time when used on a similar string with 1000000 \f(CW\*(C`a\*(C'\fRs.  Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the \f(CW\*(C`use warnings\*(C'\fR pragma or \fB\-w\fR switch saying it
\&\f(CW"matches null string many times in regex"\fR.
.Sp
On simple groups, such as the pattern \f(CW\*(C`(?> [^()]+ )\*(C'\fR, a comparable
effect may be achieved by negative look-ahead, as in \f(CW\*(C`[^()]+ (?! [^()] )\*(C'\fR.
This was only 4 times slower on a string with 1000000 \f(CW\*(C`a\*(C'\fRs.
.Sp
The \*(L"grab all you can, and do not give anything back\*(R" semantic is desirable
in many situations where on the first sight a simple \f(CW\*(C`()*\*(C'\fR looks like
the correct solution.  Suppose we parse text with comments being delimited
by \f(CW\*(C`#\*(C'\fR followed by some optional (horizontal) whitespace.  Contrary to
its appearance, \f(CW\*(C`#[ \et]*\*(C'\fR \fIis not\fR the correct subexpression to match
the comment delimiter, because it may \*(L"give up\*(R" some whitespace if
the remainder of the pattern can be made to match that way.  The correct
answer is either one of these:
.Sp
.Vb 2
\&    (?>#[ \et]*)
\&    #[ \et]*(?![ \et])
.Ve
.Sp
For example, to grab non-empty comments into \f(CW$1\fR, one should use either
one of these:
.Sp
.Vb 2
\&    / (?> \e# [ \et]* ) (        .+ ) /x;
\&    /     \e# [ \et]*   ( [^ \et] .* ) /x;
.Ve
.Sp
Which one you pick depends on which of these expressions better reflects
the above specification of comments.
.Sp
In some literature this construct is called \*(L"atomic matching\*(R" or
\&\*(L"possessive matching\*(R".
.Sp
Possessive quantifiers are equivalent to putting the item they are applied
to inside of one of these constructs. The following equivalences apply:
.Sp
.Vb 6
\&    Quantifier Form     Bracketing Form
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PAT*+               (?>PAT*)
\&    PAT++               (?>PAT+)
\&    PAT?+               (?>PAT?)
\&    PAT{min,max}+       (?>PAT{min,max})
.Ve
.SS "Special Backtracking Control Verbs"
.IX Subsection "Special Backtracking Control Verbs"
\&\fB\s-1WARNING:\s0\fR These patterns are experimental and subject to change or
removal in a future version of Perl. Their usage in production code should
be noted to avoid problems during upgrades.
.PP
These special patterns are generally of the form \f(CW\*(C`(*VERB:ARG)\*(C'\fR. Unless
otherwise stated the \s-1ARG\s0 argument is optional; in some cases, it is
forbidden.
.PP
Any pattern containing a special backtracking verb that allows an argument
has the special behaviour that when executed it sets the current package's
\&\f(CW$REGERROR\fR and \f(CW$REGMARK\fR variables. When doing so the following
rules apply:
.PP
On failure, the \f(CW$REGERROR\fR variable will be set to the \s-1ARG\s0 value of the
verb pattern, if the verb was involved in the failure of the match. If the
\&\s-1ARG\s0 part of the pattern was omitted, then \f(CW$REGERROR\fR will be set to the
name of the last \f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed, or to \s-1TRUE\s0 if there was
none. Also, the \f(CW$REGMARK\fR variable will be set to \s-1FALSE\s0.
.PP
On a successful match, the \f(CW$REGERROR\fR variable will be set to \s-1FALSE\s0, and
the \f(CW$REGMARK\fR variable will be set to the name of the last
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed.  See the explanation for the
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR verb below for more details.
.PP
\&\fB\s-1NOTE:\s0\fR \f(CW$REGERROR\fR and \f(CW$REGMARK\fR are not magic variables like \f(CW$1\fR
and most other regex-related variables. They are not local to a scope, nor
readonly, but instead are volatile package variables similar to \f(CW$AUTOLOAD\fR.
Use \f(CW\*(C`local\*(C'\fR to localize changes to them to a specific scope if necessary.
.PP
If a pattern does not contain a special backtracking verb that allows an
argument, then \f(CW$REGERROR\fR and \f(CW$REGMARK\fR are not touched at all.
.IP "Verbs that take an argument" 3
.IX Item "Verbs that take an argument"
.RS 3
.PD 0
.ie n .IP """(*PRUNE)"" ""(*PRUNE:NAME)""" 4
.el .IP "\f(CW(*PRUNE)\fR \f(CW(*PRUNE:NAME)\fR" 4
.IX Xref "(*PRUNE) (*PRUNE:NAME)"
.IX Item "(*PRUNE) (*PRUNE:NAME)"
.PD
This zero-width pattern prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern \f(CW\*(C`A (*PRUNE) B\*(C'\fR,
where A and B are complex patterns. Until the \f(CW\*(C`(*PRUNE)\*(C'\fR verb is reached,
A may backtrack as necessary to match. Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.
.Sp
The following example counts all the possible matching strings in a
pattern (without actually matching any of them).
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
which produces:
.Sp
.Vb 10
\&    aaab
\&    aaa
\&    aa
\&    a
\&    aab
\&    aa
\&    a
\&    ab
\&    a
\&    Count=9
.Ve
.Sp
If we add a \f(CW\*(C`(*PRUNE)\*(C'\fR before the count like the following
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(*PRUNE)(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
we prevent backtracking and find the count of the longest matching string
at each matching starting point like so:
.Sp
.Vb 4
\&    aaab
\&    aab
\&    ab
\&    Count=3
.Ve
.Sp
Any number of \f(CW\*(C`(*PRUNE)\*(C'\fR assertions may be used in a pattern.
.Sp
See also \f(CW\*(C`(?>pattern)\*(C'\fR and possessive quantifiers for other ways to
control backtracking. In some cases, the use of \f(CW\*(C`(*PRUNE)\*(C'\fR can be
replaced with a \f(CW\*(C`(?>pattern)\*(C'\fR with no functional difference; however,
\&\f(CW\*(C`(*PRUNE)\*(C'\fR can be used to handle cases that cannot be expressed using a
\&\f(CW\*(C`(?>pattern)\*(C'\fR alone.
.ie n .IP """(*SKIP)"" ""(*SKIP:NAME)""" 4
.el .IP "\f(CW(*SKIP)\fR \f(CW(*SKIP:NAME)\fR" 4
.IX Xref "(*SKIP)"
.IX Item "(*SKIP) (*SKIP:NAME)"
This zero-width pattern is similar to \f(CW\*(C`(*PRUNE)\*(C'\fR, except that on
failure it also signifies that whatever text that was matched leading up
to the \f(CW\*(C`(*SKIP)\*(C'\fR pattern being executed cannot be part of \fIany\fR match
of this pattern. This effectively means that the regex engine \*(L"skips\*(R" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).
.Sp
The name of the \f(CW\*(C`(*SKIP:NAME)\*(C'\fR pattern has special significance. If a
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR was encountered while matching, then it is that position
which is used as the \*(L"skip point\*(R". If no \f(CW\*(C`(*MARK)\*(C'\fR of that name was
encountered, then the \f(CW\*(C`(*SKIP)\*(C'\fR operator has no effect. When used
without a name the \*(L"skip point\*(R" is where the match point was when
executing the (*SKIP) pattern.
.Sp
Compare the following to the examples in \f(CW\*(C`(*PRUNE)\*(C'\fR; note the string
is twice as long:
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*SKIP)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 3
\&    aaab
\&    aaab
\&    Count=2
.Ve
.Sp
Once the 'aaab' at the start of the string has matched, and the \f(CW\*(C`(*SKIP)\*(C'\fR
executed, the next starting point will be where the cursor was when the
\&\f(CW\*(C`(*SKIP)\*(C'\fR was executed.
.ie n .IP """(*MARK:NAME)"" ""(*:NAME)""" 4
.el .IP "\f(CW(*MARK:NAME)\fR \f(CW(*:NAME)\fR" 4
.IX Xref "(*MARK) (*MARK:NAME) (*:NAME)"
.IX Item "(*MARK:NAME) (*:NAME)"
This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later \f(CW\*(C`(*SKIP)\*(C'\fR pattern will then skip
forward to that point if backtracked into on failure. Any number of
\&\f(CW\*(C`(*MARK)\*(C'\fR patterns are allowed, and the \s-1NAME\s0 portion may be duplicated.
.Sp
In addition to interacting with the \f(CW\*(C`(*SKIP)\*(C'\fR pattern, \f(CW\*(C`(*MARK:NAME)\*(C'\fR
can be used to \*(L"label\*(R" a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.
.Sp
When a match is successful, the \f(CW$REGMARK\fR variable will be set to the
name of the most recently executed \f(CW\*(C`(*MARK:NAME)\*(C'\fR that was involved
in the match.
.Sp
This can be used to determine which branch of a pattern was matched
without using a separate capture group for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
\&\f(CW\*(C`/(?:(x)|(y)|(z))/\*(C'\fR as efficiently as something like
\&\f(CW\*(C`/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/\*(C'\fR.
.Sp
When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the \f(CW$REGERROR\fR
variable will be set to the name of the most recently executed
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR.
.Sp
See \*(L"(*SKIP)\*(R" for more details.
.Sp
As a shortcut \f(CW\*(C`(*MARK:NAME)\*(C'\fR can be written \f(CW\*(C`(*:NAME)\*(C'\fR.
.ie n .IP """(*THEN)"" ""(*THEN:NAME)""" 4
.el .IP "\f(CW(*THEN)\fR \f(CW(*THEN:NAME)\fR" 4
.IX Item "(*THEN) (*THEN:NAME)"
This is similar to the \*(L"cut group\*(R" operator \f(CW\*(C`::\*(C'\fR from Perl 6.  Like
\&\f(CW\*(C`(*PRUNE)\*(C'\fR, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise) that has alternations.
The two branches of a \f(CW\*(C`(?(condition)yes\-pattern|no\-pattern)\*(C'\fR do not
count as an alternation, as far as \f(CW\*(C`(*THEN)\*(C'\fR is concerned.
.Sp
Its name comes from the observation that this operation combined with the
alternation operator (\f(CW\*(C`|\*(C'\fR) can be used to create what is essentially a
pattern-based if/then/else block:
.Sp
.Vb 1
\&  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )
.Ve
.Sp
Note that if this operator is used and \s-1NOT\s0 inside of an alternation then
it acts exactly like the \f(CW\*(C`(*PRUNE)\*(C'\fR operator.
.Sp
.Vb 1
\&  / A (*PRUNE) B /
.Ve
.Sp
is the same as
.Sp
.Vb 1
\&  / A (*THEN) B /
.Ve
.Sp
but
.Sp
.Vb 1
\&  / ( A (*THEN) B | C (*THEN) D ) /
.Ve
.Sp
is not the same as
.Sp
.Vb 1
\&  / ( A (*PRUNE) B | C (*PRUNE) D ) /
.Ve
.Sp
as after matching the A but failing on the B the \f(CW\*(C`(*THEN)\*(C'\fR verb will
backtrack and try C; but the \f(CW\*(C`(*PRUNE)\*(C'\fR verb will simply fail.
.RE
.RS 3
.RE
.IP "Verbs without an argument" 3
.IX Item "Verbs without an argument"
.RS 3
.PD 0
.ie n .IP """(*COMMIT)""" 4
.el .IP "\f(CW(*COMMIT)\fR" 4
.IX Xref "(*COMMIT)"
.IX Item "(*COMMIT)"
.PD
This is the Perl 6 \*(L"commit pattern\*(R" \f(CW\*(C`<commit>\*(C'\fR or \f(CW\*(C`:::\*(C'\fR. It's a
zero-width pattern similar to \f(CW\*(C`(*SKIP)\*(C'\fR, except that when backtracked
into on failure it causes the match to fail outright. No further attempts
to find a valid match by advancing the start pointer will occur again.
For example,
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*COMMIT)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 2
\&    aaab
\&    Count=1
.Ve
.Sp
In other words, once the \f(CW\*(C`(*COMMIT)\*(C'\fR has been entered, and if the pattern
does not match, the regex engine will not try any further matching on the
rest of the string.
.ie n .IP """(*FAIL)"" ""(*F)""" 4
.el .IP "\f(CW(*FAIL)\fR \f(CW(*F)\fR" 4
.IX Xref "(*FAIL) (*F)"
.IX Item "(*FAIL) (*F)"
This pattern matches nothing and always fails. It can be used to force the
engine to backtrack. It is equivalent to \f(CW\*(C`(?!)\*(C'\fR, but easier to read. In
fact, \f(CW\*(C`(?!)\*(C'\fR gets optimised into \f(CW\*(C`(*FAIL)\*(C'\fR internally.
.Sp
It is probably useful only when combined with \f(CW\*(C`(?{})\*(C'\fR or \f(CW\*(C`(??{})\*(C'\fR.
.ie n .IP """(*ACCEPT)""" 4
.el .IP "\f(CW(*ACCEPT)\fR" 4
.IX Xref "(*ACCEPT)"
.IX Item "(*ACCEPT)"
\&\fB\s-1WARNING:\s0\fR This feature is highly experimental. It is not recommended
for production code.
.Sp
This pattern matches nothing and causes the end of successful matching at
the point at which the \f(CW\*(C`(*ACCEPT)\*(C'\fR pattern was encountered, regardless of
whether there is actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via \f(CW\*(C`(??{})\*(C'\fR, only the innermost pattern is ended immediately.
.Sp
If the \f(CW\*(C`(*ACCEPT)\*(C'\fR is inside of capturing groups then the groups are
marked as ended at the point at which the \f(CW\*(C`(*ACCEPT)\*(C'\fR was encountered.
For instance:
.Sp
.Vb 1
\&  \*(AqAB\*(Aq =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;
.Ve
.Sp
will match, and \f(CW$1\fR will be \f(CW\*(C`AB\*(C'\fR and \f(CW$2\fR will be \f(CW\*(C`B\*(C'\fR, \f(CW$3\fR will not
be set. If another branch in the inner parentheses was matched, such as in the
string '\s-1ACDE\s0', then the \f(CW\*(C`D\*(C'\fR and \f(CW\*(C`E\*(C'\fR would have to be matched as well.
.RE
.RS 3
.RE
.SS "Backtracking"
.IX Xref "backtrack backtracking"
.IX Subsection "Backtracking"
\&\s-1NOTE:\s0 This section presents an abstract approximation of regular
expression behavior.  For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see \*(L"Combining \s-1RE\s0 Pieces\*(R".
.PP
A fundamental feature of regular expression matching involves the
notion called \fIbacktracking\fR, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}\*(C'\fR, and \f(CW\*(C`{n,m}?\*(C'\fR.  Backtracking is often optimized
internally, but the general principle outlined here is valid.
.PP
For a regular expression to match, the \fIentire\fR regular expression must
match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part\*(--that's why it's called backtracking.
.PP
Here is an example of backtracking:  Let's say you want to find the
word following \*(L"foo\*(R" in the string \*(L"Food is on the foo table.\*(R":
.PP
.Vb 4
\&    $_ = "Food is on the foo table.";
\&    if ( /\eb(foo)\es+(\ew+)/i ) {
\&        print "$2 follows $1.\en";
\&    }
.Ve
.PP
When the match runs, the first part of the regular expression (\f(CW\*(C`\eb(foo)\*(C'\fR)
finds a possible match right at the beginning of the string, and loads up
\&\f(CW$1\fR with \*(L"Foo\*(R".  However, as soon as the matching engine sees that there's
no whitespace following the \*(L"Foo\*(R" that it had saved in \f(CW$1\fR, it realizes its
mistake and starts over again one character after where it had the
tentative match.  This time it goes all the way until the next occurrence
of \*(L"foo\*(R". The complete regular expression matches this time, and you get
the expected output of \*(L"table follows foo.\*(R"
.PP
Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between \*(L"foo\*(R" and \*(L"bar\*(R".  Initially, you write something
like this:
.PP
.Vb 4
\&    $_ =  "The food is under the bar in the barn.";
\&    if ( /foo(.*)bar/ ) {
\&        print "got <$1>\en";
\&    }
.Ve
.PP
Which perhaps unexpectedly yields:
.PP
.Vb 1
\&  got <d is under the bar in the >
.Ve
.PP
That's because \f(CW\*(C`.*\*(C'\fR was greedy, so you get everything between the
\&\fIfirst\fR \*(L"foo\*(R" and the \fIlast\fR \*(L"bar\*(R".  Here it's more effective
to use minimal matching to make sure you get the text between a \*(L"foo\*(R"
and the first \*(L"bar\*(R" thereafter.
.PP
.Vb 2
\&    if ( /foo(.*?)bar/ ) { print "got <$1>\en" }
\&  got <d is under the >
.Ve
.PP
Here's another example. Let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part of the match.
So you write this:
.PP
.Vb 4
\&    $_ = "I have 2 numbers: 53147";
\&    if ( /(.*)(\ed*)/ ) {                                # Wrong!
\&        print "Beginning is <$1>, number is <$2>.\en";
\&    }
.Ve
.PP
That won't work at all, because \f(CW\*(C`.*\*(C'\fR was greedy and gobbled up the
whole string. As \f(CW\*(C`\ed*\*(C'\fR can match on an empty string the complete
regular expression matched successfully.
.PP
.Vb 1
\&    Beginning is <I have 2 numbers: 53147>, number is <>.
.Ve
.PP
Here are some variants, most of which don't work:
.PP
.Vb 11
\&    $_ = "I have 2 numbers: 53147";
\&    @pats = qw{
\&        (.*)(\ed*)
\&        (.*)(\ed+)
\&        (.*?)(\ed*)
\&        (.*?)(\ed+)
\&        (.*)(\ed+)$
\&        (.*?)(\ed+)$
\&        (.*)\eb(\ed+)$
\&        (.*\eD)(\ed+)$
\&    };
\&
\&    for $pat (@pats) {
\&        printf "%\-12s ", $pat;
\&        if ( /$pat/ ) {
\&            print "<$1> <$2>\en";
\&        } else {
\&            print "FAIL\en";
\&        }
\&    }
.Ve
.PP
That will print out:
.PP
.Vb 8
\&    (.*)(\ed*)    <I have 2 numbers: 53147> <>
\&    (.*)(\ed+)    <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed*)   <> <>
\&    (.*?)(\ed+)   <I have > <2>
\&    (.*)(\ed+)$   <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed+)$  <I have 2 numbers: > <53147>
\&    (.*)\eb(\ed+)$ <I have 2 numbers: > <53147>
\&    (.*\eD)(\ed+)$ <I have 2 numbers: > <53147>
.Ve
.PP
As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.
.PP
When using look-ahead assertions and negations, this can all get even
trickier.  Imagine you'd like to find a sequence of non-digits not
followed by \*(L"123\*(R".  You might try to write that as
.PP
.Vb 4
\&    $_ = "ABC123";
\&    if ( /^\eD*(?!123)/ ) {                # Wrong!
\&        print "Yup, no 123 in $_\en";
\&    }
.Ve
.PP
But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why that pattern matches, contrary to popular expectations:
.PP
.Vb 2
\&    $x = \*(AqABC123\*(Aq;
\&    $y = \*(AqABC445\*(Aq;
\&
\&    print "1: got $1\en" if $x =~ /^(ABC)(?!123)/;
\&    print "2: got $1\en" if $y =~ /^(ABC)(?!123)/;
\&
\&    print "3: got $1\en" if $x =~ /^(\eD*)(?!123)/;
\&    print "4: got $1\en" if $y =~ /^(\eD*)(?!123)/;
.Ve
.PP
This prints
.PP
.Vb 3
\&    2: got ABC
\&    3: got AB
\&    4: got ABC
.Ve
.PP
You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (\f(CW\*(C`\eD*\*(C'\fR) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked \*(L"Is it true that at the start of \f(CW$x\fR, following 0 or more
non-digits, you have something that's not 123?\*(R"  If the pattern matcher had
let \f(CW\*(C`\eD*\*(C'\fR expand to \*(L"\s-1ABC\s0\*(R", this would have caused the whole pattern to
fail.
.PP
The search engine will initially match \f(CW\*(C`\eD*\*(C'\fR with \*(L"\s-1ABC\s0\*(R".  Then it will
try to match \f(CW\*(C`(?!123)\*(C'\fR with \*(L"123\*(R", which fails.  But because
a quantifier (\f(CW\*(C`\eD*\*(C'\fR) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.
.PP
The pattern really, \fIreally\fR wants to succeed, so it uses the
standard pattern back-off-and-retry and lets \f(CW\*(C`\eD*\*(C'\fR expand to just \*(L"\s-1AB\s0\*(R" this
time.  Now there's indeed something following \*(L"\s-1AB\s0\*(R" that is not
\&\*(L"123\*(R".  It's \*(L"C123\*(R", which suffices.
.PP
We can deal with this by using both an assertion and a negation.
We'll say that the first part in \f(CW$1\fR must be followed both by a digit
and by something that's not \*(L"123\*(R".  Remember that the look-aheads
are zero-width expressions\*(--they only look, but don't consume any
of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:
.PP
.Vb 2
\&    print "5: got $1\en" if $x =~ /^(\eD*)(?=\ed)(?!123)/;
\&    print "6: got $1\en" if $y =~ /^(\eD*)(?=\ed)(?!123)/;
\&
\&    6: got ABC
.Ve
.PP
In other words, the two zero-width assertions next to each other work as though
they're ANDed together, just as you'd use any built-in assertions:  \f(CW\*(C`/^$/\*(C'\fR
matches only if you're at the beginning of the line \s-1AND\s0 the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means \s-1AND\s0, except when you write an explicit \s-1OR\s0
using the vertical bar.  \f(CW\*(C`/ab/\*(C'\fR means match \*(L"a\*(R" \s-1AND\s0 (then) match \*(L"b\*(R",
although the attempted matches are made at different positions because \*(L"a\*(R"
is not a zero-width assertion, but a one-width assertion.
.PP
\&\fB\s-1WARNING\s0\fR: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.  For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:
.PP
.Vb 1
\&    \*(Aqaaaaaaaaaaaa\*(Aq =~ /((a{0,5}){0,5})*[c]/
.Ve
.PP
And if you used \f(CW\*(C`*\*(C'\fR's in the internal groups instead of limiting them
to 0 through 5 matches, then it would take forever\*(--or until you ran
out of stack space.  Moreover, these internal optimizations are not
always applicable.  For example, if you put \f(CW\*(C`{0,5}\*(C'\fR instead of \f(CW\*(C`*\*(C'\fR
on the external group, no current optimization is applicable, and the
match takes a long time to finish.
.PP
A powerful tool for optimizing such beasts is what is known as an
\&\*(L"independent group\*(R",
which does not backtrack (see "\f(CW\*(C`(?>pattern)\*(C'\fR").  Note also that
zero-length look\-ahead/look\-behind assertions will not backtrack to make
the tail match, since they are in \*(L"logical\*(R" context: only
whether they match is considered relevant.  For an example
where side-effects of look-ahead \fImight\fR have influenced the
following match, see "\f(CW\*(C`(?>pattern)\*(C'\fR".
.SS "Version 8 Regular Expressions"
.IX Xref "regular expression, version 8 regex, version 8 regexp, version 8"
.IX Subsection "Version 8 Regular Expressions"
In case you're not familiar with the \*(L"regular\*(R" Version 8 regex
routines, here are the pattern-matching rules not described above.
.PP
Any single character matches itself, unless it is a \fImetacharacter\fR
with a special meaning described here or above.  You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a \*(L"\e\*(R" (e.g., \*(L"\e.\*(R" matches a \*(L".\*(R", not any
character; \*(L"\e\e\*(R" matches a \*(L"\e\*(R"). This escape mechanism is also required
for the character used as the pattern delimiter.
.PP
A series of characters matches that series of characters in the target
string, so the pattern \f(CW\*(C`blurfl\*(C'\fR would match \*(L"blurfl\*(R" in the target
string.
.PP
You can specify a character class, by enclosing a list of characters
in \f(CW\*(C`[]\*(C'\fR, which will match any character from the list.  If the
first character after the \*(L"[\*(R" is \*(L"^\*(R", the class matches any character not
in the list.  Within a list, the \*(L"\-\*(R" character specifies a
range, so that \f(CW\*(C`a\-z\*(C'\fR represents all characters between \*(L"a\*(R" and \*(L"z\*(R",
inclusive.  If you want either \*(L"\-\*(R" or \*(L"]\*(R" itself to be a member of a
class, put it at the start of the list (possibly after a \*(L"^\*(R"), or
escape it with a backslash.  \*(L"\-\*(R" is also taken literally when it is
at the end of the list, just before the closing \*(L"]\*(R".  (The
following all specify the same class of three characters: \f(CW\*(C`[\-az]\*(C'\fR,
\&\f(CW\*(C`[az\-]\*(C'\fR, and \f(CW\*(C`[a\e\-z]\*(C'\fR.  All are different from \f(CW\*(C`[a\-z]\*(C'\fR, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, or \f(CW\*(C`\eD\*(C'\fR as endpoints of
a range, the \*(L"\-\*(R" is understood literally.
.PP
Note also that the whole range idea is rather unportable between
character sets\*(--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a\-e],
[A\-E]), or digits ([0\-9]).  Anything else is unsafe.  If in doubt,
spell out the character sets in full.
.PP
Characters may be specified using a metacharacter syntax much like that
used in C: \*(L"\en\*(R" matches a newline, \*(L"\et\*(R" a tab, \*(L"\er\*(R" a carriage return,
\&\*(L"\ef\*(R" a form feed, etc.  More generally, \e\fInnn\fR, where \fInnn\fR is a string
of three octal digits, matches the character whose coded character set value
is \fInnn\fR.  Similarly, \ex\fInn\fR, where \fInn\fR are hexadecimal digits,
matches the character whose ordinal is \fInn\fR. The expression \ec\fIx\fR
matches the character control\-\fIx\fR.  Finally, the \*(L".\*(R" metacharacter
matches any character except \*(L"\en\*(R" (unless you use \f(CW\*(C`/s\*(C'\fR).
.PP
You can specify a series of alternatives for a pattern using \*(L"|\*(R" to
separate them, so that \f(CW\*(C`fee|fie|foe\*(C'\fR will match any of \*(L"fee\*(R", \*(L"fie\*(R",
or \*(L"foe\*(R" in the target string (as would \f(CW\*(C`f(e|i|o)e\*(C'\fR).  The
first alternative includes everything from the last pattern delimiter
(\*(L"(\*(R", \*(L"(?:\*(R", etc. or the beginning of the pattern) up to the first \*(L"|\*(R", and
the last alternative contains everything from the last \*(L"|\*(R" to the next
closing pattern delimiter.  That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.
.PP
Alternatives are tried from left to right, so the first
alternative found for which the entire expression matches, is the one that
is chosen. This means that alternatives are not necessarily greedy. For
example: when matching \f(CW\*(C`foo|foot\*(C'\fR against \*(L"barefoot\*(R", only the \*(L"foo\*(R"
part will match, as that is the first alternative tried, and it successfully
matches the target string. (This might not seem important, but it is
important when you are capturing matched text using parentheses.)
.PP
Also remember that \*(L"|\*(R" is interpreted as a literal within square brackets,
so if you write \f(CW\*(C`[fee|fie|foe]\*(C'\fR you're really only matching \f(CW\*(C`[feio|]\*(C'\fR.
.PP
Within a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to the
\&\fIn\fRth subpattern later in the pattern using the metacharacter
\&\e\fIn\fR or \eg\fIn\fR.  Subpatterns are numbered based on the left to right order
of their opening parenthesis.  A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.  Therefore, \f(CW\*(C`(0|0x)\ed*\es\eg1\ed*\*(C'\fR will
match \*(L"0x1234 0x4321\*(R", but not \*(L"0x1234 01234\*(R", because subpattern
1 matched \*(L"0x\*(R", even though the rule \f(CW\*(C`0|0x\*(C'\fR could potentially match
the leading 0 in the second number.
.ie n .SS "Warning on \e1 Instead of $1"
.el .SS "Warning on \e1 Instead of \f(CW$1\fP"
.IX Subsection "Warning on 1 Instead of $1"
Some people get too used to writing things like:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e\e1/g;
.Ve
.PP
This is grandfathered (for \e1 to \e9) for the \s-1RHS\s0 of a substitute to avoid
shocking the
\&\fBsed\fR addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of an \f(CW\*(C`s///\*(C'\fR is a double-quoted string.  \f(CW\*(C`\e1\*(C'\fR in
the usual double-quoted string means a control-A.  The customary Unix
meaning of \f(CW\*(C`\e1\*(C'\fR is kludged in for \f(CW\*(C`s///\*(C'\fR.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an \f(CW\*(C`/e\*(C'\fR
modifier.
.PP
.Vb 1
\&    s/(\ed+)/ \e1 + 1 /eg;            # causes warning under \-w
.Ve
.PP
Or if you try to do
.PP
.Vb 1
\&    s/(\ed+)/\e1000/;
.Ve
.PP
You can't disambiguate that by saying \f(CW\*(C`\e{1}000\*(C'\fR, whereas you can fix it with
\&\f(CW\*(C`${1}000\*(C'\fR.  The operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the \fIleft\fR side of the \f(CW\*(C`s///\*(C'\fR.
.SS "Repeated Patterns Matching a Zero-length Substring"
.IX Subsection "Repeated Patterns Matching a Zero-length Substring"
\&\fB\s-1WARNING\s0\fR: Difficult material (and prose) ahead.  This section needs a rewrite.
.PP
Regular expressions provide a terse and powerful programming language.  As
with most other power tools, power comes together with the ability
to wreak havoc.
.PP
A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:
.PP
.Vb 1
\&    \*(Aqfoo\*(Aq =~ m{ ( o? )* }x;
.Ve
.PP
The \f(CW\*(C`o?\*(C'\fR matches at the beginning of \f(CW\*(Aqfoo\*(Aq\fR, and since the position
in the string is not moved by the match, \f(CW\*(C`o?\*(C'\fR would match again and again
because of the \f(CW\*(C`*\*(C'\fR quantifier.  Another common way to create a similar cycle
is with the looping modifier \f(CW\*(C`//g\*(C'\fR:
.PP
.Vb 1
\&    @matches = ( \*(Aqfoo\*(Aq =~ m{ o? }xg );
.Ve
.PP
or
.PP
.Vb 1
\&    print "match: <$&>\en" while \*(Aqfoo\*(Aq =~ m{ o? }xg;
.Ve
.PP
or the loop implied by \fIsplit()\fR.
.PP
However, long experience has shown that many programming tasks may
be significantly simplified by using repeated subexpressions that
may match zero-length substrings.  Here's a simple example being:
.PP
.Vb 2
\&    @chars = split //, $string;           # // is not magic in split
\&    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /
.Ve
.PP
Thus Perl allows such constructs, by \fIforcefully breaking
the infinite loop\fR.  The rules for this are different for lower-level
loops given by the greedy quantifiers \f(CW\*(C`*+{}\*(C'\fR, and for higher-level
ones like the \f(CW\*(C`/g\*(C'\fR modifier or \fIsplit()\fR operator.
.PP
The lower-level loops are \fIinterrupted\fR (that is, the loop is
broken) when Perl detects that a repeated expression matched a
zero-length substring.   Thus
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
.Ve
.PP
is made equivalent to
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;
.Ve
.PP
For example, this program
.PP
.Vb 12
\&   #!perl \-l
\&   "aaaaab" =~ /
\&     (?:
\&        a                 # non\-zero
\&        |                 # or
\&       (?{print "hello"}) # print hello whenever this
\&                          #    branch is tried
\&       (?=(b))            # zero\-width assertion
\&     )*  # any number of times
\&    /x;
\&   print $&;
\&   print $1;
.Ve
.PP
prints
.PP
.Vb 3
\&   hello
\&   aaaaa
\&   b
.Ve
.PP
Notice that \*(L"hello\*(R" is only printed once, as when Perl sees that the sixth
iteration of the outermost \f(CW\*(C`(?:)*\*(C'\fR matches a zero-length string, it stops
the \f(CW\*(C`*\*(C'\fR.
.PP
The higher-level loops preserve an additional state between iterations:
whether the last match was zero-length.  To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.
This prohibition interacts with backtracking (see \*(L"Backtracking\*(R"),
and so the \fIsecond best\fR match is chosen if the \fIbest\fR match is of
zero length.
.PP
For example:
.PP
.Vb 2
\&    $_ = \*(Aqbar\*(Aq;
\&    s/\ew??/<$&>/g;
.Ve
.PP
results in \f(CW\*(C`<><b><><a><><r><>\*(C'\fR.  At each position of the string the best
match given by non-greedy \f(CW\*(C`??\*(C'\fR is the zero-length match, and the \fIsecond
best\fR match is what is matched by \f(CW\*(C`\ew\*(C'\fR.  Thus zero-length matches
alternate with one-character-long matches.
.PP
Similarly, for repeated \f(CW\*(C`m/()/g\*(C'\fR the second-best match is the match at the
position one notch further in the string.
.PP
The additional state of being \fImatched with zero-length\fR is associated with
the matched string, and is reset by each assignment to \fIpos()\fR.
Zero-length matches at the end of the previous match are ignored
during \f(CW\*(C`split\*(C'\fR.
.SS "Combining \s-1RE\s0 Pieces"
.IX Subsection "Combining RE Pieces"
Each of the elementary pieces of regular expressions which were described
before (such as \f(CW\*(C`ab\*(C'\fR or \f(CW\*(C`\eZ\*(C'\fR) could match at most one substring
at the given position of the input string.  However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators \f(CW\*(C`ST\*(C'\fR, \f(CW\*(C`S|T\*(C'\fR, \f(CW\*(C`S*\*(C'\fR etc.
(in these examples \f(CW\*(C`S\*(C'\fR and \f(CW\*(C`T\*(C'\fR are regular subexpressions).
.PP
Such combinations can include alternatives, leading to a problem of choice:
if we match a regular expression \f(CW\*(C`a|ab\*(C'\fR against \f(CW"abc"\fR, will it match
substring \f(CW"a"\fR or \f(CW"ab"\fR?  One way to describe which substring is
actually matched is the concept of backtracking (see \*(L"Backtracking\*(R").
However, this description is too low-level and makes you think
in terms of a particular implementation.
.PP
Another description starts with notions of \*(L"better\*(R"/\*(L"worse\*(R".  All the
substrings which may be matched by the given regular expression can be
sorted from the \*(L"best\*(R" match to the \*(L"worst\*(R" match, and it is the \*(L"best\*(R"
match which is chosen.  This substitutes the question of \*(L"what is chosen?\*(R"
by the question of \*(L"which matches are better, and which are worse?\*(R".
.PP
Again, for elementary pieces there is no such question, since at most
one match at a given position is possible.  This section describes the
notion of better/worse for combining operators.  In the description
below \f(CW\*(C`S\*(C'\fR and \f(CW\*(C`T\*(C'\fR are regular subexpressions.
.ie n .IP """ST""" 4
.el .IP "\f(CWST\fR" 4
.IX Item "ST"
Consider two possible matches, \f(CW\*(C`AB\*(C'\fR and \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR, \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`A\*(Aq\*(C'\fR are
substrings which can be matched by \f(CW\*(C`S\*(C'\fR, \f(CW\*(C`B\*(C'\fR and \f(CW\*(C`B\*(Aq\*(C'\fR are substrings
which can be matched by \f(CW\*(C`T\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR is a better match for \f(CW\*(C`S\*(C'\fR than \f(CW\*(C`A\*(Aq\*(C'\fR, \f(CW\*(C`AB\*(C'\fR is a better
match than \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`A\*(Aq\*(C'\fR coincide: \f(CW\*(C`AB\*(C'\fR is a better match than \f(CW\*(C`AB\*(Aq\*(C'\fR if
\&\f(CW\*(C`B\*(C'\fR is a better match for \f(CW\*(C`T\*(C'\fR than \f(CW\*(C`B\*(Aq\*(C'\fR.
.ie n .IP """S|T""" 4
.el .IP "\f(CWS|T\fR" 4
.IX Item "S|T"
When \f(CW\*(C`S\*(C'\fR can match, it is a better match than when only \f(CW\*(C`T\*(C'\fR can match.
.Sp
Ordering of two matches for \f(CW\*(C`S\*(C'\fR is the same as for \f(CW\*(C`S\*(C'\fR.  Similar for
two matches for \f(CW\*(C`T\*(C'\fR.
.ie n .IP """S{REPEAT_COUNT}""" 4
.el .IP "\f(CWS{REPEAT_COUNT}\fR" 4
.IX Item "S{REPEAT_COUNT}"
Matches as \f(CW\*(C`SSS...S\*(C'\fR (repeated as many times as necessary).
.ie n .IP """S{min,max}""" 4
.el .IP "\f(CWS{min,max}\fR" 4
.IX Item "S{min,max}"
Matches as \f(CW\*(C`S{max}|S{max\-1}|...|S{min+1}|S{min}\*(C'\fR.
.ie n .IP """S{min,max}?""" 4
.el .IP "\f(CWS{min,max}?\fR" 4
.IX Item "S{min,max}?"
Matches as \f(CW\*(C`S{min}|S{min+1}|...|S{max\-1}|S{max}\*(C'\fR.
.ie n .IP """S?"", ""S*"", ""S+""" 4
.el .IP "\f(CWS?\fR, \f(CWS*\fR, \f(CWS+\fR" 4
.IX Item "S?, S*, S+"
Same as \f(CW\*(C`S{0,1}\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}\*(C'\fR respectively.
.ie n .IP """S??"", ""S*?"", ""S+?""" 4
.el .IP "\f(CWS??\fR, \f(CWS*?\fR, \f(CWS+?\fR" 4
.IX Item "S??, S*?, S+?"
Same as \f(CW\*(C`S{0,1}?\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}?\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}?\*(C'\fR respectively.
.ie n .IP """(?>S)""" 4
.el .IP "\f(CW(?>S)\fR" 4
.IX Item "(?>S)"
Matches the best match for \f(CW\*(C`S\*(C'\fR and only that.
.ie n .IP """(?=S)"", ""(?<=S)""" 4
.el .IP "\f(CW(?=S)\fR, \f(CW(?<=S)\fR" 4
.IX Item "(?=S), (?<=S)"
Only the best match for \f(CW\*(C`S\*(C'\fR is considered.  (This is important only if
\&\f(CW\*(C`S\*(C'\fR has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)
.ie n .IP """(?!S)"", ""(?<!S)""" 4
.el .IP "\f(CW(?!S)\fR, \f(CW(?<!S)\fR" 4
.IX Item "(?!S), (?<!S)"
For this grouping operator there is no need to describe the ordering, since
only whether or not \f(CW\*(C`S\*(C'\fR can match is important.
.ie n .IP """(??{ EXPR })"", ""(?PARNO)""" 4
.el .IP "\f(CW(??{ EXPR })\fR, \f(CW(?PARNO)\fR" 4
.IX Item "(??{ EXPR }), (?PARNO)"
The ordering is the same as for the regular expression which is
the result of \s-1EXPR\s0, or the pattern contained by capture group \s-1PARNO\s0.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern|no-pattern)"
Recall that which of \f(CW\*(C`yes\-pattern\*(C'\fR or \f(CW\*(C`no\-pattern\*(C'\fR actually matches is
already determined.  The ordering of the matches is the same as for the
chosen subexpression.
.PP
The above recipes describe the ordering of matches \fIat a given position\fR.
One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.
.SS "Creating Custom \s-1RE\s0 Engines"
.IX Subsection "Creating Custom RE Engines"
As of Perl 5.10.0, one can create custom regular expression engines.  This
is not for the faint of heart, as they have to plug in at the C level.  See
perlreapi for more details.
.PP
As an alternative, overloaded constants (see overload) provide a simple
way to extend the functionality of the \s-1RE\s0 engine, by substituting one
pattern for another.
.PP
Suppose that we want to enable a new \s-1RE\s0 escape-sequence \f(CW\*(C`\eY|\*(C'\fR which
matches at a boundary between whitespace characters and non-whitespace
characters.  Note that \f(CW\*(C`(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)\*(C'\fR matches exactly
at these positions, so we want to have each \f(CW\*(C`\eY|\*(C'\fR in the place of the
more complicated version.  We can create a module \f(CW\*(C`customre\*(C'\fR to do
this:
.PP
.Vb 2
\&    package customre;
\&    use overload;
\&
\&    sub import {
\&      shift;
\&      die "No argument to customre::import allowed" if @_;
\&      overload::constant \*(Aqqr\*(Aq => \e&convert;
\&    }
\&
\&    sub invalid { die "/$_[0]/: invalid escape \*(Aq\e\e$_[1]\*(Aq"}
\&
\&    # We must also take care of not escaping the legitimate \e\eY|
\&    # sequence, hence the presence of \*(Aq\e\e\*(Aq in the conversion rules.
\&    my %rules = ( \*(Aq\e\e\*(Aq => \*(Aq\e\e\e\e\*(Aq,
\&                  \*(AqY|\*(Aq => qr/(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)/ );
\&    sub convert {
\&      my $re = shift;
\&      $re =~ s{
\&                \e\e ( \e\e | Y . )
\&              }
\&              { $rules{$1} or invalid($re,$1) }sgex;
\&      return $re;
\&    }
.Ve
.PP
Now \f(CW\*(C`use customre\*(C'\fR enables the new escape in constant regular
expressions, i.e., those without any runtime variable interpolations.
As documented in overload, this conversion will work only over
literal parts of regular expressions.  For \f(CW\*(C`\eY|$re\eY|\*(C'\fR the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of \f(CW\*(C`\eY|\*(C'\fR should be enabled inside \f(CW$re\fR):
.PP
.Vb 5
\&    use customre;
\&    $re = <>;
\&    chomp $re;
\&    $re = customre::convert $re;
\&    /\eY|$re\eY|/;
.Ve
.SS "PCRE/Python Support"
.IX Subsection "PCRE/Python Support"
As of Perl 5.10.0, Perl supports several Python/PCRE\-specific extensions
to the regex syntax. While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted:
.ie n .IP """(?P<NAME>pattern)""" 4
.el .IP "\f(CW(?P<NAME>pattern)\fR" 4
.IX Item "(?P<NAME>pattern)"
Define a named capture group. Equivalent to \f(CW\*(C`(?<NAME>pattern)\*(C'\fR.
.ie n .IP """(?P=NAME)""" 4
.el .IP "\f(CW(?P=NAME)\fR" 4
.IX Item "(?P=NAME)"
Backreference to a named capture group. Equivalent to \f(CW\*(C`\eg{NAME}\*(C'\fR.
.ie n .IP """(?P>NAME)""" 4
.el .IP "\f(CW(?P>NAME)\fR" 4
.IX Item "(?P>NAME)"
Subroutine call to a named capture group. Equivalent to \f(CW\*(C`(?&NAME)\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Many regular expression constructs don't work on \s-1EBCDIC\s0 platforms.
.PP
There are a number of issues with regard to case-insensitive matching
in Unicode rules.  See \f(CW\*(C`i\*(C'\fR under \*(L"Modifiers\*(R" above.
.PP
This document varies from difficult to understand to completely
and utterly opaque.  The wandering prose riddled with jargon is
hard to fathom in several places.
.PP
This document needs a rewrite that separates the tutorial content
from the reference content.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlrequick.
.PP
perlretut.
.PP
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop.
.PP
\&\*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.PP
perlfaq6.
.PP
\&\*(L"pos\*(R" in perlfunc.
.PP
perllocale.
.PP
perlebcdic.
.PP
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl, published
by O'Reilly and Associates.
                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlre5.18.1                                 0100644 0001750 0001750 00000370126 12566207443 022557  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRE 1"
.TH PERLRE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlre \- Perl regular expressions
.IX Xref "regular expression regex regexp"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page describes the syntax of regular expressions in Perl.
.PP
If you haven't used regular expressions before, a quick-start
introduction is available in perlrequick, and a longer tutorial
introduction is available in perlretut.
.PP
For reference on how regular expressions are used in matching
operations, plus various examples of the same, see discussions of
\&\f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR and \f(CW\*(C`??\*(C'\fR in \*(L"Regexp Quote-Like
Operators\*(R" in perlop.
.SS "Modifiers"
.IX Subsection "Modifiers"
Matching operations can have various modifiers.  Modifiers
that relate to the interpretation of the regular expression inside
are listed below.  Modifiers that alter the way a regular expression
is used by Perl are detailed in \*(L"Regexp Quote-Like Operators\*(R" in perlop and
\&\*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.IP "m" 4
.IX Xref " m regex, multiline regexp, multiline regular expression, multiline"
.IX Item "m"
Treat string as multiple lines.  That is, change \*(L"^\*(R" and \*(L"$\*(R" from matching
the start or end of line only at the left and right ends of the string to
matching them anywhere within the string.
.IP "s" 4
.IX Xref " s regex, single-line regexp, single-line regular expression, single-line"
.IX Item "s"
Treat string as single line.  That is, change \*(L".\*(R" to match any character
whatsoever, even a newline, which normally it would not match.
.Sp
Used together, as \f(CW\*(C`/ms\*(C'\fR, they let the \*(L".\*(R" match any character whatsoever,
while still allowing \*(L"^\*(R" and \*(L"$\*(R" to match, respectively, just after
and just before newlines within the string.
.IP "i" 4
.IX Xref " i regex, case-insensitive regexp, case-insensitive regular expression, case-insensitive"
.IX Item "i"
Do case-insensitive pattern matching.
.Sp
If locale matching rules are in effect, the case map is taken from the
current
locale for code points less than 255, and from Unicode rules for larger
code points.  However, matches that would cross the Unicode
rules/non\-Unicode rules boundary (ords 255/256) will not succeed.  See
perllocale.
.Sp
There are a number of Unicode characters that match multiple characters
under \f(CW\*(C`/i\*(C'\fR.  For example, \f(CW\*(C`LATIN SMALL LIGATURE FI\*(C'\fR
should match the sequence \f(CW\*(C`fi\*(C'\fR.  Perl is not
currently able to do this when the multiple characters are in the pattern and
are split between groupings, or when one or more are quantified.  Thus
.Sp
.Vb 3
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi/i;          # Matches
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /[fi][fi]/i;    # Doesn\*(Aqt match!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi*/i;         # Doesn\*(Aqt match!
\&
\& # The below doesn\*(Aqt match, and it isn\*(Aqt clear what $1 and $2 would
\& # be even if it did!!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /(f)(i)/i;      # Doesn\*(Aqt match!
.Ve
.Sp
Perl doesn't match multiple characters in a bracketed
character class unless the character that maps to them is explicitly
mentioned, and it doesn't match them at all if the character class is
inverted, which otherwise could be highly confusing.  See
\&\*(L"Bracketed Character Classes\*(R" in perlrecharclass, and
\&\*(L"Negation\*(R" in perlrecharclass.
.IP "x" 4
.IX Xref " x"
.IX Item "x"
Extend your pattern's legibility by permitting whitespace and comments.
Details in \*(L"/x\*(R"
.IP "p" 4
.IX Xref " p regex, preserve regexp, preserve"
.IX Item "p"
Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and
${^POSTMATCH} are available for use after matching.
.IP "g and c" 4
.IX Xref " g c"
.IX Item "g and c"
Global matching, and keep the Current position after failed matching.
Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself. See
\&\*(L"Using regular expressions in Perl\*(R" in perlretut for further explanation
of the g and c modifiers.
.IP "a, d, l and u" 4
.IX Xref " a d l u"
.IX Item "a, d, l and u"
These modifiers, all new in 5.14, affect which character-set semantics
(Unicode, etc.) are used, as described below in
\&\*(L"Character set modifiers\*(R".
.PP
Regular expression modifiers are usually written in documentation
as e.g., "the \f(CW\*(C`/x\*(C'\fR modifier", even though the delimiter
in question might not really be a slash.  The modifiers \f(CW\*(C`/imsxadlup\*(C'\fR
may also be embedded within the regular expression itself using
the \f(CW\*(C`(?...)\*(C'\fR construct, see \*(L"Extended Patterns\*(R" below.
.PP
\fI/x\fR
.IX Subsection "/x"
.PP
\&\f(CW\*(C`/x\*(C'\fR tells
the regular expression parser to ignore most whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The \f(CW\*(C`#\*(C'\fR
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or \f(CW\*(C`#\*(C'\fR characters in the pattern (outside a character
class, where they are unaffected by \f(CW\*(C`/x\*(C'\fR), then you'll either have to
escape them (using backslashes or \f(CW\*(C`\eQ...\eE\*(C'\fR) or encode them using octal,
hex, or \f(CW\*(C`\eN{}\*(C'\fR escapes.  Taken together, these features go a long way towards
making Perl's regular expressions more readable.  Note that you have to
be careful not to include the pattern delimiter in the comment\*(--perl has
no way of knowing you did not intend to close the pattern early.  See
the C\-comment deletion code in perlop.  Also note that anything inside
a \f(CW\*(C`\eQ...\eE\*(C'\fR stays unaffected by \f(CW\*(C`/x\*(C'\fR.  And note that \f(CW\*(C`/x\*(C'\fR doesn't affect
space interpretation within a single multi-character construct.  For
example in \f(CW\*(C`\ex{...}\*(C'\fR, regardless of the \f(CW\*(C`/x\*(C'\fR modifier, there can be no
spaces.  Same for a quantifier such as \f(CW\*(C`{3}\*(C'\fR or
\&\f(CW\*(C`{5,}\*(C'\fR.  Similarly, \f(CW\*(C`(?:...)\*(C'\fR can't have a space between the \f(CW\*(C`(\*(C'\fR,
\&\f(CW\*(C`?\*(C'\fR, and \f(CW\*(C`:\*(C'\fR.  Within any delimiters for such a
construct, allowed spaces are not affected by \f(CW\*(C`/x\*(C'\fR, and depend on the
construct.  For example, \f(CW\*(C`\ex{...}\*(C'\fR can't have spaces because hexadecimal
numbers don't have spaces in them.  But, Unicode properties can have spaces, so
in \f(CW\*(C`\ep{...}\*(C'\fR there can be spaces that follow the Unicode rules, for which see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops.
.IX Xref " x"
.PP
\fICharacter set modifiers\fR
.IX Subsection "Character set modifiers"
.PP
\&\f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, \f(CW\*(C`/a\*(C'\fR, and \f(CW\*(C`/l\*(C'\fR, available starting in 5.14, are called
the character set modifiers; they affect the character set semantics
used for the regular expression.
.PP
The \f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, and \f(CW\*(C`/l\*(C'\fR modifiers are not likely to be of much use
to you, and so you need not worry about them very much.  They exist for
Perl's internal use, so that complex regular expression data structures
can be automatically serialized and later exactly reconstituted,
including all their nuances.  But, since Perl can't keep a secret, and
there may be rare instances where they are useful, they are documented
here.
.PP
The \f(CW\*(C`/a\*(C'\fR modifier, on the other hand, may be useful.  Its purpose is to
allow code that is to work mostly on \s-1ASCII\s0 data to not have to concern
itself with Unicode.
.PP
Briefly, \f(CW\*(C`/l\*(C'\fR sets the character set to that of whatever \fBL\fRocale is in
effect at the time of the execution of the pattern match.
.PP
\&\f(CW\*(C`/u\*(C'\fR sets the character set to \fBU\fRnicode.
.PP
\&\f(CW\*(C`/a\*(C'\fR also sets the character set to Unicode, \s-1BUT\s0 adds several
restrictions for \fBA\fRSCII-safe matching.
.PP
\&\f(CW\*(C`/d\*(C'\fR is the old, problematic, pre\-5.14 \fBD\fRefault character set
behavior.  Its only use is to force that old behavior.
.PP
At any given time, exactly one of these modifiers is in effect.  Their
existence allows Perl to keep the originally compiled behavior of a
regular expression, regardless of what rules are in effect when it is
actually executed.  And if it is interpolated into a larger regex, the
original's rules continue to apply to it, and only it.
.PP
The \f(CW\*(C`/l\*(C'\fR and \f(CW\*(C`/u\*(C'\fR modifiers are automatically selected for
regular expressions compiled within the scope of various pragmas,
and we recommend that in general, you use those pragmas instead of
specifying these modifiers explicitly.  For one thing, the modifiers
affect only pattern matching, and do not extend to even any replacement
done, whereas using the pragmas give consistent results for all
appropriate operations within their scopes.  For example,
.PP
.Vb 1
\& s/foo/\eUbar/il
.Ve
.PP
will match \*(L"foo\*(R" using the locale's rules for case-insensitive matching,
but the \f(CW\*(C`/l\*(C'\fR does not affect how the \f(CW\*(C`\eU\*(C'\fR operates.  Most likely you
want both of them to use locale rules.  To do this, instead compile the
regular expression within the scope of \f(CW\*(C`use locale\*(C'\fR.  This both
implicitly adds the \f(CW\*(C`/l\*(C'\fR and applies locale rules to the \f(CW\*(C`\eU\*(C'\fR.   The
lesson is to \f(CW\*(C`use locale\*(C'\fR and not \f(CW\*(C`/l\*(C'\fR explicitly.
.PP
Similarly, it would be better to use \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR
instead of,
.PP
.Vb 1
\& s/foo/\eLbar/iu
.Ve
.PP
to get Unicode rules, as the \f(CW\*(C`\eL\*(C'\fR in the former (but not necessarily
the latter) would also use Unicode rules.
.PP
More detail on each of the modifiers follows.  Most likely you don't
need to know this detail for \f(CW\*(C`/l\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, and \f(CW\*(C`/d\*(C'\fR, and can skip ahead
to /a.
.PP
/l
.IX Subsection "/l"
.PP
means to use the current locale's rules (see perllocale) when pattern
matching.  For example, \f(CW\*(C`\ew\*(C'\fR will match the \*(L"word\*(R" characters of that
locale, and \f(CW"/i"\fR case-insensitive matching will match according to
the locale's case folding rules.  The locale used will be the one in
effect at the time of execution of the pattern match.  This may not be
the same as the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
\&\fIsetlocale()\fR function.
.PP
Perl only supports single-byte locales.  This means that code points
above 255 are treated as Unicode no matter what locale is in effect.
Under Unicode rules, there are a few case-insensitive matches that cross
the 255/256 boundary.  These are disallowed under \f(CW\*(C`/l\*(C'\fR.  For example,
0xFF (on \s-1ASCII\s0 platforms) does not caselessly match the character at
0x178, \f(CW\*(C`LATIN CAPITAL LETTER Y WITH DIAERESIS\*(C'\fR, because 0xFF may not be
\&\f(CW\*(C`LATIN SMALL LETTER Y WITH DIAERESIS\*(C'\fR in the current locale, and Perl
has no way of knowing if that character even exists in the locale, much
less what code point it is.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use locale\*(C'\fR, but
see \*(L"Which character set modifier is in effect?\*(R".
.IX Xref " l"
.PP
/u
.IX Subsection "/u"
.PP
means to use Unicode rules when pattern matching.  On \s-1ASCII\s0 platforms,
this means that the code points between 128 and 255 take on their
Latin\-1 (\s-1ISO\-8859\-1\s0) meanings (which are the same as Unicode's).
(Otherwise Perl considers their meanings to be undefined.)  Thus,
under this modifier, the \s-1ASCII\s0 platform effectively becomes a Unicode
platform; and hence, for example, \f(CW\*(C`\ew\*(C'\fR will match any of the more than
100_000 word characters in Unicode.
.PP
Unlike most locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters \fIsomewhere\fR in
the world as
\&\f(CW\*(C`\ew\*(C'\fR.  For example, your locale might not think that \f(CW\*(C`LATIN SMALL
LETTER ETH\*(C'\fR is a letter (unless you happen to speak Icelandic), but
Unicode does.  Similarly, all the characters that are decimal digits
somewhere in the world will match \f(CW\*(C`\ed\*(C'\fR; this is hundreds, not 10,
possible matches.  And some of those digits look like some of the 10
\&\s-1ASCII\s0 digits, but mean a different number, so a human could easily think
a number is a different quantity than it really is.  For example,
\&\f(CW\*(C`BENGALI DIGIT FOUR\*(C'\fR (U+09EA) looks very much like an
\&\f(CW\*(C`ASCII DIGIT EIGHT\*(C'\fR (U+0038).  And, \f(CW\*(C`\ed+\*(C'\fR, may match strings of digits
that are a mixture from different writing systems, creating a security
issue.  \*(L"\fInum()\fR\*(R" in Unicode::UCD can be used to sort
this out.  Or the \f(CW\*(C`/a\*(C'\fR modifier can be used to force \f(CW\*(C`\ed\*(C'\fR to match
just the \s-1ASCII 0\s0 through 9.
.PP
Also, under this modifier, case-insensitive matching works on the full
set of Unicode
characters.  The \f(CW\*(C`KELVIN SIGN\*(C'\fR, for example matches the letters \*(L"k\*(R" and
\&\*(L"K\*(R"; and \f(CW\*(C`LATIN SMALL LIGATURE FF\*(C'\fR matches the sequence \*(L"ff\*(R", which,
if you're not prepared, might make it look like a hexadecimal constant,
presenting another potential security issue.  See
<http://unicode.org/reports/tr36> for a detailed discussion of Unicode
security issues.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use feature
\&\*(Aqunicode_strings\*(C'\fR, \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher),
but see \*(L"Which character set modifier is in effect?\*(R".
.IX Xref " u"
.PP
/d
.IX Subsection "/d"
.PP
This modifier means to use the \*(L"Default\*(R" native rules of the platform
except when there is cause to use Unicode rules instead, as follows:
.IP "1." 4
the target string is encoded in \s-1UTF\-8\s0; or
.IP "2." 4
the pattern is encoded in \s-1UTF\-8\s0; or
.IP "3." 4
the pattern explicitly mentions a code point that is above 255 (say by
\&\f(CW\*(C`\ex{100}\*(C'\fR); or
.IP "4." 4
the pattern uses a Unicode name (\f(CW\*(C`\eN{...}\*(C'\fR);  or
.IP "5." 4
the pattern uses a Unicode property (\f(CW\*(C`\ep{...}\*(C'\fR); or
.IP "6." 4
the pattern uses "\f(CW\*(C`(?[ ])\*(C'\fR"
.PP
Another mnemonic for this modifier is \*(L"Depends\*(R", as the rules actually
used depend on various things, and as a result you can get unexpected
results.  See \*(L"The \*(R"Unicode Bug"" in perlunicode.  The Unicode Bug has
become rather infamous, leading to yet another (printable) name for this
modifier, \*(L"Dodgy\*(R".
.PP
Unless the pattern or string are encoded in \s-1UTF\-8,\s0 only \s-1ASCII\s0 characters
can match positively.
.PP
Here are some examples of how that works on an \s-1ASCII\s0 platform:
.PP
.Vb 6
\& $str =  "\exDF";      # $str is not in UTF\-8 format.
\& $str =~ /^\ew/;       # No match, as $str isn\*(Aqt in UTF\-8 format.
\& $str .= "\ex{0e0b}";  # Now $str is in UTF\-8 format.
\& $str =~ /^\ew/;       # Match! $str is now in UTF\-8 format.
\& chop $str;
\& $str =~ /^\ew/;       # Still a match! $str remains in UTF\-8 format.
.Ve
.PP
This modifier is automatically selected by default when none of the
others are, so yet another name for it is \*(L"Default\*(R".
.PP
Because of the unexpected behaviors associated with this modifier, you
probably should only use it to maintain weird backward compatibilities.
.PP
/a (and /aa)
.IX Subsection "/a (and /aa)"
.PP
This modifier stands for ASCII-restrict (or ASCII-safe).  This modifier,
unlike the others, may be doubled-up to increase its effect.
.PP
When it appears singly, it causes the sequences \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and
the Posix character classes to match only in the \s-1ASCII\s0 range.  They thus
revert to their pre\-5.6, pre-Unicode meanings.  Under \f(CW\*(C`/a\*(C'\fR,  \f(CW\*(C`\ed\*(C'\fR
always means precisely the digits \f(CW"0"\fR to \f(CW"9"\fR; \f(CW\*(C`\es\*(C'\fR means the five
characters \f(CW\*(C`[ \ef\en\er\et]\*(C'\fR, and starting in Perl v5.18, experimentally,
the vertical tab; \f(CW\*(C`\ew\*(C'\fR means the 63 characters
\&\f(CW\*(C`[A\-Za\-z0\-9_]\*(C'\fR; and likewise, all the Posix classes such as
\&\f(CW\*(C`[[:print:]]\*(C'\fR match only the appropriate ASCII-range characters.
.PP
This modifier is useful for people who only incidentally use Unicode,
and who do not wish to be burdened with its complexities and security
concerns.
.PP
With \f(CW\*(C`/a\*(C'\fR, one can write \f(CW\*(C`\ed\*(C'\fR with confidence that it will only match
\&\s-1ASCII\s0 characters, and should the need arise to match beyond \s-1ASCII,\s0 you
can instead use \f(CW\*(C`\ep{Digit}\*(C'\fR (or \f(CW\*(C`\ep{Word}\*(C'\fR for \f(CW\*(C`\ew\*(C'\fR).  There are
similar \f(CW\*(C`\ep{...}\*(C'\fR constructs that can match beyond \s-1ASCII\s0 both white
space (see \*(L"Whitespace\*(R" in perlrecharclass), and Posix classes (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass).  Thus, this modifier
doesn't mean you can't use Unicode, it means that to get Unicode
matching you must explicitly use a construct (\f(CW\*(C`\ep{}\*(C'\fR, \f(CW\*(C`\eP{}\*(C'\fR) that
signals Unicode.
.PP
As you would expect, this modifier causes, for example, \f(CW\*(C`\eD\*(C'\fR to mean
the same thing as \f(CW\*(C`[^0\-9]\*(C'\fR; in fact, all non-ASCII characters match
\&\f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, and \f(CW\*(C`\eW\*(C'\fR.  \f(CW\*(C`\eb\*(C'\fR still means to match at the boundary
between \f(CW\*(C`\ew\*(C'\fR and \f(CW\*(C`\eW\*(C'\fR, using the \f(CW\*(C`/a\*(C'\fR definitions of them (similarly
for \f(CW\*(C`\eB\*(C'\fR).
.PP
Otherwise, \f(CW\*(C`/a\*(C'\fR behaves like the \f(CW\*(C`/u\*(C'\fR modifier, in that
case-insensitive matching uses Unicode semantics; for example, \*(L"k\*(R" will
match the Unicode \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching, and code
points in the Latin1 range, above \s-1ASCII\s0 will have Unicode rules when it
comes to case-insensitive matching.
.PP
To forbid ASCII/non\-ASCII matches (like \*(L"k\*(R" with \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR),
specify the \*(L"a\*(R" twice, for example \f(CW\*(C`/aai\*(C'\fR or \f(CW\*(C`/aia\*(C'\fR.  (The first
occurrence of \*(L"a\*(R" restricts the \f(CW\*(C`\ed\*(C'\fR, etc., and the second occurrence
adds the \f(CW\*(C`/i\*(C'\fR restrictions.)  But, note that code points outside the
\&\s-1ASCII\s0 range will use Unicode rules for \f(CW\*(C`/i\*(C'\fR matching, so the modifier
doesn't really restrict things to just \s-1ASCII\s0; it just forbids the
intermixing of \s-1ASCII\s0 and non-ASCII.
.PP
To summarize, this modifier provides protection for applications that
don't wish to be exposed to all of Unicode.  Specifying it twice
gives added protection.
.PP
This modifier may be specified to be the default by \f(CW\*(C`use re \*(Aq/a\*(Aq\*(C'\fR
or \f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR.  If you do so, you may actually have occasion to use
the \f(CW\*(C`/u\*(C'\fR modifier explictly if there are a few regular expressions
where you do want full Unicode rules (but even here, it's best if
everything were under feature \f(CW"unicode_strings"\fR, along with the
\&\f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR).  Also see \*(L"Which character set modifier is in
effect?\*(R".
.IX Xref " a aa"
.PP
Which character set modifier is in effect?
.IX Subsection "Which character set modifier is in effect?"
.PP
Which of these modifiers is in effect at any given point in a regular
expression depends on a fairly complex set of interactions.  These have
been designed so that in general you don't have to worry about it, but
this section gives the gory details.  As
explained below in \*(L"Extended Patterns\*(R" it is possible to explicitly
specify modifiers that apply only to portions of a regular expression.
The innermost always has priority over any outer ones, and one applying
to the whole expression has priority over any of the default settings that are
described in the remainder of this section.
.PP
The \f(CW\*(C`use re \*(Aq/foo\*(Aq\*(C'\fR pragma can be used to set
default modifiers (including these) for regular expressions compiled
within its scope.  This pragma has precedence over the other pragmas
listed below that also change the defaults.
.PP
Otherwise, \f(CW\*(C`use locale\*(C'\fR sets the default modifier to \f(CW\*(C`/l\*(C'\fR;
and \f(CW\*(C`use feature \*(Aqunicode_strings\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher) set the default to
\&\f(CW\*(C`/u\*(C'\fR when not in the same scope as either \f(CW\*(C`use locale\*(C'\fR
or \f(CW\*(C`use bytes\*(C'\fR.
(\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR also
sets the default to \f(CW\*(C`/u\*(C'\fR, overriding any plain \f(CW\*(C`use locale\*(C'\fR.)
Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern matching, and so
give more consistent results with other operators, including using
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, etc. in substitution replacements.
.PP
If none of the above apply, for backwards compatibility reasons, the
\&\f(CW\*(C`/d\*(C'\fR modifier is the one in effect by default.  As this can lead to
unexpected results, it is best to specify which other rule set should be
used.
.PP
Character set modifier behavior prior to Perl 5.14
.IX Subsection "Character set modifier behavior prior to Perl 5.14"
.PP
Prior to 5.14, there were no explicit modifiers, but \f(CW\*(C`/l\*(C'\fR was implied
for regexes compiled within the scope of \f(CW\*(C`use locale\*(C'\fR, and \f(CW\*(C`/d\*(C'\fR was
implied otherwise.  However, interpolating a regex into a larger regex
would ignore the original compilation in favor of whatever was in effect
at the time of the second compilation.  There were a number of
inconsistencies (bugs) with the \f(CW\*(C`/d\*(C'\fR modifier, where Unicode rules
would be used when inappropriate, and vice versa.  \f(CW\*(C`\ep{}\*(C'\fR did not imply
Unicode rules, and neither did all occurrences of \f(CW\*(C`\eN{}\*(C'\fR, until 5.12.
.SS "Regular Expressions"
.IX Subsection "Regular Expressions"
\fIMetacharacters\fR
.IX Subsection "Metacharacters"
.PP
The patterns used in Perl pattern matching evolved from those supplied in
the Version 8 regex routines.  (The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See \*(L"Version 8 Regular Expressions\*(R" for
details.
.PP
In particular the following metacharacters have their standard \fIegrep\fR\-ish
meanings:
.IX Xref "metacharacter \\ ^ . $ | ( () [ []"
.PP
.Vb 7
\&    \e        Quote the next metacharacter
\&    ^        Match the beginning of the line
\&    .        Match any character (except newline)
\&    $        Match the end of the line (or before newline at the end)
\&    |        Alternation
\&    ()       Grouping
\&    []       Bracketed Character class
.Ve
.PP
By default, the \*(L"^\*(R" character is guaranteed to match only the
beginning of the string, the \*(L"$\*(R" character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by \*(L"^\*(R" or \*(L"$\*(R".  You may, however, wish to treat a
string as a multi-line buffer, such that the \*(L"^\*(R" will match after any
newline within the string (except if the newline is the last character in
the string), and \*(L"$\*(R" will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting \f(CW$*\fR,
but this option was removed in perl 5.10.)
.IX Xref "^ $ m"
.PP
To simplify multi-line substitutions, the \*(L".\*(R" character never matches a
newline unless you use the \f(CW\*(C`/s\*(C'\fR modifier, which in effect tells Perl to pretend
the string is a single line\*(--even if it isn't.
.IX Xref ". s"
.PP
\fIQuantifiers\fR
.IX Subsection "Quantifiers"
.PP
The following standard quantifiers are recognized:
.IX Xref "metacharacter quantifier * + ? {n} {n,} {n,m}"
.PP
.Vb 6
\&    *           Match 0 or more times
\&    +           Match 1 or more times
\&    ?           Match 1 or 0 times
\&    {n}         Match exactly n times
\&    {n,}        Match at least n times
\&    {n,m}       Match at least n but not more than m times
.Ve
.PP
(If a curly bracket occurs in any other context and does not form part of
a backslashed sequence like \f(CW\*(C`\ex{...}\*(C'\fR, it is treated as a regular
character.  In particular, the lower quantifier bound is not optional,
and a typo in a quantifier silently causes it to be treated as the
literal characters.  For example,
.PP
.Vb 1
\&    /o{4,3}/
.Ve
.PP
looks like a quantifier that matches 0 times, since 4 is greater than 3,
but it really means to match the sequence of six characters
\&\f(CW"o\ {\ 4\ ,\ 3\ }"\fR.  It is planned to eventually require literal uses
of curly brackets to be escaped, say by preceding them with a backslash
or enclosing them within square brackets, (\f(CW"\e{"\fR or \f(CW"[{]"\fR).  This
change will allow for future syntax extensions (like making the lower
bound of a quantifier optional), and better error checking.  In the
meantime, you should get in the habit of escaping all instances where
you mean a literal \*(L"{\*(R".)
.PP
The \*(L"*\*(R" quantifier is equivalent to \f(CW\*(C`{0,}\*(C'\fR, the \*(L"+\*(R"
quantifier to \f(CW\*(C`{1,}\*(C'\fR, and the \*(L"?\*(R" quantifier to \f(CW\*(C`{0,1}\*(C'\fR.  n and m are limited
to non-negative integral values less than a preset limit defined when perl is built.
This is usually 32766 on the most common platforms.  The actual limit can
be seen in the error message generated by code such as this:
.PP
.Vb 1
\&    $_ **= $_ , / {$_} / for 2 .. 42;
.Ve
.PP
By default, a quantified subpattern is \*(L"greedy\*(R", that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.  If you want it to match the
minimum number of times possible, follow the quantifier with a \*(L"?\*(R".  Note
that the meanings don't change, just the \*(L"greediness\*(R":
.IX Xref "metacharacter greedy greediness ? *? +? ?? {n}? {n,}? {n,m}?"
.PP
.Vb 6
\&    *?        Match 0 or more times, not greedily
\&    +?        Match 1 or more times, not greedily
\&    ??        Match 0 or 1 time, not greedily
\&    {n}?      Match exactly n times, not greedily (redundant)
\&    {n,}?     Match at least n times, not greedily
\&    {n,m}?    Match at least n but not more than m times, not greedily
.Ve
.PP
By default, when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl provides the \*(L"possessive\*(R" quantifier form
as well.
.PP
.Vb 6
\& *+     Match 0 or more times and give nothing back
\& ++     Match 1 or more times and give nothing back
\& ?+     Match 0 or 1 time and give nothing back
\& {n}+   Match exactly n times and give nothing back (redundant)
\& {n,}+  Match at least n times and give nothing back
\& {n,m}+ Match at least n but not more than m times and give nothing back
.Ve
.PP
For instance,
.PP
.Vb 1
\&   \*(Aqaaaa\*(Aq =~ /a++a/
.Ve
.PP
will never match, as the \f(CW\*(C`a++\*(C'\fR will gobble up all the \f(CW\*(C`a\*(C'\fR's in the
string and won't leave any for the remaining part of the pattern. This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack. For instance, the typical \*(L"match a double-quoted
string\*(R" problem can be most efficiently performed when written as:
.PP
.Vb 1
\&   /"(?:[^"\e\e]++|\e\e.)*+"/
.Ve
.PP
as we know that if the final quote does not match, backtracking will not
help. See the independent subexpression
"\f(CW\*(C`(?>pattern)\*(C'\fR" for more details;
possessive quantifiers are just syntactic sugar for that construct. For
instance the above example could also be written as follows:
.PP
.Vb 1
\&   /"(?>(?:(?>[^"\e\e]+)|\e\e.)*)"/
.Ve
.PP
\fIEscape sequences\fR
.IX Subsection "Escape sequences"
.PP
Because patterns are processed as double-quoted strings, the following
also work:
.PP
.Vb 10
\& \et          tab                   (HT, TAB)
\& \en          newline               (LF, NL)
\& \er          return                (CR)
\& \ef          form feed             (FF)
\& \ea          alarm (bell)          (BEL)
\& \ee          escape (think troff)  (ESC)
\& \ecK         control char          (example: VT)
\& \ex{}, \ex00  character whose ordinal is the given hexadecimal number
\& \eN{name}    named Unicode character or character sequence
\& \eN{U+263D}  Unicode character     (example: FIRST QUARTER MOON)
\& \eo{}, \e000  character whose ordinal is the given octal number
\& \el          lowercase next char (think vi)
\& \eu          uppercase next char (think vi)
\& \eL          lowercase till \eE (think vi)
\& \eU          uppercase till \eE (think vi)
\& \eQ          quote (disable) pattern metacharacters till \eE
\& \eE          end either case modification or quoted section, think vi
.Ve
.PP
Details are in \*(L"Quote and Quote-like Operators\*(R" in perlop.
.PP
\fICharacter Classes and other Special Escapes\fR
.IX Subsection "Character Classes and other Special Escapes"
.PP
In addition, Perl defines the following:
.IX Xref "\\g \\k \\K backreference"
.PP
.Vb 10
\& Sequence   Note    Description
\&  [...]     [1]  Match a character according to the rules of the
\&                   bracketed character class defined by the "...".
\&                   Example: [a\-z] matches "a" or "b" or "c" ... or "z"
\&  [[:...:]] [2]  Match a character according to the rules of the POSIX
\&                   character class "..." within the outer bracketed
\&                   character class.  Example: [[:upper:]] matches any
\&                   uppercase character.
\&  (?[...])  [8]  Extended bracketed character class
\&  \ew        [3]  Match a "word" character (alphanumeric plus "_", plus
\&                   other connector punctuation chars plus Unicode
\&                   marks)
\&  \eW        [3]  Match a non\-"word" character
\&  \es        [3]  Match a whitespace character
\&  \eS        [3]  Match a non\-whitespace character
\&  \ed        [3]  Match a decimal digit character
\&  \eD        [3]  Match a non\-digit character
\&  \epP       [3]  Match P, named property.  Use \ep{Prop} for longer names
\&  \ePP       [3]  Match non\-P
\&  \eX        [4]  Match Unicode "eXtended grapheme cluster"
\&  \eC             Match a single C\-language char (octet) even if that is
\&                   part of a larger UTF\-8 character.  Thus it breaks up
\&                   characters into their UTF\-8 bytes, so you may end up
\&                   with malformed pieces of UTF\-8.  Unsupported in
\&                   lookbehind.
\&  \e1        [5]  Backreference to a specific capture group or buffer.
\&                   \*(Aq1\*(Aq may actually be any positive integer.
\&  \eg1       [5]  Backreference to a specific or previous group,
\&  \eg{\-1}    [5]  The number may be negative indicating a relative
\&                   previous group and may optionally be wrapped in
\&                   curly brackets for safer parsing.
\&  \eg{name}  [5]  Named backreference
\&  \ek<name>  [5]  Named backreference
\&  \eK        [6]  Keep the stuff left of the \eK, don\*(Aqt include it in $&
\&  \eN        [7]  Any character but \en.  Not affected by /s modifier
\&  \ev        [3]  Vertical whitespace
\&  \eV        [3]  Not vertical whitespace
\&  \eh        [3]  Horizontal whitespace
\&  \eH        [3]  Not horizontal whitespace
\&  \eR        [4]  Linebreak
.Ve
.IP "[1]" 4
.IX Item "[1]"
See \*(L"Bracketed Character Classes\*(R" in perlrecharclass for details.
.IP "[2]" 4
.IX Item "[2]"
See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass for details.
.IP "[3]" 4
.IX Item "[3]"
See \*(L"Backslash sequences\*(R" in perlrecharclass for details.
.IP "[4]" 4
.IX Item "[4]"
See \*(L"Misc\*(R" in perlrebackslash for details.
.IP "[5]" 4
.IX Item "[5]"
See \*(L"Capture groups\*(R" below for details.
.IP "[6]" 4
.IX Item "[6]"
See \*(L"Extended Patterns\*(R" below for details.
.IP "[7]" 4
.IX Item "[7]"
Note that \f(CW\*(C`\eN\*(C'\fR has two meanings.  When of the form \f(CW\*(C`\eN{NAME}\*(C'\fR, it matches the
character or character sequence whose name is \f(CW\*(C`NAME\*(C'\fR; and similarly
when of the form \f(CW\*(C`\eN{U+\f(CIhex\f(CW}\*(C'\fR, it matches the character whose Unicode
code point is \fIhex\fR.  Otherwise it matches any character but \f(CW\*(C`\en\*(C'\fR.
.IP "[8]" 4
.IX Item "[8]"
See \*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass for details.
.PP
\fIAssertions\fR
.IX Subsection "Assertions"
.PP
Perl defines the following zero-width assertions:
.IX Xref "zero-width assertion assertion regex, zero-width assertion regexp, zero-width assertion regular expression, zero-width assertion \\b \\B \\A \\Z \\z \\G"
.PP
.Vb 7
\&    \eb  Match a word boundary
\&    \eB  Match except at a word boundary
\&    \eA  Match only at beginning of string
\&    \eZ  Match only at end of string, or before newline at the end
\&    \ez  Match only at end of string
\&    \eG  Match only at pos() (e.g. at the end\-of\-match position
\&        of prior m//g)
.Ve
.PP
A word boundary (\f(CW\*(C`\eb\*(C'\fR) is a spot between two characters
that has a \f(CW\*(C`\ew\*(C'\fR on one side of it and a \f(CW\*(C`\eW\*(C'\fR on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a \f(CW\*(C`\eW\*(C'\fR.  (Within
character classes \f(CW\*(C`\eb\*(C'\fR represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The \f(CW\*(C`\eA\*(C'\fR and \f(CW\*(C`\eZ\*(C'\fR are just like \*(L"^\*(R" and \*(L"$\*(R", except that they
won't match multiple times when the \f(CW\*(C`/m\*(C'\fR modifier is used, while
\&\*(L"^\*(R" and \*(L"$\*(R" will match at every internal line boundary.  To match
the actual end of the string and not ignore an optional trailing
newline, use \f(CW\*(C`\ez\*(C'\fR.
.IX Xref "\\b \\A \\Z \\z m"
.PP
The \f(CW\*(C`\eG\*(C'\fR assertion can be used to chain global matches (using
\&\f(CW\*(C`m//g\*(C'\fR), as described in \*(L"Regexp Quote-Like Operators\*(R" in perlop.
It is also useful when writing \f(CW\*(C`lex\*(C'\fR\-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string; see the previous reference.  The actual location
where \f(CW\*(C`\eG\*(C'\fR will match can also be influenced by using \f(CW\*(C`pos()\*(C'\fR as
an lvalue: see \*(L"pos\*(R" in perlfunc. Note that the rule for zero-length
matches (see \*(L"Repeated Patterns Matching a Zero-length Substring\*(R")
is modified somewhat, in that contents to the left of \f(CW\*(C`\eG\*(C'\fR are
not counted when determining the length of the match. Thus the following
will not match forever:
.IX Xref "\\G"
.PP
.Vb 5
\&     my $string = \*(AqABC\*(Aq;
\&     pos($string) = 1;
\&     while ($string =~ /(.\eG)/g) {
\&         print $1;
\&     }
.Ve
.PP
It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.
.PP
It is worth noting that \f(CW\*(C`\eG\*(C'\fR improperly used can result in an infinite
loop. Take care when using patterns that include \f(CW\*(C`\eG\*(C'\fR in an alternation.
.PP
\fICapture groups\fR
.IX Subsection "Capture groups"
.PP
The bracketing construct \f(CW\*(C`( ... )\*(C'\fR creates capture groups (also referred to as
capture buffers). To refer to the current contents of a group later on, within
the same pattern, use \f(CW\*(C`\eg1\*(C'\fR (or \f(CW\*(C`\eg{1}\*(C'\fR) for the first, \f(CW\*(C`\eg2\*(C'\fR (or \f(CW\*(C`\eg{2}\*(C'\fR)
for the second, and so on.
This is called a \fIbackreference\fR.
 
 
 
 
    
 
 
  
There is no limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being number 1, etc.  If
a group did not match, the associated backreference won't match either. (This
can happen if the group is optional, or in a different branch of an
alternation.)
You can omit the \f(CW"g"\fR, and write \f(CW"\e1"\fR, etc, but there are some issues with
this form, described below.
.IX Xref "regex, capture buffer regexp, capture buffer regex, capture group regexp, capture group regular expression, capture buffer backreference regular expression, capture group backreference \\g{1} \\g{-1} \\g{name} relative backreference named backreference named capture buffer regular expression, named capture buffer named capture group regular expression, named capture group %+ $+{name} \\k<name>"
.PP
You can also refer to capture groups relatively, by using a negative number, so
that \f(CW\*(C`\eg\-1\*(C'\fR and \f(CW\*(C`\eg{\-1}\*(C'\fR both refer to the immediately preceding capture
group, and \f(CW\*(C`\eg\-2\*(C'\fR and \f(CW\*(C`\eg{\-2}\*(C'\fR both refer to the group before it.  For
example:
.PP
.Vb 8
\&        /
\&         (Y)            # group 1
\&         (              # group 2
\&            (X)         # group 3
\&            \eg{\-1}      # backref to group 3
\&            \eg{\-3}      # backref to group 1
\&         )
\&        /x
.Ve
.PP
would match the same as \f(CW\*(C`/(Y) ( (X) \eg3 \eg1 )/x\*(C'\fR.  This allows you to
interpolate regexes into larger regexes and not have to worry about the
capture groups being renumbered.
.PP
You can dispense with numbers altogether and create named capture groups.
The notation is \f(CW\*(C`(?<\f(CIname\f(CW>...)\*(C'\fR to declare and \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR to
reference.  (To be compatible with .Net regular expressions, \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR may
also be written as \f(CW\*(C`\ek{\f(CIname\f(CW}\*(C'\fR, \f(CW\*(C`\ek<\f(CIname\f(CW>\*(C'\fR or \f(CW\*(C`\ek\*(Aq\f(CIname\f(CW\*(Aq\*(C'\fR.)
\&\fIname\fR must not begin with a number, nor contain hyphens.
When different groups within the same pattern have the same name, any reference
to that name assumes the leftmost defined group.  Named groups count in
absolute and relative numbering, and so can also be referred to by those
numbers.
(It's possible to do things with named capture groups that would otherwise
require \f(CW\*(C`(??{})\*(C'\fR.)
.PP
Capture group contents are dynamically scoped and available to you outside the
pattern until the end of the enclosing block or until the next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" in perlsyn.)
You can refer to them by absolute number (using \f(CW"$1"\fR instead of \f(CW"\eg1"\fR,
etc); or by name via the \f(CW\*(C`%+\*(C'\fR hash, using \f(CW"$+{\f(CIname\f(CW}"\fR.
.PP
Braces are required in referring to named capture groups, but are optional for
absolute or relative numbered ones.  Braces are safer when creating a regex by
concatenating smaller strings.  For example if you have \f(CW\*(C`qr/$a$b/\*(C'\fR, and \f(CW$a\fR
contained \f(CW"\eg1"\fR, and \f(CW$b\fR contained \f(CW"37"\fR, you would get \f(CW\*(C`/\eg137/\*(C'\fR which
is probably not what you intended.
.PP
The \f(CW\*(C`\eg\*(C'\fR and \f(CW\*(C`\ek\*(C'\fR notations were introduced in Perl 5.10.0.  Prior to that
there were no named nor relative numbered capture groups.  Absolute numbered
groups were referred to using \f(CW\*(C`\e1\*(C'\fR,
\&\f(CW\*(C`\e2\*(C'\fR, etc., and this notation is still
accepted (and likely always will be).  But it leads to some ambiguities if
there are more than 9 capture groups, as \f(CW\*(C`\e10\*(C'\fR could mean either the tenth
capture group, or the character whose ordinal in octal is 010 (a backspace in
\&\s-1ASCII\s0).  Perl resolves this ambiguity by interpreting \f(CW\*(C`\e10\*(C'\fR as a backreference
only if at least 10 left parentheses have opened before it.  Likewise \f(CW\*(C`\e11\*(C'\fR is
a backreference only if at least 11 left parentheses have opened before it.
And so on.  \f(CW\*(C`\e1\*(C'\fR through \f(CW\*(C`\e9\*(C'\fR are always interpreted as backreferences.
There are several examples below that illustrate these perils.  You can avoid
the ambiguity by always using \f(CW\*(C`\eg{}\*(C'\fR or \f(CW\*(C`\eg\*(C'\fR if you mean capturing groups;
and for octal constants always using \f(CW\*(C`\eo{}\*(C'\fR, or for \f(CW\*(C`\e077\*(C'\fR and below, using 3
digits padded with leading zeros, since a leading zero implies an octal
constant.
.PP
The \f(CW\*(C`\e\f(CIdigit\f(CW\*(C'\fR notation also works in certain circumstances outside
the pattern.  See \*(L"Warning on \e1 Instead of \f(CW$1\fR\*(R" below for details.
.PP
Examples:
.PP
.Vb 1
\&    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
\&
\&    /(.)\eg1/                        # find first doubled char
\&         and print "\*(Aq$1\*(Aq is the first doubled character\en";
\&
\&    /(?<char>.)\ek<char>/            # ... a different way
\&         and print "\*(Aq$+{char}\*(Aq is the first doubled character\en";
\&
\&    /(?\*(Aqchar\*(Aq.)\eg1/                 # ... mix and match
\&         and print "\*(Aq$1\*(Aq is the first doubled character\en";
\&
\&    if (/Time: (..):(..):(..)/) {   # parse out values
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
\&
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\eg10/   # \eg10 is a backreference
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\e10/    # \e10 is octal
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e10/  # \e10 is a backreference
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e010/ # \e010 is octal
\&
\&    $a = \*(Aq(.)\e1\*(Aq;        # Creates problems when concatenated.
\&    $b = \*(Aq(.)\eg{1}\*(Aq;     # Avoids the problems.
\&    "aa" =~ /${a}/;      # True
\&    "aa" =~ /${b}/;      # True
\&    "aa0" =~ /${a}0/;    # False!
\&    "aa0" =~ /${b}0/;    # True
\&    "aa\ex08" =~ /${a}0/;  # True!
\&    "aa\ex08" =~ /${b}0/;  # False
.Ve
.PP
Several special variables also refer back to portions of the previous
match.  \f(CW$+\fR returns whatever the last bracket match matched.
\&\f(CW$&\fR returns the entire matched string.  (At one point \f(CW$0\fR did
also, but now it returns the name of the program.)  \f(CW\*(C`$\`\*(C'\fR returns
everything before the matched string.  \f(CW\*(C`$\*(Aq\*(C'\fR returns everything
after the matched string. And \f(CW$^N\fR contains whatever was matched by
the most-recently closed group (submatch). \f(CW$^N\fR can be used in
extended patterns (see below), for example to assign a submatch to a
variable.
.IX Xref "$+ $^N $& $` $'"
.PP
These special variables, like the \f(CW\*(C`%+\*(C'\fR hash and the numbered match variables
(\f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR, etc.) are dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" in perlsyn.)
.IX Xref "$+ $^N $& $` $' $1 $2 $3 $4 $5 $6 $7 $8 $9"
.PP
\&\fB\s-1NOTE\s0\fR: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.
.PP
\&\fB\s-1WARNING\s0\fR: Once Perl sees that you need one of \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR, or
\&\f(CW\*(C`$\*(Aq\*(C'\fR anywhere in the program, it has to provide them for every
pattern match.  This may substantially slow your program.  Perl
uses the same mechanism to produce \f(CW$1\fR, \f(CW$2\fR, etc, so you also pay a
price for each pattern that contains capturing parentheses.  (To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression \f(CW\*(C`(?: ... )\*(C'\fR instead.)  But if you never
use \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR or \f(CW\*(C`$\*(Aq\*(C'\fR, then patterns \fIwithout\fR capturing
parentheses will not be penalized.  So avoid \f(CW$&\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, and \f(CW\*(C`$\`\*(C'\fR
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.  As of 5.17.4, the presence of each of the three
variables in a program is recorded separately, and depending on
circumstances, perl may be able be more efficient knowing that only \f(CW$&\fR
rather than all three have been seen, for example.
.IX Xref "$& $` $'"
.PP
As a workaround for this problem, Perl 5.10.0 introduces \f(CW\*(C`${^PREMATCH}\*(C'\fR,
\&\f(CW\*(C`${^MATCH}\*(C'\fR and \f(CW\*(C`${^POSTMATCH}\*(C'\fR, which are equivalent to \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR
and \f(CW\*(C`$\*(Aq\*(C'\fR, \fBexcept\fR that they are only guaranteed to be defined after a
successful match that was executed with the \f(CW\*(C`/p\*(C'\fR (preserve) modifier.
The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.
.IX Xref " p p modifier"
.SS "Quoting metacharacters"
.IX Subsection "Quoting metacharacters"
Backslashed metacharacters in Perl are alphanumeric, such as \f(CW\*(C`\eb\*(C'\fR,
\&\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\en\*(C'\fR.  Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.  So anything
that looks like \e\e, \e(, \e), \e[, \e], \e{, or \e} is always
interpreted as a literal character, not a metacharacter.  This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern. Simply quote all non\-\*(L"word\*(R" characters:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e$1/g;
.Ve
.PP
(If \f(CW\*(C`use locale\*(C'\fR is set, then this depends on the current locale.)
Today it is more common to use the \fIquotemeta()\fR function or the \f(CW\*(C`\eQ\*(C'\fR
metaquoting escape sequence to disable all metacharacters' special
meanings like this:
.PP
.Vb 1
\&    /$unquoted\eQ$quoted\eE$unquoted/
.Ve
.PP
Beware that if you put literal backslashes (those not inside
interpolated variables) between \f(CW\*(C`\eQ\*(C'\fR and \f(CW\*(C`\eE\*(C'\fR, double-quotish
backslash interpolation may lead to confusing results.  If you
\&\fIneed\fR to use literal backslashes within \f(CW\*(C`\eQ...\eE\*(C'\fR,
consult \*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.PP
\&\f(CW\*(C`quotemeta()\*(C'\fR and \f(CW\*(C`\eQ\*(C'\fR are fully described in \*(L"quotemeta\*(R" in perlfunc.
.SS "Extended Patterns"
.IX Subsection "Extended Patterns"
Perl also defines a consistent extension syntax for features not
found in standard tools like \fBawk\fR and
\&\fBlex\fR.  The syntax for most of these is a
pair of parentheses with a question mark as the first thing within
the parentheses.  The character after the question mark indicates
the extension.
.PP
The stability of these extensions varies widely.  Some have been
part of the core language for many years.  Others are experimental
and may change without warning or be completely removed.  Check
the documentation on an individual feature to verify its current
status.
.PP
A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
\&\*(L"question\*(R" exactly what is going on.  That's psychology....
.ie n .IP """(?#text)""" 4
.el .IP "\f(CW(?#text)\fR" 4
.IX Xref "(?#)"
.IX Item "(?#text)"
A comment.  The text is ignored.  If the \f(CW\*(C`/x\*(C'\fR modifier enables
whitespace formatting, a simple \f(CW\*(C`#\*(C'\fR will suffice.  Note that Perl closes
the comment as soon as it sees a \f(CW\*(C`)\*(C'\fR, so there is no way to put a literal
\&\f(CW\*(C`)\*(C'\fR in the comment.
.ie n .IP """(?adlupimsx\-imsx)""" 4
.el .IP "\f(CW(?adlupimsx\-imsx)\fR" 4
.IX Item "(?adlupimsx-imsx)"
.PD 0
.ie n .IP """(?^alupimsx)""" 4
.el .IP "\f(CW(?^alupimsx)\fR" 4
.IX Xref "(?) (?^)"
.IX Item "(?^alupimsx)"
.PD
One or more embedded pattern-match modifiers, to be turned on (or
turned off, if preceded by \f(CW\*(C`\-\*(C'\fR) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).
.Sp
This is particularly useful for dynamic patterns, such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.  Consider the case where some patterns want to be
case-sensitive and some do not:  The case-insensitive ones merely need to
include \f(CW\*(C`(?i)\*(C'\fR at the front of the pattern.  For example:
.Sp
.Vb 2
\&    $pattern = "foobar";
\&    if ( /$pattern/i ) { }
\&
\&    # more flexible:
\&
\&    $pattern = "(?i)foobar";
\&    if ( /$pattern/ ) { }
.Ve
.Sp
These modifiers are restored at the end of the enclosing group. For example,
.Sp
.Vb 1
\&    ( (?i) blah ) \es+ \eg1
.Ve
.Sp
will match \f(CW\*(C`blah\*(C'\fR in any case, some spaces, and an exact (\fIincluding the case\fR!)
repetition of the previous word, assuming the \f(CW\*(C`/x\*(C'\fR modifier, and no \f(CW\*(C`/i\*(C'\fR
modifier outside this group.
.Sp
These modifiers do not carry over into named subpatterns called in the
enclosing group. In other words, a pattern such as \f(CW\*(C`((?i)(?&NAME))\*(C'\fR does not
change the case-sensitivity of the \*(L"\s-1NAME\*(R"\s0 pattern.
.Sp
Any of these modifiers can be set to apply globally to all regular
expressions compiled within the scope of a \f(CW\*(C`use re\*(C'\fR.  See
\&\*(L"'/flags' mode\*(R" in re.
.Sp
Starting in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
after the \f(CW"?"\fR is a shorthand equivalent to \f(CW\*(C`d\-imsx\*(C'\fR.  Flags (except
\&\f(CW"d"\fR) may follow the caret to override it.
But a minus sign is not legal with it.
.Sp
Note that the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR, and \f(CW\*(C`u\*(C'\fR modifiers are special in
that they can only be enabled, not disabled, and the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, and
\&\f(CW\*(C`u\*(C'\fR modifiers are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two \f(CW\*(C`a\*(C'\fR's) may appear in the
construct.  Thus, for
example, \f(CW\*(C`(?\-p)\*(C'\fR will warn when compiled under \f(CW\*(C`use warnings\*(C'\fR;
\&\f(CW\*(C`(?\-d:...)\*(C'\fR and \f(CW\*(C`(?dl:...)\*(C'\fR are fatal errors.
.Sp
Note also that the \f(CW\*(C`p\*(C'\fR modifier is special in that its presence
anywhere in a pattern has a global effect.
.ie n .IP """(?:pattern)""" 4
.el .IP "\f(CW(?:pattern)\fR" 4
.IX Xref "(?:)"
.IX Item "(?:pattern)"
.PD 0
.ie n .IP """(?adluimsx\-imsx:pattern)""" 4
.el .IP "\f(CW(?adluimsx\-imsx:pattern)\fR" 4
.IX Item "(?adluimsx-imsx:pattern)"
.ie n .IP """(?^aluimsx:pattern)""" 4
.el .IP "\f(CW(?^aluimsx:pattern)\fR" 4
.IX Xref "(?^:)"
.IX Item "(?^aluimsx:pattern)"
.PD
This is for clustering, not capturing; it groups subexpressions like
\&\*(L"()\*(R", but doesn't make backreferences as \*(L"()\*(R" does.  So
.Sp
.Vb 1
\&    @fields = split(/\eb(?:a|b|c)\eb/)
.Ve
.Sp
is like
.Sp
.Vb 1
\&    @fields = split(/\eb(a|b|c)\eb/)
.Ve
.Sp
but doesn't spit out extra fields.  It's also cheaper not to capture
characters if you don't need to.
.Sp
Any letters between \f(CW\*(C`?\*(C'\fR and \f(CW\*(C`:\*(C'\fR act as flags modifiers as with
\&\f(CW\*(C`(?adluimsx\-imsx)\*(C'\fR.  For example,
.Sp
.Vb 1
\&    /(?s\-i:more.*than).*million/i
.Ve
.Sp
is equivalent to the more verbose
.Sp
.Vb 1
\&    /(?:(?s\-i)more.*than).*million/i
.Ve
.Sp
Starting in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
after the \f(CW"?"\fR is a shorthand equivalent to \f(CW\*(C`d\-imsx\*(C'\fR.  Any positive
flags (except \f(CW"d"\fR) may follow the caret, so
.Sp
.Vb 1
\&    (?^x:foo)
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    (?x\-ims:foo)
.Ve
.Sp
The caret tells Perl that this cluster doesn't inherit the flags of any
surrounding pattern, but uses the system defaults (\f(CW\*(C`d\-imsx\*(C'\fR),
modified by any flags specified.
.Sp
The caret allows for simpler stringification of compiled regular
expressions.  These look like
.Sp
.Vb 1
\&    (?^:pattern)
.Ve
.Sp
with any non-default flags appearing between the caret and the colon.
A test that looks at such stringification thus doesn't need to have the
system default flags hard-coded in it, just the caret.  If new flags are
added to Perl, the meaning of the caret's expansion will change to include
the default for those flags, so the test will still work, unchanged.
.Sp
Specifying a negative flag after the caret is an error, as the flag is
redundant.
.Sp
Mnemonic for \f(CW\*(C`(?^...)\*(C'\fR:  A fresh beginning since the usual use of a caret is
to match at the beginning.
.ie n .IP """(?|pattern)""" 4
.el .IP "\f(CW(?|pattern)\fR" 4
.IX Xref "(?|) Branch reset"
.IX Item "(?|pattern)"
This is the \*(L"branch reset\*(R" pattern, which has the special property
that the capture groups are numbered from the same starting point
in each alternation branch. It is available starting from perl 5.10.0.
.Sp
Capture groups are numbered from left to right, but inside this
construct the numbering is restarted for each branch.
.Sp
The numbering within each branch will be as normal, and any groups
following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
groups in it.
.Sp
This construct is useful when you want to capture one of a
number of alternative matches.
.Sp
Consider the following pattern.  The numbers underneath show in
which group the captured content will be stored.
.Sp
.Vb 3
\&    # before  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-branch\-reset\-\-\-\-\-\-\-\-\-\-\- after        
\&    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
\&    # 1            2         2  3        2     3     4
.Ve
.Sp
Be careful when using the branch reset pattern in combination with 
named captures. Named captures are implemented as being aliases to 
numbered groups holding the captures, and that interferes with the
implementation of the branch reset pattern. If you are using named
captures in a branch reset pattern, it's best to use the same names,
in the same order, in each of the alternations:
.Sp
.Vb 2
\&   /(?|  (?<a> x ) (?<b> y )
\&      |  (?<a> z ) (?<b> w )) /x
.Ve
.Sp
Not doing so may lead to surprises:
.Sp
.Vb 3
\&  "12" =~ /(?| (?<a> \ed+ ) | (?<b> \eD+))/x;
\&  say $+ {a};   # Prints \*(Aq12\*(Aq
\&  say $+ {b};   # *Also* prints \*(Aq12\*(Aq.
.Ve
.Sp
The problem here is that both the group named \f(CW\*(C`a\*(C'\fR and the group
named \f(CW\*(C`b\*(C'\fR are aliases for the group belonging to \f(CW$1\fR.
.IP "Look-Around Assertions" 4
.IX Xref "look-around assertion lookaround assertion look-around lookaround"
.IX Item "Look-Around Assertions"
Look-around assertions are zero-width patterns which match a specific
pattern without including it in \f(CW$&\fR. Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.
.RS 4
.ie n .IP """(?=pattern)""" 4
.el .IP "\f(CW(?=pattern)\fR" 4
.IX Xref "(?=) look-ahead, positive lookahead, positive"
.IX Item "(?=pattern)"
A zero-width positive look-ahead assertion.  For example, \f(CW\*(C`/\ew+(?=\et)/\*(C'\fR
matches a word followed by a tab, without including the tab in \f(CW$&\fR.
.ie n .IP """(?!pattern)""" 4
.el .IP "\f(CW(?!pattern)\fR" 4
.IX Xref "(?!) look-ahead, negative lookahead, negative"
.IX Item "(?!pattern)"
A zero-width negative look-ahead assertion.  For example \f(CW\*(C`/foo(?!bar)/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" that isn't followed by \*(L"bar\*(R".  Note
however that look-ahead and look-behind are \s-1NOT\s0 the same thing.  You cannot
use this for look-behind.
.Sp
If you are looking for a \*(L"bar\*(R" that isn't preceded by a \*(L"foo\*(R", \f(CW\*(C`/(?!foo)bar/\*(C'\fR
will not do what you want.  That's because the \f(CW\*(C`(?!foo)\*(C'\fR is just saying that
the next thing cannot be \*(L"foo\*(R"\-\-and it's not, it's a \*(L"bar\*(R", so \*(L"foobar\*(R" will
match.  Use look-behind instead (see below).
.ie n .IP """(?<=pattern)"" ""\eK""" 4
.el .IP "\f(CW(?<=pattern)\fR \f(CW\eK\fR" 4
.IX Xref "(?<=) look-behind, positive lookbehind, positive \\K"
.IX Item "(?<=pattern) K"
A zero-width positive look-behind assertion.  For example, \f(CW\*(C`/(?<=\et)\ew+/\*(C'\fR
matches a word that follows a tab, without including the tab in \f(CW$&\fR.
Works only for fixed-width look-behind.
.Sp
There is a special form of this construct, called \f(CW\*(C`\eK\*(C'\fR, which causes the
regex engine to \*(L"keep\*(R" everything it had matched prior to the \f(CW\*(C`\eK\*(C'\fR and
not include it in \f(CW$&\fR. This effectively provides variable-length
look-behind. The use of \f(CW\*(C`\eK\*(C'\fR inside of another look-around assertion
is allowed, but the behaviour is currently not well defined.
.Sp
For various reasons \f(CW\*(C`\eK\*(C'\fR may be significantly more efficient than the
equivalent \f(CW\*(C`(?<=...)\*(C'\fR construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string. For instance
.Sp
.Vb 1
\&  s/(foo)bar/$1/g;
.Ve
.Sp
can be rewritten as the much more efficient
.Sp
.Vb 1
\&  s/foo\eKbar//g;
.Ve
.ie n .IP """(?<!pattern)""" 4
.el .IP "\f(CW(?<!pattern)\fR" 4
.IX Xref "(?<!) look-behind, negative lookbehind, negative"
.IX Item "(?<!pattern)"
A zero-width negative look-behind assertion.  For example \f(CW\*(C`/(?<!bar)foo/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" that does not follow \*(L"bar\*(R".  Works
only for fixed-width look-behind.
.RE
.RS 4
.RE
.ie n .IP """(?\*(AqNAME\*(Aqpattern)""" 4
.el .IP "\f(CW(?\*(AqNAME\*(Aqpattern)\fR" 4
.IX Item "(?NAMEpattern)"
.PD 0
.ie n .IP """(?<NAME>pattern)""" 4
.el .IP "\f(CW(?<NAME>pattern)\fR" 4
.IX Xref "(?<NAME>) (?'NAME') named capture capture"
.IX Item "(?<NAME>pattern)"
.PD
A named capture group. Identical in every respect to normal capturing
parentheses \f(CW\*(C`()\*(C'\fR but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like \f(CW\*(C`\eg{NAME}\*(C'\fR) and can be accessed by name
after a successful match via \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR. See perlvar
for more details on the \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR hashes.
.Sp
If multiple distinct capture groups have the same name then the
$+{\s-1NAME\s0} will refer to the leftmost defined group in the match.
.Sp
The forms \f(CW\*(C`(?\*(AqNAME\*(Aqpattern)\*(C'\fR and \f(CW\*(C`(?<NAME>pattern)\*(C'\fR are equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR While the notation of this construct is the same as the similar
function in .NET regexes, the behavior is not. In Perl the groups are
numbered sequentially regardless of being named or not. Thus in the
pattern
.Sp
.Vb 1
\&  /(x)(?<foo>y)(z)/
.Ve
.Sp
$+{foo} will be the same as \f(CW$2\fR, and \f(CW$3\fR will contain 'z' instead of
the opposite which is what a .NET regex hacker might expect.
.Sp
Currently \s-1NAME\s0 is restricted to simple identifiers only.
In other words, it must match \f(CW\*(C`/^[_A\-Za\-z][_A\-Za\-z0\-9]*\ez/\*(C'\fR or
its Unicode extension (see utf8),
though it isn't extended by the locale (see perllocale).
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines, the pattern \f(CW\*(C`(?P<NAME>pattern)\*(C'\fR
may be used instead of \f(CW\*(C`(?<NAME>pattern)\*(C'\fR; however this form does not
support the use of single quotes as a delimiter for the name.
.ie n .IP """\ek<NAME>""" 4
.el .IP "\f(CW\ek<NAME>\fR" 4
.IX Item "k<NAME>"
.PD 0
.ie n .IP """\ek\*(AqNAME\*(Aq""" 4
.el .IP "\f(CW\ek\*(AqNAME\*(Aq\fR" 4
.IX Item "kNAME"
.PD
Named backreference. Similar to numeric backreferences, except that
the group is designated by name and not number. If multiple groups
have the same name then it refers to the leftmost defined group in
the current match.
.Sp
It is an error to refer to a name not defined by a \f(CW\*(C`(?<NAME>)\*(C'\fR
earlier in the pattern.
.Sp
Both forms are equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines, the pattern \f(CW\*(C`(?P=NAME)\*(C'\fR
may be used instead of \f(CW\*(C`\ek<NAME>\*(C'\fR.
.ie n .IP """(?{ code })""" 4
.el .IP "\f(CW(?{ code })\fR" 4
.IX Xref "(?{}) regex, code in regexp, code in regular expression, code in"
.IX Item "(?{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine. The
implementation of this feature was radically overhauled for the 5.18.0
release, and its behaviour in earlier versions of perl was much buggier,
especially in relation to parsing, lexical vars, scoping, recursion and
reentrancy.
.Sp
This zero-width assertion executes any embedded Perl code.  It always
succeeds, and its return value is set as \f(CW$^R\fR.
.Sp
In literal patterns, the code is parsed at the same time as the
surrounding code. While within the pattern, control is passed temporarily
back to the perl parser, until the logically-balancing closing brace is
encountered. This is similar to the way that an array index expression in
a literal string is handled, for example
.Sp
.Vb 1
\&    "abc$array[ 1 + f(\*(Aq[\*(Aq) + g()]def"
.Ve
.Sp
In particular, braces do not need to be balanced:
.Sp
.Vb 1
\&    s/abc(?{ f(\*(Aq{\*(Aq); })/def/
.Ve
.Sp
Even in a pattern that is interpolated and compiled at run-time, literal
code blocks will be compiled once, at perl compile time; the following
prints \*(L"\s-1ABCD\*(R":\s0
.Sp
.Vb 5
\&    print "D";
\&    my $qr = qr/(?{ BEGIN { print "A" } })/;
\&    my $foo = "foo";
\&    /$foo$qr(?{ BEGIN { print "B" } })/;
\&    BEGIN { print "C" }
.Ve
.Sp
In patterns where the text of the code is derived from run-time
information rather than appearing literally in a source code /pattern/,
the code is compiled at the same time that the pattern is compiled, and
for reasons of security, \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR must be in scope. This is to
stop user-supplied patterns containing code snippets from being
executable.
.Sp
In situations where you need to enable this with \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR, you should
also have taint checking enabled.  Better yet, use the carefully
constrained evaluation within a Safe compartment.  See perlsec for
details about both these mechanisms.
.Sp
From the viewpoint of parsing, lexical variable scope and closures,
.Sp
.Vb 1
\&    /AAA(?{ BBB })CCC/
.Ve
.Sp
behaves approximately like
.Sp
.Vb 1
\&    /AAA/ && do { BBB } && /CCC/
.Ve
.Sp
Similarly,
.Sp
.Vb 1
\&    qr/AAA(?{ BBB })CCC/
.Ve
.Sp
behaves approximately like
.Sp
.Vb 1
\&    sub { /AAA/ && do { BBB } && /CCC/ }
.Ve
.Sp
In particular:
.Sp
.Vb 3
\&    { my $i = 1; $r = qr/(?{ print $i })/ }
\&    my $i = 2;
\&    /$r/; # prints "1"
.Ve
.Sp
Inside a \f(CW\*(C`(?{...})\*(C'\fR block, \f(CW$_\fR refers to the string the regular
expression is matching against. You can also use \f(CW\*(C`pos()\*(C'\fR to know what is
the current position of matching within this string.
.Sp
The code block introduces a new scope from the perspective of lexical
variable declarations, but \fBnot\fR from the perspective of \f(CW\*(C`local\*(C'\fR and
similar localizing behaviours. So later code blocks within the same
pattern will still see the values which were localized in earlier blocks.
These accumulated localizations are undone either at the end of a
successful match, or if the assertion is backtracked (compare
\&\*(L"Backtracking\*(R"). For example,
.Sp
.Vb 10
\&  $_ = \*(Aqa\*(Aq x 8;
\&  m<
\&     (?{ $cnt = 0 })               # Initialize $cnt.
\&     (
\&       a
\&       (?{
\&           local $cnt = $cnt + 1;  # Update $cnt,
\&                                   # backtracking\-safe.
\&       })
\&     )*
\&     aaaa
\&     (?{ $res = $cnt })            # On success copy to
\&                                   # non\-localized location.
\&   >x;
.Ve
.Sp
will initially increment \f(CW$cnt\fR up to 8; then during backtracking, its
value will be unwound back to 4, which is the value assigned to \f(CW$res\fR.
At the end of the regex execution, \f(CW$cnt\fR will be wound back to its initial
value of 0.
.Sp
This assertion may be used as the condition in a
.Sp
.Vb 1
\&    (?(condition)yes\-pattern|no\-pattern)
.Ve
.Sp
switch.  If \fInot\fR used in this way, the result of evaluation of \f(CW\*(C`code\*(C'\fR
is put into the special variable \f(CW$^R\fR.  This happens immediately, so
\&\f(CW$^R\fR can be used from other \f(CW\*(C`(?{ code })\*(C'\fR assertions inside the same
regular expression.
.Sp
The assignment to \f(CW$^R\fR above is properly localized, so the old
value of \f(CW$^R\fR is restored if the assertion is backtracked; compare
\&\*(L"Backtracking\*(R".
.Sp
Note that the special variable \f(CW$^N\fR  is particularly useful with code
blocks to capture the results of submatches in variables without having to
keep track of the number of nested parentheses. For example:
.Sp
.Vb 3
\&  $_ = "The brown fox jumps over the lazy dog";
\&  /the (\eS+)(?{ $color = $^N }) (\eS+)(?{ $animal = $^N })/i;
\&  print "color = $color, animal = $animal\en";
.Ve
.ie n .IP """(??{ code })""" 4
.el .IP "\f(CW(??{ code })\fR" 4
.IX Xref "(??{}) regex, postponed regexp, postponed regular expression, postponed"
.IX Item "(??{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.
.Sp
This is a \*(L"postponed\*(R" regular subexpression.  It behaves in \fIexactly\fR the
same way as a \f(CW\*(C`(?{ code })\*(C'\fR code block as described above, except that
its return value, rather than being assigned to \f(CW$^R\fR, is treated as a
pattern, compiled if it's a string (or used as-is if its a qr// object),
then matched as if it were inserted instead of this construct.
.Sp
During the matching of this sub-pattern, it has its own set of
captures which are valid during the sub-match, but are discarded once
control returns to the main pattern. For example, the following matches,
with the inner pattern capturing \*(L"B\*(R" and matching \*(L"\s-1BB\*(R",\s0 while the outer
pattern captures \*(L"A\*(R";
.Sp
.Vb 3
\&    my $inner = \*(Aq(.)\e1\*(Aq;
\&    "ABBA" =~ /^(.)(??{ $inner })\e1/;
\&    print $1; # prints "A";
.Ve
.Sp
Note that this means that  there is no way for the inner pattern to refer
to a capture group defined outside.  (The code block itself can use \f(CW$1\fR,
etc., to refer to the enclosing pattern's capture groups.)  Thus, although
.Sp
.Vb 1
\&    (\*(Aqa\*(Aq x 100)=~/(??{\*(Aq(.)\*(Aq x 100})/
.Ve
.Sp
\&\fIwill\fR match, it will \fInot\fR set \f(CW$1\fR on exit.
.Sp
The following pattern matches a parenthesized group:
.Sp
.Vb 9
\& $re = qr{
\&            \e(
\&            (?:
\&               (?> [^()]+ )  # Non\-parens without backtracking
\&             |
\&               (??{ $re })   # Group with matching parens
\&            )*
\&            \e)
\&         }x;
.Ve
.Sp
See also
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR
for a different, more efficient way to accomplish
the same task.
.Sp
Executing a postponed regular expression 50 times without consuming any
input string will result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.
.ie n .IP """(?\f(CIPARNO\f(CW)"" ""(?\-\f(CIPARNO\f(CW)"" ""(?+\f(CIPARNO\f(CW)"" ""(?R)"" ""(?0)""" 4
.el .IP "\f(CW(?\f(CIPARNO\f(CW)\fR \f(CW(?\-\f(CIPARNO\f(CW)\fR \f(CW(?+\f(CIPARNO\f(CW)\fR \f(CW(?R)\fR \f(CW(?0)\fR" 4
.IX Xref "(?PARNO) (?1) (?R) (?0) (?-1) (?+1) (?-PARNO) (?+PARNO) regex, recursive regexp, recursive regular expression, recursive regex, relative recursion"
.IX Item "(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)"
Similar to \f(CW\*(C`(??{ code })\*(C'\fR except that it does not involve executing any
code or potentially compiling a returned pattern string; instead it treats
the part of the current pattern contained within a specified capture group
as an independent pattern that must match at the current position.
Capture groups contained by the pattern will have the value as determined
by the outermost recursion.
.Sp
\&\fI\s-1PARNO\s0\fR is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture group to recurse to. \f(CW\*(C`(?R)\*(C'\fR recurses to
the beginning of the whole pattern. \f(CW\*(C`(?0)\*(C'\fR is an alternate syntax for
\&\f(CW\*(C`(?R)\*(C'\fR. If \fI\s-1PARNO\s0\fR is preceded by a plus or minus sign then it is assumed
to be relative, with negative numbers indicating preceding capture groups
and positive ones following. Thus \f(CW\*(C`(?\-1)\*(C'\fR refers to the most recently
declared group, and \f(CW\*(C`(?+1)\*(C'\fR indicates the next group to be declared.
Note that the counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed groups \fBare\fR
included.
.Sp
The following pattern matches a function \fIfoo()\fR which may contain
balanced parentheses as the argument.
.Sp
.Vb 10
\&  $re = qr{ (                   # paren group 1 (full function)
\&              foo
\&              (                 # paren group 2 (parens)
\&                \e(
\&                  (             # paren group 3 (contents of parens)
\&                  (?:
\&                   (?> [^()]+ ) # Non\-parens without backtracking
\&                  |
\&                   (?2)         # Recurse to start of paren group 2
\&                  )*
\&                  )
\&                \e)
\&              )
\&            )
\&          }x;
.Ve
.Sp
If the pattern was used as follows
.Sp
.Vb 4
\&    \*(Aqfoo(bar(baz)+baz(bop))\*(Aq=~/$re/
\&        and print "\e$1 = $1\en",
\&                  "\e$2 = $2\en",
\&                  "\e$3 = $3\en";
.Ve
.Sp
the output produced should be the following:
.Sp
.Vb 3
\&    $1 = foo(bar(baz)+baz(bop))
\&    $2 = (bar(baz)+baz(bop))
\&    $3 = bar(baz)+baz(bop)
.Ve
.Sp
If there is no corresponding capture group defined, then it is a
fatal error.  Recursing deeper than 50 times without consuming any input
string will also result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.
.Sp
The following shows how using negative indexing can make it
easier to embed recursive patterns inside of a \f(CW\*(C`qr//\*(C'\fR construct
for later use:
.Sp
.Vb 4
\&    my $parens = qr/(\e((?:[^()]++|(?\-1))*+\e))/;
\&    if (/foo $parens \es+ \e+ \es+ bar $parens/x) {
\&       # do something here...
\&    }
.Ve
.Sp
\&\fBNote\fR that this pattern does not behave the same way as the equivalent
\&\s-1PCRE\s0 or Python construct of the same form. In Perl you can backtrack into
a recursed group, in \s-1PCRE\s0 and Python the recursed into group is treated
as atomic. Also, modifiers are resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will
be processed.
.ie n .IP """(?&NAME)""" 4
.el .IP "\f(CW(?&NAME)\fR" 4
.IX Xref "(?&NAME)"
.IX Item "(?&NAME)"
Recurse to a named subpattern. Identical to \f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR except that the
parenthesis to recurse to is determined by name. If multiple parentheses have
the same name, then it recurses to the leftmost.
.Sp
It is an error to refer to a name that is not declared somewhere in the
pattern.
.Sp
\&\fB\s-1NOTE:\s0\fR In order to make things easier for programmers with experience
with the Python or \s-1PCRE\s0 regex engines the pattern \f(CW\*(C`(?P>NAME)\*(C'\fR
may be used instead of \f(CW\*(C`(?&NAME)\*(C'\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Xref "(?()"
.IX Item "(?(condition)yes-pattern|no-pattern)"
.PD 0
.ie n .IP """(?(condition)yes\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern)"
.PD
Conditional expression. Matches \f(CW\*(C`yes\-pattern\*(C'\fR if \f(CW\*(C`condition\*(C'\fR yields
a true value, matches \f(CW\*(C`no\-pattern\*(C'\fR otherwise. A missing pattern always
matches.
.Sp
\&\f(CW\*(C`(condition)\*(C'\fR should be one of: 1) an integer in
parentheses (which is valid if the corresponding pair of parentheses
matched); 2) a look\-ahead/look\-behind/evaluate zero-width assertion; 3) a
name in angle brackets or single quotes (which is valid if a group
with the given name matched); or 4) the special symbol (R) (true when
evaluated inside of recursion or eval). Additionally the R may be
followed by a number, (which will be true when evaluated when recursing
inside of the appropriate group), or by \f(CW&NAME\fR, in which case it will
be true only when evaluated during recursion in the named group.
.Sp
Here's a summary of the possible predicates:
.RS 4
.IP "(1) (2) ..." 4
.IX Item "(1) (2) ..."
Checks if the numbered capturing group has matched something.
.IP "(<\s-1NAME\s0>) ('\s-1NAME\s0')" 4
.IX Item "(<NAME>) ('NAME')"
Checks if a group with the given name has matched something.
.IP "(?=...) (?!...) (?<=...) (?<!...)" 4
Checks whether the pattern matches (or does not match, for the '!'
variants).
.IP "(?{ \s-1CODE \s0})" 4
.IX Item "(?{ CODE })"
Treats the return value of the code block as the condition.
.IP "(R)" 4
.IX Item "(R)"
Checks if the expression has been evaluated inside of recursion.
.IP "(R1) (R2) ..." 4
.IX Item "(R1) (R2) ..."
Checks if the expression has been evaluated while executing directly
inside of the n\-th capture group. This check is the regex equivalent of
.Sp
.Vb 1
\&  if ((caller(0))[3] eq \*(Aqsubname\*(Aq) { ... }
.Ve
.Sp
In other words, it does not check the full recursion stack.
.IP "(R&NAME)" 4
.IX Item "(R&NAME)"
Similar to \f(CW\*(C`(R1)\*(C'\fR, this predicate checks to see if we're executing
directly inside of the leftmost group with a given name (this is the same
logic used by \f(CW\*(C`(?&NAME)\*(C'\fR to disambiguate). It does not check the full
stack, but only the name of the innermost active recursion.
.IP "(\s-1DEFINE\s0)" 4
.IX Item "(DEFINE)"
In this case, the yes-pattern is never directly executed, and no
no-pattern is allowed. Similar in spirit to \f(CW\*(C`(?{0})\*(C'\fR but more efficient.
See below for details.
.RE
.RS 4
.Sp
For example:
.Sp
.Vb 4
\&    m{ ( \e( )?
\&       [^()]+
\&       (?(1) \e) )
\&     }x
.Ve
.Sp
matches a chunk of non-parentheses, possibly included in parentheses
themselves.
.Sp
A special form is the \f(CW\*(C`(DEFINE)\*(C'\fR predicate, which never executes its
yes-pattern directly, and does not allow a no-pattern. This allows one to
define subpatterns which will be executed only by the recursion mechanism.
This way, you can define a set of regular expression rules that can be
bundled into any pattern you choose.
.Sp
It is recommended that for this usage you put the \s-1DEFINE\s0 block at the
end of the pattern, and that you name any subpatterns defined within it.
.Sp
Also, it's worth noting that patterns defined this way probably will
not be as efficient, as the optimiser is not very clever about
handling them.
.Sp
An example of how this might be used is as follows:
.Sp
.Vb 5
\&  /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
\&   (?(DEFINE)
\&     (?<NAME_PAT>....)
\&     (?<ADRESS_PAT>....)
\&   )/x
.Ve
.Sp
Note that capture groups matched inside of recursion are not accessible
after the recursion returns, so the extra layer of capturing groups is
necessary. Thus \f(CW$+{NAME_PAT}\fR would not be defined even though
\&\f(CW$+{NAME}\fR would be.
.Sp
Finally, keep in mind that subpatterns created inside a \s-1DEFINE\s0 block
count towards the absolute and relative number of captures, so this:
.Sp
.Vb 5
\&    my @captures = "a" =~ /(.)                  # First capture
\&                           (?(DEFINE)
\&                               (?<EXAMPLE> 1 )  # Second capture
\&                           )/x;
\&    say scalar @captures;
.Ve
.Sp
Will output 2, not 1. This is particularly important if you intend to
compile the definitions with the \f(CW\*(C`qr//\*(C'\fR operator, and later
interpolate them in another pattern.
.RE
.ie n .IP """(?>pattern)""" 4
.el .IP "\f(CW(?>pattern)\fR" 4
.IX Xref "backtrack backtracking atomic possessive"
.IX Item "(?>pattern)"
An \*(L"independent\*(R" subexpression, one which matches the substring
that a \fIstandalone\fR \f(CW\*(C`pattern\*(C'\fR would match if anchored at the given
position, and it matches \fInothing other than this substring\fR.  This
construct is useful for optimizations of what would otherwise be
\&\*(L"eternal\*(R" matches, because it will not backtrack (see \*(L"Backtracking\*(R").
It may also be useful in places where the \*(L"grab all you can, and do not
give anything back\*(R" semantic is desirable.
.Sp
For example: \f(CW\*(C`^(?>a*)ab\*(C'\fR will never match, since \f(CW\*(C`(?>a*)\*(C'\fR
(anchored at the beginning of string, as above) will match \fIall\fR
characters \f(CW\*(C`a\*(C'\fR at the beginning of string, leaving no \f(CW\*(C`a\*(C'\fR for
\&\f(CW\*(C`ab\*(C'\fR to match.  In contrast, \f(CW\*(C`a*ab\*(C'\fR will match the same as \f(CW\*(C`a+b\*(C'\fR,
since the match of the subgroup \f(CW\*(C`a*\*(C'\fR is influenced by the following
group \f(CW\*(C`ab\*(C'\fR (see \*(L"Backtracking\*(R").  In particular, \f(CW\*(C`a*\*(C'\fR inside
\&\f(CW\*(C`a*ab\*(C'\fR will match fewer characters than a standalone \f(CW\*(C`a*\*(C'\fR, since
this makes the tail match.
.Sp
\&\f(CW\*(C`(?>pattern)\*(C'\fR does not disable backtracking altogether once it has
matched. It is still possible to backtrack past the construct, but not
into it. So \f(CW\*(C`((?>a*)|(?>b*))ar\*(C'\fR will still match \*(L"bar\*(R".
.Sp
An effect similar to \f(CW\*(C`(?>pattern)\*(C'\fR may be achieved by writing
\&\f(CW\*(C`(?=(pattern))\eg{\-1}\*(C'\fR.  This matches the same substring as a standalone
\&\f(CW\*(C`a+\*(C'\fR, and the following \f(CW\*(C`\eg{\-1}\*(C'\fR eats the matched string; it therefore
makes a zero-length assertion into an analogue of \f(CW\*(C`(?>...)\*(C'\fR.
(The difference between these two constructs is that the second one
uses a capturing group, thus shifting ordinals of backreferences
in the rest of a regular expression.)
.Sp
Consider this pattern:
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            [^()]+           # x+
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
That will efficiently match a nonempty group with matching parentheses
two levels deep or less.  However, if there is no such group, it
will take virtually forever on a long string.  That's because there
are so many different ways to split a long string into several
substrings.  This is what \f(CW\*(C`(.+)+\*(C'\fR is doing, and \f(CW\*(C`(.+)+\*(C'\fR is similar
to a subpattern of the above pattern.  Consider how the pattern
above detects no-match on \f(CW\*(C`((()aaaaaaaaaaaaaaaaaa\*(C'\fR in several
seconds, but that each extra letter doubles this time.  This
exponential performance will make it appear that your program has
hung.  However, a tiny change to this pattern
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            (?> [^()]+ )        # change x+ above to (?> x+ )
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
which uses \f(CW\*(C`(?>...)\*(C'\fR matches exactly when the one above does (verifying
this yourself would be a productive exercise), but finishes in a fourth
the time when used on a similar string with 1000000 \f(CW\*(C`a\*(C'\fRs.  Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the \f(CW\*(C`use warnings\*(C'\fR pragma or \fB\-w\fR switch saying it
\&\f(CW"matches null string many times in regex"\fR.
.Sp
On simple groups, such as the pattern \f(CW\*(C`(?> [^()]+ )\*(C'\fR, a comparable
effect may be achieved by negative look-ahead, as in \f(CW\*(C`[^()]+ (?! [^()] )\*(C'\fR.
This was only 4 times slower on a string with 1000000 \f(CW\*(C`a\*(C'\fRs.
.Sp
The \*(L"grab all you can, and do not give anything back\*(R" semantic is desirable
in many situations where on the first sight a simple \f(CW\*(C`()*\*(C'\fR looks like
the correct solution.  Suppose we parse text with comments being delimited
by \f(CW\*(C`#\*(C'\fR followed by some optional (horizontal) whitespace.  Contrary to
its appearance, \f(CW\*(C`#[ \et]*\*(C'\fR \fIis not\fR the correct subexpression to match
the comment delimiter, because it may \*(L"give up\*(R" some whitespace if
the remainder of the pattern can be made to match that way.  The correct
answer is either one of these:
.Sp
.Vb 2
\&    (?>#[ \et]*)
\&    #[ \et]*(?![ \et])
.Ve
.Sp
For example, to grab non-empty comments into \f(CW$1\fR, one should use either
one of these:
.Sp
.Vb 2
\&    / (?> \e# [ \et]* ) (        .+ ) /x;
\&    /     \e# [ \et]*   ( [^ \et] .* ) /x;
.Ve
.Sp
Which one you pick depends on which of these expressions better reflects
the above specification of comments.
.Sp
In some literature this construct is called \*(L"atomic matching\*(R" or
\&\*(L"possessive matching\*(R".
.Sp
Possessive quantifiers are equivalent to putting the item they are applied
to inside of one of these constructs. The following equivalences apply:
.Sp
.Vb 6
\&    Quantifier Form     Bracketing Form
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PAT*+               (?>PAT*)
\&    PAT++               (?>PAT+)
\&    PAT?+               (?>PAT?)
\&    PAT{min,max}+       (?>PAT{min,max})
.Ve
.ie n .IP """(?[ ])""" 4
.el .IP "\f(CW(?[ ])\fR" 4
.IX Item "(?[ ])"
See \*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass.
.SS "Special Backtracking Control Verbs"
.IX Subsection "Special Backtracking Control Verbs"
\&\fB\s-1WARNING:\s0\fR These patterns are experimental and subject to change or
removal in a future version of Perl. Their usage in production code should
be noted to avoid problems during upgrades.
.PP
These special patterns are generally of the form \f(CW\*(C`(*VERB:ARG)\*(C'\fR. Unless
otherwise stated the \s-1ARG\s0 argument is optional; in some cases, it is
forbidden.
.PP
Any pattern containing a special backtracking verb that allows an argument
has the special behaviour that when executed it sets the current package's
\&\f(CW$REGERROR\fR and \f(CW$REGMARK\fR variables. When doing so the following
rules apply:
.PP
On failure, the \f(CW$REGERROR\fR variable will be set to the \s-1ARG\s0 value of the
verb pattern, if the verb was involved in the failure of the match. If the
\&\s-1ARG\s0 part of the pattern was omitted, then \f(CW$REGERROR\fR will be set to the
name of the last \f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed, or to \s-1TRUE\s0 if there was
none. Also, the \f(CW$REGMARK\fR variable will be set to \s-1FALSE.\s0
.PP
On a successful match, the \f(CW$REGERROR\fR variable will be set to \s-1FALSE,\s0 and
the \f(CW$REGMARK\fR variable will be set to the name of the last
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed.  See the explanation for the
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR verb below for more details.
.PP
\&\fB\s-1NOTE:\s0\fR \f(CW$REGERROR\fR and \f(CW$REGMARK\fR are not magic variables like \f(CW$1\fR
and most other regex-related variables. They are not local to a scope, nor
readonly, but instead are volatile package variables similar to \f(CW$AUTOLOAD\fR.
Use \f(CW\*(C`local\*(C'\fR to localize changes to them to a specific scope if necessary.
.PP
If a pattern does not contain a special backtracking verb that allows an
argument, then \f(CW$REGERROR\fR and \f(CW$REGMARK\fR are not touched at all.
.IP "Verbs that take an argument" 3
.IX Item "Verbs that take an argument"
.RS 3
.PD 0
.ie n .IP """(*PRUNE)"" ""(*PRUNE:NAME)""" 4
.el .IP "\f(CW(*PRUNE)\fR \f(CW(*PRUNE:NAME)\fR" 4
.IX Xref "(*PRUNE) (*PRUNE:NAME)"
.IX Item "(*PRUNE) (*PRUNE:NAME)"
.PD
This zero-width pattern prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern \f(CW\*(C`A (*PRUNE) B\*(C'\fR,
where A and B are complex patterns. Until the \f(CW\*(C`(*PRUNE)\*(C'\fR verb is reached,
A may backtrack as necessary to match. Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.
.Sp
The following example counts all the possible matching strings in a
pattern (without actually matching any of them).
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
which produces:
.Sp
.Vb 10
\&    aaab
\&    aaa
\&    aa
\&    a
\&    aab
\&    aa
\&    a
\&    ab
\&    a
\&    Count=9
.Ve
.Sp
If we add a \f(CW\*(C`(*PRUNE)\*(C'\fR before the count like the following
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(*PRUNE)(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
we prevent backtracking and find the count of the longest matching string
at each matching starting point like so:
.Sp
.Vb 4
\&    aaab
\&    aab
\&    ab
\&    Count=3
.Ve
.Sp
Any number of \f(CW\*(C`(*PRUNE)\*(C'\fR assertions may be used in a pattern.
.Sp
See also \f(CW\*(C`(?>pattern)\*(C'\fR and possessive quantifiers for other ways to
control backtracking. In some cases, the use of \f(CW\*(C`(*PRUNE)\*(C'\fR can be
replaced with a \f(CW\*(C`(?>pattern)\*(C'\fR with no functional difference; however,
\&\f(CW\*(C`(*PRUNE)\*(C'\fR can be used to handle cases that cannot be expressed using a
\&\f(CW\*(C`(?>pattern)\*(C'\fR alone.
.ie n .IP """(*SKIP)"" ""(*SKIP:NAME)""" 4
.el .IP "\f(CW(*SKIP)\fR \f(CW(*SKIP:NAME)\fR" 4
.IX Xref "(*SKIP)"
.IX Item "(*SKIP) (*SKIP:NAME)"
This zero-width pattern is similar to \f(CW\*(C`(*PRUNE)\*(C'\fR, except that on
failure it also signifies that whatever text that was matched leading up
to the \f(CW\*(C`(*SKIP)\*(C'\fR pattern being executed cannot be part of \fIany\fR match
of this pattern. This effectively means that the regex engine \*(L"skips\*(R" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).
.Sp
The name of the \f(CW\*(C`(*SKIP:NAME)\*(C'\fR pattern has special significance. If a
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR was encountered while matching, then it is that position
which is used as the \*(L"skip point\*(R". If no \f(CW\*(C`(*MARK)\*(C'\fR of that name was
encountered, then the \f(CW\*(C`(*SKIP)\*(C'\fR operator has no effect. When used
without a name the \*(L"skip point\*(R" is where the match point was when
executing the (*SKIP) pattern.
.Sp
Compare the following to the examples in \f(CW\*(C`(*PRUNE)\*(C'\fR; note the string
is twice as long:
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*SKIP)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 3
\&    aaab
\&    aaab
\&    Count=2
.Ve
.Sp
Once the 'aaab' at the start of the string has matched, and the \f(CW\*(C`(*SKIP)\*(C'\fR
executed, the next starting point will be where the cursor was when the
\&\f(CW\*(C`(*SKIP)\*(C'\fR was executed.
.ie n .IP """(*MARK:NAME)"" ""(*:NAME)""" 4
.el .IP "\f(CW(*MARK:NAME)\fR \f(CW(*:NAME)\fR" 4
.IX Xref "(*MARK) (*MARK:NAME) (*:NAME)"
.IX Item "(*MARK:NAME) (*:NAME)"
This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later \f(CW\*(C`(*SKIP)\*(C'\fR pattern will then skip
forward to that point if backtracked into on failure. Any number of
\&\f(CW\*(C`(*MARK)\*(C'\fR patterns are allowed, and the \s-1NAME\s0 portion may be duplicated.
.Sp
In addition to interacting with the \f(CW\*(C`(*SKIP)\*(C'\fR pattern, \f(CW\*(C`(*MARK:NAME)\*(C'\fR
can be used to \*(L"label\*(R" a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.
.Sp
When a match is successful, the \f(CW$REGMARK\fR variable will be set to the
name of the most recently executed \f(CW\*(C`(*MARK:NAME)\*(C'\fR that was involved
in the match.
.Sp
This can be used to determine which branch of a pattern was matched
without using a separate capture group for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
\&\f(CW\*(C`/(?:(x)|(y)|(z))/\*(C'\fR as efficiently as something like
\&\f(CW\*(C`/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/\*(C'\fR.
.Sp
When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the \f(CW$REGERROR\fR
variable will be set to the name of the most recently executed
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR.
.Sp
See \*(L"(*SKIP)\*(R" for more details.
.Sp
As a shortcut \f(CW\*(C`(*MARK:NAME)\*(C'\fR can be written \f(CW\*(C`(*:NAME)\*(C'\fR.
.ie n .IP """(*THEN)"" ""(*THEN:NAME)""" 4
.el .IP "\f(CW(*THEN)\fR \f(CW(*THEN:NAME)\fR" 4
.IX Item "(*THEN) (*THEN:NAME)"
This is similar to the \*(L"cut group\*(R" operator \f(CW\*(C`::\*(C'\fR from Perl 6.  Like
\&\f(CW\*(C`(*PRUNE)\*(C'\fR, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise) that has alternations.
The two branches of a \f(CW\*(C`(?(condition)yes\-pattern|no\-pattern)\*(C'\fR do not
count as an alternation, as far as \f(CW\*(C`(*THEN)\*(C'\fR is concerned.
.Sp
Its name comes from the observation that this operation combined with the
alternation operator (\f(CW\*(C`|\*(C'\fR) can be used to create what is essentially a
pattern-based if/then/else block:
.Sp
.Vb 1
\&  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )
.Ve
.Sp
Note that if this operator is used and \s-1NOT\s0 inside of an alternation then
it acts exactly like the \f(CW\*(C`(*PRUNE)\*(C'\fR operator.
.Sp
.Vb 1
\&  / A (*PRUNE) B /
.Ve
.Sp
is the same as
.Sp
.Vb 1
\&  / A (*THEN) B /
.Ve
.Sp
but
.Sp
.Vb 1
\&  / ( A (*THEN) B | C ) /
.Ve
.Sp
is not the same as
.Sp
.Vb 1
\&  / ( A (*PRUNE) B | C ) /
.Ve
.Sp
as after matching the A but failing on the B the \f(CW\*(C`(*THEN)\*(C'\fR verb will
backtrack and try C; but the \f(CW\*(C`(*PRUNE)\*(C'\fR verb will simply fail.
.RE
.RS 3
.RE
.IP "Verbs without an argument" 3
.IX Item "Verbs without an argument"
.RS 3
.PD 0
.ie n .IP """(*COMMIT)""" 4
.el .IP "\f(CW(*COMMIT)\fR" 4
.IX Xref "(*COMMIT)"
.IX Item "(*COMMIT)"
.PD
This is the Perl 6 \*(L"commit pattern\*(R" \f(CW\*(C`<commit>\*(C'\fR or \f(CW\*(C`:::\*(C'\fR. It's a
zero-width pattern similar to \f(CW\*(C`(*SKIP)\*(C'\fR, except that when backtracked
into on failure it causes the match to fail outright. No further attempts
to find a valid match by advancing the start pointer will occur again.
For example,
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*COMMIT)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 2
\&    aaab
\&    Count=1
.Ve
.Sp
In other words, once the \f(CW\*(C`(*COMMIT)\*(C'\fR has been entered, and if the pattern
does not match, the regex engine will not try any further matching on the
rest of the string.
.ie n .IP """(*FAIL)"" ""(*F)""" 4
.el .IP "\f(CW(*FAIL)\fR \f(CW(*F)\fR" 4
.IX Xref "(*FAIL) (*F)"
.IX Item "(*FAIL) (*F)"
This pattern matches nothing and always fails. It can be used to force the
engine to backtrack. It is equivalent to \f(CW\*(C`(?!)\*(C'\fR, but easier to read. In
fact, \f(CW\*(C`(?!)\*(C'\fR gets optimised into \f(CW\*(C`(*FAIL)\*(C'\fR internally.
.Sp
It is probably useful only when combined with \f(CW\*(C`(?{})\*(C'\fR or \f(CW\*(C`(??{})\*(C'\fR.
.ie n .IP """(*ACCEPT)""" 4
.el .IP "\f(CW(*ACCEPT)\fR" 4
.IX Xref "(*ACCEPT)"
.IX Item "(*ACCEPT)"
\&\fB\s-1WARNING:\s0\fR This feature is highly experimental. It is not recommended
for production code.
.Sp
This pattern matches nothing and causes the end of successful matching at
the point at which the \f(CW\*(C`(*ACCEPT)\*(C'\fR pattern was encountered, regardless of
whether there is actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via \f(CW\*(C`(??{})\*(C'\fR, only the innermost pattern is ended immediately.
.Sp
If the \f(CW\*(C`(*ACCEPT)\*(C'\fR is inside of capturing groups then the groups are
marked as ended at the point at which the \f(CW\*(C`(*ACCEPT)\*(C'\fR was encountered.
For instance:
.Sp
.Vb 1
\&  \*(AqAB\*(Aq =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;
.Ve
.Sp
will match, and \f(CW$1\fR will be \f(CW\*(C`AB\*(C'\fR and \f(CW$2\fR will be \f(CW\*(C`B\*(C'\fR, \f(CW$3\fR will not
be set. If another branch in the inner parentheses was matched, such as in the
string '\s-1ACDE\s0', then the \f(CW\*(C`D\*(C'\fR and \f(CW\*(C`E\*(C'\fR would have to be matched as well.
.RE
.RS 3
.RE
.SS "Backtracking"
.IX Xref "backtrack backtracking"
.IX Subsection "Backtracking"
\&\s-1NOTE:\s0 This section presents an abstract approximation of regular
expression behavior.  For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see \*(L"Combining \s-1RE\s0 Pieces\*(R".
.PP
A fundamental feature of regular expression matching involves the
notion called \fIbacktracking\fR, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}\*(C'\fR, and \f(CW\*(C`{n,m}?\*(C'\fR.  Backtracking is often optimized
internally, but the general principle outlined here is valid.
.PP
For a regular expression to match, the \fIentire\fR regular expression must
match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part\*(--that's why it's called backtracking.
.PP
Here is an example of backtracking:  Let's say you want to find the
word following \*(L"foo\*(R" in the string \*(L"Food is on the foo table.\*(R":
.PP
.Vb 4
\&    $_ = "Food is on the foo table.";
\&    if ( /\eb(foo)\es+(\ew+)/i ) {
\&        print "$2 follows $1.\en";
\&    }
.Ve
.PP
When the match runs, the first part of the regular expression (\f(CW\*(C`\eb(foo)\*(C'\fR)
finds a possible match right at the beginning of the string, and loads up
\&\f(CW$1\fR with \*(L"Foo\*(R".  However, as soon as the matching engine sees that there's
no whitespace following the \*(L"Foo\*(R" that it had saved in \f(CW$1\fR, it realizes its
mistake and starts over again one character after where it had the
tentative match.  This time it goes all the way until the next occurrence
of \*(L"foo\*(R". The complete regular expression matches this time, and you get
the expected output of \*(L"table follows foo.\*(R"
.PP
Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between \*(L"foo\*(R" and \*(L"bar\*(R".  Initially, you write something
like this:
.PP
.Vb 4
\&    $_ =  "The food is under the bar in the barn.";
\&    if ( /foo(.*)bar/ ) {
\&        print "got <$1>\en";
\&    }
.Ve
.PP
Which perhaps unexpectedly yields:
.PP
.Vb 1
\&  got <d is under the bar in the >
.Ve
.PP
That's because \f(CW\*(C`.*\*(C'\fR was greedy, so you get everything between the
\&\fIfirst\fR \*(L"foo\*(R" and the \fIlast\fR \*(L"bar\*(R".  Here it's more effective
to use minimal matching to make sure you get the text between a \*(L"foo\*(R"
and the first \*(L"bar\*(R" thereafter.
.PP
.Vb 2
\&    if ( /foo(.*?)bar/ ) { print "got <$1>\en" }
\&  got <d is under the >
.Ve
.PP
Here's another example. Let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part of the match.
So you write this:
.PP
.Vb 4
\&    $_ = "I have 2 numbers: 53147";
\&    if ( /(.*)(\ed*)/ ) {                                # Wrong!
\&        print "Beginning is <$1>, number is <$2>.\en";
\&    }
.Ve
.PP
That won't work at all, because \f(CW\*(C`.*\*(C'\fR was greedy and gobbled up the
whole string. As \f(CW\*(C`\ed*\*(C'\fR can match on an empty string the complete
regular expression matched successfully.
.PP
.Vb 1
\&    Beginning is <I have 2 numbers: 53147>, number is <>.
.Ve
.PP
Here are some variants, most of which don't work:
.PP
.Vb 11
\&    $_ = "I have 2 numbers: 53147";
\&    @pats = qw{
\&        (.*)(\ed*)
\&        (.*)(\ed+)
\&        (.*?)(\ed*)
\&        (.*?)(\ed+)
\&        (.*)(\ed+)$
\&        (.*?)(\ed+)$
\&        (.*)\eb(\ed+)$
\&        (.*\eD)(\ed+)$
\&    };
\&
\&    for $pat (@pats) {
\&        printf "%\-12s ", $pat;
\&        if ( /$pat/ ) {
\&            print "<$1> <$2>\en";
\&        } else {
\&            print "FAIL\en";
\&        }
\&    }
.Ve
.PP
That will print out:
.PP
.Vb 8
\&    (.*)(\ed*)    <I have 2 numbers: 53147> <>
\&    (.*)(\ed+)    <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed*)   <> <>
\&    (.*?)(\ed+)   <I have > <2>
\&    (.*)(\ed+)$   <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed+)$  <I have 2 numbers: > <53147>
\&    (.*)\eb(\ed+)$ <I have 2 numbers: > <53147>
\&    (.*\eD)(\ed+)$ <I have 2 numbers: > <53147>
.Ve
.PP
As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.
.PP
When using look-ahead assertions and negations, this can all get even
trickier.  Imagine you'd like to find a sequence of non-digits not
followed by \*(L"123\*(R".  You might try to write that as
.PP
.Vb 4
\&    $_ = "ABC123";
\&    if ( /^\eD*(?!123)/ ) {                # Wrong!
\&        print "Yup, no 123 in $_\en";
\&    }
.Ve
.PP
But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why that pattern matches, contrary to popular expectations:
.PP
.Vb 2
\&    $x = \*(AqABC123\*(Aq;
\&    $y = \*(AqABC445\*(Aq;
\&
\&    print "1: got $1\en" if $x =~ /^(ABC)(?!123)/;
\&    print "2: got $1\en" if $y =~ /^(ABC)(?!123)/;
\&
\&    print "3: got $1\en" if $x =~ /^(\eD*)(?!123)/;
\&    print "4: got $1\en" if $y =~ /^(\eD*)(?!123)/;
.Ve
.PP
This prints
.PP
.Vb 3
\&    2: got ABC
\&    3: got AB
\&    4: got ABC
.Ve
.PP
You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (\f(CW\*(C`\eD*\*(C'\fR) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked \*(L"Is it true that at the start of \f(CW$x\fR, following 0 or more
non-digits, you have something that's not 123?\*(R"  If the pattern matcher had
let \f(CW\*(C`\eD*\*(C'\fR expand to \*(L"\s-1ABC\*(R",\s0 this would have caused the whole pattern to
fail.
.PP
The search engine will initially match \f(CW\*(C`\eD*\*(C'\fR with \*(L"\s-1ABC\*(R". \s0 Then it will
try to match \f(CW\*(C`(?!123)\*(C'\fR with \*(L"123\*(R", which fails.  But because
a quantifier (\f(CW\*(C`\eD*\*(C'\fR) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.
.PP
The pattern really, \fIreally\fR wants to succeed, so it uses the
standard pattern back-off-and-retry and lets \f(CW\*(C`\eD*\*(C'\fR expand to just \*(L"\s-1AB\*(R"\s0 this
time.  Now there's indeed something following \*(L"\s-1AB\*(R"\s0 that is not
\&\*(L"123\*(R".  It's \*(L"C123\*(R", which suffices.
.PP
We can deal with this by using both an assertion and a negation.
We'll say that the first part in \f(CW$1\fR must be followed both by a digit
and by something that's not \*(L"123\*(R".  Remember that the look-aheads
are zero-width expressions\*(--they only look, but don't consume any
of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:
.PP
.Vb 2
\&    print "5: got $1\en" if $x =~ /^(\eD*)(?=\ed)(?!123)/;
\&    print "6: got $1\en" if $y =~ /^(\eD*)(?=\ed)(?!123)/;
\&
\&    6: got ABC
.Ve
.PP
In other words, the two zero-width assertions next to each other work as though
they're ANDed together, just as you'd use any built-in assertions:  \f(CW\*(C`/^$/\*(C'\fR
matches only if you're at the beginning of the line \s-1AND\s0 the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means \s-1AND,\s0 except when you write an explicit \s-1OR\s0
using the vertical bar.  \f(CW\*(C`/ab/\*(C'\fR means match \*(L"a\*(R" \s-1AND \s0(then) match \*(L"b\*(R",
although the attempted matches are made at different positions because \*(L"a\*(R"
is not a zero-width assertion, but a one-width assertion.
.PP
\&\fB\s-1WARNING\s0\fR: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.  For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:
.PP
.Vb 1
\&    \*(Aqaaaaaaaaaaaa\*(Aq =~ /((a{0,5}){0,5})*[c]/
.Ve
.PP
And if you used \f(CW\*(C`*\*(C'\fR's in the internal groups instead of limiting them
to 0 through 5 matches, then it would take forever\*(--or until you ran
out of stack space.  Moreover, these internal optimizations are not
always applicable.  For example, if you put \f(CW\*(C`{0,5}\*(C'\fR instead of \f(CW\*(C`*\*(C'\fR
on the external group, no current optimization is applicable, and the
match takes a long time to finish.
.PP
A powerful tool for optimizing such beasts is what is known as an
\&\*(L"independent group\*(R",
which does not backtrack (see "\f(CW\*(C`(?>pattern)\*(C'\fR").  Note also that
zero-length look\-ahead/look\-behind assertions will not backtrack to make
the tail match, since they are in \*(L"logical\*(R" context: only
whether they match is considered relevant.  For an example
where side-effects of look-ahead \fImight\fR have influenced the
following match, see "\f(CW\*(C`(?>pattern)\*(C'\fR".
.SS "Version 8 Regular Expressions"
.IX Xref "regular expression, version 8 regex, version 8 regexp, version 8"
.IX Subsection "Version 8 Regular Expressions"
In case you're not familiar with the \*(L"regular\*(R" Version 8 regex
routines, here are the pattern-matching rules not described above.
.PP
Any single character matches itself, unless it is a \fImetacharacter\fR
with a special meaning described here or above.  You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a \*(L"\e\*(R" (e.g., \*(L"\e.\*(R" matches a \*(L".\*(R", not any
character; \*(L"\e\e\*(R" matches a \*(L"\e\*(R"). This escape mechanism is also required
for the character used as the pattern delimiter.
.PP
A series of characters matches that series of characters in the target
string, so the pattern \f(CW\*(C`blurfl\*(C'\fR would match \*(L"blurfl\*(R" in the target
string.
.PP
You can specify a character class, by enclosing a list of characters
in \f(CW\*(C`[]\*(C'\fR, which will match any character from the list.  If the
first character after the \*(L"[\*(R" is \*(L"^\*(R", the class matches any character not
in the list.  Within a list, the \*(L"\-\*(R" character specifies a
range, so that \f(CW\*(C`a\-z\*(C'\fR represents all characters between \*(L"a\*(R" and \*(L"z\*(R",
inclusive.  If you want either \*(L"\-\*(R" or \*(L"]\*(R" itself to be a member of a
class, put it at the start of the list (possibly after a \*(L"^\*(R"), or
escape it with a backslash.  \*(L"\-\*(R" is also taken literally when it is
at the end of the list, just before the closing \*(L"]\*(R".  (The
following all specify the same class of three characters: \f(CW\*(C`[\-az]\*(C'\fR,
\&\f(CW\*(C`[az\-]\*(C'\fR, and \f(CW\*(C`[a\e\-z]\*(C'\fR.  All are different from \f(CW\*(C`[a\-z]\*(C'\fR, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, or \f(CW\*(C`\eD\*(C'\fR as endpoints of
a range, the \*(L"\-\*(R" is understood literally.
.PP
Note also that the whole range idea is rather unportable between
character sets\*(--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a\-e],
[A\-E]), or digits ([0\-9]).  Anything else is unsafe.  If in doubt,
spell out the character sets in full.
.PP
Characters may be specified using a metacharacter syntax much like that
used in C: \*(L"\en\*(R" matches a newline, \*(L"\et\*(R" a tab, \*(L"\er\*(R" a carriage return,
\&\*(L"\ef\*(R" a form feed, etc.  More generally, \e\fInnn\fR, where \fInnn\fR is a string
of three octal digits, matches the character whose coded character set value
is \fInnn\fR.  Similarly, \ex\fInn\fR, where \fInn\fR are hexadecimal digits,
matches the character whose ordinal is \fInn\fR. The expression \ec\fIx\fR
matches the character control\-\fIx\fR.  Finally, the \*(L".\*(R" metacharacter
matches any character except \*(L"\en\*(R" (unless you use \f(CW\*(C`/s\*(C'\fR).
.PP
You can specify a series of alternatives for a pattern using \*(L"|\*(R" to
separate them, so that \f(CW\*(C`fee|fie|foe\*(C'\fR will match any of \*(L"fee\*(R", \*(L"fie\*(R",
or \*(L"foe\*(R" in the target string (as would \f(CW\*(C`f(e|i|o)e\*(C'\fR).  The
first alternative includes everything from the last pattern delimiter
(\*(L"(\*(R", \*(L"(?:\*(R", etc. or the beginning of the pattern) up to the first \*(L"|\*(R", and
the last alternative contains everything from the last \*(L"|\*(R" to the next
closing pattern delimiter.  That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.
.PP
Alternatives are tried from left to right, so the first
alternative found for which the entire expression matches, is the one that
is chosen. This means that alternatives are not necessarily greedy. For
example: when matching \f(CW\*(C`foo|foot\*(C'\fR against \*(L"barefoot\*(R", only the \*(L"foo\*(R"
part will match, as that is the first alternative tried, and it successfully
matches the target string. (This might not seem important, but it is
important when you are capturing matched text using parentheses.)
.PP
Also remember that \*(L"|\*(R" is interpreted as a literal within square brackets,
so if you write \f(CW\*(C`[fee|fie|foe]\*(C'\fR you're really only matching \f(CW\*(C`[feio|]\*(C'\fR.
.PP
Within a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to the
\&\fIn\fRth subpattern later in the pattern using the metacharacter
\&\e\fIn\fR or \eg\fIn\fR.  Subpatterns are numbered based on the left to right order
of their opening parenthesis.  A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.  Therefore, \f(CW\*(C`(0|0x)\ed*\es\eg1\ed*\*(C'\fR will
match \*(L"0x1234 0x4321\*(R", but not \*(L"0x1234 01234\*(R", because subpattern
1 matched \*(L"0x\*(R", even though the rule \f(CW\*(C`0|0x\*(C'\fR could potentially match
the leading 0 in the second number.
.ie n .SS "Warning on \e1 Instead of $1"
.el .SS "Warning on \e1 Instead of \f(CW$1\fP"
.IX Subsection "Warning on 1 Instead of $1"
Some people get too used to writing things like:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e\e1/g;
.Ve
.PP
This is grandfathered (for \e1 to \e9) for the \s-1RHS\s0 of a substitute to avoid
shocking the
\&\fBsed\fR addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of an \f(CW\*(C`s///\*(C'\fR is a double-quoted string.  \f(CW\*(C`\e1\*(C'\fR in
the usual double-quoted string means a control-A.  The customary Unix
meaning of \f(CW\*(C`\e1\*(C'\fR is kludged in for \f(CW\*(C`s///\*(C'\fR.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an \f(CW\*(C`/e\*(C'\fR
modifier.
.PP
.Vb 1
\&    s/(\ed+)/ \e1 + 1 /eg;            # causes warning under \-w
.Ve
.PP
Or if you try to do
.PP
.Vb 1
\&    s/(\ed+)/\e1000/;
.Ve
.PP
You can't disambiguate that by saying \f(CW\*(C`\e{1}000\*(C'\fR, whereas you can fix it with
\&\f(CW\*(C`${1}000\*(C'\fR.  The operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the \fIleft\fR side of the \f(CW\*(C`s///\*(C'\fR.
.SS "Repeated Patterns Matching a Zero-length Substring"
.IX Subsection "Repeated Patterns Matching a Zero-length Substring"
\&\fB\s-1WARNING\s0\fR: Difficult material (and prose) ahead.  This section needs a rewrite.
.PP
Regular expressions provide a terse and powerful programming language.  As
with most other power tools, power comes together with the ability
to wreak havoc.
.PP
A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:
.PP
.Vb 1
\&    \*(Aqfoo\*(Aq =~ m{ ( o? )* }x;
.Ve
.PP
The \f(CW\*(C`o?\*(C'\fR matches at the beginning of \f(CW\*(Aqfoo\*(Aq\fR, and since the position
in the string is not moved by the match, \f(CW\*(C`o?\*(C'\fR would match again and again
because of the \f(CW\*(C`*\*(C'\fR quantifier.  Another common way to create a similar cycle
is with the looping modifier \f(CW\*(C`//g\*(C'\fR:
.PP
.Vb 1
\&    @matches = ( \*(Aqfoo\*(Aq =~ m{ o? }xg );
.Ve
.PP
or
.PP
.Vb 1
\&    print "match: <$&>\en" while \*(Aqfoo\*(Aq =~ m{ o? }xg;
.Ve
.PP
or the loop implied by \fIsplit()\fR.
.PP
However, long experience has shown that many programming tasks may
be significantly simplified by using repeated subexpressions that
may match zero-length substrings.  Here's a simple example being:
.PP
.Vb 2
\&    @chars = split //, $string;           # // is not magic in split
\&    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /
.Ve
.PP
Thus Perl allows such constructs, by \fIforcefully breaking
the infinite loop\fR.  The rules for this are different for lower-level
loops given by the greedy quantifiers \f(CW\*(C`*+{}\*(C'\fR, and for higher-level
ones like the \f(CW\*(C`/g\*(C'\fR modifier or \fIsplit()\fR operator.
.PP
The lower-level loops are \fIinterrupted\fR (that is, the loop is
broken) when Perl detects that a repeated expression matched a
zero-length substring.   Thus
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
.Ve
.PP
is made equivalent to
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;
.Ve
.PP
For example, this program
.PP
.Vb 12
\&   #!perl \-l
\&   "aaaaab" =~ /
\&     (?:
\&        a                 # non\-zero
\&        |                 # or
\&       (?{print "hello"}) # print hello whenever this
\&                          #    branch is tried
\&       (?=(b))            # zero\-width assertion
\&     )*  # any number of times
\&    /x;
\&   print $&;
\&   print $1;
.Ve
.PP
prints
.PP
.Vb 3
\&   hello
\&   aaaaa
\&   b
.Ve
.PP
Notice that \*(L"hello\*(R" is only printed once, as when Perl sees that the sixth
iteration of the outermost \f(CW\*(C`(?:)*\*(C'\fR matches a zero-length string, it stops
the \f(CW\*(C`*\*(C'\fR.
.PP
The higher-level loops preserve an additional state between iterations:
whether the last match was zero-length.  To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.
This prohibition interacts with backtracking (see \*(L"Backtracking\*(R"),
and so the \fIsecond best\fR match is chosen if the \fIbest\fR match is of
zero length.
.PP
For example:
.PP
.Vb 2
\&    $_ = \*(Aqbar\*(Aq;
\&    s/\ew??/<$&>/g;
.Ve
.PP
results in \f(CW\*(C`<><b><><a><><r><>\*(C'\fR.  At each position of the string the best
match given by non-greedy \f(CW\*(C`??\*(C'\fR is the zero-length match, and the \fIsecond
best\fR match is what is matched by \f(CW\*(C`\ew\*(C'\fR.  Thus zero-length matches
alternate with one-character-long matches.
.PP
Similarly, for repeated \f(CW\*(C`m/()/g\*(C'\fR the second-best match is the match at the
position one notch further in the string.
.PP
The additional state of being \fImatched with zero-length\fR is associated with
the matched string, and is reset by each assignment to \fIpos()\fR.
Zero-length matches at the end of the previous match are ignored
during \f(CW\*(C`split\*(C'\fR.
.SS "Combining \s-1RE\s0 Pieces"
.IX Subsection "Combining RE Pieces"
Each of the elementary pieces of regular expressions which were described
before (such as \f(CW\*(C`ab\*(C'\fR or \f(CW\*(C`\eZ\*(C'\fR) could match at most one substring
at the given position of the input string.  However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators \f(CW\*(C`ST\*(C'\fR, \f(CW\*(C`S|T\*(C'\fR, \f(CW\*(C`S*\*(C'\fR etc.
(in these examples \f(CW\*(C`S\*(C'\fR and \f(CW\*(C`T\*(C'\fR are regular subexpressions).
.PP
Such combinations can include alternatives, leading to a problem of choice:
if we match a regular expression \f(CW\*(C`a|ab\*(C'\fR against \f(CW"abc"\fR, will it match
substring \f(CW"a"\fR or \f(CW"ab"\fR?  One way to describe which substring is
actually matched is the concept of backtracking (see \*(L"Backtracking\*(R").
However, this description is too low-level and makes you think
in terms of a particular implementation.
.PP
Another description starts with notions of \*(L"better\*(R"/\*(L"worse\*(R".  All the
substrings which may be matched by the given regular expression can be
sorted from the \*(L"best\*(R" match to the \*(L"worst\*(R" match, and it is the \*(L"best\*(R"
match which is chosen.  This substitutes the question of \*(L"what is chosen?\*(R"
by the question of \*(L"which matches are better, and which are worse?\*(R".
.PP
Again, for elementary pieces there is no such question, since at most
one match at a given position is possible.  This section describes the
notion of better/worse for combining operators.  In the description
below \f(CW\*(C`S\*(C'\fR and \f(CW\*(C`T\*(C'\fR are regular subexpressions.
.ie n .IP """ST""" 4
.el .IP "\f(CWST\fR" 4
.IX Item "ST"
Consider two possible matches, \f(CW\*(C`AB\*(C'\fR and \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR, \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`A\*(Aq\*(C'\fR are
substrings which can be matched by \f(CW\*(C`S\*(C'\fR, \f(CW\*(C`B\*(C'\fR and \f(CW\*(C`B\*(Aq\*(C'\fR are substrings
which can be matched by \f(CW\*(C`T\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR is a better match for \f(CW\*(C`S\*(C'\fR than \f(CW\*(C`A\*(Aq\*(C'\fR, \f(CW\*(C`AB\*(C'\fR is a better
match than \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`A\*(Aq\*(C'\fR coincide: \f(CW\*(C`AB\*(C'\fR is a better match than \f(CW\*(C`AB\*(Aq\*(C'\fR if
\&\f(CW\*(C`B\*(C'\fR is a better match for \f(CW\*(C`T\*(C'\fR than \f(CW\*(C`B\*(Aq\*(C'\fR.
.ie n .IP """S|T""" 4
.el .IP "\f(CWS|T\fR" 4
.IX Item "S|T"
When \f(CW\*(C`S\*(C'\fR can match, it is a better match than when only \f(CW\*(C`T\*(C'\fR can match.
.Sp
Ordering of two matches for \f(CW\*(C`S\*(C'\fR is the same as for \f(CW\*(C`S\*(C'\fR.  Similar for
two matches for \f(CW\*(C`T\*(C'\fR.
.ie n .IP """S{REPEAT_COUNT}""" 4
.el .IP "\f(CWS{REPEAT_COUNT}\fR" 4
.IX Item "S{REPEAT_COUNT}"
Matches as \f(CW\*(C`SSS...S\*(C'\fR (repeated as many times as necessary).
.ie n .IP """S{min,max}""" 4
.el .IP "\f(CWS{min,max}\fR" 4
.IX Item "S{min,max}"
Matches as \f(CW\*(C`S{max}|S{max\-1}|...|S{min+1}|S{min}\*(C'\fR.
.ie n .IP """S{min,max}?""" 4
.el .IP "\f(CWS{min,max}?\fR" 4
.IX Item "S{min,max}?"
Matches as \f(CW\*(C`S{min}|S{min+1}|...|S{max\-1}|S{max}\*(C'\fR.
.ie n .IP """S?"", ""S*"", ""S+""" 4
.el .IP "\f(CWS?\fR, \f(CWS*\fR, \f(CWS+\fR" 4
.IX Item "S?, S*, S+"
Same as \f(CW\*(C`S{0,1}\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}\*(C'\fR respectively.
.ie n .IP """S??"", ""S*?"", ""S+?""" 4
.el .IP "\f(CWS??\fR, \f(CWS*?\fR, \f(CWS+?\fR" 4
.IX Item "S??, S*?, S+?"
Same as \f(CW\*(C`S{0,1}?\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}?\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}?\*(C'\fR respectively.
.ie n .IP """(?>S)""" 4
.el .IP "\f(CW(?>S)\fR" 4
.IX Item "(?>S)"
Matches the best match for \f(CW\*(C`S\*(C'\fR and only that.
.ie n .IP """(?=S)"", ""(?<=S)""" 4
.el .IP "\f(CW(?=S)\fR, \f(CW(?<=S)\fR" 4
.IX Item "(?=S), (?<=S)"
Only the best match for \f(CW\*(C`S\*(C'\fR is considered.  (This is important only if
\&\f(CW\*(C`S\*(C'\fR has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)
.ie n .IP """(?!S)"", ""(?<!S)""" 4
.el .IP "\f(CW(?!S)\fR, \f(CW(?<!S)\fR" 4
.IX Item "(?!S), (?<!S)"
For this grouping operator there is no need to describe the ordering, since
only whether or not \f(CW\*(C`S\*(C'\fR can match is important.
.ie n .IP """(??{ EXPR })"", ""(?\f(CIPARNO\f(CW)""" 4
.el .IP "\f(CW(??{ EXPR })\fR, \f(CW(?\f(CIPARNO\f(CW)\fR" 4
.IX Item "(??{ EXPR }), (?PARNO)"
The ordering is the same as for the regular expression which is
the result of \s-1EXPR,\s0 or the pattern contained by capture group \fI\s-1PARNO\s0\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern|no-pattern)"
Recall that which of \f(CW\*(C`yes\-pattern\*(C'\fR or \f(CW\*(C`no\-pattern\*(C'\fR actually matches is
already determined.  The ordering of the matches is the same as for the
chosen subexpression.
.PP
The above recipes describe the ordering of matches \fIat a given position\fR.
One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.
.SS "Creating Custom \s-1RE\s0 Engines"
.IX Subsection "Creating Custom RE Engines"
As of Perl 5.10.0, one can create custom regular expression engines.  This
is not for the faint of heart, as they have to plug in at the C level.  See
perlreapi for more details.
.PP
As an alternative, overloaded constants (see overload) provide a simple
way to extend the functionality of the \s-1RE\s0 engine, by substituting one
pattern for another.
.PP
Suppose that we want to enable a new \s-1RE\s0 escape-sequence \f(CW\*(C`\eY|\*(C'\fR which
matches at a boundary between whitespace characters and non-whitespace
characters.  Note that \f(CW\*(C`(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)\*(C'\fR matches exactly
at these positions, so we want to have each \f(CW\*(C`\eY|\*(C'\fR in the place of the
more complicated version.  We can create a module \f(CW\*(C`customre\*(C'\fR to do
this:
.PP
.Vb 2
\&    package customre;
\&    use overload;
\&
\&    sub import {
\&      shift;
\&      die "No argument to customre::import allowed" if @_;
\&      overload::constant \*(Aqqr\*(Aq => \e&convert;
\&    }
\&
\&    sub invalid { die "/$_[0]/: invalid escape \*(Aq\e\e$_[1]\*(Aq"}
\&
\&    # We must also take care of not escaping the legitimate \e\eY|
\&    # sequence, hence the presence of \*(Aq\e\e\*(Aq in the conversion rules.
\&    my %rules = ( \*(Aq\e\e\*(Aq => \*(Aq\e\e\e\e\*(Aq,
\&                  \*(AqY|\*(Aq => qr/(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)/ );
\&    sub convert {
\&      my $re = shift;
\&      $re =~ s{
\&                \e\e ( \e\e | Y . )
\&              }
\&              { $rules{$1} or invalid($re,$1) }sgex;
\&      return $re;
\&    }
.Ve
.PP
Now \f(CW\*(C`use customre\*(C'\fR enables the new escape in constant regular
expressions, i.e., those without any runtime variable interpolations.
As documented in overload, this conversion will work only over
literal parts of regular expressions.  For \f(CW\*(C`\eY|$re\eY|\*(C'\fR the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of \f(CW\*(C`\eY|\*(C'\fR should be enabled inside \f(CW$re\fR):
.PP
.Vb 5
\&    use customre;
\&    $re = <>;
\&    chomp $re;
\&    $re = customre::convert $re;
\&    /\eY|$re\eY|/;
.Ve
.SS "PCRE/Python Support"
.IX Subsection "PCRE/Python Support"
As of Perl 5.10.0, Perl supports several Python/PCRE\-specific extensions
to the regex syntax. While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted:
.ie n .IP """(?P<NAME>pattern)""" 4
.el .IP "\f(CW(?P<NAME>pattern)\fR" 4
.IX Item "(?P<NAME>pattern)"
Define a named capture group. Equivalent to \f(CW\*(C`(?<NAME>pattern)\*(C'\fR.
.ie n .IP """(?P=NAME)""" 4
.el .IP "\f(CW(?P=NAME)\fR" 4
.IX Item "(?P=NAME)"
Backreference to a named capture group. Equivalent to \f(CW\*(C`\eg{NAME}\*(C'\fR.
.ie n .IP """(?P>NAME)""" 4
.el .IP "\f(CW(?P>NAME)\fR" 4
.IX Item "(?P>NAME)"
Subroutine call to a named capture group. Equivalent to \f(CW\*(C`(?&NAME)\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Many regular expression constructs don't work on \s-1EBCDIC\s0 platforms.
.PP
There are a number of issues with regard to case-insensitive matching
in Unicode rules.  See \f(CW\*(C`i\*(C'\fR under \*(L"Modifiers\*(R" above.
.PP
This document varies from difficult to understand to completely
and utterly opaque.  The wandering prose riddled with jargon is
hard to fathom in several places.
.PP
This document needs a rewrite that separates the tutorial content
from the reference content.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlrequick.
.PP
perlretut.
.PP
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop.
.PP
\&\*(L"Gory details of parsing quoted constructs\*(R" in perlop.
.PP
perlfaq6.
.PP
\&\*(L"pos\*(R" in perlfunc.
.PP
perllocale.
.PP
perlebcdic.
.PP
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl, published
by O'Reilly and Associates.
                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreapi.1                                  0100644 0001750 0001750 00000115711 12566207443 022732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREAPI 1"
.TH PERLREAPI 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreapi \- Perl regular expression plugin interface
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As of Perl 5.9.5 there is a new interface for plugging and using
regular expression engines other than the default one.
.PP
Each engine is supposed to provide access to a constant structure of the
following format:
.PP
.Vb 10
\&    typedef struct regexp_engine {
\&        REGEXP* (*comp) (pTHX_
\&                         const SV * const pattern, const U32 flags);
\&        I32     (*exec) (pTHX_
\&                         REGEXP * const rx,
\&                         char* stringarg,
\&                         char* strend, char* strbeg,
\&                         I32 minend, SV* screamer,
\&                         void* data, U32 flags);
\&        char*   (*intuit) (pTHX_
\&                           REGEXP * const rx, SV *sv,
\&                           char *strpos, char *strend, U32 flags,
\&                           struct re_scream_pos_data_s *data);
\&        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
\&        void    (*free) (pTHX_ REGEXP * const rx);
\&        void    (*numbered_buff_FETCH) (pTHX_
\&                                        REGEXP * const rx,
\&                                        const I32 paren,
\&                                        SV * const sv);
\&        void    (*numbered_buff_STORE) (pTHX_
\&                                        REGEXP * const rx,
\&                                        const I32 paren,
\&                                        SV const * const value);
\&        I32     (*numbered_buff_LENGTH) (pTHX_
\&                                         REGEXP * const rx,
\&                                         const SV * const sv,
\&                                         const I32 paren);
\&        SV*     (*named_buff) (pTHX_
\&                               REGEXP * const rx,
\&                               SV * const key,
\&                               SV * const value,
\&                               U32 flags);
\&        SV*     (*named_buff_iter) (pTHX_
\&                                    REGEXP * const rx,
\&                                    const SV * const lastkey,
\&                                    const U32 flags);
\&        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
\&    #ifdef USE_ITHREADS
\&        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
\&    #endif
\&        REGEXP* (*op_comp) (...);
.Ve
.PP
When a regexp is compiled, its \f(CW\*(C`engine\*(C'\fR field is then set to point at
the appropriate structure, so that when it needs to be used Perl can find
the right routines to do so.
.PP
In order to install a new regexp handler, \f(CW$^H{regcomp}\fR is set
to an integer which (when casted appropriately) resolves to one of these
structures.  When compiling, the \f(CW\*(C`comp\*(C'\fR method is executed, and the
resulting \f(CW\*(C`regexp\*(C'\fR structure's engine field is expected to point back at
the same structure.
.PP
The pTHX_ symbol in the definition is a macro used by Perl under threading
to provide an extra argument to the routine holding a pointer back to
the interpreter that is executing the regexp. So under threading all
routines get an extra argument.
.SH "Callbacks"
.IX Header "Callbacks"
.SS "comp"
.IX Subsection "comp"
.Vb 1
\&    REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
.Ve
.PP
Compile the pattern stored in \f(CW\*(C`pattern\*(C'\fR using the given \f(CW\*(C`flags\*(C'\fR and
return a pointer to a prepared \f(CW\*(C`REGEXP\*(C'\fR structure that can perform
the match.  See \*(L"The \s-1REGEXP\s0 structure\*(R" below for an explanation of
the individual fields in the \s-1REGEXP\s0 struct.
.PP
The \f(CW\*(C`pattern\*(C'\fR parameter is the scalar that was used as the
pattern.  Previous versions of Perl would pass two \f(CW\*(C`char*\*(C'\fR indicating
the start and end of the stringified pattern; the following snippet can
be used to get the old parameters:
.PP
.Vb 3
\&    STRLEN plen;
\&    char*  exp = SvPV(pattern, plen);
\&    char* xend = exp + plen;
.Ve
.PP
Since any scalar can be passed as a pattern, it's possible to implement
an engine that does something with an array (\f(CW\*(C`"ook" =~ [ qw/ eek
hlagh / ]\*(C'\fR) or with the non-stringified form of a compiled regular
expression (\f(CW\*(C`"ook" =~ qr/eek/\*(C'\fR).  Perl's own engine will always
stringify everything using the snippet above, but that doesn't mean
other engines have to.
.PP
The \f(CW\*(C`flags\*(C'\fR parameter is a bitfield which indicates which of the
\&\f(CW\*(C`msixp\*(C'\fR flags the regex was compiled with.  It also contains
additional info, such as if \f(CW\*(C`use locale\*(C'\fR is in effect.
.PP
The \f(CW\*(C`eogc\*(C'\fR flags are stripped out before being passed to the comp
routine.  The regex engine does not need to know if any of these
are set, as those flags should only affect what Perl does with the
pattern and its match variables, not how it gets compiled and
executed.
.PP
By the time the comp callback is called, some of these flags have
already had effect (noted below where applicable).  However most of
their effect occurs after the comp callback has run, in routines that
read the \f(CW\*(C`rx\->extflags\*(C'\fR field which it populates.
.PP
In general the flags should be preserved in \f(CW\*(C`rx\->extflags\*(C'\fR after
compilation, although the regex engine might want to add or delete
some of them to invoke or disable some special behavior in Perl.  The
flags along with any special behavior they cause are documented below:
.PP
The pattern modifiers:
.ie n .IP """/m"" \- RXf_PMf_MULTILINE" 4
.el .IP "\f(CW/m\fR \- RXf_PMf_MULTILINE" 4
.IX Item "/m - RXf_PMf_MULTILINE"
If this is in \f(CW\*(C`rx\->extflags\*(C'\fR it will be passed to
\&\f(CW\*(C`Perl_fbm_instr\*(C'\fR by \f(CW\*(C`pp_split\*(C'\fR which will treat the subject string
as a multi-line string.
.ie n .IP """/s"" \- RXf_PMf_SINGLELINE" 4
.el .IP "\f(CW/s\fR \- RXf_PMf_SINGLELINE" 4
.IX Item "/s - RXf_PMf_SINGLELINE"
.PD 0
.ie n .IP """/i"" \- RXf_PMf_FOLD" 4
.el .IP "\f(CW/i\fR \- RXf_PMf_FOLD" 4
.IX Item "/i - RXf_PMf_FOLD"
.ie n .IP """/x"" \- RXf_PMf_EXTENDED" 4
.el .IP "\f(CW/x\fR \- RXf_PMf_EXTENDED" 4
.IX Item "/x - RXf_PMf_EXTENDED"
.PD
If present on a regex, \f(CW"#"\fR comments will be handled differently by the
tokenizer in some cases.
.Sp
\&\s-1TODO:\s0 Document those cases.
.ie n .IP """/p"" \- RXf_PMf_KEEPCOPY" 4
.el .IP "\f(CW/p\fR \- RXf_PMf_KEEPCOPY" 4
.IX Item "/p - RXf_PMf_KEEPCOPY"
\&\s-1TODO:\s0 Document this
.IP "Character set" 4
.IX Item "Character set"
The character set semantics are determined by an enum that is contained
in this field.  This is still experimental and subject to change, but
the current interface returns the rules by use of the in-line function
\&\f(CW\*(C`get_regex_charset(const U32 flags)\*(C'\fR.  The only currently documented
value returned from it is \s-1REGEX_LOCALE_CHARSET,\s0 which is set if
\&\f(CW\*(C`use locale\*(C'\fR is in effect. If present in \f(CW\*(C`rx\->extflags\*(C'\fR,
\&\f(CW\*(C`split\*(C'\fR will use the locale dependent definition of whitespace
when RXf_SKIPWHITE or RXf_WHITE is in effect.  \s-1ASCII\s0 whitespace
is defined as per isSPACE, and by the internal
macros \f(CW\*(C`is_utf8_space\*(C'\fR under \s-1UTF\-8,\s0 and \f(CW\*(C`isSPACE_LC\*(C'\fR under \f(CW\*(C`use
locale\*(C'\fR.
.PP
Additional flags:
.IP "RXf_SPLIT" 4
.IX Item "RXf_SPLIT"
This flag was removed in perl 5.18.0.  \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR is now special-cased
solely in the parser.  RXf_SPLIT is still #defined, so you can test for it.
This is how it used to work:
.Sp
If \f(CW\*(C`split\*(C'\fR is invoked as \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR or with no arguments (which
really means \f(CW\*(C`split(\*(Aq \*(Aq, $_)\*(C'\fR, see split), Perl will
set this flag.  The regex engine can then check for it and set the
\&\s-1SKIPWHITE\s0 and \s-1WHITE\s0 extflags.  To do this, the Perl engine does:
.Sp
.Vb 2
\&    if (flags & RXf_SPLIT && r\->prelen == 1 && r\->precomp[0] == \*(Aq \*(Aq)
\&        r\->extflags |= (RXf_SKIPWHITE|RXf_WHITE);
.Ve
.PP
These flags can be set during compilation to enable optimizations in
the \f(CW\*(C`split\*(C'\fR operator.
.IP "RXf_SKIPWHITE" 4
.IX Item "RXf_SKIPWHITE"
This flag was removed in perl 5.18.0.  It is still #defined, so you can
set it, but doing so will have no effect.  This is how it used to work:
.Sp
If the flag is present in \f(CW\*(C`rx\->extflags\*(C'\fR \f(CW\*(C`split\*(C'\fR will delete
whitespace from the start of the subject string before it's operated
on.  What is considered whitespace depends on if the subject is a
\&\s-1UTF\-8\s0 string and if the \f(CW\*(C`RXf_PMf_LOCALE\*(C'\fR flag is set.
.Sp
If RXf_WHITE is set in addition to this flag, \f(CW\*(C`split\*(C'\fR will behave like
\&\f(CW\*(C`split " "\*(C'\fR under the Perl engine.
.IP "RXf_START_ONLY" 4
.IX Item "RXf_START_ONLY"
Tells the split operator to split the target string on newlines
(\f(CW\*(C`\en\*(C'\fR) without invoking the regex engine.
.Sp
Perl's engine sets this if the pattern is \f(CW\*(C`/^/\*(C'\fR (\f(CW\*(C`plen == 1 && *exp
== \*(Aq^\*(Aq\*(C'\fR), even under \f(CW\*(C`/^/s\*(C'\fR; see split.  Of course a
different regex engine might want to use the same optimizations
with a different syntax.
.IP "RXf_WHITE" 4
.IX Item "RXf_WHITE"
Tells the split operator to split the target string on whitespace
without invoking the regex engine.  The definition of whitespace varies
depending on if the target string is a \s-1UTF\-8\s0 string and on
if RXf_PMf_LOCALE is set.
.Sp
Perl's engine sets this flag if the pattern is \f(CW\*(C`\es+\*(C'\fR.
.IP "RXf_NULL" 4
.IX Item "RXf_NULL"
Tells the split operator to split the target string on
characters.  The definition of character varies depending on if
the target string is a \s-1UTF\-8\s0 string.
.Sp
Perl's engine sets this flag on empty patterns, this optimization
makes \f(CW\*(C`split //\*(C'\fR much faster than it would otherwise be.  It's even
faster than \f(CW\*(C`unpack\*(C'\fR.
.IP "RXf_NO_INPLACE_SUBST" 4
.IX Item "RXf_NO_INPLACE_SUBST"
Added in perl 5.18.0, this flag indicates that a regular expression might
perform an operation that would interfere with inplace substituion. For
instance it might contain lookbehind, or assign to non-magical variables
(such as \f(CW$REGMARK\fR and \f(CW$REGERROR\fR) during matching.  \f(CW\*(C`s///\*(C'\fR will skip
certain optimisations when this is set.
.SS "exec"
.IX Subsection "exec"
.Vb 4
\&    I32 exec(pTHX_ REGEXP * const rx,
\&             char *stringarg, char* strend, char* strbeg,
\&             I32 minend, SV* screamer,
\&             void* data, U32 flags);
.Ve
.PP
Execute a regexp. The arguments are
.IP "rx" 4
.IX Item "rx"
The regular expression to execute.
.IP "screamer" 4
.IX Item "screamer"
This strangely-named arg is the \s-1SV\s0 to be matched against.  Note that the
actual char array to be matched against is supplied by the arguments
described below; the \s-1SV\s0 is just used to determine UTF8ness, \f(CW\*(C`pos()\*(C'\fR etc.
.IP "strbeg" 4
.IX Item "strbeg"
Pointer to the physical start of the string.
.IP "strend" 4
.IX Item "strend"
Pointer to the character following the physical end of the string (i.e.
the \f(CW\*(C`\e0\*(C'\fR).
.IP "stringarg" 4
.IX Item "stringarg"
Pointer to the position in the string where matching should start; it might
not be equal to \f(CW\*(C`strbeg\*(C'\fR (for example in a later iteration of \f(CW\*(C`/.../g\*(C'\fR).
.IP "minend" 4
.IX Item "minend"
Minimum length of string (measured in bytes from \f(CW\*(C`stringarg\*(C'\fR) that must
match; if the engine reaches the end of the match but hasn't reached this
position in the string, it should fail.
.IP "data" 4
.IX Item "data"
Optimisation data; subject to change.
.IP "flags" 4
.IX Item "flags"
Optimisation flags; subject to change.
.SS "intuit"
.IX Subsection "intuit"
.Vb 3
\&    char* intuit(pTHX_ REGEXP * const rx,
\&                  SV *sv, char *strpos, char *strend,
\&                  const U32 flags, struct re_scream_pos_data_s *data);
.Ve
.PP
Find the start position where a regex match should be attempted,
or possibly if the regex engine should not be run because the
pattern can't match.  This is called, as appropriate, by the core,
depending on the values of the \f(CW\*(C`extflags\*(C'\fR member of the \f(CW\*(C`regexp\*(C'\fR
structure.
.SS "checkstr"
.IX Subsection "checkstr"
.Vb 1
\&    SV* checkstr(pTHX_ REGEXP * const rx);
.Ve
.PP
Return a \s-1SV\s0 containing a string that must appear in the pattern. Used
by \f(CW\*(C`split\*(C'\fR for optimising matches.
.SS "free"
.IX Subsection "free"
.Vb 1
\&    void free(pTHX_ REGEXP * const rx);
.Ve
.PP
Called by Perl when it is freeing a regexp pattern so that the engine
can release any resources pointed to by the \f(CW\*(C`pprivate\*(C'\fR member of the
\&\f(CW\*(C`regexp\*(C'\fR structure.  This is only responsible for freeing private data;
Perl will handle releasing anything else contained in the \f(CW\*(C`regexp\*(C'\fR structure.
.SS "Numbered capture callbacks"
.IX Subsection "Numbered capture callbacks"
Called to get/set the value of \f(CW\*(C`$\`\*(C'\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, \f(CW$&\fR and their named
equivalents, ${^PREMATCH}, ${^POSTMATCH} and $^{\s-1MATCH\s0}, as well as the
numbered capture groups (\f(CW$1\fR, \f(CW$2\fR, ...).
.PP
The \f(CW\*(C`paren\*(C'\fR parameter will be \f(CW1\fR for \f(CW$1\fR, \f(CW2\fR for \f(CW$2\fR and so
forth, and have these symbolic values for the special variables:
.PP
.Vb 6
\&    ${^PREMATCH}  RX_BUFF_IDX_CARET_PREMATCH
\&    ${^POSTMATCH} RX_BUFF_IDX_CARET_POSTMATCH
\&    ${^MATCH}     RX_BUFF_IDX_CARET_FULLMATCH
\&    $\`            RX_BUFF_IDX_PREMATCH
\&    $\*(Aq            RX_BUFF_IDX_POSTMATCH
\&    $&            RX_BUFF_IDX_FULLMATCH
.Ve
.PP
Note that in Perl 5.17.3 and earlier, the last three constants were also
used for the caret variants of the variables.
.PP
The names have been chosen by analogy with Tie::Scalar methods
names with an additional \fB\s-1LENGTH\s0\fR callback for efficiency.  However
named capture variables are currently not tied internally but
implemented via magic.
.PP
\fInumbered_buff_FETCH\fR
.IX Subsection "numbered_buff_FETCH"
.PP
.Vb 2
\&    void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
\&                             SV * const sv);
.Ve
.PP
Fetch a specified numbered capture.  \f(CW\*(C`sv\*(C'\fR should be set to the scalar
to return, the scalar is passed as an argument rather than being
returned from the function because when it's called Perl already has a
scalar to store the value, creating another one would be
redundant.  The scalar can be set with \f(CW\*(C`sv_setsv\*(C'\fR, \f(CW\*(C`sv_setpvn\*(C'\fR and
friends, see perlapi.
.PP
This callback is where Perl untaints its own capture variables under
taint mode (see perlsec).  See the \f(CW\*(C`Perl_reg_numbered_buff_fetch\*(C'\fR
function in \fIregcomp.c\fR for how to untaint capture variables if
that's something you'd like your engine to do as well.
.PP
\fInumbered_buff_STORE\fR
.IX Subsection "numbered_buff_STORE"
.PP
.Vb 4
\&    void    (*numbered_buff_STORE) (pTHX_
\&                                    REGEXP * const rx,
\&                                    const I32 paren,
\&                                    SV const * const value);
.Ve
.PP
Set the value of a numbered capture variable.  \f(CW\*(C`value\*(C'\fR is the scalar
that is to be used as the new value.  It's up to the engine to make
sure this is used as the new value (or reject it).
.PP
Example:
.PP
.Vb 4
\&    if ("ook" =~ /(o*)/) {
\&        # \*(Aqparen\*(Aq will be \*(Aq1\*(Aq and \*(Aqvalue\*(Aq will be \*(Aqee\*(Aq
\&        $1 =~ tr/o/e/;
\&    }
.Ve
.PP
Perl's own engine will croak on any attempt to modify the capture
variables, to do this in another engine use the following callback
(copied from \f(CW\*(C`Perl_reg_numbered_buff_store\*(C'\fR):
.PP
.Vb 9
\&    void
\&    Example_reg_numbered_buff_store(pTHX_
\&                                    REGEXP * const rx,
\&                                    const I32 paren,
\&                                    SV const * const value)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        PERL_UNUSED_ARG(paren);
\&        PERL_UNUSED_ARG(value);
\&
\&        if (!PL_localizing)
\&            Perl_croak(aTHX_ PL_no_modify);
\&    }
.Ve
.PP
Actually Perl will not \fIalways\fR croak in a statement that looks
like it would modify a numbered capture variable.  This is because the
\&\s-1STORE\s0 callback will not be called if Perl can determine that it
doesn't have to modify the value.  This is exactly how tied variables
behave in the same situation:
.PP
.Vb 2
\&    package CaptureVar;
\&    use base \*(AqTie::Scalar\*(Aq;
\&
\&    sub TIESCALAR { bless [] }
\&    sub FETCH { undef }
\&    sub STORE { die "This doesn\*(Aqt get called" }
\&
\&    package main;
\&
\&    tie my $sv => "CaptureVar";
\&    $sv =~ y/a/b/;
.Ve
.PP
Because \f(CW$sv\fR is \f(CW\*(C`undef\*(C'\fR when the \f(CW\*(C`y///\*(C'\fR operator is applied to it,
the transliteration won't actually execute and the program won't
\&\f(CW\*(C`die\*(C'\fR.  This is different to how 5.8 and earlier versions behaved
since the capture variables were \s-1READONLY\s0 variables then; now they'll
just die when assigned to in the default engine.
.PP
\fInumbered_buff_LENGTH\fR
.IX Subsection "numbered_buff_LENGTH"
.PP
.Vb 4
\&    I32 numbered_buff_LENGTH (pTHX_
\&                              REGEXP * const rx,
\&                              const SV * const sv,
\&                              const I32 paren);
.Ve
.PP
Get the \f(CW\*(C`length\*(C'\fR of a capture variable.  There's a special callback
for this so that Perl doesn't have to do a \s-1FETCH\s0 and run \f(CW\*(C`length\*(C'\fR on
the result, since the length is (in Perl's case) known from an offset
stored in \f(CW\*(C`rx\->offs\*(C'\fR, this is much more efficient:
.PP
.Vb 3
\&    I32 s1  = rx\->offs[paren].start;
\&    I32 s2  = rx\->offs[paren].end;
\&    I32 len = t1 \- s1;
.Ve
.PP
This is a little bit more complex in the case of \s-1UTF\-8,\s0 see what
\&\f(CW\*(C`Perl_reg_numbered_buff_length\*(C'\fR does with
is_utf8_string_loclen.
.SS "Named capture callbacks"
.IX Subsection "Named capture callbacks"
Called to get/set the value of \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR, as well as by some
utility functions in re.
.PP
There are two callbacks, \f(CW\*(C`named_buff\*(C'\fR is called in all the cases the
\&\s-1FETCH, STORE, DELETE, CLEAR, EXISTS\s0 and \s-1SCALAR \s0Tie::Hash callbacks
would be on changes to \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR and \f(CW\*(C`named_buff_iter\*(C'\fR in the
same cases as \s-1FIRSTKEY\s0 and \s-1NEXTKEY.\s0
.PP
The \f(CW\*(C`flags\*(C'\fR parameter can be used to determine which of these
operations the callbacks should respond to.  The following flags are
currently defined:
.PP
Which Tie::Hash operation is being performed from the Perl level on
\&\f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%+\*(C'\fR, if any:
.PP
.Vb 8
\&    RXapif_FETCH
\&    RXapif_STORE
\&    RXapif_DELETE
\&    RXapif_CLEAR
\&    RXapif_EXISTS
\&    RXapif_SCALAR
\&    RXapif_FIRSTKEY
\&    RXapif_NEXTKEY
.Ve
.PP
If \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR is being operated on, if any.
.PP
.Vb 2
\&    RXapif_ONE /* %+ */
\&    RXapif_ALL /* %\- */
.Ve
.PP
If this is being called as \f(CW\*(C`re::regname\*(C'\fR, \f(CW\*(C`re::regnames\*(C'\fR or
\&\f(CW\*(C`re::regnames_count\*(C'\fR, if any.  The first two will be combined with
\&\f(CW\*(C`RXapif_ONE\*(C'\fR or \f(CW\*(C`RXapif_ALL\*(C'\fR.
.PP
.Vb 3
\&    RXapif_REGNAME
\&    RXapif_REGNAMES
\&    RXapif_REGNAMES_COUNT
.Ve
.PP
Internally \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR are implemented with a real tied interface
via Tie::Hash::NamedCapture.  The methods in that package will call
back into these functions.  However the usage of
Tie::Hash::NamedCapture for this purpose might change in future
releases.  For instance this might be implemented by magic instead
(would need an extension to mgvtbl).
.PP
\fInamed_buff\fR
.IX Subsection "named_buff"
.PP
.Vb 2
\&    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
\&                           SV * const value, U32 flags);
.Ve
.PP
\fInamed_buff_iter\fR
.IX Subsection "named_buff_iter"
.PP
.Vb 4
\&    SV*     (*named_buff_iter) (pTHX_
\&                                REGEXP * const rx,
\&                                const SV * const lastkey,
\&                                const U32 flags);
.Ve
.SS "qr_package"
.IX Subsection "qr_package"
.Vb 1
\&    SV* qr_package(pTHX_ REGEXP * const rx);
.Ve
.PP
The package the qr// magic object is blessed into (as seen by \f(CW\*(C`ref
qr//\*(C'\fR).  It is recommended that engines change this to their package
name for identification regardless of if they implement methods
on the object.
.PP
The package this method returns should also have the internal
\&\f(CW\*(C`Regexp\*(C'\fR package in its \f(CW@ISA\fR.  \f(CW\*(C`qr//\->isa("Regexp")\*(C'\fR should always
be true regardless of what engine is being used.
.PP
Example implementation might be:
.PP
.Vb 6
\&    SV*
\&    Example_qr_package(pTHX_ REGEXP * const rx)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        return newSVpvs("re::engine::Example");
\&    }
.Ve
.PP
Any method calls on an object created with \f(CW\*(C`qr//\*(C'\fR will be dispatched to the
package as a normal object.
.PP
.Vb 3
\&    use re::engine::Example;
\&    my $re = qr//;
\&    $re\->meth; # dispatched to re::engine::Example::meth()
.Ve
.PP
To retrieve the \f(CW\*(C`REGEXP\*(C'\fR object from the scalar in an \s-1XS\s0 function use
the \f(CW\*(C`SvRX\*(C'\fR macro, see \*(L"\s-1REGEXP\s0 Functions\*(R" in perlapi.
.PP
.Vb 3
\&    void meth(SV * rv)
\&    PPCODE:
\&        REGEXP * re = SvRX(sv);
.Ve
.SS "dupe"
.IX Subsection "dupe"
.Vb 1
\&    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
.Ve
.PP
On threaded builds a regexp may need to be duplicated so that the pattern
can be used by multiple threads.  This routine is expected to handle the
duplication of any private data pointed to by the \f(CW\*(C`pprivate\*(C'\fR member of
the \f(CW\*(C`regexp\*(C'\fR structure.  It will be called with the preconstructed new
\&\f(CW\*(C`regexp\*(C'\fR structure as an argument, the \f(CW\*(C`pprivate\*(C'\fR member will point at
the \fBold\fR private structure, and it is this routine's responsibility to
construct a copy and return a pointer to it (which Perl will then use to
overwrite the field as passed to this routine.)
.PP
This allows the engine to dupe its private data but also if necessary
modify the final structure if it really must.
.PP
On unthreaded builds this field doesn't exist.
.SS "op_comp"
.IX Subsection "op_comp"
This is private to the Perl core and subject to change. Should be left
null.
.SH "The REGEXP structure"
.IX Header "The REGEXP structure"
The \s-1REGEXP\s0 struct is defined in \fIregexp.h\fR.
All regex engines must be able to
correctly build such a structure in their \*(L"comp\*(R" routine.
.PP
The \s-1REGEXP\s0 structure contains all the data that Perl needs to be aware of
to properly work with the regular expression.  It includes data about
optimisations that Perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts, such as if the pattern anchored in
some way, or what flags were used during the compile, or if the
program contains special constructs that Perl needs to be aware of.
.PP
In addition it contains two fields that are intended for the private
use of the regex engine that compiled the pattern.  These are the
\&\f(CW\*(C`intflags\*(C'\fR and \f(CW\*(C`pprivate\*(C'\fR members.  \f(CW\*(C`pprivate\*(C'\fR is a void pointer to
an arbitrary structure, whose use and management is the responsibility
of the compiling engine.  Perl will never modify either of these
values.
.PP
.Vb 3
\&    typedef struct regexp {
\&        /* what engine created this regexp? */
\&        const struct regexp_engine* engine;
\&
\&        /* what re is this a lightweight copy of? */
\&        struct regexp* mother_re;
\&
\&        /* Information about the match that the Perl core uses to manage
\&         * things */
\&        U32 extflags;   /* Flags used both externally and internally */
\&        I32 minlen;     /* mininum possible number of chars in */
\&                           string to match */
\&        I32 minlenret;  /* mininum possible number of chars in $& */
\&        U32 gofs;       /* chars left of pos that we search from */
\&
\&        /* substring data about strings that must appear
\&           in the final match, used for optimisations */
\&        struct reg_substr_data *substrs;
\&
\&        U32 nparens;  /* number of capture groups */
\&
\&        /* private engine specific data */
\&        U32 intflags;   /* Engine Specific Internal flags */
\&        void *pprivate; /* Data private to the regex engine which 
\&                           created this object. */
\&
\&        /* Data about the last/current match. These are modified during
\&         * matching*/
\&        U32 lastparen;            /* highest close paren matched ($+) */
\&        U32 lastcloseparen;       /* last close paren matched ($^N) */
\&        regexp_paren_pair *swap;  /* Swap copy of *offs */
\&        regexp_paren_pair *offs;  /* Array of offsets for (@\-) and
\&                                     (@+) */
\&
\&        char *subbeg;  /* saved or original string so \edigit works
\&                          forever. */
\&        SV_SAVED_COPY  /* If non\-NULL, SV which is COW from original */
\&        I32 sublen;    /* Length of string pointed by subbeg */
\&        I32 suboffset;  /* byte offset of subbeg from logical start of
\&                           str */
\&        I32 subcoffset; /* suboffset equiv, but in chars (for @\-/@+) */
\&
\&        /* Information about the match that isn\*(Aqt often used */
\&        I32 prelen;           /* length of precomp */
\&        const char *precomp;  /* pre\-compilation regular expression */
\&
\&        char *wrapped;  /* wrapped version of the pattern */
\&        I32 wraplen;    /* length of wrapped */
\&
\&        I32 seen_evals;   /* number of eval groups in the pattern \- for
\&                             security checks */
\&        HV *paren_names;  /* Optional hash of paren names */
\&
\&        /* Refcount of this regexp */
\&        I32 refcnt;             /* Refcount of this regexp */
\&    } regexp;
.Ve
.PP
The fields are discussed in more detail below:
.ie n .SS """engine"""
.el .SS "\f(CWengine\fP"
.IX Subsection "engine"
This field points at a \f(CW\*(C`regexp_engine\*(C'\fR structure which contains pointers
to the subroutines that are to be used for performing a match.  It
is the compiling routine's responsibility to populate this field before
returning the regexp object.
.PP
Internally this is set to \f(CW\*(C`NULL\*(C'\fR unless a custom engine is specified in
\&\f(CW$^H{regcomp}\fR, Perl's own set of callbacks can be accessed in the struct
pointed to by \f(CW\*(C`RE_ENGINE_PTR\*(C'\fR.
.ie n .SS """mother_re"""
.el .SS "\f(CWmother_re\fP"
.IX Subsection "mother_re"
\&\s-1TODO,\s0 see <http://www.mail\-archive.com/perl5\-changes@perl.org/msg17328.html>
.ie n .SS """extflags"""
.el .SS "\f(CWextflags\fP"
.IX Subsection "extflags"
This will be used by Perl to see what flags the regexp was compiled
with, this will normally be set to the value of the flags parameter by
the comp callback.  See the comp documentation for
valid flags.
.ie n .SS """minlen"" ""minlenret"""
.el .SS "\f(CWminlen\fP \f(CWminlenret\fP"
.IX Subsection "minlen minlenret"
The minimum string length (in characters) required for the pattern to match.
This is used to
prune the search space by not bothering to match any closer to the end of a
string than would allow a match.  For instance there is no point in even
starting the regex engine if the minlen is 10 but the string is only 5
characters long.  There is no way that the pattern can match.
.PP
\&\f(CW\*(C`minlenret\*(C'\fR is the minimum length (in characters) of the string that would
be found in $& after a match.
.PP
The difference between \f(CW\*(C`minlen\*(C'\fR and \f(CW\*(C`minlenret\*(C'\fR can be seen in the
following pattern:
.PP
.Vb 1
\&    /ns(?=\ed)/
.Ve
.PP
where the \f(CW\*(C`minlen\*(C'\fR would be 3 but \f(CW\*(C`minlenret\*(C'\fR would only be 2 as the \ed is
required to match but is not actually
included in the matched content.  This
distinction is particularly important as the substitution logic uses the
\&\f(CW\*(C`minlenret\*(C'\fR to tell if it can do in-place substitutions (these can
result in considerable speed-up).
.ie n .SS """gofs"""
.el .SS "\f(CWgofs\fP"
.IX Subsection "gofs"
Left offset from \fIpos()\fR to start match at.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Substring data about strings that must appear in the final match.  This
is currently only used internally by Perl's engine, but might be
used in the future for all engines for optimisations.
.ie n .SS """nparens"", ""lastparen"", and ""lastcloseparen"""
.el .SS "\f(CWnparens\fP, \f(CWlastparen\fP, and \f(CWlastcloseparen\fP"
.IX Subsection "nparens, lastparen, and lastcloseparen"
These fields are used to keep track of how many paren groups could be matched
in the pattern, which was the last open paren to be entered, and which was
the last close paren to be entered.
.ie n .SS """intflags"""
.el .SS "\f(CWintflags\fP"
.IX Subsection "intflags"
The engine's private copy of the flags the pattern was compiled with. Usually
this is the same as \f(CW\*(C`extflags\*(C'\fR unless the engine chose to modify one of them.
.ie n .SS """pprivate"""
.el .SS "\f(CWpprivate\fP"
.IX Subsection "pprivate"
A void* pointing to an engine-defined
data structure.  The Perl engine uses the
\&\f(CW\*(C`regexp_internal\*(C'\fR structure (see \*(L"Base Structures\*(R" in perlreguts) but a custom
engine should use something else.
.ie n .SS """swap"""
.el .SS "\f(CWswap\fP"
.IX Subsection "swap"
Unused.  Left in for compatibility with Perl 5.10.0.
.ie n .SS """offs"""
.el .SS "\f(CWoffs\fP"
.IX Subsection "offs"
A \f(CW\*(C`regexp_paren_pair\*(C'\fR structure which defines offsets into the string being
matched which correspond to the \f(CW$&\fR and \f(CW$1\fR, \f(CW$2\fR etc. captures, the
\&\f(CW\*(C`regexp_paren_pair\*(C'\fR struct is defined as follows:
.PP
.Vb 4
\&    typedef struct regexp_paren_pair {
\&        I32 start;
\&        I32 end;
\&    } regexp_paren_pair;
.Ve
.PP
If \f(CW\*(C`\->offs[num].start\*(C'\fR or \f(CW\*(C`\->offs[num].end\*(C'\fR is \f(CW\*(C`\-1\*(C'\fR then that
capture group did not match.
\&\f(CW\*(C`\->offs[0].start/end\*(C'\fR represents \f(CW$&\fR (or
\&\f(CW\*(C`${^MATCH}\*(C'\fR under \f(CW\*(C`//p\*(C'\fR) and \f(CW\*(C`\->offs[paren].end\*(C'\fR matches \f(CW$$paren\fR where
\&\f(CW$paren \fR= 1>.
.ie n .SS """precomp"" ""prelen"""
.el .SS "\f(CWprecomp\fP \f(CWprelen\fP"
.IX Subsection "precomp prelen"
Used for optimisations.  \f(CW\*(C`precomp\*(C'\fR holds a copy of the pattern that
was compiled and \f(CW\*(C`prelen\*(C'\fR its length.  When a new pattern is to be
compiled (such as inside a loop) the internal \f(CW\*(C`regcomp\*(C'\fR operator
checks if the last compiled \f(CW\*(C`REGEXP\*(C'\fR's \f(CW\*(C`precomp\*(C'\fR and \f(CW\*(C`prelen\*(C'\fR
are equivalent to the new one, and if so uses the old pattern instead
of compiling a new one.
.PP
The relevant snippet from \f(CW\*(C`Perl_pp_regcomp\*(C'\fR:
.PP
.Vb 3
\&        if (!re || !re\->precomp || re\->prelen != (I32)len ||
\&            memNE(re\->precomp, t, len))
\&        /* Compile a new pattern */
.Ve
.ie n .SS """paren_names"""
.el .SS "\f(CWparen_names\fP"
.IX Subsection "paren_names"
This is a hash used internally to track named capture groups and their
offsets.  The keys are the names of the buffers the values are dualvars,
with the \s-1IV\s0 slot holding the number of buffers with the given name and the
pv being an embedded array of I32.  The values may also be contained
independently in the data array in cases where named backreferences are
used.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Holds information on the longest string that must occur at a fixed
offset from the start of the pattern, and the longest string that must
occur at a floating offset from the start of the pattern.  Used to do
Fast-Boyer-Moore searches on the string to find out if its worth using
the regex engine at all, and if so where in the string to search.
.ie n .SS """subbeg"" ""sublen"" ""saved_copy"" ""suboffset"" ""subcoffset"""
.el .SS "\f(CWsubbeg\fP \f(CWsublen\fP \f(CWsaved_copy\fP \f(CWsuboffset\fP \f(CWsubcoffset\fP"
.IX Subsection "subbeg sublen saved_copy suboffset subcoffset"
Used during the execution phase for managing search and replace patterns,
and for providing the text for \f(CW$&\fR, \f(CW$1\fR etc. \f(CW\*(C`subbeg\*(C'\fR points to a
buffer (either the original string, or a copy in the case of
\&\f(CW\*(C`RX_MATCH_COPIED(rx)\*(C'\fR), and \f(CW\*(C`sublen\*(C'\fR is the length of the buffer.  The
\&\f(CW\*(C`RX_OFFS\*(C'\fR start and end indices index into this buffer.
.PP
In the presence of the \f(CW\*(C`REXEC_COPY_STR\*(C'\fR flag, but with the addition of
the \f(CW\*(C`REXEC_COPY_SKIP_PRE\*(C'\fR or \f(CW\*(C`REXEC_COPY_SKIP_POST\*(C'\fR flags, an engine
can choose not to copy the full buffer (although it must still do so in
the presence of \f(CW\*(C`RXf_PMf_KEEPCOPY\*(C'\fR or the relevant bits being set in
\&\f(CW\*(C`PL_sawampersand\*(C'\fR).  In this case, it may set \f(CW\*(C`suboffset\*(C'\fR to indicate the
number of bytes from the logical start of the buffer to the physical start
(i.e. \f(CW\*(C`subbeg\*(C'\fR).  It should also set \f(CW\*(C`subcoffset\*(C'\fR, the number of
characters in the offset. The latter is needed to support \f(CW\*(C`@\-\*(C'\fR and \f(CW\*(C`@+\*(C'\fR
which work in characters, not bytes.
.ie n .SS """wrapped"" ""wraplen"""
.el .SS "\f(CWwrapped\fP \f(CWwraplen\fP"
.IX Subsection "wrapped wraplen"
Stores the string \f(CW\*(C`qr//\*(C'\fR stringifies to. The Perl engine for example
stores \f(CW\*(C`(?^:eek)\*(C'\fR in the case of \f(CW\*(C`qr/eek/\*(C'\fR.
.PP
When using a custom engine that doesn't support the \f(CW\*(C`(?:)\*(C'\fR construct
for inline modifiers, it's probably best to have \f(CW\*(C`qr//\*(C'\fR stringify to
the supplied pattern, note that this will create undesired patterns in
cases such as:
.PP
.Vb 3
\&    my $x = qr/a|b/;  # "a|b"
\&    my $y = qr/c/i;   # "c"
\&    my $z = qr/$x$y/; # "a|bc"
.Ve
.PP
There's no solution for this problem other than making the custom
engine understand a construct like \f(CW\*(C`(?:)\*(C'\fR.
.ie n .SS """seen_evals"""
.el .SS "\f(CWseen_evals\fP"
.IX Subsection "seen_evals"
This stores the number of eval groups in
the pattern.  This is used for security
purposes when embedding compiled regexes into larger patterns with \f(CW\*(C`qr//\*(C'\fR.
.ie n .SS """refcnt"""
.el .SS "\f(CWrefcnt\fP"
.IX Subsection "refcnt"
The number of times the structure is referenced.  When
this falls to 0, the regexp is automatically freed
by a call to pregfree.  This should be set to 1 in
each engine's \*(L"comp\*(R" routine.
.SH "HISTORY"
.IX Header "HISTORY"
Originally part of perlreguts.
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally written by Yves Orton, expanded by \*(Aevar Arnfjo\*:r\*(d-
Bjarmason.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2006 Yves Orton and 2007 \*(Aevar Arnfjo\*:r\*(d- Bjarmason.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreapi5.16.1                              0100644 0001750 0001750 00000104415 12566207423 023241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREAPI 1"
.TH PERLREAPI 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreapi \- perl regular expression plugin interface
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As of Perl 5.9.5 there is a new interface for plugging and using other
regular expression engines than the default one.
.PP
Each engine is supposed to provide access to a constant structure of the
following format:
.PP
.Vb 10
\&    typedef struct regexp_engine {
\&        REGEXP* (*comp) (pTHX_ const SV * const pattern, const U32 flags);
\&        I32     (*exec) (pTHX_ REGEXP * const rx, char* stringarg, char* strend,
\&                         char* strbeg, I32 minend, SV* screamer,
\&                         void* data, U32 flags);
\&        char*   (*intuit) (pTHX_ REGEXP * const rx, SV *sv, char *strpos,
\&                           char *strend, U32 flags,
\&                           struct re_scream_pos_data_s *data);
\&        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
\&        void    (*free) (pTHX_ REGEXP * const rx);
\&        void    (*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32 paren,
\&                                 SV * const sv);
\&        void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,
\&                                       SV const * const value);
\&        I32     (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const SV * const sv,
\&                                        const I32 paren);
\&        SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
\&                               SV * const value, U32 flags);
\&        SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,
\&                                    const U32 flags);
\&        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
\&    #ifdef USE_ITHREADS
\&        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
\&    #endif
.Ve
.PP
When a regexp is compiled, its \f(CW\*(C`engine\*(C'\fR field is then set to point at
the appropriate structure, so that when it needs to be used Perl can find
the right routines to do so.
.PP
In order to install a new regexp handler, \f(CW$^H{regcomp}\fR is set
to an integer which (when casted appropriately) resolves to one of these
structures. When compiling, the \f(CW\*(C`comp\*(C'\fR method is executed, and the
resulting regexp structure's engine field is expected to point back at
the same structure.
.PP
The pTHX_ symbol in the definition is a macro used by perl under threading
to provide an extra argument to the routine holding a pointer back to
the interpreter that is executing the regexp. So under threading all
routines get an extra argument.
.SH "Callbacks"
.IX Header "Callbacks"
.SS "comp"
.IX Subsection "comp"
.Vb 1
\&    REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
.Ve
.PP
Compile the pattern stored in \f(CW\*(C`pattern\*(C'\fR using the given \f(CW\*(C`flags\*(C'\fR and
return a pointer to a prepared \f(CW\*(C`REGEXP\*(C'\fR structure that can perform
the match. See \*(L"The \s-1REGEXP\s0 structure\*(R" below for an explanation of
the individual fields in the \s-1REGEXP\s0 struct.
.PP
The \f(CW\*(C`pattern\*(C'\fR parameter is the scalar that was used as the
pattern. previous versions of perl would pass two \f(CW\*(C`char*\*(C'\fR indicating
the start and end of the stringified pattern, the following snippet can
be used to get the old parameters:
.PP
.Vb 3
\&    STRLEN plen;
\&    char*  exp = SvPV(pattern, plen);
\&    char* xend = exp + plen;
.Ve
.PP
Since any scalar can be passed as a pattern it's possible to implement
an engine that does something with an array (\f(CW\*(C`"ook" =~ [ qw/ eek
hlagh / ]\*(C'\fR) or with the non-stringified form of a compiled regular
expression (\f(CW\*(C`"ook" =~ qr/eek/\*(C'\fR). perl's own engine will always
stringify everything using the snippet above but that doesn't mean
other engines have to.
.PP
The \f(CW\*(C`flags\*(C'\fR parameter is a bitfield which indicates which of the
\&\f(CW\*(C`msixp\*(C'\fR flags the regex was compiled with. It also contains
additional info such as whether \f(CW\*(C`use locale\*(C'\fR is in effect.
.PP
The \f(CW\*(C`eogc\*(C'\fR flags are stripped out before being passed to the comp
routine. The regex engine does not need to know whether any of these
are set as those flags should only affect what perl does with the
pattern and its match variables, not how it gets compiled and
executed.
.PP
By the time the comp callback is called, some of these flags have
already had effect (noted below where applicable). However most of
their effect occurs after the comp callback has run in routines that
read the \f(CW\*(C`rx\->extflags\*(C'\fR field which it populates.
.PP
In general the flags should be preserved in \f(CW\*(C`rx\->extflags\*(C'\fR after
compilation, although the regex engine might want to add or delete
some of them to invoke or disable some special behavior in perl. The
flags along with any special behavior they cause are documented below:
.PP
The pattern modifiers:
.ie n .IP """/m"" \- RXf_PMf_MULTILINE" 4
.el .IP "\f(CW/m\fR \- RXf_PMf_MULTILINE" 4
.IX Item "/m - RXf_PMf_MULTILINE"
If this is in \f(CW\*(C`rx\->extflags\*(C'\fR it will be passed to
\&\f(CW\*(C`Perl_fbm_instr\*(C'\fR by \f(CW\*(C`pp_split\*(C'\fR which will treat the subject string
as a multi-line string.
.ie n .IP """/s"" \- RXf_PMf_SINGLELINE" 4
.el .IP "\f(CW/s\fR \- RXf_PMf_SINGLELINE" 4
.IX Item "/s - RXf_PMf_SINGLELINE"
.PD 0
.ie n .IP """/i"" \- RXf_PMf_FOLD" 4
.el .IP "\f(CW/i\fR \- RXf_PMf_FOLD" 4
.IX Item "/i - RXf_PMf_FOLD"
.ie n .IP """/x"" \- RXf_PMf_EXTENDED" 4
.el .IP "\f(CW/x\fR \- RXf_PMf_EXTENDED" 4
.IX Item "/x - RXf_PMf_EXTENDED"
.PD
If present on a regex \f(CW\*(C`#\*(C'\fR comments will be handled differently by the
tokenizer in some cases.
.Sp
\&\s-1TODO:\s0 Document those cases.
.ie n .IP """/p"" \- RXf_PMf_KEEPCOPY" 4
.el .IP "\f(CW/p\fR \- RXf_PMf_KEEPCOPY" 4
.IX Item "/p - RXf_PMf_KEEPCOPY"
\&\s-1TODO:\s0 Document this
.IP "Character set" 4
.IX Item "Character set"
The character set semantics are determined by an enum that is contained
in this field.  This is still experimental and subject to change, but
the current interface returns the rules by use of the in-line function
\&\f(CW\*(C`get_regex_charset(const U32 flags)\*(C'\fR.  The only currently documented
value returned from it is \s-1REGEX_LOCALE_CHARSET\s0, which is set if
\&\f(CW\*(C`use locale\*(C'\fR is in effect. If present in \f(CW\*(C`rx\->extflags\*(C'\fR,
\&\f(CW\*(C`split\*(C'\fR will use the locale dependent definition of whitespace
when RXf_SKIPWHITE or RXf_WHITE is in effect. \s-1ASCII\s0 whitespace
is defined as per isSPACE, and by the internal
macros \f(CW\*(C`is_utf8_space\*(C'\fR under \s-1UTF\-8\s0, and \f(CW\*(C`isSPACE_LC\*(C'\fR under \f(CW\*(C`use
locale\*(C'\fR.
.PP
Additional flags:
.IP "RXf_UTF8" 4
.IX Item "RXf_UTF8"
Set if the pattern is \fISvUTF8()\fR, set by Perl_pmruntime.
.Sp
A regex engine may want to set or disable this flag during
compilation. The perl engine for instance may upgrade non\-UTF\-8
strings to \s-1UTF\-8\s0 if the pattern includes constructs such as \f(CW\*(C`\ex{...}\*(C'\fR
that can only match Unicode values.
.IP "RXf_SPLIT" 4
.IX Item "RXf_SPLIT"
If \f(CW\*(C`split\*(C'\fR is invoked as \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR or with no arguments (which
really means \f(CW\*(C`split(\*(Aq \*(Aq, $_)\*(C'\fR, see split), perl will
set this flag. The regex engine can then check for it and set the
\&\s-1SKIPWHITE\s0 and \s-1WHITE\s0 extflags. To do this the perl engine does:
.Sp
.Vb 2
\&    if (flags & RXf_SPLIT && r\->prelen == 1 && r\->precomp[0] == \*(Aq \*(Aq)
\&        r\->extflags |= (RXf_SKIPWHITE|RXf_WHITE);
.Ve
.PP
These flags can be set during compilation to enable optimizations in
the \f(CW\*(C`split\*(C'\fR operator.
.IP "RXf_SKIPWHITE" 4
.IX Item "RXf_SKIPWHITE"
If the flag is present in \f(CW\*(C`rx\->extflags\*(C'\fR \f(CW\*(C`split\*(C'\fR will delete
whitespace from the start of the subject string before it's operated
on. What is considered whitespace depends on whether the subject is a
\&\s-1UTF\-8\s0 string and whether the \f(CW\*(C`RXf_PMf_LOCALE\*(C'\fR flag is set.
.Sp
If RXf_WHITE is set in addition to this flag \f(CW\*(C`split\*(C'\fR will behave like
\&\f(CW\*(C`split " "\*(C'\fR under the perl engine.
.IP "RXf_START_ONLY" 4
.IX Item "RXf_START_ONLY"
Tells the split operator to split the target string on newlines
(\f(CW\*(C`\en\*(C'\fR) without invoking the regex engine.
.Sp
Perl's engine sets this if the pattern is \f(CW\*(C`/^/\*(C'\fR (\f(CW\*(C`plen == 1 && *exp
== \*(Aq^\*(Aq\*(C'\fR), even under \f(CW\*(C`/^/s\*(C'\fR, see split. Of course a
different regex engine might want to use the same optimizations
with a different syntax.
.IP "RXf_WHITE" 4
.IX Item "RXf_WHITE"
Tells the split operator to split the target string on whitespace
without invoking the regex engine. The definition of whitespace varies
depending on whether the target string is a \s-1UTF\-8\s0 string and on
whether RXf_PMf_LOCALE is set.
.Sp
Perl's engine sets this flag if the pattern is \f(CW\*(C`\es+\*(C'\fR.
.IP "RXf_NULL" 4
.IX Item "RXf_NULL"
Tells the split operator to split the target string on
characters. The definition of character varies depending on whether
the target string is a \s-1UTF\-8\s0 string.
.Sp
Perl's engine sets this flag on empty patterns, this optimization
makes \f(CW\*(C`split //\*(C'\fR much faster than it would otherwise be. It's even
faster than \f(CW\*(C`unpack\*(C'\fR.
.SS "exec"
.IX Subsection "exec"
.Vb 4
\&    I32 exec(pTHX_ REGEXP * const rx,
\&             char *stringarg, char* strend, char* strbeg,
\&             I32 minend, SV* screamer,
\&             void* data, U32 flags);
.Ve
.PP
Execute a regexp.
.SS "intuit"
.IX Subsection "intuit"
.Vb 3
\&    char* intuit(pTHX_ REGEXP * const rx,
\&                  SV *sv, char *strpos, char *strend,
\&                  const U32 flags, struct re_scream_pos_data_s *data);
.Ve
.PP
Find the start position where a regex match should be attempted,
or possibly whether the regex engine should not be run because the
pattern can't match. This is called as appropriate by the core
depending on the values of the extflags member of the regexp
structure.
.SS "checkstr"
.IX Subsection "checkstr"
.Vb 1
\&    SV* checkstr(pTHX_ REGEXP * const rx);
.Ve
.PP
Return a \s-1SV\s0 containing a string that must appear in the pattern. Used
by \f(CW\*(C`split\*(C'\fR for optimising matches.
.SS "free"
.IX Subsection "free"
.Vb 1
\&    void free(pTHX_ REGEXP * const rx);
.Ve
.PP
Called by perl when it is freeing a regexp pattern so that the engine
can release any resources pointed to by the \f(CW\*(C`pprivate\*(C'\fR member of the
regexp structure. This is only responsible for freeing private data;
perl will handle releasing anything else contained in the regexp structure.
.SS "Numbered capture callbacks"
.IX Subsection "Numbered capture callbacks"
Called to get/set the value of \f(CW\*(C`$\`\*(C'\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, \f(CW$&\fR and their named
equivalents, ${^PREMATCH}, ${^POSTMATCH} and $^{\s-1MATCH\s0}, as well as the
numbered capture groups (\f(CW$1\fR, \f(CW$2\fR, ...).
.PP
The \f(CW\*(C`paren\*(C'\fR parameter will be \f(CW\*(C`\-2\*(C'\fR for \f(CW\*(C`$\`\*(C'\fR, \f(CW\*(C`\-1\*(C'\fR for \f(CW\*(C`$\*(Aq\*(C'\fR, \f(CW0\fR
for \f(CW$&\fR, \f(CW1\fR for \f(CW$1\fR and so forth.
.PP
The names have been chosen by analogy with Tie::Scalar methods
names with an additional \fB\s-1LENGTH\s0\fR callback for efficiency. However
named capture variables are currently not tied internally but
implemented via magic.
.PP
\fInumbered_buff_FETCH\fR
.IX Subsection "numbered_buff_FETCH"
.PP
.Vb 2
\&    void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
\&                             SV * const sv);
.Ve
.PP
Fetch a specified numbered capture. \f(CW\*(C`sv\*(C'\fR should be set to the scalar
to return, the scalar is passed as an argument rather than being
returned from the function because when it's called perl already has a
scalar to store the value, creating another one would be
redundant. The scalar can be set with \f(CW\*(C`sv_setsv\*(C'\fR, \f(CW\*(C`sv_setpvn\*(C'\fR and
friends, see perlapi.
.PP
This callback is where perl untaints its own capture variables under
taint mode (see perlsec). See the \f(CW\*(C`Perl_reg_numbered_buff_fetch\*(C'\fR
function in \fIregcomp.c\fR for how to untaint capture variables if
that's something you'd like your engine to do as well.
.PP
\fInumbered_buff_STORE\fR
.IX Subsection "numbered_buff_STORE"
.PP
.Vb 2
\&    void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,
\&                                    SV const * const value);
.Ve
.PP
Set the value of a numbered capture variable. \f(CW\*(C`value\*(C'\fR is the scalar
that is to be used as the new value. It's up to the engine to make
sure this is used as the new value (or reject it).
.PP
Example:
.PP
.Vb 4
\&    if ("ook" =~ /(o*)/) {
\&        # \*(Aqparen\*(Aq will be \*(Aq1\*(Aq and \*(Aqvalue\*(Aq will be \*(Aqee\*(Aq
\&        $1 =~ tr/o/e/;
\&    }
.Ve
.PP
Perl's own engine will croak on any attempt to modify the capture
variables, to do this in another engine use the following callback
(copied from \f(CW\*(C`Perl_reg_numbered_buff_store\*(C'\fR):
.PP
.Vb 7
\&    void
\&    Example_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,
\&                                                            SV const * const value)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        PERL_UNUSED_ARG(paren);
\&        PERL_UNUSED_ARG(value);
\&
\&        if (!PL_localizing)
\&            Perl_croak(aTHX_ PL_no_modify);
\&    }
.Ve
.PP
Actually perl will not \fIalways\fR croak in a statement that looks
like it would modify a numbered capture variable. This is because the
\&\s-1STORE\s0 callback will not be called if perl can determine that it
doesn't have to modify the value. This is exactly how tied variables
behave in the same situation:
.PP
.Vb 2
\&    package CaptureVar;
\&    use base \*(AqTie::Scalar\*(Aq;
\&
\&    sub TIESCALAR { bless [] }
\&    sub FETCH { undef }
\&    sub STORE { die "This doesn\*(Aqt get called" }
\&
\&    package main;
\&
\&    tie my $sv => "CaptureVar";
\&    $sv =~ y/a/b/;
.Ve
.PP
Because \f(CW$sv\fR is \f(CW\*(C`undef\*(C'\fR when the \f(CW\*(C`y///\*(C'\fR operator is applied to it
the transliteration won't actually execute and the program won't
\&\f(CW\*(C`die\*(C'\fR. This is different to how 5.8 and earlier versions behaved
since the capture variables were \s-1READONLY\s0 variables then, now they'll
just die when assigned to in the default engine.
.PP
\fInumbered_buff_LENGTH\fR
.IX Subsection "numbered_buff_LENGTH"
.PP
.Vb 2
\&    I32 numbered_buff_LENGTH (pTHX_ REGEXP * const rx, const SV * const sv,
\&                              const I32 paren);
.Ve
.PP
Get the \f(CW\*(C`length\*(C'\fR of a capture variable. There's a special callback
for this so that perl doesn't have to do a \s-1FETCH\s0 and run \f(CW\*(C`length\*(C'\fR on
the result, since the length is (in perl's case) known from an offset
stored in \f(CW\*(C`rx\->offs\*(C'\fR this is much more efficient:
.PP
.Vb 3
\&    I32 s1  = rx\->offs[paren].start;
\&    I32 s2  = rx\->offs[paren].end;
\&    I32 len = t1 \- s1;
.Ve
.PP
This is a little bit more complex in the case of \s-1UTF\-8\s0, see what
\&\f(CW\*(C`Perl_reg_numbered_buff_length\*(C'\fR does with
is_utf8_string_loclen.
.SS "Named capture callbacks"
.IX Subsection "Named capture callbacks"
Called to get/set the value of \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR as well as by some
utility functions in re.
.PP
There are two callbacks, \f(CW\*(C`named_buff\*(C'\fR is called in all the cases the
\&\s-1FETCH\s0, \s-1STORE\s0, \s-1DELETE\s0, \s-1CLEAR\s0, \s-1EXISTS\s0 and \s-1SCALAR\s0 Tie::Hash callbacks
would be on changes to \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR and \f(CW\*(C`named_buff_iter\*(C'\fR in the
same cases as \s-1FIRSTKEY\s0 and \s-1NEXTKEY\s0.
.PP
The \f(CW\*(C`flags\*(C'\fR parameter can be used to determine which of these
operations the callbacks should respond to, the following flags are
currently defined:
.PP
Which Tie::Hash operation is being performed from the Perl level on
\&\f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%+\*(C'\fR, if any:
.PP
.Vb 8
\&    RXapif_FETCH
\&    RXapif_STORE
\&    RXapif_DELETE
\&    RXapif_CLEAR
\&    RXapif_EXISTS
\&    RXapif_SCALAR
\&    RXapif_FIRSTKEY
\&    RXapif_NEXTKEY
.Ve
.PP
Whether \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR is being operated on, if any.
.PP
.Vb 2
\&    RXapif_ONE /* %+ */
\&    RXapif_ALL /* %\- */
.Ve
.PP
Whether this is being called as \f(CW\*(C`re::regname\*(C'\fR, \f(CW\*(C`re::regnames\*(C'\fR or
\&\f(CW\*(C`re::regnames_count\*(C'\fR, if any. The first two will be combined with
\&\f(CW\*(C`RXapif_ONE\*(C'\fR or \f(CW\*(C`RXapif_ALL\*(C'\fR.
.PP
.Vb 3
\&    RXapif_REGNAME
\&    RXapif_REGNAMES
\&    RXapif_REGNAMES_COUNT
.Ve
.PP
Internally \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR are implemented with a real tied interface
via Tie::Hash::NamedCapture. The methods in that package will call
back into these functions. However the usage of
Tie::Hash::NamedCapture for this purpose might change in future
releases. For instance this might be implemented by magic instead
(would need an extension to mgvtbl).
.PP
\fInamed_buff\fR
.IX Subsection "named_buff"
.PP
.Vb 2
\&    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
\&                           SV * const value, U32 flags);
.Ve
.PP
\fInamed_buff_iter\fR
.IX Subsection "named_buff_iter"
.PP
.Vb 2
\&    SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,
\&                                const U32 flags);
.Ve
.SS "qr_package"
.IX Subsection "qr_package"
.Vb 1
\&    SV* qr_package(pTHX_ REGEXP * const rx);
.Ve
.PP
The package the qr// magic object is blessed into (as seen by \f(CW\*(C`ref
qr//\*(C'\fR). It is recommended that engines change this to their package
name for identification regardless of whether they implement methods
on the object.
.PP
The package this method returns should also have the internal
\&\f(CW\*(C`Regexp\*(C'\fR package in its \f(CW@ISA\fR. \f(CW\*(C`qr//\->isa("Regexp")\*(C'\fR should always
be true regardless of what engine is being used.
.PP
Example implementation might be:
.PP
.Vb 6
\&    SV*
\&    Example_qr_package(pTHX_ REGEXP * const rx)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        return newSVpvs("re::engine::Example");
\&    }
.Ve
.PP
Any method calls on an object created with \f(CW\*(C`qr//\*(C'\fR will be dispatched to the
package as a normal object.
.PP
.Vb 3
\&    use re::engine::Example;
\&    my $re = qr//;
\&    $re\->meth; # dispatched to re::engine::Example::meth()
.Ve
.PP
To retrieve the \f(CW\*(C`REGEXP\*(C'\fR object from the scalar in an \s-1XS\s0 function use
the \f(CW\*(C`SvRX\*(C'\fR macro, see \*(L"\s-1REGEXP\s0 Functions\*(R" in perlapi.
.PP
.Vb 3
\&    void meth(SV * rv)
\&    PPCODE:
\&        REGEXP * re = SvRX(sv);
.Ve
.SS "dupe"
.IX Subsection "dupe"
.Vb 1
\&    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
.Ve
.PP
On threaded builds a regexp may need to be duplicated so that the pattern
can be used by multiple threads. This routine is expected to handle the
duplication of any private data pointed to by the \f(CW\*(C`pprivate\*(C'\fR member of
the regexp structure.  It will be called with the preconstructed new
regexp structure as an argument, the \f(CW\*(C`pprivate\*(C'\fR member will point at
the \fBold\fR private structure, and it is this routine's responsibility to
construct a copy and return a pointer to it (which perl will then use to
overwrite the field as passed to this routine.)
.PP
This allows the engine to dupe its private data but also if necessary
modify the final structure if it really must.
.PP
On unthreaded builds this field doesn't exist.
.SH "The REGEXP structure"
.IX Header "The REGEXP structure"
The \s-1REGEXP\s0 struct is defined in \fIregexp.h\fR. All regex engines must be able to
correctly build such a structure in their \*(L"comp\*(R" routine.
.PP
The \s-1REGEXP\s0 structure contains all the data that perl needs to be aware of
to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.
.PP
In addition it contains two fields that are intended for the private
use of the regex engine that compiled the pattern. These are the
\&\f(CW\*(C`intflags\*(C'\fR and \f(CW\*(C`pprivate\*(C'\fR members. \f(CW\*(C`pprivate\*(C'\fR is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values.
.PP
.Vb 3
\&    typedef struct regexp {
\&        /* what engine created this regexp? */
\&        const struct regexp_engine* engine;
\&
\&        /* what re is this a lightweight copy of? */
\&        struct regexp* mother_re;
\&
\&        /* Information about the match that the perl core uses to manage things */
\&        U32 extflags;   /* Flags used both externally and internally */
\&        I32 minlen;     /* mininum possible length of string to match */
\&        I32 minlenret;  /* mininum possible length of $& */
\&        U32 gofs;       /* chars left of pos that we search from */
\&
\&        /* substring data about strings that must appear
\&           in the final match, used for optimisations */
\&        struct reg_substr_data *substrs;
\&
\&        U32 nparens;  /* number of capture groups */
\&
\&        /* private engine specific data */
\&        U32 intflags;   /* Engine Specific Internal flags */
\&        void *pprivate; /* Data private to the regex engine which 
\&                           created this object. */
\&
\&        /* Data about the last/current match. These are modified during matching*/
\&        U32 lastparen;            /* last open paren matched */
\&        U32 lastcloseparen;       /* last close paren matched */
\&        regexp_paren_pair *swap;  /* Swap copy of *offs */
\&        regexp_paren_pair *offs;  /* Array of offsets for (@\-) and (@+) */
\&
\&        char *subbeg;  /* saved or original string so \edigit works forever. */
\&        SV_SAVED_COPY  /* If non\-NULL, SV which is COW from original */
\&        I32 sublen;    /* Length of string pointed by subbeg */
\&
\&        /* Information about the match that isn\*(Aqt often used */
\&        I32 prelen;           /* length of precomp */
\&        const char *precomp;  /* pre\-compilation regular expression */
\&
\&        char *wrapped;  /* wrapped version of the pattern */
\&        I32 wraplen;    /* length of wrapped */
\&
\&        I32 seen_evals;   /* number of eval groups in the pattern \- for security checks */
\&        HV *paren_names;  /* Optional hash of paren names */
\&
\&        /* Refcount of this regexp */
\&        I32 refcnt;             /* Refcount of this regexp */
\&    } regexp;
.Ve
.PP
The fields are discussed in more detail below:
.ie n .SS """engine"""
.el .SS "\f(CWengine\fP"
.IX Subsection "engine"
This field points at a regexp_engine structure which contains pointers
to the subroutines that are to be used for performing a match. It
is the compiling routine's responsibility to populate this field before
returning the regexp object.
.PP
Internally this is set to \f(CW\*(C`NULL\*(C'\fR unless a custom engine is specified in
\&\f(CW$^H{regcomp}\fR, perl's own set of callbacks can be accessed in the struct
pointed to by \f(CW\*(C`RE_ENGINE_PTR\*(C'\fR.
.ie n .SS """mother_re"""
.el .SS "\f(CWmother_re\fP"
.IX Subsection "mother_re"
\&\s-1TODO\s0, see http://www.mail\-archive.com/perl5\-changes@perl.org/msg17328.html <http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html>
.ie n .SS """extflags"""
.el .SS "\f(CWextflags\fP"
.IX Subsection "extflags"
This will be used by perl to see what flags the regexp was compiled
with, this will normally be set to the value of the flags parameter by
the comp callback. See the comp documentation for
valid flags.
.ie n .SS """minlen"" ""minlenret"""
.el .SS "\f(CWminlen\fP \f(CWminlenret\fP"
.IX Subsection "minlen minlenret"
The minimum string length required for the pattern to match.  This is used to
prune the search space by not bothering to match any closer to the end of a
string than would allow a match. For instance there is no point in even
starting the regex engine if the minlen is 10 but the string is only 5
characters long. There is no way that the pattern can match.
.PP
\&\f(CW\*(C`minlenret\*(C'\fR is the minimum length of the string that would be found
in $& after a match.
.PP
The difference between \f(CW\*(C`minlen\*(C'\fR and \f(CW\*(C`minlenret\*(C'\fR can be seen in the
following pattern:
.PP
.Vb 1
\&    /ns(?=\ed)/
.Ve
.PP
where the \f(CW\*(C`minlen\*(C'\fR would be 3 but \f(CW\*(C`minlenret\*(C'\fR would only be 2 as the \ed is
required to match but is not actually included in the matched content. This
distinction is particularly important as the substitution logic uses the
\&\f(CW\*(C`minlenret\*(C'\fR to tell whether it can do in-place substitution which can result in
considerable speedup.
.ie n .SS """gofs"""
.el .SS "\f(CWgofs\fP"
.IX Subsection "gofs"
Left offset from \fIpos()\fR to start match at.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Substring data about strings that must appear in the final match. This
is currently only used internally by perl's engine for but might be
used in the future for all engines for optimisations.
.ie n .SS """nparens"", ""lastparen"", and ""lastcloseparen"""
.el .SS "\f(CWnparens\fP, \f(CWlastparen\fP, and \f(CWlastcloseparen\fP"
.IX Subsection "nparens, lastparen, and lastcloseparen"
These fields are used to keep track of how many paren groups could be matched
in the pattern, which was the last open paren to be entered, and which was
the last close paren to be entered.
.ie n .SS """intflags"""
.el .SS "\f(CWintflags\fP"
.IX Subsection "intflags"
The engine's private copy of the flags the pattern was compiled with. Usually
this is the same as \f(CW\*(C`extflags\*(C'\fR unless the engine chose to modify one of them.
.ie n .SS """pprivate"""
.el .SS "\f(CWpprivate\fP"
.IX Subsection "pprivate"
A void* pointing to an engine-defined data structure. The perl engine uses the
\&\f(CW\*(C`regexp_internal\*(C'\fR structure (see \*(L"Base Structures\*(R" in perlreguts) but a custom
engine should use something else.
.ie n .SS """swap"""
.el .SS "\f(CWswap\fP"
.IX Subsection "swap"
Unused. Left in for compatibility with perl 5.10.0.
.ie n .SS """offs"""
.el .SS "\f(CWoffs\fP"
.IX Subsection "offs"
A \f(CW\*(C`regexp_paren_pair\*(C'\fR structure which defines offsets into the string being
matched which correspond to the \f(CW$&\fR and \f(CW$1\fR, \f(CW$2\fR etc. captures, the
\&\f(CW\*(C`regexp_paren_pair\*(C'\fR struct is defined as follows:
.PP
.Vb 4
\&    typedef struct regexp_paren_pair {
\&        I32 start;
\&        I32 end;
\&    } regexp_paren_pair;
.Ve
.PP
If \f(CW\*(C`\->offs[num].start\*(C'\fR or \f(CW\*(C`\->offs[num].end\*(C'\fR is \f(CW\*(C`\-1\*(C'\fR then that
capture group did not match. \f(CW\*(C`\->offs[0].start/end\*(C'\fR represents \f(CW$&\fR (or
\&\f(CW\*(C`${^MATCH\*(C'\fR under \f(CW\*(C`//p\*(C'\fR) and \f(CW\*(C`\->offs[paren].end\*(C'\fR matches \f(CW$$paren\fR where
\&\f(CW$paren \fR= 1>.
.ie n .SS """precomp"" ""prelen"""
.el .SS "\f(CWprecomp\fP \f(CWprelen\fP"
.IX Subsection "precomp prelen"
Used for optimisations. \f(CW\*(C`precomp\*(C'\fR holds a copy of the pattern that
was compiled and \f(CW\*(C`prelen\*(C'\fR its length. When a new pattern is to be
compiled (such as inside a loop) the internal \f(CW\*(C`regcomp\*(C'\fR operator
checks whether the last compiled \f(CW\*(C`REGEXP\*(C'\fR's \f(CW\*(C`precomp\*(C'\fR and \f(CW\*(C`prelen\*(C'\fR
are equivalent to the new one, and if so uses the old pattern instead
of compiling a new one.
.PP
The relevant snippet from \f(CW\*(C`Perl_pp_regcomp\*(C'\fR:
.PP
.Vb 3
\&        if (!re || !re\->precomp || re\->prelen != (I32)len ||
\&            memNE(re\->precomp, t, len))
\&        /* Compile a new pattern */
.Ve
.ie n .SS """paren_names"""
.el .SS "\f(CWparen_names\fP"
.IX Subsection "paren_names"
This is a hash used internally to track named capture groups and their
offsets. The keys are the names of the buffers the values are dualvars,
with the \s-1IV\s0 slot holding the number of buffers with the given name and the
pv being an embedded array of I32.  The values may also be contained
independently in the data array in cases where named backreferences are
used.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Holds information on the longest string that must occur at a fixed
offset from the start of the pattern, and the longest string that must
occur at a floating offset from the start of the pattern. Used to do
Fast-Boyer-Moore searches on the string to find out if its worth using
the regex engine at all, and if so where in the string to search.
.ie n .SS """subbeg"" ""sublen"" ""saved_copy"""
.el .SS "\f(CWsubbeg\fP \f(CWsublen\fP \f(CWsaved_copy\fP"
.IX Subsection "subbeg sublen saved_copy"
Used during execution phase for managing search and replace patterns.
.ie n .SS """wrapped"" ""wraplen"""
.el .SS "\f(CWwrapped\fP \f(CWwraplen\fP"
.IX Subsection "wrapped wraplen"
Stores the string \f(CW\*(C`qr//\*(C'\fR stringifies to. The perl engine for example
stores \f(CW\*(C`(?^:eek)\*(C'\fR in the case of \f(CW\*(C`qr/eek/\*(C'\fR.
.PP
When using a custom engine that doesn't support the \f(CW\*(C`(?:)\*(C'\fR construct
for inline modifiers, it's probably best to have \f(CW\*(C`qr//\*(C'\fR stringify to
the supplied pattern, note that this will create undesired patterns in
cases such as:
.PP
.Vb 3
\&    my $x = qr/a|b/;  # "a|b"
\&    my $y = qr/c/i;   # "c"
\&    my $z = qr/$x$y/; # "a|bc"
.Ve
.PP
There's no solution for this problem other than making the custom
engine understand a construct like \f(CW\*(C`(?:)\*(C'\fR.
.ie n .SS """seen_evals"""
.el .SS "\f(CWseen_evals\fP"
.IX Subsection "seen_evals"
This stores the number of eval groups in the pattern. This is used for security
purposes when embedding compiled regexes into larger patterns with \f(CW\*(C`qr//\*(C'\fR.
.ie n .SS """refcnt"""
.el .SS "\f(CWrefcnt\fP"
.IX Subsection "refcnt"
The number of times the structure is referenced. When this falls to 0 the
regexp is automatically freed by a call to pregfree. This should be set to 1 in
each engine's \*(L"comp\*(R" routine.
.SH "HISTORY"
.IX Header "HISTORY"
Originally part of perlreguts.
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally written by Yves Orton, expanded by \*(AEvar Arnfjo\*:r\*(d-
Bjarmason.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2006 Yves Orton and 2007 \*(AEvar Arnfjo\*:r\*(d- Bjarmason.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreapi5.18.1                              0100644 0001750 0001750 00000115711 12566207443 023246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREAPI 1"
.TH PERLREAPI 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreapi \- Perl regular expression plugin interface
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As of Perl 5.9.5 there is a new interface for plugging and using
regular expression engines other than the default one.
.PP
Each engine is supposed to provide access to a constant structure of the
following format:
.PP
.Vb 10
\&    typedef struct regexp_engine {
\&        REGEXP* (*comp) (pTHX_
\&                         const SV * const pattern, const U32 flags);
\&        I32     (*exec) (pTHX_
\&                         REGEXP * const rx,
\&                         char* stringarg,
\&                         char* strend, char* strbeg,
\&                         I32 minend, SV* screamer,
\&                         void* data, U32 flags);
\&        char*   (*intuit) (pTHX_
\&                           REGEXP * const rx, SV *sv,
\&                           char *strpos, char *strend, U32 flags,
\&                           struct re_scream_pos_data_s *data);
\&        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
\&        void    (*free) (pTHX_ REGEXP * const rx);
\&        void    (*numbered_buff_FETCH) (pTHX_
\&                                        REGEXP * const rx,
\&                                        const I32 paren,
\&                                        SV * const sv);
\&        void    (*numbered_buff_STORE) (pTHX_
\&                                        REGEXP * const rx,
\&                                        const I32 paren,
\&                                        SV const * const value);
\&        I32     (*numbered_buff_LENGTH) (pTHX_
\&                                         REGEXP * const rx,
\&                                         const SV * const sv,
\&                                         const I32 paren);
\&        SV*     (*named_buff) (pTHX_
\&                               REGEXP * const rx,
\&                               SV * const key,
\&                               SV * const value,
\&                               U32 flags);
\&        SV*     (*named_buff_iter) (pTHX_
\&                                    REGEXP * const rx,
\&                                    const SV * const lastkey,
\&                                    const U32 flags);
\&        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
\&    #ifdef USE_ITHREADS
\&        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
\&    #endif
\&        REGEXP* (*op_comp) (...);
.Ve
.PP
When a regexp is compiled, its \f(CW\*(C`engine\*(C'\fR field is then set to point at
the appropriate structure, so that when it needs to be used Perl can find
the right routines to do so.
.PP
In order to install a new regexp handler, \f(CW$^H{regcomp}\fR is set
to an integer which (when casted appropriately) resolves to one of these
structures.  When compiling, the \f(CW\*(C`comp\*(C'\fR method is executed, and the
resulting \f(CW\*(C`regexp\*(C'\fR structure's engine field is expected to point back at
the same structure.
.PP
The pTHX_ symbol in the definition is a macro used by Perl under threading
to provide an extra argument to the routine holding a pointer back to
the interpreter that is executing the regexp. So under threading all
routines get an extra argument.
.SH "Callbacks"
.IX Header "Callbacks"
.SS "comp"
.IX Subsection "comp"
.Vb 1
\&    REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
.Ve
.PP
Compile the pattern stored in \f(CW\*(C`pattern\*(C'\fR using the given \f(CW\*(C`flags\*(C'\fR and
return a pointer to a prepared \f(CW\*(C`REGEXP\*(C'\fR structure that can perform
the match.  See \*(L"The \s-1REGEXP\s0 structure\*(R" below for an explanation of
the individual fields in the \s-1REGEXP\s0 struct.
.PP
The \f(CW\*(C`pattern\*(C'\fR parameter is the scalar that was used as the
pattern.  Previous versions of Perl would pass two \f(CW\*(C`char*\*(C'\fR indicating
the start and end of the stringified pattern; the following snippet can
be used to get the old parameters:
.PP
.Vb 3
\&    STRLEN plen;
\&    char*  exp = SvPV(pattern, plen);
\&    char* xend = exp + plen;
.Ve
.PP
Since any scalar can be passed as a pattern, it's possible to implement
an engine that does something with an array (\f(CW\*(C`"ook" =~ [ qw/ eek
hlagh / ]\*(C'\fR) or with the non-stringified form of a compiled regular
expression (\f(CW\*(C`"ook" =~ qr/eek/\*(C'\fR).  Perl's own engine will always
stringify everything using the snippet above, but that doesn't mean
other engines have to.
.PP
The \f(CW\*(C`flags\*(C'\fR parameter is a bitfield which indicates which of the
\&\f(CW\*(C`msixp\*(C'\fR flags the regex was compiled with.  It also contains
additional info, such as if \f(CW\*(C`use locale\*(C'\fR is in effect.
.PP
The \f(CW\*(C`eogc\*(C'\fR flags are stripped out before being passed to the comp
routine.  The regex engine does not need to know if any of these
are set, as those flags should only affect what Perl does with the
pattern and its match variables, not how it gets compiled and
executed.
.PP
By the time the comp callback is called, some of these flags have
already had effect (noted below where applicable).  However most of
their effect occurs after the comp callback has run, in routines that
read the \f(CW\*(C`rx\->extflags\*(C'\fR field which it populates.
.PP
In general the flags should be preserved in \f(CW\*(C`rx\->extflags\*(C'\fR after
compilation, although the regex engine might want to add or delete
some of them to invoke or disable some special behavior in Perl.  The
flags along with any special behavior they cause are documented below:
.PP
The pattern modifiers:
.ie n .IP """/m"" \- RXf_PMf_MULTILINE" 4
.el .IP "\f(CW/m\fR \- RXf_PMf_MULTILINE" 4
.IX Item "/m - RXf_PMf_MULTILINE"
If this is in \f(CW\*(C`rx\->extflags\*(C'\fR it will be passed to
\&\f(CW\*(C`Perl_fbm_instr\*(C'\fR by \f(CW\*(C`pp_split\*(C'\fR which will treat the subject string
as a multi-line string.
.ie n .IP """/s"" \- RXf_PMf_SINGLELINE" 4
.el .IP "\f(CW/s\fR \- RXf_PMf_SINGLELINE" 4
.IX Item "/s - RXf_PMf_SINGLELINE"
.PD 0
.ie n .IP """/i"" \- RXf_PMf_FOLD" 4
.el .IP "\f(CW/i\fR \- RXf_PMf_FOLD" 4
.IX Item "/i - RXf_PMf_FOLD"
.ie n .IP """/x"" \- RXf_PMf_EXTENDED" 4
.el .IP "\f(CW/x\fR \- RXf_PMf_EXTENDED" 4
.IX Item "/x - RXf_PMf_EXTENDED"
.PD
If present on a regex, \f(CW"#"\fR comments will be handled differently by the
tokenizer in some cases.
.Sp
\&\s-1TODO:\s0 Document those cases.
.ie n .IP """/p"" \- RXf_PMf_KEEPCOPY" 4
.el .IP "\f(CW/p\fR \- RXf_PMf_KEEPCOPY" 4
.IX Item "/p - RXf_PMf_KEEPCOPY"
\&\s-1TODO:\s0 Document this
.IP "Character set" 4
.IX Item "Character set"
The character set semantics are determined by an enum that is contained
in this field.  This is still experimental and subject to change, but
the current interface returns the rules by use of the in-line function
\&\f(CW\*(C`get_regex_charset(const U32 flags)\*(C'\fR.  The only currently documented
value returned from it is \s-1REGEX_LOCALE_CHARSET,\s0 which is set if
\&\f(CW\*(C`use locale\*(C'\fR is in effect. If present in \f(CW\*(C`rx\->extflags\*(C'\fR,
\&\f(CW\*(C`split\*(C'\fR will use the locale dependent definition of whitespace
when RXf_SKIPWHITE or RXf_WHITE is in effect.  \s-1ASCII\s0 whitespace
is defined as per isSPACE, and by the internal
macros \f(CW\*(C`is_utf8_space\*(C'\fR under \s-1UTF\-8,\s0 and \f(CW\*(C`isSPACE_LC\*(C'\fR under \f(CW\*(C`use
locale\*(C'\fR.
.PP
Additional flags:
.IP "RXf_SPLIT" 4
.IX Item "RXf_SPLIT"
This flag was removed in perl 5.18.0.  \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR is now special-cased
solely in the parser.  RXf_SPLIT is still #defined, so you can test for it.
This is how it used to work:
.Sp
If \f(CW\*(C`split\*(C'\fR is invoked as \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR or with no arguments (which
really means \f(CW\*(C`split(\*(Aq \*(Aq, $_)\*(C'\fR, see split), Perl will
set this flag.  The regex engine can then check for it and set the
\&\s-1SKIPWHITE\s0 and \s-1WHITE\s0 extflags.  To do this, the Perl engine does:
.Sp
.Vb 2
\&    if (flags & RXf_SPLIT && r\->prelen == 1 && r\->precomp[0] == \*(Aq \*(Aq)
\&        r\->extflags |= (RXf_SKIPWHITE|RXf_WHITE);
.Ve
.PP
These flags can be set during compilation to enable optimizations in
the \f(CW\*(C`split\*(C'\fR operator.
.IP "RXf_SKIPWHITE" 4
.IX Item "RXf_SKIPWHITE"
This flag was removed in perl 5.18.0.  It is still #defined, so you can
set it, but doing so will have no effect.  This is how it used to work:
.Sp
If the flag is present in \f(CW\*(C`rx\->extflags\*(C'\fR \f(CW\*(C`split\*(C'\fR will delete
whitespace from the start of the subject string before it's operated
on.  What is considered whitespace depends on if the subject is a
\&\s-1UTF\-8\s0 string and if the \f(CW\*(C`RXf_PMf_LOCALE\*(C'\fR flag is set.
.Sp
If RXf_WHITE is set in addition to this flag, \f(CW\*(C`split\*(C'\fR will behave like
\&\f(CW\*(C`split " "\*(C'\fR under the Perl engine.
.IP "RXf_START_ONLY" 4
.IX Item "RXf_START_ONLY"
Tells the split operator to split the target string on newlines
(\f(CW\*(C`\en\*(C'\fR) without invoking the regex engine.
.Sp
Perl's engine sets this if the pattern is \f(CW\*(C`/^/\*(C'\fR (\f(CW\*(C`plen == 1 && *exp
== \*(Aq^\*(Aq\*(C'\fR), even under \f(CW\*(C`/^/s\*(C'\fR; see split.  Of course a
different regex engine might want to use the same optimizations
with a different syntax.
.IP "RXf_WHITE" 4
.IX Item "RXf_WHITE"
Tells the split operator to split the target string on whitespace
without invoking the regex engine.  The definition of whitespace varies
depending on if the target string is a \s-1UTF\-8\s0 string and on
if RXf_PMf_LOCALE is set.
.Sp
Perl's engine sets this flag if the pattern is \f(CW\*(C`\es+\*(C'\fR.
.IP "RXf_NULL" 4
.IX Item "RXf_NULL"
Tells the split operator to split the target string on
characters.  The definition of character varies depending on if
the target string is a \s-1UTF\-8\s0 string.
.Sp
Perl's engine sets this flag on empty patterns, this optimization
makes \f(CW\*(C`split //\*(C'\fR much faster than it would otherwise be.  It's even
faster than \f(CW\*(C`unpack\*(C'\fR.
.IP "RXf_NO_INPLACE_SUBST" 4
.IX Item "RXf_NO_INPLACE_SUBST"
Added in perl 5.18.0, this flag indicates that a regular expression might
perform an operation that would interfere with inplace substituion. For
instance it might contain lookbehind, or assign to non-magical variables
(such as \f(CW$REGMARK\fR and \f(CW$REGERROR\fR) during matching.  \f(CW\*(C`s///\*(C'\fR will skip
certain optimisations when this is set.
.SS "exec"
.IX Subsection "exec"
.Vb 4
\&    I32 exec(pTHX_ REGEXP * const rx,
\&             char *stringarg, char* strend, char* strbeg,
\&             I32 minend, SV* screamer,
\&             void* data, U32 flags);
.Ve
.PP
Execute a regexp. The arguments are
.IP "rx" 4
.IX Item "rx"
The regular expression to execute.
.IP "screamer" 4
.IX Item "screamer"
This strangely-named arg is the \s-1SV\s0 to be matched against.  Note that the
actual char array to be matched against is supplied by the arguments
described below; the \s-1SV\s0 is just used to determine UTF8ness, \f(CW\*(C`pos()\*(C'\fR etc.
.IP "strbeg" 4
.IX Item "strbeg"
Pointer to the physical start of the string.
.IP "strend" 4
.IX Item "strend"
Pointer to the character following the physical end of the string (i.e.
the \f(CW\*(C`\e0\*(C'\fR).
.IP "stringarg" 4
.IX Item "stringarg"
Pointer to the position in the string where matching should start; it might
not be equal to \f(CW\*(C`strbeg\*(C'\fR (for example in a later iteration of \f(CW\*(C`/.../g\*(C'\fR).
.IP "minend" 4
.IX Item "minend"
Minimum length of string (measured in bytes from \f(CW\*(C`stringarg\*(C'\fR) that must
match; if the engine reaches the end of the match but hasn't reached this
position in the string, it should fail.
.IP "data" 4
.IX Item "data"
Optimisation data; subject to change.
.IP "flags" 4
.IX Item "flags"
Optimisation flags; subject to change.
.SS "intuit"
.IX Subsection "intuit"
.Vb 3
\&    char* intuit(pTHX_ REGEXP * const rx,
\&                  SV *sv, char *strpos, char *strend,
\&                  const U32 flags, struct re_scream_pos_data_s *data);
.Ve
.PP
Find the start position where a regex match should be attempted,
or possibly if the regex engine should not be run because the
pattern can't match.  This is called, as appropriate, by the core,
depending on the values of the \f(CW\*(C`extflags\*(C'\fR member of the \f(CW\*(C`regexp\*(C'\fR
structure.
.SS "checkstr"
.IX Subsection "checkstr"
.Vb 1
\&    SV* checkstr(pTHX_ REGEXP * const rx);
.Ve
.PP
Return a \s-1SV\s0 containing a string that must appear in the pattern. Used
by \f(CW\*(C`split\*(C'\fR for optimising matches.
.SS "free"
.IX Subsection "free"
.Vb 1
\&    void free(pTHX_ REGEXP * const rx);
.Ve
.PP
Called by Perl when it is freeing a regexp pattern so that the engine
can release any resources pointed to by the \f(CW\*(C`pprivate\*(C'\fR member of the
\&\f(CW\*(C`regexp\*(C'\fR structure.  This is only responsible for freeing private data;
Perl will handle releasing anything else contained in the \f(CW\*(C`regexp\*(C'\fR structure.
.SS "Numbered capture callbacks"
.IX Subsection "Numbered capture callbacks"
Called to get/set the value of \f(CW\*(C`$\`\*(C'\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, \f(CW$&\fR and their named
equivalents, ${^PREMATCH}, ${^POSTMATCH} and $^{\s-1MATCH\s0}, as well as the
numbered capture groups (\f(CW$1\fR, \f(CW$2\fR, ...).
.PP
The \f(CW\*(C`paren\*(C'\fR parameter will be \f(CW1\fR for \f(CW$1\fR, \f(CW2\fR for \f(CW$2\fR and so
forth, and have these symbolic values for the special variables:
.PP
.Vb 6
\&    ${^PREMATCH}  RX_BUFF_IDX_CARET_PREMATCH
\&    ${^POSTMATCH} RX_BUFF_IDX_CARET_POSTMATCH
\&    ${^MATCH}     RX_BUFF_IDX_CARET_FULLMATCH
\&    $\`            RX_BUFF_IDX_PREMATCH
\&    $\*(Aq            RX_BUFF_IDX_POSTMATCH
\&    $&            RX_BUFF_IDX_FULLMATCH
.Ve
.PP
Note that in Perl 5.17.3 and earlier, the last three constants were also
used for the caret variants of the variables.
.PP
The names have been chosen by analogy with Tie::Scalar methods
names with an additional \fB\s-1LENGTH\s0\fR callback for efficiency.  However
named capture variables are currently not tied internally but
implemented via magic.
.PP
\fInumbered_buff_FETCH\fR
.IX Subsection "numbered_buff_FETCH"
.PP
.Vb 2
\&    void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
\&                             SV * const sv);
.Ve
.PP
Fetch a specified numbered capture.  \f(CW\*(C`sv\*(C'\fR should be set to the scalar
to return, the scalar is passed as an argument rather than being
returned from the function because when it's called Perl already has a
scalar to store the value, creating another one would be
redundant.  The scalar can be set with \f(CW\*(C`sv_setsv\*(C'\fR, \f(CW\*(C`sv_setpvn\*(C'\fR and
friends, see perlapi.
.PP
This callback is where Perl untaints its own capture variables under
taint mode (see perlsec).  See the \f(CW\*(C`Perl_reg_numbered_buff_fetch\*(C'\fR
function in \fIregcomp.c\fR for how to untaint capture variables if
that's something you'd like your engine to do as well.
.PP
\fInumbered_buff_STORE\fR
.IX Subsection "numbered_buff_STORE"
.PP
.Vb 4
\&    void    (*numbered_buff_STORE) (pTHX_
\&                                    REGEXP * const rx,
\&                                    const I32 paren,
\&                                    SV const * const value);
.Ve
.PP
Set the value of a numbered capture variable.  \f(CW\*(C`value\*(C'\fR is the scalar
that is to be used as the new value.  It's up to the engine to make
sure this is used as the new value (or reject it).
.PP
Example:
.PP
.Vb 4
\&    if ("ook" =~ /(o*)/) {
\&        # \*(Aqparen\*(Aq will be \*(Aq1\*(Aq and \*(Aqvalue\*(Aq will be \*(Aqee\*(Aq
\&        $1 =~ tr/o/e/;
\&    }
.Ve
.PP
Perl's own engine will croak on any attempt to modify the capture
variables, to do this in another engine use the following callback
(copied from \f(CW\*(C`Perl_reg_numbered_buff_store\*(C'\fR):
.PP
.Vb 9
\&    void
\&    Example_reg_numbered_buff_store(pTHX_
\&                                    REGEXP * const rx,
\&                                    const I32 paren,
\&                                    SV const * const value)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        PERL_UNUSED_ARG(paren);
\&        PERL_UNUSED_ARG(value);
\&
\&        if (!PL_localizing)
\&            Perl_croak(aTHX_ PL_no_modify);
\&    }
.Ve
.PP
Actually Perl will not \fIalways\fR croak in a statement that looks
like it would modify a numbered capture variable.  This is because the
\&\s-1STORE\s0 callback will not be called if Perl can determine that it
doesn't have to modify the value.  This is exactly how tied variables
behave in the same situation:
.PP
.Vb 2
\&    package CaptureVar;
\&    use base \*(AqTie::Scalar\*(Aq;
\&
\&    sub TIESCALAR { bless [] }
\&    sub FETCH { undef }
\&    sub STORE { die "This doesn\*(Aqt get called" }
\&
\&    package main;
\&
\&    tie my $sv => "CaptureVar";
\&    $sv =~ y/a/b/;
.Ve
.PP
Because \f(CW$sv\fR is \f(CW\*(C`undef\*(C'\fR when the \f(CW\*(C`y///\*(C'\fR operator is applied to it,
the transliteration won't actually execute and the program won't
\&\f(CW\*(C`die\*(C'\fR.  This is different to how 5.8 and earlier versions behaved
since the capture variables were \s-1READONLY\s0 variables then; now they'll
just die when assigned to in the default engine.
.PP
\fInumbered_buff_LENGTH\fR
.IX Subsection "numbered_buff_LENGTH"
.PP
.Vb 4
\&    I32 numbered_buff_LENGTH (pTHX_
\&                              REGEXP * const rx,
\&                              const SV * const sv,
\&                              const I32 paren);
.Ve
.PP
Get the \f(CW\*(C`length\*(C'\fR of a capture variable.  There's a special callback
for this so that Perl doesn't have to do a \s-1FETCH\s0 and run \f(CW\*(C`length\*(C'\fR on
the result, since the length is (in Perl's case) known from an offset
stored in \f(CW\*(C`rx\->offs\*(C'\fR, this is much more efficient:
.PP
.Vb 3
\&    I32 s1  = rx\->offs[paren].start;
\&    I32 s2  = rx\->offs[paren].end;
\&    I32 len = t1 \- s1;
.Ve
.PP
This is a little bit more complex in the case of \s-1UTF\-8,\s0 see what
\&\f(CW\*(C`Perl_reg_numbered_buff_length\*(C'\fR does with
is_utf8_string_loclen.
.SS "Named capture callbacks"
.IX Subsection "Named capture callbacks"
Called to get/set the value of \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR, as well as by some
utility functions in re.
.PP
There are two callbacks, \f(CW\*(C`named_buff\*(C'\fR is called in all the cases the
\&\s-1FETCH, STORE, DELETE, CLEAR, EXISTS\s0 and \s-1SCALAR \s0Tie::Hash callbacks
would be on changes to \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR and \f(CW\*(C`named_buff_iter\*(C'\fR in the
same cases as \s-1FIRSTKEY\s0 and \s-1NEXTKEY.\s0
.PP
The \f(CW\*(C`flags\*(C'\fR parameter can be used to determine which of these
operations the callbacks should respond to.  The following flags are
currently defined:
.PP
Which Tie::Hash operation is being performed from the Perl level on
\&\f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%+\*(C'\fR, if any:
.PP
.Vb 8
\&    RXapif_FETCH
\&    RXapif_STORE
\&    RXapif_DELETE
\&    RXapif_CLEAR
\&    RXapif_EXISTS
\&    RXapif_SCALAR
\&    RXapif_FIRSTKEY
\&    RXapif_NEXTKEY
.Ve
.PP
If \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR is being operated on, if any.
.PP
.Vb 2
\&    RXapif_ONE /* %+ */
\&    RXapif_ALL /* %\- */
.Ve
.PP
If this is being called as \f(CW\*(C`re::regname\*(C'\fR, \f(CW\*(C`re::regnames\*(C'\fR or
\&\f(CW\*(C`re::regnames_count\*(C'\fR, if any.  The first two will be combined with
\&\f(CW\*(C`RXapif_ONE\*(C'\fR or \f(CW\*(C`RXapif_ALL\*(C'\fR.
.PP
.Vb 3
\&    RXapif_REGNAME
\&    RXapif_REGNAMES
\&    RXapif_REGNAMES_COUNT
.Ve
.PP
Internally \f(CW\*(C`%+\*(C'\fR and \f(CW\*(C`%\-\*(C'\fR are implemented with a real tied interface
via Tie::Hash::NamedCapture.  The methods in that package will call
back into these functions.  However the usage of
Tie::Hash::NamedCapture for this purpose might change in future
releases.  For instance this might be implemented by magic instead
(would need an extension to mgvtbl).
.PP
\fInamed_buff\fR
.IX Subsection "named_buff"
.PP
.Vb 2
\&    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
\&                           SV * const value, U32 flags);
.Ve
.PP
\fInamed_buff_iter\fR
.IX Subsection "named_buff_iter"
.PP
.Vb 4
\&    SV*     (*named_buff_iter) (pTHX_
\&                                REGEXP * const rx,
\&                                const SV * const lastkey,
\&                                const U32 flags);
.Ve
.SS "qr_package"
.IX Subsection "qr_package"
.Vb 1
\&    SV* qr_package(pTHX_ REGEXP * const rx);
.Ve
.PP
The package the qr// magic object is blessed into (as seen by \f(CW\*(C`ref
qr//\*(C'\fR).  It is recommended that engines change this to their package
name for identification regardless of if they implement methods
on the object.
.PP
The package this method returns should also have the internal
\&\f(CW\*(C`Regexp\*(C'\fR package in its \f(CW@ISA\fR.  \f(CW\*(C`qr//\->isa("Regexp")\*(C'\fR should always
be true regardless of what engine is being used.
.PP
Example implementation might be:
.PP
.Vb 6
\&    SV*
\&    Example_qr_package(pTHX_ REGEXP * const rx)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        return newSVpvs("re::engine::Example");
\&    }
.Ve
.PP
Any method calls on an object created with \f(CW\*(C`qr//\*(C'\fR will be dispatched to the
package as a normal object.
.PP
.Vb 3
\&    use re::engine::Example;
\&    my $re = qr//;
\&    $re\->meth; # dispatched to re::engine::Example::meth()
.Ve
.PP
To retrieve the \f(CW\*(C`REGEXP\*(C'\fR object from the scalar in an \s-1XS\s0 function use
the \f(CW\*(C`SvRX\*(C'\fR macro, see \*(L"\s-1REGEXP\s0 Functions\*(R" in perlapi.
.PP
.Vb 3
\&    void meth(SV * rv)
\&    PPCODE:
\&        REGEXP * re = SvRX(sv);
.Ve
.SS "dupe"
.IX Subsection "dupe"
.Vb 1
\&    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
.Ve
.PP
On threaded builds a regexp may need to be duplicated so that the pattern
can be used by multiple threads.  This routine is expected to handle the
duplication of any private data pointed to by the \f(CW\*(C`pprivate\*(C'\fR member of
the \f(CW\*(C`regexp\*(C'\fR structure.  It will be called with the preconstructed new
\&\f(CW\*(C`regexp\*(C'\fR structure as an argument, the \f(CW\*(C`pprivate\*(C'\fR member will point at
the \fBold\fR private structure, and it is this routine's responsibility to
construct a copy and return a pointer to it (which Perl will then use to
overwrite the field as passed to this routine.)
.PP
This allows the engine to dupe its private data but also if necessary
modify the final structure if it really must.
.PP
On unthreaded builds this field doesn't exist.
.SS "op_comp"
.IX Subsection "op_comp"
This is private to the Perl core and subject to change. Should be left
null.
.SH "The REGEXP structure"
.IX Header "The REGEXP structure"
The \s-1REGEXP\s0 struct is defined in \fIregexp.h\fR.
All regex engines must be able to
correctly build such a structure in their \*(L"comp\*(R" routine.
.PP
The \s-1REGEXP\s0 structure contains all the data that Perl needs to be aware of
to properly work with the regular expression.  It includes data about
optimisations that Perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts, such as if the pattern anchored in
some way, or what flags were used during the compile, or if the
program contains special constructs that Perl needs to be aware of.
.PP
In addition it contains two fields that are intended for the private
use of the regex engine that compiled the pattern.  These are the
\&\f(CW\*(C`intflags\*(C'\fR and \f(CW\*(C`pprivate\*(C'\fR members.  \f(CW\*(C`pprivate\*(C'\fR is a void pointer to
an arbitrary structure, whose use and management is the responsibility
of the compiling engine.  Perl will never modify either of these
values.
.PP
.Vb 3
\&    typedef struct regexp {
\&        /* what engine created this regexp? */
\&        const struct regexp_engine* engine;
\&
\&        /* what re is this a lightweight copy of? */
\&        struct regexp* mother_re;
\&
\&        /* Information about the match that the Perl core uses to manage
\&         * things */
\&        U32 extflags;   /* Flags used both externally and internally */
\&        I32 minlen;     /* mininum possible number of chars in */
\&                           string to match */
\&        I32 minlenret;  /* mininum possible number of chars in $& */
\&        U32 gofs;       /* chars left of pos that we search from */
\&
\&        /* substring data about strings that must appear
\&           in the final match, used for optimisations */
\&        struct reg_substr_data *substrs;
\&
\&        U32 nparens;  /* number of capture groups */
\&
\&        /* private engine specific data */
\&        U32 intflags;   /* Engine Specific Internal flags */
\&        void *pprivate; /* Data private to the regex engine which 
\&                           created this object. */
\&
\&        /* Data about the last/current match. These are modified during
\&         * matching*/
\&        U32 lastparen;            /* highest close paren matched ($+) */
\&        U32 lastcloseparen;       /* last close paren matched ($^N) */
\&        regexp_paren_pair *swap;  /* Swap copy of *offs */
\&        regexp_paren_pair *offs;  /* Array of offsets for (@\-) and
\&                                     (@+) */
\&
\&        char *subbeg;  /* saved or original string so \edigit works
\&                          forever. */
\&        SV_SAVED_COPY  /* If non\-NULL, SV which is COW from original */
\&        I32 sublen;    /* Length of string pointed by subbeg */
\&        I32 suboffset;  /* byte offset of subbeg from logical start of
\&                           str */
\&        I32 subcoffset; /* suboffset equiv, but in chars (for @\-/@+) */
\&
\&        /* Information about the match that isn\*(Aqt often used */
\&        I32 prelen;           /* length of precomp */
\&        const char *precomp;  /* pre\-compilation regular expression */
\&
\&        char *wrapped;  /* wrapped version of the pattern */
\&        I32 wraplen;    /* length of wrapped */
\&
\&        I32 seen_evals;   /* number of eval groups in the pattern \- for
\&                             security checks */
\&        HV *paren_names;  /* Optional hash of paren names */
\&
\&        /* Refcount of this regexp */
\&        I32 refcnt;             /* Refcount of this regexp */
\&    } regexp;
.Ve
.PP
The fields are discussed in more detail below:
.ie n .SS """engine"""
.el .SS "\f(CWengine\fP"
.IX Subsection "engine"
This field points at a \f(CW\*(C`regexp_engine\*(C'\fR structure which contains pointers
to the subroutines that are to be used for performing a match.  It
is the compiling routine's responsibility to populate this field before
returning the regexp object.
.PP
Internally this is set to \f(CW\*(C`NULL\*(C'\fR unless a custom engine is specified in
\&\f(CW$^H{regcomp}\fR, Perl's own set of callbacks can be accessed in the struct
pointed to by \f(CW\*(C`RE_ENGINE_PTR\*(C'\fR.
.ie n .SS """mother_re"""
.el .SS "\f(CWmother_re\fP"
.IX Subsection "mother_re"
\&\s-1TODO,\s0 see <http://www.mail\-archive.com/perl5\-changes@perl.org/msg17328.html>
.ie n .SS """extflags"""
.el .SS "\f(CWextflags\fP"
.IX Subsection "extflags"
This will be used by Perl to see what flags the regexp was compiled
with, this will normally be set to the value of the flags parameter by
the comp callback.  See the comp documentation for
valid flags.
.ie n .SS """minlen"" ""minlenret"""
.el .SS "\f(CWminlen\fP \f(CWminlenret\fP"
.IX Subsection "minlen minlenret"
The minimum string length (in characters) required for the pattern to match.
This is used to
prune the search space by not bothering to match any closer to the end of a
string than would allow a match.  For instance there is no point in even
starting the regex engine if the minlen is 10 but the string is only 5
characters long.  There is no way that the pattern can match.
.PP
\&\f(CW\*(C`minlenret\*(C'\fR is the minimum length (in characters) of the string that would
be found in $& after a match.
.PP
The difference between \f(CW\*(C`minlen\*(C'\fR and \f(CW\*(C`minlenret\*(C'\fR can be seen in the
following pattern:
.PP
.Vb 1
\&    /ns(?=\ed)/
.Ve
.PP
where the \f(CW\*(C`minlen\*(C'\fR would be 3 but \f(CW\*(C`minlenret\*(C'\fR would only be 2 as the \ed is
required to match but is not actually
included in the matched content.  This
distinction is particularly important as the substitution logic uses the
\&\f(CW\*(C`minlenret\*(C'\fR to tell if it can do in-place substitutions (these can
result in considerable speed-up).
.ie n .SS """gofs"""
.el .SS "\f(CWgofs\fP"
.IX Subsection "gofs"
Left offset from \fIpos()\fR to start match at.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Substring data about strings that must appear in the final match.  This
is currently only used internally by Perl's engine, but might be
used in the future for all engines for optimisations.
.ie n .SS """nparens"", ""lastparen"", and ""lastcloseparen"""
.el .SS "\f(CWnparens\fP, \f(CWlastparen\fP, and \f(CWlastcloseparen\fP"
.IX Subsection "nparens, lastparen, and lastcloseparen"
These fields are used to keep track of how many paren groups could be matched
in the pattern, which was the last open paren to be entered, and which was
the last close paren to be entered.
.ie n .SS """intflags"""
.el .SS "\f(CWintflags\fP"
.IX Subsection "intflags"
The engine's private copy of the flags the pattern was compiled with. Usually
this is the same as \f(CW\*(C`extflags\*(C'\fR unless the engine chose to modify one of them.
.ie n .SS """pprivate"""
.el .SS "\f(CWpprivate\fP"
.IX Subsection "pprivate"
A void* pointing to an engine-defined
data structure.  The Perl engine uses the
\&\f(CW\*(C`regexp_internal\*(C'\fR structure (see \*(L"Base Structures\*(R" in perlreguts) but a custom
engine should use something else.
.ie n .SS """swap"""
.el .SS "\f(CWswap\fP"
.IX Subsection "swap"
Unused.  Left in for compatibility with Perl 5.10.0.
.ie n .SS """offs"""
.el .SS "\f(CWoffs\fP"
.IX Subsection "offs"
A \f(CW\*(C`regexp_paren_pair\*(C'\fR structure which defines offsets into the string being
matched which correspond to the \f(CW$&\fR and \f(CW$1\fR, \f(CW$2\fR etc. captures, the
\&\f(CW\*(C`regexp_paren_pair\*(C'\fR struct is defined as follows:
.PP
.Vb 4
\&    typedef struct regexp_paren_pair {
\&        I32 start;
\&        I32 end;
\&    } regexp_paren_pair;
.Ve
.PP
If \f(CW\*(C`\->offs[num].start\*(C'\fR or \f(CW\*(C`\->offs[num].end\*(C'\fR is \f(CW\*(C`\-1\*(C'\fR then that
capture group did not match.
\&\f(CW\*(C`\->offs[0].start/end\*(C'\fR represents \f(CW$&\fR (or
\&\f(CW\*(C`${^MATCH}\*(C'\fR under \f(CW\*(C`//p\*(C'\fR) and \f(CW\*(C`\->offs[paren].end\*(C'\fR matches \f(CW$$paren\fR where
\&\f(CW$paren \fR= 1>.
.ie n .SS """precomp"" ""prelen"""
.el .SS "\f(CWprecomp\fP \f(CWprelen\fP"
.IX Subsection "precomp prelen"
Used for optimisations.  \f(CW\*(C`precomp\*(C'\fR holds a copy of the pattern that
was compiled and \f(CW\*(C`prelen\*(C'\fR its length.  When a new pattern is to be
compiled (such as inside a loop) the internal \f(CW\*(C`regcomp\*(C'\fR operator
checks if the last compiled \f(CW\*(C`REGEXP\*(C'\fR's \f(CW\*(C`precomp\*(C'\fR and \f(CW\*(C`prelen\*(C'\fR
are equivalent to the new one, and if so uses the old pattern instead
of compiling a new one.
.PP
The relevant snippet from \f(CW\*(C`Perl_pp_regcomp\*(C'\fR:
.PP
.Vb 3
\&        if (!re || !re\->precomp || re\->prelen != (I32)len ||
\&            memNE(re\->precomp, t, len))
\&        /* Compile a new pattern */
.Ve
.ie n .SS """paren_names"""
.el .SS "\f(CWparen_names\fP"
.IX Subsection "paren_names"
This is a hash used internally to track named capture groups and their
offsets.  The keys are the names of the buffers the values are dualvars,
with the \s-1IV\s0 slot holding the number of buffers with the given name and the
pv being an embedded array of I32.  The values may also be contained
independently in the data array in cases where named backreferences are
used.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Holds information on the longest string that must occur at a fixed
offset from the start of the pattern, and the longest string that must
occur at a floating offset from the start of the pattern.  Used to do
Fast-Boyer-Moore searches on the string to find out if its worth using
the regex engine at all, and if so where in the string to search.
.ie n .SS """subbeg"" ""sublen"" ""saved_copy"" ""suboffset"" ""subcoffset"""
.el .SS "\f(CWsubbeg\fP \f(CWsublen\fP \f(CWsaved_copy\fP \f(CWsuboffset\fP \f(CWsubcoffset\fP"
.IX Subsection "subbeg sublen saved_copy suboffset subcoffset"
Used during the execution phase for managing search and replace patterns,
and for providing the text for \f(CW$&\fR, \f(CW$1\fR etc. \f(CW\*(C`subbeg\*(C'\fR points to a
buffer (either the original string, or a copy in the case of
\&\f(CW\*(C`RX_MATCH_COPIED(rx)\*(C'\fR), and \f(CW\*(C`sublen\*(C'\fR is the length of the buffer.  The
\&\f(CW\*(C`RX_OFFS\*(C'\fR start and end indices index into this buffer.
.PP
In the presence of the \f(CW\*(C`REXEC_COPY_STR\*(C'\fR flag, but with the addition of
the \f(CW\*(C`REXEC_COPY_SKIP_PRE\*(C'\fR or \f(CW\*(C`REXEC_COPY_SKIP_POST\*(C'\fR flags, an engine
can choose not to copy the full buffer (although it must still do so in
the presence of \f(CW\*(C`RXf_PMf_KEEPCOPY\*(C'\fR or the relevant bits being set in
\&\f(CW\*(C`PL_sawampersand\*(C'\fR).  In this case, it may set \f(CW\*(C`suboffset\*(C'\fR to indicate the
number of bytes from the logical start of the buffer to the physical start
(i.e. \f(CW\*(C`subbeg\*(C'\fR).  It should also set \f(CW\*(C`subcoffset\*(C'\fR, the number of
characters in the offset. The latter is needed to support \f(CW\*(C`@\-\*(C'\fR and \f(CW\*(C`@+\*(C'\fR
which work in characters, not bytes.
.ie n .SS """wrapped"" ""wraplen"""
.el .SS "\f(CWwrapped\fP \f(CWwraplen\fP"
.IX Subsection "wrapped wraplen"
Stores the string \f(CW\*(C`qr//\*(C'\fR stringifies to. The Perl engine for example
stores \f(CW\*(C`(?^:eek)\*(C'\fR in the case of \f(CW\*(C`qr/eek/\*(C'\fR.
.PP
When using a custom engine that doesn't support the \f(CW\*(C`(?:)\*(C'\fR construct
for inline modifiers, it's probably best to have \f(CW\*(C`qr//\*(C'\fR stringify to
the supplied pattern, note that this will create undesired patterns in
cases such as:
.PP
.Vb 3
\&    my $x = qr/a|b/;  # "a|b"
\&    my $y = qr/c/i;   # "c"
\&    my $z = qr/$x$y/; # "a|bc"
.Ve
.PP
There's no solution for this problem other than making the custom
engine understand a construct like \f(CW\*(C`(?:)\*(C'\fR.
.ie n .SS """seen_evals"""
.el .SS "\f(CWseen_evals\fP"
.IX Subsection "seen_evals"
This stores the number of eval groups in
the pattern.  This is used for security
purposes when embedding compiled regexes into larger patterns with \f(CW\*(C`qr//\*(C'\fR.
.ie n .SS """refcnt"""
.el .SS "\f(CWrefcnt\fP"
.IX Subsection "refcnt"
The number of times the structure is referenced.  When
this falls to 0, the regexp is automatically freed
by a call to pregfree.  This should be set to 1 in
each engine's \*(L"comp\*(R" routine.
.SH "HISTORY"
.IX Header "HISTORY"
Originally part of perlreguts.
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally written by Yves Orton, expanded by \*(Aevar Arnfjo\*:r\*(d-
Bjarmason.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2006 Yves Orton and 2007 \*(Aevar Arnfjo\*:r\*(d- Bjarmason.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrebackslash.1                            0100644 0001750 0001750 00000104744 12566207444 024121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREBACKSLASH 1"
.TH PERLREBACKSLASH 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrebackslash \- Perl Regular Expression Backslash Sequences and Escapes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This document describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the sequences that have
a special meaning in Perl regular expressions (in alphabetical order),
then describes each of them.
.PP
Most sequences are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide describing all
backslash and escape sequences.
.SS "The backslash"
.IX Subsection "The backslash"
In a regular expression, the backslash can perform one of two tasks:
it either takes away the special meaning of the character following it
(for instance, \f(CW\*(C`\e|\*(C'\fR matches a vertical bar, it's not an alternation),
or it is the start of a backslash or escape sequence.
.PP
The rules determining what it is are quite simple: if the character
following the backslash is an \s-1ASCII\s0 punctuation (non-word) character (that is,
anything that is not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following it.
.PP
If the character following the backslash is an \s-1ASCII\s0 letter or an \s-1ASCII\s0 digit,
then the sequence may be special; if so, it's listed below. A few letters have
not been used yet, so escaping them with a backslash doesn't change them to be
special.  A future version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you use such a
sequence.  [1].
.PP
It is however guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and not in a future
version of Perl 5. So it is safe to put a backslash in front of a non-word
character.
.PP
Note that the backslash itself is special; if you want to match a backslash,
you have to escape the backslash with a backslash: \f(CW\*(C`/\e\e/\*(C'\fR matches a single
backslash.
.IP "[1]" 4
.IX Item "[1]"
There is one exception. If you use an alphanumeric character as the
delimiter of your pattern (which you probably shouldn't do for readability
reasons), you have to escape the delimiter if you want to match
it. Perl won't warn then. See also \*(L"Gory details of parsing
quoted constructs\*(R" in perlop.
.SS "All the sequences and escapes"
.IX Subsection "All the sequences and escapes"
Those not usable within a bracketed character class (like \f(CW\*(C`[\eda\-z]\*(C'\fR) are marked
as \f(CW\*(C`Not in [].\*(C'\fR
.PP
.Vb 10
\& \e000              Octal escape sequence.  See also \eo{}.
\& \e1                Absolute backreference.  Not in [].
\& \ea                Alarm or bell.
\& \eA                Beginning of string.  Not in [].
\& \eb                Word/non\-word boundary. (Backspace in []).
\& \eB                Not a word/non\-word boundary.  Not in [].
\& \ecX               Control\-X.
\& \eC                Single octet, even under UTF\-8.  Not in [].
\& \ed                Character class for digits.
\& \eD                Character class for non\-digits.
\& \ee                Escape character.
\& \eE                Turn off \eQ, \eL and \eU processing.  Not in [].
\& \ef                Form feed.
\& \eF                Foldcase till \eE.  Not in [].
\& \eg{}, \eg1         Named, absolute or relative backreference.
\&                   Not in [].
\& \eG                Pos assertion.  Not in [].
\& \eh                Character class for horizontal whitespace.
\& \eH                Character class for non horizontal whitespace.
\& \ek{}, \ek<>, \ek\*(Aq\*(Aq  Named backreference.  Not in [].
\& \eK                Keep the stuff left of \eK.  Not in [].
\& \el                Lowercase next character.  Not in [].
\& \eL                Lowercase till \eE.  Not in [].
\& \en                (Logical) newline character.
\& \eN                Any character but newline.  Not in [].
\& \eN{}              Named or numbered (Unicode) character or sequence.
\& \eo{}              Octal escape sequence.
\& \ep{}, \epP         Character with the given Unicode property.
\& \eP{}, \ePP         Character without the given Unicode property.
\& \eQ                Quote (disable) pattern metacharacters till \eE.  Not
\&                   in [].
\& \er                Return character.
\& \eR                Generic new line.  Not in [].
\& \es                Character class for whitespace.
\& \eS                Character class for non whitespace.
\& \et                Tab character.
\& \eu                Titlecase next character.  Not in [].
\& \eU                Uppercase till \eE.  Not in [].
\& \ev                Character class for vertical whitespace.
\& \eV                Character class for non vertical whitespace.
\& \ew                Character class for word characters.
\& \eW                Character class for non\-word characters.
\& \ex{}, \ex00        Hexadecimal escape sequence.
\& \eX                Unicode "extended grapheme cluster".  Not in [].
\& \ez                End of string.  Not in [].
\& \eZ                End of string.  Not in [].
.Ve
.SS "Character Escapes"
.IX Subsection "Character Escapes"
\fIFixed characters\fR
.IX Subsection "Fixed characters"
.PP
A handful of characters have a dedicated \fIcharacter escape\fR. The following
table shows them, along with their \s-1ASCII\s0 code points (in decimal and hex),
their \s-1ASCII\s0 name, the control escape on \s-1ASCII\s0 platforms and a short
description.  (For \s-1EBCDIC\s0 platforms, see \*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 in perlebcdic.)
.PP
.Vb 9
\& Seq.  Code Point  ASCII   Cntrl   Description.
\&       Dec    Hex
\&  \ea     7     07    BEL    \ecG    alarm or bell
\&  \eb     8     08     BS    \ecH    backspace [1]
\&  \ee    27     1B    ESC    \ec[    escape character
\&  \ef    12     0C     FF    \ecL    form feed
\&  \en    10     0A     LF    \ecJ    line feed [2]
\&  \er    13     0D     CR    \ecM    carriage return
\&  \et     9     09    TAB    \ecI    tab
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\eb\*(C'\fR is the backspace character only inside a character class. Outside a
character class, \f(CW\*(C`\eb\*(C'\fR is a word/non\-word boundary.
.IP "[2]" 4
.IX Item "[2]"
\&\f(CW\*(C`\en\*(C'\fR matches a logical newline. Perl converts between \f(CW\*(C`\en\*(C'\fR and your
\&\s-1OS\s0's native newline character when reading from or writing to text files.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\et/;   # Matches if $str contains a (horizontal) tab.
.Ve
.PP
\fIControl characters\fR
.IX Subsection "Control characters"
.PP
\&\f(CW\*(C`\ec\*(C'\fR is used to denote a control character; the character following \f(CW\*(C`\ec\*(C'\fR
determines the value of the construct.  For example the value of \f(CW\*(C`\ecA\*(C'\fR is
\&\f(CWchr(1)\fR, and the value of \f(CW\*(C`\ecb\*(C'\fR is \f(CWchr(2)\fR, etc.
The gory details are in \*(L"Regexp Quote-Like Operators\*(R" in perlop.  A complete
list of what \f(CWchr(1)\fR, etc. means for \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms is in
\&\*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 in perlebcdic.
.PP
Note that \f(CW\*(C`\ec\e\*(C'\fR alone at the end of a regular expression (or doubled-quoted
string) is not valid.  The backslash must be followed by another character.
That is, \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR means \f(CW\*(C`chr(28) . \*(Aq\f(CIX\f(CW\*(Aq\*(C'\fR for all characters \fIX\fR.
.PP
To write platform-independent code, you must use \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR instead, like
\&\f(CW\*(C`\eN{ESCAPE}\*(C'\fR or \f(CW\*(C`\eN{U+001B}\*(C'\fR, see charnames.
.PP
Mnemonic: \fIc\fRontrol character.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\ecK/;  # Matches if $str contains a vertical tab (control\-K).
.Ve
.PP
\fINamed or numbered characters and character sequences\fR
.IX Subsection "Named or numbered characters and character sequences"
.PP
Unicode characters have a Unicode name and numeric code point (ordinal)
value.  Use the
\&\f(CW\*(C`\eN{}\*(C'\fR construct to specify a character by either of these values.
Certain sequences of characters also have names.
.PP
To specify by name, the name of the character or character sequence goes
between the curly braces.
.PP
To specify a character by Unicode code point, use the form \f(CW\*(C`\eN{U+\f(CIcode
point\f(CW}\*(C'\fR, where \fIcode point\fR is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired character.  It is
customary but not required to use leading zeros to pad the number to 4
digits.  Thus \f(CW\*(C`\eN{U+0041}\*(C'\fR means \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR, and you will
rarely see it written without the two leading zeros.  \f(CW\*(C`\eN{U+0041}\*(C'\fR means
\&\*(L"A\*(R" even on \s-1EBCDIC\s0 machines (where the ordinal value of \*(L"A\*(R" is not 0x41).
.PP
It is even possible to give your own names to characters and character
sequences.  For details, see charnames.
.PP
(There is an expanded internal form that you may see in debug output:
\&\f(CW\*(C`\eN{U+\f(CIcode point\f(CW.\f(CIcode point\f(CW...}\*(C'\fR.
The \f(CW\*(C`...\*(C'\fR means any number of these \fIcode point\fRs separated by dots.
This represents the sequence formed by the characters.  This is an internal
form only, subject to change, and you should not try to use it yourself.)
.PP
Mnemonic: \fIN\fRamed character.
.PP
Note that a character or character sequence expressed as a named
or numbered character is considered a character without special
meaning by the regex engine, and will match \*(L"as is\*(R".
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\eN{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character
\&
\& use charnames \*(AqCyrillic\*(Aq;            # Loads Cyrillic names.
\& $str =~ /\eN{ZHE}\eN{KA}/;             # Match "ZHE" followed by "KA".
.Ve
.PP
\fIOctal escapes\fR
.IX Subsection "Octal escapes"
.PP
There are two forms of octal escapes.  Each is used to specify a character by
its code point specified in octal notation.
.PP
One form, available starting in Perl 5.14 looks like \f(CW\*(C`\eo{...}\*(C'\fR, where the dots
represent one or more octal digits.  It can be used for any Unicode character.
.PP
It was introduced to avoid the potential problems with the other form,
available in all Perls.  That form consists of a backslash followed by three
octal digits.  One problem with this form is that it can look exactly like an
old-style backreference (see
\&\*(L"Disambiguation rules between old-style octal escapes and backreferences\*(R"
below.)  You can avoid this by making the first of the three digits always a
zero, but that makes \e077 the largest code point specifiable.
.PP
In some contexts, a backslash followed by two or even one octal digits may be
interpreted as an octal escape, sometimes with a warning, and because of some
bugs, sometimes with surprising results.  Also, if you are creating a regex
out of smaller snippets concatenated together, and you use fewer than three
digits, the beginning of one snippet may be interpreted as adding digits to the
ending of the snippet before it.  See \*(L"Absolute referencing\*(R" for more
discussion and examples of the snippet problem.
.PP
Note that a character expressed as an octal escape is considered
a character without special meaning by the regex engine, and will match
\&\*(L"as is\*(R".
.PP
To summarize, the \f(CW\*(C`\eo{}\*(C'\fR form is always safe to use, and the other form is
safe to use for code points through \e077 when you use exactly three digits to
specify them.
.PP
Mnemonic: \fI0\fRctal or \fIo\fRctal.
.PP
Examples (assuming an \s-1ASCII\s0 platform)
.IX Subsection "Examples (assuming an ASCII platform)"
.PP
.Vb 9
\& $str = "Perl";
\& $str =~ /\eo{120}/;  # Match, "\e120" is "P".
\& $str =~ /\e120/;     # Same.
\& $str =~ /\eo{120}+/; # Match, "\e120" is "P",
\&                     # it\*(Aqs repeated at least once.
\& $str =~ /\e120+/;    # Same.
\& $str =~ /P\e053/;    # No match, "\e053" is "+" and taken literally.
\& /\eo{23073}/         # Black foreground, white background smiling face.
\& /\eo{4801234567}/    # Raises a warning, and yields chr(4).
.Ve
.PP
Disambiguation rules between old-style octal escapes and backreferences
.IX Subsection "Disambiguation rules between old-style octal escapes and backreferences"
.PP
Octal escapes of the \f(CW\*(C`\e000\*(C'\fR form outside of bracketed character classes
potentially clash with old-style backreferences (see \*(L"Absolute referencing\*(R"
below).  They both consist of a backslash followed by numbers.  So Perl has to
use heuristics to determine whether it is a backreference or an octal escape.
Perl uses the following rules to disambiguate:
.IP "1." 4
If the backslash is followed by a single digit, it's a backreference.
.IP "2." 4
If the first digit following the backslash is a 0, it's an octal escape.
.IP "3." 4
If the number following the backslash is N (in decimal), and Perl already
has seen N capture groups, Perl considers this a backreference.  Otherwise,
it considers it an octal escape. If N has more than three digits, Perl
takes only the first three for the octal escape; the rest are matched as is.
.Sp
.Vb 6
\& my $pat  = "(" x 999;
\&    $pat .= "a";
\&    $pat .= ")" x 999;
\& /^($pat)\e1000$/;   #  Matches \*(Aqaa\*(Aq; there are 1000 capture groups.
\& /^$pat\e1000$/;     #  Matches \*(Aqa@0\*(Aq; there are 999 capture groups
\&                    #  and \e1000 is seen as \e100 (a \*(Aq@\*(Aq) and a \*(Aq0\*(Aq.
.Ve
.PP
You can force a backreference interpretation always by using the \f(CW\*(C`\eg{...}\*(C'\fR
form.  You can the force an octal interpretation always by using the \f(CW\*(C`\eo{...}\*(C'\fR
form, or for numbers up through \e077 (= 63 decimal), by using three digits,
beginning with a \*(L"0\*(R".
.PP
\fIHexadecimal escapes\fR
.IX Subsection "Hexadecimal escapes"
.PP
Like octal escapes, there are two forms of hexadecimal escapes, but both start
with the same thing, \f(CW\*(C`\ex\*(C'\fR.  This is followed by either exactly two hexadecimal
digits forming a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. The hexadecimal number is the code point of the character you
want to express.
.PP
Note that a character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and will match
\&\*(L"as is\*(R".
.PP
Mnemonic: he\fIx\fRadecimal.
.PP
Examples (assuming an \s-1ASCII\s0 platform)
.IX Subsection "Examples (assuming an ASCII platform)"
.PP
.Vb 4
\& $str = "Perl";
\& $str =~ /\ex50/;    # Match, "\ex50" is "P".
\& $str =~ /\ex50+/;   # Match, "\ex50" is "P", it is repeated at least once
\& $str =~ /P\ex2B/;   # No match, "\ex2B" is "+" and taken literally.
\&
\& /\ex{2603}\ex{2602}/ # Snowman with an umbrella.
\&                    # The Unicode character 2603 is a snowman,
\&                    # the Unicode character 2602 is an umbrella.
\& /\ex{263B}/         # Black smiling face.
\& /\ex{263b}/         # Same, the hex digits A \- F are case insensitive.
.Ve
.SS "Modifiers"
.IX Subsection "Modifiers"
A number of backslash sequences have to do with changing the character,
or characters following them. \f(CW\*(C`\el\*(C'\fR will lowercase the character following
it, while \f(CW\*(C`\eu\*(C'\fR will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar to the
functions \f(CW\*(C`lcfirst\*(C'\fR and \f(CW\*(C`ucfirst\*(C'\fR.
.PP
To uppercase or lowercase several characters, one might want to use
\&\f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR, which will lowercase/uppercase all characters following
them, until either the end of the pattern or the next occurrence of
\&\f(CW\*(C`\eE\*(C'\fR, whichever comes first. They provide functionality similar to what
the functions \f(CW\*(C`lc\*(C'\fR and \f(CW\*(C`uc\*(C'\fR provide.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR is used to quote (disable) pattern metacharacters, up to the next
\&\f(CW\*(C`\eE\*(C'\fR or the end of the pattern. \f(CW\*(C`\eQ\*(C'\fR adds a backslash to any character
that could have special meaning to Perl.  In the \s-1ASCII\s0 range, it quotes
every character that isn't a letter, digit, or underscore.  See
\&\*(L"quotemeta\*(R" in perlfunc for details on what gets quoted for non-ASCII
code points.  Using this ensures that any character between \f(CW\*(C`\eQ\*(C'\fR and
\&\f(CW\*(C`\eE\*(C'\fR will be matched literally, not interpreted as a metacharacter by
the regex engine.
.PP
\&\f(CW\*(C`\eF\*(C'\fR can be used to casefold all characters following, up to the next \f(CW\*(C`\eE\*(C'\fR
or the end of the pattern. It provides the functionality similar to
the \f(CW\*(C`fc\*(C'\fR function.
.PP
Mnemonic: \fIL\fRowercase, \fIU\fRppercase, \fIF\fRold-case, \fIQ\fRuotemeta, \fIE\fRnd.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& $sid     = "sid";
\& $greg    = "GrEg";
\& $miranda = "(Miranda)";
\& $str     =~ /\eu$sid/;        # Matches \*(AqSid\*(Aq
\& $str     =~ /\eL$greg/;       # Matches \*(Aqgreg\*(Aq
\& $str     =~ /\eQ$miranda\eE/;  # Matches \*(Aq(Miranda)\*(Aq, as if the pattern
\&                              #   had been written as /\e(Miranda\e)/
.Ve
.SS "Character classes"
.IX Subsection "Character classes"
Perl regular expressions have a large range of character classes. Some of
the character classes are written as a backslash sequence. We will briefly
discuss those here; full details of character classes can be found in
perlrecharclass.
.PP
\&\f(CW\*(C`\ew\*(C'\fR is a character class that matches any single \fIword\fR character
(letters, digits, Unicode marks, and connector punctuation (like the
underscore)).  \f(CW\*(C`\ed\*(C'\fR is a character class that matches any decimal
digit, while the character class \f(CW\*(C`\es\*(C'\fR matches any whitespace character.
New in perl 5.10.0 are the classes \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR which match horizontal
and vertical whitespace characters.
.PP
The exact set of characters matched by \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, and \f(CW\*(C`\ew\*(C'\fR varies
depending on various pragma and regular expression modifiers.  It is
possible to restrict the match to the \s-1ASCII\s0 range by using the \f(CW\*(C`/a\*(C'\fR
regular expression modifier.  See perlrecharclass.
.PP
The uppercase variants (\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\eH\*(C'\fR, and \f(CW\*(C`\eV\*(C'\fR) are
character classes that match, respectively, any character that isn't a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.
.PP
Mnemonics: \fIw\fRord, \fId\fRigit, \fIs\fRpace, \fIh\fRorizontal, \fIv\fRertical.
.PP
\fIUnicode classes\fR
.IX Subsection "Unicode classes"
.PP
\&\f(CW\*(C`\epP\*(C'\fR (where \f(CW\*(C`P\*(C'\fR is a single letter) and \f(CW\*(C`\ep{Property}\*(C'\fR are used to
match a character that matches the given Unicode property; properties
include things like \*(L"letter\*(R", or \*(L"thai character\*(R". Capitalizing the
sequence to \f(CW\*(C`\ePP\*(C'\fR and \f(CW\*(C`\eP{Property}\*(C'\fR make the sequence match a character
that doesn't match the given Unicode property. For more details, see
\&\*(L"Backslash sequences\*(R" in perlrecharclass and
\&\*(L"Unicode Character Properties\*(R" in perlunicode.
.PP
Mnemonic: \fIp\fRroperty.
.SS "Referencing"
.IX Subsection "Referencing"
If capturing parenthesis are used in a regular expression, we can refer
to the part of the source string that was matched, and match exactly the
same thing. There are three ways of referring to such \fIbackreference\fR:
absolutely, relatively, and by name.
.PP
\fIAbsolute referencing\fR
.IX Subsection "Absolute referencing"
.PP
Either \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR (starting in Perl 5.10.0), or \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR (old-style) where \fIN\fR
is a positive (unsigned) decimal number of any length is an absolute reference
to a capturing group.
.PP
\&\fIN\fR refers to the Nth set of parentheses, so \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR refers to whatever has
been matched by that set of parentheses.  Thus \f(CW\*(C`\eg1\*(C'\fR refers to the first
capture group in the regex.
.PP
The \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR form can be equivalently written as \f(CW\*(C`\eg{\f(CIN\f(CW}\*(C'\fR
which avoids ambiguity when building a regex by concatenating shorter
strings.  Otherwise if you had a regex \f(CW\*(C`qr/$a$b/\*(C'\fR, and \f(CW$a\fR contained
\&\f(CW"\eg1"\fR, and \f(CW$b\fR contained \f(CW"37"\fR, you would get \f(CW\*(C`/\eg137/\*(C'\fR which is
probably not what you intended.
.PP
In the \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR form, \fIN\fR must not begin with a \*(L"0\*(R", and there must be at
least \fIN\fR capturing groups, or else \fIN\fR is considered an octal escape
(but something like \f(CW\*(C`\e18\*(C'\fR is the same as \f(CW\*(C`\e0018\*(C'\fR; that is, the octal escape
\&\f(CW"\e001"\fR followed by a literal digit \f(CW"8"\fR).
.PP
Mnemonic: \fIg\fRroup.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 3
\& /(\ew+) \eg1/;    # Finds a duplicated word, (e.g. "cat cat").
\& /(\ew+) \e1/;     # Same thing; written old\-style.
\& /(.)(.)\eg2\eg1/;  # Match a four letter palindrome (e.g. "ABBA").
.Ve
.PP
\fIRelative referencing\fR
.IX Subsection "Relative referencing"
.PP
\&\f(CW\*(C`\eg\-\f(CIN\f(CW\*(C'\fR (starting in Perl 5.10.0) is used for relative addressing.  (It can
be written as \f(CW\*(C`\eg{\-\f(CIN\f(CW\*(C'\fR.)  It refers to the \fIN\fRth group before the
\&\f(CW\*(C`\eg{\-\f(CIN\f(CW}\*(C'\fR.
.PP
The big advantage of this form is that it makes it much easier to write
patterns with references that can be interpolated in larger patterns,
even if the larger pattern also contains capture groups.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& /(A)        # Group 1
\&  (          # Group 2
\&    (B)      # Group 3
\&    \eg{\-1}   # Refers to group 3 (B)
\&    \eg{\-3}   # Refers to group 1 (A)
\&  )
\& /x;         # Matches "ABBA".
\&
\& my $qr = qr /(.)(.)\eg{\-2}\eg{\-1}/;  # Matches \*(Aqabab\*(Aq, \*(Aqcdcd\*(Aq, etc.
\& /$qr$qr/                           # Matches \*(Aqababcdcd\*(Aq.
.Ve
.PP
\fINamed referencing\fR
.IX Subsection "Named referencing"
.PP
\&\f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR (starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to think about capture
buffer positions.
.PP
To be compatible with .Net regular expressions, \f(CW\*(C`\eg{name}\*(C'\fR may also be
written as \f(CW\*(C`\ek{name}\*(C'\fR, \f(CW\*(C`\ek<name>\*(C'\fR or \f(CW\*(C`\ek\*(Aqname\*(Aq\*(C'\fR.
.PP
To prevent any ambiguity, \fIname\fR must not start with a digit nor contain a
hyphen.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 5
\& /(?<word>\ew+) \eg{word}/ # Finds duplicated word, (e.g. "cat cat")
\& /(?<word>\ew+) \ek{word}/ # Same.
\& /(?<word>\ew+) \ek<word>/ # Same.
\& /(?<letter1>.)(?<letter2>.)\eg{letter2}\eg{letter1}/
\&                         # Match a four letter palindrome (e.g. "ABBA")
.Ve
.SS "Assertions"
.IX Subsection "Assertions"
Assertions are conditions that have to be true; they don't actually
match parts of the substring. There are six assertions that are written as
backslash sequences.
.IP "\eA" 4
.IX Item "A"
\&\f(CW\*(C`\eA\*(C'\fR only matches at the beginning of the string. If the \f(CW\*(C`/m\*(C'\fR modifier
isn't used, then \f(CW\*(C`/\eA/\*(C'\fR is equivalent to \f(CW\*(C`/^/\*(C'\fR. However, if the \f(CW\*(C`/m\*(C'\fR
modifier is used, then \f(CW\*(C`/^/\*(C'\fR matches internal newlines, but the meaning
of \f(CW\*(C`/\eA/\*(C'\fR isn't changed by the \f(CW\*(C`/m\*(C'\fR modifier. \f(CW\*(C`\eA\*(C'\fR matches at the beginning
of the string regardless whether the \f(CW\*(C`/m\*(C'\fR modifier is used.
.IP "\ez, \eZ" 4
.IX Item "z, Z"
\&\f(CW\*(C`\ez\*(C'\fR and \f(CW\*(C`\eZ\*(C'\fR match at the end of the string. If the \f(CW\*(C`/m\*(C'\fR modifier isn't
used, then \f(CW\*(C`/\eZ/\*(C'\fR is equivalent to \f(CW\*(C`/$/\*(C'\fR; that is, it matches at the
end of the string, or one before the newline at the end of the string. If the
\&\f(CW\*(C`/m\*(C'\fR modifier is used, then \f(CW\*(C`/$/\*(C'\fR matches at internal newlines, but the
meaning of \f(CW\*(C`/\eZ/\*(C'\fR isn't changed by the \f(CW\*(C`/m\*(C'\fR modifier. \f(CW\*(C`\eZ\*(C'\fR matches at
the end of the string (or just before a trailing newline) regardless whether
the \f(CW\*(C`/m\*(C'\fR modifier is used.
.Sp
\&\f(CW\*(C`\ez\*(C'\fR is just like \f(CW\*(C`\eZ\*(C'\fR, except that it does not match before a trailing
newline. \f(CW\*(C`\ez\*(C'\fR matches at the end of the string only, regardless of the
modifiers used, and not just before a newline.  It is how to anchor the
match to the true end of the string under all conditions.
.IP "\eG" 4
.IX Item "G"
\&\f(CW\*(C`\eG\*(C'\fR is usually used only in combination with the \f(CW\*(C`/g\*(C'\fR modifier. If the
\&\f(CW\*(C`/g\*(C'\fR modifier is used and the match is done in scalar context, Perl 
remembers where in the source string the last match ended, and the next time,
it will start the match from where it ended the previous time.
.Sp
\&\f(CW\*(C`\eG\*(C'\fR matches the point where the previous match on that string ended, 
or the beginning of that string if there was no previous match.
.Sp
Mnemonic: \fIG\fRlobal.
.IP "\eb, \eB" 4
.IX Item "b, B"
\&\f(CW\*(C`\eb\*(C'\fR matches at any place between a word and a non-word character; \f(CW\*(C`\eB\*(C'\fR
matches at any place between characters where \f(CW\*(C`\eb\*(C'\fR doesn't match. \f(CW\*(C`\eb\*(C'\fR
and \f(CW\*(C`\eB\*(C'\fR assume there's a non-word character before the beginning and after
the end of the source string; so \f(CW\*(C`\eb\*(C'\fR will match at the beginning (or end)
of the source string if the source string begins (or ends) with a word
character. Otherwise, \f(CW\*(C`\eB\*(C'\fR will match.
.Sp
Do not use something like \f(CW\*(C`\eb=head\ed\eb\*(C'\fR and expect it to match the
beginning of a line.  It can't, because for there to be a boundary before
the non-word \*(L"=\*(R", there must be a word character immediately previous.  
All boundary determinations look for word characters alone, not for
non-words characters nor for string ends.  It may help to understand how
<\eb> and <\eB> work by equating them as follows:
.Sp
.Vb 2
\&    \eb  really means    (?:(?<=\ew)(?!\ew)|(?<!\ew)(?=\ew))
\&    \eB  really means    (?:(?<=\ew)(?=\ew)|(?<!\ew)(?!\ew))
.Ve
.Sp
Mnemonic: \fIb\fRoundary.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 4
\&  "cat"   =~ /\eAcat/;     # Match.
\&  "cat"   =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\ez/;     # No match.
\&
\&  "cat"   =~ /\ebcat\eb/;   # Matches.
\&  "cats"  =~ /\ebcat\eb/;   # No match.
\&  "cat"   =~ /\ebcat\eB/;   # No match.
\&  "cats"  =~ /\ebcat\eB/;   # Match.
\&
\&  while ("cat dog" =~ /(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcatdog\*(Aq
\&  }
\&  while ("cat dog" =~ /\eG(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcat\*(Aq
\&  }
.Ve
.SS "Misc"
.IX Subsection "Misc"
Here we document the backslash sequences that don't fall in one of the
categories above. These are:
.IP "\eC" 4
.IX Item "C"
\&\f(CW\*(C`\eC\*(C'\fR always matches a single octet, even if the source string is encoded
in \s-1UTF\-8\s0 format, and the character to be matched is a multi-octet character.
This is very dangerous, because it violates
the logical character abstraction and can cause \s-1UTF\-8\s0 sequences to become malformed.
.Sp
Mnemonic: o\fIC\fRtet.
.IP "\eK" 4
.IX Item "K"
This appeared in perl 5.10.0. Anything matched left of \f(CW\*(C`\eK\*(C'\fR is
not included in \f(CW$&\fR, and will not be replaced if the pattern is
used in a substitution. This lets you write \f(CW\*(C`s/PAT1 \eK PAT2/REPL/x\*(C'\fR
instead of \f(CW\*(C`s/(PAT1) PAT2/${1}REPL/x\*(C'\fR or \f(CW\*(C`s/(?<=PAT1) PAT2/REPL/x\*(C'\fR.
.Sp
Mnemonic: \fIK\fReep.
.IP "\eN" 4
.IX Item "N"
This feature, available starting in v5.12,  matches any character
that is \fBnot\fR a newline.  It is a short-hand for writing \f(CW\*(C`[^\en]\*(C'\fR, and is
identical to the \f(CW\*(C`.\*(C'\fR metasymbol, except under the \f(CW\*(C`/s\*(C'\fR flag, which changes
the meaning of \f(CW\*(C`.\*(C'\fR, but not \f(CW\*(C`\eN\*(C'\fR.
.Sp
Note that \f(CW\*(C`\eN{...}\*(C'\fR can mean a
named or numbered character
\&.
.Sp
Mnemonic: Complement of \fI\en\fR.
.IP "\eR" 4
.IX Xref "\\R"
.IX Item "R"
\&\f(CW\*(C`\eR\*(C'\fR matches a \fIgeneric newline\fR; that is, anything considered a
linebreak sequence by Unicode. This includes all characters matched by
\&\f(CW\*(C`\ev\*(C'\fR (vertical whitespace), and the multi character sequence \f(CW"\ex0D\ex0A"\fR
(carriage return followed by a line feed, sometimes called the network
newline; it's the end of line sequence used in Microsoft text files opened
in binary mode). \f(CW\*(C`\eR\*(C'\fR is equivalent to \f(CW\*(C`(?>\ex0D\ex0A|\ev)\*(C'\fR.  (The
reason it doesn't backtrack is that the sequence is considered
inseparable.  That means that
.Sp
.Vb 1
\& "\ex0D\ex0A" =~ /^\eR\ex0A$/   # No match
.Ve
.Sp
fails, because the \f(CW\*(C`\eR\*(C'\fR matches the entire string, and won't backtrack
to match just the \f(CW"\ex0D"\fR.)  Since
\&\f(CW\*(C`\eR\*(C'\fR can match a sequence of more than one character, it cannot be put
inside a bracketed character class; \f(CW\*(C`/[\eR]/\*(C'\fR is an error; use \f(CW\*(C`\ev\*(C'\fR
instead.  \f(CW\*(C`\eR\*(C'\fR was introduced in perl 5.10.0.
.Sp
Note that this does not respect any locale that might be in effect; it
matches according to the platform's native character set.
.Sp
Mnemonic: none really. \f(CW\*(C`\eR\*(C'\fR was picked because \s-1PCRE\s0 already uses \f(CW\*(C`\eR\*(C'\fR,
and more importantly because Unicode recommends such a regular expression
metacharacter, and suggests \f(CW\*(C`\eR\*(C'\fR as its notation.
.IP "\eX" 4
.IX Xref "\\X"
.IX Item "X"
This matches a Unicode \fIextended grapheme cluster\fR.
.Sp
\&\f(CW\*(C`\eX\*(C'\fR matches quite well what normal (non-Unicode-programmer) usage
would consider a single character.  As an example, consider a G with some sort
of diacritic mark, such as an arrow.  There is no such single character in
Unicode, but one can be composed by using a G followed by a Unicode \*(L"\s-1COMBINING
UPWARDS ARROW BELOW\*(R",\s0 and would be displayed by Unicode-aware software as if it
were a single character.
.Sp
Mnemonic: e\fIX\fRtended Unicode character.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 2
\& "\ex{256}" =~ /^\eC\eC$/;    # Match as chr (0x256) takes 
\&                           # 2 octets in UTF\-8.
\&
\& $str =~ s/foo\eKbar/baz/g; # Change any \*(Aqbar\*(Aq following a \*(Aqfoo\*(Aq to \*(Aqbaz\*(Aq
\& $str =~ s/(.)\eK\eg1//g;    # Delete duplicated characters.
\&
\& "\en"   =~ /^\eR$/;         # Match, \en   is a generic newline.
\& "\er"   =~ /^\eR$/;         # Match, \er   is a generic newline.
\& "\er\en" =~ /^\eR$/;         # Match, \er\en is a generic newline.
\&
\& "P\ex{307}" =~ /^\eX$/     # \eX matches a P with a dot above.
.Ve
                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrebackslash5.16.1                        0100644 0001750 0001750 00000104471 12566207423 024425  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREBACKSLASH 1"
.TH PERLREBACKSLASH 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrebackslash \- Perl Regular Expression Backslash Sequences and Escapes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This document describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the sequences that have
a special meaning in Perl regular expressions (in alphabetical order),
then describes each of them.
.PP
Most sequences are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide describing all
backslash and escape sequences.
.SS "The backslash"
.IX Subsection "The backslash"
In a regular expression, the backslash can perform one of two tasks:
it either takes away the special meaning of the character following it
(for instance, \f(CW\*(C`\e|\*(C'\fR matches a vertical bar, it's not an alternation),
or it is the start of a backslash or escape sequence.
.PP
The rules determining what it is are quite simple: if the character
following the backslash is an \s-1ASCII\s0 punctuation (non-word) character (that is,
anything that is not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following it.
.PP
If the character following the backslash is an \s-1ASCII\s0 letter or an \s-1ASCII\s0 digit,
then the sequence may be special; if so, it's listed below. A few letters have
not been used yet, so escaping them with a backslash doesn't change them to be
special.  A future version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you use such a
sequence.  [1].
.PP
It is however guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and not in a future
version of Perl 5. So it is safe to put a backslash in front of a non-word
character.
.PP
Note that the backslash itself is special; if you want to match a backslash,
you have to escape the backslash with a backslash: \f(CW\*(C`/\e\e/\*(C'\fR matches a single
backslash.
.IP "[1]" 4
.IX Item "[1]"
There is one exception. If you use an alphanumeric character as the
delimiter of your pattern (which you probably shouldn't do for readability
reasons), you have to escape the delimiter if you want to match
it. Perl won't warn then. See also \*(L"Gory details of parsing
quoted constructs\*(R" in perlop.
.SS "All the sequences and escapes"
.IX Subsection "All the sequences and escapes"
Those not usable within a bracketed character class (like \f(CW\*(C`[\eda\-z]\*(C'\fR) are marked
as \f(CW\*(C`Not in [].\*(C'\fR
.PP
.Vb 10
\& \e000              Octal escape sequence.  See also \eo{}.
\& \e1                Absolute backreference.  Not in [].
\& \ea                Alarm or bell.
\& \eA                Beginning of string.  Not in [].
\& \eb                Word/non\-word boundary. (Backspace in []).
\& \eB                Not a word/non\-word boundary.  Not in [].
\& \ecX               Control\-X
\& \eC                Single octet, even under UTF\-8.  Not in [].
\& \ed                Character class for digits.
\& \eD                Character class for non\-digits.
\& \ee                Escape character.
\& \eE                Turn off \eQ, \eL and \eU processing.  Not in [].
\& \ef                Form feed.
\& \eF                Foldcase till \eE.  Not in [].
\& \eg{}, \eg1         Named, absolute or relative backreference.  Not in []
\& \eG                Pos assertion.  Not in [].
\& \eh                Character class for horizontal whitespace.
\& \eH                Character class for non horizontal whitespace.
\& \ek{}, \ek<>, \ek\*(Aq\*(Aq  Named backreference.  Not in [].
\& \eK                Keep the stuff left of \eK.  Not in [].
\& \el                Lowercase next character.  Not in [].
\& \eL                Lowercase till \eE.  Not in [].
\& \en                (Logical) newline character.
\& \eN                Any character but newline.  Experimental.  Not in [].
\& \eN{}              Named or numbered (Unicode) character or sequence.
\& \eo{}              Octal escape sequence.
\& \ep{}, \epP         Character with the given Unicode property.
\& \eP{}, \ePP         Character without the given Unicode property.
\& \eQ                Quote (disable) pattern metacharacters till \eE.  Not
\&                   in [].
\& \er                Return character.
\& \eR                Generic new line.  Not in [].
\& \es                Character class for whitespace.
\& \eS                Character class for non whitespace.
\& \et                Tab character.
\& \eu                Titlecase next character.  Not in [].
\& \eU                Uppercase till \eE.  Not in [].
\& \ev                Character class for vertical whitespace.
\& \eV                Character class for non vertical whitespace.
\& \ew                Character class for word characters.
\& \eW                Character class for non\-word characters.
\& \ex{}, \ex00        Hexadecimal escape sequence.
\& \eX                Unicode "extended grapheme cluster".  Not in [].
\& \ez                End of string.  Not in [].
\& \eZ                End of string.  Not in [].
.Ve
.SS "Character Escapes"
.IX Subsection "Character Escapes"
\fIFixed characters\fR
.IX Subsection "Fixed characters"
.PP
A handful of characters have a dedicated \fIcharacter escape\fR. The following
table shows them, along with their \s-1ASCII\s0 code points (in decimal and hex),
their \s-1ASCII\s0 name, the control escape on \s-1ASCII\s0 platforms and a short
description.  (For \s-1EBCDIC\s0 platforms, see \*(L"\s-1OPERATOR\s0 \s-1DIFFERENCES\s0\*(R" in perlebcdic.)
.PP
.Vb 9
\& Seq.  Code Point  ASCII   Cntrl   Description.
\&       Dec    Hex
\&  \ea     7     07    BEL    \ecG    alarm or bell
\&  \eb     8     08     BS    \ecH    backspace [1]
\&  \ee    27     1B    ESC    \ec[    escape character
\&  \ef    12     0C     FF    \ecL    form feed
\&  \en    10     0A     LF    \ecJ    line feed [2]
\&  \er    13     0D     CR    \ecM    carriage return
\&  \et     9     09    TAB    \ecI    tab
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\eb\*(C'\fR is the backspace character only inside a character class. Outside a
character class, \f(CW\*(C`\eb\*(C'\fR is a word/non\-word boundary.
.IP "[2]" 4
.IX Item "[2]"
\&\f(CW\*(C`\en\*(C'\fR matches a logical newline. Perl converts between \f(CW\*(C`\en\*(C'\fR and your
\&\s-1OS\s0's native newline character when reading from or writing to text files.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\et/;   # Matches if $str contains a (horizontal) tab.
.Ve
.PP
\fIControl characters\fR
.IX Subsection "Control characters"
.PP
\&\f(CW\*(C`\ec\*(C'\fR is used to denote a control character; the character following \f(CW\*(C`\ec\*(C'\fR
determines the value of the construct.  For example the value of \f(CW\*(C`\ecA\*(C'\fR is
\&\f(CWchr(1)\fR, and the value of \f(CW\*(C`\ecb\*(C'\fR is \f(CWchr(2)\fR, etc.
The gory details are in \*(L"Regexp Quote-Like Operators\*(R" in perlop.  A complete
list of what \f(CWchr(1)\fR, etc. means for \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms is in
\&\*(L"\s-1OPERATOR\s0 \s-1DIFFERENCES\s0\*(R" in perlebcdic.
.PP
Note that \f(CW\*(C`\ec\e\*(C'\fR alone at the end of a regular expression (or doubled-quoted
string) is not valid.  The backslash must be followed by another character.
That is, \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR means \f(CW\*(C`chr(28) . \*(Aq\f(CIX\f(CW\*(Aq\*(C'\fR for all characters \fIX\fR.
.PP
To write platform-independent code, you must use \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR instead, like
\&\f(CW\*(C`\eN{ESCAPE}\*(C'\fR or \f(CW\*(C`\eN{U+001B}\*(C'\fR, see charnames.
.PP
Mnemonic: \fIc\fRontrol character.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\ecK/;  # Matches if $str contains a vertical tab (control\-K).
.Ve
.PP
\fINamed or numbered characters and character sequences\fR
.IX Subsection "Named or numbered characters and character sequences"
.PP
Unicode characters have a Unicode name and numeric code point (ordinal)
value.  Use the
\&\f(CW\*(C`\eN{}\*(C'\fR construct to specify a character by either of these values.
Certain sequences of characters also have names.
.PP
To specify by name, the name of the character or character sequence goes
between the curly braces.
.PP
To specify a character by Unicode code point, use the form \f(CW\*(C`\eN{U+\f(CIcode
point\f(CW}\*(C'\fR, where \fIcode point\fR is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired character.  It is
customary but not required to use leading zeros to pad the number to 4
digits.  Thus \f(CW\*(C`\eN{U+0041}\*(C'\fR means \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR, and you will
rarely see it written without the two leading zeros.  \f(CW\*(C`\eN{U+0041}\*(C'\fR means
\&\*(L"A\*(R" even on \s-1EBCDIC\s0 machines (where the ordinal value of \*(L"A\*(R" is not 0x41).
.PP
It is even possible to give your own names to characters and character
sequences.  For details, see charnames.
.PP
(There is an expanded internal form that you may see in debug output:
\&\f(CW\*(C`\eN{U+\f(CIcode point\f(CW.\f(CIcode point\f(CW...}\*(C'\fR.
The \f(CW\*(C`...\*(C'\fR means any number of these \fIcode point\fRs separated by dots.
This represents the sequence formed by the characters.  This is an internal
form only, subject to change, and you should not try to use it yourself.)
.PP
Mnemonic: \fIN\fRamed character.
.PP
Note that a character or character sequence expressed as a named
or numbered character is considered a character without special
meaning by the regex engine, and will match \*(L"as is\*(R".
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\eN{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character
\&
\& use charnames \*(AqCyrillic\*(Aq;            # Loads Cyrillic names.
\& $str =~ /\eN{ZHE}\eN{KA}/;             # Match "ZHE" followed by "KA".
.Ve
.PP
\fIOctal escapes\fR
.IX Subsection "Octal escapes"
.PP
There are two forms of octal escapes.  Each is used to specify a character by
its code point specified in octal notation.
.PP
One form, available starting in Perl 5.14 looks like \f(CW\*(C`\eo{...}\*(C'\fR, where the dots
represent one or more octal digits.  It can be used for any Unicode character.
.PP
It was introduced to avoid the potential problems with the other form,
available in all Perls.  That form consists of a backslash followed by three
octal digits.  One problem with this form is that it can look exactly like an
old-style backreference (see
\&\*(L"Disambiguation rules between old-style octal escapes and backreferences\*(R"
below.)  You can avoid this by making the first of the three digits always a
zero, but that makes \e077 the largest code point specifiable.
.PP
In some contexts, a backslash followed by two or even one octal digits may be
interpreted as an octal escape, sometimes with a warning, and because of some
bugs, sometimes with surprising results.  Also, if you are creating a regex
out of smaller snippets concatenated together, and you use fewer than three
digits, the beginning of one snippet may be interpreted as adding digits to the
ending of the snippet before it.  See \*(L"Absolute referencing\*(R" for more
discussion and examples of the snippet problem.
.PP
Note that a character expressed as an octal escape is considered
a character without special meaning by the regex engine, and will match
\&\*(L"as is\*(R".
.PP
To summarize, the \f(CW\*(C`\eo{}\*(C'\fR form is always safe to use, and the other form is
safe to use for code points through \e077 when you use exactly three digits to
specify them.
.PP
Mnemonic: \fI0\fRctal or \fIo\fRctal.
.PP
Examples (assuming an \s-1ASCII\s0 platform)
.IX Subsection "Examples (assuming an ASCII platform)"
.PP
.Vb 8
\& $str = "Perl";
\& $str =~ /\eo{120}/;  # Match, "\e120" is "P".
\& $str =~ /\e120/;     # Same.
\& $str =~ /\eo{120}+/; # Match, "\e120" is "P", it\*(Aqs repeated at least once
\& $str =~ /\e120+/;    # Same.
\& $str =~ /P\e053/;    # No match, "\e053" is "+" and taken literally.
\& /\eo{23073}/         # Black foreground, white background smiling face.
\& /\eo{4801234567}/    # Raises a warning, and yields chr(4)
.Ve
.PP
Disambiguation rules between old-style octal escapes and backreferences
.IX Subsection "Disambiguation rules between old-style octal escapes and backreferences"
.PP
Octal escapes of the \f(CW\*(C`\e000\*(C'\fR form outside of bracketed character classes
potentially clash with old-style backreferences.  (see \*(L"Absolute referencing\*(R"
below).  They both consist of a backslash followed by numbers.  So Perl has to
use heuristics to determine whether it is a backreference or an octal escape.
Perl uses the following rules to disambiguate:
.IP "1." 4
If the backslash is followed by a single digit, it's a backreference.
.IP "2." 4
If the first digit following the backslash is a 0, it's an octal escape.
.IP "3." 4
If the number following the backslash is N (in decimal), and Perl already
has seen N capture groups, Perl considers this a backreference.  Otherwise,
it considers it an octal escape. If N has more than three digits, Perl
takes only the first three for the octal escape; the rest are matched as is.
.Sp
.Vb 6
\& my $pat  = "(" x 999;
\&    $pat .= "a";
\&    $pat .= ")" x 999;
\& /^($pat)\e1000$/;   #  Matches \*(Aqaa\*(Aq; there are 1000 capture groups.
\& /^$pat\e1000$/;     #  Matches \*(Aqa@0\*(Aq; there are 999 capture groups
\&                    #    and \e1000 is seen as \e100 (a \*(Aq@\*(Aq) and a \*(Aq0\*(Aq
.Ve
.PP
You can force a backreference interpretation always by using the \f(CW\*(C`\eg{...}\*(C'\fR
form.  You can the force an octal interpretation always by using the \f(CW\*(C`\eo{...}\*(C'\fR
form, or for numbers up through \e077 (= 63 decimal), by using three digits,
beginning with a \*(L"0\*(R".
.PP
\fIHexadecimal escapes\fR
.IX Subsection "Hexadecimal escapes"
.PP
Like octal escapes, there are two forms of hexadecimal escapes, but both start
with the same thing, \f(CW\*(C`\ex\*(C'\fR.  This is followed by either exactly two hexadecimal
digits forming a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. The hexadecimal number is the code point of the character you
want to express.
.PP
Note that a character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and will match
\&\*(L"as is\*(R".
.PP
Mnemonic: he\fIx\fRadecimal.
.PP
Examples (assuming an \s-1ASCII\s0 platform)
.IX Subsection "Examples (assuming an ASCII platform)"
.PP
.Vb 4
\& $str = "Perl";
\& $str =~ /\ex50/;    # Match, "\ex50" is "P".
\& $str =~ /\ex50+/;   # Match, "\ex50" is "P", it is repeated at least once
\& $str =~ /P\ex2B/;   # No match, "\ex2B" is "+" and taken literally.
\&
\& /\ex{2603}\ex{2602}/ # Snowman with an umbrella.
\&                    # The Unicode character 2603 is a snowman,
\&                    # the Unicode character 2602 is an umbrella.
\& /\ex{263B}/         # Black smiling face.
\& /\ex{263b}/         # Same, the hex digits A \- F are case insensitive.
.Ve
.SS "Modifiers"
.IX Subsection "Modifiers"
A number of backslash sequences have to do with changing the character,
or characters following them. \f(CW\*(C`\el\*(C'\fR will lowercase the character following
it, while \f(CW\*(C`\eu\*(C'\fR will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar to the
functions \f(CW\*(C`lcfirst\*(C'\fR and \f(CW\*(C`ucfirst\*(C'\fR.
.PP
To uppercase or lowercase several characters, one might want to use
\&\f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR, which will lowercase/uppercase all characters following
them, until either the end of the pattern or the next occurrence of
\&\f(CW\*(C`\eE\*(C'\fR, whichever comes first. They provide functionality similar to what
the functions \f(CW\*(C`lc\*(C'\fR and \f(CW\*(C`uc\*(C'\fR provide.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR is used to quote (disable) pattern metacharacters, up to the next
\&\f(CW\*(C`\eE\*(C'\fR or the end of the pattern. \f(CW\*(C`\eQ\*(C'\fR adds a backslash to any character
that could have special meaning to Perl.  In the \s-1ASCII\s0 range, it quotes
every character that isn't a letter, digit, or underscore.  See
\&\*(L"quotemeta\*(R" in perlfunc for details on what gets quoted for non-ASCII
code points.  Using this ensures that any character between \f(CW\*(C`\eQ\*(C'\fR and
\&\f(CW\*(C`\eE\*(C'\fR will be matched literally, not interpreted as a metacharacter by
the regex engine.
.PP
\&\f(CW\*(C`\eF\*(C'\fR can be used to casefold all characters following, up to the next \f(CW\*(C`\eE\*(C'\fR
or the end of the pattern. It provides the functionality similar to
the \f(CW\*(C`fc\*(C'\fR function.
.PP
Mnemonic: \fIL\fRowercase, \fIU\fRppercase, \fIF\fRold-case, \fIQ\fRuotemeta, \fIE\fRnd.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& $sid     = "sid";
\& $greg    = "GrEg";
\& $miranda = "(Miranda)";
\& $str     =~ /\eu$sid/;        # Matches \*(AqSid\*(Aq
\& $str     =~ /\eL$greg/;       # Matches \*(Aqgreg\*(Aq
\& $str     =~ /\eQ$miranda\eE/;  # Matches \*(Aq(Miranda)\*(Aq, as if the pattern
\&                              #   had been written as /\e(Miranda\e)/
.Ve
.SS "Character classes"
.IX Subsection "Character classes"
Perl regular expressions have a large range of character classes. Some of
the character classes are written as a backslash sequence. We will briefly
discuss those here; full details of character classes can be found in
perlrecharclass.
.PP
\&\f(CW\*(C`\ew\*(C'\fR is a character class that matches any single \fIword\fR character
(letters, digits, Unicode marks, and connector punctuation (like the
underscore)).  \f(CW\*(C`\ed\*(C'\fR is a character class that matches any decimal
digit, while the character class \f(CW\*(C`\es\*(C'\fR matches any whitespace character.
New in perl 5.10.0 are the classes \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR which match horizontal
and vertical whitespace characters.
.PP
The exact set of characters matched by \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, and \f(CW\*(C`\ew\*(C'\fR varies
depending on various pragma and regular expression modifiers.  It is
possible to restrict the match to the \s-1ASCII\s0 range by using the \f(CW\*(C`/a\*(C'\fR
regular expression modifier.  See perlrecharclass.
.PP
The uppercase variants (\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\eH\*(C'\fR, and \f(CW\*(C`\eV\*(C'\fR) are
character classes that match, respectively, any character that isn't a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.
.PP
Mnemonics: \fIw\fRord, \fId\fRigit, \fIs\fRpace, \fIh\fRorizontal, \fIv\fRertical.
.PP
\fIUnicode classes\fR
.IX Subsection "Unicode classes"
.PP
\&\f(CW\*(C`\epP\*(C'\fR (where \f(CW\*(C`P\*(C'\fR is a single letter) and \f(CW\*(C`\ep{Property}\*(C'\fR are used to
match a character that matches the given Unicode property; properties
include things like \*(L"letter\*(R", or \*(L"thai character\*(R". Capitalizing the
sequence to \f(CW\*(C`\ePP\*(C'\fR and \f(CW\*(C`\eP{Property}\*(C'\fR make the sequence match a character
that doesn't match the given Unicode property. For more details, see
\&\*(L"Backslash sequences\*(R" in perlrecharclass and
\&\*(L"Unicode Character Properties\*(R" in perlunicode.
.PP
Mnemonic: \fIp\fRroperty.
.SS "Referencing"
.IX Subsection "Referencing"
If capturing parenthesis are used in a regular expression, we can refer
to the part of the source string that was matched, and match exactly the
same thing. There are three ways of referring to such \fIbackreference\fR:
absolutely, relatively, and by name.
.PP
\fIAbsolute referencing\fR
.IX Subsection "Absolute referencing"
.PP
Either \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR (starting in Perl 5.10.0), or \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR (old-style) where \fIN\fR
is a positive (unsigned) decimal number of any length is an absolute reference
to a capturing group.
.PP
\&\fIN\fR refers to the Nth set of parentheses, so \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR refers to whatever has
been matched by that set of parentheses.  Thus \f(CW\*(C`\eg1\*(C'\fR refers to the first
capture group in the regex.
.PP
The \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR form can be equivalently written as \f(CW\*(C`\eg{\f(CIN\f(CW}\*(C'\fR
which avoids ambiguity when building a regex by concatenating shorter
strings.  Otherwise if you had a regex \f(CW\*(C`qr/$a$b/\*(C'\fR, and \f(CW$a\fR contained
\&\f(CW"\eg1"\fR, and \f(CW$b\fR contained \f(CW"37"\fR, you would get \f(CW\*(C`/\eg137/\*(C'\fR which is
probably not what you intended.
.PP
In the \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR form, \fIN\fR must not begin with a \*(L"0\*(R", and there must be at
least \fIN\fR capturing groups, or else \fIN\fR is considered an octal escape
(but something like \f(CW\*(C`\e18\*(C'\fR is the same as \f(CW\*(C`\e0018\*(C'\fR; that is, the octal escape
\&\f(CW"\e001"\fR followed by a literal digit \f(CW"8"\fR).
.PP
Mnemonic: \fIg\fRroup.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 3
\& /(\ew+) \eg1/;    # Finds a duplicated word, (e.g. "cat cat").
\& /(\ew+) \e1/;     # Same thing; written old\-style
\& /(.)(.)\eg2\eg1/;  # Match a four letter palindrome (e.g. "ABBA").
.Ve
.PP
\fIRelative referencing\fR
.IX Subsection "Relative referencing"
.PP
\&\f(CW\*(C`\eg\-\f(CIN\f(CW\*(C'\fR (starting in Perl 5.10.0) is used for relative addressing.  (It can
be written as \f(CW\*(C`\eg{\-\f(CIN\f(CW\*(C'\fR.)  It refers to the \fIN\fRth group before the
\&\f(CW\*(C`\eg{\-\f(CIN\f(CW}\*(C'\fR.
.PP
The big advantage of this form is that it makes it much easier to write
patterns with references that can be interpolated in larger patterns,
even if the larger pattern also contains capture groups.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& /(A)        # Group 1
\&  (          # Group 2
\&    (B)      # Group 3
\&    \eg{\-1}   # Refers to group 3 (B)
\&    \eg{\-3}   # Refers to group 1 (A)
\&  )
\& /x;         # Matches "ABBA".
\&
\& my $qr = qr /(.)(.)\eg{\-2}\eg{\-1}/;  # Matches \*(Aqabab\*(Aq, \*(Aqcdcd\*(Aq, etc.
\& /$qr$qr/                           # Matches \*(Aqababcdcd\*(Aq.
.Ve
.PP
\fINamed referencing\fR
.IX Subsection "Named referencing"
.PP
\&\f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR (starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to think about capture
buffer positions.
.PP
To be compatible with .Net regular expressions, \f(CW\*(C`\eg{name}\*(C'\fR may also be
written as \f(CW\*(C`\ek{name}\*(C'\fR, \f(CW\*(C`\ek<name>\*(C'\fR or \f(CW\*(C`\ek\*(Aqname\*(Aq\*(C'\fR.
.PP
To prevent any ambiguity, \fIname\fR must not start with a digit nor contain a
hyphen.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 5
\& /(?<word>\ew+) \eg{word}/ # Finds duplicated word, (e.g. "cat cat")
\& /(?<word>\ew+) \ek{word}/ # Same.
\& /(?<word>\ew+) \ek<word>/ # Same.
\& /(?<letter1>.)(?<letter2>.)\eg{letter2}\eg{letter1}/
\&                         # Match a four letter palindrome (e.g. "ABBA")
.Ve
.SS "Assertions"
.IX Subsection "Assertions"
Assertions are conditions that have to be true; they don't actually
match parts of the substring. There are six assertions that are written as
backslash sequences.
.IP "\eA" 4
.IX Item "A"
\&\f(CW\*(C`\eA\*(C'\fR only matches at the beginning of the string. If the \f(CW\*(C`/m\*(C'\fR modifier
isn't used, then \f(CW\*(C`/\eA/\*(C'\fR is equivalent to \f(CW\*(C`/^/\*(C'\fR. However, if the \f(CW\*(C`/m\*(C'\fR
modifier is used, then \f(CW\*(C`/^/\*(C'\fR matches internal newlines, but the meaning
of \f(CW\*(C`/\eA/\*(C'\fR isn't changed by the \f(CW\*(C`/m\*(C'\fR modifier. \f(CW\*(C`\eA\*(C'\fR matches at the beginning
of the string regardless whether the \f(CW\*(C`/m\*(C'\fR modifier is used.
.IP "\ez, \eZ" 4
.IX Item "z, Z"
\&\f(CW\*(C`\ez\*(C'\fR and \f(CW\*(C`\eZ\*(C'\fR match at the end of the string. If the \f(CW\*(C`/m\*(C'\fR modifier isn't
used, then \f(CW\*(C`/\eZ/\*(C'\fR is equivalent to \f(CW\*(C`/$/\*(C'\fR; that is, it matches at the
end of the string, or one before the newline at the end of the string. If the
\&\f(CW\*(C`/m\*(C'\fR modifier is used, then \f(CW\*(C`/$/\*(C'\fR matches at internal newlines, but the
meaning of \f(CW\*(C`/\eZ/\*(C'\fR isn't changed by the \f(CW\*(C`/m\*(C'\fR modifier. \f(CW\*(C`\eZ\*(C'\fR matches at
the end of the string (or just before a trailing newline) regardless whether
the \f(CW\*(C`/m\*(C'\fR modifier is used.
.Sp
\&\f(CW\*(C`\ez\*(C'\fR is just like \f(CW\*(C`\eZ\*(C'\fR, except that it does not match before a trailing
newline. \f(CW\*(C`\ez\*(C'\fR matches at the end of the string only, regardless of the
modifiers used, and not just before a newline.  It is how to anchor the
match to the true end of the string under all conditions.
.IP "\eG" 4
.IX Item "G"
\&\f(CW\*(C`\eG\*(C'\fR is usually used only in combination with the \f(CW\*(C`/g\*(C'\fR modifier. If the
\&\f(CW\*(C`/g\*(C'\fR modifier is used and the match is done in scalar context, Perl 
remembers where in the source string the last match ended, and the next time,
it will start the match from where it ended the previous time.
.Sp
\&\f(CW\*(C`\eG\*(C'\fR matches the point where the previous match on that string ended, 
or the beginning of that string if there was no previous match.
.Sp
Mnemonic: \fIG\fRlobal.
.IP "\eb, \eB" 4
.IX Item "b, B"
\&\f(CW\*(C`\eb\*(C'\fR matches at any place between a word and a non-word character; \f(CW\*(C`\eB\*(C'\fR
matches at any place between characters where \f(CW\*(C`\eb\*(C'\fR doesn't match. \f(CW\*(C`\eb\*(C'\fR
and \f(CW\*(C`\eB\*(C'\fR assume there's a non-word character before the beginning and after
the end of the source string; so \f(CW\*(C`\eb\*(C'\fR will match at the beginning (or end)
of the source string if the source string begins (or ends) with a word
character. Otherwise, \f(CW\*(C`\eB\*(C'\fR will match.
.Sp
Do not use something like \f(CW\*(C`\eb=head\ed\eb\*(C'\fR and expect it to match the
beginning of a line.  It can't, because for there to be a boundary before
the non-word \*(L"=\*(R", there must be a word character immediately previous.  
All boundary determinations look for word characters alone, not for
non-words characters nor for string ends.  It may help to understand how
<\eb> and <\eB> work by equating them as follows:
.Sp
.Vb 2
\&    \eb  really means    (?:(?<=\ew)(?!\ew)|(?<!\ew)(?=\ew))
\&    \eB  really means    (?:(?<=\ew)(?=\ew)|(?<!\ew)(?!\ew))
.Ve
.Sp
Mnemonic: \fIb\fRoundary.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 4
\&  "cat"   =~ /\eAcat/;     # Match.
\&  "cat"   =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\ez/;     # No match.
\&
\&  "cat"   =~ /\ebcat\eb/;   # Matches.
\&  "cats"  =~ /\ebcat\eb/;   # No match.
\&  "cat"   =~ /\ebcat\eB/;   # No match.
\&  "cats"  =~ /\ebcat\eB/;   # Match.
\&
\&  while ("cat dog" =~ /(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcatdog\*(Aq
\&  }
\&  while ("cat dog" =~ /\eG(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcat\*(Aq
\&  }
.Ve
.SS "Misc"
.IX Subsection "Misc"
Here we document the backslash sequences that don't fall in one of the
categories above. These are:
.IP "\eC" 4
.IX Item "C"
\&\f(CW\*(C`\eC\*(C'\fR always matches a single octet, even if the source string is encoded
in \s-1UTF\-8\s0 format, and the character to be matched is a multi-octet character.
\&\f(CW\*(C`\eC\*(C'\fR was introduced in perl 5.6.  This is very dangerous, because it violates
the logical character abstraction and can cause \s-1UTF\-8\s0 sequences to become malformed.
.Sp
Mnemonic: o\fIC\fRtet.
.IP "\eK" 4
.IX Item "K"
This appeared in perl 5.10.0. Anything matched left of \f(CW\*(C`\eK\*(C'\fR is
not included in \f(CW$&\fR, and will not be replaced if the pattern is
used in a substitution. This lets you write \f(CW\*(C`s/PAT1 \eK PAT2/REPL/x\*(C'\fR
instead of \f(CW\*(C`s/(PAT1) PAT2/${1}REPL/x\*(C'\fR or \f(CW\*(C`s/(?<=PAT1) PAT2/REPL/x\*(C'\fR.
.Sp
Mnemonic: \fIK\fReep.
.IP "\eN" 4
.IX Item "N"
This is an experimental feature new to perl 5.12.0.  It matches any character
that is \fBnot\fR a newline.  It is a short-hand for writing \f(CW\*(C`[^\en]\*(C'\fR, and is
identical to the \f(CW\*(C`.\*(C'\fR metasymbol, except under the \f(CW\*(C`/s\*(C'\fR flag, which changes
the meaning of \f(CW\*(C`.\*(C'\fR, but not \f(CW\*(C`\eN\*(C'\fR.
.Sp
Note that \f(CW\*(C`\eN{...}\*(C'\fR can mean a
named or numbered character
\&.
.Sp
Mnemonic: Complement of \fI\en\fR.
.IP "\eR" 4
.IX Xref "\\R"
.IX Item "R"
\&\f(CW\*(C`\eR\*(C'\fR matches a \fIgeneric newline\fR; that is, anything considered a
linebreak sequence by Unicode. This includes all characters matched by
\&\f(CW\*(C`\ev\*(C'\fR (vertical whitespace), and the multi character sequence \f(CW"\ex0D\ex0A"\fR
(carriage return followed by a line feed, sometimes called the network
newline; it's the end of line sequence used in Microsoft text files opened
in binary mode). \f(CW\*(C`\eR\*(C'\fR is equivalent to \f(CW\*(C`(?>\ex0D\ex0A|\ev)\*(C'\fR.  (The
reason it doesn't backtrack is that the sequence is considered
inseparable.  That means that
.Sp
.Vb 1
\& "\ex0D\ex0A" =~ /^\eR\ex0A$/   # No match
.Ve
.Sp
fails, because the \f(CW\*(C`\eR\*(C'\fR matches the entire string, and won't backtrack
to match just the \f(CW"\ex0D"\fR.)  Since
\&\f(CW\*(C`\eR\*(C'\fR can match a sequence of more than one character, it cannot be put
inside a bracketed character class; \f(CW\*(C`/[\eR]/\*(C'\fR is an error; use \f(CW\*(C`\ev\*(C'\fR
instead.  \f(CW\*(C`\eR\*(C'\fR was introduced in perl 5.10.0.
.Sp
Note that this does not respect any locale that might be in effect; it
matches according to the platform's native character set.
.Sp
Mnemonic: none really. \f(CW\*(C`\eR\*(C'\fR was picked because \s-1PCRE\s0 already uses \f(CW\*(C`\eR\*(C'\fR,
and more importantly because Unicode recommends such a regular expression
metacharacter, and suggests \f(CW\*(C`\eR\*(C'\fR as its notation.
.IP "\eX" 4
.IX Xref "\\X"
.IX Item "X"
This matches a Unicode \fIextended grapheme cluster\fR.
.Sp
\&\f(CW\*(C`\eX\*(C'\fR matches quite well what normal (non-Unicode-programmer) usage
would consider a single character.  As an example, consider a G with some sort
of diacritic mark, such as an arrow.  There is no such single character in
Unicode, but one can be composed by using a G followed by a Unicode \*(L"\s-1COMBINING\s0
\&\s-1UPWARDS\s0 \s-1ARROW\s0 \s-1BELOW\s0\*(R", and would be displayed by Unicode-aware software as if it
were a single character.
.Sp
Mnemonic: e\fIX\fRtended Unicode character.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 1
\& "\ex{256}" =~ /^\eC\eC$/;    # Match as chr (0x256) takes 2 octets in UTF\-8.
\&
\& $str =~ s/foo\eKbar/baz/g; # Change any \*(Aqbar\*(Aq following a \*(Aqfoo\*(Aq to \*(Aqbaz\*(Aq
\& $str =~ s/(.)\eK\eg1//g;    # Delete duplicated characters.
\&
\& "\en"   =~ /^\eR$/;         # Match, \en   is a generic newline.
\& "\er"   =~ /^\eR$/;         # Match, \er   is a generic newline.
\& "\er\en" =~ /^\eR$/;         # Match, \er\en is a generic newline.
\&
\& "P\ex{307}" =~ /^\eX$/     # \eX matches a P with a dot above.
.Ve
                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrebackslash5.18.1                        0100644 0001750 0001750 00000104744 12566207444 024435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREBACKSLASH 1"
.TH PERLREBACKSLASH 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrebackslash \- Perl Regular Expression Backslash Sequences and Escapes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This document describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the sequences that have
a special meaning in Perl regular expressions (in alphabetical order),
then describes each of them.
.PP
Most sequences are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide describing all
backslash and escape sequences.
.SS "The backslash"
.IX Subsection "The backslash"
In a regular expression, the backslash can perform one of two tasks:
it either takes away the special meaning of the character following it
(for instance, \f(CW\*(C`\e|\*(C'\fR matches a vertical bar, it's not an alternation),
or it is the start of a backslash or escape sequence.
.PP
The rules determining what it is are quite simple: if the character
following the backslash is an \s-1ASCII\s0 punctuation (non-word) character (that is,
anything that is not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following it.
.PP
If the character following the backslash is an \s-1ASCII\s0 letter or an \s-1ASCII\s0 digit,
then the sequence may be special; if so, it's listed below. A few letters have
not been used yet, so escaping them with a backslash doesn't change them to be
special.  A future version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you use such a
sequence.  [1].
.PP
It is however guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and not in a future
version of Perl 5. So it is safe to put a backslash in front of a non-word
character.
.PP
Note that the backslash itself is special; if you want to match a backslash,
you have to escape the backslash with a backslash: \f(CW\*(C`/\e\e/\*(C'\fR matches a single
backslash.
.IP "[1]" 4
.IX Item "[1]"
There is one exception. If you use an alphanumeric character as the
delimiter of your pattern (which you probably shouldn't do for readability
reasons), you have to escape the delimiter if you want to match
it. Perl won't warn then. See also \*(L"Gory details of parsing
quoted constructs\*(R" in perlop.
.SS "All the sequences and escapes"
.IX Subsection "All the sequences and escapes"
Those not usable within a bracketed character class (like \f(CW\*(C`[\eda\-z]\*(C'\fR) are marked
as \f(CW\*(C`Not in [].\*(C'\fR
.PP
.Vb 10
\& \e000              Octal escape sequence.  See also \eo{}.
\& \e1                Absolute backreference.  Not in [].
\& \ea                Alarm or bell.
\& \eA                Beginning of string.  Not in [].
\& \eb                Word/non\-word boundary. (Backspace in []).
\& \eB                Not a word/non\-word boundary.  Not in [].
\& \ecX               Control\-X.
\& \eC                Single octet, even under UTF\-8.  Not in [].
\& \ed                Character class for digits.
\& \eD                Character class for non\-digits.
\& \ee                Escape character.
\& \eE                Turn off \eQ, \eL and \eU processing.  Not in [].
\& \ef                Form feed.
\& \eF                Foldcase till \eE.  Not in [].
\& \eg{}, \eg1         Named, absolute or relative backreference.
\&                   Not in [].
\& \eG                Pos assertion.  Not in [].
\& \eh                Character class for horizontal whitespace.
\& \eH                Character class for non horizontal whitespace.
\& \ek{}, \ek<>, \ek\*(Aq\*(Aq  Named backreference.  Not in [].
\& \eK                Keep the stuff left of \eK.  Not in [].
\& \el                Lowercase next character.  Not in [].
\& \eL                Lowercase till \eE.  Not in [].
\& \en                (Logical) newline character.
\& \eN                Any character but newline.  Not in [].
\& \eN{}              Named or numbered (Unicode) character or sequence.
\& \eo{}              Octal escape sequence.
\& \ep{}, \epP         Character with the given Unicode property.
\& \eP{}, \ePP         Character without the given Unicode property.
\& \eQ                Quote (disable) pattern metacharacters till \eE.  Not
\&                   in [].
\& \er                Return character.
\& \eR                Generic new line.  Not in [].
\& \es                Character class for whitespace.
\& \eS                Character class for non whitespace.
\& \et                Tab character.
\& \eu                Titlecase next character.  Not in [].
\& \eU                Uppercase till \eE.  Not in [].
\& \ev                Character class for vertical whitespace.
\& \eV                Character class for non vertical whitespace.
\& \ew                Character class for word characters.
\& \eW                Character class for non\-word characters.
\& \ex{}, \ex00        Hexadecimal escape sequence.
\& \eX                Unicode "extended grapheme cluster".  Not in [].
\& \ez                End of string.  Not in [].
\& \eZ                End of string.  Not in [].
.Ve
.SS "Character Escapes"
.IX Subsection "Character Escapes"
\fIFixed characters\fR
.IX Subsection "Fixed characters"
.PP
A handful of characters have a dedicated \fIcharacter escape\fR. The following
table shows them, along with their \s-1ASCII\s0 code points (in decimal and hex),
their \s-1ASCII\s0 name, the control escape on \s-1ASCII\s0 platforms and a short
description.  (For \s-1EBCDIC\s0 platforms, see \*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 in perlebcdic.)
.PP
.Vb 9
\& Seq.  Code Point  ASCII   Cntrl   Description.
\&       Dec    Hex
\&  \ea     7     07    BEL    \ecG    alarm or bell
\&  \eb     8     08     BS    \ecH    backspace [1]
\&  \ee    27     1B    ESC    \ec[    escape character
\&  \ef    12     0C     FF    \ecL    form feed
\&  \en    10     0A     LF    \ecJ    line feed [2]
\&  \er    13     0D     CR    \ecM    carriage return
\&  \et     9     09    TAB    \ecI    tab
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\eb\*(C'\fR is the backspace character only inside a character class. Outside a
character class, \f(CW\*(C`\eb\*(C'\fR is a word/non\-word boundary.
.IP "[2]" 4
.IX Item "[2]"
\&\f(CW\*(C`\en\*(C'\fR matches a logical newline. Perl converts between \f(CW\*(C`\en\*(C'\fR and your
\&\s-1OS\s0's native newline character when reading from or writing to text files.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\et/;   # Matches if $str contains a (horizontal) tab.
.Ve
.PP
\fIControl characters\fR
.IX Subsection "Control characters"
.PP
\&\f(CW\*(C`\ec\*(C'\fR is used to denote a control character; the character following \f(CW\*(C`\ec\*(C'\fR
determines the value of the construct.  For example the value of \f(CW\*(C`\ecA\*(C'\fR is
\&\f(CWchr(1)\fR, and the value of \f(CW\*(C`\ecb\*(C'\fR is \f(CWchr(2)\fR, etc.
The gory details are in \*(L"Regexp Quote-Like Operators\*(R" in perlop.  A complete
list of what \f(CWchr(1)\fR, etc. means for \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms is in
\&\*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 in perlebcdic.
.PP
Note that \f(CW\*(C`\ec\e\*(C'\fR alone at the end of a regular expression (or doubled-quoted
string) is not valid.  The backslash must be followed by another character.
That is, \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR means \f(CW\*(C`chr(28) . \*(Aq\f(CIX\f(CW\*(Aq\*(C'\fR for all characters \fIX\fR.
.PP
To write platform-independent code, you must use \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR instead, like
\&\f(CW\*(C`\eN{ESCAPE}\*(C'\fR or \f(CW\*(C`\eN{U+001B}\*(C'\fR, see charnames.
.PP
Mnemonic: \fIc\fRontrol character.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\ecK/;  # Matches if $str contains a vertical tab (control\-K).
.Ve
.PP
\fINamed or numbered characters and character sequences\fR
.IX Subsection "Named or numbered characters and character sequences"
.PP
Unicode characters have a Unicode name and numeric code point (ordinal)
value.  Use the
\&\f(CW\*(C`\eN{}\*(C'\fR construct to specify a character by either of these values.
Certain sequences of characters also have names.
.PP
To specify by name, the name of the character or character sequence goes
between the curly braces.
.PP
To specify a character by Unicode code point, use the form \f(CW\*(C`\eN{U+\f(CIcode
point\f(CW}\*(C'\fR, where \fIcode point\fR is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired character.  It is
customary but not required to use leading zeros to pad the number to 4
digits.  Thus \f(CW\*(C`\eN{U+0041}\*(C'\fR means \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR, and you will
rarely see it written without the two leading zeros.  \f(CW\*(C`\eN{U+0041}\*(C'\fR means
\&\*(L"A\*(R" even on \s-1EBCDIC\s0 machines (where the ordinal value of \*(L"A\*(R" is not 0x41).
.PP
It is even possible to give your own names to characters and character
sequences.  For details, see charnames.
.PP
(There is an expanded internal form that you may see in debug output:
\&\f(CW\*(C`\eN{U+\f(CIcode point\f(CW.\f(CIcode point\f(CW...}\*(C'\fR.
The \f(CW\*(C`...\*(C'\fR means any number of these \fIcode point\fRs separated by dots.
This represents the sequence formed by the characters.  This is an internal
form only, subject to change, and you should not try to use it yourself.)
.PP
Mnemonic: \fIN\fRamed character.
.PP
Note that a character or character sequence expressed as a named
or numbered character is considered a character without special
meaning by the regex engine, and will match \*(L"as is\*(R".
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\eN{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character
\&
\& use charnames \*(AqCyrillic\*(Aq;            # Loads Cyrillic names.
\& $str =~ /\eN{ZHE}\eN{KA}/;             # Match "ZHE" followed by "KA".
.Ve
.PP
\fIOctal escapes\fR
.IX Subsection "Octal escapes"
.PP
There are two forms of octal escapes.  Each is used to specify a character by
its code point specified in octal notation.
.PP
One form, available starting in Perl 5.14 looks like \f(CW\*(C`\eo{...}\*(C'\fR, where the dots
represent one or more octal digits.  It can be used for any Unicode character.
.PP
It was introduced to avoid the potential problems with the other form,
available in all Perls.  That form consists of a backslash followed by three
octal digits.  One problem with this form is that it can look exactly like an
old-style backreference (see
\&\*(L"Disambiguation rules between old-style octal escapes and backreferences\*(R"
below.)  You can avoid this by making the first of the three digits always a
zero, but that makes \e077 the largest code point specifiable.
.PP
In some contexts, a backslash followed by two or even one octal digits may be
interpreted as an octal escape, sometimes with a warning, and because of some
bugs, sometimes with surprising results.  Also, if you are creating a regex
out of smaller snippets concatenated together, and you use fewer than three
digits, the beginning of one snippet may be interpreted as adding digits to the
ending of the snippet before it.  See \*(L"Absolute referencing\*(R" for more
discussion and examples of the snippet problem.
.PP
Note that a character expressed as an octal escape is considered
a character without special meaning by the regex engine, and will match
\&\*(L"as is\*(R".
.PP
To summarize, the \f(CW\*(C`\eo{}\*(C'\fR form is always safe to use, and the other form is
safe to use for code points through \e077 when you use exactly three digits to
specify them.
.PP
Mnemonic: \fI0\fRctal or \fIo\fRctal.
.PP
Examples (assuming an \s-1ASCII\s0 platform)
.IX Subsection "Examples (assuming an ASCII platform)"
.PP
.Vb 9
\& $str = "Perl";
\& $str =~ /\eo{120}/;  # Match, "\e120" is "P".
\& $str =~ /\e120/;     # Same.
\& $str =~ /\eo{120}+/; # Match, "\e120" is "P",
\&                     # it\*(Aqs repeated at least once.
\& $str =~ /\e120+/;    # Same.
\& $str =~ /P\e053/;    # No match, "\e053" is "+" and taken literally.
\& /\eo{23073}/         # Black foreground, white background smiling face.
\& /\eo{4801234567}/    # Raises a warning, and yields chr(4).
.Ve
.PP
Disambiguation rules between old-style octal escapes and backreferences
.IX Subsection "Disambiguation rules between old-style octal escapes and backreferences"
.PP
Octal escapes of the \f(CW\*(C`\e000\*(C'\fR form outside of bracketed character classes
potentially clash with old-style backreferences (see \*(L"Absolute referencing\*(R"
below).  They both consist of a backslash followed by numbers.  So Perl has to
use heuristics to determine whether it is a backreference or an octal escape.
Perl uses the following rules to disambiguate:
.IP "1." 4
If the backslash is followed by a single digit, it's a backreference.
.IP "2." 4
If the first digit following the backslash is a 0, it's an octal escape.
.IP "3." 4
If the number following the backslash is N (in decimal), and Perl already
has seen N capture groups, Perl considers this a backreference.  Otherwise,
it considers it an octal escape. If N has more than three digits, Perl
takes only the first three for the octal escape; the rest are matched as is.
.Sp
.Vb 6
\& my $pat  = "(" x 999;
\&    $pat .= "a";
\&    $pat .= ")" x 999;
\& /^($pat)\e1000$/;   #  Matches \*(Aqaa\*(Aq; there are 1000 capture groups.
\& /^$pat\e1000$/;     #  Matches \*(Aqa@0\*(Aq; there are 999 capture groups
\&                    #  and \e1000 is seen as \e100 (a \*(Aq@\*(Aq) and a \*(Aq0\*(Aq.
.Ve
.PP
You can force a backreference interpretation always by using the \f(CW\*(C`\eg{...}\*(C'\fR
form.  You can the force an octal interpretation always by using the \f(CW\*(C`\eo{...}\*(C'\fR
form, or for numbers up through \e077 (= 63 decimal), by using three digits,
beginning with a \*(L"0\*(R".
.PP
\fIHexadecimal escapes\fR
.IX Subsection "Hexadecimal escapes"
.PP
Like octal escapes, there are two forms of hexadecimal escapes, but both start
with the same thing, \f(CW\*(C`\ex\*(C'\fR.  This is followed by either exactly two hexadecimal
digits forming a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. The hexadecimal number is the code point of the character you
want to express.
.PP
Note that a character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and will match
\&\*(L"as is\*(R".
.PP
Mnemonic: he\fIx\fRadecimal.
.PP
Examples (assuming an \s-1ASCII\s0 platform)
.IX Subsection "Examples (assuming an ASCII platform)"
.PP
.Vb 4
\& $str = "Perl";
\& $str =~ /\ex50/;    # Match, "\ex50" is "P".
\& $str =~ /\ex50+/;   # Match, "\ex50" is "P", it is repeated at least once
\& $str =~ /P\ex2B/;   # No match, "\ex2B" is "+" and taken literally.
\&
\& /\ex{2603}\ex{2602}/ # Snowman with an umbrella.
\&                    # The Unicode character 2603 is a snowman,
\&                    # the Unicode character 2602 is an umbrella.
\& /\ex{263B}/         # Black smiling face.
\& /\ex{263b}/         # Same, the hex digits A \- F are case insensitive.
.Ve
.SS "Modifiers"
.IX Subsection "Modifiers"
A number of backslash sequences have to do with changing the character,
or characters following them. \f(CW\*(C`\el\*(C'\fR will lowercase the character following
it, while \f(CW\*(C`\eu\*(C'\fR will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar to the
functions \f(CW\*(C`lcfirst\*(C'\fR and \f(CW\*(C`ucfirst\*(C'\fR.
.PP
To uppercase or lowercase several characters, one might want to use
\&\f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR, which will lowercase/uppercase all characters following
them, until either the end of the pattern or the next occurrence of
\&\f(CW\*(C`\eE\*(C'\fR, whichever comes first. They provide functionality similar to what
the functions \f(CW\*(C`lc\*(C'\fR and \f(CW\*(C`uc\*(C'\fR provide.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR is used to quote (disable) pattern metacharacters, up to the next
\&\f(CW\*(C`\eE\*(C'\fR or the end of the pattern. \f(CW\*(C`\eQ\*(C'\fR adds a backslash to any character
that could have special meaning to Perl.  In the \s-1ASCII\s0 range, it quotes
every character that isn't a letter, digit, or underscore.  See
\&\*(L"quotemeta\*(R" in perlfunc for details on what gets quoted for non-ASCII
code points.  Using this ensures that any character between \f(CW\*(C`\eQ\*(C'\fR and
\&\f(CW\*(C`\eE\*(C'\fR will be matched literally, not interpreted as a metacharacter by
the regex engine.
.PP
\&\f(CW\*(C`\eF\*(C'\fR can be used to casefold all characters following, up to the next \f(CW\*(C`\eE\*(C'\fR
or the end of the pattern. It provides the functionality similar to
the \f(CW\*(C`fc\*(C'\fR function.
.PP
Mnemonic: \fIL\fRowercase, \fIU\fRppercase, \fIF\fRold-case, \fIQ\fRuotemeta, \fIE\fRnd.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& $sid     = "sid";
\& $greg    = "GrEg";
\& $miranda = "(Miranda)";
\& $str     =~ /\eu$sid/;        # Matches \*(AqSid\*(Aq
\& $str     =~ /\eL$greg/;       # Matches \*(Aqgreg\*(Aq
\& $str     =~ /\eQ$miranda\eE/;  # Matches \*(Aq(Miranda)\*(Aq, as if the pattern
\&                              #   had been written as /\e(Miranda\e)/
.Ve
.SS "Character classes"
.IX Subsection "Character classes"
Perl regular expressions have a large range of character classes. Some of
the character classes are written as a backslash sequence. We will briefly
discuss those here; full details of character classes can be found in
perlrecharclass.
.PP
\&\f(CW\*(C`\ew\*(C'\fR is a character class that matches any single \fIword\fR character
(letters, digits, Unicode marks, and connector punctuation (like the
underscore)).  \f(CW\*(C`\ed\*(C'\fR is a character class that matches any decimal
digit, while the character class \f(CW\*(C`\es\*(C'\fR matches any whitespace character.
New in perl 5.10.0 are the classes \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR which match horizontal
and vertical whitespace characters.
.PP
The exact set of characters matched by \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, and \f(CW\*(C`\ew\*(C'\fR varies
depending on various pragma and regular expression modifiers.  It is
possible to restrict the match to the \s-1ASCII\s0 range by using the \f(CW\*(C`/a\*(C'\fR
regular expression modifier.  See perlrecharclass.
.PP
The uppercase variants (\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\eH\*(C'\fR, and \f(CW\*(C`\eV\*(C'\fR) are
character classes that match, respectively, any character that isn't a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.
.PP
Mnemonics: \fIw\fRord, \fId\fRigit, \fIs\fRpace, \fIh\fRorizontal, \fIv\fRertical.
.PP
\fIUnicode classes\fR
.IX Subsection "Unicode classes"
.PP
\&\f(CW\*(C`\epP\*(C'\fR (where \f(CW\*(C`P\*(C'\fR is a single letter) and \f(CW\*(C`\ep{Property}\*(C'\fR are used to
match a character that matches the given Unicode property; properties
include things like \*(L"letter\*(R", or \*(L"thai character\*(R". Capitalizing the
sequence to \f(CW\*(C`\ePP\*(C'\fR and \f(CW\*(C`\eP{Property}\*(C'\fR make the sequence match a character
that doesn't match the given Unicode property. For more details, see
\&\*(L"Backslash sequences\*(R" in perlrecharclass and
\&\*(L"Unicode Character Properties\*(R" in perlunicode.
.PP
Mnemonic: \fIp\fRroperty.
.SS "Referencing"
.IX Subsection "Referencing"
If capturing parenthesis are used in a regular expression, we can refer
to the part of the source string that was matched, and match exactly the
same thing. There are three ways of referring to such \fIbackreference\fR:
absolutely, relatively, and by name.
.PP
\fIAbsolute referencing\fR
.IX Subsection "Absolute referencing"
.PP
Either \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR (starting in Perl 5.10.0), or \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR (old-style) where \fIN\fR
is a positive (unsigned) decimal number of any length is an absolute reference
to a capturing group.
.PP
\&\fIN\fR refers to the Nth set of parentheses, so \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR refers to whatever has
been matched by that set of parentheses.  Thus \f(CW\*(C`\eg1\*(C'\fR refers to the first
capture group in the regex.
.PP
The \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR form can be equivalently written as \f(CW\*(C`\eg{\f(CIN\f(CW}\*(C'\fR
which avoids ambiguity when building a regex by concatenating shorter
strings.  Otherwise if you had a regex \f(CW\*(C`qr/$a$b/\*(C'\fR, and \f(CW$a\fR contained
\&\f(CW"\eg1"\fR, and \f(CW$b\fR contained \f(CW"37"\fR, you would get \f(CW\*(C`/\eg137/\*(C'\fR which is
probably not what you intended.
.PP
In the \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR form, \fIN\fR must not begin with a \*(L"0\*(R", and there must be at
least \fIN\fR capturing groups, or else \fIN\fR is considered an octal escape
(but something like \f(CW\*(C`\e18\*(C'\fR is the same as \f(CW\*(C`\e0018\*(C'\fR; that is, the octal escape
\&\f(CW"\e001"\fR followed by a literal digit \f(CW"8"\fR).
.PP
Mnemonic: \fIg\fRroup.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 3
\& /(\ew+) \eg1/;    # Finds a duplicated word, (e.g. "cat cat").
\& /(\ew+) \e1/;     # Same thing; written old\-style.
\& /(.)(.)\eg2\eg1/;  # Match a four letter palindrome (e.g. "ABBA").
.Ve
.PP
\fIRelative referencing\fR
.IX Subsection "Relative referencing"
.PP
\&\f(CW\*(C`\eg\-\f(CIN\f(CW\*(C'\fR (starting in Perl 5.10.0) is used for relative addressing.  (It can
be written as \f(CW\*(C`\eg{\-\f(CIN\f(CW\*(C'\fR.)  It refers to the \fIN\fRth group before the
\&\f(CW\*(C`\eg{\-\f(CIN\f(CW}\*(C'\fR.
.PP
The big advantage of this form is that it makes it much easier to write
patterns with references that can be interpolated in larger patterns,
even if the larger pattern also contains capture groups.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& /(A)        # Group 1
\&  (          # Group 2
\&    (B)      # Group 3
\&    \eg{\-1}   # Refers to group 3 (B)
\&    \eg{\-3}   # Refers to group 1 (A)
\&  )
\& /x;         # Matches "ABBA".
\&
\& my $qr = qr /(.)(.)\eg{\-2}\eg{\-1}/;  # Matches \*(Aqabab\*(Aq, \*(Aqcdcd\*(Aq, etc.
\& /$qr$qr/                           # Matches \*(Aqababcdcd\*(Aq.
.Ve
.PP
\fINamed referencing\fR
.IX Subsection "Named referencing"
.PP
\&\f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR (starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to think about capture
buffer positions.
.PP
To be compatible with .Net regular expressions, \f(CW\*(C`\eg{name}\*(C'\fR may also be
written as \f(CW\*(C`\ek{name}\*(C'\fR, \f(CW\*(C`\ek<name>\*(C'\fR or \f(CW\*(C`\ek\*(Aqname\*(Aq\*(C'\fR.
.PP
To prevent any ambiguity, \fIname\fR must not start with a digit nor contain a
hyphen.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 5
\& /(?<word>\ew+) \eg{word}/ # Finds duplicated word, (e.g. "cat cat")
\& /(?<word>\ew+) \ek{word}/ # Same.
\& /(?<word>\ew+) \ek<word>/ # Same.
\& /(?<letter1>.)(?<letter2>.)\eg{letter2}\eg{letter1}/
\&                         # Match a four letter palindrome (e.g. "ABBA")
.Ve
.SS "Assertions"
.IX Subsection "Assertions"
Assertions are conditions that have to be true; they don't actually
match parts of the substring. There are six assertions that are written as
backslash sequences.
.IP "\eA" 4
.IX Item "A"
\&\f(CW\*(C`\eA\*(C'\fR only matches at the beginning of the string. If the \f(CW\*(C`/m\*(C'\fR modifier
isn't used, then \f(CW\*(C`/\eA/\*(C'\fR is equivalent to \f(CW\*(C`/^/\*(C'\fR. However, if the \f(CW\*(C`/m\*(C'\fR
modifier is used, then \f(CW\*(C`/^/\*(C'\fR matches internal newlines, but the meaning
of \f(CW\*(C`/\eA/\*(C'\fR isn't changed by the \f(CW\*(C`/m\*(C'\fR modifier. \f(CW\*(C`\eA\*(C'\fR matches at the beginning
of the string regardless whether the \f(CW\*(C`/m\*(C'\fR modifier is used.
.IP "\ez, \eZ" 4
.IX Item "z, Z"
\&\f(CW\*(C`\ez\*(C'\fR and \f(CW\*(C`\eZ\*(C'\fR match at the end of the string. If the \f(CW\*(C`/m\*(C'\fR modifier isn't
used, then \f(CW\*(C`/\eZ/\*(C'\fR is equivalent to \f(CW\*(C`/$/\*(C'\fR; that is, it matches at the
end of the string, or one before the newline at the end of the string. If the
\&\f(CW\*(C`/m\*(C'\fR modifier is used, then \f(CW\*(C`/$/\*(C'\fR matches at internal newlines, but the
meaning of \f(CW\*(C`/\eZ/\*(C'\fR isn't changed by the \f(CW\*(C`/m\*(C'\fR modifier. \f(CW\*(C`\eZ\*(C'\fR matches at
the end of the string (or just before a trailing newline) regardless whether
the \f(CW\*(C`/m\*(C'\fR modifier is used.
.Sp
\&\f(CW\*(C`\ez\*(C'\fR is just like \f(CW\*(C`\eZ\*(C'\fR, except that it does not match before a trailing
newline. \f(CW\*(C`\ez\*(C'\fR matches at the end of the string only, regardless of the
modifiers used, and not just before a newline.  It is how to anchor the
match to the true end of the string under all conditions.
.IP "\eG" 4
.IX Item "G"
\&\f(CW\*(C`\eG\*(C'\fR is usually used only in combination with the \f(CW\*(C`/g\*(C'\fR modifier. If the
\&\f(CW\*(C`/g\*(C'\fR modifier is used and the match is done in scalar context, Perl 
remembers where in the source string the last match ended, and the next time,
it will start the match from where it ended the previous time.
.Sp
\&\f(CW\*(C`\eG\*(C'\fR matches the point where the previous match on that string ended, 
or the beginning of that string if there was no previous match.
.Sp
Mnemonic: \fIG\fRlobal.
.IP "\eb, \eB" 4
.IX Item "b, B"
\&\f(CW\*(C`\eb\*(C'\fR matches at any place between a word and a non-word character; \f(CW\*(C`\eB\*(C'\fR
matches at any place between characters where \f(CW\*(C`\eb\*(C'\fR doesn't match. \f(CW\*(C`\eb\*(C'\fR
and \f(CW\*(C`\eB\*(C'\fR assume there's a non-word character before the beginning and after
the end of the source string; so \f(CW\*(C`\eb\*(C'\fR will match at the beginning (or end)
of the source string if the source string begins (or ends) with a word
character. Otherwise, \f(CW\*(C`\eB\*(C'\fR will match.
.Sp
Do not use something like \f(CW\*(C`\eb=head\ed\eb\*(C'\fR and expect it to match the
beginning of a line.  It can't, because for there to be a boundary before
the non-word \*(L"=\*(R", there must be a word character immediately previous.  
All boundary determinations look for word characters alone, not for
non-words characters nor for string ends.  It may help to understand how
<\eb> and <\eB> work by equating them as follows:
.Sp
.Vb 2
\&    \eb  really means    (?:(?<=\ew)(?!\ew)|(?<!\ew)(?=\ew))
\&    \eB  really means    (?:(?<=\ew)(?=\ew)|(?<!\ew)(?!\ew))
.Ve
.Sp
Mnemonic: \fIb\fRoundary.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 4
\&  "cat"   =~ /\eAcat/;     # Match.
\&  "cat"   =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\ez/;     # No match.
\&
\&  "cat"   =~ /\ebcat\eb/;   # Matches.
\&  "cats"  =~ /\ebcat\eb/;   # No match.
\&  "cat"   =~ /\ebcat\eB/;   # No match.
\&  "cats"  =~ /\ebcat\eB/;   # Match.
\&
\&  while ("cat dog" =~ /(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcatdog\*(Aq
\&  }
\&  while ("cat dog" =~ /\eG(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcat\*(Aq
\&  }
.Ve
.SS "Misc"
.IX Subsection "Misc"
Here we document the backslash sequences that don't fall in one of the
categories above. These are:
.IP "\eC" 4
.IX Item "C"
\&\f(CW\*(C`\eC\*(C'\fR always matches a single octet, even if the source string is encoded
in \s-1UTF\-8\s0 format, and the character to be matched is a multi-octet character.
This is very dangerous, because it violates
the logical character abstraction and can cause \s-1UTF\-8\s0 sequences to become malformed.
.Sp
Mnemonic: o\fIC\fRtet.
.IP "\eK" 4
.IX Item "K"
This appeared in perl 5.10.0. Anything matched left of \f(CW\*(C`\eK\*(C'\fR is
not included in \f(CW$&\fR, and will not be replaced if the pattern is
used in a substitution. This lets you write \f(CW\*(C`s/PAT1 \eK PAT2/REPL/x\*(C'\fR
instead of \f(CW\*(C`s/(PAT1) PAT2/${1}REPL/x\*(C'\fR or \f(CW\*(C`s/(?<=PAT1) PAT2/REPL/x\*(C'\fR.
.Sp
Mnemonic: \fIK\fReep.
.IP "\eN" 4
.IX Item "N"
This feature, available starting in v5.12,  matches any character
that is \fBnot\fR a newline.  It is a short-hand for writing \f(CW\*(C`[^\en]\*(C'\fR, and is
identical to the \f(CW\*(C`.\*(C'\fR metasymbol, except under the \f(CW\*(C`/s\*(C'\fR flag, which changes
the meaning of \f(CW\*(C`.\*(C'\fR, but not \f(CW\*(C`\eN\*(C'\fR.
.Sp
Note that \f(CW\*(C`\eN{...}\*(C'\fR can mean a
named or numbered character
\&.
.Sp
Mnemonic: Complement of \fI\en\fR.
.IP "\eR" 4
.IX Xref "\\R"
.IX Item "R"
\&\f(CW\*(C`\eR\*(C'\fR matches a \fIgeneric newline\fR; that is, anything considered a
linebreak sequence by Unicode. This includes all characters matched by
\&\f(CW\*(C`\ev\*(C'\fR (vertical whitespace), and the multi character sequence \f(CW"\ex0D\ex0A"\fR
(carriage return followed by a line feed, sometimes called the network
newline; it's the end of line sequence used in Microsoft text files opened
in binary mode). \f(CW\*(C`\eR\*(C'\fR is equivalent to \f(CW\*(C`(?>\ex0D\ex0A|\ev)\*(C'\fR.  (The
reason it doesn't backtrack is that the sequence is considered
inseparable.  That means that
.Sp
.Vb 1
\& "\ex0D\ex0A" =~ /^\eR\ex0A$/   # No match
.Ve
.Sp
fails, because the \f(CW\*(C`\eR\*(C'\fR matches the entire string, and won't backtrack
to match just the \f(CW"\ex0D"\fR.)  Since
\&\f(CW\*(C`\eR\*(C'\fR can match a sequence of more than one character, it cannot be put
inside a bracketed character class; \f(CW\*(C`/[\eR]/\*(C'\fR is an error; use \f(CW\*(C`\ev\*(C'\fR
instead.  \f(CW\*(C`\eR\*(C'\fR was introduced in perl 5.10.0.
.Sp
Note that this does not respect any locale that might be in effect; it
matches according to the platform's native character set.
.Sp
Mnemonic: none really. \f(CW\*(C`\eR\*(C'\fR was picked because \s-1PCRE\s0 already uses \f(CW\*(C`\eR\*(C'\fR,
and more importantly because Unicode recommends such a regular expression
metacharacter, and suggests \f(CW\*(C`\eR\*(C'\fR as its notation.
.IP "\eX" 4
.IX Xref "\\X"
.IX Item "X"
This matches a Unicode \fIextended grapheme cluster\fR.
.Sp
\&\f(CW\*(C`\eX\*(C'\fR matches quite well what normal (non-Unicode-programmer) usage
would consider a single character.  As an example, consider a G with some sort
of diacritic mark, such as an arrow.  There is no such single character in
Unicode, but one can be composed by using a G followed by a Unicode \*(L"\s-1COMBINING
UPWARDS ARROW BELOW\*(R",\s0 and would be displayed by Unicode-aware software as if it
were a single character.
.Sp
Mnemonic: e\fIX\fRtended Unicode character.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 2
\& "\ex{256}" =~ /^\eC\eC$/;    # Match as chr (0x256) takes 
\&                           # 2 octets in UTF\-8.
\&
\& $str =~ s/foo\eKbar/baz/g; # Change any \*(Aqbar\*(Aq following a \*(Aqfoo\*(Aq to \*(Aqbaz\*(Aq
\& $str =~ s/(.)\eK\eg1//g;    # Delete duplicated characters.
\&
\& "\en"   =~ /^\eR$/;         # Match, \en   is a generic newline.
\& "\er"   =~ /^\eR$/;         # Match, \er   is a generic newline.
\& "\er\en" =~ /^\eR$/;         # Match, \er\en is a generic newline.
\&
\& "P\ex{307}" =~ /^\eX$/     # \eX matches a P with a dot above.
.Ve
                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrecharclass.1                            0100644 0001750 0001750 00000154624 12566207444 024133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRECHARCLASS 1"
.TH PERLRECHARCLASS 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrecharclass \- Perl Regular Expression Character Classes
.IX Xref "character class"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This manual page discusses the syntax and use of character
classes in Perl regular expressions.
.PP
A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)
.PP
There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term \*(L"character class\*(R" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.
.SS "The dot"
.IX Subsection "The dot"
The dot (or period), \f(CW\*(C`.\*(C'\fR is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. That default can be changed to
add matching the newline by using the \fIsingle line\fR modifier: either
for the entire regular expression with the \f(CW\*(C`/s\*(C'\fR modifier, or
locally with \f(CW\*(C`(?s)\*(C'\fR.  (The \f(CW\*(C`\eN\*(C'\fR backslash sequence, described
below, matches any character except newline without regard to the
\&\fIsingle line\fR modifier.)
.PP
Here are some examples:
.PP
.Vb 7
\& "a"  =~  /./       # Match
\& "."  =~  /./       # Match
\& ""   =~  /./       # No match (dot has to match a character)
\& "\en" =~  /./       # No match (dot does not match a newline)
\& "\en" =~  /./s      # Match (global \*(Aqsingle line\*(Aq modifier)
\& "\en" =~  /(?s:.)/  # Match (local \*(Aqsingle line\*(Aq modifier)
\& "ab" =~  /^.$/     # No match (dot matches one character)
.Ve
.SS "Backslash sequences"
.IX Xref "\\w \\W \\s \\S \\d \\D \\p \\P \\N \\v \\V \\h \\H word whitespace"
.IX Subsection "Backslash sequences"
A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.
.PP
Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see perlrebackslash.)
.PP
.Vb 10
\& \ed             Match a decimal digit character.
\& \eD             Match a non\-decimal\-digit character.
\& \ew             Match a "word" character.
\& \eW             Match a non\-"word" character.
\& \es             Match a whitespace character.
\& \eS             Match a non\-whitespace character.
\& \eh             Match a horizontal whitespace character.
\& \eH             Match a character that isn\*(Aqt horizontal whitespace.
\& \ev             Match a vertical whitespace character.
\& \eV             Match a character that isn\*(Aqt vertical whitespace.
\& \eN             Match a character that isn\*(Aqt a newline.
\& \epP, \ep{Prop}  Match a character that has the given Unicode property.
\& \ePP, \eP{Prop}  Match a character that doesn\*(Aqt have the Unicode property
.Ve
.PP
\fI\eN\fR
.IX Subsection "N"
.PP
\&\f(CW\*(C`\eN\*(C'\fR, available starting in v5.12, like the dot, matches any
character that is not a newline. The difference is that \f(CW\*(C`\eN\*(C'\fR is not influenced
by the \fIsingle line\fR regular expression modifier (see \*(L"The dot\*(R" above).  Note
that the form \f(CW\*(C`\eN{...}\*(C'\fR may mean something completely different.  When the
\&\f(CW\*(C`{...}\*(C'\fR is a quantifier, it means to match a non-newline
character that many times.  For example, \f(CW\*(C`\eN{3}\*(C'\fR means to match 3
non-newlines; \f(CW\*(C`\eN{5,}\*(C'\fR means to match 5 or more non-newlines.  But if \f(CW\*(C`{...}\*(C'\fR
is not a legal quantifier, it is presumed to be a named character.  See
charnames for those.  For example, none of \f(CW\*(C`\eN{COLON}\*(C'\fR, \f(CW\*(C`\eN{4F}\*(C'\fR, and
\&\f(CW\*(C`\eN{F4}\*(C'\fR contain legal quantifiers, so Perl will try to find characters whose
names are respectively \f(CW\*(C`COLON\*(C'\fR, \f(CW\*(C`4F\*(C'\fR, and \f(CW\*(C`F4\*(C'\fR.
.PP
\fIDigits\fR
.IX Subsection "Digits"
.PP
\&\f(CW\*(C`\ed\*(C'\fR matches a single character considered to be a decimal \fIdigit\fR.
If the \f(CW\*(C`/a\*(C'\fR regular expression modifier is in effect, it matches [0\-9].
Otherwise, it
matches anything that is matched by \f(CW\*(C`\ep{Digit}\*(C'\fR, which includes [0\-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have [0\-9] matched by \f(CW\*(C`\ed\*(C'\fR, and/or might match
other characters whose code point is less than 256.  Such a locale
definition would be in violation of the C language standard, but Perl
doesn't currently assume anything in regard to this.)
.PP
What this means is that unless the \f(CW\*(C`/a\*(C'\fR modifier is in effect \f(CW\*(C`\ed\*(C'\fR not
only matches the digits '0' \- '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.
.PP
Some digits that \f(CW\*(C`\ed\*(C'\fR matches look like some of the [0\-9] ones, but
have different values.  For example, \s-1BENGALI DIGIT FOUR \s0(U+09EA) looks
very much like an \s-1ASCII DIGIT EIGHT \s0(U+0038).  An application that
is expecting only the \s-1ASCII\s0 digits might be misled, or if the match is
\&\f(CW\*(C`\ed+\*(C'\fR, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  \*(L"\fInum()\fR\*(R" in Unicode::UCD can
be used to safely
calculate the value, returning \f(CW\*(C`undef\*(C'\fR if the input string contains
such a mixture.
.PP
What \f(CW\*(C`\ep{Digit}\*(C'\fR means (and hence \f(CW\*(C`\ed\*(C'\fR except under the \f(CW\*(C`/a\*(C'\fR
modifier) is \f(CW\*(C`\ep{General_Category=Decimal_Number}\*(C'\fR, or synonymously,
\&\f(CW\*(C`\ep{General_Category=Digit}\*(C'\fR.  Starting with Unicode version 4.1, this
is the same set of characters matched by \f(CW\*(C`\ep{Numeric_Type=Decimal}\*(C'\fR.
But Unicode also has a different property with a similar name,
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, which matches a completely different set of
characters.  These characters are things such as \f(CW\*(C`CIRCLED DIGIT ONE\*(C'\fR
or subscripts, or are from writing systems that lack all ten digits.
.PP
The design intent is for \f(CW\*(C`\ed\*(C'\fR to exactly match the set of characters
that can safely be used with \*(L"normal\*(R" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of \*(L"digit\*(R",
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, and so \f(CW\*(C`\ed\*(C'\fR doesn't match them.
.PP
The Tamil digits (U+0BE6 \- U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean \*(L"times 10\*(R", \*(L"times 100\*(R",
etc.  (See <http://www.unicode.org/notes/tn21>.)
.PP
Any character not matched by \f(CW\*(C`\ed\*(C'\fR is matched by \f(CW\*(C`\eD\*(C'\fR.
.PP
\fIWord characters\fR
.IX Subsection "Word characters"
.PP
A \f(CW\*(C`\ew\*(C'\fR matches a single alphanumeric character (an alphabetic character, or a
decimal digit); or a connecting punctuation character, such as an
underscore (\*(L"_\*(R"); or a \*(L"mark\*(R" character (like some sort of accent) that
attaches to one of those.  It does not match a whole word.  To match a
whole word, use \f(CW\*(C`\ew+\*(C'\fR.  This isn't the same thing as matching an
English word, but in the \s-1ASCII\s0 range it is the same as a string of
Perl-identifier characters.
.ie n .IP "If the ""/a"" modifier is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier is in effect ..." 4
.IX Item "If the /a modifier is in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches the 63 characters [a\-zA\-Z0\-9_].
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches the same as \f(CW\*(C`\ep{Word}\*(C'\fR matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a \f(CW\*(C`COMBINING TILDE\*(C'\fR and the modifier letters, which
are generally used to add auxiliary markings to letters.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.
.IP "if Unicode rules are in effect ..." 4
.IX Item "if Unicode rules are in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches exactly what \f(CW\*(C`\ep{Word}\*(C'\fR matches.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\ew\*(C'\fR matches [a\-zA\-Z0\-9_].
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
There are a number of security issues with the full Unicode list of word
characters.  See <http://unicode.org/reports/tr36>.
.PP
Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the \s-1ASCII\s0 range, you may wish to instead use the
more customized \*(L"Unicode Properties\*(R", \f(CW\*(C`\ep{ID_Start}\*(C'\fR,
\&\f(CW\*(C`\ep{ID_Continue}\*(C'\fR, \f(CW\*(C`\ep{XID_Start}\*(C'\fR, and \f(CW\*(C`\ep{XID_Continue}\*(C'\fR.  See
<http://unicode.org/reports/tr31>.
.PP
Any character not matched by \f(CW\*(C`\ew\*(C'\fR is matched by \f(CW\*(C`\eW\*(C'\fR.
.PP
\fIWhitespace\fR
.IX Subsection "Whitespace"
.PP
\&\f(CW\*(C`\es\*(C'\fR matches any single character considered whitespace.
.ie n .IP "If the ""/a"" modifier is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier is in effect ..." 4
.IX Item "If the /a modifier is in effect ..."
In all Perl versions, \f(CW\*(C`\es\*(C'\fR matches the 5 characters [\et\en\ef\er ]; that
is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.
Starting in Perl v5.18, experimentally, it also matches the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
See note \f(CW\*(C`[1]\*(C'\fR below for a discussion of this.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches exactly the code points above 255 shown with an \*(L"s\*(R" column
in the table below.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches whatever the locale considers to be whitespace.
.IP "if Unicode rules are in effect ..." 4
.IX Item "if Unicode rules are in effect ..."
\&\f(CW\*(C`\es\*(C'\fR matches exactly the characters shown with an \*(L"s\*(R" column in the
table below.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\es\*(C'\fR matches [\et\en\ef\er\ecK ] and, starting, experimentally in Perl
v5.18, the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
(See note \f(CW\*(C`[1]\*(C'\fR below for a discussion of this.)
Note that this list doesn't include the non-breaking space.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
Any character not matched by \f(CW\*(C`\es\*(C'\fR is matched by \f(CW\*(C`\eS\*(C'\fR.
.PP
\&\f(CW\*(C`\eh\*(C'\fR matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  \f(CW\*(C`\eH\*(C'\fR matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.
.PP
\&\f(CW\*(C`\ev\*(C'\fR matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
\&\f(CW\*(C`\eV\*(C'\fR matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.
.PP
\&\f(CW\*(C`\eR\*(C'\fR matches anything that can be considered a newline under Unicode
rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class; use \f(CW\*(C`\ev\*(C'\fR instead (vertical whitespace).  It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
Details are discussed in perlrebackslash.
.PP
Note that unlike \f(CW\*(C`\es\*(C'\fR (and \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR), \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in \s-1UTF\-8\s0 format.
.PP
One might think that \f(CW\*(C`\es\*(C'\fR is equivalent to \f(CW\*(C`[\eh\ev]\*(C'\fR. This is indeed true
starting in Perl v5.18, but prior to that, the sole difference was that the
vertical tab (\f(CW"\ecK"\fR) was not matched by \f(CW\*(C`\es\*(C'\fR.
.PP
The following table is a complete listing of characters matched by
\&\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR as of Unicode 6.0.
.PP
The first column gives the Unicode code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale is in
effect that changes the \f(CW\*(C`\es\*(C'\fR matching).
.PP
.Vb 10
\& 0x0009        CHARACTER TABULATION   h s
\& 0x000a              LINE FEED (LF)    vs
\& 0x000b             LINE TABULATION    vs  [1]
\& 0x000c              FORM FEED (FF)    vs
\& 0x000d        CARRIAGE RETURN (CR)    vs
\& 0x0020                       SPACE   h s
\& 0x0085             NEXT LINE (NEL)    vs  [2]
\& 0x00a0              NO\-BREAK SPACE   h s  [2]
\& 0x1680            OGHAM SPACE MARK   h s
\& 0x180e   MONGOLIAN VOWEL SEPARATOR   h s
\& 0x2000                     EN QUAD   h s
\& 0x2001                     EM QUAD   h s
\& 0x2002                    EN SPACE   h s
\& 0x2003                    EM SPACE   h s
\& 0x2004          THREE\-PER\-EM SPACE   h s
\& 0x2005           FOUR\-PER\-EM SPACE   h s
\& 0x2006            SIX\-PER\-EM SPACE   h s
\& 0x2007                FIGURE SPACE   h s
\& 0x2008           PUNCTUATION SPACE   h s
\& 0x2009                  THIN SPACE   h s
\& 0x200a                  HAIR SPACE   h s
\& 0x2028              LINE SEPARATOR    vs
\& 0x2029         PARAGRAPH SEPARATOR    vs
\& 0x202f       NARROW NO\-BREAK SPACE   h s
\& 0x205f   MEDIUM MATHEMATICAL SPACE   h s
\& 0x3000           IDEOGRAPHIC SPACE   h s
.Ve
.IP "[1]" 4
.IX Item "[1]"
Prior to Perl v5.18, \f(CW\*(C`\es\*(C'\fR did not match the vertical tab.  The change
in v5.18 is considered an experiment, which means it could be backed out
in v5.20 or v5.22 if experience indicates that it breaks too much
existing code.  If this change adversely affects you, send email to
\&\f(CW\*(C`perlbug@perl.org\*(C'\fR; if it affects you positively, email
\&\f(CW\*(C`perlthanks@perl.org\*(C'\fR.  In the meantime, \f(CW\*(C`[^\eS\ecK]\*(C'\fR (obscurely)
matches what \f(CW\*(C`\es\*(C'\fR traditionally did.
.IP "[2]" 4
.IX Item "[2]"
\&\s-1NEXT LINE\s0 and NO-BREAK \s-1SPACE\s0 may or may not match \f(CW\*(C`\es\*(C'\fR depending
on the rules in effect.  See
the beginning of this section.
.PP
\fIUnicode Properties\fR
.IX Subsection "Unicode Properties"
.PP
\&\f(CW\*(C`\epP\*(C'\fR and \f(CW\*(C`\ep{Prop}\*(C'\fR are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the \f(CW\*(C`\epP\*(C'\fR form,
with the property name following the \f(CW\*(C`\ep\*(C'\fR, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like \f(CW\*(C`\ep{name=value}\*(C'\fR,
which means to match if the property \*(L"name\*(R" for the character has that particular
\&\*(L"value\*(R".
For instance, a match for a number can be written as \f(CW\*(C`/\epN/\*(C'\fR or as
\&\f(CW\*(C`/\ep{Number}/\*(C'\fR, or as \f(CW\*(C`/\ep{Number=True}/\*(C'\fR.
Lowercase letters are matched by the property \fILowercase_Letter\fR which
has the short form \fILl\fR. They need the braces, so are written as \f(CW\*(C`/\ep{Ll}/\*(C'\fR or
\&\f(CW\*(C`/\ep{Lowercase_Letter}/\*(C'\fR, or \f(CW\*(C`/\ep{General_Category=Lowercase_Letter}/\*(C'\fR
(the underscores are optional).
\&\f(CW\*(C`/\epLl/\*(C'\fR is valid, but means something different.
It matches a two character string: a letter (Unicode property \f(CW\*(C`\epL\*(C'\fR),
followed by a lowercase \f(CW\*(C`l\*(C'\fR.
.PP
If locale rules are not in effect, the use of
a Unicode property will force the regular expression into using Unicode
rules, if it isn't already.
.PP
Note that almost all properties are immune to case-insensitive matching.
That is, adding a \f(CW\*(C`/i\*(C'\fR regular expression modifier does not change what
they match.  There are two sets that are affected.  The first set is
\&\f(CW\*(C`Uppercase_Letter\*(C'\fR,
\&\f(CW\*(C`Lowercase_Letter\*(C'\fR,
and \f(CW\*(C`Titlecase_Letter\*(C'\fR,
all of which match \f(CW\*(C`Cased_Letter\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
The second set is
\&\f(CW\*(C`Uppercase\*(C'\fR,
\&\f(CW\*(C`Lowercase\*(C'\fR,
and \f(CW\*(C`Titlecase\*(C'\fR,
all of which match \f(CW\*(C`Cased\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are \f(CW\*(C`Cased\*(C'\fR, but
aren't considered to be letters, so they aren't \f(CW\*(C`Cased_Letter\*(C'\fRs. They're
actually \f(CW\*(C`Letter_Number\*(C'\fRs.)
This set also includes its subsets \f(CW\*(C`PosixUpper\*(C'\fR and \f(CW\*(C`PosixLower\*(C'\fR, both
of which under \f(CW\*(C`/i\*(C'\fR match \f(CW\*(C`PosixAlpha\*(C'\fR.
.PP
For more details on Unicode properties, see \*(L"Unicode
Character Properties\*(R" in perlunicode; for a
complete list of possible properties, see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops,
which notes all forms that have \f(CW\*(C`/i\*(C'\fR differences.
It is also possible to define your own properties. This is discussed in
\&\*(L"User-Defined Character Properties\*(R" in perlunicode.
.PP
Unicode properties are defined (surprise!) only on Unicode code points.
A warning is raised and all matches fail on non-Unicode code points
(those above the legal Unicode maximum of 0x10FFFF).  This can be
somewhat surprising,
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Also fails!
.Ve
.PP
Even though these two matches might be thought of as complements, they
are so only on Unicode code points.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 8
\& "a"  =~  /\ew/      # Match, "a" is a \*(Aqword\*(Aq character.
\& "7"  =~  /\ew/      # Match, "7" is a \*(Aqword\*(Aq character as well.
\& "a"  =~  /\ed/      # No match, "a" isn\*(Aqt a digit.
\& "7"  =~  /\ed/      # Match, "7" is a digit.
\& " "  =~  /\es/      # Match, a space is whitespace.
\& "a"  =~  /\eD/      # Match, "a" is a non\-digit.
\& "7"  =~  /\eD/      # No match, "7" is not a non\-digit.
\& " "  =~  /\eS/      # No match, a space is not non\-whitespace.
\&
\& " "  =~  /\eh/      # Match, space is horizontal whitespace.
\& " "  =~  /\ev/      # No match, space is not vertical whitespace.
\& "\er" =~  /\ev/      # Match, a return is vertical whitespace.
\&
\& "a"  =~  /\epL/     # Match, "a" is a letter.
\& "a"  =~  /\ep{Lu}/  # No match, /\ep{Lu}/ matches upper case letters.
\&
\& "\ex{0e0b}" =~ /\ep{Thai}/  # Match, \ex{0e0b} is the character
\&                           # \*(AqTHAI CHARACTER SO SO\*(Aq, and that\*(Aqs in
\&                           # Thai Unicode class.
\& "a"  =~  /\eP{Lao}/ # Match, as "a" is not a Laotian character.
.Ve
.PP
It is worth emphasizing that \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use \f(CW\*(C`\ed+\*(C'\fR; to match a word, use \f(CW\*(C`\ew+\*(C'\fR.  But be aware of the security
considerations in doing so, as mentioned above.
.SS "Bracketed Character Classes"
.IX Subsection "Bracketed Character Classes"
The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: \f(CW\*(C`[aeiou]\*(C'\fR.
This matches one of \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`o\*(C'\fR or \f(CW\*(C`u\*(C'\fR.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a quantifier.  For
instance, \f(CW\*(C`[aeiou]+\*(C'\fR matches one or more lowercase English vowels.
.PP
Repeating a character in a character class has no
effect; it's considered to be in the set only once.
.PP
Examples:
.PP
.Vb 5
\& "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
\& "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
\& "ae" =~  /^[aeiou]$/      # No match, a character class only matches
\&                           # a single character.
\& "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.
\&
\& \-\-\-\-\-\-\-
.Ve
.PP
* There is an exception to a bracketed character class matching a
single character only.  When the class is to match caselessly under \f(CW\*(C`/i\*(C'\fR
matching rules, and a character that is explicitly mentioned inside the
class matches a
multiple-character sequence caselessly under Unicode rules, the class
(when not inverted) will also match that sequence.  For
example, Unicode says that the letter \f(CW\*(C`LATIN SMALL LETTER SHARP S\*(C'\fR
should match the sequence \f(CW\*(C`ss\*(C'\fR under \f(CW\*(C`/i\*(C'\fR rules.  Thus,
.PP
.Vb 2
\& \*(Aqss\*(Aq =~ /\eA\eN{LATIN SMALL LETTER SHARP S}\ez/i             # Matches
\& \*(Aqss\*(Aq =~ /\eA[aeioust\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # Matches
.Ve
.PP
For this to happen, the character must be explicitly specified, and not
be part of a multi-character range (not even as one of its endpoints).
(\*(L"Character Ranges\*(R" will be explained shortly.)  Therefore,
.PP
.Vb 5
\& \*(Aqss\*(Aq =~ /\eA[\e0\-\ex{ff}]\ez/i        # Doesn\*(Aqt match
\& \*(Aqss\*(Aq =~ /\eA[\e0\-\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # No match
\& \*(Aqss\*(Aq =~ /\eA[\exDF\-\exDF]\ez/i    # Matches on ASCII platforms, since \eXDF
\&                               # is LATIN SMALL LETTER SHARP S, and the
\&                               # range is just a single element
.Ve
.PP
Note that it isn't a good idea to specify these types of ranges anyway.
.PP
\fISpecial Characters Inside a Bracketed Character Class\fR
.IX Subsection "Special Characters Inside a Bracketed Character Class"
.PP
Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`*\*(C'\fR, or \f(CW\*(C`(\*(C'\fR) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, \f(CW\*(C`[()]\*(C'\fR matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.
.PP
Characters that may carry a special meaning inside a character class are:
\&\f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.
.PP
The sequence \f(CW\*(C`\eb\*(C'\fR is special inside a bracketed character class. While
outside the character class, \f(CW\*(C`\eb\*(C'\fR is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, \f(CW\*(C`\eb\*(C'\fR matches a
backspace character.
.PP
The sequences
\&\f(CW\*(C`\ea\*(C'\fR,
\&\f(CW\*(C`\ec\*(C'\fR,
\&\f(CW\*(C`\ee\*(C'\fR,
\&\f(CW\*(C`\ef\*(C'\fR,
\&\f(CW\*(C`\en\*(C'\fR,
\&\f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR,
\&\f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR,
\&\f(CW\*(C`\er\*(C'\fR,
\&\f(CW\*(C`\et\*(C'\fR,
and
\&\f(CW\*(C`\ex\*(C'\fR
are also special and have the same meanings as they do outside a
bracketed character class.  (However, inside a bracketed character
class, if \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR expands to a sequence of characters, only the first
one in the sequence is used, with a warning.)
.PP
Also, a backslash followed by two or three octal digits is considered an octal
number.
.PP
A \f(CW\*(C`[\*(C'\fR is not special inside a character class, unless it's the start of a
\&\s-1POSIX\s0 character class (see \*(L"\s-1POSIX\s0 Character Classes\*(R" below). It normally does
not need escaping.
.PP
A \f(CW\*(C`]\*(C'\fR is normally either the end of a \s-1POSIX\s0 character class (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" below), or it signals the end of the bracketed
character class.  If you want to include a \f(CW\*(C`]\*(C'\fR in the set of characters, you
must generally escape it.
.PP
However, if the \f(CW\*(C`]\*(C'\fR is the \fIfirst\fR (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.
.PP
Examples:
.PP
.Vb 8
\& "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
\& "\ecH" =~ /[\eb]/      #  Match, \eb inside in a character class.
\&                      #  is equivalent to a backspace.
\& "]"   =~ /[][]/      #  Match, as the character class contains.
\&                      #  both [ and ].
\& "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
\&                      #  containing just ], and the character class is
\&                      #  followed by a ].
.Ve
.PP
\fICharacter Ranges\fR
.IX Subsection "Character Ranges"
.PP
It is not uncommon to want to match a range of characters. Luckily, instead
of listing all characters in the range, one may use the hyphen (\f(CW\*(C`\-\*(C'\fR).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, \f(CW\*(C`[0\-9]\*(C'\fR matches any \s-1ASCII\s0 digit, and \f(CW\*(C`[a\-m]\*(C'\fR
matches any lowercase letter from the first half of the \s-1ASCII\s0 alphabet.
.PP
Note that the two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is possible,
although not advisable.  \f(CW\*(C`[\*(Aq\-?]\*(C'\fR contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as \s-1EBCDIC.\s0
.PP
If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.
.PP
Examples:
.PP
.Vb 8
\& [a\-z]       #  Matches a character that is a lower case ASCII letter.
\& [a\-fz]      #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive) or
\&             #  the letter \*(Aqz\*(Aq.
\& [\-z]        #  Matches either a hyphen (\*(Aq\-\*(Aq) or the letter \*(Aqz\*(Aq.
\& [a\-f\-m]     #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive), the
\&             #  hyphen (\*(Aq\-\*(Aq), or the letter \*(Aqm\*(Aq.
\& [\*(Aq\-?]       #  Matches any of the characters  \*(Aq()*+,\-./0123456789:;<=>?
\&             #  (But not on an EBCDIC platform).
.Ve
.PP
\fINegation\fR
.IX Subsection "Negation"
.PP
It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (\f(CW\*(C`^\*(C'\fR) as the first character in the
character class. For instance, \f(CW\*(C`[^a\-z]\*(C'\fR matches any character that is not a
lowercase \s-1ASCII\s0 letter, which therefore includes more than a million
Unicode code points.  The class is said to be \*(L"negated\*(R" or \*(L"inverted\*(R".
.PP
This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
the caret as one of the characters to match, either escape the caret or
else don't list it first.
.PP
In inverted bracketed character classes, Perl ignores the Unicode rules
that normally say that certain characters should match a sequence of
multiple characters under caseless \f(CW\*(C`/i\*(C'\fR matching.  Following those
rules could lead to highly confusing situations:
.PP
.Vb 1
\& "ss" =~ /^[^\exDF]+$/ui;   # Matches!
.Ve
.PP
This should match any sequences of characters that aren't \f(CW\*(C`\exDF\*(C'\fR nor
what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  \f(CW"s"\fR isn't \f(CW\*(C`\exDF\*(C'\fR, but Unicode
says that \f(CW"ss"\fR is what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  So which one
\&\*(L"wins\*(R"? Do you fail the match because the string has \f(CW\*(C`ss\*(C'\fR or accept it
because it has an \f(CW\*(C`s\*(C'\fR followed by another \f(CW\*(C`s\*(C'\fR?  Perl has chosen the
latter.
.PP
Examples:
.PP
.Vb 4
\& "e"  =~  /[^aeiou]/   #  No match, the \*(Aqe\*(Aq is listed.
\& "x"  =~  /[^aeiou]/   #  Match, as \*(Aqx\*(Aq isn\*(Aqt a lowercase vowel.
\& "^"  =~  /[^^]/       #  No match, matches anything that isn\*(Aqt a caret.
\& "^"  =~  /[x^]/       #  Match, caret is not special here.
.Ve
.PP
\fIBackslash Sequences\fR
.IX Subsection "Backslash Sequences"
.PP
You can put any backslash sequence character class (with the exception of
\&\f(CW\*(C`\eN\*(C'\fR and \f(CW\*(C`\eR\*(C'\fR) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, \f(CW\*(C`[a\-f\ed]\*(C'\fR matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.
.PP
\&\f(CW\*(C`\eN\*(C'\fR within a bracketed character class must be of the forms \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR
or \f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR, and \s-1NOT\s0 be the form that matches non-newlines,
for the same reason that a dot \f(CW\*(C`.\*(C'\fR inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.
.PP
Examples:
.PP
.Vb 4
\& /[\ep{Thai}\ed]/     # Matches a character that is either a Thai
\&                    # character, or a digit.
\& /[^\ep{Arabic}()]/  # Matches a character that is neither an Arabic
\&                    # character, nor a parenthesis.
.Ve
.PP
Backslash sequence character classes cannot form one of the endpoints
of a range.  Thus, you can't say:
.PP
.Vb 1
\& /[\ep{Thai}\-\ed]/     # Wrong!
.Ve
.PP
\fI\s-1POSIX\s0 Character Classes\fR
.IX Xref "character class \\p \\p{} alpha alnum ascii blank cntrl digit graph lower print punct space upper word xdigit"
.IX Subsection "POSIX Character Classes"
.PP
\&\s-1POSIX\s0 character classes have the form \f(CW\*(C`[:class:]\*(C'\fR, where \fIclass\fR is
name, and the \f(CW\*(C`[:\*(C'\fR and \f(CW\*(C`:]\*(C'\fR delimiters. \s-1POSIX\s0 character classes only appear
\&\fIinside\fR bracketed character classes, and are a convenient and descriptive
way of listing a group of characters.
.PP
Be careful about the syntax,
.PP
.Vb 2
\& # Correct:
\& $string =~ /[[:alpha:]]/
\&
\& # Incorrect (will warn):
\& $string =~ /[:alpha:]/
.Ve
.PP
The latter pattern would be a character class consisting of a colon,
and the letters \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR and \f(CW\*(C`h\*(C'\fR.
\&\s-1POSIX\s0 character classes can be part of a larger bracketed character class.
For example,
.PP
.Vb 1
\& [01[:alpha:]%]
.Ve
.PP
is valid and matches '0', '1', any alphabetic character, and the percent sign.
.PP
Perl recognizes the following \s-1POSIX\s0 character classes:
.PP
.Vb 10
\& alpha  Any alphabetical character ("[A\-Za\-z]").
\& alnum  Any alphanumeric character ("[A\-Za\-z0\-9]").
\& ascii  Any character in the ASCII character set.
\& blank  A GNU extension, equal to a space or a horizontal tab ("\et").
\& cntrl  Any control character.  See Note [2] below.
\& digit  Any decimal digit ("[0\-9]"), equivalent to "\ed".
\& graph  Any printable character, excluding a space.  See Note [3] below.
\& lower  Any lowercase character ("[a\-z]").
\& print  Any printable character, including a space.  See Note [4] below.
\& punct  Any graphical character excluding "word" characters.  Note [5].
\& space  Any whitespace character. "\es" including the vertical tab
\&        ("\ecK").
\& upper  Any uppercase character ("[A\-Z]").
\& word   A Perl extension ("[A\-Za\-z0\-9_]"), equivalent to "\ew".
\& xdigit Any hexadecimal digit ("[0\-9a\-fA\-F]").
.Ve
.PP
Most \s-1POSIX\s0 character classes have two Unicode-style \f(CW\*(C`\ep\*(C'\fR property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between \s-1POSIX\s0 character classes and these counterparts.
.PP
One counterpart, in the column labelled \*(L"ASCII-range Unicode\*(R" in
the table, matches only characters in the \s-1ASCII\s0 character set.
.PP
The other counterpart, in the column labelled \*(L"Full-range Unicode\*(R", matches any
appropriate characters in the full Unicode character set.  For example,
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR matches not just the \s-1ASCII\s0 alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
An entry in the column labelled \*(L"backslash sequence\*(R" is a (short)
equivalent.
.PP
.Vb 10
\& [[:...:]]      ASCII\-range          Full\-range  backslash  Note
\&                 Unicode              Unicode     sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   alpha      \ep{PosixAlpha}       \ep{XPosixAlpha}
\&   alnum      \ep{PosixAlnum}       \ep{XPosixAlnum}
\&   ascii      \ep{ASCII}
\&   blank      \ep{PosixBlank}       \ep{XPosixBlank}  \eh      [1]
\&                                   or \ep{HorizSpace}        [1]
\&   cntrl      \ep{PosixCntrl}       \ep{XPosixCntrl}          [2]
\&   digit      \ep{PosixDigit}       \ep{XPosixDigit}  \ed
\&   graph      \ep{PosixGraph}       \ep{XPosixGraph}          [3]
\&   lower      \ep{PosixLower}       \ep{XPosixLower}
\&   print      \ep{PosixPrint}       \ep{XPosixPrint}          [4]
\&   punct      \ep{PosixPunct}       \ep{XPosixPunct}          [5]
\&              \ep{PerlSpace}        \ep{XPerlSpace}   \es      [6]
\&   space      \ep{PosixSpace}       \ep{XPosixSpace}          [6]
\&   upper      \ep{PosixUpper}       \ep{XPosixUpper}
\&   word       \ep{PosixWord}        \ep{XPosixWord}   \ew
\&   xdigit     \ep{PosixXDigit}      \ep{XPosixXDigit}
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\ep{Blank}\*(C'\fR and \f(CW\*(C`\ep{HorizSpace}\*(C'\fR are synonyms.
.IP "[2]" 4
.IX Item "[2]"
Control characters don't produce output as such, but instead usually control
the terminal somehow: for example, newline and backspace are control characters.
In the \s-1ASCII\s0 range, characters whose code points are between 0 and 31 inclusive,
plus 127 (\f(CW\*(C`DEL\*(C'\fR) are control characters.
.IP "[3]" 4
.IX Item "[3]"
Any character that is \fIgraphical\fR, that is, visible. This class consists
of all alphanumeric characters and all punctuation characters.
.IP "[4]" 4
.IX Item "[4]"
All printable characters, which is the set of all graphical characters
plus those whitespace characters which are not also controls.
.IP "[5]" 4
.IX Item "[5]"
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR and \f(CW\*(C`[[:punct:]]\*(C'\fR in the \s-1ASCII\s0 range match all
non-controls, non-alphanumeric, non-space characters:
\&\f(CW\*(C`[\-!"#$%&\*(Aq()*+,./:;<=>?@[\e\e\e]^_\`{|}~]\*(C'\fR (although if a locale is in effect,
it could alter the behavior of \f(CW\*(C`[[:punct:]]\*(C'\fR).
.Sp
The similarly named property, \f(CW\*(C`\ep{Punct}\*(C'\fR, matches a somewhat different
set in the \s-1ASCII\s0 range, namely
\&\f(CW\*(C`[\-!"#%&\*(Aq()*,./:;?@[\e\e\e]_{}]\*(C'\fR.  That is, it is missing the nine
characters \f(CW\*(C`[$+<=>^\`|~]\*(C'\fR.
This is because Unicode splits what \s-1POSIX\s0 considers to be punctuation into two
categories, Punctuation and Symbols.
.Sp
\&\f(CW\*(C`\ep{XPosixPunct}\*(C'\fR and (under Unicode rules) \f(CW\*(C`[[:punct:]]\*(C'\fR, match what
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR matches in the \s-1ASCII\s0 range, plus what \f(CW\*(C`\ep{Punct}\*(C'\fR
matches.  This is different than strictly matching according to
\&\f(CW\*(C`\ep{Punct}\*(C'\fR.  Another way to say it is that
if Unicode rules are in effect, \f(CW\*(C`[[:punct:]]\*(C'\fR matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.
.IP "[6]" 4
.IX Item "[6]"
\&\f(CW\*(C`\ep{SpacePerl}\*(C'\fR and \f(CW\*(C`\ep{Space}\*(C'\fR match identically starting with Perl
v5.18.  In earlier versions, these differ only in that in non-locale
matching, \f(CW\*(C`\ep{SpacePerl}\*(C'\fR does not match the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
Same for the two ASCII-only range forms.
.PP
There are various other synonyms that can be used besides the names
listed in the table.  For example, \f(CW\*(C`\ep{PosixAlpha}\*(C'\fR can be written as
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR.  All are listed in
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops,
plus all characters matched by each ASCII-range property.
.PP
Both the \f(CW\*(C`\ep\*(C'\fR counterparts always assume Unicode rules are in effect.
On \s-1ASCII\s0 platforms, this means they assume that the code points from 128
to 255 are Latin\-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin\-1 or \s-1UTF\-8. \s0 In contrast, the
\&\s-1POSIX\s0 character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:
.ie n .IP "If the ""/a"" modifier, is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier, is in effect ..." 4
.IX Item "If the /a modifier, is in effect ..."
Each of the \s-1POSIX\s0 classes matches exactly the same as their ASCII-r