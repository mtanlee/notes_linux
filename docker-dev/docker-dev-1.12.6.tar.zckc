 paths before the gem_prelude.rb paths
  # so you can override the gem_prelude.rb default $LOAD_PATH paths.

  def self.load_path_insert_index
    index = $LOAD_PATH.index ConfigMap[:sitelibdir]

    index
  end

  @yaml_loaded = false

  ##
  # Loads YAML, preferring Psych

  def self.load_yaml
    return if @yaml_loaded
    return unless defined?(gem)

    test_syck = ENV['TEST_SYCK']

    unless test_syck
      begin
        gem 'psych', '~> 1.2', '>= 1.2.1'
      rescue Gem::LoadError
        # It's OK if the user does not have the psych gem installed.  We will
        # attempt to require the stdlib version
      end

      begin
        # Try requiring the gem version *or* stdlib version of psych.
        require 'psych'
      rescue ::LoadError
        # If we can't load psych, thats fine, go on.
      else
        # If 'yaml' has already been required, then we have to
        # be sure to switch it over to the newly loaded psych.
        if defined?(YAML::ENGINE) && YAML::ENGINE.yamler != "psych"
          YAML::ENGINE.yamler = "psych"
        end

        require 'rubygems/psych_additions'
        require 'rubygems/psych_tree'
      end
    end

    require 'yaml'

    # If we're supposed to be using syck, then we may have to force
    # activate it via the YAML::ENGINE API.
    if test_syck and defined?(YAML::ENGINE)
      YAML::ENGINE.yamler = "syck" unless YAML::ENGINE.syck?
    end

    # Now that we're sure some kind of yaml library is loaded, pull
    # in our hack to deal with Syck's DefaultKey ugliness.
    require 'rubygems/syck_hack'

    @yaml_loaded = true
  end

  ##
  # The file name and line number of the caller of the caller of this method.

  def self.location_of_caller
    caller[1] =~ /(.*?):(\d+).*?$/i
    file = $1
    lineno = $2.to_i

    # TODO: it is ALWAYS joined! STUPID!
    [file, lineno]
  end

  ##
  # The version of the Marshal format for your Ruby.

  def self.marshal_version
    "#{Marshal::MAJOR_VERSION}.#{Marshal::MINOR_VERSION}"
  end

  ##
  # Set array of platforms this RubyGems supports (primarily for testing).

  def self.platforms=(platforms)
    @platforms = platforms
  end

  ##
  # Array of platforms this RubyGems supports.

  def self.platforms
    @platforms ||= []
    if @platforms.empty?
      @platforms = [Gem::Platform::RUBY, Gem::Platform.local]
    end
    @platforms
  end

  ##
  # Adds a post-build hook that will be passed an Gem::Installer instance
  # when Gem::Installer#install is called.  The hook is called after the gem
  # has been extracted and extensions have been built but before the
  # executables or gemspec has been written.  If the hook returns +false+ then
  # the gem's files will be removed and the install will be aborted.

  def self.post_build(&hook)
    @post_build_hooks << hook
  end

  ##
  # Adds a post-install hook that will be passed an Gem::Installer instance
  # when Gem::Installer#install is called

  def self.post_install(&hook)
    @post_install_hooks << hook
  end

  ##
  # Adds a post-installs hook that will be passed a Gem::DependencyInstaller
  # and a list of installed specifications when
  # Gem::DependencyInstaller#install is complete

  def self.done_installing(&hook)
    @done_installing_hooks << hook
  end

  ##
  # Adds a hook that will get run after Gem::Specification.reset is
  # run.

  def self.post_reset(&hook)
    @post_reset_hooks << hook
  end

  ##
  # Adds a post-uninstall hook that will be passed a Gem::Uninstaller instance
  # and the spec that was uninstalled when Gem::Uninstaller#uninstall is
  # called

  def self.post_uninstall(&hook)
    @post_uninstall_hooks << hook
  end

  ##
  # Adds a pre-install hook that will be passed an Gem::Installer instance
  # when Gem::Installer#install is called.  If the hook returns +false+ then
  # the install will be aborted.

  def self.pre_install(&hook)
    @pre_install_hooks << hook
  end

  ##
  # Adds a hook that will get run before Gem::Specification.reset is
  # run.

  def self.pre_reset(&hook)
    @pre_reset_hooks << hook
  end

  ##
  # Adds a pre-uninstall hook that will be passed an Gem::Uninstaller instance
  # and the spec that will be uninstalled when Gem::Uninstaller#uninstall is
  # called

  def self.pre_uninstall(&hook)
    @pre_uninstall_hooks << hook
  end

  ##
  # The directory prefix this RubyGems was installed at. If your
  # prefix is in a standard location (ie, rubygems is installed where
  # you'd expect it to be), then prefix returns nil.

  def self.prefix
    prefix = File.dirname RUBYGEMS_DIR

    if prefix != File.expand_path(ConfigMap[:sitelibdir]) and
       prefix != File.expand_path(ConfigMap[:libdir]) and
       'lib' == File.basename(RUBYGEMS_DIR) then
      prefix
    end
  end

  ##
  # Refresh available gems from disk.

  def self.refresh
    Gem::Specification.reset
  end

  ##
  # Safely read a file in binary mode on all platforms.

  def self.read_binary(path)
    File.open path, binary_mode do |f| f.read end
  end

  ##
  # The path to the running Ruby interpreter.

  def self.ruby
    if @ruby.nil? then
      @ruby = File.join(ConfigMap[:bindir],
                        "#{ConfigMap[:ruby_install_name]}#{ConfigMap[:EXEEXT]}")

      @ruby = "\"#{@ruby}\"" if @ruby =~ /\s/
    end

    @ruby
  end

  ##
  # Returns the latest release-version specification for the gem +name+.

  def self.latest_spec_for name
    dependency   = Gem::Dependency.new name
    fetcher      = Gem::SpecFetcher.fetcher
    spec_tuples, = fetcher.spec_for_dependency dependency

    spec, = spec_tuples.first

    spec
  end

  ##
  # Returns the latest release version of RubyGems.

  def self.latest_rubygems_version
    latest_version_for('rubygems-update') or
      raise "Can't find 'rubygems-update' in any repo. Check `gem source list`."
  end

  ##
  # Returns the version of the latest release-version of gem +name+

  def self.latest_version_for name
    spec = latest_spec_for name
    spec and spec.version
  end

  ##
  # A Gem::Version for the currently running ruby.

  def self.ruby_version
    return @ruby_version if defined? @ruby_version
    version = RUBY_VERSION.dup

    if defined?(RUBY_PATCHLEVEL) && RUBY_PATCHLEVEL != -1 then
      version << ".#{RUBY_PATCHLEVEL}"
    elsif defined?(RUBY_REVISION) then
      version << ".dev.#{RUBY_REVISION}"
    end

    @ruby_version = Gem::Version.new version
  end

  ##
  # A Gem::Version for the currently running RubyGems

  def self.rubygems_version
    return @rubygems_version if defined? @rubygems_version
    @rubygems_version = Gem::Version.new Gem::VERSION
  end

  ##
  # Returns an Array of sources to fetch remote gems from. Uses
  # default_sources if the sources list is empty.

  def self.sources
    @sources ||= Gem::SourceList.from(default_sources)
  end

  ##
  # Need to be able to set the sources without calling
  # Gem.sources.replace since that would cause an infinite loop.
  #
  # DOC: This comment is not documentation about the method itself, it's
  # more of a code comment about the implementation.

  def self.sources= new_sources
    if !new_sources
      @sources = nil
    else
      @sources = Gem::SourceList.from(new_sources)
    end
  end

  ##
  # Glob pattern for require-able path suffixes.

  def self.suffix_pattern
    @suffix_pattern ||= "{#{suffixes.join(',')}}"
  end

  ##
  # Suffixes for require-able paths.

  def self.suffixes
    @suffixes ||= ['',
                   '.rb',
                   *%w(DLEXT DLEXT2).map { |key|
                     val = RbConfig::CONFIG[key]
                     next unless val and not val.empty?
                     ".#{val}"
                   }
                  ].compact.uniq
  end

  ##
  # Prints the amount of time the supplied block takes to run using the debug
  # UI output.

  def self.time(msg, width = 0, display = Gem.configuration.verbose)
    now = Time.now

    value = yield

    elapsed = Time.now - now

    ui.say "%2$*1$s: %3$3.3fs" % [-width, msg, elapsed] if display

    value
  end

  ##
  # Lazily loads DefaultUserInteraction and returns the default UI.

  def self.ui
    require 'rubygems/user_interaction'

    Gem::DefaultUserInteraction.ui
  end

  ##
  # Use the +home+ and +paths+ values for Gem.dir and Gem.path.  Used mainly
  # by the unit tests to provide environment isolation.

  def self.use_paths(home, *paths)
    paths = nil if paths == [nil]
    paths = paths.first if Array === Array(paths).first
    self.paths = { "GEM_HOME" => home, "GEM_PATH" => paths }
    # TODO: self.paths = home, paths
  end

  ##
  # The home directory for the user.

  def self.user_home
    @user_home ||= find_home.untaint
  end

  ##
  # Is this a windows platform?

  def self.win_platform?
    if @@win_platform.nil? then
      ruby_platform = RbConfig::CONFIG['host_os']
      @@win_platform = !!WIN_PATTERNS.find { |r| ruby_platform =~ r }
    end

    @@win_platform
  end

  ##
  # Load +plugins+ as ruby files

  def self.load_plugin_files(plugins)
    plugins.each do |plugin|

      # Skip older versions of the GemCutter plugin: Its commands are in
      # RubyGems proper now.

      next if plugin =~ /gemcutter-0\.[0-3]/

      begin
        load plugin
      rescue ::Exception => e
        details = "#{plugin.inspect}: #{e.message} (#{e.class})"
        warn "Error loading RubyGems plugin #{details}"
      end
    end
  end

  ##
  # Find all 'rubygems_plugin' files in installed gems and load them

  def self.load_plugins
    load_plugin_files find_files('rubygems_plugin', false)
  end

  ##
  # Find all 'rubygems_plugin' files in $LOAD_PATH and load them

  def self.load_env_plugins
    path = "rubygems_plugin"

    files = []
    $LOAD_PATH.each do |load_path|
      globbed = Dir["#{File.expand_path path, load_path}#{Gem.suffix_pattern}"]

      globbed.each do |load_path_file|
        files << load_path_file if File.file?(load_path_file.untaint)
      end
    end

    load_plugin_files files
  end

  # FIX: Almost everywhere else we use the `def self.` way of defining class
  # methods, and then we switch over to `class << self` here. Pick one or the
  # other.
  class << self

    ##
    # Hash of loaded Gem::Specification keyed by name

    attr_reader :loaded_specs

    ##
    # Register a Gem::Specification for default gem

    def register_default_spec(spec)
      spec.files.each do |file|
        @path_to_default_spec_map[file] = spec
      end
    end

    ##
    # Find a Gem::Specification of default gem from +path+

    def find_unresolved_default_spec(path)
      Gem.suffixes.each do |suffix|
        spec = @path_to_default_spec_map["#{path}#{suffix}"]
        return spec if spec
      end
      nil
    end

    ##
    # Remove needless Gem::Specification of default gem from
    # unresolved default gem list

    def remove_unresolved_default_spec(spec)
      spec.files.each do |file|
        @path_to_default_spec_map.delete(file)
      end
    end

    ##
    # Clear default gem related varibles. It is for test

    def clear_default_specs
      @path_to_default_spec_map.clear
    end

    ##
    # The list of hooks to be run after Gem::Installer#install extracts files
    # and builds extensions

    attr_reader :post_build_hooks

    ##
    # The list of hooks to be run after Gem::Installer#install completes
    # installation

    attr_reader :post_install_hooks

    ##
    # The list of hooks to be run after Gem::DependencyInstaller installs a
    # set of gems

    attr_reader :done_installing_hooks

    ##
    # The list of hooks to be run after Gem::Specification.reset is run.

    attr_reader :post_reset_hooks

    ##
    # The list of hooks to be run after Gem::Uninstaller#uninstall completes
    # installation

    attr_reader :post_uninstall_hooks

    ##
    # The list of hooks to be run before Gem::Installer#install does any work

    attr_reader :pre_install_hooks

    ##
    # The list of hooks to be run before Gem::Specification.reset is run.

    attr_reader :pre_reset_hooks

    ##
    # The list of hooks to be run before Gem::Uninstaller#uninstall does any
    # work

    attr_reader :pre_uninstall_hooks
  end

  ##
  # Location of Marshal quick gemspecs on remote repositories

  MARSHAL_SPEC_DIR = "quick/Marshal.#{Gem.marshal_version}/"

  autoload :ConfigFile,         'rubygems/config_file'
  autoload :Dependency,         'rubygems/dependency'
  autoload :DependencyList,     'rubygems/dependency_list'
  autoload :DependencyResolver, 'rubygems/dependency_resolver'
  autoload :PathSupport,        'rubygems/path_support'
  autoload :Platform,           'rubygems/platform'
  autoload :RequestSet,         'rubygems/request_set'
  autoload :Requirement,        'rubygems/requirement'
  autoload :SourceList,         'rubygems/source_list'
  autoload :SpecFetcher,        'rubygems/spec_fetcher'
  autoload :Specification,      'rubygems/specification'
  autoload :Version,            'rubygems/version'
  autoload :Source,             'rubygems/source'

  require "rubygems/specification"
end

require 'rubygems/exceptions'

# REFACTOR: This should be pulled out into some kind of hacks file.
gem_preluded = Gem::GEM_PRELUDE_SUCKAGE and defined? Gem
unless gem_preluded then # TODO: remove guard after 1.9.2 dropped
  begin
    ##
    # Defaults the operating system (or packager) wants to provide for RubyGems.

    require 'rubygems/defaults/operating_system'
  rescue LoadError
  end

  if defined?(RUBY_ENGINE) then
    begin
      ##
      # Defaults the ruby implementation wants to provide for RubyGems

      require "rubygems/defaults/#{RUBY_ENGINE}"
    rescue LoadError
    end
  end
end

##
# Loads the default specs.
Gem::Specification.load_defaults

require 'rubygems/core_ext/kernel_gem'
require 'rubygems/core_ext/kernel_require'

Gem.detect_gemdeps
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      scanf.rb                                                                                            0100644 0001750 0001750 00000057021 11655163713 033732  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           # scanf for Ruby
#
#--
# $Release Version: 1.1.2 $
# $Revision: 33638 $
# $Id: scanf.rb 33638 2011-11-05 07:37:47Z ktsj $
# $Author: ktsj $
#++
#
# == Description
#
# scanf is an implementation of the C function scanf(3), modified as necessary
# for ruby compatibility.
#
# the methods provided are String#scanf, IO#scanf, and
# Kernel#scanf. Kernel#scanf is a wrapper around STDIN.scanf.  IO#scanf
# can be used on any IO stream, including file handles and sockets.
# scanf can be called either with or without a block.
#
# Scanf scans an input string or stream according to a <b>format</b>, as
# described below in Conversions, and returns an array of matches between
# the format and the input.  The format is defined in a string, and is
# similar (though not identical) to the formats used in Kernel#printf and
# Kernel#sprintf.
#
# The format may contain <b>conversion specifiers</b>, which tell scanf
# what form (type) each particular matched substring should be converted
# to (e.g., decimal integer, floating point number, literal string,
# etc.)  The matches and conversions take place from left to right, and
# the conversions themselves are returned as an array.
#
# The format string may also contain characters other than those in the
# conversion specifiers.  White space (blanks, tabs, or newlines) in the
# format string matches any amount of white space, including none, in
# the input.  Everything else matches only itself.
#
# Scanning stops, and scanf returns, when any input character fails to
# match the specifications in the format string, or when input is
# exhausted, or when everything in the format string has been
# matched. All matches found up to the stopping point are returned in
# the return array (or yielded to the block, if a block was given).
#
#
# == Basic usage
#
#   require 'scanf'
#
#   # String#scanf and IO#scanf take a single argument, the format string
#   array = a_string.scanf("%d%s")
#   array = an_io.scanf("%d%s")
#
#   # Kernel#scanf reads from STDIN
#   array = scanf("%d%s")
#
# == Block usage
#
# When called with a block, scanf keeps scanning the input, cycling back
# to the beginning of the format string, and yields a new array of
# conversions to the block every time the format string is matched
# (including partial matches, but not including complete failures).  The
# actual return value of scanf when called with a block is an array
# containing the results of all the executions of the block.
#
#   str = "123 abc 456 def 789 ghi"
#   str.scanf("%d%s") { |num,str| [ num * 2, str.upcase ] }
#   # => [[246, "ABC"], [912, "DEF"], [1578, "GHI"]]
#
# == Conversions
#
# The single argument to scanf is a format string, which generally
# includes one or more conversion specifiers.  Conversion specifiers
# begin with the percent character ('%') and include information about
# what scanf should next scan for (string, decimal number, single
# character, etc.).
#
# There may be an optional maximum field width, expressed as a decimal
# integer, between the % and the conversion.  If no width is given, a
# default of `infinity' is used (with the exception of the %c specifier;
# see below).  Otherwise, given a field width of <em>n</em> for a given
# conversion, at most <em>n</em> characters are scanned in processing
# that conversion.  Before conversion begins, most conversions skip
# white space in the input string; this white space is not counted
# against the field width.
#
# The following conversions are available.
#
# [%]
#   Matches a literal `%'. That is, `%%' in the format string matches a
#   single input `%' character. No conversion is done, and the resulting
#   '%' is not included in the return array.
#
# [d]
#   Matches an optionally signed decimal integer.
#
# [u]
#   Same as d.
#
# [i]
#   Matches an optionally signed integer. The integer is read in base
#   16 if it begins with `0x' or `0X', in base 8 if it begins with `0',
#   and in base 10 other- wise. Only characters that correspond to the
#   base are recognized.
#
# [o]
#   Matches an optionally signed octal integer.
#
# [x, X]
#   Matches an optionally signed hexadecimal integer,
#
# [a, e, f, g, A, E, F, G]
#   Matches an optionally signed floating-point number.
#
# [s]
#   Matches a sequence of non-white-space character. The input string stops at
#   white space or at the maximum field width, whichever occurs first.
#
# [c]
#   Matches a single character, or a sequence of <em>n</em> characters if a
#   field width of <em>n</em> is specified. The usual skip of leading white
#   space is suppressed. To skip white space first, use an explicit space in
#   the format.
#
# [[]
#   Matches a nonempty sequence of characters from the specified set
#   of accepted characters.  The usual skip of leading white space is
#   suppressed.  This bracketed sub-expression is interpreted exactly like a
#   character class in a Ruby regular expression.  (In fact, it is placed as-is
#   in a regular expression.)  The matching against the input string ends with
#   the appearance of a character not in (or, with a circumflex, in) the set,
#   or when the field width runs out, whichever comes first.
#
# === Assignment suppression
#
# To require that a particular match occur, but without including the result
# in the return array, place the <b>assignment suppression flag</b>, which is
# the star character ('*'), immediately after the leading '%' of a format
# specifier (just before the field width, if any).
#
# == scanf for Ruby compared with scanf in C
#
# scanf for Ruby is based on the C function scanf(3), but with modifications,
# dictated mainly by the underlying differences between the languages.
#
# === Unimplemented flags and specifiers
#
# * The only flag implemented in scanf for Ruby is '<tt>*</tt>' (ignore
#   upcoming conversion).  Many of the flags available in C versions of
#   scanf(3) have to do with the type of upcoming pointer arguments, and are
#   meaningless in Ruby.
#
# * The <tt>n</tt> specifier (store number of characters consumed so far in
#   next pointer) is not implemented.
#
# * The <tt>p</tt> specifier (match a pointer value) is not implemented.
#
# === Altered specifiers
#
# [o, u, x, X]
#   In scanf for Ruby, all of these specifiers scan for an optionally signed
#   integer, rather than for an unsigned integer like their C counterparts.
#
# === Return values
#
# scanf for Ruby returns an array of successful conversions, whereas
# scanf(3) returns the number of conversions successfully
# completed. (See below for more details on scanf for Ruby's return
# values.)
#
# == Return values
#
# Without a block, scanf returns an array containing all the conversions
# it has found.  If none are found, scanf will return an empty array. An
# unsuccessful match is never ignored, but rather always signals the end
# of the scanning operation.  If the first unsuccessful match takes place
# after one or more successful matches have already taken place, the
# returned array will contain the results of those successful matches.
#
# With a block scanf returns a 'map'-like array of transformations from
# the block -- that is, an array reflecting what the block did with each
# yielded result from the iterative scanf operation.  (See "Block
# usage", above.)
#
# == Current limitations and bugs
#
# When using IO#scanf under Windows, make sure you open your files in
# binary mode:
#
#     File.open("filename", "rb")
#
# so that scanf can keep track of characters correctly.
#
# Support for character classes is reasonably complete (since it
# essentially piggy-backs on Ruby's regular expression handling of
# character classes), but users are advised that character class testing
# has not been exhaustive, and that they should exercise some caution
# in using any of the more complex and/or arcane character class
# idioms.
#
# == License and copyright
#
# Copyright:: (c) 2002-2003 David Alan Black
# License:: Distributed on the same licensing terms as Ruby itself
#
# == Warranty disclaimer
#
# This software is provided "as is" and without any express or implied
# warranties, including, without limitation, the implied warranties of
# merchantability and fitness for a particular purpose.
#
# == Credits and acknowledgements
#
# scanf was developed as the major activity of the Austin Ruby Codefest
# (Austin, Texas, August 2002).
#
# Principal author:: David Alan Black (mailto:dblack@superlink.net)
# Co-author:: Hal Fulton (mailto:hal9000@hypermetrics.com)
# Project contributors:: Nolan Darilek, Jason Johnston
#
# Thanks to Hal Fulton for hosting the Codefest.
#
# Thanks to Matz for suggestions about the class design.
#
# Thanks to Gavin Sinclair for some feedback on the documentation.
#
# The text for parts of this document, especially the Description and
# Conversions sections, above, were adapted from the Linux Programmer's
# Manual manpage for scanf(3), dated 1995-11-01.
#
# == Bugs and bug reports
#
# scanf for Ruby is based on something of an amalgam of C scanf
# implementations and documentation, rather than on a single canonical
# description.  Suggestions for features and behaviors which appear in
# other scanfs, and would be meaningful in Ruby, are welcome, as are
# reports of suspicious behaviors and/or bugs.  (Please see "Credits and
# acknowledgements", above, for email addresses.)

module Scanf
  # :stopdoc:

  # ==Technical notes
  #
  # ===Rationale behind scanf for Ruby
  #
  # The impetus for a scanf implementation in Ruby comes chiefly from the fact
  # that existing pattern matching operations, such as Regexp#match and
  # String#scan, return all results as strings, which have to be converted to
  # integers or floats explicitly in cases where what's ultimately wanted are
  # integer or float values.
  #
  # ===Design of scanf for Ruby
  #
  # scanf for Ruby is essentially a <format string>-to-<regular
  # expression> converter.
  #
  # When scanf is called, a FormatString object is generated from the
  # format string ("%d%s...") argument. The FormatString object breaks the
  # format string down into atoms ("%d", "%5f", "blah", etc.), and from
  # each atom it creates a FormatSpecifier object, which it
  # saves.
  #
  # Each FormatSpecifier has a regular expression fragment and a "handler"
  # associated with it. For example, the regular expression fragment
  # associated with the format "%d" is "([-+]?\d+)", and the handler
  # associated with it is a wrapper around String#to_i. scanf itself calls
  # FormatString#match, passing in the input string. FormatString#match
  # iterates through its FormatSpecifiers; for each one, it matches the
  # corresponding regular expression fragment against the string. If
  # there's a match, it sends the matched string to the handler associated
  # with the FormatSpecifier.
  #
  # Thus, to follow up the "%d" example: if "123" occurs in the input
  # string when a FormatSpecifier consisting of "%d" is reached, the "123"
  # will be matched against "([-+]?\d+)", and the matched string will be
  # rendered into an integer by a call to to_i.
  #
  # The rendered match is then saved to an accumulator array, and the
  # input string is reduced to the post-match substring. Thus the string
  # is "eaten" from the left as the FormatSpecifiers are applied in
  # sequence.  (This is done to a duplicate string; the original string is
  # not altered.)
  #
  # As soon as a regular expression fragment fails to match the string, or
  # when the FormatString object runs out of FormatSpecifiers, scanning
  # stops and results accumulated so far are returned in an array.

  class FormatSpecifier

    attr_reader :re_string, :matched_string, :conversion, :matched

    private

    def skip;  /^\s*%\*/.match(@spec_string); end

    def extract_float(s)
      return nil unless s &&! skip
      if /\A(?<sign>[-+]?)0[xX](?<frac>\.\h+|\h+(?:\.\h*)?)[pP](?<exp>[-+]\d+)/ =~ s
        f1, f2 = frac.split('.')
        f = f1.hex
        if f2
          len = f2.length
          if len > 0
            f += f2.hex / (16.0 ** len)
          end
        end
        (sign == ?- ? -1 : 1) * Math.ldexp(f, exp.to_i)
      elsif /\A([-+]?\d+)\.([eE][-+]\d+)/ =~ s
        ($1 << $2).to_f
      else
        s.to_f
      end
    end
    def extract_decimal(s); s.to_i if s &&! skip; end
    def extract_hex(s); s.hex if s &&! skip; end
    def extract_octal(s); s.oct if s &&! skip; end
    def extract_integer(s); Integer(s) if s &&! skip; end
    def extract_plain(s); s unless skip; end

    def nil_proc(s); nil; end

    public

    def to_s
      @spec_string
    end

    def count_space?
      /(?:\A|\S)%\*?\d*c|%\d*\[/.match(@spec_string)
    end

    def initialize(str)
      @spec_string = str
      h = '[A-Fa-f0-9]'

      @re_string, @handler =
        case @spec_string

          # %[[:...:]]
        when /%\*?(\[\[:[a-z]+:\]\])/
          [ "(#{$1}+)", :extract_plain ]

          # %5[[:...:]]
        when /%\*?(\d+)(\[\[:[a-z]+:\]\])/
          [ "(#{$2}{1,#{$1}})", :extract_plain ]

          # %[...]
        when /%\*?\[([^\]]*)\]/
          yes = $1
          if /^\^/.match(yes) then no = yes[1..-1] else no = '^' + yes end
          [ "([#{yes}]+)(?=[#{no}]|\\z)", :extract_plain ]

          # %5[...]
        when /%\*?(\d+)\[([^\]]*)\]/
          yes = $2
          w = $1
          [ "([#{yes}]{1,#{w}})", :extract_plain ]

          # %i
        when /%\*?i/
          [ "([-+]?(?:(?:0[0-7]+)|(?:0[Xx]#{h}+)|(?:[1-9]\\d*)))", :extract_integer ]

          # %5i
        when /%\*?(\d+)i/
          n = $1.to_i
          s = "("
          if n > 1 then s += "[1-9]\\d{1,#{n-1}}|" end
          if n > 1 then s += "0[0-7]{1,#{n-1}}|" end
          if n > 2 then s += "[-+]0[0-7]{1,#{n-2}}|" end
          if n > 2 then s += "[-+][1-9]\\d{1,#{n-2}}|" end
          if n > 2 then s += "0[Xx]#{h}{1,#{n-2}}|" end
          if n > 3 then s += "[-+]0[Xx]#{h}{1,#{n-3}}|" end
          s += "\\d"
          s += ")"
          [ s, :extract_integer ]

          # %d, %u
        when /%\*?[du]/
          [ '([-+]?\d+)', :extract_decimal ]

          # %5d, %5u
        when /%\*?(\d+)[du]/
          n = $1.to_i
          s = "("
          if n > 1 then s += "[-+]\\d{1,#{n-1}}|" end
          s += "\\d{1,#{$1}})"
          [ s, :extract_decimal ]

          # %x
        when /%\*?[Xx]/
          [ "([-+]?(?:0[Xx])?#{h}+)", :extract_hex ]

          # %5x
        when /%\*?(\d+)[Xx]/
          n = $1.to_i
          s = "("
          if n > 3 then s += "[-+]0[Xx]#{h}{1,#{n-3}}|" end
          if n > 2 then s += "0[Xx]#{h}{1,#{n-2}}|" end
          if n > 1 then s += "[-+]#{h}{1,#{n-1}}|" end
          s += "#{h}{1,#{n}}"
          s += ")"
          [ s, :extract_hex ]

          # %o
        when /%\*?o/
          [ '([-+]?[0-7]+)', :extract_octal ]

          # %5o
        when /%\*?(\d+)o/
          [ "([-+][0-7]{1,#{$1.to_i-1}}|[0-7]{1,#{$1}})", :extract_octal ]

          # %f
        when /%\*?[aefgAEFG]/
          [ '([-+]?(?:0[xX](?:\.\h+|\h+(?:\.\h*)?)[pP][-+]\d+|\d+(?![\d.])|\d*\.\d*(?:[eE][-+]?\d+)?))', :extract_float ]

          # %5f
        when /%\*?(\d+)[aefgAEFG]/
          [ '(?=[-+]?(?:0[xX](?:\.\h+|\h+(?:\.\h*)?)[pP][-+]\d+|\d+(?![\d.])|\d*\.\d*(?:[eE][-+]?\d+)?))' +
            "(\\S{1,#{$1}})", :extract_float ]

          # %5s
        when /%\*?(\d+)s/
          [ "(\\S{1,#{$1}})", :extract_plain ]

          # %s
        when /%\*?s/
          [ '(\S+)', :extract_plain ]

          # %c
        when /\s%\*?c/
          [ "\\s*(.)", :extract_plain ]

          # %c
        when /%\*?c/
          [ "(.)", :extract_plain ]

          # %5c (whitespace issues are handled by the count_*_space? methods)
        when /%\*?(\d+)c/
          [ "(.{1,#{$1}})", :extract_plain ]

          # %%
        when /%%/
          [ '(\s*%)', :nil_proc ]

          # literal characters
        else
          [ "(#{Regexp.escape(@spec_string)})", :nil_proc ]
        end

      @re_string = '\A' + @re_string
    end

    def to_re
      Regexp.new(@re_string,Regexp::MULTILINE)
    end

    def match(str)
      @matched = false
      s = str.dup
      s.sub!(/\A\s+/,'') unless count_space?
      res = to_re.match(s)
      if res
        @conversion = send(@handler, res[1])
        @matched_string = @conversion.to_s
        @matched = true
      end
      res
    end

    def letter
      @spec_string[/%\*?\d*([a-z\[])/, 1]
    end

    def width
      w = @spec_string[/%\*?(\d+)/, 1]
      w && w.to_i
    end

    def mid_match?
      return false unless @matched
      cc_no_width    = letter == '[' &&! width
      c_or_cc_width  = (letter == 'c' || letter == '[') && width
      width_left     = c_or_cc_width && (matched_string.size < width)

      return width_left || cc_no_width
    end

  end

  class FormatString

    attr_reader :string_left, :last_spec_tried,
                :last_match_tried, :matched_count, :space

    SPECIFIERS = 'diuXxofFeEgGscaA'
    REGEX = /
        # possible space, followed by...
          (?:\s*
          # percent sign, followed by...
            %
            # another percent sign, or...
              (?:%|
                 # optional assignment suppression flag
                 \*?
                 # optional maximum field width
                 \d*
                   # named character class, ...
                   (?:\[\[:\w+:\]\]|
                   # traditional character class, or...
                      \[[^\]]*\]|
                   # specifier letter.
                      [#{SPECIFIERS}])))|
            # or miscellaneous characters
              [^%\s]+/ix

    def initialize(str)
      @specs = []
      @i = 1
      s = str.to_s
      return unless /\S/.match(s)
      @space = true if /\s\z/.match(s)
      @specs.replace s.scan(REGEX).map {|spec| FormatSpecifier.new(spec) }
    end

    def to_s
      @specs.join('')
    end

    def prune(n=matched_count)
      n.times { @specs.shift }
    end

    def spec_count
      @specs.size
    end

    def last_spec
      @i == spec_count - 1
    end

    def match(str)
      accum = []
      @string_left = str
      @matched_count = 0

      @specs.each_with_index do |spec,i|
        @i=i
        @last_spec_tried = spec
        @last_match_tried = spec.match(@string_left)
        break unless @last_match_tried
        @matched_count += 1

        accum << spec.conversion

        @string_left = @last_match_tried.post_match
        break if @string_left.empty?
      end
      return accum.compact
    end
  end
  # :startdoc:
end

class IO

  #:stopdoc:
  # The trick here is doing a match where you grab one *line*
  # of input at a time.  The linebreak may or may not occur
  # at the boundary where the string matches a format specifier.
  # And if it does, some rule about whitespace may or may not
  # be in effect...
  #
  # That's why this is much more elaborate than the string
  # version.
  #
  # For each line:
  #
  # Match succeeds (non-emptily)
  # and the last attempted spec/string sub-match succeeded:
  #
  #   could the last spec keep matching?
  #     yes: save interim results and continue (next line)
  #
  # The last attempted spec/string did not match:
  #
  # are we on the next-to-last spec in the string?
  #   yes:
  #     is fmt_string.string_left all spaces?
  #       yes: does current spec care about input space?
  #         yes: fatal failure
  #         no: save interim results and continue
  #   no: continue  [this state could be analyzed further]
  #
  #:startdoc:

  # Scans the current string until the match is exhausted,
  # yielding each match as it is encountered in the string.
  # A block is not necessary though, as the results will simply
  # be aggregated into the final array.
  #
  #   "123 456".block_scanf("%d")
  #   # => [123, 456]
  #
  # If a block is given, the value from that is returned from
  # the yield is added to an output array.
  #
  #   "123 456".block_scanf("%d) do |digit,| # the ',' unpacks the Array
  #     digit + 100
  #   end
  #   # => [223, 556]
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use use IO#scanf.
  def scanf(str,&b) #:yield: current_match
    return block_scanf(str,&b) if b
    return [] unless str.size > 0

    start_position = pos rescue 0
    matched_so_far = 0
    source_buffer = ""
    result_buffer = []
    final_result = []

    fstr = Scanf::FormatString.new(str)

    loop do
      if eof || (tty? &&! fstr.match(source_buffer))
        final_result.concat(result_buffer)
        break
      end

      source_buffer << gets

      current_match = fstr.match(source_buffer)

      spec = fstr.last_spec_tried

      if spec.matched
        if spec.mid_match?
          result_buffer.replace(current_match)
          next
        end

      elsif (fstr.matched_count == fstr.spec_count - 1)
        if /\A\s*\z/.match(fstr.string_left)
          break if spec.count_space?
          result_buffer.replace(current_match)
          next
        end
      end

      final_result.concat(current_match)

      matched_so_far += source_buffer.size
      source_buffer.replace(fstr.string_left)
      matched_so_far -= source_buffer.size
      break if fstr.last_spec
      fstr.prune
    end
    seek(start_position + matched_so_far, IO::SEEK_SET) rescue Errno::ESPIPE
    soak_up_spaces if fstr.last_spec && fstr.space

    return final_result
  end

  private

  def soak_up_spaces
    c = getc
    ungetc(c) if c
    until eof ||! c || /\S/.match(c.chr)
      c = getc
    end
    ungetc(c) if (c && /\S/.match(c.chr))
  end

  def block_scanf(str)
    final = []
# Sub-ideal, since another FS gets created in scanf.
# But used here to determine the number of specifiers.
    fstr = Scanf::FormatString.new(str)
    last_spec = fstr.last_spec
    begin
      current = scanf(str)
      break if current.empty?
      final.push(yield(current))
    end until eof || fstr.last_spec_tried == last_spec
    return final
  end
end

class String

  # :section: scanf
  #
  # You will need to require 'scanf' to use these methods

  # Scans the current string. If a block is given, it
  # functions exactly like block_scanf.
  #
  #   arr = "123 456".scanf("%d%d")
  #   # => [123, 456]
  #
  #   require 'pp'
  #
  #   "this 123 read that 456 other".scanf("%s%d%s") {|m| pp m}
  #
  #   # ["this", 123, "read"]
  #   # ["that", 456, "other"]
  #   # => [["this", 123, "read"], ["that", 456, "other"]]
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use String#scanf
  def scanf(fstr,&b) #:yield: current_match
    if b
      block_scanf(fstr,&b)
    else
      fs =
        if fstr.is_a? Scanf::FormatString
          fstr
        else
          Scanf::FormatString.new(fstr)
        end
      fs.match(self)
    end
  end

  # Scans the current string until the match is exhausted
  # yielding each match as it is encountered in the string.
  # A block is not necessary as the results will simply
  # be aggregated into the final array.
  #
  #   "123 456".block_scanf("%d")
  #   # => [123, 456]
  #
  # If a block is given, the value from that is returned from
  # the yield is added to an output array.
  #
  #   "123 456".block_scanf("%d) do |digit,| # the ',' unpacks the Array
  #     digit + 100
  #   end
  #   # => [223, 556]
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use String#block_scanf
  def block_scanf(fstr) #:yield: current_match
    fs = Scanf::FormatString.new(fstr)
    str = self.dup
    final = []
    begin
      current = str.scanf(fs)
      final.push(yield(current)) unless current.empty?
      str = fs.string_left
    end until current.empty? || str.empty?
    return final
  end
end

module Kernel
  private
  # Scans STDIN for data matching +format+.  See IO#scanf for details.
  #
  # See Scanf for details on creating a format string.
  #
  # You will need to require 'scanf' to use Kernel#scanf.
  def scanf(format, &b) #:doc:
    STDIN.scanf(format ,&b)
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               securerandom.rb                                                                                     0100644 0001750 0001750 00000021100 12024354443 035305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           # = Secure random number generator interface.
#
# This library is an interface for secure random number generator which is
# suitable for generating session key in HTTP cookies, etc.
#
# It supports following secure random number generators.
#
# * openssl
# * /dev/urandom
# * Win32
#
# == Example
#
# # random hexadecimal string.
# p SecureRandom.hex(10) #=> "52750b30ffbc7de3b362"
# p SecureRandom.hex(10) #=> "92b15d6c8dc4beb5f559"
# p SecureRandom.hex(11) #=> "6aca1b5c58e4863e6b81b8"
# p SecureRandom.hex(12) #=> "94b2fff3e7fd9b9c391a2306"
# p SecureRandom.hex(13) #=> "39b290146bea6ce975c37cfc23"
# ...
#
# # random base64 string.
# p SecureRandom.base64(10) #=> "EcmTPZwWRAozdA=="
# p SecureRandom.base64(10) #=> "9b0nsevdwNuM/w=="
# p SecureRandom.base64(10) #=> "KO1nIU+p9DKxGg=="
# p SecureRandom.base64(11) #=> "l7XEiFja+8EKEtY="
# p SecureRandom.base64(12) #=> "7kJSM/MzBJI+75j8"
# p SecureRandom.base64(13) #=> "vKLJ0tXBHqQOuIcSIg=="
# ...
#
# # random binary string.
# p SecureRandom.random_bytes(10) #=> "\016\t{\370g\310pbr\301"
# p SecureRandom.random_bytes(10) #=> "\323U\030TO\234\357\020\a\337"
# ...

begin
  require 'openssl'
rescue LoadError
end

module SecureRandom
  # SecureRandom.random_bytes generates a random binary string.
  #
  # The argument _n_ specifies the length of the result string.
  #
  # If _n_ is not specified, 16 is assumed.
  # It may be larger in future.
  #
  # The result may contain any byte: "\x00" - "\xff".
  #
  #   p SecureRandom.random_bytes #=> "\xD8\\\xE0\xF4\r\xB2\xFC*WM\xFF\x83\x18\xF45\xB6"
  #   p SecureRandom.random_bytes #=> "m\xDC\xFC/\a\x00Uf\xB2\xB2P\xBD\xFF6S\x97"
  #
  # If secure random number generator is not available,
  # NotImplementedError is raised.
  def self.random_bytes(n=nil)
    n = n ? n.to_int : 16

    if defined? OpenSSL::Random
      @pid = 0 if !defined?(@pid)
      pid = $$
      if @pid != pid
        now = Time.now
        ary = [now.to_i, now.nsec, @pid, pid]
        OpenSSL::Random.seed(ary.to_s)
        @pid = pid
      end
      return OpenSSL::Random.random_bytes(n)
    end

    if !defined?(@has_urandom) || @has_urandom
      flags = File::RDONLY
      flags |= File::NONBLOCK if defined? File::NONBLOCK
      flags |= File::NOCTTY if defined? File::NOCTTY
      begin
        File.open("/dev/urandom", flags) {|f|
          unless f.stat.chardev?
            raise Errno::ENOENT
          end
          @has_urandom = true
          ret = f.read(n)
          if ret.length != n
            raise NotImplementedError, "Unexpected partial read from random device: only #{ret.length} for #{n} bytes"
          end
          return ret
        }
      rescue Errno::ENOENT
        @has_urandom = false
      end
    end

    if !defined?(@has_win32)
      begin
        require 'Win32API'

        crypt_acquire_context = Win32API.new("advapi32", "CryptAcquireContext", 'PPPII', 'L')
        @crypt_gen_random = Win32API.new("advapi32", "CryptGenRandom", 'VIP', 'L')

        hProvStr = " " * DL::SIZEOF_VOIDP
        prov_rsa_full = 1
        crypt_verifycontext = 0xF0000000

        if crypt_acquire_context.call(hProvStr, nil, nil, prov_rsa_full, crypt_verifycontext) == 0
          raise SystemCallError, "CryptAcquireContext failed: #{lastWin32ErrorMessage}"
        end
        type = DL::SIZEOF_VOIDP == DL::SIZEOF_LONG_LONG ? 'q' : 'l'
        @hProv, = hProvStr.unpack(type)

        @has_win32 = true
      rescue LoadError
        @has_win32 = false
      end
    end
    if @has_win32
      bytes = " ".force_encoding("ASCII-8BIT") * n
      if @crypt_gen_random.call(@hProv, bytes.size, bytes) == 0
        raise SystemCallError, "CryptGenRandom failed: #{lastWin32ErrorMessage}"
      end
      return bytes
    end

    raise NotImplementedError, "No random device"
  end

  # SecureRandom.hex generates a random hex string.
  #
  # The argument _n_ specifies the length of the random length.
  # The length of the result string is twice of _n_.
  #
  # If _n_ is not specified, 16 is assumed.
  # It may be larger in future.
  #
  # The result may contain 0-9 and a-f.
  #
  #   p SecureRandom.hex #=> "eb693ec8252cd630102fd0d0fb7c3485"
  #   p SecureRandom.hex #=> "91dc3bfb4de5b11d029d376634589b61"
  #
  # If secure random number generator is not available,
  # NotImplementedError is raised.
  def self.hex(n=nil)
    random_bytes(n).unpack("H*")[0]
  end

  # SecureRandom.base64 generates a random base64 string.
  #
  # The argument _n_ specifies the length of the random length.
  # The length of the result string is about 4/3 of _n_.
  #
  # If _n_ is not specified, 16 is assumed.
  # It may be larger in future.
  #
  # The result may contain A-Z, a-z, 0-9, "+", "/" and "=".
  #
  #   p SecureRandom.base64 #=> "/2BuBuLf3+WfSKyQbRcc/A=="
  #   p SecureRandom.base64 #=> "6BbW0pxO0YENxn38HMUbcQ=="
  #
  # If secure random number generator is not available,
  # NotImplementedError is raised.
  #
  # See RFC 3548 for the definition of base64.
  def self.base64(n=nil)
    [random_bytes(n)].pack("m*").delete("\n")
  end

  # SecureRandom.urlsafe_base64 generates a random URL-safe base64 string.
  #
  # The argument _n_ specifies the length of the random length.
  # The length of the result string is about 4/3 of _n_.
  #
  # If _n_ is not specified, 16 is assumed.
  # It may be larger in future.
  #
  # The boolean argument _padding_ specifies the padding.
  # If it is false or nil, padding is not generated.
  # Otherwise padding is generated.
  # By default, padding is not generated because "=" may be used as a URL delimiter.
  #
  # The result may contain A-Z, a-z, 0-9, "-" and "_".
  # "=" is also used if _padding_ is true.
  #
  #   p SecureRandom.urlsafe_base64 #=> "b4GOKm4pOYU_-BOXcrUGDg"
  #   p SecureRandom.urlsafe_base64 #=> "UZLdOkzop70Ddx-IJR0ABg"
  #
  #   p SecureRandom.urlsafe_base64(nil, true) #=> "i0XQ-7gglIsHGV2_BNPrdQ=="
  #   p SecureRandom.urlsafe_base64(nil, true) #=> "-M8rLhr7JEpJlqFGUMmOxg=="
  #
  # If secure random number generator is not available,
  # NotImplementedError is raised.
  #
  # See RFC 3548 for the definition of URL-safe base64.
  def self.urlsafe_base64(n=nil, padding=false)
    s = [random_bytes(n)].pack("m*")
    s.delete!("\n")
    s.tr!("+/", "-_")
    s.delete!("=") if !padding
    s
  end

  # SecureRandom.random_number generates a random number.
  #
  # If a positive integer is given as _n_,
  # SecureRandom.random_number returns an integer:
  # 0 <= SecureRandom.random_number(n) < n.
  #
  #   p SecureRandom.random_number(100) #=> 15
  #   p SecureRandom.random_number(100) #=> 88
  #
  # If 0 is given or an argument is not given,
  # SecureRandom.random_number returns a float:
  # 0.0 <= SecureRandom.random_number() < 1.0.
  #
  #   p SecureRandom.random_number #=> 0.596506046187744
  #   p SecureRandom.random_number #=> 0.350621695741409
  #
  def self.random_number(n=0)
    if 0 < n
      hex = n.to_s(16)
      hex = '0' + hex if (hex.length & 1) == 1
      bin = [hex].pack("H*")
      mask = bin[0].ord
      mask |= mask >> 1
      mask |= mask >> 2
      mask |= mask >> 4
      begin
        rnd = SecureRandom.random_bytes(bin.length)
        rnd[0] = (rnd[0].ord & mask).chr
      end until rnd < bin
      rnd.unpack("H*")[0].hex
    else
      # assumption: Float::MANT_DIG <= 64
      i64 = SecureRandom.random_bytes(8).unpack("Q")[0]
      Math.ldexp(i64 >> (64-Float::MANT_DIG), -Float::MANT_DIG)
    end
  end

  # SecureRandom.uuid generates a v4 random UUID (Universally Unique IDentifier).
  #
  #   p SecureRandom.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
  #   p SecureRandom.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
  #   p SecureRandom.uuid #=> "62936e70-1815-439b-bf89-8492855a7e6b"
  #
  # The version 4 UUID is purely random (except the version).
  # It doesn't contain meaningful information such as MAC address, time, etc.
  #
  # See RFC 4122 for details of UUID.
  #
  def self.uuid
    ary = self.random_bytes(16).unpack("NnnnnN")
    ary[2] = (ary[2] & 0x0fff) | 0x4000
    ary[3] = (ary[3] & 0x3fff) | 0x8000
    "%08x-%04x-%04x-%04x-%04x%08x" % ary
  end

  # Following code is based on David Garamond's GUID library for Ruby.
  def self.lastWin32ErrorMessage # :nodoc:
    get_last_error = Win32API.new("kernel32", "GetLastError", '', 'L')
    format_message = Win32API.new("kernel32", "FormatMessageA", 'LPLLPLPPPPPPPP', 'L')
    format_message_ignore_inserts = 0x00000200
    format_message_from_system    = 0x00001000

    code = get_last_error.call
    msg = "\0" * 1024
    len = format_message.call(format_message_ignore_inserts + format_message_from_system, 0, code, 0, msg, 1024, nil, nil, nil, nil, nil, nil, nil, nil)
    msg[0, len].force_encoding("filesystem").tr("\r", '').chomp
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                set.rb                                                                                              0100644 0001750 0001750 00000042504 12054213501 033414  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #--
# set.rb - defines the Set class
#++
# Copyright (c) 2002-2008 Akinori MUSHA <knu@iDaemons.org>
#
# Documentation by Akinori MUSHA and Gavin Sinclair.
#
# All rights reserved.  You can redistribute and/or modify it under the same
# terms as Ruby.
#
#   $Id: set.rb 37839 2012-11-24 18:51:45Z knu $
#
# == Overview
#
# This library provides the Set class, which deals with a collection
# of unordered values with no duplicates.  It is a hybrid of Array's
# intuitive inter-operation facilities and Hash's fast lookup.  If you
# need to keep values ordered, use the SortedSet class.
#
# The method +to_set+ is added to Enumerable for convenience.
#
# See the Set and SortedSet documentation for examples of usage.


#
# Set implements a collection of unordered values with no duplicates.
# This is a hybrid of Array's intuitive inter-operation facilities and
# Hash's fast lookup.
#
# The equality of each couple of elements is determined according to
# Object#eql? and Object#hash, since Set uses Hash as storage.
#
# Set is easy to use with Enumerable objects (implementing +each+).
# Most of the initializer methods and binary operators accept generic
# Enumerable objects besides sets and arrays.  An Enumerable object
# can be converted to Set using the +to_set+ method.
#
# == Comparison
#
# The comparison operators <, >, <= and >= are implemented as
# shorthand for the {proper_,}{subset?,superset?} methods.  However,
# the <=> operator is intentionally left out because not every pair of
# sets is comparable. ({x,y} vs. {x,z} for example)
#
# == Example
#
#   require 'set'
#   s1 = Set.new [1, 2]                   # -> #<Set: {1, 2}>
#   s2 = [1, 2].to_set                    # -> #<Set: {1, 2}>
#   s1 == s2                              # -> true
#   s1.add("foo")                         # -> #<Set: {1, 2, "foo"}>
#   s1.merge([2, 6])                      # -> #<Set: {6, 1, 2, "foo"}>
#   s1.subset? s2                         # -> false
#   s2.subset? s1                         # -> true
#
# == Contact
#
#   - Akinori MUSHA <knu@iDaemons.org> (current maintainer)
#
class Set
  include Enumerable

  # Creates a new set containing the given objects.
  def self.[](*ary)
    new(ary)
  end

  # Creates a new set containing the elements of the given enumerable
  # object.
  #
  # If a block is given, the elements of enum are preprocessed by the
  # given block.
  def initialize(enum = nil, &block) # :yields: o
    @hash ||= Hash.new

    enum.nil? and return

    if block
      do_with_enum(enum) { |o| add(block[o]) }
    else
      merge(enum)
    end
  end

  def do_with_enum(enum, &block) # :nodoc:
    if enum.respond_to?(:each_entry)
      enum.each_entry(&block)
    elsif enum.respond_to?(:each)
      enum.each(&block)
    else
      raise ArgumentError, "value must be enumerable"
    end
  end
  private :do_with_enum

  # Copy internal hash.
  def initialize_copy(orig)
    @hash = orig.instance_variable_get(:@hash).dup
  end

  def freeze    # :nodoc:
    super
    @hash.freeze
    self
  end

  def taint     # :nodoc:
    super
    @hash.taint
    self
  end

  def untaint   # :nodoc:
    super
    @hash.untaint
    self
  end

  # Returns the number of elements.
  def size
    @hash.size
  end
  alias length size

  # Returns true if the set contains no elements.
  def empty?
    @hash.empty?
  end

  # Removes all elements and returns self.
  def clear
    @hash.clear
    self
  end

  # Replaces the contents of the set with the contents of the given
  # enumerable object and returns self.
  def replace(enum)
    if enum.instance_of?(self.class)
      @hash.replace(enum.instance_variable_get(:@hash))
    else
      clear
      merge(enum)
    end

    self
  end

  # Converts the set to an array.  The order of elements is uncertain.
  def to_a
    @hash.keys
  end

  def flatten_merge(set, seen = Set.new) # :nodoc:
    set.each { |e|
      if e.is_a?(Set)
        if seen.include?(e_id = e.object_id)
          raise ArgumentError, "tried to flatten recursive Set"
        end

        seen.add(e_id)
        flatten_merge(e, seen)
        seen.delete(e_id)
      else
        add(e)
      end
    }

    self
  end
  protected :flatten_merge

  # Returns a new set that is a copy of the set, flattening each
  # containing set recursively.
  def flatten
    self.class.new.flatten_merge(self)
  end

  # Equivalent to Set#flatten, but replaces the receiver with the
  # result in place.  Returns nil if no modifications were made.
  def flatten!
    if detect { |e| e.is_a?(Set) }
      replace(flatten())
    else
      nil
    end
  end

  # Returns true if the set contains the given object.
  def include?(o)
    @hash.include?(o)
  end
  alias member? include?

  # Returns true if the set is a superset of the given set.
  def superset?(set)
    set.is_a?(Set) or raise ArgumentError, "value must be a set"
    return false if size < set.size
    set.all? { |o| include?(o) }
  end
  alias >= superset?

  # Returns true if the set is a proper superset of the given set.
  def proper_superset?(set)
    set.is_a?(Set) or raise ArgumentError, "value must be a set"
    return false if size <= set.size
    set.all? { |o| include?(o) }
  end
  alias > proper_superset?

  # Returns true if the set is a subset of the given set.
  def subset?(set)
    set.is_a?(Set) or raise ArgumentError, "value must be a set"
    return false if set.size < size
    all? { |o| set.include?(o) }
  end
  alias <= subset?

  # Returns true if the set is a proper subset of the given set.
  def proper_subset?(set)
    set.is_a?(Set) or raise ArgumentError, "value must be a set"
    return false if set.size <= size
    all? { |o| set.include?(o) }
  end
  alias < proper_subset?

  # Calls the given block once for each element in the set, passing
  # the element as parameter.  Returns an enumerator if no block is
  # given.
  def each(&block)
    block or return enum_for(__method__)
    @hash.each_key(&block)
    self
  end

  # Adds the given object to the set and returns self.  Use +merge+ to
  # add many elements at once.
  def add(o)
    @hash[o] = true
    self
  end
  alias << add

  # Adds the given object to the set and returns self.  If the
  # object is already in the set, returns nil.
  def add?(o)
    if include?(o)
      nil
    else
      add(o)
    end
  end

  # Deletes the given object from the set and returns self.  Use +subtract+ to
  # delete many items at once.
  def delete(o)
    @hash.delete(o)
    self
  end

  # Deletes the given object from the set and returns self.  If the
  # object is not in the set, returns nil.
  def delete?(o)
    if include?(o)
      delete(o)
    else
      nil
    end
  end

  # Deletes every element of the set for which block evaluates to
  # true, and returns self.
  def delete_if
    block_given? or return enum_for(__method__)
    to_a.each { |o| @hash.delete(o) if yield(o) }
    self
  end

  # Deletes every element of the set for which block evaluates to
  # false, and returns self.
  def keep_if
    block_given? or return enum_for(__method__)
    to_a.each { |o| @hash.delete(o) unless yield(o) }
    self
  end

  # Replaces the elements with ones returned by collect().
  def collect!
    block_given? or return enum_for(__method__)
    set = self.class.new
    each { |o| set << yield(o) }
    replace(set)
  end
  alias map! collect!

  # Equivalent to Set#delete_if, but returns nil if no changes were
  # made.
  def reject!(&block)
    block or return enum_for(__method__)
    n = size
    delete_if(&block)
    size == n ? nil : self
  end

  # Equivalent to Set#keep_if, but returns nil if no changes were
  # made.
  def select!(&block)
    block or return enum_for(__method__)
    n = size
    keep_if(&block)
    size == n ? nil : self
  end

  # Merges the elements of the given enumerable object to the set and
  # returns self.
  def merge(enum)
    if enum.instance_of?(self.class)
      @hash.update(enum.instance_variable_get(:@hash))
    else
      do_with_enum(enum) { |o| add(o) }
    end

    self
  end

  # Deletes every element that appears in the given enumerable object
  # and returns self.
  def subtract(enum)
    do_with_enum(enum) { |o| delete(o) }
    self
  end

  # Returns a new set built by merging the set and the elements of the
  # given enumerable object.
  def |(enum)
    dup.merge(enum)
  end
  alias + |             ##
  alias union |         ##

  # Returns a new set built by duplicating the set, removing every
  # element that appears in the given enumerable object.
  def -(enum)
    dup.subtract(enum)
  end
  alias difference -    ##

  # Returns a new set containing elements common to the set and the
  # given enumerable object.
  def &(enum)
    n = self.class.new
    do_with_enum(enum) { |o| n.add(o) if include?(o) }
    n
  end
  alias intersection &  ##

  # Returns a new set containing elements exclusive between the set
  # and the given enumerable object.  (set ^ enum) is equivalent to
  # ((set | enum) - (set & enum)).
  def ^(enum)
    n = Set.new(enum)
    each { |o| if n.include?(o) then n.delete(o) else n.add(o) end }
    n
  end

  # Returns true if two sets are equal.  The equality of each couple
  # of elements is defined according to Object#eql?.
  def ==(other)
    if self.equal?(other)
      true
    elsif other.instance_of?(self.class)
      @hash == other.instance_variable_get(:@hash)
    elsif other.is_a?(Set) && self.size == other.size
      other.all? { |o| @hash.include?(o) }
    else
      false
    end
  end

  def hash      # :nodoc:
    @hash.hash
  end

  def eql?(o)   # :nodoc:
    return false unless o.is_a?(Set)
    @hash.eql?(o.instance_variable_get(:@hash))
  end

  # Classifies the set by the return value of the given block and
  # returns a hash of {value => set of elements} pairs.  The block is
  # called once for each element of the set, passing the element as
  # parameter.
  #
  # e.g.:
  #
  #   require 'set'
  #   files = Set.new(Dir.glob("*.rb"))
  #   hash = files.classify { |f| File.mtime(f).year }
  #   p hash    # => {2000=>#<Set: {"a.rb", "b.rb"}>,
  #             #     2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,
  #             #     2002=>#<Set: {"f.rb"}>}
  def classify # :yields: o
    block_given? or return enum_for(__method__)

    h = {}

    each { |i|
      x = yield(i)
      (h[x] ||= self.class.new).add(i)
    }

    h
  end

  # Divides the set into a set of subsets according to the commonality
  # defined by the given block.
  #
  # If the arity of the block is 2, elements o1 and o2 are in common
  # if block.call(o1, o2) is true.  Otherwise, elements o1 and o2 are
  # in common if block.call(o1) == block.call(o2).
  #
  # e.g.:
  #
  #   require 'set'
  #   numbers = Set[1, 3, 4, 6, 9, 10, 11]
  #   set = numbers.divide { |i,j| (i - j).abs == 1 }
  #   p set     # => #<Set: {#<Set: {1}>,
  #             #            #<Set: {11, 9, 10}>,
  #             #            #<Set: {3, 4}>,
  #             #            #<Set: {6}>}>
  def divide(&func)
    func or return enum_for(__method__)

    if func.arity == 2
      require 'tsort'

      class << dig = {}         # :nodoc:
        include TSort

        alias tsort_each_node each_key
        def tsort_each_child(node, &block)
          fetch(node).each(&block)
        end
      end

      each { |u|
        dig[u] = a = []
        each{ |v| func.call(u, v) and a << v }
      }

      set = Set.new()
      dig.each_strongly_connected_component { |css|
        set.add(self.class.new(css))
      }
      set
    else
      Set.new(classify(&func).values)
    end
  end

  InspectKey = :__inspect_key__         # :nodoc:

  # Returns a string containing a human-readable representation of the
  # set. ("#<Set: {element1, element2, ...}>")
  def inspect
    ids = (Thread.current[InspectKey] ||= [])

    if ids.include?(object_id)
      return sprintf('#<%s: {...}>', self.class.name)
    end

    begin
      ids << object_id
      return sprintf('#<%s: {%s}>', self.class, to_a.inspect[1..-2])
    ensure
      ids.pop
    end
  end

  def pretty_print(pp)  # :nodoc:
    pp.text sprintf('#<%s: {', self.class.name)
    pp.nest(1) {
      pp.seplist(self) { |o|
        pp.pp o
      }
    }
    pp.text "}>"
  end

  def pretty_print_cycle(pp)    # :nodoc:
    pp.text sprintf('#<%s: {%s}>', self.class.name, empty? ? '' : '...')
  end
end

#
# SortedSet implements a Set that guarantees that it's element are
# yielded in sorted order (according to the return values of their
# #<=> methods) when iterating over them.
#
# All elements that are added to a SortedSet must respond to the <=>
# method for comparison.
#
# Also, all elements must be <em>mutually comparable</em>: <tt>el1 <=>
# el2</tt> must not return <tt>nil</tt> for any elements <tt>el1</tt>
# and <tt>el2</tt>, else an ArgumentError will be raised when
# iterating over the SortedSet.
#
# == Example
#
#   require "set"
#
#   set = SortedSet.new([2, 1, 5, 6, 4, 5, 3, 3, 3])
#   ary = []
#
#   set.each do |obj|
#     ary << obj
#   end
#
#   p ary # => [1, 2, 3, 4, 5, 6]
#
#   set2 = SortedSet.new([1, 2, "3"])
#   set2.each { |obj| } # => raises ArgumentError: comparison of Fixnum with String failed
#
class SortedSet < Set
  @@setup = false

  class << self
    def [](*ary)        # :nodoc:
      new(ary)
    end

    def setup   # :nodoc:
      @@setup and return

      module_eval {
        # a hack to shut up warning
        alias old_init initialize
      }
      begin
        require 'rbtree'

        module_eval %{
          def initialize(*args)
            @hash = RBTree.new
            super
          end

          def add(o)
            o.respond_to?(:<=>) or raise ArgumentError, "value must respond to <=>"
            super
          end
          alias << add
        }
      rescue LoadError
        module_eval %{
          def initialize(*args)
            @keys = nil
            super
          end

          def clear
            @keys = nil
            super
          end

          def replace(enum)
            @keys = nil
            super
          end

          def add(o)
            o.respond_to?(:<=>) or raise ArgumentError, "value must respond to <=>"
            @keys = nil
            super
          end
          alias << add

          def delete(o)
            @keys = nil
            @hash.delete(o)
            self
          end

          def delete_if
            block_given? or return enum_for(__method__)
            n = @hash.size
            super
            @keys = nil if @hash.size != n
            self
          end

          def keep_if
            block_given? or return enum_for(__method__)
            n = @hash.size
            super
            @keys = nil if @hash.size != n
            self
          end

          def merge(enum)
            @keys = nil
            super
          end

          def each(&block)
            block or return enum_for(__method__)
            to_a.each(&block)
            self
          end

          def to_a
            (@keys = @hash.keys).sort! unless @keys
            @keys
          end
        }
      end
      module_eval {
        # a hack to shut up warning
        remove_method :old_init
      }

      @@setup = true
    end
  end

  def initialize(*args, &block) # :nodoc:
    SortedSet.setup
    initialize(*args, &block)
  end
end

module Enumerable
  # Makes a set from the enumerable object with given arguments.
  # Needs to +require "set"+ to use this method.
  def to_set(klass = Set, *args, &block)
    klass.new(self, *args, &block)
  end
end

# =begin
# == RestricedSet class
# RestricedSet implements a set with restrictions defined by a given
# block.
#
# === Super class
#     Set
#
# === Class Methods
# --- RestricedSet::new(enum = nil) { |o| ... }
# --- RestricedSet::new(enum = nil) { |rset, o| ... }
#     Creates a new restricted set containing the elements of the given
#     enumerable object.  Restrictions are defined by the given block.
#
#     If the block's arity is 2, it is called with the RestrictedSet
#     itself and an object to see if the object is allowed to be put in
#     the set.
#
#     Otherwise, the block is called with an object to see if the object
#     is allowed to be put in the set.
#
# === Instance Methods
# --- restriction_proc
#     Returns the restriction procedure of the set.
#
# =end
#
# class RestricedSet < Set
#   def initialize(*args, &block)
#     @proc = block or raise ArgumentError, "missing a block"
#
#     if @proc.arity == 2
#       instance_eval %{
#       def add(o)
#         @hash[o] = true if @proc.call(self, o)
#         self
#       end
#       alias << add
#
#       def add?(o)
#         if include?(o) || !@proc.call(self, o)
#           nil
#         else
#           @hash[o] = true
#           self
#         end
#       end
#
#       def replace(enum)
#         enum.respond_to?(:each) or raise ArgumentError, "value must be enumerable"
#         clear
#         enum.each_entry { |o| add(o) }
#
#         self
#       end
#
#       def merge(enum)
#         enum.respond_to?(:each) or raise ArgumentError, "value must be enumerable"
#         enum.each_entry { |o| add(o) }
#
#         self
#       end
#       }
#     else
#       instance_eval %{
#       def add(o)
#         if @proc.call(o)
#           @hash[o] = true
#         end
#         self
#       end
#       alias << add
#
#       def add?(o)
#         if include?(o) || !@proc.call(o)
#           nil
#         else
#           @hash[o] = true
#           self
#         end
#       end
#       }
#     end
#
#     super(*args)
#   end
#
#   def restriction_proc
#     @proc
#   end
# end

# Tests have been moved to test/test_set.rb.
                                                                                                                                                                                            shell/                                                                                              0040755 0001750 0001750 00000000000 12612224745 033415  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           builtin-command.rb                                                                                  0100644 0001750 0001750 00000005203 11565057475 037033  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   shell/builtin-command.rb -
#       $Release Version: 0.7 $
#       $Revision: 31641 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

require "shell/filter"

class Shell
  class BuiltInCommand<Filter
    def wait?
      false
    end
    def active?
      true
    end
  end

  class Void < BuiltInCommand
    def initialize(sh, *opts)
      super sh
    end

    def each(rs = nil)
      # do nothing
    end
  end

  class Echo < BuiltInCommand
    def initialize(sh, *strings)
      super sh
      @strings = strings
    end

    def each(rs = nil)
      rs =  @shell.record_separator unless rs
      for str  in @strings
        yield str + rs
      end
    end
  end

  class Cat < BuiltInCommand
    def initialize(sh, *filenames)
      super sh
      @cat_files = filenames
    end

    def each(rs = nil)
      if @cat_files.empty?
        super
      else
        for src in @cat_files
          @shell.foreach(src, rs){|l| yield l}
        end
      end
    end
  end

  class Glob < BuiltInCommand
    def initialize(sh, pattern)
      super sh

      @pattern = pattern
    end

    def each(rs = nil)
      if @pattern[0] == ?/
        @files = Dir[@pattern]
      else
        prefix = @shell.pwd+"/"
        @files = Dir[prefix+@pattern].collect{|p| p.sub(prefix, "")}
      end
      rs =  @shell.record_separator unless rs
      for f in @files
        yield f+rs
      end
    end
  end

#   class Sort < Cat
#     def initialize(sh, *filenames)
#       super
#     end
#
#     def each(rs = nil)
#       ary = []
#       super{|l|       ary.push l}
#       for l in ary.sort!
#       yield l
#       end
#     end
#   end

  class AppendIO < BuiltInCommand
    def initialize(sh, io, filter)
      super sh
      @input = filter
      @io = io
    end

    def input=(filter)
      @input.input=filter
      for l in @input
        @io << l
      end
    end

  end

  class AppendFile < AppendIO
    def initialize(sh, to_filename, filter)
      @file_name = to_filename
      io = sh.open(to_filename, "a")
      super(sh, io, filter)
    end

    def input=(filter)
      begin
        super
      ensure
        @io.close
      end
    end
  end

  class Tee < BuiltInCommand
    def initialize(sh, filename)
      super sh
      @to_filename = filename
    end

    def each(rs = nil)
      to = @shell.open(@to_filename, "w")
      begin
        super{|l| to << l; yield l}
      ensure
        to.close
      end
    end
  end

  class Concat < BuiltInCommand
    def initialize(sh, *jobs)
      super(sh)
      @jobs = jobs
    end

    def each(rs = nil)
      while job = @jobs.shift
        job.each{|l| yield l}
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                             command-processor.rb                                                                                0100644 0001750 0001750 00000044774 12057533613 037412  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   shell/command-controller.rb -
#       $Release Version: 0.7 $
#       $Revision: 38201 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

require "e2mmap"
require "thread"

require "shell/error"
require "shell/filter"
require "shell/system-command"
require "shell/builtin-command"

class Shell
  # In order to execute a command on your OS, you need to define it as a
  # Shell method.
  #
  # Alternatively, you can execute any command via
  # Shell::CommandProcessor#system even if it is not defined.
  class CommandProcessor
#    include Error

    #
    # initialize of Shell and related classes.
    #
    m = [:initialize, :expand_path]
    if Object.methods.first.kind_of?(String)
      NoDelegateMethods = m.collect{|x| x.id2name}
    else
      NoDelegateMethods = m
    end

    def self.initialize

      install_builtin_commands

      # define CommandProcessor#methods to Shell#methods and Filter#methods
      for m in CommandProcessor.instance_methods(false) - NoDelegateMethods
        add_delegate_command_to_shell(m)
      end

      def self.method_added(id)
        add_delegate_command_to_shell(id)
      end
    end

    #
    # include run file.
    #
    def self.run_config
      begin
        load File.expand_path("~/.rb_shell") if ENV.key?("HOME")
      rescue LoadError, Errno::ENOENT
      rescue
        print "load error: #{rc}\n"
        print $!.class, ": ", $!, "\n"
        for err in $@[0, $@.size - 2]
          print "\t", err, "\n"
        end
      end
    end

    def initialize(shell)
      @shell = shell
      @system_commands = {}
    end

    #
    # CommandProcessor#expand_path(path)
    #     path:   String
    #     return: String
    #   returns the absolute path for <path>
    #
    def expand_path(path)
      @shell.expand_path(path)
    end

    # call-seq:
    #   foreach(path, record_separator) -> Enumerator
    #   foreach(path, record_separator) { block }
    #
    # See IO.foreach when +path+ is a file.
    #
    # See Dir.foreach when +path+ is a directory.
    #
    def foreach(path = nil, *rs)
      path = "." unless path
      path = expand_path(path)

      if File.directory?(path)
        Dir.foreach(path){|fn| yield fn}
      else
        IO.foreach(path, *rs){|l| yield l}
      end
    end

    # call-seq:
    #   open(path, mode, permissions) -> Enumerator
    #   open(path, mode, permissions) { block }
    #
    # See IO.open when +path+ is a file.
    #
    # See Dir.open when +path+ is a directory.
    #
    def open(path, mode = nil, perm = 0666, &b)
      path = expand_path(path)
      if File.directory?(path)
        Dir.open(path, &b)
      else
        if @shell.umask
          f = File.open(path, mode, perm)
          File.chmod(perm & ~@shell.umask, path)
          if block_given?
            f.each(&b)
          end
          f
        else
          f = File.open(path, mode, perm, &b)
        end
      end
    end
    #  public :open

    # call-seq:
    #   unlink(path)
    #
    # See IO.unlink when +path+ is a file.
    #
    # See Dir.unlink when +path+ is a directory.
    #
    def unlink(path)
      @shell.check_point

      path = expand_path(path)
      if File.directory?(path)
        Dir.unlink(path)
      else
        IO.unlink(path)
      end
      Void.new(@shell)
    end

    # See Shell::CommandProcessor#test
    alias top_level_test test
    # call-seq:
    #   test(command, file1, file2) ->  true or false
    #   [command, file1, file2] ->  true or false
    #
    # Tests if the given +command+ exists in +file1+, or optionally +file2+.
    #
    # Example:
    #     sh[?e, "foo"]
    #     sh[:e, "foo"]
    #     sh["e", "foo"]
    #     sh[:exists?, "foo"]
    #     sh["exists?", "foo"]
    #
    def test(command, file1, file2=nil)
      file1 = expand_path(file1)
      file2 = expand_path(file2) if file2
      command = command.id2name if command.kind_of?(Symbol)

      case command
      when Integer
        if file2
          top_level_test(command, file1, file2)
        else
          top_level_test(command, file1)
        end
      when String
        if command.size == 1
          if file2
            top_level_test(command, file1, file2)
          else
            top_level_test(command, file1)
          end
        else
          if file2
            FileTest.send(command, file1, file2)
          else
            FileTest.send(command, file1)
          end
        end
      end
    end
    # See Shell::CommandProcessor#test
    alias [] test

    # call-seq:
    #   mkdir(path)
    #
    # Same as Dir.mkdir, except multiple directories are allowed.
    def mkdir(*path)
      @shell.check_point
      notify("mkdir #{path.join(' ')}")

      perm = nil
      if path.last.kind_of?(Integer)
        perm = path.pop
      end
      for dir in path
        d = expand_path(dir)
        if perm
          Dir.mkdir(d, perm)
        else
          Dir.mkdir(d)
        end
        File.chmod(d, 0666 & ~@shell.umask) if @shell.umask
      end
      Void.new(@shell)
    end

    # call-seq:
    #   rmdir(path)
    #
    # Same as Dir.rmdir, except multiple directories are allowed.
    def rmdir(*path)
      @shell.check_point
      notify("rmdir #{path.join(' ')}")

      for dir in path
        Dir.rmdir(expand_path(dir))
      end
      Void.new(@shell)
    end

    # call-seq:
    #   system(command, *options) -> SystemCommand
    #
    # Executes the given +command+ with the +options+ parameter.
    #
    # Example:
    #     print sh.system("ls", "-l")
    #     sh.system("ls", "-l") | sh.head > STDOUT
    #
    def system(command, *opts)
      if opts.empty?
        if command =~ /\*|\?|\{|\}|\[|\]|<|>|\(|\)|~|&|\||\\|\$|;|'|`|"|\n/
          return SystemCommand.new(@shell, find_system_command("sh"), "-c", command)
        else
          command, *opts = command.split(/\s+/)
        end
      end
      SystemCommand.new(@shell, find_system_command(command), *opts)
    end

    # call-seq:
    #   rehash
    #
    # Clears the command hash table.
    def rehash
      @system_commands = {}
    end

    def check_point # :nodoc:
      @shell.process_controller.wait_all_jobs_execution
    end
    alias finish_all_jobs check_point # :nodoc:

    # call-seq:
    #   transact { block }
    #
    # Executes a block as self
    #
    # Example:
    #   sh.transact { system("ls", "-l") | head > STDOUT }
    def transact(&block)
      begin
        @shell.instance_eval(&block)
      ensure
        check_point
      end
    end

    # call-seq:
    #   out(device) { block }
    #
    # Calls <code>device.print</code> on the result passing the _block_ to
    # #transact
    def out(dev = STDOUT, &block)
      dev.print transact(&block)
    end

    # call-seq:
    #   echo(*strings) ->  Echo
    #
    # Returns a Echo object, for the given +strings+
    def echo(*strings)
      Echo.new(@shell, *strings)
    end

    # call-seq:
    #   cat(*filename) ->  Cat
    #
    # Returns a Cat object, for the given +filenames+
    def cat(*filenames)
      Cat.new(@shell, *filenames)
    end

    #   def sort(*filenames)
    #     Sort.new(self, *filenames)
    #   end
    # call-seq:
    #   glob(pattern) ->  Glob
    #
    # Returns a Glob filter object, with the given +pattern+ object
    def glob(pattern)
      Glob.new(@shell, pattern)
    end

    def append(to, filter)
      case to
      when String
        AppendFile.new(@shell, to, filter)
      when IO
        AppendIO.new(@shell, to, filter)
      else
        Shell.Fail Error::CantApplyMethod, "append", to.class
      end
    end

    # call-seq:
    #   tee(file) ->  Tee
    #
    # Returns a Tee filter object, with the given +file+ command
    def tee(file)
      Tee.new(@shell, file)
    end

    # call-seq:
    #   concat(*jobs) ->  Concat
    #
    # Returns a Concat object, for the given +jobs+
    def concat(*jobs)
      Concat.new(@shell, *jobs)
    end

    # %pwd, %cwd -> @pwd
    def notify(*opts)
      Shell.notify(*opts) {|mes|
        yield mes if iterator?

        mes.gsub!("%pwd", "#{@cwd}")
        mes.gsub!("%cwd", "#{@cwd}")
      }
    end

    #
    # private functions
    #
    def find_system_command(command)
      return command if /^\// =~ command
      case path = @system_commands[command]
      when String
        if exists?(path)
          return path
        else
          Shell.Fail Error::CommandNotFound, command
        end
      when false
        Shell.Fail Error::CommandNotFound, command
      end

      for p in @shell.system_path
        path = join(p, command)
        if FileTest.exist?(path)
          @system_commands[command] = path
          return path
        end
      end
      @system_commands[command] = false
      Shell.Fail Error::CommandNotFound, command
    end

    # call-seq:
    #   def_system_command(command, path)  ->  Shell::SystemCommand
    #
    # Defines a command, registering +path+ as a Shell method for the given
    # +command+.
    #
    #     Shell::CommandProcessor.def_system_command "ls"
    #       #=> Defines ls.
    #
    #     Shell::CommandProcessor.def_system_command "sys_sort", "sort"
    #       #=> Defines sys_sort as sort
    #
    def self.def_system_command(command, path = command)
      begin
        eval((d = %Q[def #{command}(*opts)
                  SystemCommand.new(@shell, '#{path}', *opts)
               end]), nil, __FILE__, __LINE__ - 1)
      rescue SyntaxError
        Shell.notify "warn: Can't define #{command} path: #{path}."
      end
      Shell.notify "Define #{command} path: #{path}.", Shell.debug?
      Shell.notify("Definition of #{command}: ", d,
             Shell.debug.kind_of?(Integer) && Shell.debug > 1)
    end

    # call-seq:
    #   undef_system_command(command) ->  self
    #
    # Undefines a command
    def self.undef_system_command(command)
      command = command.id2name if command.kind_of?(Symbol)
      remove_method(command)
      Shell.module_eval{remove_method(command)}
      Filter.module_eval{remove_method(command)}
      self
    end

    @alias_map = {}
    # Returns a list of aliased commands
    def self.alias_map
      @alias_map
    end
    # call-seq:
    #   alias_command(alias, command, *options) ->  self
    #
    # Creates a command alias at the given +alias+ for the given +command+,
    # passing any +options+ along with it.
    #
    #     Shell::CommandProcessor.alias_command "lsC", "ls", "-CBF", "--show-control-chars"
    #     Shell::CommandProcessor.alias_command("lsC", "ls"){|*opts| ["-CBF", "--show-control-chars", *opts]}
    #
    def self.alias_command(ali, command, *opts)
      ali = ali.id2name if ali.kind_of?(Symbol)
      command = command.id2name if command.kind_of?(Symbol)
      begin
        if iterator?
          @alias_map[ali.intern] = proc

          eval((d = %Q[def #{ali}(*opts)
                          @shell.__send__(:#{command},
                                          *(CommandProcessor.alias_map[:#{ali}].call *opts))
                        end]), nil, __FILE__, __LINE__ - 1)

        else
           args = opts.collect{|opt| '"' + opt + '"'}.join(",")
           eval((d = %Q[def #{ali}(*opts)
                          @shell.__send__(:#{command}, #{args}, *opts)
                        end]), nil, __FILE__, __LINE__ - 1)
        end
      rescue SyntaxError
        Shell.notify "warn: Can't alias #{ali} command: #{command}."
        Shell.notify("Definition of #{ali}: ", d)
        raise
      end
      Shell.notify "Define #{ali} command: #{command}.", Shell.debug?
      Shell.notify("Definition of #{ali}: ", d,
             Shell.debug.kind_of?(Integer) && Shell.debug > 1)
      self
    end

    # call-seq:
    #   unalias_command(alias)  ->  self
    #
    # Unaliases the given +alias+ command.
    def self.unalias_command(ali)
      ali = ali.id2name if ali.kind_of?(Symbol)
      @alias_map.delete ali.intern
      undef_system_command(ali)
    end

    # :nodoc:
    #
    # Delegates File and FileTest methods into Shell, including the following
    # commands:
    #
    # * Shell#blockdev?(file)
    # * Shell#chardev?(file)
    # * Shell#directory?(file)
    # * Shell#executable?(file)
    # * Shell#executable_real?(file)
    # * Shell#exist?(file)/Shell#exists?(file)
    # * Shell#file?(file)
    # * Shell#grpowned?(file)
    # * Shell#owned?(file)
    # * Shell#pipe?(file)
    # * Shell#readable?(file)
    # * Shell#readable_real?(file)
    # * Shell#setgid?(file)
    # * Shell#setuid?(file)
    # * Shell#size(file)/Shell#size?(file)
    # * Shell#socket?(file)
    # * Shell#sticky?(file)
    # * Shell#symlink?(file)
    # * Shell#writable?(file)
    # * Shell#writable_real?(file)
    # * Shell#zero?(file)
    # * Shell#syscopy(filename_from, filename_to)
    # * Shell#copy(filename_from, filename_to)
    # * Shell#move(filename_from, filename_to)
    # * Shell#compare(filename_from, filename_to)
    # * Shell#safe_unlink(*filenames)
    # * Shell#makedirs(*filenames)
    # * Shell#install(filename_from, filename_to, mode)
    #
    # And also, there are some aliases for convenience:
    #
    # * Shell#cmp	<- Shell#compare
    # * Shell#mv	<- Shell#move
    # * Shell#cp	<- Shell#copy
    # * Shell#rm_f	<- Shell#safe_unlink
    # * Shell#mkpath	<- Shell#makedirs
    #
    def self.def_builtin_commands(delegation_class, command_specs)
      for meth, args in command_specs
        arg_str = args.collect{|arg| arg.downcase}.join(", ")
        call_arg_str = args.collect{
          |arg|
          case arg
          when /^(FILENAME.*)$/
            format("expand_path(%s)", $1.downcase)
          when /^(\*FILENAME.*)$/
            # \*FILENAME* -> filenames.collect{|fn| expand_path(fn)}.join(", ")
            $1.downcase + '.collect{|fn| expand_path(fn)}'
          else
            arg
          end
        }.join(", ")
        d = %Q[def #{meth}(#{arg_str})
                    #{delegation_class}.#{meth}(#{call_arg_str})
                 end]
        Shell.notify "Define #{meth}(#{arg_str})", Shell.debug?
        Shell.notify("Definition of #{meth}: ", d,
                     Shell.debug.kind_of?(Integer) && Shell.debug > 1)
        eval d
      end
    end

    # call-seq:
    #     install_system_commands(prefix = "sys_")
    #
    # Defines all commands in the Shell.default_system_path as Shell method,
    # all with given +prefix+ appended to their names.
    #
    # Any invalid character names are converted to +_+, and errors are passed
    # to Shell.notify.
    #
    # Methods already defined are skipped.
    def self.install_system_commands(pre = "sys_")
      defined_meth = {}
      for m in Shell.methods
        defined_meth[m] = true
      end
      sh = Shell.new
      for path in Shell.default_system_path
        next unless sh.directory? path
        sh.cd path
        sh.foreach do
          |cn|
          if !defined_meth[pre + cn] && sh.file?(cn) && sh.executable?(cn)
            command = (pre + cn).gsub(/\W/, "_").sub(/^([0-9])/, '_\1')
            begin
              def_system_command(command, sh.expand_path(cn))
            rescue
              Shell.notify "warn: Can't define #{command} path: #{cn}"
            end
            defined_meth[command] = command
          end
        end
      end
    end

    def self.add_delegate_command_to_shell(id) # :nodoc:
      id = id.intern if id.kind_of?(String)
      name = id.id2name
      if Shell.method_defined?(id)
        Shell.notify "warn: override definition of Shell##{name}."
        Shell.notify "warn: alias Shell##{name} to Shell##{name}_org.\n"
        Shell.module_eval "alias #{name}_org #{name}"
      end
      Shell.notify "method added: Shell##{name}.", Shell.debug?
      Shell.module_eval(%Q[def #{name}(*args, &block)
                            begin
                              @command_processor.__send__(:#{name}, *args, &block)
                            rescue Exception
                              $@.delete_if{|s| /:in `__getobj__'$/ =~ s} #`
                              $@.delete_if{|s| /^\\(eval\\):/ =~ s}
                            raise
                            end
                          end], __FILE__, __LINE__)

      if Shell::Filter.method_defined?(id)
        Shell.notify "warn: override definition of Shell::Filter##{name}."
        Shell.notify "warn: alias Shell##{name} to Shell::Filter##{name}_org."
        Filter.module_eval "alias #{name}_org #{name}"
      end
      Shell.notify "method added: Shell::Filter##{name}.", Shell.debug?
      Filter.module_eval(%Q[def #{name}(*args, &block)
                            begin
                              self | @shell.__send__(:#{name}, *args, &block)
                            rescue Exception
                              $@.delete_if{|s| /:in `__getobj__'$/ =~ s} #`
                              $@.delete_if{|s| /^\\(eval\\):/ =~ s}
                            raise
                            end
                          end], __FILE__, __LINE__)
    end

    # Delegates File methods into Shell, including the following commands:
    #
    # * Shell#atime(file)
    # * Shell#basename(file, *opt)
    # * Shell#chmod(mode, *files)
    # * Shell#chown(owner, group, *file)
    # * Shell#ctime(file)
    # * Shell#delete(*file)
    # * Shell#dirname(file)
    # * Shell#ftype(file)
    # * Shell#join(*file)
    # * Shell#link(file_from, file_to)
    # * Shell#lstat(file)
    # * Shell#mtime(file)
    # * Shell#readlink(file)
    # * Shell#rename(file_from, file_to)
    # * Shell#split(file)
    # * Shell#stat(file)
    # * Shell#symlink(file_from, file_to)
    # * Shell#truncate(file, length)
    # * Shell#utime(atime, mtime, *file)
    #
    def self.install_builtin_commands
      # method related File.
      # (exclude open/foreach/unlink)
      normal_delegation_file_methods = [
        ["atime", ["FILENAME"]],
        ["basename", ["fn", "*opts"]],
        ["chmod", ["mode", "*FILENAMES"]],
        ["chown", ["owner", "group", "*FILENAME"]],
        ["ctime", ["FILENAMES"]],
        ["delete", ["*FILENAMES"]],
        ["dirname", ["FILENAME"]],
        ["ftype", ["FILENAME"]],
        ["join", ["*items"]],
        ["link", ["FILENAME_O", "FILENAME_N"]],
        ["lstat", ["FILENAME"]],
        ["mtime", ["FILENAME"]],
        ["readlink", ["FILENAME"]],
        ["rename", ["FILENAME_FROM", "FILENAME_TO"]],
        #      ["size", ["FILENAME"]],
        ["split", ["pathname"]],
        ["stat", ["FILENAME"]],
        ["symlink", ["FILENAME_O", "FILENAME_N"]],
        ["truncate", ["FILENAME", "length"]],
        ["utime", ["atime", "mtime", "*FILENAMES"]]]

      def_builtin_commands(File, normal_delegation_file_methods)
      alias_method :rm, :delete

      # method related FileTest
      def_builtin_commands(FileTest,
                   FileTest.singleton_methods(false).collect{|m| [m, ["FILENAME"]]})

    end

  end
end
    error.rb                                                                                            0100644 0001750 0001750 00000001075 11565057475 035105  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   shell/error.rb -
#       $Release Version: 0.7 $
#       $Revision: 31641 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

require "e2mmap"

class Shell
  module Error
    extend Exception2MessageMapper
    def_e2message TypeError, "wrong argument type %s (expected %s)"

    def_exception :DirStackEmpty, "Directory stack empty."
    def_exception :CantDefine, "Can't define method(%s, %s)."
    def_exception :CantApplyMethod, "This method(%s) does not apply to this type(%s)."
    def_exception :CommandNotFound, "Command not found(%s)."
  end
end

                                                                                                                                                                                                                                                                                                                                                                                                                                                                   filter.rb                                                                                           0100644 0001750 0001750 00000005075 12057533613 035233  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   shell/filter.rb -
#       $Release Version: 0.7 $
#       $Revision: 38201 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

class Shell #:nodoc:
  # Any result of command exection is a Filter.
  #
  # This class includes Enumerable, therefore a Filter object can use all
  # Enumerable
  # facilities.
  #
  class Filter
    include Enumerable

    def initialize(sh)
      @shell = sh         # parent shell
      @input = nil        # input filter
    end

    attr_reader :input

    def input=(filter)
      @input = filter
    end

    # call-seq:
    #   each(record_separator=nil) { block }
    #
    # Iterates a block for each line.
    def each(rs = nil)
      rs = @shell.record_separator unless rs
      if @input
        @input.each(rs){|l| yield l}
      end
    end

    # call-seq:
    #   < source
    #
    # Inputs from +source+, which is either a string of a file name or an IO
    # object.
    def < (src)
      case src
      when String
        cat = Cat.new(@shell, src)
        cat | self
      when IO
        self.input = src
        self
      else
        Shell.Fail Error::CantApplyMethod, "<", to.class
      end
    end

    # call-seq:
    #   > source
    #
    # Outputs from +source+, which is either a string of a file name or an IO
    # object.
    def > (to)
      case to
      when String
        dst = @shell.open(to, "w")
        begin
          each(){|l| dst << l}
        ensure
          dst.close
        end
      when IO
        each(){|l| to << l}
      else
        Shell.Fail Error::CantApplyMethod, ">", to.class
      end
      self
    end

    # call-seq:
    #   >> source
    #
    # Appends the output to +source+, which is either a string of a file name
    # or an IO object.
    def >> (to)
      begin
        Shell.cd(@shell.pwd).append(to, self)
      rescue CantApplyMethod
        Shell.Fail Error::CantApplyMethod, ">>", to.class
      end
    end

    # call-seq:
    #   | filter
    #
    # Processes a pipeline.
    def | (filter)
      filter.input = self
      if active?
        @shell.process_controller.start_job filter
      end
      filter
    end

    # call-seq:
    #   filter1 + filter2
    #
    # Outputs +filter1+, and then +filter2+ using Join.new
    def + (filter)
      Join.new(@shell, self, filter)
    end

    def to_a
      ary = []
      each(){|l| ary.push l}
      ary
    end

    def to_s
      str = ""
      each(){|l| str.concat l}
      str
    end

    def inspect
      if @shell.debug.kind_of?(Integer) && @shell.debug > 2
        super
      else
        to_s
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   process-controller.rb                                                                               0100644 0001750 0001750 00000017722 11655163713 037612  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   shell/process-controller.rb -
#       $Release Version: 0.7 $
#       $Revision: 33638 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#
require "forwardable"

require "thread"
require "sync"

class Shell
  class ProcessController

    @ProcessControllers = {}
    @ProcessControllersMonitor = Mutex.new
    @ProcessControllersCV = ConditionVariable.new

    @BlockOutputMonitor = Mutex.new
    @BlockOutputCV = ConditionVariable.new

    class << self
      extend Forwardable

      def_delegator("@ProcessControllersMonitor",
                    "synchronize", "process_controllers_exclusive")

      def active_process_controllers
        process_controllers_exclusive do
          @ProcessControllers.dup
        end
      end

      def activate(pc)
        process_controllers_exclusive do
          @ProcessControllers[pc] ||= 0
          @ProcessControllers[pc] += 1
        end
      end

      def inactivate(pc)
        process_controllers_exclusive do
          if @ProcessControllers[pc]
            if (@ProcessControllers[pc] -= 1) == 0
              @ProcessControllers.delete(pc)
              @ProcessControllersCV.signal
            end
          end
        end
      end

      def each_active_object
        process_controllers_exclusive do
          for ref in @ProcessControllers.keys
            yield ref
          end
        end
      end

      def block_output_synchronize(&b)
        @BlockOutputMonitor.synchronize(&b)
      end

      def wait_to_finish_all_process_controllers
        process_controllers_exclusive do
          while !@ProcessControllers.empty?
            Shell::notify("Process finishing, but active shell exists",
                          "You can use Shell#transact or Shell#check_point for more safe execution.")
            if Shell.debug?
              for pc in @ProcessControllers.keys
                Shell::notify(" Not finished jobs in "+pc.shell.to_s)
                for com in pc.jobs
                  com.notify("  Jobs: %id")
                end
              end
            end
            @ProcessControllersCV.wait(@ProcessControllersMonitor)
          end
        end
      end
    end

    # for shell-command complete finish at this process exit.
    USING_AT_EXIT_WHEN_PROCESS_EXIT = true
    at_exit do
      wait_to_finish_all_process_controllers unless $@
    end

    def initialize(shell)
      @shell = shell
      @waiting_jobs = []
      @active_jobs = []
      @jobs_sync = Sync.new

      @job_monitor = Mutex.new
      @job_condition = ConditionVariable.new
    end

    attr_reader :shell

    def jobs
      jobs = []
      @jobs_sync.synchronize(:SH) do
        jobs.concat @waiting_jobs
        jobs.concat @active_jobs
      end
      jobs
    end

    def active_jobs
      @active_jobs
    end

    def waiting_jobs
      @waiting_jobs
    end

    def jobs_exist?
      @jobs_sync.synchronize(:SH) do
        @active_jobs.empty? or @waiting_jobs.empty?
      end
    end

    def active_jobs_exist?
      @jobs_sync.synchronize(:SH) do
        @active_jobs.empty?
      end
    end

    def waiting_jobs_exist?
      @jobs_sync.synchronize(:SH) do
        @waiting_jobs.empty?
      end
    end

    # schedule a command
    def add_schedule(command)
      @jobs_sync.synchronize(:EX) do
        ProcessController.activate(self)
        if @active_jobs.empty?
          start_job command
        else
          @waiting_jobs.push(command)
        end
      end
    end

    # start a job
    def start_job(command = nil)
      @jobs_sync.synchronize(:EX) do
        if command
          return if command.active?
          @waiting_jobs.delete command
        else
          command = @waiting_jobs.shift
#         command.notify "job(%id) pre-start.", @shell.debug?

          return unless command
        end
        @active_jobs.push command
        command.start
#       command.notify "job(%id) post-start.", @shell.debug?

        # start all jobs that input from the job
        for job in @waiting_jobs.dup
          start_job(job) if job.input == command
        end
#       command.notify "job(%id) post2-start.", @shell.debug?
      end
    end

    def waiting_job?(job)
      @jobs_sync.synchronize(:SH) do
        @waiting_jobs.include?(job)
      end
    end

    def active_job?(job)
      @jobs_sync.synchronize(:SH) do
        @active_jobs.include?(job)
      end
    end

    # terminate a job
    def terminate_job(command)
      @jobs_sync.synchronize(:EX) do
        @active_jobs.delete command
        ProcessController.inactivate(self)
        if @active_jobs.empty?
          command.notify("start_job in terminate_job(%id)", Shell::debug?)
          start_job
        end
      end
    end

    # kill a job
    def kill_job(sig, command)
      @jobs_sync.synchronize(:EX) do
        if @waiting_jobs.delete command
          ProcessController.inactivate(self)
          return
        elsif @active_jobs.include?(command)
          begin
            r = command.kill(sig)
            ProcessController.inactivate(self)
          rescue
            print "Shell: Warn: $!\n" if @shell.verbose?
            return nil
          end
          @active_jobs.delete command
          r
        end
      end
    end

    # wait for all jobs to terminate
    def wait_all_jobs_execution
      @job_monitor.synchronize do
        begin
          while !jobs.empty?
            @job_condition.wait(@job_monitor)
            for job in jobs
              job.notify("waiting job(%id)", Shell::debug?)
            end
          end
        ensure
          redo unless jobs.empty?
        end
      end
    end

    # simple fork
    def sfork(command)
      pipe_me_in, pipe_peer_out = IO.pipe
      pipe_peer_in, pipe_me_out = IO.pipe


      pid = nil
      pid_mutex = Mutex.new
      pid_cv = ConditionVariable.new

      Thread.start do
        ProcessController.block_output_synchronize do
          STDOUT.flush
          ProcessController.each_active_object do |pc|
            for jobs in pc.active_jobs
              jobs.flush
            end
          end

          pid = fork {
            Thread.list.each do |th|
#             th.kill unless [Thread.main, Thread.current].include?(th)
              th.kill unless Thread.current == th
            end

            STDIN.reopen(pipe_peer_in)
            STDOUT.reopen(pipe_peer_out)

            ObjectSpace.each_object(IO) do |io|
              if ![STDIN, STDOUT, STDERR].include?(io)
                io.close unless io.closed?
              end
            end

            yield
          }
        end
        pid_cv.signal

        pipe_peer_in.close
        pipe_peer_out.close
        command.notify "job(%name:##{pid}) start", @shell.debug?

        begin
          _pid = nil
          command.notify("job(%id) start to waiting finish.", @shell.debug?)
          _pid = Process.waitpid(pid, nil)
        rescue Errno::ECHILD
          command.notify "warn: job(%id) was done already waitpid."
          _pid = true
          #     rescue
          #       STDERR.puts $!
        ensure
          command.notify("Job(%id): Wait to finish when Process finished.", @shell.debug?)
          # when the process ends, wait until the command terminates
          if USING_AT_EXIT_WHEN_PROCESS_EXIT or _pid
          else
            command.notify("notice: Process finishing...",
                           "wait for Job[%id] to finish.",
                           "You can use Shell#transact or Shell#check_point for more safe execution.")
            redo
          end

#         command.notify "job(%id) pre-pre-finish.", @shell.debug?
          @job_monitor.synchronize do
#           command.notify "job(%id) pre-finish.", @shell.debug?
            terminate_job(command)
#           command.notify "job(%id) pre-finish2.", @shell.debug?
            @job_condition.signal
            command.notify "job(%id) finish.", @shell.debug?
          end
        end
      end

      pid_mutex.synchronize do
        while !pid
          pid_cv.wait(pid_mutex)
        end
      end

      return pid, pipe_me_in, pipe_me_out
    end
  end
end
                                              system-command.rb                                                                                   0100644 0001750 0001750 00000007147 11655163713 036713  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   shell/system-command.rb -
#       $Release Version: 0.7 $
#       $Revision: 33638 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

require "shell/filter"

class Shell
  class SystemCommand < Filter
    def initialize(sh, command, *opts)
      if t = opts.find{|opt| !opt.kind_of?(String) && opt.class}
        Shell.Fail Error::TypeError, t.class, "String"
      end
      super(sh)
      @command = command
      @opts = opts

      @input_queue = Queue.new
      @pid = nil

      sh.process_controller.add_schedule(self)
    end

    attr_reader :command
    alias name command

    def wait?
      @shell.process_controller.waiting_job?(self)
    end

    def active?
      @shell.process_controller.active_job?(self)
    end

    def input=(inp)
      super
      if active?
        start_export
      end
    end

    def start
      notify([@command, *@opts].join(" "))

      @pid, @pipe_in, @pipe_out = @shell.process_controller.sfork(self) {
        Dir.chdir @shell.pwd
        $0 = @command
        exec(@command, *@opts)
      }
      if @input
        start_export
      end
      start_import
    end

    def flush
      @pipe_out.flush if @pipe_out and !@pipe_out.closed?
    end

    def terminate
      begin
        @pipe_in.close
      rescue IOError
      end
      begin
        @pipe_out.close
      rescue IOError
      end
    end

    def kill(sig)
      if @pid
        Process.kill(sig, @pid)
      end
    end

    def start_import
      notify "Job(%id) start imp-pipe.", @shell.debug?
      rs = @shell.record_separator unless rs
      _eop = true
      Thread.start {
        begin
          while l = @pipe_in.gets
            @input_queue.push l
          end
          _eop = false
        rescue Errno::EPIPE
          _eop = false
        ensure
          if !ProcessController::USING_AT_EXIT_WHEN_PROCESS_EXIT and _eop
            notify("warn: Process finishing...",
                   "wait for Job[%id] to finish pipe importing.",
                   "You can use Shell#transact or Shell#check_point for more safe execution.")
            redo
          end
          notify "job(%id}) close imp-pipe.", @shell.debug?
          @input_queue.push :EOF
          @pipe_in.close
        end
      }
    end

    def start_export
      notify "job(%id) start exp-pipe.", @shell.debug?
      _eop = true
      Thread.start{
        begin
          @input.each do |l|
            ProcessController::block_output_synchronize do
              @pipe_out.print l
            end
          end
          _eop = false
        rescue Errno::EPIPE, Errno::EIO
          _eop = false
        ensure
          if !ProcessController::USING_AT_EXIT_WHEN_PROCESS_EXIT and _eop
            notify("shell: warn: Process finishing...",
                   "wait for Job(%id) to finish pipe exporting.",
                   "You can use Shell#transact or Shell#check_point for more safe execution.")
            redo
          end
          notify "job(%id) close exp-pipe.", @shell.debug?
          @pipe_out.close
        end
      }
    end

    alias super_each each
    def each(rs = nil)
      while (l = @input_queue.pop) != :EOF
        yield l
      end
    end

    # ex)
    #    if you wish to output:
    #       "shell: job(#{@command}:#{@pid}) close pipe-out."
    #    then
    #       mes: "job(%id) close pipe-out."
    #    yorn: Boolean(@shell.debug? or @shell.verbose?)
    def notify(*opts)
      @shell.notify(*opts) do |mes|
        yield mes if iterator?

        mes.gsub!("%id", "#{@command}:##{@pid}")
        mes.gsub!("%name", "#{@command}")
        mes.gsub!("%pid", "#{@pid}")
        mes
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                         version.rb                                                                                          0100644 0001750 0001750 00000000377 12057533613 035433  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/shell                                                     #
#   version.rb - shell version definition file
#       $Release Version: 0.7$
#       $Revision: 38201 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

class Shell # :nodoc:
  @RELEASE_VERSION = "0.7"
  @LAST_UPDATE_DATE = "07/03/20"
end
                                                                                                                                                                                                                                                                 shell.rb                                                                                            0100644 0001750 0001750 00000024463 12057533613 033750  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
#   shell.rb -
#       $Release Version: 0.7 $
#       $Revision: 1.9 $
#       by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

require "e2mmap"

require "thread" unless defined?(Mutex)

require "forwardable"

require "shell/error"
require "shell/command-processor"
require "shell/process-controller"

# Shell implements an idiomatic Ruby interface for common UNIX shell commands.
#
# It provides users the ability to execute commands with filters and pipes,
# like +sh+/+csh+ by using native facilities of Ruby.
#
# == Examples
#
# === Temp file creation
#
# In this example we will create three +tmpFile+'s in three different folders
# under the +/tmp+ directory.
#
#   sh = Shell.cd("/tmp") # Change to the /tmp directory
#   sh.mkdir "shell-test-1" unless sh.exists?("shell-test-1")
#   # make the 'shell-test-1' directory if it doesn't already exist
#   sh.cd("shell-test-1") # Change to the /tmp/shell-test-1 directory
#   for dir in ["dir1", "dir3", "dir5"]
#     if !sh.exists?(dir)
#       sh.mkdir dir # make dir if it doesnt' already exist
#       sh.cd(dir) do
#         # change to the `dir` directory
# 	  f = sh.open("tmpFile", "w") # open a new file in write mode
# 	  f.print "TEST\n"            # write to the file
# 	  f.close                     # close the file handler
#       end
#       print sh.pwd                  # output the process working directory
#     end
#   end
#
# === Temp file creationg with self
#
# This example is identical to the first, except we're using
# CommandProcessor#transact.
#
# CommandProcessor#transact executes the given block against self, in this case
# +sh+; our Shell object. Within the block we can substitute +sh.cd+ to +cd+,
# because the scope within the block uses +sh+ already.
#
#   sh = Shell.cd("/tmp")
#   sh.transact do
#     mkdir "shell-test-1" unless exists?("shell-test-1")
#     cd("shell-test-1")
#     for dir in ["dir1", "dir3", "dir5"]
#       if !exists?(dir)
# 	  mkdir dir
# 	  cd(dir) do
# 	    f = open("tmpFile", "w")
# 	    f.print "TEST\n"
# 	    f.close
# 	  end
# 	  print pwd
#       end
#     end
#   end
#
# === Pipe /etc/printcap into a file
#
# In this example we will read the operating system file +/etc/printcap+,
# generated by +cupsd+, and then output it to a new file relative to the +pwd+
# of +sh+.
#
#   sh = Shell.new
#   sh.cat("/etc/printcap") | sh.tee("tee1") > "tee2"
#   (sh.cat < "/etc/printcap") | sh.tee("tee11") > "tee12"
#   sh.cat("/etc/printcap") | sh.tee("tee1") >> "tee2"
#   (sh.cat < "/etc/printcap") | sh.tee("tee11") >> "tee12"
#
class Shell
  @RCS_ID='-$Id: shell.rb,v 1.9 2002/03/04 12:01:10 keiju Exp keiju $-'

  include Error
  extend Exception2MessageMapper

#  @cascade = true
  # debug: true -> normal debug
  # debug: 1    -> eval definition debug
  # debug: 2    -> detail inspect debug
  @debug = false
  @verbose = true

  @debug_display_process_id = false
  @debug_display_thread_id = true
  @debug_output_mutex = Mutex.new

  class << Shell
    extend Forwardable

    attr_accessor :cascade, :debug, :verbose

#    alias cascade? cascade
    alias debug? debug
    alias verbose? verbose
    @verbose = true

    def debug=(val)
      @debug = val
      @verbose = val if val
    end


    # call-seq:
    #   Shell.cd(path)
    #
    # Creates a new Shell instance with the current working directory
    # set to +path+.
    def cd(path)
      new(path)
    end

    # Returns the directories in the current shell's PATH environment variable
    # as an array of directory names. This sets the system_path for all
    # instances of Shell.
    #
    # Example: If in your current shell, you did:
    #
    #   $ echo $PATH
    #   /usr/bin:/bin:/usr/local/bin
    #
    # Running this method in the above shell would then return:
    #
    #   ["/usr/bin", "/bin", "/usr/local/bin"]
    #
    def default_system_path
      if @default_system_path
        @default_system_path
      else
        ENV["PATH"].split(":")
      end
    end

    # Sets the system_path that new instances of Shell should have as their
    # initial system_path.
    #
    # +path+ should be an array of directory name strings.
    def default_system_path=(path)
      @default_system_path = path
    end

    def default_record_separator
      if @default_record_separator
        @default_record_separator
      else
        $/
      end
    end

    def default_record_separator=(rs)
      @default_record_separator = rs
    end

    # os resource mutex
    mutex_methods = ["unlock", "lock", "locked?", "synchronize", "try_lock", "exclusive_unlock"]
    for m in mutex_methods
      def_delegator("@debug_output_mutex", m, "debug_output_"+m.to_s)
    end

  end

  # call-seq:
  #   Shell.new(pwd, umask) -> obj
  #
  # Creates a Shell object which current directory is set to the process
  # current directory, unless otherwise specified by the +pwd+ argument.
  def initialize(pwd = Dir.pwd, umask = nil)
    @cwd = File.expand_path(pwd)
    @dir_stack = []
    @umask = umask

    @system_path = Shell.default_system_path
    @record_separator = Shell.default_record_separator

    @command_processor = CommandProcessor.new(self)
    @process_controller = ProcessController.new(self)

    @verbose = Shell.verbose
    @debug = Shell.debug
  end

  # Returns the command search path in an array
  attr_reader :system_path

  # Sets the system path (the Shell instance's PATH environment variable).
  #
  # +path+ should be an array of directory name strings.
  def system_path=(path)
    @system_path = path
    rehash
  end


  # Returns the umask
  attr_accessor :umask
  attr_accessor :record_separator
  attr_accessor :verbose, :debug

  def debug=(val)
    @debug = val
    @verbose = val if val
  end

  alias verbose? verbose
  alias debug? debug

  attr_reader :command_processor
  attr_reader :process_controller

  def expand_path(path)
    File.expand_path(path, @cwd)
  end

  # Most Shell commands are defined via CommandProcessor

  #
  # Dir related methods
  #
  # Shell#cwd/dir/getwd/pwd
  # Shell#chdir/cd
  # Shell#pushdir/pushd
  # Shell#popdir/popd
  # Shell#mkdir
  # Shell#rmdir

  # Returns the current working directory.
  attr_reader :cwd
  alias dir cwd
  alias getwd cwd
  alias pwd cwd

  attr_reader :dir_stack
  alias dirs dir_stack

  # call-seq:
  #   Shell.chdir(path)
  #
  # Creates a Shell object which current directory is set to +path+.
  #
  # If a block is given, it restores the current directory when the block ends.
  #
  # If called as iterator, it restores the current directory when the
  # block ends.
  def chdir(path = nil, verbose = @verbose)
    check_point

    if iterator?
      notify("chdir(with block) #{path}") if verbose
      cwd_old = @cwd
      begin
        chdir(path, nil)
        yield
      ensure
        chdir(cwd_old, nil)
      end
    else
      notify("chdir #{path}") if verbose
      path = "~" unless path
      @cwd = expand_path(path)
      notify "current dir: #{@cwd}"
      rehash
      Void.new(self)
    end
  end
  alias cd chdir

  # call-seq:
  #   pushdir(path)
  #   pushdir(path) { &block }
  #
  # Pushes the current directory to the directory stack, changing the current
  # directory to +path+.
  #
  # If +path+ is omitted, it exchanges its current directory and the top of its
  # directory stack.
  #
  # If a block is given, it restores the current directory when the block ends.
  def pushdir(path = nil, verbose = @verbose)
    check_point

    if iterator?
      notify("pushdir(with block) #{path}") if verbose
      pushdir(path, nil)
      begin
        yield
      ensure
        popdir
      end
    elsif path
      notify("pushdir #{path}") if verbose
      @dir_stack.push @cwd
      chdir(path, nil)
      notify "dir stack: [#{@dir_stack.join ', '}]"
      self
    else
      notify("pushdir") if verbose
      if pop = @dir_stack.pop
        @dir_stack.push @cwd
        chdir pop
        notify "dir stack: [#{@dir_stack.join ', '}]"
        self
      else
        Shell.Fail DirStackEmpty
      end
    end
    Void.new(self)
  end
  alias pushd pushdir

  # Pops a directory from the directory stack, and sets the current directory
  # to it.
  def popdir
    check_point

    notify("popdir")
    if pop = @dir_stack.pop
      chdir pop
      notify "dir stack: [#{@dir_stack.join ', '}]"
      self
    else
      Shell.Fail DirStackEmpty
    end
    Void.new(self)
  end
  alias popd popdir

  # Returns a list of scheduled jobs.
  def jobs
    @process_controller.jobs
  end

  # call-seq:
  #   kill(signal, job)
  #
  # Sends the given +signal+ to the given +job+
  def kill(sig, command)
    @process_controller.kill_job(sig, command)
  end

  # Convenience method for Shell::CommandProcessor.def_system_command
  def Shell.def_system_command(command, path = command)
    CommandProcessor.def_system_command(command, path)
  end

  # Convenience method for Shell::CommandProcessor.undef_system_command
  def Shell.undef_system_command(command)
    CommandProcessor.undef_system_command(command)
  end

  # Convenience method for Shell::CommandProcessor.alias_command
  def Shell.alias_command(ali, command, *opts, &block)
    CommandProcessor.alias_command(ali, command, *opts, &block)
  end

  # Convenience method for Shell::CommandProcessor.unalias_command
  def Shell.unalias_command(ali)
    CommandProcessor.unalias_command(ali)
  end

  # Convenience method for Shell::CommandProcessor.install_system_commands
  def Shell.install_system_commands(pre = "sys_")
    CommandProcessor.install_system_commands(pre)
  end

  #
  def inspect
    if debug.kind_of?(Integer) && debug > 2
      super
    else
      to_s
    end
  end

  def self.notify(*opts)
    Shell::debug_output_synchronize do
      if opts[-1].kind_of?(String)
        yorn = verbose?
      else
        yorn = opts.pop
      end
      return unless yorn

      if @debug_display_thread_id
        if @debug_display_process_id
          prefix = "shell(##{Process.pid}:#{Thread.current.to_s.sub("Thread", "Th")}): "
        else
          prefix = "shell(#{Thread.current.to_s.sub("Thread", "Th")}): "
        end
      else
        prefix = "shell: "
      end
      _head = true
      STDERR.print opts.collect{|mes|
        mes = mes.dup
        yield mes if iterator?
        if _head
          _head = false
#         "shell" " + mes
          prefix + mes
        else
          " "* prefix.size + mes
        end
      }.join("\n")+"\n"
    end
  end

  CommandProcessor.initialize
  CommandProcessor.run_config
end
                                                                                                                                                                                                             shellwords.rb                                                                                       0100644 0001750 0001750 00000013703 12047121160 035007  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           ##
# == Manipulates strings like the UNIX Bourne shell
#
# This module manipulates strings according to the word parsing rules
# of the UNIX Bourne shell.
#
# The shellwords() function was originally a port of shellwords.pl,
# but modified to conform to POSIX / SUSv3 (IEEE Std 1003.1-2001 [1]).
#
# === Usage
#
# You can use shellwords to parse a string into a Bourne shell friendly Array.
#
#   require 'shellwords'
#
#   argv = Shellwords.split('three blind "mice"')
#   argv #=> ["three", "blind", "mice"]
#
# Once you've required Shellwords, you can use the #split alias
# String#shellsplit.
#
#   argv = "see how they run".shellsplit
#   argv #=> ["see", "how", "they", "run"]
#
# Be careful you don't leave a quote unmatched.
#
#   argv = "they all ran after the farmer's wife".shellsplit
#        #=> ArgumentError: Unmatched double quote: ...
#
# In this case, you might want to use Shellwords.escape, or it's alias
# String#shellescape.
#
# This method will escape the String for you to safely use with a Bourne shell.
#
#   argv = Shellwords.escape("special's.txt")
#   argv #=> "special\\s.txt"
#   system("cat " + argv)
#
# Shellwords also comes with a core extension for Array, Array#shelljoin.
#
#   argv = %w{ls -lta lib}
#   system(argv.shelljoin)
#
# You can use this method to create an escaped string out of an array of tokens
# separated by a space. In this example we'll use the literal shortcut for
# Array.new.
#
# === Authors
# * Wakou Aoyama
# * Akinori MUSHA <knu@iDaemons.org>
#
# === Contact
# * Akinori MUSHA <knu@iDaemons.org> (current maintainer)
#
# === Resources
#
# 1: {IEEE Std 1003.1-2004}[http://pubs.opengroup.org/onlinepubs/009695399/toc.htm]

module Shellwords
  # Splits a string into an array of tokens in the same way the UNIX
  # Bourne shell does.
  #
  #   argv = Shellwords.split('here are "two words"')
  #   argv #=> ["here", "are", "two words"]
  #
  # String#shellsplit is a shortcut for this function.
  #
  #   argv = 'here are "two words"'.shellsplit
  #   argv #=> ["here", "are", "two words"]
  def shellsplit(line)
    words = []
    field = ''
    line.scan(/\G\s*(?>([^\s\\\'\"]+)|'([^\']*)'|"((?:[^\"\\]|\\.)*)"|(\\.?)|(\S))(\s|\z)?/m) do
      |word, sq, dq, esc, garbage, sep|
      raise ArgumentError, "Unmatched double quote: #{line.inspect}" if garbage
      field << (word || sq || (dq || esc).gsub(/\\(.)/, '\\1'))
      if sep
        words << field
        field = ''
      end
    end
    words
  end

  alias shellwords shellsplit

  module_function :shellsplit, :shellwords

  class << self
    alias split shellsplit
  end

  # Escapes a string so that it can be safely used in a Bourne shell
  # command line.  +str+ can be a non-string object that responds to
  # +to_s+.
  #
  # Note that a resulted string should be used unquoted and is not
  # intended for use in double quotes nor in single quotes.
  #
  #   argv = Shellwords.escape("It's better to give than to receive")
  #   argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"
  #
  # String#shellescape is a shorthand for this function.
  #
  #   argv = "It's better to give than to receive".shellescape
  #   argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"
  #
  #   # Search files in lib for method definitions
  #   pattern = "^[ \t]*def "
  #   open("| grep -Ern #{pattern.shellescape} lib") { |grep|
  #     grep.each_line { |line|
  #       file, lineno, matched_line = line.split(':', 3)
  #       # ...
  #     }
  #   }
  #
  # It is the caller's responsibility to encode the string in the right
  # encoding for the shell environment where this string is used.
  #
  # Multibyte characters are treated as multibyte characters, not bytes.
  #
  # Returns an empty quoted String if +str+ has a length of zero.
  def shellescape(str)
    str = str.to_s

    # An empty argument will be skipped, so return empty quotes.
    return "''" if str.empty?

    str = str.dup

    # Treat multibyte characters as is.  It is caller's responsibility
    # to encode the string in the right encoding for the shell
    # environment.
    str.gsub!(/([^A-Za-z0-9_\-.,:\/@\n])/, "\\\\\\1")

    # A LF cannot be escaped with a backslash because a backslash + LF
    # combo is regarded as line continuation and simply ignored.
    str.gsub!(/\n/, "'\n'")

    return str
  end

  module_function :shellescape

  class << self
    alias escape shellescape
  end

  # Builds a command line string from an argument list, +array+.
  #
  # All elements are joined into a single string with fields separated by a
  # space, where each element is escaped for Bourne shell and stringified using
  # +to_s+.
  #
  #   ary = ["There's", "a", "time", "and", "place", "for", "everything"]
  #   argv = Shellwords.join(ary)
  #   argv #=> "There\\'s a time and place for everything"
  #
  # Array#shelljoin is a shortcut for this function.
  #
  #   ary = ["Don't", "rock", "the", "boat"]
  #   argv = ary.shelljoin
  #   argv #=> "Don\\'t rock the boat"
  #
  # You can also mix non-string objects in the elements as allowed in Array#join.
  #
  #   output = `#{['ps', '-p', $$].shelljoin}`
  #
  def shelljoin(array)
    array.map { |arg| shellescape(arg) }.join(' ')
  end

  module_function :shelljoin

  class << self
    alias join shelljoin
  end
end

class String
  # call-seq:
  #   str.shellsplit => array
  #
  # Splits +str+ into an array of tokens in the same way the UNIX
  # Bourne shell does.
  #
  # See Shellwords.shellsplit for details.
  def shellsplit
    Shellwords.split(self)
  end

  # call-seq:
  #   str.shellescape => string
  #
  # Escapes +str+ so that it can be safely used in a Bourne shell
  # command line.
  #
  # See Shellwords.shellescape for details.
  def shellescape
    Shellwords.escape(self)
  end
end

class Array
  # call-seq:
  #   array.shelljoin => string
  #
  # Builds a command line string from an argument list +array+ joining
  # all elements escaped for Bourne shell and separated by a space.
  #
  # See Shellwords.shelljoin for details.
  def shelljoin
    Shellwords.join(self)
  end
end
                                                             singleton.rb                                                                                        0100644 0001750 0001750 00000010022 11564751442 034631  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           require 'thread'

# The Singleton module implements the Singleton pattern.
#
# == Usage
#
# To use Singleton, include the module in your class.
#
#    class Klass
#       include Singleton
#       # ...
#    end
#
# This ensures that only one instance of Klass can be created.
#
#      a,b  = Klass.instance, Klass.instance
#
#      a == b
#      # => true
#
#      Klass.new
#      # => NoMethodError - new is private ...
#
# The instance is created at upon the first call of Klass.instance().
#
#      class OtherKlass
#        include Singleton
#        # ...
#      end
#
#      ObjectSpace.each_object(OtherKlass){}
#      # => 0
#
#      OtherKlass.instance
#      ObjectSpace.each_object(OtherKlass){}
#      # => 1
#
#
# This behavior is preserved under inheritance and cloning.
#
# == Implementation
#
# This above is achieved by:
#
# *  Making Klass.new and Klass.allocate private.
#
# *  Overriding Klass.inherited(sub_klass) and Klass.clone() to ensure that the
#    Singleton properties are kept when inherited and cloned.
#
# *  Providing the Klass.instance() method that returns the same object each
#    time it is called.
#
# *  Overriding Klass._load(str) to call Klass.instance().
#
# *  Overriding Klass#clone and Klass#dup to raise TypeErrors to prevent
#    cloning or duping.
#
# == Singleton and Marshal
#
# By default Singleton's #_dump(depth) returns the empty string. Marshalling by
# default will strip state information, e.g. instance variables and taint
# state, from the instance. Classes using Singleton can provide custom
# _load(str) and _dump(depth) methods to retain some of the previous state of
# the instance.
#
#    require 'singleton'
#
#    class Example
#      include Singleton
#      attr_accessor :keep, :strip
#      def _dump(depth)
#        # this strips the @strip information from the instance
#        Marshal.dump(@keep, depth)
#      end
#
#      def self._load(str)
#        instance.keep = Marshal.load(str)
#        instance
#      end
#    end
#
#    a = Example.instance
#    a.keep = "keep this"
#    a.strip = "get rid of this"
#    a.taint
#
#    stored_state = Marshal.dump(a)
#
#    a.keep = nil
#    a.strip = nil
#    b = Marshal.load(stored_state)
#    p a == b  #  => true
#    p a.keep  #  => "keep this"
#    p a.strip #  => nil
#
module Singleton
  # Raises a TypeError to prevent cloning.
  def clone
    raise TypeError, "can't clone instance of singleton #{self.class}"
  end

  # Raises a TypeError to prevent duping.
  def dup
    raise TypeError, "can't dup instance of singleton #{self.class}"
  end

  # By default, do not retain any state when marshalling.
  def _dump(depth = -1)
    ''
  end

  module SingletonClassMethods # :nodoc:

    def clone # :nodoc:
      Singleton.__init__(super)
    end

    # By default calls instance(). Override to retain singleton state.
    def _load(str)
      instance
    end

    private

    def inherited(sub_klass)
      super
      Singleton.__init__(sub_klass)
    end
  end

  class << Singleton # :nodoc:
    def __init__(klass) # :nodoc:
      klass.instance_eval {
        @singleton__instance__ = nil
        @singleton__mutex__ = Mutex.new
      }
      def klass.instance # :nodoc:
        return @singleton__instance__ if @singleton__instance__
        @singleton__mutex__.synchronize {
          return @singleton__instance__ if @singleton__instance__
          @singleton__instance__ = new()
        }
        @singleton__instance__
      end
      klass
    end

    private

    # extending an object with Singleton is a bad idea
    undef_method :extend_object

    def append_features(mod)
      #  help out people counting on transitive mixins
      unless mod.instance_of?(Class)
        raise TypeError, "Inclusion of the OO-Singleton module in module #{mod}"
      end
      super
    end

    def included(klass)
      super
      klass.private_class_method :new, :allocate
      klass.extend SingletonClassMethods
      Singleton.__init__(klass)
    end
  end

  ##
  # :singleton-method: _load
  #  By default calls instance(). Override to retain singleton state.
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              socket.rb                                                                                           0100644 0001750 0001750 00000063410 12566207012 034120  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           require 'socket.so'

class Addrinfo
  # creates an Addrinfo object from the arguments.
  #
  # The arguments are interpreted as similar to self.
  #
  #   Addrinfo.tcp("0.0.0.0", 4649).family_addrinfo("www.ruby-lang.org", 80)
  #   #=> #<Addrinfo: 221.186.184.68:80 TCP (www.ruby-lang.org:80)>
  #
  #   Addrinfo.unix("/tmp/sock").family_addrinfo("/tmp/sock2")
  #   #=> #<Addrinfo: /tmp/sock2 SOCK_STREAM>
  #
  def family_addrinfo(*args)
    if args.empty?
      raise ArgumentError, "no address specified"
    elsif Addrinfo === args.first
      raise ArgumentError, "too many arguments" if args.length != 1
      addrinfo = args.first
      if (self.pfamily != addrinfo.pfamily) ||
         (self.socktype != addrinfo.socktype)
        raise ArgumentError, "Addrinfo type mismatch"
      end
      addrinfo
    elsif self.ip?
      raise ArgumentError, "IP address needs host and port but #{args.length} arguments given" if args.length != 2
      host, port = args
      Addrinfo.getaddrinfo(host, port, self.pfamily, self.socktype, self.protocol)[0]
    elsif self.unix?
      raise ArgumentError, "UNIX socket needs single path argument but #{args.length} arguments given" if args.length != 1
      path, = args
      Addrinfo.unix(path)
    else
      raise ArgumentError, "unexpected family"
    end
  end

  # creates a new Socket connected to the address of +local_addrinfo+.
  #
  # If _local_addrinfo_ is nil, the address of the socket is not bound.
  #
  # The _timeout_ specify the seconds for timeout.
  # Errno::ETIMEDOUT is raised when timeout occur.
  #
  # If a block is given the created socket is yielded for each address.
  #
  def connect_internal(local_addrinfo, timeout=nil) # :yields: socket
    sock = Socket.new(self.pfamily, self.socktype, self.protocol)
    begin
      sock.ipv6only! if self.ipv6?
      sock.bind local_addrinfo if local_addrinfo
      if timeout
        begin
          sock.connect_nonblock(self)
        rescue IO::WaitWritable
          if !IO.select(nil, [sock], nil, timeout)
            raise Errno::ETIMEDOUT, 'user specified timeout'
          end
          begin
            sock.connect_nonblock(self) # check connection failure
          rescue Errno::EISCONN
          end
        end
      else
        sock.connect(self)
      end
    rescue Exception
      sock.close
      raise
    end
    if block_given?
      begin
        yield sock
      ensure
        sock.close if !sock.closed?
      end
    else
      sock
    end
  end
  private :connect_internal

  # :call-seq:
  #   addrinfo.connect_from([local_addr_args], [opts]) {|socket| ... }
  #   addrinfo.connect_from([local_addr_args], [opts])
  #
  # creates a socket connected to the address of self.
  #
  # If one or more arguments given as _local_addr_args_,
  # it is used as the local address of the socket.
  # _local_addr_args_ is given for family_addrinfo to obtain actual address.
  #
  # If _local_addr_args_ is not given, the local address of the socket is not bound.
  #
  # The optional last argument _opts_ is options represented by a hash.
  # _opts_ may have following options:
  #
  # [:timeout] specify the timeout in seconds.
  #
  # If a block is given, it is called with the socket and the value of the block is returned.
  # The socket is returned otherwise.
  #
  #   Addrinfo.tcp("www.ruby-lang.org", 80).connect_from("0.0.0.0", 4649) {|s|
  #     s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #     puts s.read
  #   }
  #
  #   # Addrinfo object can be taken for the argument.
  #   Addrinfo.tcp("www.ruby-lang.org", 80).connect_from(Addrinfo.tcp("0.0.0.0", 4649)) {|s|
  #     s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #     puts s.read
  #   }
  #
  def connect_from(*args, &block)
    opts = Hash === args.last ? args.pop : {}
    local_addr_args = args
    connect_internal(family_addrinfo(*local_addr_args), opts[:timeout], &block)
  end

  # :call-seq:
  #   addrinfo.connect([opts]) {|socket| ... }
  #   addrinfo.connect([opts])
  #
  # creates a socket connected to the address of self.
  #
  # The optional argument _opts_ is options represented by a hash.
  # _opts_ may have following options:
  #
  # [:timeout] specify the timeout in seconds.
  #
  # If a block is given, it is called with the socket and the value of the block is returned.
  # The socket is returned otherwise.
  #
  #   Addrinfo.tcp("www.ruby-lang.org", 80).connect {|s|
  #     s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #     puts s.read
  #   }
  #
  def connect(opts={}, &block)
    connect_internal(nil, opts[:timeout], &block)
  end

  # :call-seq:
  #   addrinfo.connect_to([remote_addr_args], [opts]) {|socket| ... }
  #   addrinfo.connect_to([remote_addr_args], [opts])
  #
  # creates a socket connected to _remote_addr_args_ and bound to self.
  #
  # The optional last argument _opts_ is options represented by a hash.
  # _opts_ may have following options:
  #
  # [:timeout] specify the timeout in seconds.
  #
  # If a block is given, it is called with the socket and the value of the block is returned.
  # The socket is returned otherwise.
  #
  #   Addrinfo.tcp("0.0.0.0", 4649).connect_to("www.ruby-lang.org", 80) {|s|
  #     s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #     puts s.read
  #   }
  #
  def connect_to(*args, &block)
    opts = Hash === args.last ? args.pop : {}
    remote_addr_args = args
    remote_addrinfo = family_addrinfo(*remote_addr_args)
    remote_addrinfo.send(:connect_internal, self, opts[:timeout], &block)
  end

  # creates a socket bound to self.
  #
  # If a block is given, it is called with the socket and the value of the block is returned.
  # The socket is returned otherwise.
  #
  #   Addrinfo.udp("0.0.0.0", 9981).bind {|s|
  #     s.local_address.connect {|s| s.send "hello", 0 }
  #     p s.recv(10) #=> "hello"
  #   }
  #
  def bind
    sock = Socket.new(self.pfamily, self.socktype, self.protocol)
    begin
      sock.ipv6only! if self.ipv6?
      sock.setsockopt(:SOCKET, :REUSEADDR, 1)
      sock.bind(self)
    rescue Exception
      sock.close
      raise
    end
    if block_given?
      begin
        yield sock
      ensure
        sock.close if !sock.closed?
      end
    else
      sock
    end
  end

  # creates a listening socket bound to self.
  def listen(backlog=Socket::SOMAXCONN)
    sock = Socket.new(self.pfamily, self.socktype, self.protocol)
    begin
      sock.ipv6only! if self.ipv6?
      sock.setsockopt(:SOCKET, :REUSEADDR, 1)
      sock.bind(self)
      sock.listen(backlog)
    rescue Exception
      sock.close
      raise
    end
    if block_given?
      begin
        yield sock
      ensure
        sock.close if !sock.closed?
      end
    else
      sock
    end
  end

  # iterates over the list of Addrinfo objects obtained by Addrinfo.getaddrinfo.
  #
  #   Addrinfo.foreach(nil, 80) {|x| p x }
  #   #=> #<Addrinfo: 127.0.0.1:80 TCP (:80)>
  #   #   #<Addrinfo: 127.0.0.1:80 UDP (:80)>
  #   #   #<Addrinfo: [::1]:80 TCP (:80)>
  #   #   #<Addrinfo: [::1]:80 UDP (:80)>
  #
  def self.foreach(nodename, service, family=nil, socktype=nil, protocol=nil, flags=nil, &block)
    Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol, flags).each(&block)
  end
end

class BasicSocket < IO
  # Returns an address of the socket suitable for connect in the local machine.
  #
  # This method returns _self_.local_address, except following condition.
  #
  # - IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address (127.0.0.1).
  # - IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).
  #
  # If the local address is not suitable for connect, SocketError is raised.
  # IPv4 and IPv6 address which port is 0 is not suitable for connect.
  # Unix domain socket which has no path is not suitable for connect.
  #
  #   Addrinfo.tcp("0.0.0.0", 0).listen {|serv|
  #     p serv.connect_address #=> #<Addrinfo: 127.0.0.1:53660 TCP>
  #     serv.connect_address.connect {|c|
  #       s, _ = serv.accept
  #       p [c, s] #=> [#<Socket:fd 4>, #<Socket:fd 6>]
  #     }
  #   }
  #
  def connect_address
    addr = local_address
    afamily = addr.afamily
    if afamily == Socket::AF_INET
      raise SocketError, "unbound IPv4 socket" if addr.ip_port == 0
      if addr.ip_address == "0.0.0.0"
        addr = Addrinfo.new(["AF_INET", addr.ip_port, nil, "127.0.0.1"], addr.pfamily, addr.socktype, addr.protocol)
      end
    elsif defined?(Socket::AF_INET6) && afamily == Socket::AF_INET6
      raise SocketError, "unbound IPv6 socket" if addr.ip_port == 0
      if addr.ip_address == "::"
        addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
      elsif addr.ip_address == "0.0.0.0" # MacOS X 10.4 returns "a.b.c.d" for IPv4-mapped IPv6 address.
        addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
      elsif addr.ip_address == "::ffff:0.0.0.0" # MacOS X 10.6 returns "::ffff:a.b.c.d" for IPv4-mapped IPv6 address.
        addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
      end
    elsif defined?(Socket::AF_UNIX) && afamily == Socket::AF_UNIX
      raise SocketError, "unbound Unix socket" if addr.unix_path == ""
    end
    addr
  end
end

class Socket < BasicSocket
  # enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.
  def ipv6only!
    if defined? Socket::IPV6_V6ONLY
      self.setsockopt(:IPV6, :V6ONLY, 1)
    end
  end

  # :call-seq:
  #   Socket.tcp(host, port, local_host=nil, local_port=nil, [opts]) {|socket| ... }
  #   Socket.tcp(host, port, local_host=nil, local_port=nil, [opts])
  #
  # creates a new socket object connected to host:port using TCP/IP.
  #
  # If local_host:local_port is given,
  # the socket is bound to it.
  #
  # The optional last argument _opts_ is options represented by a hash.
  # _opts_ may have following options:
  #
  # [:connect_timeout] specify the timeout in seconds.
  #
  # If a block is given, the block is called with the socket.
  # The value of the block is returned.
  # The socket is closed when this method returns.
  #
  # The optional last argument _opts_ is options represented by a hash.
  # _opts_ may have following options:
  #
  # [:timeout] specify the timeout in seconds.
  #
  # If no block is given, the socket is returned.
  #
  #   Socket.tcp("www.ruby-lang.org", 80) {|sock|
  #     sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #     sock.close_write
  #     puts sock.read
  #   }
  #
  def self.tcp(host, port, *rest) # :yield: socket
    opts = Hash === rest.last ? rest.pop : {}
    raise ArgumentError, "wrong number of arguments (#{rest.length} for 2)" if 2 < rest.length
    local_host, local_port = rest
    last_error = nil
    ret = nil

    connect_timeout = opts[:connect_timeout]

    local_addr_list = nil
    if local_host != nil || local_port != nil
      local_addr_list = Addrinfo.getaddrinfo(local_host, local_port, nil, :STREAM, nil)
    end

    Addrinfo.foreach(host, port, nil, :STREAM) {|ai|
      if local_addr_list
        local_addr = local_addr_list.find {|local_ai| local_ai.afamily == ai.afamily }
        next if !local_addr
      else
        local_addr = nil
      end
      begin
        sock = local_addr ?
          ai.connect_from(local_addr, :timeout => connect_timeout) :
          ai.connect(:timeout => connect_timeout)
      rescue SystemCallError
        last_error = $!
        next
      end
      ret = sock
      break
    }
    if !ret
      if last_error
        raise last_error
      else
        raise SocketError, "no appropriate local address"
      end
    end
    if block_given?
      begin
        yield ret
      ensure
        ret.close if !ret.closed?
      end
    else
      ret
    end
  end

  # :stopdoc:
  def self.ip_sockets_port0(ai_list, reuseaddr)
    sockets = []
    begin
      sockets.clear
      port = nil
      ai_list.each {|ai|
        begin
          s = Socket.new(ai.pfamily, ai.socktype, ai.protocol)
        rescue SystemCallError
          next
        end
        sockets << s
        s.ipv6only! if ai.ipv6?
        if reuseaddr
          s.setsockopt(:SOCKET, :REUSEADDR, 1)
        end
        if !port
          s.bind(ai)
          port = s.local_address.ip_port
        else
          s.bind(ai.family_addrinfo(ai.ip_address, port))
        end
      }
    rescue Errno::EADDRINUSE
      sockets.each {|s| s.close }
      retry
    rescue Exception
      sockets.each {|s| s.close }
      raise
    end
    sockets
  end
  class << self
    private :ip_sockets_port0
  end

  def self.tcp_server_sockets_port0(host)
    ai_list = Addrinfo.getaddrinfo(host, 0, nil, :STREAM, nil, Socket::AI_PASSIVE)
    sockets = ip_sockets_port0(ai_list, true)
    begin
      sockets.each {|s|
        s.listen(Socket::SOMAXCONN)
      }
    rescue Exception
      sockets.each {|s| s.close }
      raise
    end
    sockets
  end
  class << self
    private :tcp_server_sockets_port0
  end
  # :startdoc:

  # creates TCP/IP server sockets for _host_ and _port_.
  # _host_ is optional.
  #
  # If no block given,
  # it returns an array of listening sockets.
  #
  # If a block is given, the block is called with the sockets.
  # The value of the block is returned.
  # The socket is closed when this method returns.
  #
  # If _port_ is 0, actual port number is chosen dynamically.
  # However all sockets in the result has same port number.
  #
  #   # tcp_server_sockets returns two sockets.
  #   sockets = Socket.tcp_server_sockets(1296)
  #   p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #
  #   # The sockets contains IPv6 and IPv4 sockets.
  #   sockets.each {|s| p s.local_address }
  #   #=> #<Addrinfo: [::]:1296 TCP>
  #   #   #<Addrinfo: 0.0.0.0:1296 TCP>
  #
  #   # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
  #   sockets = Socket.tcp_server_sockets(0)
  #   sockets.each {|s| p s.local_address }
  #   #=> #<Addrinfo: [::]:53114 TCP>
  #   #   #<Addrinfo: 0.0.0.0:53114 TCP>
  #
  #   # The block is called with the sockets.
  #   Socket.tcp_server_sockets(0) {|sockets|
  #     p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #   }
  #
  def self.tcp_server_sockets(host=nil, port)
    if port == 0
      sockets = tcp_server_sockets_port0(host)
    else
      last_error = nil
      sockets = []
      begin
        Addrinfo.foreach(host, port, nil, :STREAM, nil, Socket::AI_PASSIVE) {|ai|
          begin
            s = ai.listen
          rescue SystemCallError
            last_error = $!
            next
          end
          sockets << s
        }
        if sockets.empty?
          raise last_error
        end
      rescue Exception
        sockets.each {|s| s.close }
        raise
      end
    end
    if block_given?
      begin
        yield sockets
      ensure
        sockets.each {|s| s.close if !s.closed? }
      end
    else
      sockets
    end
  end

  # yield socket and client address for each a connection accepted via given sockets.
  #
  # The arguments are a list of sockets.
  # The individual argument should be a socket or an array of sockets.
  #
  # This method yields the block sequentially.
  # It means that the next connection is not accepted until the block returns.
  # So concurrent mechanism, thread for example, should be used to service multiple clients at a time.
  #
  def self.accept_loop(*sockets) # :yield: socket, client_addrinfo
    sockets.flatten!(1)
    if sockets.empty?
      raise ArgumentError, "no sockets"
    end
    loop {
      readable, _, _ = IO.select(sockets)
      readable.each {|r|
        begin
          sock, addr = r.accept_nonblock
        rescue IO::WaitReadable
          next
        end
        yield sock, addr
      }
    }
  end

  # creates a TCP/IP server on _port_ and calls the block for each connection accepted.
  # The block is called with a socket and a client_address as an Addrinfo object.
  #
  # If _host_ is specified, it is used with _port_ to determine the server addresses.
  #
  # The socket is *not* closed when the block returns.
  # So application should close it explicitly.
  #
  # This method calls the block sequentially.
  # It means that the next connection is not accepted until the block returns.
  # So concurrent mechanism, thread for example, should be used to service multiple clients at a time.
  #
  # Note that Addrinfo.getaddrinfo is used to determine the server socket addresses.
  # When Addrinfo.getaddrinfo returns two or more addresses,
  # IPv4 and IPv6 address for example,
  # all of them are used.
  # Socket.tcp_server_loop succeeds if one socket can be used at least.
  #
  #   # Sequential echo server.
  #   # It services only one client at a time.
  #   Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #     begin
  #       IO.copy_stream(sock, sock)
  #     ensure
  #       sock.close
  #     end
  #   }
  #
  #   # Threaded echo server
  #   # It services multiple clients at a time.
  #   # Note that it may accept connections too much.
  #   Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #     Thread.new {
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #   }
  #
  def self.tcp_server_loop(host=nil, port, &b) # :yield: socket, client_addrinfo
    tcp_server_sockets(host, port) {|sockets|
      accept_loop(sockets, &b)
    }
  end

  # :call-seq:
  #   Socket.udp_server_sockets([host, ] port)
  #
  # Creates UDP/IP sockets for a UDP server.
  #
  # If no block given, it returns an array of sockets.
  #
  # If a block is given, the block is called with the sockets.
  # The value of the block is returned.
  # The sockets are closed when this method returns.
  #
  # If _port_ is zero, some port is chosen.
  # But the chosen port is used for the all sockets.
  #
  #   # UDP/IP echo server
  #   Socket.udp_server_sockets(0) {|sockets|
  #     p sockets.first.local_address.ip_port     #=> 32963
  #     Socket.udp_server_loop_on(sockets) {|msg, msg_src|
  #       msg_src.reply msg
  #     }
  #   }
  #
  def self.udp_server_sockets(host=nil, port)
    last_error = nil
    sockets = []

    ipv6_recvpktinfo = nil
    if defined? Socket::AncillaryData
      if defined? Socket::IPV6_RECVPKTINFO # RFC 3542
        ipv6_recvpktinfo = Socket::IPV6_RECVPKTINFO
      elsif defined? Socket::IPV6_PKTINFO # RFC 2292
        ipv6_recvpktinfo = Socket::IPV6_PKTINFO
      end
    end

    local_addrs = Socket.ip_address_list

    ip_list = []
    Addrinfo.foreach(host, port, nil, :DGRAM, nil, Socket::AI_PASSIVE) {|ai|
      if ai.ipv4? && ai.ip_address == "0.0.0.0"
        local_addrs.each {|a|
          next if !a.ipv4?
          ip_list << Addrinfo.new(a.to_sockaddr, :INET, :DGRAM, 0);
        }
      elsif ai.ipv6? && ai.ip_address == "::" && !ipv6_recvpktinfo
        local_addrs.each {|a|
          next if !a.ipv6?
          ip_list << Addrinfo.new(a.to_sockaddr, :INET6, :DGRAM, 0);
        }
      else
        ip_list << ai
      end
    }

    if port == 0
      sockets = ip_sockets_port0(ip_list, false)
    else
      ip_list.each {|ip|
        ai = Addrinfo.udp(ip.ip_address, port)
        begin
          s = ai.bind
        rescue SystemCallError
          last_error = $!
          next
        end
        sockets << s
      }
      if sockets.empty?
        raise last_error
      end
    end

    sockets.each {|s|
      ai = s.local_address
      if ipv6_recvpktinfo && ai.ipv6? && ai.ip_address == "::"
        s.setsockopt(:IPV6, ipv6_recvpktinfo, 1)
      end
    }

    if block_given?
      begin
        yield sockets
      ensure
        sockets.each {|s| s.close if !s.closed? } if sockets
      end
    else
      sockets
    end
  end

  # :call-seq:
  #   Socket.udp_server_recv(sockets) {|msg, msg_src| ... }
  #
  # Receive UDP/IP packets from the given _sockets_.
  # For each packet received, the block is called.
  #
  # The block receives _msg_ and _msg_src_.
  # _msg_ is a string which is the payload of the received packet.
  # _msg_src_ is a Socket::UDPSource object which is used for reply.
  #
  # Socket.udp_server_loop can be implemented using this method as follows.
  #
  #   udp_server_sockets(host, port) {|sockets|
  #     loop {
  #       readable, _, _ = IO.select(sockets)
  #       udp_server_recv(readable) {|msg, msg_src| ... }
  #     }
  #   }
  #
  def self.udp_server_recv(sockets)
    sockets.each {|r|
      begin
        msg, sender_addrinfo, _, *controls = r.recvmsg_nonblock
      rescue IO::WaitReadable
        next
      end
      ai = r.local_address
      if ai.ipv6? and pktinfo = controls.find {|c| c.cmsg_is?(:IPV6, :PKTINFO) }
        ai = Addrinfo.udp(pktinfo.ipv6_pktinfo_addr.ip_address, ai.ip_port)
        yield msg, UDPSource.new(sender_addrinfo, ai) {|reply_msg|
          r.sendmsg reply_msg, 0, sender_addrinfo, pktinfo
        }
      else
        yield msg, UDPSource.new(sender_addrinfo, ai) {|reply_msg|
          r.send reply_msg, 0, sender_addrinfo
        }
      end
    }
  end

  # :call-seq:
  #   Socket.udp_server_loop_on(sockets) {|msg, msg_src| ... }
  #
  # Run UDP/IP server loop on the given sockets.
  #
  # The return value of Socket.udp_server_sockets is appropriate for the argument.
  #
  # It calls the block for each message received.
  #
  def self.udp_server_loop_on(sockets, &b) # :yield: msg, msg_src
    loop {
      readable, _, _ = IO.select(sockets)
      udp_server_recv(readable, &b)
    }
  end

  # :call-seq:
  #   Socket.udp_server_loop(port) {|msg, msg_src| ... }
  #   Socket.udp_server_loop(host, port) {|msg, msg_src| ... }
  #
  # creates a UDP/IP server on _port_ and calls the block for each message arrived.
  # The block is called with the message and its source information.
  #
  # This method allocates sockets internally using _port_.
  # If _host_ is specified, it is used conjunction with _port_ to determine the server addresses.
  #
  # The _msg_ is a string.
  #
  # The _msg_src_ is a Socket::UDPSource object.
  # It is used for reply.
  #
  #   # UDP/IP echo server.
  #   Socket.udp_server_loop(9261) {|msg, msg_src|
  #     msg_src.reply msg
  #   }
  #
  def self.udp_server_loop(host=nil, port, &b) # :yield: message, message_source
    udp_server_sockets(host, port) {|sockets|
      udp_server_loop_on(sockets, &b)
    }
  end

  # UDP/IP address information used by Socket.udp_server_loop.
  class UDPSource
    # +remote_address+ is an Addrinfo object.
    #
    # +local_address+ is an Addrinfo object.
    #
    # +reply_proc+ is a Proc used to send reply back to the source.
    def initialize(remote_address, local_address, &reply_proc)
      @remote_address = remote_address
      @local_address = local_address
      @reply_proc = reply_proc
    end

    # Address of the source
    attr_reader :remote_address

    # Local address
    attr_reader :local_address

    def inspect # :nodoc:
      "\#<#{self.class}: #{@remote_address.inspect_sockaddr} to #{@local_address.inspect_sockaddr}>"
    end

    # Sends the String +msg+ to the source
    def reply(msg)
      @reply_proc.call msg
    end
  end

  # creates a new socket connected to path using UNIX socket socket.
  #
  # If a block is given, the block is called with the socket.
  # The value of the block is returned.
  # The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #   # talk to /tmp/sock socket.
  #   Socket.unix("/tmp/sock") {|sock|
  #     t = Thread.new { IO.copy_stream(sock, STDOUT) }
  #     IO.copy_stream(STDIN, sock)
  #     t.join
  #   }
  #
  def self.unix(path) # :yield: socket
    addr = Addrinfo.unix(path)
    sock = addr.connect
    if block_given?
      begin
        yield sock
      ensure
        sock.close if !sock.closed?
      end
    else
      sock
    end
  end

  # creates a UNIX server socket on _path_
  #
  # If no block given, it returns a listening socket.
  #
  # If a block is given, it is called with the socket and the block value is returned.
  # When the block exits, the socket is closed and the socket file is removed.
  #
  #   socket = Socket.unix_server_socket("/tmp/s")
  #   p socket                  #=> #<Socket:fd 3>
  #   p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>
  #
  #   Socket.unix_server_socket("/tmp/sock") {|s|
  #     p s                     #=> #<Socket:fd 3>
  #     p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
  #   }
  #
  def self.unix_server_socket(path)
    if !unix_socket_abstract_name?(path)
      begin
        st = File.lstat(path)
      rescue Errno::ENOENT
      end
      if st && st.socket? && st.owned?
        File.unlink path
      end
    end
    s = Addrinfo.unix(path).listen
    if block_given?
      begin
        yield s
      ensure
        s.close if !s.closed?
        if !unix_socket_abstract_name?(path)
          File.unlink path
        end
      end
    else
      s
    end
  end

  class << self
    private

    def unix_socket_abstract_name?(path)
      /linux/ =~ RUBY_PLATFORM && /\A(\0|\z)/ =~ path
    end
  end

  # creates a UNIX socket server on _path_.
  # It calls the block for each socket accepted.
  #
  # If _host_ is specified, it is used with _port_ to determine the server ports.
  #
  # The socket is *not* closed when the block returns.
  # So application should close it.
  #
  # This method deletes the socket file pointed by _path_ at first if
  # the file is a socket file and it is owned by the user of the application.
  # This is safe only if the directory of _path_ is not changed by a malicious user.
  # So don't use /tmp/malicious-users-directory/socket.
  # Note that /tmp/socket and /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.
  #
  #   # Sequential echo server.
  #   # It services only one client at a time.
  #   Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
  #     begin
  #       IO.copy_stream(sock, sock)
  #     ensure
  #       sock.close
  #     end
  #   }
  #
  def self.unix_server_loop(path, &b) # :yield: socket, client_addrinfo
    unix_server_socket(path) {|serv|
      accept_loop(serv, &b)
    }
  end

end

                                                                                                                                                                                                                                                        sync.rb                                                                                             0100644 0001750 0001750 00000016406 12065555222 033612  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
#   sync.rb - 2 phase lock with counter
#       $Release Version: 1.0$
#       $Revision: 38577 $
#       by Keiju ISHITSUKA(keiju@ishitsuka.com)
#
# --
#  Sync_m, Synchronizer_m
#  Usage:
#   obj.extend(Sync_m)
#   or
#   class Foo
#       include Sync_m
#       :
#   end
#
#   Sync_m#sync_mode
#   Sync_m#sync_locked?, locked?
#   Sync_m#sync_shared?, shared?
#   Sync_m#sync_exclusive?, sync_exclusive?
#   Sync_m#sync_try_lock, try_lock
#   Sync_m#sync_lock, lock
#   Sync_m#sync_unlock, unlock
#
#  Sync, Synchronizer:
#  Usage:
#   sync = Sync.new
#
#   Sync#mode
#   Sync#locked?
#   Sync#shared?
#   Sync#exclusive?
#   Sync#try_lock(mode) -- mode = :EX, :SH, :UN
#   Sync#lock(mode)     -- mode = :EX, :SH, :UN
#   Sync#unlock
#   Sync#synchronize(mode) {...}
#
#

unless defined? Thread
  raise "Thread not available for this ruby interpreter"
end

##
# A module that provides a two-phase lock with a counter.

module Sync_m
  # lock mode
  UN = :UN
  SH = :SH
  EX = :EX

  # exceptions
  class Err < StandardError
    def Err.Fail(*opt)
      fail self, sprintf(self::Message, *opt)
    end

    class UnknownLocker < Err
      Message = "Thread(%s) not locked."
      def UnknownLocker.Fail(th)
        super(th.inspect)
      end
    end

    class LockModeFailer < Err
      Message = "Unknown lock mode(%s)"
      def LockModeFailer.Fail(mode)
        if mode.id2name
          mode = id2name
        end
        super(mode)
      end
    end
  end

  def Sync_m.define_aliases(cl)
    cl.module_eval %q{
      alias locked? sync_locked?
      alias shared? sync_shared?
      alias exclusive? sync_exclusive?
      alias lock sync_lock
      alias unlock sync_unlock
      alias try_lock sync_try_lock
      alias synchronize sync_synchronize
    }
  end

  def Sync_m.append_features(cl)
    super
    # do nothing for Modules
    # make aliases for Classes.
    define_aliases(cl) unless cl.instance_of?(Module)
    self
  end

  def Sync_m.extend_object(obj)
    super
    obj.sync_extend
  end

  def sync_extend
    unless (defined? locked? and
            defined? shared? and
            defined? exclusive? and
            defined? lock and
            defined? unlock and
            defined? try_lock and
            defined? synchronize)
      Sync_m.define_aliases(singleton_class)
    end
    sync_initialize
  end

  # accessing
  def sync_locked?
    sync_mode != UN
  end

  def sync_shared?
    sync_mode == SH
  end

  def sync_exclusive?
    sync_mode == EX
  end

  # locking methods.
  def sync_try_lock(mode = EX)
    return unlock if mode == UN
    @sync_mutex.synchronize do
      sync_try_lock_sub(mode)
    end
  end

  def sync_lock(m = EX)
    return unlock if m == UN
    Thread.handle_interrupt(StandardError => :on_blocking) do
      while true
        @sync_mutex.synchronize do
          begin
            if sync_try_lock_sub(m)
              return self
            else
              if sync_sh_locker[Thread.current]
                sync_upgrade_waiting.push [Thread.current, sync_sh_locker[Thread.current]]
                sync_sh_locker.delete(Thread.current)
              else
                unless sync_waiting.include?(Thread.current) || sync_upgrade_waiting.reverse_each.any?{|w| w.first == Thread.current }
                  sync_waiting.push Thread.current
                end
              end
              @sync_mutex.sleep
            end
          ensure
            sync_waiting.delete(Thread.current)
          end
        end
      end
    end
    self
  end

  def sync_unlock(m = EX)
    wakeup_threads = []
    @sync_mutex.synchronize do
      if sync_mode == UN
        Err::UnknownLocker.Fail(Thread.current)
      end

      m = sync_mode if m == EX and sync_mode == SH

      runnable = false
      case m
      when UN
        Err::UnknownLocker.Fail(Thread.current)

      when EX
        if sync_ex_locker == Thread.current
          if (self.sync_ex_count = sync_ex_count - 1) == 0
            self.sync_ex_locker = nil
            if sync_sh_locker.include?(Thread.current)
              self.sync_mode = SH
            else
              self.sync_mode = UN
            end
            runnable = true
          end
        else
          Err::UnknownLocker.Fail(Thread.current)
        end

      when SH
        if (count = sync_sh_locker[Thread.current]).nil?
          Err::UnknownLocker.Fail(Thread.current)
        else
          if (sync_sh_locker[Thread.current] = count - 1) == 0
            sync_sh_locker.delete(Thread.current)
            if sync_sh_locker.empty? and sync_ex_count == 0
              self.sync_mode = UN
              runnable = true
            end
          end
        end
      end

      if runnable
        if sync_upgrade_waiting.size > 0
          th, count = sync_upgrade_waiting.shift
          sync_sh_locker[th] = count
          th.wakeup
          wakeup_threads.push th
        else
          wait = sync_waiting
          self.sync_waiting = []
          for th in wait
            th.wakeup
            wakeup_threads.push th
          end
        end
      end
    end
    for th in wakeup_threads
      th.run
    end
    self
  end

  def sync_synchronize(mode = EX)
    Thread.handle_interrupt(StandardError => :on_blocking) do
      sync_lock(mode)
      begin
        yield
      ensure
        sync_unlock
      end
    end
  end

  attr_accessor :sync_mode

  attr_accessor :sync_waiting
  attr_accessor :sync_upgrade_waiting
  attr_accessor :sync_sh_locker
  attr_accessor :sync_ex_locker
  attr_accessor :sync_ex_count

  def sync_inspect
    sync_iv = instance_variables.select{|iv| /^@sync_/ =~ iv.id2name}.collect{|iv| iv.id2name + '=' + instance_eval(iv.id2name).inspect}.join(",")
    print "<#{self.class}.extend Sync_m: #{inspect}, <Sync_m: #{sync_iv}>"
  end

  private

  def sync_initialize
    @sync_mode = UN
    @sync_waiting = []
    @sync_upgrade_waiting = []
    @sync_sh_locker = Hash.new
    @sync_ex_locker = nil
    @sync_ex_count = 0

    @sync_mutex = Mutex.new
  end

  def initialize(*args)
    super
    sync_initialize
  end

  def sync_try_lock_sub(m)
    case m
    when SH
      case sync_mode
      when UN
        self.sync_mode = m
        sync_sh_locker[Thread.current] = 1
        ret = true
      when SH
        count = 0 unless count = sync_sh_locker[Thread.current]
        sync_sh_locker[Thread.current] = count + 1
        ret = true
      when EX
        # in EX mode, lock will upgrade to EX lock
        if sync_ex_locker == Thread.current
          self.sync_ex_count = sync_ex_count + 1
          ret = true
        else
          ret = false
        end
      end
    when EX
      if sync_mode == UN or
          sync_mode == SH && sync_sh_locker.size == 1 && sync_sh_locker.include?(Thread.current)
        self.sync_mode = m
        self.sync_ex_locker = Thread.current
        self.sync_ex_count = 1
        ret = true
      elsif sync_mode == EX && sync_ex_locker == Thread.current
        self.sync_ex_count = sync_ex_count + 1
        ret = true
      else
        ret = false
      end
    else
      Err::LockModeFailer.Fail mode
    end
    return ret
  end
end

##
# An alias for Sync_m from sync.rb

Synchronizer_m = Sync_m

##
# A class that providesa two-phase lock with a counter.  See Sync_m for
# details.

class Sync
  include Sync_m
end

##
# An alias for Sync from sync.rb.  See Sync_m for details.

Synchronizer = Sync
                                                                                                                                                                                                                                                          syslog/                                                                                             0040755 0001750 0001750 00000000000 12612224745 033626  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           logger.rb                                                                                           0100644 0001750 0001750 00000012264 12566207013 035431  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/syslog                                                    require 'syslog'
require 'logger'

##
# Syslog::Logger is a Logger work-alike that logs via syslog instead of to a
# file.  You can use Syslog::Logger to aggregate logs between multiple
# machines.
#
# By default, Syslog::Logger uses the program name 'ruby', but this can be
# changed via the first argument to Syslog::Logger.new.
#
# NOTE! You can only set the Syslog::Logger program name when you initialize
# Syslog::Logger for the first time.  This is a limitation of the way
# Syslog::Logger uses syslog (and in some ways, a limitation of the way
# syslog(3) works).  Attempts to change Syslog::Logger's program name after
# the first initialization will be ignored.
#
# === Example
#
# The following will log to syslogd on your local machine:
#
#   require 'syslog/logger'
#
#   log = Syslog::Logger.new 'my_program'
#   log.info 'this line will be logged via syslog(3)'
#
# You may need to perform some syslog.conf setup first.  For a BSD machine add
# the following lines to /etc/syslog.conf:
#
#  !my_program
#  *.*                                             /var/log/my_program.log
#
# Then touch /var/log/my_program.log and signal syslogd with a HUP
# (killall -HUP syslogd, on FreeBSD).
#
# If you wish to have logs automatically roll over and archive, see the
# newsyslog.conf(5) and newsyslog(8) man pages.

class Syslog::Logger
  # Default formatter for log messages.
  class Formatter
    def call severity, time, progname, msg
      clean msg
    end

    private

    ##
    # Clean up messages so they're nice and pretty.

    def clean message
      message = message.to_s.strip
      message.gsub!(/\e\[[0-9;]*m/, '') # remove useless ansi color codes
      return message
    end
  end

  ##
  # The version of Syslog::Logger you are using.

  VERSION = '2.0'

  ##
  # Maps Logger warning types to syslog(3) warning types.
  #
  # Messages from ruby applications are not considered as critical as messages
  # from other system daemons using syslog(3), so most messages are reduced by
  # one level.  For example, a fatal message for ruby's Logger is considered
  # an error for syslog(3).

  LEVEL_MAP = {
    ::Logger::UNKNOWN => Syslog::LOG_ALERT,
    ::Logger::FATAL   => Syslog::LOG_ERR,
    ::Logger::ERROR   => Syslog::LOG_WARNING,
    ::Logger::WARN    => Syslog::LOG_NOTICE,
    ::Logger::INFO    => Syslog::LOG_INFO,
    ::Logger::DEBUG   => Syslog::LOG_DEBUG,
  }

  ##
  # Returns the internal Syslog object that is initialized when the
  # first instance is created.

  def self.syslog
    @@syslog
  end

  ##
  # Specifies the internal Syslog object to be used.

  def self.syslog= syslog
    @@syslog = syslog
  end

  ##
  # Builds a methods for level +meth+.

  def self.make_methods meth
    level = ::Logger.const_get(meth.upcase)
    eval <<-EOM, nil, __FILE__, __LINE__ + 1
      def #{meth}(message = nil, &block)
        add(#{level}, message, &block)
      end

      def #{meth}?
        @level <= #{level}
      end
    EOM
  end

  ##
  # :method: unknown
  #
  # Logs a +message+ at the unknown (syslog alert) log level, or logs the
  # message returned from the block.

  ##
  # :method: fatal
  #
  # Logs a +message+ at the fatal (syslog err) log level, or logs the message
  # returned from the block.

  ##
  # :method: error
  #
  # Logs a +message+ at the error (syslog warning) log level, or logs the
  # message returned from the block.

  ##
  # :method: warn
  #
  # Logs a +message+ at the warn (syslog notice) log level, or logs the
  # message returned from the block.

  ##
  # :method: info
  #
  # Logs a +message+ at the info (syslog info) log level, or logs the message
  # returned from the block.

  ##
  # :method: debug
  #
  # Logs a +message+ at the debug (syslog debug) log level, or logs the
  # message returned from the block.

  Logger::Severity::constants.each do |severity|
    make_methods severity.downcase
  end

  ##
  # Log level for Logger compatibility.

  attr_accessor :level

  # Logging formatter, as a +Proc+ that will take four arguments and
  # return the formatted message. The arguments are:
  #
  # +severity+:: The Severity of the log message.
  # +time+:: A Time instance representing when the message was logged.
  # +progname+:: The #progname configured, or passed to the logger method.
  # +msg+:: The _Object_ the user passed to the log message; not necessarily a
  #         String.
  #
  # The block should return an Object that can be written to the logging
  # device via +write+.  The default formatter is used when no formatter is
  # set.
  attr_accessor :formatter

  ##
  # Fills in variables for Logger compatibility.  If this is the first
  # instance of Syslog::Logger, +program_name+ may be set to change the logged
  # program name.
  #
  # Due to the way syslog works, only one program name may be chosen.

  def initialize program_name = 'ruby'
    @level = ::Logger::DEBUG
    @formatter = Formatter.new

    @@syslog ||= Syslog.open(program_name)
  end

  ##
  # Almost duplicates Logger#add.  +progname+ is ignored.

  def add severity, message = nil, progname = nil, &block
    severity ||= ::Logger::UNKNOWN
    @level <= severity and
      @@syslog.log LEVEL_MAP[severity], '%s', formatter.call(severity, Time.now, progname, (message || block.call))
    true
  end
end

                                                                                                                                                                                                                                                                                                                                            tempfile.rb                                                                                         0100644 0001750 0001750 00000024235 12225300044 034426  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
# tempfile - manipulates temporary files
#
# $Id: tempfile.rb 43229 2013-10-09 16:11:16Z nagachika $
#

require 'delegate'
require 'tmpdir'
require 'thread'

# A utility class for managing temporary files. When you create a Tempfile
# object, it will create a temporary file with a unique filename. A Tempfile
# objects behaves just like a File object, and you can perform all the usual
# file operations on it: reading data, writing data, changing its permissions,
# etc. So although this class does not explicitly document all instance methods
# supported by File, you can in fact call any File instance method on a
# Tempfile object.
#
# == Synopsis
#
#   require 'tempfile'
#
#   file = Tempfile.new('foo')
#   file.path      # => A unique filename in the OS's temp directory,
#                  #    e.g.: "/tmp/foo.24722.0"
#                  #    This filename contains 'foo' in its basename.
#   file.write("hello world")
#   file.rewind
#   file.read      # => "hello world"
#   file.close
#   file.unlink    # deletes the temp file
#
# == Good practices
#
# === Explicit close
#
# When a Tempfile object is garbage collected, or when the Ruby interpreter
# exits, its associated temporary file is automatically deleted. This means
# that's it's unnecessary to explicitly delete a Tempfile after use, though
# it's good practice to do so: not explicitly deleting unused Tempfiles can
# potentially leave behind large amounts of tempfiles on the filesystem
# until they're garbage collected. The existence of these temp files can make
# it harder to determine a new Tempfile filename.
#
# Therefore, one should always call #unlink or close in an ensure block, like
# this:
#
#   file = Tempfile.new('foo')
#   begin
#      ...do something with file...
#   ensure
#      file.close
#      file.unlink   # deletes the temp file
#   end
#
# === Unlink after creation
#
# On POSIX systems, it's possible to unlink a file right after creating it,
# and before closing it. This removes the filesystem entry without closing
# the file handle, so it ensures that only the processes that already had
# the file handle open can access the file's contents. It's strongly
# recommended that you do this if you do not want any other processes to
# be able to read from or write to the Tempfile, and you do not need to
# know the Tempfile's filename either.
#
# For example, a practical use case for unlink-after-creation would be this:
# you need a large byte buffer that's too large to comfortably fit in RAM,
# e.g. when you're writing a web server and you want to buffer the client's
# file upload data.
#
# Please refer to #unlink for more information and a code example.
#
# == Minor notes
#
# Tempfile's filename picking method is both thread-safe and inter-process-safe:
# it guarantees that no other threads or processes will pick the same filename.
#
# Tempfile itself however may not be entirely thread-safe. If you access the
# same Tempfile object from multiple threads then you should protect it with a
# mutex.
class Tempfile < DelegateClass(File)
  include Dir::Tmpname

  # call-seq:
  #    new(basename, [tmpdir = Dir.tmpdir], [options])
  #
  # Creates a temporary file with permissions 0600 (= only readable and
  # writable by the owner) and opens it with mode "w+".
  #
  # The +basename+ parameter is used to determine the name of the
  # temporary file. You can either pass a String or an Array with
  # 2 String elements. In the former form, the temporary file's base
  # name will begin with the given string. In the latter form,
  # the temporary file's base name will begin with the array's first
  # element, and end with the second element. For example:
  #
  #   file = Tempfile.new('hello')
  #   file.path  # => something like: "/tmp/hello2843-8392-92849382--0"
  #
  #   # Use the Array form to enforce an extension in the filename:
  #   file = Tempfile.new(['hello', '.jpg'])
  #   file.path  # => something like: "/tmp/hello2843-8392-92849382--0.jpg"
  #
  # The temporary file will be placed in the directory as specified
  # by the +tmpdir+ parameter. By default, this is +Dir.tmpdir+.
  # When $SAFE > 0 and the given +tmpdir+ is tainted, it uses
  # '/tmp' as the temporary directory. Please note that ENV values
  # are tainted by default, and +Dir.tmpdir+'s return value might
  # come from environment variables (e.g. <tt>$TMPDIR</tt>).
  #
  #   file = Tempfile.new('hello', '/home/aisaka')
  #   file.path  # => something like: "/home/aisaka/hello2843-8392-92849382--0"
  #
  # You can also pass an options hash. Under the hood, Tempfile creates
  # the temporary file using +File.open+. These options will be passed to
  # +File.open+. This is mostly useful for specifying encoding
  # options, e.g.:
  #
  #   Tempfile.new('hello', '/home/aisaka', :encoding => 'ascii-8bit')
  #
  #   # You can also omit the 'tmpdir' parameter:
  #   Tempfile.new('hello', :encoding => 'ascii-8bit')
  #
  # === Exceptions
  #
  # If Tempfile.new cannot find a unique filename within a limited
  # number of tries, then it will raise an exception.
  def initialize(basename, *rest)
    if block_given?
      warn "Tempfile.new doesn't call the given block."
    end
    @data = []
    @clean_proc = Remover.new(@data)
    ObjectSpace.define_finalizer(self, @clean_proc)

    create(basename, *rest) do |tmpname, n, opts|
      mode = File::RDWR|File::CREAT|File::EXCL
      perm = 0600
      if opts
        mode |= opts.delete(:mode) || 0
        opts[:perm] = perm
        perm = nil
      else
        opts = perm
      end
      @data[1] = @tmpfile = File.open(tmpname, mode, opts)
      @data[0] = @tmpname = tmpname
      @mode = mode & ~(File::CREAT|File::EXCL)
      perm or opts.freeze
      @opts = opts
    end

    super(@tmpfile)
  end

  # Opens or reopens the file with mode "r+".
  def open
    @tmpfile.close if @tmpfile
    @tmpfile = File.open(@tmpname, @mode, @opts)
    @data[1] = @tmpfile
    __setobj__(@tmpfile)
  end

  def _close    # :nodoc:
    begin
      @tmpfile.close if @tmpfile
    ensure
      @tmpfile = nil
      @data[1] = nil if @data
    end
  end
  protected :_close

  # Closes the file. If +unlink_now+ is true, then the file will be unlinked
  # (deleted) after closing. Of course, you can choose to later call #unlink
  # if you do not unlink it now.
  #
  # If you don't explicitly unlink the temporary file, the removal
  # will be delayed until the object is finalized.
  def close(unlink_now=false)
    if unlink_now
      close!
    else
      _close
    end
  end

  # Closes and unlinks (deletes) the file. Has the same effect as called
  # <tt>close(true)</tt>.
  def close!
    _close
    unlink
  end

  # Unlinks (deletes) the file from the filesystem. One should always unlink
  # the file after using it, as is explained in the "Explicit close" good
  # practice section in the Tempfile overview:
  #
  #   file = Tempfile.new('foo')
  #   begin
  #      ...do something with file...
  #   ensure
  #      file.close
  #      file.unlink   # deletes the temp file
  #   end
  #
  # === Unlink-before-close
  #
  # On POSIX systems it's possible to unlink a file before closing it. This
  # practice is explained in detail in the Tempfile overview (section
  # "Unlink after creation"); please refer there for more information.
  #
  # However, unlink-before-close may not be supported on non-POSIX operating
  # systems. Microsoft Windows is the most notable case: unlinking a non-closed
  # file will result in an error, which this method will silently ignore. If
  # you want to practice unlink-before-close whenever possible, then you should
  # write code like this:
  #
  #   file = Tempfile.new('foo')
  #   file.unlink   # On Windows this silently fails.
  #   begin
  #      ... do something with file ...
  #   ensure
  #      file.close!   # Closes the file handle. If the file wasn't unlinked
  #                    # because #unlink failed, then this method will attempt
  #                    # to do so again.
  #   end
  def unlink
    return unless @tmpname
    begin
      File.unlink(@tmpname)
    rescue Errno::ENOENT
    rescue Errno::EACCES
      # may not be able to unlink on Windows; just ignore
      return
    end
    # remove tmpname from remover
    @data[0] = @data[1] = nil
    @tmpname = nil
    ObjectSpace.undefine_finalizer(self)
  end
  alias delete unlink

  # Returns the full path name of the temporary file.
  # This will be nil if #unlink has been called.
  def path
    @tmpname
  end

  # Returns the size of the temporary file.  As a side effect, the IO
  # buffer is flushed before determining the size.
  def size
    if @tmpfile
      @tmpfile.flush
      @tmpfile.stat.size
    elsif @tmpname
      File.size(@tmpname)
    else
      0
    end
  end
  alias length size

  def inspect
    "#<#{self.class}:#{path}>"
  end

  # :stopdoc:
  class Remover
    def initialize(data)
      @pid = $$
      @data = data
    end

    def call(*args)
      return if @pid != $$

      path, tmpfile = *@data

      STDERR.print "removing ", path, "..." if $DEBUG

      tmpfile.close if tmpfile

      if path
        begin
          File.unlink(path)
        rescue Errno::ENOENT
        end
      end

      STDERR.print "done\n" if $DEBUG
    end
  end
  # :startdoc:

  class << self
    # Creates a new Tempfile.
    #
    # If no block is given, this is a synonym for Tempfile.new.
    #
    # If a block is given, then a Tempfile object will be constructed,
    # and the block is run with said object as argument. The Tempfile
    # object will be automatically closed after the block terminates.
    # The call returns the value of the block.
    #
    # In any case, all arguments (+*args+) will be passed to Tempfile.new.
    #
    #   Tempfile.open('foo', '/home/temp') do |f|
    #      ... do something with f ...
    #   end
    #
    #   # Equivalent:
    #   f = Tempfile.open('foo', '/home/temp')
    #   begin
    #      ... do something with f ...
    #   ensure
    #      f.close
    #   end
    def open(*args)
      tempfile = new(*args)

      if block_given?
        begin
          yield(tempfile)
        ensure
          tempfile.close
        end
      else
        tempfile
      end
    end
  end
end

if __FILE__ == $0
#  $DEBUG = true
  f = Tempfile.new("foo")
  f.print("foo\n")
  f.close
  f.open
  p f.gets # => "foo\n"
  f.close!
end
                                                                                                                                                                                                                                                                                                                                                                   test/                                                                                               0040755 0001750 0001750 00000000000 12612224745 033265  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           unit/                                                                                               0040755 0001750 0001750 00000000000 12612224745 034244  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/test                                                      assertions.rb                                                                                       0100644 0001750 0001750 00000025540 12131570240 036754  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/test/unit                                                 require 'minitest/unit'
require 'pp'

module Test
  module Unit
    module Assertions
      include MiniTest::Assertions

      def mu_pp(obj) #:nodoc:
        obj.pretty_inspect.chomp
      end

      MINI_DIR = File.join(File.dirname(File.dirname(File.expand_path(__FILE__))), "minitest") #:nodoc:

      UNASSIGNED = Object.new # :nodoc:

      # :call-seq:
      #   assert( test, failure_message = UNASSIGNED )
      #
      #Tests if +test+ is true.
      #
      #+msg+ may be a String or a Proc. If +msg+ is a String, it will be used
      #as the failure message. Otherwise, the result of calling +msg+ will be
      #used as the message if the assertion fails.
      #
      #If no +msg+ is given, a default message will be used.
      #
      #    assert(false, "This was expected to be true")
      def assert(test, msg = UNASSIGNED)
        case msg
        when UNASSIGNED
          msg = nil
        when String, Proc
        else
          bt = caller.reject { |s| s.rindex(MINI_DIR, 0) }
          raise ArgumentError, "assertion message must be String or Proc, but #{msg.class} was given.", bt
        end
        super
      end

      # :call-seq:
      #   assert_block( failure_message = nil )
      #
      #Tests the result of the given block. If the block does not return true,
      #the assertion will fail. The optional +failure_message+ argument is the same as in
      #Assertions#assert.
      #
      #    assert_block do
      #      [1, 2, 3].any? { |num| num < 1 }
      #    end
      def assert_block(*msgs)
        assert yield, *msgs
      end

      # :call-seq:
      #   assert_raise( *args, &block )
      #
      #Tests if the given block raises an exception. Acceptable exception
      #types maye be given as optional arguments. If the last argument is a
      #String, it will be used as the error message.
      #
      #    assert_raise do #Fails, no Exceptions are raised
      #    end
      #
      #    assert_raise NameError do
      #      puts x  #Raises NameError, so assertion succeeds
      #    end
      def assert_raise(*args, &b)
        assert_raises(*args, &b)
      end

      # :call-seq:
      #   assert_nothing_raised( *args, &block )
      #
      #If any exceptions are given as arguments, the assertion will
      #fail if one of those exceptions are raised. Otherwise, the test fails
      #if any exceptions are raised.
      #
      #The final argument may be a failure message.
      #
      #    assert_nothing_raised RuntimeError do
      #      raise Exception #Assertion passes, Exception is not a RuntimeError
      #    end
      #
      #    assert_nothing_raised do
      #      raise Exception #Assertion fails
      #    end
      def assert_nothing_raised(*args)
        self._assertions += 1
        if Module === args.last
          msg = nil
        else
          msg = args.pop
        end
        begin
          line = __LINE__; yield
        rescue MiniTest::Skip
          raise
        rescue Exception => e
          bt = e.backtrace
          as = e.instance_of?(MiniTest::Assertion)
          if as
            ans = /\A#{Regexp.quote(__FILE__)}:#{line}:in /o
            bt.reject! {|ln| ans =~ ln}
          end
          if ((args.empty? && !as) ||
              args.any? {|a| a.instance_of?(Module) ? e.is_a?(a) : e.class == a })
            msg = message(msg) { "Exception raised:\n<#{mu_pp(e)}>" }
            raise MiniTest::Assertion, msg.call, bt
          else
            raise
          end
        end
        nil
      end

      # :call-seq:
      #   assert_nothing_thrown( failure_message = nil, &block )
      #
      #Fails if the given block uses a call to Kernel#throw.
      #
      #An optional failure message may be provided as the final argument.
      #
      #    assert_nothing_thrown "Something was thrown!" do
      #      throw :problem?
      #    end
      def assert_nothing_thrown(msg=nil)
        begin
          yield
        rescue ArgumentError => error
          raise error if /\Auncaught throw (.+)\z/m !~ error.message
          msg = message(msg) { "<#{$1}> was thrown when nothing was expected" }
          flunk(msg)
        end
        assert(true, "Expected nothing to be thrown")
      end

      # :call-seq:
      #   assert_equal( expected, actual, failure_message = nil )
      #
      #Tests if +expected+ is equal to +actual+.
      #
      #An optional failure message may be provided as the final argument.
      def assert_equal(exp, act, msg = nil)
        msg = message(msg) {
          exp_str = mu_pp(exp)
          act_str = mu_pp(act)
          exp_comment = ''
          act_comment = ''
          if exp_str == act_str
            if (exp.is_a?(String) && act.is_a?(String)) ||
               (exp.is_a?(Regexp) && act.is_a?(Regexp))
              exp_comment = " (#{exp.encoding})"
              act_comment = " (#{act.encoding})"
            elsif exp.is_a?(Float) && act.is_a?(Float)
              exp_str = "%\#.#{Float::DIG+2}g" % exp
              act_str = "%\#.#{Float::DIG+2}g" % act
            elsif exp.is_a?(Time) && act.is_a?(Time)
              if exp.subsec * 1000_000_000 == exp.nsec
                exp_comment = " (#{exp.nsec}[ns])"
              else
                exp_comment = " (subsec=#{exp.subsec})"
              end
              if act.subsec * 1000_000_000 == act.nsec
                act_comment = " (#{act.nsec}[ns])"
              else
                act_comment = " (subsec=#{act.subsec})"
              end
            elsif exp.class != act.class
              # a subclass of Range, for example.
              exp_comment = " (#{exp.class})"
              act_comment = " (#{act.class})"
            end
          elsif !Encoding.compatible?(exp_str, act_str)
            if exp.is_a?(String) && act.is_a?(String)
              exp_str = exp.dump
              act_str = act.dump
              exp_comment = " (#{exp.encoding})"
              act_comment = " (#{act.encoding})"
            else
              exp_str = exp_str.dump
              act_str = act_str.dump
            end
          end
          "<#{exp_str}>#{exp_comment} expected but was\n<#{act_str}>#{act_comment}"
        }
        assert(exp == act, msg)
      end

      # :call-seq:
      #   assert_not_nil( expression, failure_message = nil )
      #
      #Tests if +expression+ is not nil.
      #
      #An optional failure message may be provided as the final argument.
      def assert_not_nil(exp, msg=nil)
        msg = message(msg) { "<#{mu_pp(exp)}> expected to not be nil" }
        assert(!exp.nil?, msg)
      end

      # :call-seq:
      #   assert_not_equal( expected, actual, failure_message = nil )
      #
      #Tests if +expected+ is not equal to +actual+.
      #
      #An optional failure message may be provided as the final argument.
      def assert_not_equal(exp, act, msg=nil)
        msg = message(msg) { "<#{mu_pp(exp)}> expected to be != to\n<#{mu_pp(act)}>" }
        assert(exp != act, msg)
      end

      # :call-seq:
      #   assert_no_match( regexp, string, failure_message = nil )
      #
      #Tests if the given Regexp does not match a given String.
      #
      #An optional failure message may be provided as the final argument.
      def assert_no_match(regexp, string, msg=nil)
        assert_instance_of(Regexp, regexp, "The first argument to assert_no_match should be a Regexp.")
        self._assertions -= 1
        msg = message(msg) { "<#{mu_pp(regexp)}> expected to not match\n<#{mu_pp(string)}>" }
        assert(regexp !~ string, msg)
      end

      # :call-seq:
      #   assert_not_same( expected, actual, failure_message = nil )
      #
      #Tests if +expected+ is not the same object as +actual+.
      #This test uses Object#equal? to test equality.
      #
      #An optional failure message may be provided as the final argument.
      #
      #    assert_not_same("x", "x") #Succeeds
      def assert_not_same(expected, actual, message="")
        msg = message(msg) { build_message(message, <<EOT, expected, expected.__id__, actual, actual.__id__) }
<?>
with id <?> expected to not be equal\\? to
<?>
with id <?>.
EOT
        assert(!actual.equal?(expected), msg)
      end

      # :call-seq:
      #   assert_respond_to( object, method, failure_message = nil )
      #
      #Tests if the given Object responds to +method+.
      #
      #An optional failure message may be provided as the final argument.
      #
      #    assert_respond_to("hello", :reverse)  #Succeeds
      #    assert_respond_to("hello", :does_not_exist)  #Fails
      def assert_respond_to obj, (meth, priv), msg = nil
        if priv
          msg = message(msg) {
            "Expected #{mu_pp(obj)} (#{obj.class}) to respond to ##{meth}#{" privately" if priv}"
          }
          return assert obj.respond_to?(meth, priv), msg
        end
        #get rid of overcounting
        super if !caller[0].rindex(MINI_DIR, 0) || !obj.respond_to?(meth)
      end

      # :call-seq:
      #   assert_send( +send_array+, failure_message = nil )
      #
      # Passes if the method send returns a true value.
      #
      # +send_array+ is composed of:
      # * A receiver
      # * A method
      # * Arguments to the method
      #
      # Example:
      #   assert_send([[1, 2], :member?, 1]) # -> pass
      #   assert_send([[1, 2], :member?, 4]) # -> fail
      def assert_send send_ary, m = nil
        recv, msg, *args = send_ary
        m = message(m) {
          if args.empty?
            argsstr = ""
          else
            (argsstr = mu_pp(args)).sub!(/\A\[(.*)\]\z/m, '(\1)')
          end
          "Expected #{mu_pp(recv)}.#{msg}#{argsstr} to return true"
        }
        assert recv.__send__(msg, *args), m
      end

      # :call-seq:
      #   assert_not_send( +send_array+, failure_message = nil )
      #
      # Passes if the method send doesn't return a true value.
      #
      # +send_array+ is composed of:
      # * A receiver
      # * A method
      # * Arguments to the method
      #
      # Example:
      #   assert_not_send([[1, 2], :member?, 1]) # -> fail
      #   assert_not_send([[1, 2], :member?, 4]) # -> pass
      def assert_not_send send_ary, m = nil
        recv, msg, *args = send_ary
        m = message(m) {
          if args.empty?
            argsstr = ""
          else
            (argsstr = mu_pp(args)).sub!(/\A\[(.*)\]\z/m, '(\1)')
          end
          "Expected #{mu_pp(recv)}.#{msg}#{argsstr} to return false"
        }
        assert !recv.__send__(msg, *args), m
      end

      ms = instance_methods(true).map {|sym| sym.to_s }
      ms.grep(/\Arefute_/) do |m|
        mname = ('assert_not_' << m.to_s[/.*?_(.*)/, 1])
        alias_method(mname, m) unless ms.include? mname
      end
      alias assert_include assert_includes
      alias assert_not_include assert_not_includes

      def build_message(head, template=nil, *arguments) #:nodoc:
        template &&= template.chomp
        template.gsub(/\G((?:[^\\]|\\.)*?)(\\)?\?/) { $1 + ($2 ? "?" : mu_pp(arguments.shift)) }
      end
    end
  end
end
                                                                                                                                                                parallel.rb                                                                                         0100644 0001750 0001750 00000011137 12400550052 036351  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/test/unit                                                 require 'test/unit'

module Test
  module Unit
    class Worker < Runner
      class << self
        undef autorun
      end

      alias orig_run_suite mini_run_suite
      undef _run_suite
      undef _run_suites
      undef run

      def increment_io(orig)
        *rest, io = 32.times.inject([orig.dup]){|ios, | ios << ios.last.dup }
        rest.each(&:close)
        io
      end

      def _run_suites(suites, type)
        suites.map do |suite|
          _run_suite(suite, type)
        end
      end

      def _run_suite(suite, type)
        @partial_report = []
        orig_testout = MiniTest::Unit.output
        i,o = IO.pipe

        MiniTest::Unit.output = o
        orig_stdin, orig_stdout = $stdin, $stdout

        th = Thread.new do
          begin
            while buf = (self.verbose ? i.gets : i.read(5))
              _report "p", buf
            end
          rescue IOError
          rescue Errno::EPIPE
          end
        end

        e, f, s = @errors, @failures, @skips

        begin
          result = orig_run_suite(suite, type)
        rescue Interrupt
          @need_exit = true
          result = [nil,nil]
        end

        MiniTest::Unit.output = orig_testout
        $stdin = orig_stdin
        $stdout = orig_stdout

        o.close
        begin
          th.join
        rescue IOError
          raise unless ["stream closed","closed stream"].include? $!.message
        end
        i.close

        result << @partial_report
        @partial_report = nil
        result << [@errors-e,@failures-f,@skips-s]
        result << ($: - @old_loadpath)
        result << suite.name

        begin
          _report "done", Marshal.dump(result)
        rescue Errno::EPIPE; end
        return result
      ensure
        MiniTest::Unit.output = orig_stdout
        $stdin = orig_stdin
        $stdout = orig_stdout
        o.close if o && !o.closed?
        i.close if i && !i.closed?
      end

      def run(args = [])
        process_args args
        @@stop_auto_run = true
        @opts = @options.dup
        @need_exit = false

        @old_loadpath = []
        begin
          begin
            @stdout = increment_io(STDOUT)
            @stdin = increment_io(STDIN)
          rescue
            exit 2
          end
          exit 2 unless @stdout && @stdin

          @stdout.sync = true
          _report "ready!"
          while buf = @stdin.gets
            case buf.chomp
            when /^loadpath (.+?)$/
              @old_loadpath = $:.dup
              $:.push(*Marshal.load($1.unpack("m")[0].force_encoding("ASCII-8BIT"))).uniq!
            when /^run (.+?) (.+?)$/
              _report "okay"

              @options = @opts.dup
              suites = MiniTest::Unit::TestCase.test_suites

              begin
                require $1
              rescue LoadError
                _report "after", Marshal.dump([$1, ProxyError.new($!)])
                _report "ready"
                next
              end
              _run_suites MiniTest::Unit::TestCase.test_suites-suites, $2.to_sym

              if @need_exit
                begin
                  _report "bye"
                rescue Errno::EPIPE; end
                exit
              else
                _report "ready"
              end
            when /^quit$/
              begin
                _report "bye"
              rescue Errno::EPIPE; end
              exit
            end
          end
        rescue Errno::EPIPE
        rescue Exception => e
          begin
            trace = e.backtrace
            err = ["#{trace.shift}: #{e.message} (#{e.class})"] + trace.map{|t| t.prepend("\t") }

            _report "bye", Marshal.dump(err.join("\n"))
          rescue Errno::EPIPE;end
          exit
        ensure
          @stdin.close if @stdin
          @stdout.close if @stdout
        end
      end

      def _report(res, *args)
        res = "#{res} #{args.pack("m0")}" unless args.empty?
        @stdout.puts(res)
      end

      def puke(klass, meth, e)
        if e.is_a?(MiniTest::Skip)
          new_e = MiniTest::Skip.new(e.message)
          new_e.set_backtrace(e.backtrace)
          e = new_e
        end
        @partial_report << [klass.name, meth, e.is_a?(MiniTest::Assertion) ? e : ProxyError.new(e)]
        super
      end
    end
  end
end

if $0 == __FILE__
  module Test
    module Unit
      class TestCase < MiniTest::Unit::TestCase
        undef on_parallel_worker?
        def on_parallel_worker?
          true
        end
      end
    end
  end
  require 'rubygems'
  class Gem::TestCase < MiniTest::Unit::TestCase
    @@project_dir = File.expand_path('../../../..', __FILE__)
  end

  Test::Unit::Worker.new.run(ARGV)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                 testcase.rb                                                                                         0100644 0001750 0001750 00000001312 12002444300 036356  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/test/unit                                                 require 'test/unit/assertions'

module Test
  module Unit
    # remove silly TestCase class
    remove_const(:TestCase) if defined?(self::TestCase)

    class TestCase < MiniTest::Unit::TestCase
      include Assertions

      def on_parallel_worker?
        false
      end

      def run runner
        @options = runner.options
        super runner
      end

      def self.test_order
        :sorted
      end

      def self.method_added(name)
        return unless name.to_s.start_with?("test_")
        @test_methods ||= {}
        if @test_methods[name]
          warn "test/unit warning: method #{ self }##{ name } is redefined"
        end
        @test_methods[name] = true
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                      unit.rb                                                                                             0100644 0001750 0001750 00000056743 12462630067 034606  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/test                                                      # test/unit compatibility layer using minitest.

require 'minitest/unit'
require 'test/unit/assertions'
require 'test/unit/testcase'
require 'optparse'

module Test
  module Unit
    TEST_UNIT_IMPLEMENTATION = 'test/unit compatibility layer using minitest'

    module RunCount
      @@run_count = 0

      def self.have_run?
        @@run_count.nonzero?
      end

      def run(*)
        @@run_count += 1
        super
      end

      def run_once
        return if have_run?
        return if $! # don't run if there was an exception
        yield
      end
      module_function :run_once
    end

    module Options
      def initialize(*, &block)
        @init_hook = block
        @options = nil
        super(&nil)
      end

      def option_parser
        @option_parser ||= OptionParser.new
      end

      def process_args(args = [])
        return @options if @options
        orig_args = args.dup
        options = {}
        opts = option_parser
        setup_options(opts, options)
        opts.parse!(args)
        orig_args -= args
        args = @init_hook.call(args, options) if @init_hook
        non_options(args, options)
        @help = orig_args.map { |s| s =~ /[\s|&<>$()]/ ? s.inspect : s }.join " "
        @options = options
        if @options[:parallel]
          @files = args
          @args = orig_args
        end
        options
      end

      private
      def setup_options(opts, options)
        opts.separator 'minitest options:'
        opts.version = MiniTest::Unit::VERSION

        options[:retry] = true
        options[:job_status] = nil

        opts.on '-h', '--help', 'Display this help.' do
          puts opts
          exit
        end

        opts.on '-s', '--seed SEED', Integer, "Sets random seed" do |m|
          options[:seed] = m
        end

        opts.on '-v', '--verbose', "Verbose. Show progress processing files." do
          options[:verbose] = true
          self.verbose = options[:verbose]
        end

        opts.on '-n', '--name PATTERN', "Filter test names on pattern." do |a|
          options[:filter] = a
        end

        opts.on '--jobs-status [TYPE]', [:normal, :replace],
                "Show status of jobs every file; Disabled when --jobs isn't specified." do |type|
          options[:job_status] = type || :normal
        end

        opts.on '-j N', '--jobs N', "Allow run tests with N jobs at once" do |a|
          if /^t/ =~ a
            options[:testing] = true # For testing
            options[:parallel] = a[1..-1].to_i
          else
            options[:parallel] = a.to_i
          end
        end

        opts.on '--separate', "Restart job process after one testcase has done" do
          options[:parallel] ||= 1
          options[:separate] = true
        end

        opts.on '--retry', "Retry running testcase when --jobs specified" do
          options[:retry] = true
        end

        opts.on '--no-retry', "Disable --retry" do
          options[:retry] = false
        end

        opts.on '--ruby VAL', "Path to ruby; It'll have used at -j option" do |a|
          options[:ruby] = a.split(/ /).reject(&:empty?)
        end

        opts.on '-q', '--hide-skip', 'Hide skipped tests' do
          options[:hide_skip] = true
        end

        opts.on '--show-skip', 'Show skipped tests' do
          options[:hide_skip] = false
        end

        opts.on '--color[=WHEN]',
                [:always, :never, :auto],
                "colorize the output.  WHEN defaults to 'always'", "or can be 'never' or 'auto'." do |c|
          options[:color] = c || :always
        end

        opts.on '--tty[=WHEN]',
                [:yes, :no],
                "force to output tty control.  WHEN defaults to 'yes'", "or can be 'no'." do |c|
          @tty = c != :no
        end
      end

      def non_options(files, options)
        begin
          require "rbconfig"
        rescue LoadError
          warn "#{caller(1)[0]}: warning: Parallel running disabled because can't get path to ruby; run specify with --ruby argument"
          options[:parallel] = nil
        else
          options[:ruby] ||= [RbConfig.ruby]
        end

        true
      end
    end

    module GlobOption
      @@testfile_prefix = "test"

      def setup_options(parser, options)
        super
        parser.on '-b', '--basedir=DIR', 'Base directory of test suites.' do |dir|
          options[:base_directory] = dir
        end
        parser.on '-x', '--exclude PATTERN', 'Exclude test files on pattern.' do |pattern|
          (options[:reject] ||= []) << pattern
        end
      end

      def non_options(files, options)
        paths = [options.delete(:base_directory), nil].uniq
        if reject = options.delete(:reject)
          reject_pat = Regexp.union(reject.map {|r| /#{r}/ })
        end
        files.map! {|f|
          f = f.tr(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR
          ((paths if /\A\.\.?(?:\z|\/)/ !~ f) || [nil]).any? do |prefix|
            if prefix
              path = f.empty? ? prefix : "#{prefix}/#{f}"
            else
              next if f.empty?
              path = f
            end
            if !(match = Dir["#{path}/**/#{@@testfile_prefix}_*.rb"]).empty?
              if reject
                match.reject! {|n|
                  n[(prefix.length+1)..-1] if prefix
                  reject_pat =~ n
                }
              end
              break match
            elsif !reject or reject_pat !~ f and File.exist? path
              break path
            end
          end or
            raise ArgumentError, "file not found: #{f}"
        }
        files.flatten!
        super(files, options)
      end
    end

    module LoadPathOption
      def setup_options(parser, options)
        super
        parser.on '-Idirectory', 'Add library load path' do |dirs|
          dirs.split(':').each { |d| $LOAD_PATH.unshift d }
        end
      end
    end

    module GCStressOption
      def setup_options(parser, options)
        super
        parser.on '--[no-]gc-stress', 'Set GC.stress as true' do |flag|
          options[:gc_stress] = flag
        end
      end

      def non_options(files, options)
        if options.delete(:gc_stress)
          MiniTest::Unit::TestCase.class_eval do
            oldrun = instance_method(:run)
            define_method(:run) do |runner|
              begin
                gc_stress, GC.stress = GC.stress, true
                oldrun.bind(self).call(runner)
              ensure
                GC.stress = gc_stress
              end
            end
          end
        end
        super
      end
    end

    module RequireFiles
      def non_options(files, options)
        return false if !super
        result = false
        files.each {|f|
          d = File.dirname(path = File.realpath(f))
          unless $:.include? d
            $: << d
          end
          begin
            require path unless options[:parallel]
            result = true
          rescue LoadError
            puts "#{f}: #{$!}"
          end
        }
        result
      end
    end

    class Runner < MiniTest::Unit
      include Test::Unit::Options
      include Test::Unit::GlobOption
      include Test::Unit::LoadPathOption
      include Test::Unit::GCStressOption
      include Test::Unit::RunCount

      class Worker
        def self.launch(ruby,args=[])
          io = IO.popen([*ruby,
                        "#{File.dirname(__FILE__)}/unit/parallel.rb",
                        *args], "rb+")
          new(io, io.pid, :waiting)
        end

        attr_reader :quit_called

        def initialize(io, pid, status)
          @io = io
          @pid = pid
          @status = status
          @file = nil
          @real_file = nil
          @loadpath = []
          @hooks = {}
          @quit_called = false
        end

        def puts(*args)
          @io.puts(*args)
        end

        def run(task,type)
          @file = File.basename(task, ".rb")
          @real_file = task
          begin
            puts "loadpath #{[Marshal.dump($:-@loadpath)].pack("m0")}"
            @loadpath = $:.dup
            puts "run #{task} #{type}"
            @status = :prepare
          rescue Errno::EPIPE
            died
          rescue IOError
            raise unless ["stream closed","closed stream"].include? $!.message
            died
          end
        end

        def hook(id,&block)
          @hooks[id] ||= []
          @hooks[id] << block
          self
        end

        def read
          res = (@status == :quit) ? @io.read : @io.gets
          res && res.chomp
        end

        def close
          @io.close unless @io.closed?
          self
        rescue IOError
        end

        def quit
          return if @io.closed?
          @quit_called = true
          @io.puts "quit"
          @io.close
        end

        def kill
          Process.kill(:KILL, @pid)
        rescue Errno::ESRCH
        end

        def died(*additional)
          @status = :quit
          @io.close

          call_hook(:dead,*additional)
        end

        def to_s
          if @file
            "#{@pid}=#{@file}"
          else
            "#{@pid}:#{@status.to_s.ljust(7)}"
          end
        end

        attr_reader :io, :pid
        attr_accessor :status, :file, :real_file, :loadpath

        private

        def call_hook(id,*additional)
          @hooks[id] ||= []
          @hooks[id].each{|hook| hook[self,additional] }
          self
        end

      end

      class << self; undef autorun; end

      @@stop_auto_run = false
      def self.autorun
        at_exit {
          Test::Unit::RunCount.run_once {
            exit(Test::Unit::Runner.new.run(ARGV) || true)
          } unless @@stop_auto_run
        } unless @@installed_at_exit
        @@installed_at_exit = true
      end

      def after_worker_down(worker, e=nil, c=false)
        return unless @options[:parallel]
        return if @interrupt
        warn e if e
        @need_quit = true
        warn ""
        warn "Some worker was crashed. It seems ruby interpreter's bug"
        warn "or, a bug of test/unit/parallel.rb. try again without -j"
        warn "option."
        warn ""
        STDERR.flush
        exit c
      end

      def terminal_width
        unless @terminal_width ||= nil
          begin
            require 'io/console'
            width = $stdout.winsize[1]
          rescue LoadError, NoMethodError, Errno::ENOTTY, Errno::EBADF, Errno::EINVAL
            width = ENV["COLUMNS"].to_i.nonzero? || 80
          end
          width -= 1 if /mswin|mingw/ =~ RUBY_PLATFORM
          @terminal_width = width
        end
        @terminal_width
      end

      def del_status_line
        @status_line_size ||= 0
        unless @options[:job_status] == :replace
          $stdout.puts
          return
        end
        print "\r"+" "*@status_line_size+"\r"
        $stdout.flush
        @status_line_size = 0
      end

      def put_status(line)
        unless @options[:job_status] == :replace
          print(line)
          return
        end
        @status_line_size ||= 0
        del_status_line
        $stdout.flush
        line = line[0...terminal_width]
        print line
        $stdout.flush
        @status_line_size = line.size
      end

      def add_status(line)
        unless @options[:job_status] == :replace
          print(line)
          return
        end
        @status_line_size ||= 0
        line = line[0...(terminal_width-@status_line_size)]
        print line
        $stdout.flush
        @status_line_size += line.size
      end

      def jobs_status
        return unless @options[:job_status]
        puts "" unless @options[:verbose] or @options[:job_status] == :replace
        status_line = @workers.map(&:to_s).join(" ")
        update_status(status_line) or (puts; nil)
      end

      def del_jobs_status
        return unless @options[:job_status] == :replace && @status_line_size.nonzero?
        del_status_line
      end

      def after_worker_quit(worker)
        return unless @options[:parallel]
        return if @interrupt
        @workers.delete(worker)
        @dead_workers << worker
        @ios = @workers.map(&:io)
      end

      def launch_worker
        begin
          worker = Worker.launch(@options[:ruby],@args)
        rescue => e
          abort "ERROR: Failed to launch job process - #{e.class}: #{e.message}"
        end
        worker.hook(:dead) do |w,info|
          after_worker_quit w
          after_worker_down w, *info if !info.empty? && !worker.quit_called
        end
        @workers << worker
        @ios << worker.io
        @workers_hash[worker.io] = worker
        worker
      end

      def delete_worker(worker)
        @workers_hash.delete worker.io
        @workers.delete worker
        @ios.delete worker.io
      end

      def quit_workers
        return if @workers.empty?
        @workers.reject! do |worker|
          begin
            timeout(1) do
              worker.quit
            end
          rescue Errno::EPIPE
          rescue Timeout::Error
          end
          worker.close
        end

        return if @workers.empty?
        begin
          timeout(0.2 * @workers.size) do
            Process.waitall
          end
        rescue Timeout::Error
          @workers.each do |worker|
            worker.kill
          end
          @worker.clear
        end
      end

      def start_watchdog
        Thread.new do
          while stat = Process.wait2
            break if @interrupt # Break when interrupt
            pid, stat = stat
            w = (@workers + @dead_workers).find{|x| pid == x.pid }
            next unless w
            w = w.dup
            if w.status != :quit && !w.quit_called?
              # Worker down
              w.died(nil, !stat.signaled? && stat.exitstatus)
            end
          end
        end
      end

      def deal(io, type, result, rep, shutting_down = false)
        worker = @workers_hash[io]
        case worker.read
        when /^okay$/
          worker.status = :running
          jobs_status
        when /^ready(!)?$/
          bang = $1
          worker.status = :ready

          return nil unless task = @tasks.shift
          if @options[:separate] and not bang
            worker.quit
            worker = add_worker
          end
          worker.run(task, type)
          @test_count += 1

          jobs_status
        when /^done (.+?)$/
          r = Marshal.load($1.unpack("m")[0])
          result << r[0..1] unless r[0..1] == [nil,nil]
          rep    << {file: worker.real_file, report: r[2], result: r[3], testcase: r[5]}
          $:.push(*r[4]).uniq!
          return true
        when /^p (.+?)$/
          del_jobs_status
          print $1.unpack("m")[0]
          jobs_status if @options[:job_status] == :replace
        when /^after (.+?)$/
          @warnings << Marshal.load($1.unpack("m")[0])
        when /^bye (.+?)$/
          after_worker_down worker, Marshal.load($1.unpack("m")[0])
        when /^bye$/, nil
          if shutting_down || worker.quit_called
            after_worker_quit worker
          else
            after_worker_down worker
          end
        end
        return false
      end

      def _run_parallel suites, type, result
        if @options[:parallel] < 1
          warn "Error: parameter of -j option should be greater than 0."
          return
        end

        # Require needed things for parallel running
        require 'thread'
        require 'timeout'
        @tasks = @files.dup # Array of filenames.
        @need_quit = false
        @dead_workers = []  # Array of dead workers.
        @warnings = []
        @total_tests = @tasks.size.to_s(10)
        rep = [] # FIXME: more good naming

        @workers      = [] # Array of workers.
        @workers_hash = {} # out-IO => worker
        @ios          = [] # Array of worker IOs
        begin
          # Thread: watchdog
          watchdog = start_watchdog

          @options[:parallel].times {launch_worker}

          while _io = IO.select(@ios)[0]
            break if _io.any? do |io|
              @need_quit or
                (deal(io, type, result, rep).nil? and
                 !@workers.any? {|x| [:running, :prepare].include? x.status})
            end
          end
        rescue Interrupt => ex
          @interrupt = ex
          return result
        ensure
          watchdog.kill if watchdog
          if @interrupt
            @ios.select!{|x| @workers_hash[x].status == :running }
            while !@ios.empty? && (__io = IO.select(@ios,[],[],10))
              __io[0].reject! {|io| deal(io, type, result, rep, true)}
            end
          end

          quit_workers

          unless @interrupt || !@options[:retry] || @need_quit
            @options[:parallel] = false
            suites, rep = rep.partition {|r| r[:testcase] && r[:file] && r[:report].any? {|e| !e[2].is_a?(MiniTest::Skip)}}
            suites.map {|r| r[:file]}.uniq.each {|file| require file}
            suites.map! {|r| eval("::"+r[:testcase])}
            del_status_line or puts
            unless suites.empty?
              puts "Retrying..."
              _run_suites(suites, type)
            end
          end
          unless @options[:retry]
            del_status_line or puts
          end
          unless rep.empty?
            rep.each do |r|
              r[:report].each do |f|
                puke(*f) if f
              end
            end
            if @options[:retry]
              @errors   += rep.map{|x| x[:result][0] }.inject(:+)
              @failures += rep.map{|x| x[:result][1] }.inject(:+)
              @skips    += rep.map{|x| x[:result][2] }.inject(:+)
            end
          end
          unless @warnings.empty?
            warn ""
            @warnings.uniq! {|w| w[1].message}
            @warnings.each do |w|
              warn "#{w[0]}: #{w[1].message} (#{w[1].class})"
            end
            warn ""
          end
        end
      end

      def _run_suites suites, type
        _prepare_run(suites, type)
        @interrupt = nil
        result = []
        GC.start
        if @options[:parallel]
          _run_parallel suites, type, result
        else
          suites.each {|suite|
            begin
              result << _run_suite(suite, type)
            rescue Interrupt => e
              @interrupt = e
              break
            end
          }
        end
        report.reject!{|r| r.start_with? "Skipped:" } if @options[:hide_skip]
        report.sort_by!{|r| r.start_with?("Skipped:") ? 0 : \
                           (r.start_with?("Failure:") ? 1 : 2) }
        result
      end

      alias mini_run_suite _run_suite

      def output
        (@output ||= nil) || super
      end

      def _prepare_run(suites, type)
        options[:job_status] ||= :replace if @tty && !@verbose
        case options[:color]
        when :always
          color = true
        when :auto, nil
          color = @options[:job_status] == :replace && /dumb/ !~ ENV["TERM"]
        else
          color = false
        end
        if color
          # dircolors-like style
          colors = (colors = ENV['TEST_COLORS']) ? Hash[colors.scan(/(\w+)=([^:]*)/)] : {}
          @passed_color = "\e[#{colors["pass"] || "32"}m"
          @failed_color = "\e[#{colors["fail"] || "31"}m"
          @skipped_color = "\e[#{colors["skip"] || "33"}m"
          @reset_color = "\e[m"
        else
          @passed_color = @failed_color = @skipped_color = @reset_color = ""
        end
        if color or @options[:job_status] == :replace
          @verbose = !options[:parallel]
          @output = StatusLineOutput.new(self)
        end
        if /\A\/(.*)\/\z/ =~ (filter = options[:filter])
          filter = Regexp.new($1)
        end
        type = "#{type}_methods"
        total = if filter
                  suites.inject(0) {|n, suite| n + suite.send(type).grep(filter).size}
                else
                  suites.inject(0) {|n, suite| n + suite.send(type).size}
                end
        @test_count = 0
        @total_tests = total.to_s(10)
      end

      def new_test(s)
        @test_count += 1
        update_status(s)
      end

      def update_status(s)
        count = @test_count.to_s(10).rjust(@total_tests.size)
        put_status("#{@passed_color}[#{count}/#{@total_tests}]#{@reset_color} #{s}")
      end

      def _print(s); $stdout.print(s); end
      def succeed; del_status_line; end

      def failed(s)
        sep = "\n"
        @report_count ||= 0
        report.each do |msg|
          if msg.start_with? "Skipped:"
            if @options[:hide_skip]
              del_status_line
              next
            end
            color = @skipped_color
          else
            color = @failed_color
          end
          msg = msg.split(/$/, 2)
          $stdout.printf("%s%s%3d) %s%s%s\n",
                         sep, color, @report_count += 1,
                         msg[0], @reset_color, msg[1])
          sep = nil
        end
        report.clear
      end

      # Overriding of MiniTest::Unit#puke
      def puke klass, meth, e
        # TODO:
        #   this overriding is for minitest feature that skip messages are
        #   hidden when not verbose (-v), note this is temporally.
        n = report.size
        rep = super
        if MiniTest::Skip === e and /no message given\z/ =~ e.message
          report.slice!(n..-1)
          rep = "."
        end
        rep
      end

      def initialize # :nodoc:
        super
        @tty = $stdout.tty?
      end

      def status(*args)
        result = super
        raise @interrupt if @interrupt
        result
      end

      def run(*args)
        result = super
        puts "\nruby -v: #{RUBY_DESCRIPTION}"
        result
      end
    end

    class StatusLineOutput < Struct.new(:runner)
      def puts(*a) $stdout.puts(*a) unless a.empty? end
      def respond_to_missing?(*a) $stdout.respond_to?(*a) end
      def method_missing(*a, &b) $stdout.__send__(*a, &b) end

      def print(s)
        case s
        when /\A(.*\#.*) = \z/
          runner.new_test($1)
        when /\A(.* s) = \z/
          runner.add_status(" = "+$1.chomp)
        when /\A\.+\z/
          runner.succeed
        when /\A[EFS]\z/
          runner.failed(s)
        else
          $stdout.print(s)
        end
      end
    end

    class AutoRunner
      class Runner < Test::Unit::Runner
        include Test::Unit::RequireFiles
      end

      attr_accessor :to_run, :options

      def initialize(force_standalone = false, default_dir = nil, argv = ARGV)
        @force_standalone = force_standalone
        @runner = Runner.new do |files, options|
          options[:base_directory] ||= default_dir
          files << default_dir if files.empty? and default_dir
          @to_run = files
          yield self if block_given?
          files
        end
        Runner.runner = @runner
        @options = @runner.option_parser
        if @force_standalone
          @options.banner.sub!(/\[options\]/, '\& tests...')
        end
        @argv = argv
      end

      def process_args(*args)
        @runner.process_args(*args)
        !@to_run.empty?
      end

      def run
        if @force_standalone and not process_args(@argv)
          abort @options.banner
        end
        @runner.run(@argv) || true
      end

      def self.run(*args)
        new(*args).run
      end
    end

    class ProxyError < StandardError
      def initialize(ex)
        @message = ex.message
        @backtrace = ex.backtrace
      end

      attr_accessor :message, :backtrace
    end
  end
end

class MiniTest::Unit::TestCase
  undef run_test
  RUN_TEST_TRACE = "#{__FILE__}:#{__LINE__+3}:in `run_test'".freeze
  def run_test(name)
    progname, $0 = $0, "#{$0}: #{self.class}##{name}"
    self.__send__(name)
  ensure
    $@.delete(RUN_TEST_TRACE) if $@
    $0 = progname
  end
end

Test::Unit::Runner.autorun
                             thread.rb                                                                                           0100644 0001750 0001750 00000015707 12275723715 034117  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
#               thread.rb - thread support classes
#                       by Yukihiro Matsumoto <matz@netlab.co.jp>
#
# Copyright (C) 2001  Yukihiro Matsumoto
# Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
# Copyright (C) 2000  Information-technology Promotion Agency, Japan
#

unless defined? Thread
  raise "Thread not available for this ruby interpreter"
end

unless defined? ThreadError
  class ThreadError < StandardError
  end
end

if $DEBUG
  Thread.abort_on_exception = true
end

#
# ConditionVariable objects augment class Mutex. Using condition variables,
# it is possible to suspend while in the middle of a critical section until a
# resource becomes available.
#
# Example:
#
#   require 'thread'
#
#   mutex = Mutex.new
#   resource = ConditionVariable.new
#
#   a = Thread.new {
#     mutex.synchronize {
#       # Thread 'a' now needs the resource
#       resource.wait(mutex)
#       # 'a' can now have the resource
#     }
#   }
#
#   b = Thread.new {
#     mutex.synchronize {
#       # Thread 'b' has finished using the resource
#       resource.signal
#     }
#   }
#
class ConditionVariable
  #
  # Creates a new ConditionVariable
  #
  def initialize
    @waiters = {}
    @waiters_mutex = Mutex.new
  end

  #
  # Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup.
  #
  # If +timeout+ is given, this method returns after +timeout+ seconds passed,
  # even if no other thread doesn't signal.
  #
  def wait(mutex, timeout=nil)
    Thread.handle_interrupt(StandardError => :never) do
      begin
        Thread.handle_interrupt(StandardError => :on_blocking) do
          @waiters_mutex.synchronize do
            @waiters[Thread.current] = true
          end
          mutex.sleep timeout
        end
      ensure
        @waiters_mutex.synchronize do
          @waiters.delete(Thread.current)
        end
      end
    end
    self
  end

  #
  # Wakes up the first thread in line waiting for this lock.
  #
  def signal
    Thread.handle_interrupt(StandardError => :on_blocking) do
      begin
        t, _ = @waiters_mutex.synchronize { @waiters.shift }
        t.run if t
      rescue ThreadError
        retry # t was already dead?
      end
    end
    self
  end

  #
  # Wakes up all threads waiting for this lock.
  #
  def broadcast
    Thread.handle_interrupt(StandardError => :on_blocking) do
      threads = nil
      @waiters_mutex.synchronize do
        threads = @waiters.keys
        @waiters.clear
      end
      for t in threads
        begin
          t.run
        rescue ThreadError
        end
      end
    end
    self
  end
end

#
# This class provides a way to synchronize communication between threads.
#
# Example:
#
#   require 'thread'
#
#   queue = Queue.new
#
#   producer = Thread.new do
#     5.times do |i|
#       sleep rand(i) # simulate expense
#       queue << i
#       puts "#{i} produced"
#     end
#   end
#
#   consumer = Thread.new do
#     5.times do |i|
#       value = queue.pop
#       sleep rand(i/2) # simulate expense
#       puts "consumed #{value}"
#     end
#   end
#
#   consumer.join
#
class Queue
  #
  # Creates a new queue.
  #
  def initialize
    @que = []
    @que.taint          # enable tainted communication
    @num_waiting = 0
    self.taint
    @mutex = Mutex.new
    @cond = ConditionVariable.new
  end

  #
  # Pushes +obj+ to the queue.
  #
  def push(obj)
    Thread.handle_interrupt(StandardError => :on_blocking) do
      @mutex.synchronize do
        @que.push obj
        @cond.signal
      end
    end
  end

  #
  # Alias of push
  #
  alias << push

  #
  # Alias of push
  #
  alias enq push

  #
  # Retrieves data from the queue.  If the queue is empty, the calling thread is
  # suspended until data is pushed onto the queue.  If +non_block+ is true, the
  # thread isn't suspended, and an exception is raised.
  #
  def pop(non_block=false)
    Thread.handle_interrupt(StandardError => :on_blocking) do
      @mutex.synchronize do
        while true
          if @que.empty?
            if non_block
              raise ThreadError, "queue empty"
            else
              begin
                @num_waiting += 1
                @cond.wait @mutex
              ensure
                @num_waiting -= 1
              end
            end
          else
            return @que.shift
          end
        end
      end
    end
  end

  #
  # Alias of pop
  #
  alias shift pop

  #
  # Alias of pop
  #
  alias deq pop

  #
  # Returns +true+ if the queue is empty.
  #
  def empty?
    @que.empty?
  end

  #
  # Removes all objects from the queue.
  #
  def clear
    @que.clear
  end

  #
  # Returns the length of the queue.
  #
  def length
    @que.length
  end

  #
  # Alias of length.
  #
  alias size length

  #
  # Returns the number of threads waiting on the queue.
  #
  def num_waiting
    @num_waiting
  end
end

#
# This class represents queues of specified size capacity.  The push operation
# may be blocked if the capacity is full.
#
# See Queue for an example of how a SizedQueue works.
#
class SizedQueue < Queue
  #
  # Creates a fixed-length queue with a maximum size of +max+.
  #
  def initialize(max)
    raise ArgumentError, "queue size must be positive" unless max > 0
    @max = max
    @enque_cond = ConditionVariable.new
    @num_enqueue_waiting = 0
    super()
  end

  #
  # Returns the maximum size of the queue.
  #
  def max
    @max
  end

  #
  # Sets the maximum size of the queue.
  #
  def max=(max)
    raise ArgumentError, "queue size must be positive" unless max > 0

    @mutex.synchronize do
      if max <= @max
        @max = max
      else
        diff = max - @max
        @max = max
        diff.times do
          @enque_cond.signal
        end
      end
    end
    max
  end

  #
  # Pushes +obj+ to the queue.  If there is no space left in the queue, waits
  # until space becomes available.
  #
  def push(obj)
    Thread.handle_interrupt(RuntimeError => :on_blocking) do
      @mutex.synchronize do
        while true
          break if @que.length < @max
          @num_enqueue_waiting += 1
          begin
            @enque_cond.wait @mutex
          ensure
            @num_enqueue_waiting -= 1
          end
        end

        @que.push obj
        @cond.signal
      end
    end
  end

  #
  # Removes all objects from the queue.
  #
  def clear
    super
    @mutex.synchronize do
      @max.times do
        @enque_cond.signal
      end
    end
  end

  #
  # Alias of push
  #
  alias << push

  #
  # Alias of push
  #
  alias enq push

  #
  # Retrieves data from the queue and runs a waiting thread, if any.
  #
  def pop(*args)
    retval = super
    @mutex.synchronize do
      if @que.length < @max
        @enque_cond.signal
      end
    end
    retval
  end

  #
  # Alias of pop
  #
  alias shift pop

  #
  # Alias of pop
  #
  alias deq pop

  #
  # Returns the number of threads waiting on the queue.
  #
  def num_waiting
    @num_waiting + @num_enqueue_waiting
  end
end

# Documentation comments:
#  - How do you make RDoc inherit documentation from superclass?
                                                         thwait.rb                                                                                           0100644 0001750 0001750 00000006601 11602513556 034132  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
#   thwait.rb - thread synchronization class
#       $Release Version: 0.9 $
#       $Revision: 1.3 $
#       by Keiju ISHITSUKA(Nihon Rational Software Co.,Ltd.)

require "thread.rb"
require "e2mmap.rb"

#
# This class watches for termination of multiple threads.  Basic functionality
# (wait until specified threads have terminated) can be accessed through the
# class method ThreadsWait::all_waits.  Finer control can be gained using
# instance methods.
#
# Example:
#
#   ThreadsWait.all_wait(thr1, thr2, ...) do |t|
#     STDERR.puts "Thread #{t} has terminated."
#   end
#
#
#   th = ThreadsWait.new(thread1,...)
#   th.next_wait # next one to be done
#
#
class ThreadsWait
  RCS_ID='-$Id: thwait.rb,v 1.3 1998/06/26 03:19:34 keiju Exp keiju $-'

  extend Exception2MessageMapper
  def_exception("ErrNoWaitingThread", "No threads for waiting.")
  def_exception("ErrNoFinishedThread", "No finished threads.")

  #
  # Waits until all specified threads have terminated.  If a block is provided,
  # it is executed for each thread as they terminate.
  #
  def ThreadsWait.all_waits(*threads) # :yield: thread
    tw = ThreadsWait.new(*threads)
    if block_given?
      tw.all_waits do |th|
        yield th
      end
    else
      tw.all_waits
    end
  end

  #
  # Creates a ThreadsWait object, specifying the threads to wait on.
  # Non-blocking.
  #
  def initialize(*threads)
    @threads = []
    @wait_queue = Queue.new
    join_nowait(*threads) unless threads.empty?
  end

  # Returns the array of threads that have not terminated yet.
  attr :threads

  #
  # Returns +true+ if there are no threads in the pool still running.
  #
  def empty?
    @threads.empty?
  end

  #
  # Returns +true+ if any thread has terminated and is ready to be collected.
  #
  def finished?
    !@wait_queue.empty?
  end

  #
  # Waits for specified threads to terminate, and returns when one of
  # the threads terminated.
  #
  def join(*threads)
    join_nowait(*threads)
    next_wait
  end

  #
  # Specifies the threads that this object will wait for, but does not actually
  # wait.
  #
  def join_nowait(*threads)
    threads.flatten!
    @threads.concat threads
    for th in threads
      Thread.start(th) do |t|
        begin
          t.join
        ensure
          @wait_queue.push t
        end
      end
    end
  end

  #
  # Waits until any of the specified threads has terminated, and returns the one
  # that does.
  #
  # If there is no thread to wait, raises +ErrNoWaitingThread+.  If +nonblock+
  # is true, and there is no terminated thread, raises +ErrNoFinishedThread+.
  #
  def next_wait(nonblock = nil)
    ThreadsWait.fail ErrNoWaitingThread if @threads.empty?
    begin
      @threads.delete(th = @wait_queue.pop(nonblock))
      th
    rescue ThreadError
      ThreadsWait.fail ErrNoFinishedThread
    end
  end

  #
  # Waits until all of the specified threads are terminated.  If a block is
  # supplied for the method, it is executed for each thread termination.
  #
  # Raises exceptions in the same manner as +next_wait+.
  #
  def all_waits
    until @threads.empty?
      th = next_wait
      yield th if block_given?
    end
  end
end

##
# An alias for ThreadsWait from thwait.rb

ThWait = ThreadsWait

# Documentation comments:
#  - Source of documentation is evenly split between Nutshell, existing
#    comments, and my own rephrasing.
#  - I'm not particularly confident that the comments are all exactly correct.
                                                                                                                               time.rb                                                                                             0100644 0001750 0001750 00000052135 12225270501 033563  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           require 'date'

# = time.rb
#
# When 'time' is required, Time is extended with additional methods for parsing
# and converting Times.
#
# == Features
#
# This library extends the Time class with the following conversions between
# date strings and Time objects:
#
# * date-time defined by {RFC 2822}[http://www.ietf.org/rfc/rfc2822.txt]
# * HTTP-date defined by {RFC 2616}[http://www.ietf.org/rfc/rfc2616.txt]
# * dateTime defined by XML Schema Part 2: Datatypes ({ISO
#   8601}[http://www.iso.org/iso/date_and_time_format])
# * various formats handled by Date._parse
# * custom formats handled by Date._strptime
#
# == Examples
#
# All examples assume you have loaded Time with:
#
#   require 'time'
#
# All of these examples were done using the EST timezone which is GMT-5.
#
# === Converting to a String
#
#   t = Time.now
#   t.iso8601  # => "2011-10-05T22:26:12-04:00"
#   t.rfc2822  # => "Wed, 05 Oct 2011 22:26:12 -0400"
#   t.httpdate # => "Thu, 06 Oct 2011 02:26:12 GMT"
#
# === Time.parse
#
# #parse takes a string representation of a Time and attempts to parse it
# using a heuristic.
#
#   Date.parse("2010-10-31") #=> 2010-10-31 00:00:00 -0500
#
# Any missing pieces of the date are inferred based on the current date.
#
#   # assuming the current date is "2011-10-31"
#   Time.parse("12:00") #=> 2011-10-31 12:00:00 -0500
#
# We can change the date used to infer our missing elements by passing a second
# object that responds to #mon, #day and #year, such as Date, Time or DateTime.
# We can also use our own object.
#
#   class MyDate
#     attr_reader :mon, :day, :year
#
#     def initialize(mon, day, year)
#       @mon, @day, @year = mon, day, year
#     end
#   end
#
#   d  = Date.parse("2010-10-28")
#   t  = Time.parse("2010-10-29")
#   dt = DateTime.parse("2010-10-30")
#   md = MyDate.new(10,31,2010)
#
#   Time.parse("12:00", d)  #=> 2010-10-28 12:00:00 -0500
#   Time.parse("12:00", t)  #=> 2010-10-29 12:00:00 -0500
#   Time.parse("12:00", dt) #=> 2010-10-30 12:00:00 -0500
#   Time.parse("12:00", md) #=> 2010-10-31 12:00:00 -0500
#
# #parse also accepts an optional block. You can use this block to specify how
# to handle the year component of the date. This is specifically designed for
# handling two digit years. For example, if you wanted to treat all two digit
# years prior to 70 as the year 2000+ you could write this:
#
#   Time.parse("01-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
#   #=> 2001-10-31 00:00:00 -0500
#   Time.parse("70-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
#   #=> 1970-10-31 00:00:00 -0500
#
# === Time.strptime
#
# #strptime works similar to +parse+ except that instead of using a heuristic
# to detect the format of the input string, you provide a second argument that
# is describes the format of the string. For example:
#
#   Time.strptime("2000-10-31", "%Y-%m-%d") #=> 2000-10-31 00:00:00 -0500

class Time
  class << Time

    #
    # A hash of timezones mapped to hour differences from UTC. The
    # set of time zones corresponds to the ones specified by RFC 2822
    # and ISO 8601.
    #
    ZoneOffset = { # :nodoc:
      'UTC' => 0,
      # ISO 8601
      'Z' => 0,
      # RFC 822
      'UT' => 0, 'GMT' => 0,
      'EST' => -5, 'EDT' => -4,
      'CST' => -6, 'CDT' => -5,
      'MST' => -7, 'MDT' => -6,
      'PST' => -8, 'PDT' => -7,
      # Following definition of military zones is original one.
      # See RFC 1123 and RFC 2822 for the error in RFC 822.
      'A' => +1, 'B' => +2, 'C' => +3, 'D' => +4,  'E' => +5,  'F' => +6,
      'G' => +7, 'H' => +8, 'I' => +9, 'K' => +10, 'L' => +11, 'M' => +12,
      'N' => -1, 'O' => -2, 'P' => -3, 'Q' => -4,  'R' => -5,  'S' => -6,
      'T' => -7, 'U' => -8, 'V' => -9, 'W' => -10, 'X' => -11, 'Y' => -12,
    }

    #
    # Return the number of seconds the specified time zone differs
    # from UTC.
    #
    # Numeric time zones that include minutes, such as
    # <code>-10:00</code> or <code>+1330</code> will work, as will
    # simpler hour-only time zones like <code>-10</code> or
    # <code>+13</code>.
    #
    # Textual time zones listed in ZoneOffset are also supported.
    #
    # If the time zone does not match any of the above, +zone_offset+
    # will check if the local time zone (both with and without
    # potential Daylight Saving \Time changes being in effect) matches
    # +zone+. Specifying a value for +year+ will change the year used
    # to find the local time zone.
    #
    # If +zone_offset+ is unable to determine the offset, nil will be
    # returned.
    def zone_offset(zone, year=self.now.year)
      off = nil
      zone = zone.upcase
      if /\A([+-])(\d\d):?(\d\d)\z/ =~ zone
        off = ($1 == '-' ? -1 : 1) * ($2.to_i * 60 + $3.to_i) * 60
      elsif /\A[+-]\d\d\z/ =~ zone
        off = zone.to_i * 3600
      elsif ZoneOffset.include?(zone)
        off = ZoneOffset[zone] * 3600
      elsif ((t = self.local(year, 1, 1)).zone.upcase == zone rescue false)
        off = t.utc_offset
      elsif ((t = self.local(year, 7, 1)).zone.upcase == zone rescue false)
        off = t.utc_offset
      end
      off
    end

    def zone_utc?(zone)
      # * +0000
      #   In RFC 2822, +0000 indicate a time zone at Universal Time.
      #   Europe/Lisbon is "a time zone at Universal Time" in Winter.
      #   Atlantic/Reykjavik is "a time zone at Universal Time".
      #   Africa/Dakar is "a time zone at Universal Time".
      #   So +0000 is a local time such as Europe/London, etc.
      # * GMT
      #   GMT is used as a time zone abbreviation in Europe/London,
      #   Africa/Dakar, etc.
      #   So it is a local time.
      #
      # * -0000, -00:00
      #   In RFC 2822, -0000 the date-time contains no information about the
      #   local time zone.
      #   In RFC 3339, -00:00 is used for the time in UTC is known,
      #   but the offset to local time is unknown.
      #   They are not appropriate for specific time zone such as
      #   Europe/London because time zone neutral,
      #   So -00:00 and -0000 are treated as UTC.
      if /\A(?:-00:00|-0000|-00|UTC|Z|UT)\z/i =~ zone
        true
      else
        false
      end
    end
    private :zone_utc?

    LeapYearMonthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    CommonYearMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    def month_days(y, m)
      if ((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)
        LeapYearMonthDays[m-1]
      else
        CommonYearMonthDays[m-1]
      end
    end
    private :month_days

    def apply_offset(year, mon, day, hour, min, sec, off)
      if off < 0
        off = -off
        off, o = off.divmod(60)
        if o != 0 then sec += o; o, sec = sec.divmod(60); off += o end
        off, o = off.divmod(60)
        if o != 0 then min += o; o, min = min.divmod(60); off += o end
        off, o = off.divmod(24)
        if o != 0 then hour += o; o, hour = hour.divmod(24); off += o end
        if off != 0
          day += off
          if month_days(year, mon) < day
            mon += 1
            if 12 < mon
              mon = 1
              year += 1
            end
            day = 1
          end
        end
      elsif 0 < off
        off, o = off.divmod(60)
        if o != 0 then sec -= o; o, sec = sec.divmod(60); off -= o end
        off, o = off.divmod(60)
        if o != 0 then min -= o; o, min = min.divmod(60); off -= o end
        off, o = off.divmod(24)
        if o != 0 then hour -= o; o, hour = hour.divmod(24); off -= o end
        if off != 0 then
          day -= off
          if day < 1
            mon -= 1
            if mon < 1
              year -= 1
              mon = 12
            end
            day = month_days(year, mon)
          end
        end
      end
      return year, mon, day, hour, min, sec
    end
    private :apply_offset

    def make_time(year, mon, day, hour, min, sec, sec_fraction, zone, now)
      usec = nil
      usec = sec_fraction * 1000000 if sec_fraction
      if now
        begin
          break if year; year = now.year
          break if mon; mon = now.mon
          break if day; day = now.day
          break if hour; hour = now.hour
          break if min; min = now.min
          break if sec; sec = now.sec
          break if sec_fraction; usec = now.tv_usec
        end until true
      end

      year ||= 1970
      mon ||= 1
      day ||= 1
      hour ||= 0
      min ||= 0
      sec ||= 0
      usec ||= 0

      off = nil
      off = zone_offset(zone, year) if zone

      if off
        year, mon, day, hour, min, sec =
          apply_offset(year, mon, day, hour, min, sec, off)
        t = self.utc(year, mon, day, hour, min, sec, usec)
        t.localtime if !zone_utc?(zone)
        t
      else
        self.local(year, mon, day, hour, min, sec, usec)
      end
    end
    private :make_time

    #
    # Parses +date+ using Date._parse and converts it to a Time object.
    #
    # If a block is given, the year described in +date+ is converted by the
    # block.  For example:
    #
    #     Time.parse(...) {|y| 0 <= y && y < 100 ? (y >= 69 ? y + 1900 : y + 2000) : y}
    #
    # If the upper components of the given time are broken or missing, they are
    # supplied with those of +now+.  For the lower components, the minimum
    # values (1 or 0) are assumed if broken or missing.  For example:
    #
    #     # Suppose it is "Thu Nov 29 14:33:20 GMT 2001" now and
    #     # your time zone is GMT:
    #     now = Time.parse("Thu Nov 29 14:33:20 GMT 2001")
    #     Time.parse("16:30", now)     #=> 2001-11-29 16:30:00 +0900
    #     Time.parse("7/23", now)      #=> 2001-07-23 00:00:00 +0900
    #     Time.parse("Aug 31", now)    #=> 2001-08-31 00:00:00 +0900
    #     Time.parse("Aug 2000", now)  #=> 2000-08-01 00:00:00 +0900
    #
    # Since there are numerous conflicts among locally defined time zone
    # abbreviations all over the world, this method is not intended to
    # understand all of them.  For example, the abbreviation "CST" is
    # used variously as:
    #
    #     -06:00 in America/Chicago,
    #     -05:00 in America/Havana,
    #     +08:00 in Asia/Harbin,
    #     +09:30 in Australia/Darwin,
    #     +10:30 in Australia/Adelaide,
    #     etc.
    #
    # Based on this fact, this method only understands the time zone
    # abbreviations described in RFC 822 and the system time zone, in the
    # order named. (i.e. a definition in RFC 822 overrides the system
    # time zone definition.)  The system time zone is taken from
    # <tt>Time.local(year, 1, 1).zone</tt> and
    # <tt>Time.local(year, 7, 1).zone</tt>.
    # If the extracted time zone abbreviation does not match any of them,
    # it is ignored and the given time is regarded as a local time.
    #
    # ArgumentError is raised if Date._parse cannot extract information from
    # +date+ or if the Time class cannot represent specified date.
    #
    # This method can be used as a fail-safe for other parsing methods as:
    #
    #   Time.rfc2822(date) rescue Time.parse(date)
    #   Time.httpdate(date) rescue Time.parse(date)
    #   Time.xmlschema(date) rescue Time.parse(date)
    #
    # A failure of Time.parse should be checked, though.
    #
    # You must require 'time' to use this method.
    #
    def parse(date, now=self.now)
      comp = !block_given?
      d = Date._parse(date, comp)
      if !d[:year] && !d[:mon] && !d[:mday] && !d[:hour] && !d[:min] && !d[:sec] && !d[:sec_fraction]
        raise ArgumentError, "no time information in #{date.inspect}"
      end
      year = d[:year]
      year = yield(year) if year && !comp
      make_time(year, d[:mon], d[:mday], d[:hour], d[:min], d[:sec], d[:sec_fraction], d[:zone], now)
    end

    #
    # Parses +date+ using Date._strptime and converts it to a Time object.
    #
    # If a block is given, the year described in +date+ is converted by the
    # block.  For example:
    #
    #   Time.strptime(...) {|y| y < 100 ? (y >= 69 ? y + 1900 : y + 2000) : y}
    #
    # Below is a list of the formating options:
    #
    # %a :: The abbreviated weekday name ("Sun")
    # %A :: The  full  weekday  name ("Sunday")
    # %b :: The abbreviated month name ("Jan")
    # %B :: The  full  month  name ("January")
    # %c :: The preferred local date and time representation
    # %C :: Century (20 in 2009)
    # %d :: Day of the month (01..31)
    # %D :: Date (%m/%d/%y)
    # %e :: Day of the month, blank-padded ( 1..31)
    # %F :: Equivalent to %Y-%m-%d (the ISO 8601 date format)
    # %h :: Equivalent to %b
    # %H :: Hour of the day, 24-hour clock (00..23)
    # %I :: Hour of the day, 12-hour clock (01..12)
    # %j :: Day of the year (001..366)
    # %k :: hour, 24-hour clock, blank-padded ( 0..23)
    # %l :: hour, 12-hour clock, blank-padded ( 0..12)
    # %L :: Millisecond of the second (000..999)
    # %m :: Month of the year (01..12)
    # %M :: Minute of the hour (00..59)
    # %n :: Newline (\n)
    # %N :: Fractional seconds digits, default is 9 digits (nanosecond)
    #       %3N :: millisecond (3 digits)
    #       %6N :: microsecond (6 digits)
    #       %9N :: nanosecond (9 digits)
    # %p :: Meridian indicator ("AM" or "PM")
    # %P :: Meridian indicator ("am" or "pm")
    # %r :: time, 12-hour (same as %I:%M:%S %p)
    # %R :: time, 24-hour (%H:%M)
    # %s :: Number of seconds since 1970-01-01 00:00:00 UTC.
    # %S :: Second of the minute (00..60)
    # %t :: Tab character (\t)
    # %T :: time, 24-hour (%H:%M:%S)
    # %u :: Day of the week as a decimal, Monday being 1. (1..7)
    # %U :: Week number of the current year, starting with the first Sunday as
    #       the first day of the first week (00..53)
    # %v :: VMS date (%e-%b-%Y)
    # %V :: Week number of year according to ISO 8601 (01..53)
    # %W :: Week  number  of the current year, starting with the first Monday
    #       as the first day of the first week (00..53)
    # %w :: Day of the week (Sunday is 0, 0..6)
    # %x :: Preferred representation for the date alone, no time
    # %X :: Preferred representation for the time alone, no date
    # %y :: Year without a century (00..99)
    # %Y :: Year with century
    # %z :: Time zone as  hour offset from UTC (e.g. +0900)
    # %Z :: Time zone name
    # %% :: Literal "%" character

    def strptime(date, format, now=self.now)
      d = Date._strptime(date, format)
      raise ArgumentError, "invalid strptime format - `#{format}'" unless d
      if seconds = d[:seconds]
        if offset = d[:offset]
          Time.at(seconds).localtime(offset)
        else
          Time.at(seconds)
        end
      else
        year = d[:year]
        year = yield(year) if year && block_given?
        make_time(year, d[:mon], d[:mday], d[:hour], d[:min], d[:sec], d[:sec_fraction], d[:zone], now)
      end
    end

    MonthValue = {
      'JAN' => 1, 'FEB' => 2, 'MAR' => 3, 'APR' => 4, 'MAY' => 5, 'JUN' => 6,
      'JUL' => 7, 'AUG' => 8, 'SEP' => 9, 'OCT' =>10, 'NOV' =>11, 'DEC' =>12
    }

    #
    # Parses +date+ as date-time defined by RFC 2822 and converts it to a Time
    # object.  The format is identical to the date format defined by RFC 822 and
    # updated by RFC 1123.
    #
    # ArgumentError is raised if +date+ is not compliant with RFC 2822
    # or if the Time class cannot represent specified date.
    #
    # See #rfc2822 for more information on this format.
    #
    # You must require 'time' to use this method.
    #
    def rfc2822(date)
      if /\A\s*
          (?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s*,\s*)?
          (\d{1,2})\s+
          (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+
          (\d{2,})\s+
          (\d{2})\s*
          :\s*(\d{2})\s*
          (?::\s*(\d{2}))?\s+
          ([+-]\d{4}|
           UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-IK-Z])/ix =~ date
        # Since RFC 2822 permit comments, the regexp has no right anchor.
        day = $1.to_i
        mon = MonthValue[$2.upcase]
        year = $3.to_i
        hour = $4.to_i
        min = $5.to_i
        sec = $6 ? $6.to_i : 0
        zone = $7

        # following year completion is compliant with RFC 2822.
        year = if year < 50
                 2000 + year
               elsif year < 1000
                 1900 + year
               else
                 year
               end

        year, mon, day, hour, min, sec =
          apply_offset(year, mon, day, hour, min, sec, zone_offset(zone))
        t = self.utc(year, mon, day, hour, min, sec)
        t.localtime if !zone_utc?(zone)
        t
      else
        raise ArgumentError.new("not RFC 2822 compliant date: #{date.inspect}")
      end
    end
    alias rfc822 rfc2822

    #
    # Parses +date+ as an HTTP-date defined by RFC 2616 and converts it to a
    # Time object.
    #
    # ArgumentError is raised if +date+ is not compliant with RFC 2616 or if
    # the Time class cannot represent specified date.
    #
    # See #httpdate for more information on this format.
    #
    # You must require 'time' to use this method.
    #
    def httpdate(date)
      if /\A\s*
          (?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\x20
          (\d{2})\x20
          (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x20
          (\d{4})\x20
          (\d{2}):(\d{2}):(\d{2})\x20
          GMT
          \s*\z/ix =~ date
        self.rfc2822(date)
      elsif /\A\s*
             (?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\x20
             (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d)\x20
             (\d\d):(\d\d):(\d\d)\x20
             GMT
             \s*\z/ix =~ date
        year = $3.to_i
        if year < 50
          year += 2000
        else
          year += 1900
        end
        self.utc(year, $2, $1.to_i, $4.to_i, $5.to_i, $6.to_i)
      elsif /\A\s*
             (?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\x20
             (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x20
             (\d\d|\x20\d)\x20
             (\d\d):(\d\d):(\d\d)\x20
             (\d{4})
             \s*\z/ix =~ date
        self.utc($6.to_i, MonthValue[$1.upcase], $2.to_i,
                 $3.to_i, $4.to_i, $5.to_i)
      else
        raise ArgumentError.new("not RFC 2616 compliant date: #{date.inspect}")
      end
    end

    #
    # Parses +date+ as a dateTime defined by the XML Schema and converts it to
    # a Time object.  The format is a restricted version of the format defined
    # by ISO 8601.
    #
    # ArgumentError is raised if +date+ is not compliant with the format or if
    # the Time class cannot represent specified date.
    #
    # See #xmlschema for more information on this format.
    #
    # You must require 'time' to use this method.
    #
    def xmlschema(date)
      if /\A\s*
          (-?\d+)-(\d\d)-(\d\d)
          T
          (\d\d):(\d\d):(\d\d)
          (\.\d+)?
          (Z|[+-]\d\d:\d\d)?
          \s*\z/ix =~ date
        year = $1.to_i
        mon = $2.to_i
        day = $3.to_i
        hour = $4.to_i
        min = $5.to_i
        sec = $6.to_i
        usec = 0
        if $7
          usec = Rational($7) * 1000000
        end
        if $8
          zone = $8
          year, mon, day, hour, min, sec =
            apply_offset(year, mon, day, hour, min, sec, zone_offset(zone))
          self.utc(year, mon, day, hour, min, sec, usec)
        else
          self.local(year, mon, day, hour, min, sec, usec)
        end
      else
        raise ArgumentError.new("invalid date: #{date.inspect}")
      end
    end
    alias iso8601 xmlschema
  end # class << self

  #
  # Returns a string which represents the time as date-time defined by RFC 2822:
  #
  #   day-of-week, DD month-name CCYY hh:mm:ss zone
  #
  # where zone is [+-]hhmm.
  #
  # If +self+ is a UTC time, -0000 is used as zone.
  #
  # You must require 'time' to use this method.
  #
  def rfc2822
    sprintf('%s, %02d %s %0*d %02d:%02d:%02d ',
      RFC2822_DAY_NAME[wday],
      day, RFC2822_MONTH_NAME[mon-1], year < 0 ? 5 : 4, year,
      hour, min, sec) +
    if utc?
      '-0000'
    else
      off = utc_offset
      sign = off < 0 ? '-' : '+'
      sprintf('%s%02d%02d', sign, *(off.abs / 60).divmod(60))
    end
  end
  alias rfc822 rfc2822

  RFC2822_DAY_NAME = [
    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
  ]
  RFC2822_MONTH_NAME = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
  ]

  #
  # Returns a string which represents the time as RFC 1123 date of HTTP-date
  # defined by RFC 2616:
  #
  #   day-of-week, DD month-name CCYY hh:mm:ss GMT
  #
  # Note that the result is always UTC (GMT).
  #
  # You must require 'time' to use this method.
  #
  def httpdate
    t = dup.utc
    sprintf('%s, %02d %s %0*d %02d:%02d:%02d GMT',
      RFC2822_DAY_NAME[t.wday],
      t.day, RFC2822_MONTH_NAME[t.mon-1], t.year < 0 ? 5 : 4, t.year,
      t.hour, t.min, t.sec)
  end

  #
  # Returns a string which represents the time as a dateTime defined by XML
  # Schema:
  #
  #   CCYY-MM-DDThh:mm:ssTZD
  #   CCYY-MM-DDThh:mm:ss.sssTZD
  #
  # where TZD is Z or [+-]hh:mm.
  #
  # If self is a UTC time, Z is used as TZD.  [+-]hh:mm is used otherwise.
  #
  # +fractional_digits+ specifies a number of digits to use for fractional
  # seconds.  Its default value is 0.
  #
  # You must require 'time' to use this method.
  #
  def xmlschema(fraction_digits=0)
    fraction_digits = fraction_digits.to_i
    s = strftime("%FT%T")
    if fraction_digits > 0
      s << strftime(".%#{fraction_digits}N")
    end
    s << (utc? ? 'Z' : strftime("%:z"))
  end
  alias iso8601 xmlschema
end

                                                                                                                                                                                                                                                                                                                                                                                                                                   timeout.rb                                                                                          0100644 0001750 0001750 00000006247 12132544501 034317  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           # Timeout long-running blocks
#
# == Synopsis
#
#   require 'timeout'
#   status = Timeout::timeout(5) {
#     # Something that should be interrupted if it takes more than 5 seconds...
#   }
#
# == Description
#
# Timeout provides a way to auto-terminate a potentially long-running
# operation if it hasn't finished in a fixed amount of time.
#
# Previous versions didn't use a module for namespacing, however
# #timeout is provided for backwards compatibility.  You
# should prefer Timeout#timeout instead.
#
# == Copyright
#
# Copyright:: (C) 2000  Network Applied Communication Laboratory, Inc.
# Copyright:: (C) 2000  Information-technology Promotion Agency, Japan

module Timeout
  # Raised by Timeout#timeout when the block times out.
  class Error < RuntimeError
  end
  class ExitException < ::Exception # :nodoc:
  end

  # :stopdoc:
  THIS_FILE = /\A#{Regexp.quote(__FILE__)}:/o
  CALLER_OFFSET = ((c = caller[0]) && THIS_FILE =~ c) ? 1 : 0
  # :startdoc:

  # Perform an operation in a block, raising an error if it takes longer than
  # +sec+ seconds to complete.
  #
  # +sec+:: Number of seconds to wait for the block to terminate. Any number
  #         may be used, including Floats to specify fractional seconds. A
  #         value of 0 or +nil+ will execute the block without any timeout.
  # +klass+:: Exception Class to raise if the block fails to terminate
  #           in +sec+ seconds.  Omitting will use the default, Timeout::Error
  #
  # Returns the result of the block *if* the block completed before
  # +sec+ seconds, otherwise throws an exception, based on the value of +klass+.
  #
  # Note that this is both a method of module Timeout, so you can <tt>include
  # Timeout</tt> into your classes so they have a #timeout method, as well as
  # a module method, so you can call it directly as Timeout.timeout().
  def timeout(sec, klass = nil)   #:yield: +sec+
    return yield(sec) if sec == nil or sec.zero?
    exception = klass || Class.new(ExitException)
    begin
      begin
        x = Thread.current
        y = Thread.start {
          begin
            sleep sec
          rescue => e
            x.raise e
          else
            x.raise exception, "execution expired"
          end
        }
        return yield(sec)
      ensure
        if y
          y.kill
          y.join # make sure y is dead.
        end
      end
    rescue exception => e
      rej = /\A#{Regexp.quote(__FILE__)}:#{__LINE__-4}\z/o
      (bt = e.backtrace).reject! {|m| rej =~ m}
      level = -caller(CALLER_OFFSET).size
      while THIS_FILE =~ bt[level]
        bt.delete_at(level)
        level += 1
      end
      raise if klass            # if exception class is specified, it
                                # would be expected outside.
      raise Error, e.message, e.backtrace
    end
  end

  module_function :timeout
end

# Identical to:
#
#   Timeout::timeout(n, e, &block).
#
# This method is deprecated and provided only for backwards compatibility.
# You should use Timeout#timeout instead.
def timeout(n, e = nil, &block)
  Timeout::timeout(n, e, &block)
end

# Another name for Timeout::Error, defined for backwards compatibility with
# earlier versions of timeout.rb.
TimeoutError = Timeout::Error
                                                                                                                                                                                                                                                                                                                                                         tmpdir.rb                                                                                           0100644 0001750 0001750 00000010230 12062075523 034120  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
# tmpdir - retrieve temporary directory path
#
# $Id: tmpdir.rb 38348 2012-12-12 12:40:51Z nobu $
#

require 'fileutils'
begin
  require 'etc.so'
rescue LoadError
end

class Dir

  @@systmpdir ||= defined?(Etc.systmpdir) ? Etc.systmpdir : '/tmp'

  ##
  # Returns the operating system's temporary file path.

  def Dir::tmpdir
    if $SAFE > 0
      tmp = @@systmpdir
    else
      tmp = nil
      for dir in [ENV['TMPDIR'], ENV['TMP'], ENV['TEMP'], @@systmpdir, '/tmp', '.']
        next if !dir
        dir = File.expand_path(dir)
        if stat = File.stat(dir) and stat.directory? and stat.writable? and
            (!stat.world_writable? or stat.sticky?)
          tmp = dir
          break
        end rescue nil
      end
      raise ArgumentError, "could not find a temporary directory" if !tmp
      tmp
    end
  end

  # Dir.mktmpdir creates a temporary directory.
  #
  # The directory is created with 0700 permission.
  # Application should not change the permission to make the temporary directory accesible from other users.
  #
  # The prefix and suffix of the name of the directory is specified by
  # the optional first argument, <i>prefix_suffix</i>.
  # - If it is not specified or nil, "d" is used as the prefix and no suffix is used.
  # - If it is a string, it is used as the prefix and no suffix is used.
  # - If it is an array, first element is used as the prefix and second element is used as a suffix.
  #
  #  Dir.mktmpdir {|dir| dir is ".../d..." }
  #  Dir.mktmpdir("foo") {|dir| dir is ".../foo..." }
  #  Dir.mktmpdir(["foo", "bar"]) {|dir| dir is ".../foo...bar" }
  #
  # The directory is created under Dir.tmpdir or
  # the optional second argument <i>tmpdir</i> if non-nil value is given.
  #
  #  Dir.mktmpdir {|dir| dir is "#{Dir.tmpdir}/d..." }
  #  Dir.mktmpdir(nil, "/var/tmp") {|dir| dir is "/var/tmp/d..." }
  #
  # If a block is given,
  # it is yielded with the path of the directory.
  # The directory and its contents are removed
  # using FileUtils.remove_entry before Dir.mktmpdir returns.
  # The value of the block is returned.
  #
  #  Dir.mktmpdir {|dir|
  #    # use the directory...
  #    open("#{dir}/foo", "w") { ... }
  #  }
  #
  # If a block is not given,
  # The path of the directory is returned.
  # In this case, Dir.mktmpdir doesn't remove the directory.
  #
  #  dir = Dir.mktmpdir
  #  begin
  #    # use the directory...
  #    open("#{dir}/foo", "w") { ... }
  #  ensure
  #    # remove the directory.
  #    FileUtils.remove_entry dir
  #  end
  #
  def Dir.mktmpdir(prefix_suffix=nil, *rest)
    path = Tmpname.create(prefix_suffix || "d", *rest) {|n| mkdir(n, 0700)}
    if block_given?
      begin
        yield path
      ensure
        stat = File.stat(File.dirname(path))
        if stat.world_writable? and !stat.sticky?
          raise ArgumentError, "parent directory is world writable but not sticky"
        end
        FileUtils.remove_entry path
      end
    else
      path
    end
  end

  module Tmpname # :nodoc:
    module_function

    def tmpdir
      Dir.tmpdir
    end

    def make_tmpname(prefix_suffix, n)
      case prefix_suffix
      when String
        prefix = prefix_suffix
        suffix = ""
      when Array
        prefix = prefix_suffix[0]
        suffix = prefix_suffix[1]
      else
        raise ArgumentError, "unexpected prefix_suffix: #{prefix_suffix.inspect}"
      end
      t = Time.now.strftime("%Y%m%d")
      path = "#{prefix}#{t}-#{$$}-#{rand(0x100000000).to_s(36)}"
      path << "-#{n}" if n
      path << suffix
    end

    def create(basename, *rest)
      if opts = Hash.try_convert(rest[-1])
        opts = opts.dup if rest.pop.equal?(opts)
        max_try = opts.delete(:max_try)
        opts = [opts]
      else
        opts = []
      end
      tmpdir, = *rest
      if $SAFE > 0 and tmpdir.tainted?
        tmpdir = '/tmp'
      else
        tmpdir ||= tmpdir()
      end
      n = nil
      begin
        path = File.join(tmpdir, make_tmpname(basename, n))
        yield(path, n, *opts)
      rescue Errno::EEXIST
        n ||= 0
        n += 1
        retry if !max_try or n < max_try
        raise "cannot generate temporary name using `#{basename}' under `#{tmpdir}'"
      end
      path
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                        tracer.rb                                                                                           0100644 0001750 0001750 00000015046 12103773430 034111  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #--
# $Release Version: 0.3$
# $Revision: 1.12 $
require "thread"

##
# Outputs a source level execution trace of a Ruby program.
#
# It does this by registering an event handler with Kernel#set_trace_func for
# processing incoming events.  It also provides methods for filtering unwanted
# trace output (see Tracer.add_filter, Tracer.on, and Tracer.off).
#
# == Example
#
# Consider the following ruby script
#
#   class A
#     def square(a)
#       return a*a
#     end
#   end
#
#   a = A.new
#   a.square(5)
#
# Running the above script using <code>ruby -r tracer example.rb</code> will
# output the following trace to STDOUT (Note you can also explicitly
# <code>require 'tracer'</code>)
#
#   #0:<internal:lib/rubygems/custom_require>:38:Kernel:<: -
#   #0:example.rb:3::-: class A
#   #0:example.rb:3::C: class A
#   #0:example.rb:4::-:   def square(a)
#   #0:example.rb:7::E: end
#   #0:example.rb:9::-: a = A.new
#   #0:example.rb:10::-: a.square(5)
#   #0:example.rb:4:A:>:   def square(a)
#   #0:example.rb:5:A:-:     return a*a
#   #0:example.rb:6:A:<:   end
#    |  |         | |  |
#    |  |         | |   ---------------------+ event
#    |  |         |  ------------------------+ class
#    |  |          --------------------------+ line
#    |   ------------------------------------+ filename
#     ---------------------------------------+ thread
#
# Symbol table used for displaying incoming events:
#
# +}+:: call a C-language routine
# +{+:: return from a C-language routine
# +>+:: call a Ruby method
# +C+:: start a class or module definition
# +E+:: finish a class or module definition
# +-+:: execute code on a new line
# +^+:: raise an exception
# +<+:: return from a Ruby method
#
# == Copyright
#
# by Keiju ISHITSUKA(keiju@ishitsuka.com)
#
class Tracer
  class << self
    # display additional debug information (defaults to false)
    attr_accessor :verbose
    alias verbose? verbose

    # output stream used to output trace (defaults to STDOUT)
    attr_accessor :stdout

    # mutex lock used by tracer for displaying trace output
    attr_reader :stdout_mutex

    # display process id in trace output (defaults to false)
    attr_accessor :display_process_id
    alias display_process_id? display_process_id

    # display thread id in trace output (defaults to true)
    attr_accessor :display_thread_id
    alias display_thread_id? display_thread_id

    # display C-routine calls in trace output (defaults to false)
    attr_accessor :display_c_call
    alias display_c_call? display_c_call
  end

  Tracer::stdout = STDOUT
  Tracer::verbose = false
  Tracer::display_process_id = false
  Tracer::display_thread_id = true
  Tracer::display_c_call = false

  @stdout_mutex = Mutex.new

  # Symbol table used for displaying trace information
  EVENT_SYMBOL = {
    "line" => "-",
    "call" => ">",
    "return" => "<",
    "class" => "C",
    "end" => "E",
    "raise" => "^",
    "c-call" => "}",
    "c-return" => "{",
    "unknown" => "?"
  }

  def initialize # :nodoc:
    @threads = Hash.new
    if defined? Thread.main
      @threads[Thread.main.object_id] = 0
    else
      @threads[Thread.current.object_id] = 0
    end

    @get_line_procs = {}

    @filters = []
  end

  def stdout # :nodoc:
    Tracer.stdout
  end

  def on # :nodoc:
    if block_given?
      on
      begin
        yield
      ensure
        off
      end
    else
      set_trace_func method(:trace_func).to_proc
      stdout.print "Trace on\n" if Tracer.verbose?
    end
  end

  def off # :nodoc:
    set_trace_func nil
    stdout.print "Trace off\n" if Tracer.verbose?
  end

  def add_filter(p = proc) # :nodoc:
    @filters.push p
  end

  def set_get_line_procs(file, p = proc) # :nodoc:
    @get_line_procs[file] = p
  end

  def get_line(file, line) # :nodoc:
    if p = @get_line_procs[file]
      return p.call(line)
    end

    unless list = SCRIPT_LINES__[file]
      begin
        f = File::open(file)
        begin
          SCRIPT_LINES__[file] = list = f.readlines
        ensure
          f.close
        end
      rescue
        SCRIPT_LINES__[file] = list = []
      end
    end

    if l = list[line - 1]
      l
    else
      "-\n"
    end
  end

  def get_thread_no # :nodoc:
    if no = @threads[Thread.current.object_id]
      no
    else
      @threads[Thread.current.object_id] = @threads.size
    end
  end

  def trace_func(event, file, line, id, binding, klass, *) # :nodoc:
    return if file == __FILE__

    for p in @filters
      return unless p.call event, file, line, id, binding, klass
    end

    return unless Tracer::display_c_call? or
      event != "c-call" && event != "c-return"

    Tracer::stdout_mutex.synchronize do
      if EVENT_SYMBOL[event]
        stdout.printf("<%d>", $$) if Tracer::display_process_id?
        stdout.printf("#%d:", get_thread_no) if Tracer::display_thread_id?
        if line == 0
          source = "?\n"
        else
          source = get_line(file, line)
        end
        stdout.printf("%s:%d:%s:%s: %s",
               file,
               line,
               klass || '',
               EVENT_SYMBOL[event],
               source)
      end
    end

  end

  # Reference to singleton instance of Tracer
  Single = new

  ##
  # Start tracing
  #
  # === Example
  #
  #   Tracer.on
  #   # code to trace here
  #   Tracer.off
  #
  # You can also pass a block:
  #
  #   Tracer.on {
  #     # trace everything in this block
  #   }

  def Tracer.on
    if block_given?
      Single.on{yield}
    else
      Single.on
    end
  end

  ##
  # Disable tracing

  def Tracer.off
    Single.off
  end

  ##
  # Register an event handler <code>p</code> which is called everytime a line
  # in +file_name+ is executed.
  #
  # Example:
  #
  #   Tracer.set_get_line_procs("example.rb", lambda { |line|
  #     puts "line number executed is #{line}"
  #   })

  def Tracer.set_get_line_procs(file_name, p = proc)
    Single.set_get_line_procs(file_name, p)
  end

  ##
  # Used to filter unwanted trace output
  #
  # Example which only outputs lines of code executed within the Kernel class:
  #
  #   Tracer.add_filter do |event, file, line, id, binding, klass, *rest|
  #     "Kernel" == klass.to_s
  #   end

  def Tracer.add_filter(p = proc)
    Single.add_filter(p)
  end
end

# :stopdoc:
SCRIPT_LINES__ = {} unless defined? SCRIPT_LINES__

if $0 == __FILE__
  # direct call

  $0 = ARGV[0]
  ARGV.shift
  Tracer.on
  require $0
else
  # call Tracer.on only if required by -r command-line option
  count = caller.count {|bt| %r%/rubygems/core_ext/kernel_require\.rb:% !~ bt}
  if (defined?(Gem) and count == 0) or
     (!defined?(Gem) and count <= 1)
    Tracer.on
  end
end
# :startdoc:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          tsort.rb                                                                                            0100644 0001750 0001750 00000015456 11154122451 034005  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #--
# tsort.rb - provides a module for topological sorting and strongly connected components.
#++
#

#
# TSort implements topological sorting using Tarjan's algorithm for
# strongly connected components.
#
# TSort is designed to be able to be used with any object which can be
# interpreted as a directed graph.
#
# TSort requires two methods to interpret an object as a graph,
# tsort_each_node and tsort_each_child.
#
# * tsort_each_node is used to iterate for all nodes over a graph.
# * tsort_each_child is used to iterate for child nodes of a given node.
#
# The equality of nodes are defined by eql? and hash since
# TSort uses Hash internally.
#
# == A Simple Example
#
# The following example demonstrates how to mix the TSort module into an
# existing class (in this case, Hash). Here, we're treating each key in
# the hash as a node in the graph, and so we simply alias the required
# #tsort_each_node method to Hash's #each_key method. For each key in the
# hash, the associated value is an array of the node's child nodes. This
# choice in turn leads to our implementation of the required #tsort_each_child
# method, which fetches the array of child nodes and then iterates over that
# array using the user-supplied block.
#
#   require 'tsort'
#
#   class Hash
#     include TSort
#     alias tsort_each_node each_key
#     def tsort_each_child(node, &block)
#       fetch(node).each(&block)
#     end
#   end
#
#   {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
#   #=> [3, 2, 1, 4]
#
#   {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
#   #=> [[4], [2, 3], [1]]
#
# == A More Realistic Example
#
# A very simple `make' like tool can be implemented as follows:
#
#   require 'tsort'
#
#   class Make
#     def initialize
#       @dep = {}
#       @dep.default = []
#     end
#
#     def rule(outputs, inputs=[], &block)
#       triple = [outputs, inputs, block]
#       outputs.each {|f| @dep[f] = [triple]}
#       @dep[triple] = inputs
#     end
#
#     def build(target)
#       each_strongly_connected_component_from(target) {|ns|
#         if ns.length != 1
#           fs = ns.delete_if {|n| Array === n}
#           raise TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
#         end
#         n = ns.first
#         if Array === n
#           outputs, inputs, block = n
#           inputs_time = inputs.map {|f| File.mtime f}.max
#           begin
#             outputs_time = outputs.map {|f| File.mtime f}.min
#           rescue Errno::ENOENT
#             outputs_time = nil
#           end
#           if outputs_time == nil ||
#              inputs_time != nil && outputs_time <= inputs_time
#             sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
#             block.call
#           end
#         end
#       }
#     end
#
#     def tsort_each_child(node, &block)
#       @dep[node].each(&block)
#     end
#     include TSort
#   end
#
#   def command(arg)
#     print arg, "\n"
#     system arg
#   end
#
#   m = Make.new
#   m.rule(%w[t1]) { command 'date > t1' }
#   m.rule(%w[t2]) { command 'date > t2' }
#   m.rule(%w[t3]) { command 'date > t3' }
#   m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
#   m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
#   m.build('t5')
#
# == Bugs
#
# * 'tsort.rb' is wrong name because this library uses
#   Tarjan's algorithm for strongly connected components.
#   Although 'strongly_connected_components.rb' is correct but too long.
#
# == References
#
# R. E. Tarjan, "Depth First Search and Linear Graph Algorithms",
# <em>SIAM Journal on Computing</em>, Vol. 1, No. 2, pp. 146-160, June 1972.
#

module TSort
  class Cyclic < StandardError
  end

  #
  # Returns a topologically sorted array of nodes.
  # The array is sorted from children to parents, i.e.
  # the first element has no child and the last node has no parent.
  #
  # If there is a cycle, TSort::Cyclic is raised.
  #
  def tsort
    result = []
    tsort_each {|element| result << element}
    result
  end

  #
  # The iterator version of the #tsort method.
  # <tt><em>obj</em>.tsort_each</tt> is similar to <tt><em>obj</em>.tsort.each</tt>, but
  # modification of _obj_ during the iteration may lead to unexpected results.
  #
  # #tsort_each returns +nil+.
  # If there is a cycle, TSort::Cyclic is raised.
  #
  def tsort_each # :yields: node
    each_strongly_connected_component {|component|
      if component.size == 1
        yield component.first
      else
        raise Cyclic.new("topological sort failed: #{component.inspect}")
      end
    }
  end

  #
  # Returns strongly connected components as an array of arrays of nodes.
  # The array is sorted from children to parents.
  # Each elements of the array represents a strongly connected component.
  #
  def strongly_connected_components
    result = []
    each_strongly_connected_component {|component| result << component}
    result
  end

  #
  # The iterator version of the #strongly_connected_components method.
  # <tt><em>obj</em>.each_strongly_connected_component</tt> is similar to
  # <tt><em>obj</em>.strongly_connected_components.each</tt>, but
  # modification of _obj_ during the iteration may lead to unexpected results.
  #
  #
  # #each_strongly_connected_component returns +nil+.
  #
  def each_strongly_connected_component # :yields: nodes
    id_map = {}
    stack = []
    tsort_each_node {|node|
      unless id_map.include? node
        each_strongly_connected_component_from(node, id_map, stack) {|c|
          yield c
        }
      end
    }
    nil
  end

  #
  # Iterates over strongly connected component in the subgraph reachable from
  # _node_.
  #
  # Return value is unspecified.
  #
  # #each_strongly_connected_component_from doesn't call #tsort_each_node.
  #
  def each_strongly_connected_component_from(node, id_map={}, stack=[]) # :yields: nodes
    minimum_id = node_id = id_map[node] = id_map.size
    stack_length = stack.length
    stack << node

    tsort_each_child(node) {|child|
      if id_map.include? child
        child_id = id_map[child]
        minimum_id = child_id if child_id && child_id < minimum_id
      else
        sub_minimum_id =
          each_strongly_connected_component_from(child, id_map, stack) {|c|
            yield c
          }
        minimum_id = sub_minimum_id if sub_minimum_id < minimum_id
      end
    }

    if node_id == minimum_id
      component = stack.slice!(stack_length .. -1)
      component.each {|n| id_map[n] = nil}
      yield component
    end

    minimum_id
  end

  #
  # Should be implemented by a extended class.
  #
  # #tsort_each_node is used to iterate for all nodes over a graph.
  #
  def tsort_each_node # :yields: node
    raise NotImplementedError.new
  end

  #
  # Should be implemented by a extended class.
  #
  # #tsort_each_child is used to iterate for child nodes of _node_.
  #
  def tsort_each_child(node) # :yields: child
    raise NotImplementedError.new
  end
end
                                                                                                                                                                                                                  ubygems.rb                                                                                          0100644 0001750 0001750 00000000414 11261354723 034301  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           # This file allows for the running of rubygems with a nice
# command line look-and-feel: ruby -rubygems foo.rb
#--
# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.
# All rights reserved.
# See LICENSE.txt for permissions.
#++


require 'rubygems'
                                                                                                                                                                                                                                                    un.rb                                                                                               0100644 0001750 0001750 00000020531 12006705166 033251  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           #
# = un.rb
#
# Copyright (c) 2003 WATANABE Hirofumi <eban@ruby-lang.org>
#
# This program is free software.
# You can distribute/modify this program under the same terms of Ruby.
#
# == Utilities to replace common UNIX commands in Makefiles etc
#
# == SYNOPSIS
#
#   ruby -run -e cp -- [OPTION] SOURCE DEST
#   ruby -run -e ln -- [OPTION] TARGET LINK_NAME
#   ruby -run -e mv -- [OPTION] SOURCE DEST
#   ruby -run -e rm -- [OPTION] FILE
#   ruby -run -e mkdir -- [OPTION] DIRS
#   ruby -run -e rmdir -- [OPTION] DIRS
#   ruby -run -e install -- [OPTION] SOURCE DEST
#   ruby -run -e chmod -- [OPTION] OCTAL-MODE FILE
#   ruby -run -e touch -- [OPTION] FILE
#   ruby -run -e wait_writable -- [OPTION] FILE
#   ruby -run -e mkmf -- [OPTION] EXTNAME [OPTION]
#   ruby -run -e httpd -- [OPTION] DocumentRoot
#   ruby -run -e help [COMMAND]

require "fileutils"
require "optparse"

module FileUtils
#  @fileutils_label = ""
  @fileutils_output = $stdout
end

def setup(options = "", *long_options)
  opt_hash = {}
  argv = []
  OptionParser.new do |o|
    options.scan(/.:?/) do |s|
      opt_name = s.delete(":").intern
      o.on("-" + s.tr(":", " ")) do |val|
        opt_hash[opt_name] = val
      end
    end
    long_options.each do |s|
      opt_name, arg_name = s.split(/(?=[\s=])/, 2)
      opt_name.sub!(/\A--/, '')
      s = "--#{opt_name.gsub(/([A-Z]+|[a-z])([A-Z])/, '\1-\2').downcase}#{arg_name}"
      puts "#{opt_name}=>#{s}" if $DEBUG
      opt_name = opt_name.intern
      o.on(s) do |val|
        opt_hash[opt_name] = val
      end
    end
    o.on("-v") do opt_hash[:verbose] = true end
    o.order!(ARGV) do |x|
      if /[*?\[{]/ =~ x
        argv.concat(Dir[x])
      else
        argv << x
      end
    end
  end
  yield argv, opt_hash
end

##
# Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY
#
#   ruby -run -e cp -- [OPTION] SOURCE DEST
#
#   -p          preserve file attributes if possible
#   -r          copy recursively
#   -v          verbose
#

def cp
  setup("pr") do |argv, options|
    cmd = "cp"
    cmd += "_r" if options.delete :r
    options[:preserve] = true if options.delete :p
    dest = argv.pop
    argv = argv[0] if argv.size == 1
    FileUtils.send cmd, argv, dest, options
  end
end

##
# Create a link to the specified TARGET with LINK_NAME.
#
#   ruby -run -e ln -- [OPTION] TARGET LINK_NAME
#
#   -s          make symbolic links instead of hard links
#   -f          remove existing destination files
#   -v          verbose
#

def ln
  setup("sf") do |argv, options|
    cmd = "ln"
    cmd += "_s" if options.delete :s
    options[:force] = true if options.delete :f
    dest = argv.pop
    argv = argv[0] if argv.size == 1
    FileUtils.send cmd, argv, dest, options
  end
end

##
# Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.
#
#   ruby -run -e mv -- [OPTION] SOURCE DEST
#
#   -v          verbose
#

def mv
  setup do |argv, options|
    dest = argv.pop
    argv = argv[0] if argv.size == 1
    FileUtils.mv argv, dest, options
  end
end

##
# Remove the FILE
#
#   ruby -run -e rm -- [OPTION] FILE
#
#   -f          ignore nonexistent files
#   -r          remove the contents of directories recursively
#   -v          verbose
#

def rm
  setup("fr") do |argv, options|
    cmd = "rm"
    cmd += "_r" if options.delete :r
    options[:force] = true if options.delete :f
    FileUtils.send cmd, argv, options
  end
end

##
# Create the DIR, if they do not already exist.
#
#   ruby -run -e mkdir -- [OPTION] DIR
#
#   -p          no error if existing, make parent directories as needed
#   -v          verbose
#

def mkdir
  setup("p") do |argv, options|
    cmd = "mkdir"
    cmd += "_p" if options.delete :p
    FileUtils.send cmd, argv, options
  end
end

##
# Remove the DIR.
#
#   ruby -run -e rmdir -- [OPTION] DIR
#
#   -p          remove DIRECTORY and its ancestors.
#   -v          verbose
#

def rmdir
  setup("p") do |argv, options|
    options[:parents] = true if options.delete :p
    FileUtils.rmdir argv, options
  end
end

##
# Copy SOURCE to DEST.
#
#   ruby -run -e install -- [OPTION] SOURCE DEST
#
#   -p          apply access/modification times of SOURCE files to
#               corresponding destination files
#   -m          set permission mode (as in chmod), instead of 0755
#   -v          verbose
#

def install
  setup("pm:") do |argv, options|
    options[:mode] = (mode = options.delete :m) ? mode.oct : 0755
    options[:preserve] = true if options.delete :p
    dest = argv.pop
    argv = argv[0] if argv.size == 1
    FileUtils.install argv, dest, options
  end
end

##
# Change the mode of each FILE to OCTAL-MODE.
#
#   ruby -run -e chmod -- [OPTION] OCTAL-MODE FILE
#
#   -v          verbose
#

def chmod
  setup do |argv, options|
    mode = argv.shift.oct
    FileUtils.chmod mode, argv, options
  end
end

##
# Update the access and modification times of each FILE to the current time.
#
#   ruby -run -e touch -- [OPTION] FILE
#
#   -v          verbose
#

def touch
  setup do |argv, options|
    FileUtils.touch argv, options
  end
end

##
# Wait until the file becomes writable.
#
#   ruby -run -e wait_writable -- [OPTION] FILE
#
#   -n RETRY    count to retry
#   -w SEC      each wait time in seconds
#   -v          verbose
#

def wait_writable
  setup("n:w:v") do |argv, options|
    verbose = options[:verbose]
    n = options[:n] and n = Integer(n)
    wait = (wait = options[:w]) ? Float(wait) : 0.2
    argv.each do |file|
      begin
        open(file, "r+b")
      rescue Errno::ENOENT
        break
      rescue Errno::EACCES => e
        raise if n and (n -= 1) <= 0
        puts e
        STDOUT.flush
        sleep wait
        retry
      end
    end
  end
end

##
# Create makefile using mkmf.
#
#   ruby -run -e mkmf -- [OPTION] EXTNAME [OPTION]
#
#   -d ARGS     run dir_config
#   -h ARGS     run have_header
#   -l ARGS     run have_library
#   -f ARGS     run have_func
#   -v ARGS     run have_var
#   -t ARGS     run have_type
#   -m ARGS     run have_macro
#   -c ARGS     run have_const
#   --vendor    install to vendor_ruby
#

def mkmf
  setup("d:h:l:f:v:t:m:c:", "vendor") do |argv, options|
    require 'mkmf'
    opt = options[:d] and opt.split(/:/).each {|n| dir_config(*n.split(/,/))}
    opt = options[:h] and opt.split(/:/).each {|n| have_header(*n.split(/,/))}
    opt = options[:l] and opt.split(/:/).each {|n| have_library(*n.split(/,/))}
    opt = options[:f] and opt.split(/:/).each {|n| have_func(*n.split(/,/))}
    opt = options[:v] and opt.split(/:/).each {|n| have_var(*n.split(/,/))}
    opt = options[:t] and opt.split(/:/).each {|n| have_type(*n.split(/,/))}
    opt = options[:m] and opt.split(/:/).each {|n| have_macro(*n.split(/,/))}
    opt = options[:c] and opt.split(/:/).each {|n| have_const(*n.split(/,/))}
    $configure_args["--vendor"] = true if options[:vendor]
    create_makefile(*argv)
  end
end

##
# Run WEBrick HTTP server.
#
#   ruby -run -e httpd -- [OPTION] DocumentRoot
#
#   --bind-address=ADDR         address to bind
#   --port=NUM                  listening port number
#   --max-clients=MAX           max number of simultaneous clients
#   --temp-dir=DIR              temporary directory
#   --do-not-reverse-lookup     disable reverse lookup
#   --request-timeout=SECOND    request timeout in seconds
#   --http-version=VERSION      HTTP version
#   -v                          verbose
#

def httpd
  setup("", "BindAddress=ADDR", "Port=PORT", "MaxClients=NUM", "TempDir=DIR",
        "DoNotReverseLookup", "RequestTimeout=SECOND", "HTTPVersion=VERSION") do
    |argv, options|
    require 'webrick'
    opt = options[:RequestTimeout] and options[:RequestTimeout] = opt.to_i
    [:Port, :MaxClients].each do |name|
      opt = options[name] and (options[name] = Integer(opt)) rescue nil
    end
    unless argv.size == 1
      raise ArgumentError, "DocumentRoot is mandatory"
    end
    options[:DocumentRoot] = argv.shift
    s = WEBrick::HTTPServer.new(options)
    shut = proc {s.shutdown}
    siglist = %w"TERM QUIT"
    siglist.concat(%w"HUP INT") if STDIN.tty?
    siglist &= Signal.list.keys
    siglist.each do |sig|
      Signal.trap(sig, shut)
    end
    s.start
  end
end

##
# Display help message.
#
#   ruby -run -e help [COMMAND]
#

def help
  setup do |argv,|
    all = argv.empty?
    open(__FILE__) do |me|
      while me.gets("##\n")
        if help = me.gets("\n\n")
          if all or argv.delete help[/-e \w+/].sub(/-e /, "")
            print help.gsub(/^# ?/, "")
          end
        end
      end
    end
  end
end
                                                                                                                                                                       universal-darwin15/                                                                                 0040755 0001750 0001750 00000000000 12612224745 035746  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           rbconfig.rb                                                                                         0100644 0001750 0001750 00000026241 12566206474 040075  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwin15                                        
# This file was created by mkconfig.rb when ruby was built.  Any
# changes made to this file will be lost the next time ruby is built.

module RbConfig
  RUBY_VERSION == "2.0.0" or
    raise "ruby lib version (2.0.0) doesn't match executable version (#{RUBY_VERSION})"

  TOPDIR = File.dirname(__FILE__).chomp!("/lib/ruby/2.0.0/universal-darwin15")
  DESTDIR = '' unless defined? DESTDIR
  arch_flag = ENV['ARCHFLAGS'] || ((e = ENV['RC_ARCHS']) && e.split.uniq.map {|a| "-arch #{a}"}.join(' '))
  universal = " i386=i386 x86_64=x86_64"
  CONFIG = {}
  CONFIG["DESTDIR"] = DESTDIR
  CONFIG["MAJOR"] = "2"
  CONFIG["MINOR"] = "0"
  CONFIG["TEENY"] = "0"
  CONFIG["PATCHLEVEL"] = "645"
  CONFIG["INSTALL"] = '/usr/bin/install -c'
  CONFIG["EXEEXT"] = ""
  CONFIG["prefix"] = (TOPDIR || DESTDIR + "/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr")
  CONFIG["ruby_install_name"] = "ruby"
  CONFIG["RUBY_INSTALL_NAME"] = "ruby"
  CONFIG["RUBY_SO_NAME"] = "ruby.2.0.0"
  CONFIG["exec"] = "exec"
  CONFIG["ruby_pc"] = "ruby-2.0.pc"
  CONFIG["PACKAGE"] = "ruby"
  CONFIG["BUILTIN_TRANSSRCS"] = " newline.c"
  CONFIG["USE_RUBYGEMS"] = "YES"
  CONFIG["MANTYPE"] = "doc"
  CONFIG["NROFF"] = "/usr/bin/nroff"
  CONFIG["vendorarchhdrdir"] = "$(vendorhdrdir)/$(sitearch)"
  CONFIG["sitearchhdrdir"] = "$(sitehdrdir)/$(sitearch)"
  CONFIG["rubyarchhdrdir"] = "$(rubyhdrdir)/$(arch)"
  CONFIG["vendorhdrdir"] = "$(rubyhdrdir)/vendor_ruby"
  CONFIG["sitehdrdir"] = "$(rubyhdrdir)/site_ruby"
  CONFIG["rubyhdrdir"] = "$(includedir)/$(RUBY_VERSION_NAME)"
  CONFIG["UNIVERSAL_INTS"] = "'long long' long int short"
  CONFIG["UNIVERSAL_ARCHNAMES"] = universal
  CONFIG["configure_args"] = " '--prefix=/usr' '--mandir=/usr/share/man' '--infodir=/usr/share/info' '--disable-dependency-tracking' '--prefix=/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr' '--sysconfdir=/Library/Ruby/Site' '--with-sitedir=/Library/Ruby/Site' '--enable-shared' '--with-arch=i386,x86_64' '--without-ext=tk' 'ac_cv_func_getcontext=no' 'ac_cv_func_setcontext=no' 'ac_cv_c_compiler_gnu=no' 'ac_cv_header_net_if_h=yes' 'av_cv_header_ifaddrs_h=yes' 'rb_cv_pri_prefix_long_long=ll' 'ac_cv_sizeof_struct_stat_st_size=SIZEOF_OFF_T' 'ac_cv_sizeof_struct_stat_st_blocks=SIZEOF_INT64_T' 'ac_cv_sizeof_struct_stat_st_ino=SIZEOF_UINT64_T' 'CC=xcrun clang' 'CFLAGS=-arch i386 -arch x86_64 -g -Os -pipe -DHAVE_GCC_SYNC_BUILTINS' 'LDFLAGS=-arch i386 -arch x86_64            ' 'CXX=xcrun clang++' 'CXXFLAGS=-arch i386 -arch x86_64 -g -Os -pipe '"
  CONFIG["vendorarchdir"] = "$(vendorlibdir)/$(sitearch)"
  CONFIG["vendorlibdir"] = "$(vendordir)/$(ruby_version)"
  CONFIG["vendordir"] = "$(rubylibprefix)/vendor_ruby"
  CONFIG["sitearchdir"] = "$(sitelibdir)/$(sitearch)"
  CONFIG["sitelibdir"] = "$(sitedir)/$(ruby_version)"
  CONFIG["sitedir"] = "$(DESTDIR)/Library/Ruby/Site"
  CONFIG["rubyarchdir"] = "$(rubylibdir)/$(arch)"
  CONFIG["rubylibdir"] = "$(rubylibprefix)/$(ruby_version)"
  CONFIG["ruby_version"] = "2.0.0"
  CONFIG["sitearch"] = "$(arch)"
  CONFIG["arch"] = "universal-darwin15"
  CONFIG["sitearchincludedir"] = "$(includedir)/$(sitearch)"
  CONFIG["archincludedir"] = "$(includedir)/$(arch)"
  CONFIG["sitearchlibdir"] = "$(libdir)/$(sitearch)"
  CONFIG["archlibdir"] = "$(libdir)/$(arch)"
  CONFIG["RI_BASE_NAME"] = "ri"
  CONFIG["ridir"] = "$(datarootdir)/$(RI_BASE_NAME)"
  CONFIG["rubysitearchprefix"] = "$(rubylibprefix)/$(sitearch)"
  CONFIG["rubyarchprefix"] = "$(rubylibprefix)/$(arch)"
  CONFIG["rubylibprefix"] = "$(libdir)/$(RUBY_BASE_NAME)"
  CONFIG["MAKEFILES"] = "Makefile"
  CONFIG["PLATFORM_DIR"] = ""
  CONFIG["THREAD_MODEL"] = "pthread"
  CONFIG["SYMBOL_PREFIX"] = "_"
  CONFIG["EXPORT_PREFIX"] = ""
  CONFIG["COMMON_HEADERS"] = ""
  CONFIG["COMMON_MACROS"] = ""
  CONFIG["COMMON_LIBS"] = ""
  CONFIG["MAINLIBS"] = ""
  CONFIG["ENABLE_SHARED"] = "yes"
  CONFIG["DLDLIBS"] = ""
  CONFIG["SOLIBS"] = ""
  CONFIG["LIBRUBYARG_SHARED"] = "-l$(RUBY_SO_NAME)"
  CONFIG["LIBRUBYARG_STATIC"] = "-l$(RUBY_SO_NAME)-static"
  CONFIG["LIBRUBYARG"] = "$(LIBRUBYARG_SHARED)"
  CONFIG["LIBRUBY"] = "$(LIBRUBY_SO)"
  CONFIG["LIBRUBY_ALIASES"] = "lib$(RUBY_BASE_NAME).$(MAJOR).$(MINOR).dylib lib$(RUBY_INSTALL_NAME).dylib"
  CONFIG["LIBRUBY_SO"] = "lib$(RUBY_SO_NAME).dylib"
  CONFIG["LIBRUBY_A"] = "lib$(RUBY_SO_NAME)-static.a"
  CONFIG["RUBYW_INSTALL_NAME"] = ""
  CONFIG["rubyw_install_name"] = ""
  CONFIG["LIBRUBY_DLDFLAGS"] = "-Wl,-undefined,dynamic_lookup -Wl,-multiply_defined,suppress -install_name $(libdir)/$(LIBRUBY_SO) -current_version $(MAJOR).$(MINOR).$(TEENY) -compatibility_version $(ruby_version)  $(XLDFLAGS)"
  CONFIG["LIBRUBY_LDSHARED"] = "$(CC) -dynamiclib"
  CONFIG["EXTDLDFLAGS"] = ""
  CONFIG["EXTLDFLAGS"] = ""
  CONFIG["strict_warnflags"] = ""
  CONFIG["warnflags"] = ""
  CONFIG["debugflags"] = "-g"
  CONFIG["optflags"] = ""
  CONFIG["cxxflags"] = " $(optflags) $(debugflags) $(warnflags)"
  CONFIG["cflags"] = " $(optflags) $(debugflags) $(warnflags)"
  CONFIG["cppflags"] = ""
  CONFIG["NULLCMD"] = ":"
  CONFIG["DLNOBJ"] = "dln.o"
  CONFIG["INSTALLDOC"] = "all"
  CONFIG["CAPITARGET"] = "nodoc"
  CONFIG["RDOCTARGET"] = "rdoc"
  CONFIG["DTRACE_GLOMMED_OBJ"] = ""
  CONFIG["DTRACE_OBJ"] = ""
  CONFIG["DTRACE_EXT"] = "d"
  CONFIG["EXECUTABLE_EXTS"] = ""
  CONFIG["ARCHFILE"] = ""
  CONFIG["LIBRUBY_RELATIVE"] = "no"
  CONFIG["EXTOUT"] = ".ext"
  CONFIG["RUNRUBY_COMMAND"] = "$(MINIRUBY) $(srcdir)/tool/runruby.rb --extout=$(EXTOUT) $(RUNRUBYOPT)"
  CONFIG["PREP"] = "miniruby$(EXEEXT)"
  CONFIG["BTESTRUBY"] = "$(MINIRUBY)"
  CONFIG["CROSS_COMPILING"] = "no"
  CONFIG["TEST_RUNNABLE"] = "yes"
  CONFIG["setup"] = "Setup"
  CONFIG["EXTSTATIC"] = ""
  CONFIG["STRIP"] = "strip -A -n"
  CONFIG["TRY_LINK"] = ""
  CONFIG["LIBPATHENV"] = "DYLD_LIBRARY_PATH"
  CONFIG["RPATHFLAG"] = ""
  CONFIG["LIBPATHFLAG"] = " -L%s"
  CONFIG["LINK_SO"] = "\ntest -z '$(RUBY_CODESIGN)' || codesign -s '$(RUBY_CODESIGN)' -f $@"
  CONFIG["LIBEXT"] = "a"
  CONFIG["DLEXT2"] = ""
  CONFIG["DLEXT"] = "bundle"
  CONFIG["LDSHAREDXX"] = "$(CXX) -dynamic -bundle"
  CONFIG["LDSHARED"] = "$(CC) -dynamic -bundle"
  CONFIG["CCDLFLAGS"] = ""
  CONFIG["STATIC"] = ""
  CONFIG["ARCH_FLAG"] = arch_flag || " -arch i386 -arch x86_64"
  CONFIG["DLDFLAGS"] = "-Wl,-undefined,dynamic_lookup -Wl,-multiply_defined,suppress"
  CONFIG["ALLOCA"] = ""
  CONFIG["codesign"] = "codesign"
  CONFIG["POSTLINK"] = "test -z '$(RUBY_CODESIGN)' || codesign -s '$(RUBY_CODESIGN)' -f $@"
  CONFIG["WERRORFLAG"] = ""
  CONFIG["CHDIR"] = "cd -P"
  CONFIG["RMALL"] = "rm -fr"
  CONFIG["RMDIRS"] = "rmdir -p"
  CONFIG["RMDIR"] = "rmdir"
  CONFIG["CP"] = "cp"
  CONFIG["RM"] = "rm -f"
  CONFIG["PKG_CONFIG"] = ""
  CONFIG["PYTHON"] = ""
  CONFIG["DOXYGEN"] = ""
  CONFIG["DOT"] = ""
  CONFIG["DTRACE"] = "dtrace"
  CONFIG["MAKEDIRS"] = "mkdir -p"
  CONFIG["MKDIR_P"] = "mkdir -p"
  CONFIG["INSTALL_DATA"] = "$(INSTALL) -m 644"
  CONFIG["INSTALL_SCRIPT"] = "$(INSTALL)"
  CONFIG["INSTALL_PROGRAM"] = "$(INSTALL)"
  CONFIG["SET_MAKE"] = ""
  CONFIG["LN_S"] = "ln -s"
  CONFIG["NM"] = "nm"
  CONFIG["DLLWRAP"] = ""
  CONFIG["WINDRES"] = ""
  CONFIG["OBJCOPY"] = ""
  CONFIG["OBJDUMP"] = ""
  CONFIG["ASFLAGS"] = ""
  CONFIG["AS"] = "as"
  CONFIG["AR"] = "ar"
  CONFIG["RANLIB"] = "ranlib"
  CONFIG["try_header"] = "try_compile"
  CONFIG["COUTFLAG"] = "-o "
  CONFIG["OUTFLAG"] = "-o "
  CONFIG["CPPOUTFILE"] = "-o conftest.i"
  CONFIG["GNU_LD"] = "no"
  CONFIG["LD"] = "ld"
  CONFIG["GCC"] = ""
  CONFIG["EGREP"] = "/usr/bin/grep -E"
  CONFIG["GREP"] = "/usr/bin/grep"
  CONFIG["CPP"] = "$(CC) -E"
  CONFIG["CXXFLAGS"] = "$(ARCH_FLAG) -g -Os -pipe "
  CONFIG["CXX"] = "xcrun clang++"
  CONFIG["OBJEXT"] = "o"
  CONFIG["CPPFLAGS"] = "-D_XOPEN_SOURCE -D_DARWIN_C_SOURCE -D_DARWIN_UNLIMITED_SELECT -D_REENTRANT $(DEFS) $(cppflags)"
  CONFIG["LDFLAGS"] = "-L. -L/usr/local/lib"
  CONFIG["CFLAGS"] = " -g -Os -pipe -DHAVE_GCC_SYNC_BUILTINS"
  CONFIG["CC"] = "xcrun clang"
  CONFIG["NACL_SDK_VARIANT"] = ""
  CONFIG["NACL_SDK_ROOT"] = ""
  CONFIG["NACL_TOOLCHAIN"] = ""
  CONFIG["target_os"] = "darwin15"
  CONFIG["target_vendor"] = "apple"
  CONFIG["target_cpu"] = "universal"
  CONFIG["target"] = "universal-apple-darwin15"
  CONFIG["host_os"] = "darwin15"
  CONFIG["host_vendor"] = "apple"
  CONFIG["host_cpu"] = "x86_64"
  CONFIG["host"] = "x86_64-apple-darwin15"
  CONFIG["RUBY_VERSION_NAME"] = "$(RUBY_BASE_NAME)-$(ruby_version)"
  CONFIG["RUBYW_BASE_NAME"] = "rubyw"
  CONFIG["RUBY_BASE_NAME"] = "ruby"
  CONFIG["build_os"] = "darwin15"
  CONFIG["build_vendor"] = "apple"
  CONFIG["build_cpu"] = "x86_64"
  CONFIG["build"] = "x86_64-apple-darwin15"
  CONFIG["RUBY_RELEASE_DATE"] = "2015-04-13"
  CONFIG["RUBY_PROGRAM_VERSION"] = "2.0.0"
  CONFIG["target_alias"] = ""
  CONFIG["host_alias"] = ""
  CONFIG["build_alias"] = ""
  CONFIG["LIBS"] = "-lpthread -ldl -lobjc"
  CONFIG["ECHO_T"] = ""
  CONFIG["ECHO_N"] = ""
  CONFIG["ECHO_C"] = "\\\\c"
  CONFIG["DEFS"] = ""
  CONFIG["mandir"] = "$(DESTDIR)/usr/share/man"
  CONFIG["localedir"] = "$(datarootdir)/locale"
  CONFIG["libdir"] = "$(exec_prefix)/lib"
  CONFIG["psdir"] = "$(docdir)"
  CONFIG["pdfdir"] = "$(docdir)"
  CONFIG["dvidir"] = "$(docdir)"
  CONFIG["htmldir"] = "$(docdir)"
  CONFIG["infodir"] = "$(DESTDIR)/usr/share/info"
  CONFIG["docdir"] = "$(datarootdir)/doc/$(PACKAGE)"
  CONFIG["oldincludedir"] = "/usr/include"
  CONFIG["includedir"] = (ENV['SDKROOT'] || (File.exists?(File.join(CONFIG['prefix'],'include')) ? '' : %x(xcode-select --print-path >/dev/null 2>&1 && xcrun --sdk macosx --show-sdk-path 2>/dev/null).chomp)) + "$(prefix)/include"
  CONFIG["localstatedir"] = "$(prefix)/var"
  CONFIG["sharedstatedir"] = "$(prefix)/com"
  CONFIG["sysconfdir"] = "$(DESTDIR)/Library/Ruby/Site"
  CONFIG["datadir"] = "$(datarootdir)"
  CONFIG["datarootdir"] = "$(prefix)/share"
  CONFIG["libexecdir"] = "$(exec_prefix)/libexec"
  CONFIG["sbindir"] = "$(exec_prefix)/sbin"
  CONFIG["bindir"] = "$(exec_prefix)/bin"
  CONFIG["exec_prefix"] = "$(prefix)"
  CONFIG["PACKAGE_URL"] = ""
  CONFIG["PACKAGE_BUGREPORT"] = ""
  CONFIG["PACKAGE_STRING"] = ""
  CONFIG["PACKAGE_VERSION"] = ""
  CONFIG["PACKAGE_TARNAME"] = ""
  CONFIG["PACKAGE_NAME"] = ""
  CONFIG["PATH_SEPARATOR"] = ":"
  CONFIG["SHELL"] = "/bin/sh"
  CONFIG["archdir"] = "$(rubyarchdir)"
  CONFIG["topdir"] = File.dirname(__FILE__)
  MAKEFILE_CONFIG = {}
  CONFIG.each{|k,v| MAKEFILE_CONFIG[k] = v.dup}
  def RbConfig::expand(val, config = CONFIG)
    newval = val.gsub(/\$\$|\$\(([^()]+)\)|\$\{([^{}]+)\}/) {
      var = $&
      if !(v = $1 || $2)
	'$'
      elsif key = config[v = v[/\A[^:]+(?=(?::(.*?)=(.*))?\z)/]]
	pat, sub = $1, $2
	config[v] = false
	config[v] = RbConfig::expand(key, config)
	key = key.gsub(/#{Regexp.quote(pat)}(?=\s|\z)/n) {sub} if pat
	key
      else
	var
      end
    }
    val.replace(newval) unless newval == val
    val
  end
  CONFIG.each_value do |val|
    RbConfig::expand(val)
  end

  # returns the absolute pathname of the ruby command.
  def RbConfig.ruby
    File.join(
      RbConfig::CONFIG["bindir"],
      RbConfig::CONFIG["ruby_install_name"] + RbConfig::CONFIG["EXEEXT"]
    )
  end
end
autoload :Config, "rbconfig/obsolete.rb" # compatibility for ruby-1.8.4 and older.
CROSS_COMPILING = nil unless defined? CROSS_COMPILING
RUBY_FRAMEWORK = true
RUBY_FRAMEWORK_VERSION = RbConfig::CONFIG['ruby_version']
APPLE_GEM_HOME = File.join(RbConfig::CONFIG['libdir'], 'ruby/gems', RbConfig::CONFIG['ruby_version'])
                                                                                                                                                                                                                                                                                                                                                               uri/                                                                                                0040755 0001750 0001750 00000000000 12612224746 033106  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           common.rb                                                                                           0100644 0001750 0001750 00000071664 12177202445 034734  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       #--
# = uri/common.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# Revision:: $Id: common.rb 42355 2013-08-03 13:27:01Z nagachika $
# License::
#   You can redistribute it and/or modify it under the same term as Ruby.
#
# See URI for general documentation
#

module URI
  #
  # Includes URI::REGEXP::PATTERN
  #
  module REGEXP
    #
    # Patterns used to parse URI's
    #
    module PATTERN
      # :stopdoc:

      # RFC 2396 (URI Generic Syntax)
      # RFC 2732 (IPv6 Literal Addresses in URL's)
      # RFC 2373 (IPv6 Addressing Architecture)

      # alpha         = lowalpha | upalpha
      ALPHA = "a-zA-Z"
      # alphanum      = alpha | digit
      ALNUM = "#{ALPHA}\\d"

      # hex           = digit | "A" | "B" | "C" | "D" | "E" | "F" |
      #                         "a" | "b" | "c" | "d" | "e" | "f"
      HEX     = "a-fA-F\\d"
      # escaped       = "%" hex hex
      ESCAPED = "%[#{HEX}]{2}"
      # mark          = "-" | "_" | "." | "!" | "~" | "*" | "'" |
      #                 "(" | ")"
      # unreserved    = alphanum | mark
      UNRESERVED = "\\-_.!~*'()#{ALNUM}"
      # reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
      #                 "$" | ","
      # reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
      #                 "$" | "," | "[" | "]" (RFC 2732)
      RESERVED = ";/?:@&=+$,\\[\\]"

      # domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
      DOMLABEL = "(?:[#{ALNUM}](?:[-#{ALNUM}]*[#{ALNUM}])?)"
      # toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
      TOPLABEL = "(?:[#{ALPHA}](?:[-#{ALNUM}]*[#{ALNUM}])?)"
      # hostname      = *( domainlabel "." ) toplabel [ "." ]
      HOSTNAME = "(?:#{DOMLABEL}\\.)*#{TOPLABEL}\\.?"

      # :startdoc:
    end # PATTERN

    # :startdoc:
  end # REGEXP

  # class that Parses String's into URI's
  #
  # It contains a Hash set of patterns and Regexp's that match and validate.
  #
  class Parser
    include REGEXP

    #
    # == Synopsis
    #
    #   URI::Parser.new([opts])
    #
    # == Args
    #
    # The constructor accepts a hash as options for parser.
    # Keys of options are pattern names of URI components
    # and values of options are pattern strings.
    # The constructor generetes set of regexps for parsing URIs.
    #
    # You can use the following keys:
    #
    #   * :ESCAPED (URI::PATTERN::ESCAPED in default)
    #   * :UNRESERVED (URI::PATTERN::UNRESERVED in default)
    #   * :DOMLABEL (URI::PATTERN::DOMLABEL in default)
    #   * :TOPLABEL (URI::PATTERN::TOPLABEL in default)
    #   * :HOSTNAME (URI::PATTERN::HOSTNAME in default)
    #
    # == Examples
    #
    #   p = URI::Parser.new(:ESCAPED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")
    #   u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP:0xb78cf4f8 URL:http://example.jp/%uABCD>
    #   URI.parse(u.to_s) #=> raises URI::InvalidURIError
    #
    #   s = "http://examle.com/ABCD"
    #   u1 = p.parse(s) #=> #<URI::HTTP:0xb78c3220 URL:http://example.com/ABCD>
    #   u2 = URI.parse(s) #=> #<URI::HTTP:0xb78b6d54 URL:http://example.com/ABCD>
    #   u1 == u2 #=> true
    #   u1.eql?(u2) #=> false
    #
    def initialize(opts = {})
      @pattern = initialize_pattern(opts)
      @pattern.each_value {|v| v.freeze}
      @pattern.freeze

      @regexp = initialize_regexp(@pattern)
      @regexp.each_value {|v| v.freeze}
      @regexp.freeze
    end

    # The Hash of patterns.
    #
    # see also URI::Parser.initialize_pattern
    attr_reader :pattern

    # The Hash of Regexp
    #
    # see also URI::Parser.initialize_regexp
    attr_reader :regexp

    # Returns a split URI against regexp[:ABS_URI]
    def split(uri)
      case uri
      when ''
        # null uri

      when @regexp[:ABS_URI]
        scheme, opaque, userinfo, host, port,
          registry, path, query, fragment = $~[1..-1]

        # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]

        # absoluteURI   = scheme ":" ( hier_part | opaque_part )
        # hier_part     = ( net_path | abs_path ) [ "?" query ]
        # opaque_part   = uric_no_slash *uric

        # abs_path      = "/"  path_segments
        # net_path      = "//" authority [ abs_path ]

        # authority     = server | reg_name
        # server        = [ [ userinfo "@" ] hostport ]

        if !scheme
          raise InvalidURIError,
            "bad URI(absolute but no scheme): #{uri}"
        end
        if !opaque && (!path && (!host && !registry))
          raise InvalidURIError,
            "bad URI(absolute but no path): #{uri}"
        end

      when @regexp[:REL_URI]
        scheme = nil
        opaque = nil

        userinfo, host, port, registry,
          rel_segment, abs_path, query, fragment = $~[1..-1]
        if rel_segment && abs_path
          path = rel_segment + abs_path
        elsif rel_segment
          path = rel_segment
        elsif abs_path
          path = abs_path
        end

        # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]

        # relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]

        # net_path      = "//" authority [ abs_path ]
        # abs_path      = "/"  path_segments
        # rel_path      = rel_segment [ abs_path ]

        # authority     = server | reg_name
        # server        = [ [ userinfo "@" ] hostport ]

      else
        raise InvalidURIError, "bad URI(is not URI?): #{uri}"
      end

      path = '' if !path && !opaque # (see RFC2396 Section 5.2)
      ret = [
        scheme,
        userinfo, host, port,         # X
        registry,                     # X
        path,                         # Y
        opaque,                       # Y
        query,
        fragment
      ]
      return ret
    end

    #
    # == Args
    #
    # +uri+::
    #    String
    #
    # == Description
    #
    # parses +uri+ and constructs either matching URI scheme object
    # (FTP, HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic
    #
    # == Usage
    #
    #   p = URI::Parser.new
    #   p.parse("ldap://ldap.example.com/dc=example?user=john")
    #   #=> #<URI::LDAP:0x00000000b9e7e8 URL:ldap://ldap.example.com/dc=example?user=john>
    #
    def parse(uri)
      scheme, userinfo, host, port,
        registry, path, opaque, query, fragment = self.split(uri)

      if scheme && URI.scheme_list.include?(scheme.upcase)
        URI.scheme_list[scheme.upcase].new(scheme, userinfo, host, port,
                                           registry, path, opaque, query,
                                           fragment, self)
      else
        Generic.new(scheme, userinfo, host, port,
                    registry, path, opaque, query,
                    fragment, self)
      end
    end


    #
    # == Args
    #
    # +uris+::
    #    an Array of Strings
    #
    # == Description
    #
    # Attempts to parse and merge a set of URIs
    #
    def join(*uris)
      uris[0] = convert_to_uri(uris[0])
      uris.inject :merge
    end

    #
    # :call-seq:
    #   extract( str )
    #   extract( str, schemes )
    #   extract( str, schemes ) {|item| block }
    #
    # == Args
    #
    # +str+::
    #    String to search
    # +schemes+::
    #    Patterns to apply to +str+
    #
    # == Description
    #
    # Attempts to parse and merge a set of URIs
    # If no +block+ given , then returns the result,
    # else it calls +block+ for each element in result.
    #
    # see also URI::Parser.make_regexp
    #
    def extract(str, schemes = nil)
      if block_given?
        str.scan(make_regexp(schemes)) { yield $& }
        nil
      else
        result = []
        str.scan(make_regexp(schemes)) { result.push $& }
        result
      end
    end

    # returns Regexp that is default self.regexp[:ABS_URI_REF],
    # unless +schemes+ is provided. Then it is a Regexp.union with self.pattern[:X_ABS_URI]
    def make_regexp(schemes = nil)
      unless schemes
        @regexp[:ABS_URI_REF]
      else
        /(?=#{Regexp.union(*schemes)}:)#{@pattern[:X_ABS_URI]}/x
      end
    end

    #
    # :call-seq:
    #   escape( str )
    #   escape( str, unsafe )
    #
    # == Args
    #
    # +str+::
    #    String to make safe
    # +unsafe+::
    #    Regexp to apply. Defaults to self.regexp[:UNSAFE]
    #
    # == Description
    #
    # constructs a safe String from +str+, removing unsafe characters,
    # replacing them with codes.
    #
    def escape(str, unsafe = @regexp[:UNSAFE])
      unless unsafe.kind_of?(Regexp)
        # perhaps unsafe is String object
        unsafe = Regexp.new("[#{Regexp.quote(unsafe)}]", false)
      end
      str.gsub(unsafe) do
        us = $&
        tmp = ''
        us.each_byte do |uc|
          tmp << sprintf('%%%02X', uc)
        end
        tmp
      end.force_encoding(Encoding::US_ASCII)
    end

    #
    # :call-seq:
    #   unescape( str )
    #   unescape( str, unsafe )
    #
    # == Args
    #
    # +str+::
    #    String to remove escapes from
    # +unsafe+::
    #    Regexp to apply. Defaults to self.regexp[:ESCAPED]
    #
    # == Description
    #
    # Removes escapes from +str+
    #
    def unescape(str, escaped = @regexp[:ESCAPED])
      str.gsub(escaped) { [$&[1, 2].hex].pack('C') }.force_encoding(str.encoding)
    end

    @@to_s = Kernel.instance_method(:to_s)
    def inspect
      @@to_s.bind(self).call
    end

    private

    # Constructs the default Hash of patterns
    def initialize_pattern(opts = {})
      ret = {}
      ret[:ESCAPED] = escaped = (opts.delete(:ESCAPED) || PATTERN::ESCAPED)
      ret[:UNRESERVED] = unreserved = opts.delete(:UNRESERVED) || PATTERN::UNRESERVED
      ret[:RESERVED] = reserved = opts.delete(:RESERVED) || PATTERN::RESERVED
      ret[:DOMLABEL] = opts.delete(:DOMLABEL) || PATTERN::DOMLABEL
      ret[:TOPLABEL] = opts.delete(:TOPLABEL) || PATTERN::TOPLABEL
      ret[:HOSTNAME] = hostname = opts.delete(:HOSTNAME)

      # RFC 2396 (URI Generic Syntax)
      # RFC 2732 (IPv6 Literal Addresses in URL's)
      # RFC 2373 (IPv6 Addressing Architecture)

      # uric          = reserved | unreserved | escaped
      ret[:URIC] = uric = "(?:[#{unreserved}#{reserved}]|#{escaped})"
      # uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
      #                 "&" | "=" | "+" | "$" | ","
      ret[:URIC_NO_SLASH] = uric_no_slash = "(?:[#{unreserved};?:@&=+$,]|#{escaped})"
      # query         = *uric
      ret[:QUERY] = query = "#{uric}*"
      # fragment      = *uric
      ret[:FRAGMENT] = fragment = "#{uric}*"

      # hostname      = *( domainlabel "." ) toplabel [ "." ]
      # reg-name      = *( unreserved / pct-encoded / sub-delims ) # RFC3986
      unless hostname
        ret[:HOSTNAME] = hostname = "(?:[a-zA-Z0-9\\-.]|%\\h\\h)+"
      end

      # RFC 2373, APPENDIX B:
      # IPv6address = hexpart [ ":" IPv4address ]
      # IPv4address   = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
      # hexpart = hexseq | hexseq "::" [ hexseq ] | "::" [ hexseq ]
      # hexseq  = hex4 *( ":" hex4)
      # hex4    = 1*4HEXDIG
      #
      # XXX: This definition has a flaw. "::" + IPv4address must be
      # allowed too.  Here is a replacement.
      #
      # IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
      ret[:IPV4ADDR] = ipv4addr = "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"
      # hex4     = 1*4HEXDIG
      hex4 = "[#{PATTERN::HEX}]{1,4}"
      # lastpart = hex4 | IPv4address
      lastpart = "(?:#{hex4}|#{ipv4addr})"
      # hexseq1  = *( hex4 ":" ) hex4
      hexseq1 = "(?:#{hex4}:)*#{hex4}"
      # hexseq2  = *( hex4 ":" ) lastpart
      hexseq2 = "(?:#{hex4}:)*#{lastpart}"
      # IPv6address = hexseq2 | [ hexseq1 ] "::" [ hexseq2 ]
      ret[:IPV6ADDR] = ipv6addr = "(?:#{hexseq2}|(?:#{hexseq1})?::(?:#{hexseq2})?)"

      # IPv6prefix  = ( hexseq1 | [ hexseq1 ] "::" [ hexseq1 ] ) "/" 1*2DIGIT
      # unused

      # ipv6reference = "[" IPv6address "]" (RFC 2732)
      ret[:IPV6REF] = ipv6ref = "\\[#{ipv6addr}\\]"

      # host          = hostname | IPv4address
      # host          = hostname | IPv4address | IPv6reference (RFC 2732)
      ret[:HOST] = host = "(?:#{hostname}|#{ipv4addr}|#{ipv6ref})"
      # port          = *digit
      port = '\d*'
      # hostport      = host [ ":" port ]
      ret[:HOSTPORT] = hostport = "#{host}(?::#{port})?"

      # userinfo      = *( unreserved | escaped |
      #                    ";" | ":" | "&" | "=" | "+" | "$" | "," )
      ret[:USERINFO] = userinfo = "(?:[#{unreserved};:&=+$,]|#{escaped})*"

      # pchar         = unreserved | escaped |
      #                 ":" | "@" | "&" | "=" | "+" | "$" | ","
      pchar = "(?:[#{unreserved}:@&=+$,]|#{escaped})"
      # param         = *pchar
      param = "#{pchar}*"
      # segment       = *pchar *( ";" param )
      segment = "#{pchar}*(?:;#{param})*"
      # path_segments = segment *( "/" segment )
      ret[:PATH_SEGMENTS] = path_segments = "#{segment}(?:/#{segment})*"

      # server        = [ [ userinfo "@" ] hostport ]
      server = "(?:#{userinfo}@)?#{hostport}"
      # reg_name      = 1*( unreserved | escaped | "$" | "," |
      #                     ";" | ":" | "@" | "&" | "=" | "+" )
      ret[:REG_NAME] = reg_name = "(?:[#{unreserved}$,;:@&=+]|#{escaped})+"
      # authority     = server | reg_name
      authority = "(?:#{server}|#{reg_name})"

      # rel_segment   = 1*( unreserved | escaped |
      #                     ";" | "@" | "&" | "=" | "+" | "$" | "," )
      ret[:REL_SEGMENT] = rel_segment = "(?:[#{unreserved};@&=+$,]|#{escaped})+"

      # scheme        = alpha *( alpha | digit | "+" | "-" | "." )
      ret[:SCHEME] = scheme = "[#{PATTERN::ALPHA}][\\-+.#{PATTERN::ALPHA}\\d]*"

      # abs_path      = "/"  path_segments
      ret[:ABS_PATH] = abs_path = "/#{path_segments}"
      # rel_path      = rel_segment [ abs_path ]
      ret[:REL_PATH] = rel_path = "#{rel_segment}(?:#{abs_path})?"
      # net_path      = "//" authority [ abs_path ]
      ret[:NET_PATH] = net_path = "//#{authority}(?:#{abs_path})?"

      # hier_part     = ( net_path | abs_path ) [ "?" query ]
      ret[:HIER_PART] = hier_part = "(?:#{net_path}|#{abs_path})(?:\\?(?:#{query}))?"
      # opaque_part   = uric_no_slash *uric
      ret[:OPAQUE_PART] = opaque_part = "#{uric_no_slash}#{uric}*"

      # absoluteURI   = scheme ":" ( hier_part | opaque_part )
      ret[:ABS_URI] = abs_uri = "#{scheme}:(?:#{hier_part}|#{opaque_part})"
      # relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]
      ret[:REL_URI] = rel_uri = "(?:#{net_path}|#{abs_path}|#{rel_path})(?:\\?#{query})?"

      # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
      ret[:URI_REF] = "(?:#{abs_uri}|#{rel_uri})?(?:##{fragment})?"

      ret[:X_ABS_URI] = "
        (#{scheme}):                           (?# 1: scheme)
        (?:
           (#{opaque_part})                    (?# 2: opaque)
        |
           (?:(?:
             //(?:
                 (?:(?:(#{userinfo})@)?        (?# 3: userinfo)
                   (?:(#{host})(?::(\\d*))?))? (?# 4: host, 5: port)
               |
                 (#{reg_name})                 (?# 6: registry)
               )
             |
             (?!//))                           (?# XXX: '//' is the mark for hostport)
             (#{abs_path})?                    (?# 7: path)
           )(?:\\?(#{query}))?                 (?# 8: query)
        )
        (?:\\#(#{fragment}))?                  (?# 9: fragment)
      "

      ret[:X_REL_URI] = "
        (?:
          (?:
            //
            (?:
              (?:(#{userinfo})@)?       (?# 1: userinfo)
                (#{host})?(?::(\\d*))?  (?# 2: host, 3: port)
            |
              (#{reg_name})             (?# 4: registry)
            )
          )
        |
          (#{rel_segment})              (?# 5: rel_segment)
        )?
        (#{abs_path})?                  (?# 6: abs_path)
        (?:\\?(#{query}))?              (?# 7: query)
        (?:\\#(#{fragment}))?           (?# 8: fragment)
      "

      ret
    end

    # Constructs the default Hash of Regexp's
    def initialize_regexp(pattern)
      ret = {}

      # for URI::split
      ret[:ABS_URI] = Regexp.new('\A\s*' + pattern[:X_ABS_URI] + '\s*\z', Regexp::EXTENDED)
      ret[:REL_URI] = Regexp.new('\A\s*' + pattern[:X_REL_URI] + '\s*\z', Regexp::EXTENDED)

      # for URI::extract
      ret[:URI_REF]     = Regexp.new(pattern[:URI_REF])
      ret[:ABS_URI_REF] = Regexp.new(pattern[:X_ABS_URI], Regexp::EXTENDED)
      ret[:REL_URI_REF] = Regexp.new(pattern[:X_REL_URI], Regexp::EXTENDED)

      # for URI::escape/unescape
      ret[:ESCAPED] = Regexp.new(pattern[:ESCAPED])
      ret[:UNSAFE]  = Regexp.new("[^#{pattern[:UNRESERVED]}#{pattern[:RESERVED]}]")

      # for Generic#initialize
      ret[:SCHEME]   = Regexp.new("\\A#{pattern[:SCHEME]}\\z")
      ret[:USERINFO] = Regexp.new("\\A#{pattern[:USERINFO]}\\z")
      ret[:HOST]     = Regexp.new("\\A#{pattern[:HOST]}\\z")
      ret[:PORT]     = Regexp.new("\\A#{pattern[:PORT]}\\z")
      ret[:OPAQUE]   = Regexp.new("\\A#{pattern[:OPAQUE_PART]}\\z")
      ret[:REGISTRY] = Regexp.new("\\A#{pattern[:REG_NAME]}\\z")
      ret[:ABS_PATH] = Regexp.new("\\A#{pattern[:ABS_PATH]}\\z")
      ret[:REL_PATH] = Regexp.new("\\A#{pattern[:REL_PATH]}\\z")
      ret[:QUERY]    = Regexp.new("\\A#{pattern[:QUERY]}\\z")
      ret[:FRAGMENT] = Regexp.new("\\A#{pattern[:FRAGMENT]}\\z")

      ret
    end

    def convert_to_uri(uri)
      if uri.is_a?(URI::Generic)
        uri
      elsif uri = String.try_convert(uri)
        parse(uri)
      else
        raise ArgumentError,
          "bad argument (expected URI object or URI string)"
      end
    end

  end # class Parser

  # URI::Parser.new
  DEFAULT_PARSER = Parser.new
  DEFAULT_PARSER.pattern.each_pair do |sym, str|
    unless REGEXP::PATTERN.const_defined?(sym)
      REGEXP::PATTERN.const_set(sym, str)
    end
  end
  DEFAULT_PARSER.regexp.each_pair do |sym, str|
    const_set(sym, str)
  end

  module Util # :nodoc:
    def make_components_hash(klass, array_hash)
      tmp = {}
      if array_hash.kind_of?(Array) &&
          array_hash.size == klass.component.size - 1
        klass.component[1..-1].each_index do |i|
          begin
            tmp[klass.component[i + 1]] = array_hash[i].clone
          rescue TypeError
            tmp[klass.component[i + 1]] = array_hash[i]
          end
        end

      elsif array_hash.kind_of?(Hash)
        array_hash.each do |key, value|
          begin
            tmp[key] = value.clone
          rescue TypeError
            tmp[key] = value
          end
        end
      else
        raise ArgumentError,
          "expected Array of or Hash of components of #{klass.to_s} (#{klass.component[1..-1].join(', ')})"
      end
      tmp[:scheme] = klass.to_s.sub(/\A.*::/, '').downcase

      return tmp
    end
    module_function :make_components_hash
  end

  # module for escaping unsafe characters with codes.
  module Escape
    #
    # == Synopsis
    #
    #   URI.escape(str [, unsafe])
    #
    # == Args
    #
    # +str+::
    #   String to replaces in.
    # +unsafe+::
    #   Regexp that matches all symbols that must be replaced with codes.
    #   By default uses <tt>REGEXP::UNSAFE</tt>.
    #   When this argument is a String, it represents a character set.
    #
    # == Description
    #
    # Escapes the string, replacing all unsafe characters with codes.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   enc_uri = URI.escape("http://example.com/?a=\11\15")
    #   p enc_uri
    #   # => "http://example.com/?a=%09%0D"
    #
    #   p URI.unescape(enc_uri)
    #   # => "http://example.com/?a=\t\r"
    #
    #   p URI.escape("@?@!", "!?")
    #   # => "@%3F@%21"
    #
    def escape(*arg)
      warn "#{caller(1)[0]}: warning: URI.escape is obsolete" if $VERBOSE
      DEFAULT_PARSER.escape(*arg)
    end
    alias encode escape
    #
    # == Synopsis
    #
    #   URI.unescape(str)
    #
    # == Args
    #
    # +str+::
    #   Unescapes the string.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   enc_uri = URI.escape("http://example.com/?a=\11\15")
    #   p enc_uri
    #   # => "http://example.com/?a=%09%0D"
    #
    #   p URI.unescape(enc_uri)
    #   # => "http://example.com/?a=\t\r"
    #
    def unescape(*arg)
      warn "#{caller(1)[0]}: warning: URI.unescape is obsolete" if $VERBOSE
      DEFAULT_PARSER.unescape(*arg)
    end
    alias decode unescape
  end # module Escape

  extend Escape
  include REGEXP

  @@schemes = {}
  # Returns a Hash of the defined schemes
  def self.scheme_list
    @@schemes
  end

  #
  # Base class for all URI exceptions.
  #
  class Error < StandardError; end
  #
  # Not a URI.
  #
  class InvalidURIError < Error; end
  #
  # Not a URI component.
  #
  class InvalidComponentError < Error; end
  #
  # URI is valid, bad usage is not.
  #
  class BadURIError < Error; end

  #
  # == Synopsis
  #
  #   URI::split(uri)
  #
  # == Args
  #
  # +uri+::
  #   String with URI.
  #
  # == Description
  #
  # Splits the string on following parts and returns array with result:
  #
  #   * Scheme
  #   * Userinfo
  #   * Host
  #   * Port
  #   * Registry
  #   * Path
  #   * Opaque
  #   * Query
  #   * Fragment
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   p URI.split("http://www.ruby-lang.org/")
  #   # => ["http", nil, "www.ruby-lang.org", nil, nil, "/", nil, nil, nil]
  #
  def self.split(uri)
    DEFAULT_PARSER.split(uri)
  end

  #
  # == Synopsis
  #
  #   URI::parse(uri_str)
  #
  # == Args
  #
  # +uri_str+::
  #   String with URI.
  #
  # == Description
  #
  # Creates one of the URI's subclasses instance from the string.
  #
  # == Raises
  #
  # URI::InvalidURIError
  #   Raised if URI given is not a correct one.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://www.ruby-lang.org/")
  #   p uri
  #   # => #<URI::HTTP:0x202281be URL:http://www.ruby-lang.org/>
  #   p uri.scheme
  #   # => "http"
  #   p uri.host
  #   # => "www.ruby-lang.org"
  #
  def self.parse(uri)
    DEFAULT_PARSER.parse(uri)
  end

  #
  # == Synopsis
  #
  #   URI::join(str[, str, ...])
  #
  # == Args
  #
  # +str+::
  #   String(s) to work with
  #
  # == Description
  #
  # Joins URIs.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   p URI.join("http://example.com/","main.rbx")
  #   # => #<URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx>
  #
  #   p URI.join('http://example.com', 'foo')
  #   # => #<URI::HTTP:0x01ab80a0 URL:http://example.com/foo>
  #
  #   p URI.join('http://example.com', '/foo', '/bar')
  #   # => #<URI::HTTP:0x01aaf0b0 URL:http://example.com/bar>
  #
  #   p URI.join('http://example.com', '/foo', 'bar')
  #   # => #<URI::HTTP:0x801a92af0 URL:http://example.com/bar>
  #
  #   p URI.join('http://example.com', '/foo/', 'bar')
  #   # => #<URI::HTTP:0x80135a3a0 URL:http://example.com/foo/bar>
  #
  #
  def self.join(*str)
    DEFAULT_PARSER.join(*str)
  end

  #
  # == Synopsis
  #
  #   URI::extract(str[, schemes][,&blk])
  #
  # == Args
  #
  # +str+::
  #   String to extract URIs from.
  # +schemes+::
  #   Limit URI matching to a specific schemes.
  #
  # == Description
  #
  # Extracts URIs from a string. If block given, iterates through all matched URIs.
  # Returns nil if block given or array with matches.
  #
  # == Usage
  #
  #   require "uri"
  #
  #   URI.extract("text here http://foo.example.org/bla and here mailto:test@example.com and here also.")
  #   # => ["http://foo.example.com/bla", "mailto:test@example.com"]
  #
  def self.extract(str, schemes = nil, &block)
    DEFAULT_PARSER.extract(str, schemes, &block)
  end

  #
  # == Synopsis
  #
  #   URI::regexp([match_schemes])
  #
  # == Args
  #
  # +match_schemes+::
  #   Array of schemes. If given, resulting regexp matches to URIs
  #   whose scheme is one of the match_schemes.
  #
  # == Description
  # Returns a Regexp object which matches to URI-like strings.
  # The Regexp object returned by this method includes arbitrary
  # number of capture group (parentheses).  Never rely on it's number.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   # extract first URI from html_string
  #   html_string.slice(URI.regexp)
  #
  #   # remove ftp URIs
  #   html_string.sub(URI.regexp(['ftp'])
  #
  #   # You should not rely on the number of parentheses
  #   html_string.scan(URI.regexp) do |*matches|
  #     p $&
  #   end
  #
  def self.regexp(schemes = nil)
    DEFAULT_PARSER.make_regexp(schemes)
  end

  TBLENCWWWCOMP_ = {} # :nodoc:
  256.times do |i|
    TBLENCWWWCOMP_[i.chr] = '%%%02X' % i
  end
  TBLENCWWWCOMP_[' '] = '+'
  TBLENCWWWCOMP_.freeze
  TBLDECWWWCOMP_ = {} # :nodoc:
  256.times do |i|
    h, l = i>>4, i&15
    TBLDECWWWCOMP_['%%%X%X' % [h, l]] = i.chr
    TBLDECWWWCOMP_['%%%x%X' % [h, l]] = i.chr
    TBLDECWWWCOMP_['%%%X%x' % [h, l]] = i.chr
    TBLDECWWWCOMP_['%%%x%x' % [h, l]] = i.chr
  end
  TBLDECWWWCOMP_['+'] = ' '
  TBLDECWWWCOMP_.freeze

  HTML5ASCIIINCOMPAT = [Encoding::UTF_7, Encoding::UTF_16BE, Encoding::UTF_16LE,
    Encoding::UTF_32BE, Encoding::UTF_32LE] # :nodoc:

  # Encode given +str+ to URL-encoded form data.
  #
  # This method doesn't convert *, -, ., 0-9, A-Z, _, a-z, but does convert SP
  # (ASCII space) to + and converts others to %XX.
  #
  # This is an implementation of
  # http://www.w3.org/TR/html5/association-of-controls-and-forms.html#url-encoded-form-data
  #
  # See URI.decode_www_form_component, URI.encode_www_form
  def self.encode_www_form_component(str)
    str = str.to_s
    if HTML5ASCIIINCOMPAT.include?(str.encoding)
      str = str.encode(Encoding::UTF_8)
    else
      str = str.dup
    end
    str.force_encoding(Encoding::ASCII_8BIT)
    str.gsub!(/[^*\-.0-9A-Z_a-z]/, TBLENCWWWCOMP_)
    str.force_encoding(Encoding::US_ASCII)
  end

  # Decode given +str+ of URL-encoded form data.
  #
  # This decodes + to SP.
  #
  # See URI.encode_www_form_component, URI.decode_www_form
  def self.decode_www_form_component(str, enc=Encoding::UTF_8)
    raise ArgumentError, "invalid %-encoding (#{str})" unless /\A[^%]*(?:%\h\h[^%]*)*\z/ =~ str
    str.dup.force_encoding("ASCII-8BIT") \
       .gsub(/\+|%\h\h/, TBLDECWWWCOMP_) \
       .force_encoding(enc)
  end

  # Generate URL-encoded form data from given +enum+.
  #
  # This generates application/x-www-form-urlencoded data defined in HTML5
  # from given an Enumerable object.
  #
  # This internally uses URI.encode_www_form_component(str).
  #
  # This method doesn't convert the encoding of given items, so convert them
  # before call this method if you want to send data as other than original
  # encoding or mixed encoding data. (Strings which are encoded in an HTML5
  # ASCII incompatible encoding are converted to UTF-8.)
  #
  # This method doesn't handle files.  When you send a file, use
  # multipart/form-data.
  #
  # This is an implementation of
  # http://www.w3.org/TR/html5/forms.html#url-encoded-form-data
  #
  #    URI.encode_www_form([["q", "ruby"], ["lang", "en"]])
  #    #=> "q=ruby&lang=en"
  #    URI.encode_www_form("q" => "ruby", "lang" => "en")
  #    #=> "q=ruby&lang=en"
  #    URI.encode_www_form("q" => ["ruby", "perl"], "lang" => "en")
  #    #=> "q=ruby&q=perl&lang=en"
  #    URI.encode_www_form([["q", "ruby"], ["q", "perl"], ["lang", "en"]])
  #    #=> "q=ruby&q=perl&lang=en"
  #
  # See URI.encode_www_form_component, URI.decode_www_form
  def self.encode_www_form(enum)
    enum.map do |k,v|
      if v.nil?
        encode_www_form_component(k)
      elsif v.respond_to?(:to_ary)
        v.to_ary.map do |w|
          str = encode_www_form_component(k)
          unless w.nil?
            str << '='
            str << encode_www_form_component(w)
          end
        end.join('&')
      else
        str = encode_www_form_component(k)
        str << '='
        str << encode_www_form_component(v)
      end
    end.join('&')
  end

  WFKV_ = '(?:[^%#=;&]*(?:%\h\h[^%#=;&]*)*)' # :nodoc:

  # Decode URL-encoded form data from given +str+.
  #
  # This decodes application/x-www-form-urlencoded data
  # and returns array of key-value array.
  # This internally uses URI.decode_www_form_component.
  #
  # _charset_ hack is not supported now because the mapping from given charset
  # to Ruby's encoding is not clear yet.
  # see also http://www.w3.org/TR/html5/syntax.html#character-encodings-0
  #
  # This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data
  #
  # ary = URI.decode_www_form("a=1&a=2&b=3")
  # p ary                  #=> [['a', '1'], ['a', '2'], ['b', '3']]
  # p ary.assoc('a').last  #=> '1'
  # p ary.assoc('b').last  #=> '3'
  # p ary.rassoc('a').last #=> '2'
  # p Hash[ary]            # => {"a"=>"2", "b"=>"3"}
  #
  # See URI.decode_www_form_component, URI.encode_www_form
  def self.decode_www_form(str, enc=Encoding::UTF_8)
    return [] if str.empty?
    unless /\A#{WFKV_}=#{WFKV_}(?:[;&]#{WFKV_}=#{WFKV_})*\z/o =~ str
      raise ArgumentError, "invalid data of application/x-www-form-urlencoded (#{str})"
    end
    ary = []
    $&.scan(/([^=;&]+)=([^;&]*)/) do
      ary << [decode_www_form_component($1, enc), decode_www_form_component($2, enc)]
    end
    ary
  end
end # module URI

module Kernel

  #
  # Returns +uri+ converted to a URI object.
  #
  def URI(uri)
    if uri.is_a?(URI::Generic)
      uri
    elsif uri = String.try_convert(uri)
      URI.parse(uri)
    else
      raise ArgumentError,
        "bad argument (expected URI object or URI string)"
    end
  end
  module_function :URI
end
                                                                            ftp.rb                                                                                              0100644 0001750 0001750 00000015246 12103104254 034213  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/ftp.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# License:: You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: ftp.rb 39014 2013-02-02 03:31:56Z zzak $
#
# See URI for general documentation
#

require 'uri/generic'

module URI

  #
  # FTP URI syntax is defined by RFC1738 section 3.2.
  #
  # This class will be redesigned because of difference of implementations;
  # the structure of its path. draft-hoffman-ftp-uri-04 is a draft but it
  # is a good summary about the de facto spec.
  # http://tools.ietf.org/html/draft-hoffman-ftp-uri-04
  #
  class FTP < Generic
    # A Default port of 21 for URI::FTP
    DEFAULT_PORT = 21

    #
    # An Array of the available components for URI::FTP
    #
    COMPONENT = [
      :scheme,
      :userinfo, :host, :port,
      :path, :typecode
    ].freeze

    #
    # Typecode is "a", "i" or "d".
    #
    # * "a" indicates a text file (the FTP command was ASCII)
    # * "i" indicates a binary file (FTP command IMAGE)
    # * "d" indicates the contents of a directory should be displayed
    #
    TYPECODE = ['a', 'i', 'd'].freeze

    # Typecode prefix
    #  ';type='
    TYPECODE_PREFIX = ';type='.freeze

    def self.new2(user, password, host, port, path,
                  typecode = nil, arg_check = true) # :nodoc:
      # Do not use this method!  Not tested.  [Bug #7301]
      # This methods remains just for compatibility,
      # Keep it undocumented until the active maintainer is assigned.
      typecode = nil if typecode.size == 0
      if typecode && !TYPECODE.include?(typecode)
        raise ArgumentError,
          "bad typecode is specified: #{typecode}"
      end

      # do escape

      self.new('ftp',
               [user, password],
               host, port, nil,
               typecode ? path + TYPECODE_PREFIX + typecode : path,
               nil, nil, nil, arg_check)
    end

    #
    # == Description
    #
    # Creates a new URI::FTP object from components, with syntax checking.
    #
    # The components accepted are +userinfo+, +host+, +port+, +path+ and
    # +typecode+.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order
    # [userinfo, host, port, path, typecode]
    #
    # If the path supplied is absolute, it will be escaped in order to
    # make it absolute in the URI. Examples:
    #
    #     require 'uri'
    #
    #     uri = URI::FTP.build(['user:password', 'ftp.example.com', nil,
    #       '/path/file.> zip', 'i'])
    #     puts uri.to_s  ->  ftp://user:password@ftp.example.com/%2Fpath/file.zip;type=a
    #
    #     uri2 = URI::FTP.build({:host => 'ftp.example.com',
    #       :path => 'ruby/src'})
    #     puts uri2.to_s  ->  ftp://ftp.example.com/ruby/src
    #
    def self.build(args)

      # Fix the incoming path to be generic URL syntax
      # FTP path  ->  URL path
      # foo/bar       /foo/bar
      # /foo/bar      /%2Ffoo/bar
      #
      if args.kind_of?(Array)
        args[3] = '/' + args[3].sub(/^\//, '%2F')
      else
        args[:path] = '/' + args[:path].sub(/^\//, '%2F')
      end

      tmp = Util::make_components_hash(self, args)

      if tmp[:typecode]
        if tmp[:typecode].size == 1
          tmp[:typecode] = TYPECODE_PREFIX + tmp[:typecode]
        end
        tmp[:path] << tmp[:typecode]
      end

      return super(tmp)
    end

    #
    # == Description
    #
    # Creates a new URI::FTP object from generic URL components with no
    # syntax checking.
    #
    # Unlike build(), this method does not escape the path component as
    # required by RFC1738; instead it is treated as per RFC2396.
    #
    # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,
    # +opaque+, +query+ and +fragment+, in that order.
    #
    def initialize(*arg)
      raise InvalidURIError unless arg[5]
      arg[5] = arg[5].sub(/^\//,'').sub(/^%2F/,'/')
      super(*arg)
      @typecode = nil
      tmp = @path.index(TYPECODE_PREFIX)
      if tmp
        typecode = @path[tmp + TYPECODE_PREFIX.size..-1]
        @path = @path[0..tmp - 1]

        if arg[-1]
          self.typecode = typecode
        else
          self.set_typecode(typecode)
        end
      end
    end

    # typecode accessor
    #
    # see URI::FTP::COMPONENT
    attr_reader :typecode

    # validates typecode +v+,
    # returns a +true+ or +false+ boolean
    #
    def check_typecode(v)
      if TYPECODE.include?(v)
        return true
      else
        raise InvalidComponentError,
          "bad typecode(expected #{TYPECODE.join(', ')}): #{v}"
      end
    end
    private :check_typecode

    # private setter for the typecode +v+
    #
    # see also URI::FTP.typecode=
    #
    def set_typecode(v)
      @typecode = v
    end
    protected :set_typecode

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the typecode +v+.
    # (with validation)
    #
    # see also URI::FTP.check_typecode
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("ftp://john@ftp.example.com/my_file.img")
    #   #=> #<URI::FTP:0x00000000923650 URL:ftp://john@ftp.example.com/my_file.img>
    #   uri.typecode = "i"
    #   # =>  "i"
    #   uri
    #   #=> #<URI::FTP:0x00000000923650 URL:ftp://john@ftp.example.com/my_file.img;type=i>
    #
    def typecode=(typecode)
      check_typecode(typecode)
      set_typecode(typecode)
      typecode
    end

    def merge(oth) # :nodoc:
      tmp = super(oth)
      if self != tmp
        tmp.set_typecode(oth.typecode)
      end

      return tmp
    end

    # Returns the path from an FTP URI.
    #
    # RFC 1738 specifically states that the path for an FTP URI does not
    # include the / which separates the URI path from the URI host. Example:
    #
    #     ftp://ftp.example.com/pub/ruby
    #
    # The above URI indicates that the client should connect to
    # ftp.example.com then cd pub/ruby from the initial login directory.
    #
    # If you want to cd to an absolute directory, you must include an
    # escaped / (%2F) in the path. Example:
    #
    #     ftp://ftp.example.com/%2Fpub/ruby
    #
    # This method will then return "/pub/ruby"
    #
    def path
      return @path.sub(/^\//,'').sub(/^%2F/,'/')
    end

    def set_path(v)
      super("/" + v.sub(/^\//, "%2F"))
    end
    protected :set_path

    def to_s
      save_path = nil
      if @typecode
        save_path = @path
        @path = @path + TYPECODE_PREFIX + @typecode
      end
      str = super
      if @typecode
        @path = save_path
      end

      return str
    end
  end
  @@schemes['FTP'] = FTP
end
                                                                                                                                                                                                                                                                                                                                                          generic.rb                                                                                          0100644 0001750 0001750 00000114260 12471753040 035045  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/generic.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# License:: You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: generic.rb 49669 2015-02-21 00:49:36Z usa $
#
# See URI for general documentation
#

require 'uri/common'

module URI

  #
  # Base class for all URI classes.
  # Implements generic URI syntax as per RFC 2396.
  #
  class Generic
    include URI

    #
    # A Default port of nil for URI::Generic
    #
    DEFAULT_PORT = nil

    #
    # Returns default port
    #
    def self.default_port
      self::DEFAULT_PORT
    end

    #
    # Returns default port
    #
    def default_port
      self.class.default_port
    end

    #
    # An Array of the available components for URI::Generic
    #
    COMPONENT = [
      :scheme,
      :userinfo, :host, :port, :registry,
      :path, :opaque,
      :query,
      :fragment
    ].freeze

    #
    # Components of the URI in the order.
    #
    def self.component
      self::COMPONENT
    end

    #
    # Default to not use the registry for a URI::Generic
    #
    USE_REGISTRY = false

    #
    # Returns whether a registry of naming
    # authorities are being used.
    #
    def self.use_registry
      self::USE_REGISTRY
    end

    #
    # == Synopsis
    #
    # See #new
    #
    # == Description
    #
    # At first, tries to create a new URI::Generic instance using
    # URI::Generic::build. But, if exception URI::InvalidComponentError is raised,
    # then it URI::Escape.escape all URI components and tries again.
    #
    #
    def self.build2(args)
      begin
        return self.build(args)
      rescue InvalidComponentError
        if args.kind_of?(Array)
          return self.build(args.collect{|x|
            if x.is_a?(String)
              DEFAULT_PARSER.escape(x)
            else
              x
            end
          })
        elsif args.kind_of?(Hash)
          tmp = {}
          args.each do |key, value|
            tmp[key] = if value
                DEFAULT_PARSER.escape(value)
              else
                value
              end
          end
          return self.build(tmp)
        end
      end
    end

    #
    # == Synopsis
    #
    # See #new
    #
    # == Description
    #
    # Creates a new URI::Generic instance from components of URI::Generic
    # with check.  Components are: scheme, userinfo, host, port, registry, path,
    # opaque, query and fragment. You can provide arguments either by an Array or a Hash.
    # See #new for hash keys to use or for order of array items.
    #
    def self.build(args)
      if args.kind_of?(Array) &&
          args.size == ::URI::Generic::COMPONENT.size
        tmp = args.dup
      elsif args.kind_of?(Hash)
        tmp = ::URI::Generic::COMPONENT.collect do |c|
          if args.include?(c)
            args[c]
          else
            nil
          end
        end
      else
        component = self.class.component rescue ::URI::Generic::COMPONENT
        raise ArgumentError,
        "expected Array of or Hash of components of #{self.class} (#{component.join(', ')})"
      end

      tmp << nil
      tmp << true
      return self.new(*tmp)
    end
    #
    # == Args
    #
    # +scheme+::
    #   Protocol scheme, i.e. 'http','ftp','mailto' and so on.
    # +userinfo+::
    #   User name and password, i.e. 'sdmitry:bla'
    # +host+::
    #   Server host name
    # +port+::
    #   Server port
    # +registry+::
    #   Registry of naming authorities.
    # +path+::
    #   Path on server
    # +opaque+::
    #   Opaque part
    # +query+::
    #   Query data
    # +fragment+::
    #   A part of URI after '#' sign
    # +parser+::
    #   Parser for internal use [URI::DEFAULT_PARSER by default]
    # +arg_check+::
    #   Check arguments [false by default]
    #
    # == Description
    #
    # Creates a new URI::Generic instance from ``generic'' components without check.
    #
    def initialize(scheme,
                   userinfo, host, port, registry,
                   path, opaque,
                   query,
                   fragment,
                   parser = DEFAULT_PARSER,
                   arg_check = false)
      @scheme = nil
      @user = nil
      @password = nil
      @host = nil
      @port = nil
      @path = nil
      @query = nil
      @opaque = nil
      @registry = nil
      @fragment = nil
      @parser = parser == DEFAULT_PARSER ? nil : parser

      if arg_check
        self.scheme = scheme
        self.userinfo = userinfo
        self.hostname = host
        self.port = port
        self.path = path
        self.query = query
        self.opaque = opaque
        self.registry = registry
        self.fragment = fragment
      else
        self.set_scheme(scheme)
        self.set_userinfo(userinfo)
        self.set_host(host)
        self.set_port(port)
        self.set_path(path)
        self.set_query(query)
        self.set_opaque(opaque)
        self.set_registry(registry)
        self.set_fragment(fragment)
      end
      if @registry && !self.class.use_registry
        raise InvalidURIError,
          "the scheme #{@scheme} does not accept registry part: #{@registry} (or bad hostname?)"
      end

      @scheme.freeze if @scheme
      self.set_path('') if !@path && !@opaque # (see RFC2396 Section 5.2)
      self.set_port(self.default_port) if self.default_port && !@port
    end

    #
    # returns the scheme component of the URI.
    #
    #   URI("http://foo/bar/baz").scheme #=> "http"
    #
    attr_reader :scheme

    # returns the host component of the URI.
    #
    #   URI("http://foo/bar/baz").host #=> "foo"
    #
    # It returns nil if no host component.
    #
    #   URI("mailto:foo@example.org").host #=> nil
    #
    # The component doesn't contains the port number.
    #
    #   URI("http://foo:8080/bar/baz").host #=> "foo"
    #
    # Since IPv6 addresses are wrapped by brackets in URIs,
    # this method returns IPv6 addresses wrapped by brackets.
    # This form is not appropriate to pass socket methods such as TCPSocket.open.
    # If unwrapped host names are required, use "hostname" method.
    #
    #   URI("http://[::1]/bar/baz").host #=> "[::1]"
    #   URI("http://[::1]/bar/baz").hostname #=> "::1"
    #
    attr_reader :host

    # returns the port component of the URI.
    #
    #   URI("http://foo/bar/baz").port #=> "80"
    #
    #   URI("http://foo:8080/bar/baz").port #=> "8080"
    #
    attr_reader :port

    # returns the registry component of the URI.
    #
    #  (see RFC2396 Section 3.2)
    #
    attr_reader :registry

    # returns the path component of the URI.
    #
    #   URI("http://foo/bar/baz").path #=> "/bar/baz"
    #
    attr_reader :path

    # returns the query component of the URI.
    #
    #   URI("http://foo/bar/baz?search=FooBar").query #=> "search=FooBar"
    #
    attr_reader :query

    # returns the opaque part of the URI.
    #
    #   URI("mailto:foo@example.org").opaque #=> "foo@example.org"
    #
    # Portion of the path that does make use of the slash '/'.
    # The path typically refers to the absolute path and the opaque part.
    #  (see RFC2396 Section 3 and 5.2)
    #
    attr_reader :opaque

    # returns the fragment component of the URI.
    #
    #   URI("http://foo/bar/baz?search=FooBar#ponies").fragment #=> "ponies"
    #
    attr_reader :fragment

    # returns the parser to be used.
    #
    # Unless a URI::Parser is defined, then DEFAULT_PARSER is used.
    #
    def parser
      if !defined?(@parser) || !@parser
        DEFAULT_PARSER
      else
        @parser || DEFAULT_PARSER
      end
    end

    # replace self by other URI object
    def replace!(oth)
      if self.class != oth.class
        raise ArgumentError, "expected #{self.class} object"
      end

      component.each do |c|
        self.__send__("#{c}=", oth.__send__(c))
      end
    end
    private :replace!

    #
    # Components of the URI in the order.
    #
    def component
      self.class.component
    end

    #
    # check the scheme +v+ component against the URI::Parser Regexp for :SCHEME
    #
    def check_scheme(v)
      if v && parser.regexp[:SCHEME] !~ v
        raise InvalidComponentError,
          "bad component(expected scheme component): #{v}"
      end

      return true
    end
    private :check_scheme

    # protected setter for the scheme component +v+
    #
    # see also URI::Generic.scheme=
    #
    def set_scheme(v)
      @scheme = v ? v.downcase : v
    end
    protected :set_scheme

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the scheme component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_scheme
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com")
    #   uri.scheme = "https"
    #   # =>  "https"
    #   uri
    #   #=> #<URI::HTTP:0x000000008e89e8 URL:https://my.example.com>
    #
    def scheme=(v)
      check_scheme(v)
      set_scheme(v)
      v
    end

    #
    # check the +user+ and +password+.
    #
    # If +password+ is not provided, then +user+ is
    # split, using URI::Generic.split_userinfo, to
    # pull +user+ and +password.
    #
    # see also URI::Generic.check_user, URI::Generic.check_password
    #
    def check_userinfo(user, password = nil)
      if !password
        user, password = split_userinfo(user)
      end
      check_user(user)
      check_password(password, user)

      return true
    end
    private :check_userinfo

    #
    # check the user +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp for :USERINFO
    #
    # Can not have a registry or opaque component defined,
    # with a user component defined.
    #
    def check_user(v)
      if @registry || @opaque
        raise InvalidURIError,
          "can not set user with registry or opaque"
      end

      return v unless v

      if parser.regexp[:USERINFO] !~ v
        raise InvalidComponentError,
          "bad component(expected userinfo component or user component): #{v}"
      end

      return true
    end
    private :check_user

    #
    # check the password +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp for :USERINFO
    #
    # Can not have a registry or opaque component defined,
    # with a user component defined.
    #
    def check_password(v, user = @user)
      if @registry || @opaque
        raise InvalidURIError,
          "can not set password with registry or opaque"
      end
      return v unless v

      if !user
        raise InvalidURIError,
          "password component depends user component"
      end

      if parser.regexp[:USERINFO] !~ v
        raise InvalidComponentError,
          "bad component(expected user component): #{v}"
      end

      return true
    end
    private :check_password

    #
    # Sets userinfo, argument is string like 'name:pass'
    #
    def userinfo=(userinfo)
      if userinfo.nil?
        return nil
      end
      check_userinfo(*userinfo)
      set_userinfo(*userinfo)
      # returns userinfo
    end

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the +user+ component.
    # (with validation)
    #
    # see also URI::Generic.check_user
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    #   uri.user = "sam"
    #   # =>  "sam"
    #   uri
    #   #=> #<URI::HTTP:0x00000000881d90 URL:http://sam:V3ry_S3nsit1ve@my.example.com>
    #
    def user=(user)
      check_user(user)
      set_user(user)
      # returns user
    end

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the +password+ component.
    # (with validation)
    #
    # see also URI::Generic.check_password
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    #   uri.password = "V3ry_S3nsit1ve"
    #   # =>  "V3ry_S3nsit1ve"
    #   uri
    #   #=> #<URI::HTTP:0x00000000881d90 URL:http://john:V3ry_S3nsit1ve@my.example.com>
    #
    def password=(password)
      check_password(password)
      set_password(password)
      # returns password
    end

    # protect setter for the +user+ component, and +password+ if available.
    # (with validation)
    #
    # see also URI::Generic.userinfo=
    #
    def set_userinfo(user, password = nil)
      unless password
        user, password = split_userinfo(user)
      end
      @user     = user
      @password = password if password

      [@user, @password]
    end
    protected :set_userinfo

    # protected setter for the user component +v+
    #
    # see also URI::Generic.user=
    #
    def set_user(v)
      set_userinfo(v, @password)
      v
    end
    protected :set_user

    # protected setter for the password component +v+
    #
    # see also URI::Generic.password=
    #
    def set_password(v)
      @password = v
      # returns v
    end
    protected :set_password

    # returns the userinfo +ui+ as user, password
    # if properly formated as 'user:password'
    def split_userinfo(ui)
      return nil, nil unless ui
      user, password = ui.split(/:/, 2)

      return user, password
    end
    private :split_userinfo

    # escapes 'user:password' +v+ based on RFC 1738 section 3.1
    def escape_userpass(v)
      v = parser.escape(v, /[@:\/]/o) # RFC 1738 section 3.1 #/
    end
    private :escape_userpass

    # returns the userinfo, either as 'user' or 'user:password'
    def userinfo
      if @user.nil?
        nil
      elsif @password.nil?
        @user
      else
        @user + ':' + @password
      end
    end

    # returns the user component
    def user
      @user
    end

    # returns the password component
    def password
      @password
    end

    #
    # check the host +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp for :HOST
    #
    # Can not have a registry or opaque component defined,
    # with a host component defined.
    #
    def check_host(v)
      return v unless v

      if @registry || @opaque
        raise InvalidURIError,
          "can not set host with registry or opaque"
      elsif parser.regexp[:HOST] !~ v
        raise InvalidComponentError,
          "bad component(expected host component): #{v}"
      end

      return true
    end
    private :check_host

    # protected setter for the host component +v+
    #
    # see also URI::Generic.host=
    #
    def set_host(v)
      @host = v
    end
    protected :set_host

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the host component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_host
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com")
    #   uri.host = "foo.com"
    #   # =>  "foo.com"
    #   uri
    #   #=> #<URI::HTTP:0x000000008e89e8 URL:http://foo.com>
    #
    def host=(v)
      check_host(v)
      set_host(v)
      v
    end

    # extract the host part of the URI and unwrap brackets for IPv6 addresses.
    #
    # This method is same as URI::Generic#host except
    # brackets for IPv6 (andn future IP) addresses are removed.
    #
    # u = URI("http://[::1]/bar")
    # p u.hostname      #=> "::1"
    # p u.host          #=> "[::1]"
    #
    def hostname
      v = self.host
      /\A\[(.*)\]\z/ =~ v ? $1 : v
    end

    # set the host part of the URI as the argument with brackets for IPv6 addresses.
    #
    # This method is same as URI::Generic#host= except
    # the argument can be bare IPv6 address.
    #
    # u = URI("http://foo/bar")
    # p u.to_s                  #=> "http://foo/bar"
    # u.hostname = "::1"
    # p u.to_s                  #=> "http://[::1]/bar"
    #
    # If the arugument seems IPv6 address,
    # it is wrapped by brackets.
    #
    def hostname=(v)
      v = "[#{v}]" if /\A\[.*\]\z/ !~ v && /:/ =~ v
      self.host = v
    end

    #
    # check the port +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp for :PORT
    #
    # Can not have a registry or opaque component defined,
    # with a port component defined.
    #
    def check_port(v)
      return v unless v

      if @registry || @opaque
        raise InvalidURIError,
          "can not set port with registry or opaque"
      elsif !v.kind_of?(Fixnum) && parser.regexp[:PORT] !~ v
        raise InvalidComponentError,
          "bad component(expected port component): #{v}"
      end

      return true
    end
    private :check_port

    # protected setter for the port component +v+
    #
    # see also URI::Generic.port=
    #
    def set_port(v)
      unless !v || v.kind_of?(Fixnum)
        if v.empty?
          v = nil
        else
          v = v.to_i
        end
      end
      @port = v
    end
    protected :set_port

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the port component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_port
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com")
    #   uri.port = 8080
    #   # =>  8080
    #   uri
    #   #=> #<URI::HTTP:0x000000008e89e8 URL:http://my.example.com:8080>
    #
    def port=(v)
      check_port(v)
      set_port(v)
      port
    end

    #
    # check the registry +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp for :REGISTRY
    #
    # Can not have a host, port or user component defined,
    # with a registry component defined.
    #
    def check_registry(v)
      return v unless v

      # raise if both server and registry are not nil, because:
      # authority     = server | reg_name
      # server        = [ [ userinfo "@" ] hostport ]
      if @host || @port || @user # userinfo = @user + ':' + @password
        raise InvalidURIError,
          "can not set registry with host, port, or userinfo"
      elsif v && parser.regexp[:REGISTRY] !~ v
        raise InvalidComponentError,
          "bad component(expected registry component): #{v}"
      end

      return true
    end
    private :check_registry

    # protected setter for the registry component +v+
    #
    # see also URI::Generic.registry=
    #
    def set_registry(v)
      @registry = v
    end
    protected :set_registry

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the registry component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_registry
    #
    def registry=(v)
      check_registry(v)
      set_registry(v)
      v
    end

    #
    # check the path +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp
    # for :ABS_PATH and :REL_PATH
    #
    # Can not have a opaque component defined,
    # with a path component defined.
    #
    def check_path(v)
      # raise if both hier and opaque are not nil, because:
      # absoluteURI   = scheme ":" ( hier_part | opaque_part )
      # hier_part     = ( net_path | abs_path ) [ "?" query ]
      if v && @opaque
        raise InvalidURIError,
          "path conflicts with opaque"
      end

      # If scheme is ftp, path may be relative.
      # See RFC 1738 section 3.2.2, and RFC 2396.
      if @scheme && @scheme != "ftp"
        if v && v != '' && parser.regexp[:ABS_PATH] !~ v
          raise InvalidComponentError,
            "bad component(expected absolute path component): #{v}"
        end
      else
        if v && v != '' && parser.regexp[:ABS_PATH] !~ v && parser.regexp[:REL_PATH] !~ v
          raise InvalidComponentError,
            "bad component(expected relative path component): #{v}"
        end
      end

      return true
    end
    private :check_path

    # protected setter for the path component +v+
    #
    # see also URI::Generic.path=
    #
    def set_path(v)
      @path = v
    end
    protected :set_path

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the path component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_path
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com/pub/files")
    #   uri.path = "/faq/"
    #   # =>  "/faq/"
    #   uri
    #   #=> #<URI::HTTP:0x000000008e89e8 URL:http://my.example.com/faq/>
    #
    def path=(v)
      check_path(v)
      set_path(v)
      v
    end

    #
    # check the query +v+ component for RFC2396 compliance
    # and against the URI::Parser Regexp for :QUERY
    #
    # Can not have a opaque component defined,
    # with a query component defined.
    #
    def check_query(v)
      return v unless v

      # raise if both hier and opaque are not nil, because:
      # absoluteURI   = scheme ":" ( hier_part | opaque_part )
      # hier_part     = ( net_path | abs_path ) [ "?" query ]
      if @opaque
        raise InvalidURIError,
          "query conflicts with opaque"
      end

      if v && v != '' && parser.regexp[:QUERY] !~ v
          raise InvalidComponentError,
            "bad component(expected query component): #{v}"
      end

      return true
    end
    private :check_query

    # protected setter for the query component +v+
    #
    # see also URI::Generic.query=
    #
    def set_query(v)
      @query = v
    end
    protected :set_query

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the query component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_query
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com/?id=25")
    #   uri.query = "id=1"
    #   # =>  "id=1"
    #   uri
    #   #=> #<URI::HTTP:0x000000008e89e8 URL:http://my.example.com/?id=1>
    #
    def query=(v)
      check_query(v)
      set_query(v)
      v
    end

    #
    # check the opaque +v+ component for RFC2396 compliance and
    # against the URI::Parser Regexp for :OPAQUE
    #
    # Can not have a host, port, user or path component defined,
    # with an opaque component defined.
    #
    def check_opaque(v)
      return v unless v

      # raise if both hier and opaque are not nil, because:
      # absoluteURI   = scheme ":" ( hier_part | opaque_part )
      # hier_part     = ( net_path | abs_path ) [ "?" query ]
      if @host || @port || @user || @path  # userinfo = @user + ':' + @password
        raise InvalidURIError,
          "can not set opaque with host, port, userinfo or path"
      elsif v && parser.regexp[:OPAQUE] !~ v
        raise InvalidComponentError,
          "bad component(expected opaque component): #{v}"
      end

      return true
    end
    private :check_opaque

    # protected setter for the opaque component +v+
    #
    # see also URI::Generic.opaque=
    #
    def set_opaque(v)
      @opaque = v
    end
    protected :set_opaque

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the opaque component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_opaque
    #
    def opaque=(v)
      check_opaque(v)
      set_opaque(v)
      v
    end

    #
    # check the fragment +v+ component against the URI::Parser Regexp for :FRAGMENT
    #
    def check_fragment(v)
      return v unless v

      if v && v != '' && parser.regexp[:FRAGMENT] !~ v
        raise InvalidComponentError,
          "bad component(expected fragment component): #{v}"
      end

      return true
    end
    private :check_fragment

    # protected setter for the fragment component +v+
    #
    # see also URI::Generic.fragment=
    #
    def set_fragment(v)
      @fragment = v
    end
    protected :set_fragment

    #
    # == Args
    #
    # +v+::
    #    String
    #
    # == Description
    #
    # public setter for the fragment component +v+.
    # (with validation)
    #
    # see also URI::Generic.check_fragment
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com/?id=25#time=1305212049")
    #   uri.fragment = "time=1305212086"
    #   # =>  "time=1305212086"
    #   uri
    #   #=> #<URI::HTTP:0x000000007a81f8 URL:http://my.example.com/?id=25#time=1305212086>
    #
    def fragment=(v)
      check_fragment(v)
      set_fragment(v)
      v
    end

    #
    # Checks if URI has a path
    #
    def hierarchical?
      if @path
        true
      else
        false
      end
    end

    #
    # Checks if URI is an absolute one
    #
    def absolute?
      if @scheme
        true
      else
        false
      end
    end
    alias absolute absolute?

    #
    # Checks if URI is relative
    #
    def relative?
      !absolute?
    end

    #
    # returns an Array of the path split on '/'
    #
    def split_path(path)
      path.split(%r{/+}, -1)
    end
    private :split_path

    #
    # Merges a base path +base+, with relative path +rel+,
    # returns a modified base path.
    #
    def merge_path(base, rel)

      # RFC2396, Section 5.2, 5)
      # RFC2396, Section 5.2, 6)
      base_path = split_path(base)
      rel_path  = split_path(rel)

      # RFC2396, Section 5.2, 6), a)
      base_path << '' if base_path.last == '..'
      while i = base_path.index('..')
        base_path.slice!(i - 1, 2)
      end

      if (first = rel_path.first) and first.empty?
        base_path.clear
        rel_path.shift
      end

      # RFC2396, Section 5.2, 6), c)
      # RFC2396, Section 5.2, 6), d)
      rel_path.push('') if rel_path.last == '.' || rel_path.last == '..'
      rel_path.delete('.')

      # RFC2396, Section 5.2, 6), e)
      tmp = []
      rel_path.each do |x|
        if x == '..' &&
            !(tmp.empty? || tmp.last == '..')
          tmp.pop
        else
          tmp << x
        end
      end

      add_trailer_slash = !tmp.empty?
      if base_path.empty?
        base_path = [''] # keep '/' for root directory
      elsif add_trailer_slash
        base_path.pop
      end
      while x = tmp.shift
        if x == '..'
          # RFC2396, Section 4
          # a .. or . in an absolute path has no special meaning
          base_path.pop if base_path.size > 1
        else
          # if x == '..'
          #   valid absolute (but abnormal) path "/../..."
          # else
          #   valid absolute path
          # end
          base_path << x
          tmp.each {|t| base_path << t}
          add_trailer_slash = false
          break
        end
      end
      base_path.push('') if add_trailer_slash

      return base_path.join('/')
    end
    private :merge_path

    #
    # == Args
    #
    # +oth+::
    #    URI or String
    #
    # == Description
    #
    # Destructive form of #merge
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com")
    #   uri.merge!("/main.rbx?page=1")
    #   p uri
    #   # =>  #<URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1>
    #
    def merge!(oth)
      t = merge(oth)
      if self == t
        nil
      else
        replace!(t)
        self
      end
    end

    #
    # == Args
    #
    # +oth+::
    #    URI or String
    #
    # == Description
    #
    # Merges two URI's.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com")
    #   p uri.merge("/main.rbx?page=1")
    #   # =>  #<URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1>
    #
    def merge(oth)
      begin
        base, rel = merge0(oth)
      rescue
        raise $!.class, $!.message
      end

      if base == rel
        return base
      end

      authority = rel.userinfo || rel.host || rel.port

      # RFC2396, Section 5.2, 2)
      if (rel.path.nil? || rel.path.empty?) && !authority && !rel.query
        base.set_fragment(rel.fragment) if rel.fragment
        return base
      end

      base.set_query(nil)
      base.set_fragment(nil)

      # RFC2396, Section 5.2, 4)
      if !authority
        base.set_path(merge_path(base.path, rel.path)) if base.path && rel.path
      else
        # RFC2396, Section 5.2, 4)
        base.set_path(rel.path) if rel.path
      end

      # RFC2396, Section 5.2, 7)
      base.set_userinfo(rel.userinfo) if rel.userinfo
      base.set_host(rel.host)         if rel.host
      base.set_port(rel.port)         if rel.port
      base.set_query(rel.query)       if rel.query
      base.set_fragment(rel.fragment) if rel.fragment

      return base
    end # merge
    alias + merge

    # return base and rel.
    # you can modify `base', but can not `rel'.
    def merge0(oth)
      oth = parser.send(:convert_to_uri, oth)

      if self.relative? && oth.relative?
        raise BadURIError,
          "both URI are relative"
      end

      if self.absolute? && oth.absolute?
        #raise BadURIError,
        #  "both URI are absolute"
        # hmm... should return oth for usability?
        return oth, oth
      end

      if self.absolute?
        return self.dup, oth
      else
        return oth, oth
      end
    end
    private :merge0

    # :stopdoc:
    def route_from_path(src, dst)
      case dst
      when src
        # RFC2396, Section 4.2
        return ''
      when %r{(?:\A|/)\.\.?(?:/|\z)}
        # dst has abnormal absolute path,
        # like "/./", "/../", "/x/../", ...
        return dst.dup
      end

      src_path = src.scan(%r{(?:\A|[^/]+)/})
      dst_path = dst.scan(%r{(?:\A|[^/]+)/?})

      # discard same parts
      while !dst_path.empty? && dst_path.first == src_path.first
        src_path.shift
        dst_path.shift
      end

      tmp = dst_path.join

      # calculate
      if src_path.empty?
        if tmp.empty?
          return './'
        elsif dst_path.first.include?(':') # (see RFC2396 Section 5)
          return './' + tmp
        else
          return tmp
        end
      end

      return '../' * src_path.size + tmp
    end
    private :route_from_path
    # :startdoc:

    # :stopdoc:
    def route_from0(oth)
      oth = parser.send(:convert_to_uri, oth)
      if self.relative?
        raise BadURIError,
          "relative URI: #{self}"
      end
      if oth.relative?
        raise BadURIError,
          "relative URI: #{oth}"
      end

      if self.scheme != oth.scheme
        return self, self.dup
      end
      rel = URI::Generic.new(nil, # it is relative URI
                             self.userinfo, self.host, self.port,
                             self.registry, self.path, self.opaque,
                             self.query, self.fragment, parser)

      if rel.userinfo != oth.userinfo ||
          rel.host.to_s.downcase != oth.host.to_s.downcase ||
          rel.port != oth.port

        if self.userinfo.nil? && self.host.nil?
          return self, self.dup
        end

        rel.set_port(nil) if rel.port == oth.default_port
        return rel, rel
      end
      rel.set_userinfo(nil)
      rel.set_host(nil)
      rel.set_port(nil)

      if rel.path && rel.path == oth.path
        rel.set_path('')
        rel.set_query(nil) if rel.query == oth.query
        return rel, rel
      elsif rel.opaque && rel.opaque == oth.opaque
        rel.set_opaque('')
        rel.set_query(nil) if rel.query == oth.query
        return rel, rel
      end

      # you can modify `rel', but can not `oth'.
      return oth, rel
    end
    private :route_from0
    # :startdoc:

    #
    # == Args
    #
    # +oth+::
    #    URI or String
    #
    # == Description
    #
    # Calculates relative path from oth to self
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse('http://my.example.com/main.rbx?page=1')
    #   p uri.route_from('http://my.example.com')
    #   #=> #<URI::Generic:0x20218858 URL:/main.rbx?page=1>
    #
    def route_from(oth)
      # you can modify `rel', but can not `oth'.
      begin
        oth, rel = route_from0(oth)
      rescue
        raise $!.class, $!.message
      end
      if oth == rel
        return rel
      end

      rel.set_path(route_from_path(oth.path, self.path))
      if rel.path == './' && self.query
        # "./?foo" -> "?foo"
        rel.set_path('')
      end

      return rel
    end

    alias - route_from

    #
    # == Args
    #
    # +oth+::
    #    URI or String
    #
    # == Description
    #
    # Calculates relative path to oth from self
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse('http://my.example.com')
    #   p uri.route_to('http://my.example.com/main.rbx?page=1')
    #   #=> #<URI::Generic:0x2020c2f6 URL:/main.rbx?page=1>
    #
    def route_to(oth)
      parser.send(:convert_to_uri, oth).route_from(self)
    end

    #
    # Returns normalized URI
    #
    def normalize
      uri = dup
      uri.normalize!
      uri
    end

    #
    # Destructive version of #normalize
    #
    def normalize!
      if path && path == ''
        set_path('/')
      end
      if scheme && scheme != scheme.downcase
        set_scheme(self.scheme.downcase)
      end
      if host && host != host.downcase
        set_host(self.host.downcase)
      end
    end

    # returns the assemble String with path and query components
    def path_query
      str = @path
      if @query
        str += '?' + @query
      end
      str
    end
    private :path_query

    #
    # Constructs String from URI
    #
    def to_s
      str = ''
      if @scheme
        str << @scheme
        str << ':'
      end

      if @opaque
        str << @opaque

      else
        if @registry
          str << @registry
        else
          if @host
            str << '//'
          end
          if self.userinfo
            str << self.userinfo
            str << '@'
          end
          if @host
            str << @host
          end
          if @port && @port != self.default_port
            str << ':'
            str << @port.to_s
          end
        end

        str << path_query
      end

      if @fragment
        str << '#'
        str << @fragment
      end

      str
    end

    #
    # Compares to URI's
    #
    def ==(oth)
      if self.class == oth.class
        self.normalize.component_ary == oth.normalize.component_ary
      else
        false
      end
    end

    def hash
      self.component_ary.hash
    end

    def eql?(oth)
      self.class == oth.class &&
      parser == oth.parser &&
      self.component_ary.eql?(oth.component_ary)
    end

=begin

--- URI::Generic#===(oth)

=end
#    def ===(oth)
#      raise NotImplementedError
#    end

=begin
=end


    # returns an Array of the components defined from the COMPONENT Array
    def component_ary
      component.collect do |x|
        self.send(x)
      end
    end
    protected :component_ary

    # == Args
    #
    # +components+::
    #    Multiple Symbol arguments defined in URI::HTTP
    #
    # == Description
    #
    # Selects specified components from URI
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')
    #   p uri.select(:userinfo, :host, :path)
    #   # => ["myuser:mypass", "my.example.com", "/test.rbx"]
    #
    def select(*components)
      components.collect do |c|
        if component.include?(c)
          self.send(c)
        else
          raise ArgumentError,
            "expected of components of #{self.class} (#{self.class.component.join(', ')})"
        end
      end
    end

    @@to_s = Kernel.instance_method(:to_s)
    def inspect
      @@to_s.bind(self).call.sub!(/>\z/) {" URL:#{self}>"}
    end

    #
    # == Args
    #
    # +v+::
    #    URI or String
    #
    # == Description
    #
    #  attempt to parse other URI +oth+
    #  return [parsed_oth, self]
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   uri = URI.parse("http://my.example.com")
    #   uri.coerce("http://foo.com")
    #   #=> [#<URI::HTTP:0x00000000bcb028 URL:http://foo.com/>, #<URI::HTTP:0x00000000d92178 URL:http://my.example.com>]
    #
    def coerce(oth)
      case oth
      when String
        oth = parser.parse(oth)
      else
        super
      end

      return oth, self
    end

    # returns a proxy URI.
    # The proxy URI is obtained from environment variables such as http_proxy,
    # ftp_proxy, no_proxy, etc.
    # If there is no proper proxy, nil is returned.
    #
    # Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.)
    # are examined too.
    #
    # But http_proxy and HTTP_PROXY is treated specially under CGI environment.
    # It's because HTTP_PROXY may be set by Proxy: header.
    # So HTTP_PROXY is not used.
    # http_proxy is not used too if the variable is case insensitive.
    # CGI_HTTP_PROXY can be used instead.
    def find_proxy
      raise BadURIError, "relative URI: #{self}" if self.relative?
      name = self.scheme.downcase + '_proxy'
      proxy_uri = nil
      if name == 'http_proxy' && ENV.include?('REQUEST_METHOD') # CGI?
        # HTTP_PROXY conflicts with *_proxy for proxy settings and
        # HTTP_* for header information in CGI.
        # So it should be careful to use it.
        pairs = ENV.reject {|k, v| /\Ahttp_proxy\z/i !~ k }
        case pairs.length
        when 0 # no proxy setting anyway.
          proxy_uri = nil
        when 1
          k, _ = pairs.shift
          if k == 'http_proxy' && ENV[k.upcase] == nil
            # http_proxy is safe to use because ENV is case sensitive.
            proxy_uri = ENV[name]
          else
            proxy_uri = nil
          end
        else # http_proxy is safe to use because ENV is case sensitive.
          proxy_uri = ENV.to_hash[name]
        end
        if !proxy_uri
          # Use CGI_HTTP_PROXY.  cf. libwww-perl.
          proxy_uri = ENV["CGI_#{name.upcase}"]
        end
      elsif name == 'http_proxy'
        unless proxy_uri = ENV[name]
          if proxy_uri = ENV[name.upcase]
            warn 'The environment variable HTTP_PROXY is discouraged.  Use http_proxy.'
          end
        end
      else
        proxy_uri = ENV[name] || ENV[name.upcase]
      end

      if proxy_uri.nil? || proxy_uri.empty?
        return nil
      end

      if self.hostname
        require 'socket'
        begin
          addr = IPSocket.getaddress(self.hostname)
          return nil if /\A127\.|\A::1\z/ =~ addr
        rescue SocketError
        end
      end

      name = 'no_proxy'
      if no_proxy = ENV[name] || ENV[name.upcase]
        no_proxy.scan(/([^:,]*)(?::(\d+))?/) {|host, port|
          if /(\A|\.)#{Regexp.quote host}\z/i =~ self.host &&
            (!port || self.port == port.to_i)
            return nil
          end
        }
      end
      URI.parse(proxy_uri)
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                http.rb                                                                                             0100644 0001750 0001750 00000005402 12045612015 034376  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/http.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# License:: You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: http.rb 37472 2012-11-05 01:19:09Z zzak $
#
# See URI for general documentation
#

require 'uri/generic'

module URI

  #
  # The syntax of HTTP URIs is defined in RFC1738 section 3.3.
  #
  # Note that the Ruby URI library allows HTTP URLs containing usernames and
  # passwords. This is not legal as per the RFC, but used to be
  # supported in Internet Explorer 5 and 6, before the MS04-004 security
  # update. See <URL:http://support.microsoft.com/kb/834489>.
  #
  class HTTP < Generic
    # A Default port of 80 for URI::HTTP
    DEFAULT_PORT = 80

    # An Array of the available components for URI::HTTP
    COMPONENT = [
      :scheme,
      :userinfo, :host, :port,
      :path,
      :query,
      :fragment
    ].freeze

    #
    # == Description
    #
    # Create a new URI::HTTP object from components, with syntax checking.
    #
    # The components accepted are userinfo, host, port, path, query and
    # fragment.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order
    # [userinfo, host, port, path, query, fragment].
    #
    # Example:
    #
    #     newuri = URI::HTTP.build({:host => 'www.example.com',
    #       :path => '/foo/bar'})
    #
    #     newuri = URI::HTTP.build([nil, "www.example.com", nil, "/path",
    #       "query", 'fragment'])
    #
    # Currently, if passed userinfo components this method generates
    # invalid HTTP URIs as per RFC 1738.
    #
    def self.build(args)
      tmp = Util::make_components_hash(self, args)
      return super(tmp)
    end

    #
    # == Description
    #
    # Create a new URI::HTTP object from generic URI components as per
    # RFC 2396. No HTTP-specific syntax checking (as per RFC 1738) is
    # performed.
    #
    # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,
    # +opaque+, +query+ and +fragment+, in that order.
    #
    # Example:
    #
    #     uri = URI::HTTP.new('http', nil, "www.example.com", nil, "/path",
    #       "query", 'fragment')
    #
    #
    # See also URI::Generic.new
    #
    def initialize(*arg)
      super(*arg)
    end

    #
    # == Description
    #
    # Returns the full path for an HTTP request, as required by Net::HTTP::Get.
    #
    # If the URI contains a query, the full path is URI#path + '?' + URI#query.
    # Otherwise, the path is simply URI#path.
    #
    def request_uri
      r = path_query
      if r && r[0] != ?/
        r = '/' + r
      end

      r
    end
  end

  @@schemes['HTTP'] = HTTP
end
                                                                                                                                                                                                                                                              https.rb                                                                                            0100644 0001750 0001750 00000001105 11563307211 034560  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/https.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# License:: You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: https.rb 31555 2011-05-13 20:03:21Z drbrain $
#
# See URI for general documentation
#

require 'uri/http'

module URI

  # The default port for HTTPS URIs is 443, and the scheme is 'https:' rather
  # than 'http:'. Other than that, HTTPS URIs are identical to HTTP URIs;
  # see URI::HTTP.
  class HTTPS < HTTP
    # A Default port of 443 for URI::HTTPS
    DEFAULT_PORT = 443
  end
  @@schemes['HTTPS'] = HTTPS
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                           ldap.rb                                                                                             0100644 0001750 0001750 00000013362 11563307211 034346  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/ldap.rb
#
# Author::
#  Takaaki Tateishi <ttate@jaist.ac.jp>
#  Akira Yamada <akira@ruby-lang.org>
# License::
#   URI::LDAP is copyrighted free software by Takaaki Tateishi and Akira Yamada.
#   You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: ldap.rb 31555 2011-05-13 20:03:21Z drbrain $
#
# See URI for general documentation
#

require 'uri/generic'

module URI

  #
  # LDAP URI SCHEMA (described in RFC2255)
  # ldap://<host>/<dn>[?<attrs>[?<scope>[?<filter>[?<extensions>]]]]
  #
  class LDAP < Generic

    # A Default port of 389 for URI::LDAP
    DEFAULT_PORT = 389

    # An Array of the available components for URI::LDAP
    COMPONENT = [
      :scheme,
      :host, :port,
      :dn,
      :attributes,
      :scope,
      :filter,
      :extensions,
    ].freeze

    # Scopes available for the starting point.
    #
    # * SCOPE_BASE - the Base DN
    # * SCOPE_ONE  - one level under the Base DN, not including the base DN and
    #                not including any entries under this.
    # * SCOPE_SUB  - subtress, all entries at all levels
    #
    SCOPE = [
      SCOPE_ONE = 'one',
      SCOPE_SUB = 'sub',
      SCOPE_BASE = 'base',
    ].freeze

    #
    # == Description
    #
    # Create a new URI::LDAP object from components, with syntax checking.
    #
    # The components accepted are host, port, dn, attributes,
    # scope, filter, and extensions.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the order
    # [host, port, dn, attributes, scope, filter, extensions].
    #
    # Example:
    #
    #     newuri = URI::LDAP.build({:host => 'ldap.example.com',
    #       :dn> => '/dc=example'})
    #
    #     newuri = URI::LDAP.build(["ldap.example.com", nil,
    #       "/dc=example;dc=com", "query", nil, nil, nil])
    #
    def self.build(args)
      tmp = Util::make_components_hash(self, args)

      if tmp[:dn]
        tmp[:path] = tmp[:dn]
      end

      query = []
      [:extensions, :filter, :scope, :attributes].collect do |x|
        next if !tmp[x] && query.size == 0
        query.unshift(tmp[x])
      end

      tmp[:query] = query.join('?')

      return super(tmp)
    end

    #
    # == Description
    #
    # Create a new URI::LDAP object from generic URI components as per
    # RFC 2396. No LDAP-specific syntax checking is performed.
    #
    # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,
    # +opaque+, +query+ and +fragment+, in that order.
    #
    # Example:
    #
    #     uri = URI::LDAP.new("ldap", nil, "ldap.example.com", nil,
    #       "/dc=example;dc=com", "query", nil, nil, nil, nil)
    #
    #
    # See also URI::Generic.new
    #
    def initialize(*arg)
      super(*arg)

      if @fragment
        raise InvalidURIError, 'bad LDAP URL'
      end

      parse_dn
      parse_query
    end

    # private method to cleanup +dn+ from using the +path+ component attribute
    def parse_dn
      @dn = @path[1..-1]
    end
    private :parse_dn

    # private method to cleanup +attributes+, +scope+, +filter+ and +extensions+,
    # from using the +query+ component attribute
    def parse_query
      @attributes = nil
      @scope      = nil
      @filter     = nil
      @extensions = nil

      if @query
        attrs, scope, filter, extensions = @query.split('?')

        @attributes = attrs if attrs && attrs.size > 0
        @scope      = scope if scope && scope.size > 0
        @filter     = filter if filter && filter.size > 0
        @extensions = extensions if extensions && extensions.size > 0
      end
    end
    private :parse_query

    # private method to assemble +query+ from +attributes+, +scope+, +filter+ and +extensions+.
    def build_path_query
      @path = '/' + @dn

      query = []
      [@extensions, @filter, @scope, @attributes].each do |x|
        next if !x && query.size == 0
        query.unshift(x)
      end
      @query = query.join('?')
    end
    private :build_path_query

    # returns dn.
    def dn
      @dn
    end

    # private setter for dn +val+
    def set_dn(val)
      @dn = val
      build_path_query
      @dn
    end
    protected :set_dn

    # setter for dn +val+
    def dn=(val)
      set_dn(val)
      val
    end

    # returns attributes.
    def attributes
      @attributes
    end

    # private setter for attributes +val+
    def set_attributes(val)
      @attributes = val
      build_path_query
      @attributes
    end
    protected :set_attributes

    # setter for attributes +val+
    def attributes=(val)
      set_attributes(val)
      val
    end

    # returns scope.
    def scope
      @scope
    end

    # private setter for scope +val+
    def set_scope(val)
      @scope = val
      build_path_query
      @scope
    end
    protected :set_scope

    # setter for scope +val+
    def scope=(val)
      set_scope(val)
      val
    end

    # returns filter.
    def filter
      @filter
    end

    # private setter for filter +val+
    def set_filter(val)
      @filter = val
      build_path_query
      @filter
    end
    protected :set_filter

    # setter for filter +val+
    def filter=(val)
      set_filter(val)
      val
    end

    # returns extensions.
    def extensions
      @extensions
    end

    # private setter for extensions +val+
    def set_extensions(val)
      @extensions = val
      build_path_query
      @extensions
    end
    protected :set_extensions

    # setter for extensions +val+
    def extensions=(val)
      set_extensions(val)
      val
    end

    # Checks if URI has a path
    # For URI::LDAP this will return +false+
    def hierarchical?
      false
    end
  end

  @@schemes['LDAP'] = LDAP
end
                                                                                                                                                                                                                                                                              ldaps.rb                                                                                            0100644 0001750 0001750 00000000726 11563307211 034531  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/ldap.rb
#
# License:: You can redistribute it and/or modify it under the same term as Ruby.
#
# See URI for general documentation
#

require 'uri/ldap'

module URI

  # The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather
  # than 'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs;
  # see URI::LDAP.
  class LDAPS < LDAP
    # A Default port of 636 for URI::LDAPS
    DEFAULT_PORT = 636
  end
  @@schemes['LDAPS'] = LDAPS
end
                                          mailto.rb                                                                                           0100644 0001750 0001750 00000016060 11707213204 034707  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/uri                                                       # = uri/mailto.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# License:: You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: mailto.rb 34360 2012-01-23 08:12:52Z naruse $
#
# See URI for general documentation
#

require 'uri/generic'

module URI

  #
  # RFC2368, The mailto URL scheme
  #
  class MailTo < Generic
    include REGEXP

    # A Default port of nil for URI::MailTo
    DEFAULT_PORT = nil

    # An Array of the available components for URI::MailTo
    COMPONENT = [ :scheme, :to, :headers ].freeze

    # :stopdoc:
    #  "hname" and "hvalue" are encodings of an RFC 822 header name and
    #  value, respectively. As with "to", all URL reserved characters must
    #  be encoded.
    #
    #  "#mailbox" is as specified in RFC 822 [RFC822]. This means that it
    #  consists of zero or more comma-separated mail addresses, possibly
    #  including "phrase" and "comment" components. Note that all URL
    #  reserved characters in "to" must be encoded: in particular,
    #  parentheses, commas, and the percent sign ("%"), which commonly occur
    #  in the "mailbox" syntax.
    #
    #  Within mailto URLs, the characters "?", "=", "&" are reserved.

    # hname      =  *urlc
    # hvalue     =  *urlc
    # header     =  hname "=" hvalue
    HEADER_PATTERN = "(?:[^?=&]*=[^?=&]*)".freeze
    HEADER_REGEXP  = Regexp.new(HEADER_PATTERN).freeze
    # headers    =  "?" header *( "&" header )
    # to         =  #mailbox
    # mailtoURL  =  "mailto:" [ to ] [ headers ]
    MAILBOX_PATTERN = "(?:#{PATTERN::ESCAPED}|[^(),%?=&])".freeze
    MAILTO_REGEXP = Regexp.new(" # :nodoc:
      \\A
      (#{MAILBOX_PATTERN}*?)                          (?# 1: to)
      (?:
        \\?
        (#{HEADER_PATTERN}(?:\\&#{HEADER_PATTERN})*)  (?# 2: headers)
      )?
      (?:
        \\#
        (#{PATTERN::FRAGMENT})                        (?# 3: fragment)
      )?
      \\z
    ", Regexp::EXTENDED).freeze
    # :startdoc:

    #
    # == Description
    #
    # Creates a new URI::MailTo object from components, with syntax checking.
    #
    # Components can be provided as an Array or Hash. If an Array is used,
    # the components must be supplied as [to, headers].
    #
    # If a Hash is used, the keys are the component names preceded by colons.
    #
    # The headers can be supplied as a pre-encoded string, such as
    # "subject=subscribe&cc=address", or as an Array of Arrays like
    # [['subject', 'subscribe'], ['cc', 'address']]
    #
    # Examples:
    #
    #    require 'uri'
    #
    #    m1 = URI::MailTo.build(['joe@example.com', 'subject=Ruby'])
    #    puts m1.to_s  ->  mailto:joe@example.com?subject=Ruby
    #
    #    m2 = URI::MailTo.build(['john@example.com', [['Subject', 'Ruby'], ['Cc', 'jack@example.com']]])
    #    puts m2.to_s  ->  mailto:john@example.com?Subject=Ruby&Cc=jack@example.com
    #
    #    m3 = URI::MailTo.build({:to => 'listman@example.com', :headers => [['subject', 'subscribe']]})
    #    puts m3.to_s  ->  mailto:listman@example.com?subject=subscribe
    #
    def self.build(args)
      tmp = Util::make_components_hash(self, args)

      if tmp[:to]
        tmp[:opaque] = tmp[:to]
      else
        tmp[:opaque] = ''
      end

      if tmp[:headers]
        tmp[:opaque] << '?'

        if tmp[:headers].kind_of?(Array)
          tmp[:opaque] << tmp[:headers].collect { |x|
            if x.kind_of?(Array)
              x[0] + '=' + x[1..-1].join
            else
              x.to_s
            end
          }.join('&')

        elsif tmp[:headers].kind_of?(Hash)
          tmp[:opaque] << tmp[:headers].collect { |h,v|
            h + '=' + v
          }.join('&')

        else
          tmp[:opaque] << tmp[:headers].to_s
        end
      end

      return super(tmp)
    end

    #
    # == Description
    #
    # Creates a new URI::MailTo object from generic URL components with
    # no syntax checking.
    #
    # This method is usually called from URI::parse, which checks
    # the validity of each component.
    #
    def initialize(*arg)
      super(*arg)

      @to = nil
      @headers = []

      if MAILTO_REGEXP =~ @opaque
        if arg[-1]
          self.to = $1
          self.headers = $2
        else
          set_to($1)
          set_headers($2)
        end

      else
        raise InvalidComponentError,
          "unrecognised opaque part for mailtoURL: #{@opaque}"
      end
    end

    # The primary e-mail address of the URL, as a String
    attr_reader :to

    # E-mail headers set by the URL, as an Array of Arrays
    attr_reader :headers

    # check the to +v+ component against either
    # * URI::Parser Regexp for :OPAQUE
    # * MAILBOX_PATTERN
    def check_to(v)
      return true unless v
      return true if v.size == 0

      if parser.regexp[:OPAQUE] !~ v || /\A#{MAILBOX_PATTERN}*\z/o !~ v
        raise InvalidComponentError,
          "bad component(expected opaque component): #{v}"
      end

      return true
    end
    private :check_to

    # private setter for to +v+
    def set_to(v)
      @to = v
    end
    protected :set_to

    # setter for to +v+
    def to=(v)
      check_to(v)
      set_to(v)
      v
    end

    # check the headers +v+ component against either
    # * URI::Parser Regexp for :OPAQUE
    # * HEADER_PATTERN
    def check_headers(v)
      return true unless v
      return true if v.size == 0

      if parser.regexp[:OPAQUE] !~ v ||
          /\A(#{HEADER_PATTERN}(?:\&#{HEADER_PATTERN})*)\z/o !~ v
        raise InvalidComponentError,
          "bad component(expected opaque component): #{v}"
      end

      return true
    end
    private :check_headers

    # private setter for headers +v+
    def set_headers(v)
      @headers = []
      if v
        v.scan(HEADER_REGEXP) do |x|
          @headers << x.split(/=/o, 2)
        end
      end
    end
    protected :set_headers

    # setter for headers +v+
    def headers=(v)
      check_headers(v)
      set_headers(v)
      v
    end

    # Constructs String from URI
    def to_s
      @scheme + ':' +
        if @to
          @to
        else
          ''
        end +
        if @headers.size > 0
          '?' + @headers.collect{|x| x.join('=')}.join('&')
        else
          ''
        end +
        if @fragment
          '#' + @fragment
        else
          ''
        end
    end

    # Returns the RFC822 e-mail text equivalent of the URL, as a String.
    #
    # Example:
    #
    #   require 'uri'
    #
    #   uri = URI.parse("mailto:ruby-list@ruby-lang.org?Subject=subscribe&cc=myaddr")
    #   uri.to_mailtext
    #   # => "To: ruby-list@ruby-lang.org\nSubject: subscribe\nCc: myaddr\n\n\n"
    #
    def to_mailtext
      to = parser.unescape(@to)
      head = ''
      body = ''
      @headers.each do |x|
        case x[0]
        when 'body'
          body = parser.unescape(x[1])
        when 'to'
          to << ', ' + parser.unescape(x[1])
        else
          head << parser.unescape(x[0]).capitalize + ': ' +
            parser.unescape(x[1])  + "\n"
        end
      end

      return "To: #{to}
#{head}
#{body}
"
    end
    alias to_rfc822text to_mailtext
  end

  @@schemes['MAILTO'] = MailTo
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                uri.rb                                                                                              0100644 0001750 0001750 00000006110 11563307211 033417  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           # URI is a module providing classes to handle Uniform Resource Identifiers
# (RFC2396[http://tools.ietf.org/html/rfc2396])
#
# == Features
#
# * Uniform handling of handling URIs
# * Flexibility to introduce custom URI schemes
# * Flexibility to have an alternate URI::Parser (or just different patterns
#   and regexp's)
#
# == Basic example
#
#   require 'uri'
#
#   uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
#   #=> #<URI::HTTP:0x00000000b14880
#         URL:http://foo.com/posts?id=30&limit=5#time=1305298413>
#   uri.scheme
#   #=> "http"
#   uri.host
#   #=> "foo.com"
#   uri.path
#   #=> "/posts"
#   uri.query
#   #=> "id=30&limit=5"
#   uri.fragment
#   #=> "time=1305298413"
#
#   uri.to_s
#   #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"
#
# == Adding custom URIs
#
#   module URI
#     class RSYNC < Generic
#       DEFAULT_PORT = 873
#     end
#     @@schemes['RSYNC'] = RSYNC
#   end
#   #=> URI::RSYNC
#
#   URI.scheme_list
#   #=> {"FTP"=>URI::FTP, "HTTP"=>URI::HTTP, "HTTPS"=>URI::HTTPS,
#        "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS, "MAILTO"=>URI::MailTo,
#        "RSYNC"=>URI::RSYNC}
#
#   uri = URI("rsync://rsync.foo.com")
#   #=> #<URI::RSYNC:0x00000000f648c8 URL:rsync://rsync.foo.com>
#
# == RFC References
#
# A good place to view an RFC spec is http://www.ietf.org/rfc.html
#
# Here is a list of all related RFC's.
# - RFC822[http://tools.ietf.org/html/rfc822]
# - RFC1738[http://tools.ietf.org/html/rfc1738]
# - RFC2255[http://tools.ietf.org/html/rfc2255]
# - RFC2368[http://tools.ietf.org/html/rfc2368]
# - RFC2373[http://tools.ietf.org/html/rfc2373]
# - RFC2396[http://tools.ietf.org/html/rfc2396]
# - RFC2732[http://tools.ietf.org/html/rfc2732]
# - RFC3986[http://tools.ietf.org/html/rfc3986]
#
# == Class tree
#
# - URI::Generic (in uri/generic.rb)
#   - URI::FTP - (in uri/ftp.rb)
#   - URI::HTTP - (in uri/http.rb)
#     - URI::HTTPS - (in uri/https.rb)
#   - URI::LDAP - (in uri/ldap.rb)
#     - URI::LDAPS - (in uri/ldaps.rb)
#   - URI::MailTo - (in uri/mailto.rb)
# - URI::Parser - (in uri/common.rb)
# - URI::REGEXP - (in uri/common.rb)
#   - URI::REGEXP::PATTERN - (in uri/common.rb)
# - URI::Util - (in uri/common.rb)
# - URI::Escape - (in uri/common.rb)
# - URI::Error - (in uri/common.rb)
#   - URI::InvalidURIError - (in uri/common.rb)
#   - URI::InvalidComponentError - (in uri/common.rb)
#   - URI::BadURIError - (in uri/common.rb)
#
# == Copyright Info
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# Documentation::
#   Akira Yamada <akira@ruby-lang.org>
#   Dmitry V. Sabanin <sdmitry@lrn.ru>
#   Vincent Batts <vbatts@hashbangbash.com>
# License::
#  Copyright (c) 2001 akira yamada <akira@ruby-lang.org>
#  You can redistribute it and/or modify it under the same term as Ruby.
# Revision:: $Id: uri.rb 31555 2011-05-13 20:03:21Z drbrain $
#

module URI
  # :stopdoc:
  VERSION_CODE = '000911'.freeze
  VERSION = VERSION_CODE.scan(/../).collect{|n| n.to_i}.join('.').freeze
  # :startdoc:

end

require 'uri/common'
require 'uri/generic'
require 'uri/ftp'
require 'uri/http'
require 'uri/https'
require 'uri/ldap'
require 'uri/ldaps'
require 'uri/mailto'
                                                                                                                                                                                                                                                                                                                                                                                                                                                        weakref.rb                                                                                          0100644 0001750 0001750 00000006353 12056604771 034266  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           require "delegate"

# Weak Reference class that allows a referenced object to be
# garbage-collected.
#
# A WeakRef may be used exactly like the object it references.
#
# Usage:
#
#   foo = Object.new            # create a new object instance
#   p foo.to_s                  # original's class
#   foo = WeakRef.new(foo)      # reassign foo with WeakRef instance
#   p foo.to_s                  # should be same class
#   GC.start                    # start the garbage collector
#   p foo.to_s                  # should raise exception (recycled)
#
# == Example
#
# With help from WeakRef, we can implement our own redimentary WeakHash class.
#
# We will call it WeakHash, since it's really just a Hash except all of it's
# keys and values can be garbage collected.
#
#     require 'weakref'
#
#     class WeakHash < Hash
#       def []= key, obj
#         super WeakRef.new(key), WeakRef.new(obj)
#       end
#     end
#
# This is just a simple implementation, we've opened the Hash class and changed
# Hash#store to create a new WeakRef object with +key+ and +obj+ parameters
# before passing them as our key-value pair to the hash.
#
# With this you will have to limit your self to String key's, otherwise you
# will get an ArgumentError because WeakRef cannot create a finalizer for a
# Symbol. Symbols are immutable and cannot be garbage collected.
#
# Let's see it in action:
#
#   omg = "lol"
#   c = WeakHash.new
#   c['foo'] = "bar"
#   c['baz'] = Object.new
#   c['qux'] = omg
#   puts c.inspect
#   #=> {"foo"=>"bar", "baz"=>#<Object:0x007f4ddfc6cb48>, "qux"=>"lol"}
#
#   # Now run the garbage collector
#   GC.start
#   c['foo'] #=> nil
#   c['baz'] #=> nil
#   c['qux'] #=> nil
#   omg      #=> "lol"
#
#   puts c.inspect
#   #=> WeakRef::RefError: Invalid Reference - probably recycled
#
# You can see the local variable +omg+ stayed, although it's reference in our
# hash object was garbage collected, along with the rest of the keys and
# values. Also, when we tried to inspect our hash, we got a WeakRef::RefError,
# this is because these objects were also garbage collected.

class WeakRef < Delegator

  ##
  # RefError is raised when a referenced object has been recycled by the
  # garbage collector

  class RefError < StandardError
  end

  @@__map = ::ObjectSpace::WeakMap.new

  ##
  # Creates a weak reference to +orig+
  #
  # Raises an ArgumentError if the given +orig+ is immutable, such as Symbol,
  # Fixnum, or Float.

  def initialize(orig)
    case orig
    when true, false, nil
      @delegate_sd_obj = orig
    else
      @@__map[self] = orig
    end
    super
  end

  def __getobj__ # :nodoc:
    @@__map[self] or defined?(@delegate_sd_obj) ? @delegate_sd_obj :
      Kernel::raise(RefError, "Invalid Reference - probably recycled", Kernel::caller(2))
  end

  def __setobj__(obj) # :nodoc:
  end

  ##
  # Returns true if the referenced object is still alive.

  def weakref_alive?
    !!(@@__map[self] or defined?(@delegate_sd_obj))
  end
end

if __FILE__ == $0
#  require 'thread'
  foo = Object.new
  p foo.to_s                    # original's class
  foo = WeakRef.new(foo)
  p foo.to_s                    # should be same class
  ObjectSpace.garbage_collect
  ObjectSpace.garbage_collect
  p foo.to_s                    # should raise exception (recycled)
end
                                                                                                                                                                                                                                                                                     webrick/                                                                                            0040755 0001750 0001750 00000000000 12612224746 033735  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           accesslog.rb                                                                                        0100644 0001750 0001750 00000010473 12100626626 036222  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #--
# accesslog.rb -- Access log handling utilities
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2002 keita yamaguchi
# Copyright (c) 2002 Internet Programming with Ruby writers
#
# $IPR: accesslog.rb,v 1.1 2002/10/01 17:16:32 gotoyuzo Exp $

module WEBrick

  ##
  # AccessLog provides logging to various files in various formats.
  #
  # Multiple logs may be written to at the same time:
  #
  #   access_log = [
  #     [$stderr, WEBrick::AccessLog::COMMON_LOG_FORMAT],
  #     [$stderr, WEBrick::AccessLog::REFERER_LOG_FORMAT],
  #   ]
  #
  #   server = WEBrick::HTTPServer.new :AccessLog => access_log
  #
  # Custom log formats may be defined.  WEBrick::AccessLog provides a subset
  # of the formatting from Apache's mod_log_config
  # http://httpd.apache.org/docs/mod/mod_log_config.html#formats.  See
  # AccessLog::setup_params for a list of supported options

  module AccessLog

    ##
    # Raised if a parameter such as %e, %i, %o or %n is used without fetching
    # a specific field.

    class AccessLogError < StandardError; end

    ##
    # The Common Log Format's time format

    CLF_TIME_FORMAT     = "[%d/%b/%Y:%H:%M:%S %Z]"

    ##
    # Common Log Format

    COMMON_LOG_FORMAT   = "%h %l %u %t \"%r\" %s %b"

    ##
    # Short alias for Common Log Format

    CLF                 = COMMON_LOG_FORMAT

    ##
    # Referer Log Format

    REFERER_LOG_FORMAT  = "%{Referer}i -> %U"

    ##
    # User-Agent Log Format

    AGENT_LOG_FORMAT    = "%{User-Agent}i"

    ##
    # Combined Log Format

    COMBINED_LOG_FORMAT = "#{CLF} \"%{Referer}i\" \"%{User-agent}i\""

    module_function

    # This format specification is a subset of mod_log_config of Apache:
    #
    # %a:: Remote IP address
    # %b:: Total response size
    # %e{variable}:: Given variable in ENV
    # %f:: Response filename
    # %h:: Remote host name
    # %{header}i:: Given request header
    # %l:: Remote logname, always "-"
    # %m:: Request method
    # %{attr}n:: Given request attribute from <tt>req.attributes</tt>
    # %{header}o:: Given response header
    # %p:: Server's request port
    # %{format}p:: The canonical port of the server serving the request or the
    #              actual port or the client's actual port.  Valid formats are
    #              canonical, local or remote.
    # %q:: Request query string
    # %r:: First line of the request
    # %s:: Request status
    # %t:: Time the request was recieved
    # %T:: Time taken to process the request
    # %u:: Remote user from auth
    # %U:: Unparsed URI
    # %%:: Literal %

    def setup_params(config, req, res)
      params = Hash.new("")
      params["a"] = req.peeraddr[3]
      params["b"] = res.sent_size
      params["e"] = ENV
      params["f"] = res.filename || ""
      params["h"] = req.peeraddr[2]
      params["i"] = req
      params["l"] = "-"
      params["m"] = req.request_method
      params["n"] = req.attributes
      params["o"] = res
      params["p"] = req.port
      params["q"] = req.query_string
      params["r"] = req.request_line.sub(/\x0d?\x0a\z/o, '')
      params["s"] = res.status       # won't support "%>s"
      params["t"] = req.request_time
      params["T"] = Time.now - req.request_time
      params["u"] = req.user || "-"
      params["U"] = req.unparsed_uri
      params["v"] = config[:ServerName]
      params
    end

    ##
    # Formats +params+ according to +format_string+ which is described in
    # setup_params.

    def format(format_string, params)
      format_string.gsub(/\%(?:\{(.*?)\})?>?([a-zA-Z%])/){
         param, spec = $1, $2
         case spec[0]
         when ?e, ?i, ?n, ?o
           raise AccessLogError,
             "parameter is required for \"#{spec}\"" unless param
           (param = params[spec][param]) ? escape(param) : "-"
         when ?t
           params[spec].strftime(param || CLF_TIME_FORMAT)
         when ?p
           case param
           when 'remote'
             escape(params["i"].peeraddr[1].to_s)
           else
             escape(params["p"].to_s)
           end
         when ?%
           "%"
         else
           escape(params[spec].to_s)
         end
      }
    end

    ##
    # Escapes control characters in +data+

    def escape(data)
      if data.tainted?
        data.gsub(/[[:cntrl:]\\]+/) {$&.dump[1...-1]}.untaint
      else
        data
      end
    end
  end
end
                                                                                                                                                                                                     cgi.rb                                                                                              0100644 0001750 0001750 00000017741 12100626626 035026  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# cgi.rb -- Yet another CGI library
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $Id: cgi.rb 38945 2013-01-26 01:12:54Z drbrain $

require "webrick/httprequest"
require "webrick/httpresponse"
require "webrick/config"
require "stringio"

module WEBrick

  # A CGI library using WEBrick requests and responses.
  #
  # Example:
  #
  #   class MyCGI < WEBrick::CGI
  #     def do_GET req, res
  #       res.body = 'it worked!'
  #       res.status = 200
  #     end
  #   end
  #
  #   MyCGI.new.start

  class CGI

    # The CGI error exception class

    CGIError = Class.new(StandardError)

    ##
    # The CGI configuration.  This is based on WEBrick::Config::HTTP

    attr_reader :config

    ##
    # The CGI logger

    attr_reader :logger

    ##
    # Creates a new CGI interface.
    #
    # The first argument in +args+ is a configuration hash which would update
    # WEBrick::Config::HTTP.
    #
    # Any remaining arguments are stored in the <code>@options</code> instance
    # variable for use by a subclass.

    def initialize(*args)
      if defined?(MOD_RUBY)
        unless ENV.has_key?("GATEWAY_INTERFACE")
          Apache.request.setup_cgi_env
        end
      end
      if %r{HTTP/(\d+\.\d+)} =~ ENV["SERVER_PROTOCOL"]
        httpv = $1
      end
      @config = WEBrick::Config::HTTP.dup.update(
        :ServerSoftware => ENV["SERVER_SOFTWARE"] || "null",
        :HTTPVersion    => HTTPVersion.new(httpv || "1.0"),
        :RunOnCGI       => true,   # to detect if it runs on CGI.
        :NPH            => false   # set true to run as NPH script.
      )
      if config = args.shift
        @config.update(config)
      end
      @config[:Logger] ||= WEBrick::BasicLog.new($stderr)
      @logger = @config[:Logger]
      @options = args
    end

    ##
    # Reads +key+ from the configuration

    def [](key)
      @config[key]
    end

    ##
    # Starts the CGI process with the given environment +env+ and standard
    # input and output +stdin+ and +stdout+.

    def start(env=ENV, stdin=$stdin, stdout=$stdout)
      sock = WEBrick::CGI::Socket.new(@config, env, stdin, stdout)
      req = HTTPRequest.new(@config)
      res = HTTPResponse.new(@config)
      unless @config[:NPH] or defined?(MOD_RUBY)
        def res.setup_header
          unless @header["status"]
            phrase = HTTPStatus::reason_phrase(@status)
            @header["status"] = "#{@status} #{phrase}"
          end
          super
        end
        def res.status_line
          ""
        end
      end

      begin
        req.parse(sock)
        req.script_name = (env["SCRIPT_NAME"] || File.expand_path($0)).dup
        req.path_info = (env["PATH_INFO"] || "").dup
        req.query_string = env["QUERY_STRING"]
        req.user = env["REMOTE_USER"]
        res.request_method = req.request_method
        res.request_uri = req.request_uri
        res.request_http_version = req.http_version
        res.keep_alive = req.keep_alive?
        self.service(req, res)
      rescue HTTPStatus::Error => ex
        res.set_error(ex)
      rescue HTTPStatus::Status => ex
        res.status = ex.code
      rescue Exception => ex
        @logger.error(ex)
        res.set_error(ex, true)
      ensure
        req.fixup
        if defined?(MOD_RUBY)
          res.setup_header
          Apache.request.status_line = "#{res.status} #{res.reason_phrase}"
          Apache.request.status = res.status
          table = Apache.request.headers_out
          res.header.each{|key, val|
            case key
            when /^content-encoding$/i
              Apache::request.content_encoding = val
            when /^content-type$/i
              Apache::request.content_type = val
            else
              table[key] = val.to_s
            end
          }
          res.cookies.each{|cookie|
            table.add("Set-Cookie", cookie.to_s)
          }
          Apache.request.send_http_header
          res.send_body(sock)
        else
          res.send_response(sock)
        end
      end
    end

    ##
    # Services the request +req+ which will fill in the response +res+.  See
    # WEBrick::HTTPServlet::AbstractServlet#service for details.

    def service(req, res)
      method_name = "do_" + req.request_method.gsub(/-/, "_")
      if respond_to?(method_name)
        __send__(method_name, req, res)
      else
        raise HTTPStatus::MethodNotAllowed,
              "unsupported method `#{req.request_method}'."
      end
    end

    ##
    # Provides HTTP socket emulation from the CGI environment

    class Socket # :nodoc:
      include Enumerable

      private

      def initialize(config, env, stdin, stdout)
        @config = config
        @env = env
        @header_part = StringIO.new
        @body_part = stdin
        @out_port = stdout
        @out_port.binmode

        @server_addr = @env["SERVER_ADDR"] || "0.0.0.0"
        @server_name = @env["SERVER_NAME"]
        @server_port = @env["SERVER_PORT"]
        @remote_addr = @env["REMOTE_ADDR"]
        @remote_host = @env["REMOTE_HOST"] || @remote_addr
        @remote_port = @env["REMOTE_PORT"] || 0

        begin
          @header_part << request_line << CRLF
          setup_header
          @header_part << CRLF
          @header_part.rewind
        rescue Exception
          raise CGIError, "invalid CGI environment"
        end
      end

      def request_line
        meth = @env["REQUEST_METHOD"] || "GET"
        unless url = @env["REQUEST_URI"]
          url = (@env["SCRIPT_NAME"] || File.expand_path($0)).dup
          url << @env["PATH_INFO"].to_s
          url = WEBrick::HTTPUtils.escape_path(url)
          if query_string = @env["QUERY_STRING"]
            unless query_string.empty?
              url << "?" << query_string
            end
          end
        end
        # we cannot get real HTTP version of client ;)
        httpv = @config[:HTTPVersion]
        return "#{meth} #{url} HTTP/#{httpv}"
      end

      def setup_header
        @env.each{|key, value|
          case key
          when "CONTENT_TYPE", "CONTENT_LENGTH"
            add_header(key.gsub(/_/, "-"), value)
          when /^HTTP_(.*)/
            add_header($1.gsub(/_/, "-"), value)
          end
        }
      end

      def add_header(hdrname, value)
        unless value.empty?
          @header_part << hdrname << ": " << value << CRLF
        end
      end

      def input
        @header_part.eof? ? @body_part : @header_part
      end

      public

      def peeraddr
        [nil, @remote_port, @remote_host, @remote_addr]
      end

      def addr
        [nil, @server_port, @server_name, @server_addr]
      end

      def gets(eol=LF, size=nil)
        input.gets(eol, size)
      end

      def read(size=nil)
        input.read(size)
      end

      def each
        input.each{|line| yield(line) }
      end

      def eof?
        input.eof?
      end

      def <<(data)
        @out_port << data
      end

      def cert
        return nil unless defined?(OpenSSL)
        if pem = @env["SSL_SERVER_CERT"]
          OpenSSL::X509::Certificate.new(pem) unless pem.empty?
        end
      end

      def peer_cert
        return nil unless defined?(OpenSSL)
        if pem = @env["SSL_CLIENT_CERT"]
          OpenSSL::X509::Certificate.new(pem) unless pem.empty?
        end
      end

      def peer_cert_chain
        return nil unless defined?(OpenSSL)
        if @env["SSL_CLIENT_CERT_CHAIN_0"]
          keys = @env.keys
          certs = keys.sort.collect{|k|
            if /^SSL_CLIENT_CERT_CHAIN_\d+$/ =~ k
              if pem = @env[k]
                OpenSSL::X509::Certificate.new(pem) unless pem.empty?
              end
            end
          }
          certs.compact
        end
      end

      def cipher
        return nil unless defined?(OpenSSL)
        if cipher = @env["SSL_CIPHER"]
          ret = [ cipher ]
          ret << @env["SSL_PROTOCOL"]
          ret << @env["SSL_CIPHER_USEKEYSIZE"]
          ret << @env["SSL_CIPHER_ALGKEYSIZE"]
          ret
        end
      end
    end
  end
end
                               compat.rb                                                                                           0100644 0001750 0001750 00000001620 11564555306 035545  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# compat.rb -- cross platform compatibility
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2002 GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: compat.rb,v 1.6 2002/10/01 17:16:32 gotoyuzo Exp $

##
# System call error module used by webrick for cross platform compatability.
#
# EPROTO:: protocol error
# ECONNRESET:: remote host reset the connection request
# ECONNABORTED:: Client sent TCP reset (RST) before server has accepted the
#                connection requested by client.
#
module Errno
  ##
  # Protocol error.

  class EPROTO       < SystemCallError; end

  ##
  # Remote host reset the connection request.

  class ECONNRESET   < SystemCallError; end

  ##
  # Client sent TCP reset (RST) before server has accepted the connection
  # requested by client.

  class ECONNABORTED < SystemCallError; end
end
                                                                                                                config.rb                                                                                           0100644 0001750 0001750 00000013102 12100626626 035514  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# config.rb -- Default configurations.
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: config.rb,v 1.52 2003/07/22 19:20:42 gotoyuzo Exp $

require 'webrick/version'
require 'webrick/httpversion'
require 'webrick/httputils'
require 'webrick/utils'
require 'webrick/log'

module WEBrick
  module Config
    LIBDIR = File::dirname(__FILE__) # :nodoc:

    # for GenericServer
    General = {
      :ServerName     => Utils::getservername,
      :BindAddress    => nil,   # "0.0.0.0" or "::" or nil
      :Port           => nil,   # users MUST specify this!!
      :MaxClients     => 100,   # maximum number of the concurrent connections
      :ServerType     => nil,   # default: WEBrick::SimpleServer
      :Logger         => nil,   # default: WEBrick::Log.new
      :ServerSoftware => "WEBrick/#{WEBrick::VERSION} " +
                         "(Ruby/#{RUBY_VERSION}/#{RUBY_RELEASE_DATE})",
      :TempDir        => ENV['TMPDIR']||ENV['TMP']||ENV['TEMP']||'/tmp',
      :DoNotListen    => false,
      :StartCallback  => nil,
      :StopCallback   => nil,
      :AcceptCallback => nil,
      :DoNotReverseLookup => nil,
      :ShutdownSocketWithoutClose => false,
    }

    # for HTTPServer, HTTPRequest, HTTPResponse ...
    HTTP = General.dup.update(
      :Port           => 80,
      :RequestTimeout => 30,
      :HTTPVersion    => HTTPVersion.new("1.1"),
      :AccessLog      => nil,
      :MimeTypes      => HTTPUtils::DefaultMimeTypes,
      :DirectoryIndex => ["index.html","index.htm","index.cgi","index.rhtml"],
      :DocumentRoot   => nil,
      :DocumentRootOptions => { :FancyIndexing => true },
      :RequestCallback => nil,
      :ServerAlias    => nil,
      :InputBufferSize  => 65536, # input buffer size in reading request body
      :OutputBufferSize => 65536, # output buffer size in sending File or IO

      # for HTTPProxyServer
      :ProxyAuthProc  => nil,
      :ProxyContentHandler => nil,
      :ProxyVia       => true,
      :ProxyTimeout   => true,
      :ProxyURI       => nil,

      :CGIInterpreter => nil,
      :CGIPathEnv     => nil,

      # workaround: if Request-URIs contain 8bit chars,
      # they should be escaped before calling of URI::parse().
      :Escape8bitURI  => false
    )

    ##
    # Default configuration for WEBrick::HTTPServlet::FileHandler
    #
    # :AcceptableLanguages::
    #   Array of languages allowed for accept-language.  There is no default
    # :DirectoryCallback::
    #   Allows preprocessing of directory requests.  There is no default
    #   callback.
    # :FancyIndexing::
    #   If true, show an index for directories.  The default is true.
    # :FileCallback::
    #   Allows preprocessing of file requests.  There is no default callback.
    # :HandlerCallback::
    #   Allows preprocessing of requests.  There is no default callback.
    # :HandlerTable::
    #   Maps file suffixes to file handlers.  DefaultFileHandler is used by
    #   default but any servlet can be used.
    # :NondisclosureName::
    #   Do not show files matching this array of globs.  .ht* and *~ are
    #   excluded by default.
    # :UserDir::
    #   Directory inside ~user to serve content from for /~user requests.
    #   Only works if mounted on /.  Disabled by default.

    FileHandler = {
      :NondisclosureName => [".ht*", "*~"],
      :FancyIndexing     => false,
      :HandlerTable      => {},
      :HandlerCallback   => nil,
      :DirectoryCallback => nil,
      :FileCallback      => nil,
      :UserDir           => nil,  # e.g. "public_html"
      :AcceptableLanguages => []  # ["en", "ja", ... ]
    }

    ##
    # Default configuration for WEBrick::HTTPAuth::BasicAuth
    #
    # :AutoReloadUserDB:: Reload the user database provided by :UserDB
    #                     automatically?

    BasicAuth = {
      :AutoReloadUserDB     => true,
    }

    ##
    # Default configuration for WEBrick::HTTPAuth::DigestAuth.
    #
    # :Algorithm:: MD5, MD5-sess (default), SHA1, SHA1-sess
    # :Domain:: An Array of URIs that define the protected space
    # :Qop:: 'auth' for authentication, 'auth-int' for integrity protection or
    #        both
    # :UseOpaque:: Should the server send opaque values to the client?  This
    #              helps prevent replay attacks.
    # :CheckNc:: Should the server check the nonce count?  This helps the
    #            server detect replay attacks.
    # :UseAuthenticationInfoHeader:: Should the server send an
    #                                AuthenticationInfo header?
    # :AutoReloadUserDB:: Reload the user database provided by :UserDB
    #                     automatically?
    # :NonceExpirePeriod:: How long should we store used nonces?  Default is
    #                      30 minutes.
    # :NonceExpireDelta:: How long is a nonce valid?  Default is 1 minute
    # :InternetExplorerHack:: Hack which allows Internet Explorer to work.
    # :OperaHack:: Hack which allows Opera to work.

    DigestAuth = {
      :Algorithm            => 'MD5-sess', # or 'MD5'
      :Domain               => nil,        # an array includes domain names.
      :Qop                  => [ 'auth' ], # 'auth' or 'auth-int' or both.
      :UseOpaque            => true,
      :UseNextNonce         => false,
      :CheckNc              => false,
      :UseAuthenticationInfoHeader => true,
      :AutoReloadUserDB     => true,
      :NonceExpirePeriod    => 30*60,
      :NonceExpireDelta     => 60,
      :InternetExplorerHack => true,
      :OperaHack            => true,
    }
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                              cookie.rb                                                                                           0100644 0001750 0001750 00000007611 12100640017 035516  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# cookie.rb -- Cookie class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: cookie.rb,v 1.16 2002/09/21 12:23:35 gotoyuzo Exp $

require 'time'
require 'webrick/httputils'

module WEBrick

  ##
  # Processes HTTP cookies

  class Cookie

    ##
    # The cookie name

    attr_reader :name

    ##
    # The cookie value

    attr_accessor :value

    ##
    # The cookie version

    attr_accessor :version

    ##
    # The cookie domain
    attr_accessor :domain

    ##
    # The cookie path

    attr_accessor :path

    ##
    # Is this a secure cookie?

    attr_accessor :secure

    ##
    # The cookie comment

    attr_accessor :comment

    ##
    # The maximum age of the cookie

    attr_accessor :max_age

    #attr_accessor :comment_url, :discard, :port

    ##
    # Creates a new cookie with the given +name+ and +value+

    def initialize(name, value)
      @name = name
      @value = value
      @version = 0     # Netscape Cookie

      @domain = @path = @secure = @comment = @max_age =
      @expires = @comment_url = @discard = @port = nil
    end

    ##
    # Sets the cookie expiration to the time +t+.  The expiration time may be
    # a false value to disable expiration or a Time or HTTP format time string
    # to set the expiration date.

    def expires=(t)
      @expires = t && (t.is_a?(Time) ? t.httpdate : t.to_s)
    end

    ##
    # Retrieves the expiration time as a Time

    def expires
      @expires && Time.parse(@expires)
    end

    ##
    # The cookie string suitable for use in an HTTP header

    def to_s
      ret = ""
      ret << @name << "=" << @value
      ret << "; " << "Version=" << @version.to_s if @version > 0
      ret << "; " << "Domain="  << @domain  if @domain
      ret << "; " << "Expires=" << @expires if @expires
      ret << "; " << "Max-Age=" << @max_age.to_s if @max_age
      ret << "; " << "Comment=" << @comment if @comment
      ret << "; " << "Path="    << @path if @path
      ret << "; " << "Secure"   if @secure
      ret
    end

    ##
    # Parses a Cookie field sent from the user-agent.  Returns an array of
    # cookies.

    def self.parse(str)
      if str
        ret = []
        cookie = nil
        ver = 0
        str.split(/[;,]\s+/).each{|x|
          key, val = x.split(/=/,2)
          val = val ? HTTPUtils::dequote(val) : ""
          case key
          when "$Version"; ver = val.to_i
          when "$Path";    cookie.path = val
          when "$Domain";  cookie.domain = val
          when "$Port";    cookie.port = val
          else
            ret << cookie if cookie
            cookie = self.new(key, val)
            cookie.version = ver
          end
        }
        ret << cookie if cookie
        ret
      end
    end

    ##
    # Parses the cookie in +str+

    def self.parse_set_cookie(str)
      cookie_elem = str.split(/;/)
      first_elem = cookie_elem.shift
      first_elem.strip!
      key, value = first_elem.split(/=/, 2)
      cookie = new(key, HTTPUtils.dequote(value))
      cookie_elem.each{|pair|
        pair.strip!
        key, value = pair.split(/=/, 2)
        if value
          value = HTTPUtils.dequote(value.strip)
        end
        case key.downcase
        when "domain"  then cookie.domain  = value
        when "path"    then cookie.path    = value
        when "expires" then cookie.expires = value
        when "max-age" then cookie.max_age = Integer(value)
        when "comment" then cookie.comment = value
        when "version" then cookie.version = Integer(value)
        when "secure"  then cookie.secure = true
        end
      }
      return cookie
    end

    ##
    # Parses the cookies in +str+

    def self.parse_set_cookies(str)
      return str.split(/,(?=[^;,]*=)|,$/).collect{|c|
        parse_set_cookie(c)
      }
    end
  end
end
                                                                                                                       htmlutils.rb                                                                                        0100644 0001750 0001750 00000001250 12300166641 036273  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #--
# htmlutils.rb -- HTMLUtils Module
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: htmlutils.rb,v 1.7 2002/09/21 12:23:35 gotoyuzo Exp $

module WEBrick
  module HTMLUtils

    ##
    # Escapes &, ", > and < in +string+

    def escape(string)
      return "" unless string
      str = string.b
      str.gsub!(/&/n, '&amp;')
      str.gsub!(/\"/n, '&quot;')
      str.gsub!(/>/n, '&gt;')
      str.gsub!(/</n, '&lt;')
      str.force_encoding(string.encoding)
    end
    module_function :escape

  end
end
                                                                                                                                                                                                                                                                                                                                                        httpauth/                                                                                           0040755 0001750 0001750 00000000000 12612224746 035576  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   authenticator.rb                                                                                    0100644 0001750 0001750 00000005776 12100626626 041004  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #--
# httpauth/authenticator.rb -- Authenticator mix-in module.
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: authenticator.rb,v 1.3 2003/02/20 07:15:47 gotoyuzo Exp $

module WEBrick
  module HTTPAuth

    ##
    # Module providing generic support for both Digest and Basic
    # authentication schemes.

    module Authenticator

      RequestField      = "Authorization" # :nodoc:
      ResponseField     = "WWW-Authenticate" # :nodoc:
      ResponseInfoField = "Authentication-Info" # :nodoc:
      AuthException     = HTTPStatus::Unauthorized # :nodoc:

      ##
      # Method of authentication, must be overridden by the including class

      AuthScheme        = nil

      ##
      # The realm this authenticator covers

      attr_reader :realm

      ##
      # The user database for this authenticator

      attr_reader :userdb

      ##
      # The logger for this authenticator

      attr_reader :logger

      private

      # :stopdoc:

      ##
      # Initializes the authenticator from +config+

      def check_init(config)
        [:UserDB, :Realm].each{|sym|
          unless config[sym]
            raise ArgumentError, "Argument #{sym.inspect} missing."
          end
        }
        @realm     = config[:Realm]
        @userdb    = config[:UserDB]
        @logger    = config[:Logger] || Log::new($stderr)
        @reload_db = config[:AutoReloadUserDB]
        @request_field   = self::class::RequestField
        @response_field  = self::class::ResponseField
        @resp_info_field = self::class::ResponseInfoField
        @auth_exception  = self::class::AuthException
        @auth_scheme     = self::class::AuthScheme
      end

      ##
      # Ensures +req+ has credentials that can be authenticated.

      def check_scheme(req)
        unless credentials = req[@request_field]
          error("no credentials in the request.")
          return nil
        end
        unless match = /^#{@auth_scheme}\s+/i.match(credentials)
          error("invalid scheme in %s.", credentials)
          info("%s: %s", @request_field, credentials) if $DEBUG
          return nil
        end
        return match.post_match
      end

      def log(meth, fmt, *args)
        msg = format("%s %s: ", @auth_scheme, @realm)
        msg << fmt % args
        @logger.send(meth, msg)
      end

      def error(fmt, *args)
        if @logger.error?
          log(:error, fmt, *args)
        end
      end

      def info(fmt, *args)
        if @logger.info?
          log(:info, fmt, *args)
        end
      end

      # :startdoc:
    end

    ##
    # Module providing generic support for both Digest and Basic
    # authentication schemes for proxies.

    module ProxyAuthenticator
      RequestField  = "Proxy-Authorization" # :nodoc:
      ResponseField = "Proxy-Authenticate" # :nodoc:
      InfoField     = "Proxy-Authentication-Info" # :nodoc:
      AuthException = HTTPStatus::ProxyAuthenticationRequired # :nodoc:
    end
  end
end
  basicauth.rb                                                                                        0100644 0001750 0001750 00000005764 12100626626 040072  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #
# httpauth/basicauth.rb -- HTTP basic access authentication
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: basicauth.rb,v 1.5 2003/02/20 07:15:47 gotoyuzo Exp $

require 'webrick/config'
require 'webrick/httpstatus'
require 'webrick/httpauth/authenticator'

module WEBrick
  module HTTPAuth

    ##
    # Basic Authentication for WEBrick
    #
    # Use this class to add basic authentication to a WEBrick servlet.
    #
    # Here is an example of how to set up a BasicAuth:
    #
    #   config = { :Realm => 'BasicAuth example realm' }
    #
    #   htpasswd = WEBrick::HTTPAuth::Htpasswd.new 'my_password_file'
    #   htpasswd.set_passwd config[:Realm], 'username', 'password'
    #   htpasswd.flush
    #
    #   config[:UserDB] = htpasswd
    #
    #   basic_auth = WEBrick::HTTPAuth::BasicAuth.new config

    class BasicAuth
      include Authenticator

      AuthScheme = "Basic" # :nodoc:

      ##
      # Used by UserDB to create a basic password entry

      def self.make_passwd(realm, user, pass)
        pass ||= ""
        pass.crypt(Utils::random_string(2))
      end

      attr_reader :realm, :userdb, :logger

      ##
      # Creates a new BasicAuth instance.
      #
      # See WEBrick::Config::BasicAuth for default configuration entries
      #
      # You must supply the following configuration entries:
      #
      # :Realm:: The name of the realm being protected.
      # :UserDB:: A database of usernames and passwords.
      #           A WEBrick::HTTPAuth::Htpasswd instance should be used.

      def initialize(config, default=Config::BasicAuth)
        check_init(config)
        @config = default.dup.update(config)
      end

      ##
      # Authenticates a +req+ and returns a 401 Unauthorized using +res+ if
      # the authentication was not correct.

      def authenticate(req, res)
        unless basic_credentials = check_scheme(req)
          challenge(req, res)
        end
        userid, password = basic_credentials.unpack("m*")[0].split(":", 2)
        password ||= ""
        if userid.empty?
          error("user id was not given.")
          challenge(req, res)
        end
        unless encpass = @userdb.get_passwd(@realm, userid, @reload_db)
          error("%s: the user is not allowed.", userid)
          challenge(req, res)
        end
        if password.crypt(encpass) != encpass
          error("%s: password unmatch.", userid)
          challenge(req, res)
        end
        info("%s: authentication succeeded.", userid)
        req.user = userid
      end

      ##
      # Returns a challenge response which asks for for authentication
      # information

      def challenge(req, res)
        res[@response_field] = "#{@auth_scheme} realm=\"#{@realm}\""
        raise @auth_exception
      end
    end

    ##
    # Basic authentication for proxy servers.  See BasicAuth for details.

    class ProxyBasicAuth < BasicAuth
      include ProxyAuthenticator
    end
  end
end
            digestauth.rb                                                                                       0100644 0001750 0001750 00000032046 12100626626 040261  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #
# httpauth/digestauth.rb -- HTTP digest access authentication
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers.
# Copyright (c) 2003 H.M.
#
# The original implementation is provided by H.M.
#   URL: http://rwiki.jin.gr.jp/cgi-bin/rw-cgi.rb?cmd=view;name=
#        %C7%A7%BE%DA%B5%A1%C7%BD%A4%F2%B2%FE%C2%A4%A4%B7%A4%C6%A4%DF%A4%EB
#
# $IPR: digestauth.rb,v 1.5 2003/02/20 07:15:47 gotoyuzo Exp $

require 'webrick/config'
require 'webrick/httpstatus'
require 'webrick/httpauth/authenticator'
require 'digest/md5'
require 'digest/sha1'

module WEBrick
  module HTTPAuth

    ##
    # RFC 2617 Digest Access Authentication for WEBrick
    #
    # Use this class to add digest authentication to a WEBrick servlet.
    #
    # Here is an example of how to set up DigestAuth:
    #
    #   config = { :Realm => 'DigestAuth example realm' }
    #
    #   htdigest = WEBrick::HTTPAuth::Htdigest.new 'my_password_file'
    #   htdigest.set_passwd config[:Realm], 'username', 'password'
    #   htdigest.flush
    #
    #   config[:UserDB] = htdigest
    #
    #   digest_auth = WEBrick::HTTPAuth::DigestAuth.new config
    #
    # When using this as with a servlet be sure not to create a new DigestAuth
    # object in the servlet's #initialize.  By default WEBrick creates a new
    # servlet instance for every request and the DigestAuth object must be
    # used across requests.

    class DigestAuth
      include Authenticator

      AuthScheme = "Digest" # :nodoc:

      ##
      # Struct containing the opaque portion of the digest authentication

      OpaqueInfo = Struct.new(:time, :nonce, :nc) # :nodoc:

      ##
      # Digest authentication algorithm

      attr_reader :algorithm

      ##
      # Quality of protection.  RFC 2617 defines "auth" and "auth-int"

      attr_reader :qop

      ##
      # Used by UserDB to create a digest password entry

      def self.make_passwd(realm, user, pass)
        pass ||= ""
        Digest::MD5::hexdigest([user, realm, pass].join(":"))
      end

      ##
      # Creates a new DigestAuth instance.  Be sure to use the same DigestAuth
      # instance for multiple requests as it saves state between requests in
      # order to perform authentication.
      #
      # See WEBrick::Config::DigestAuth for default configuration entries
      #
      # You must supply the following configuration entries:
      #
      # :Realm:: The name of the realm being protected.
      # :UserDB:: A database of usernames and passwords.
      #           A WEBrick::HTTPAuth::Htdigest instance should be used.

      def initialize(config, default=Config::DigestAuth)
        check_init(config)
        @config                 = default.dup.update(config)
        @algorithm              = @config[:Algorithm]
        @domain                 = @config[:Domain]
        @qop                    = @config[:Qop]
        @use_opaque             = @config[:UseOpaque]
        @use_next_nonce         = @config[:UseNextNonce]
        @check_nc               = @config[:CheckNc]
        @use_auth_info_header   = @config[:UseAuthenticationInfoHeader]
        @nonce_expire_period    = @config[:NonceExpirePeriod]
        @nonce_expire_delta     = @config[:NonceExpireDelta]
        @internet_explorer_hack = @config[:InternetExplorerHack]

        case @algorithm
        when 'MD5','MD5-sess'
          @h = Digest::MD5
        when 'SHA1','SHA1-sess'  # it is a bonus feature :-)
          @h = Digest::SHA1
        else
          msg = format('Algorithm "%s" is not supported.', @algorithm)
          raise ArgumentError.new(msg)
        end

        @instance_key = hexdigest(self.__id__, Time.now.to_i, Process.pid)
        @opaques = {}
        @last_nonce_expire = Time.now
        @mutex = Mutex.new
      end

      ##
      # Authenticates a +req+ and returns a 401 Unauthorized using +res+ if
      # the authentication was not correct.

      def authenticate(req, res)
        unless result = @mutex.synchronize{ _authenticate(req, res) }
          challenge(req, res)
        end
        if result == :nonce_is_stale
          challenge(req, res, true)
        end
        return true
      end

      ##
      # Returns a challenge response which asks for for authentication
      # information

      def challenge(req, res, stale=false)
        nonce = generate_next_nonce(req)
        if @use_opaque
          opaque = generate_opaque(req)
          @opaques[opaque].nonce = nonce
        end

        param = Hash.new
        param["realm"]  = HTTPUtils::quote(@realm)
        param["domain"] = HTTPUtils::quote(@domain.to_a.join(" ")) if @domain
        param["nonce"]  = HTTPUtils::quote(nonce)
        param["opaque"] = HTTPUtils::quote(opaque) if opaque
        param["stale"]  = stale.to_s
        param["algorithm"] = @algorithm
        param["qop"]    = HTTPUtils::quote(@qop.to_a.join(",")) if @qop

        res[@response_field] =
          "#{@auth_scheme} " + param.map{|k,v| "#{k}=#{v}" }.join(", ")
        info("%s: %s", @response_field, res[@response_field]) if $DEBUG
        raise @auth_exception
      end

      private

      # :stopdoc:

      MustParams = ['username','realm','nonce','uri','response']
      MustParamsAuth = ['cnonce','nc']

      def _authenticate(req, res)
        unless digest_credentials = check_scheme(req)
          return false
        end

        auth_req = split_param_value(digest_credentials)
        if auth_req['qop'] == "auth" || auth_req['qop'] == "auth-int"
          req_params = MustParams + MustParamsAuth
        else
          req_params = MustParams
        end
        req_params.each{|key|
          unless auth_req.has_key?(key)
            error('%s: parameter missing. "%s"', auth_req['username'], key)
            raise HTTPStatus::BadRequest
          end
        }

        if !check_uri(req, auth_req)
          raise HTTPStatus::BadRequest
        end

        if auth_req['realm'] != @realm
          error('%s: realm unmatch. "%s" for "%s"',
                auth_req['username'], auth_req['realm'], @realm)
          return false
        end

        auth_req['algorithm'] ||= 'MD5'
        if auth_req['algorithm'].upcase != @algorithm.upcase
          error('%s: algorithm unmatch. "%s" for "%s"',
                auth_req['username'], auth_req['algorithm'], @algorithm)
          return false
        end

        if (@qop.nil? && auth_req.has_key?('qop')) ||
           (@qop && (! @qop.member?(auth_req['qop'])))
          error('%s: the qop is not allowed. "%s"',
                auth_req['username'], auth_req['qop'])
          return false
        end

        password = @userdb.get_passwd(@realm, auth_req['username'], @reload_db)
        unless password
          error('%s: the user is not allowd.', auth_req['username'])
          return false
        end

        nonce_is_invalid = false
        if @use_opaque
          info("@opaque = %s", @opaque.inspect) if $DEBUG
          if !(opaque = auth_req['opaque'])
            error('%s: opaque is not given.', auth_req['username'])
            nonce_is_invalid = true
          elsif !(opaque_struct = @opaques[opaque])
            error('%s: invalid opaque is given.', auth_req['username'])
            nonce_is_invalid = true
          elsif !check_opaque(opaque_struct, req, auth_req)
            @opaques.delete(auth_req['opaque'])
            nonce_is_invalid = true
          end
        elsif !check_nonce(req, auth_req)
          nonce_is_invalid = true
        end

        if /-sess$/i =~ auth_req['algorithm']
          ha1 = hexdigest(password, auth_req['nonce'], auth_req['cnonce'])
        else
          ha1 = password
        end

        if auth_req['qop'] == "auth" || auth_req['qop'] == nil
          ha2 = hexdigest(req.request_method, auth_req['uri'])
          ha2_res = hexdigest("", auth_req['uri'])
        elsif auth_req['qop'] == "auth-int"
          ha2 = hexdigest(req.request_method, auth_req['uri'],
                          hexdigest(req.body))
          ha2_res = hexdigest("", auth_req['uri'], hexdigest(res.body))
        end

        if auth_req['qop'] == "auth" || auth_req['qop'] == "auth-int"
          param2 = ['nonce', 'nc', 'cnonce', 'qop'].map{|key|
            auth_req[key]
          }.join(':')
          digest     = hexdigest(ha1, param2, ha2)
          digest_res = hexdigest(ha1, param2, ha2_res)
        else
          digest     = hexdigest(ha1, auth_req['nonce'], ha2)
          digest_res = hexdigest(ha1, auth_req['nonce'], ha2_res)
        end

        if digest != auth_req['response']
          error("%s: digest unmatch.", auth_req['username'])
          return false
        elsif nonce_is_invalid
          error('%s: digest is valid, but nonce is not valid.',
                auth_req['username'])
          return :nonce_is_stale
        elsif @use_auth_info_header
          auth_info = {
            'nextnonce' => generate_next_nonce(req),
            'rspauth'   => digest_res
          }
          if @use_opaque
            opaque_struct.time  = req.request_time
            opaque_struct.nonce = auth_info['nextnonce']
            opaque_struct.nc    = "%08x" % (auth_req['nc'].hex + 1)
          end
          if auth_req['qop'] == "auth" || auth_req['qop'] == "auth-int"
            ['qop','cnonce','nc'].each{|key|
              auth_info[key] = auth_req[key]
            }
          end
          res[@resp_info_field] = auth_info.keys.map{|key|
            if key == 'nc'
              key + '=' + auth_info[key]
            else
              key + "=" + HTTPUtils::quote(auth_info[key])
            end
          }.join(', ')
        end
        info('%s: authentication succeeded.', auth_req['username'])
        req.user = auth_req['username']
        return true
      end

      def split_param_value(string)
        ret = {}
        while string.bytesize != 0
          case string
          when /^\s*([\w\-\.\*\%\!]+)=\s*\"((\\.|[^\"])*)\"\s*,?/
            key = $1
            matched = $2
            string = $'
            ret[key] = matched.gsub(/\\(.)/, "\\1")
          when /^\s*([\w\-\.\*\%\!]+)=\s*([^,\"]*),?/
            key = $1
            matched = $2
            string = $'
            ret[key] = matched.clone
          when /^s*^,/
            string = $'
          else
            break
          end
        end
        ret
      end

      def generate_next_nonce(req)
        now = "%012d" % req.request_time.to_i
        pk  = hexdigest(now, @instance_key)[0,32]
        nonce = [now + ":" + pk].pack("m*").chop # it has 60 length of chars.
        nonce
      end

      def check_nonce(req, auth_req)
        username = auth_req['username']
        nonce = auth_req['nonce']

        pub_time, pk = nonce.unpack("m*")[0].split(":", 2)
        if (!pub_time || !pk)
          error("%s: empty nonce is given", username)
          return false
        elsif (hexdigest(pub_time, @instance_key)[0,32] != pk)
          error("%s: invalid private-key: %s for %s",
                username, hexdigest(pub_time, @instance_key)[0,32], pk)
          return false
        end

        diff_time = req.request_time.to_i - pub_time.to_i
        if (diff_time < 0)
          error("%s: difference of time-stamp is negative.", username)
          return false
        elsif diff_time > @nonce_expire_period
          error("%s: nonce is expired.", username)
          return false
        end

        return true
      end

      def generate_opaque(req)
        @mutex.synchronize{
          now = req.request_time
          if now - @last_nonce_expire > @nonce_expire_delta
            @opaques.delete_if{|key,val|
              (now - val.time) > @nonce_expire_period
            }
            @last_nonce_expire = now
          end
          begin
            opaque = Utils::random_string(16)
          end while @opaques[opaque]
          @opaques[opaque] = OpaqueInfo.new(now, nil, '00000001')
          opaque
        }
      end

      def check_opaque(opaque_struct, req, auth_req)
        if (@use_next_nonce && auth_req['nonce'] != opaque_struct.nonce)
          error('%s: nonce unmatched. "%s" for "%s"',
                auth_req['username'], auth_req['nonce'], opaque_struct.nonce)
          return false
        elsif !check_nonce(req, auth_req)
          return false
        end
        if (@check_nc && auth_req['nc'] != opaque_struct.nc)
          error('%s: nc unmatched."%s" for "%s"',
                auth_req['username'], auth_req['nc'], opaque_struct.nc)
          return false
        end
        true
      end

      def check_uri(req, auth_req)
        uri = auth_req['uri']
        if uri != req.request_uri.to_s && uri != req.unparsed_uri &&
           (@internet_explorer_hack && uri != req.path)
          error('%s: uri unmatch. "%s" for "%s"', auth_req['username'],
                auth_req['uri'], req.request_uri.to_s)
          return false
        end
        true
      end

      def hexdigest(*args)
        @h.hexdigest(args.join(":"))
      end

      # :startdoc:
    end

    ##
    # Digest authentication for proxy servers.  See DigestAuth for details.

    class ProxyDigestAuth < DigestAuth
      include ProxyAuthenticator

      private
      def check_uri(req, auth_req) # :nodoc:
        return true
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          htdigest.rb                                                                                         0100644 0001750 0001750 00000006501 11562346107 037734  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #
# httpauth/htdigest.rb -- Apache compatible htdigest file
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: htdigest.rb,v 1.4 2003/07/22 19:20:45 gotoyuzo Exp $

require 'webrick/httpauth/userdb'
require 'webrick/httpauth/digestauth'
require 'tempfile'

module WEBrick
  module HTTPAuth

    ##
    # Htdigest accesses apache-compatible digest password files.  Passwords are
    # matched to a realm where they are valid.  For security, the path for a
    # digest password database should be stored outside of the paths available
    # to the HTTP server.
    #
    # Htdigest is intended for use with WEBrick::HTTPAuth::DigestAuth and
    # stores passwords using cryptographic hashes.
    #
    #   htpasswd = WEBrick::HTTPAuth::Htdigest.new 'my_password_file'
    #   htpasswd.set_passwd 'my realm', 'username', 'password'
    #   htpasswd.flush

    class Htdigest
      include UserDB

      ##
      # Open a digest password database at +path+

      def initialize(path)
        @path = path
        @mtime = Time.at(0)
        @digest = Hash.new
        @mutex = Mutex::new
        @auth_type = DigestAuth
        open(@path,"a").close unless File::exist?(@path)
        reload
      end

      ##
      # Reloads passwords from the database

      def reload
        mtime = File::mtime(@path)
        if mtime > @mtime
          @digest.clear
          open(@path){|io|
            while line = io.gets
              line.chomp!
              user, realm, pass = line.split(/:/, 3)
              unless @digest[realm]
                @digest[realm] = Hash.new
              end
              @digest[realm][user] = pass
            end
          }
          @mtime = mtime
        end
      end

      ##
      # Flush the password database.  If +output+ is given the database will
      # be written there instead of to the original path.

      def flush(output=nil)
        output ||= @path
        tmp = Tempfile.new("htpasswd", File::dirname(output))
        begin
          each{|item| tmp.puts(item.join(":")) }
          tmp.close
          File::rename(tmp.path, output)
        rescue
          tmp.close(true)
        end
      end

      ##
      # Retrieves a password from the database for +user+ in +realm+.  If
      # +reload_db+ is true the database will be reloaded first.

      def get_passwd(realm, user, reload_db)
        reload() if reload_db
        if hash = @digest[realm]
          hash[user]
        end
      end

      ##
      # Sets a password in the database for +user+ in +realm+ to +pass+.

      def set_passwd(realm, user, pass)
        @mutex.synchronize{
          unless @digest[realm]
            @digest[realm] = Hash.new
          end
          @digest[realm][user] = make_passwd(realm, user, pass)
        }
      end

      ##
      # Removes a password from the database for +user+ in +realm+.

      def delete_passwd(realm, user)
        if hash = @digest[realm]
          hash.delete(user)
        end
      end

      ##
      # Iterate passwords in the database.

      def each # :yields: [user, realm, password_hash]
        @digest.keys.sort.each{|realm|
          hash = @digest[realm]
          hash.keys.sort.each{|user|
            yield([user, realm, hash[user]])
          }
        }
      end
    end
  end
end
                                                                                                                                                                                               htgroup.rb                                                                                          0100644 0001750 0001750 00000004521 11562346107 037611  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #
# httpauth/htgroup.rb -- Apache compatible htgroup file
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: htgroup.rb,v 1.1 2003/02/16 22:22:56 gotoyuzo Exp $

require 'tempfile'

module WEBrick
  module HTTPAuth

    ##
    # Htgroup accesses apache-compatible group files.  Htgroup can be used to
    # provide group-based authentication for users.  Currently Htgroup is not
    # directly integrated with any authenticators in WEBrick.  For security,
    # the path for a digest password database should be stored outside of the
    # paths available to the HTTP server.
    #
    # Example:
    #
    #   htgroup = WEBrick::HTTPAuth::Htgroup.new 'my_group_file'
    #   htgroup.add 'superheroes', %w[spiderman batman]
    #
    #   htgroup.members('superheroes').include? 'magneto' # => false

    class Htgroup

      ##
      # Open a group database at +path+

      def initialize(path)
        @path = path
        @mtime = Time.at(0)
        @group = Hash.new
        open(@path,"a").close unless File::exist?(@path)
        reload
      end

      ##
      # Reload groups from the database

      def reload
        if (mtime = File::mtime(@path)) > @mtime
          @group.clear
          open(@path){|io|
            while line = io.gets
              line.chomp!
              group, members = line.split(/:\s*/)
              @group[group] = members.split(/\s+/)
            end
          }
          @mtime = mtime
        end
      end

      ##
      # Flush the group database.  If +output+ is given the database will be
      # written there instead of to the original path.

      def flush(output=nil)
        output ||= @path
        tmp = Tempfile.new("htgroup", File::dirname(output))
        begin
          @group.keys.sort.each{|group|
            tmp.puts(format("%s: %s", group, self.members(group).join(" ")))
          }
          tmp.close
          File::rename(tmp.path, output)
        rescue
          tmp.close(true)
        end
      end

      ##
      # Retrieve the list of members from +group+

      def members(group)
        reload
        @group[group] || []
      end

      ##
      # Add an Array of +members+ to +group+

      def add(group, members)
        @group[group] = members(group) | members
      end
    end
  end
end
                                                                                                                                                                               htpasswd.rb                                                                                         0100644 0001750 0001750 00000006233 11562346107 037760  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #
# httpauth/htpasswd -- Apache compatible htpasswd file
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: htpasswd.rb,v 1.4 2003/07/22 19:20:45 gotoyuzo Exp $

require 'webrick/httpauth/userdb'
require 'webrick/httpauth/basicauth'
require 'tempfile'

module WEBrick
  module HTTPAuth

    ##
    # Htpasswd accesses apache-compatible password files.  Passwords are
    # matched to a realm where they are valid.  For security, the path for a
    # password database should be stored outside of the paths available to the
    # HTTP server.
    #
    # Htpasswd is intended for use with WEBrick::HTTPAuth::BasicAuth.
    #
    # To create an Htpasswd database with a single user:
    #
    #   htpasswd = WEBrick::HTTPAuth::Htpasswd.new 'my_password_file'
    #   htpasswd.set_passwd 'my realm', 'username', 'password'
    #   htpasswd.flush

    class Htpasswd
      include UserDB

      ##
      # Open a password database at +path+

      def initialize(path)
        @path = path
        @mtime = Time.at(0)
        @passwd = Hash.new
        @auth_type = BasicAuth
        open(@path,"a").close unless File::exist?(@path)
        reload
      end

      ##
      # Reload passwords from the database

      def reload
        mtime = File::mtime(@path)
        if mtime > @mtime
          @passwd.clear
          open(@path){|io|
            while line = io.gets
              line.chomp!
              case line
              when %r!\A[^:]+:[a-zA-Z0-9./]{13}\z!
                user, pass = line.split(":")
              when /:\$/, /:{SHA}/
                raise NotImplementedError,
                      'MD5, SHA1 .htpasswd file not supported'
              else
                raise StandardError, 'bad .htpasswd file'
              end
              @passwd[user] = pass
            end
          }
          @mtime = mtime
        end
      end

      ##
      # Flush the password database.  If +output+ is given the database will
      # be written there instead of to the original path.

      def flush(output=nil)
        output ||= @path
        tmp = Tempfile.new("htpasswd", File::dirname(output))
        begin
          each{|item| tmp.puts(item.join(":")) }
          tmp.close
          File::rename(tmp.path, output)
        rescue
          tmp.close(true)
        end
      end

      ##
      # Retrieves a password from the database for +user+ in +realm+.  If
      # +reload_db+ is true the database will be reloaded first.

      def get_passwd(realm, user, reload_db)
        reload() if reload_db
        @passwd[user]
      end

      ##
      # Sets a password in the database for +user+ in +realm+ to +pass+.

      def set_passwd(realm, user, pass)
        @passwd[user] = make_passwd(realm, user, pass)
      end

      ##
      # Removes a password from the database for +user+ in +realm+.

      def delete_passwd(realm, user)
        @passwd.delete(user)
      end

      ##
      # Iterate passwords in the database.

      def each # :yields: [user, password]
        @passwd.keys.sort.each{|user|
          yield([user, @passwd[user]])
        }
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                     userdb.rb                                                                                           0100644 0001750 0001750 00000002443 11562346107 037406  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpauth                                          #--
# httpauth/userdb.rb -- UserDB mix-in module.
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: userdb.rb,v 1.2 2003/02/20 07:15:48 gotoyuzo Exp $

module WEBrick
  module HTTPAuth

    ##
    # User database mixin for HTTPAuth.  This mixin dispatches user record
    # access to the underlying auth_type for this database.

    module UserDB

      ##
      # The authentication type.
      #
      # WEBrick::HTTPAuth::BasicAuth or WEBrick::HTTPAuth::DigestAuth are
      # built-in.

      attr_accessor :auth_type

      ##
      # Creates an obscured password in +realm+ with +user+ and +password+
      # using the auth_type of this database.

      def make_passwd(realm, user, pass)
        @auth_type::make_passwd(realm, user, pass)
      end

      ##
      # Sets a password in +realm+ with +user+ and +password+ for the
      # auth_type of this database.

      def set_passwd(realm, user, pass)
        self[user] = pass
      end

      ##
      # Retrieves a password in +realm+ for +user+ for the auth_type of this
      # database.  +reload_db+ is a dummy value.

      def get_passwd(realm, user, reload_db=false)
        make_passwd(realm, user, self[user])
      end
    end
  end
end
                                                                                                                                                                                                                             httpauth.rb                                                                                         0100644 0001750 0001750 00000006517 11562346107 036130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httpauth.rb -- HTTP access authentication
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpauth.rb,v 1.14 2003/07/22 19:20:42 gotoyuzo Exp $

require 'webrick/httpauth/basicauth'
require 'webrick/httpauth/digestauth'
require 'webrick/httpauth/htpasswd'
require 'webrick/httpauth/htdigest'
require 'webrick/httpauth/htgroup'

module WEBrick

  ##
  # HTTPAuth provides both basic and digest authentication.
  #
  # To enable authentication for requests in WEBrick you will need a user
  # database and an authenticator.  To start, here's an Htpasswd database for
  # use with a DigestAuth authenticator:
  #
  #   config = { :Realm => 'DigestAuth example realm' }
  #
  #   htpasswd = WEBrick::HTTPAuth::Htpasswd.new 'my_password_file'
  #   htpasswd.auth_type = WEBrick::HTTPAuth::DigestAuth
  #   htpasswd.set_passwd config[:Realm], 'username', 'password'
  #   htpasswd.flush
  #
  # The +:Realm+ is used to provide different access to different groups
  # across several resources on a server.  Typically you'll need only one
  # realm for a server.
  #
  # This database can be used to create an authenticator:
  #
  #   config[:UserDB] = htpasswd
  #
  #   digest_auth = WEBrick::HTTPAuth::DigestAuth.new config
  #
  # To authenticate a request call #authenticate with a request and response
  # object in a servlet:
  #
  #   def do_GET req, res
  #     @authenticator.authenticate req, res
  #   end
  #
  # For digest authentication the authenticator must not be created every
  # request, it must be passed in as an option via WEBrick::HTTPServer#mount.

  module HTTPAuth
    module_function

    def _basic_auth(req, res, realm, req_field, res_field, err_type,
                    block) # :nodoc:
      user = pass = nil
      if /^Basic\s+(.*)/o =~ req[req_field]
        userpass = $1
        user, pass = userpass.unpack("m*")[0].split(":", 2)
      end
      if block.call(user, pass)
        req.user = user
        return
      end
      res[res_field] = "Basic realm=\"#{realm}\""
      raise err_type
    end

    ##
    # Simple wrapper for providing basic authentication for a request.  When
    # called with a request +req+, response +res+, authentication +realm+ and
    # +block+ the block will be called with a +username+ and +password+.  If
    # the block returns true the request is allowed to continue, otherwise an
    # HTTPStatus::Unauthorized error is raised.

    def basic_auth(req, res, realm, &block) # :yield: username, password
      _basic_auth(req, res, realm, "Authorization", "WWW-Authenticate",
                  HTTPStatus::Unauthorized, block)
    end

    ##
    # Simple wrapper for providing basic authentication for a proxied request.
    # When called with a request +req+, response +res+, authentication +realm+
    # and +block+ the block will be called with a +username+ and +password+.
    # If the block returns true the request is allowed to continue, otherwise
    # an HTTPStatus::ProxyAuthenticationRequired error is raised.

    def proxy_basic_auth(req, res, realm, &block) # :yield: username, password
      _basic_auth(req, res, realm, "Proxy-Authorization", "Proxy-Authenticate",
                  HTTPStatus::ProxyAuthenticationRequired, block)
    end
  end
end
                                                                                                                                                                                 httpproxy.rb                                                                                        0100644 0001750 0001750 00000023226 12123624536 036343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httpproxy.rb -- HTTPProxy Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2002 GOTO Kentaro
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpproxy.rb,v 1.18 2003/03/08 18:58:10 gotoyuzo Exp $
# $kNotwork: straw.rb,v 1.3 2002/02/12 15:13:07 gotoken Exp $

require "webrick/httpserver"
require "net/http"

Net::HTTP::version_1_2 if RUBY_VERSION < "1.7"

module WEBrick

  NullReader = Object.new # :nodoc:
  class << NullReader # :nodoc:
    def read(*args)
      nil
    end
    alias gets read
  end

  FakeProxyURI = Object.new # :nodoc:
  class << FakeProxyURI # :nodoc:
    def method_missing(meth, *args)
      if %w(scheme host port path query userinfo).member?(meth.to_s)
        return nil
      end
      super
    end
  end

  # :startdoc:

  ##
  # An HTTP Proxy server which proxies GET, HEAD and POST requests.
  #
  # To create a simple proxy server:
  #
  #   require 'webrick'
  #   require 'webrick/httpproxy'
  #
  #   proxy = WEBrick::HTTPProxyServer.new Port: 8000
  #
  #   trap 'INT'  do proxy.shutdown end
  #   trap 'TERM' do proxy.shutdown end
  #
  #   proxy.start
  #
  # See ::new for proxy-specific configuration items.
  #
  # == Modifying proxied responses
  #
  # To modify content the proxy server returns use the +:ProxyContentHandler+
  # option:
  #
  #   handler = proc do |req, res|
  #     if res['content-type'] == 'text/plain' then
  #       res.body << "\nThis content was proxied!\n"
  #     end
  #   end
  #
  #   proxy =
  #     WEBrick::HTTPProxyServer.new Port: 8000, ProxyContentHandler: handler

  class HTTPProxyServer < HTTPServer

    ##
    # Proxy server configurations.  The proxy server handles the following
    # configuration items in addition to those supported by HTTPServer:
    #
    # :ProxyAuthProc:: Called with a request and response to authorize a
    #                  request
    # :ProxyVia:: Appended to the via header
    # :ProxyURI:: The proxy server's URI
    # :ProxyContentHandler:: Called with a request and response and allows
    #                        modification of the response
    # :ProxyTimeout:: Sets the proxy timeouts to 30 seconds for open and 60
    #                 seconds for read operations

    def initialize(config={}, default=Config::HTTP)
      super(config, default)
      c = @config
      @via = "#{c[:HTTPVersion]} #{c[:ServerName]}:#{c[:Port]}"
    end

    # :stopdoc:
    def service(req, res)
      if req.request_method == "CONNECT"
        do_CONNECT(req, res)
      elsif req.unparsed_uri =~ %r!^http://!
        proxy_service(req, res)
      else
        super(req, res)
      end
    end

    def proxy_auth(req, res)
      if proc = @config[:ProxyAuthProc]
        proc.call(req, res)
      end
      req.header.delete("proxy-authorization")
    end

    def proxy_uri(req, res)
      # should return upstream proxy server's URI
      return @config[:ProxyURI]
    end

    def proxy_service(req, res)
      # Proxy Authentication
      proxy_auth(req, res)

      begin
        self.send("do_#{req.request_method}", req, res)
      rescue NoMethodError
        raise HTTPStatus::MethodNotAllowed,
          "unsupported method `#{req.request_method}'."
      rescue => err
        logger.debug("#{err.class}: #{err.message}")
        raise HTTPStatus::ServiceUnavailable, err.message
      end

      # Process contents
      if handler = @config[:ProxyContentHandler]
        handler.call(req, res)
      end
    end

    def do_CONNECT(req, res)
      # Proxy Authentication
      proxy_auth(req, res)

      ua = Thread.current[:WEBrickSocket]  # User-Agent
      raise HTTPStatus::InternalServerError,
        "[BUG] cannot get socket" unless ua

      host, port = req.unparsed_uri.split(":", 2)
      # Proxy authentication for upstream proxy server
      if proxy = proxy_uri(req, res)
        proxy_request_line = "CONNECT #{host}:#{port} HTTP/1.0"
        if proxy.userinfo
          credentials = "Basic " + [proxy.userinfo].pack("m").delete("\n")
        end
        host, port = proxy.host, proxy.port
      end

      begin
        @logger.debug("CONNECT: upstream proxy is `#{host}:#{port}'.")
        os = TCPSocket.new(host, port)     # origin server

        if proxy
          @logger.debug("CONNECT: sending a Request-Line")
          os << proxy_request_line << CRLF
          @logger.debug("CONNECT: > #{proxy_request_line}")
          if credentials
            @logger.debug("CONNECT: sending a credentials")
            os << "Proxy-Authorization: " << credentials << CRLF
          end
          os << CRLF
          proxy_status_line = os.gets(LF)
          @logger.debug("CONNECT: read a Status-Line form the upstream server")
          @logger.debug("CONNECT: < #{proxy_status_line}")
          if %r{^HTTP/\d+\.\d+\s+200\s*} =~ proxy_status_line
            while line = os.gets(LF)
              break if /\A(#{CRLF}|#{LF})\z/om =~ line
            end
          else
            raise HTTPStatus::BadGateway
          end
        end
        @logger.debug("CONNECT #{host}:#{port}: succeeded")
        res.status = HTTPStatus::RC_OK
      rescue => ex
        @logger.debug("CONNECT #{host}:#{port}: failed `#{ex.message}'")
        res.set_error(ex)
        raise HTTPStatus::EOFError
      ensure
        if handler = @config[:ProxyContentHandler]
          handler.call(req, res)
        end
        res.send_response(ua)
        access_log(@config, req, res)

        # Should clear request-line not to send the response twice.
        # see: HTTPServer#run
        req.parse(NullReader) rescue nil
      end

      begin
        while fds = IO::select([ua, os])
          if fds[0].member?(ua)
            buf = ua.sysread(1024);
            @logger.debug("CONNECT: #{buf.bytesize} byte from User-Agent")
            os.syswrite(buf)
          elsif fds[0].member?(os)
            buf = os.sysread(1024);
            @logger.debug("CONNECT: #{buf.bytesize} byte from #{host}:#{port}")
            ua.syswrite(buf)
          end
        end
      rescue => ex
        os.close
        @logger.debug("CONNECT #{host}:#{port}: closed")
      end

      raise HTTPStatus::EOFError
    end

    def do_GET(req, res)
      perform_proxy_request(req, res) do |http, path, header|
        http.get(path, header)
      end
    end

    def do_HEAD(req, res)
      perform_proxy_request(req, res) do |http, path, header|
        http.head(path, header)
      end
    end

    def do_POST(req, res)
      perform_proxy_request(req, res) do |http, path, header|
        http.post(path, req.body || "", header)
      end
    end

    def do_OPTIONS(req, res)
      res['allow'] = "GET,HEAD,POST,OPTIONS,CONNECT"
    end

    private

    # Some header fields should not be transferred.
    HopByHop = %w( connection keep-alive proxy-authenticate upgrade
                   proxy-authorization te trailers transfer-encoding )
    ShouldNotTransfer = %w( set-cookie proxy-connection )
    def split_field(f) f ? f.split(/,\s+/).collect{|i| i.downcase } : [] end

    def choose_header(src, dst)
      connections = split_field(src['connection'])
      src.each{|key, value|
        key = key.downcase
        if HopByHop.member?(key)          || # RFC2616: 13.5.1
           connections.member?(key)       || # RFC2616: 14.10
           ShouldNotTransfer.member?(key)    # pragmatics
          @logger.debug("choose_header: `#{key}: #{value}'")
          next
        end
        dst[key] = value
      }
    end

    # Net::HTTP is stupid about the multiple header fields.
    # Here is workaround:
    def set_cookie(src, dst)
      if str = src['set-cookie']
        cookies = []
        str.split(/,\s*/).each{|token|
          if /^[^=]+;/o =~ token
            cookies[-1] << ", " << token
          elsif /=/o =~ token
            cookies << token
          else
            cookies[-1] << ", " << token
          end
        }
        dst.cookies.replace(cookies)
      end
    end

    def set_via(h)
      if @config[:ProxyVia]
        if  h['via']
          h['via'] << ", " << @via
        else
          h['via'] = @via
        end
      end
    end

    def setup_proxy_header(req, res)
      # Choose header fields to transfer
      header = Hash.new
      choose_header(req, header)
      set_via(header)
      return header
    end

    def setup_upstream_proxy_authentication(req, res, header)
      if upstream = proxy_uri(req, res)
        if upstream.userinfo
          header['proxy-authorization'] =
            "Basic " + [upstream.userinfo].pack("m").delete("\n")
        end
        return upstream
      end
      return FakeProxyURI
    end

    def perform_proxy_request(req, res)
      uri = req.request_uri
      path = uri.path.dup
      path << "?" << uri.query if uri.query
      header = setup_proxy_header(req, res)
      upstream = setup_upstream_proxy_authentication(req, res, header)
      response = nil

      http = Net::HTTP.new(uri.host, uri.port, upstream.host, upstream.port)
      http.start do
        if @config[:ProxyTimeout]
          ##################################   these issues are
          http.open_timeout = 30   # secs  #   necessary (maybe bacause
          http.read_timeout = 60   # secs  #   Ruby's bug, but why?)
          ##################################
        end
        response = yield(http, path, header)
      end

      # Persistent connection requirements are mysterious for me.
      # So I will close the connection in every response.
      res['proxy-connection'] = "close"
      res['connection'] = "close"

      # Convert Net::HTTP::HTTPResponse to WEBrick::HTTPResponse
      res.status = response.code.to_i
      choose_header(response, res)
      set_cookie(response, res)
      set_via(res)
      res.body = response.body
    end

    # :stopdoc:
  end
end
                                                                                                                                                                                                                                                                                                                                                                          httprequest.rb                                                                                      0100644 0001750 0001750 00000034516 12256326071 036656  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httprequest.rb -- HTTPRequest Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httprequest.rb,v 1.64 2003/07/13 17:18:22 gotoyuzo Exp $

require 'uri'
require 'webrick/httpversion'
require 'webrick/httpstatus'
require 'webrick/httputils'
require 'webrick/cookie'

module WEBrick

  ##
  # An HTTP request.  This is consumed by service and do_* methods in
  # WEBrick servlets

  class HTTPRequest

    BODY_CONTAINABLE_METHODS = [ "POST", "PUT" ] # :nodoc:

    # :section: Request line

    ##
    # The complete request line such as:
    #
    #   GET / HTTP/1.1

    attr_reader :request_line

    ##
    # The request method, GET, POST, PUT, etc.

    attr_reader :request_method

    ##
    # The unparsed URI of the request

    attr_reader :unparsed_uri

    ##
    # The HTTP version of the request

    attr_reader :http_version

    # :section: Request-URI

    ##
    # The parsed URI of the request

    attr_reader :request_uri

    ##
    # The request path

    attr_reader :path

    ##
    # The script name (CGI variable)

    attr_accessor :script_name

    ##
    # The path info (CGI variable)

    attr_accessor :path_info

    ##
    # The query from the URI of the request

    attr_accessor :query_string

    # :section: Header and entity body

    ##
    # The raw header of the request

    attr_reader :raw_header

    ##
    # The parsed header of the request

    attr_reader :header

    ##
    # The parsed request cookies

    attr_reader :cookies

    ##
    # The Accept header value

    attr_reader :accept

    ##
    # The Accept-Charset header value

    attr_reader :accept_charset

    ##
    # The Accept-Encoding header value

    attr_reader :accept_encoding

    ##
    # The Accept-Language header value

    attr_reader :accept_language

    # :section:

    ##
    # The remote user (CGI variable)

    attr_accessor :user

    ##
    # The socket address of the server

    attr_reader :addr

    ##
    # The socket address of the client

    attr_reader :peeraddr

    ##
    # Hash of request attributes

    attr_reader :attributes

    ##
    # Is this a keep-alive connection?

    attr_reader :keep_alive

    ##
    # The local time this request was received

    attr_reader :request_time

    ##
    # Creates a new HTTP request.  WEBrick::Config::HTTP is the default
    # configuration.

    def initialize(config)
      @config = config
      @buffer_size = @config[:InputBufferSize]
      @logger = config[:Logger]

      @request_line = @request_method =
        @unparsed_uri = @http_version = nil

      @request_uri = @host = @port = @path = nil
      @script_name = @path_info = nil
      @query_string = nil
      @query = nil
      @form_data = nil

      @raw_header = Array.new
      @header = nil
      @cookies = []
      @accept = []
      @accept_charset = []
      @accept_encoding = []
      @accept_language = []
      @body = ""

      @addr = @peeraddr = nil
      @attributes = {}
      @user = nil
      @keep_alive = false
      @request_time = nil

      @remaining_size = nil
      @socket = nil

      @forwarded_proto = @forwarded_host = @forwarded_port =
        @forwarded_server = @forwarded_for = nil
    end

    ##
    # Parses a request from +socket+.  This is called internally by
    # WEBrick::HTTPServer.

    def parse(socket=nil)
      @socket = socket
      begin
        @peeraddr = socket.respond_to?(:peeraddr) ? socket.peeraddr : []
        @addr = socket.respond_to?(:addr) ? socket.addr : []
      rescue Errno::ENOTCONN
        raise HTTPStatus::EOFError
      end

      read_request_line(socket)
      if @http_version.major > 0
        read_header(socket)
        @header['cookie'].each{|cookie|
          @cookies += Cookie::parse(cookie)
        }
        @accept = HTTPUtils.parse_qvalues(self['accept'])
        @accept_charset = HTTPUtils.parse_qvalues(self['accept-charset'])
        @accept_encoding = HTTPUtils.parse_qvalues(self['accept-encoding'])
        @accept_language = HTTPUtils.parse_qvalues(self['accept-language'])
      end
      return if @request_method == "CONNECT"
      return if @unparsed_uri == "*"

      begin
        setup_forwarded_info
        @request_uri = parse_uri(@unparsed_uri)
        @path = HTTPUtils::unescape(@request_uri.path)
        @path = HTTPUtils::normalize_path(@path)
        @host = @request_uri.host
        @port = @request_uri.port
        @query_string = @request_uri.query
        @script_name = ""
        @path_info = @path.dup
      rescue
        raise HTTPStatus::BadRequest, "bad URI `#{@unparsed_uri}'."
      end

      if /close/io =~ self["connection"]
        @keep_alive = false
      elsif /keep-alive/io =~ self["connection"]
        @keep_alive = true
      elsif @http_version < "1.1"
        @keep_alive = false
      else
        @keep_alive = true
      end
    end

    ##
    # Generate HTTP/1.1 100 continue response if the client expects it,
    # otherwise does nothing.

    def continue # :nodoc:
      if self['expect'] == '100-continue' && @config[:HTTPVersion] >= "1.1"
        @socket << "HTTP/#{@config[:HTTPVersion]} 100 continue#{CRLF}#{CRLF}"
        @header.delete('expect')
      end
    end

    ##
    # Returns the request body.

    def body(&block) # :yields: body_chunk
      block ||= Proc.new{|chunk| @body << chunk }
      read_body(@socket, block)
      @body.empty? ? nil : @body
    end

    ##
    # Request query as a Hash

    def query
      unless @query
        parse_query()
      end
      @query
    end

    ##
    # The content-length header

    def content_length
      return Integer(self['content-length'])
    end

    ##
    # The content-type header

    def content_type
      return self['content-type']
    end

    ##
    # Retrieves +header_name+

    def [](header_name)
      if @header
        value = @header[header_name.downcase]
        value.empty? ? nil : value.join(", ")
      end
    end

    ##
    # Iterates over the request headers

    def each
      if @header
        @header.each{|k, v|
          value = @header[k]
          yield(k, value.empty? ? nil : value.join(", "))
        }
      end
    end

    ##
    # The host this request is for

    def host
      return @forwarded_host || @host
    end

    ##
    # The port this request is for

    def port
      return @forwarded_port || @port
    end

    ##
    # The server name this request is for

    def server_name
      return @forwarded_server || @config[:ServerName]
    end

    ##
    # The client's IP address

    def remote_ip
      return self["client-ip"] || @forwarded_for || @peeraddr[3]
    end

    ##
    # Is this an SSL request?

    def ssl?
      return @request_uri.scheme == "https"
    end

    ##
    # Should the connection this request was made on be kept alive?

    def keep_alive?
      @keep_alive
    end

    def to_s # :nodoc:
      ret = @request_line.dup
      @raw_header.each{|line| ret << line }
      ret << CRLF
      ret << body if body
      ret
    end

    ##
    # Consumes any remaining body and updates keep-alive status

    def fixup() # :nodoc:
      begin
        body{|chunk| }   # read remaining body
      rescue HTTPStatus::Error => ex
        @logger.error("HTTPRequest#fixup: #{ex.class} occurred.")
        @keep_alive = false
      rescue => ex
        @logger.error(ex)
        @keep_alive = false
      end
    end

    # This method provides the metavariables defined by the revision 3
    # of "The WWW Common Gateway Interface Version 1.1"
    # http://Web.Golux.Com/coar/cgi/

    def meta_vars
      meta = Hash.new

      cl = self["Content-Length"]
      ct = self["Content-Type"]
      meta["CONTENT_LENGTH"]    = cl if cl.to_i > 0
      meta["CONTENT_TYPE"]      = ct.dup if ct
      meta["GATEWAY_INTERFACE"] = "CGI/1.1"
      meta["PATH_INFO"]         = @path_info ? @path_info.dup : ""
     #meta["PATH_TRANSLATED"]   = nil      # no plan to be provided
      meta["QUERY_STRING"]      = @query_string ? @query_string.dup : ""
      meta["REMOTE_ADDR"]       = @peeraddr[3]
      meta["REMOTE_HOST"]       = @peeraddr[2]
     #meta["REMOTE_IDENT"]      = nil      # no plan to be provided
      meta["REMOTE_USER"]       = @user
      meta["REQUEST_METHOD"]    = @request_method.dup
      meta["REQUEST_URI"]       = @request_uri.to_s
      meta["SCRIPT_NAME"]       = @script_name.dup
      meta["SERVER_NAME"]       = @host
      meta["SERVER_PORT"]       = @port.to_s
      meta["SERVER_PROTOCOL"]   = "HTTP/" + @config[:HTTPVersion].to_s
      meta["SERVER_SOFTWARE"]   = @config[:ServerSoftware].dup

      self.each{|key, val|
        next if /^content-type$/i =~ key
        next if /^content-length$/i =~ key
        name = "HTTP_" + key
        name.gsub!(/-/o, "_")
        name.upcase!
        meta[name] = val
      }

      meta
    end

    private

    # :stopdoc:

    MAX_URI_LENGTH = 2083 # :nodoc:

    def read_request_line(socket)
      @request_line = read_line(socket, MAX_URI_LENGTH) if socket
      if @request_line.bytesize >= MAX_URI_LENGTH and @request_line[-1, 1] != LF
        raise HTTPStatus::RequestURITooLarge
      end
      @request_time = Time.now
      raise HTTPStatus::EOFError unless @request_line
      if /^(\S+)\s+(\S++)(?:\s+HTTP\/(\d+\.\d+))?\r?\n/mo =~ @request_line
        @request_method = $1
        @unparsed_uri   = $2
        @http_version   = HTTPVersion.new($3 ? $3 : "0.9")
      else
        rl = @request_line.sub(/\x0d?\x0a\z/o, '')
        raise HTTPStatus::BadRequest, "bad Request-Line `#{rl}'."
      end
    end

    def read_header(socket)
      if socket
        while line = read_line(socket)
          break if /\A(#{CRLF}|#{LF})\z/om =~ line
          @raw_header << line
        end
      end
      @header = HTTPUtils::parse_header(@raw_header.join)
    end

    def parse_uri(str, scheme="http")
      if @config[:Escape8bitURI]
        str = HTTPUtils::escape8bit(str)
      end
      str.sub!(%r{\A/+}o, '/')
      uri = URI::parse(str)
      return uri if uri.absolute?
      if @forwarded_host
        host, port = @forwarded_host, @forwarded_port
      elsif self["host"]
        pattern = /\A(#{URI::REGEXP::PATTERN::HOST})(?::(\d+))?\z/n
        host, port = *self['host'].scan(pattern)[0]
      elsif @addr.size > 0
        host, port = @addr[2], @addr[1]
      else
        host, port = @config[:ServerName], @config[:Port]
      end
      uri.scheme = @forwarded_proto || scheme
      uri.host = host
      uri.port = port ? port.to_i : nil
      return URI::parse(uri.to_s)
    end

    def read_body(socket, block)
      return unless socket
      if tc = self['transfer-encoding']
        case tc
        when /chunked/io then read_chunked(socket, block)
        else raise HTTPStatus::NotImplemented, "Transfer-Encoding: #{tc}."
        end
      elsif self['content-length'] || @remaining_size
        @remaining_size ||= self['content-length'].to_i
        while @remaining_size > 0
          sz = [@buffer_size, @remaining_size].min
          break unless buf = read_data(socket, sz)
          @remaining_size -= buf.bytesize
          block.call(buf)
        end
        if @remaining_size > 0 && @socket.eof?
          raise HTTPStatus::BadRequest, "invalid body size."
        end
      elsif BODY_CONTAINABLE_METHODS.member?(@request_method)
        raise HTTPStatus::LengthRequired
      end
      return @body
    end

    def read_chunk_size(socket)
      line = read_line(socket)
      if /^([0-9a-fA-F]+)(?:;(\S+))?/ =~ line
        chunk_size = $1.hex
        chunk_ext = $2
        [ chunk_size, chunk_ext ]
      else
        raise HTTPStatus::BadRequest, "bad chunk `#{line}'."
      end
    end

    def read_chunked(socket, block)
      chunk_size, = read_chunk_size(socket)
      while chunk_size > 0
        data = read_data(socket, chunk_size) # read chunk-data
        if data.nil? || data.bytesize != chunk_size
          raise BadRequest, "bad chunk data size."
        end
        read_line(socket)                    # skip CRLF
        block.call(data)
        chunk_size, = read_chunk_size(socket)
      end
      read_header(socket)                    # trailer + CRLF
      @header.delete("transfer-encoding")
      @remaining_size = 0
    end

    def _read_data(io, method, *arg)
      begin
        WEBrick::Utils.timeout(@config[:RequestTimeout]){
          return io.__send__(method, *arg)
        }
      rescue Errno::ECONNRESET
        return nil
      rescue TimeoutError
        raise HTTPStatus::RequestTimeout
      end
    end

    def read_line(io, size=4096)
      _read_data(io, :gets, LF, size)
    end

    def read_data(io, size)
      _read_data(io, :read, size)
    end

    def parse_query()
      begin
        if @request_method == "GET" || @request_method == "HEAD"
          @query = HTTPUtils::parse_query(@query_string)
        elsif self['content-type'] =~ /^application\/x-www-form-urlencoded/
          @query = HTTPUtils::parse_query(body)
        elsif self['content-type'] =~ /^multipart\/form-data; boundary=(.+)/
          boundary = HTTPUtils::dequote($1)
          @query = HTTPUtils::parse_form_data(body, boundary)
        else
          @query = Hash.new
        end
      rescue => ex
        raise HTTPStatus::BadRequest, ex.message
      end
    end

    PrivateNetworkRegexp = /
      ^unknown$|
      ^((::ffff:)?127.0.0.1|::1)$|
      ^(::ffff:)?(10|172\.(1[6-9]|2[0-9]|3[01])|192\.168)\.
    /ixo

    # It's said that all X-Forwarded-* headers will contain more than one
    # (comma-separated) value if the original request already contained one of
    # these headers. Since we could use these values as Host header, we choose
    # the initial(first) value. (apr_table_mergen() adds new value after the
    # existing value with ", " prefix)
    def setup_forwarded_info
      if @forwarded_server = self["x-forwarded-server"]
        @forwarded_server = @forwarded_server.split(",", 2).first
      end
      @forwarded_proto = self["x-forwarded-proto"]
      if host_port = self["x-forwarded-host"]
        host_port = host_port.split(",", 2).first
        @forwarded_host, tmp = host_port.split(":", 2)
        @forwarded_port = (tmp || (@forwarded_proto == "https" ? 443 : 80)).to_i
      end
      if addrs = self["x-forwarded-for"]
        addrs = addrs.split(",").collect(&:strip)
        addrs.reject!{|ip| PrivateNetworkRegexp =~ ip }
        @forwarded_for = addrs.first
      end
    end

    # :startdoc:
  end
end
                                                                                                                                                                                  httpresponse.rb                                                                                     0100644 0001750 0001750 00000025100 12100626626 037006  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httpresponse.rb -- HTTPResponse Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpresponse.rb,v 1.45 2003/07/11 11:02:25 gotoyuzo Exp $

require 'time'
require 'webrick/httpversion'
require 'webrick/htmlutils'
require 'webrick/httputils'
require 'webrick/httpstatus'

module WEBrick
  ##
  # An HTTP response.  This is filled in by the service or do_* methods of a
  # WEBrick HTTP Servlet.

  class HTTPResponse

    ##
    # HTTP Response version

    attr_reader :http_version

    ##
    # Response status code (200)

    attr_reader :status

    ##
    # Response header

    attr_reader :header

    ##
    # Response cookies

    attr_reader :cookies

    ##
    # Response reason phrase ("OK")

    attr_accessor :reason_phrase

    ##
    # Body may be a String or IO subclass.

    attr_accessor :body

    ##
    # Request method for this response

    attr_accessor :request_method

    ##
    # Request URI for this response

    attr_accessor :request_uri

    ##
    # Request HTTP version for this response

    attr_accessor :request_http_version

    ##
    # Filename of the static file in this response.  Only used by the
    # FileHandler servlet.

    attr_accessor :filename

    ##
    # Is this a keep-alive response?

    attr_accessor :keep_alive

    ##
    # Configuration for this response

    attr_reader :config

    ##
    # Bytes sent in this response

    attr_reader :sent_size

    ##
    # Creates a new HTTP response object.  WEBrick::Config::HTTP is the
    # default configuration.

    def initialize(config)
      @config = config
      @buffer_size = config[:OutputBufferSize]
      @logger = config[:Logger]
      @header = Hash.new
      @status = HTTPStatus::RC_OK
      @reason_phrase = nil
      @http_version = HTTPVersion::convert(@config[:HTTPVersion])
      @body = ''
      @keep_alive = true
      @cookies = []
      @request_method = nil
      @request_uri = nil
      @request_http_version = @http_version  # temporary
      @chunked = false
      @filename = nil
      @sent_size = 0
    end

    ##
    # The response's HTTP status line

    def status_line
      "HTTP/#@http_version #@status #@reason_phrase #{CRLF}"
    end

    ##
    # Sets the response's status to the +status+ code

    def status=(status)
      @status = status
      @reason_phrase = HTTPStatus::reason_phrase(status)
    end

    ##
    # Retrieves the response header +field+

    def [](field)
      @header[field.downcase]
    end

    ##
    # Sets the response header +field+ to +value+

    def []=(field, value)
      @header[field.downcase] = value.to_s
    end

    ##
    # The content-length header

    def content_length
      if len = self['content-length']
        return Integer(len)
      end
    end

    ##
    # Sets the content-length header to +len+

    def content_length=(len)
      self['content-length'] = len.to_s
    end

    ##
    # The content-type header

    def content_type
      self['content-type']
    end

    ##
    # Sets the content-type header to +type+

    def content_type=(type)
      self['content-type'] = type
    end

    ##
    # Iterates over each header in the resopnse

    def each
      @header.each{|field, value|  yield(field, value) }
    end

    ##
    # Will this response body be returned using chunked transfer-encoding?

    def chunked?
      @chunked
    end

    ##
    # Enables chunked transfer encoding.

    def chunked=(val)
      @chunked = val ? true : false
    end

    ##
    # Will this response's connection be kept alive?

    def keep_alive?
      @keep_alive
    end

    ##
    # Sends the response on +socket+

    def send_response(socket) # :nodoc:
      begin
        setup_header()
        send_header(socket)
        send_body(socket)
      rescue Errno::EPIPE, Errno::ECONNRESET, Errno::ENOTCONN => ex
        @logger.debug(ex)
        @keep_alive = false
      rescue Exception => ex
        @logger.error(ex)
        @keep_alive = false
      end
    end

    ##
    # Sets up the headers for sending

    def setup_header() # :nodoc:
      @reason_phrase    ||= HTTPStatus::reason_phrase(@status)
      @header['server'] ||= @config[:ServerSoftware]
      @header['date']   ||= Time.now.httpdate

      # HTTP/0.9 features
      if @request_http_version < "1.0"
        @http_version = HTTPVersion.new("0.9")
        @keep_alive = false
      end

      # HTTP/1.0 features
      if @request_http_version < "1.1"
        if chunked?
          @chunked = false
          ver = @request_http_version.to_s
          msg = "chunked is set for an HTTP/#{ver} request. (ignored)"
          @logger.warn(msg)
        end
      end

      # Determine the message length (RFC2616 -- 4.4 Message Length)
      if @status == 304 || @status == 204 || HTTPStatus::info?(@status)
        @header.delete('content-length')
        @body = ""
      elsif chunked?
        @header["transfer-encoding"] = "chunked"
        @header.delete('content-length')
      elsif %r{^multipart/byteranges} =~ @header['content-type']
        @header.delete('content-length')
      elsif @header['content-length'].nil?
        unless @body.is_a?(IO)
          @header['content-length'] = @body ? @body.bytesize : 0
        end
      end

      # Keep-Alive connection.
      if @header['connection'] == "close"
         @keep_alive = false
      elsif keep_alive?
        if chunked? || @header['content-length'] || @status == 304 || @status == 204 || HTTPStatus.info?(@status)
          @header['connection'] = "Keep-Alive"
        else
          msg = "Could not determine content-length of response body. Set content-length of the response or set Response#chunked = true"
          @logger.warn(msg)
          @header['connection'] = "close"
          @keep_alive = false
        end
      else
        @header['connection'] = "close"
      end

      # Location is a single absoluteURI.
      if location = @header['location']
        if @request_uri
          @header['location'] = @request_uri.merge(location)
        end
      end
    end

    ##
    # Sends the headers on +socket+

    def send_header(socket) # :nodoc:
      if @http_version.major > 0
        data = status_line()
        @header.each{|key, value|
          tmp = key.gsub(/\bwww|^te$|\b\w/){ $&.upcase }
          data << "#{tmp}: #{value}" << CRLF
        }
        @cookies.each{|cookie|
          data << "Set-Cookie: " << cookie.to_s << CRLF
        }
        data << CRLF
        _write_data(socket, data)
      end
    end

    ##
    # Sends the body on +socket+

    def send_body(socket) # :nodoc:
      case @body
      when IO then send_body_io(socket)
      else send_body_string(socket)
      end
    end

    def to_s # :nodoc:
      ret = ""
      send_response(ret)
      ret
    end

    ##
    # Redirects to +url+ with a WEBrick::HTTPStatus::Redirect +status+.
    #
    # Example:
    #
    #   res.set_redirect WEBrick::HTTPStatus::TemporaryRedirect

    def set_redirect(status, url)
      @body = "<HTML><A HREF=\"#{url.to_s}\">#{url.to_s}</A>.</HTML>\n"
      @header['location'] = url.to_s
      raise status
    end

    ##
    # Creates an error page for exception +ex+ with an optional +backtrace+

    def set_error(ex, backtrace=false)
      case ex
      when HTTPStatus::Status
        @keep_alive = false if HTTPStatus::error?(ex.code)
        self.status = ex.code
      else
        @keep_alive = false
        self.status = HTTPStatus::RC_INTERNAL_SERVER_ERROR
      end
      @header['content-type'] = "text/html; charset=ISO-8859-1"

      if respond_to?(:create_error_page)
        create_error_page()
        return
      end

      if @request_uri
        host, port = @request_uri.host, @request_uri.port
      else
        host, port = @config[:ServerName], @config[:Port]
      end

      @body = ''
      @body << <<-_end_of_html_
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
  <HEAD><TITLE>#{HTMLUtils::escape(@reason_phrase)}</TITLE></HEAD>
  <BODY>
    <H1>#{HTMLUtils::escape(@reason_phrase)}</H1>
    #{HTMLUtils::escape(ex.message)}
    <HR>
      _end_of_html_

      if backtrace && $DEBUG
        @body << "backtrace of `#{HTMLUtils::escape(ex.class.to_s)}' "
        @body << "#{HTMLUtils::escape(ex.message)}"
        @body << "<PRE>"
        ex.backtrace.each{|line| @body << "\t#{line}\n"}
        @body << "</PRE><HR>"
      end

      @body << <<-_end_of_html_
    <ADDRESS>
     #{HTMLUtils::escape(@config[:ServerSoftware])} at
     #{host}:#{port}
    </ADDRESS>
  </BODY>
</HTML>
      _end_of_html_
    end

    private

    # :stopdoc:

    def send_body_io(socket)
      begin
        if @request_method == "HEAD"
          # do nothing
        elsif chunked?
          begin
            buf  = ''
            data = ''
            while true
              @body.readpartial( @buffer_size, buf ) # there is no need to clear buf?
              data << format("%x", buf.bytesize) << CRLF
              data << buf << CRLF
              _write_data(socket, data)
              data.clear
              @sent_size += buf.bytesize
            end
          rescue EOFError # do nothing
          end
          _write_data(socket, "0#{CRLF}#{CRLF}")
        else
          size = @header['content-length'].to_i
          _send_file(socket, @body, 0, size)
          @sent_size = size
        end
      ensure
        @body.close
      end
    end

    def send_body_string(socket)
      if @request_method == "HEAD"
        # do nothing
      elsif chunked?
        body ? @body.bytesize : 0
        while buf = @body[@sent_size, @buffer_size]
          break if buf.empty?
          data = ""
          data << format("%x", buf.bytesize) << CRLF
          data << buf << CRLF
          _write_data(socket, data)
          @sent_size += buf.bytesize
        end
        _write_data(socket, "0#{CRLF}#{CRLF}")
      else
        if @body && @body.bytesize > 0
          _write_data(socket, @body)
          @sent_size = @body.bytesize
        end
      end
    end

    def _send_file(output, input, offset, size)
      while offset > 0
        sz = @buffer_size < size ? @buffer_size : size
        buf = input.read(sz)
        offset -= buf.bytesize
      end

      if size == 0
        while buf = input.read(@buffer_size)
          _write_data(output, buf)
        end
      else
        while size > 0
          sz = @buffer_size < size ? @buffer_size : size
          buf = input.read(sz)
          _write_data(output, buf)
          size -= buf.bytesize
        end
      end
    end

    def _write_data(socket, data)
      socket << data
    end

    # :startdoc:
  end

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                https.rb                                                                                            0100644 0001750 0001750 00000003566 12100626626 035426  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# https.rb -- SSL/TLS enhancement for HTTPServer
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: https.rb,v 1.15 2003/07/22 19:20:42 gotoyuzo Exp $

require 'webrick/ssl'

module WEBrick
  module Config
    HTTP.update(SSL)
  end

  ##
  #--
  # Adds SSL functionality to WEBrick::HTTPRequest

  class HTTPRequest

    ##
    # HTTP request SSL cipher

    attr_reader :cipher

    ##
    # HTTP request server certificate

    attr_reader :server_cert

    ##
    # HTTP request client certificate

    attr_reader :client_cert

    # :stopdoc:

    alias orig_parse parse

    def parse(socket=nil)
      if socket.respond_to?(:cert)
        @server_cert = socket.cert || @config[:SSLCertificate]
        @client_cert = socket.peer_cert
        @client_cert_chain = socket.peer_cert_chain
        @cipher      = socket.cipher
      end
      orig_parse(socket)
    end

    alias orig_parse_uri parse_uri

    def parse_uri(str, scheme="https")
      if server_cert
        return orig_parse_uri(str, scheme)
      end
      return orig_parse_uri(str)
    end
    private :parse_uri

    alias orig_meta_vars meta_vars

    def meta_vars
      meta = orig_meta_vars
      if server_cert
        meta["HTTPS"] = "on"
        meta["SSL_SERVER_CERT"] = @server_cert.to_pem
        meta["SSL_CLIENT_CERT"] = @client_cert ? @client_cert.to_pem : ""
        if @client_cert_chain
          @client_cert_chain.each_with_index{|cert, i|
            meta["SSL_CLIENT_CERT_CHAIN_#{i}"] = cert.to_pem
          }
        end
        meta["SSL_CIPHER"] = @cipher[0]
        meta["SSL_PROTOCOL"] = @cipher[1]
        meta["SSL_CIPHER_USEKEYSIZE"] = @cipher[2].to_s
        meta["SSL_CIPHER_ALGKEYSIZE"] = @cipher[3].to_s
      end
      meta
    end

    # :startdoc:
  end
end
                                                                                                                                          httpserver.rb                                                                                       0100644 0001750 0001750 00000017301 12100626626 036462  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httpserver.rb -- HTTPServer Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpserver.rb,v 1.63 2002/10/01 17:16:32 gotoyuzo Exp $

require 'webrick/server'
require 'webrick/httputils'
require 'webrick/httpstatus'
require 'webrick/httprequest'
require 'webrick/httpresponse'
require 'webrick/httpservlet'
require 'webrick/accesslog'

module WEBrick
  class HTTPServerError < ServerError; end

  ##
  # An HTTP Server

  class HTTPServer < ::WEBrick::GenericServer
    ##
    # Creates a new HTTP server according to +config+
    #
    # An HTTP server uses the following attributes:
    #
    # :AccessLog:: An array of access logs.  See WEBrick::AccessLog
    # :BindAddress:: Local address for the server to bind to
    # :DocumentRoot:: Root path to serve files from
    # :DocumentRootOptions:: Options for the default HTTPServlet::FileHandler
    # :HTTPVersion:: The HTTP version of this server
    # :Port:: Port to listen on
    # :RequestCallback:: Called with a request and response before each
    #                    request is serviced.
    # :RequestTimeout:: Maximum time to wait between requests
    # :ServerAlias:: Array of alternate names for this server for virtual
    #                hosting
    # :ServerName:: Name for this server for virtual hosting

    def initialize(config={}, default=Config::HTTP)
      super(config, default)
      @http_version = HTTPVersion::convert(@config[:HTTPVersion])

      @mount_tab = MountTable.new
      if @config[:DocumentRoot]
        mount("/", HTTPServlet::FileHandler, @config[:DocumentRoot],
              @config[:DocumentRootOptions])
      end

      unless @config[:AccessLog]
        @config[:AccessLog] = [
          [ $stderr, AccessLog::COMMON_LOG_FORMAT ],
          [ $stderr, AccessLog::REFERER_LOG_FORMAT ]
        ]
      end

      @virtual_hosts = Array.new
    end

    ##
    # Processes requests on +sock+

    def run(sock)
      while true
        res = HTTPResponse.new(@config)
        req = HTTPRequest.new(@config)
        server = self
        begin
          timeout = @config[:RequestTimeout]
          while timeout > 0
            break if IO.select([sock], nil, nil, 0.5)
            timeout = 0 if @status != :Running
            timeout -= 0.5
          end
          raise HTTPStatus::EOFError if timeout <= 0
          raise HTTPStatus::EOFError if sock.eof?
          req.parse(sock)
          res.request_method = req.request_method
          res.request_uri = req.request_uri
          res.request_http_version = req.http_version
          res.keep_alive = req.keep_alive?
          server = lookup_server(req) || self
          if callback = server[:RequestCallback]
            callback.call(req, res)
          elsif callback = server[:RequestHandler]
            msg = ":RequestHandler is deprecated, please use :RequestCallback"
            @logger.warn(msg)
            callback.call(req, res)
          end
          server.service(req, res)
        rescue HTTPStatus::EOFError, HTTPStatus::RequestTimeout => ex
          res.set_error(ex)
        rescue HTTPStatus::Error => ex
          @logger.error(ex.message)
          res.set_error(ex)
        rescue HTTPStatus::Status => ex
          res.status = ex.code
        rescue StandardError => ex
          @logger.error(ex)
          res.set_error(ex, true)
        ensure
          if req.request_line
            if req.keep_alive? && res.keep_alive?
              req.fixup()
            end
            res.send_response(sock)
            server.access_log(@config, req, res)
          end
        end
        break if @http_version < "1.1"
        break unless req.keep_alive?
        break unless res.keep_alive?
      end
    end

    ##
    # Services +req+ and fills in +res+

    def service(req, res)
      if req.unparsed_uri == "*"
        if req.request_method == "OPTIONS"
          do_OPTIONS(req, res)
          raise HTTPStatus::OK
        end
        raise HTTPStatus::NotFound, "`#{req.unparsed_uri}' not found."
      end

      servlet, options, script_name, path_info = search_servlet(req.path)
      raise HTTPStatus::NotFound, "`#{req.path}' not found." unless servlet
      req.script_name = script_name
      req.path_info = path_info
      si = servlet.get_instance(self, *options)
      @logger.debug(format("%s is invoked.", si.class.name))
      si.service(req, res)
    end

    ##
    # The default OPTIONS request handler says GET, HEAD, POST and OPTIONS
    # requests are allowed.

    def do_OPTIONS(req, res)
      res["allow"] = "GET,HEAD,POST,OPTIONS"
    end

    ##
    # Mounts +servlet+ on +dir+ passing +options+ to the servlet at creation
    # time

    def mount(dir, servlet, *options)
      @logger.debug(sprintf("%s is mounted on %s.", servlet.inspect, dir))
      @mount_tab[dir] = [ servlet, options ]
    end

    ##
    # Mounts +proc+ or +block+ on +dir+ and calls it with a
    # WEBrick::HTTPRequest and WEBrick::HTTPResponse

    def mount_proc(dir, proc=nil, &block)
      proc ||= block
      raise HTTPServerError, "must pass a proc or block" unless proc
      mount(dir, HTTPServlet::ProcHandler.new(proc))
    end

    ##
    # Unmounts +dir+

    def unmount(dir)
      @logger.debug(sprintf("unmount %s.", dir))
      @mount_tab.delete(dir)
    end
    alias umount unmount

    ##
    # Finds a servlet for +path+

    def search_servlet(path)
      script_name, path_info = @mount_tab.scan(path)
      servlet, options = @mount_tab[script_name]
      if servlet
        [ servlet, options, script_name, path_info ]
      end
    end

    ##
    # Adds +server+ as a virtual host.

    def virtual_host(server)
      @virtual_hosts << server
      @virtual_hosts = @virtual_hosts.sort_by{|s|
        num = 0
        num -= 4 if s[:BindAddress]
        num -= 2 if s[:Port]
        num -= 1 if s[:ServerName]
        num
      }
    end

    ##
    # Finds the appropriate virtual host to handle +req+

    def lookup_server(req)
      @virtual_hosts.find{|s|
        (s[:BindAddress].nil? || req.addr[3] == s[:BindAddress]) &&
        (s[:Port].nil?        || req.port == s[:Port])           &&
        ((s[:ServerName].nil?  || req.host == s[:ServerName]) ||
         (!s[:ServerAlias].nil? && s[:ServerAlias].find{|h| h === req.host}))
      }
    end

    ##
    # Logs +req+ and +res+ in the access logs.  +config+ is used for the
    # server name.

    def access_log(config, req, res)
      param = AccessLog::setup_params(config, req, res)
      @config[:AccessLog].each{|logger, fmt|
        logger << AccessLog::format(fmt+"\n", param)
      }
    end

    ##
    # Mount table for the path a servlet is mounted on in the directory space
    # of the server.  Users of WEBrick can only access this indirectly via
    # WEBrick::HTTPServer#mount, WEBrick::HTTPServer#unmount and
    # WEBrick::HTTPServer#search_servlet

    class MountTable # :nodoc:
      def initialize
        @tab = Hash.new
        compile
      end

      def [](dir)
        dir = normalize(dir)
        @tab[dir]
      end

      def []=(dir, val)
        dir = normalize(dir)
        @tab[dir] = val
        compile
        val
      end

      def delete(dir)
        dir = normalize(dir)
        res = @tab.delete(dir)
        compile
        res
      end

      def scan(path)
        @scanner =~ path
        [ $&, $' ]
      end

      private

      def compile
        k = @tab.keys
        k.sort!
        k.reverse!
        k.collect!{|path| Regexp.escape(path) }
        @scanner = Regexp.new("^(" + k.join("|") +")(?=/|$)")
      end

      def normalize(dir)
        ret = dir ? dir.dup : ""
        ret.sub!(%r|/+$|, "")
        ret
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                               httpservlet/                                                                                        0040755 0001750 0001750 00000000000 12612224746 036321  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   abstract.rb                                                                                         0100644 0001750 0001750 00000010257 12072060730 040442  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpservlet                                       #
# httpservlet.rb -- HTTPServlet Module
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: abstract.rb,v 1.24 2003/07/11 11:16:46 gotoyuzo Exp $

require 'thread'

require 'webrick/htmlutils'
require 'webrick/httputils'
require 'webrick/httpstatus'

module WEBrick
  module HTTPServlet
    class HTTPServletError < StandardError; end

    ##
    # AbstractServlet allows HTTP server modules to be reused across multiple
    # servers and allows encapsulation of functionality.
    #
    # By default a servlet will respond to GET, HEAD (through an alias to GET)
    # and OPTIONS requests.
    #
    # By default a new servlet is initialized for every request.  A servlet
    # instance can be reused by overriding ::get_instance in the
    # AbstractServlet subclass.
    #
    # == A Simple Servlet
    #
    #  class Simple < WEBrick::HTTPServlet::AbstractServlet
    #    def do_GET request, response
    #      status, content_type, body = do_stuff_with request
    #
    #      response.status = status
    #      response['Content-Type'] = content_type
    #      response.body = body
    #    end
    #
    #    def do_stuff_with request
    #      return 200, 'text/plain', 'you got a page'
    #    end
    #  end
    #
    # This servlet can be mounted on a server at a given path:
    #
    #   server.mount '/simple', Simple
    #
    # == Servlet Configuration
    #
    # Servlets can be configured via initialize.  The first argument is the
    # HTTP server the servlet is being initialized for.
    #
    #  class Configurable < Simple
    #    def initialize server, color, size
    #      super server
    #      @color = color
    #      @size = size
    #    end
    #
    #    def do_stuff_with request
    #      content = "<p " \
    #                %q{style="color: #{@color}; font-size: #{@size}"} \
    #                ">Hello, World!"
    #
    #      return 200, "text/html", content
    #    end
    #  end
    #
    # This servlet must be provided two arguments at mount time:
    #
    #   server.mount '/configurable', Configurable, 'red', '2em'

    class AbstractServlet

      ##
      # Factory for servlet instances that will handle a request from +server+
      # using +options+ from the mount point.  By default a new servlet
      # instance is created for every call.

      def self.get_instance(server, *options)
        self.new(server, *options)
      end

      ##
      # Initializes a new servlet for +server+ using +options+ which are
      # stored as-is in +@options+.  +@logger+ is also provided.

      def initialize(server, *options)
        @server = @config = server
        @logger = @server[:Logger]
        @options = options
      end

      ##
      # Dispatches to a +do_+ method based on +req+ if such a method is
      # available.  (+do_GET+ for a GET request).  Raises a MethodNotAllowed
      # exception if the method is not implemented.

      def service(req, res)
        method_name = "do_" + req.request_method.gsub(/-/, "_")
        if respond_to?(method_name)
          __send__(method_name, req, res)
        else
          raise HTTPStatus::MethodNotAllowed,
                "unsupported method `#{req.request_method}'."
        end
      end

      ##
      # Raises a NotFound exception

      def do_GET(req, res)
        raise HTTPStatus::NotFound, "not found."
      end

      ##
      # Dispatches to do_GET

      def do_HEAD(req, res)
        do_GET(req, res)
      end

      ##
      # Returns the allowed HTTP request methods

      def do_OPTIONS(req, res)
        m = self.methods.grep(/\Ado_([A-Z]+)\z/) {$1}
        m.sort!
        res["allow"] = m.join(",")
      end

      private

      ##
      # Redirects to a path ending in /

      def redirect_to_directory_uri(req, res)
        if req.path[-1] != ?/
          location = WEBrick::HTTPUtils.escape_path(req.path + "/")
          if req.query_string && req.query_string.bytesize > 0
            location << "?" << req.query_string
          end
          res.set_redirect(HTTPStatus::MovedPermanently, location)
        end
      end
    end

  end
end
                                                                                                                                                                                                                                                                                                                                                 cgi_runner.rb                                                                                       0100644 0001750 0001750 00000001716 11466062225 041001  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpservlet                                       #
# cgi_runner.rb -- CGI launcher.
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000 TAKAHASHI Masayoshi, GOTOU YUUZOU
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: cgi_runner.rb,v 1.9 2002/09/25 11:33:15 gotoyuzo Exp $

def sysread(io, size)
  buf = ""
  while size > 0
    tmp = io.sysread(size)
    buf << tmp
    size -= tmp.bytesize
  end
  return buf
end

STDIN.binmode

len = sysread(STDIN, 8).to_i
out = sysread(STDIN, len)
STDOUT.reopen(open(out, "w"))

len = sysread(STDIN, 8).to_i
err = sysread(STDIN, len)
STDERR.reopen(open(err, "w"))

len  = sysread(STDIN, 8).to_i
dump = sysread(STDIN, len)
hash = Marshal.restore(dump)
ENV.keys.each{|name| ENV.delete(name) }
hash.each{|k, v| ENV[k] = v if v }

dir = File::dirname(ENV["SCRIPT_FILENAME"])
Dir::chdir dir

if ARGV[0]
  argv = ARGV.dup
  argv << ENV["SCRIPT_FILENAME"]
  exec(*argv)
  # NOTREACHED
end
exec ENV["SCRIPT_FILENAME"]
                                                  cgihandler.rb                                                                                       0100644 0001750 0001750 00000007150 12100626626 040741  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpservlet                                       #
# cgihandler.rb -- CGIHandler Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: cgihandler.rb,v 1.27 2003/03/21 19:56:01 gotoyuzo Exp $

require 'rbconfig'
require 'tempfile'
require 'webrick/config'
require 'webrick/httpservlet/abstract'

module WEBrick
  module HTTPServlet

    ##
    # Servlet for handling CGI scripts
    #
    # Example:
    #
    #  server.mount('/cgi/my_script', WEBrick::HTTPServlet::CGIHandler,
    #               '/path/to/my_script')

    class CGIHandler < AbstractServlet
      Ruby = RbConfig.ruby # :nodoc:
      CGIRunner = "\"#{Ruby}\" \"#{WEBrick::Config::LIBDIR}/httpservlet/cgi_runner.rb\"" # :nodoc:

      ##
      # Creates a new CGI script servlet for the script at +name+

      def initialize(server, name)
        super(server, name)
        @script_filename = name
        @tempdir = server[:TempDir]
        @cgicmd = "#{CGIRunner} #{server[:CGIInterpreter]}"
      end

      # :stopdoc:

      def do_GET(req, res)
        data = nil
        status = -1

        cgi_in = IO::popen(@cgicmd, "wb")
        cgi_out = Tempfile.new("webrick.cgiout.", @tempdir, mode: IO::BINARY)
        cgi_out.set_encoding("ASCII-8BIT")
        cgi_err = Tempfile.new("webrick.cgierr.", @tempdir, mode: IO::BINARY)
        cgi_err.set_encoding("ASCII-8BIT")
        begin
          cgi_in.sync = true
          meta = req.meta_vars
          meta["SCRIPT_FILENAME"] = @script_filename
          meta["PATH"] = @config[:CGIPathEnv]
          if /mswin|bccwin|mingw/ =~ RUBY_PLATFORM
            meta["SystemRoot"] = ENV["SystemRoot"]
          end
          dump = Marshal.dump(meta)

          cgi_in.write("%8d" % cgi_out.path.bytesize)
          cgi_in.write(cgi_out.path)
          cgi_in.write("%8d" % cgi_err.path.bytesize)
          cgi_in.write(cgi_err.path)
          cgi_in.write("%8d" % dump.bytesize)
          cgi_in.write(dump)

          if req.body and req.body.bytesize > 0
            cgi_in.write(req.body)
          end
        ensure
          cgi_in.close
          status = $?.exitstatus
          sleep 0.1 if /mswin|bccwin|mingw/ =~ RUBY_PLATFORM
          data = cgi_out.read
          cgi_out.close(true)
          if errmsg = cgi_err.read
            if errmsg.bytesize > 0
              @logger.error("CGIHandler: #{@script_filename}:\n" + errmsg)
            end
          end
          cgi_err.close(true)
        end

        if status != 0
          @logger.error("CGIHandler: #{@script_filename} exit with #{status}")
        end

        data = "" unless data
        raw_header, body = data.split(/^[\xd\xa]+/, 2)
        raise HTTPStatus::InternalServerError,
          "Premature end of script headers: #{@script_filename}" if body.nil?

        begin
          header = HTTPUtils::parse_header(raw_header)
          if /^(\d+)/ =~ header['status'][0]
            res.status = $1.to_i
            header.delete('status')
          end
          if header.has_key?('location')
            # RFC 3875 6.2.3, 6.2.4
            res.status = 302 unless (300...400) === res.status
          end
          if header.has_key?('set-cookie')
            header['set-cookie'].each{|k|
              res.cookies << Cookie.parse_set_cookie(k)
            }
            header.delete('set-cookie')
          end
          header.each{|key, val| res[key] = val.join(", ") }
        rescue => ex
          raise HTTPStatus::InternalServerError, ex.message
        end
        res.body = body
      end
      alias do_POST do_GET

      # :startdoc:
    end

  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                        erbhandler.rb                                                                                       0100644 0001750 0001750 00000004420 11576313233 040747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpservlet                                       #
# erbhandler.rb -- ERBHandler Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: erbhandler.rb,v 1.25 2003/02/24 19:25:31 gotoyuzo Exp $

require 'webrick/httpservlet/abstract.rb'

require 'erb'

module WEBrick
  module HTTPServlet

    ##
    # ERBHandler evaluates an ERB file and returns the result.  This handler
    # is automatically used if there are .rhtml files in a directory served by
    # the FileHandler.
    #
    # ERBHandler supports GET and POST methods.
    #
    # The ERB file is evaluated with the local variables +servlet_request+ and
    # +servlet_response+ which are a WEBrick::HTTPRequest and
    # WEBrick::HTTPResponse respectively.
    #
    # Example .rhtml file:
    #
    #   Request to <%= servlet_request.request_uri %>
    #
    #   Query params <%= servlet_request.query.inspect %>

    class ERBHandler < AbstractServlet

      ##
      # Creates a new ERBHandler on +server+ that will evaluate and serve the
      # ERB file +name+

      def initialize(server, name)
        super(server, name)
        @script_filename = name
      end

      ##
      # Handles GET requests

      def do_GET(req, res)
        unless defined?(ERB)
          @logger.warn "#{self.class}: ERB not defined."
          raise HTTPStatus::Forbidden, "ERBHandler cannot work."
        end
        begin
          data = open(@script_filename){|io| io.read }
          res.body = evaluate(ERB.new(data), req, res)
          res['content-type'] ||=
            HTTPUtils::mime_type(@script_filename, @config[:MimeTypes])
        rescue StandardError => ex
          raise
        rescue Exception => ex
          @logger.error(ex)
          raise HTTPStatus::InternalServerError, ex.message
        end
      end

      ##
      # Handles POST requests

      alias do_POST do_GET

      private

      ##
      # Evaluates +erb+ providing +servlet_request+ and +servlet_response+ as
      # local variables.

      def evaluate(erb, servlet_request, servlet_response)
        Module.new.module_eval{
          servlet_request.meta_vars
          servlet_request.query
          erb.result(binding)
        }
      end
    end
  end
end
                                                                                                                                                                                                                                                filehandler.rb                                                                                      0100644 0001750 0001750 00000036374 12100626626 041130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpservlet                                       #
# filehandler.rb -- FileHandler Module
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: filehandler.rb,v 1.44 2003/06/07 01:34:51 gotoyuzo Exp $

require 'thread'
require 'time'

require 'webrick/htmlutils'
require 'webrick/httputils'
require 'webrick/httpstatus'

module WEBrick
  module HTTPServlet

    ##
    # Servlet for serving a single file.  You probably want to use the
    # FileHandler servlet instead as it handles directories and fancy indexes.
    #
    # Example:
    #
    #   server.mount('/my_page.txt', WEBrick::HTTPServlet::DefaultFileHandler,
    #                '/path/to/my_page.txt')
    #
    # This servlet handles If-Modified-Since and Range requests.

    class DefaultFileHandler < AbstractServlet

      ##
      # Creates a DefaultFileHandler instance for the file at +local_path+.

      def initialize(server, local_path)
        super(server, local_path)
        @local_path = local_path
      end

      # :stopdoc:

      def do_GET(req, res)
        st = File::stat(@local_path)
        mtime = st.mtime
        res['etag'] = sprintf("%x-%x-%x", st.ino, st.size, st.mtime.to_i)

        if not_modified?(req, res, mtime, res['etag'])
          res.body = ''
          raise HTTPStatus::NotModified
        elsif req['range']
          make_partial_content(req, res, @local_path, st.size)
          raise HTTPStatus::PartialContent
        else
          mtype = HTTPUtils::mime_type(@local_path, @config[:MimeTypes])
          res['content-type'] = mtype
          res['content-length'] = st.size
          res['last-modified'] = mtime.httpdate
          res.body = open(@local_path, "rb")
        end
      end

      def not_modified?(req, res, mtime, etag)
        if ir = req['if-range']
          begin
            if Time.httpdate(ir) >= mtime
              return true
            end
          rescue
            if HTTPUtils::split_header_value(ir).member?(res['etag'])
              return true
            end
          end
        end

        if (ims = req['if-modified-since']) && Time.parse(ims) >= mtime
          return true
        end

        if (inm = req['if-none-match']) &&
           HTTPUtils::split_header_value(inm).member?(res['etag'])
          return true
        end

        return false
      end

      def make_partial_content(req, res, filename, filesize)
        mtype = HTTPUtils::mime_type(filename, @config[:MimeTypes])
        unless ranges = HTTPUtils::parse_range_header(req['range'])
          raise HTTPStatus::BadRequest,
            "Unrecognized range-spec: \"#{req['range']}\""
        end
        open(filename, "rb"){|io|
          if ranges.size > 1
            time = Time.now
            boundary = "#{time.sec}_#{time.usec}_#{Process::pid}"
            body = ''
            ranges.each{|range|
              first, last = prepare_range(range, filesize)
              next if first < 0
              io.pos = first
              content = io.read(last-first+1)
              body << "--" << boundary << CRLF
              body << "Content-Type: #{mtype}" << CRLF
              body << "Content-Range: bytes #{first}-#{last}/#{filesize}" << CRLF
              body << CRLF
              body << content
              body << CRLF
            }
            raise HTTPStatus::RequestRangeNotSatisfiable if body.empty?
            body << "--" << boundary << "--" << CRLF
            res["content-type"] = "multipart/byteranges; boundary=#{boundary}"
            res.body = body
          elsif range = ranges[0]
            first, last = prepare_range(range, filesize)
            raise HTTPStatus::RequestRangeNotSatisfiable if first < 0
            if last == filesize - 1
              content = io.dup
              content.pos = first
            else
              io.pos = first
              content = io.read(last-first+1)
            end
            res['content-type'] = mtype
            res['content-range'] = "bytes #{first}-#{last}/#{filesize}"
            res['content-length'] = last - first + 1
            res.body = content
          else
            raise HTTPStatus::BadRequest
          end
        }
      end

      def prepare_range(range, filesize)
        first = range.first < 0 ? filesize + range.first : range.first
        return -1, -1 if first < 0 || first >= filesize
        last = range.last < 0 ? filesize + range.last : range.last
        last = filesize - 1 if last >= filesize
        return first, last
      end

      # :startdoc:
    end

    ##
    # Serves a directory including fancy indexing and a variety of other
    # options.
    #
    # Example:
    #
    #   server.mount '/assets', WEBrick::FileHandler, '/path/to/assets'

    class FileHandler < AbstractServlet
      HandlerTable = Hash.new # :nodoc:

      ##
      # Allow custom handling of requests for files with +suffix+ by class
      # +handler+

      def self.add_handler(suffix, handler)
        HandlerTable[suffix] = handler
      end

      ##
      # Remove custom handling of requests for files with +suffix+

      def self.remove_handler(suffix)
        HandlerTable.delete(suffix)
      end

      ##
      # Creates a FileHandler servlet on +server+ that serves files starting
      # at directory +root+
      #
      # +options+ may be a Hash containing keys from
      # WEBrick::Config::FileHandler or +true+ or +false+.
      #
      # If +options+ is true or false then +:FancyIndexing+ is enabled or
      # disabled respectively.

      def initialize(server, root, options={}, default=Config::FileHandler)
        @config = server.config
        @logger = @config[:Logger]
        @root = File.expand_path(root)
        if options == true || options == false
          options = { :FancyIndexing => options }
        end
        @options = default.dup.update(options)
      end

      # :stopdoc:

      def service(req, res)
        # if this class is mounted on "/" and /~username is requested.
        # we're going to override path informations before invoking service.
        if defined?(Etc) && @options[:UserDir] && req.script_name.empty?
          if %r|^(/~([^/]+))| =~ req.path_info
            script_name, user = $1, $2
            path_info = $'
            begin
              passwd = Etc::getpwnam(user)
              @root = File::join(passwd.dir, @options[:UserDir])
              req.script_name = script_name
              req.path_info = path_info
            rescue
              @logger.debug "#{self.class}#do_GET: getpwnam(#{user}) failed"
            end
          end
        end
        prevent_directory_traversal(req, res)
        super(req, res)
      end

      def do_GET(req, res)
        unless exec_handler(req, res)
          set_dir_list(req, res)
        end
      end

      def do_POST(req, res)
        unless exec_handler(req, res)
          raise HTTPStatus::NotFound, "`#{req.path}' not found."
        end
      end

      def do_OPTIONS(req, res)
        unless exec_handler(req, res)
          super(req, res)
        end
      end

      # ToDo
      # RFC2518: HTTP Extensions for Distributed Authoring -- WEBDAV
      #
      # PROPFIND PROPPATCH MKCOL DELETE PUT COPY MOVE
      # LOCK UNLOCK

      # RFC3253: Versioning Extensions to WebDAV
      #          (Web Distributed Authoring and Versioning)
      #
      # VERSION-CONTROL REPORT CHECKOUT CHECK_IN UNCHECKOUT
      # MKWORKSPACE UPDATE LABEL MERGE ACTIVITY

      private

      def trailing_pathsep?(path)
        # check for trailing path separator:
        #   File.dirname("/aaaa/bbbb/")      #=> "/aaaa")
        #   File.dirname("/aaaa/bbbb/x")     #=> "/aaaa/bbbb")
        #   File.dirname("/aaaa/bbbb")       #=> "/aaaa")
        #   File.dirname("/aaaa/bbbbx")      #=> "/aaaa")
        return File.dirname(path) != File.dirname(path+"x")
      end

      def prevent_directory_traversal(req, res)
        # Preventing directory traversal on Windows platforms;
        # Backslashes (0x5c) in path_info are not interpreted as special
        # character in URI notation. So the value of path_info should be
        # normalize before accessing to the filesystem.

        # dirty hack for filesystem encoding; in nature, File.expand_path
        # should not be used for path normalization.  [Bug #3345]
        path = req.path_info.dup.force_encoding(Encoding.find("filesystem"))
        if trailing_pathsep?(req.path_info)
          # File.expand_path removes the trailing path separator.
          # Adding a character is a workaround to save it.
          #  File.expand_path("/aaa/")        #=> "/aaa"
          #  File.expand_path("/aaa/" + "x")  #=> "/aaa/x"
          expanded = File.expand_path(path + "x")
          expanded.chop!  # remove trailing "x"
        else
          expanded = File.expand_path(path)
        end
        expanded.force_encoding(req.path_info.encoding)
        req.path_info = expanded
      end

      def exec_handler(req, res)
        raise HTTPStatus::NotFound, "`#{req.path}' not found" unless @root
        if set_filename(req, res)
          handler = get_handler(req, res)
          call_callback(:HandlerCallback, req, res)
          h = handler.get_instance(@config, res.filename)
          h.service(req, res)
          return true
        end
        call_callback(:HandlerCallback, req, res)
        return false
      end

      def get_handler(req, res)
        suffix1 = (/\.(\w+)\z/ =~ res.filename) && $1.downcase
        if /\.(\w+)\.([\w\-]+)\z/ =~ res.filename
          if @options[:AcceptableLanguages].include?($2.downcase)
            suffix2 = $1.downcase
          end
        end
        handler_table = @options[:HandlerTable]
        return handler_table[suffix1] || handler_table[suffix2] ||
               HandlerTable[suffix1] || HandlerTable[suffix2] ||
               DefaultFileHandler
      end

      def set_filename(req, res)
        res.filename = @root.dup
        path_info = req.path_info.scan(%r|/[^/]*|)

        path_info.unshift("")  # dummy for checking @root dir
        while base = path_info.first
          break if base == "/"
          break unless File.directory?(File.expand_path(res.filename + base))
          shift_path_info(req, res, path_info)
          call_callback(:DirectoryCallback, req, res)
        end

        if base = path_info.first
          if base == "/"
            if file = search_index_file(req, res)
              shift_path_info(req, res, path_info, file)
              call_callback(:FileCallback, req, res)
              return true
            end
            shift_path_info(req, res, path_info)
          elsif file = search_file(req, res, base)
            shift_path_info(req, res, path_info, file)
            call_callback(:FileCallback, req, res)
            return true
          else
            raise HTTPStatus::NotFound, "`#{req.path}' not found."
          end
        end

        return false
      end

      def check_filename(req, res, name)
        if nondisclosure_name?(name) || windows_ambiguous_name?(name)
          @logger.warn("the request refers nondisclosure name `#{name}'.")
          raise HTTPStatus::NotFound, "`#{req.path}' not found."
        end
      end

      def shift_path_info(req, res, path_info, base=nil)
        tmp = path_info.shift
        base = base || tmp
        req.path_info = path_info.join
        req.script_name << base
        res.filename = File.expand_path(res.filename + base)
        check_filename(req, res, File.basename(res.filename))
      end

      def search_index_file(req, res)
        @config[:DirectoryIndex].each{|index|
          if file = search_file(req, res, "/"+index)
            return file
          end
        }
        return nil
      end

      def search_file(req, res, basename)
        langs = @options[:AcceptableLanguages]
        path = res.filename + basename
        if File.file?(path)
          return basename
        elsif langs.size > 0
          req.accept_language.each{|lang|
            path_with_lang = path + ".#{lang}"
            if langs.member?(lang) && File.file?(path_with_lang)
              return basename + ".#{lang}"
            end
          }
          (langs - req.accept_language).each{|lang|
            path_with_lang = path + ".#{lang}"
            if File.file?(path_with_lang)
              return basename + ".#{lang}"
            end
          }
        end
        return nil
      end

      def call_callback(callback_name, req, res)
        if cb = @options[callback_name]
          cb.call(req, res)
        end
      end

      def windows_ambiguous_name?(name)
        return true if /[. ]+\z/ =~ name
        return true if /::\$DATA\z/ =~ name
        return false
      end

      def nondisclosure_name?(name)
        @options[:NondisclosureName].each{|pattern|
          if File.fnmatch(pattern, name, File::FNM_CASEFOLD)
            return true
          end
        }
        return false
      end

      def set_dir_list(req, res)
        redirect_to_directory_uri(req, res)
        unless @options[:FancyIndexing]
          raise HTTPStatus::Forbidden, "no access permission to `#{req.path}'"
        end
        local_path = res.filename
        list = Dir::entries(local_path).collect{|name|
          next if name == "." || name == ".."
          next if nondisclosure_name?(name)
          next if windows_ambiguous_name?(name)
          st = (File::stat(File.join(local_path, name)) rescue nil)
          if st.nil?
            [ name, nil, -1 ]
          elsif st.directory?
            [ name + "/", st.mtime, -1 ]
          else
            [ name, st.mtime, st.size ]
          end
        }
        list.compact!

        if    d0 = req.query["N"]; idx = 0
        elsif d0 = req.query["M"]; idx = 1
        elsif d0 = req.query["S"]; idx = 2
        else  d0 = "A"           ; idx = 0
        end
        d1 = (d0 == "A") ? "D" : "A"

        if d0 == "A"
          list.sort!{|a,b| a[idx] <=> b[idx] }
        else
          list.sort!{|a,b| b[idx] <=> a[idx] }
        end

        res['content-type'] = "text/html"

        res.body = <<-_end_of_html_
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
  <HEAD><TITLE>Index of #{HTMLUtils::escape(req.path)}</TITLE></HEAD>
  <BODY>
    <H1>Index of #{HTMLUtils::escape(req.path)}</H1>
        _end_of_html_

        res.body << "<PRE>\n"
        res.body << " <A HREF=\"?N=#{d1}\">Name</A>                          "
        res.body << "<A HREF=\"?M=#{d1}\">Last modified</A>         "
        res.body << "<A HREF=\"?S=#{d1}\">Size</A>\n"
        res.body << "<HR>\n"

        list.unshift [ "..", File::mtime(local_path+"/.."), -1 ]
        list.each{ |name, time, size|
          if name == ".."
            dname = "Parent Directory"
          elsif name.bytesize > 25
            dname = name.sub(/^(.{23})(?:.*)/, '\1..')
          else
            dname = name
          end
          s =  " <A HREF=\"#{HTTPUtils::escape(name)}\">#{HTMLUtils::escape(dname)}</A>"
          s << " " * (30 - dname.bytesize)
          s << (time ? time.strftime("%Y/%m/%d %H:%M      ") : " " * 22)
          s << (size >= 0 ? size.to_s : "-") << "\n"
          res.body << s
        }
        res.body << "</PRE><HR>"

        res.body << <<-_end_of_html_
    <ADDRESS>
     #{HTMLUtils::escape(@config[:ServerSoftware])}<BR>
     at #{req.host}:#{req.port}
    </ADDRESS>
  </BODY>
</HTML>
        _end_of_html_
      end

      # :startdoc:
    end
  end
end
                                                                                                                                                                                                                                                                    prochandler.rb                                                                                      0100644 0001750 0001750 00000002013 12100626626 041133  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick/httpservlet                                       #
# prochandler.rb -- ProcHandler Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: prochandler.rb,v 1.7 2002/09/21 12:23:42 gotoyuzo Exp $

require 'webrick/httpservlet/abstract.rb'

module WEBrick
  module HTTPServlet

    ##
    # Mounts a proc at a path that accepts a request and response.
    #
    # Instead of mounting this servlet with WEBrick::HTTPServer#mount use
    # WEBrick::HTTPServer#mount_proc:
    #
    #   server.mount_proc '/' do |req, res|
    #     res.body = 'it worked!'
    #     res.status = 200
    #   end

    class ProcHandler < AbstractServlet
      # :stopdoc:
      def get_instance(server, *options)
        self
      end

      def initialize(proc)
        @proc = proc
      end

      def do_GET(request, response)
        @proc.call(request, response)
      end

      alias do_POST do_GET
      # :startdoc:
    end

  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     httpservlet.rb                                                                                      0100644 0001750 0001750 00000001235 11261354723 036642  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httpservlet.rb -- HTTPServlet Utility File
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpservlet.rb,v 1.21 2003/02/23 12:24:46 gotoyuzo Exp $

require 'webrick/httpservlet/abstract'
require 'webrick/httpservlet/filehandler'
require 'webrick/httpservlet/cgihandler'
require 'webrick/httpservlet/erbhandler'
require 'webrick/httpservlet/prochandler'

module WEBrick
  module HTTPServlet
    FileHandler.add_handler("cgi", CGIHandler)
    FileHandler.add_handler("rhtml", ERBHandler)
  end
end
                                                                                                                                                                                                                                                                                                                                                                   httpstatus.rb                                                                                       0100644 0001750 0001750 00000012415 12014611612 036471  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #--
# httpstatus.rb -- HTTPStatus Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpstatus.rb,v 1.11 2003/03/24 20:18:55 gotoyuzo Exp $

module WEBrick

  ##
  # This module is used to manager HTTP status codes.
  #
  # See http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html for more
  # information.
  module HTTPStatus

    ##
    # Root of the HTTP status class hierarchy
    class Status < StandardError
      def initialize(*args) # :nodoc:
        args[0] = AccessLog.escape(args[0]) unless args.empty?
        super(*args)
      end
      class << self
        attr_reader :code, :reason_phrase # :nodoc:
      end

      # Returns the HTTP status code
      def code() self::class::code end

      # Returns the HTTP status description
      def reason_phrase() self::class::reason_phrase end

      alias to_i code # :nodoc:
    end

    # Root of the HTTP info statuses
    class Info        < Status; end
    # Root of the HTTP sucess statuses
    class Success     < Status; end
    # Root of the HTTP redirect statuses
    class Redirect    < Status; end
    # Root of the HTTP error statuses
    class Error       < Status; end
    # Root of the HTTP client error statuses
    class ClientError < Error; end
    # Root of the HTTP server error statuses
    class ServerError < Error; end

    class EOFError < StandardError; end

    # HTTP status codes and descriptions
    StatusMessage = { # :nodoc:
      100 => 'Continue',
      101 => 'Switching Protocols',
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',
      423 => 'Locked',
      424 => 'Failed Dependency',
      426 => 'Upgrade Required',
      428 => 'Precondition Required',
      429 => 'Too Many Requests',
      431 => 'Request Header Fields Too Large',
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      507 => 'Insufficient Storage',
      511 => 'Network Authentication Required',
    }

    # Maps a status code to the corresponding Status class
    CodeToError = {} # :nodoc:

    # Creates a status or error class for each status code and
    # populates the CodeToError map.
    StatusMessage.each{|code, message|
      message.freeze
      var_name = message.gsub(/[ \-]/,'_').upcase
      err_name = message.gsub(/[ \-]/,'')

      case code
      when 100...200; parent = Info
      when 200...300; parent = Success
      when 300...400; parent = Redirect
      when 400...500; parent = ClientError
      when 500...600; parent = ServerError
      end

      const_set("RC_#{var_name}", code)
      err_class = Class.new(parent)
      err_class.instance_variable_set(:@code, code)
      err_class.instance_variable_set(:@reason_phrase, message)
      const_set(err_name, err_class)
      CodeToError[code] = err_class
    }

    ##
    # Returns the description corresponding to the HTTP status +code+
    #
    #   WEBrick::HTTPStatus.reason_phrase 404
    #   => "Not Found"
    def reason_phrase(code)
      StatusMessage[code.to_i]
    end

    ##
    # Is +code+ an informational status?
    def info?(code)
      code.to_i >= 100 and code.to_i < 200
    end

    ##
    # Is +code+ a successful status?
    def success?(code)
      code.to_i >= 200 and code.to_i < 300
    end

    ##
    # Is +code+ a redirection status?
    def redirect?(code)
      code.to_i >= 300 and code.to_i < 400
    end

    ##
    # Is +code+ an error status?
    def error?(code)
      code.to_i >= 400 and code.to_i < 600
    end

    ##
    # Is +code+ a client error status?
    def client_error?(code)
      code.to_i >= 400 and code.to_i < 500
    end

    ##
    # Is +code+ a server error status?
    def server_error?(code)
      code.to_i >= 500 and code.to_i < 600
    end

    ##
    # Returns the status class corresponding to +code+
    #
    #   WEBrick::HTTPStatus[302]
    #   => WEBrick::HTTPStatus::NotFound
    #
    def self.[](code)
      CodeToError[code]
    end

    module_function :reason_phrase
    module_function :info?, :success?, :redirect?, :error?
    module_function :client_error?, :server_error?
  end
end
                                                                                                                                                                                                                                                   httputils.rb                                                                                        0100644 0001750 0001750 00000031323 12300166641 036312  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# httputils.rb -- HTTPUtils Module
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httputils.rb,v 1.34 2003/06/05 21:34:08 gotoyuzo Exp $

require 'socket'
require 'tempfile'

module WEBrick
  CR   = "\x0d"     # :nodoc:
  LF   = "\x0a"     # :nodoc:
  CRLF = "\x0d\x0a" # :nodoc:

  ##
  # HTTPUtils provides utility methods for working with the HTTP protocol.
  #
  # This module is generally used internally by WEBrick

  module HTTPUtils

    ##
    # Normalizes a request path.  Raises an exception if the path cannot be
    # normalized.

    def normalize_path(path)
      raise "abnormal path `#{path}'" if path[0] != ?/
      ret = path.dup

      ret.gsub!(%r{/+}o, '/')                    # //      => /
      while ret.sub!(%r'/\.(?:/|\Z)', '/'); end  # /.      => /
      while ret.sub!(%r'/(?!\.\./)[^/]+/\.\.(?:/|\Z)', '/'); end # /foo/.. => /foo

      raise "abnormal path `#{path}'" if %r{/\.\.(/|\Z)} =~ ret
      ret
    end
    module_function :normalize_path

    ##
    # Default mime types

    DefaultMimeTypes = {
      "ai"    => "application/postscript",
      "asc"   => "text/plain",
      "avi"   => "video/x-msvideo",
      "bin"   => "application/octet-stream",
      "bmp"   => "image/bmp",
      "class" => "application/octet-stream",
      "cer"   => "application/pkix-cert",
      "crl"   => "application/pkix-crl",
      "crt"   => "application/x-x509-ca-cert",
     #"crl"   => "application/x-pkcs7-crl",
      "css"   => "text/css",
      "dms"   => "application/octet-stream",
      "doc"   => "application/msword",
      "dvi"   => "application/x-dvi",
      "eps"   => "application/postscript",
      "etx"   => "text/x-setext",
      "exe"   => "application/octet-stream",
      "gif"   => "image/gif",
      "htm"   => "text/html",
      "html"  => "text/html",
      "jpe"   => "image/jpeg",
      "jpeg"  => "image/jpeg",
      "jpg"   => "image/jpeg",
      "js"    => "application/javascript",
      "lha"   => "application/octet-stream",
      "lzh"   => "application/octet-stream",
      "mov"   => "video/quicktime",
      "mpe"   => "video/mpeg",
      "mpeg"  => "video/mpeg",
      "mpg"   => "video/mpeg",
      "pbm"   => "image/x-portable-bitmap",
      "pdf"   => "application/pdf",
      "pgm"   => "image/x-portable-graymap",
      "png"   => "image/png",
      "pnm"   => "image/x-portable-anymap",
      "ppm"   => "image/x-portable-pixmap",
      "ppt"   => "application/vnd.ms-powerpoint",
      "ps"    => "application/postscript",
      "qt"    => "video/quicktime",
      "ras"   => "image/x-cmu-raster",
      "rb"    => "text/plain",
      "rd"    => "text/plain",
      "rtf"   => "application/rtf",
      "sgm"   => "text/sgml",
      "sgml"  => "text/sgml",
      "svg"   => "image/svg+xml",
      "tif"   => "image/tiff",
      "tiff"  => "image/tiff",
      "txt"   => "text/plain",
      "xbm"   => "image/x-xbitmap",
      "xhtml" => "text/html",
      "xls"   => "application/vnd.ms-excel",
      "xml"   => "text/xml",
      "xpm"   => "image/x-xpixmap",
      "xwd"   => "image/x-xwindowdump",
      "zip"   => "application/zip",
    }

    ##
    # Loads Apache-compatible mime.types in +file+.

    def load_mime_types(file)
      open(file){ |io|
        hash = Hash.new
        io.each{ |line|
          next if /^#/ =~ line
          line.chomp!
          mimetype, ext0 = line.split(/\s+/, 2)
          next unless ext0
          next if ext0.empty?
          ext0.split(/\s+/).each{ |ext| hash[ext] = mimetype }
        }
        hash
      }
    end
    module_function :load_mime_types

    ##
    # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
    # mime type was found application/octet-stream is returned.

    def mime_type(filename, mime_tab)
      suffix1 = (/\.(\w+)$/ =~ filename && $1.downcase)
      suffix2 = (/\.(\w+)\.[\w\-]+$/ =~ filename && $1.downcase)
      mime_tab[suffix1] || mime_tab[suffix2] || "application/octet-stream"
    end
    module_function :mime_type

    ##
    # Parses an HTTP header +raw+ into a hash of header fields with an Array
    # of values.

    def parse_header(raw)
      header = Hash.new([].freeze)
      field = nil
      raw.each_line{|line|
        case line
        when /^([A-Za-z0-9!\#$%&'*+\-.^_`|~]+):\s*(.*?)\s*\z/om
          field, value = $1, $2
          field.downcase!
          header[field] = [] unless header.has_key?(field)
          header[field] << value
        when /^\s+(.*?)\s*\z/om
          value = $1
          unless field
            raise HTTPStatus::BadRequest, "bad header '#{line}'."
          end
          header[field][-1] << " " << value
        else
          raise HTTPStatus::BadRequest, "bad header '#{line}'."
        end
      }
      header.each{|key, values|
        values.each{|value|
          value.strip!
          value.gsub!(/\s+/, " ")
        }
      }
      header
    end
    module_function :parse_header

    ##
    # Splits a header value +str+ according to HTTP specification.

    def split_header_value(str)
      str.scan(%r'\G((?:"(?:\\.|[^"])+?"|[^",]+)+)
                    (?:,\s*|\Z)'xn).flatten
    end
    module_function :split_header_value

    ##
    # Parses a Range header value +ranges_specifier+

    def parse_range_header(ranges_specifier)
      if /^bytes=(.*)/ =~ ranges_specifier
        byte_range_set = split_header_value($1)
        byte_range_set.collect{|range_spec|
          case range_spec
          when /^(\d+)-(\d+)/ then $1.to_i .. $2.to_i
          when /^(\d+)-/      then $1.to_i .. -1
          when /^-(\d+)/      then -($1.to_i) .. -1
          else return nil
          end
        }
      end
    end
    module_function :parse_range_header

    ##
    # Parses q values in +value+ as used in Accept headers.

    def parse_qvalues(value)
      tmp = []
      if value
        parts = value.split(/,\s*/)
        parts.each {|part|
          if m = %r{^([^\s,]+?)(?:;\s*q=(\d+(?:\.\d+)?))?$}.match(part)
            val = m[1]
            q = (m[2] or 1).to_f
            tmp.push([val, q])
          end
        }
        tmp = tmp.sort_by{|val, q| -q}
        tmp.collect!{|val, q| val}
      end
      return tmp
    end
    module_function :parse_qvalues

    ##
    # Removes quotes and escapes from +str+

    def dequote(str)
      ret = (/\A"(.*)"\Z/ =~ str) ? $1 : str.dup
      ret.gsub!(/\\(.)/, "\\1")
      ret
    end
    module_function :dequote

    ##
    # Quotes and escapes quotes in +str+

    def quote(str)
      '"' << str.gsub(/[\\\"]/o, "\\\1") << '"'
    end
    module_function :quote

    ##
    # Stores multipart form data.  FormData objects are created when
    # WEBrick::HTTPUtils.parse_form_data is called.

    class FormData < String
      EmptyRawHeader = [].freeze # :nodoc:
      EmptyHeader = {}.freeze # :nodoc:

      ##
      # The name of the form data part

      attr_accessor :name

      ##
      # The filename of the form data part

      attr_accessor :filename

      attr_accessor :next_data # :nodoc:
      protected :next_data

      ##
      # Creates a new FormData object.
      #
      # +args+ is an Array of form data entries.  One FormData will be created
      # for each entry.
      #
      # This is called by WEBrick::HTTPUtils.parse_form_data for you

      def initialize(*args)
        @name = @filename = @next_data = nil
        if args.empty?
          @raw_header = []
          @header = nil
          super("")
        else
          @raw_header = EmptyRawHeader
          @header = EmptyHeader
          super(args.shift)
          unless args.empty?
            @next_data = self.class.new(*args)
          end
        end
      end

      ##
      # Retrieves the header at the first entry in +key+

      def [](*key)
        begin
          @header[key[0].downcase].join(", ")
        rescue StandardError, NameError
          super
        end
      end

      ##
      # Adds +str+ to this FormData which may be the body, a header or a
      # header entry.
      #
      # This is called by WEBrick::HTTPUtils.parse_form_data for you

      def <<(str)
        if @header
          super
        elsif str == CRLF
          @header = HTTPUtils::parse_header(@raw_header.join)
          if cd = self['content-disposition']
            if /\s+name="(.*?)"/ =~ cd then @name = $1 end
            if /\s+filename="(.*?)"/ =~ cd then @filename = $1 end
          end
        else
          @raw_header << str
        end
        self
      end

      ##
      # Adds +data+ at the end of the chain of entries
      #
      # This is called by WEBrick::HTTPUtils.parse_form_data for you.

      def append_data(data)
        tmp = self
        while tmp
          unless tmp.next_data
            tmp.next_data = data
            break
          end
          tmp = tmp.next_data
        end
        self
      end

      ##
      # Yields each entry in this FormData

      def each_data
        tmp = self
        while tmp
          next_data = tmp.next_data
          yield(tmp)
          tmp = next_data
        end
      end

      ##
      # Returns all the FormData as an Array

      def list
        ret = []
        each_data{|data|
          ret << data.to_s
        }
        ret
      end

      ##
      # A FormData will behave like an Array

      alias :to_ary :list

      ##
      # This FormData's body

      def to_s
        String.new(self)
      end
    end

    ##
    # Parses the query component of a URI in +str+

    def parse_query(str)
      query = Hash.new
      if str
        str.split(/[&;]/).each{|x|
          next if x.empty?
          key, val = x.split(/=/,2)
          key = unescape_form(key)
          val = unescape_form(val.to_s)
          val = FormData.new(val)
          val.name = key
          if query.has_key?(key)
            query[key].append_data(val)
            next
          end
          query[key] = val
        }
      end
      query
    end
    module_function :parse_query

    ##
    # Parses form data in +io+ with the given +boundary+

    def parse_form_data(io, boundary)
      boundary_regexp = /\A--#{Regexp.quote(boundary)}(--)?#{CRLF}\z/
      form_data = Hash.new
      return form_data unless io
      data = nil
      io.each_line{|line|
        if boundary_regexp =~ line
          if data
            data.chop!
            key = data.name
            if form_data.has_key?(key)
              form_data[key].append_data(data)
            else
              form_data[key] = data
            end
          end
          data = FormData.new
          next
        else
          if data
            data << line
          end
        end
      }
      return form_data
    end
    module_function :parse_form_data

    #####

    reserved = ';/?:@&=+$,'
    num      = '0123456789'
    lowalpha = 'abcdefghijklmnopqrstuvwxyz'
    upalpha  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    mark     = '-_.!~*\'()'
    unreserved = num + lowalpha + upalpha + mark
    control  = (0x0..0x1f).collect{|c| c.chr }.join + "\x7f"
    space    = " "
    delims   = '<>#%"'
    unwise   = '{}|\\^[]`'
    nonascii = (0x80..0xff).collect{|c| c.chr }.join

    module_function

    # :stopdoc:

    def _make_regex(str) /([#{Regexp.escape(str)}])/n end
    def _make_regex!(str) /([^#{Regexp.escape(str)}])/n end
    def _escape(str, regex)
      str = str.b
      str.gsub!(regex) {"%%%02X" % $1.ord}
      # %-escaped string should contain US-ASCII only
      str.force_encoding(Encoding::US_ASCII)
    end
    def _unescape(str, regex)
      str = str.b
      str.gsub!(regex) {$1.hex.chr}
      # encoding of %-unescaped string is unknown
      str
    end

    UNESCAPED = _make_regex(control+space+delims+unwise+nonascii)
    UNESCAPED_FORM = _make_regex(reserved+control+delims+unwise+nonascii)
    NONASCII  = _make_regex(nonascii)
    ESCAPED   = /%([0-9a-fA-F]{2})/
    UNESCAPED_PCHAR = _make_regex!(unreserved+":@&=+$,")

    # :startdoc:

    ##
    # Escapes HTTP reserved and unwise characters in +str+

    def escape(str)
      _escape(str, UNESCAPED)
    end

    ##
    # Unescapes HTTP reserved and unwise characters in +str+

    def unescape(str)
      _unescape(str, ESCAPED)
    end

    ##
    # Escapes form reserved characters in +str+

    def escape_form(str)
      ret = _escape(str, UNESCAPED_FORM)
      ret.gsub!(/ /, "+")
      ret
    end

    ##
    # Unescapes form reserved characters in +str+

    def unescape_form(str)
      _unescape(str.gsub(/\+/, " "), ESCAPED)
    end

    ##
    # Escapes path +str+

    def escape_path(str)
      result = ""
      str.scan(%r{/([^/]*)}).each{|i|
        result << "/" << _escape(i[0], UNESCAPED_PCHAR)
      }
      return result
    end

    ##
    # Escapes 8 bit characters in +str+

    def escape8bit(str)
      _escape(str, NONASCII)
    end
  end
end
                                                                                                                                                                                                                                                                                                             httpversion.rb                                                                                      0100644 0001750 0001750 00000003113 12100626626 036635  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #--
# HTTPVersion.rb -- presentation of HTTP version
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpversion.rb,v 1.5 2002/09/21 12:23:37 gotoyuzo Exp $

module WEBrick

  ##
  # Represents an HTTP protocol version

  class HTTPVersion
    include Comparable

    ##
    # The major protocol version number

    attr_accessor :major

    ##
    # The minor protocol version number

    attr_accessor :minor

    ##
    # Converts +version+ into an HTTPVersion

    def self.convert(version)
      version.is_a?(self) ? version : new(version)
    end

    ##
    # Creates a new HTTPVersion from +version+.

    def initialize(version)
      case version
      when HTTPVersion
        @major, @minor = version.major, version.minor
      when String
        if /^(\d+)\.(\d+)$/ =~ version
          @major, @minor = $1.to_i, $2.to_i
        end
      end
      if @major.nil? || @minor.nil?
        raise ArgumentError,
          format("cannot convert %s into %s", version.class, self.class)
      end
    end

    ##
    # Compares this version with +other+ according to the HTTP specification
    # rules.

    def <=>(other)
      unless other.is_a?(self.class)
        other = self.class.new(other)
      end
      if (ret = @major <=> other.major) == 0
        return @minor <=> other.minor
      end
      return ret
    end

    ##
    # The HTTP version as show in the HTTP request and response.  For example,
    # "1.1"

    def to_s
      format("%d.%d", @major, @minor)
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                     log.rb                                                                                              0100644 0001750 0001750 00000007660 12100626626 035044  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #--
# log.rb -- Log Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: log.rb,v 1.26 2002/10/06 17:06:10 gotoyuzo Exp $

module WEBrick

  ##
  # A generic logging class

  class BasicLog

    # Fatal log level which indicates a server crash

    FATAL = 1

    # Error log level which indicates a recoverable error

    ERROR = 2

    # Warning log level which indicates a possible problem

    WARN  = 3

    # Information log level which indicates possibly useful information

    INFO  = 4

    # Debugging error level for messages used in server development or
    # debugging

    DEBUG = 5

    # log-level, messages above this level will be logged
    attr_accessor :level

    ##
    # Initializes a new logger for +log_file+ that outputs messages at +level+
    # or higher.  +log_file+ can be a filename, an IO-like object that
    # responds to #<< or nil which outputs to $stderr.
    #
    # If no level is given INFO is chosen by default

    def initialize(log_file=nil, level=nil)
      @level = level || INFO
      case log_file
      when String
        @log = open(log_file, "a+")
        @log.sync = true
        @opened = true
      when NilClass
        @log = $stderr
      else
        @log = log_file  # requires "<<". (see BasicLog#log)
      end
    end

    ##
    # Closes the logger (also closes the log device associated to the logger)
    def close
      @log.close if @opened
      @log = nil
    end

    ##
    # Logs +data+ at +level+ if the given level is above the current log
    # level.

    def log(level, data)
      if @log && level <= @level
        data += "\n" if /\n\Z/ !~ data
        @log << data
      end
    end

    ##
    # Synonym for log(INFO, obj.to_s)
    def <<(obj)
      log(INFO, obj.to_s)
    end

    # Shortcut for logging a FATAL message
    def fatal(msg) log(FATAL, "FATAL " << format(msg)); end
    # Shortcut for logging an ERROR message
    def error(msg) log(ERROR, "ERROR " << format(msg)); end
    # Shortcut for logging a WARN message
    def warn(msg)  log(WARN,  "WARN  " << format(msg)); end
    # Shortcut for logging an INFO message
    def info(msg)  log(INFO,  "INFO  " << format(msg)); end
    # Shortcut for logging a DEBUG message
    def debug(msg) log(DEBUG, "DEBUG " << format(msg)); end

    # Will the logger output FATAL messages?
    def fatal?; @level >= FATAL; end
    # Will the logger output ERROR messages?
    def error?; @level >= ERROR; end
    # Will the logger output WARN messages?
    def warn?;  @level >= WARN; end
    # Will the logger output INFO messages?
    def info?;  @level >= INFO; end
    # Will the logger output DEBUG messages?
    def debug?; @level >= DEBUG; end

    private

    ##
    # Formats +arg+ for the logger
    #
    # * If +arg+ is an Exception, it will format the error message and
    #   the back trace.
    # * If +arg+ responds to #to_str, it will return it.
    # * Otherwise it will return +arg+.inspect.
    def format(arg)
      if arg.is_a?(Exception)
        "#{arg.class}: #{arg.message}\n\t" <<
        arg.backtrace.join("\n\t") << "\n"
      elsif arg.respond_to?(:to_str)
        arg.to_str
      else
        arg.inspect
      end
    end
  end

  ##
  # A logging class that prepends a timestamp to each message.

  class Log < BasicLog
    # Format of the timestamp which is applied to each logged line.  The
    # default is <tt>"[%Y-%m-%d %H:%M:%S]"</tt>
    attr_accessor :time_format

    ##
    # Same as BasicLog#initialize
    #
    # You can set the timestamp format through #time_format
    def initialize(log_file=nil, level=nil)
      super(log_file, level)
      @time_format = "[%Y-%m-%d %H:%M:%S]"
    end

    ##
    # Same as BasicLog#log
    def log(level, data)
      tmp = Time.now.strftime(@time_format)
      tmp << " " << data
      super(level, tmp)
    end
  end
end
                                                                                server.rb                                                                                           0100644 0001750 0001750 00000020651 12100626626 035564  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# server.rb -- GenericServer Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: server.rb,v 1.62 2003/07/22 19:20:43 gotoyuzo Exp $

require 'thread'
require 'socket'
require 'webrick/config'
require 'webrick/log'

module WEBrick

  ##
  # Server error exception

  class ServerError < StandardError; end

  ##
  # Base server class

  class SimpleServer

    ##
    # A SimpleServer only yields when you start it

    def SimpleServer.start
      yield
    end
  end

  ##
  # A generic module for daemonizing a process

  class Daemon

    ##
    # Performs the standard operations for daemonizing a process.  Runs a
    # block, if given.

    def Daemon.start
      exit!(0) if fork
      Process::setsid
      exit!(0) if fork
      Dir::chdir("/")
      File::umask(0)
      STDIN.reopen("/dev/null")
      STDOUT.reopen("/dev/null", "w")
      STDERR.reopen("/dev/null", "w")
      yield if block_given?
    end
  end

  ##
  # Base TCP server class.  You must subclass GenericServer and provide a #run
  # method.

  class GenericServer

    ##
    # The server status.  One of :Stop, :Running or :Shutdown

    attr_reader :status

    ##
    # The server configuration

    attr_reader :config

    ##
    # The server logger.  This is independent from the HTTP access log.

    attr_reader :logger

    ##
    # Tokens control the number of outstanding clients.  The
    # <code>:MaxClients</code> configuration sets this.

    attr_reader :tokens

    ##
    # Sockets listening for connections.

    attr_reader :listeners

    ##
    # Creates a new generic server from +config+.  The default configuration
    # comes from +default+.

    def initialize(config={}, default=Config::General)
      @config = default.dup.update(config)
      @status = :Stop
      @config[:Logger] ||= Log::new
      @logger = @config[:Logger]

      @tokens = SizedQueue.new(@config[:MaxClients])
      @config[:MaxClients].times{ @tokens.push(nil) }

      webrickv = WEBrick::VERSION
      rubyv = "#{RUBY_VERSION} (#{RUBY_RELEASE_DATE}) [#{RUBY_PLATFORM}]"
      @logger.info("WEBrick #{webrickv}")
      @logger.info("ruby #{rubyv}")

      @listeners = []
      unless @config[:DoNotListen]
        if @config[:Listen]
          warn(":Listen option is deprecated; use GenericServer#listen")
        end
        listen(@config[:BindAddress], @config[:Port])
        if @config[:Port] == 0
          @config[:Port] = @listeners[0].addr[1]
        end
      end
    end

    ##
    # Retrieves +key+ from the configuration

    def [](key)
      @config[key]
    end

    ##
    # Adds listeners from +address+ and +port+ to the server.  See
    # WEBrick::Utils::create_listeners for details.

    def listen(address, port)
      @listeners += Utils::create_listeners(address, port, @logger)
    end

    ##
    # Starts the server and runs the +block+ for each connection.  This method
    # does not return until the server is stopped from a signal handler or
    # another thread using #stop or #shutdown.
    #
    # If the block raises a subclass of StandardError the exception is logged
    # and ignored.  If an IOError or Errno::EBADF exception is raised the
    # exception is ignored.  If an Exception subclass is raised the exception
    # is logged and re-raised which stops the server.
    #
    # To completely shut down a server call #shutdown from ensure:
    #
    #   server = WEBrick::GenericServer.new
    #   # or WEBrick::HTTPServer.new
    #
    #   begin
    #     server.start
    #   ensure
    #     server.shutdown
    #   end

    def start(&block)
      raise ServerError, "already started." if @status != :Stop
      server_type = @config[:ServerType] || SimpleServer

      server_type.start{
        @logger.info \
          "#{self.class}#start: pid=#{$$} port=#{@config[:Port]}"
        call_callback(:StartCallback)

        thgroup = ThreadGroup.new
        @status = :Running
        begin
          while @status == :Running
            begin
              if svrs = IO.select(@listeners, nil, nil, 2.0)
                svrs[0].each{|svr|
                  @tokens.pop          # blocks while no token is there.
                  if sock = accept_client(svr)
                    sock.do_not_reverse_lookup = config[:DoNotReverseLookup]
                    th = start_thread(sock, &block)
                    th[:WEBrickThread] = true
                    thgroup.add(th)
                  else
                    @tokens.push(nil)
                  end
                }
              end
            rescue Errno::EBADF, IOError => ex
              # if the listening socket was closed in GenericServer#shutdown,
              # IO::select raise it.
            rescue StandardError => ex
              msg = "#{ex.class}: #{ex.message}\n\t#{ex.backtrace[0]}"
              @logger.error msg
            rescue Exception => ex
              @logger.fatal ex
              raise
            end
          end

        ensure
          @status = :Shutdown
          @logger.info "going to shutdown ..."
          thgroup.list.each{|th| th.join if th[:WEBrickThread] }
          call_callback(:StopCallback)
          @logger.info "#{self.class}#start done."
          @status = :Stop
        end
      }
    end

    ##
    # Stops the server from accepting new connections.

    def stop
      if @status == :Running
        @status = :Shutdown
      end
    end

    ##
    # Shuts down the server and all listening sockets.  New listeners must be
    # provided to restart the server.

    def shutdown
      stop
      @listeners.each{|s|
        if @logger.debug?
          addr = s.addr
          @logger.debug("close TCPSocket(#{addr[2]}, #{addr[1]})")
        end
        begin
          s.shutdown
        rescue Errno::ENOTCONN
          # when `Errno::ENOTCONN: Socket is not connected' on some platforms,
          # call #close instead of #shutdown.
          # (ignore @config[:ShutdownSocketWithoutClose])
          s.close
        else
          unless @config[:ShutdownSocketWithoutClose]
            s.close
          end
        end
      }
      @listeners.clear
    end

    ##
    # You must subclass GenericServer and implement \#run which accepts a TCP
    # client socket

    def run(sock)
      @logger.fatal "run() must be provided by user."
    end

    private

    # :stopdoc:

    ##
    # Accepts a TCP client socket from the TCP server socket +svr+ and returns
    # the client socket.

    def accept_client(svr)
      sock = nil
      begin
        sock = svr.accept
        sock.sync = true
        Utils::set_non_blocking(sock)
        Utils::set_close_on_exec(sock)
      rescue Errno::ECONNRESET, Errno::ECONNABORTED,
             Errno::EPROTO, Errno::EINVAL => ex
      rescue StandardError => ex
        msg = "#{ex.class}: #{ex.message}\n\t#{ex.backtrace[0]}"
        @logger.error msg
      end
      return sock
    end

    ##
    # Starts a server thread for the client socket +sock+ that runs the given
    # +block+.
    #
    # Sets the socket to the <code>:WEBrickSocket</code> thread local variable
    # in the thread.
    #
    # If any errors occur in the block they are logged and handled.

    def start_thread(sock, &block)
      Thread.start{
        begin
          Thread.current[:WEBrickSocket] = sock
          begin
            addr = sock.peeraddr
            @logger.debug "accept: #{addr[3]}:#{addr[1]}"
          rescue SocketError
            @logger.debug "accept: <address unknown>"
            raise
          end
          call_callback(:AcceptCallback, sock)
          block ? block.call(sock) : run(sock)
        rescue Errno::ENOTCONN
          @logger.debug "Errno::ENOTCONN raised"
        rescue ServerError => ex
          msg = "#{ex.class}: #{ex.message}\n\t#{ex.backtrace[0]}"
          @logger.error msg
        rescue Exception => ex
          @logger.error ex
        ensure
          @tokens.push(nil)
          Thread.current[:WEBrickSocket] = nil
          if addr
            @logger.debug "close: #{addr[3]}:#{addr[1]}"
          else
            @logger.debug "close: <address unknown>"
          end
          sock.close unless sock.closed?
        end
      }
    end

    ##
    # Calls the callback +callback_name+ from the configuration with +args+

    def call_callback(callback_name, *args)
      if cb = @config[callback_name]
        cb.call(*args)
      end
    end
  end    # end of GenericServer
end
                                                                                       ssl.rb                                                                                              0100644 0001750 0001750 00000015254 12100626626 035062  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# ssl.rb -- SSL/TLS enhancement for GenericServer
#
# Copyright (c) 2003 GOTOU Yuuzou All rights reserved.
#
# $Id: ssl.rb 38945 2013-01-26 01:12:54Z drbrain $

require 'webrick'
require 'openssl'

module WEBrick
  module Config
    svrsoft = General[:ServerSoftware]
    osslv = ::OpenSSL::OPENSSL_VERSION.split[1]

    ##
    # Default SSL server configuration.
    #
    # WEBrick can automatically create a self-signed certificate if
    # <code>:SSLCertName</code> is set.  For more information on the various
    # SSL options see OpenSSL::SSL::SSLContext.
    #
    # :ServerSoftware       ::
    #   The server software name used in the Server: header.
    # :SSLEnable            :: false,
    #   Enable SSL for this server.  Defaults to false.
    # :SSLCertificate       ::
    #   The SSL certificate for the server.
    # :SSLPrivateKey        ::
    #   The SSL private key for the server certificate.
    # :SSLClientCA          :: nil,
    #   Array of certificates that will be sent to the client.
    # :SSLExtraChainCert    :: nil,
    #   Array of certificates that willbe added to the certificate chain
    # :SSLCACertificateFile :: nil,
    #   Path to a CA certificate file
    # :SSLCACertificatePath :: nil,
    #   Path to a directory containing CA certificates
    # :SSLCertificateStore  :: nil,
    #   OpenSSL::X509::Store used for certificate validation of the client
    # :SSLTmpDhCallback     :: nil,
    #   Callback invoked when DH parameters are required.
    # :SSLVerifyClient      ::
    #   Sets whether the client is verified.  This defaults to VERIFY_NONE
    #   which is typical for an HTTPS server.
    # :SSLVerifyDepth       ::
    #   Number of CA certificates to walk when verifying a certificate chain
    # :SSLVerifyCallback    ::
    #   Custom certificate verification callback
    # :SSLTimeout           ::
    #   Maximum session lifetime
    # :SSLOptions           ::
    #   Various SSL options
    # :SSLStartImmediately  ::
    #   Immediately start SSL upon connection?  Defaults to true
    # :SSLCertName          ::
    #   SSL certificate name.  Must be set to enable automatic certificate
    #   creation.
    # :SSLCertComment       ::
    #   Comment used during automatic certificate creation.

    SSL = {
      :ServerSoftware       => "#{svrsoft} OpenSSL/#{osslv}",
      :SSLEnable            => false,
      :SSLCertificate       => nil,
      :SSLPrivateKey        => nil,
      :SSLClientCA          => nil,
      :SSLExtraChainCert    => nil,
      :SSLCACertificateFile => nil,
      :SSLCACertificatePath => nil,
      :SSLCertificateStore  => nil,
      :SSLTmpDhCallback     => nil,
      :SSLVerifyClient      => ::OpenSSL::SSL::VERIFY_NONE,
      :SSLVerifyDepth       => nil,
      :SSLVerifyCallback    => nil,   # custom verification
      :SSLTimeout           => nil,
      :SSLOptions           => nil,
      :SSLStartImmediately  => true,
      # Must specify if you use auto generated certificate.
      :SSLCertName          => nil,
      :SSLCertComment       => "Generated by Ruby/OpenSSL"
    }
    General.update(SSL)
  end

  module Utils
    ##
    # Creates a self-signed certificate with the given number of +bits+,
    # the issuer +cn+ and a +comment+ to be stored in the certificate.

    def create_self_signed_cert(bits, cn, comment)
      rsa = OpenSSL::PKey::RSA.new(bits){|p, n|
        case p
        when 0; $stderr.putc "."  # BN_generate_prime
        when 1; $stderr.putc "+"  # BN_generate_prime
        when 2; $stderr.putc "*"  # searching good prime,
                                  # n = #of try,
                                  # but also data from BN_generate_prime
        when 3; $stderr.putc "\n" # found good prime, n==0 - p, n==1 - q,
                                  # but also data from BN_generate_prime
        else;   $stderr.putc "*"  # BN_generate_prime
        end
      }
      cert = OpenSSL::X509::Certificate.new
      cert.version = 2
      cert.serial = 1
      name = OpenSSL::X509::Name.new(cn)
      cert.subject = name
      cert.issuer = name
      cert.not_before = Time.now
      cert.not_after = Time.now + (365*24*60*60)
      cert.public_key = rsa.public_key

      ef = OpenSSL::X509::ExtensionFactory.new(nil,cert)
      ef.issuer_certificate = cert
      cert.extensions = [
        ef.create_extension("basicConstraints","CA:FALSE"),
        ef.create_extension("keyUsage", "keyEncipherment"),
        ef.create_extension("subjectKeyIdentifier", "hash"),
        ef.create_extension("extendedKeyUsage", "serverAuth"),
        ef.create_extension("nsComment", comment),
      ]
      aki = ef.create_extension("authorityKeyIdentifier",
                                "keyid:always,issuer:always")
      cert.add_extension(aki)
      cert.sign(rsa, OpenSSL::Digest::SHA1.new)

      return [ cert, rsa ]
    end
    module_function :create_self_signed_cert
  end

  ##
  #--
  # Updates WEBrick::GenericServer with SSL functionality

  class GenericServer

    ##
    # SSL context for the server when run in SSL mode

    def ssl_context # :nodoc:
      @ssl_context ||= nil
    end

    undef listen

    ##
    # Updates +listen+ to enable SSL when the SSL configuration is active.

    def listen(address, port) # :nodoc:
      listeners = Utils::create_listeners(address, port, @logger)
      if @config[:SSLEnable]
        unless ssl_context
          @ssl_context = setup_ssl_context(@config)
          @logger.info("\n" + @config[:SSLCertificate].to_text)
        end
        listeners.collect!{|svr|
          ssvr = ::OpenSSL::SSL::SSLServer.new(svr, ssl_context)
          ssvr.start_immediately = @config[:SSLStartImmediately]
          ssvr
        }
      end
      @listeners += listeners
    end

    ##
    # Sets up an SSL context for +config+

    def setup_ssl_context(config) # :nodoc:
      unless config[:SSLCertificate]
        cn = config[:SSLCertName]
        comment = config[:SSLCertComment]
        cert, key = Utils::create_self_signed_cert(1024, cn, comment)
        config[:SSLCertificate] = cert
        config[:SSLPrivateKey] = key
      end
      ctx = OpenSSL::SSL::SSLContext.new
      ctx.key = config[:SSLPrivateKey]
      ctx.cert = config[:SSLCertificate]
      ctx.client_ca = config[:SSLClientCA]
      ctx.extra_chain_cert = config[:SSLExtraChainCert]
      ctx.ca_file = config[:SSLCACertificateFile]
      ctx.ca_path = config[:SSLCACertificatePath]
      ctx.cert_store = config[:SSLCertificateStore]
      ctx.tmp_dh_callback = config[:SSLTmpDhCallback]
      ctx.verify_mode = config[:SSLVerifyClient]
      ctx.verify_depth = config[:SSLVerifyDepth]
      ctx.verify_callback = config[:SSLVerifyCallback]
      ctx.timeout = config[:SSLTimeout]
      ctx.options = config[:SSLOptions]
      ctx
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                    utils.rb                                                                                            0100644 0001750 0001750 00000014707 12100626626 035423  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #
# utils.rb -- Miscellaneous utilities
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: utils.rb,v 1.10 2003/02/16 22:22:54 gotoyuzo Exp $

require 'socket'
require 'fcntl'
begin
  require 'etc'
rescue LoadError
  nil
end

module WEBrick
  module Utils
    ##
    # Sets IO operations on +io+ to be non-blocking
    def set_non_blocking(io)
      flag = File::NONBLOCK
      if defined?(Fcntl::F_GETFL)
        flag |= io.fcntl(Fcntl::F_GETFL)
      end
      io.fcntl(Fcntl::F_SETFL, flag)
    end
    module_function :set_non_blocking

    ##
    # Sets the close on exec flag for +io+
    def set_close_on_exec(io)
      if defined?(Fcntl::FD_CLOEXEC)
        io.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC)
      end
    end
    module_function :set_close_on_exec

    ##
    # Changes the process's uid and gid to the ones of +user+
    def su(user)
      if defined?(Etc)
        pw = Etc.getpwnam(user)
        Process::initgroups(user, pw.gid)
        Process::Sys::setgid(pw.gid)
        Process::Sys::setuid(pw.uid)
      else
        warn("WEBrick::Utils::su doesn't work on this platform")
      end
    end
    module_function :su

    ##
    # The server hostname
    def getservername
      host = Socket::gethostname
      begin
        Socket::gethostbyname(host)[0]
      rescue
        host
      end
    end
    module_function :getservername

    ##
    # Creates TCP server sockets bound to +address+:+port+ and returns them.
    #
    # It will create IPV4 and IPV6 sockets on all interfaces.
    def create_listeners(address, port, logger=nil)
      unless port
        raise ArgumentError, "must specify port"
      end
      res = Socket::getaddrinfo(address, port,
                                Socket::AF_UNSPEC,   # address family
                                Socket::SOCK_STREAM, # socket type
                                0,                   # protocol
                                Socket::AI_PASSIVE)  # flag
      last_error = nil
      sockets = []
      res.each{|ai|
        begin
          logger.debug("TCPServer.new(#{ai[3]}, #{port})") if logger
          sock = TCPServer.new(ai[3], port)
          port = sock.addr[1] if port == 0
          Utils::set_close_on_exec(sock)
          sockets << sock
        rescue => ex
          logger.warn("TCPServer Error: #{ex}") if logger
          last_error  = ex
        end
      }
      raise last_error if sockets.empty?
      return sockets
    end
    module_function :create_listeners

    ##
    # Characters used to generate random strings
    RAND_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                 "0123456789" +
                 "abcdefghijklmnopqrstuvwxyz"

    ##
    # Generates a random string of length +len+
    def random_string(len)
      rand_max = RAND_CHARS.bytesize
      ret = ""
      len.times{ ret << RAND_CHARS[rand(rand_max)] }
      ret
    end
    module_function :random_string

    ###########

    require "thread"
    require "timeout"
    require "singleton"

    ##
    # Class used to manage timeout handlers across multiple threads.
    #
    # Timeout handlers should be managed by using the class methods which are
    # synchronized.
    #
    #   id = TimeoutHandler.register(10, Timeout::Error)
    #   begin
    #     sleep 20
    #     puts 'foo'
    #   ensure
    #     TimeoutHandler.cancel(id)
    #   end
    #
    # will raise Timeout::Error
    #
    #   id = TimeoutHandler.register(10, Timeout::Error)
    #   begin
    #     sleep 5
    #     puts 'foo'
    #   ensure
    #     TimeoutHandler.cancel(id)
    #   end
    #
    # will print 'foo'
    #
    class TimeoutHandler
      include Singleton

      ##
      # Mutex used to synchronize access across threads
      TimeoutMutex = Mutex.new # :nodoc:

      ##
      # Registers a new timeout handler
      #
      # +time+:: Timeout in seconds
      # +exception+:: Exception to raise when timeout elapsed
      def TimeoutHandler.register(seconds, exception)
        TimeoutMutex.synchronize{
          instance.register(Thread.current, Time.now + seconds, exception)
        }
      end

      ##
      # Cancels the timeout handler +id+
      def TimeoutHandler.cancel(id)
        TimeoutMutex.synchronize{
          instance.cancel(Thread.current, id)
        }
      end

      ##
      # Creates a new TimeoutHandler.  You should use ::register and ::cancel
      # instead of creating the timeout handler directly.
      def initialize
        @timeout_info = Hash.new
        Thread.start{
          while true
            now = Time.now
            @timeout_info.keys.each{|thread|
              ary = @timeout_info[thread]
              next unless ary
              ary.dup.each{|info|
                time, exception = *info
                interrupt(thread, info.object_id, exception) if time < now
              }
            }
            sleep 0.5
          end
        }
      end

      ##
      # Interrupts the timeout handler +id+ and raises +exception+
      def interrupt(thread, id, exception)
        TimeoutMutex.synchronize{
          if cancel(thread, id) && thread.alive?
            thread.raise(exception, "execution timeout")
          end
        }
      end

      ##
      # Registers a new timeout handler
      #
      # +time+:: Timeout in seconds
      # +exception+:: Exception to raise when timeout elapsed
      def register(thread, time, exception)
        @timeout_info[thread] ||= Array.new
        @timeout_info[thread] << [time, exception]
        return @timeout_info[thread].last.object_id
      end

      ##
      # Cancels the timeout handler +id+
      def cancel(thread, id)
        if ary = @timeout_info[thread]
          ary.delete_if{|info| info.object_id == id }
          if ary.empty?
            @timeout_info.delete(thread)
          end
          return true
        end
        return false
      end
    end

    ##
    # Executes the passed block and raises +exception+ if execution takes more
    # than +seconds+.
    #
    # If +seconds+ is zero or nil, simply executes the block
    def timeout(seconds, exception=Timeout::Error)
      return yield if seconds.nil? or seconds.zero?
      # raise ThreadError, "timeout within critical session" if Thread.critical
      id = TimeoutHandler.register(seconds, exception)
      begin
        yield(seconds)
      ensure
        TimeoutHandler.cancel(id)
      end
    end
    module_function :timeout
  end
end
                                                         version.rb                                                                                          0100644 0001750 0001750 00000000600 12100626626 035733  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/webrick                                                   #--
# version.rb -- version and release date
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000 TAKAHASHI Masayoshi, GOTOU YUUZOU
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: version.rb,v 1.74 2003/07/22 19:20:43 gotoyuzo Exp $

module WEBrick

  ##
  # The WEBrick version

  VERSION      = "1.3.1"
end
                                                                                                                                webrick.rb                                                                                          0100644 0001750 0001750 00000015310 12046402225 034246  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           ##
# = WEB server toolkit.
#
# WEBrick is an HTTP server toolkit that can be configured as an HTTPS server,
# a proxy server, and a virtual-host server.  WEBrick features complete
# logging of both server operations and HTTP access.  WEBrick supports both
# basic and digest authentication in addition to algorithms not in RFC 2617.
#
# A WEBrick server can be composed of multiple WEBrick servers or servlets to
# provide differing behavior on a per-host or per-path basis.  WEBrick
# includes servlets for handling CGI scripts, ERb pages, ruby blocks and
# directory listings.
#
# WEBrick also includes tools for daemonizing a process and starting a process
# at a higher privilege level and dropping permissions.
#
# == Starting an HTTP server
#
# To create a new WEBrick::HTTPServer that will listen to connections on port
# 8000 and serve documents from the current user's public_html folder:
#
#   require 'webrick'
#
#   root = File.expand_path '~/public_html'
#   server = WEBrick::HTTPServer.new :Port => 8000, :DocumentRoot => root
#
# To run the server you will need to provide a suitable shutdown hook as
# starting the server blocks the current thread:
#
#   trap 'INT' do server.shutdown end
#
#   server.start
#
# == Custom Behavior
#
# The easiest way to have a server perform custom operations is through
# WEBrick::HTTPServer#mount_proc.  The block given will be called with a
# WEBrick::HTTPRequest with request info and a WEBrick::HTTPResponse which
# must be filled in appropriately:
#
#   server.mount_proc '/' do |req, res|
#     res.body = 'Hello, world!'
#   end
#
# Remember that <tt>server.mount_proc</tt> must <tt>server.start</tt>.
#
# == Servlets
#
# Advanced custom behavior can be obtained through mounting a subclass of
# WEBrick::HTTPServlet::AbstractServlet.  Servlets provide more modularity
# when writing an HTTP server than mount_proc allows.  Here is a simple
# servlet:
#
#   class Simple < WEBrick::HTTPServlet::AbstractServlet
#     def do_GET request, response
#       status, content_type, body = do_stuff_with request
#
#       response.status = 200
#       response['Content-Type'] = 'text/plain'
#       response.body = 'Hello, World!'
#     end
#   end
#
# To initialize the servlet you mount it on the server:
#
#   server.mount '/simple', Simple
#
# See WEBrick::HTTPServlet::AbstractServlet for more details.
#
# == Virtual Hosts
#
# A server can act as a virtual host for multiple host names.  After creating
# the listening host, additional hosts that do not listen can be created and
# attached as virtual hosts:
#
#   server = WEBrick::HTTPServer.new # ...
#
#   vhost = WEBrick::HTTPServer.new :ServerName => 'vhost.example',
#                                   :DoNotListen => true, # ...
#   vhost.mount '/', ...
#
#   server.virtual_host vhost
#
# If no +:DocumentRoot+ is provided and no servlets or procs are mounted on the
# main server it will return 404 for all URLs.
#
# == HTTPS
#
# To create an HTTPS server you only need to enable SSL and provide an SSL
# certificate name:
#
#   require 'webrick'
#   require 'webrick/https'
#
#   cert_name = [
#     %w[CN localhost],
#   ]
#
#   server = WEBrick::HTTPServer.new(:Port => 8000,
#                                    :SSLEnable => true,
#                                    :SSLCertName => cert_name)
#
# This will start the server with a self-generated self-signed certificate.
# The certificate will be changed every time the server is restarted.
#
# To create a server with a pre-determined key and certificate you can provide
# them:
#
#   require 'webrick'
#   require 'webrick/https'
#   require 'openssl'
#
#   cert = OpenSSL::X509::Certificate.new File.read '/path/to/cert.pem'
#   pkey = OpenSSL::PKey::RSA.new File.read '/path/to/pkey.pem'
#
#   server = WEBrick::HTTPServer.new(:Port => 8000,
#                                    :SSLEnable => true,
#                                    :SSLCertificate => cert,
#                                    :SSLPrivateKey => pkey)
#
# == Proxy Server
#
# WEBrick can act as a proxy server:
#
#   require 'webrick'
#   require 'webrick/httpproxy'
#
#   proxy = WEBrick::HTTPProxyServer.new :Port => 8000
#
#   trap 'INT' do proxy.shutdown end
#
# See WEBrick::HTTPProxy for further details including modifying proxied
# responses.
#
# == Basic and Digest authentication
#
# WEBrick provides both Basic and Digest authentication for regular and proxy
# servers.  See WEBrick::HTTPAuth, WEBrick::HTTPAuth::BasicAuth and
# WEBrick::HTTPAuth::DigestAuth.
#
# == WEBrick as a Production Web Server
#
# WEBrick can be run as a production server for small loads.
#
# === Daemonizing
#
# To start a WEBrick server as a daemon simple run WEBrick::Daemon.start
# before starting the server.
#
# === Dropping Permissions
#
# WEBrick can be started as one user to gain permission to bind to port 80 or
# 443 for serving HTTP or HTTPS traffic then can drop these permissions for
# regular operation.  To listen on all interfaces for HTTP traffic:
#
#   sockets = WEBrick::Utils.create_listeners nil, 80
#
# Then drop privileges:
#
#   WEBrick::Utils.su 'www'
#
# Then create a server that does not listen by default:
#
#   server = WEBrick::HTTPServer.new :DoNotListen => true, # ...
#
# Then overwrite the listening sockets with the port 80 sockets:
#
#   server.listeners.replace sockets
#
# === Logging
#
# WEBrick can separately log server operations and end-user access.  For
# server operations:
#
#   log_file = File.open '/var/log/webrick.log', 'a+'
#   log = WEBrick::Log.new log_file
#
# For user access logging:
#
#   access_log = [
#     [log_file, WEBrick::AccessLog::COMBINED_LOG_FORMAT],
#   ]
#
#   server = WEBrick::HTTPServer.new :Logger => log, :AccessLog => access_log
#
# See WEBrick::AccessLog for further log formats.
#
# === Log Rotation
#
# To rotate logs in WEBrick on a HUP signal (like syslogd can send), open the
# log file in 'a+' mode (as above) and trap 'HUP' to reopen the log file:
#
#   trap 'HUP' do log_file.reopen '/path/to/webrick.log', 'a+'
#
# == Copyright
#
# Author: IPR -- Internet Programming with Ruby -- writers
#
# Copyright (c) 2000 TAKAHASHI Masayoshi, GOTOU YUUZOU
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#--
# $IPR: webrick.rb,v 1.12 2002/10/01 17:16:31 gotoyuzo Exp $

module WEBrick
end

require 'webrick/compat.rb'

require 'webrick/version.rb'
require 'webrick/config.rb'
require 'webrick/log.rb'
require 'webrick/server.rb'
require 'webrick/utils.rb'
require 'webrick/accesslog'

require 'webrick/htmlutils.rb'
require 'webrick/httputils.rb'
require 'webrick/cookie.rb'
require 'webrick/httpversion.rb'
require 'webrick/httpstatus.rb'
require 'webrick/httprequest.rb'
require 'webrick/httpresponse.rb'
require 'webrick/httpserver.rb'
require 'webrick/httpservlet.rb'
require 'webrick/httpauth.rb'
                                                                                                                                                                                                                                                                                                                        xmlrpc/                                                                                             0040755 0001750 0001750 00000000000 12612224746 033614  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           base64.rb                                                                                           0100644 0001750 0001750 00000002640 12024241522 035210  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    #
# xmlrpc/base64.rb
# Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# Released under the same term of license as Ruby.

module XMLRPC # :nodoc:

# This class is necessary for 'xmlrpc4r' to determine that a string should
# be transmitted base64-encoded and not as a raw-string.
#
# You can use XMLRPC::Base64 on the client and server-side as a
# parameter and/or return-value.
class Base64

  # Creates a new XMLRPC::Base64 instance with string +str+ as the
  # internal string. When +state+ is +:dec+ it assumes that the
  # string +str+ is not in base64 format (perhaps already decoded),
  # otherwise if +state+ is +:enc+ it decodes +str+
  # and stores it as the internal string.
  def initialize(str, state = :dec)
    case state
    when :enc
      @str = Base64.decode(str)
    when :dec
      @str = str
    else
      raise ArgumentError, "wrong argument; either :enc or :dec"
    end
  end

  # Returns the decoded internal string.
  def decoded
    @str
  end

  # Returns the base64 encoded internal string.
  def encoded
    Base64.encode(@str)
  end


  # Decodes string +str+ with base64 and returns that value.
  def Base64.decode(str)
    str.gsub(/\s+/, "").unpack("m")[0]
  end

  # Encodes string +str+ with base64 and returns that value.
  def Base64.encode(str)
    [str].pack("m")
  end

end


end # module XMLRPC


=begin
= History
    $Id: base64.rb 36958 2012-09-13 02:22:10Z zzak $
=end
                                                                                                client.rb                                                                                           0100644 0001750 0001750 00000044027 12340776223 035423  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    # xmlrpc/client.rb
# Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# Released under the same term of license as Ruby.
#
# History
#   $Id: client.rb 46153 2014-05-27 02:46:43Z usa $
#
require "xmlrpc/parser"
require "xmlrpc/create"
require "xmlrpc/config"
require "xmlrpc/utils"     # ParserWriterChooseMixin
require "net/http"
require "uri"

module XMLRPC # :nodoc:

  # Provides remote procedure calls to a XML-RPC server.
  #
  # After setting the connection-parameters with XMLRPC::Client.new which
  # creates a new XMLRPC::Client instance, you can execute a remote procedure
  # by sending the XMLRPC::Client#call or XMLRPC::Client#call2
  # message to this new instance.
  #
  # The given parameters indicate which method to call on the remote-side and
  # of course the parameters for the remote procedure.
  #
  #     require "xmlrpc/client"
  #
  #     server = XMLRPC::Client.new("www.ruby-lang.org", "/RPC2", 80)
  #     begin
  #       param = server.call("michael.add", 4, 5)
  #       puts "4 + 5 = #{param}"
  #     rescue XMLRPC::FaultException => e
  #       puts "Error:"
  #       puts e.faultCode
  #       puts e.faultString
  #     end
  #
  # or
  #
  #     require "xmlrpc/client"
  #
  #     server = XMLRPC::Client.new("www.ruby-lang.org", "/RPC2", 80)
  #     ok, param = server.call2("michael.add", 4, 5)
  #     if ok then
  #       puts "4 + 5 = #{param}"
  #     else
  #       puts "Error:"
  #       puts param.faultCode
  #       puts param.faultString
  #     end
  class Client

    USER_AGENT = "XMLRPC::Client (Ruby #{RUBY_VERSION})"

    include ParserWriterChooseMixin
    include ParseContentType


    # Creates an object which represents the remote XML-RPC server on the
    # given +host+. If the server is CGI-based, +path+ is the
    # path to the CGI-script, which will be called, otherwise (in the
    # case of a standalone server) +path+ should be <tt>"/RPC2"</tt>.
    # +port+ is the port on which the XML-RPC server listens.
    #
    # If +proxy_host+ is given, then a proxy server listening at
    # +proxy_host+ is used. +proxy_port+ is the port of the
    # proxy server.
    #
    # Default values for +host+, +path+ and +port+ are 'localhost', '/RPC2' and
    # '80' respectively using SSL '443'.
    #
    # If +user+ and +password+ are given, each time a request is sent,
    # an Authorization header is sent. Currently only Basic Authentication is
    # implemented, no Digest.
    #
    # If +use_ssl+ is set to +true+, communication over SSL is enabled.
    #
    # Parameter +timeout+ is the time to wait for a XML-RPC response, defaults to 30.
    def initialize(host=nil, path=nil, port=nil, proxy_host=nil, proxy_port=nil,
                   user=nil, password=nil, use_ssl=nil, timeout=nil)

      @http_header_extra = nil
      @http_last_response = nil
      @cookie = nil

      @host       = host || "localhost"
      @path       = path || "/RPC2"
      @proxy_host = proxy_host
      @proxy_port = proxy_port
      @proxy_host ||= 'localhost' if @proxy_port != nil
      @proxy_port ||= 8080 if @proxy_host != nil
      @use_ssl    = use_ssl || false
      @timeout    = timeout || 30

      if use_ssl
        require "net/https"
        @port = port || 443
      else
        @port = port || 80
      end

      @user, @password = user, password

      set_auth

      # convert ports to integers
      @port = @port.to_i if @port != nil
      @proxy_port = @proxy_port.to_i if @proxy_port != nil

      # HTTP object for synchronous calls
      @http = net_http(@host, @port, @proxy_host, @proxy_port)
      @http.use_ssl = @use_ssl if @use_ssl
      @http.read_timeout = @timeout
      @http.open_timeout = @timeout

      @parser = nil
      @create = nil
    end


    class << self

    # Creates an object which represents the remote XML-RPC server at the
    # given +uri+. The URI should have a host, port, path, user and password.
    # Example: https://user:password@host:port/path
    #
    # Raises an ArgumentError if the +uri+ is invalid,
    # or if the protocol isn't http or https.
    #
    # If a +proxy+ is given it should be in the form of "host:port".
    #
    # The optional +timeout+ defaults to 30 seconds.
    def new2(uri, proxy=nil, timeout=nil)
      begin
        url = URI(uri)
      rescue URI::InvalidURIError => e
        raise ArgumentError, e.message, e.backtrace
      end

      unless URI::HTTP === url
        raise ArgumentError, "Wrong protocol specified. Only http or https allowed!"
      end

      proto  = url.scheme
      user   = url.user
      passwd = url.password
      host   = url.host
      port   = url.port
      path   = url.path.empty? ? nil : url.request_uri

      proxy_host, proxy_port = (proxy || "").split(":")
      proxy_port = proxy_port.to_i if proxy_port

      self.new(host, path, port, proxy_host, proxy_port, user, passwd, (proto == "https"), timeout)
    end

    alias new_from_uri new2

    # Receives a Hash and calls XMLRPC::Client.new
    # with the corresponding values.
    #
    # The +hash+ parameter has following case-insensitive keys:
    # * host
    # * path
    # * port
    # * proxy_host
    # * proxy_port
    # * user
    # * password
    # * use_ssl
    # * timeout
    def new3(hash={})

      # convert all keys into lowercase strings
      h = {}
      hash.each { |k,v| h[k.to_s.downcase] = v }

      self.new(h['host'], h['path'], h['port'], h['proxy_host'], h['proxy_port'], h['user'], h['password'],
               h['use_ssl'], h['timeout'])
    end

    alias new_from_hash new3

    end


    # Add additional HTTP headers to the request
    attr_accessor :http_header_extra

    # Returns the Net::HTTPResponse object of the last RPC.
    attr_reader :http_last_response

    # Get and set the HTTP Cookie header.
    attr_accessor :cookie


    # Return the corresponding attributes.
    attr_reader :timeout, :user, :password

    # Sets the Net::HTTP#read_timeout and Net::HTTP#open_timeout to
    # +new_timeout+
    def timeout=(new_timeout)
      @timeout = new_timeout
      @http.read_timeout = @timeout
      @http.open_timeout = @timeout
    end

    # Changes the user for the Basic Authentication header to +new_user+
    def user=(new_user)
      @user = new_user
      set_auth
    end

    # Changes the password for the Basic Authentication header to
    # +new_password+
    def password=(new_password)
      @password = new_password
      set_auth
    end

    # Invokes the method named +method+ with the parameters given by
    # +args+ on the XML-RPC server.
    #
    # The +method+ parameter is converted into a String and should
    # be a valid XML-RPC method-name.
    #
    # Each parameter of +args+ must be of one of the following types,
    # where Hash, Struct and Array can contain any of these listed _types_:
    #
    # * Fixnum, Bignum
    # * TrueClass, FalseClass, +true+, +false+
    # * String, Symbol
    # * Float
    # * Hash, Struct
    # * Array
    # * Date, Time, XMLRPC::DateTime
    # * XMLRPC::Base64
    # * A Ruby object which class includes XMLRPC::Marshallable
    #   (only if Config::ENABLE_MARSHALLABLE is +true+).
    #   That object is converted into a hash, with one additional key/value
    #   pair <code>___class___</code> which contains the class name
    #   for restoring that object later.
    #
    # The method returns the return-value from the Remote Procedure Call.
    #
    # The type of the return-value is one of the types shown above.
    #
    # A Bignum is only allowed when it fits in 32-bit. A XML-RPC
    # +dateTime.iso8601+ type is always returned as a XMLRPC::DateTime object.
    # Struct is never returned, only a Hash, the same for a Symbol, where as a
    # String is always returned. XMLRPC::Base64 is returned as a String from
    # xmlrpc4r version 1.6.1 on.
    #
    # If the remote procedure returned a fault-structure, then a
    # XMLRPC::FaultException exception is raised, which has two accessor-methods
    # +faultCode+ an Integer, and +faultString+ a String.
    def call(method, *args)
      ok, param = call2(method, *args)
      if ok
        param
      else
        raise param
      end
    end

    # The difference between this method and XMLRPC::Client#call is, that
    # this method will <b>NOT</b> raise a XMLRPC::FaultException exception.
    #
    # The method returns an array of two values. The first value indicates if
    # the second value is +true+ or an XMLRPC::FaultException.
    #
    # Both are explained in XMLRPC::Client#call.
    #
    # Simple to remember: The "2" in "call2" denotes the number of values it returns.
    def call2(method, *args)
      request = create().methodCall(method, *args)
      data = do_rpc(request, false)
      parser().parseMethodResponse(data)
    end

    # Similar to XMLRPC::Client#call, however can be called concurrently and
    # use a new connection for each request. In contrast to the corresponding
    # method without the +_async+ suffix, which use connect-alive (one
    # connection for all requests).
    #
    # Note, that you have to use Thread to call these methods concurrently.
    # The following example calls two methods concurrently:
    #
    #   Thread.new {
    #     p client.call_async("michael.add", 4, 5)
    #   }
    #
    #   Thread.new {
    #     p client.call_async("michael.div", 7, 9)
    #   }
    #
    def call_async(method, *args)
      ok, param = call2_async(method, *args)
      if ok
        param
      else
        raise param
      end
    end

    # Same as XMLRPC::Client#call2, but can be called concurrently.
    #
    # See also XMLRPC::Client#call_async
    def call2_async(method, *args)
      request = create().methodCall(method, *args)
      data = do_rpc(request, true)
      parser().parseMethodResponse(data)
    end


    # You can use this method to execute several methods on a XMLRPC server
    # which support the multi-call extension.
    #
    #     s.multicall(
    #       ['michael.add', 3, 4],
    #       ['michael.sub', 4, 5]
    #     )
    #     # => [7, -1]
    def multicall(*methods)
      ok, params = multicall2(*methods)
      if ok
        params
      else
        raise params
      end
    end

    # Same as XMLRPC::Client#multicall, but returns two parameters instead of
    # raising an XMLRPC::FaultException.
    #
    # See XMLRPC::Client#call2
    def multicall2(*methods)
      gen_multicall(methods, false)
    end

    # Similar to XMLRPC::Client#multicall, however can be called concurrently and
    # use a new connection for each request. In contrast to the corresponding
    # method without the +_async+ suffix, which use connect-alive (one
    # connection for all requests).
    #
    # Note, that you have to use Thread to call these methods concurrently.
    # The following example calls two methods concurrently:
    #
    #   Thread.new {
    #     p client.multicall_async("michael.add", 4, 5)
    #   }
    #
    #   Thread.new {
    #     p client.multicall_async("michael.div", 7, 9)
    #   }
    #
    def multicall_async(*methods)
      ok, params = multicall2_async(*methods)
      if ok
        params
      else
        raise params
      end
    end

    # Same as XMLRPC::Client#multicall2, but can be called concurrently.
    #
    # See also XMLRPC::Client#multicall_async
    def multicall2_async(*methods)
      gen_multicall(methods, true)
    end


    # Returns an object of class XMLRPC::Client::Proxy, initialized with
    # +prefix+ and +args+.
    #
    # A proxy object returned by this method behaves like XMLRPC::Client#call,
    # i.e. a call on that object will raise a XMLRPC::FaultException when a
    # fault-structure is returned by that call.
    def proxy(prefix=nil, *args)
      Proxy.new(self, prefix, args, :call)
    end

    # Almost the same like XMLRPC::Client#proxy only that a call on the returned
    # XMLRPC::Client::Proxy object will return two parameters.
    #
    # See XMLRPC::Client#call2
    def proxy2(prefix=nil, *args)
      Proxy.new(self, prefix, args, :call2)
    end

    # Similar to XMLRPC::Client#proxy, however can be called concurrently and
    # use a new connection for each request. In contrast to the corresponding
    # method without the +_async+ suffix, which use connect-alive (one
    # connection for all requests).
    #
    # Note, that you have to use Thread to call these methods concurrently.
    # The following example calls two methods concurrently:
    #
    #   Thread.new {
    #     p client.proxy_async("michael.add", 4, 5)
    #   }
    #
    #   Thread.new {
    #     p client.proxy_async("michael.div", 7, 9)
    #   }
    #
    def proxy_async(prefix=nil, *args)
      Proxy.new(self, prefix, args, :call_async)
    end

    # Same as XMLRPC::Client#proxy2, but can be called concurrently.
    #
    # See also XMLRPC::Client#proxy_async
    def proxy2_async(prefix=nil, *args)
      Proxy.new(self, prefix, args, :call2_async)
    end


    private

    def net_http(host, port, proxy_host, proxy_port)
      Net::HTTP.new host, port, proxy_host, proxy_port
    end

    def set_auth
      if @user.nil?
        @auth = nil
      else
        a =  "#@user"
        a << ":#@password" if @password != nil
        @auth = "Basic " + [a].pack("m0")
      end
    end

    def do_rpc(request, async=false)
      header = {
       "User-Agent"     =>  USER_AGENT,
       "Content-Type"   => "text/xml; charset=utf-8",
       "Content-Length" => request.bytesize.to_s,
       "Connection"     => (async ? "close" : "keep-alive")
      }

      header["Cookie"] = @cookie        if @cookie
      header.update(@http_header_extra) if @http_header_extra

      if @auth != nil
        # add authorization header
        header["Authorization"] = @auth
      end

      resp = nil
      @http_last_response = nil

      if async
        # use a new HTTP object for each call
        http = net_http(@host, @port, @proxy_host, @proxy_port)
        http.use_ssl = @use_ssl if @use_ssl
        http.read_timeout = @timeout
        http.open_timeout = @timeout

        # post request
        http.start {
          resp = http.request_post(@path, request, header)
        }
      else
        # reuse the HTTP object for each call => connection alive is possible
        # we must start connection explicitely first time so that http.request
        # does not assume that we don't want keepalive
        @http.start if not @http.started?

        # post request
        resp = @http.request_post(@path, request, header)
      end

      @http_last_response = resp

      data = resp.body

      if resp.code == "401"
        # Authorization Required
        raise "Authorization failed.\nHTTP-Error: #{resp.code} #{resp.message}"
      elsif resp.code[0,1] != "2"
        raise "HTTP-Error: #{resp.code} #{resp.message}"
      end

      # assume text/xml on instances where Content-Type header is not set
      ct_expected = resp["Content-Type"] || 'text/xml'
      ct = parse_content_type(ct_expected).first
      if ct != "text/xml"
        if ct == "text/html"
          raise "Wrong content-type (received '#{ct}' but expected 'text/xml'): \n#{data}"
        else
          raise "Wrong content-type (received '#{ct}' but expected 'text/xml')"
        end
      end

      expected = resp["Content-Length"] || "<unknown>"
      if data.nil? or data.bytesize == 0
        raise "Wrong size. Was #{data.bytesize}, should be #{expected}"
      end

      set_cookies = resp.get_fields("Set-Cookie")
      if set_cookies and !set_cookies.empty?
        require 'webrick/cookie'
        @cookie = set_cookies.collect do |set_cookie|
          cookie = WEBrick::Cookie.parse_set_cookie(set_cookie)
          WEBrick::Cookie.new(cookie.name, cookie.value).to_s
        end.join("; ")
      end

      return data
    end

    def gen_multicall(methods=[], async=false)
      meth = :call2
      meth = :call2_async if async

      ok, params = self.send(meth, "system.multicall",
        methods.collect {|m| {'methodName' => m[0], 'params' => m[1..-1]} }
      )

      if ok
        params = params.collect do |param|
          if param.is_a? Array
            param[0]
          elsif param.is_a? Hash
            XMLRPC::FaultException.new(param["faultCode"], param["faultString"])
          else
            raise "Wrong multicall return value"
          end
        end
      end

      return ok, params
    end



    # XML-RPC calls look nicer!
    #
    # You can call any method onto objects of that class - the object handles
    # XMLRPC::Client::Proxy#method_missing and will forward the method call to
    # a XML-RPC server.
    #
    # Don't use this class directly, instead use the public instance method
    # XMLRPC::Client#proxy or XMLRPC::Client#proxy2.
    #
    #     require "xmlrpc/client"
    #
    #     server = XMLRPC::Client.new("www.ruby-lang.org", "/RPC2", 80)
    #
    #     michael  = server.proxy("michael")
    #     michael2 = server.proxy("michael", 4)
    #
    #     # both calls should return the same value '9'.
    #     p michael.add(4,5)
    #     p michael2.add(5)
    class Proxy

      # Creates an object which provides XMLRPC::Client::Proxy#method_missing.
      #
      # The given +server+ must be an instance of XMLRPC::Client, which is the
      # XML-RPC server to be used for a XML-RPC call.
      #
      # +prefix+ and +delim+ will be prepended to the method name called onto this object.
      #
      # An optional parameter +meth+ is the method to use for a RPC.
      # It can be either, call, call2, call_async, call2_async
      #
      # +args+ are arguments which are automatically given to every XML-RPC
      # call before being provided through +method_missing+.
      def initialize(server, prefix, args=[], meth=:call, delim=".")
        @server = server
        @prefix = prefix ? prefix + delim : ""
        @args   = args
        @meth   = meth
      end

      # Every method call is forwarded to the XML-RPC server defined in
      # XMLRPC::Client::Proxy#new.
      #
      # Note: Inherited methods from class Object cannot be used as XML-RPC
      # names, because they get around +method_missing+.
      def method_missing(mid, *args)
        pre = @prefix + mid.to_s
        arg = @args + args
        @server.send(@meth, pre, *arg)
      end

    end # class Proxy

  end # class Client

end # module XMLRPC

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         config.rb                                                                                           0100644 0001750 0001750 00000001735 12024241522 035375  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    #
# $Id: config.rb 36958 2012-09-13 02:22:10Z zzak $
# Configuration file for XML-RPC for Ruby
#

module XMLRPC # :nodoc:

  module Config

    # or XMLWriter::XMLParser
    DEFAULT_WRITER = XMLWriter::Simple

    # === Available parsers
    #
    # * XMLParser::NQXMLTreeParser
    # * XMLParser::NQXMLStreamParser
    # * XMLParser::XMLTreeParser
    # * XMLParser::XMLStreamParser (fastest)
    # * XMLParser::REXMLStreamParser
    # * XMLParser::XMLScanStreamParser
    DEFAULT_PARSER = XMLParser::REXMLStreamParser

    # enable <code><nil/></code> tag
    ENABLE_NIL_CREATE    = false
    ENABLE_NIL_PARSER    = false

    # allows integers greater than 32-bit if +true+
    ENABLE_BIGINT        = false

    # enable marshalling ruby objects which include XMLRPC::Marshallable
    ENABLE_MARSHALLING   = true

    # enable multiCall extension by default
    ENABLE_MULTICALL     = false

    # enable Introspection extension by default
    ENABLE_INTROSPECTION = false

  end

end

                                   create.rb                                                                                           0100644 0001750 0001750 00000015043 12024241522 035370  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    #
# Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# $Id: create.rb 36958 2012-09-13 02:22:10Z zzak $
#

require "date"
require "xmlrpc/base64"

module XMLRPC # :nodoc:

  module XMLWriter

    class Abstract
      def ele(name, *children)
        element(name, nil, *children)
      end

      def tag(name, txt)
        element(name, nil, text(txt))
      end
    end


    class Simple < Abstract

      def document_to_str(doc)
        doc
      end

      def document(*params)
        params.join("")
      end

      def pi(name, *params)
        "<?#{name} " + params.join(" ") + " ?>"
      end

      def element(name, attrs, *children)
        raise "attributes not yet implemented" unless attrs.nil?
        if children.empty?
          "<#{name}/>"
        else
          "<#{name}>" + children.join("") + "</#{name}>"
        end
      end

      def text(txt)
        cleaned = txt.dup
        cleaned.gsub!(/&/, '&amp;')
        cleaned.gsub!(/</, '&lt;')
        cleaned.gsub!(/>/, '&gt;')
        cleaned
      end

    end # class Simple


    class XMLParser < Abstract

      def initialize
        require "xmltreebuilder"
      end

      def document_to_str(doc)
        doc.to_s
      end

      def document(*params)
        XML::SimpleTree::Document.new(*params)
      end

      def pi(name, *params)
        XML::SimpleTree::ProcessingInstruction.new(name, *params)
      end

      def element(name, attrs, *children)
        XML::SimpleTree::Element.new(name, attrs, *children)
      end

      def text(txt)
        XML::SimpleTree::Text.new(txt)
      end

    end # class XMLParser

    Classes = [Simple, XMLParser]

    # yields an instance of each installed XML writer
    def self.each_installed_writer
      XMLRPC::XMLWriter::Classes.each do |klass|
        begin
          yield klass.new
        rescue LoadError
        end
      end
    end

  end # module XMLWriter

  # Creates XML-RPC call/response documents
  #
  class Create

    def initialize(xml_writer = nil)
      @writer = xml_writer || Config::DEFAULT_WRITER.new
    end


    def methodCall(name, *params)
      name = name.to_s

      if name !~ /[a-zA-Z0-9_.:\/]+/
        raise ArgumentError, "Wrong XML-RPC method-name"
      end

      parameter = params.collect do |param|
        @writer.ele("param", conv2value(param))
      end

      tree = @writer.document(
               @writer.pi("xml", 'version="1.0"'),
               @writer.ele("methodCall",
                 @writer.tag("methodName", name),
                 @writer.ele("params", *parameter)
               )
             )

      @writer.document_to_str(tree) + "\n"
    end



    #
    # Generates a XML-RPC methodResponse document
    #
    # When +is_ret+ is +false+ then the +params+ array must
    # contain only one element, which is a structure
    # of a fault return-value.
    #
    # When +is_ret+ is +true+ then a normal
    # return-value of all the given +params+ is created.
    #
    def methodResponse(is_ret, *params)

      if is_ret
        resp = params.collect do |param|
          @writer.ele("param", conv2value(param))
        end

        resp = [@writer.ele("params", *resp)]
      else
        if params.size != 1 or params[0] === XMLRPC::FaultException
          raise ArgumentError, "no valid fault-structure given"
        end
        resp = @writer.ele("fault", conv2value(params[0].to_h))
      end


      tree = @writer.document(
               @writer.pi("xml", 'version="1.0"'),
               @writer.ele("methodResponse", resp)
             )

      @writer.document_to_str(tree) + "\n"
    end



    private

    #
    # Converts a Ruby object into a XML-RPC <code><value></code> tag
    #
    def conv2value(param) # :doc:

        val = case param
        when Fixnum, Bignum
          # XML-RPC's int is 32bit int, and Fixnum also may be beyond 32bit
          if Config::ENABLE_BIGINT
            @writer.tag("i4", param.to_s)
          else
            if param >= -(2**31) and param <= (2**31-1)
              @writer.tag("i4", param.to_s)
            else
              raise "Bignum is too big! Must be signed 32-bit integer!"
            end
          end
        when TrueClass, FalseClass
          @writer.tag("boolean", param ? "1" : "0")

        when Symbol
          @writer.tag("string", param.to_s)

        when String
          @writer.tag("string", param)

        when NilClass
          if Config::ENABLE_NIL_CREATE
            @writer.ele("nil")
          else
            raise "Wrong type NilClass. Not allowed!"
          end

        when Float
          raise "Wrong value #{param}. Not allowed!" unless param.finite?
          @writer.tag("double", param.to_s)

        when Struct
          h = param.members.collect do |key|
            value = param[key]
            @writer.ele("member",
              @writer.tag("name", key.to_s),
              conv2value(value)
            )
          end

          @writer.ele("struct", *h)

        when Hash
          # TODO: can a Hash be empty?

          h = param.collect do |key, value|
            @writer.ele("member",
              @writer.tag("name", key.to_s),
              conv2value(value)
            )
          end

          @writer.ele("struct", *h)

        when Array
          # TODO: can an Array be empty?
          a = param.collect {|v| conv2value(v) }

          @writer.ele("array",
            @writer.ele("data", *a)
          )

        when Time, Date, ::DateTime
          @writer.tag("dateTime.iso8601", param.strftime("%Y%m%dT%H:%M:%S"))

        when XMLRPC::DateTime
          @writer.tag("dateTime.iso8601",
            format("%.4d%02d%02dT%02d:%02d:%02d", *param.to_a))

        when XMLRPC::Base64
          @writer.tag("base64", param.encoded)

        else
          if Config::ENABLE_MARSHALLING and param.class.included_modules.include? XMLRPC::Marshallable
            # convert Ruby object into Hash
            ret = {"___class___" => param.class.name}
            param.instance_variables.each {|v|
              name = v[1..-1]
              val = param.instance_variable_get(v)

              if val.nil?
                ret[name] = val if Config::ENABLE_NIL_CREATE
              else
                ret[name] = val
              end
            }
            return conv2value(ret)
          else
            ok, pa = wrong_type(param)
            if ok
              return conv2value(pa)
            else
              raise "Wrong type!"
            end
          end
        end

        @writer.ele("value", val)
    end

    def wrong_type(value)
      false
    end


  end # class Create

end # module XMLRPC

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             datetime.rb                                                                                         0100644 0001750 0001750 00000007040 12024241522 035717  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    #
# xmlrpc/datetime.rb
# Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# Released under the same term of license as Ruby.
#
require "date"

module XMLRPC # :nodoc:

# This class is important to handle XMLRPC +dateTime.iso8601+ values,
# correcly, because normal UNIX-dates, ie: Date, only handle dates
# from year 1970 on, and ruby's native Time class handles dates without the
# time component.
#
# XMLRPC::DateTime is able to store a XMLRPC +dateTime.iso8601+ value correctly.
class DateTime

  # Return the value of the specified date/time component.
  attr_reader :year, :month, :day, :hour, :min, :sec

  # Set +value+ as the new date/time component.
  #
  # Raises ArgumentError if the given +value+ is out of range, or in the case
  # of XMLRPC::DateTime#year= if +value+ is not of type Integer.
  def year= (value)
    raise ArgumentError, "date/time out of range" unless value.is_a? Integer
    @year = value
  end

  # Set +value+ as the new date/time component.
  #
  # Raises an ArgumentError if the given +value+ isn't between 1 and 12.
  def month= (value)
    raise ArgumentError, "date/time out of range" unless (1..12).include? value
    @month = value
  end

  # Set +value+ as the new date/time component.
  #
  # Raises an ArgumentError if the given +value+ isn't between 1 and 31.
  def day= (value)
    raise ArgumentError, "date/time out of range" unless (1..31).include? value
    @day = value
  end

  # Set +value+ as the new date/time component.
  #
  # Raises an ArgumentError if the given +value+ isn't between 0 and 24.
  def hour= (value)
    raise ArgumentError, "date/time out of range" unless (0..24).include? value
    @hour = value
  end

  # Set +value+ as the new date/time component.
  #
  # Raises an ArgumentError if the given +value+ isn't between 0 and 59.
  def min= (value)
    raise ArgumentError, "date/time out of range" unless (0..59).include? value
    @min = value
  end

  # Set +value+ as the new date/time component.
  #
  # Raises an ArgumentError if the given +value+ isn't between 0 and 59.
  def sec= (value)
    raise ArgumentError, "date/time out of range" unless (0..59).include? value
    @sec = value
  end

  # Alias for XMLRPC::DateTime#month.
  alias mon  month
  # Alias for XMLRPC::DateTime#month=.
  alias mon= month=


  # Creates a new XMLRPC::DateTime instance with the
  # parameters +year+, +month+, +day+ as date and
  # +hour+, +min+, +sec+ as time.
  #
  # Raises an ArgumentError if a parameter is out of range,
  # or if +year+ is not of the Integer type.
  def initialize(year, month, day, hour, min, sec)
    self.year, self.month, self.day = year, month, day
    self.hour, self.min, self.sec   = hour, min, sec
  end

  # Return a Time object of the date/time which represents +self+.
  # If the <code>@year</code> is below 1970, this method returns +nil+,
  # because Time cannot handle years below 1970.
  #
  # The timezone used is GMT.
  def to_time
    if @year >= 1970
      Time.gm(*to_a)
    else
      nil
    end
  end

  # Return a Date object of the date which represents +self+.
  #
  # The Date object do _not_ contain the time component (only date).
  def to_date
    Date.new(*to_a[0,3])
  end

  # Returns all date/time components in an array.
  #
  # Returns +[year, month, day, hour, min, sec]+.
  def to_a
    [@year, @month, @day, @hour, @min, @sec]
  end

  # Returns whether or not all date/time components are an array.
  def ==(o)
    self.to_a == Array(o) rescue false
  end

end


end # module XMLRPC


=begin
= History
    $Id: datetime.rb 36958 2012-09-13 02:22:10Z zzak $
=end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                httpserver.rb                                                                                       0100644 0001750 0001750 00000010203 12024241522 036324  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    # Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# $Id: httpserver.rb 36958 2012-09-13 02:22:10Z zzak $
#


require "gserver"

# Implements a simple HTTP-server by using John W. Small's (jsmall@laser.net)
# ruby-generic-server: GServer.
class HttpServer < GServer

  ##
  # +handle_obj+ specifies the object, that receives calls from +request_handler+
  # and +ip_auth_handler+
  def initialize(handle_obj, port = 8080, host = DEFAULT_HOST, maxConnections = 4,
                 stdlog = $stdout, audit = true, debug = true)
    @handler = handle_obj
    super(port, host, maxConnections, stdlog, audit, debug)
  end

private

  CRLF        = "\r\n"
  HTTP_PROTO  = "HTTP/1.0"
  SERVER_NAME = "HttpServer (Ruby #{RUBY_VERSION})"

  # Default header for the server name
  DEFAULT_HEADER = {
    "Server" => SERVER_NAME
  }

  # Mapping of status codes and error messages
  StatusCodeMapping = {
    200 => "OK",
    400 => "Bad Request",
    403 => "Forbidden",
    405 => "Method Not Allowed",
    411 => "Length Required",
    500 => "Internal Server Error"
  }

  class Request
    attr_reader :data, :header, :method, :path, :proto

    def initialize(data, method=nil, path=nil, proto=nil)
      @header, @data = Table.new, data
      @method, @path, @proto = method, path, proto
    end

    def content_length
      len = @header['Content-Length']
      return nil if len.nil?
      return len.to_i
    end

  end

  class Response
    attr_reader   :header
    attr_accessor :body, :status, :status_message

    def initialize(status=200)
      @status = status
      @status_message = nil
      @header = Table.new
    end
  end

  # A case-insensitive Hash class for HTTP header
  class Table
    include Enumerable

    def initialize(hash={})
      @hash = hash
      update(hash)
    end

    def [](key)
      @hash[key.to_s.capitalize]
    end

    def []=(key, value)
      @hash[key.to_s.capitalize] = value
    end

    def update(hash)
      hash.each {|k,v| self[k] = v}
      self
    end

    def each
      @hash.each {|k,v| yield k.capitalize, v }
    end

    # Output the Hash table for the HTTP header
    def writeTo(port)
      each { |k,v| port << "#{k}: #{v}" << CRLF }
    end
  end # class Table


  # Generates a Hash with the HTTP headers
  def http_header(header=nil) # :doc:
    new_header = Table.new(DEFAULT_HEADER)
    new_header.update(header) unless header.nil?

    new_header["Connection"] = "close"
    new_header["Date"]       = http_date(Time.now)

    new_header
  end

  # Returns a string which represents the time as rfc1123-date of HTTP-date
  def http_date( aTime ) # :doc:
    aTime.gmtime.strftime( "%a, %d %b %Y %H:%M:%S GMT" )
  end

  # Returns a string which includes the status code message as,
  # http headers, and body for the response.
  def http_resp(status_code, status_message=nil, header=nil, body=nil) # :doc:
    status_message ||= StatusCodeMapping[status_code]

    str = ""
    str << "#{HTTP_PROTO} #{status_code} #{status_message}" << CRLF
    http_header(header).writeTo(str)
    str << CRLF
    str << body unless body.nil?
    str
  end

  # Handles the HTTP request and writes the response back to the client, +io+.
  #
  # If an Exception is raised while handling the request, the client will receive
  # a 500 "Internal Server Error" message.
  def serve(io) # :doc:
    # perform IP authentification
    unless @handler.ip_auth_handler(io)
      io << http_resp(403, "Forbidden")
      return
    end

    # parse first line
    if io.gets =~ /^(\S+)\s+(\S+)\s+(\S+)/
      request = Request.new(io, $1, $2, $3)
    else
      io << http_resp(400, "Bad Request")
      return
    end

    # parse HTTP headers
    while (line=io.gets) !~ /^(\n|\r)/
      if line =~ /^([\w-]+):\s*(.*)$/
        request.header[$1] = $2.strip
      end
    end

    io.binmode
    response = Response.new

    # execute request handler
    @handler.request_handler(request, response)

    # write response back to the client
    io << http_resp(response.status, response.status_message,
                    response.header, response.body)

  rescue Exception
    io << http_resp(500, "Internal Server Error")
  end

end # class HttpServer

                                                                                                                                                                                                                                                                                                                                                                                             marshal.rb                                                                                          0100644 0001750 0001750 00000002734 12024241522 035557  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    #
# Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# $Id: marshal.rb 36958 2012-09-13 02:22:10Z zzak $
#

require "xmlrpc/parser"
require "xmlrpc/create"
require "xmlrpc/config"
require "xmlrpc/utils"

module XMLRPC # :nodoc:

  # Marshalling of XMLRPC::Create#methodCall and XMLRPC::Create#methodResponse
  class Marshal
    include ParserWriterChooseMixin

    class << self

      def dump_call( methodName, *params )
        new.dump_call( methodName, *params )
      end

      def dump_response( param )
        new.dump_response( param )
      end

      def load_call( stringOrReadable )
        new.load_call( stringOrReadable )
      end

      def load_response( stringOrReadable )
        new.load_response( stringOrReadable )
      end

      alias dump dump_response
      alias load load_response

    end # class self

    def initialize( parser = nil, writer = nil )
      set_parser( parser )
      set_writer( writer )
    end

    def dump_call( methodName, *params )
      create.methodCall( methodName, *params )
    end

    def dump_response( param )
      create.methodResponse( ! param.kind_of?( XMLRPC::FaultException ) , param )
    end

    # Returns <code>[ methodname, params ]</code>
    def load_call( stringOrReadable )
      parser.parseMethodCall( stringOrReadable )
    end

    # Returns +paramOrFault+
    def load_response( stringOrReadable )
      parser.parseMethodResponse( stringOrReadable )[1]
    end

  end # class Marshal

end
                                    parser.rb                                                                                           0100644 0001750 0001750 00000050010 12051470001 035406  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    # Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# $Id: parser.rb 37688 2012-11-16 16:55:29Z marcandre $
#


require "date"
require "xmlrpc/base64"
require "xmlrpc/datetime"


module NQXML
  class Node

    def removeChild(node)
      @children.delete(node)
    end
    def childNodes
      @children
    end
    def hasChildNodes
      not @children.empty?
    end
    def [] (index)
      @children[index]
    end

    def nodeType
      if @entity.instance_of? NQXML::Text then :TEXT
      elsif @entity.instance_of? NQXML::Comment then :COMMENT
      #elsif @entity.instance_of? NQXML::Element then :ELEMENT
      elsif @entity.instance_of? NQXML::Tag then :ELEMENT
      else :ELSE
      end
    end

    def nodeValue
      #TODO: error when wrong Entity-type
      @entity.text
    end
    def nodeName
      #TODO: error when wrong Entity-type
      @entity.name
    end
  end # class Node
end # module NQXML

module XMLRPC # :nodoc:

  # Raised when the remote procedure returns a fault-structure, which has two
  # accessor-methods +faultCode+ an Integer, and +faultString+ a String.
  class FaultException < StandardError
    attr_reader :faultCode, :faultString

    # Creates a new XMLRPC::FaultException instance.
    #
    # +faultString+ is passed to StandardError as the +msg+ of the Exception.
    def initialize(faultCode, faultString)
      @faultCode   = faultCode
      @faultString = faultString
      super(@faultString)
    end

    # The +faultCode+ and +faultString+ of the exception in a Hash.
    def to_h
      {"faultCode" => @faultCode, "faultString" => @faultString}
    end
  end

  # Helper class used to convert types.
  module Convert

    # Converts a String to an Integer
    #
    # See also String.to_i
    def self.int(str)
      str.to_i
    end

    # Converts a String to +true+ or +false+
    #
    # Raises an exception if +str+ is not +0+ or +1+
    def self.boolean(str)
      case str
      when "0" then false
      when "1" then true
      else
        raise "RPC-value of type boolean is wrong"
      end
    end

    # Converts a String to a Float
    #
    # See also String.to_f
    def self.double(str)
      str.to_f
    end

    # Converts a the given +str+ to a +dateTime.iso8601+ formatted date.
    #
    # Raises an exception if the String isn't in +dateTime.iso8601+ format.
    #
    # See also, XMLRPC::DateTime
    def self.dateTime(str)
      case str
      when /^(-?\d\d\d\d)-?(\d\d)-?(\d\d)T(\d\d):(\d\d):(\d\d)(?:Z|([+-])(\d\d):?(\d\d))?$/
        a = [$1, $2, $3, $4, $5, $6].collect{|i| i.to_i}
        if $7
          ofs = $8.to_i*3600 + $9.to_i*60
          ofs = -ofs if $7=='+'
          utc = Time.utc(*a) + ofs
          a = [ utc.year, utc.month, utc.day, utc.hour, utc.min, utc.sec ]
        end
        XMLRPC::DateTime.new(*a)
      when /^(-?\d\d)-?(\d\d)-?(\d\d)T(\d\d):(\d\d):(\d\d)(Z|([+-]\d\d):(\d\d))?$/
        a = [$1, $2, $3, $4, $5, $6].collect{|i| i.to_i}
        if a[0] < 70
          a[0] += 2000
        else
          a[0] += 1900
        end
        if $7
          ofs = $8.to_i*3600 + $9.to_i*60
          ofs = -ofs if $7=='+'
          utc = Time.utc(*a) + ofs
          a = [ utc.year, utc.month, utc.day, utc.hour, utc.min, utc.sec ]
        end
        XMLRPC::DateTime.new(*a)
      else
        raise "wrong dateTime.iso8601 format " + str
      end
    end

    # Decodes the given +str+ using XMLRPC::Base64.decode
    def self.base64(str)
      XMLRPC::Base64.decode(str)
    end

    # Converts the given +hash+ to a marshalled object.
    #
    # Returns the given +hash+ if an exception occurs.
    def self.struct(hash)
      # convert to marshalled object
      klass = hash["___class___"]
      if klass.nil? or Config::ENABLE_MARSHALLING == false
        hash
      else
        begin
          mod = Module
          klass.split("::").each {|const| mod = mod.const_get(const.strip)}

          obj = mod.allocate

          hash.delete "___class___"
          hash.each {|key, value|
            obj.instance_variable_set("@#{ key }", value) if key =~ /^([a-zA-Z_]\w*)$/
          }
          obj
        rescue
          hash
        end
      end
    end

    # Converts the given +hash+ to an XMLRPC::FaultException object by passing
    # the +faultCode+ and +faultString+ attributes of the Hash to
    # XMLRPC::FaultException.new
    #
    # Raises an Exception if the given +hash+ doesn't meet the requirements.
    # Those requirements being:
    # * 2 keys
    # * <code>'faultCode'</code> key is an Integer
    # * <code>'faultString'</code> key is a String
    def self.fault(hash)
      if hash.kind_of? Hash and hash.size == 2 and
        hash.has_key? "faultCode" and hash.has_key? "faultString" and
        hash["faultCode"].kind_of? Integer and hash["faultString"].kind_of? String

        XMLRPC::FaultException.new(hash["faultCode"], hash["faultString"])
      else
        raise "wrong fault-structure: #{hash.inspect}"
      end
    end

  end # module Convert

  # Parser for XML-RPC call and response
  module XMLParser

    class AbstractTreeParser

      def parseMethodResponse(str)
        methodResponse_document(createCleanedTree(str))
      end

      def parseMethodCall(str)
        methodCall_document(createCleanedTree(str))
      end

      private

      # Removes all whitespaces but in the tags i4, i8, int, boolean....
      # and all comments
      def removeWhitespacesAndComments(node)
        remove = []
        childs = node.childNodes.to_a
        childs.each do |nd|
          case _nodeType(nd)
          when :TEXT
            # TODO: add nil?
            unless %w(i4 i8 int boolean string double dateTime.iso8601 base64).include? node.nodeName

               if node.nodeName == "value"
                 if not node.childNodes.to_a.detect {|n| _nodeType(n) == :ELEMENT}.nil?
                   remove << nd if nd.nodeValue.strip == ""
                 end
               else
                 remove << nd if nd.nodeValue.strip == ""
               end
            end
          when :COMMENT
            remove << nd
          else
            removeWhitespacesAndComments(nd)
          end
        end

        remove.each { |i| node.removeChild(i) }
      end


      def nodeMustBe(node, name)
        cmp = case name
        when Array
          name.include?(node.nodeName)
        when String
          name == node.nodeName
        else
          raise "error"
        end

        if not cmp then
          raise "wrong xml-rpc (name)"
        end

        node
      end

      # Returns, when successfully the only child-node
      def hasOnlyOneChild(node, name=nil)
        if node.childNodes.to_a.size != 1
          raise "wrong xml-rpc (size)"
        end
        if name != nil then
          nodeMustBe(node.firstChild, name)
        end
      end


      def assert(b)
        if not b then
          raise "assert-fail"
        end
      end

      # The node `node` has empty string or string
      def text_zero_one(node)
        nodes = node.childNodes.to_a.size

        if nodes == 1
          text(node.firstChild)
        elsif nodes == 0
          ""
        else
          raise "wrong xml-rpc (size)"
        end
      end


      def integer(node)
        #TODO: check string for float because to_i returnsa
        #      0 when wrong string
         nodeMustBe(node, %w(i4 i8 int))
        hasOnlyOneChild(node)

        Convert.int(text(node.firstChild))
      end

      def boolean(node)
        nodeMustBe(node, "boolean")
        hasOnlyOneChild(node)

        Convert.boolean(text(node.firstChild))
      end

      def v_nil(node)
        nodeMustBe(node, "nil")
        assert( node.childNodes.to_a.size == 0 )
        nil
      end

      def string(node)
        nodeMustBe(node, "string")
        text_zero_one(node)
      end

      def double(node)
        #TODO: check string for float because to_f returnsa
        #      0.0 when wrong string
        nodeMustBe(node, "double")
        hasOnlyOneChild(node)

        Convert.double(text(node.firstChild))
      end

      def dateTime(node)
        nodeMustBe(node, "dateTime.iso8601")
        hasOnlyOneChild(node)

        Convert.dateTime( text(node.firstChild) )
      end

      def base64(node)
        nodeMustBe(node, "base64")
        #hasOnlyOneChild(node)

        Convert.base64(text_zero_one(node))
      end

      def member(node)
        nodeMustBe(node, "member")
        assert( node.childNodes.to_a.size == 2 )

        [ name(node[0]), value(node[1]) ]
      end

      def name(node)
        nodeMustBe(node, "name")
        #hasOnlyOneChild(node)
        text_zero_one(node)
      end

      def array(node)
        nodeMustBe(node, "array")
        hasOnlyOneChild(node, "data")
        data(node.firstChild)
      end

      def data(node)
        nodeMustBe(node, "data")

        node.childNodes.to_a.collect do |val|
          value(val)
        end
      end

      def param(node)
        nodeMustBe(node, "param")
        hasOnlyOneChild(node, "value")
        value(node.firstChild)
      end

      def methodResponse(node)
        nodeMustBe(node, "methodResponse")
        hasOnlyOneChild(node, %w(params fault))
        child = node.firstChild

        case child.nodeName
        when "params"
          [ true, params(child,false) ]
        when "fault"
          [ false, fault(child) ]
        else
          raise "unexpected error"
        end

      end

      def methodName(node)
        nodeMustBe(node, "methodName")
        hasOnlyOneChild(node)
        text(node.firstChild)
      end

      def params(node, call=true)
        nodeMustBe(node, "params")

        if call
          node.childNodes.to_a.collect do |n|
            param(n)
          end
        else # response (only one param)
          hasOnlyOneChild(node)
          param(node.firstChild)
        end
      end

      def fault(node)
        nodeMustBe(node, "fault")
        hasOnlyOneChild(node, "value")
        f = value(node.firstChild)
        Convert.fault(f)
      end



      # _nodeType is defined in the subclass
      def text(node)
        assert( _nodeType(node) == :TEXT )
        assert( node.hasChildNodes == false )
        assert( node.nodeValue != nil )

        node.nodeValue.to_s
      end

      def struct(node)
        nodeMustBe(node, "struct")

        hash = {}
        node.childNodes.to_a.each do |me|
          n, v = member(me)
          hash[n] = v
        end

        Convert.struct(hash)
      end


      def value(node)
        nodeMustBe(node, "value")
        nodes = node.childNodes.to_a.size
        if nodes == 0
          return ""
        elsif nodes > 1
          raise "wrong xml-rpc (size)"
        end

        child = node.firstChild

        case _nodeType(child)
        when :TEXT
          text_zero_one(node)
        when :ELEMENT
          case child.nodeName
          when "i4", "i8", "int"  then integer(child)
          when "boolean"          then boolean(child)
          when "string"           then string(child)
          when "double"           then double(child)
          when "dateTime.iso8601" then dateTime(child)
          when "base64"           then base64(child)
          when "struct"           then struct(child)
          when "array"            then array(child)
          when "nil"
            if Config::ENABLE_NIL_PARSER
              v_nil(child)
            else
              raise "wrong/unknown XML-RPC type 'nil'"
            end
          else
            raise "wrong/unknown XML-RPC type"
          end
        else
          raise "wrong type of node"
        end

      end

      def methodCall(node)
        nodeMustBe(node, "methodCall")
        assert( (1..2).include?( node.childNodes.to_a.size ) )
        name = methodName(node[0])

        if node.childNodes.to_a.size == 2 then
          pa = params(node[1])
        else # no parameters given
          pa = []
        end
        [name, pa]
      end

    end # module TreeParserMixin

    class AbstractStreamParser
      def parseMethodResponse(str)
        parser = @parser_class.new
        parser.parse(str)
        raise "No valid method response!" if parser.method_name != nil
        if parser.fault != nil
          # is a fault structure
          [false, parser.fault]
        else
          # is a normal return value
          raise "Missing return value!" if parser.params.size == 0
          raise "Too many return values. Only one allowed!" if parser.params.size > 1
          [true, parser.params[0]]
        end
      end

      def parseMethodCall(str)
        parser = @parser_class.new
        parser.parse(str)
        raise "No valid method call - missing method name!" if parser.method_name.nil?
        [parser.method_name, parser.params]
      end
    end

    module StreamParserMixin
      attr_reader :params
      attr_reader :method_name
      attr_reader :fault

      def initialize(*a)
        super(*a)
        @params = []
        @values = []
        @val_stack = []

        @names = []
        @name = []

        @structs = []
        @struct = {}

        @method_name = nil
        @fault = nil

        @data = nil
      end

      def startElement(name, attrs=[])
        @data = nil
        case name
        when "value"
          @value = nil
        when "nil"
          raise "wrong/unknown XML-RPC type 'nil'" unless Config::ENABLE_NIL_PARSER
          @value = :nil
        when "array"
          @val_stack << @values
          @values = []
        when "struct"
          @names << @name
          @name = []

          @structs << @struct
          @struct = {}
        end
      end

      def endElement(name)
        @data ||= ""
        case name
        when "string"
          @value = @data
        when "i4", "i8", "int"
          @value = Convert.int(@data)
        when "boolean"
          @value = Convert.boolean(@data)
        when "double"
          @value = Convert.double(@data)
        when "dateTime.iso8601"
          @value = Convert.dateTime(@data)
        when "base64"
          @value = Convert.base64(@data)
        when "value"
          @value = @data if @value.nil?
          @values << (@value == :nil ? nil : @value)
        when "array"
          @value = @values
          @values = @val_stack.pop
        when "struct"
          @value = Convert.struct(@struct)

          @name = @names.pop
          @struct = @structs.pop
        when "name"
          @name[0] = @data
        when "member"
          @struct[@name[0]] = @values.pop

        when "param"
          @params << @values[0]
          @values = []

        when "fault"
          @fault = Convert.fault(@values[0])

        when "methodName"
          @method_name = @data
        end

        @data = nil
      end

      def character(data)
        if @data
          @data << data
        else
          @data = data
        end
      end

    end # module StreamParserMixin

    class XMLStreamParser < AbstractStreamParser
      def initialize
        require "xmlparser"
        @parser_class = Class.new(::XMLParser) {
          include StreamParserMixin
        }
      end
    end # class XMLStreamParser

    class NQXMLStreamParser < AbstractStreamParser
      def initialize
        require "nqxml/streamingparser"
        @parser_class = XMLRPCParser
      end

      class XMLRPCParser
        include StreamParserMixin

        def parse(str)
          parser = NQXML::StreamingParser.new(str)
          parser.each do |ele|
            case ele
            when NQXML::Text
              @data = ele.text
              #character(ele.text)
            when NQXML::Tag
              if ele.isTagEnd
                endElement(ele.name)
              else
                startElement(ele.name, ele.attrs)
              end
            end
          end # do
        end # method parse
      end # class XMLRPCParser

    end # class NQXMLStreamParser

    class XMLTreeParser < AbstractTreeParser

      def initialize
        require "xmltreebuilder"

        # The new XMLParser library (0.6.2+) uses a slightly different DOM implementation.
        # The following code removes the differences between both versions.
        if defined? XML::DOM::Builder
          return if defined? XML::DOM::Node::DOCUMENT # code below has been already executed
          klass = XML::DOM::Node
          klass.const_set(:DOCUMENT, klass::DOCUMENT_NODE)
          klass.const_set(:TEXT, klass::TEXT_NODE)
          klass.const_set(:COMMENT, klass::COMMENT_NODE)
          klass.const_set(:ELEMENT, klass::ELEMENT_NODE)
        end
      end

      private

      def _nodeType(node)
        tp = node.nodeType
        if tp == XML::SimpleTree::Node::TEXT then :TEXT
        elsif tp == XML::SimpleTree::Node::COMMENT then :COMMENT
        elsif tp == XML::SimpleTree::Node::ELEMENT then :ELEMENT
        else :ELSE
        end
      end


      def methodResponse_document(node)
        assert( node.nodeType == XML::SimpleTree::Node::DOCUMENT )
        hasOnlyOneChild(node, "methodResponse")

        methodResponse(node.firstChild)
      end

      def methodCall_document(node)
        assert( node.nodeType == XML::SimpleTree::Node::DOCUMENT )
        hasOnlyOneChild(node, "methodCall")

        methodCall(node.firstChild)
      end

      def createCleanedTree(str)
        doc = XML::SimpleTreeBuilder.new.parse(str)
        doc.documentElement.normalize
        removeWhitespacesAndComments(doc)
        doc
      end

    end # class XMLParser

    class NQXMLTreeParser < AbstractTreeParser

      def initialize
        require "nqxml/treeparser"
      end

      private

      def _nodeType(node)
        node.nodeType
      end

      def methodResponse_document(node)
        methodResponse(node)
      end

      def methodCall_document(node)
        methodCall(node)
      end

      def createCleanedTree(str)
        doc = ::NQXML::TreeParser.new(str).document.rootNode
        removeWhitespacesAndComments(doc)
        doc
      end

    end # class NQXMLTreeParser

    class REXMLStreamParser < AbstractStreamParser
      def initialize
        require "rexml/document"
        @parser_class = StreamListener
      end

      class StreamListener
        include StreamParserMixin

        alias :tag_start :startElement
        alias :tag_end :endElement
        alias :text :character
        alias :cdata :character

        def method_missing(*a)
          # ignore
        end

        def parse(str)
          REXML::Document.parse_stream(str, self)
        end
      end

    end

    class XMLScanStreamParser < AbstractStreamParser
      def initialize
        require "xmlscan/parser"
        @parser_class = XMLScanParser
      end

      class XMLScanParser
        include StreamParserMixin

        Entities = {
          "lt"   => "<",
          "gt"   => ">",
          "amp"  => "&",
          "quot" => '"',
          "apos" => "'"
        }

        def parse(str)
          parser  = XMLScan::XMLParser.new(self)
          parser.parse(str)
        end

        alias :on_stag :startElement
        alias :on_etag :endElement

        def on_stag_end(name); end

        def on_stag_end_empty(name)
          startElement(name)
          endElement(name)
        end

        def on_chardata(str)
          character(str)
        end

        def on_cdata(str)
          character(str)
        end

        def on_entityref(ent)
          str = Entities[ent]
          if str
            character(str)
          else
            raise "unknown entity"
          end
        end

        def on_charref(code)
          character(code.chr)
        end

        def on_charref_hex(code)
          character(code.chr)
        end

        def method_missing(*a)
        end

        # TODO: call/implement?
        # valid_name?
        # valid_chardata?
        # valid_char?
        # parse_error

      end
    end

    XMLParser   = XMLTreeParser
    NQXMLParser = NQXMLTreeParser

    Classes = [XMLStreamParser, XMLTreeParser,
               NQXMLStreamParser, NQXMLTreeParser,
               REXMLStreamParser, XMLScanStreamParser]

    # yields an instance of each installed parser
    def self.each_installed_parser
      XMLRPC::XMLParser::Classes.each do |klass|
        begin
          yield klass.new
        rescue LoadError
        end
      end
    end

  end # module XMLParser


end # module XMLRPC

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        server.rb                                                                                           0100644 0001750 0001750 00000047471 12256326071 035457  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    # xmlrpc/server.rb
# Copyright (C) 2001, 2002, 2003, 2005 by Michael Neumann (mneumann@ntecs.de)
#
# Released under the same term of license as Ruby.

require "xmlrpc/parser"
require "xmlrpc/create"
require "xmlrpc/config"
require "xmlrpc/utils"         # ParserWriterChooseMixin



module XMLRPC # :nodoc:


# This is the base class for all XML-RPC server-types (CGI, standalone).
# You can add handler and set a default handler.
# Do not use this server, as this is/should be an abstract class.
#
# === How the method to call is found
# The arity (number of accepted arguments) of a handler (method or Proc
# object) is compared to the given arguments submitted by the client for a
# RPC, or Remote Procedure Call.
#
# A handler is only called if it accepts the number of arguments, otherwise
# the search for another handler will go on. When at the end no handler was
# found, the default_handler, XMLRPC::BasicServer#set_default_handler will be
# called.
#
# With this technique it is possible to do overloading by number of parameters, but
# only for Proc handler, because you cannot define two methods of the same name in
# the same class.
class BasicServer

  include ParserWriterChooseMixin
  include ParseContentType

  ERR_METHOD_MISSING        = 1
  ERR_UNCAUGHT_EXCEPTION    = 2
  ERR_MC_WRONG_PARAM        = 3
  ERR_MC_MISSING_PARAMS     = 4
  ERR_MC_MISSING_METHNAME   = 5
  ERR_MC_RECURSIVE_CALL     = 6
  ERR_MC_WRONG_PARAM_PARAMS = 7
  ERR_MC_EXPECTED_STRUCT    = 8


  # Creates a new XMLRPC::BasicServer instance, which should not be
  # done, because XMLRPC::BasicServer is an abstract class. This
  # method should be called from a subclass indirectly by a +super+ call
  # in the initialize method.
  #
  # The paramter +class_delim+ is used by add_handler, see
  # XMLRPC::BasicServer#add_handler, when an object is added as a handler, to
  # delimit the object-prefix and the method-name.
  def initialize(class_delim=".")
    @handler = []
    @default_handler = nil
    @service_hook = nil

    @class_delim = class_delim
    @create = nil
    @parser = nil

    add_multicall     if Config::ENABLE_MULTICALL
    add_introspection if Config::ENABLE_INTROSPECTION
  end

  # Adds +aBlock+ to the list of handlers, with +name+ as the name of
  # the method.
  #
  # Parameters +signature+ and +help+ are used by the Introspection method if
  # specified, where +signature+ is either an Array containing strings each
  # representing a type of it's signature (the first is the return value) or
  # an Array of Arrays if the method has multiple signatures.
  #
  # Value type-names are "int, boolean, double, string, dateTime.iso8601,
  # base64, array, struct".
  #
  # Parameter +help+ is a String with information about how to call this method etc.
  #
  # When a method fails, it can tell the client by throwing an
  # XMLRPC::FaultException like in this example:
  #
  #     s.add_handler("michael.div") do |a,b|
  #       if b == 0
  #         raise XMLRPC::FaultException.new(1, "division by zero")
  #       else
  #         a / b
  #       end
  #     end
  #
  # In the case of <code>b==0</code> the client gets an object back of type
  # XMLRPC::FaultException that has a +faultCode+ and +faultString+ field.
  #
  # This is the second form of ((<add_handler|XMLRPC::BasicServer#add_handler>)).
  # To add an object write:
  #
  #     server.add_handler("michael", MyHandlerClass.new)
  #
  # All public methods of MyHandlerClass are accessible to
  # the XML-RPC clients by <code>michael."name of method"</code>. This is
  # where the +class_delim+ in XMLRPC::BasicServer.new plays it's role, a
  # XML-RPC method-name is defined by +prefix+ + +class_delim+ + <code>"name
  # of method"</code>.
  #
  # The third form of +add_handler is to use XMLRPC::Service::Interface to
  # generate an object, which represents an interface (with signature and
  # help text) for a handler class.
  #
  # The +interface+ parameter must be an instance of XMLRPC::Service::Interface.
  # Adds all methods of +obj+ which are defined in the +interface+ to the server.
  #
  # This is the recommended way of adding services to a server!
  def add_handler(prefix, obj_or_signature=nil, help=nil, &block)
    if block_given?
      # proc-handler
      @handler << [prefix, block, obj_or_signature, help]
    else
      if prefix.kind_of? String
        # class-handler
        raise ArgumentError, "Expected non-nil value" if obj_or_signature.nil?
        @handler << [prefix + @class_delim, obj_or_signature]
      elsif prefix.kind_of? XMLRPC::Service::BasicInterface
        # class-handler with interface
        # add all methods
        @handler += prefix.get_methods(obj_or_signature, @class_delim)
      else
        raise ArgumentError, "Wrong type for parameter 'prefix'"
      end
    end
    self
  end

  # Returns the service-hook, which is called on each service request (RPC)
  # unless it's +nil+.
  def get_service_hook
    @service_hook
  end

  # A service-hook is called for each service request (RPC).
  #
  # You can use a service-hook for example to wrap existing methods and catch
  # exceptions of them or convert values to values recognized by XMLRPC.
  #
  # You can disable it by passing +nil+ as the +handler+ parameter.
  #
  # The service-hook is called with a Proc object along with any parameters.
  #
  # An example:
  #
  #    server.set_service_hook {|obj, *args|
  #      begin
  #        ret = obj.call(*args)  # call the original service-method
  #        # could convert the return value
  #      rescue
  #        # rescue exceptions
  #      end
  #    }
  #
  def set_service_hook(&handler)
    @service_hook = handler
    self
  end

  # Returns the default-handler, which is called when no handler for
  # a method-name is found.
  #
  # It is either a Proc object or +nil+.
  def get_default_handler
    @default_handler
  end

  # Sets +handler+ as the default-handler, which is called when
  # no handler for a method-name is found.
  #
  # +handler+ is a code-block.
  #
  # The default-handler is called with the (XML-RPC) method-name as first
  # argument, and the other arguments are the parameters given by the
  # client-call.
  #
  # If no block is specified the default of XMLRPC::BasicServer is
  # used, which raises a XMLRPC::FaultException saying "method missing".
  def set_default_handler(&handler)
    @default_handler = handler
    self
  end

  # Adds the multi-call handler <code>"system.multicall"</code>.
  def add_multicall
    add_handler("system.multicall", %w(array array), "Multicall Extension") do |arrStructs|
      unless arrStructs.is_a? Array
        raise XMLRPC::FaultException.new(ERR_MC_WRONG_PARAM, "system.multicall expects an array")
      end

      arrStructs.collect {|call|
        if call.is_a? Hash
          methodName = call["methodName"]
          params     = call["params"]

          if params.nil?
            multicall_fault(ERR_MC_MISSING_PARAMS, "Missing params")
          elsif methodName.nil?
            multicall_fault(ERR_MC_MISSING_METHNAME, "Missing methodName")
          else
            if methodName == "system.multicall"
              multicall_fault(ERR_MC_RECURSIVE_CALL, "Recursive system.multicall forbidden")
            else
              unless params.is_a? Array
                multicall_fault(ERR_MC_WRONG_PARAM_PARAMS, "Parameter params have to be an Array")
              else
                ok, val = call_method(methodName, *params)
                if ok
                  # correct return value
                  [val]
                else
                  # exception
                  multicall_fault(val.faultCode, val.faultString)
                end
              end
            end
          end

        else
          multicall_fault(ERR_MC_EXPECTED_STRUCT, "system.multicall expected struct")
        end
      }
    end # end add_handler
    self
  end

  # Adds the introspection handlers <code>"system.listMethods"</code>,
  # <code>"system.methodSignature"</code> and
  # <code>"system.methodHelp"</code>, where only the first one works.
  def add_introspection
    add_handler("system.listMethods",%w(array), "List methods available on this XML-RPC server") do
      methods = []
      @handler.each do |name, obj|
        if obj.kind_of? Proc
          methods << name
        else
          obj.class.public_instance_methods(false).each do |meth|
            methods << "#{name}#{meth}"
          end
        end
      end
      methods
    end

    add_handler("system.methodSignature", %w(array string), "Returns method signature") do |meth|
      sigs = []
      @handler.each do |name, obj, sig|
        if obj.kind_of? Proc and sig != nil and name == meth
          if sig[0].kind_of? Array
            # sig contains multiple signatures, e.g. [["array"], ["array", "string"]]
            sig.each {|s| sigs << s}
          else
            # sig is a single signature, e.g. ["array"]
            sigs << sig
          end
        end
      end
      sigs.uniq! || sigs  # remove eventually duplicated signatures
    end

    add_handler("system.methodHelp", %w(string string), "Returns help on using this method") do |meth|
      help = nil
      @handler.each do |name, obj, sig, hlp|
        if obj.kind_of? Proc and name == meth
          help = hlp
          break
        end
      end
      help || ""
    end

    self
  end



  def process(data)
    method, params = parser().parseMethodCall(data)
    handle(method, *params)
  end

  private

  def multicall_fault(nr, str)
    {"faultCode" => nr, "faultString" => str}
  end

  def dispatch(methodname, *args)
    for name, obj in @handler
      if obj.kind_of? Proc
        next unless methodname == name
      else
        next unless methodname =~ /^#{name}(.+)$/
        next unless obj.respond_to? $1
        obj = obj.method($1)
      end

      if check_arity(obj, args.size)
        if @service_hook.nil?
          return obj.call(*args)
        else
          return @service_hook.call(obj, *args)
        end
      end
    end

    if @default_handler.nil?
      raise XMLRPC::FaultException.new(ERR_METHOD_MISSING, "Method #{methodname} missing or wrong number of parameters!")
    else
      @default_handler.call(methodname, *args)
    end
  end


  # Returns +true+, if the arity of +obj+ matches +n_args+
  def check_arity(obj, n_args)
    ary = obj.arity

    if ary >= 0
      n_args == ary
    else
      n_args >= (ary+1).abs
    end
  end



  def call_method(methodname, *args)
    begin
      [true, dispatch(methodname, *args)]
    rescue XMLRPC::FaultException => e
      [false, e]
    rescue Exception => e
      [false, XMLRPC::FaultException.new(ERR_UNCAUGHT_EXCEPTION, "Uncaught exception #{e.message} in method #{methodname}")]
    end
  end

  def handle(methodname, *args)
    create().methodResponse(*call_method(methodname, *args))
  end


end


# Implements a CGI-based XML-RPC server.
#
#     require "xmlrpc/server"
#
#     s = XMLRPC::CGIServer.new
#
#     s.add_handler("michael.add") do |a,b|
#       a + b
#     end
#
#     s.add_handler("michael.div") do |a,b|
#       if b == 0
#         raise XMLRPC::FaultException.new(1, "division by zero")
#       else
#         a / b
#       end
#     end
#
#     s.set_default_handler do |name, *args|
#       raise XMLRPC::FaultException.new(-99, "Method #{name} missing" +
#                                        " or wrong number of parameters!")
#     end
#
#     s.serve
#
#
# <b>Note:</b> Make sure that you don't write to standard-output in a
# handler, or in any other part of your program, this would cause a CGI-based
# server to fail!
class CGIServer < BasicServer
  @@obj = nil

  # Creates a new XMLRPC::CGIServer instance.
  #
  # All parameters given are by-passed to XMLRPC::BasicServer.new.
  #
  # You can only create <b>one</b> XMLRPC::CGIServer instance, because more
  # than one makes no sense.
  def CGIServer.new(*a)
    @@obj = super(*a) if @@obj.nil?
    @@obj
  end

  def initialize(*a)
    super(*a)
  end

  # Call this after you have added all you handlers to the server.
  #
  # This method processes a XML-RPC method call and sends the answer
  # back to the client.
  def serve
    catch(:exit_serve) {
      length = ENV['CONTENT_LENGTH'].to_i

      http_error(405, "Method Not Allowed") unless ENV['REQUEST_METHOD'] == "POST"
      http_error(400, "Bad Request")        unless parse_content_type(ENV['CONTENT_TYPE']).first == "text/xml"
      http_error(411, "Length Required")    unless length > 0

      # TODO: do we need a call to binmode?
      $stdin.binmode if $stdin.respond_to? :binmode
      data = $stdin.read(length)

      http_error(400, "Bad Request")        if data.nil? or data.bytesize != length

      http_write(process(data), "Content-type" => "text/xml; charset=utf-8")
    }
  end


  private

  def http_error(status, message)
    err = "#{status} #{message}"
    msg = <<-"MSGEND"
      <html>
        <head>
          <title>#{err}</title>
        </head>
        <body>
          <h1>#{err}</h1>
          <p>Unexpected error occurred while processing XML-RPC request!</p>
        </body>
      </html>
    MSGEND

    http_write(msg, "Status" => err, "Content-type" => "text/html")
    throw :exit_serve # exit from the #serve method
  end

  def http_write(body, header)
    h = {}
    header.each {|key, value| h[key.to_s.capitalize] = value}
    h['Status']         ||= "200 OK"
    h['Content-length'] ||= body.bytesize.to_s

    str = ""
    h.each {|key, value| str << "#{key}: #{value}\r\n"}
    str << "\r\n#{body}"

    print str
  end

end


# Implements a XML-RPC server, which works with Apache mod_ruby.
#
# Use it in the same way as XMLRPC::CGIServer!
class ModRubyServer < BasicServer

  # Creates a new XMLRPC::ModRubyServer instance.
  #
  # All parameters given are by-passed to XMLRPC::BasicServer.new.
  def initialize(*a)
    @ap = Apache::request
    super(*a)
  end

  # Call this after you have added all you handlers to the server.
  #
  # This method processes a XML-RPC method call and sends the answer
  # back to the client.
  def serve
    catch(:exit_serve) {
      header = {}
      @ap.headers_in.each {|key, value| header[key.capitalize] = value}

      length = header['Content-length'].to_i

      http_error(405, "Method Not Allowed") unless @ap.request_method  == "POST"
      http_error(400, "Bad Request")        unless parse_content_type(header['Content-type']).first == "text/xml"
      http_error(411, "Length Required")    unless length > 0

      # TODO: do we need a call to binmode?
      @ap.binmode
      data = @ap.read(length)

      http_error(400, "Bad Request")        if data.nil? or data.bytesize != length

      http_write(process(data), 200, "Content-type" => "text/xml; charset=utf-8")
    }
  end


  private

  def http_error(status, message)
    err = "#{status} #{message}"
    msg = <<-"MSGEND"
      <html>
        <head>
          <title>#{err}</title>
        </head>
        <body>
          <h1>#{err}</h1>
          <p>Unexpected error occurred while processing XML-RPC request!</p>
        </body>
      </html>
    MSGEND

    http_write(msg, status, "Status" => err, "Content-type" => "text/html")
    throw :exit_serve # exit from the #serve method
  end

  def http_write(body, status, header)
    h = {}
    header.each {|key, value| h[key.to_s.capitalize] = value}
    h['Status']         ||= "200 OK"
    h['Content-length'] ||= body.bytesize.to_s

    h.each {|key, value| @ap.headers_out[key] = value }
    @ap.content_type = h["Content-type"]
    @ap.status = status.to_i
    @ap.send_http_header

    @ap.print body
  end

end


class WEBrickServlet < BasicServer; end # forward declaration

# Implements a standalone XML-RPC server. The method XMLRPC::Server#serve is
# left if a SIGHUP is sent to the program.
#
#    require "xmlrpc/server"
#
#   s = XMLRPC::Server.new(8080)
#
#   s.add_handler("michael.add") do |a,b|
#     a + b
#   end
#
#   s.add_handler("michael.div") do |a,b|
#     if b == 0
#       raise XMLRPC::FaultException.new(1, "division by zero")
#     else
#       a / b
#     end
#   end
#
#   s.set_default_handler do |name, *args|
#     raise XMLRPC::FaultException.new(-99, "Method #{name} missing" +
#                                      " or wrong number of parameters!")
#   end
#
#   s.serve
class Server < WEBrickServlet

  # Creates a new XMLRPC::Server instance, which is a XML-RPC server
  # listening on the given +port+ and accepts requests for the given +host+,
  # which is +localhost+ by default.
  #
  # The server is not started, to start it you have to call
  # XMLRPC::Server#serve.
  #
  # The optional +audit+ and +debug+ parameters are obsolete!
  #
  # All additionally provided parameters in <code>*a</code> are by-passed to
  # XMLRPC::BasicServer.new.
  def initialize(port=8080, host="127.0.0.1", maxConnections=4, stdlog=$stdout, audit=true, debug=true, *a)
    super(*a)
    require 'webrick'
    @server = WEBrick::HTTPServer.new(:Port => port, :BindAddress => host, :MaxClients => maxConnections,
                                      :Logger => WEBrick::Log.new(stdlog))
    @server.mount("/", self)
  end

  # Call this after you have added all you handlers to the server.
  # This method starts the server to listen for XML-RPC requests and answer them.
  def serve
    signals = %w[INT TERM HUP] & Signal.list.keys
    signals.each { |signal| trap(signal) { @server.shutdown } }

    @server.start
  end

  # Stops and shuts the server down.
  def shutdown
    @server.shutdown
  end

end


# Implements a servlet for use with WEBrick, a pure Ruby (HTTP) server
# framework.
#
#     require "webrick"
#     require "xmlrpc/server"
#
#     s = XMLRPC::WEBrickServlet.new
#     s.add_handler("michael.add") do |a,b|
#       a + b
#     end
#
#     s.add_handler("michael.div") do |a,b|
#       if b == 0
#         raise XMLRPC::FaultException.new(1, "division by zero")
#       else
#         a / b
#       end
#     end
#
#     s.set_default_handler do |name, *args|
#       raise XMLRPC::FaultException.new(-99, "Method #{name} missing" +
#                                        " or wrong number of parameters!")
#     end
#
#     httpserver = WEBrick::HTTPServer.new(:Port => 8080)
#     httpserver.mount("/RPC2", s)
#     trap("HUP") { httpserver.shutdown }   # use 1 instead of "HUP" on Windows
#     httpserver.start
class WEBrickServlet < BasicServer
  def initialize(*a)
    super
    require "webrick/httpstatus"
    @valid_ip = nil
  end

  # Deprecated from WEBrick/1.2.2, but does not break anything.
  def require_path_info?
    false
  end

  def get_instance(config, *options)
    # TODO: set config & options
    self
  end

  # Specifies the valid IP addresses that are allowed to connect to the server.
  #
  # Each IP is either a String or a Regexp.
  def set_valid_ip(*ip_addr)
    if ip_addr.size == 1 and ip_addr[0].nil?
      @valid_ip = nil
    else
      @valid_ip = ip_addr
    end
  end

  # Return the valid IP addresses that are allowed to connect to the server.
  #
  # See also, XMLRPC::Server#set_valid_ip
  def get_valid_ip
    @valid_ip
  end

  def service(request, response)

    if @valid_ip
      raise WEBrick::HTTPStatus::Forbidden unless @valid_ip.any? { |ip| request.peeraddr[3] =~ ip }
    end

    if request.request_method != "POST"
      raise WEBrick::HTTPStatus::MethodNotAllowed,
            "unsupported method `#{request.request_method}'."
    end

    if parse_content_type(request['Content-type']).first != "text/xml"
      raise WEBrick::HTTPStatus::BadRequest
    end

    length = (request['Content-length'] || 0).to_i

    raise WEBrick::HTTPStatus::LengthRequired unless length > 0

    data = request.body

    if data.nil? or data.bytesize != length
      raise WEBrick::HTTPStatus::BadRequest
    end

    resp = process(data)
    if resp.nil? or resp.bytesize <= 0
      raise WEBrick::HTTPStatus::InternalServerError
    end

    response.status = 200
    response['Content-Length'] = resp.bytesize
    response['Content-Type']   = "text/xml; charset=utf-8"
    response.body = resp
  end
end


end # module XMLRPC


=begin
= History
    $Id: server.rb 44391 2013-12-24 15:46:01Z nagachika $
=end

                                                                                                                                                                                                       utils.rb                                                                                            0100644 0001750 0001750 00000007650 12024241522 035272  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/xmlrpc                                                    #
# Copyright (C) 2001, 2002, 2003 by Michael Neumann (mneumann@ntecs.de)
#
# $Id: utils.rb 36958 2012-09-13 02:22:10Z zzak $
#
module XMLRPC # :nodoc:


  # This module enables a user-class to be marshalled
  # by XML-RPC for Ruby into a Hash, with one additional
  # key/value pair <code>___class___ => ClassName</code>
  #
  module Marshallable
  end


  # Defines ParserWriterChooseMixin, which makes it possible to choose a
  # different XMLWriter and/or XMLParser then the default one.
  #
  # The Mixin is used in client.rb (class XMLRPC::Client)
  # and server.rb (class XMLRPC::BasicServer)
  module ParserWriterChooseMixin

    # Sets the XMLWriter to use for generating XML output.
    #
    # Should be an instance of a class from module XMLRPC::XMLWriter.
    #
    # If this method is not called, then XMLRPC::Config::DEFAULT_WRITER is used.
    def set_writer(writer)
      @create = Create.new(writer)
      self
    end

    # Sets the XMLParser to use for parsing XML documents.
    #
    # Should be an instance of a class from module XMLRPC::XMLParser.
    #
    # If this method is not called, then XMLRPC::Config::DEFAULT_PARSER is used.
    def set_parser(parser)
      @parser = parser
      self
    end

    private

    def create
      # if set_writer was not already called then call it now
      if @create.nil? then
        set_writer(Config::DEFAULT_WRITER.new)
      end
      @create
    end

    def parser
      # if set_parser was not already called then call it now
      if @parser.nil? then
        set_parser(Config::DEFAULT_PARSER.new)
      end
      @parser
    end

  end # module ParserWriterChooseMixin


  module Service

  # Base class for XMLRPC::Service::Interface definitions, used
  # by XMLRPC::BasicServer#add_handler
  class BasicInterface
    attr_reader :prefix, :methods

    def initialize(prefix)
      @prefix = prefix
      @methods = []
    end

    def add_method(sig, help=nil, meth_name=nil)
      mname = nil
      sig = [sig] if sig.kind_of? String

      sig = sig.collect do |s|
        name, si = parse_sig(s)
        raise "Wrong signatures!" if mname != nil and name != mname
        mname = name
        si
      end

      @methods << [mname, meth_name || mname, sig, help]
    end

    private

    def parse_sig(sig)
      # sig is a String
      if sig =~ /^\s*(\w+)\s+([^(]+)(\(([^)]*)\))?\s*$/
        params = [$1]
        name   = $2.strip
        $4.split(",").each {|i| params << i.strip} if $4 != nil
        return name, params
      else
        raise "Syntax error in signature"
      end
    end

  end # class BasicInterface

  #
  # Class which wraps a XMLRPC::Service::Interface definition, used
  # by XMLRPC::BasicServer#add_handler
  #
  class Interface < BasicInterface
    def initialize(prefix, &p)
      raise "No interface specified" if p.nil?
      super(prefix)
      instance_eval(&p)
    end

    def get_methods(obj, delim=".")
      prefix = @prefix + delim
      @methods.collect { |name, meth, sig, help|
        [prefix + name.to_s, obj.method(meth).to_proc, sig, help]
      }
    end

    private

    def meth(*a)
      add_method(*a)
    end

  end # class Interface

  class PublicInstanceMethodsInterface < BasicInterface
    def initialize(prefix)
      super(prefix)
    end

    def get_methods(obj, delim=".")
      prefix = @prefix + delim
      obj.class.public_instance_methods(false).collect { |name|
        [prefix + name.to_s, obj.method(name).to_proc, nil, nil]
      }
    end
  end


  end # module Service


  #
  # Short-form to create a XMLRPC::Service::Interface
  #
  def self.interface(prefix, &p)
    Service::Interface.new(prefix, &p)
  end

  # Short-cut for creating a XMLRPC::Service::PublicInstanceMethodsInterface
  def self.iPIMethods(prefix)
    Service::PublicInstanceMethodsInterface.new(prefix)
  end


  module ParseContentType
    def parse_content_type(str)
      a, *b = str.split(";")
      return a.strip.downcase, *b
    end
  end

end # module XMLRPC

                                                                                        xmlrpc.rb                                                                                           0100644 0001750 0001750 00000020771 12024241710 034130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           # == Author and Copyright
#
# Copyright (C) 2001-2004 by Michael Neumann (mailto:mneumann@ntecs.de)
#
# Released under the same term of license as Ruby.
#
# == Overview
#
# XMLRPC is a lightweight protocol that enables remote procedure calls over
# HTTP.  It is defined at http://www.xmlrpc.com.
#
# XMLRPC allows you to create simple distributed computing solutions that span
# computer languages.  Its distinctive feature is its simplicity compared to
# other approaches like SOAP and CORBA.
#
# The Ruby standard library package 'xmlrpc' enables you to create a server that
# implements remote procedures and a client that calls them.  Very little code
# is required to achieve either of these.
#
# == Example
#
# Try the following code.  It calls a standard demonstration remote procedure.
#
#   require 'xmlrpc/client'
#   require 'pp'
#
#   server = XMLRPC::Client.new2("http://xmlrpc-c.sourceforge.net/api/sample.php")
#   result = server.call("sample.sumAndDifference", 5, 3)
#   pp result
#
# == Documentation
#
# See http://www.ntecs.de/projects/xmlrpc4r.  There is plenty of detail there to
# use the client and implement a server.
#
# == Features of XMLRPC for Ruby
#
# * Extensions
#   * Introspection
#   * multiCall
#   * optionally nil values and integers larger than 32 Bit
#
# * Server
#   * Standalone XML-RPC server
#   * CGI-based (works with FastCGI)
#   * Apache mod_ruby server
#   * WEBrick servlet
#
# * Client
#   * synchronous/asynchronous calls
#   * Basic HTTP-401 Authentification
#   * HTTPS protocol (SSL)
#
# * Parsers
#   * NQXML (XMLParser::NQXMLStreamParser, XMLParser::NQXMLTreeParser)
#   * Expat (XMLParser::XMLStreamParser, XMLParser::XMLTreeParser)
#   * REXML (XMLParser::REXMLStreamParser)
#   * xml-scan (XMLParser::XMLScanStreamParser)
#   * Fastest parser is Expat's XMLParser::XMLStreamParser!
#
# * General
#   * possible to choose between XMLParser module (Expat wrapper) and REXML/NQXML (pure Ruby) parsers
#   * Marshalling Ruby objects to Hashs and reconstruct them later from a Hash
#   * SandStorm component architecture XMLRPC::Client interface
#
# == Howto
#
# === Client
#
#   require "xmlrpc/client"
#
#   # Make an object to represent the XML-RPC server.
#   server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")
#
#   # Call the remote server and get our result
#   result = server.call("sample.sumAndDifference", 5, 3)
#
#   sum = result["sum"]
#   difference = result["difference"]
#
#   puts "Sum: #{sum}, Difference: #{difference}"
#
# === XMLRPC::Client with XML-RPC fault-structure handling
#
# There are two possible ways, of handling a fault-structure:
#
# ==== by catching a XMLRPC::FaultException exception
#
#   require "xmlrpc/client"
#
#   # Make an object to represent the XML-RPC server.
#   server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")
#
#   begin
#     # Call the remote server and get our result
#     result = server.call("sample.sumAndDifference", 5, 3)
#
#     sum = result["sum"]
#     difference = result["difference"]
#
#     puts "Sum: #{sum}, Difference: #{difference}"
#
#   rescue XMLRPC::FaultException => e
#     puts "Error: "
#     puts e.faultCode
#     puts e.faultString
#   end
#
# ==== by calling "call2" which returns a boolean
#
#   require "xmlrpc/client"
#
#   # Make an object to represent the XML-RPC server.
#   server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")
#
#   # Call the remote server and get our result
#   ok, result = server.call2("sample.sumAndDifference", 5, 3)
#
#   if ok
#     sum = result["sum"]
#     difference = result["difference"]
#
#     puts "Sum: #{sum}, Difference: #{difference}"
#   else
#     puts "Error: "
#     puts result.faultCode
#     puts result.faultString
#   end
#
# === Using XMLRPC::Client::Proxy
#
# You can create a Proxy object onto which you can call methods. This way it
# looks nicer. Both forms, _call_ and _call2_ are supported through _proxy_ and
# _proxy2_.  You can additionally give arguments to the Proxy, which will be
# given to each XML-RPC call using that Proxy.
#
#   require "xmlrpc/client"
#
#   # Make an object to represent the XML-RPC server.
#   server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")
#
#   # Create a Proxy object
#   sample = server.proxy("sample")
#
#   # Call the remote server and get our result
#   result = sample.sumAndDifference(5,3)
#
#   sum = result["sum"]
#   difference = result["difference"]
#
#   puts "Sum: #{sum}, Difference: #{difference}"
#
# === CGI-based server using XMLRPC::CGIServer
#
# There are also two ways to define handler, the first is
# like C/PHP, the second like Java, of course both ways
# can be mixed:
#
# ==== C/PHP-like (handler functions)
#
#   require "xmlrpc/server"
#
#   s = XMLRPC::CGIServer.new
#
#   s.add_handler("sample.sumAndDifference") do |a,b|
#     { "sum" => a + b, "difference" => a - b }
#   end
#
#   s.serve
#
# ==== Java-like (handler classes)
#
#   require "xmlrpc/server"
#
#   s = XMLRPC::CGIServer.new
#
#   class MyHandler
#     def sumAndDifference(a, b)
#       { "sum" => a + b, "difference" => a - b }
#     end
#   end
#
#   # NOTE: Security Hole (read below)!!!
#   s.add_handler("sample", MyHandler.new)
#   s.serve
#
#
# To return a fault-structure you have to raise an XMLRPC::FaultException e.g.:
#
#   raise XMLRPC::FaultException.new(3, "division by Zero")
#
# ===== Security Note
#
# From Brian Candler:
#
#   Above code sample has an extremely nasty security hole, in that you can now call
#   any method of 'MyHandler' remotely, including methods inherited from Object
#   and Kernel! For example, in the client code, you can use
#
#     puts server.call("sample.send","`","ls")
#
#   (backtick being the method name for running system processes). Needless to
#   say, 'ls' can be replaced with something else.
#
#   The version which binds proc objects (or the version presented below in the next section)
#   doesn't have this problem, but people may be tempted to use the second version because it's
#   so nice and 'Rubyesque'. I think it needs a big red disclaimer.
#
#
# From Michael:
#
# A solution is to undef insecure methods or to use
# XMLRPC::Service::PublicInstanceMethodsInterface as shown below:
#
#   class MyHandler
#     def sumAndDifference(a, b)
#       { "sum" => a + b, "difference" => a - b }
#     end
#   end
#
#   # ... server initialization ...
#
#   s.add_handler(XMLRPC::iPIMethods("sample"), MyHandler.new)
#
#   # ...
#
# This adds only public instance methods explicitly declared in class MyHandler
# (and not those inherited from any other class).
#
# ==== With interface declarations
#
# Code sample from the book Ruby Developer's Guide:
#
#   require "xmlrpc/server"
#
#   class Num
#     INTERFACE = XMLRPC::interface("num") {
#       meth 'int add(int, int)', 'Add two numbers', 'add'
#       meth 'int div(int, int)', 'Divide two numbers'
#     }
#
#     def add(a, b) a + b end
#     def div(a, b) a / b end
#   end
#
#
#   s = XMLRPC::CGIServer.new
#   s.add_handler(Num::INTERFACE, Num.new)
#   s.serve
#
# === Standalone XMLRPC::Server
#
# Same as CGI-based server, the only difference being
#
#   server = XMLRPC::CGIServer.new
#
# must be changed to
#
#   server = XMLRPC::Server.new(8080)
#
# if you want a server listening on port 8080.
# The rest is the same.
#
# === Choosing a different XMLParser or XMLWriter
#
# The examples above all use the default parser (which is now since 1.8
# XMLParser::REXMLStreamParser) and a default XMLRPC::XMLWriter.
# If you want to use a different XMLParser, then you have to call the
# ParserWriterChooseMixin#set_parser method of XMLRPC::Client instances
# or instances of subclasses of XMLRPC::BasicServer or by editing
# xmlrpc/config.rb.
#
# XMLRPC::Client Example:
#
#   # ...
#   server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")
#   server.set_parser(XMLRPC::XMLParser::XMLParser.new)
#   # ...
#
# XMLRPC::Server Example:
#
#   # ...
#   s = XMLRPC::CGIServer.new
#   s.set_parser(XMLRPC::XMLParser::XMLStreamParser.new)
#   # ...
#
# or:
#
#   # ...
#   server = XMLRPC::Server.new(8080)
#   server.set_parser(XMLRPC::XMLParser::NQXMLParser.new)
#   # ...
#
#
# Note that XMLParser::XMLStreamParser is incredible faster (and uses less memory) than any
# other parser and scales well for large documents. For example for a 0.5 MB XML
# document with many tags, XMLParser::XMLStreamParser is ~350 (!) times faster than
# XMLParser::NQXMLTreeParser and still ~18 times as fast as XMLParser::XMLTreeParser.
#
# You can change the XML-writer by calling method ParserWriterChooseMixin#set_writer.
module XMLRPC; end
       yaml/                                                                                               0040755 0001750 0001750 00000000000 12612224746 033251  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           dbm.rb                                                                                              0100644 0001750 0001750 00000013225 11637614356 034346  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/yaml                                                      require 'yaml'
require 'dbm'

module YAML

# YAML + DBM = YDBM
#
# YAML::DBM provides the same interface as ::DBM.
#
# However, while DBM only allows strings for both keys and values,
# this library allows one to use most Ruby objects for values
# by first converting them to YAML. Keys must be strings.
#
# Conversion to and from YAML is performed automatically.
#
# See the documentation for ::DBM and ::YAML for more information.
class DBM < ::DBM
    VERSION = "0.1"

    # Return value associated with +key+ from database.
    #
    # Returns +nil+ if there is no such +key+.
    def []( key )
        fetch( key )
    end

    # :call-seq:
    #   []=( key, value )
    #
    # Set +key+ to +value+ in database.
    #
    # +value+ will be converted to YAML before storage.
    def []=( key, val )
        store( key, val )
    end

    # :call-seq:
    #   fetch( key, ifnone = nil )
    #   fetch( key, &block )
    #
    # Return value associated with +key+.
    #
    # If there is no value for +key+ and no block is given, returns +ifnone+.
    #
    # Otherwise, calls block passing in the given +key+.
    def fetch( keystr, ifnone = nil )
        begin
            val = super( keystr )
            return YAML.load( val ) if String === val
        rescue IndexError
        end
        if block_given?
            yield keystr
        else
            ifnone
        end
    end

    # Deprecated, used YAML::DBM#key instead.
    # ----
    # Note:
    # YAML::DBM#index makes warning from internal of ::DBM#index.
    # It says 'DBM#index is deprecated; use DBM#key', but DBM#key
    # behaves not same as DBM#index.
    #
    def index( keystr )
        super( keystr.to_yaml )
    end

    def key( keystr )
        invert[keystr]
    end

    # Returns an array containing the values associated with the given keys.
    def values_at( *keys )
        keys.collect { |k| fetch( k ) }
    end

    # Deletes value from database associated with +key+.
    #
    # Returns value or +nil+.
    def delete( key )
        v = super( key )
        if String === v
            v = YAML.load( v )
        end
        v
    end

    # Calls the given block once for each +key+, +value+ pair in the database.
    # Deletes all entries for which the block returns true.
    #
    # Returns +self+.
    def delete_if # :yields: [key, value]
        del_keys = keys.dup
        del_keys.delete_if { |k| yield( k, fetch( k ) ) == false }
        del_keys.each { |k| delete( k ) }
        self
    end

    # Converts the contents of the database to an in-memory Hash, then calls
    # Hash#reject with the specified code block, returning a new Hash.
    def reject
        hsh = self.to_hash
        hsh.reject { |k,v| yield k, v }
    end

    # Calls the given block once for each +key+, +value+ pair in the database.
    #
    # Returns +self+.
    def each_pair # :yields: [key, value]
        keys.each { |k| yield k, fetch( k ) }
        self
    end

    # Calls the given block for each value in database.
    #
    # Returns +self+.
    def each_value # :yields: value
        super { |v| yield YAML.load( v ) }
        self
    end

    # Returns an array of values from the database.
    def values
        super.collect { |v| YAML.load( v ) }
    end

    # Returns true if specified value is found in the database.
    def has_value?( val )
        each_value { |v| return true if v == val }
        return false
    end

    # Returns a Hash (not a DBM database) created by using each value in the
    # database as a key, with the corresponding key as its value.
    #
    # Note that all values in the hash will be Strings, but the keys will be
    # actual objects.
    def invert
        h = {}
        keys.each { |k| h[ self.fetch( k ) ] = k }
        h
    end

    # Replaces the contents of the database with the contents of the specified
    # object. Takes any object which implements the each_pair method, including
    # Hash and DBM objects.
    def replace( hsh )
        clear
        update( hsh )
    end

    # Removes a [key, value] pair from the database, and returns it.
    # If the database is empty, returns +nil+.
    #
    # The order in which values are removed/returned is not guaranteed.
    def shift
        a = super
        a[1] = YAML.load( a[1] ) if a
        a
    end

    # :call-seq:
    #   select( &block )
    #   select( *keys )
    #
    # If a block is provided, returns a new array containing [key, value] pairs
    # for which the block returns true.
    #
    # Otherwise, same as #values_at
    def select( *keys )
        if block_given?
            self.keys.collect { |k| v = self[k]; [k, v] if yield k, v }.compact
        else
            values_at( *keys )
        end
    end

    # :call-seq:
    #   store( key, value )
    #
    #Stores +value+ in database with +key+ as the index. +value+ is converted
    #to YAML before being stored.
    #
    #Returns +value+
    def store( key, val )
        super( key, val.to_yaml )
        val
    end

    # Updates the database with multiple values from the specified object.
    # Takes any object which implements the each_pair method, including
    # Hash and DBM objects.
    #
    # Returns +self+.
    def update( hsh )
        hsh.each_pair do |k,v|
            self.store( k, v )
        end
        self
    end

    # Converts the contents of the database to an array of [key, value] arrays,
    # and returns it.
    def to_a
        a = []
        keys.each { |k| a.push [ k, self.fetch( k ) ] }
        a
    end


    # Converts the contents of the database to an in-memory Hash object, and
    # returns it.
    def to_hash
        h = {}
        keys.each { |k| h[ k ] = self.fetch( k ) }
        h
    end

    alias :each :each_pair
end

end
                                                                                                                                                                                                                                                                                                                                                                           store.rb                                                                                            0100644 0001750 0001750 00000003174 11641746207 034736  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/yaml                                                      #
# YAML::Store
#
require 'yaml'
require 'pstore'

# YAML::Store provides the same functionality as PStore, except it uses YAML
# to dump objects instead of Marshal.
#
# == Example
#
#   require 'yaml/store'
#
#   Person = Struct.new :first_name, :last_name
#
#   people = [Person.new("Bob", "Smith"), Person.new("Mary", "Johnson")]
#
#   store = YAML::Store.new "test.store"
#
#   store.transaction do
#     store["people"] = people
#     store["greeting"] = { "hello" => "world" }
#   end
#
# After running the above code, the contents of "test.store" will be:
#
#   ---
#   people:
#   - !ruby/struct:Person
#     first_name: Bob
#     last_name: Smith
#   - !ruby/struct:Person
#     first_name: Mary
#     last_name: Johnson
#   greeting:
#     hello: world

class YAML::Store < PStore

  # :call-seq:
  #   initialize( file_name, yaml_opts = {} )
  #
  # Creates a new YAML::Store object, which will store data in +file_name+.
  # If the file does not already exist, it will be created.
  #
  #
  # Options passed in through +yaml_opts+ will be used when converting the
  # store to YAML via Hash#to_yaml().
  def initialize file_name, yaml_opts = {}
    @opt = yaml_opts
    super
  end

  # :stopdoc:

  def dump(table)
    YAML.dump @table
  end

  def load(content)
    table = YAML.load(content)
    if table == false
      {}
    else
      table
    end
  end

  def marshal_dump_supports_canonical_option?
    false
  end

  EMPTY_MARSHAL_DATA = YAML.dump({})
  EMPTY_MARSHAL_CHECKSUM = Digest::MD5.digest(EMPTY_MARSHAL_DATA)
  def empty_marshal_data
    EMPTY_MARSHAL_DATA
  end
  def empty_marshal_checksum
    EMPTY_MARSHAL_CHECKSUM
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                    yaml.rb                                                                                             0100644 0001750 0001750 00000004466 12146220627 033601  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0                                                           ##
# The YAML module is an alias of Psych, the YAML engine for ruby.

begin
  require 'psych'
rescue LoadError
  warn "#{caller[0]}:"
  warn "It seems your ruby installation is missing psych (for YAML output)."
  warn "To eliminate this warning, please install libyaml and reinstall your ruby."
  raise
end

YAML = Psych

module Psych # :nodoc:
  # For compatibility, deprecated
  class EngineManager # :nodoc:
    attr_reader :yamler # :nodoc:

    def initialize # :nodoc:
      @yamler = 'psych'
    end

    def syck? # :nodoc:
      false
    end

    # Psych is always used and this method has no effect.
    #
    # This method is still present for compatibility.
    #
    # You may still use the Syck engine by installing
    # the 'syck' gem and using the Syck constant.
    def yamler= engine # :nodoc:
      case engine
      when 'syck' then warn "syck has been removed, psych is used instead"
      when 'psych' then @yamler = 'psych'
      else
        raise(ArgumentError, "bad engine")
      end

      engine
    end
  end

  ENGINE = EngineManager.new # :nodoc:
end

# YAML Ain't Markup Language
#
# This module provides a Ruby interface for data serialization in YAML format.
#
# The underlying implementation is the libyaml wrapper Psych.
#
# == Usage
#
# Working with YAML can be very simple, for example:
#
#     require 'yaml' # STEP ONE, REQUIRE YAML!
#     # Parse a YAML string
#     YAML.load("--- foo") #=> "foo"
#
#     # Emit some YAML
#     YAML.dump("foo")     # => "--- foo\n...\n"
#     { :a => 'b'}.to_yaml  # => "---\n:a: b\n"
#
# == Security
#
# Do not use YAML to load untrusted data. Doing so is unsafe and could allow
# malicious input to execute arbitrary code inside your application. Please see
# doc/security.rdoc for more information.
#
# == History
#
# Syck was the original for YAML implementation in Ruby's standard library
# developed by why the lucky stiff.
#
# You can still use Syck, if you prefer, for parsing and emitting YAML, but you
# must install the 'syck' gem now in order to use it.
#
# In older Ruby versions, ie. <= 1.9, Syck is still provided, however it was
# completely removed with the release of Ruby 2.0.0.
#
# == More info
#
# For more advanced details on the implementation see Psych, and also check out
# http://yaml.org for spec details and other helpful information.
module YAML
end
                                                                                                                                                                                                          gems/                                                                                               0040755 0001750 0001750 00000000000 12612224746 032605  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby                                                                 2.0.0/                                                                                              0040755 0001750 0001750 00000000000 12612224746 033242  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems                                                            gems/                                                                                               0040755 0001750 0001750 00000000000 12612224746 034175  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0                                                      CFPropertyList-2.2.8/                                                                               0040755 0001750 0001750 00000000000 12612224746 037533  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems                                                 lib/                                                                                                0040755 0001750 0001750 00000000000 12612224746 040301  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8                            cfpropertylist/                                                                                     0040755 0001750 0001750 00000000000 12612224746 043372  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        cfpropertylist/rbBinaryCFPropertyList.rb                                                            0100644 0001750 0001750 00000044522 12566211275 050306  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-

require 'stringio'

module CFPropertyList
  # Binary PList parser class
  class Binary
    # Read a binary plist file
    def load(opts)
      @unique_table = {}
      @count_objects = 0
      @object_refs = 0

      @written_object_count = 0
      @object_table = []
      @object_ref_size = 0

      @offsets = []

      fd = nil
      if(opts.has_key?(:file))
        fd = File.open(opts[:file],"rb")
        file = opts[:file]
      else
        fd = StringIO.new(opts[:data],"rb")
        file = "<string>"
      end

      # first, we read the trailer: 32 byte from the end
      fd.seek(-32,IO::SEEK_END)
      buff = fd.read(32)

      offset_size, object_ref_size, number_of_objects, top_object, table_offset = buff.unpack "x6CCx4Nx4Nx4N"

      # after that, get the offset table
      fd.seek(table_offset, IO::SEEK_SET)
      coded_offset_table = fd.read(number_of_objects * offset_size)
      raise CFFormatError.new("#{file}: Format error!") unless coded_offset_table.bytesize == number_of_objects * offset_size

      @count_objects = number_of_objects

      # decode offset table
      if(offset_size != 3)
        formats = ["","C*","n*","","N*"]
        @offsets = coded_offset_table.unpack(formats[offset_size])
      else
        @offsets = coded_offset_table.unpack("C*").each_slice(3).map {
          |x,y,z| (x << 16) | (y << 8) | z
        }
      end

      @object_ref_size = object_ref_size
      val = read_binary_object_at(file,fd,top_object)

      fd.close
      val
    end


    # Convert CFPropertyList to binary format; since we have to count our objects we simply unique CFDictionary and CFArray
    def to_str(opts={})
      @unique_table = {}
      @count_objects = 0
      @object_refs = 0

      @written_object_count = 0
      @object_table = []

      @offsets = []

      binary_str = "bplist00"

      @object_refs = count_object_refs(opts[:root])

      opts[:root].to_binary(self)

      next_offset = 8
      offsets = @object_table.map do |object|
        offset = next_offset
        next_offset += object.bytesize
        offset
      end
      binary_str << @object_table.join

      table_offset = next_offset
      offset_size = Binary.bytes_needed(table_offset)

      if offset_size < 8
        # Fast path: encode the entire offset array at once.
        binary_str << offsets.pack((%w(C n N N)[offset_size - 1]) + '*')
      else
        # Slow path: host may be little or big endian, must pack each offset
        # separately.
        offsets.each do |offset|
          binary_str << "#{Binary.pack_it_with_size(offset_size,offset)}"
        end
      end

      binary_str << [offset_size, object_ref_size(@object_refs)].pack("x6CC")
      binary_str << [@object_table.size].pack("x4N")
      binary_str << [0].pack("x4N")
      binary_str << [table_offset].pack("x4N")

      binary_str
    end

    def object_ref_size object_refs
      Binary.bytes_needed(object_refs)
    end

    # read a „null” type (i.e. null byte, marker byte, bool value)
    def read_binary_null_type(length)
      case length
      when 0  then 0 # null byte
      when 8  then CFBoolean.new(false)
      when 9  then CFBoolean.new(true)
      when 15 then 15 # fill type
      else
        raise CFFormatError.new("unknown null type: #{length}")
      end
    end
    protected :read_binary_null_type

    # read a binary int value
    def read_binary_int(fname,fd,length)
      if length > 3
        raise CFFormatError.new("Integer greater than 8 bytes: #{length}")
      end

      nbytes = 1 << length

      buff = fd.read(nbytes)

      CFInteger.new(
        case length
        when 0 then buff.unpack("C")[0]
        when 1 then buff.unpack("n")[0]
        when 2 then buff.unpack("N")[0]
        when 3
          hiword,loword = buff.unpack("NN")
          if (hiword & 0x80000000) != 0
            # 8 byte integers are always signed, and are negative when bit 63 is
            # set. Decoding into either a Fixnum or Bignum is tricky, however,
            # because the size of a Fixnum varies among systems, and Ruby
            # doesn't consider the number to be negative, and won't sign extend.
            -(2**63 - ((hiword & 0x7fffffff) << 32 | loword))
          else
            hiword << 32 | loword
          end
        end
      )
    end
    protected :read_binary_int

    # read a binary real value
    def read_binary_real(fname,fd,length)
      raise CFFormatError.new("Real greater than 8 bytes: #{length}") if length > 3

      nbytes = 1 << length
      buff = fd.read(nbytes)

      CFReal.new(
        case length
        when 0 # 1 byte float? must be an error
          raise CFFormatError.new("got #{length+1} byte float, must be an error!")
        when 1 # 2 byte float? must be an error
          raise CFFormatError.new("got #{length+1} byte float, must be an error!")
        when 2 then
          buff.reverse.unpack("f")[0]
        when 3 then
          buff.reverse.unpack("d")[0]
        else
          fail "unexpected length: #{length}"
        end
      )
    end
    protected :read_binary_real

    # read a binary date value
    def read_binary_date(fname,fd,length)
      raise CFFormatError.new("Date greater than 8 bytes: #{length}") if length > 3

      nbytes = 1 << length
      buff = fd.read(nbytes)

      CFDate.new(
        case length
        when 0 then # 1 byte CFDate is an error
          raise CFFormatError.new("#{length+1} byte CFDate, error")
        when 1 then # 2 byte CFDate is an error
          raise CFFormatError.new("#{length+1} byte CFDate, error")
        when 2 then
          buff.reverse.unpack("f")[0]
        when 3 then
          buff.reverse.unpack("d")[0]
        end,
        CFDate::TIMESTAMP_APPLE
      )
    end
    protected :read_binary_date

    # Read a binary data value
    def read_binary_data(fname,fd,length)
      CFData.new(read_fd(fd, length), CFData::DATA_RAW)
    end
    protected :read_binary_data

    def read_fd fd, length
      length > 0 ? fd.read(length) : ""
    end

    # Read a binary string value
    def read_binary_string(fname,fd,length)
      buff = read_fd fd, length
      @unique_table[buff] = true unless @unique_table.has_key?(buff)
      CFString.new(buff)
    end
    protected :read_binary_string

    # Convert the given string from one charset to another
    def Binary.charset_convert(str,from,to="UTF-8")
      return str.dup.force_encoding(from).encode(to) if str.respond_to?("encode")
      Iconv.conv(to,from,str)
    end

    # Count characters considering character set
    def Binary.charset_strlen(str,charset="UTF-8")
      if str.respond_to?(:encode)
        size = str.length
      else
        utf8_str = Iconv.conv("UTF-8",charset,str)
        size = utf8_str.scan(/./mu).size
      end

      # UTF-16 code units in the range D800-DBFF are the beginning of
      # a surrogate pair, and count as one additional character for
      # length calculation.
      if charset =~ /^UTF-16/
        if str.respond_to?(:encode)
          str.bytes.to_a.each_slice(2) { |pair| size += 1 if (0xd8..0xdb).include?(pair[0]) }
        else
          str.split('').each_slice(2) { |pair| size += 1 if ("\xd8".."\xdb").include?(pair[0]) }
        end
      end

      size
    end

    # Read a unicode string value, coded as UTF-16BE
    def read_binary_unicode_string(fname,fd,length)
      # The problem is: we get the length of the string IN CHARACTERS;
      # since a char in UTF-16 can be 16 or 32 bit long, we don't really know
      # how long the string is in bytes
      buff = fd.read(2*length)

      @unique_table[buff] = true unless @unique_table.has_key?(buff)
      CFString.new(Binary.charset_convert(buff,"UTF-16BE","UTF-8"))
    end
    protected :read_binary_unicode_string

    def unpack_with_size(nbytes, buff)
      format = ["C*", "n*", "N*", "N*"][nbytes - 1];

      if nbytes == 3
        buff = "\0" + buff.scan(/.{1,3}/).join("\0")
      end

      return buff.unpack(format)
    end

    # Read an binary array value, including contained objects
    def read_binary_array(fname,fd,length)
      ary = []

      # first: read object refs
      if(length != 0)
        buff = fd.read(length * @object_ref_size)
        objects = unpack_with_size(@object_ref_size, buff) #buff.unpack(@object_ref_size == 1 ? "C*" : "n*")

        # now: read objects
        0.upto(length-1) do |i|
          object = read_binary_object_at(fname,fd,objects[i])
          ary.push object
        end
      end

      CFArray.new(ary)
    end
    protected :read_binary_array

    # Read a dictionary value, including contained objects
    def read_binary_dict(fname,fd,length)
      dict = {}

      # first: read keys
      if(length != 0) then
        buff = fd.read(length * @object_ref_size)
        keys = unpack_with_size(@object_ref_size, buff)

        # second: read object refs
        buff = fd.read(length * @object_ref_size)
        objects = unpack_with_size(@object_ref_size, buff)

        # read real keys and objects
        0.upto(length-1) do |i|
          key = read_binary_object_at(fname,fd,keys[i])
          object = read_binary_object_at(fname,fd,objects[i])
          dict[key.value] = object
        end
      end

      CFDictionary.new(dict)
    end
    protected :read_binary_dict

    # Read an object type byte, decode it and delegate to the correct
    # reader function
    def read_binary_object(fname,fd)
      # first: read the marker byte
      buff = fd.read(1)

      object_length = buff.unpack("C*")
      object_length = object_length[0] & 0xF

      buff = buff.unpack("H*")
      object_type = buff[0][0].chr

      if(object_type != "0" && object_length == 15) then
        object_length = read_binary_object(fname,fd)
        object_length = object_length.value
      end

      case object_type
      when '0' # null, false, true, fillbyte
        read_binary_null_type(object_length)
      when '1' # integer
        read_binary_int(fname,fd,object_length)
      when '2' # real
        read_binary_real(fname,fd,object_length)
      when '3' # date
        read_binary_date(fname,fd,object_length)
      when '4' # data
        read_binary_data(fname,fd,object_length)
      when '5' # byte string, usually utf8 encoded
        read_binary_string(fname,fd,object_length)
      when '6' # unicode string (utf16be)
        read_binary_unicode_string(fname,fd,object_length)
      when '8'
        CFUid.new(read_binary_int(fname, fd, object_length).value)
      when 'a' # array
        read_binary_array(fname,fd,object_length)
      when 'd' # dictionary
        read_binary_dict(fname,fd,object_length)
      end
    end
    protected :read_binary_object

    # Read an object type byte at position $pos, decode it and delegate to the correct reader function
    def read_binary_object_at(fname,fd,pos)
      position = @offsets[pos]
      fd.seek(position,IO::SEEK_SET)
      read_binary_object(fname,fd)
    end
    protected :read_binary_object_at

    # pack an +int+ of +nbytes+ with size
    def Binary.pack_it_with_size(nbytes,int)
      case nbytes
      when 1 then [int].pack('c')
      when 2 then [int].pack('n')
      when 4 then [int].pack('N')
      when 8
        [int >> 32, int & 0xFFFFFFFF].pack('NN')
      else
        raise CFFormatError.new("Don't know how to pack #{nbytes} byte integer")
      end
    end

    def Binary.pack_int_array_with_size(nbytes, array)
      case nbytes
      when 1 then array.pack('C*')
      when 2 then array.pack('n*')
      when 4 then array.pack('N*')
      when 8
        array.map { |int| [int >> 32, int & 0xFFFFFFFF].pack('NN') }.join
      else
        raise CFFormatError.new("Don't know how to pack #{nbytes} byte integer")
      end
    end

    # calculate how many bytes are needed to save +count+
    def Binary.bytes_needed(count)
      case
      when count < 2**8  then 1
      when count < 2**16 then 2
      when count < 2**32 then 4
      when count < 2**64 then 8
      else
        raise CFFormatError.new("Data size too large: #{count}")
      end
    end

    # Create a type byte for binary format as defined by apple
    def Binary.type_bytes(type, length)
      if length < 15
        [(type << 4) | length].pack('C')
      else
        bytes = [(type << 4) | 0xF]
        if length <= 0xFF
          bytes.push(0x10, length).pack('CCC')                              # 1 byte length
        elsif length <= 0xFFFF
          bytes.push(0x11, length).pack('CCn')                              # 2 byte length
        elsif length <= 0xFFFFFFFF
          bytes.push(0x12, length).pack('CCN')                              # 4 byte length
        elsif length <= 0x7FFFFFFFFFFFFFFF
          bytes.push(0x13, length >> 32, length & 0xFFFFFFFF).pack('CCNN')  # 8 byte length
        else
          raise CFFormatError.new("Integer too large: #{int}")
        end
      end
    end

    def count_object_refs(object)
      case object
      when CFArray
        contained_refs = 0
        object.value.each do |element|
          if CFArray === element || CFDictionary === element
            contained_refs += count_object_refs(element)
          end
        end
        return object.value.size + contained_refs
      when CFDictionary
        contained_refs = 0
        object.value.each_value do |value|
          if CFArray === value || CFDictionary === value
            contained_refs += count_object_refs(value)
          end
        end
        return object.value.keys.size * 2 + contained_refs
      else
        return 0
      end
    end

    def Binary.ascii_string?(str)
      if str.respond_to?(:ascii_only?)
        str.ascii_only?
      else
        str !~ /[\x80-\xFF]/mn
      end
    end

    # Uniques and transforms a string value to binary format and adds it to the object table
    def string_to_binary(val)
      val = val.to_s

      @unique_table[val] ||= begin
        if !Binary.ascii_string?(val)
          val = Binary.charset_convert(val,"UTF-8","UTF-16BE")
          bdata = Binary.type_bytes(0b0110, Binary.charset_strlen(val,"UTF-16BE"))

          val.force_encoding("ASCII-8BIT") if val.respond_to?("encode")
          @object_table[@written_object_count] = bdata << val
        else
          bdata = Binary.type_bytes(0b0101,val.bytesize)
          @object_table[@written_object_count] = bdata << val
        end

        @written_object_count += 1
        @written_object_count - 1
      end
    end

    # Codes an integer to binary format
    def int_to_binary(value)
      nbytes = 0
      nbytes = 1  if value > 0xFF # 1 byte integer
      nbytes += 1 if value > 0xFFFF # 4 byte integer
      nbytes += 1 if value > 0xFFFFFFFF # 8 byte integer
      nbytes = 3  if value < 0 # 8 byte integer, since signed

      Binary.type_bytes(0b0001, nbytes) <<
        if nbytes < 3
          [value].pack(
            if nbytes == 0    then "C"
            elsif nbytes == 1 then "n"
            else "N"
            end
          )
        else
          # 64 bit signed integer; we need the higher and the lower 32 bit of the value
          high_word = value >> 32
          low_word = value & 0xFFFFFFFF
          [high_word,low_word].pack("NN")
        end
    end

    # Codes a real value to binary format
    def real_to_binary(val)
      Binary.type_bytes(0b0010,3) << [val].pack("d").reverse
    end

    # Converts a numeric value to binary and adds it to the object table
    def num_to_binary(value)
      @object_table[@written_object_count] =
        if value.is_a?(CFInteger)
          int_to_binary(value.value)
        else
          real_to_binary(value.value)
        end

      @written_object_count += 1
      @written_object_count - 1
    end

    def uid_to_binary(value)
      nbytes = 0
      nbytes = 1  if value > 0xFF # 1 byte integer
      nbytes += 1 if value > 0xFFFF # 4 byte integer
      nbytes += 1 if value > 0xFFFFFFFF # 8 byte integer
      nbytes = 3  if value < 0 # 8 byte integer, since signed

      @object_table[@written_object_count] = Binary.type_bytes(0b1000, nbytes) <<
        if nbytes < 3
          [value].pack(
            if nbytes == 0    then "C"
            elsif nbytes == 1 then "n"
            else "N"
            end
          )
        else
          # 64 bit signed integer; we need the higher and the lower 32 bit of the value
          high_word = value >> 32
          low_word = value & 0xFFFFFFFF
          [high_word,low_word].pack("NN")
        end

      @written_object_count += 1
      @written_object_count - 1
    end

    # Convert date value (apple format) to binary and adds it to the object table
    def date_to_binary(val)
      val = val.getutc.to_f - CFDate::DATE_DIFF_APPLE_UNIX # CFDate is a real, number of seconds since 01/01/2001 00:00:00 GMT

      @object_table[@written_object_count] =
        (Binary.type_bytes(0b0011, 3) << [val].pack("d").reverse)

      @written_object_count += 1
      @written_object_count - 1
    end

    # Convert a bool value to binary and add it to the object table
    def bool_to_binary(val)

      @object_table[@written_object_count] = val ? "\x9" : "\x8" # 0x9 is 1001, type indicator for true; 0x8 is 1000, type indicator for false
      @written_object_count += 1
      @written_object_count - 1
    end

    # Convert data value to binary format and add it to the object table
    def data_to_binary(val)
      @object_table[@written_object_count] =
        (Binary.type_bytes(0b0100, val.bytesize) << val)

      @written_object_count += 1
      @written_object_count - 1
    end

    # Convert array to binary format and add it to the object table
    def array_to_binary(val)
      saved_object_count = @written_object_count
      @written_object_count += 1
      #@object_refs += val.value.size

      values = val.value.map { |v| v.to_binary(self) }
      bdata = Binary.type_bytes(0b1010, val.value.size) <<
        Binary.pack_int_array_with_size(object_ref_size(@object_refs),
                                        values)

      @object_table[saved_object_count] = bdata
      saved_object_count
    end

    # Convert dictionary to binary format and add it to the object table
    def dict_to_binary(val)
      saved_object_count = @written_object_count
      @written_object_count += 1

      #@object_refs += val.value.keys.size * 2

      keys_and_values = val.value.keys.map { |k| CFString.new(k).to_binary(self) }
      keys_and_values.concat(val.value.values.map { |v| v.to_binary(self) })

      bdata = Binary.type_bytes(0b1101,val.value.size) <<
        Binary.pack_int_array_with_size(object_ref_size(@object_refs), keys_and_values)

      @object_table[saved_object_count] = bdata
      return saved_object_count
    end
  end
end

# eof
                                                                                                                                                                              cfpropertylist/rbCFPlistError.rb                                                                    0100644 0001750 0001750 00000001063 12566211275 046557  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-
#
# Exceptions used:
# CFPlistError:: General base exception
# CFFormatError:: Format error
# CFTypeError:: Type error
#
# Easy and simple :-)
#
# Author::    Christian Kruse (mailto:cjk@wwwtech.de)
# Copyright:: Copyright (c) 2010
# License::   MIT License

# general plist error. All exceptions thrown are derived from this class.
class CFPlistError < Exception
end

# Exception thrown when format errors occur
class CFFormatError < CFPlistError
end

# Exception thrown when type errors occur
class CFTypeError < CFPlistError
end

# eof
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             cfpropertylist/rbCFPropertyList.rb                                                                  0100644 0001750 0001750 00000031202 12566211275 047130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-

require 'kconv'
require 'date'
require 'time'

#
# CFPropertyList implementation
#
# class to read, manipulate and write both XML and binary property list
# files (plist(5)) as defined by Apple. Have a look at CFPropertyList::List
# for more documentation.
#
# == Example
#   require 'cfpropertylist'
#
#   # create a arbitrary data structure of basic data types
#   data = {
#     'name' => 'John Doe',
#     'missing' => true,
#     'last_seen' => Time.now,
#     'friends' => ['Jane Doe','Julian Doe'],
#     'likes' => {
#       'me' => false
#     }
#   }
#
#   # create CFPropertyList::List object
#   plist = CFPropertyList::List.new
#
#   # call CFPropertyList.guess() to create corresponding CFType values
#   # pass in optional :convert_unknown_to_string => true to convert things like symbols into strings.
#   plist.value = CFPropertyList.guess(data)
#
#   # write plist to file
#   plist.save("example.plist", CFPropertyList::List::FORMAT_BINARY)
#
#   # … later, read it again
#   plist = CFPropertyList::List.new(:file => "example.plist")
#   data = CFPropertyList.native_types(plist.value)
#
# Author::    Christian Kruse (mailto:cjk@wwwtech.de)
# Copyright:: Copyright (c) 2010
# License::   MIT License
module CFPropertyList
  class << self
    attr_accessor :xml_parser_interface
  end

  # interface class for PList parsers
  class ParserInterface
    # load a plist
    def load(opts={})
      return ""
    end

    # convert a plist to string
    def to_str(opts={})
      return true
    end
  end

  class XMLParserInterface < ParserInterface
    def new_node(name)
    end

    def new_text(val)
    end

    def append_node(parent, child)
    end
  end
end

class String
  unless("".respond_to?(:bytesize)) then
    def bytesize
      self.length
    end
  end
end

dirname = File.dirname(__FILE__)
require dirname + '/rbCFPlistError.rb'
require dirname + '/rbCFTypes.rb'
require dirname + '/rbBinaryCFPropertyList.rb'

require 'iconv' unless "".respond_to?("encode")

# ensure that the module and class exist
module Enumerable
  class Enumerator
  end
end

begin
  require dirname + '/rbLibXMLParser.rb'
  temp = LibXML::XML::Parser::Options::NOBLANKS; # check if we have a version with parser options
  try_nokogiri = false
  CFPropertyList.xml_parser_interface = CFPropertyList::LibXMLParser
rescue LoadError, NameError
  try_nokogiri = true
end

if try_nokogiri then
  begin
    require dirname + '/rbNokogiriParser.rb'
    CFPropertyList.xml_parser_interface = CFPropertyList::NokogiriXMLParser
  rescue LoadError => e
    require dirname + '/rbREXMLParser.rb'
    CFPropertyList.xml_parser_interface = CFPropertyList::ReXMLParser
  end
end


module CFPropertyList
  # Create CFType hierarchy by guessing the correct CFType, e.g.
  #
  #  x = {
  #    'a' => ['b','c','d']
  #  }
  #  cftypes = CFPropertyList.guess(x)
  #
  # pass optional options hash. Only possible value actually:
  # +convert_unknown_to_string+::   Convert unknown objects to string calling to_str()
  # +converter_method+::    Convert unknown objects to known objects calling +method_name+
  #
  #  cftypes = CFPropertyList.guess(x,:convert_unknown_to_string => true,:converter_method => :to_hash, :converter_with_opts => true)
  def guess(object, options = {})
    case object
    when Fixnum, Integer       then CFInteger.new(object)
    when UidFixnum             then CFUid.new(object)
    when Float                 then CFReal.new(object)
    when TrueClass, FalseClass then CFBoolean.new(object)

    when Blob
      CFData.new(object, CFData::DATA_RAW)

    when String
      CFString.new(object)

    when Time, DateTime, Date  then CFDate.new(object)

    when Array, Enumerator, Enumerable::Enumerator
      ary = Array.new
      object.each do |o|
        ary.push CFPropertyList.guess(o, options)
      end
      CFArray.new(ary)

    when Hash
      hsh = Hash.new
      object.each_pair do |k,v|
        k = k.to_s if k.is_a?(Symbol)
        hsh[k] = CFPropertyList.guess(v, options)
      end
      CFDictionary.new(hsh)
    else
      case
      when Object.const_defined?('BigDecimal') && object.is_a?(BigDecimal)
        CFReal.new(object)
      when object.respond_to?(:read)
        raw_data = object.read
        # treat the data as a bytestring (ASCII-8BIT) if Ruby supports it.  Do this by forcing
        # the encoding, on the assumption that the bytes were read correctly, and just tagged with
        # an inappropriate encoding, rather than transcoding.
        raw_data.force_encoding(Encoding::ASCII_8BIT) if raw_data.respond_to?(:force_encoding)
        CFData.new(raw_data, CFData::DATA_RAW)
      when options[:converter_method] && object.respond_to?(options[:converter_method])
        if options[:converter_with_opts]
          CFPropertyList.guess(object.send(options[:converter_method],options),options)
        else
          CFPropertyList.guess(object.send(options[:converter_method]),options)
        end
      when options[:convert_unknown_to_string]
        CFString.new(object.to_s)
      else
        raise CFTypeError.new("Unknown class #{object.class.to_s}. Try using :convert_unknown_to_string if you want to use unknown object types!")
      end
    end
  end

  # Converts a CFType hiercharchy to native Ruby types
  def native_types(object,keys_as_symbols=false)
    return if object.nil?

    if(object.is_a?(CFDate) || object.is_a?(CFString) || object.is_a?(CFInteger) || object.is_a?(CFReal) || object.is_a?(CFBoolean)) || object.is_a?(CFUid) then
      return object.value
    elsif(object.is_a?(CFData)) then
      return CFPropertyList::Blob.new(object.decoded_value)
    elsif(object.is_a?(CFArray)) then
      ary = []
      object.value.each do
        |v|
        ary.push CFPropertyList.native_types(v)
      end

      return ary
    elsif(object.is_a?(CFDictionary)) then
      hsh = {}
      object.value.each_pair do
        |k,v|
        k = k.to_sym if keys_as_symbols
        hsh[k] = CFPropertyList.native_types(v)
      end

      return hsh
    end
  end

  module_function :guess, :native_types

  # Class representing a CFPropertyList. Instanciate with #new
  class List
    # Format constant for binary format
    FORMAT_BINARY = 1

    # Format constant for XML format
    FORMAT_XML = 2

    # Format constant for automatic format recognizing
    FORMAT_AUTO = 0

    @@parsers = [Binary, CFPropertyList.xml_parser_interface]

    # Path of PropertyList
    attr_accessor :filename
    # the original format of the PropertyList
    attr_accessor :format
    # the root value in the plist file
    attr_accessor :value
    # default value for XML generation; if true generate formatted XML
    attr_accessor :formatted

    # initialize a new CFPropertyList, arguments are:
    #
    # :file:: Parse a file
    # :format:: Format is one of FORMAT_BINARY or FORMAT_XML. Defaults to FORMAT_AUTO
    # :data:: Parse a string
    #
    # All arguments are optional
    def initialize(opts={})
      @filename = opts[:file]
      @format = opts[:format] || FORMAT_AUTO
      @data = opts[:data]
      @formatted = opts[:formatted]

      load(@filename) unless @filename.nil?
      load_str(@data) unless @data.nil?
    end

    # returns a list of registered parsers
    def self.parsers
      @@parsers
    end

    # set a list of parsers
    def self.parsers=(val)
      @@parsers = val
    end

    # Load an XML PropertyList
    # filename = nil:: The filename to read from; if nil, read from the file defined by instance variable +filename+
    def load_xml(filename=nil)
      load(filename,List::FORMAT_XML)
    end

    # read a binary plist file
    # filename = nil:: The filename to read from; if nil, read from the file defined by instance variable +filename+
    def load_binary(filename=nil)
      load(filename,List::FORMAT_BINARY)
    end

    # load a plist from a XML string
    # str:: The string containing the plist
    def load_xml_str(str=nil)
      load_str(str,List::FORMAT_XML)
    end

    # load a plist from a binary string
    # str:: The string containing the plist
    def load_binary_str(str=nil)
      load_str(str,List::FORMAT_BINARY)
    end

    # load a plist from a string
    # str = nil:: The string containing the plist
    # format = nil:: The format of the plist
    def load_str(str=nil,format=nil)
      str = @data if str.nil?
      format = @format if format.nil?

      @value = {}
      case format
      when List::FORMAT_BINARY, List::FORMAT_XML then
        prsr = @@parsers[format-1].new
        @value = prsr.load({:data => str})

      when List::FORMAT_AUTO then # what we now do is ugly, but neccessary to recognize the file format
        filetype = str[0..5]
        version = str[6..7]

        prsr = nil
        if filetype == "bplist" then
          raise CFFormatError.new("Wrong file version #{version}") unless version == "00"
          prsr = Binary.new
          @format = List::FORMAT_BINARY
        else
          prsr = CFPropertyList.xml_parser_interface.new
          @format = List::FORMAT_XML
        end

        @value = prsr.load({:data => str})
      end
    end

    # Read a plist file
    # file = nil:: The filename of the file to read. If nil, use +filename+ instance variable
    # format = nil:: The format of the plist file. Auto-detect if nil
    def load(file=nil,format=nil)
      file = @filename if file.nil?
      format = @format if format.nil?
      @value = {}

      raise IOError.new("File #{file} not readable!") unless File.readable? file

      case format
      when List::FORMAT_BINARY, List::FORMAT_XML then
        prsr = @@parsers[format-1].new
        @value = prsr.load({:file => file})

      when List::FORMAT_AUTO then # what we now do is ugly, but neccessary to recognize the file format
        magic_number = IO.read(file,8)
        raise IOError.new("File #{file} is empty.") unless magic_number
        filetype = magic_number[0..5]
        version = magic_number[6..7]

        prsr = nil
        if filetype == "bplist" then
          raise CFFormatError.new("Wong file version #{version}") unless version == "00"
          prsr = Binary.new
          @format = List::FORMAT_BINARY
        else
          prsr = CFPropertyList.xml_parser_interface.new
          @format = List::FORMAT_XML
        end

        @value = prsr.load({:file => file})
      end

      raise CFFormatError.new("Invalid format or parser error!") if @value.nil?
    end

    # Serialize CFPropertyList object to specified format and write it to file
    # file = nil:: The filename of the file to write to. Uses +filename+ instance variable if nil
    # format = nil:: The format to save in. Uses +format+ instance variable if nil
    def save(file=nil,format=nil,opts={})
      format = @format if format.nil?
      file = @filename if file.nil?

      raise CFFormatError.new("Format #{format} not supported, use List::FORMAT_BINARY or List::FORMAT_XML") if format != FORMAT_BINARY && format != FORMAT_XML

      if(!File.exists?(file)) then
        raise IOError.new("File #{file} not writable!") unless File.writable?(File.dirname(file))
      elsif(!File.writable?(file)) then
        raise IOError.new("File #{file} not writable!")
      end

      opts[:root] = @value
      opts[:formatted] = @formatted unless opts.has_key?(:formatted)

      prsr = @@parsers[format-1].new

      content = prsr.to_str(opts)

      File.open(file, 'wb') {
        |fd|
        fd.write content
      }
    end

    # convert plist to string
    # format = List::FORMAT_BINARY:: The format to save the plist
    # opts={}:: Pass parser options
    def to_str(format=List::FORMAT_BINARY,opts={})
      raise CFFormatError.new("Format #{format} not supported, use List::FORMAT_BINARY or List::FORMAT_XML") if format != FORMAT_BINARY && format != FORMAT_XML

      prsr = @@parsers[format-1].new

      opts[:root] = @value
      opts[:formatted] = @formatted unless opts.has_key?(:formatted)

      return prsr.to_str(opts)
    end
  end
end


class Array
  # convert an array to plist format
  def to_plist(options={})
    options[:plist_format] ||= CFPropertyList::List::FORMAT_BINARY

    plist = CFPropertyList::List.new
    plist.value = CFPropertyList.guess(self, options)
    plist.to_str(options[:plist_format], options)
  end
end

class Enumerator
  # convert an array to plist format
  def to_plist(options={})
    options[:plist_format] ||= CFPropertyList::List::FORMAT_BINARY

    plist = CFPropertyList::List.new
    plist.value = CFPropertyList.guess(self, options)
    plist.to_str(options[:plist_format], options)
  end
end

class Hash
  # convert a hash to plist format
  def to_plist(options={})
    options[:plist_format] ||= CFPropertyList::List::FORMAT_BINARY

    plist = CFPropertyList::List.new
    plist.value = CFPropertyList.guess(self, options)
    plist.to_str(options[:plist_format], options)
  end
end

# eof
                                                                                                                                                                                                                                                                                                                                                                                              cfpropertylist/rbCFTypes.rb                                                                         0100644 0001750 0001750 00000014674 12566211275 045572  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-
#
# CFTypes, e.g. CFString, CFInteger
# needed to create unambiguous plists
#
# Author::    Christian Kruse (mailto:cjk@wwwtech.de)
# Copyright:: Copyright (c) 2009
# License::   MIT License

require 'base64'

module CFPropertyList
  ##
  # Blob is intended to distinguish between a Ruby String instance that should
  # be converted to a CFString type and a Ruby String instance that should be
  # converted to a CFData type
  class Blob < String
  end

  ##
  # UidFixnum is intended to distinguish between a Ruby Fixnum
  # instance that should be converted to a CFInteger/CFReal type and a
  # Ruby Fixnum instance that should be converted to a CFUid type.
  class UidFixnum < Fixnum
  end

  # This class defines the base class for all CFType classes
  #
  class CFType
    # value of the type
    attr_accessor :value

    def initialize(value=nil)
      @value = value
    end

    def to_xml(parser)
    end

    def to_binary(bplist) end
  end

  # This class holds string values, both, UTF-8 and UTF-16BE
  # It will convert the value to UTF-16BE if necessary (i.e. if non-ascii char contained)
  class CFString < CFType
    # convert to XML
    def to_xml(parser)
      n = parser.new_node('string')
      n = parser.append_node(n, parser.new_text(@value)) unless @value.nil?
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.string_to_binary(@value);
    end
  end

  # This class holds integer/fixnum values
  class CFInteger < CFType
    # convert to XML
    def to_xml(parser)
      n = parser.new_node('integer')
      n = parser.append_node(n, parser.new_text(@value.to_s))
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.num_to_binary(self)
    end
  end

  # This class holds float values
  class CFReal < CFType
    # convert to XML
    def to_xml(parser)
      n = parser.new_node('real')
      n = parser.append_node(n, parser.new_text(@value.to_s))
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.num_to_binary(self)
    end
  end

  # This class holds Time values. While Apple uses seconds since 2001,
  # the rest of the world uses seconds since 1970. So if you access value
  # directly, you get the Time class. If you access via get_value you either
  # geht the timestamp or the Apple timestamp
  class CFDate < CFType
    TIMESTAMP_APPLE = 0
    TIMESTAMP_UNIX  = 1;
    DATE_DIFF_APPLE_UNIX = 978307200

    # create a XML date strimg from a time object
    def CFDate.date_string(val)
      # 2009-05-13T20:23:43Z
      val.getutc.strftime("%Y-%m-%dT%H:%M:%SZ")
    end

    # parse a XML date string
    def CFDate.parse_date(val)
      # 2009-05-13T20:23:43Z
      val =~ %r{^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$}
      year,month,day,hour,min,sec = $1, $2, $3, $4, $5, $6
      return Time.utc(year,month,day,hour,min,sec).getlocal
    end

    # set value to defined state
    def initialize(value = nil,format=CFDate::TIMESTAMP_UNIX)
      if(value.is_a?(Time) || value.nil?) then
        @value = value.nil? ? Time.now : value
      elsif value.instance_of? Date
        @value = Time.utc(value.year, value.month, value.day, 0, 0, 0)
      elsif value.instance_of? DateTime
        @value = value.to_time.utc
      else
        set_value(value,format)
      end
    end

    # set value with timestamp, either Apple or UNIX
    def set_value(value,format=CFDate::TIMESTAMP_UNIX)
      if(format == CFDate::TIMESTAMP_UNIX) then
        @value = Time.at(value)
      else
        @value = Time.at(value + CFDate::DATE_DIFF_APPLE_UNIX)
      end
    end

    # get timestamp, either UNIX or Apple timestamp
    def get_value(format=CFDate::TIMESTAMP_UNIX)
      if(format == CFDate::TIMESTAMP_UNIX) then
        @value.to_i
      else
        @value.to_f - CFDate::DATE_DIFF_APPLE_UNIX
      end
    end

    # convert to XML
    def to_xml(parser)
      n = parser.new_node('date')
      n = parser.append_node(n, parser.new_text(CFDate::date_string(@value)))
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.date_to_binary(@value)
    end
  end

  # This class contains a boolean value
  class CFBoolean < CFType
    # convert to XML
    def to_xml(parser)
      parser.new_node(@value ? 'true' : 'false')
    end

    # convert to binary
    def to_binary(bplist)
      bplist.bool_to_binary(@value);
    end
  end

  # This class contains binary data values
  class CFData < CFType
    # Base64 encoded data
    DATA_BASE64 = 0
    # Raw data
    DATA_RAW = 1

    # set value to defined state, either base64 encoded or raw
    def initialize(value=nil,format=DATA_BASE64)
      if(format == DATA_RAW)
        @raw_value = value
      else
        @value = value
      end
    end

    # get base64 encoded value
    def encoded_value
      @value ||= "\n#{Base64.encode64(@raw_value).gsub("\n", '').scan(/.{1,76}/).join("\n")}\n"
    end

    # get base64 decoded value
    def decoded_value
      @raw_value ||= Blob.new(Base64.decode64(@value))
    end

    # convert to XML
    def to_xml(parser)
      n = parser.new_node('data')
      n = parser.append_node(n, parser.new_text(encoded_value()))
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.data_to_binary(decoded_value())
    end
  end

  # This class contains an array of values
  class CFArray < CFType
    # create a new array CFType
    def initialize(val=[])
      @value = val
    end

    # convert to XML
    def to_xml(parser)
      n = parser.new_node('array')
      @value.each do |v|
        n = parser.append_node(n, v.to_xml(parser))
      end
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.array_to_binary(self)
    end
  end

  # this class contains a hash of values
  class CFDictionary < CFType
    # Create new CFDictonary type.
    def initialize(value={})
      @value = value
    end

    # convert to XML
    def to_xml(parser)
      n = parser.new_node('dict')
      @value.each_pair do |key, value|
        k = parser.append_node(parser.new_node('key'), parser.new_text(key.to_s))
        n = parser.append_node(n, k)
        n = parser.append_node(n, value.to_xml(parser))
      end
      n
    end

    # convert to binary
    def to_binary(bplist)
      bplist.dict_to_binary(self)
    end
  end

  class CFUid < CFType
    def to_xml(parser)
      CFDictionary.new({'CF$UID' => CFInteger.new(@value)}).to_xml(parser)
    end

    # convert to binary
    def to_binary(bplist)
      bplist.uid_to_binary(@value)
    end
  end
end

# eof
                                                                    cfpropertylist/rbLibXMLParser.rb                                                                    0100644 0001750 0001750 00000007130 12566211275 046506  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-

require 'libxml'

module CFPropertyList
  # XML parser
  class LibXMLParser < XMLParserInterface
    # read a XML file
    # opts::
    # * :file - The filename of the file to load
    # * :data - The data to parse
    def load(opts)
      doc = nil

      if(opts.has_key?(:file)) then
        doc = LibXML::XML::Document.file(opts[:file],:options => LibXML::XML::Parser::Options::NOBLANKS|LibXML::XML::Parser::Options::NOENT)
      else
        doc = LibXML::XML::Document.string(opts[:data],:options => LibXML::XML::Parser::Options::NOBLANKS|LibXML::XML::Parser::Options::NOENT)
      end

      if doc
        root = doc.root.first
        return import_xml(root)
      end
    rescue LibXML::XML::Error => e
      raise CFFormatError.new('invalid XML: ' + e.message)
    end

    # serialize CFPropertyList object to XML
    # opts = {}:: Specify options: :formatted - Use indention and line breaks
    def to_str(opts={})
      doc = LibXML::XML::Document.new

      doc.root = LibXML::XML::Node.new('plist')
      doc.encoding = LibXML::XML::Encoding::UTF_8

      doc.root['version'] = '1.0'
      doc.root << opts[:root].to_xml(self)

      # ugly hack, but there's no other possibility I know
      str = doc.to_s(:indent => opts[:formatted])
      str1 = String.new
      first = false
      str.each_line do |line|
        str1 << line
        unless(first) then
          str1 << "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n" if line =~ /^\s*<\?xml/
        end

        first = true
      end

      str1.force_encoding('UTF-8') if str1.respond_to?(:force_encoding)
      return str1
    end

    def new_node(name)
      LibXML::XML::Node.new(name)
    end

    def new_text(val)
      LibXML::XML::Node.new_text(val)
    end

    def append_node(parent, child)
      parent << child
    end

    protected

    # get the value of a DOM node
    def get_value(n)
      content = if n.children?
        n.first.content
      else
        n.content
      end

      content.force_encoding('UTF-8') if content.respond_to?(:force_encoding)
      content
    end

    # import the XML values
    def import_xml(node)
      ret = nil

      case node.name
      when 'dict'
        hsh = Hash.new
        key = nil

        if node.children? then
          node.children.each do |n|
            next if n.text? # avoid a bug of libxml
            next if n.comment?

            if n.name == "key" then
              key = get_value(n)
            else
              raise CFFormatError.new("Format error!") if key.nil?
              hsh[key] = import_xml(n)
              key = nil
            end
          end
        end

        if hsh['CF$UID'] and hsh.keys.length == 1
          ret = CFUid.new(hsh['CF$UID'].value)
        else
          ret = CFDictionary.new(hsh)
        end

      when 'array'
        ary = Array.new

        if node.children? then
          node.children.each do |n|
            next if n.text? # avoid a bug of libxml
            next if n.comment?
            ary.push import_xml(n)
          end
        end

        ret = CFArray.new(ary)

      when 'true'
        ret = CFBoolean.new(true)
      when 'false'
        ret = CFBoolean.new(false)
      when 'real'
        ret = CFReal.new(get_value(node).to_f)
      when 'integer'
        ret = CFInteger.new(get_value(node).to_i)
      when 'string'
        ret = CFString.new(get_value(node))
      when 'data'
        ret = CFData.new(get_value(node))
      when 'date'
        ret = CFDate.new(CFDate.parse_date(get_value(node)))
      end

      return ret
    end
  end
end

# eof
                                                                                                                                                                                                                                                                                                                                                                                                                                        cfpropertylist/rbNokogiriParser.rb                                                                  0100644 0001750 0001750 00000007476 12566211275 047215  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-

require 'nokogiri'

module CFPropertyList
  # XML parser
  class NokogiriXMLParser < ParserInterface
    # read a XML file
    # opts::
    # * :file - The filename of the file to load
    # * :data - The data to parse
    def load(opts)
      doc = nil
      if(opts.has_key?(:file)) then
        File.open(opts[:file], "rb") { |fd| doc = Nokogiri::XML::Document.parse(fd, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS|Nokogiri::XML::ParseOptions::NOENT) }
      else
        doc = Nokogiri::XML::Document.parse(opts[:data], nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS|Nokogiri::XML::ParseOptions::NOENT)
      end

      if doc
        root = doc.root.children.first
        return import_xml(root)
      end
    rescue Nokogiri::XML::SyntaxError => e
      raise CFFormatError.new('invalid XML: ' + e.message)
    end

    # serialize CFPropertyList object to XML
    # opts = {}:: Specify options: :formatted - Use indention and line breaks
    def to_str(opts={})
      doc = Nokogiri::XML::Document.new
      @doc = doc

      doc.root = doc.create_element 'plist', :version => '1.0'
      doc.encoding = 'UTF-8'

      doc.root << opts[:root].to_xml(self)

      # ugly hack, but there's no other possibility I know
      s_opts = Nokogiri::XML::Node::SaveOptions::AS_XML
      s_opts |= Nokogiri::XML::Node::SaveOptions::FORMAT if opts[:formatted]

      str = doc.serialize(:save_with => s_opts)
      str1 = String.new
      first = false
      str.each_line do |line|
        str1 << line
        unless(first) then
          str1 << "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n" if line =~ /^\s*<\?xml/
        end

        first = true
      end

      str1.force_encoding('UTF-8') if str1.respond_to?(:force_encoding)
      return str1
    end

    def new_node(name)
      @doc.create_element name
    end

    def new_text(val)
      @doc.create_text_node val
    end

    def append_node(parent, child)
      parent << child
    end

    protected

    # get the value of a DOM node
    def get_value(n)
      content = if n.children.empty?
        n.content
      else
        n.children.first.content
      end

      content.force_encoding('UTF-8') if content.respond_to?(:force_encoding)
      content
    end

    # import the XML values
    def import_xml(node)
      ret = nil

      case node.name
      when 'dict'
        hsh = Hash.new
        key = nil
        children = node.children

        unless children.empty? then
          children.each do |n|
            next if n.text? # avoid a bug of libxml
            next if n.comment?

            if n.name == "key" then
              key = get_value(n)
            else
              raise CFFormatError.new("Format error!") if key.nil?
              hsh[key] = import_xml(n)
              key = nil
            end
          end
        end

        if hsh['CF$UID'] and hsh.keys.length == 1
          ret = CFUid.new(hsh['CF$UID'].value)
        else
          ret = CFDictionary.new(hsh)
        end

      when 'array'
        ary = Array.new
        children = node.children

        unless children.empty? then
          children.each do |n|
            next if n.text? # avoid a bug of libxml
            next if n.comment?
            ary.push import_xml(n)
          end
        end

        ret = CFArray.new(ary)

      when 'true'
        ret = CFBoolean.new(true)
      when 'false'
        ret = CFBoolean.new(false)
      when 'real'
        ret = CFReal.new(get_value(node).to_f)
      when 'integer'
        ret = CFInteger.new(get_value(node).to_i)
      when 'string'
        ret = CFString.new(get_value(node))
      when 'data'
        ret = CFData.new(get_value(node))
      when 'date'
        ret = CFDate.new(CFDate.parse_date(get_value(node)))
      end

      return ret
    end
  end
end

# eof
                                                                                                                                                                                                  cfpropertylist/rbREXMLParser.rb                                                                     0100644 0001750 0001750 00000007115 12566211275 046311  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-

require 'rexml/document'

module CFPropertyList
  # XML parser
  class ReXMLParser < ParserInterface
    # read a XML file
    # opts::
    # * :file - The filename of the file to load
    # * :data - The data to parse
    def load(opts)

      doc = nil
      if(opts.has_key?(:file)) then
        File.open(opts[:file], "rb") { |fd| doc = REXML::Document.new(fd) }
      else
        doc = REXML::Document.new(opts[:data])
      end

      if doc
        root = doc.root.elements[1]
        return import_xml(root)
      end
    rescue REXML::ParseException => e
      raise CFFormatError.new('invalid XML: ' + e.message)
    end

    # serialize CFPropertyList object to XML
    # opts = {}:: Specify options: :formatted - Use indention and line breaks
    def to_str(opts={})
      doc = REXML::Document.new
      @doc = doc

      doc.context[:attribute_quote] = :quote

      doc.add_element 'plist', {'version' => '1.0'}
      doc.root << opts[:root].to_xml(self)

      formatter = if opts[:formatted] then
        f = REXML::Formatters::Pretty.new(2)
        f.compact = true
        f
      else
        REXML::Formatters::Default.new
      end

      str = formatter.write(doc.root, "")
      str1 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n" + str + "\n"
      str1.force_encoding('UTF-8') if str1.respond_to?(:force_encoding)

      return str1
    end

    def new_node(name)
      REXML::Element.new(name)
    end

    def new_text(val)
      val
    end

    def append_node(parent, child)
      if child.is_a?(String) then
        parent.add_text child
      else
        parent.elements << child
      end
      parent
    end

    protected

    # get the value of a DOM node
    def get_value(n)
      content = n.text

      content.force_encoding('UTF-8') if content.respond_to?(:force_encoding)
      content
    end

    # import the XML values
    def import_xml(node)
      ret = nil

      case node.name
      when 'dict'
        hsh = Hash.new
        key = nil

        if node.has_elements? then
          node.elements.each do |n|
            next if n.name == '#text' # avoid a bug of libxml
            next if n.name == '#comment'

            if n.name == "key" then
              key = get_value(n)
              key = '' if key.nil? # REXML returns nil if key is empty
            else
              raise CFFormatError.new("Format error!") if key.nil?
              hsh[key] = import_xml(n)
              key = nil
            end
          end
        end

        if hsh['CF$UID'] and hsh.keys.length == 1
          ret = CFUid.new(hsh['CF$UID'].value)
        else
          ret = CFDictionary.new(hsh)
        end

      when 'array'
        ary = Array.new

        if node.has_elements? then
          node.elements.each do |n|
            next if n.name == '#text' # avoid a bug of libxml
            ary.push import_xml(n)
          end
        end

        ret = CFArray.new(ary)

      when 'true'
        ret = CFBoolean.new(true)
      when 'false'
        ret = CFBoolean.new(false)
      when 'real'
        ret = CFReal.new(get_value(node).to_f)
      when 'integer'
        ret = CFInteger.new(get_value(node).to_i)
      when 'string'
        ret = CFString.new(get_value(node))
        ret.value = '' if ret.value.nil? # REXML returns nil for empty elements' .text attribute
      when 'data'
        ret = CFData.new(get_value(node))
      when 'date'
        ret = CFDate.new(CFDate.parse_date(get_value(node)))
      end

      return ret
    end
  end
end

# eof
                                                                                                                                                                                                                                                                                                                                                                                                                                                   cfpropertylist.rb                                                                                   0100644 0001750 0001750 00000000113 12566211275 043710  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/CFPropertyList-2.2.8/lib                        # -*- coding: utf-8 -*-

require 'cfpropertylist/rbCFPropertyList'


# eof
                                                                                                                                                                                                                                                                                                                                                                                                                                                     libxml-ruby-2.6.0/                                                                                  0040755 0001750 0001750 00000000000 12612224746 037104  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems                                                 ext/                                                                                                0040755 0001750 0001750 00000000000 12612224746 037704  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0                               libxml/                                                                                             0040755 0001750 0001750 00000000000 12612224746 041173  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext                           extconf.h                                                                                           0100644 0001750 0001750 00000000202 12566211304 042773  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef EXTCONF_H
#define EXTCONF_H
#define HAVE_ZLIB_H 1
#define HAVE_LIBXML_XMLVERSION_H 1
#define HAVE_RB_IO_BUFWRITE 1
#endif
                                                                                                                                                                                                                                                                                                                                                                                              extconf.rb                                                                                          0100644 0001750 0001750 00000005262 12566211276 043172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #!/usr/bin/env ruby

require 'rbconfig'

require 'mkmf'

if defined?(CFLAGS)
  if CFLAGS.index(CONFIG['CCDLFLAGS'])
    $CFLAGS = CFLAGS + ' ' + CONFIG['CCDLFLAGS']
  else
    $CFLAGS = CFLAGS
  end
else
  $CFLAGS = CONFIG['CFLAGS']
end
$LDFLAGS = CONFIG['LDFLAGS']
$LIBPATH.push(Config::CONFIG['libdir'])

def crash(str)
  printf(" extconf failure: %s\n", str)
  exit 1
end

dir_config('iconv')
dir_config('zlib')

have_library('socket','socket')
have_library('nsl','gethostbyname')

unless have_library('m', 'atan')
  # try again for gcc 4.0
  saveflags = $CFLAGS
  $CFLAGS += ' -fno-builtin'
  unless have_library('m', 'atan')
    crash('need libm')
  end
  $CFLAGS = saveflags
end

unless have_library('z', 'inflate') or
       have_library('zlib', 'inflate') or
       have_library('zlib1', 'inflate') or
       have_library('libz', 'inflate')
  crash('need zlib')
else
  $defs.push('-DHAVE_ZLIB_H')
end

unless have_library('iconv','iconv_open') or 
       have_library('iconv','libiconv_open') or
       have_library('libiconv', 'libiconv_open') or
       have_library('libiconv', 'iconv_open') or
       have_library('c','iconv_open') or
       have_library('recode','iconv_open') or
       have_library('iconv')
  crash(<<EOL)
need libiconv.

Install the libiconv or try passing one of the following options
to extconf.rb:

  --with-iconv-dir=/path/to/iconv
  --with-iconv-lib=/path/to/iconv/lib
  --with-iconv-include=/path/to/iconv/include
EOL
end

if (xc = with_config('xml2-config')) or RUBY_PLATFORM.match(/darwin/i) then
  xc = 'xml2-config' if xc == true or xc.nil?
  cflags = `#{xc} --cflags`.chomp
  if $? != 0
		cflags = nil
	else
  	libs = `#{xc} --libs`.chomp
  	if $? != 0
			libs = nil
		else
  		$CFLAGS += ' ' + cflags
  		$libs = libs + " " + $libs
		end
	end
else
	dir_config('xml2')
end

unless (have_library('xml2', 'xmlParseDoc') or
				have_library('libxml2', 'xmlParseDoc') or
				find_library('xml2', 'xmlParseDoc', '/opt/lib', '/usr/local/lib', '/usr/lib')) and 
			 (have_header('libxml/xmlversion.h') or
			  find_header('libxml/xmlversion.h',
										'/opt/include/libxml2', 
										'/usr/local/include/libxml2',
										'/usr/include/libxml2'))
		crash(<<EOL)
need libxml2.

    Install the library or try one of the following options to extconf.rb:

      --with-xml2-config=/path/to/xml2-config
      --with-xml2-dir=/path/to/libxml2
      --with-xml2-lib=/path/to/libxml2/lib
      --with-xml2-include=/path/to/libxml2/include
EOL
end

have_func('rb_io_bufwrite', 'ruby/io.h')

# For FreeBSD add /usr/local/include
$INCFLAGS << " -I/usr/local/include"

$CFLAGS << ' ' << $INCFLAGS

#$INSTALLFILES = [["libxml.rb", "$(RUBYLIBDIR)", "../xml"]]

create_header()
create_makefile('libxml_ruby')
                                                                                                                                                                                                                                                                                                                                              libxml.c                                                                                            0100644 0001750 0001750 00000003445 12566211276 042633  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"

#if RUBY_INTERN_H
#include <ruby/util.h>
#else
#include <util.h>
#endif


VALUE mLibXML;

static void rxml_init_memory(void)
{
 /* Disable for now - broke attributes. 
  xmlGcMemSetup(
      (xmlFreeFunc)ruby_xfree,
      (xmlMallocFunc)ruby_xmalloc,
      (xmlMallocFunc)ruby_xmalloc,
      (xmlReallocFunc)ruby_xrealloc,
      (xmlStrdupFunc)ruby_strdup
  );*/
}

void Init_libxml_ruby(void)
{
/* The libxml gem provides Ruby language bindings for GNOME's Libxml2
 * XML toolkit.  To get started you may:
 *
 *  require 'test_helper'
 *  document = XML::Document.new
 *
 * However, when creating an application or library you plan to
 * redistribute, it is best to not add the LibXML module to the global
 * namespace, in which case you can either write your code like this:
 *
 *  require 'libxml'
 *  document = LibXML::XML::Document.new
 *
 * Refer to the README file to get started and the LICENSE file for
 * copyright and distribution information.
 */
  mLibXML = rb_define_module("LibXML");

  rxml_init_memory();
  rxml_init_xml();
  rxml_init_io();
  rxml_init_error();
  rxml_init_encoding();
  rxml_init_parser();
  rxml_init_parser_context();
  rxml_init_parser_options();
  rxml_init_node();
  rxml_init_attributes();
  rxml_init_attr();
  rxml_init_attr_decl();
  rxml_init_document();
  rxml_init_namespaces();
  rxml_init_namespace();
  rxml_init_sax_parser();
  rxml_init_sax2_handler();
  rxml_init_xinclude();
  rxml_init_xpath();
  rxml_init_xpath_object();
  rxml_init_xpath_context();
  rxml_init_xpath_expression();
  rxml_init_xpointer();
  rxml_init_html_parser();
  rxml_init_html_parser_options();
  rxml_init_html_parser_context();
  rxml_init_input_callbacks();
  rxml_init_dtd();
  rxml_init_schema();
  rxml_init_relaxng();
  rxml_init_reader();
  rxml_init_writer();
}
                                                                                                                                                                                                                           ruby_libxml.h                                                                                       0100644 0001750 0001750 00000003573 12566211276 043703  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RUBY_LIBXML_H__
#define __RUBY_LIBXML_H__

#include <ruby.h>
#include <libxml/parser.h>
#include <libxml/parserInternals.h>
#include <libxml/debugXML.h>
#include <libxml/xmlversion.h>
#include <libxml/xmlmemory.h>
#include <libxml/xpath.h>
#include <libxml/valid.h>
#include <libxml/catalog.h>
#include <libxml/HTMLparser.h>
#include <libxml/xmlreader.h>
#include <libxml/c14n.h>

/* Needed prior to Ruby 1.9.1 */
#ifndef RHASH_TBL
#define RHASH_TBL(s) (RHASH(s)->tbl)
#endif

// Encoding support added in Ruby 1.9.*
#ifdef HAVE_RUBY_ENCODING_H
#include <ruby/encoding.h>
#endif

#ifdef LIBXML_DEBUG_ENABLED
#include <libxml/xpathInternals.h>
#endif
#ifdef LIBXML_XINCLUDE_ENABLED
#include <libxml/xinclude.h>
#endif
#ifdef LIBXML_XPTR_ENABLED
#include <libxml/xpointer.h>
#endif

#include "ruby_xml_version.h"
#include "ruby_xml.h"
#include "ruby_xml_io.h"
#include "ruby_xml_error.h"
#include "ruby_xml_encoding.h"
#include "ruby_xml_attributes.h"
#include "ruby_xml_attr.h"
#include "ruby_xml_attr_decl.h"
#include "ruby_xml_document.h"
#include "ruby_xml_node.h"
#include "ruby_xml_namespace.h"
#include "ruby_xml_namespaces.h"
#include "ruby_xml_parser.h"
#include "ruby_xml_parser_options.h"
#include "ruby_xml_parser_context.h"
#include "ruby_xml_html_parser.h"
#include "ruby_xml_html_parser_options.h"
#include "ruby_xml_html_parser_context.h"
#include "ruby_xml_reader.h"
#include "ruby_xml_writer.h"
#include "ruby_xml_sax2_handler.h"
#include "ruby_xml_sax_parser.h"
#include "ruby_xml_xinclude.h"
#include "ruby_xml_xpath.h"
#include "ruby_xml_xpath_expression.h"
#include "ruby_xml_xpath_context.h"
#include "ruby_xml_xpath_object.h"
#include "ruby_xml_xpointer.h"
#include "ruby_xml_input_cbg.h"
#include "ruby_xml_dtd.h"
#include "ruby_xml_schema.h"
#include "ruby_xml_relaxng.h"

extern VALUE mLibXML;

#endif
                                                                                                                                     ruby_xml.c                                                                                          0100644 0001750 0001750 00000050767 12566211276 043216  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml.h"

VALUE mXML;

/*
 * call-seq:
 * 		XML.catalog_dump -> true
 *
 * Dump all the global catalog content stdout.
 */
static VALUE rxml_catalog_dump(VALUE self)
{
  xmlCatalogDump(stdout);
  return (Qtrue);
}

/*
 * call-seq:
 * 		XML.catalog_remove(catalog) -> true
 *
 * Remove the specified resource catalog.
 */
static VALUE rxml_catalog_remove(VALUE self, VALUE cat)
{
  Check_Type(cat, T_STRING);
  xmlCatalogRemove((xmlChar *) StringValuePtr(cat));
  return (Qtrue);
}

/*
 * call-seq:
 * 		XML.check_lib_versions -> true
 *
 * Check LIBXML version matches version the bindings
 * were compiled to. Throws an exception if not.
 */
static VALUE rxml_check_lib_versions(VALUE klass)
{
  xmlCheckVersion(LIBXML_VERSION);
  return (Qtrue);
}

/*
 * call-seq:
 * 		XML.enabled_automata? -> (true|false)
 *
 * Determine whether libxml regexp automata support is enabled.
 */
static VALUE rxml_enabled_automata_q(VALUE klass)
{
#ifdef LIBXML_AUTOMATA_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_c14n? -> (true|false)
 *
 * Determine whether libxml 'canonical XML' support is enabled.
 * See "Canonical XML" (http://www.w3.org/TR/xml-c14n)
 */
static VALUE rxml_enabled_c14n_q(VALUE klass)
{
#ifdef LIBXML_C14N_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_catalog? -> (true|false)
 *
 * Determine whether libxml resource catalog support is enabled.
 */
static VALUE rxml_enabled_catalog_q(VALUE klass)
{
#ifdef LIBXML_CATALOG_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_debug? -> (true|false)
 *
 * Determine whether libxml debugging support is enabled.
 */
static VALUE rxml_enabled_debug_q(VALUE klass)
{
#ifdef LIBXML_DEBUG_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_docbook? -> (true|false)
 *
 * Determine whether libxml docbook support is enabled.
 */
static VALUE rxml_enabled_docbook_q(VALUE klass)
{
#ifdef LIBXML_DOCB_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_ftp? -> (true|false)
 *
 * Determine whether libxml ftp client support is enabled.
 */
static VALUE rxml_enabled_ftp_q(VALUE klass)
{
#ifdef LIBXML_FTP_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_http? -> (true|false)
 *
 * Determine whether libxml http client support is enabled.
 */
static VALUE rxml_enabled_http_q(VALUE klass)
{
#ifdef LIBXML_HTTP_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_html? -> (true|false)
 *
 * Determine whether libxml html support is enabled.
 */
static VALUE rxml_enabled_html_q(VALUE klass)
{
#ifdef LIBXML_HTML_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_iconv? -> (true|false)
 *
 * Determine whether libxml iconv support is enabled.
 */
static VALUE rxml_enabled_iconv_q(VALUE klass)
{
#ifdef LIBXML_ICONV_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_memory_debug? -> (true|false)
 *
 * Determine whether libxml memory location debugging support
 * is enabled.
 */
static VALUE rxml_enabled_memory_debug_location_q(VALUE klass)
{
#ifdef DEBUG_MEMORY_LOCATION
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_regexp? -> (true|false)
 *
 * Determine whether libxml regular expression support is enabled.
 */
static VALUE rxml_enabled_regexp_q(VALUE klass)
{
#ifdef LIBXML_REGEXP_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_schemas? -> (true|false)
 *
 * Determine whether libxml schema support is enabled.
 */
static VALUE rxml_enabled_schemas_q(VALUE klass)
{
#ifdef LIBXML_SCHEMAS_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_thread? -> (true|false)
 *
 * Determine whether thread-safe semantics support for libxml is enabled and
 * is used by this ruby extension.  Threading support in libxml uses pthread
 * on Unix-like systems and Win32 threads on Windows.
 */
static VALUE rxml_enabled_thread_q(VALUE klass)
{
  /* This won't be defined unless this code is compiled with _REENTRANT or __MT__
   * defined or the compiler is in C99 mode.
   *
   * Note the relevant portion libxml/xmlversion.h on a thread-enabled build:
   *
   *    #if defined(_REENTRANT) || defined(__MT__) || \
   *        (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE - 0 >= 199506L))
   *        #define LIBXML_THREAD_ENABLED
   *    #endif
   *
   */
#ifdef LIBXML_THREAD_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_unicode? -> (true|false)
 *
 * Determine whether libxml unicode support is enabled.
 */
static VALUE rxml_enabled_unicode_q(VALUE klass)
{
#ifdef LIBXML_UNICODE_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_xinclude? -> (true|false)
 *
 * Determine whether libxml xinclude support is enabled.
 */
static VALUE rxml_enabled_xinclude_q(VALUE klass)
{
#ifdef LIBXML_XINCLUDE_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_xpath? -> (true|false)
 *
 * Determine whether libxml xpath support is enabled.
 */
static VALUE rxml_enabled_xpath_q(VALUE klass)
{
#ifdef LIBXML_XPATH_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_xpointer? -> (true|false)
 *
 * Determine whether libxml xpointer support is enabled.
 */
static VALUE rxml_enabled_xpointer_q(VALUE klass)
{
#ifdef LIBXML_XPTR_ENABLED
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 * 		XML.enabled_zlib? -> (true|false)
 *
 * Determine whether libxml zlib support is enabled.
 */
static VALUE rxml_enabled_zlib_q(VALUE klass)
{
#ifdef HAVE_ZLIB_H
  return(Qtrue);
#else
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    XML.debug_entities -> (true|false)
 *
 * Determine whether included-entity debugging is enabled.
 * (Requires Libxml to be compiled with debugging support)
 */
static VALUE rxml_debug_entities_get(VALUE klass)
{
#ifdef LIBXML_DEBUG_ENABLED
  if (xmlParserDebugEntities)
  return(Qtrue);
  else
  return(Qfalse);
#else
  rb_warn("libxml was compiled with debugging turned off");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    XML.debug_entities = true|false
 *
 * Enable or disable included-entity debugging.
 * (Requires Libxml to be compiled with debugging support)
 */
static VALUE rxml_debug_entities_set(VALUE klass, VALUE bool)
{
#ifdef LIBXML_DEBUG_ENABLED
  if (TYPE(bool) == T_FALSE)
  {
    xmlParserDebugEntities = 0;
    return(Qfalse);
  }
  else
  {
    xmlParserDebugEntities = 1;
    return(Qtrue);
  }
#else
  rb_warn("libxml was compiled with debugging turned off");
#endif
}

/*
 * call-seq:
 *    XML.default_keep_blanks -> (true|false)
 *
 * Determine whether parsers retain whitespace by default.
 */
static VALUE rxml_default_keep_blanks_get(VALUE klass)
{
  if (xmlKeepBlanksDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_keep_blanks = true|false
 *
 * Controls whether parsers retain whitespace by default.
 */
static VALUE rxml_default_keep_blanks_set(VALUE klass, VALUE bool)
{
  if (TYPE(bool) == T_FALSE)
  {
    xmlKeepBlanksDefaultValue = 0;
    return (Qfalse);
  }
  else if (TYPE(bool) == T_TRUE)
  {
    xmlKeepBlanksDefaultValue = 1;
    return (Qtrue);
  }
  else
  {
    rb_raise(rb_eArgError, "Invalid argument, must be a boolean");
  }
}

/*
 * call-seq:
 *    XML.default_load_external_dtd -> (true|false)
 *
 * Determine whether parsers load external DTDs by default.
 */
static VALUE rxml_default_load_external_dtd_get(VALUE klass)
{
  if (xmlLoadExtDtdDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_load_external_dtd = true|false
 *
 * Controls whether parsers load external DTDs by default.
 */
static VALUE rxml_default_load_external_dtd_set(VALUE klass, VALUE bool)
{
  if (bool == Qfalse)
  {
    xmlLoadExtDtdDefaultValue = 0;
    return (Qfalse);
  }
  else
  {
    xmlLoadExtDtdDefaultValue = 1;
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    XML.default_line_numbers -> (true|false)
 *
 * Determine whether parsers retain line-numbers by default.
 */
static VALUE rxml_default_line_numbers_get(VALUE klass)
{
  if (xmlLineNumbersDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_line_numbers = true|false
 *
 * Controls whether parsers retain line-numbers by default.
 */
static VALUE rxml_default_line_numbers_set(VALUE klass, VALUE bool)
{
  if (TYPE(bool) == T_FALSE)
  {
    xmlLineNumbersDefault(0);
    return (Qfalse);
  }
  else
  {
    xmlLineNumbersDefault(1);
    return (Qtrue);
  }
}

int rxml_libxml_default_options()
{
  int options = 0;

  if (xmlLoadExtDtdDefaultValue)
    options |= XML_PARSE_DTDLOAD;

  if (xmlDoValidityCheckingDefaultValue)
    options |= XML_PARSE_DTDVALID;

  if (!xmlKeepBlanksDefaultValue)
    options |= XML_PARSE_NOBLANKS;

  if (xmlSubstituteEntitiesDefaultValue)
    options |= XML_PARSE_NOENT;

  if (!xmlGetWarningsDefaultValue)
    options |= XML_PARSE_NOWARNING;

  if (xmlPedanticParserDefaultValue)
    options |= XML_PARSE_PEDANTIC;
  
  return options;
}

/*
 * call-seq:
 *    XML.default_options -> int
 *
 * Returns an integer that summarize libxml2's default options.
 */
static VALUE rxml_default_options_get(VALUE klass)
{
  int options = rxml_libxml_default_options();
  return INT2NUM(options);
}

/*
 * call-seq:
 *    XML.default_pedantic_parser -> (true|false)
 *
 * Determine whether parsers are pedantic by default.
 */
static VALUE rxml_default_pedantic_parser_get(VALUE klass)
{
  if (xmlPedanticParserDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_pedantic_parser = true|false
 *
 * Controls whether parsers are pedantic by default.
 */
static VALUE rxml_default_pedantic_parser_set(VALUE klass, VALUE bool)
{
  if (TYPE(bool) == T_FALSE)
  {
    xmlPedanticParserDefault(0);
    return (Qfalse);
  }
  else
  {
    xmlPedanticParserDefault(1);
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    XML.default_substitute_entities -> (true|false)
 *
 * Determine whether parsers perform inline entity substitution
 * (for external entities) by default.
 */
static VALUE rxml_default_substitute_entities_get(VALUE klass)
{
  if (xmlSubstituteEntitiesDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_substitute_entities = true|false
 *
 * Controls whether parsers perform inline entity substitution
 * (for external entities) by default.
 */
static VALUE rxml_default_substitute_entities_set(VALUE klass, VALUE bool)
{
  if (bool == Qfalse)
  {
    xmlSubstituteEntitiesDefault(0);
    return (Qfalse);
  }
  else
  {
    xmlSubstituteEntitiesDefault(1);
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    XML.default_tree_indent_string -> "string"
 *
 * Obtain the default string used by parsers to indent the XML tree
 * for output.
 */
static VALUE rxml_default_tree_indent_string_get(VALUE klass)
{
  if (xmlTreeIndentString == NULL)
    return (Qnil);
  else
    return (rb_str_new2(xmlTreeIndentString));
}

/*
 * call-seq:
 *    XML.default_tree_indent_string = "string"
 *
 * Set the default string used by parsers to indent the XML tree
 * for output.
 */
static VALUE rxml_default_tree_indent_string_set(VALUE klass, VALUE string)
{
  Check_Type(string, T_STRING);
  xmlTreeIndentString = xmlStrdup((xmlChar *)StringValuePtr(string));
  return (string);
}

/*
 * call-seq:
 *    XML.default_validity_checking -> (true|false)
 *
 * Determine whether parsers perform XML validation by default.
 */
static VALUE rxml_default_validity_checking_get(VALUE klass)
{
  if (xmlDoValidityCheckingDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_validity_checking = true|false
 *
 * Controls whether parsers perform XML validation by default.
 */
static VALUE rxml_default_validity_checking_set(VALUE klass, VALUE bool)
{
  if (TYPE(bool) == T_FALSE)
  {
    xmlDoValidityCheckingDefaultValue = 0;
    return (Qfalse);
  }
  else
  {
    xmlDoValidityCheckingDefaultValue = 1;
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    XML.default_warnings -> (true|false)
 *
 * Determine whether parsers output warnings by default.
 */
static VALUE rxml_default_warnings_get(VALUE klass)
{
  if (xmlGetWarningsDefaultValue)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.default_warnings = true|false
 *
 * Controls whether parsers output warnings by default.
 */
static VALUE rxml_default_warnings_set(VALUE klass, VALUE bool)
{
  if (TYPE(bool) == T_FALSE)
  {
    xmlGetWarningsDefaultValue = 0;
    return (Qfalse);
  }
  else
  {
    xmlGetWarningsDefaultValue = 1;
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    XML.default_compression -> (true|false)
 *
 * Determine whether parsers use Zlib compression by default
 * (requires libxml to be compiled with Zlib support).
 */
static VALUE rxml_default_compression_get(VALUE klass)
{
#ifdef HAVE_ZLIB_H
  return(INT2FIX(xmlGetCompressMode()));
#else
  rb_warn("libxml was compiled without zlib support");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    XML.default_compression = true|false
 *
 * Controls whether parsers use Zlib compression by default
 * (requires libxml to be compiled with Zlib support).
 */
static VALUE rxml_default_compression_set(VALUE klass, VALUE num)
{
#ifdef HAVE_ZLIB_H
  Check_Type(num, T_FIXNUM);
  xmlSetCompressMode(FIX2INT(num));
  return(num);
#else
  rb_warn("libxml was compiled without zlib support");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    XML.features -> ["feature", ..., "feature"]
 *
 * Obtains an array of strings representing features supported
 * (and enabled) by the installed libxml.
 */
static VALUE rxml_features(VALUE klass)
{
  VALUE arr, str;
  int i, len = MAX_LIBXML_FEATURES_LEN;
  char **list = NULL;

  list = ALLOC_N(char *,MAX_LIBXML_FEATURES_LEN);
  MEMZERO(list, char *, MAX_LIBXML_FEATURES_LEN);

  arr = rb_ary_new();
  if (xmlGetFeaturesList(&len, (const char **) list) == -1)
    return Qnil;

  for (i = 0; i < len; i++)
  {
    str = rb_str_new2((const char *) list[i]);
    rb_gc_unregister_address(&str);
    rb_ary_push(arr, str);
  }

  if (len == MAX_LIBXML_FEATURES_LEN)
    rb_warn(
        "Please contact libxml-devel@rubyforge.org and ask to have the \"MAX_LIBXML_FEATURES_LEN increased\" because you could possibly be seeing an incomplete list");

  ruby_xfree(list);
  return (arr);
}

/*
 * call-seq:
 *    XML.indent_tree_output -> (true|false)
 *
 * Determines whether XML output will be indented
 * (using the string supplied to +default_indent_tree_string+)
 */
static VALUE rxml_indent_tree_output_get(VALUE klass)
{
  if (xmlIndentTreeOutput)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    XML.indent_tree_output = true|false
 *
 * Controls whether XML output will be indented
 * (using the string supplied to +default_indent_tree_string+)
 */
static VALUE rxml_indent_tree_output_set(VALUE klass, VALUE bool)
{
  if (TYPE(bool) == T_TRUE)
  {
    xmlIndentTreeOutput = 1;
    return (Qtrue);
  }
  else if (TYPE(bool) == T_FALSE)
  {
    xmlIndentTreeOutput = 0;
    return (Qfalse);
  }
  else
  {
    rb_raise(rb_eArgError, "Invalid argument, must be boolean");
  }
}

/*
 * call-seq:
 *    XML.memory_dump -> (true|false)
 *
 * Perform a parser memory dump (requires memory debugging
 * support in libxml).
 */
static VALUE rxml_memory_dump(VALUE self)
{
#ifdef DEBUG_MEMORY_LOCATION
  xmlMemoryDump();
  return(Qtrue);
#else
  rb_warn("libxml was compiled without memory debugging support");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    XML.memory_used -> num_bytes
 *
 * Perform a parser memory dump (requires memory debugging
 * support in libxml).
 */
static VALUE rxml_memory_used(VALUE self)
{
#ifdef DEBUG_MEMORY_LOCATION
  return(INT2NUM(xmlMemUsed()));
#else
  rb_warn("libxml was compiled without memory debugging support");
  return (Qfalse);
#endif
}

/* The libxml gem provides Ruby language bindings for GNOME's Libxml2
 * XML toolkit. Refer to the README file to get started
 * and the LICENSE file for copyright and distribution information.
*/

void rxml_init_xml(void)
{
  mXML = rb_define_module_under(mLibXML, "XML");

  /* Constants */
  rb_define_const(mXML, "LIBXML_VERSION", rb_str_new2(LIBXML_DOTTED_VERSION));
  rb_define_const(mXML, "VERSION", rb_str_new2(RUBY_LIBXML_VERSION));
  rb_define_const(mXML, "VERNUM", INT2NUM(RUBY_LIBXML_VERNUM));
  rb_define_const(mXML, "XML_NAMESPACE", rb_str_new2((const char*) XML_XML_NAMESPACE));

  rb_define_module_function(mXML, "enabled_automata?", rxml_enabled_automata_q, 0);
  rb_define_module_function(mXML, "enabled_c14n?", rxml_enabled_c14n_q, 0);
  rb_define_module_function(mXML, "enabled_catalog?", rxml_enabled_catalog_q, 0);
  rb_define_module_function(mXML, "enabled_debug?", rxml_enabled_debug_q, 0);
  rb_define_module_function(mXML, "enabled_docbook?", rxml_enabled_docbook_q, 0);
  rb_define_module_function(mXML, "enabled_ftp?", rxml_enabled_ftp_q, 0);
  rb_define_module_function(mXML, "enabled_http?", rxml_enabled_http_q, 0);
  rb_define_module_function(mXML, "enabled_html?", rxml_enabled_html_q, 0);
  rb_define_module_function(mXML, "enabled_iconv?", rxml_enabled_iconv_q, 0);
  rb_define_module_function(mXML, "enabled_memory_debug?", rxml_enabled_memory_debug_location_q, 0);
  rb_define_module_function(mXML, "enabled_regexp?", rxml_enabled_regexp_q, 0);
  rb_define_module_function(mXML, "enabled_schemas?", rxml_enabled_schemas_q, 0);
  rb_define_module_function(mXML, "enabled_thread?", rxml_enabled_thread_q, 0);
  rb_define_module_function(mXML, "enabled_unicode?", rxml_enabled_unicode_q, 0);
  rb_define_module_function(mXML, "enabled_xinclude?", rxml_enabled_xinclude_q, 0);
  rb_define_module_function(mXML, "enabled_xpath?", rxml_enabled_xpath_q, 0);
  rb_define_module_function(mXML, "enabled_xpointer?", rxml_enabled_xpointer_q, 0);
  rb_define_module_function(mXML, "enabled_zlib?", rxml_enabled_zlib_q, 0);

  rb_define_module_function(mXML, "catalog_dump", rxml_catalog_dump, 0);
  rb_define_module_function(mXML, "catalog_remove", rxml_catalog_remove, 1);
  rb_define_module_function(mXML, "check_lib_versions", rxml_check_lib_versions, 0);
  rb_define_module_function(mXML, "debug_entities", rxml_debug_entities_get, 0);
  rb_define_module_function(mXML, "debug_entities=", rxml_debug_entities_set, 1);
  rb_define_module_function(mXML, "default_compression", rxml_default_compression_get, 0);
  rb_define_module_function(mXML, "default_compression=", rxml_default_compression_set, 1);
  rb_define_module_function(mXML, "default_keep_blanks", rxml_default_keep_blanks_get, 0);
  rb_define_module_function(mXML, "default_keep_blanks=", rxml_default_keep_blanks_set, 1);
  rb_define_module_function(mXML, "default_load_external_dtd", rxml_default_load_external_dtd_get, 0);
  rb_define_module_function(mXML, "default_load_external_dtd=", rxml_default_load_external_dtd_set, 1);
  rb_define_module_function(mXML, "default_line_numbers", rxml_default_line_numbers_get, 0);
  rb_define_module_function(mXML, "default_line_numbers=", rxml_default_line_numbers_set, 1);
  rb_define_module_function(mXML, "default_options", rxml_default_options_get, 0);
  rb_define_module_function(mXML, "default_pedantic_parser", rxml_default_pedantic_parser_get, 0);
  rb_define_module_function(mXML, "default_pedantic_parser=", rxml_default_pedantic_parser_set, 1);
  rb_define_module_function(mXML, "default_substitute_entities", rxml_default_substitute_entities_get, 0);
  rb_define_module_function(mXML, "default_substitute_entities=", rxml_default_substitute_entities_set, 1);
  rb_define_module_function(mXML, "default_tree_indent_string", rxml_default_tree_indent_string_get, 0);
  rb_define_module_function(mXML, "default_tree_indent_string=", rxml_default_tree_indent_string_set, 1);
  rb_define_module_function(mXML, "default_validity_checking", rxml_default_validity_checking_get, 0);
  rb_define_module_function(mXML, "default_validity_checking=", rxml_default_validity_checking_set, 1);
  rb_define_module_function(mXML, "default_warnings", rxml_default_warnings_get, 0);
  rb_define_module_function(mXML, "default_warnings=", rxml_default_warnings_set, 1);
  rb_define_module_function(mXML, "features", rxml_features, 0);
  rb_define_module_function(mXML, "indent_tree_output", rxml_indent_tree_output_get, 0);
  rb_define_module_function(mXML, "indent_tree_output=", rxml_indent_tree_output_set, 1);
  rb_define_module_function(mXML, "memory_dump", rxml_memory_dump, 0);
  rb_define_module_function(mXML, "memory_used", rxml_memory_used, 0);
}
         ruby_xml.h                                                                                          0100644 0001750 0001750 00000000325 12566211276 043204  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RUBY_XML_H__
#define __RUBY_XML_H__

extern VALUE mXML;
int rxml_libxml_default_options();
void rxml_init_xml(void);

#endif
                                                                                                                                                                                                                                                                                                           ruby_xml_attr.c                                                                                     0100644 0001750 0001750 00000017330 12566211276 044235  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

/*
 * Document-class: LibXML::XML::Attr
 *
 * Provides access to an attribute defined on an element.
 *
 * Basic Usage:
 *
 *  require 'test_helper'
 *
 *  doc = XML::Document.new(<some_file>)
 *  attribute = doc.root.attributes.get_attribute_ns('http://www.w3.org/1999/xlink', 'href')
 *  attribute.name == 'href'
 *  attribute.value == 'http://www.mydocument.com'
 *  attribute.remove!
 */

/* Attributes are owned and freed by their nodes.  Thus, its easier for the
   ruby bindings to not manage attribute memory management.  This does mean
   that accessing a particular attribute multiple times will return multiple
   different ruby objects.  Since we are not using free or xnode->_private
   this works out fine.  Previous versions of the bindings had a one to
   one mapping between ruby object and xml attribute, but that could 
   result in segfaults because the ruby object could be gc'ed.  In theory
   the mark method on the parent node could prevent that, but if an 
   attribute is returned using an xpath statement then the node would
   never by surfaced to ruby and the mark method never called. */

#include "ruby_libxml.h"
#include "ruby_xml_attr.h"

VALUE cXMLAttr;

void rxml_attr_mark(xmlAttrPtr xattr)
{
  /* This can happen if Ruby does a GC run after creating the
     new attribute but before initializing it. */
  if (xattr != NULL)
    rxml_node_mark((xmlNodePtr) xattr);
}

VALUE rxml_attr_wrap(xmlAttrPtr xattr)
{
  return Data_Wrap_Struct(cXMLAttr, rxml_attr_mark, NULL, xattr);
}

static VALUE rxml_attr_alloc(VALUE klass)
{
  return Data_Wrap_Struct(klass, rxml_attr_mark, NULL, NULL);
}

/*
 * call-seq:
 *    attr.initialize(node, "name", "value")
 *
 * Creates a new attribute for the node.
 *
 * node: The XML::Node that will contain the attribute
 * name: The name of the attribute
 * value: The value of the attribute
 *
 *  attr = XML::Attr.new(doc.root, 'name', 'libxml')
 */
static VALUE rxml_attr_initialize(int argc, VALUE *argv, VALUE self)
{
  VALUE node = argv[0];
  VALUE name = argv[1];
  VALUE value = argv[2];
  VALUE ns = (argc == 4 ? argv[3] : Qnil);

  xmlNodePtr xnode;
  xmlAttrPtr xattr;

  if (argc < 3 || argc > 4)
    rb_raise(rb_eArgError, "Wrong number of arguments (3 or 4)");

  Check_Type(name, T_STRING);
  Check_Type(value, T_STRING);

  Data_Get_Struct(node, xmlNode, xnode);

  if (xnode->type != XML_ELEMENT_NODE)
    rb_raise(rb_eArgError, "Attributes can only be created on element nodes.");

  if (NIL_P(ns))
  {
    xattr = xmlNewProp(xnode, (xmlChar*)StringValuePtr(name), (xmlChar*)StringValuePtr(value));
  }
  else
  {
    xmlNsPtr xns;
    Data_Get_Struct(ns, xmlNs, xns);
    xattr = xmlNewNsProp(xnode, xns, (xmlChar*)StringValuePtr(name), (xmlChar*)StringValuePtr(value));
  }

  if (!xattr)
    rb_raise(rb_eRuntimeError, "Could not create attribute.");

  DATA_PTR( self) = xattr;
  return self;
}

/*
 * call-seq:
 *    attr.child -> node
 *
 * Obtain this attribute's child attribute(s).
 */
static VALUE rxml_attr_child_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->children == NULL)
    return Qnil;
  else
    return rxml_node_wrap((xmlNodePtr) xattr->children);
}


/*
 * call-seq:
 *    attr.doc -> XML::Document
 *
 * Returns this attribute's document.
 *
 *  doc.root.attributes.get_attribute('name').doc == doc
 */
static VALUE rxml_attr_doc_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->doc == NULL)
    return Qnil;
  else
    return rxml_document_wrap(xattr->doc);
}

/*
 * call-seq:
 *    attr.last -> node
 *
 * Obtain the last attribute.
 */
static VALUE rxml_attr_last_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->last == NULL)
    return Qnil;
  else
    return rxml_node_wrap(xattr->last);
}

/*
 * call-seq:
 *    attr.name -> "name"
 *
 * Obtain this attribute's name.
 */
static VALUE rxml_attr_name_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);

  if (xattr->name == NULL)
    return Qnil;
  else
    return rxml_new_cstr((const char*) xattr->name, NULL);
}

/*
 * call-seq:
 *    attr.next -> node
 *
 * Obtain the next attribute.
 */
static VALUE rxml_attr_next_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->next == NULL)
    return Qnil;
  else
    return rxml_attr_wrap(xattr->next);
}

/*
 * call-seq:
 *    attr.node_type -> num
 *
 * Obtain this node's type identifier.
 */
static VALUE rxml_attr_node_type(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  return INT2NUM(xattr->type);
}

/*
 * call-seq:
 *    attr.ns -> namespace
 *
 * Obtain this attribute's associated XML::NS, if any.
 */
static VALUE rxml_attr_ns_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->ns == NULL)
    return Qnil;
  else
    return rxml_namespace_wrap(xattr->ns);
}

/*
 * call-seq:
 *    attr.parent -> node
 *
 * Obtain this attribute node's parent.
 */
static VALUE rxml_attr_parent_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->parent == NULL)
    return Qnil;
  else
    return rxml_node_wrap(xattr->parent);
}

/*
 * call-seq:
 *    attr.prev -> node
 *
 * Obtain the previous attribute.
 */
static VALUE rxml_attr_prev_get(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  if (xattr->prev == NULL)
    return Qnil;
  else
    return rxml_attr_wrap(xattr->prev);
}

/*
 * call-seq:
 *     attr.remove! -> nil
 *
 * Removes this attribute from it's parent.  Note
 * the attribute and its content is freed and can
 * no longer be used.  If you try to use it you 
 * will get a segmentation fault.
 */
static VALUE rxml_attr_remove_ex(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  xmlRemoveProp(xattr);

  RDATA(self)->data = NULL;
  RDATA(self)->dfree = NULL;
  RDATA(self)->dmark = NULL;

  return Qnil;
}

/*
 * call-seq:
 *    attr.value -> "value"
 *
 * Obtain the value of this attribute.
 */
VALUE rxml_attr_value_get(VALUE self)
{
  xmlAttrPtr xattr;
  xmlChar *value;
  VALUE result = Qnil;

  Data_Get_Struct(self, xmlAttr, xattr);
  value = xmlNodeGetContent((xmlNodePtr)xattr);

  if (value != NULL)
  {
    result = rxml_new_cstr((const char*) value, NULL);
    xmlFree(value);
  }
  return result;
}

/*
 * call-seq:
 *    attr.value = "value"
 *
 * Sets the value of this attribute.
 */
VALUE rxml_attr_value_set(VALUE self, VALUE val)
{
  xmlAttrPtr xattr;

  Check_Type(val, T_STRING);
  Data_Get_Struct(self, xmlAttr, xattr);

  if (xattr->ns)
    xmlSetNsProp(xattr->parent, xattr->ns, xattr->name,
        (xmlChar*) StringValuePtr(val));
  else
    xmlSetProp(xattr->parent, xattr->name, (xmlChar*) StringValuePtr(val));

  return (self);
}

void rxml_init_attr(void)
{
  cXMLAttr = rb_define_class_under(mXML, "Attr", rb_cObject);
  rb_define_alloc_func(cXMLAttr, rxml_attr_alloc);
  rb_define_method(cXMLAttr, "initialize", rxml_attr_initialize, -1);
  rb_define_method(cXMLAttr, "child", rxml_attr_child_get, 0);
  rb_define_method(cXMLAttr, "doc", rxml_attr_doc_get, 0);
  rb_define_method(cXMLAttr, "last", rxml_attr_last_get, 0);
  rb_define_method(cXMLAttr, "name", rxml_attr_name_get, 0);
  rb_define_method(cXMLAttr, "next", rxml_attr_next_get, 0);
  rb_define_method(cXMLAttr, "node_type", rxml_attr_node_type, 0);
  rb_define_method(cXMLAttr, "ns", rxml_attr_ns_get, 0);
  rb_define_method(cXMLAttr, "parent", rxml_attr_parent_get, 0);
  rb_define_method(cXMLAttr, "prev", rxml_attr_prev_get, 0);
  rb_define_method(cXMLAttr, "remove!", rxml_attr_remove_ex, 0);
  rb_define_method(cXMLAttr, "value", rxml_attr_value_get, 0);
  rb_define_method(cXMLAttr, "value=", rxml_attr_value_set, 1);
}
                                                                                                                                                                                                                                                                                                        ruby_xml_attr.h                                                                                     0100644 0001750 0001750 00000000466 12566211276 044244  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_ATTR__
#define __RXML_ATTR__

extern VALUE cXMLAttr;

void rxml_init_attr(void);
VALUE rxml_attr_wrap(xmlAttrPtr xattr);
VALUE rxml_attr_value_get(VALUE self);
VALUE rxml_attr_value_set(VALUE self, VALUE val);
#endif
                                                                                                                                                                                                          ruby_xml_attr_decl.c                                                                                0100644 0001750 0001750 00000007042 12566211276 045223  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

/*
 * Document-class: LibXML::XML::AttrDecl
 *
 * At attribute declaration is used in XML::Dtds to define 
 * what attributes are allowed on an element.  An attribute
 * declaration defines an attribues name, data type and default
 * value (if any).
 */

#include "ruby_libxml.h"

VALUE cXMLAttrDecl;

void rxml_attr_decl_mark(xmlAttributePtr xattr)
{
  rxml_node_mark((xmlNodePtr) xattr);
}

VALUE rxml_attr_decl_wrap(xmlAttributePtr xattr)
{
  return Data_Wrap_Struct(cXMLAttrDecl, rxml_attr_decl_mark, NULL, xattr);
}

/*
 * call-seq:
 *    attr_decl.doc -> XML::Document
 *
 * Returns this attribute declaration's document.
 */
static VALUE rxml_attr_decl_doc_get(VALUE self)
{
  xmlAttributePtr xattr;
  Data_Get_Struct(self, xmlAttribute, xattr);
  if (xattr->doc == NULL)
    return Qnil;
  else
    return rxml_document_wrap(xattr->doc);
}


/*
 * call-seq:
 *    attr_decl.name -> "name"
 *
 * Obtain this attribute declaration's name.
 */
static VALUE rxml_attr_decl_name_get(VALUE self)
{
  xmlAttributePtr xattr;
  Data_Get_Struct(self, xmlAttribute, xattr);

  if (xattr->name == NULL)
    return Qnil;
  else
    return rxml_new_cstr((const char*) xattr->name, xattr->doc->encoding);
}

/*
 * call-seq:
 *    attr_decl.next -> XML::AttrDecl
 *
 * Obtain the next attribute declaration.
 */
static VALUE rxml_attr_decl_next_get(VALUE self)
{
  xmlAttributePtr xattr;
  Data_Get_Struct(self, xmlAttribute, xattr);
  if (xattr->next == NULL)
    return Qnil;
  else
    return rxml_attr_decl_wrap((xmlAttributePtr)xattr->next);
}

/*
 * call-seq:
 *    attr_decl.type -> num
 *
 * Obtain this attribute declaration's type node type.
 */
static VALUE rxml_attr_decl_node_type(VALUE self)
{
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlAttr, xattr);
  return INT2NUM(xattr->type);
}

/*
 * call-seq:
 *    attr_decl.parent -> XML::Dtd
 *
 * Obtain this attribute declaration's parent which
 * is an instance of a XML::DTD.
 */
static VALUE rxml_attr_decl_parent_get(VALUE self)
{
  xmlAttributePtr xattr;
  Data_Get_Struct(self, xmlAttribute, xattr);

  if (xattr->parent == NULL)
    return Qnil;
  else
    return rxml_dtd_wrap(xattr->parent);
}

/*
 * call-seq:
 *    attr_decl.prev -> (XML::AttrDecl | XML::ElementDecl)
 *
 * Obtain the previous attribute declaration or the owning
 * element declration (not implemented).
 */
static VALUE rxml_attr_decl_prev_get(VALUE self)
{
  xmlAttributePtr xattr;
  Data_Get_Struct(self, xmlAttribute, xattr);

  if (xattr->prev == NULL)
    return Qnil;
  else
    return rxml_attr_decl_wrap((xmlAttributePtr)xattr->prev);
}

/*
 * call-seq:
 *    attr_decl.value -> "value"
 *
 * Obtain the default value of this attribute declaration.
 */
VALUE rxml_attr_decl_value_get(VALUE self)
{
  xmlAttributePtr xattr;

  Data_Get_Struct(self, xmlAttribute, xattr);

  if (xattr->defaultValue)
    return rxml_new_cstr((const char *)xattr->defaultValue, NULL);
  else
    return Qnil;
}

void rxml_init_attr_decl(void)
{
  cXMLAttrDecl = rb_define_class_under(mXML, "AttrDecl", rb_cObject);
  rb_define_method(cXMLAttrDecl, "doc", rxml_attr_decl_doc_get, 0);
  rb_define_method(cXMLAttrDecl, "name", rxml_attr_decl_name_get, 0);
  rb_define_method(cXMLAttrDecl, "next", rxml_attr_decl_next_get, 0);
  rb_define_method(cXMLAttrDecl, "node_type", rxml_attr_decl_node_type, 0);
  rb_define_method(cXMLAttrDecl, "parent", rxml_attr_decl_parent_get, 0);
  rb_define_method(cXMLAttrDecl, "prev", rxml_attr_decl_prev_get, 0);
  rb_define_method(cXMLAttrDecl, "value", rxml_attr_decl_value_get, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ruby_xml_attr_decl.h                                                                                0100644 0001750 0001750 00000000453 12566211276 045227  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_ATTR_DECL__
#define __RXML_ATTR_DECL__

extern VALUE cXMLAttrDecl;

void rxml_init_attr_decl(void);
VALUE rxml_attr_decl_wrap(xmlAttributePtr xattribute);
VALUE rxml_attr_decl_value_get(VALUE self);
#endif
                                                                                                                                                                                                                     ruby_xml_attributes.c                                                                               0100644 0001750 0001750 00000014645 12566211276 045457  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

/*
 * Document-class: LibXML::XML::Attributes
 *
 * Provides access to an element's attributes (XML::Attr).
 *
 * Basic Usage:
 *  require 'test_helper'
 *
 *  doc = XML::Document.new(<some_file>)
 *  attributes = doc.root.attributes
 *
 *  attributes.each do |attribute|
 *    ..
 *  end
 *
 *  attributes['foo'] = 'bar'
 *  attribute = attributes.get_attribute['foo']
 *  attribute.value == 'foo'
 *
 * To access a namespaced attribute:
 *
 *  XLINK_URI = 'http://www.w3.org/1999/xlink'
 *
 *  attribute = attributes.get_attribute_ns(XLINK_URI, 'title')
 *  attribute.value = 'My title'
 */

#include "ruby_libxml.h"
#include "ruby_xml_attributes.h"

VALUE cXMLAttributes;

void rxml_attributes_mark(xmlNodePtr xnode)
{
  rxml_node_mark(xnode);
}

/*
 * Creates a  new attributes instance.  Not exposed to ruby.
 */
VALUE rxml_attributes_new(xmlNodePtr xnode)
{
  return Data_Wrap_Struct(cXMLAttributes, rxml_attributes_mark, NULL, xnode);
}

/*
 * call-seq:
 *   attributes.node -> XML::Node
 *
 * Return the node that owns this attributes list.
 *
 *  doc.root.attributes.node == doc.root
 */
VALUE rxml_attributes_node_get(VALUE self)
{
  xmlNodePtr xnode;
  Data_Get_Struct(self, xmlNode, xnode);
  return rxml_node_wrap(xnode);
}

/*
 * call-seq:
 *    attributes.get_attribute("name") -> (XML::Attr | XML::AtrrDecl)
 *
 * Returns the specified attribute.  If the attribute does not 
 * exist but the document has an associated DTD that defines
 * a default value for the attribute, then a XML::AttrDecl is
 * returned.
 *
 * name: The name of the attribute, not including a namespace.
 *
 *  doc.root.attributes.get_attribute("foo")
 */
static VALUE rxml_attributes_get_attribute(VALUE self, VALUE name)
{
  xmlNodePtr xnode;
  xmlAttrPtr xattr;

  name = rb_obj_as_string(name);

  Data_Get_Struct(self, xmlNode, xnode);

  xattr = xmlHasProp(xnode, (xmlChar*) StringValuePtr(name));

  if (!xattr)
    return Qnil;
  else if (xattr->type == XML_ATTRIBUTE_DECL)
    return rxml_attr_decl_wrap((xmlAttributePtr)xattr);
  else
    return rxml_attr_wrap(xattr);
}

/*
 * call-seq:
 *    attributes.get_attribute_ns("namespace", "name") -> (XML::Attr | XML::AtrrDecl)
 *
 * Returns the specified attribute.  If the attribute does not 
 * exist but the document has an associated DTD that defines
 * a default value for the attribute, then a XML::AttrDecl is
 * returned.
 *
 * namespace: The URI of the attribute's namespace.
 * name: The name of the attribute, not including a namespace.
 *
 *  doc.root.attributes.get_attribute_ns('http://www.w3.org/1999/xlink', 'href')
 */
static VALUE rxml_attributes_get_attribute_ns(VALUE self, VALUE namespace,
    VALUE name)
{
  xmlNodePtr xnode;
  xmlAttrPtr xattr;

  name = rb_obj_as_string(name);

  Data_Get_Struct(self, xmlNode, xnode);

  xattr = xmlHasNsProp(xnode, (xmlChar*) StringValuePtr(name),
                      (xmlChar*) StringValuePtr(namespace));

  if (!xattr)
    return Qnil;
  else if (xattr->type == XML_ATTRIBUTE_DECL)
    return rxml_attr_decl_wrap((xmlAttributePtr)xattr);
  else
    return rxml_attr_wrap(xattr);
}

/*
 * call-seq:
 *    attributes["name"] -> String
 *
 * Fetches an attribute value. If you want to access the underlying
 * Attribute itself use get_attribute.
 *
 * name: The name of the attribute, not including any namespaces.
 *
 *  doc.root.attributes['att'] -> 'some value'
 */
VALUE rxml_attributes_attribute_get(VALUE self, VALUE name)
{
  VALUE xattr = rxml_attributes_get_attribute(self, name);
  
  if (NIL_P(xattr))
    return Qnil;
  else
    return rxml_attr_value_get(xattr);
}

/*
 * call-seq:
 *    attributes["name"] = "value"
 *
 * Sets an attribute value. If you want to get the Attribute itself,
 * use get_attribute.
 *
 * name: The name of the attribute, not including any namespaces.
 * value: The new value of the namespace.
 *
 *  doc.root.attributes['att'] = 'some value'
 */
VALUE rxml_attributes_attribute_set(VALUE self, VALUE name, VALUE value)
{
  VALUE xattr = rxml_attributes_get_attribute(self, name);
  if (NIL_P(xattr))
  {
    VALUE args[3];

    args[0] = rxml_attributes_node_get(self);
    args[1] = name;
    args[2] = value;

    return rb_class_new_instance(sizeof(args)/sizeof(VALUE), args, cXMLAttr);
  }
  else
  {
    return rxml_attr_value_set(xattr, value);
  }
}

/*
 * call-seq:
 *    attributes.each {block} -> XML::Attr
 *
 * Iterates over each attribute.
 *
 *  doc.root.attributes.each {|attribute| puts attribute.name}
 */
static VALUE rxml_attributes_each(VALUE self)
{
  xmlNodePtr xnode;
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlNode, xnode);

  xattr = xnode->properties;

  while (xattr)
  {
    /* Get the next attribute while we still can - the user
       may remove the yielded attribute. */
    xmlAttrPtr next = xattr->next;

    VALUE attr = rxml_attr_wrap(xattr);
    rb_yield(attr);
    xattr = next;
  }

  return self;
}

/*
 * call-seq:
 *    attributes.length -> Integer
 *
 * Returns the number of attributes.
 *
 *  doc.root.attributes.length
 */
static VALUE rxml_attributes_length(VALUE self)
{
  int length = 0;
  xmlNodePtr xnode;
  xmlAttrPtr xattr;
  Data_Get_Struct(self, xmlNode, xnode);

  xattr = xnode->properties;

  while (xattr)
  {
    length++;
    xattr = xattr->next;
  }
  
  return INT2NUM(length);
}

/*
 * call-seq:
 *    attributes.first -> XML::Attr
 *
 * Returns the first attribute.
 *
 *  doc.root.attributes.first
 */
static VALUE rxml_attributes_first(VALUE self)
{
  xmlNodePtr xnode;
  Data_Get_Struct(self, xmlNode, xnode);

  if (xnode->type == XML_ELEMENT_NODE)
  {
    xmlAttrPtr xattr = xnode->properties;

    if (xattr)
    {
      return rxml_attr_wrap(xattr);
    }
  }
  return Qnil;
}

void rxml_init_attributes(void)
{
  cXMLAttributes = rb_define_class_under(mXML, "Attributes", rb_cObject);
  rb_include_module(cXMLAttributes, rb_mEnumerable);
  rb_define_method(cXMLAttributes, "node", rxml_attributes_node_get, 0);
  rb_define_method(cXMLAttributes, "get_attribute", rxml_attributes_get_attribute, 1);
  rb_define_method(cXMLAttributes, "get_attribute_ns", rxml_attributes_get_attribute_ns, 2);
  rb_define_method(cXMLAttributes, "[]", rxml_attributes_attribute_get, 1);
  rb_define_method(cXMLAttributes, "[]=", rxml_attributes_attribute_set, 2);
  rb_define_method(cXMLAttributes, "each", rxml_attributes_each, 0);
  rb_define_method(cXMLAttributes, "length", rxml_attributes_length, 0);
  rb_define_method(cXMLAttributes, "first", rxml_attributes_first, 0);
}
                                                                                           ruby_xml_attributes.h                                                                               0100644 0001750 0001750 00000000612 12566211276 045451  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_ATTRIBUTES__
#define __RXML_ATTRIBUTES__

extern VALUE cXMLAttributesibutes;

void rxml_init_attributes(void);
VALUE rxml_attributes_new(xmlNodePtr xnode);

VALUE rxml_attributes_attribute_get(VALUE self, VALUE name);
VALUE rxml_attributes_attribute_set(VALUE self, VALUE name, VALUE value);


#endif
                                                                                                                      ruby_xml_cbg.c                                                                                      0100644 0001750 0001750 00000004027 12566211276 044015  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include <string.h>
#include <libxml/xmlIO.h>

/*
 int         xmlRegisterInputCallbacks       (xmlInputMatchCallback matchFunc,
                                              xmlInputOpenCallback openFunc,
                                              xmlInputReadCallback readFunc,
                                              xmlInputCloseCallback closeFunc);


 int         (*xmlInputMatchCallback)        (char const *filename);
 void*       (*xmlInputOpenCallback)         (char const *filename);
 int         (*xmlInputReadCallback)         (void *context,
 char *buffer,
 int len);
 int         (*xmlInputCloseCallback)        (void *context);
 */

typedef struct deb_doc_context
{
  char *buffer;
  char *bpos;
  int remaining;
} deb_doc_context;

int deb_Match(char const *filename)
{
  fprintf(stderr, "deb_Match: %s\n", filename);
  if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "deb://", 6))
  {
    return (1);
  }
  return (0);
}

void* deb_Open(char const *filename)
{
  deb_doc_context *deb_doc;
  VALUE res;

  deb_doc = (deb_doc_context*) malloc(sizeof(deb_doc_context));

  res = rb_funcall(rb_funcall(rb_mKernel, rb_intern("const_get"), 1,
      rb_str_new2("DEBSystem")), rb_intern("document_query"), 1, rb_str_new2(filename));
  deb_doc->buffer = strdup(StringValuePtr(res));
  //deb_doc->buffer = strdup("<serepes>serepes</serepes>");

  deb_doc->bpos = deb_doc->buffer;
  deb_doc->remaining = strlen(deb_doc->buffer);
  return deb_doc;
}

int deb_Read(void *context, char *buffer, int len)
{
  deb_doc_context *deb_doc;
  int ret_len;
  deb_doc = (deb_doc_context*) context;

  if (len >= deb_doc->remaining)
  {
    ret_len = deb_doc->remaining;
  }
  else
  {
    ret_len = len;
  }
  deb_doc->remaining -= ret_len;
  strncpy(buffer, deb_doc->bpos, ret_len);
  deb_doc->bpos += ret_len;

  return ret_len;
}

int deb_Close(void *context)
{
  free(((deb_doc_context*) context)->buffer);
  free(context);
  return 1;
}

void deb_register_cbg()
{
  xmlRegisterInputCallbacks(deb_Match, deb_Open, deb_Read, deb_Close);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ruby_xml_document.c                                                                                 0100644 0001750 0001750 00000066763 12566211276 045117  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /*
 * Document-class: LibXML::XML::Document
 *
 * The XML::Document class provides a tree based API for working
 * with xml documents.  You may directly create a document and
 * manipulate it, or create a document from a data source by
 * using an XML::Parser object.
 *
 * To read a document from a file:
 *
 *   doc = XML::Document.file('my_file')
 *
 * To use a parser to read a document:
 *
 *   parser = XML::Parser.file('my_file')
 *   doc = parser.parse
 *
 * To create a document from scratch:
 *
 *  doc = XML::Document.new()
 *  doc.root = XML::Node.new('root_node')
 *  doc.root << XML::Node.new('elem1')
 *  doc.save(filename, :indent => true, :encoding => XML::Encoding::UTF_8)
 *
 * To write a document to a file:
 *
 *  doc = XML::Document.new()
 *  doc.root = XML::Node.new('root_node')
 *  root = doc.root
 *
 *  root << elem1 = XML::Node.new('elem1')
 *  elem1['attr1'] = 'val1'
 *  elem1['attr2'] = 'val2'
 *
 *  root << elem2 = XML::Node.new('elem2')
 *  elem2['attr1'] = 'val1'
 *  elem2['attr2'] = 'val2'
 *
 *  root << elem3 = XML::Node.new('elem3')
 *  elem3 << elem4 = XML::Node.new('elem4')
 *  elem3 << elem5 = XML::Node.new('elem5')
 *
 *  elem5 << elem6 = XML::Node.new('elem6')
 *  elem6 << 'Content for element 6'
 *
 *  elem3['attr'] = 'baz'
 *
 *  doc.save(filename, :indent => true, :encoding => XML::Encoding::UTF_8)
 */

#include <stdarg.h>
#include "ruby_libxml.h"
#include "ruby_xml_document.h"

VALUE cXMLDocument;


void rxml_document_mark_node_list(xmlNodePtr xnode)
{
  if (xnode == NULL) return;

  while (xnode != NULL)
  {
    rxml_document_mark_node_list(xnode->children);
    if (xnode->_private)
      rb_gc_mark((VALUE) xnode->_private);
    xnode = xnode->next;
  }
}

void rxml_document_mark(xmlDocPtr xdoc)
{
  if (xdoc)
    rxml_document_mark_node_list(xdoc->children);
}

void rxml_document_free(xmlDocPtr xdoc)
{
  xdoc->_private = NULL;
  xmlFreeDoc(xdoc);
}

VALUE rxml_document_wrap(xmlDocPtr xdoc)
{
  VALUE result;

  // This node is already wrapped
  if (xdoc->_private != NULL)
  {
    result = (VALUE) xdoc->_private;
  }
  else
  {
    result = Data_Wrap_Struct(cXMLDocument, rxml_document_mark, rxml_document_free, xdoc);
    xdoc->_private = (void*) result;
  }

  return result;
}

/*
 * call-seq:
 *    XML::Document.alloc(xml_version = 1.0) -> document
 *
 * Alocates a new XML::Document, optionally specifying the
 * XML version.
 */
static VALUE rxml_document_alloc(VALUE klass)
{
  return Data_Wrap_Struct(klass, rxml_document_mark, rxml_document_free, NULL);
}

/*
 * call-seq:
 *    XML::Document.initialize(xml_version = 1.0) -> document
 *
 * Initializes a new XML::Document, optionally specifying the
 * XML version.
 */
static VALUE rxml_document_initialize(int argc, VALUE *argv, VALUE self)
{
  xmlDocPtr xdoc;
  VALUE xmlver;

  switch (argc)
  {
  case 0:
    xmlver = rb_str_new2("1.0");
    break;
  case 1:
    rb_scan_args(argc, argv, "01", &xmlver);
    break;
  default:
    rb_raise(rb_eArgError, "wrong number of arguments (need 0 or 1)");
  }

  Check_Type(xmlver, T_STRING);
  xdoc = xmlNewDoc((xmlChar*) StringValuePtr(xmlver));
  xdoc->_private = (void*) self;
  DATA_PTR(self) = xdoc;

  return self;
}

/* XML_C14N_1* constants are not defined until libxml 1.1.25, so if they
   are not defined then define these constants to map to zero,
   the same value as XML_C14N_1_0. */

/* XML_C14N* constants are not defined until libxml 1.1.25, so define them
   if needed so things compile. */
#ifndef XML_C14N_1_0
#define XML_C14N_1_0 0
#define XML_C14N_EXCLUSIVE_1_0 XML_C14N_1_0
#define XML_C14N_1_1 XML_C14N_1_0
#endif

/*
  * :call-seq:
  *   document.canonicalize -> String
  *   document.canonicalize(options) -> String
  *
  * Returns a string containing the canonicalized form of the document.
  * Implemented to include all of the functionality of the libxml2
  * {xmlC14NDocDumpMemory}[http://xmlsoft.org/html/libxml-c14n.html#xmlC14NDocDumpMemory]
  * method.
  *
  * === Options
  * [comments]
  *   * *Type:* Boolean
  *   * *Default:* false
  *   Specifies if comments should be output.
  *   * Must be boolean, otherwise defaults to false.
  * [inclusive_ns_prefixes]
  *   * *Type:* Array of strings
  *   * *Default:* empty array
  *   Array of namespace prefixes to include in exclusive canonicalization only.
  *   * The last item in the list is reserved for a NULL value because the C method demands it, therefore
  *     up to the first 255 valid entries will be used.
  *   * <em>Only used for *XML_C14N_EXCLUSIVE_1_0* mode. Ignored otherwise.</em>
  * [mode]
  *   * *Type:* XML::Document Constant
  *   * *Default:* XML_C14N_1_0
  *   Specifies the mode of canonicalization.
  *   * *NOTE:* XML_C14N_1_1 may not be fully implemented upon compilation due to C library compatibility.
  *     Please check if XML_C14N_1_0 and XML_C14N_1_1 are the same value prior to using XML_C14N_1_1.
  * [nodes]
  *   * *Type:* Array of XML::Node objects
  *   * *Default:* empty array
  *   XML::Nodes to include in the canonicalization process
  *   * For large lists of more than 256 valid namespaces, up to the first 256 valid entries will be used.
  */
#define C14N_NS_LIMIT 256
#define C14N_NODESET_LIMIT 256

static VALUE
rxml_document_canonicalize(int argc, VALUE *argv, VALUE self)
{
  VALUE result = Qnil;
  int length;
  xmlDocPtr xdoc;
  xmlChar *buffer = NULL;
  VALUE option_hash = Qnil;
  VALUE o_nodes = Qnil;

  // :comments option
  VALUE comments = Qfalse;
  // :mode option
  int c14n_mode = XML_C14N_1_0;
  // :inclusive_ns_prefixes option (ARRAY)

  xmlChar * inc_ns_prefixes_ptr[C14N_NS_LIMIT];

  // :nodes option (ARRAY)
  xmlNodePtr  node_ptr_array[C14N_NODESET_LIMIT];
  xmlNodeSet nodeset = {
    0, C14N_NODESET_LIMIT, NULL
  };

  /* At least one NULL value must be defined in the array or the extension will
   * segfault when using XML_C14N_EXCLUSIVE_1_0 mode.
   * API docs: "list of inclusive namespace prefixes ended with a NULL"
   */
  inc_ns_prefixes_ptr[0] = NULL;

  rb_scan_args(argc, argv, "01", &option_hash);
  // Do stuff if ruby hash passed as argument
  if (!NIL_P(option_hash)) 
  {
	VALUE o_comments = Qnil;
	VALUE o_mode = Qnil;
	VALUE o_i_ns_prefixes = Qnil;
		
    Check_Type(option_hash, T_HASH);

    o_comments = rb_hash_aref(option_hash, ID2SYM(rb_intern("comments")));
    comments = (RTEST(o_comments) ? 1 : 0);

    o_mode = rb_hash_aref(option_hash, ID2SYM(rb_intern("mode")));
    if (!NIL_P(o_mode)) 
	{
      Check_Type(o_mode, T_FIXNUM);
      c14n_mode = NUM2INT(o_mode);
      //TODO: clean this up
      //if (c14n_mode > 2) { c14n_mode = 0; }
      //mode_int = (NUM2INT(o_mode) > 2 ? 0 : NUM2INT(o_mode));
    }

    o_i_ns_prefixes = rb_hash_aref(option_hash, ID2SYM(rb_intern("inclusive_ns_prefixes")));
    if (!NIL_P(o_i_ns_prefixes)) 
	{
      int i;
      int p = 0; //pointer array index
      VALUE *list_in = NULL;
      int list_size = 0;

	  Check_Type(o_i_ns_prefixes, T_ARRAY);
      list_in = RARRAY_PTR(o_i_ns_prefixes);
      list_size = RARRAY_LEN(o_i_ns_prefixes);

      if (list_size > 0) 
	  {
        for(i=0; i < list_size; ++i) {
          if (p >= C14N_NS_LIMIT) { break; }

          if (RTEST(list_in[i])) 
		  {
            if (TYPE(list_in[i]) == T_STRING) 
			{
              inc_ns_prefixes_ptr[p] = (xmlChar *)StringValueCStr(list_in[i]);
              p++;
            }
          }
        }
      }

      // ensure p is not out of bound
      p = (p >= C14N_NS_LIMIT ? (C14N_NS_LIMIT-1) : p);

      // API docs: "list of inclusive namespace prefixes ended with a NULL"
      // Set last element to NULL
      inc_ns_prefixes_ptr[p] = NULL;
    }
    //o_ns_prefixes will free at end of block

    o_nodes = rb_hash_aref(option_hash, ID2SYM(rb_intern("nodes")));
    if (!NIL_P(o_nodes)) 
	{
      int i;
      int p = 0; // index of pointer array
      VALUE * list_in = NULL;
      int node_list_size = 0;

	  if (CLASS_OF(o_nodes) == cXMLXPathObject)
	  {
		  o_nodes = rb_funcall(o_nodes, rb_intern("to_a"), 0);
	  }
	  else
	  {
		  Check_Type(o_nodes, T_ARRAY);
	  }
      list_in = RARRAY_PTR(o_nodes);
      node_list_size = RARRAY_LEN(o_nodes);

      for (i=0; i < node_list_size; ++i)
	  {
        if (p >= C14N_NODESET_LIMIT) { break; }

        if (RTEST(list_in[i])) 
		{
          xmlNodePtr node_ptr;
          Data_Get_Struct(list_in[i], xmlNode, node_ptr);
          node_ptr_array[p] = node_ptr;
          p++;
        }
      }

      // Need to set values in nodeset struct
      nodeset.nodeNr = (node_list_size > C14N_NODESET_LIMIT ?
                        C14N_NODESET_LIMIT :
                        node_list_size);
      nodeset.nodeTab = node_ptr_array;
    }
  }//option_hash

  Data_Get_Struct(self, xmlDoc, xdoc);
  length = xmlC14NDocDumpMemory(
    xdoc,
    (nodeset.nodeNr == 0 ? NULL : &nodeset),
    c14n_mode,
    inc_ns_prefixes_ptr,
    comments,
    &buffer
  );

  if (buffer)
  {
    result = rxml_new_cstr((const char*) buffer, NULL);
    xmlFree(buffer);
  }

  return result;
}


/*
 * call-seq:
 *    document.compression -> num
 *
 * Obtain this document's compression mode identifier.
 */
static VALUE rxml_document_compression_get(VALUE self)
{
#ifdef HAVE_ZLIB_H
  xmlDocPtr xdoc;

  int compmode;
  Data_Get_Struct(self, xmlDoc, xdoc);

  compmode = xmlGetDocCompressMode(xdoc);
  if (compmode == -1)
  return(Qnil);
  else
  return(INT2NUM(compmode));
#else
  rb_warn("libxml not compiled with zlib support");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    document.compression = num
 *
 * Set this document's compression mode.
 */
static VALUE rxml_document_compression_set(VALUE self, VALUE num)
{
#ifdef HAVE_ZLIB_H
  xmlDocPtr xdoc;

  int compmode;
  Check_Type(num, T_FIXNUM);
  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc == NULL)
  {
    return(Qnil);
  }
  else
  {
    xmlSetDocCompressMode(xdoc, NUM2INT(num));

    compmode = xmlGetDocCompressMode(xdoc);
    if (compmode == -1)
    return(Qnil);
    else
    return(INT2NUM(compmode));
  }
#else
  rb_warn("libxml compiled without zlib support");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    document.compression? -> (true|false)
 *
 * Determine whether this document is compressed.
 */
static VALUE rxml_document_compression_q(VALUE self)
{
#ifdef HAVE_ZLIB_H
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->compression != -1)
  return(Qtrue);
  else
  return(Qfalse);
#else
  rb_warn("libxml compiled without zlib support");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    document.child -> node
 *
 * Get this document's child node.
 */
static VALUE rxml_document_child_get(VALUE self)
{
  xmlDocPtr xdoc;
  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->children == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc->children);
}

/*
 * call-seq:
 *    document.child? -> (true|false)
 *
 * Determine whether this document has a child node.
 */
static VALUE rxml_document_child_q(VALUE self)
{
  xmlDocPtr xdoc;
  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->children == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}


/*
 * call-seq:
 *    node.debug -> true|false
 *
 * Print libxml debugging information to stdout.
 * Requires that libxml was compiled with debugging enabled.
*/
static VALUE rxml_document_debug(VALUE self)
{
#ifdef LIBXML_DEBUG_ENABLED
  xmlDocPtr xdoc;
  Data_Get_Struct(self, xmlDoc, xdoc);
  xmlDebugDumpDocument(NULL, xdoc);
  return Qtrue;
#else
  rb_warn("libxml was compiled without debugging support.")
  return Qfalse;
#endif
}

/*
 * call-seq:
 *    document.encoding -> XML::Encoding::UTF_8
 *
 * Returns the LibXML encoding constant specified by this document.
 */
static VALUE rxml_document_encoding_get(VALUE self)
{
  xmlDocPtr xdoc;
  const char *xencoding;
  Data_Get_Struct(self, xmlDoc, xdoc);

  xencoding = (const char*)xdoc->encoding;
  return INT2NUM(xmlParseCharEncoding(xencoding));
}


/*
 * call-seq:
 *    document.rb_encoding -> Encoding
 *
 * Returns the Ruby encoding specified by this document
 * (available on Ruby 1.9.x and higher).
 */
#ifdef HAVE_RUBY_ENCODING_H
static VALUE rxml_document_rb_encoding_get(VALUE self)
{
  xmlDocPtr xdoc;
  const char *xencoding;
  rb_encoding* rbencoding;
  Data_Get_Struct(self, xmlDoc, xdoc);

  xencoding = (const char*)xdoc->encoding;
  rbencoding = rxml_xml_encoding_to_rb_encoding(mXMLEncoding, xmlParseCharEncoding(xencoding));
  return rb_enc_from_encoding(rbencoding);
}
#endif

/*
 * call-seq:
 *    document.encoding = XML::Encoding::UTF_8
 *
 * Set the encoding for this document.
 */
static VALUE rxml_document_encoding_set(VALUE self, VALUE encoding)
{
  xmlDocPtr xdoc;
  const char* xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(encoding));

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->encoding != NULL)
    xmlFree((xmlChar *) xdoc->encoding);

  xdoc->encoding = xmlStrdup((xmlChar *)xencoding);
  return self;
}

/*
 * call-seq:
 *    document.import(node) -> XML::Node
 *
 * Creates a copy of the node that can be inserted into the
 * current document.
 *
 * IMPORTANT - The returned node MUST be inserted into the document.
 * This is because the returned node refereces internal LibXML data
 * structures owned by the document.  Therefore, if the document is
 * is freed before the the node is freed a segmentation fault will occur.
 */
static VALUE rxml_document_import(VALUE self, VALUE node)
{
  xmlDocPtr xdoc;
  xmlNodePtr xnode, xresult;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(node, xmlNode, xnode);

  xresult = xmlDocCopyNode(xnode, xdoc, 1);

  if (xresult == NULL)
    rxml_raise(&xmlLastError);

  return rxml_node_wrap(xresult);
}

/*
 * call-seq:
 *    document.last -> node
 *
 * Obtain the last node.
 */
static VALUE rxml_document_last_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->last == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc->last);
}

/*
 * call-seq:
 *    document.last? -> (true|false)
 *
 * Determine whether there is a last node.
 */
static VALUE rxml_document_last_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->last == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}

/*
 * call-seq:
 *    document.next -> node
 *
 * Obtain the next node.
 */
static VALUE rxml_document_next_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->next == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc->next);
}

/*
 * call-seq:
 *    document.next? -> (true|false)
 *
 * Determine whether there is a next node.
 */
static VALUE rxml_document_next_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->next == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}

/*
 * call-seq:
 *    node.type -> num
 *
 * Obtain this node's type identifier.
 */
static VALUE rxml_document_node_type(VALUE self)
{
  xmlNodePtr xnode;
  Data_Get_Struct(self, xmlNode, xnode);
  return (INT2NUM(xnode->type));
}

/*
 * call-seq:
 *    document.parent -> node
 *
 * Obtain the parent node.
 */
static VALUE rxml_document_parent_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->parent == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc->parent);
}

/*
 * call-seq:
 *    document.parent? -> (true|false)
 *
 * Determine whether there is a parent node.
 */
static VALUE rxml_document_parent_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->parent == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}

/*
 * call-seq:
 *    document.prev -> node
 *
 * Obtain the previous node.
 */
static VALUE rxml_document_prev_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->prev == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc->prev);
}

/*
 * call-seq:
 *    document.prev? -> (true|false)
 *
 * Determine whether there is a previous node.
 */
static VALUE rxml_document_prev_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc->prev == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}

/*
 * call-seq:
 *    document.root -> node
 *
 * Obtain the root node.
 */
static VALUE rxml_document_root_get(VALUE self)
{
  xmlDocPtr xdoc;

  xmlNodePtr root;

  Data_Get_Struct(self, xmlDoc, xdoc);
  root = xmlDocGetRootElement(xdoc);

  if (root == NULL)
    return (Qnil);

  return rxml_node_wrap(root);
}

/*
 * call-seq:
 *    document.root = node
 *
 * Set the root node.
 */
static VALUE rxml_document_root_set(VALUE self, VALUE node)
{
  xmlDocPtr xdoc;
  xmlNodePtr xroot, xnode;

  if (rb_obj_is_kind_of(node, cXMLNode) == Qfalse)
    rb_raise(rb_eTypeError, "must pass an XML::Node type object");

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(node, xmlNode, xnode);

  if (xnode->doc != NULL && xnode->doc != xdoc)
    rb_raise(eXMLError, "Nodes belong to different documents.  You must first import the node by calling XML::Document.import");

  xroot = xmlDocSetRootElement(xdoc, xnode);
  return node;
}

/*
 * call-seq:
 *    document.save(filename) -> int
 *    document.save(filename, :indent => true, :encoding => XML::Encoding::UTF_8) -> int
 *
 * Saves a document to a file.  You may provide an optional hash table
 * to control how the string is generated.  Valid options are:
 *
 * :indent - Specifies if the string should be indented.  The default value
 * is true.  Note that indentation is only added if both :indent is
 * true and XML.indent_tree_output is true.  If :indent is set to false,
 * then both indentation and line feeds are removed from the result.
 *
 * :encoding - Specifies the output encoding of the string.  It
 * defaults to the original encoding of the document (see
 * #encoding.  To override the orginal encoding, use one of the
 * XML::Encoding encoding constants. */
static VALUE rxml_document_save(int argc, VALUE *argv, VALUE self)
{
  VALUE options = Qnil;
  VALUE filename = Qnil;
  xmlDocPtr xdoc;
  int indent = 1;
  const char *xfilename;
  const char *xencoding;
  int length;

  rb_scan_args(argc, argv, "11", &filename, &options);

  Check_Type(filename, T_STRING);
  xfilename = StringValuePtr(filename);

  Data_Get_Struct(self, xmlDoc, xdoc);
  xencoding = xdoc->encoding;

  if (!NIL_P(options))
  {
    VALUE rencoding, rindent;
    Check_Type(options, T_HASH);
    rencoding = rb_hash_aref(options, ID2SYM(rb_intern("encoding")));
    rindent = rb_hash_aref(options, ID2SYM(rb_intern("indent")));

    if (rindent == Qfalse)
      indent = 0;

    if (rencoding != Qnil)
    {
      xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(rencoding));
      if (!xencoding)
        rb_raise(rb_eArgError, "Unknown encoding value: %d", NUM2INT(rencoding));
    }
  }

  length = xmlSaveFormatFileEnc(xfilename, xdoc, xencoding, indent);

  if (length == -1)
    rxml_raise(&xmlLastError);

  return (INT2NUM(length));
}

/*
 * call-seq:
 *    document.standalone? -> (true|false)
 *
 * Determine whether this is a standalone document.
 */
static VALUE rxml_document_standalone_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  if (xdoc->standalone)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    document.to_s -> "string"
 *    document.to_s(:indent => true, :encoding => XML::Encoding::UTF_8) -> "string"
 *
 * Converts a document, and all of its children, to a string representation.
 * You may provide an optional hash table to control how the string is
 * generated.  Valid options are:
 *
 * :indent - Specifies if the string should be indented.  The default value
 * is true.  Note that indentation is only added if both :indent is
 * true and XML.indent_tree_output is true.  If :indent is set to false,
 * then both indentation and line feeds are removed from the result.
 *
 * :encoding - Specifies the output encoding of the string.  It
 * defaults to XML::Encoding::UTF8.  To change it, use one of the
 * XML::Encoding encoding constants. */
static VALUE rxml_document_to_s(int argc, VALUE *argv, VALUE self)
{
  VALUE result;
  VALUE options = Qnil;
  xmlDocPtr xdoc;
  int indent = 1;
  const char *xencoding = "UTF-8";
  xmlChar *buffer;
  int length;

  rb_scan_args(argc, argv, "01", &options);

  if (!NIL_P(options))
  {
    VALUE rencoding, rindent;
    Check_Type(options, T_HASH);
    rencoding = rb_hash_aref(options, ID2SYM(rb_intern("encoding")));
    rindent = rb_hash_aref(options, ID2SYM(rb_intern("indent")));

    if (rindent == Qfalse)
      indent = 0;

    if (rencoding != Qnil)
    {
      xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(rencoding));
      if (!xencoding)
        rb_raise(rb_eArgError, "Unknown encoding value: %d", NUM2INT(rencoding));
    }
  }

  Data_Get_Struct(self, xmlDoc, xdoc);
  xmlDocDumpFormatMemoryEnc(xdoc, &buffer, &length, xencoding, indent);

  result = rxml_new_cstr((const char*) buffer, xencoding);
  xmlFree(buffer);
  return result;
}

/*
 * call-seq:
 *    document.url -> "url"
 *
 * Obtain this document's source URL, if any.
 */
static VALUE rxml_document_url_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  if (xdoc->URL == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdoc->URL, NULL));
}

/*
 * call-seq:
 *    document.version -> "version"
 *
 * Obtain the XML version specified by this document.
 */
static VALUE rxml_document_version_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  if (xdoc->version == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdoc->version, NULL));
}

/*
 * call-seq:
 *    document.xhtml? -> (true|false)
 *
 * Determine whether this is an XHTML document.
 */
static VALUE rxml_document_xhtml_q(VALUE self)
{
  xmlDocPtr xdoc;
	xmlDtdPtr xdtd;
  Data_Get_Struct(self, xmlDoc, xdoc);
	xdtd = xmlGetIntSubset(xdoc);
  if (xdtd != NULL && xmlIsXHTML(xdtd->SystemID, xdtd->ExternalID) > 0)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    document.xinclude -> num
 *
 * Process xinclude directives in this document.
 */
static VALUE rxml_document_xinclude(VALUE self)
{
#ifdef LIBXML_XINCLUDE_ENABLED
  xmlDocPtr xdoc;

  int ret;

  Data_Get_Struct(self, xmlDoc, xdoc);
  ret = xmlXIncludeProcess(xdoc);
  if (ret >= 0)
  {
    return(INT2NUM(ret));
  }
  else
  {
    rxml_raise(&xmlLastError);
    return Qnil;
  }
#else
  rb_warn(
      "libxml was compiled without XInclude support.  Please recompile libxml and ruby-libxml");
  return (Qfalse);
#endif
}

/*
 * call-seq:
 *    document.order_elements!
 *
 * Call this routine to speed up XPath computation on static documents.
 * This stamps all the element nodes with the document order.
 */
static VALUE rxml_document_order_elements(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  return LONG2FIX(xmlXPathOrderDocElems(xdoc));
}

/*
 * call-seq:
 *    document.validate_schema(schema)
 *
 * Validate this document against the specified XML::Schema.
 * If the document is valid the method returns true.  Otherwise an
 * exception is raised with validation information.
 */
static VALUE rxml_document_validate_schema(VALUE self, VALUE schema)
{
  xmlSchemaValidCtxtPtr vptr;
  xmlDocPtr xdoc;
  xmlSchemaPtr xschema;
  int is_invalid;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(schema, xmlSchema, xschema);

  vptr = xmlSchemaNewValidCtxt(xschema);

  is_invalid = xmlSchemaValidateDoc(vptr, xdoc);
  xmlSchemaFreeValidCtxt(vptr);
  if (is_invalid)
  {
    rxml_raise(&xmlLastError);
    return Qfalse;
  }
  else
  {
    return Qtrue;
  }
}

/*
 * call-seq:
 *    document.validate_relaxng(relaxng)
 *
 * Validate this document against the specified XML::RelaxNG.
 * If the document is valid the method returns true.  Otherwise an
 * exception is raised with validation information.
 */
static VALUE rxml_document_validate_relaxng(VALUE self, VALUE relaxng)
{
  xmlRelaxNGValidCtxtPtr vptr;
  xmlDocPtr xdoc;
  xmlRelaxNGPtr xrelaxng;
  int is_invalid;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(relaxng, xmlRelaxNG, xrelaxng);

  vptr = xmlRelaxNGNewValidCtxt(xrelaxng);

  is_invalid = xmlRelaxNGValidateDoc(vptr, xdoc);
  xmlRelaxNGFreeValidCtxt(vptr);
  if (is_invalid)
  {
    rxml_raise(&xmlLastError);
    return Qfalse;
  }
  else
  {
    return Qtrue;
  }
}

/*
 * call-seq:
 *    document.validate(dtd) -> (true|false)
 *
 * Validate this document against the specified XML::DTD.
 * If the document is valid the method returns true.  Otherwise an
 * exception is raised with validation information.
 */
static VALUE rxml_document_validate_dtd(VALUE self, VALUE dtd)
{
  xmlValidCtxt ctxt;
  xmlDocPtr xdoc;
  xmlDtdPtr xdtd;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(dtd, xmlDtd, xdtd);

  /* Setup context */
  memset(&ctxt, 0, sizeof(xmlValidCtxt));

  if (xmlValidateDtd(&ctxt, xdoc, xdtd))
  {
    return Qtrue;
  }
  else
  {
    rxml_raise(&xmlLastError);
    return Qfalse;
  }
}

void rxml_init_document(void)
{
  cXMLDocument = rb_define_class_under(mXML, "Document", rb_cObject);
  rb_define_alloc_func(cXMLDocument, rxml_document_alloc);

  /* Original C14N 1.0 spec */
  rb_define_const(cXMLDocument, "XML_C14N_1_0", INT2NUM(XML_C14N_1_0));
  /* Exclusive C14N 1.0 spec */
  rb_define_const(cXMLDocument, "XML_C14N_EXCLUSIVE_1_0", INT2NUM(XML_C14N_EXCLUSIVE_1_0));
  /* C14N 1.1 spec */
  rb_define_const(cXMLDocument, "XML_C14N_1_1", INT2NUM(XML_C14N_1_1));

  rb_define_method(cXMLDocument, "initialize", rxml_document_initialize, -1);
  rb_define_method(cXMLDocument, "canonicalize", rxml_document_canonicalize, -1);
  rb_define_method(cXMLDocument, "child", rxml_document_child_get, 0);
  rb_define_method(cXMLDocument, "child?", rxml_document_child_q, 0);
  rb_define_method(cXMLDocument, "compression", rxml_document_compression_get, 0);
  rb_define_method(cXMLDocument, "compression=", rxml_document_compression_set, 1);
  rb_define_method(cXMLDocument, "compression?", rxml_document_compression_q, 0);
  rb_define_method(cXMLDocument, "debug", rxml_document_debug, 0);
  rb_define_method(cXMLDocument, "encoding", rxml_document_encoding_get, 0);
#ifdef HAVE_RUBY_ENCODING_H
  rb_define_method(cXMLDocument, "rb_encoding", rxml_document_rb_encoding_get, 0);
#endif
  rb_define_method(cXMLDocument, "encoding=", rxml_document_encoding_set, 1);
  rb_define_method(cXMLDocument, "import", rxml_document_import, 1);
  rb_define_method(cXMLDocument, "last", rxml_document_last_get, 0);
  rb_define_method(cXMLDocument, "last?", rxml_document_last_q, 0);
  rb_define_method(cXMLDocument, "next", rxml_document_next_get, 0);
  rb_define_method(cXMLDocument, "next?", rxml_document_next_q, 0);
  rb_define_method(cXMLDocument, "node_type", rxml_document_node_type, 0);
  rb_define_method(cXMLDocument, "order_elements!", rxml_document_order_elements, 0);
  rb_define_method(cXMLDocument, "parent", rxml_document_parent_get, 0);
  rb_define_method(cXMLDocument, "parent?", rxml_document_parent_q, 0);
  rb_define_method(cXMLDocument, "prev", rxml_document_prev_get, 0);
  rb_define_method(cXMLDocument, "prev?", rxml_document_prev_q, 0);
  rb_define_method(cXMLDocument, "root", rxml_document_root_get, 0);
  rb_define_method(cXMLDocument, "root=", rxml_document_root_set, 1);
  rb_define_method(cXMLDocument, "save", rxml_document_save, -1);
  rb_define_method(cXMLDocument, "standalone?", rxml_document_standalone_q, 0);
  rb_define_method(cXMLDocument, "to_s", rxml_document_to_s, -1);
  rb_define_method(cXMLDocument, "url", rxml_document_url_get, 0);
  rb_define_method(cXMLDocument, "version", rxml_document_version_get, 0);
  rb_define_method(cXMLDocument, "xhtml?", rxml_document_xhtml_q, 0);
  rb_define_method(cXMLDocument, "xinclude", rxml_document_xinclude, 0);
  rb_define_method(cXMLDocument, "validate", rxml_document_validate_dtd, 1);
  rb_define_method(cXMLDocument, "validate_schema", rxml_document_validate_schema, 1);
  rb_define_method(cXMLDocument, "validate_relaxng", rxml_document_validate_relaxng, 1);
}
             ruby_xml_document.h                                                                                 0100644 0001750 0001750 00000000412 12566211276 045077  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_DOCUMENT__
#define __RXML_DOCUMENT__

extern VALUE cXMLDocument;
void rxml_init_document();
VALUE rxml_document_wrap(xmlDocPtr xnode);

typedef xmlChar * xmlCharPtr;
#endif
                                                                                                                                                                                                                                                      ruby_xml_dtd.c                                                                                      0100644 0001750 0001750 00000014563 12566211276 044043  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_dtd.h"

/*
 * Document-class: LibXML::XML::Dtd
 *
 * The XML::Dtd class is used to prepare DTD's for validation of xml
 * documents.
 *
 * DTDs can be created from a string or a pair of public and system identifiers.
 * Once a Dtd object is instantiated, an XML document can be validated by the
 * XML::Document#validate method providing the XML::Dtd object as parameeter.
 * The method will raise an exception if the document is
 * not valid.
 *
 * Basic usage:
 *
 *  # parse DTD
 *  dtd = XML::Dtd.new(<<EOF)
 *  <!ELEMENT root (item*) >
 *  <!ELEMENT item (#PCDATA) >
 *  EOF
 *
 *  # parse xml document to be validated
 *  instance = XML::Document.file('instance.xml')
 *
 *  # validate
 *  instance.validate(dtd)
 */

VALUE cXMLDtd;

void rxml_dtd_free(xmlDtdPtr xdtd)
{
  /* Set _private to NULL so that we won't reuse the
   same, freed, Ruby wrapper object later.*/
  xdtd->_private = NULL;

  if (xdtd->doc == NULL && xdtd->parent == NULL)
    xmlFreeDtd(xdtd);
}

void rxml_dtd_mark(xmlDtdPtr xdtd)
{
  if (xdtd == NULL)
    return;

  if (xdtd->_private == NULL)
  {
    rb_warning("XmlNode is not bound! (%s:%d)", __FILE__, __LINE__);
    return;
  }

  rxml_node_mark((xmlNodePtr) xdtd);
}


static VALUE rxml_dtd_alloc(VALUE klass)
{
  return Data_Wrap_Struct(klass, rxml_dtd_mark, rxml_dtd_free, NULL);
}

VALUE rxml_dtd_wrap(xmlDtdPtr xdtd)
{
  VALUE result;

  // This node is already wrapped
  if (xdtd->_private != NULL)
    return (VALUE) xdtd->_private;

  result = Data_Wrap_Struct(cXMLDtd, NULL, NULL, xdtd);

  xdtd->_private = (void*) result;

  return result;
}

/*
 * call-seq:
 *    dtd.external_id -> "string"
 *
 * Obtain this dtd's external identifer (for a PUBLIC DTD).
 */
static VALUE rxml_dtd_external_id_get(VALUE self)
{
  xmlDtdPtr xdtd;
  Data_Get_Struct(self, xmlDtd, xdtd);


  if (xdtd->ExternalID == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdtd->ExternalID, NULL));
}

/*
 * call-seq:
 *    dtd.name -> "string"
 *
 * Obtain this dtd's name.
 */
static VALUE rxml_dtd_name_get(VALUE self)
{
  xmlDtdPtr xdtd;
  Data_Get_Struct(self, xmlDtd, xdtd);


  if (xdtd->name == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdtd->name, NULL));
}


/*
 * call-seq:
 *    dtd.uri -> "string"
 *
 * Obtain this dtd's URI (for a SYSTEM or PUBLIC DTD).
 */
static VALUE rxml_dtd_uri_get(VALUE self)
{
  xmlDtdPtr xdtd;
  Data_Get_Struct(self, xmlDtd, xdtd);


  if (xdtd->SystemID == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdtd->SystemID, NULL));
}

/*
 * call-seq:
 *    XML::Dtd.new("DTD string") -> dtd
 *    XML::Dtd.new("public", "system") -> dtd
 *    XML::Dtd.new("name", "public", "system", document) -> external subset dtd
 *    XML::Dtd.new("name", "public", "system", document, false) -> internal subset dtd
 *    XML::Dtd.new("name", "public", "system", document, true) -> internal subset dtd
 *
 * Create a new Dtd from the specified public and system
 * identifiers.
 */
static VALUE rxml_dtd_initialize(int argc, VALUE *argv, VALUE self)
{
  VALUE external, system, dtd_string;
  xmlParserInputBufferPtr buffer;
  xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
  xmlChar *new_string;
  xmlDtdPtr xdtd;

  // 1 argument -- string                            --> parsujeme jako dtd
  // 2 arguments -- public, system                   --> bude se hledat
  // 3 arguments -- public, system, name             --> creates an external subset (any parameter may be nil)
  // 4 arguments -- public, system, name, doc        --> creates an external subset (any parameter may be nil)
  // 5 arguments -- public, system, name, doc, true  --> creates an internal subset (all but last parameter may be nil)
  switch (argc)
  {
  case 3:
  case 4:
  case 5: {
      VALUE name, doc, internal;
      const xmlChar *xname = NULL, *xpublic = NULL, *xsystem = NULL;
      xmlDocPtr xdoc = NULL;

      rb_scan_args(argc, argv, "32", &external, &system, &name, &doc, &internal);

      if (external != Qnil) {
        Check_Type(external, T_STRING);
        xpublic = (const xmlChar*) StringValuePtr(external);
      }
      if (system != Qnil) {
        Check_Type(system, T_STRING);
        xsystem = (const xmlChar*) StringValuePtr(system);
      }
      if (name != Qnil) {
        Check_Type(name, T_STRING);
        xname = (const xmlChar*) StringValuePtr(name);
      }
      if (doc != Qnil) {
        if (rb_obj_is_kind_of(doc, cXMLDocument) == Qfalse)
          rb_raise(rb_eTypeError, "Must pass an XML::Document object");
        Data_Get_Struct(doc, xmlDoc, xdoc);
      }

      if (internal == Qnil || internal == Qfalse)
        xdtd = xmlNewDtd(xdoc, xname, xpublic, xsystem);
      else
        xdtd = xmlCreateIntSubset(xdoc, xname, xpublic, xsystem);

      if (xdtd == NULL)
        rxml_raise(&xmlLastError);

      /* Document will free this dtd now. */
      RDATA(self)->dfree = NULL;
      DATA_PTR(self) = xdtd;

      xmlSetTreeDoc((xmlNodePtr) xdtd, xdoc);
    }
    break;

  case 2:
    rb_scan_args(argc, argv, "20", &external, &system);

    Check_Type(external, T_STRING);
    Check_Type(system, T_STRING);

    xdtd = xmlParseDTD((xmlChar*) StringValuePtr(external),
        (xmlChar*) StringValuePtr(system));

    if (xdtd == NULL)
      rxml_raise(&xmlLastError);

    DATA_PTR(self) = xdtd;

    xmlSetTreeDoc((xmlNodePtr) xdtd, NULL);
    break;

  case 1:
    rb_scan_args(argc, argv, "10", &dtd_string);
    Check_Type(dtd_string, T_STRING);

    /* Note that buffer is freed by xmlParserInputBufferPush*/
    buffer = xmlAllocParserInputBuffer(enc);
    new_string = xmlStrdup((xmlChar*) StringValuePtr(dtd_string));
    xmlParserInputBufferPush(buffer, xmlStrlen(new_string),
        (const char*) new_string);

    xdtd = xmlIOParseDTD(NULL, buffer, enc);

    if (xdtd == NULL)
      rxml_raise(&xmlLastError);

    xmlFree(new_string);

    DATA_PTR(self) = xdtd;
    break;

  default:
    rb_raise(rb_eArgError, "wrong number of arguments");
  }

  return self;
}

void rxml_init_dtd()
{
  cXMLDtd = rb_define_class_under(mXML, "Dtd", rb_cObject);
  rb_define_alloc_func(cXMLDtd, rxml_dtd_alloc);
  rb_define_method(cXMLDtd, "initialize", rxml_dtd_initialize, -1);
  rb_define_method(cXMLDtd, "external_id", rxml_dtd_external_id_get, 0);
  rb_define_method(cXMLDtd, "name", rxml_dtd_name_get, 0);
  rb_define_method(cXMLDtd, "uri", rxml_dtd_uri_get, 0);

  rb_define_alias(cXMLDtd, "system_id", "uri");
}

                                                                                                                                             ruby_xml_dtd.h                                                                                      0100644 0001750 0001750 00000000212 12566211276 044032  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_DTD__
#define __RXML_DTD__

extern VALUE cXMLDtd;

void  rxml_init_dtd(void);
VALUE rxml_dtd_wrap(xmlDtdPtr xdtd);

#endif
                                                                                                                                                                                                                                                                                                                                                                                      ruby_xml_encoding.c                                                                                 0100644 0001750 0001750 00000020025 12566211276 045044  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include <stdarg.h>
#include "ruby_libxml.h"

/*
 * Document-class: LibXML::XML::Encoding
 *
 * The encoding class exposes the encodings that libxml
 * supports via constants.  
 *
 * LibXML converts all data sources to UTF8
 * internally before processing them.  By default, 
 * LibXML determines a data source's encoding 
 * using the algorithm described on its
 * website[http://xmlsoft.org/encoding.html].  
 *
 * However, you may override a data source's encoding 
 * by using the encoding constants defined in this
 * module.
 *
 * Example 1:
 *
 *   io = File.open('some_file', 'rb')
 *   parser = XML::Parser.io(io, :encoding => XML::Encoding::ISO_8859_1)
 *   doc = parser.parse
 *
 * Example 2:
 *
 *   parser = XML::HTMLParser.file("some_file", :encoding => XML::Encoding::ISO_8859_1)
 *   doc = parser.parse
 *
 * Example 3:
 *
 *   document = XML::Document.new
 *   document.encoding = XML::Encoding::ISO_8859_1
 *   doc << XML::Node.new
 */

VALUE mXMLEncoding;

/*
 * call-seq:
 *    Encoding.from_s("UTF_8") -> XML::Encoding::UTF_8
 *
 * Converts an encoding string to an encoding constant
 * defined on the XML::Encoding class.
 */
static VALUE rxml_encoding_from_s(VALUE klass, VALUE encoding)
{
  xmlCharEncoding xencoding;

  if (encoding == Qnil)
    return Qnil;

  xencoding = xmlParseCharEncoding(StringValuePtr(encoding));
  return INT2NUM(xencoding);
}

/*
 * call-seq:
 *    Encoding.to_s(XML::Encoding::UTF_8) -> "UTF-8"
 *
 * Converts an encoding constant defined on the XML::Encoding
 * class to its text representation.
 */
static VALUE rxml_encoding_to_s(VALUE klass, VALUE encoding)
{
  const char* xencoding = xmlGetCharEncodingName(NUM2INT(encoding));

  if (!xencoding)
    return Qnil;
  else
    return rxml_new_cstr(xencoding, xencoding);
}

#ifdef HAVE_RUBY_ENCODING_H
/*
 * Converts an xmlCharEncoding enum value into a Ruby Encoding object (available
 * on Ruby 1.9.* and higher).
 */
rb_encoding* rxml_xml_encoding_to_rb_encoding(VALUE klass, xmlCharEncoding xmlEncoding)
{
  const char* encodingName;

  switch (xmlEncoding)
  {
    case XML_CHAR_ENCODING_UTF8:
      encodingName = "UTF-8";
      break;
    case XML_CHAR_ENCODING_UTF16LE:
      encodingName = "UTF-16LE";
      break;
    case XML_CHAR_ENCODING_UTF16BE:
      encodingName = "UTF-16BE";
      break;
    case XML_CHAR_ENCODING_UCS4LE:
      encodingName = "UCS-4LE";
      break;
    case XML_CHAR_ENCODING_UCS4BE:
      encodingName = "UCS-4BE";
      break;
    case XML_CHAR_ENCODING_UCS2:
      encodingName = "UCS-2";
      break;
    case XML_CHAR_ENCODING_8859_1:
      encodingName = "ISO8859-1";
      break;
    case XML_CHAR_ENCODING_8859_2:
      encodingName = "ISO8859-2";
      break;
    case XML_CHAR_ENCODING_8859_3:
      encodingName = "ISO8859-3";
      break;
    case XML_CHAR_ENCODING_8859_4:
      encodingName = "ISO8859-4";
      break;
    case XML_CHAR_ENCODING_8859_5:
      encodingName = "ISO8859-5";
      break;
    case XML_CHAR_ENCODING_8859_6:
      encodingName = "ISO8859-6";
      break;
    case XML_CHAR_ENCODING_8859_7:
      encodingName = "ISO8859-7";
      break;
    case XML_CHAR_ENCODING_8859_8:
      encodingName = "ISO8859-8";
      break;
    case XML_CHAR_ENCODING_8859_9:
      encodingName = "ISO8859-9";
      break;
    case XML_CHAR_ENCODING_2022_JP:
      encodingName = "ISO-2022-JP";
      break;
    case XML_CHAR_ENCODING_SHIFT_JIS:
      encodingName = "SHIFT-JIS";
      break;
    case XML_CHAR_ENCODING_EUC_JP:
      encodingName = "EUC-JP";
      break;
    case XML_CHAR_ENCODING_ASCII:
      encodingName = "US-ASCII";
      break;
    default:
      /* Covers XML_CHAR_ENCODING_ERROR, XML_CHAR_ENCODING_NONE, XML_CHAR_ENCODING_EBCDIC */
      encodingName = "ASCII-8BIT";
      break;
  }

  return rb_enc_find(encodingName);
}

/*
 * call-seq:
 *    Input.encoding_to_rb_encoding(Input::ENCODING) -> Encoding
 *
 * Converts an encoding constant defined on the XML::Encoding
 * class to a Ruby encoding object (available on Ruby 1.9.* and higher).
 */
VALUE rxml_encoding_to_rb_encoding(VALUE klass, VALUE encoding)
{
  xmlCharEncoding xmlEncoding = (xmlCharEncoding)NUM2INT(encoding);
  rb_encoding* rbencoding = rxml_xml_encoding_to_rb_encoding(klass, xmlEncoding);
  return rb_enc_from_encoding(rbencoding);
}

rb_encoding* rxml_figure_encoding(const char* xencoding)
{
  rb_encoding* result;
  if (xencoding)
  {
    xmlCharEncoding xmlEncoding = xmlParseCharEncoding(xencoding);
    result = rxml_xml_encoding_to_rb_encoding(mXMLEncoding, xmlEncoding);
  }
  else
  {
    result = rb_utf8_encoding();
  }
  return result;
}
#endif

VALUE rxml_new_cstr(const char* xstr, const char* xencoding)
{
#ifdef HAVE_RUBY_ENCODING_H
  rb_encoding *rbencoding = rxml_figure_encoding(xencoding);
  return rb_external_str_new_with_enc(xstr, strlen(xstr), rbencoding);
#endif
  return rb_str_new2(xstr);
}

VALUE rxml_new_cstr_len(const char* xstr, const int length, const char* xencoding)
{
#ifdef HAVE_RUBY_ENCODING_H
  rb_encoding *rbencoding = rxml_figure_encoding(xencoding);
  return rb_external_str_new_with_enc(xstr, length, rbencoding);
#endif
  return rb_str_new(xstr, length);
}

void rxml_init_encoding(void)
{
  mXMLEncoding = rb_define_module_under(mXML, "Encoding");
  rb_define_module_function(mXMLEncoding, "from_s", rxml_encoding_from_s, 1);
  rb_define_module_function(mXMLEncoding, "to_s", rxml_encoding_to_s, 1);

#ifdef HAVE_RUBY_ENCODING_H
 // rb_define_module_function(mXMLEncoding, "to_rb_encoding", rxml_encoding_to_rb_encoding, 2);
#endif

  /* -1: No char encoding detected. */
  rb_define_const(mXMLEncoding, "ERROR", INT2NUM(XML_CHAR_ENCODING_ERROR));
  /* 0: No char encoding detected. */
  rb_define_const(mXMLEncoding, "NONE", INT2NUM(XML_CHAR_ENCODING_NONE));
  /* 1: UTF-8 */
  rb_define_const(mXMLEncoding, "UTF_8", INT2NUM(XML_CHAR_ENCODING_UTF8));
  /* 2: UTF-16 little endian. */
  rb_define_const(mXMLEncoding, "UTF_16LE", INT2NUM(XML_CHAR_ENCODING_UTF16LE));
  /* 3: UTF-16 big endian. */
  rb_define_const(mXMLEncoding, "UTF_16BE", INT2NUM(XML_CHAR_ENCODING_UTF16BE)); 
  /* 4: UCS-4 little endian. */
  rb_define_const(mXMLEncoding, "UCS_4LE", INT2NUM(XML_CHAR_ENCODING_UCS4LE));
  /* 5: UCS-4 big endian. */
  rb_define_const(mXMLEncoding, "UCS_4BE", INT2NUM(XML_CHAR_ENCODING_UCS4BE));
  /* 6: EBCDIC uh! */
  rb_define_const(mXMLEncoding, "EBCDIC", INT2NUM(XML_CHAR_ENCODING_EBCDIC)); 
  /* 7: UCS-4 unusual ordering. */
  rb_define_const(mXMLEncoding, "UCS_4_2143", INT2NUM(XML_CHAR_ENCODING_UCS4_2143));
  /* 8: UCS-4 unusual ordering. */
  rb_define_const(mXMLEncoding, "UCS_4_3412", INT2NUM(XML_CHAR_ENCODING_UCS4_3412));
  /* 9: UCS-2. */
  rb_define_const(mXMLEncoding, "UCS_2", INT2NUM(XML_CHAR_ENCODING_UCS2));
  /* 10: ISO-8859-1 ISO Latin 1. */
  rb_define_const(mXMLEncoding, "ISO_8859_1", INT2NUM(XML_CHAR_ENCODING_8859_1));
  /* 11: ISO-8859-2 ISO Latin 2. */
  rb_define_const(mXMLEncoding, "ISO_8859_2", INT2NUM(XML_CHAR_ENCODING_8859_2));
  /* 12: ISO-8859-3. */
  rb_define_const(mXMLEncoding, "ISO_8859_3", INT2NUM(XML_CHAR_ENCODING_8859_3));
  /* 13: ISO-8859-4. */
  rb_define_const(mXMLEncoding, "ISO_8859_4", INT2NUM(XML_CHAR_ENCODING_8859_4));
  /* 14: ISO-8859-5. */
  rb_define_const(mXMLEncoding, "ISO_8859_5", INT2NUM(XML_CHAR_ENCODING_8859_5));
  /* 15: ISO-8859-6. */
  rb_define_const(mXMLEncoding, "ISO_8859_6", INT2NUM(XML_CHAR_ENCODING_8859_6));
  /* 16: ISO-8859-7. */
  rb_define_const(mXMLEncoding, "ISO_8859_7", INT2NUM(XML_CHAR_ENCODING_8859_7));
  /* 17: ISO-8859-8. */
  rb_define_const(mXMLEncoding, "ISO_8859_8", INT2NUM(XML_CHAR_ENCODING_8859_8));
  /* 18: ISO-8859-9. */
  rb_define_const(mXMLEncoding, "ISO_8859_9", INT2NUM(XML_CHAR_ENCODING_8859_9));
  /* 19: ISO-2022-JP. */
  rb_define_const(mXMLEncoding, "ISO_2022_JP", INT2NUM(XML_CHAR_ENCODING_2022_JP));
  /* 20: Shift_JIS. */
  rb_define_const(mXMLEncoding, "SHIFT_JIS", INT2NUM(XML_CHAR_ENCODING_SHIFT_JIS));
  /* 21: EUC-JP. */
  rb_define_const(mXMLEncoding, "EUC_JP", INT2NUM(XML_CHAR_ENCODING_EUC_JP));
  /* 22: pure ASCII. */
  rb_define_const(mXMLEncoding, "ASCII", INT2NUM(XML_CHAR_ENCODING_ASCII));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ruby_xml_encoding.h                                                                                 0100644 0001750 0001750 00000001063 12566211276 045052  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_ENCODING__
#define __RXML_ENCODING__

extern VALUE mXMLEncoding;

void rxml_init_encoding();

// Ruby 1.8/1.9 encoding compatibility
VALUE rxml_new_cstr(const char* xstr, const char* xencoding);
VALUE rxml_new_cstr_len(const char* xstr, const int length, const char* xencoding);

#ifdef HAVE_RUBY_ENCODING_H
rb_encoding* rxml_xml_encoding_to_rb_encoding(VALUE klass, xmlCharEncoding xmlEncoding);
rb_encoding* rxml_figure_encoding(const char* xencoding);
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ruby_xml_error.c                                                                                    0100644 0001750 0001750 00000220535 12566211276 044417  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"

#include <libxml/xmlerror.h>

VALUE eXMLError;
static ID CALL_METHOD;
static ID ERROR_HANDLER_ID;

/*
 * Document-class: LibXML::XML::Error
 *
 * The XML::Error class exposes libxml errors as
 * standard Ruby exceptions.  When appropriate,
 * libxml-ruby will raise an exception - for example,
 * when parsing a non-well formed xml document.
 *
 * By default, warnings, errors and fatal errors that
 * libxml generates are printed to STDERR via the
 * XML::Error::VERBOSE_HANDLER proc.
 *
 * To disable this output you can install the quiet handler:
 *
 *   XML::Error.set_handler(&XML::Error::QUIET_HANDLER)
 *
 * Get the current handler:
 *
 *   proc = XML::Error.get_handler
 *
 * Install your own handler:
 *
 *   XML::Error.set_handler do |error|
 *     puts error.to_s
 *   end
 *
 * Or remove all handlers:
 *
 *   XML::Error.reset_handler
 */

static void rxml_set_handler(VALUE self, VALUE block)
{
#ifdef RB_CVAR_SET_4ARGS
  rb_cvar_set(self, ERROR_HANDLER_ID, block, 0);
#else
  rb_cvar_set(self, ERROR_HANDLER_ID, block);
#endif
}

/*
 * call-seq:
 *    Error.get_error_handler
 *
 * Returns the proc that will be called when libxml generates
 * warning, error or fatal error messages.
 */
static VALUE rxml_error_get_handler()
{
  VALUE block = rb_cvar_get(eXMLError, ERROR_HANDLER_ID);
  return block;
}

/*
 * call-seq:
 *    Error.set_error_handler {|error| ... }
 *
 * Registers a block that will be called with an instance of
 * XML::Error when libxml generates warning, error or fatal
 * error messages.
 */
static VALUE rxml_error_set_handler(VALUE self)
{
  VALUE block;

  if (rb_block_given_p() == Qfalse)
    rb_raise(rb_eRuntimeError, "No block given");

  block = rb_block_proc();

  /* Embed the block within the Error class to avoid it to be collected.
   Previous handler will be overwritten if it exists. */
  rxml_set_handler(self, block);

  return self;
}

/*
 * call-seq:
 *    Error.reset_error_handler
 *
 * Removes the current error handler. */
static VALUE rxml_error_reset_handler(VALUE self)
{
  rxml_set_handler(self, Qnil);
  return self;
}

VALUE rxml_error_wrap(xmlErrorPtr xerror)
{
  VALUE result = Qnil;

  if (xerror->message)
    result = rb_exc_new2(eXMLError, xerror->message);
  else
    result = rb_class_new_instance(0, NULL, eXMLError);

  rb_iv_set(result, "@domain", INT2NUM(xerror->domain));
  rb_iv_set(result, "@code", INT2NUM(xerror->code));
  rb_iv_set(result, "@level", INT2NUM(xerror->level));

  if (xerror->file)
    rb_iv_set(result, "@file", rb_str_new2(xerror->file));

  if (xerror->line)
    rb_iv_set(result, "@line", INT2NUM(xerror->line));

  if (xerror->str1)
    rb_iv_set(result, "@str1", rb_str_new2(xerror->str1));

  if (xerror->str2)
    rb_iv_set(result, "@str2", rb_str_new2(xerror->str2));

  if (xerror->str3)
    rb_iv_set(result, "@str3", rb_str_new2(xerror->str3));

  rb_iv_set(result, "@int1", INT2NUM(xerror->int1));
  rb_iv_set(result, "@int2", INT2NUM(xerror->int2));

  if (xerror->node)
  {
    /* Returning the original node is too dangerous because its 
       parent document is never returned to Ruby.  So return a 
       copy of the node, which does not belong to any document,
       and can free itself when Ruby calls its free method.  Note
       we just copy the node, and don't bother with the overhead
       of a recursive query. */
    xmlNodePtr xNode = xmlCopyNode((const xmlNodePtr)xerror->node, 2);
    VALUE node = rxml_node_wrap(xNode);
    rb_iv_set(result, "@node", node);
  }
  return result;
}

/* Hook that receives xml error message */
static void structuredErrorFunc(void *userData, xmlErrorPtr xerror)
{
  VALUE error = rxml_error_wrap(xerror);

  /* Wrap error up as Ruby object and send it off to ruby */
  VALUE block = rxml_error_get_handler();

  /* Now call global handler */
  if (block != Qnil)
  {
    rb_funcall(block, CALL_METHOD, 1, error);
  }
}

void rxml_raise(xmlErrorPtr xerror)
{
  /* Wrap error up as Ruby object and send it off to ruby */
  VALUE error = rxml_error_wrap(xerror);
  rb_exc_raise(error);
}

void rxml_init_error()
{
  CALL_METHOD = rb_intern("call");
  ERROR_HANDLER_ID = rb_intern("@@__error_handler_callback__");

  /* Intercept libxml error handlers */
  xmlSetStructuredErrorFunc(NULL, structuredErrorFunc);

  /* Error class */
  eXMLError = rb_define_class_under(mXML, "Error", rb_eStandardError);
  rb_define_singleton_method(eXMLError, "get_handler", rxml_error_get_handler, 0);
  rb_define_singleton_method(eXMLError, "set_handler", rxml_error_set_handler, 0);
  rb_define_singleton_method(eXMLError, "reset_handler", rxml_error_reset_handler, 0);

  /* Ruby callback to receive errors - set it to nil by default. */
  rxml_set_handler(eXMLError, Qnil);

  /* Error attributes */
  rb_define_attr(eXMLError, "level", 1, 0);
  rb_define_attr(eXMLError, "domain", 1, 0);
  rb_define_attr(eXMLError, "code", 1, 0);
  rb_define_attr(eXMLError, "file", 1, 0);
  rb_define_attr(eXMLError, "line", 1, 0);
  rb_define_attr(eXMLError, "str1", 1, 0);
  rb_define_attr(eXMLError, "str2", 1, 0);
  rb_define_attr(eXMLError, "str3", 1, 0);
  rb_define_attr(eXMLError, "int1", 1, 0);
  rb_define_attr(eXMLError, "int2", 1, 0);
  rb_define_attr(eXMLError, "ctxt", 1, 0);
  rb_define_attr(eXMLError, "node", 1, 0);

  /* xml error levels */
  rb_define_const(eXMLError, "NONE", INT2NUM(XML_ERR_NONE));
  rb_define_const(eXMLError, "WARNING", INT2NUM(XML_ERR_WARNING));
  rb_define_const(eXMLError, "ERROR", INT2NUM(XML_ERR_ERROR));
  rb_define_const(eXMLError, "FATAL", INT2NUM(XML_ERR_FATAL));

  /* xml error domains */
  rb_define_const(eXMLError, "NO_ERROR", INT2NUM(XML_FROM_NONE));
  rb_define_const(eXMLError, "PARSER", INT2NUM(XML_FROM_PARSER));
  rb_define_const(eXMLError, "TREE", INT2NUM(XML_FROM_TREE));
  rb_define_const(eXMLError, "NAMESPACE", INT2NUM(XML_FROM_NAMESPACE));
  rb_define_const(eXMLError, "DTD", INT2NUM(XML_FROM_DTD));
  rb_define_const(eXMLError, "HTML", INT2NUM(XML_FROM_HTML));
  rb_define_const(eXMLError, "MEMORY", INT2NUM(XML_FROM_MEMORY));
  rb_define_const(eXMLError, "OUTPUT", INT2NUM(XML_FROM_OUTPUT));
  rb_define_const(eXMLError, "IO", INT2NUM(XML_FROM_IO));
  rb_define_const(eXMLError, "FTP", INT2NUM(XML_FROM_FTP));
  rb_define_const(eXMLError, "HTTP", INT2NUM(XML_FROM_HTTP));
  rb_define_const(eXMLError, "XINCLUDE", INT2NUM(XML_FROM_XINCLUDE));
  rb_define_const(eXMLError, "XPATH", INT2NUM(XML_FROM_XPATH));
  rb_define_const(eXMLError, "XPOINTER", INT2NUM(XML_FROM_XPOINTER));
  rb_define_const(eXMLError, "REGEXP", INT2NUM(XML_FROM_REGEXP));
  rb_define_const(eXMLError, "DATATYPE", INT2NUM(XML_FROM_DATATYPE));
  rb_define_const(eXMLError, "SCHEMASP", INT2NUM(XML_FROM_SCHEMASP));
  rb_define_const(eXMLError, "SCHEMASV", INT2NUM(XML_FROM_SCHEMASV));
  rb_define_const(eXMLError, "RELAXNGP", INT2NUM(XML_FROM_RELAXNGP));
  rb_define_const(eXMLError, "RELAXNGV", INT2NUM(XML_FROM_RELAXNGV));
  rb_define_const(eXMLError, "CATALOG", INT2NUM(XML_FROM_CATALOG));
  rb_define_const(eXMLError, "C14N", INT2NUM(XML_FROM_C14N));
  rb_define_const(eXMLError, "XSLT", INT2NUM(XML_FROM_XSLT));
  rb_define_const(eXMLError, "VALID", INT2NUM(XML_FROM_VALID));
  rb_define_const(eXMLError, "CHECK", INT2NUM(XML_FROM_CHECK));
  rb_define_const(eXMLError, "WRITER", INT2NUM(XML_FROM_WRITER));
#if LIBXML_VERSION >= 20621
  rb_define_const(eXMLError, "MODULE", INT2NUM(XML_FROM_MODULE));
#endif
#if LIBXML_VERSION >= 20632
  rb_define_const(eXMLError, "I18N", INT2NUM(XML_FROM_I18N));
  rb_define_const(eXMLError, "SCHEMATRONV", INT2NUM(XML_FROM_SCHEMATRONV));
#endif

  /* errors */
  rb_define_const(eXMLError, "OK", INT2NUM(XML_ERR_OK));
  rb_define_const(eXMLError, "INTERNAL_ERROR", INT2NUM(XML_ERR_INTERNAL_ERROR));
  rb_define_const(eXMLError, "NO_MEMORY", INT2NUM(XML_ERR_NO_MEMORY));
  rb_define_const(eXMLError, "DOCUMENT_START", INT2NUM(XML_ERR_DOCUMENT_START));
  rb_define_const(eXMLError, "DOCUMENT_EMPTY", INT2NUM(XML_ERR_DOCUMENT_EMPTY));
  rb_define_const(eXMLError, "DOCUMENT_END", INT2NUM(XML_ERR_DOCUMENT_END));
  rb_define_const(eXMLError, "INVALID_HEX_CHARREF", INT2NUM(XML_ERR_INVALID_HEX_CHARREF));
  rb_define_const(eXMLError, "INVALID_DEC_CHARREF", INT2NUM(XML_ERR_INVALID_DEC_CHARREF));
  rb_define_const(eXMLError, "INVALID_CHARREF", INT2NUM(XML_ERR_INVALID_CHARREF));
  rb_define_const(eXMLError, "INVALID_CHAR", INT2NUM(XML_ERR_INVALID_CHAR));
  rb_define_const(eXMLError, "CHARREF_AT_EOF", INT2NUM(XML_ERR_CHARREF_AT_EOF));
  rb_define_const(eXMLError, "CHARREF_IN_PROLOG", INT2NUM(XML_ERR_CHARREF_IN_PROLOG));
  rb_define_const(eXMLError, "CHARREF_IN_EPILOG", INT2NUM(XML_ERR_CHARREF_IN_EPILOG));
  rb_define_const(eXMLError, "CHARREF_IN_DTD", INT2NUM(XML_ERR_CHARREF_IN_DTD));
  rb_define_const(eXMLError, "ENTITYREF_AT_EOF", INT2NUM(XML_ERR_ENTITYREF_AT_EOF));
  rb_define_const(eXMLError, "ENTITYREF_IN_PROLOG", INT2NUM(XML_ERR_ENTITYREF_IN_PROLOG));
  rb_define_const(eXMLError, "ENTITYREF_IN_EPILOG", INT2NUM(XML_ERR_ENTITYREF_IN_EPILOG));
  rb_define_const(eXMLError, "ENTITYREF_IN_DTD", INT2NUM(XML_ERR_ENTITYREF_IN_DTD));
  rb_define_const(eXMLError, "PEREF_AT_EOF", INT2NUM(XML_ERR_PEREF_AT_EOF));
  rb_define_const(eXMLError, "PEREF_IN_PROLOG", INT2NUM(XML_ERR_PEREF_IN_PROLOG));
  rb_define_const(eXMLError, "PEREF_IN_EPILOG",INT2NUM(XML_ERR_PEREF_IN_EPILOG));
  rb_define_const(eXMLError, "PEREF_IN_INT_SUBSET", INT2NUM(XML_ERR_PEREF_IN_INT_SUBSET));
  rb_define_const(eXMLError, "ENTITYREF_NO_NAME", INT2NUM(XML_ERR_ENTITYREF_NO_NAME));
  rb_define_const(eXMLError, "ENTITYREF_SEMICOL_MISSING", INT2NUM(XML_ERR_ENTITYREF_SEMICOL_MISSING));
  rb_define_const(eXMLError, "PEREF_NO_NAME", INT2NUM(XML_ERR_PEREF_NO_NAME));
  rb_define_const(eXMLError, "PEREF_SEMICOL_MISSING", INT2NUM(XML_ERR_PEREF_SEMICOL_MISSING));
  rb_define_const(eXMLError, "UNDECLARED_ENTITY", INT2NUM(XML_ERR_UNDECLARED_ENTITY));
  rb_define_const(eXMLError, "XML_WAR_UNDECLARED_ENTITY", INT2NUM(XML_WAR_UNDECLARED_ENTITY));
  rb_define_const(eXMLError, "UNPARSED_ENTITY", INT2NUM(XML_ERR_UNPARSED_ENTITY));
  rb_define_const(eXMLError, "ENTITY_IS_EXTERNAL", INT2NUM(XML_ERR_ENTITY_IS_EXTERNAL));
  rb_define_const(eXMLError, "ENTITY_IS_PARAMETER", INT2NUM(XML_ERR_ENTITY_IS_PARAMETER));
  rb_define_const(eXMLError, "UNKNOWN_ENCODING", INT2NUM(XML_ERR_UNKNOWN_ENCODING));
  rb_define_const(eXMLError, "UNSUPPORTED_ENCODING", INT2NUM(XML_ERR_UNSUPPORTED_ENCODING));
  rb_define_const(eXMLError, "STRING_NOT_STARTED", INT2NUM(XML_ERR_STRING_NOT_STARTED));
  rb_define_const(eXMLError, "STRING_NOT_CLOSED", INT2NUM(XML_ERR_STRING_NOT_CLOSED));
  rb_define_const(eXMLError, "NS_DECL_ERROR", INT2NUM(XML_ERR_NS_DECL_ERROR));
  rb_define_const(eXMLError, "ENTITY_NOT_STARTED", INT2NUM(XML_ERR_ENTITY_NOT_STARTED));
  rb_define_const(eXMLError, "ENTITY_NOT_FINISHED", INT2NUM(XML_ERR_ENTITY_NOT_FINISHED));
  rb_define_const(eXMLError, "LT_IN_ATTRIBUTE", INT2NUM(XML_ERR_LT_IN_ATTRIBUTE));
  rb_define_const(eXMLError, "ATTRIBUTE_NOT_STARTED", INT2NUM(XML_ERR_ATTRIBUTE_NOT_STARTED));
  rb_define_const(eXMLError, "ATTRIBUTE_NOT_FINISHED", INT2NUM(XML_ERR_ATTRIBUTE_NOT_FINISHED));
  rb_define_const(eXMLError, "ATTRIBUTE_WITHOUT_VALUE", INT2NUM(XML_ERR_ATTRIBUTE_WITHOUT_VALUE));
  rb_define_const(eXMLError, "ATTRIBUTE_REDEFINED", INT2NUM(XML_ERR_ATTRIBUTE_REDEFINED));
  rb_define_const(eXMLError, "LITERAL_NOT_STARTED", INT2NUM(XML_ERR_LITERAL_NOT_STARTED));
  rb_define_const(eXMLError, "LITERAL_NOT_FINISHED", INT2NUM(XML_ERR_LITERAL_NOT_FINISHED));
  rb_define_const(eXMLError, "COMMENT_NOT_FINISHED", INT2NUM(XML_ERR_COMMENT_NOT_FINISHED));
  rb_define_const(eXMLError, "PI_NOT_STARTED", INT2NUM(XML_ERR_PI_NOT_STARTED));
  rb_define_const(eXMLError, "PI_NOT_FINISHED", INT2NUM(XML_ERR_PI_NOT_FINISHED));
  rb_define_const(eXMLError, "NOTATION_NOT_STARTED", INT2NUM(XML_ERR_NOTATION_NOT_STARTED));
  rb_define_const(eXMLError, "NOTATION_NOT_FINISHED", INT2NUM(XML_ERR_NOTATION_NOT_FINISHED));
  rb_define_const(eXMLError, "ATTLIST_NOT_STARTED", INT2NUM(XML_ERR_ATTLIST_NOT_STARTED));
  rb_define_const(eXMLError, "ATTLIST_NOT_FINISHED", INT2NUM(XML_ERR_ATTLIST_NOT_FINISHED));
  rb_define_const(eXMLError, "MIXED_NOT_STARTED", INT2NUM(XML_ERR_MIXED_NOT_STARTED));
  rb_define_const(eXMLError, "MIXED_NOT_FINISHED", INT2NUM(XML_ERR_MIXED_NOT_FINISHED));
  rb_define_const(eXMLError, "ELEMCONTENT_NOT_STARTED", INT2NUM(XML_ERR_ELEMCONTENT_NOT_STARTED));
  rb_define_const(eXMLError, "ELEMCONTENT_NOT_FINISHED", INT2NUM(XML_ERR_ELEMCONTENT_NOT_FINISHED));
  rb_define_const(eXMLError, "XMLDECL_NOT_STARTED", INT2NUM(XML_ERR_XMLDECL_NOT_STARTED));
  rb_define_const(eXMLError, "XMLDECL_NOT_FINISHED", INT2NUM(XML_ERR_XMLDECL_NOT_FINISHED));
  rb_define_const(eXMLError, "CONDSEC_NOT_STARTED", INT2NUM(XML_ERR_CONDSEC_NOT_STARTED));
  rb_define_const(eXMLError, "CONDSEC_NOT_FINISHED", INT2NUM(XML_ERR_CONDSEC_NOT_FINISHED));
  rb_define_const(eXMLError, "EXT_SUBSET_NOT_FINISHED", INT2NUM(XML_ERR_EXT_SUBSET_NOT_FINISHED));
  rb_define_const(eXMLError, "DOCTYPE_NOT_FINISHED", INT2NUM(XML_ERR_DOCTYPE_NOT_FINISHED));
  rb_define_const(eXMLError, "MISPLACED_CDATA_END", INT2NUM(XML_ERR_MISPLACED_CDATA_END));
  rb_define_const(eXMLError, "CDATA_NOT_FINISHED", INT2NUM(XML_ERR_CDATA_NOT_FINISHED));
  rb_define_const(eXMLError, "RESERVED_XML_NAME", INT2NUM(XML_ERR_RESERVED_XML_NAME));
  rb_define_const(eXMLError, "SPACE_REQUIRED", INT2NUM(XML_ERR_SPACE_REQUIRED));
  rb_define_const(eXMLError, "SEPARATOR_REQUIRED", INT2NUM(XML_ERR_SEPARATOR_REQUIRED));
  rb_define_const(eXMLError, "NMTOKEN_REQUIRED", INT2NUM(XML_ERR_NMTOKEN_REQUIRED));
  rb_define_const(eXMLError, "NAME_REQUIRED", INT2NUM(XML_ERR_NAME_REQUIRED));
  rb_define_const(eXMLError, "PCDATA_REQUIRED", INT2NUM(XML_ERR_PCDATA_REQUIRED));
  rb_define_const(eXMLError, "URI_REQUIRED", INT2NUM(XML_ERR_URI_REQUIRED));
  rb_define_const(eXMLError, "PUBID_REQUIRED", INT2NUM(XML_ERR_PUBID_REQUIRED));
  rb_define_const(eXMLError, "LT_REQUIRED", INT2NUM(XML_ERR_LT_REQUIRED));
  rb_define_const(eXMLError, "GT_REQUIRED", INT2NUM(XML_ERR_GT_REQUIRED));
  rb_define_const(eXMLError, "LTSLASH_REQUIRED", INT2NUM(XML_ERR_LTSLASH_REQUIRED));
  rb_define_const(eXMLError, "EQUAL_REQUIRED", INT2NUM(XML_ERR_EQUAL_REQUIRED));
  rb_define_const(eXMLError, "TAG_NAME_MISMATCH", INT2NUM(XML_ERR_TAG_NAME_MISMATCH));
  rb_define_const(eXMLError, "TAG_NOT_FINISHED", INT2NUM(XML_ERR_TAG_NOT_FINISHED));
  rb_define_const(eXMLError, "STANDALONE_VALUE", INT2NUM(XML_ERR_STANDALONE_VALUE));
  rb_define_const(eXMLError, "ENCODING_NAME", INT2NUM(XML_ERR_ENCODING_NAME));
  rb_define_const(eXMLError, "HYPHEN_IN_COMMENT", INT2NUM(XML_ERR_HYPHEN_IN_COMMENT));
  rb_define_const(eXMLError, "INVALID_ENCODING", INT2NUM(XML_ERR_INVALID_ENCODING));
  rb_define_const(eXMLError, "EXT_ENTITY_STANDALONE", INT2NUM(XML_ERR_EXT_ENTITY_STANDALONE));
  rb_define_const(eXMLError, "CONDSEC_INVALID", INT2NUM(XML_ERR_CONDSEC_INVALID));
  rb_define_const(eXMLError, "VALUE_REQUIRED", INT2NUM(XML_ERR_VALUE_REQUIRED));
  rb_define_const(eXMLError, "NOT_WELL_BALANCED", INT2NUM(XML_ERR_NOT_WELL_BALANCED));
  rb_define_const(eXMLError, "EXTRA_CONTENT", INT2NUM(XML_ERR_EXTRA_CONTENT));
  rb_define_const(eXMLError, "ENTITY_CHAR_ERROR", INT2NUM(XML_ERR_ENTITY_CHAR_ERROR));
  rb_define_const(eXMLError, "ENTITY_PE_INTERNAL", INT2NUM(XML_ERR_ENTITY_PE_INTERNAL));
  rb_define_const(eXMLError, "ENTITY_LOOP", INT2NUM(XML_ERR_ENTITY_LOOP));
  rb_define_const(eXMLError, "ENTITY_BOUNDARY", INT2NUM(XML_ERR_ENTITY_BOUNDARY));
  rb_define_const(eXMLError, "INVALID_URI", INT2NUM(XML_ERR_INVALID_URI));
  rb_define_const(eXMLError, "URI_FRAGMENT", INT2NUM(XML_ERR_URI_FRAGMENT));
  rb_define_const(eXMLError, "XML_WAR_CATALOG_PI", INT2NUM(XML_WAR_CATALOG_PI));
  rb_define_const(eXMLError, "NO_DTD", INT2NUM(XML_ERR_NO_DTD));
  rb_define_const(eXMLError, "CONDSEC_INVALID_KEYWORD", INT2NUM(XML_ERR_CONDSEC_INVALID_KEYWORD));
  rb_define_const(eXMLError, "VERSION_MISSING", INT2NUM(XML_ERR_VERSION_MISSING));
  rb_define_const(eXMLError, "XML_WAR_UNKNOWN_VERSION", INT2NUM(XML_WAR_UNKNOWN_VERSION));
  rb_define_const(eXMLError, "XML_WAR_LANG_VALUE", INT2NUM(XML_WAR_LANG_VALUE));
  rb_define_const(eXMLError, "XML_WAR_NS_URI", INT2NUM(XML_WAR_NS_URI));
  rb_define_const(eXMLError, "XML_WAR_NS_URI_RELATIVE", INT2NUM(XML_WAR_NS_URI_RELATIVE));
  rb_define_const(eXMLError, "MISSING_ENCODING", INT2NUM(XML_ERR_MISSING_ENCODING));
#if LIBXML_VERSION >= 20620
  rb_define_const(eXMLError, "XML_WAR_SPACE_VALUE", INT2NUM(XML_WAR_SPACE_VALUE));
  rb_define_const(eXMLError, "NOT_STANDALONE", INT2NUM(XML_ERR_NOT_STANDALONE));
  rb_define_const(eXMLError, "ENTITY_PROCESSING", INT2NUM(XML_ERR_ENTITY_PROCESSING));
  rb_define_const(eXMLError, "NOTATION_PROCESSING", INT2NUM(XML_ERR_NOTATION_PROCESSING));
  rb_define_const(eXMLError, "WAR_NS_COLUMN", INT2NUM(XML_WAR_NS_COLUMN));
  rb_define_const(eXMLError, "WAR_ENTITY_REDEFINED", INT2NUM(XML_WAR_ENTITY_REDEFINED));
#endif
  rb_define_const(eXMLError, "NS_ERR_XML_NAMESPACE", INT2NUM(XML_NS_ERR_XML_NAMESPACE));
  rb_define_const(eXMLError, "NS_ERR_UNDEFINED_NAMESPACE", INT2NUM(XML_NS_ERR_UNDEFINED_NAMESPACE));
  rb_define_const(eXMLError, "NS_ERR_QNAME", INT2NUM(XML_NS_ERR_QNAME));
  rb_define_const(eXMLError, "NS_ERR_ATTRIBUTE_REDEFINED", INT2NUM(XML_NS_ERR_ATTRIBUTE_REDEFINED));
#if LIBXML_VERSION >= 20620
  rb_define_const(eXMLError, "NS_ERR_EMPTY", INT2NUM(XML_NS_ERR_EMPTY));
#endif
#if LIBXML_VERSION >= 20700
  rb_define_const(eXMLError, "NS_ERR_COLON", INT2NUM(XML_NS_ERR_COLON));
#endif
  rb_define_const(eXMLError, "DTD_ATTRIBUTE_DEFAULT", INT2NUM(XML_DTD_ATTRIBUTE_DEFAULT));
  rb_define_const(eXMLError, "DTD_ATTRIBUTE_REDEFINED", INT2NUM(XML_DTD_ATTRIBUTE_REDEFINED));
  rb_define_const(eXMLError, "DTD_ATTRIBUTE_VALUE", INT2NUM(XML_DTD_ATTRIBUTE_VALUE));
  rb_define_const(eXMLError, "DTD_CONTENT_ERROR", INT2NUM(XML_DTD_CONTENT_ERROR));
  rb_define_const(eXMLError, "DTD_CONTENT_MODEL", INT2NUM(XML_DTD_CONTENT_MODEL));
  rb_define_const(eXMLError, "DTD_CONTENT_NOT_DETERMINIST", INT2NUM(XML_DTD_CONTENT_NOT_DETERMINIST));
  rb_define_const(eXMLError, "DTD_DIFFERENT_PREFIX", INT2NUM(XML_DTD_DIFFERENT_PREFIX));
  rb_define_const(eXMLError, "DTD_ELEM_DEFAULT_NAMESPACE", INT2NUM(XML_DTD_ELEM_DEFAULT_NAMESPACE));
  rb_define_const(eXMLError, "DTD_ELEM_NAMESPACE", INT2NUM(XML_DTD_ELEM_NAMESPACE));
  rb_define_const(eXMLError, "DTD_ELEM_REDEFINED", INT2NUM(XML_DTD_ELEM_REDEFINED));
  rb_define_const(eXMLError, "DTD_EMPTY_NOTATION", INT2NUM(XML_DTD_EMPTY_NOTATION));
  rb_define_const(eXMLError, "DTD_ENTITY_TYPE", INT2NUM(XML_DTD_ENTITY_TYPE));
  rb_define_const(eXMLError, "DTD_ID_FIXED", INT2NUM(XML_DTD_ID_FIXED));
  rb_define_const(eXMLError, "DTD_ID_REDEFINED", INT2NUM(XML_DTD_ID_REDEFINED));
  rb_define_const(eXMLError, "DTD_ID_SUBSET", INT2NUM(XML_DTD_ID_SUBSET));
  rb_define_const(eXMLError, "DTD_INVALID_CHILD", INT2NUM(XML_DTD_INVALID_CHILD));
  rb_define_const(eXMLError, "DTD_INVALID_DEFAULT", INT2NUM(XML_DTD_INVALID_DEFAULT));
  rb_define_const(eXMLError, "DTD_LOAD_ERROR", INT2NUM(XML_DTD_LOAD_ERROR));
  rb_define_const(eXMLError, "DTD_MISSING_ATTRIBUTE", INT2NUM(XML_DTD_MISSING_ATTRIBUTE));
  rb_define_const(eXMLError, "DTD_MIXED_CORRUPT", INT2NUM(XML_DTD_MIXED_CORRUPT));
  rb_define_const(eXMLError, "DTD_MULTIPLE_ID", INT2NUM(XML_DTD_MULTIPLE_ID));
  rb_define_const(eXMLError, "DTD_NO_DOC", INT2NUM(XML_DTD_NO_DOC));
  rb_define_const(eXMLError, "DTD_NO_DTD", INT2NUM(XML_DTD_NO_DTD));
  rb_define_const(eXMLError, "DTD_NO_ELEM_NAME", INT2NUM(XML_DTD_NO_ELEM_NAME));
  rb_define_const(eXMLError, "DTD_NO_PREFIX", INT2NUM(XML_DTD_NO_PREFIX));
  rb_define_const(eXMLError, "DTD_NO_ROOT", INT2NUM(XML_DTD_NO_ROOT));
  rb_define_const(eXMLError, "DTD_NOTATION_REDEFINED", INT2NUM(XML_DTD_NOTATION_REDEFINED));
  rb_define_const(eXMLError, "DTD_NOTATION_VALUE", INT2NUM(XML_DTD_NOTATION_VALUE));
  rb_define_const(eXMLError, "DTD_NOT_EMPTY", INT2NUM(XML_DTD_NOT_EMPTY));
  rb_define_const(eXMLError, "DTD_NOT_PCDATA", INT2NUM(XML_DTD_NOT_PCDATA));
  rb_define_const(eXMLError, "DTD_NOT_STANDALONE", INT2NUM(XML_DTD_NOT_STANDALONE));
  rb_define_const(eXMLError, "DTD_ROOT_NAME", INT2NUM(XML_DTD_ROOT_NAME));
  rb_define_const(eXMLError, "DTD_STANDALONE_WHITE_SPACE", INT2NUM(XML_DTD_STANDALONE_WHITE_SPACE));
  rb_define_const(eXMLError, "DTD_UNKNOWN_ATTRIBUTE", INT2NUM(XML_DTD_UNKNOWN_ATTRIBUTE));
  rb_define_const(eXMLError, "DTD_UNKNOWN_ELEM", INT2NUM(XML_DTD_UNKNOWN_ELEM));
  rb_define_const(eXMLError, "DTD_UNKNOWN_ENTITY", INT2NUM(XML_DTD_UNKNOWN_ENTITY));
  rb_define_const(eXMLError, "DTD_UNKNOWN_ID", INT2NUM(XML_DTD_UNKNOWN_ID));
  rb_define_const(eXMLError, "DTD_UNKNOWN_NOTATION", INT2NUM(XML_DTD_UNKNOWN_NOTATION));
  rb_define_const(eXMLError, "DTD_STANDALONE_DEFAULTED", INT2NUM(XML_DTD_STANDALONE_DEFAULTED));
  rb_define_const(eXMLError, "DTD_XMLID_VALUE", INT2NUM(XML_DTD_XMLID_VALUE));
  rb_define_const(eXMLError, "DTD_XMLID_TYPE", INT2NUM(XML_DTD_XMLID_TYPE));
  rb_define_const(eXMLError, "HTML_STRUCURE_ERROR", INT2NUM(XML_HTML_STRUCURE_ERROR));
  rb_define_const(eXMLError, "HTML_UNKNOWN_TAG", INT2NUM(XML_HTML_UNKNOWN_TAG));
  rb_define_const(eXMLError, "RNGP_ANYNAME_ATTR_ANCESTOR", INT2NUM(XML_RNGP_ANYNAME_ATTR_ANCESTOR));
  rb_define_const(eXMLError, "RNGP_ATTR_CONFLICT", INT2NUM(XML_RNGP_ATTR_CONFLICT));
  rb_define_const(eXMLError, "RNGP_ATTRIBUTE_CHILDREN", INT2NUM(XML_RNGP_ATTRIBUTE_CHILDREN));
  rb_define_const(eXMLError, "RNGP_ATTRIBUTE_CONTENT", INT2NUM(XML_RNGP_ATTRIBUTE_CONTENT));
  rb_define_const(eXMLError, "RNGP_ATTRIBUTE_EMPTY", INT2NUM(XML_RNGP_ATTRIBUTE_EMPTY));
  rb_define_const(eXMLError, "RNGP_ATTRIBUTE_NOOP", INT2NUM(XML_RNGP_ATTRIBUTE_NOOP));
  rb_define_const(eXMLError, "RNGP_CHOICE_CONTENT", INT2NUM(XML_RNGP_CHOICE_CONTENT));
  rb_define_const(eXMLError, "RNGP_CHOICE_EMPTY", INT2NUM(XML_RNGP_CHOICE_EMPTY));
  rb_define_const(eXMLError, "RNGP_CREATE_FAILURE", INT2NUM(XML_RNGP_CREATE_FAILURE));
  rb_define_const(eXMLError, "RNGP_DATA_CONTENT", INT2NUM(XML_RNGP_DATA_CONTENT));
  rb_define_const(eXMLError, "RNGP_DEF_CHOICE_AND_INTERLEAVE", INT2NUM(XML_RNGP_DEF_CHOICE_AND_INTERLEAVE));
  rb_define_const(eXMLError, "RNGP_DEFINE_CREATE_FAILED", INT2NUM(XML_RNGP_DEFINE_CREATE_FAILED));
  rb_define_const(eXMLError, "RNGP_DEFINE_EMPTY", INT2NUM(XML_RNGP_DEFINE_EMPTY));
  rb_define_const(eXMLError, "RNGP_DEFINE_MISSING", INT2NUM(XML_RNGP_DEFINE_MISSING));
  rb_define_const(eXMLError, "RNGP_DEFINE_NAME_MISSING", INT2NUM(XML_RNGP_DEFINE_NAME_MISSING));
  rb_define_const(eXMLError, "RNGP_ELEM_CONTENT_EMPTY", INT2NUM(XML_RNGP_ELEM_CONTENT_EMPTY));
  rb_define_const(eXMLError, "RNGP_ELEM_CONTENT_ERROR", INT2NUM(XML_RNGP_ELEM_CONTENT_ERROR));
  rb_define_const(eXMLError, "RNGP_ELEMENT_EMPTY", INT2NUM(XML_RNGP_ELEMENT_EMPTY));
  rb_define_const(eXMLError, "RNGP_ELEMENT_CONTENT", INT2NUM(XML_RNGP_ELEMENT_CONTENT));
  rb_define_const(eXMLError, "RNGP_ELEMENT_NAME", INT2NUM(XML_RNGP_ELEMENT_NAME));
  rb_define_const(eXMLError, "RNGP_ELEMENT_NO_CONTENT", INT2NUM(XML_RNGP_ELEMENT_NO_CONTENT));
  rb_define_const(eXMLError, "RNGP_ELEM_TEXT_CONFLICT", INT2NUM(XML_RNGP_ELEM_TEXT_CONFLICT));
  rb_define_const(eXMLError, "RNGP_EMPTY", INT2NUM(XML_RNGP_EMPTY));
  rb_define_const(eXMLError, "RNGP_EMPTY_CONSTRUCT", INT2NUM(XML_RNGP_EMPTY_CONSTRUCT));
  rb_define_const(eXMLError, "RNGP_EMPTY_CONTENT", INT2NUM(XML_RNGP_EMPTY_CONTENT));
  rb_define_const(eXMLError, "RNGP_EMPTY_NOT_EMPTY", INT2NUM(XML_RNGP_EMPTY_NOT_EMPTY));
  rb_define_const(eXMLError, "RNGP_ERROR_TYPE_LIB", INT2NUM(XML_RNGP_ERROR_TYPE_LIB));
  rb_define_const(eXMLError, "RNGP_EXCEPT_EMPTY", INT2NUM(XML_RNGP_EXCEPT_EMPTY));
  rb_define_const(eXMLError, "RNGP_EXCEPT_MISSING", INT2NUM(XML_RNGP_EXCEPT_MISSING));
  rb_define_const(eXMLError, "RNGP_EXCEPT_MULTIPLE", INT2NUM(XML_RNGP_EXCEPT_MULTIPLE));
  rb_define_const(eXMLError, "RNGP_EXCEPT_NO_CONTENT", INT2NUM(XML_RNGP_EXCEPT_NO_CONTENT));
  rb_define_const(eXMLError, "RNGP_EXTERNALREF_EMTPY", INT2NUM(XML_RNGP_EXTERNALREF_EMTPY));
  rb_define_const(eXMLError, "RNGP_EXTERNAL_REF_FAILURE", INT2NUM(XML_RNGP_EXTERNAL_REF_FAILURE));
  rb_define_const(eXMLError, "RNGP_EXTERNALREF_RECURSE", INT2NUM(XML_RNGP_EXTERNALREF_RECURSE));
  rb_define_const(eXMLError, "RNGP_FORBIDDEN_ATTRIBUTE", INT2NUM(XML_RNGP_FORBIDDEN_ATTRIBUTE));
  rb_define_const(eXMLError, "RNGP_FOREIGN_ELEMENT", INT2NUM(XML_RNGP_FOREIGN_ELEMENT));
  rb_define_const(eXMLError, "RNGP_GRAMMAR_CONTENT", INT2NUM(XML_RNGP_GRAMMAR_CONTENT));
  rb_define_const(eXMLError, "RNGP_GRAMMAR_EMPTY", INT2NUM(XML_RNGP_GRAMMAR_EMPTY));
  rb_define_const(eXMLError, "RNGP_GRAMMAR_MISSING", INT2NUM(XML_RNGP_GRAMMAR_MISSING));
  rb_define_const(eXMLError, "RNGP_GRAMMAR_NO_START", INT2NUM(XML_RNGP_GRAMMAR_NO_START));
  rb_define_const(eXMLError, "RNGP_GROUP_ATTR_CONFLICT", INT2NUM(XML_RNGP_GROUP_ATTR_CONFLICT));
  rb_define_const(eXMLError, "RNGP_HREF_ERROR", INT2NUM(XML_RNGP_HREF_ERROR));
  rb_define_const(eXMLError, "RNGP_INCLUDE_EMPTY", INT2NUM(XML_RNGP_INCLUDE_EMPTY));
  rb_define_const(eXMLError, "RNGP_INCLUDE_FAILURE", INT2NUM(XML_RNGP_INCLUDE_FAILURE));
  rb_define_const(eXMLError, "RNGP_INCLUDE_RECURSE", INT2NUM(XML_RNGP_INCLUDE_RECURSE));
  rb_define_const(eXMLError, "RNGP_INTERLEAVE_ADD", INT2NUM(XML_RNGP_INTERLEAVE_ADD));
  rb_define_const(eXMLError, "RNGP_INTERLEAVE_CREATE_FAILED", INT2NUM(XML_RNGP_INTERLEAVE_CREATE_FAILED));
  rb_define_const(eXMLError, "RNGP_INTERLEAVE_EMPTY", INT2NUM(XML_RNGP_INTERLEAVE_EMPTY));
  rb_define_const(eXMLError, "RNGP_INTERLEAVE_NO_CONTENT", INT2NUM(XML_RNGP_INTERLEAVE_NO_CONTENT));
  rb_define_const(eXMLError, "RNGP_INVALID_DEFINE_NAME", INT2NUM(XML_RNGP_INVALID_DEFINE_NAME));
  rb_define_const(eXMLError, "RNGP_INVALID_URI", INT2NUM(XML_RNGP_INVALID_URI));
  rb_define_const(eXMLError, "RNGP_INVALID_VALUE", INT2NUM(XML_RNGP_INVALID_VALUE));
  rb_define_const(eXMLError, "RNGP_MISSING_HREF", INT2NUM(XML_RNGP_MISSING_HREF));
  rb_define_const(eXMLError, "RNGP_NAME_MISSING", INT2NUM(XML_RNGP_NAME_MISSING));
  rb_define_const(eXMLError, "RNGP_NEED_COMBINE", INT2NUM(XML_RNGP_NEED_COMBINE));
  rb_define_const(eXMLError, "RNGP_NOTALLOWED_NOT_EMPTY", INT2NUM(XML_RNGP_NOTALLOWED_NOT_EMPTY));
  rb_define_const(eXMLError, "RNGP_NSNAME_ATTR_ANCESTOR", INT2NUM(XML_RNGP_NSNAME_ATTR_ANCESTOR));
  rb_define_const(eXMLError, "RNGP_NSNAME_NO_NS", INT2NUM(XML_RNGP_NSNAME_NO_NS));
  rb_define_const(eXMLError, "RNGP_PARAM_FORBIDDEN", INT2NUM(XML_RNGP_PARAM_FORBIDDEN));
  rb_define_const(eXMLError, "RNGP_PARAM_NAME_MISSING", INT2NUM(XML_RNGP_PARAM_NAME_MISSING));
  rb_define_const(eXMLError, "RNGP_PARENTREF_CREATE_FAILED", INT2NUM(XML_RNGP_PARENTREF_CREATE_FAILED));
  rb_define_const(eXMLError, "RNGP_PARENTREF_NAME_INVALID", INT2NUM(XML_RNGP_PARENTREF_NAME_INVALID));
  rb_define_const(eXMLError, "RNGP_PARENTREF_NO_NAME", INT2NUM(XML_RNGP_PARENTREF_NO_NAME));
  rb_define_const(eXMLError, "RNGP_PARENTREF_NO_PARENT", INT2NUM(XML_RNGP_PARENTREF_NO_PARENT));
  rb_define_const(eXMLError, "RNGP_PARENTREF_NOT_EMPTY", INT2NUM(XML_RNGP_PARENTREF_NOT_EMPTY));
  rb_define_const(eXMLError, "RNGP_PARSE_ERROR", INT2NUM(XML_RNGP_PARSE_ERROR));
  rb_define_const(eXMLError, "RNGP_PAT_ANYNAME_EXCEPT_ANYNAME", INT2NUM(XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME));
  rb_define_const(eXMLError, "RNGP_PAT_ATTR_ATTR", INT2NUM(XML_RNGP_PAT_ATTR_ATTR));
  rb_define_const(eXMLError, "RNGP_PAT_ATTR_ELEM", INT2NUM(XML_RNGP_PAT_ATTR_ELEM));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_ATTR", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_ATTR));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_ELEM", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_ELEM));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_EMPTY", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_EMPTY));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_GROUP", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_GROUP));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_INTERLEAVE", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_LIST", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_LIST));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_ONEMORE", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_ONEMORE));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_REF", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_REF));
  rb_define_const(eXMLError, "RNGP_PAT_DATA_EXCEPT_TEXT", INT2NUM(XML_RNGP_PAT_DATA_EXCEPT_TEXT));
  rb_define_const(eXMLError, "RNGP_PAT_LIST_ATTR", INT2NUM(XML_RNGP_PAT_LIST_ATTR));
  rb_define_const(eXMLError, "RNGP_PAT_LIST_ELEM", INT2NUM(XML_RNGP_PAT_LIST_ELEM));
  rb_define_const(eXMLError, "RNGP_PAT_LIST_INTERLEAVE", INT2NUM(XML_RNGP_PAT_LIST_INTERLEAVE));
  rb_define_const(eXMLError, "RNGP_PAT_LIST_LIST", INT2NUM(XML_RNGP_PAT_LIST_LIST));
  rb_define_const(eXMLError, "RNGP_PAT_LIST_REF", INT2NUM(XML_RNGP_PAT_LIST_REF));
  rb_define_const(eXMLError, "RNGP_PAT_LIST_TEXT", INT2NUM(XML_RNGP_PAT_LIST_TEXT));
  rb_define_const(eXMLError, "RNGP_PAT_NSNAME_EXCEPT_ANYNAME", INT2NUM(XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME));
  rb_define_const(eXMLError, "RNGP_PAT_NSNAME_EXCEPT_NSNAME", INT2NUM(XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME));
  rb_define_const(eXMLError, "RNGP_PAT_ONEMORE_GROUP_ATTR", INT2NUM(XML_RNGP_PAT_ONEMORE_GROUP_ATTR));
  rb_define_const(eXMLError, "RNGP_PAT_ONEMORE_INTERLEAVE_ATTR", INT2NUM(XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR));
  rb_define_const(eXMLError, "RNGP_PAT_START_ATTR", INT2NUM(XML_RNGP_PAT_START_ATTR));
  rb_define_const(eXMLError, "RNGP_PAT_START_DATA", INT2NUM(XML_RNGP_PAT_START_DATA));
  rb_define_const(eXMLError, "RNGP_PAT_START_EMPTY", INT2NUM(XML_RNGP_PAT_START_EMPTY));
  rb_define_const(eXMLError, "RNGP_PAT_START_GROUP", INT2NUM(XML_RNGP_PAT_START_GROUP));
  rb_define_const(eXMLError, "RNGP_PAT_START_INTERLEAVE", INT2NUM(XML_RNGP_PAT_START_INTERLEAVE));
  rb_define_const(eXMLError, "RNGP_PAT_START_LIST", INT2NUM(XML_RNGP_PAT_START_LIST));
  rb_define_const(eXMLError, "RNGP_PAT_START_ONEMORE", INT2NUM(XML_RNGP_PAT_START_ONEMORE));
  rb_define_const(eXMLError, "RNGP_PAT_START_TEXT", INT2NUM(XML_RNGP_PAT_START_TEXT));
  rb_define_const(eXMLError, "RNGP_PAT_START_VALUE", INT2NUM(XML_RNGP_PAT_START_VALUE));
  rb_define_const(eXMLError, "RNGP_PREFIX_UNDEFINED", INT2NUM(XML_RNGP_PREFIX_UNDEFINED));
  rb_define_const(eXMLError, "RNGP_REF_CREATE_FAILED", INT2NUM(XML_RNGP_REF_CREATE_FAILED));
  rb_define_const(eXMLError, "RNGP_REF_CYCLE", INT2NUM(XML_RNGP_REF_CYCLE));
  rb_define_const(eXMLError, "RNGP_REF_NAME_INVALID", INT2NUM(XML_RNGP_REF_NAME_INVALID));
  rb_define_const(eXMLError, "RNGP_REF_NO_DEF", INT2NUM(XML_RNGP_REF_NO_DEF));
  rb_define_const(eXMLError, "RNGP_REF_NO_NAME", INT2NUM(XML_RNGP_REF_NO_NAME));
  rb_define_const(eXMLError, "RNGP_REF_NOT_EMPTY", INT2NUM(XML_RNGP_REF_NOT_EMPTY));
  rb_define_const(eXMLError, "RNGP_START_CHOICE_AND_INTERLEAVE", INT2NUM(XML_RNGP_START_CHOICE_AND_INTERLEAVE));
  rb_define_const(eXMLError, "RNGP_START_CONTENT", INT2NUM(XML_RNGP_START_CONTENT));
  rb_define_const(eXMLError, "RNGP_START_EMPTY", INT2NUM(XML_RNGP_START_EMPTY));
  rb_define_const(eXMLError, "RNGP_START_MISSING", INT2NUM(XML_RNGP_START_MISSING));
  rb_define_const(eXMLError, "RNGP_TEXT_EXPECTED", INT2NUM(XML_RNGP_TEXT_EXPECTED));
  rb_define_const(eXMLError, "RNGP_TEXT_HAS_CHILD", INT2NUM(XML_RNGP_TEXT_HAS_CHILD));
  rb_define_const(eXMLError, "RNGP_TYPE_MISSING", INT2NUM(XML_RNGP_TYPE_MISSING));
  rb_define_const(eXMLError, "RNGP_TYPE_NOT_FOUND", INT2NUM(XML_RNGP_TYPE_NOT_FOUND));
  rb_define_const(eXMLError, "RNGP_TYPE_VALUE", INT2NUM(XML_RNGP_TYPE_VALUE));
  rb_define_const(eXMLError, "RNGP_UNKNOWN_ATTRIBUTE", INT2NUM(XML_RNGP_UNKNOWN_ATTRIBUTE));
  rb_define_const(eXMLError, "RNGP_UNKNOWN_COMBINE", INT2NUM(XML_RNGP_UNKNOWN_COMBINE));
  rb_define_const(eXMLError, "RNGP_UNKNOWN_CONSTRUCT", INT2NUM(XML_RNGP_UNKNOWN_CONSTRUCT));
  rb_define_const(eXMLError, "RNGP_UNKNOWN_TYPE_LIB", INT2NUM(XML_RNGP_UNKNOWN_TYPE_LIB));
  rb_define_const(eXMLError, "RNGP_URI_FRAGMENT", INT2NUM(XML_RNGP_URI_FRAGMENT));
  rb_define_const(eXMLError, "RNGP_URI_NOT_ABSOLUTE", INT2NUM(XML_RNGP_URI_NOT_ABSOLUTE));
  rb_define_const(eXMLError, "RNGP_VALUE_EMPTY", INT2NUM(XML_RNGP_VALUE_EMPTY));
  rb_define_const(eXMLError, "RNGP_VALUE_NO_CONTENT", INT2NUM(XML_RNGP_VALUE_NO_CONTENT));
  rb_define_const(eXMLError, "RNGP_XMLNS_NAME", INT2NUM(XML_RNGP_XMLNS_NAME));
  rb_define_const(eXMLError, "RNGP_XML_NS", INT2NUM(XML_RNGP_XML_NS));
  rb_define_const(eXMLError, "XPATH_EXPRESSION_OK", INT2NUM(XML_XPATH_EXPRESSION_OK));
  rb_define_const(eXMLError, "XPATH_NUMBER_ERROR", INT2NUM(XML_XPATH_NUMBER_ERROR));
  rb_define_const(eXMLError, "XPATH_UNFINISHED_LITERAL_ERROR", INT2NUM(XML_XPATH_UNFINISHED_LITERAL_ERROR));
  rb_define_const(eXMLError, "XPATH_START_LITERAL_ERROR", INT2NUM(XML_XPATH_START_LITERAL_ERROR));
  rb_define_const(eXMLError, "XPATH_VARIABLE_REF_ERROR", INT2NUM(XML_XPATH_VARIABLE_REF_ERROR));
  rb_define_const(eXMLError, "XPATH_UNDEF_VARIABLE_ERROR", INT2NUM(XML_XPATH_UNDEF_VARIABLE_ERROR));
  rb_define_const(eXMLError, "XPATH_INVALID_PREDICATE_ERROR", INT2NUM(XML_XPATH_INVALID_PREDICATE_ERROR));
  rb_define_const(eXMLError, "XPATH_EXPR_ERROR", INT2NUM(XML_XPATH_EXPR_ERROR));
  rb_define_const(eXMLError, "XPATH_UNCLOSED_ERROR", INT2NUM(XML_XPATH_UNCLOSED_ERROR));
  rb_define_const(eXMLError, "XPATH_UNKNOWN_FUNC_ERROR", INT2NUM(XML_XPATH_UNKNOWN_FUNC_ERROR));
  rb_define_const(eXMLError, "XPATH_INVALID_OPERAND", INT2NUM(XML_XPATH_INVALID_OPERAND));
  rb_define_const(eXMLError, "XPATH_INVALID_TYPE", INT2NUM(XML_XPATH_INVALID_TYPE));
  rb_define_const(eXMLError, "XPATH_INVALID_ARITY", INT2NUM(XML_XPATH_INVALID_ARITY));
  rb_define_const(eXMLError, "XPATH_INVALID_CTXT_SIZE", INT2NUM(XML_XPATH_INVALID_CTXT_SIZE));
  rb_define_const(eXMLError, "XPATH_INVALID_CTXT_POSITION", INT2NUM(XML_XPATH_INVALID_CTXT_POSITION));
  rb_define_const(eXMLError, "XPATH_MEMORY_ERROR", INT2NUM(XML_XPATH_MEMORY_ERROR));
  rb_define_const(eXMLError, "XPTR_SYNTAX_ERROR", INT2NUM(XML_XPTR_SYNTAX_ERROR));
  rb_define_const(eXMLError, "XPTR_RESOURCE_ERROR", INT2NUM(XML_XPTR_RESOURCE_ERROR));
  rb_define_const(eXMLError, "XPTR_SUB_RESOURCE_ERROR", INT2NUM(XML_XPTR_SUB_RESOURCE_ERROR));
  rb_define_const(eXMLError, "XPATH_UNDEF_PREFIX_ERROR", INT2NUM(XML_XPATH_UNDEF_PREFIX_ERROR));
  rb_define_const(eXMLError, "XPATH_ENCODING_ERROR", INT2NUM(XML_XPATH_ENCODING_ERROR));
  rb_define_const(eXMLError, "XPATH_INVALID_CHAR_ERROR", INT2NUM(XML_XPATH_INVALID_CHAR_ERROR));
  rb_define_const(eXMLError, "TREE_INVALID_HEX", INT2NUM(XML_TREE_INVALID_HEX));
  rb_define_const(eXMLError, "TREE_INVALID_DEC", INT2NUM(XML_TREE_INVALID_DEC));
  rb_define_const(eXMLError, "TREE_UNTERMINATED_ENTITY", INT2NUM(XML_TREE_UNTERMINATED_ENTITY));
#if LIBXML_VERSION >= 20632
  rb_define_const(eXMLError, "TREE_NOT_UTF8", INT2NUM(XML_TREE_NOT_UTF8));
#endif
  rb_define_const(eXMLError, "SAVE_NOT_UTF8", INT2NUM(XML_SAVE_NOT_UTF8));
  rb_define_const(eXMLError, "SAVE_CHAR_INVALID", INT2NUM(XML_SAVE_CHAR_INVALID));
  rb_define_const(eXMLError, "SAVE_NO_DOCTYPE", INT2NUM(XML_SAVE_NO_DOCTYPE));
  rb_define_const(eXMLError, "SAVE_UNKNOWN_ENCODING", INT2NUM(XML_SAVE_UNKNOWN_ENCODING));
  rb_define_const(eXMLError, "REGEXP_COMPILE_ERROR", INT2NUM(XML_REGEXP_COMPILE_ERROR));
  rb_define_const(eXMLError, "IO_UNKNOWN", INT2NUM(XML_IO_UNKNOWN));
  rb_define_const(eXMLError, "IO_EACCES", INT2NUM(XML_IO_EACCES));
  rb_define_const(eXMLError, "IO_EAGAIN", INT2NUM(XML_IO_EAGAIN));
  rb_define_const(eXMLError, "IO_EBADF", INT2NUM(XML_IO_EBADF));
  rb_define_const(eXMLError, "IO_EBADMSG", INT2NUM(XML_IO_EBADMSG));
  rb_define_const(eXMLError, "IO_EBUSY", INT2NUM(XML_IO_EBUSY));
  rb_define_const(eXMLError, "IO_ECANCELED", INT2NUM(XML_IO_ECANCELED));
  rb_define_const(eXMLError, "IO_ECHILD", INT2NUM(XML_IO_ECHILD));
  rb_define_const(eXMLError, "IO_EDEADLK", INT2NUM(XML_IO_EDEADLK));
  rb_define_const(eXMLError, "IO_EDOM", INT2NUM(XML_IO_EDOM));
  rb_define_const(eXMLError, "IO_EEXIST", INT2NUM(XML_IO_EEXIST));
  rb_define_const(eXMLError, "IO_EFAULT", INT2NUM(XML_IO_EFAULT));
  rb_define_const(eXMLError, "IO_EFBIG", INT2NUM(XML_IO_EFBIG));
  rb_define_const(eXMLError, "IO_EINPROGRESS", INT2NUM(XML_IO_EINPROGRESS));
  rb_define_const(eXMLError, "IO_EINTR", INT2NUM(XML_IO_EINTR));
  rb_define_const(eXMLError, "IO_EINVAL", INT2NUM(XML_IO_EINVAL));
  rb_define_const(eXMLError, "IO_EIO", INT2NUM(XML_IO_EIO));
  rb_define_const(eXMLError, "IO_EISDIR", INT2NUM(XML_IO_EISDIR));
  rb_define_const(eXMLError, "IO_EMFILE", INT2NUM(XML_IO_EMFILE));
  rb_define_const(eXMLError, "IO_EMLINK", INT2NUM(XML_IO_EMLINK));
  rb_define_const(eXMLError, "IO_EMSGSIZE", INT2NUM(XML_IO_EMSGSIZE));
  rb_define_const(eXMLError, "IO_ENAMETOOLONG", INT2NUM(XML_IO_ENAMETOOLONG));
  rb_define_const(eXMLError, "IO_ENFILE", INT2NUM(XML_IO_ENFILE));
  rb_define_const(eXMLError, "IO_ENODEV", INT2NUM(XML_IO_ENODEV));
  rb_define_const(eXMLError, "IO_ENOENT", INT2NUM(XML_IO_ENOENT));
  rb_define_const(eXMLError, "IO_ENOEXEC", INT2NUM(XML_IO_ENOEXEC));
  rb_define_const(eXMLError, "IO_ENOLCK", INT2NUM(XML_IO_ENOLCK));
  rb_define_const(eXMLError, "IO_ENOMEM", INT2NUM(XML_IO_ENOMEM));
  rb_define_const(eXMLError, "IO_ENOSPC", INT2NUM(XML_IO_ENOSPC));
  rb_define_const(eXMLError, "IO_ENOSYS", INT2NUM(XML_IO_ENOSYS));
  rb_define_const(eXMLError, "IO_ENOTDIR", INT2NUM(XML_IO_ENOTDIR));
  rb_define_const(eXMLError, "IO_ENOTEMPTY", INT2NUM(XML_IO_ENOTEMPTY));
  rb_define_const(eXMLError, "IO_ENOTSUP", INT2NUM(XML_IO_ENOTSUP));
  rb_define_const(eXMLError, "IO_ENOTTY", INT2NUM(XML_IO_ENOTTY));
  rb_define_const(eXMLError, "IO_ENXIO", INT2NUM(XML_IO_ENXIO));
  rb_define_const(eXMLError, "IO_EPERM", INT2NUM(XML_IO_EPERM));
  rb_define_const(eXMLError, "IO_EPIPE", INT2NUM(XML_IO_EPIPE));
  rb_define_const(eXMLError, "IO_ERANGE", INT2NUM(XML_IO_ERANGE));
  rb_define_const(eXMLError, "IO_EROFS", INT2NUM(XML_IO_EROFS));
  rb_define_const(eXMLError, "IO_ESPIPE", INT2NUM(XML_IO_ESPIPE));
  rb_define_const(eXMLError, "IO_ESRCH", INT2NUM(XML_IO_ESRCH));
  rb_define_const(eXMLError, "IO_ETIMEDOUT", INT2NUM(XML_IO_ETIMEDOUT));
  rb_define_const(eXMLError, "IO_EXDEV", INT2NUM(XML_IO_EXDEV));
  rb_define_const(eXMLError, "IO_NETWORK_ATTEMPT", INT2NUM(XML_IO_NETWORK_ATTEMPT));
  rb_define_const(eXMLError, "IO_ENCODER", INT2NUM(XML_IO_ENCODER));
  rb_define_const(eXMLError, "IO_FLUSH", INT2NUM(XML_IO_FLUSH));
  rb_define_const(eXMLError, "IO_WRITE", INT2NUM(XML_IO_WRITE));
  rb_define_const(eXMLError, "IO_NO_INPUT", INT2NUM(XML_IO_NO_INPUT));
  rb_define_const(eXMLError, "IO_BUFFER_FULL", INT2NUM(XML_IO_BUFFER_FULL));
  rb_define_const(eXMLError, "IO_LOAD_ERROR", INT2NUM(XML_IO_LOAD_ERROR));
  rb_define_const(eXMLError, "IO_ENOTSOCK", INT2NUM(XML_IO_ENOTSOCK));
  rb_define_const(eXMLError, "IO_EISCONN", INT2NUM(XML_IO_EISCONN));
  rb_define_const(eXMLError, "IO_ECONNREFUSED", INT2NUM(XML_IO_ECONNREFUSED));
  rb_define_const(eXMLError, "IO_ENETUNREACH", INT2NUM(XML_IO_ENETUNREACH));
  rb_define_const(eXMLError, "IO_EADDRINUSE", INT2NUM(XML_IO_EADDRINUSE));
  rb_define_const(eXMLError, "IO_EALREADY", INT2NUM(XML_IO_EALREADY));
  rb_define_const(eXMLError, "IO_EAFNOSUPPORT", INT2NUM(XML_IO_EAFNOSUPPORT));
  rb_define_const(eXMLError, "XINCLUDE_RECURSION", INT2NUM(XML_XINCLUDE_RECURSION));
  rb_define_const(eXMLError, "XINCLUDE_PARSE_VALUE", INT2NUM(XML_XINCLUDE_PARSE_VALUE));
  rb_define_const(eXMLError, "XINCLUDE_ENTITY_DEF_MISMATCH", INT2NUM(XML_XINCLUDE_ENTITY_DEF_MISMATCH));
  rb_define_const(eXMLError, "XINCLUDE_NO_HREF", INT2NUM(XML_XINCLUDE_NO_HREF));
  rb_define_const(eXMLError, "XINCLUDE_NO_FALLBACK", INT2NUM(XML_XINCLUDE_NO_FALLBACK));
  rb_define_const(eXMLError, "XINCLUDE_HREF_URI", INT2NUM(XML_XINCLUDE_HREF_URI));
  rb_define_const(eXMLError, "XINCLUDE_TEXT_FRAGMENT", INT2NUM(XML_XINCLUDE_TEXT_FRAGMENT));
  rb_define_const(eXMLError, "XINCLUDE_TEXT_DOCUMENT", INT2NUM(XML_XINCLUDE_TEXT_DOCUMENT));
  rb_define_const(eXMLError, "XINCLUDE_INVALID_CHAR", INT2NUM(XML_XINCLUDE_INVALID_CHAR));
  rb_define_const(eXMLError, "XINCLUDE_BUILD_FAILED", INT2NUM(XML_XINCLUDE_BUILD_FAILED));
  rb_define_const(eXMLError, "XINCLUDE_UNKNOWN_ENCODING", INT2NUM(XML_XINCLUDE_UNKNOWN_ENCODING));
  rb_define_const(eXMLError, "XINCLUDE_MULTIPLE_ROOT", INT2NUM(XML_XINCLUDE_MULTIPLE_ROOT));
  rb_define_const(eXMLError, "XINCLUDE_XPTR_FAILED", INT2NUM(XML_XINCLUDE_XPTR_FAILED));
  rb_define_const(eXMLError, "XINCLUDE_XPTR_RESULT", INT2NUM(XML_XINCLUDE_XPTR_RESULT));
  rb_define_const(eXMLError, "XINCLUDE_INCLUDE_IN_INCLUDE", INT2NUM(XML_XINCLUDE_INCLUDE_IN_INCLUDE));
  rb_define_const(eXMLError, "XINCLUDE_FALLBACKS_IN_INCLUDE", INT2NUM(XML_XINCLUDE_FALLBACKS_IN_INCLUDE));
  rb_define_const(eXMLError, "XINCLUDE_FALLBACK_NOT_IN_INCLUDE", INT2NUM(XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE));
  rb_define_const(eXMLError, "XINCLUDE_DEPRECATED_NS", INT2NUM(XML_XINCLUDE_DEPRECATED_NS));
  rb_define_const(eXMLError, "XINCLUDE_FRAGMENT_ID", INT2NUM(XML_XINCLUDE_FRAGMENT_ID));
  rb_define_const(eXMLError, "CATALOG_MISSING_ATTR", INT2NUM(XML_CATALOG_MISSING_ATTR));
  rb_define_const(eXMLError, "CATALOG_ENTRY_BROKEN", INT2NUM(XML_CATALOG_ENTRY_BROKEN));
  rb_define_const(eXMLError, "CATALOG_PREFER_VALUE", INT2NUM(XML_CATALOG_PREFER_VALUE));
  rb_define_const(eXMLError, "CATALOG_NOT_CATALOG", INT2NUM(XML_CATALOG_NOT_CATALOG));
  rb_define_const(eXMLError, "CATALOG_RECURSION", INT2NUM(XML_CATALOG_RECURSION));
  rb_define_const(eXMLError, "SCHEMAP_PREFIX_UNDEFINED", INT2NUM(XML_SCHEMAP_PREFIX_UNDEFINED));
  rb_define_const(eXMLError, "SCHEMAP_ATTRFORMDEFAULT_VALUE", INT2NUM(XML_SCHEMAP_ATTRFORMDEFAULT_VALUE));
  rb_define_const(eXMLError, "SCHEMAP_ATTRGRP_NONAME_NOREF", INT2NUM(XML_SCHEMAP_ATTRGRP_NONAME_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_ATTR_NONAME_NOREF", INT2NUM(XML_SCHEMAP_ATTR_NONAME_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_COMPLEXTYPE_NONAME_NOREF", INT2NUM(XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_ELEMFORMDEFAULT_VALUE", INT2NUM(XML_SCHEMAP_ELEMFORMDEFAULT_VALUE));
  rb_define_const(eXMLError, "SCHEMAP_ELEM_NONAME_NOREF", INT2NUM(XML_SCHEMAP_ELEM_NONAME_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_EXTENSION_NO_BASE", INT2NUM(XML_SCHEMAP_EXTENSION_NO_BASE));
  rb_define_const(eXMLError, "SCHEMAP_FACET_NO_VALUE", INT2NUM(XML_SCHEMAP_FACET_NO_VALUE));
  rb_define_const(eXMLError, "SCHEMAP_FAILED_BUILD_IMPORT", INT2NUM(XML_SCHEMAP_FAILED_BUILD_IMPORT));
  rb_define_const(eXMLError, "SCHEMAP_GROUP_NONAME_NOREF", INT2NUM(XML_SCHEMAP_GROUP_NONAME_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_IMPORT_NAMESPACE_NOT_URI", INT2NUM(XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI));
  rb_define_const(eXMLError, "SCHEMAP_IMPORT_REDEFINE_NSNAME", INT2NUM(XML_SCHEMAP_IMPORT_REDEFINE_NSNAME));
  rb_define_const(eXMLError, "SCHEMAP_IMPORT_SCHEMA_NOT_URI", INT2NUM(XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_BOOLEAN", INT2NUM(XML_SCHEMAP_INVALID_BOOLEAN));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_ENUM", INT2NUM(XML_SCHEMAP_INVALID_ENUM));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_FACET", INT2NUM(XML_SCHEMAP_INVALID_FACET));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_FACET_VALUE", INT2NUM(XML_SCHEMAP_INVALID_FACET_VALUE));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_MAXOCCURS", INT2NUM(XML_SCHEMAP_INVALID_MAXOCCURS));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_MINOCCURS", INT2NUM(XML_SCHEMAP_INVALID_MINOCCURS));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_REF_AND_SUBTYPE", INT2NUM(XML_SCHEMAP_INVALID_REF_AND_SUBTYPE));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_WHITE_SPACE", INT2NUM(XML_SCHEMAP_INVALID_WHITE_SPACE));
  rb_define_const(eXMLError, "SCHEMAP_NOATTR_NOREF", INT2NUM(XML_SCHEMAP_NOATTR_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_NOTATION_NO_NAME", INT2NUM(XML_SCHEMAP_NOTATION_NO_NAME));
  rb_define_const(eXMLError, "SCHEMAP_NOTYPE_NOREF", INT2NUM(XML_SCHEMAP_NOTYPE_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_REF_AND_SUBTYPE", INT2NUM(XML_SCHEMAP_REF_AND_SUBTYPE));
  rb_define_const(eXMLError, "SCHEMAP_RESTRICTION_NONAME_NOREF", INT2NUM(XML_SCHEMAP_RESTRICTION_NONAME_NOREF));
  rb_define_const(eXMLError, "SCHEMAP_SIMPLETYPE_NONAME", INT2NUM(XML_SCHEMAP_SIMPLETYPE_NONAME));
  rb_define_const(eXMLError, "SCHEMAP_TYPE_AND_SUBTYPE", INT2NUM(XML_SCHEMAP_TYPE_AND_SUBTYPE));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_ALL_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_ALL_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_ATTR_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_ATTR_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_ATTRGRP_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP", INT2NUM(XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_BASE_TYPE", INT2NUM(XML_SCHEMAP_UNKNOWN_BASE_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_CHOICE_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_CHOICE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_ELEM_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_ELEM_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_EXTENSION_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_FACET_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_FACET_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_FACET_TYPE", INT2NUM(XML_SCHEMAP_UNKNOWN_FACET_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_GROUP_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_GROUP_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_IMPORT_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_IMPORT_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_LIST_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_LIST_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_NOTATION_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_NOTATION_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_REF", INT2NUM(XML_SCHEMAP_UNKNOWN_REF));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_RESTRICTION_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_SCHEMAS_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_SEQUENCE_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_TYPE", INT2NUM(XML_SCHEMAP_UNKNOWN_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_UNION_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_UNION_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_ELEM_DEFAULT_FIXED", INT2NUM(XML_SCHEMAP_ELEM_DEFAULT_FIXED));
  rb_define_const(eXMLError, "SCHEMAP_REGEXP_INVALID", INT2NUM(XML_SCHEMAP_REGEXP_INVALID));
  rb_define_const(eXMLError, "SCHEMAP_FAILED_LOAD", INT2NUM(XML_SCHEMAP_FAILED_LOAD));
  rb_define_const(eXMLError, "SCHEMAP_NOTHING_TO_PARSE", INT2NUM(XML_SCHEMAP_NOTHING_TO_PARSE));
  rb_define_const(eXMLError, "SCHEMAP_NOROOT", INT2NUM(XML_SCHEMAP_NOROOT));
  rb_define_const(eXMLError, "SCHEMAP_REDEFINED_GROUP", INT2NUM(XML_SCHEMAP_REDEFINED_GROUP));
  rb_define_const(eXMLError, "SCHEMAP_REDEFINED_TYPE", INT2NUM(XML_SCHEMAP_REDEFINED_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_REDEFINED_ELEMENT", INT2NUM(XML_SCHEMAP_REDEFINED_ELEMENT));
  rb_define_const(eXMLError, "SCHEMAP_REDEFINED_ATTRGROUP", INT2NUM(XML_SCHEMAP_REDEFINED_ATTRGROUP));
  rb_define_const(eXMLError, "SCHEMAP_REDEFINED_ATTR", INT2NUM(XML_SCHEMAP_REDEFINED_ATTR));
  rb_define_const(eXMLError, "SCHEMAP_REDEFINED_NOTATION", INT2NUM(XML_SCHEMAP_REDEFINED_NOTATION));
  rb_define_const(eXMLError, "SCHEMAP_FAILED_PARSE", INT2NUM(XML_SCHEMAP_FAILED_PARSE));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_PREFIX", INT2NUM(XML_SCHEMAP_UNKNOWN_PREFIX));
  rb_define_const(eXMLError, "SCHEMAP_DEF_AND_PREFIX", INT2NUM(XML_SCHEMAP_DEF_AND_PREFIX));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_INCLUDE_CHILD", INT2NUM(XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_INCLUDE_SCHEMA_NOT_URI", INT2NUM(XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI));
  rb_define_const(eXMLError, "SCHEMAP_INCLUDE_SCHEMA_NO_URI", INT2NUM(XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI));
  rb_define_const(eXMLError, "SCHEMAP_NOT_SCHEMA", INT2NUM(XML_SCHEMAP_NOT_SCHEMA));
  rb_define_const(eXMLError, "SCHEMAP_UNKNOWN_MEMBER_TYPE", INT2NUM(XML_SCHEMAP_UNKNOWN_MEMBER_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_ATTR_USE", INT2NUM(XML_SCHEMAP_INVALID_ATTR_USE));
  rb_define_const(eXMLError, "SCHEMAP_RECURSIVE", INT2NUM(XML_SCHEMAP_RECURSIVE));
  rb_define_const(eXMLError, "SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE", INT2NUM(XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_ATTR_COMBINATION", INT2NUM(XML_SCHEMAP_INVALID_ATTR_COMBINATION));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_ATTR_INLINE_COMBINATION", INT2NUM(XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION));
  rb_define_const(eXMLError, "SCHEMAP_MISSING_SIMPLETYPE_CHILD", INT2NUM(XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD));
  rb_define_const(eXMLError, "SCHEMAP_INVALID_ATTR_NAME", INT2NUM(XML_SCHEMAP_INVALID_ATTR_NAME));
  rb_define_const(eXMLError, "SCHEMAP_REF_AND_CONTENT", INT2NUM(XML_SCHEMAP_REF_AND_CONTENT));
  rb_define_const(eXMLError, "SCHEMAP_CT_PROPS_CORRECT_1", INT2NUM(XML_SCHEMAP_CT_PROPS_CORRECT_1));
  rb_define_const(eXMLError, "SCHEMAP_CT_PROPS_CORRECT_2", INT2NUM(XML_SCHEMAP_CT_PROPS_CORRECT_2));
  rb_define_const(eXMLError, "SCHEMAP_CT_PROPS_CORRECT_3", INT2NUM(XML_SCHEMAP_CT_PROPS_CORRECT_3));
  rb_define_const(eXMLError, "SCHEMAP_CT_PROPS_CORRECT_4", INT2NUM(XML_SCHEMAP_CT_PROPS_CORRECT_4));
  rb_define_const(eXMLError, "SCHEMAP_CT_PROPS_CORRECT_5", INT2NUM(XML_SCHEMAP_CT_PROPS_CORRECT_5));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_1", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_2_2", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_3", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3));
  rb_define_const(eXMLError, "SCHEMAP_WILDCARD_INVALID_NS_MEMBER", INT2NUM(XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER));
  rb_define_const(eXMLError, "SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE", INT2NUM(XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE));
  rb_define_const(eXMLError, "SCHEMAP_UNION_NOT_EXPRESSIBLE", INT2NUM(XML_SCHEMAP_UNION_NOT_EXPRESSIBLE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_3_1", INT2NUM(XML_SCHEMAP_SRC_IMPORT_3_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_3_2", INT2NUM(XML_SCHEMAP_SRC_IMPORT_3_2));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_4_1", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_4_2", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_4_3", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3));
  rb_define_const(eXMLError, "SCHEMAP_COS_CT_EXTENDS_1_3", INT2NUM(XML_SCHEMAP_COS_CT_EXTENDS_1_3));
  rb_define_const(eXMLError, "SCHEMAV_NOROOT", INT2NUM(XML_SCHEMAV_NOROOT));
  rb_define_const(eXMLError, "SCHEMAV_UNDECLAREDELEM", INT2NUM(XML_SCHEMAV_UNDECLAREDELEM));
  rb_define_const(eXMLError, "SCHEMAV_NOTTOPLEVEL", INT2NUM(XML_SCHEMAV_NOTTOPLEVEL));
  rb_define_const(eXMLError, "SCHEMAV_MISSING", INT2NUM(XML_SCHEMAV_MISSING));
  rb_define_const(eXMLError, "SCHEMAV_WRONGELEM", INT2NUM(XML_SCHEMAV_WRONGELEM));
  rb_define_const(eXMLError, "SCHEMAV_NOTYPE", INT2NUM(XML_SCHEMAV_NOTYPE));
  rb_define_const(eXMLError, "SCHEMAV_NOROLLBACK", INT2NUM(XML_SCHEMAV_NOROLLBACK));
  rb_define_const(eXMLError, "SCHEMAV_ISABSTRACT", INT2NUM(XML_SCHEMAV_ISABSTRACT));
  rb_define_const(eXMLError, "SCHEMAV_NOTEMPTY", INT2NUM(XML_SCHEMAV_NOTEMPTY));
  rb_define_const(eXMLError, "SCHEMAV_ELEMCONT", INT2NUM(XML_SCHEMAV_ELEMCONT));
  rb_define_const(eXMLError, "SCHEMAV_HAVEDEFAULT", INT2NUM(XML_SCHEMAV_HAVEDEFAULT));
  rb_define_const(eXMLError, "SCHEMAV_NOTNILLABLE", INT2NUM(XML_SCHEMAV_NOTNILLABLE));
  rb_define_const(eXMLError, "SCHEMAV_EXTRACONTENT", INT2NUM(XML_SCHEMAV_EXTRACONTENT));
  rb_define_const(eXMLError, "SCHEMAV_INVALIDATTR", INT2NUM(XML_SCHEMAV_INVALIDATTR));
  rb_define_const(eXMLError, "SCHEMAV_INVALIDELEM", INT2NUM(XML_SCHEMAV_INVALIDELEM));
  rb_define_const(eXMLError, "SCHEMAV_NOTDETERMINIST", INT2NUM(XML_SCHEMAV_NOTDETERMINIST));
  rb_define_const(eXMLError, "SCHEMAV_CONSTRUCT", INT2NUM(XML_SCHEMAV_CONSTRUCT));
  rb_define_const(eXMLError, "SCHEMAV_INTERNAL", INT2NUM(XML_SCHEMAV_INTERNAL));
  rb_define_const(eXMLError, "SCHEMAV_NOTSIMPLE", INT2NUM(XML_SCHEMAV_NOTSIMPLE));
  rb_define_const(eXMLError, "SCHEMAV_ATTRUNKNOWN", INT2NUM(XML_SCHEMAV_ATTRUNKNOWN));
  rb_define_const(eXMLError, "SCHEMAV_ATTRINVALID", INT2NUM(XML_SCHEMAV_ATTRINVALID));
  rb_define_const(eXMLError, "SCHEMAV_VALUE", INT2NUM(XML_SCHEMAV_VALUE));
  rb_define_const(eXMLError, "SCHEMAV_FACET", INT2NUM(XML_SCHEMAV_FACET));
  rb_define_const(eXMLError, "SCHEMAV_CVC_DATATYPE_VALID_1_2_1", INT2NUM(XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_DATATYPE_VALID_1_2_2", INT2NUM(XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_DATATYPE_VALID_1_2_3", INT2NUM(XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3));
  rb_define_const(eXMLError, "SCHEMAV_CVC_TYPE_3_1_1", INT2NUM(XML_SCHEMAV_CVC_TYPE_3_1_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_TYPE_3_1_2", INT2NUM(XML_SCHEMAV_CVC_TYPE_3_1_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_FACET_VALID", INT2NUM(XML_SCHEMAV_CVC_FACET_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_LENGTH_VALID", INT2NUM(XML_SCHEMAV_CVC_LENGTH_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_MINLENGTH_VALID", INT2NUM(XML_SCHEMAV_CVC_MINLENGTH_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_MAXLENGTH_VALID", INT2NUM(XML_SCHEMAV_CVC_MAXLENGTH_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_MININCLUSIVE_VALID", INT2NUM(XML_SCHEMAV_CVC_MININCLUSIVE_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_MAXINCLUSIVE_VALID", INT2NUM(XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_MINEXCLUSIVE_VALID", INT2NUM(XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_MAXEXCLUSIVE_VALID", INT2NUM(XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_TOTALDIGITS_VALID", INT2NUM(XML_SCHEMAV_CVC_TOTALDIGITS_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_FRACTIONDIGITS_VALID", INT2NUM(XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_PATTERN_VALID", INT2NUM(XML_SCHEMAV_CVC_PATTERN_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ENUMERATION_VALID", INT2NUM(XML_SCHEMAV_CVC_ENUMERATION_VALID));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_2_1", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_2_2", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_2_3", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_2_4", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_1", INT2NUM(XML_SCHEMAV_CVC_ELT_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_2", INT2NUM(XML_SCHEMAV_CVC_ELT_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_3_1", INT2NUM(XML_SCHEMAV_CVC_ELT_3_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_3_2_1", INT2NUM(XML_SCHEMAV_CVC_ELT_3_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_3_2_2", INT2NUM(XML_SCHEMAV_CVC_ELT_3_2_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_4_1", INT2NUM(XML_SCHEMAV_CVC_ELT_4_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_4_2", INT2NUM(XML_SCHEMAV_CVC_ELT_4_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_4_3", INT2NUM(XML_SCHEMAV_CVC_ELT_4_3));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_5_1_1", INT2NUM(XML_SCHEMAV_CVC_ELT_5_1_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_5_1_2", INT2NUM(XML_SCHEMAV_CVC_ELT_5_1_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_5_2_1", INT2NUM(XML_SCHEMAV_CVC_ELT_5_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_5_2_2_1", INT2NUM(XML_SCHEMAV_CVC_ELT_5_2_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_5_2_2_2_1", INT2NUM(XML_SCHEMAV_CVC_ELT_5_2_2_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_5_2_2_2_2", INT2NUM(XML_SCHEMAV_CVC_ELT_5_2_2_2_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_6", INT2NUM(XML_SCHEMAV_CVC_ELT_6));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ELT_7",INT2NUM(XML_SCHEMAV_CVC_ELT_7));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ATTRIBUTE_1", INT2NUM(XML_SCHEMAV_CVC_ATTRIBUTE_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ATTRIBUTE_2", INT2NUM(XML_SCHEMAV_CVC_ATTRIBUTE_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ATTRIBUTE_3", INT2NUM(XML_SCHEMAV_CVC_ATTRIBUTE_3));
  rb_define_const(eXMLError, "SCHEMAV_CVC_ATTRIBUTE_4", INT2NUM(XML_SCHEMAV_CVC_ATTRIBUTE_4));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_3_1", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_3_2_1", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_3_2_2", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_4", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_4));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_5_1", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_5_2", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2));
  rb_define_const(eXMLError, "SCHEMAV_ELEMENT_CONTENT", INT2NUM(XML_SCHEMAV_ELEMENT_CONTENT));
  rb_define_const(eXMLError, "SCHEMAV_DOCUMENT_ELEMENT_MISSING", INT2NUM(XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING));
  rb_define_const(eXMLError, "SCHEMAV_CVC_COMPLEX_TYPE_1", INT2NUM(XML_SCHEMAV_CVC_COMPLEX_TYPE_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_AU", INT2NUM(XML_SCHEMAV_CVC_AU));
  rb_define_const(eXMLError, "SCHEMAV_CVC_TYPE_1", INT2NUM(XML_SCHEMAV_CVC_TYPE_1));
  rb_define_const(eXMLError, "SCHEMAV_CVC_TYPE_2", INT2NUM(XML_SCHEMAV_CVC_TYPE_2));
#if LIBXML_VERSION >= 20618
  rb_define_const(eXMLError, "SCHEMAV_CVC_IDC", INT2NUM(XML_SCHEMAV_CVC_IDC));
  rb_define_const(eXMLError, "SCHEMAV_CVC_WILDCARD", INT2NUM(XML_SCHEMAV_CVC_WILDCARD));
#endif
#if LIBXML_VERSION >= 20631
  rb_define_const(eXMLError, "SCHEMAV_MISC", INT2NUM(XML_SCHEMAV_MISC));
#endif
  rb_define_const(eXMLError, "XPTR_UNKNOWN_SCHEME", INT2NUM(XML_XPTR_UNKNOWN_SCHEME));
  rb_define_const(eXMLError, "XPTR_CHILDSEQ_START", INT2NUM(XML_XPTR_CHILDSEQ_START));
  rb_define_const(eXMLError, "XPTR_EVAL_FAILED", INT2NUM(XML_XPTR_EVAL_FAILED));
  rb_define_const(eXMLError, "XPTR_EXTRA_OBJECTS", INT2NUM(XML_XPTR_EXTRA_OBJECTS));
  rb_define_const(eXMLError, "C14N_CREATE_CTXT", INT2NUM(XML_C14N_CREATE_CTXT));
  rb_define_const(eXMLError, "C14N_REQUIRES_UTF8", INT2NUM(XML_C14N_REQUIRES_UTF8));
  rb_define_const(eXMLError, "C14N_CREATE_STACK",
      INT2NUM(XML_C14N_CREATE_STACK));
  rb_define_const(eXMLError, "C14N_INVALID_NODE",
      INT2NUM(XML_C14N_INVALID_NODE));
#if LIBXML_VERSION >= 20619
  rb_define_const(eXMLError, "C14N_UNKNOW_NODE", INT2NUM(XML_C14N_UNKNOW_NODE));
  rb_define_const(eXMLError, "C14N_RELATIVE_NAMESPACE", INT2NUM(XML_C14N_RELATIVE_NAMESPACE));
#endif
  rb_define_const(eXMLError, "FTP_PASV_ANSWER", INT2NUM(XML_FTP_PASV_ANSWER));
  rb_define_const(eXMLError, "FTP_EPSV_ANSWER", INT2NUM(XML_FTP_EPSV_ANSWER));
  rb_define_const(eXMLError, "FTP_ACCNT", INT2NUM(XML_FTP_ACCNT));
#if LIBXML_VERSION >= 20618
  rb_define_const(eXMLError, "FTP_URL_SYNTAX", INT2NUM(XML_FTP_URL_SYNTAX));
#endif
  rb_define_const(eXMLError, "HTTP_URL_SYNTAX", INT2NUM(XML_HTTP_URL_SYNTAX));
  rb_define_const(eXMLError, "HTTP_USE_IP", INT2NUM(XML_HTTP_USE_IP));
  rb_define_const(eXMLError, "HTTP_UNKNOWN_HOST", INT2NUM(XML_HTTP_UNKNOWN_HOST));
  rb_define_const(eXMLError, "SCHEMAP_SRC_SIMPLE_TYPE_1", INT2NUM(XML_SCHEMAP_SRC_SIMPLE_TYPE_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_SIMPLE_TYPE_2", INT2NUM(XML_SCHEMAP_SRC_SIMPLE_TYPE_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_SIMPLE_TYPE_3", INT2NUM(XML_SCHEMAP_SRC_SIMPLE_TYPE_3));
  rb_define_const(eXMLError, "SCHEMAP_SRC_SIMPLE_TYPE_4", INT2NUM(XML_SCHEMAP_SRC_SIMPLE_TYPE_4));
  rb_define_const(eXMLError, "SCHEMAP_SRC_RESOLVE", INT2NUM(XML_SCHEMAP_SRC_RESOLVE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE", INT2NUM(XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE", INT2NUM(XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES", INT2NUM(XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES));
  rb_define_const(eXMLError, "SCHEMAP_ST_PROPS_CORRECT_1", INT2NUM(XML_SCHEMAP_ST_PROPS_CORRECT_1));
  rb_define_const(eXMLError, "SCHEMAP_ST_PROPS_CORRECT_2", INT2NUM(XML_SCHEMAP_ST_PROPS_CORRECT_2));
  rb_define_const(eXMLError, "SCHEMAP_ST_PROPS_CORRECT_3", INT2NUM(XML_SCHEMAP_ST_PROPS_CORRECT_3));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_1_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_1_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_1_2", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_1_2));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_1_3_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_1_3_2", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_1_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_1_2", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_2_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_2_2", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_2_3", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_2_4", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_2_3_2_5", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_1_2", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_2_2", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_2_1", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_2_3", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_2_4", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_RESTRICTS_3_3_2_5", INT2NUM(XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_DERIVED_OK_2_1", INT2NUM(XML_SCHEMAP_COS_ST_DERIVED_OK_2_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_ST_DERIVED_OK_2_2", INT2NUM(XML_SCHEMAP_COS_ST_DERIVED_OK_2_2));
  rb_define_const(eXMLError, "SCHEMAP_S4S_ELEM_NOT_ALLOWED", INT2NUM(XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED));
  rb_define_const(eXMLError, "SCHEMAP_S4S_ELEM_MISSING", INT2NUM(XML_SCHEMAP_S4S_ELEM_MISSING));
  rb_define_const(eXMLError, "SCHEMAP_S4S_ATTR_NOT_ALLOWED", INT2NUM(XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED));
  rb_define_const(eXMLError, "SCHEMAP_S4S_ATTR_MISSING", INT2NUM(XML_SCHEMAP_S4S_ATTR_MISSING));
  rb_define_const(eXMLError, "SCHEMAP_S4S_ATTR_INVALID_VALUE", INT2NUM(XML_SCHEMAP_S4S_ATTR_INVALID_VALUE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ELEMENT_1", INT2NUM(XML_SCHEMAP_SRC_ELEMENT_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ELEMENT_2_1", INT2NUM(XML_SCHEMAP_SRC_ELEMENT_2_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ELEMENT_2_2", INT2NUM(XML_SCHEMAP_SRC_ELEMENT_2_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ELEMENT_3", INT2NUM(XML_SCHEMAP_SRC_ELEMENT_3));
  rb_define_const(eXMLError, "SCHEMAP_P_PROPS_CORRECT_1", INT2NUM(XML_SCHEMAP_P_PROPS_CORRECT_1));
  rb_define_const(eXMLError, "SCHEMAP_P_PROPS_CORRECT_2_1", INT2NUM(XML_SCHEMAP_P_PROPS_CORRECT_2_1));
  rb_define_const(eXMLError, "SCHEMAP_P_PROPS_CORRECT_2_2", INT2NUM(XML_SCHEMAP_P_PROPS_CORRECT_2_2));
  rb_define_const(eXMLError, "SCHEMAP_E_PROPS_CORRECT_2", INT2NUM(XML_SCHEMAP_E_PROPS_CORRECT_2));
  rb_define_const(eXMLError, "SCHEMAP_E_PROPS_CORRECT_3", INT2NUM(XML_SCHEMAP_E_PROPS_CORRECT_3));
  rb_define_const(eXMLError, "SCHEMAP_E_PROPS_CORRECT_4", INT2NUM(XML_SCHEMAP_E_PROPS_CORRECT_4));
  rb_define_const(eXMLError, "SCHEMAP_E_PROPS_CORRECT_5", INT2NUM(XML_SCHEMAP_E_PROPS_CORRECT_5));
  rb_define_const(eXMLError, "SCHEMAP_E_PROPS_CORRECT_6", INT2NUM(XML_SCHEMAP_E_PROPS_CORRECT_6));
  rb_define_const(eXMLError, "SCHEMAP_SRC_INCLUDE", INT2NUM(XML_SCHEMAP_SRC_INCLUDE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_1", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_2", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_3_1", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_3_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_3_2", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_3_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_4", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_4));
  rb_define_const(eXMLError, "SCHEMAP_NO_XMLNS", INT2NUM(XML_SCHEMAP_NO_XMLNS));
  rb_define_const(eXMLError, "SCHEMAP_NO_XSI", INT2NUM(XML_SCHEMAP_NO_XSI));
  rb_define_const(eXMLError, "SCHEMAP_COS_VALID_DEFAULT_1", INT2NUM(XML_SCHEMAP_COS_VALID_DEFAULT_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_VALID_DEFAULT_2_1", INT2NUM(XML_SCHEMAP_COS_VALID_DEFAULT_2_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_VALID_DEFAULT_2_2_1", INT2NUM(XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1));
  rb_define_const(eXMLError, "SCHEMAP_COS_VALID_DEFAULT_2_2_2", INT2NUM(XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2));
  rb_define_const(eXMLError, "SCHEMAP_CVC_SIMPLE_TYPE", INT2NUM(XML_SCHEMAP_CVC_SIMPLE_TYPE));
  rb_define_const(eXMLError, "SCHEMAP_COS_CT_EXTENDS_1_1", INT2NUM(XML_SCHEMAP_COS_CT_EXTENDS_1_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_1_1", INT2NUM(XML_SCHEMAP_SRC_IMPORT_1_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_1_2", INT2NUM(XML_SCHEMAP_SRC_IMPORT_1_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_2", INT2NUM(XML_SCHEMAP_SRC_IMPORT_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_2_1", INT2NUM(XML_SCHEMAP_SRC_IMPORT_2_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT_2_2", INT2NUM(XML_SCHEMAP_SRC_IMPORT_2_2));
  rb_define_const(eXMLError, "SCHEMAP_INTERNAL", INT2NUM(XML_SCHEMAP_INTERNAL));
  rb_define_const(eXMLError, "SCHEMAP_NOT_DETERMINISTIC", INT2NUM(XML_SCHEMAP_NOT_DETERMINISTIC));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_GROUP_1", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_GROUP_2", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_ATTRIBUTE_GROUP_3", INT2NUM(XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3));
  rb_define_const(eXMLError, "SCHEMAP_MG_PROPS_CORRECT_1", INT2NUM(XML_SCHEMAP_MG_PROPS_CORRECT_1));
  rb_define_const(eXMLError, "SCHEMAP_MG_PROPS_CORRECT_2", INT2NUM(XML_SCHEMAP_MG_PROPS_CORRECT_2));
  rb_define_const(eXMLError, "SCHEMAP_SRC_CT_1", INT2NUM(XML_SCHEMAP_SRC_CT_1));
  rb_define_const(eXMLError, "SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3", INT2NUM(XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3));
  rb_define_const(eXMLError, "SCHEMAP_AU_PROPS_CORRECT_2", INT2NUM(XML_SCHEMAP_AU_PROPS_CORRECT_2));
  rb_define_const(eXMLError, "SCHEMAP_A_PROPS_CORRECT_2", INT2NUM(XML_SCHEMAP_A_PROPS_CORRECT_2));
#if LIBXML_VERSION >= 20620
  rb_define_const(eXMLError, "SCHEMAP_C_PROPS_CORRECT", INT2NUM(XML_SCHEMAP_C_PROPS_CORRECT));
#endif
#if LIBXML_VERSION >= 20621
  rb_define_const(eXMLError, "SCHEMAP_SRC_REDEFINE", INT2NUM(XML_SCHEMAP_SRC_REDEFINE));
  rb_define_const(eXMLError, "SCHEMAP_SRC_IMPORT", INT2NUM(XML_SCHEMAP_SRC_IMPORT));
  rb_define_const(eXMLError, "SCHEMAP_WARN_SKIP_SCHEMA", INT2NUM(XML_SCHEMAP_WARN_SKIP_SCHEMA));
  rb_define_const(eXMLError, "SCHEMAP_WARN_UNLOCATED_SCHEMA", INT2NUM(XML_SCHEMAP_WARN_UNLOCATED_SCHEMA));
  rb_define_const(eXMLError, "SCHEMAP_WARN_ATTR_REDECL_PROH", INT2NUM(XML_SCHEMAP_WARN_ATTR_REDECL_PROH));
  rb_define_const(eXMLError, "SCHEMAP_WARN_ATTR_POINTLESS_PROH", INT2NUM(XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH));
#endif
#if LIBXML_VERSION >= 20623
  rb_define_const(eXMLError, "SCHEMAP_AG_PROPS_CORRECT", INT2NUM(XML_SCHEMAP_AG_PROPS_CORRECT));
  rb_define_const(eXMLError, "SCHEMAP_COS_CT_EXTENDS_1_2", INT2NUM(XML_SCHEMAP_COS_CT_EXTENDS_1_2));
  rb_define_const(eXMLError, "SCHEMAP_AU_PROPS_CORRECT", INT2NUM(XML_SCHEMAP_AU_PROPS_CORRECT));
  rb_define_const(eXMLError, "SCHEMAP_A_PROPS_CORRECT_3", INT2NUM(XML_SCHEMAP_A_PROPS_CORRECT_3));
  rb_define_const(eXMLError, "SCHEMAP_COS_ALL_LIMITED", INT2NUM(XML_SCHEMAP_COS_ALL_LIMITED));
#endif
#if LIBXML_VERSION >= 20632
  rb_define_const(eXMLError, "SCHEMATRONV_ASSERT", INT2NUM(XML_SCHEMATRONV_ASSERT));
  rb_define_const(eXMLError, "SCHEMATRONV_REPORT", INT2NUM(XML_SCHEMATRONV_REPORT));
#endif
#if LIBXML_VERSION >= 20618
  rb_define_const(eXMLError, "MODULE_OPEN", INT2NUM(XML_MODULE_OPEN));
  rb_define_const(eXMLError, "MODULE_CLOSE", INT2NUM(XML_MODULE_CLOSE));
#endif
  rb_define_const(eXMLError, "CHECK_FOUND_ELEMENT", INT2NUM(XML_CHECK_FOUND_ELEMENT));
  rb_define_const(eXMLError, "CHECK_FOUND_ATTRIBUTE", INT2NUM(XML_CHECK_FOUND_ATTRIBUTE));
  rb_define_const(eXMLError, "CHECK_FOUND_TEXT", INT2NUM(XML_CHECK_FOUND_TEXT));
  rb_define_const(eXMLError, "CHECK_FOUND_CDATA",INT2NUM(XML_CHECK_FOUND_CDATA));
  rb_define_const(eXMLError, "CHECK_FOUND_ENTITYREF", INT2NUM(XML_CHECK_FOUND_ENTITYREF));
  rb_define_const(eXMLError, "CHECK_FOUND_ENTITY", INT2NUM(XML_CHECK_FOUND_ENTITY));
  rb_define_const(eXMLError, "CHECK_FOUND_PI", INT2NUM(XML_CHECK_FOUND_PI));
  rb_define_const(eXMLError, "CHECK_FOUND_COMMENT", INT2NUM(XML_CHECK_FOUND_COMMENT));
  rb_define_const(eXMLError, "CHECK_FOUND_DOCTYPE", INT2NUM(XML_CHECK_FOUND_DOCTYPE));
  rb_define_const(eXMLError, "CHECK_FOUND_FRAGMENT", INT2NUM(XML_CHECK_FOUND_FRAGMENT));
  rb_define_const(eXMLError, "CHECK_FOUND_NOTATION", INT2NUM(XML_CHECK_FOUND_NOTATION));
  rb_define_const(eXMLError, "CHECK_UNKNOWN_NODE", INT2NUM(XML_CHECK_UNKNOWN_NODE));
  rb_define_const(eXMLError, "CHECK_ENTITY_TYPE", INT2NUM(XML_CHECK_ENTITY_TYPE));
  rb_define_const(eXMLError, "CHECK_NO_PARENT", INT2NUM(XML_CHECK_NO_PARENT));
  rb_define_const(eXMLError, "CHECK_NO_DOC", INT2NUM(XML_CHECK_NO_DOC));
  rb_define_const(eXMLError, "CHECK_NO_NAME", INT2NUM(XML_CHECK_NO_NAME));
  rb_define_const(eXMLError, "CHECK_NO_ELEM", INT2NUM(XML_CHECK_NO_ELEM));
  rb_define_const(eXMLError, "CHECK_WRONG_DOC", INT2NUM(XML_CHECK_WRONG_DOC));
  rb_define_const(eXMLError, "CHECK_NO_PREV", INT2NUM(XML_CHECK_NO_PREV));
  rb_define_const(eXMLError, "CHECK_WRONG_PREV", INT2NUM(XML_CHECK_WRONG_PREV));
  rb_define_const(eXMLError, "CHECK_NO_NEXT", INT2NUM(XML_CHECK_NO_NEXT));
  rb_define_const(eXMLError, "CHECK_WRONG_NEXT", INT2NUM(XML_CHECK_WRONG_NEXT));
  rb_define_const(eXMLError, "CHECK_NOT_DTD", INT2NUM(XML_CHECK_NOT_DTD));
  rb_define_const(eXMLError, "CHECK_NOT_ATTR", INT2NUM(XML_CHECK_NOT_ATTR));
  rb_define_const(eXMLError, "CHECK_NOT_ATTR_DECL", INT2NUM(XML_CHECK_NOT_ATTR_DECL));
  rb_define_const(eXMLError, "CHECK_NOT_ELEM_DECL", INT2NUM(XML_CHECK_NOT_ELEM_DECL));
  rb_define_const(eXMLError, "CHECK_NOT_ENTITY_DECL", INT2NUM(XML_CHECK_NOT_ENTITY_DECL));
  rb_define_const(eXMLError, "CHECK_NOT_NS_DECL", INT2NUM(XML_CHECK_NOT_NS_DECL));
  rb_define_const(eXMLError, "CHECK_NO_HREF", INT2NUM(XML_CHECK_NO_HREF));
  rb_define_const(eXMLError, "CHECK_WRONG_PARENT", INT2NUM(XML_CHECK_WRONG_PARENT));
  rb_define_const(eXMLError, "CHECK_NS_SCOPE", INT2NUM(XML_CHECK_NS_SCOPE));
  rb_define_const(eXMLError, "CHECK_NS_ANCESTOR", INT2NUM(XML_CHECK_NS_ANCESTOR));
  rb_define_const(eXMLError, "CHECK_NOT_UTF8", INT2NUM(XML_CHECK_NOT_UTF8));
  rb_define_const(eXMLError, "CHECK_NO_DICT", INT2NUM(XML_CHECK_NO_DICT));
  rb_define_const(eXMLError, "CHECK_NOT_NCNAME", INT2NUM(XML_CHECK_NOT_NCNAME));
  rb_define_const(eXMLError, "CHECK_OUTSIDE_DICT", INT2NUM(XML_CHECK_OUTSIDE_DICT));
  rb_define_const(eXMLError, "CHECK_WRONG_NAME", INT2NUM(XML_CHECK_WRONG_NAME));
#if LIBXML_VERSION >= 20621
  rb_define_const(eXMLError, "CHECK_NAME_NOT_NULL", INT2NUM(XML_CHECK_NAME_NOT_NULL));
  rb_define_const(eXMLError, "I18N_NO_NAME", INT2NUM(XML_I18N_NO_NAME));
  rb_define_const(eXMLError, "I18N_NO_HANDLER", INT2NUM(XML_I18N_NO_HANDLER));
  rb_define_const(eXMLError, "I18N_EXCESS_HANDLER", INT2NUM(XML_I18N_EXCESS_HANDLER));
  rb_define_const(eXMLError, "I18N_CONV_FAILED", INT2NUM(XML_I18N_CONV_FAILED));
  rb_define_const(eXMLError, "I18N_NO_OUTPUT", INT2NUM(XML_I18N_NO_OUTPUT));
#endif
}
                                                                                                                                                                   ruby_xml_error.h                                                                                    0100644 0001750 0001750 00000000406 12566211276 044415  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_ERROR__
#define __RXML_ERROR__

extern VALUE eXMLError;

void rxml_init_error();
VALUE rxml_error_wrap(xmlErrorPtr xerror);
void rxml_raise(xmlErrorPtr xerror);

#endif
                                                                                                                                                                                                                                                          ruby_xml_html_parser.c                                                                              0100644 0001750 0001750 00000005022 12566211276 045576  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"

/* Document-class: LibXML::XML::HTMLParser
 *
 * The HTML parser implements an HTML 4.0 non-verifying parser with an API
 * compatible with the XML::Parser.  In contrast with the XML::Parser,
 * it can parse "real world" HTML, even if it severely broken from a
 * specification point of view.
 *
 * The HTML parser creates an in-memory document object
 * that consist of any number of XML::Node instances.  This is simple
 * and powerful model, but has the major limitation that the size of
 * the document that can be processed is limited by the amount of
 * memory available.
 *
 * Using the html parser is simple:
 *
 *   parser = XML::HTMLParser.file('my_file')
 *   doc = parser.parse
 *
 * You can also parse documents (see XML::HTMLParser.document), 
 * strings (see XML::HTMLParser.string) and io objects (see
 * XML::HTMLParser.io).
 */

VALUE cXMLHtmlParser;
static ID CONTEXT_ATTR;


/* call-seq:
 *    XML::HTMLParser.initialize -> parser
 *
 * Initializes a new parser instance with no pre-determined source.
 */
static VALUE rxml_html_parser_initialize(int argc, VALUE *argv, VALUE self)
{
  VALUE context = Qnil;

  rb_scan_args(argc, argv, "01", &context);

  if (context == Qnil)
  {
    rb_warn("Passing no parameters to XML::HTMLParser.new is deprecated.  Pass an instance of XML::Parser::Context instead.");
    context = rb_class_new_instance(0, NULL, cXMLParserContext);
  }

  rb_ivar_set(self, CONTEXT_ATTR, context);
  return self;
}

/*
 * call-seq:
 *    parser.parse -> XML::Document
 *
 * Parse the input XML and create an XML::Document with
 * it's content. If an error occurs, XML::Parser::ParseError
 * is thrown.
 */
static VALUE rxml_html_parser_parse(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  VALUE context = rb_ivar_get(self, CONTEXT_ATTR);
  
  Data_Get_Struct(context, xmlParserCtxt, ctxt);

  if (htmlParseDocument(ctxt) == -1 && ! ctxt->recovery)
  {
    if (ctxt->myDoc)
      xmlFreeDoc(ctxt->myDoc);
    rxml_raise(&ctxt->lastError);
  }

  rb_funcall(context, rb_intern("close"), 0);

  return rxml_document_wrap(ctxt->myDoc);
}

void rxml_init_html_parser(void)
{
  CONTEXT_ATTR = rb_intern("@context");

  cXMLHtmlParser = rb_define_class_under(mXML, "HTMLParser", rb_cObject);

  /* Atributes */
  rb_define_attr(cXMLHtmlParser, "input", 1, 0);

  /* Instance methods */
  rb_define_method(cXMLHtmlParser, "initialize", rxml_html_parser_initialize, -1);
  rb_define_method(cXMLHtmlParser, "parse", rxml_html_parser_parse, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ruby_xml_html_parser.h                                                                              0100644 0001750 0001750 00000000321 12566211276 045600  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_HTML_PARSER__
#define __RXML_HTML_PARSER__

extern VALUE cXMLHtmlParser;

void rxml_init_html_parser(void);

#endif
                                                                                                                                                                                                                                                                                                               ruby_xml_html_parser_context.c                                                                      0100644 0001750 0001750 00000023644 12566211276 047354  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_html_parser_context.h"


/*
 * Document-class: LibXML::XML::HTMLParser::Context
 *
 * The XML::HTMLParser::Context class provides in-depth control over how
 * a document is parsed.
 */

VALUE cXMLHtmlParserContext;
static ID IO_ATTR;

/* OS X 10.5 ships with libxml2 version 2.6.16 which does not expose the
   htmlNewParserCtxt (or htmlInitParserCtxt which it uses) method.  htmlNewParserCtxt
   wasn't added to the libxml2 header files until 2.6.27.  So the next two 
   methods are simply copied from a newer version of libxml2 (2.7.2). */
#if LIBXML_VERSION < 20627
#define XML_CTXT_FINISH_DTD_0 0xabcd1234
static int htmlInitParserCtxt(htmlParserCtxtPtr ctxt)
{
  htmlSAXHandler *sax;
  if (ctxt == NULL) return(-1);
  
  memset(ctxt, 0, sizeof(htmlParserCtxt));
  ctxt->dict = xmlDictCreate();
  if (ctxt->dict == NULL) {
    rb_raise(rb_eNoMemError, "htmlInitParserCtxt: out of memory\n");
    return(-1);
  }
  sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));
  if (sax == NULL) {
    rb_raise(rb_eNoMemError, "htmlInitParserCtxt: out of memory\n");
    return(-1);
  }
  else
    memset(sax, 0, sizeof(htmlSAXHandler));

  ctxt->inputTab = (htmlParserInputPtr *) xmlMalloc(5 * sizeof(htmlParserInputPtr));
  if (ctxt->inputTab == NULL) {
    rb_raise(rb_eNoMemError, "htmlInitParserCtxt: out of memory\n");
    ctxt->inputNr = 0;
    ctxt->inputMax = 0;
    ctxt->input = NULL;
    return(-1);
  }
  ctxt->inputNr = 0;
  ctxt->inputMax = 5;
  ctxt->input = NULL;
  ctxt->version = NULL;
  ctxt->encoding = NULL;
  ctxt->standalone = -1;
  ctxt->instate = XML_PARSER_START;

  ctxt->nodeTab = (htmlNodePtr *) xmlMalloc(10 * sizeof(htmlNodePtr));
  if (ctxt->nodeTab == NULL) {
    rb_raise(rb_eNoMemError, "htmlInitParserCtxt: out of memory\n");
    ctxt->nodeNr = 0;
    ctxt->nodeMax = 0;
    ctxt->node = NULL;
    ctxt->inputNr = 0;
    ctxt->inputMax = 0;
    ctxt->input = NULL;
    return(-1);
  }
  ctxt->nodeNr = 0;
  ctxt->nodeMax = 10;
  ctxt->node = NULL;

  ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
  if (ctxt->nameTab == NULL) {
    rb_raise(rb_eNoMemError, "htmlInitParserCtxt: out of memory\n");
    ctxt->nameNr = 0;
    ctxt->nameMax = 10;
    ctxt->name = NULL;
    ctxt->nodeNr = 0;
    ctxt->nodeMax = 0;
    ctxt->node = NULL;
    ctxt->inputNr = 0;
    ctxt->inputMax = 0;
    ctxt->input = NULL;
    return(-1);
  }
  ctxt->nameNr = 0;
  ctxt->nameMax = 10;
  ctxt->name = NULL;
  	
  if (sax == NULL) ctxt->sax = (xmlSAXHandlerPtr) &htmlDefaultSAXHandler;
  else {
    ctxt->sax = sax;
    memcpy(sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));
  }
  ctxt->userData = ctxt;
  ctxt->myDoc = NULL;
  ctxt->wellFormed = 1;
  ctxt->replaceEntities = 0;
  ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ctxt->html = 1;
  ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;
  ctxt->vctxt.userData = ctxt;
  ctxt->vctxt.error = xmlParserValidityError;
  ctxt->vctxt.warning = xmlParserValidityWarning;
  ctxt->record_info = 0;
  ctxt->validate = 0;
  ctxt->nbChars = 0;
  ctxt->checkIndex = 0;
  ctxt->catalogs = NULL;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  return(0);
}

static htmlParserCtxtPtr htmlNewParserCtxt(void)
{
  xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
  if (ctxt == NULL) {
    rb_raise(rb_eNoMemError, "NewParserCtxt: out of memory\n");
    return(NULL);
  }
  memset(ctxt, 0, sizeof(xmlParserCtxt));
  if (htmlInitParserCtxt(ctxt) < 0) {
    htmlFreeParserCtxt(ctxt);
   return(NULL);
  }
  return(ctxt);
}
#endif

static void rxml_html_parser_context_free(htmlParserCtxtPtr ctxt)
{
  htmlFreeParserCtxt(ctxt);
}

static VALUE rxml_html_parser_context_wrap(htmlParserCtxtPtr ctxt)
{
  return Data_Wrap_Struct(cXMLHtmlParserContext, NULL, rxml_html_parser_context_free, ctxt);
}

/* call-seq:
 *    XML::HTMLParser::Context.file(file) -> XML::HTMLParser::Context
 *
 * Creates a new parser context based on the specified file or uri.
 *
 * Parameters:
 *
 *  file - A filename or uri.
*/
static VALUE rxml_html_parser_context_file(VALUE klass, VALUE file)
{
  htmlParserCtxtPtr ctxt = htmlCreateFileParserCtxt(StringValuePtr(file), NULL);
  if (!ctxt)
    rxml_raise(&xmlLastError);

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  htmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  return rxml_html_parser_context_wrap(ctxt);
}

/* call-seq:
 *    XML::HTMLParser::Context.io(io) -> XML::HTMLParser::Context
 *
 * Creates a new parser context based on the specified io object.
 *
 * Parameters:
 *
 *  io - A ruby IO object.
*/
static VALUE rxml_html_parser_context_io(VALUE klass, VALUE io)
{
  VALUE result;
  htmlParserCtxtPtr ctxt;
  xmlParserInputBufferPtr input;
  xmlParserInputPtr stream;

  if (NIL_P(io))
    rb_raise(rb_eTypeError, "Must pass in an IO object");

  input = xmlParserInputBufferCreateIO((xmlInputReadCallback) rxml_read_callback, NULL,
                                     (void*)io, XML_CHAR_ENCODING_NONE);

  ctxt = htmlNewParserCtxt();
  if (!ctxt)
  {
    xmlFreeParserInputBuffer(input);
    rxml_raise(&xmlLastError);
  }

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  htmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

  if (!stream)
  {
    xmlFreeParserInputBuffer(input);
    xmlFreeParserCtxt(ctxt);
    rxml_raise(&xmlLastError);
  }
  inputPush(ctxt, stream);
  result = rxml_html_parser_context_wrap(ctxt);

  /* Attach io object to parser so it won't get freed.*/
  rb_ivar_set(result, IO_ATTR, io);

  return result;
}

/* call-seq:
 *    XML::HTMLParser::Context.string(string) -> XML::HTMLParser::Context
 *
 * Creates a new parser context based on the specified string.
 *
 * Parameters:
 *
 *  string - A string that contains the data to parse.
*/
static VALUE rxml_html_parser_context_string(VALUE klass, VALUE string)
{
  htmlParserCtxtPtr ctxt;
  Check_Type(string, T_STRING);

  if (RSTRING_LEN(string) == 0)
    rb_raise(rb_eArgError, "Must specify a string with one or more characters");

  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(string),
                                   RSTRING_LEN(string));
  if (!ctxt)
    rxml_raise(&xmlLastError);

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  htmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  htmlDefaultSAXHandlerInit();
  if (ctxt->sax != NULL)
    memcpy(ctxt->sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));
  
  return rxml_html_parser_context_wrap(ctxt);
}

/*
 * call-seq:
 *    context.close -> nil
 *
 * Closes the underlying input streams.  This is useful when parsing a large amount of
 * files and you want to close the files without relying on Ruby's garbage collector
 * to run.
 */
static VALUE rxml_html_parser_context_close(VALUE self)
{
  htmlParserCtxtPtr ctxt;
  xmlParserInputPtr xinput;
  Data_Get_Struct(self, htmlParserCtxt, ctxt);

  while ((xinput = inputPop(ctxt)) != NULL)
  {
	 xmlFreeInputStream(xinput);
  }
  return Qnil;
}

/*
 * call-seq:
 *    context.disable_cdata = (true|false)
 *
 * Control whether the CDATA nodes will be created in this context.
 */
static VALUE rxml_html_parser_context_disable_cdata_set(VALUE self, VALUE bool)
{
  htmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, htmlParserCtxt, ctxt);

  if (ctxt->sax == NULL)
    rb_raise(rb_eRuntimeError, "Sax handler is not yet set");

  /* LibXML controls this internally with the default SAX handler. */ 
  if (bool)
    ctxt->sax->cdataBlock = NULL;
  else
    ctxt->sax->cdataBlock = htmlDefaultSAXHandler.cdataBlock;

  return bool;
}

/*
 * call-seq:
 *    context.options = XML::Parser::Options::NOENT |
                        XML::Parser::Options::NOCDATA
 *
 * Provides control over the execution of a parser.  Valid values 
 * are the constants defined on XML::Parser::Options.  Multiple
 * options can be combined by using Bitwise OR (|).
 */
static VALUE rxml_html_parser_context_options_set(VALUE self, VALUE options)
{
  int result;
  int xml_options = NUM2INT(options);
  htmlParserCtxtPtr ctxt;
  Check_Type(options, T_FIXNUM);

  Data_Get_Struct(self, htmlParserCtxt, ctxt);
  result = htmlCtxtUseOptions(ctxt, xml_options);

#if LIBXML_VERSION >= 20707
  /* Big hack here, but htmlCtxtUseOptions doens't support HTML_PARSE_NOIMPLIED.
     So do it ourselves. There must be a better way??? */
  if (xml_options & HTML_PARSE_NOIMPLIED) 
  {
	  ctxt->options |= HTML_PARSE_NOIMPLIED;
  }
#endif

  return self;
}

void rxml_init_html_parser_context(void)
{
  IO_ATTR = ID2SYM(rb_intern("@io"));
  cXMLHtmlParserContext = rb_define_class_under(cXMLHtmlParser, "Context", cXMLParserContext);

  rb_define_singleton_method(cXMLHtmlParserContext, "file", rxml_html_parser_context_file, 1);
  rb_define_singleton_method(cXMLHtmlParserContext, "io", rxml_html_parser_context_io, 1);
  rb_define_singleton_method(cXMLHtmlParserContext, "string", rxml_html_parser_context_string, 1);
  rb_define_method(cXMLHtmlParserContext, "close", rxml_html_parser_context_close, 0);
  rb_define_method(cXMLHtmlParserContext, "disable_cdata=", rxml_html_parser_context_disable_cdata_set, 1);
  rb_define_method(cXMLHtmlParserContext, "options=", rxml_html_parser_context_options_set, 1);
}
                                                                                            ruby_xml_html_parser_context.h                                                                      0100644 0001750 0001750 00000000360 12566211276 047347  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_HTML_PARSER_CONTEXT__
#define __RXML_HTML_PARSER_CONTEXT__

extern VALUE cXMLHtmlParserContext;

void rxml_init_html_parser_context(void);

#endif
                                                                                                                                                                                                                                                                                ruby_xml_html_parser_options.c                                                                      0100644 0001750 0001750 00000003446 12566211276 047361  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"

/* Document-class: LibXML::XML::HTMLParser::Options
 *
 * Options to control the operation of the HTMLParser.  The easiest
 * way to set a parser's options is via the methods
 * XML::HTMLParser.file, XML::HTMLParser.io or XML::HTMLParser.string.
 * For additional control, see XML::HTMLParser::Context#options=.
*/

VALUE mXMLHtmlParserOptions;

void rxml_init_html_parser_options(void)
{
  mXMLHtmlParserOptions = rb_define_module_under(cXMLHtmlParser, "Options");


#if LIBXML_VERSION >= 20621
  /* 1: Relax parsing. */
  rb_define_const(mXMLHtmlParserOptions, "RECOVER", INT2NUM(HTML_PARSE_RECOVER)); 
#endif
#if LIBXML_VERSION >= 20708
  /* 2:  Do not default a doctype if not found */
  rb_define_const(mXMLHtmlParserOptions, "NODEFDTD", INT2NUM(HTML_PARSE_NODEFDTD));
#endif
  /* 32: Suppress error reports. */
  rb_define_const(mXMLHtmlParserOptions, "NOERROR", INT2NUM(HTML_PARSE_NOERROR)); 
  /* 64: Suppress warning reports. */
  rb_define_const(mXMLHtmlParserOptions, "NOWARNING", INT2NUM(HTML_PARSE_NOWARNING));
  /* 128: Enable pedantic error reporting. */
  rb_define_const(mXMLHtmlParserOptions, "PEDANTIC", INT2NUM(HTML_PARSE_PEDANTIC)); 
  /* 256: Remove blank nodes. */
  rb_define_const(mXMLHtmlParserOptions, "NOBLANKS", INT2NUM(HTML_PARSE_NOBLANKS)); 
#if LIBXML_VERSION >= 20621
  /* 2048: Forbid network access. */
  rb_define_const(mXMLHtmlParserOptions, "NONET", INT2NUM(HTML_PARSE_NONET)); 
  /* 65536: Compact small text nodes. */
  rb_define_const(mXMLHtmlParserOptions, "COMPACT", INT2NUM(HTML_PARSE_COMPACT));
#endif
#if LIBXML_VERSION >= 20707
  /* 8192:  Do not add implied html/body... elements */
  rb_define_const(mXMLHtmlParserOptions, "NOIMPLIED", INT2NUM(HTML_PARSE_NOIMPLIED));
#endif
}
                                                                                                                                                                                                                          ruby_xml_html_parser_options.h                                                                      0100644 0001750 0001750 00000000360 12566211276 047356  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_HTML_PARSER_OPTIONS__
#define __RXML_HTML_PARSER_OPTIONS__

extern VALUE mXMLHtmlParserOptions;

void rxml_init_html_parser_options(void);

#endif
                                                                                                                                                                                                                                                                                ruby_xml_input_cbg.c                                                                                0100644 0001750 0001750 00000010251 12566211276 045230  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Author: Martin Povolny (xpovolny@fi.muni.cz) */

#include "ruby_libxml.h"
#include "ruby_xml_input_cbg.h"

/* Document-class: LibXML::XML::InputCallbacks
 *
 * Support for adding custom scheme handlers. */

static ic_scheme *first_scheme = 0;

int ic_match(char const *filename)
{
  ic_scheme *scheme;

  //fprintf( stderr, "ic_match: %s\n", filename );

  scheme = first_scheme;
  while (0 != scheme)
  {
    if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST scheme->scheme_name, scheme->name_len))
    {
      return 1;
    }
    scheme = scheme->next_scheme;
  }
  return 0;
}

void* ic_open(char const *filename)
{
  ic_doc_context *ic_doc;
  ic_scheme *scheme;
  VALUE res;

  scheme = first_scheme;
  while (0 != scheme)
  {
    if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST scheme->scheme_name, scheme->name_len))
    {
      ic_doc = (ic_doc_context*) malloc(sizeof(ic_doc_context));

      res = rb_funcall(scheme->class, rb_intern("document_query"), 1,
          rb_str_new2(filename));

      ic_doc->buffer = strdup(StringValuePtr(res));

      ic_doc->bpos = ic_doc->buffer;
      ic_doc->remaining = strlen(ic_doc->buffer);
      return ic_doc;
    }
    scheme = scheme->next_scheme;
  }
  return 0;
}

int ic_read(void *context, char *buffer, int len)
{
  ic_doc_context *ic_doc;
  int ret_len;
  ic_doc = (ic_doc_context*) context;

  if (len >= ic_doc->remaining)
  {
    ret_len = ic_doc->remaining;
  }
  else
  {
    ret_len = len;
  }
  ic_doc->remaining -= ret_len;
  strncpy(buffer, ic_doc->bpos, ret_len);
  ic_doc->bpos += ret_len;

  return ret_len;
}

int ic_close(void *context)
{
  ruby_xfree(((ic_doc_context*) context)->buffer);
  ruby_xfree(context);
  return 1;
}

/*
 * call-seq:
 *    register
 *
 * Register a new set of I/O callback for handling parser input.
 */
static VALUE input_callbacks_register_input_callbacks()
{
  xmlRegisterInputCallbacks(ic_match, ic_open, ic_read, ic_close);
  return (Qtrue);
}

/*
 * call-seq:
 *    add_scheme
 *
 * No documentation available.
 */
static VALUE input_callbacks_add_scheme(VALUE self, VALUE scheme_name,
    VALUE class)
{
  ic_scheme *scheme;

  Check_Type(scheme_name, T_STRING);

  scheme = (ic_scheme*) malloc(sizeof(ic_scheme));
  scheme->next_scheme = 0;
  scheme->scheme_name = strdup(StringValuePtr(scheme_name)); /* TODO alloc, dealloc */
  scheme->name_len = strlen(scheme->scheme_name);
  scheme->class = class; /* TODO alloc, dealloc */

  //fprintf( stderr, "registered: %s, %d, %s\n", scheme->scheme_name, scheme->name_len, scheme->class );

  if (0 == first_scheme)
    first_scheme = scheme;
  else
  {
    ic_scheme *pos;
    pos = first_scheme;
    while (0 != pos->next_scheme)
      pos = pos->next_scheme;
    pos->next_scheme = scheme;
  }

  return (Qtrue);
}

/*
 * call-seq:
 *    remove_scheme
 *
 * No documentation available.
 */
static VALUE input_callbacks_remove_scheme(VALUE self, VALUE scheme_name)
{
  char *name;
  ic_scheme *save_scheme, *scheme;

  Check_Type(scheme_name, T_STRING);
  name = StringValuePtr(scheme_name);

  if (0 == first_scheme)
    return Qfalse;

  if (!strncmp(name, first_scheme->scheme_name, first_scheme->name_len))
  {
    save_scheme = first_scheme->next_scheme;

    ruby_xfree(first_scheme->scheme_name);
    ruby_xfree(first_scheme);

    first_scheme = save_scheme;
    return Qtrue;
  }

  scheme = first_scheme;
  while (0 != scheme->next_scheme)
  {
    if (!strncmp(name, scheme->next_scheme->scheme_name,
        scheme->next_scheme->name_len))
    {
      save_scheme = scheme->next_scheme->next_scheme;

      ruby_xfree(scheme->next_scheme->scheme_name);
      ruby_xfree(scheme->next_scheme);

      scheme->next_scheme = save_scheme;
      return Qtrue;
    }
    scheme = scheme->next_scheme;
  }
  return Qfalse;
}

void rxml_init_input_callbacks(void)
{
  VALUE cInputCallbacks;
  cInputCallbacks = rb_define_class_under(mXML, "InputCallbacks", rb_cObject);

  /* Class Methods */
  rb_define_singleton_method(cInputCallbacks, "register",
      input_callbacks_register_input_callbacks, 0);
  rb_define_singleton_method(cInputCallbacks, "add_scheme",
      input_callbacks_add_scheme, 2);
  rb_define_singleton_method(cInputCallbacks, "remove_scheme",
      input_callbacks_remove_scheme, 1);
}
                                                                                                                                                                                                                                                                                                                                                       ruby_xml_input_cbg.h                                                                                0100644 0001750 0001750 00000000506 12566211276 045237  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef _INPUT_CBG_
#define _INPUT_CBG_

void rxml_init_input_callbacks(void);

typedef struct ic_doc_context {
    char *buffer;
    char *bpos;
    int remaining;
} ic_doc_context;

typedef struct ic_scheme {
    char *scheme_name;
    VALUE class;
    int name_len;

    struct ic_scheme *next_scheme;
} ic_scheme;

#endif
                                                                                                                                                                                          ruby_xml_io.c                                                                                       0100644 0001750 0001750 00000002314 12566211276 043666  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "extconf.h"
#include "ruby_libxml.h"

static ID READ_METHOD;
#ifndef HAVE_RB_IO_BUFWRITE
static ID WRITE_METHOD;
#endif /* !HAVE_RB_IO_BUFWRITE */

/* This method is called by libxml when it wants to read
 more data from a stream. We go with the duck typing
 solution to support StringIO objects. */
int rxml_read_callback(void *context, char *buffer, int len)
{
  VALUE io = (VALUE) context;
  VALUE string = rb_funcall(io, READ_METHOD, 1, INT2NUM(len));
  int size;

  if (string == Qnil)
    return 0;

  size = RSTRING_LEN(string);
  memcpy(buffer, StringValuePtr(string), size);

  return size;
}

int rxml_write_callback(void *context, const char *buffer, int len)
{
#ifndef HAVE_RB_IO_BUFWRITE
  VALUE io, written, string;

  io = (VALUE) context;
  string = rb_str_new(buffer, len);
  written = rb_funcall(io, WRITE_METHOD, 1, string);

  return NUM2INT(written);
#else
  return rb_io_bufwrite((VALUE) context, buffer, (size_t) len);
#endif /* !HAVE_RB_IO_BUFWRITE */
}

void rxml_init_io(void)
{
  READ_METHOD = rb_intern("read");
#ifndef HAVE_RB_IO_BUFWRITE
  WRITE_METHOD = rb_intern("write");
#endif /* !HAVE_RB_IO_BUFWRITE */
}
                                                                                                                                                                                                                                                                                                                    ruby_xml_io.h                                                                                       0100644 0001750 0001750 00000000433 12566211276 043673  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_IO__
#define __RXML_IO__

int rxml_read_callback(void *context, char *buffer, int len);
int rxml_write_callback(void *context, const char *buffer, int len);
void rxml_init_io(void);

#endif
                                                                                                                                                                                                                                     ruby_xml_namespace.c                                                                                0100644 0001750 0001750 00000010235 12566211276 045214  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_namespace.h"

VALUE cXMLNamespace;

/* Document-class: LibXML::XML::Namespace
 *
 * The Namespace class represents an XML namespace.
 * To add a namespace to a node, create a new instance
 * of this class.  Note that this does *not* assign the
 * node to the namespace. To do that see the 
 * XML::Namespaces#namespace method.
 *
 * Usage:
 *
 *   node = XML::Node.new('<Envelope>')
 *   XML::Namespace.new(node, 'soap', 'http://schemas.xmlsoap.org/soap/envelope/')
 *   assert_equal("<Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"/>", node.to_s)
 *   assert_nil(node.namespaces.namespace)
 */

/* Namespaces are owned and freed by their nodes.  Thus, its easier for the
   ruby bindings to not manage attribute memory management. */

static VALUE rxml_namespace_alloc(VALUE klass)
{
  return Data_Wrap_Struct(klass, NULL, NULL, NULL);
}

VALUE rxml_namespace_wrap(xmlNsPtr xns)
{
  return Data_Wrap_Struct(cXMLNamespace, NULL, NULL, xns);
}


/*
 * call-seq:
 *    initialize(node, "prefix", "href") -> XML::Namespace
 *
 * Create a new namespace and adds it to the specified node.
 * Note this does *not* assign the node to the namespace.
 * To do that see the XML::Namespaces#namespace method.
 */
static VALUE rxml_namespace_initialize(VALUE self, VALUE node, VALUE prefix,
    VALUE href)
{
  xmlNodePtr xnode;
  xmlChar *xmlPrefix;
  xmlNsPtr xns;

  Check_Type(node, T_DATA);
  Data_Get_Struct(node, xmlNode, xnode);

  /* Prefix can be null - that means its the default namespace */
  xmlPrefix = NIL_P(prefix) ? NULL : (xmlChar *)StringValuePtr(prefix);
  xns = xmlNewNs(xnode, (xmlChar*) StringValuePtr(href), xmlPrefix);

  if (!xns)
    rxml_raise(&xmlLastError);

  DATA_PTR(self) = xns;
  return self;
}

/*
 * call-seq:
 *    ns.href -> "href"
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   ns = doc.root.namespaces.find_by_href('http://schemas.xmlsoap.org/soap/envelope/')
 *   assert_equal('http://schemas.xmlsoap.org/soap/envelope/', ns.href)
 */
static VALUE rxml_namespace_href_get(VALUE self)
{
  xmlNsPtr xns;
  Data_Get_Struct(self, xmlNs, xns);
  if (xns->href == NULL)
    return Qnil;
  else
    return rxml_new_cstr((const char*) xns->href, NULL);
}

/*
 * call-seq:
 *    ns.node_type -> num
 *
 * Obtain this namespace's type identifier.
 */
static VALUE rxml_namespace_node_type(VALUE self)
{
  xmlNsPtr xns;
  Data_Get_Struct(self, xmlNs, xns);
  return INT2NUM(xns->type);
}

/*
 * call-seq:
 *    ns.prefix -> "prefix"
 *
 * Obtain the namespace's prefix.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   ns = doc.root.namespaces.find_by_href('http://schemas.xmlsoap.org/soap/envelope/')
 *   assert_equal('soap', ns.prefix)
 */
static VALUE rxml_namespace_prefix_get(VALUE self)
{
  xmlNsPtr xns;
  Data_Get_Struct(self, xmlNs, xns);
  if (xns->prefix == NULL)
    return Qnil;
  else
    return rxml_new_cstr((const char*) xns->prefix, NULL);
}

/*
 * call-seq:
 *    ns.next -> XML::Namespace
 *
 * Obtain the next namespace.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   ns = doc.root.namespaces.find_by_href('http://schemas.xmlsoap.org/soap/envelope/')
 *   assert_nil(ns.next)
 */
static VALUE rxml_namespace_next(VALUE self)
{
  xmlNsPtr xns;
  Data_Get_Struct(self, xmlNs, xns);
  if (xns == NULL || xns->next == NULL)
    return (Qnil);
  else
    return rxml_namespace_wrap(xns->next);
}

void rxml_init_namespace(void)
{
  cXMLNamespace = rb_define_class_under(mXML, "Namespace", rb_cObject);
  rb_define_alloc_func(cXMLNamespace, rxml_namespace_alloc);
  rb_define_method(cXMLNamespace, "initialize", rxml_namespace_initialize, 3);
  rb_define_method(cXMLNamespace, "href", rxml_namespace_href_get, 0);
  rb_define_method(cXMLNamespace, "next", rxml_namespace_next, 0);
  rb_define_method(cXMLNamespace, "node_type", rxml_namespace_node_type, 0);
  rb_define_method(cXMLNamespace, "prefix", rxml_namespace_prefix_get, 0);
}
                                                                                                                                                                                                                                                                                                                                                                   ruby_xml_namespace.h                                                                                0100644 0001750 0001750 00000000362 12566211276 045221  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_NAMESPACE__
#define __RXML_NAMESPACE__

extern VALUE cXMLNamespace;

void rxml_init_namespace(void);
VALUE rxml_namespace_wrap(xmlNsPtr xns);
#endif
                                                                                                                                                                                                                                                                              ruby_xml_namespaces.c                                                                               0100644 0001750 0001750 00000017453 12566211276 045410  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_namespaces.h"

VALUE cXMLNamespaces;

/* Document-class: LibXML::XML::Namespaces
 *
 * The XML::Namespaces class is used to access information about
 * a node's namespaces.  For each node, libxml maintains:
 *
 * * The node's namespace (#namespace)
 * * Which namespaces are defined on the node (#definnitions)
 * * Which namespaces are in scope for the node (#each)
 *
 * Let's look at an example:
 *
 *   <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
 *                  xmlns:xsd="http://www.w3.org/2001/XMLSchema">
 *     <soap:Body>
 *       <order xmlns="http://mynamespace.com"/>
 *     </soap:Body>
 *   </soap>
 *
 * The Envelope node is in the soap namespace.  It contains
 * two namespace definitions, one for soap and one for xsd.
 * 
 * The Body node is also in the soap namespace and does not
 * contain any namespaces.  However, the soap and xsd namespaces
 * are both in context.
 *
 * The order node is in its default namespace and contains
 * one namespace definition (http://mynamespace.com).  There
 * are three namespaces in context soap, xsd and the 
 * default namespace.
*/

static VALUE rxml_namespaces_alloc(VALUE klass)
{
  return Data_Wrap_Struct(klass, NULL, NULL, NULL);
}

/*
 * call-seq:
 *    initialize(XML::Node) -> XML::Namespaces
 *
 * Creates a new namespaces object.  Generally you
 * do not call this method directly, but instead
 * access a namespaces object via XML::Node#namespaces.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   namespaces = new XML::Namespaces(doc.root)
 */
static VALUE rxml_namespaces_initialize(VALUE self, VALUE node)
{
  xmlNodePtr xnode;

  Check_Type(node, T_DATA);
  Data_Get_Struct(node, xmlNode, xnode);

  DATA_PTR(self) = xnode;
  return self;
}

/*
 * call-seq:
 *    namespaces.definitions -> [XML::Namespace, XML::Namespace]
 *
 * Returns an array of XML::Namespace objects that are 
 * defined on this node.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   defs = doc.root.namespaces.definitions
 */
static VALUE rxml_namespaces_definitions(VALUE self)
{
  xmlNodePtr xnode;
  xmlNsPtr xns;
  VALUE arr;

  Data_Get_Struct(self, xmlNode, xnode);

  arr = rb_ary_new();
  xns = xnode->nsDef;

  while (xns)
  {
    VALUE anamespace = rxml_namespace_wrap(xns);
    rb_ary_push(arr, anamespace);
    xns = xns->next;
  }

  return arr;
}

/*
 * call-seq:
 *    namespaces.each {|XML::Namespace|}
 *
 * Iterates over the namespace objects that are
 * in context for this node.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   doc.root.namespaces.each do |ns|
 *     ..
 *   end
 */
static VALUE rxml_namespaces_each(VALUE self)
{
  xmlNodePtr xnode;
  xmlNsPtr *nsList, *xns;

  Data_Get_Struct(self, xmlNode, xnode);

  nsList = xmlGetNsList(xnode->doc, xnode);

  if (nsList == NULL)
    return (Qnil);

  for (xns = nsList; *xns != NULL; xns++)
  {
    VALUE ns = rxml_namespace_wrap(*xns);
    rb_yield(ns);
  }
  xmlFree(nsList);

  return Qnil;
}

/*
 * call-seq:
 *    namespaces.find_by_href(href) -> XML::Namespace
 *
 * Searches for a namespace that has the specified href.
 * The search starts at the current node and works upward
 * through the node's parents.  If a namespace is found,
 * then an XML::Namespace instance is returned, otherwise nil
 * is returned.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   ns = doc.root.namespaces.find_by_href('http://schemas.xmlsoap.org/soap/envelope/')
 *   assert_equal('soap', ns.prefix)
 *   assert_equal('http://schemas.xmlsoap.org/soap/envelope/', ns.href)
 */
static VALUE rxml_namespaces_find_by_href(VALUE self, VALUE href)
{
  xmlNodePtr xnode;
  xmlNsPtr xns;

  Check_Type(href, T_STRING);
  Data_Get_Struct(self, xmlNode, xnode);

  xns = xmlSearchNsByHref(xnode->doc, xnode, (xmlChar*) StringValuePtr(href));
  if (xns)
    return rxml_namespace_wrap(xns);
  else
    return Qnil;
}

/*
 * call-seq:
 *    namespaces.find_by_prefix(prefix=nil) -> XML::Namespace
 *
 * Searches for a namespace that has the specified prefix.
 * The search starts at the current node and works upward
 * through the node's parents.  If a namespace is found,
 * then an XML::Namespace instance is returned, otherwise nil
 * is returned.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   ns = doc.root.namespaces.find_by_prefix('soap')
 *   assert_equal('soap', ns.prefix)
 *   assert_equal('http://schemas.xmlsoap.org/soap/envelope/', ns.href)
 */
static VALUE rxml_namespaces_find_by_prefix(VALUE self, VALUE prefix)
{
  xmlNodePtr xnode;
  xmlNsPtr xns;
  xmlChar* xprefix = NULL;

  
  if (!NIL_P(prefix))
  {
    Check_Type(prefix, T_STRING);
    xprefix = (xmlChar*) StringValuePtr(prefix);
  }

  Data_Get_Struct(self, xmlNode, xnode);
  
  xns = xmlSearchNs(xnode->doc, xnode, xprefix);
  if (xns)
    return rxml_namespace_wrap(xns);
  else
    return Qnil;
}

/*
 * call-seq:
 *    namespaces.namespace -> XML::Namespace
 *
 * Returns the current node's namespace.
 *
 * Usage:
 *
 *   doc = XML::Document.string('<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"/>')
 *   ns = doc.root.namespaces.namespace
 *   assert_equal('soap', ns.prefix)
 *   assert_equal('http://schemas.xmlsoap.org/soap/envelope/', ns.href)
 */
static VALUE rxml_namespaces_namespace_get(VALUE self)
{
  xmlNodePtr xnode;
  Data_Get_Struct(self, xmlNode, xnode);

  if (xnode->ns)
    return rxml_namespace_wrap(xnode->ns);
  else
    return Qnil;
}

/*
 * call-seq:
 *    namespaces.namespace = XML::Namespace
 *
 * Sets the current node's namespace.  
 *
 * Basic usage:
 *
 *   # Create a node
 *   node = XML::Node.new('Envelope')
 *   
 *   # Define the soap namespace - this does *not* put the node in the namespace
 *   ns = XML::Namespace.new(node, 'soap', 'http://schemas.xmlsoap.org/soap/envelope/')
 *   assert_equal("<Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"/>", node.to_s)
 *
 *   # Now put the node in the soap namespace, not how the string representation changes
 *   node.namespaces.namespace = ns
 *   assert_equal("<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"/>", node.to_s)
 */
static VALUE rxml_namespaces_namespace_set(VALUE self, VALUE ns)
{
  xmlNodePtr xnode;
  xmlNsPtr xns;

  Data_Get_Struct(self, xmlNode, xnode);

  Check_Type(ns, T_DATA);
  Data_Get_Struct(ns, xmlNs, xns);

  xmlSetNs(xnode, xns);
  return self;
}

/*
 * call-seq:
 *    namespaces.node -> XML::Node
 *
 * Returns the current node.
 */
static VALUE rxml_namespaces_node_get(VALUE self)
{
  xmlNodePtr xnode;
  Data_Get_Struct(self, xmlNode, xnode);
  return rxml_node_wrap(xnode);
}

void rxml_init_namespaces(void)
{
  cXMLNamespaces = rb_define_class_under(mXML, "Namespaces", rb_cObject);
  rb_include_module(cXMLNamespaces, rb_mEnumerable);

  rb_define_alloc_func(cXMLNamespaces, rxml_namespaces_alloc);
  rb_define_method(cXMLNamespaces, "initialize", rxml_namespaces_initialize, 1);

  rb_define_method(cXMLNamespaces, "definitions", rxml_namespaces_definitions, 0);
  rb_define_method(cXMLNamespaces, "each", rxml_namespaces_each, 0);
  rb_define_method(cXMLNamespaces, "find_by_href", rxml_namespaces_find_by_href, 1);
  rb_define_method(cXMLNamespaces, "find_by_prefix", rxml_namespaces_find_by_prefix, 1);
  rb_define_method(cXMLNamespaces, "namespace", rxml_namespaces_namespace_get, 0);
  rb_define_method(cXMLNamespaces, "namespace=", rxml_namespaces_namespace_set, 1);
  rb_define_method(cXMLNamespaces, "node", rxml_namespaces_node_get, 0);
}
                                                                                                                                                                                                                     ruby_xml_namespaces.h                                                                               0100644 0001750 0001750 00000000315 12566211276 045402  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_NAMESPACES__
#define __RXML_NAMESPACES__

extern VALUE cXMLNamespaces;

void rxml_init_namespaces(void);
#endif
                                                                                                                                                                                                                                                                                                                   ruby_xml_node.c                                                                                     0100644 0001750 0001750 00000110602 12566211276 044204  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_node.h"
#include <assert.h>

VALUE cXMLNode;

/* Document-class: LibXML::XML::Node
 *
 * Nodes are the primary objects that make up an XML document.
 * The node class represents most node types that are found in
 * an XML document (but not LibXML::XML::Attributes, see LibXML::XML::Attr).
 * It exposes libxml's full API for creating, querying
 * moving and deleting node objects.  Many of these methods are
 * documented in the DOM Level 3 specification found at:
 * http://www.w3.org/TR/DOM-Level-3-Core/. */


/* Memory management:
 *
 * The bindings create a one-to-one mapping between libxml nodes
 * and Ruby nodes.  If a libxml node is wraped, its _private member
 * is set with a reference to the Ruby object.
 *
 * When a libxml document or top level node is freed, it will free
 * all its children.  Thus Ruby is responsible for:
 *
 *  * Using the mark function to keep alive any documents Ruby is
 *    referencing via the document or child nodes.
 *  * Using the mark function to keep alive any top level, free
 *    standing nodes Ruby is referencing via the node or its children.
 *
 * In general use, this will cause Ruby nodes to be freed before
 * a libxml document.  When a Ruby node is freed, the _private
 * field is set back to null.  
 *
 * In the sweep phase in Ruby 1.9.*, the document tends to be
 * freed before the nodes.  To support this, the bindings register
 * a callback function with libxml that is called each time a node
 * is freed.  In that case, the data_ptr is set to null, so the bindings
 * can recognize the situation.
 */

static void rxml_node_deregisterNode(xmlNodePtr xnode)
{
  /* Has the node been wrapped and exposed to Ruby? */
  if (xnode->_private)
  {
    /* Node was wrapped.  Set the _private member to free and
      then dislabe the dfree function so that Ruby will not
      try to free the node a second time. */
    VALUE node = (VALUE) xnode->_private;
    RDATA(node)->data = NULL;
    RDATA(node)->dfree = NULL;
    RDATA(node)->dmark = NULL;
  }
}

static void rxml_node_free(xmlNodePtr xnode)
{
  /* Either the node has been created yet in initialize
     or it has been freed by libxml already in Ruby's 
     mark phase. */
  if (xnode == NULL)
    return;

  /* The ruby object wrapping the xml object no longer exists. */
  xnode->_private = NULL;

  /* Ruby is responsible for freeing this node if it does not
     have a parent and is not owned by a document.  Note a corner
     case here - calling node2 = doc.import(node1) will cause node2
     to not have a parent but to have a document. */
  if (xnode->parent == NULL)
  {
    xmlFreeNode(xnode);
  }
}

 void rxml_node_mark(xmlNodePtr xnode)
{
  /* Either the node has not been created yet in initialize
     or it has been freed by libxml already in Ruby's 
     mark phase. */
  if (xnode == NULL)
    return;

  if (xnode->doc && xnode->doc->_private)
    rb_gc_mark((VALUE) xnode->doc->_private);
  
  if (xnode->parent && xnode->parent->_private)
    rb_gc_mark((VALUE) xnode->_private);
}

VALUE rxml_node_wrap(xmlNodePtr xnode)
{
  VALUE result;

  /* Is the node already wrapped? */
  if (xnode->_private != NULL)
  {
    result = (VALUE) xnode->_private;
  }
  else
  {
    result = Data_Wrap_Struct(cXMLNode, rxml_node_mark, rxml_node_free, xnode);
    xnode->_private = (void*) result;
  }
  return result;
}

static VALUE rxml_node_alloc(VALUE klass)
{
  /* Ruby is responsible for freeing this node not libxml but don't set
     up mark and free yet until we assign the node. */
  return Data_Wrap_Struct(klass, rxml_node_mark, rxml_node_free, NULL);
}

static xmlNodePtr rxml_get_xnode(VALUE node)
{
   xmlNodePtr result;
   Data_Get_Struct(node, xmlNode, result);

   if (!result)
    rb_raise(rb_eRuntimeError, "This node has already been freed.");

   return result;
}

/*
 * call-seq:
 *    XML::Node.new_cdata(content = nil) -> XML::Node
 *
 * Create a new #CDATA node, optionally setting
 * the node's content.
 */
static VALUE rxml_node_new_cdata(int argc, VALUE *argv, VALUE klass)
{
  VALUE content = Qnil;
  xmlNodePtr xnode;

  rb_scan_args(argc, argv, "01", &content);

  if (NIL_P(content))
  {
    xnode = xmlNewCDataBlock(NULL, NULL, 0);
  }
  else
  {
    content = rb_obj_as_string(content);
    xnode = xmlNewCDataBlock(NULL, (xmlChar*) StringValuePtr(content),
        RSTRING_LEN(content));
  }

  if (xnode == NULL)
    rxml_raise(&xmlLastError);

  return rxml_node_wrap(xnode);
}

/*
 * call-seq:
 *    XML::Node.new_comment(content = nil) -> XML::Node
 *
 * Create a new comment node, optionally setting
 * the node's content.
 *
 */
static VALUE rxml_node_new_comment(int argc, VALUE *argv, VALUE klass)
{
  VALUE content = Qnil;
  xmlNodePtr xnode;

  rb_scan_args(argc, argv, "01", &content);

  if (NIL_P(content))
  {
    xnode = xmlNewComment(NULL);
  }
  else
  {
    content = rb_obj_as_string(content);
    xnode = xmlNewComment((xmlChar*) StringValueCStr(content));
  }

  if (xnode == NULL)
    rxml_raise(&xmlLastError);

  return rxml_node_wrap(xnode);
}

/*
 * call-seq:
 *    XML::Node.new_pi(name, content = nil) -> XML::Node
 *
 * Create a new pi node, optionally setting
 * the node's content.
 *
 */
static VALUE rxml_node_new_pi(int argc, VALUE *argv, VALUE klass)
{
  VALUE name = Qnil;
  VALUE content = Qnil;
  xmlNodePtr xnode;

  rb_scan_args(argc, argv, "11", &name, &content);

  if (NIL_P(name))
  {
    rb_raise(rb_eRuntimeError, "You must provide me with a name for a PI.");
  }
  name = rb_obj_as_string(name);
  if (NIL_P(content))
  {
    xnode = xmlNewPI((xmlChar*) StringValuePtr(name), NULL);
  }
  else
  {
    content = rb_obj_as_string(content);
    xnode = xmlNewPI((xmlChar*) StringValuePtr(name), (xmlChar*) StringValueCStr(content));
  }

  if (xnode == NULL)
    rxml_raise(&xmlLastError);

  return rxml_node_wrap(xnode);
}

/*
 * call-seq:
 *    XML::Node.new_text(content) -> XML::Node
 *
 * Create a new text node.
 *
 */
static VALUE rxml_node_new_text(VALUE klass, VALUE content)
{
  xmlNodePtr xnode;
  Check_Type(content, T_STRING);
  content = rb_obj_as_string(content);

  xnode = xmlNewText((xmlChar*) StringValueCStr(content));

  if (xnode == NULL)
    rxml_raise(&xmlLastError);

  return rxml_node_wrap(xnode);
}

static VALUE rxml_node_content_set(VALUE self, VALUE content);

/*
 * call-seq:
 *    XML::Node.initialize(name, content = nil, namespace = nil) -> XML::Node
 *
 * Creates a new element with the specified name, content and
 * namespace. The content and namespace may be nil.
 */
static VALUE rxml_node_initialize(int argc, VALUE *argv, VALUE self)
{
  VALUE name;
  VALUE content;
  VALUE ns;
  xmlNodePtr xnode = NULL;
  xmlNsPtr xns = NULL;

  rb_scan_args(argc, argv, "12", &name, &content, &ns);

  name = rb_obj_as_string(name);

  if (!NIL_P(ns))
    Data_Get_Struct(ns, xmlNs, xns);

  xnode = xmlNewNode(xns, (xmlChar*) StringValuePtr(name));

  if (xnode == NULL)
    rxml_raise(&xmlLastError);

  /* Link the Ruby object to the libxml object and vice-versa. */
  xnode->_private = (void*) self;
  DATA_PTR(self) = xnode;

  if (!NIL_P(content))
    rxml_node_content_set(self, content);

  return self;
}

static VALUE rxml_node_modify_dom(VALUE self, VALUE target,
                                  xmlNodePtr (*xmlFunc)(xmlNodePtr, xmlNodePtr))
{
  xmlNodePtr xnode, xtarget, xresult;

  if (rb_obj_is_kind_of(target, cXMLNode) == Qfalse)
    rb_raise(rb_eTypeError, "Must pass an XML::Node object");

  xnode = rxml_get_xnode(self);
  xtarget = rxml_get_xnode(target);

  if (xtarget->doc != NULL && xtarget->doc != xnode->doc)
    rb_raise(eXMLError, "Nodes belong to different documents.  You must first import the node by calling XML::Document.import");

  xmlUnlinkNode(xtarget);

  /* This target node could be freed here. */  
  xresult = xmlFunc(xnode, xtarget);

  if (!xresult)
    rxml_raise(&xmlLastError);

  /* Was the target freed? If yes, then wrap the new node */
  if (xresult != xtarget)
  {
    RDATA(target)->data = xresult;
    xresult->_private = (void*) target;
  }

  return target;
}

/*
 * call-seq:
 *    node.base_uri -> "uri"
 *
 * Obtain this node's base URI.
 */
static VALUE rxml_node_base_uri_get(VALUE self)
{
  xmlNodePtr xnode;
  xmlChar* base_uri;
  VALUE result = Qnil;

  xnode = rxml_get_xnode(self);

  if (xnode->doc == NULL)
    return (result);

  base_uri = xmlNodeGetBase(xnode->doc, xnode);
  if (base_uri)
  {
    result = rxml_new_cstr((const char*) base_uri, NULL);
    xmlFree(base_uri);
  }

  return (result);
}

// TODO node_base_set should support setting back to nil

/*
 * call-seq:
 *    node.base_uri = "uri"
 *
 * Set this node's base URI.
 */
static VALUE rxml_node_base_uri_set(VALUE self, VALUE uri)
{
  xmlNodePtr xnode;

  Check_Type(uri, T_STRING);
  xnode = rxml_get_xnode(self);
  if (xnode->doc == NULL)
    return (Qnil);

  xmlNodeSetBase(xnode, (xmlChar*) StringValuePtr(uri));
  return (Qtrue);
}

/*
 * call-seq:
 *    node.content -> "string"
 *
 * Obtain this node's content as a string.
 */
static VALUE rxml_node_content_get(VALUE self)
{
  xmlNodePtr xnode;
  xmlChar *content;
  VALUE result = Qnil;

  xnode = rxml_get_xnode(self);
  content = xmlNodeGetContent(xnode);
  if (content)
  {
    result = rxml_new_cstr((const char *) content, NULL);
    xmlFree(content);
  }

  return result;
}

/*
 * call-seq:
 *    node.content = "string"
 *
 * Set this node's content to the specified string.
 */
static VALUE rxml_node_content_set(VALUE self, VALUE content)
{
  xmlNodePtr xnode;
  xmlChar* encoded_content;

  Check_Type(content, T_STRING);
  xnode = rxml_get_xnode(self);
  encoded_content = xmlEncodeSpecialChars(xnode->doc, (xmlChar*) StringValuePtr(content));
  xmlNodeSetContent(xnode, encoded_content);
  return (Qtrue);
}

/*
 * call-seq:
 *    node.content_stripped -> "string"
 *
 * Obtain this node's stripped content.
 *
 * *Deprecated*: Stripped content can be obtained via the
 * +content+ method.
 */
static VALUE rxml_node_content_stripped_get(VALUE self)
{
  xmlNodePtr xnode;
  xmlChar* content;
  VALUE result = Qnil;

  xnode = rxml_get_xnode(self);

  if (!xnode->content)
    return result;

  content = xmlNodeGetContent(xnode);
  if (content)
  {
    result = rxml_new_cstr((const char*) content, NULL);
    xmlFree(content);
  }
  return (result);
}

/*
 * call-seq:
 *    node.debug -> true|false
 *
 * Print libxml debugging information to stdout.
 * Requires that libxml was compiled with debugging enabled.
*/
static VALUE rxml_node_debug(VALUE self)
{
#ifdef LIBXML_DEBUG_ENABLED
  xmlNodePtr xnode;
  xnode = rxml_get_xnode(self);
  xmlDebugDumpNode(NULL, xnode, 2);
  return Qtrue;
#else
  rb_warn("libxml was compiled without debugging support.")
  return Qfalse;
#endif
}

/*
 * call-seq:
 *    node.first -> XML::Node
 *
 * Returns this node's first child node if any.
 */
static VALUE rxml_node_first_get(VALUE self)
{
  xmlNodePtr xnode;

  xnode = rxml_get_xnode(self);

  if (xnode->children)
    return (rxml_node_wrap(xnode->children));
  else
    return (Qnil);
}


/*
 * call-seq:
 *   curr_node << "Some text" 
 *   curr_node << node
 *
 * Add  the specified text or XML::Node as a new child node to the 
 * current node.
 *
 * If the specified argument is a string, it should be a raw string 
 * that contains unescaped XML special characters.  Entity references 
 * are not supported.
 * 
 * The method will return the current node.
 */
static VALUE rxml_node_content_add(VALUE self, VALUE obj)
{
  xmlNodePtr xnode;
  VALUE str;

  xnode = rxml_get_xnode(self);

  /* XXX This should only be legal for a CDATA type node, I think,
   * resulting in a merge of content, as if a string were passed
   * danj 070827
   */
  if (rb_obj_is_kind_of(obj, cXMLNode))
  { 
    rxml_node_modify_dom(self, obj, xmlAddChild);
  }
  else
  {
    str = rb_obj_as_string(obj);
    if (NIL_P(str) || TYPE(str) != T_STRING)
      rb_raise(rb_eTypeError, "invalid argument: must be string or XML::Node");

    xmlNodeAddContent(xnode, (xmlChar*) StringValuePtr(str));
  }
  return self;
}

/*
 * call-seq:
 *    node.doc -> document
 *
 * Obtain the XML::Document this node belongs to.
 */
static VALUE rxml_node_doc(VALUE self)
{
  xmlDocPtr xdoc = NULL;
  xmlNodePtr xnode = rxml_get_xnode(self);

  switch (xnode->type)
  {
  case XML_DOCUMENT_NODE:
#ifdef LIBXML_DOCB_ENABLED
  case XML_DOCB_DOCUMENT_NODE:
#endif
  case XML_HTML_DOCUMENT_NODE:
  case XML_NAMESPACE_DECL:
    break;
  case XML_ATTRIBUTE_NODE:
    xdoc = (xmlDocPtr)((xmlAttrPtr) xnode->doc);
    break;
  default:
    xdoc = xnode->doc;
  }

  if (xdoc == NULL)
    return (Qnil);
  else if (xdoc->_private)
    return (VALUE) xdoc->_private;
  else
    return (Qnil);
}

/*
 * call-seq:
 *    node.to_s -> "string"
 *    node.to_s(:indent => true, :encoding => 'UTF-8', :level => 0) -> "string"
 *
 * Converts a node, and all of its children, to a string representation.
 * To include only the node's children, use the the XML::Node#inner_xml
 * method.
 *
 * You may provide an optional hash table to control how the string is 
 * generated.  Valid options are:
 * 
 * :indent - Specifies if the string should be indented.  The default value
 * is true.  Note that indentation is only added if both :indent is
 * true and XML.inde