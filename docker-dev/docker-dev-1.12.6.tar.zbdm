     "type":"structure",
      "required":[
        "domain",
        "activityType"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which the activity type is registered.</p>"
        },
        "activityType":{
          "shape":"ActivityType",
          "documentation":"<p>The activity type to deprecate.</p>"
        }
      }
    },
    "DeprecateDomainInput":{
      "type":"structure",
      "required":["name"],
      "members":{
        "name":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain to deprecate.</p>"
        }
      }
    },
    "DeprecateWorkflowTypeInput":{
      "type":"structure",
      "required":[
        "domain",
        "workflowType"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which the workflow type is registered.</p>"
        },
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The workflow type to deprecate.</p>"
        }
      }
    },
    "DescribeActivityTypeInput":{
      "type":"structure",
      "required":[
        "domain",
        "activityType"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which the activity type is registered.</p>"
        },
        "activityType":{
          "shape":"ActivityType",
          "documentation":"<p>The activity type to get information about. Activity types are identified by the <code>name</code> and <code>version</code> that were supplied when the activity was registered.</p>"
        }
      }
    },
    "DescribeDomainInput":{
      "type":"structure",
      "required":["name"],
      "members":{
        "name":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain to describe.</p>"
        }
      }
    },
    "DescribeWorkflowExecutionInput":{
      "type":"structure",
      "required":[
        "domain",
        "execution"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain containing the workflow execution.</p>"
        },
        "execution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>The workflow execution to describe.</p>"
        }
      }
    },
    "DescribeWorkflowTypeInput":{
      "type":"structure",
      "required":[
        "domain",
        "workflowType"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which this workflow type is registered.</p>"
        },
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The workflow type to describe.</p>"
        }
      }
    },
    "Description":{
      "type":"string",
      "max":1024
    },
    "DomainAlreadyExistsFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned if the specified domain already exists. You will get this fault even if the existing domain is in deprecated status.</p>"
    },
    "DomainConfiguration":{
      "type":"structure",
      "required":["workflowExecutionRetentionPeriodInDays"],
      "members":{
        "workflowExecutionRetentionPeriodInDays":{
          "shape":"DurationInDays",
          "documentation":"<p>The retention period for workflow executions in this domain.</p>"
        }
      },
      "documentation":"<p>Contains the configuration settings of a domain.</p>"
    },
    "DomainDeprecatedFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned when the specified domain has been deprecated.</p>"
    },
    "DomainDetail":{
      "type":"structure",
      "required":[
        "domainInfo",
        "configuration"
      ],
      "members":{
        "domainInfo":{"shape":"DomainInfo"},
        "configuration":{"shape":"DomainConfiguration"}
      },
      "documentation":"<p>Contains details of a domain.</p>"
    },
    "DomainInfo":{
      "type":"structure",
      "required":[
        "name",
        "status"
      ],
      "members":{
        "name":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain. This name is unique within the account.</p>"
        },
        "status":{
          "shape":"RegistrationStatus",
          "documentation":"<p>The status of the domain:</p> <ul> <li> <b>REGISTERED</b>: The domain is properly registered and available. You can use this domain for registering types and creating new workflow executions. </li> <li> <b>DEPRECATED</b>: The domain was deprecated using <a>DeprecateDomain</a>, but is still in use. You should not create new workflow executions in this domain. </li> </ul>"
        },
        "description":{
          "shape":"Description",
          "documentation":"<p>The description of the domain provided through <a>RegisterDomain</a>.</p>"
        }
      },
      "documentation":"<p>Contains general information about a domain.</p>"
    },
    "DomainInfoList":{
      "type":"list",
      "member":{"shape":"DomainInfo"}
    },
    "DomainInfos":{
      "type":"structure",
      "required":["domainInfos"],
      "members":{
        "domainInfos":{
          "shape":"DomainInfoList",
          "documentation":"<p>A list of DomainInfo structures.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        }
      },
      "documentation":"<p>Contains a paginated collection of DomainInfo structures.</p>"
    },
    "DomainName":{
      "type":"string",
      "min":1,
      "max":256
    },
    "DurationInDays":{
      "type":"string",
      "min":1,
      "max":8
    },
    "DurationInSeconds":{
      "type":"string",
      "min":1,
      "max":8
    },
    "DurationInSecondsOptional":{
      "type":"string",
      "max":8
    },
    "ErrorMessage":{"type":"string"},
    "EventId":{"type":"long"},
    "EventType":{
      "type":"string",
      "enum":[
        "WorkflowExecutionStarted",
        "WorkflowExecutionCancelRequested",
        "WorkflowExecutionCompleted",
        "CompleteWorkflowExecutionFailed",
        "WorkflowExecutionFailed",
        "FailWorkflowExecutionFailed",
        "WorkflowExecutionTimedOut",
        "WorkflowExecutionCanceled",
        "CancelWorkflowExecutionFailed",
        "WorkflowExecutionContinuedAsNew",
        "ContinueAsNewWorkflowExecutionFailed",
        "WorkflowExecutionTerminated",
        "DecisionTaskScheduled",
        "DecisionTaskStarted",
        "DecisionTaskCompleted",
        "DecisionTaskTimedOut",
        "ActivityTaskScheduled",
        "ScheduleActivityTaskFailed",
        "ActivityTaskStarted",
        "ActivityTaskCompleted",
        "ActivityTaskFailed",
        "ActivityTaskTimedOut",
        "ActivityTaskCanceled",
        "ActivityTaskCancelRequested",
        "RequestCancelActivityTaskFailed",
        "WorkflowExecutionSignaled",
        "MarkerRecorded",
        "RecordMarkerFailed",
        "TimerStarted",
        "StartTimerFailed",
        "TimerFired",
        "TimerCanceled",
        "CancelTimerFailed",
        "StartChildWorkflowExecutionInitiated",
        "StartChildWorkflowExecutionFailed",
        "ChildWorkflowExecutionStarted",
        "ChildWorkflowExecutionCompleted",
        "ChildWorkflowExecutionFailed",
        "ChildWorkflowExecutionTimedOut",
        "ChildWorkflowExecutionCanceled",
        "ChildWorkflowExecutionTerminated",
        "SignalExternalWorkflowExecutionInitiated",
        "SignalExternalWorkflowExecutionFailed",
        "ExternalWorkflowExecutionSignaled",
        "RequestCancelExternalWorkflowExecutionInitiated",
        "RequestCancelExternalWorkflowExecutionFailed",
        "ExternalWorkflowExecutionCancelRequested",
        "LambdaFunctionScheduled",
        "LambdaFunctionStarted",
        "LambdaFunctionCompleted",
        "LambdaFunctionFailed",
        "LambdaFunctionTimedOut",
        "ScheduleLambdaFunctionFailed",
        "StartLambdaFunctionFailed"
      ]
    },
    "ExecutionStatus":{
      "type":"string",
      "enum":[
        "OPEN",
        "CLOSED"
      ]
    },
    "ExecutionTimeFilter":{
      "type":"structure",
      "required":["oldestDate"],
      "members":{
        "oldestDate":{
          "shape":"Timestamp",
          "documentation":"<p>Specifies the oldest start or close date and time to return.</p>"
        },
        "latestDate":{
          "shape":"Timestamp",
          "documentation":"<p>Specifies the latest start or close date and time to return.</p>"
        }
      },
      "documentation":"<p>Used to filter the workflow executions in visibility APIs by various time-based rules. Each parameter, if specified, defines a rule that must be satisfied by each returned query result. The parameter values are in the <a href=\"https://en.wikipedia.org/wiki/Unix_time\">Unix Time format</a>. For example: <code>\"oldestDate\": 1325376070.</code></p>"
    },
    "ExternalWorkflowExecutionCancelRequestedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowExecution",
        "initiatedEventId"
      ],
      "members":{
        "workflowExecution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>The external workflow execution to which the cancellation request was delivered.</p>"
        },
        "initiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>RequestCancelExternalWorkflowExecutionInitiated</code> event corresponding to the <code>RequestCancelExternalWorkflowExecution</code> decision to cancel this external workflow execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>ExternalWorkflowExecutionCancelRequested</code> event.</p>"
    },
    "ExternalWorkflowExecutionSignaledEventAttributes":{
      "type":"structure",
      "required":[
        "workflowExecution",
        "initiatedEventId"
      ],
      "members":{
        "workflowExecution":{
          "shape":"WorkflowExecution",
          "documentation":"<p> The external workflow execution that the signal was delivered to.</p>"
        },
        "initiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>SignalExternalWorkflowExecutionInitiated</code> event corresponding to the <code>SignalExternalWorkflowExecution</code> decision to request this signal. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p> Provides details of the <code>ExternalWorkflowExecutionSignaled</code> event.</p>"
    },
    "FailWorkflowExecutionDecisionAttributes":{
      "type":"structure",
      "members":{
        "reason":{
          "shape":"FailureReason",
          "documentation":"<p>A descriptive reason for the failure that may help in diagnostics.</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Details of the failure.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>FailWorkflowExecution</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>You cannot use an IAM policy to constrain this action's parameters.</li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "FailWorkflowExecutionFailedCause":{
      "type":"string",
      "enum":[
        "UNHANDLED_DECISION",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "FailWorkflowExecutionFailedEventAttributes":{
      "type":"structure",
      "required":[
        "cause",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "cause":{
          "shape":"FailWorkflowExecutionFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>FailWorkflowExecution</code> decision to fail this execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>FailWorkflowExecutionFailed</code> event.</p>"
    },
    "FailureReason":{
      "type":"string",
      "max":256
    },
    "FunctionId":{
      "type":"string",
      "min":1,
      "max":256
    },
    "FunctionInput":{
      "type":"string",
      "min":1,
      "max":32768
    },
    "FunctionName":{
      "type":"string",
      "min":1,
      "max":64
    },
    "GetWorkflowExecutionHistoryInput":{
      "type":"structure",
      "required":[
        "domain",
        "execution"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain containing the workflow execution.</p>"
        },
        "execution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>Specifies the workflow execution for which to return the history.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the events in reverse order. By default the results are returned in ascending order of the <code>eventTimeStamp</code> of the events.</p>"
        }
      }
    },
    "History":{
      "type":"structure",
      "required":["events"],
      "members":{
        "events":{
          "shape":"HistoryEventList",
          "documentation":"<p>The list of history events.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        }
      },
      "documentation":"<p>Paginated representation of a workflow history for a workflow execution. This is the up to date, complete and authoritative record of the events related to all tasks and events in the life of the workflow execution.</p>"
    },
    "HistoryEvent":{
      "type":"structure",
      "required":[
        "eventTimestamp",
        "eventType",
        "eventId"
      ],
      "members":{
        "eventTimestamp":{
          "shape":"Timestamp",
          "documentation":"<p>The date and time when the event occurred.</p>"
        },
        "eventType":{
          "shape":"EventType",
          "documentation":"<p>The type of the history event.</p>"
        },
        "eventId":{
          "shape":"EventId",
          "documentation":"<p>The system generated ID of the event. This ID uniquely identifies the event with in the workflow execution history.</p>"
        },
        "workflowExecutionStartedEventAttributes":{
          "shape":"WorkflowExecutionStartedEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionStarted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionCompletedEventAttributes":{
          "shape":"WorkflowExecutionCompletedEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionCompleted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "completeWorkflowExecutionFailedEventAttributes":{
          "shape":"CompleteWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>CompleteWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionFailedEventAttributes":{
          "shape":"WorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "failWorkflowExecutionFailedEventAttributes":{
          "shape":"FailWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>FailWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionTimedOutEventAttributes":{
          "shape":"WorkflowExecutionTimedOutEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionTimedOut</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionCanceledEventAttributes":{
          "shape":"WorkflowExecutionCanceledEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionCanceled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "cancelWorkflowExecutionFailedEventAttributes":{
          "shape":"CancelWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>CancelWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionContinuedAsNewEventAttributes":{
          "shape":"WorkflowExecutionContinuedAsNewEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionContinuedAsNew</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "continueAsNewWorkflowExecutionFailedEventAttributes":{
          "shape":"ContinueAsNewWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>ContinueAsNewWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionTerminatedEventAttributes":{
          "shape":"WorkflowExecutionTerminatedEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionTerminated</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionCancelRequestedEventAttributes":{
          "shape":"WorkflowExecutionCancelRequestedEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionCancelRequested</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "decisionTaskScheduledEventAttributes":{
          "shape":"DecisionTaskScheduledEventAttributes",
          "documentation":"<p>If the event is of type <code>DecisionTaskScheduled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "decisionTaskStartedEventAttributes":{
          "shape":"DecisionTaskStartedEventAttributes",
          "documentation":"<p>If the event is of type <code>DecisionTaskStarted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "decisionTaskCompletedEventAttributes":{
          "shape":"DecisionTaskCompletedEventAttributes",
          "documentation":"<p>If the event is of type <code>DecisionTaskCompleted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "decisionTaskTimedOutEventAttributes":{
          "shape":"DecisionTaskTimedOutEventAttributes",
          "documentation":"<p>If the event is of type <code>DecisionTaskTimedOut</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskScheduledEventAttributes":{
          "shape":"ActivityTaskScheduledEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskScheduled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskStartedEventAttributes":{
          "shape":"ActivityTaskStartedEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskStarted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskCompletedEventAttributes":{
          "shape":"ActivityTaskCompletedEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskCompleted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskFailedEventAttributes":{
          "shape":"ActivityTaskFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskTimedOutEventAttributes":{
          "shape":"ActivityTaskTimedOutEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskTimedOut</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskCanceledEventAttributes":{
          "shape":"ActivityTaskCanceledEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskCanceled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "activityTaskCancelRequestedEventAttributes":{
          "shape":"ActivityTaskCancelRequestedEventAttributes",
          "documentation":"<p>If the event is of type <code>ActivityTaskcancelRequested</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "workflowExecutionSignaledEventAttributes":{
          "shape":"WorkflowExecutionSignaledEventAttributes",
          "documentation":"<p>If the event is of type <code>WorkflowExecutionSignaled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "markerRecordedEventAttributes":{
          "shape":"MarkerRecordedEventAttributes",
          "documentation":"<p>If the event is of type <code>MarkerRecorded</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "recordMarkerFailedEventAttributes":{
          "shape":"RecordMarkerFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>DecisionTaskFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "timerStartedEventAttributes":{
          "shape":"TimerStartedEventAttributes",
          "documentation":"<p>If the event is of type <code>TimerStarted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "timerFiredEventAttributes":{
          "shape":"TimerFiredEventAttributes",
          "documentation":"<p>If the event is of type <code>TimerFired</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "timerCanceledEventAttributes":{
          "shape":"TimerCanceledEventAttributes",
          "documentation":"<p>If the event is of type <code>TimerCanceled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "startChildWorkflowExecutionInitiatedEventAttributes":{
          "shape":"StartChildWorkflowExecutionInitiatedEventAttributes",
          "documentation":"<p>If the event is of type <code>StartChildWorkflowExecutionInitiated</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "childWorkflowExecutionStartedEventAttributes":{
          "shape":"ChildWorkflowExecutionStartedEventAttributes",
          "documentation":"<p>If the event is of type <code>ChildWorkflowExecutionStarted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "childWorkflowExecutionCompletedEventAttributes":{
          "shape":"ChildWorkflowExecutionCompletedEventAttributes",
          "documentation":"<p>If the event is of type <code>ChildWorkflowExecutionCompleted</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "childWorkflowExecutionFailedEventAttributes":{
          "shape":"ChildWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>ChildWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "childWorkflowExecutionTimedOutEventAttributes":{
          "shape":"ChildWorkflowExecutionTimedOutEventAttributes",
          "documentation":"<p>If the event is of type <code>ChildWorkflowExecutionTimedOut</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "childWorkflowExecutionCanceledEventAttributes":{
          "shape":"ChildWorkflowExecutionCanceledEventAttributes",
          "documentation":"<p>If the event is of type <code>ChildWorkflowExecutionCanceled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "childWorkflowExecutionTerminatedEventAttributes":{
          "shape":"ChildWorkflowExecutionTerminatedEventAttributes",
          "documentation":"<p>If the event is of type <code>ChildWorkflowExecutionTerminated</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "signalExternalWorkflowExecutionInitiatedEventAttributes":{
          "shape":"SignalExternalWorkflowExecutionInitiatedEventAttributes",
          "documentation":"<p>If the event is of type <code>SignalExternalWorkflowExecutionInitiated</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "externalWorkflowExecutionSignaledEventAttributes":{
          "shape":"ExternalWorkflowExecutionSignaledEventAttributes",
          "documentation":"<p>If the event is of type <code>ExternalWorkflowExecutionSignaled</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "signalExternalWorkflowExecutionFailedEventAttributes":{
          "shape":"SignalExternalWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>SignalExternalWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "externalWorkflowExecutionCancelRequestedEventAttributes":{
          "shape":"ExternalWorkflowExecutionCancelRequestedEventAttributes",
          "documentation":"<p>If the event is of type <code>ExternalWorkflowExecutionCancelRequested</code> then this member is set and provides detailed information about the event. It is not set for other event types. </p>"
        },
        "requestCancelExternalWorkflowExecutionInitiatedEventAttributes":{
          "shape":"RequestCancelExternalWorkflowExecutionInitiatedEventAttributes",
          "documentation":"<p>If the event is of type <code>RequestCancelExternalWorkflowExecutionInitiated</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "requestCancelExternalWorkflowExecutionFailedEventAttributes":{
          "shape":"RequestCancelExternalWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>RequestCancelExternalWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "scheduleActivityTaskFailedEventAttributes":{
          "shape":"ScheduleActivityTaskFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>ScheduleActivityTaskFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "requestCancelActivityTaskFailedEventAttributes":{
          "shape":"RequestCancelActivityTaskFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>RequestCancelActivityTaskFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "startTimerFailedEventAttributes":{
          "shape":"StartTimerFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>StartTimerFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "cancelTimerFailedEventAttributes":{
          "shape":"CancelTimerFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>CancelTimerFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "startChildWorkflowExecutionFailedEventAttributes":{
          "shape":"StartChildWorkflowExecutionFailedEventAttributes",
          "documentation":"<p>If the event is of type <code>StartChildWorkflowExecutionFailed</code> then this member is set and provides detailed information about the event. It is not set for other event types.</p>"
        },
        "lambdaFunctionScheduledEventAttributes":{"shape":"LambdaFunctionScheduledEventAttributes"},
        "lambdaFunctionStartedEventAttributes":{"shape":"LambdaFunctionStartedEventAttributes"},
        "lambdaFunctionCompletedEventAttributes":{"shape":"LambdaFunctionCompletedEventAttributes"},
        "lambdaFunctionFailedEventAttributes":{"shape":"LambdaFunctionFailedEventAttributes"},
        "lambdaFunctionTimedOutEventAttributes":{"shape":"LambdaFunctionTimedOutEventAttributes"},
        "scheduleLambdaFunctionFailedEventAttributes":{"shape":"ScheduleLambdaFunctionFailedEventAttributes"},
        "startLambdaFunctionFailedEventAttributes":{"shape":"StartLambdaFunctionFailedEventAttributes"}
      },
      "documentation":"<p>Event within a workflow execution. A history event can be one of these types:</p> <ul> <li> <b>WorkflowExecutionStarted</b>: The workflow execution was started.</li> <li> <b>WorkflowExecutionCompleted</b>: The workflow execution was closed due to successful completion.</li> <li> <b>WorkflowExecutionFailed</b>: The workflow execution closed due to a failure.</li> <li> <b>WorkflowExecutionTimedOut</b>: The workflow execution was closed because a time out was exceeded.</li> <li> <b>WorkflowExecutionCanceled</b>: The workflow execution was successfully canceled and closed.</li> <li> <b>WorkflowExecutionTerminated</b>: The workflow execution was terminated.</li> <li> <b>WorkflowExecutionContinuedAsNew</b>: The workflow execution was closed and a new execution of the same type was created with the same workflowId.</li> <li> <b>WorkflowExecutionCancelRequested</b>: A request to cancel this workflow execution was made.</li> <li> <b>DecisionTaskScheduled</b>: A decision task was scheduled for the workflow execution.</li> <li> <b>DecisionTaskStarted</b>: The decision task was dispatched to a decider.</li> <li> <b>DecisionTaskCompleted</b>: The decider successfully completed a decision task by calling <a>RespondDecisionTaskCompleted</a>.</li> <li> <b>DecisionTaskTimedOut</b>: The decision task timed out.</li> <li> <b>ActivityTaskScheduled</b>: An activity task was scheduled for execution.</li> <li> <b>ScheduleActivityTaskFailed</b>: Failed to process ScheduleActivityTask decision. This happens when the decision is not configured properly, for example the activity type specified is not registered.</li> <li> <b>ActivityTaskStarted</b>: The scheduled activity task was dispatched to a worker.</li> <li> <b>ActivityTaskCompleted</b>: An activity worker successfully completed an activity task by calling <a>RespondActivityTaskCompleted</a>.</li> <li> <b>ActivityTaskFailed</b>: An activity worker failed an activity task by calling <a>RespondActivityTaskFailed</a>.</li> <li> <b>ActivityTaskTimedOut</b>: The activity task timed out.</li> <li> <b>ActivityTaskCanceled</b>: The activity task was successfully canceled.</li> <li> <b>ActivityTaskCancelRequested</b>: A <code>RequestCancelActivityTask</code> decision was received by the system.</li> <li> <b>RequestCancelActivityTaskFailed</b>: Failed to process RequestCancelActivityTask decision. This happens when the decision is not configured properly.</li> <li> <b>WorkflowExecutionSignaled</b>: An external signal was received for the workflow execution.</li> <li> <b>MarkerRecorded</b>: A marker was recorded in the workflow history as the result of a <code>RecordMarker</code> decision.</li> <li> <b>TimerStarted</b>: A timer was started for the workflow execution due to a <code>StartTimer</code> decision.</li> <li> <b>StartTimerFailed</b>: Failed to process StartTimer decision. This happens when the decision is not configured properly, for example a timer already exists with the specified timer ID.</li> <li> <b>TimerFired</b>: A timer, previously started for this workflow execution, fired.</li> <li> <b>TimerCanceled</b>: A timer, previously started for this workflow execution, was successfully canceled.</li> <li> <b>CancelTimerFailed</b>: Failed to process CancelTimer decision. This happens when the decision is not configured properly, for example no timer exists with the specified timer ID.</li> <li> <b>StartChildWorkflowExecutionInitiated</b>: A request was made to start a child workflow execution.</li> <li> <b>StartChildWorkflowExecutionFailed</b>: Failed to process StartChildWorkflowExecution decision. This happens when the decision is not configured properly, for example the workflow type specified is not registered.</li> <li> <b>ChildWorkflowExecutionStarted</b>: A child workflow execution was successfully started.</li> <li> <b>ChildWorkflowExecutionCompleted</b>: A child workflow execution, started by this workflow execution, completed successfully and was closed.</li> <li> <b>ChildWorkflowExecutionFailed</b>: A child workflow execution, started by this workflow execution, failed to complete successfully and was closed.</li> <li> <b>ChildWorkflowExecutionTimedOut</b>: A child workflow execution, started by this workflow execution, timed out and was closed.</li> <li> <b>ChildWorkflowExecutionCanceled</b>: A child workflow execution, started by this workflow execution, was canceled and closed.</li> <li> <b>ChildWorkflowExecutionTerminated</b>: A child workflow execution, started by this workflow execution, was terminated.</li> <li> <b>SignalExternalWorkflowExecutionInitiated</b>: A request to signal an external workflow was made.</li> <li> <b>ExternalWorkflowExecutionSignaled</b>: A signal, requested by this workflow execution, was successfully delivered to the target external workflow execution.</li> <li> <b>SignalExternalWorkflowExecutionFailed</b>: The request to signal an external workflow execution failed.</li> <li> <b>RequestCancelExternalWorkflowExecutionInitiated</b>: A request was made to request the cancellation of an external workflow execution.</li> <li> <b>ExternalWorkflowExecutionCancelRequested</b>: Request to cancel an external workflow execution was successfully delivered to the target execution.</li> <li> <b>RequestCancelExternalWorkflowExecutionFailed</b>: Request to cancel an external workflow execution failed.</li> <li> <b>LambdaFunctionScheduled</b>: An AWS Lambda function was scheduled for execution.</li> <li> <b>LambdaFunctionStarted</b>: The scheduled function was invoked in the AWS Lambda service.</li> <li> <b>LambdaFunctionCompleted</b>: The AWS Lambda function successfully completed.</li> <li> <b>LambdaFunctionFailed</b>: The AWS Lambda function execution failed.</li> <li> <b>LambdaFunctionTimedOut</b>: The AWS Lambda function execution timed out.</li> <li> <b>ScheduleLambdaFunctionFailed</b>: Failed to process ScheduleLambdaFunction decision. This happens when the workflow execution does not have the proper IAM role attached to invoke AWS Lambda functions.</li> <li> <b>StartLambdaFunctionFailed</b>: Failed to invoke the scheduled function in the AWS Lambda service. This happens when the AWS Lambda service is not available in the current region, or received too many requests.</li> </ul>"
    },
    "HistoryEventList":{
      "type":"list",
      "member":{"shape":"HistoryEvent"}
    },
    "Identity":{
      "type":"string",
      "max":256
    },
    "LambdaFunctionCompletedEventAttributes":{
      "type":"structure",
      "required":[
        "scheduledEventId",
        "startedEventId"
      ],
      "members":{
        "scheduledEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionScheduled</code> event that was recorded when this AWS Lambda function was scheduled. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "startedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionStarted</code> event recorded in the history.</p>"
        },
        "result":{
          "shape":"Data",
          "documentation":"<p>The result of the function execution (if any).</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>LambdaFunctionCompleted</code> event.</p>"
    },
    "LambdaFunctionFailedEventAttributes":{
      "type":"structure",
      "required":[
        "scheduledEventId",
        "startedEventId"
      ],
      "members":{
        "scheduledEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionScheduled</code> event that was recorded when this AWS Lambda function was scheduled. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "startedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionStarted</code> event recorded in the history.</p>"
        },
        "reason":{
          "shape":"FailureReason",
          "documentation":"<p>The reason provided for the failure (if any).</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p>The details of the failure (if any).</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>LambdaFunctionFailed</code> event.</p>"
    },
    "LambdaFunctionScheduledEventAttributes":{
      "type":"structure",
      "required":[
        "id",
        "name",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "id":{
          "shape":"FunctionId",
          "documentation":"<p>The unique Amazon SWF ID for the AWS Lambda task.</p>"
        },
        "name":{
          "shape":"FunctionName",
          "documentation":"<p>The name of the scheduled AWS Lambda function.</p>"
        },
        "input":{
          "shape":"FunctionInput",
          "documentation":"<p>Input provided to the AWS Lambda function.</p>"
        },
        "startToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum time, in seconds, that the AWS Lambda function can take to execute from start to close before it is marked as failed.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event for the decision that resulted in the scheduling of this AWS Lambda function. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>LambdaFunctionScheduled</code> event.</p>"
    },
    "LambdaFunctionStartedEventAttributes":{
      "type":"structure",
      "required":["scheduledEventId"],
      "members":{
        "scheduledEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionScheduled</code> event that was recorded when this AWS Lambda function was scheduled. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>LambdaFunctionStarted</code> event.</p>"
    },
    "LambdaFunctionTimedOutEventAttributes":{
      "type":"structure",
      "required":[
        "scheduledEventId",
        "startedEventId"
      ],
      "members":{
        "scheduledEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionScheduled</code> event that was recorded when this AWS Lambda function was scheduled. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "startedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionStarted</code> event recorded in the history.</p>"
        },
        "timeoutType":{
          "shape":"LambdaFunctionTimeoutType",
          "documentation":"<p>The type of the timeout that caused this event.</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>LambdaFunctionTimedOut</code> event.</p>"
    },
    "LambdaFunctionTimeoutType":{
      "type":"string",
      "enum":["START_TO_CLOSE"]
    },
    "LimitExceededFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>"
    },
    "LimitedData":{
      "type":"string",
      "max":2048
    },
    "ListActivityTypesInput":{
      "type":"structure",
      "required":[
        "domain",
        "registrationStatus"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which the activity types have been registered.</p>"
        },
        "name":{
          "shape":"Name",
          "documentation":"<p>If specified, only lists the activity types that have this name.</p>"
        },
        "registrationStatus":{
          "shape":"RegistrationStatus",
          "documentation":"<p>Specifies the registration status of the activity types to list.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the results in reverse order. By default, the results are returned in ascending alphabetical order by <code>name</code> of the activity types.</p>"
        }
      }
    },
    "ListClosedWorkflowExecutionsInput":{
      "type":"structure",
      "required":["domain"],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain that contains the workflow executions to list.</p>"
        },
        "startTimeFilter":{
          "shape":"ExecutionTimeFilter",
          "documentation":"<p>If specified, the workflow executions are included in the returned results based on whether their start times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their start times.</p> <note><code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You must specify one of these in a request but not both.</note>"
        },
        "closeTimeFilter":{
          "shape":"ExecutionTimeFilter",
          "documentation":"<p>If specified, the workflow executions are included in the returned results based on whether their close times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their close times.</p> <note><code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You must specify one of these in a request but not both.</note>"
        },
        "executionFilter":{
          "shape":"WorkflowExecutionFilter",
          "documentation":"<p>If specified, only workflow executions matching the workflow ID specified in the filter are returned.</p> <note><code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        },
        "closeStatusFilter":{
          "shape":"CloseStatusFilter",
          "documentation":"<p>If specified, only workflow executions that match this <i>close status</i> are listed. For example, if TERMINATED is specified, then only TERMINATED workflow executions are listed.</p> <note><code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        },
        "typeFilter":{
          "shape":"WorkflowTypeFilter",
          "documentation":"<p>If specified, only executions of the type specified in the filter are returned.</p> <note><code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        },
        "tagFilter":{
          "shape":"TagFilter",
          "documentation":"<p>If specified, only executions that have the matching tag are listed.</p> <note><code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in descending order of the start or the close time of the executions.</p>"
        }
      }
    },
    "ListDomainsInput":{
      "type":"structure",
      "required":["registrationStatus"],
      "members":{
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        },
        "registrationStatus":{
          "shape":"RegistrationStatus",
          "documentation":"<p>Specifies the registration status of the domains to list.</p>"
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the results in reverse order. By default, the results are returned in ascending alphabetical order by <code>name</code> of the domains.</p>"
        }
      }
    },
    "ListOpenWorkflowExecutionsInput":{
      "type":"structure",
      "required":[
        "domain",
        "startTimeFilter"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain that contains the workflow executions to list.</p>"
        },
        "startTimeFilter":{
          "shape":"ExecutionTimeFilter",
          "documentation":"<p>Workflow executions are included in the returned results based on whether their start times are within the range specified by this filter.</p>"
        },
        "typeFilter":{
          "shape":"WorkflowTypeFilter",
          "documentation":"<p>If specified, only executions of the type specified in the filter are returned.</p> <note><code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        },
        "tagFilter":{
          "shape":"TagFilter",
          "documentation":"<p>If specified, only executions that have the matching tag are listed.</p> <note><code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in descending order of the start time of the executions.</p>"
        },
        "executionFilter":{
          "shape":"WorkflowExecutionFilter",
          "documentation":"<p>If specified, only workflow executions matching the workflow ID specified in the filter are returned.</p> <note><code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a request.</note>"
        }
      }
    },
    "ListWorkflowTypesInput":{
      "type":"structure",
      "required":[
        "domain",
        "registrationStatus"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which the workflow types have been registered.</p>"
        },
        "name":{
          "shape":"Name",
          "documentation":"<p>If specified, lists the workflow type with this name.</p>"
        },
        "registrationStatus":{
          "shape":"RegistrationStatus",
          "documentation":"<p>Specifies the registration status of the workflow types to list.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in ascending alphabetical order of the <code>name</code> of the workflow types.</p>"
        }
      }
    },
    "MarkerName":{
      "type":"string",
      "min":1,
      "max":256
    },
    "MarkerRecordedEventAttributes":{
      "type":"structure",
      "required":[
        "markerName",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "markerName":{
          "shape":"MarkerName",
          "documentation":"<p>The name of the marker.</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p>Details of the marker (if any).</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>RecordMarker</code> decision that requested this marker. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>MarkerRecorded</code> event.</p>"
    },
    "Name":{
      "type":"string",
      "min":1,
      "max":256
    },
    "OpenDecisionTasksCount":{
      "type":"integer",
      "min":0,
      "max":1
    },
    "OperationNotPermittedFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned when the caller does not have sufficient permissions to invoke the action.</p>"
    },
    "PageSize":{
      "type":"integer",
      "min":0,
      "max":1000
    },
    "PageToken":{
      "type":"string",
      "max":2048
    },
    "PendingTaskCount":{
      "type":"structure",
      "required":["count"],
      "members":{
        "count":{
          "shape":"Count",
          "documentation":"<p>The number of tasks in the task list.</p>"
        },
        "truncated":{
          "shape":"Truncated",
          "documentation":"<p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>"
        }
      },
      "documentation":"<p>Contains the count of tasks in a task list.</p>"
    },
    "PollForActivityTaskInput":{
      "type":"structure",
      "required":[
        "domain",
        "taskList"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain that contains the task lists being polled.</p>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>Specifies the task list to poll for activity tasks.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "identity":{
          "shape":"Identity",
          "documentation":"<p>Identity of the worker making the request, recorded in the <code>ActivityTaskStarted</code> event in the workflow history. This enables diagnostic tracing when problems arise. The form of this identity is user defined.</p>"
        }
      }
    },
    "PollForDecisionTaskInput":{
      "type":"structure",
      "required":[
        "domain",
        "taskList"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain containing the task lists to poll.</p>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>Specifies the task list to poll for decision tasks.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "identity":{
          "shape":"Identity",
          "documentation":"<p>Identity of the decider making the request, which is recorded in the DecisionTaskStarted event in the workflow history. This enables diagnostic tracing when problems arise. The form of this identity is user defined.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p> <note>The <code>nextPageToken</code> returned by this action cannot be used with <a>GetWorkflowExecutionHistory</a> to get the next page. You must call <a>PollForDecisionTask</a> again (with the <code>nextPageToken</code>) to retrieve the next page of history records. Calling <a>PollForDecisionTask</a> with a <code>nextPageToken</code> will not return a new decision task.</note>."
        },
        "maximumPageSize":{
          "shape":"PageSize",
          "documentation":"<p>The maximum number of results that will be returned per call. <code>nextPageToken</code> can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size <i>smaller</i> than the maximum.</p> <p>This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.</p>"
        },
        "reverseOrder":{
          "shape":"ReverseOrder",
          "documentation":"<p>When set to <code>true</code>, returns the events in reverse order. By default the results are returned in ascending order of the <code>eventTimestamp</code> of the events.</p>"
        }
      }
    },
    "RecordActivityTaskHeartbeatInput":{
      "type":"structure",
      "required":["taskToken"],
      "members":{
        "taskToken":{
          "shape":"TaskToken",
          "documentation":"<p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p> <important> <code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results. </important>"
        },
        "details":{
          "shape":"LimitedData",
          "documentation":"<p>If specified, contains details about the progress of the task.</p>"
        }
      }
    },
    "RecordMarkerDecisionAttributes":{
      "type":"structure",
      "required":["markerName"],
      "members":{
        "markerName":{
          "shape":"MarkerName",
          "documentation":"<p><b>Required.</b> The name of the marker.</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> details of the marker.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>RecordMarker</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>You cannot use an IAM policy to constrain this action's parameters.</li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "RecordMarkerFailedCause":{
      "type":"string",
      "enum":["OPERATION_NOT_PERMITTED"]
    },
    "RecordMarkerFailedEventAttributes":{
      "type":"structure",
      "required":[
        "markerName",
        "cause",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "markerName":{
          "shape":"MarkerName",
          "documentation":"<p>The marker's name.</p>"
        },
        "cause":{
          "shape":"RecordMarkerFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>RecordMarkerFailed</code> decision for this cancellation request. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>RecordMarkerFailed</code> event.</p>"
    },
    "RegisterActivityTypeInput":{
      "type":"structure",
      "required":[
        "domain",
        "name",
        "version"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which this activity is to be registered.</p>"
        },
        "name":{
          "shape":"Name",
          "documentation":"<p>The name of the activity type within the domain.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "version":{
          "shape":"Version",
          "documentation":"<p>The version of the activity type.</p> <note>The activity type consists of the name and version, the combination of which must be unique within the domain.</note> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "description":{
          "shape":"Description",
          "documentation":"<p>A textual description of the activity type.</p>"
        },
        "defaultTaskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the default maximum duration that a worker can take to process tasks of this activity type. This default can be overridden when scheduling an activity task using the <code>ScheduleActivityTask</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "defaultTaskHeartbeatTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the default maximum time before which a worker processing a task of this type must report progress by calling <a>RecordActivityTaskHeartbeat</a>. If the timeout is exceeded, the activity task is automatically timed out. This default can be overridden when scheduling an activity task using the <code>ScheduleActivityTask</code> decision. If the activity worker subsequently attempts to record a heartbeat or returns a result, the activity worker receives an <code>UnknownResource</code> fault. In this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should clean up the activity task.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "defaultTaskList":{
          "shape":"TaskList",
          "documentation":"<p>If set, specifies the default task list to use for scheduling tasks of this activity type. This default task list is used if a task list is not provided when a task is scheduled through the <code>ScheduleActivityTask</code> decision.</p>"
        },
        "defaultTaskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p>The default task priority to assign to the activity type. If not assigned, then \"0\" will be used. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "defaultTaskScheduleToStartTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the default maximum duration that a task of this activity type can wait before being assigned to a worker. This default can be overridden when scheduling an activity task using the <code>ScheduleActivityTask</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "defaultTaskScheduleToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the default maximum duration for a task of this activity type. This default can be overridden when scheduling an activity task using the <code>ScheduleActivityTask</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        }
      }
    },
    "RegisterDomainInput":{
      "type":"structure",
      "required":[
        "name",
        "workflowExecutionRetentionPeriodInDays"
      ],
      "members":{
        "name":{
          "shape":"DomainName",
          "documentation":"<p>Name of the domain to register. The name must be unique in the region that the domain is registered in.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "description":{
          "shape":"Description",
          "documentation":"<p>A text description of the domain.</p>"
        },
        "workflowExecutionRetentionPeriodInDays":{
          "shape":"DurationInDays",
          "documentation":"<p>The duration (in days) that records and histories of workflow executions on the domain should be kept by the service. After the retention period, the workflow execution is not available in the results of visibility calls.</p> <p>If you pass the value <code>NONE</code> or <code>0</code> (zero), then the workflow execution history will not be retained. As soon as the workflow execution completes, the execution record and its history are deleted.</p> <p>The maximum workflow execution retention period is 90 days. For more information about Amazon SWF service limits, see: <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-limits.html\">Amazon SWF Service Limits</a> in the <i>Amazon SWF Developer Guide</i>.</p>"
        }
      }
    },
    "RegisterWorkflowTypeInput":{
      "type":"structure",
      "required":[
        "domain",
        "name",
        "version"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which to register the workflow type.</p>"
        },
        "name":{
          "shape":"Name",
          "documentation":"<p>The name of the workflow type.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "version":{
          "shape":"Version",
          "documentation":"<p>The version of the workflow type.</p> <note>The workflow type consists of the name and version, the combination of which must be unique within the domain. To get a list of all currently registered workflow types, use the <a>ListWorkflowTypes</a> action.</note> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "description":{
          "shape":"Description",
          "documentation":"<p>Textual description of the workflow type.</p>"
        },
        "defaultTaskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the default maximum duration of decision tasks for this workflow type. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "defaultExecutionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the default maximum duration for executions of this workflow type. You can override this default when starting an execution through the <a>StartWorkflowExecution</a> action or <code>StartChildWorkflowExecution</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. Unlike some of the other timeout parameters in Amazon SWF, you cannot specify a value of \"NONE\" for <code>defaultExecutionStartToCloseTimeout</code>; there is a one-year max limit on the time that a workflow execution can run. Exceeding this limit will always cause the workflow execution to time out.</p>"
        },
        "defaultTaskList":{
          "shape":"TaskList",
          "documentation":"<p>If set, specifies the default task list to use for scheduling decision tasks for executions of this workflow type. This default is used only if a task list is not provided when starting the execution through the <a>StartWorkflowExecution</a> action or <code>StartChildWorkflowExecution</code> decision.</p>"
        },
        "defaultTaskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p>The default task priority to assign to the workflow type. If not assigned, then \"0\" will be used. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "defaultChildPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>If set, specifies the default policy to use for the child workflow executions when a workflow execution of this type is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "defaultLambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The ARN of the default IAM role to use when a workflow execution of this type invokes AWS Lambda functions.</p> <p>This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> and <code>ContinueAsNewWorkflowExecution</code> decision.</p>"
        }
      }
    },
    "RegistrationStatus":{
      "type":"string",
      "enum":[
        "REGISTERED",
        "DEPRECATED"
      ]
    },
    "RequestCancelActivityTaskDecisionAttributes":{
      "type":"structure",
      "required":["activityId"],
      "members":{
        "activityId":{
          "shape":"ActivityId",
          "documentation":"<p>The <code>activityId</code> of the activity task to be canceled.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>RequestCancelActivityTask</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>You cannot use an IAM policy to constrain this action's parameters.</li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "RequestCancelActivityTaskFailedCause":{
      "type":"string",
      "enum":[
        "ACTIVITY_ID_UNKNOWN",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "RequestCancelActivityTaskFailedEventAttributes":{
      "type":"structure",
      "required":[
        "activityId",
        "cause",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "activityId":{
          "shape":"ActivityId",
          "documentation":"<p>The activityId provided in the <code>RequestCancelActivityTask</code> decision that failed.</p>"
        },
        "cause":{
          "shape":"RequestCancelActivityTaskFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>RequestCancelActivityTask</code> decision for this cancellation request. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>RequestCancelActivityTaskFailed</code> event.</p>"
    },
    "RequestCancelExternalWorkflowExecutionDecisionAttributes":{
      "type":"structure",
      "required":["workflowId"],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p><b>Required.</b> The <code>workflowId</code> of the external workflow execution to cancel.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The <code>runId</code> of the external workflow execution to cancel.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent workflow tasks.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>RequestCancelExternalWorkflowExecution</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>You cannot use an IAM policy to constrain this action's parameters.</li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "RequestCancelExternalWorkflowExecutionFailedCause":{
      "type":"string",
      "enum":[
        "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION",
        "REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "RequestCancelExternalWorkflowExecutionFailedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowId",
        "cause",
        "initiatedEventId",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The <code>workflowId</code> of the external workflow to which the cancel request was to be delivered.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The <code>runId</code> of the external workflow execution.</p>"
        },
        "cause":{
          "shape":"RequestCancelExternalWorkflowExecutionFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "initiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>RequestCancelExternalWorkflowExecutionInitiated</code> event corresponding to the <code>RequestCancelExternalWorkflowExecution</code> decision to cancel this external workflow execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>RequestCancelExternalWorkflowExecution</code> decision for this cancellation request. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "control":{"shape":"Data"}
      },
      "documentation":"<p>Provides details of the <code>RequestCancelExternalWorkflowExecutionFailed</code> event.</p>"
    },
    "RequestCancelExternalWorkflowExecutionInitiatedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowId",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The <code>workflowId</code> of the external workflow execution to be canceled.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The <code>runId</code> of the external workflow execution to be canceled.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>RequestCancelExternalWorkflowExecution</code> decision for this cancellation request. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent workflow tasks.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>RequestCancelExternalWorkflowExecutionInitiated</code> event.</p>"
    },
    "RequestCancelWorkflowExecutionInput":{
      "type":"structure",
      "required":[
        "domain",
        "workflowId"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain containing the workflow execution to cancel.</p>"
        },
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The workflowId of the workflow execution to cancel.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The runId of the workflow execution to cancel.</p>"
        }
      }
    },
    "RespondActivityTaskCanceledInput":{
      "type":"structure",
      "required":["taskToken"],
      "members":{
        "taskToken":{
          "shape":"TaskToken",
          "documentation":"<p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p> <important><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</important>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Information about the cancellation.</p>"
        }
      }
    },
    "RespondActivityTaskCompletedInput":{
      "type":"structure",
      "required":["taskToken"],
      "members":{
        "taskToken":{
          "shape":"TaskToken",
          "documentation":"<p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p> <important> <code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</important>"
        },
        "result":{
          "shape":"Data",
          "documentation":"<p>The result of the activity task. It is a free form string that is implementation specific.</p>"
        }
      }
    },
    "RespondActivityTaskFailedInput":{
      "type":"structure",
      "required":["taskToken"],
      "members":{
        "taskToken":{
          "shape":"TaskToken",
          "documentation":"<p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p> <important> <code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</important>"
        },
        "reason":{
          "shape":"FailureReason",
          "documentation":"<p>Description of the error that may assist in diagnostics.</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Detailed information about the failure.</p>"
        }
      }
    },
    "RespondDecisionTaskCompletedInput":{
      "type":"structure",
      "required":["taskToken"],
      "members":{
        "taskToken":{
          "shape":"TaskToken",
          "documentation":"<p>The <code>taskToken</code> from the <a>DecisionTask</a>.</p> <important><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</important>"
        },
        "decisions":{
          "shape":"DecisionList",
          "documentation":"<p>The list of decisions (possibly empty) made by the decider while processing this decision task. See the docs for the decision structure for details.</p>"
        },
        "executionContext":{
          "shape":"Data",
          "documentation":"<p>User defined context to add to workflow execution.</p>"
        }
      }
    },
    "ReverseOrder":{"type":"boolean"},
    "Run":{
      "type":"structure",
      "members":{
        "runId":{
          "shape":"RunId",
          "documentation":"<p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>"
        }
      },
      "documentation":"<p>Specifies the <code>runId</code> of a workflow execution.</p>"
    },
    "RunId":{
      "type":"string",
      "min":1,
      "max":64
    },
    "RunIdOptional":{
      "type":"string",
      "max":64
    },
    "ScheduleActivityTaskDecisionAttributes":{
      "type":"structure",
      "required":[
        "activityType",
        "activityId"
      ],
      "members":{
        "activityType":{
          "shape":"ActivityType",
          "documentation":"<p><b>Required.</b> The type of the activity task to schedule.</p>"
        },
        "activityId":{
          "shape":"ActivityId",
          "documentation":"<p><b>Required.</b> The <code>activityId</code> of the activity task.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent workflow tasks. This data is not sent to the activity.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>The input provided to the activity task.</p>"
        },
        "scheduleToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum duration for this activity task.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p> <note>A schedule-to-close timeout for this activity task must be specified either as a default for the activity type or through this field. If neither this field is set nor a default schedule-to-close timeout was specified at registration time then a fault will be returned.</note>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>If set, specifies the name of the task list in which to schedule the activity task. If not specified, the <code>defaultTaskList</code> registered with the activity type will be used.</p> <note>A task list for this activity task must be specified either as a default for the activity type or through this field. If neither this field is set nor a default task list was specified at registration time then a fault will be returned.</note> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "taskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p><i>Optional.</i> If set, specifies the priority with which the activity task is to be assigned to a worker. This overrides the defaultTaskPriority specified when registering the activity type using <a>RegisterActivityType</a>. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "scheduleToStartTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p><i>Optional.</i> If set, specifies the maximum duration the activity task can wait to be assigned to a worker. This overrides the default schedule-to-start timeout specified when registering the activity type using <a>RegisterActivityType</a>.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p> <note>A schedule-to-start timeout for this activity task must be specified either as a default for the activity type or through this field. If neither this field is set nor a default schedule-to-start timeout was specified at registration time then a fault will be returned.</note>"
        },
        "startToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the maximum duration a worker may take to process this activity task. This overrides the default start-to-close timeout specified when registering the activity type using <a>RegisterActivityType</a>.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p> <note>A start-to-close timeout for this activity task must be specified either as a default for the activity type or through this field. If neither this field is set nor a default start-to-close timeout was specified at registration time then a fault will be returned.</note>"
        },
        "heartbeatTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the maximum time before which a worker processing a task of this type must report progress by calling <a>RecordActivityTaskHeartbeat</a>. If the timeout is exceeded, the activity task is automatically timed out. If the worker subsequently attempts to record a heartbeat or returns a result, it will be ignored. This overrides the default heartbeat timeout specified when registering the activity type using <a>RegisterActivityType</a>.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>ScheduleActivityTask</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>Constrain the following parameters by using a <code>Condition</code> element with the appropriate keys. <ul> <li><code>activityType.name</code>: String constraint. The key is <code>swf:activityType.name</code>.</li> <li><code>activityType.version</code>: String constraint. The key is <code>swf:activityType.version</code>.</li> <li><code>taskList</code>: String constraint. The key is <code>swf:taskList.name</code>.</li> </ul> </li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "ScheduleActivityTaskFailedCause":{
      "type":"string",
      "enum":[
        "ACTIVITY_TYPE_DEPRECATED",
        "ACTIVITY_TYPE_DOES_NOT_EXIST",
        "ACTIVITY_ID_ALREADY_IN_USE",
        "OPEN_ACTIVITIES_LIMIT_EXCEEDED",
        "ACTIVITY_CREATION_RATE_EXCEEDED",
        "DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED",
        "DEFAULT_TASK_LIST_UNDEFINED",
        "DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED",
        "DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED",
        "DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "ScheduleActivityTaskFailedEventAttributes":{
      "type":"structure",
      "required":[
        "activityType",
        "activityId",
        "cause",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "activityType":{
          "shape":"ActivityType",
          "documentation":"<p>The activity type provided in the <code>ScheduleActivityTask</code> decision that failed.</p>"
        },
        "activityId":{
          "shape":"ActivityId",
          "documentation":"<p>The activityId provided in the <code>ScheduleActivityTask</code> decision that failed.</p>"
        },
        "cause":{
          "shape":"ScheduleActivityTaskFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision that resulted in the scheduling of this activity task. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>ScheduleActivityTaskFailed</code> event.</p>"
    },
    "ScheduleLambdaFunctionDecisionAttributes":{
      "type":"structure",
      "required":[
        "id",
        "name"
      ],
      "members":{
        "id":{
          "shape":"FunctionId",
          "documentation":"<p><b>Required.</b> The SWF <code>id</code> of the AWS Lambda task.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "name":{
          "shape":"FunctionName",
          "documentation":"<p><b>Required.</b> The name of the AWS Lambda function to invoke.</p>"
        },
        "input":{
          "shape":"FunctionInput",
          "documentation":"<p>The input provided to the AWS Lambda function.</p>"
        },
        "startToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>If set, specifies the maximum duration the function may take to execute.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>ScheduleLambdaFunction</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>Constrain the following parameters by using a <code>Condition</code> element with the appropriate keys. <ul> <li><code>activityType.name</code>: String constraint. The key is <code>swf:activityType.name</code>.</li> <li><code>activityType.version</code>: String constraint. The key is <code>swf:activityType.version</code>.</li> <li><code>taskList</code>: String constraint. The key is <code>swf:taskList.name</code>.</li> </ul> </li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "ScheduleLambdaFunctionFailedCause":{
      "type":"string",
      "enum":[
        "ID_ALREADY_IN_USE",
        "OPEN_LAMBDA_FUNCTIONS_LIMIT_EXCEEDED",
        "LAMBDA_FUNCTION_CREATION_RATE_EXCEEDED",
        "LAMBDA_SERVICE_NOT_AVAILABLE_IN_REGION"
      ]
    },
    "ScheduleLambdaFunctionFailedEventAttributes":{
      "type":"structure",
      "required":[
        "id",
        "name",
        "cause",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "id":{
          "shape":"FunctionId",
          "documentation":"<p>The unique Amazon SWF ID of the AWS Lambda task.</p>"
        },
        "name":{
          "shape":"FunctionName",
          "documentation":"<p>The name of the scheduled AWS Lambda function.</p>"
        },
        "cause":{
          "shape":"ScheduleLambdaFunctionFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision that resulted in the scheduling of this AWS Lambda function. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>ScheduleLambdaFunctionFailed</code> event.</p>"
    },
    "SignalExternalWorkflowExecutionDecisionAttributes":{
      "type":"structure",
      "required":[
        "workflowId",
        "signalName"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p><b>Required.</b> The <code>workflowId</code> of the workflow execution to be signaled.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The <code>runId</code> of the workflow execution to be signaled.</p>"
        },
        "signalName":{
          "shape":"SignalName",
          "documentation":"<p><b>Required.</b> The name of the signal.The target workflow execution will use the signal name and input to process the signal.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Input data to be provided with the signal. The target workflow execution will use the signal name and input data to process the signal.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent decision tasks.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>SignalExternalWorkflowExecution</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>You cannot use an IAM policy to constrain this action's parameters.</li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "SignalExternalWorkflowExecutionFailedCause":{
      "type":"string",
      "enum":[
        "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "SignalExternalWorkflowExecutionFailedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowId",
        "cause",
        "initiatedEventId",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The <code>workflowId</code> of the external workflow execution that the signal was being delivered to.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The <code>runId</code> of the external workflow execution that the signal was being delivered to.</p>"
        },
        "cause":{
          "shape":"SignalExternalWorkflowExecutionFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "initiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>SignalExternalWorkflowExecutionInitiated</code> event corresponding to the <code>SignalExternalWorkflowExecution</code> decision to request this signal. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>SignalExternalWorkflowExecution</code> decision for this signal. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "control":{"shape":"Data"}
      },
      "documentation":"<p>Provides details of the <code>SignalExternalWorkflowExecutionFailed</code> event.</p>"
    },
    "SignalExternalWorkflowExecutionInitiatedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowId",
        "signalName",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The <code>workflowId</code> of the external workflow execution.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The <code>runId</code> of the external workflow execution to send the signal to.</p>"
        },
        "signalName":{
          "shape":"SignalName",
          "documentation":"<p>The name of the signal.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>Input provided to the signal (if any).</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>SignalExternalWorkflowExecution</code> decision for this signal. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> data attached to the event that can be used by the decider in subsequent decision tasks.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>SignalExternalWorkflowExecutionInitiated</code> event.</p>"
    },
    "SignalName":{
      "type":"string",
      "min":1,
      "max":256
    },
    "SignalWorkflowExecutionInput":{
      "type":"structure",
      "required":[
        "domain",
        "workflowId",
        "signalName"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain containing the workflow execution to signal.</p>"
        },
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The workflowId of the workflow execution to signal.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The runId of the workflow execution to signal.</p>"
        },
        "signalName":{
          "shape":"SignalName",
          "documentation":"<p>The name of the signal. This name must be meaningful to the target workflow.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>Data to attach to the <code>WorkflowExecutionSignaled</code> event in the target workflow execution's history.</p>"
        }
      }
    },
    "StartChildWorkflowExecutionDecisionAttributes":{
      "type":"structure",
      "required":[
        "workflowType",
        "workflowId"
      ],
      "members":{
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p><b>Required.</b> The type of the workflow execution to be started.</p>"
        },
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p><b>Required.</b> The <code>workflowId</code> of the workflow execution.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent workflow tasks. This data is not sent to the child workflow execution.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>The input to be provided to the workflow execution.</p>"
        },
        "executionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The total duration for this workflow execution. This overrides the defaultExecutionStartToCloseTimeout specified when registering the workflow type.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p> <note>An execution start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default execution start-to-close timeout was specified at registration time then a fault will be returned.</note>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>The name of the task list to be used for decision tasks of the child workflow execution.</p> <note>A task list for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task list was specified at registration time then a fault will be returned.</note> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "taskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p><i>Optional.</i> A task priority that, if set, specifies the priority for a decision task of this workflow execution. This overrides the defaultTaskPriority specified when registering the workflow type. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "taskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>Specifies the maximum duration of decision tasks for this workflow execution. This parameter overrides the <code>defaultTaskStartToCloseTimout</code> specified when registering the workflow type using <a>RegisterWorkflowType</a>.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p> <note>A task start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task start-to-close timeout was specified at registration time then a fault will be returned.</note>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p><i>Optional.</i> If set, specifies the policy to use for the child workflow executions if the workflow execution being started is terminated by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout. This policy overrides the default child policy specified when registering the workflow type using <a>RegisterWorkflowType</a>.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul> <note>A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned.</note>"
        },
        "tagList":{
          "shape":"TagList",
          "documentation":"<p>The list of tags to associate with the child workflow execution. A maximum of 5 tags can be specified. You can list workflow executions with a specific tag by calling <a>ListOpenWorkflowExecutions</a> or <a>ListClosedWorkflowExecutions</a> and specifying a <a>TagFilter</a>.</p>"
        },
        "lambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The ARN of an IAM role that authorizes Amazon SWF to invoke AWS Lambda functions.</p> <note>In order for this workflow execution to invoke AWS Lambda functions, an appropriate IAM role must be specified either as a default for the workflow type or through this field.</note>"
        }
      },
      "documentation":"<p>Provides details of the <code>StartChildWorkflowExecution</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>Constrain the following parameters by using a <code>Condition</code> element with the appropriate keys. <ul> <li> <code>tagList.member.N</code>: The key is \"swf:tagList.N\" where N is the tag number from 0 to 4, inclusive.</li> <li><code>taskList</code>: String constraint. The key is <code>swf:taskList.name</code>.</li> <li><code>workflowType.name</code>: String constraint. The key is <code>swf:workflowType.name</code>.</li> <li><code>workflowType.version</code>: String constraint. The key is <code>swf:workflowType.version</code>.</li> </ul> </li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "StartChildWorkflowExecutionFailedCause":{
      "type":"string",
      "enum":[
        "WORKFLOW_TYPE_DOES_NOT_EXIST",
        "WORKFLOW_TYPE_DEPRECATED",
        "OPEN_CHILDREN_LIMIT_EXCEEDED",
        "OPEN_WORKFLOWS_LIMIT_EXCEEDED",
        "CHILD_CREATION_RATE_EXCEEDED",
        "WORKFLOW_ALREADY_RUNNING",
        "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED",
        "DEFAULT_TASK_LIST_UNDEFINED",
        "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED",
        "DEFAULT_CHILD_POLICY_UNDEFINED",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "StartChildWorkflowExecutionFailedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowType",
        "cause",
        "workflowId",
        "initiatedEventId",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The workflow type provided in the <code>StartChildWorkflowExecution</code> decision that failed.</p>"
        },
        "cause":{
          "shape":"StartChildWorkflowExecutionFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The <code>workflowId</code> of the child workflow execution.</p>"
        },
        "initiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>StartChildWorkflowExecutionInitiated</code> event corresponding to the <code>StartChildWorkflowExecution</code> decision to start this child workflow execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>StartChildWorkflowExecution</code> decision to request this child workflow execution. This information can be useful for diagnosing problems by tracing back the cause of events.</p>"
        },
        "control":{"shape":"Data"}
      },
      "documentation":"<p>Provides details of the <code>StartChildWorkflowExecutionFailed</code> event.</p>"
    },
    "StartChildWorkflowExecutionInitiatedEventAttributes":{
      "type":"structure",
      "required":[
        "workflowId",
        "workflowType",
        "taskList",
        "decisionTaskCompletedEventId",
        "childPolicy"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The <code>workflowId</code> of the child workflow execution.</p>"
        },
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The type of the child workflow execution.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent decision tasks. This data is not sent to the activity.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>The inputs provided to the child workflow execution (if any).</p>"
        },
        "executionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum duration for the child workflow execution. If the workflow execution is not closed within this duration, it will be timed out and force terminated.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>The name of the task list used for the decision tasks of the child workflow execution.</p>"
        },
        "taskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p><i>Optional.</i> The priority assigned for the decision tasks for this workflow execution. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>StartChildWorkflowExecution</code> decision to request this child workflow execution. This information can be useful for diagnosing problems by tracing back the cause of events.</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>The policy to use for the child workflow executions if this execution gets terminated by explicitly calling the <a>TerminateWorkflowExecution</a> action or due to an expired timeout.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "taskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum duration allowed for the decision tasks for this workflow execution.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "tagList":{
          "shape":"TagList",
          "documentation":"<p>The list of tags to associated with the child workflow execution.</p>"
        },
        "lambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The IAM role attached to this workflow execution to use when invoking AWS Lambda functions.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>StartChildWorkflowExecutionInitiated</code> event.</p>"
    },
    "StartLambdaFunctionFailedCause":{
      "type":"string",
      "enum":["ASSUME_ROLE_FAILED"]
    },
    "StartLambdaFunctionFailedEventAttributes":{
      "type":"structure",
      "members":{
        "scheduledEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>LambdaFunctionScheduled</code> event that was recorded when this AWS Lambda function was scheduled. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "cause":{
          "shape":"StartLambdaFunctionFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "message":{
          "shape":"CauseMessage",
          "documentation":"<p>The error message (if any).</p>"
        }
      },
      "documentation":"<p>Provides details for the <code>StartLambdaFunctionFailed</code> event.</p>"
    },
    "StartTimerDecisionAttributes":{
      "type":"structure",
      "required":[
        "timerId",
        "startToFireTimeout"
      ],
      "members":{
        "timerId":{
          "shape":"TimerId",
          "documentation":"<p><b>Required.</b> The unique ID of the timer.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent workflow tasks.</p>"
        },
        "startToFireTimeout":{
          "shape":"DurationInSeconds",
          "documentation":"<p><b>Required.</b> The duration to wait before firing the timer.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>StartTimer</code> decision.</p> <p><b>Access Control</b></p> <p>You can use IAM policies to control this decision's access to Amazon SWF resources as follows:</p> <ul> <li>Use a <code>Resource</code> element with the domain name to limit the action to only specified domains.</li> <li>Use an <code>Action</code> element to allow or deny permission to call this action.</li> <li>You cannot use an IAM policy to constrain this action's parameters.</li> </ul> <p>If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's <b>cause</b> parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</p>"
    },
    "StartTimerFailedCause":{
      "type":"string",
      "enum":[
        "TIMER_ID_ALREADY_IN_USE",
        "OPEN_TIMERS_LIMIT_EXCEEDED",
        "TIMER_CREATION_RATE_EXCEEDED",
        "OPERATION_NOT_PERMITTED"
      ]
    },
    "StartTimerFailedEventAttributes":{
      "type":"structure",
      "required":[
        "timerId",
        "cause",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "timerId":{
          "shape":"TimerId",
          "documentation":"<p>The timerId provided in the <code>StartTimer</code> decision that failed.</p>"
        },
        "cause":{
          "shape":"StartTimerFailedCause",
          "documentation":"<p>The cause of the failure. This information is generated by the system and can be useful for diagnostic purposes.</p> <note>If <b>cause</b> is set to OPERATION_NOT_PERMITTED, the decision failed because it lacked sufficient permissions. For details and example IAM policies, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html\">Using IAM to Manage Access to Amazon SWF Workflows</a>.</note>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>StartTimer</code> decision for this activity task. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>StartTimerFailed</code> event.</p>"
    },
    "StartWorkflowExecutionInput":{
      "type":"structure",
      "required":[
        "domain",
        "workflowId",
        "workflowType"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The name of the domain in which the workflow execution is created.</p>"
        },
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The user defined identifier associated with the workflow execution. You can use this to associate a custom identifier with the workflow execution. You may specify the same identifier if a workflow execution is logically a <i>restart</i> of a previous execution. You cannot have two open workflow executions with the same <code>workflowId</code> at the same time.</p> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The type of the workflow to start.</p>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>The task list to use for the decision tasks generated for this workflow execution. This overrides the <code>defaultTaskList</code> specified when registering the workflow type.</p> <note>A task list for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task list was specified at registration time then a fault will be returned.</note> <p>The specified string must not start or end with whitespace. It must not contain a <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any control characters (\\u0000-\\u001f | \\u007f - \\u009f). Also, it must not contain the literal string quotarnquot.</p>"
        },
        "taskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p>The task priority to use for this workflow execution. This will override any default priority that was assigned when the workflow type was registered. If not set, then the default task priority for the workflow type will be used. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>The input for the workflow execution. This is a free form string which should be meaningful to the workflow you are starting. This <code>input</code> is made available to the new workflow execution in the <code>WorkflowExecutionStarted</code> history event.</p>"
        },
        "executionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The total duration for this workflow execution. This overrides the defaultExecutionStartToCloseTimeout specified when registering the workflow type.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. Exceeding this limit will cause the workflow execution to time out. Unlike some of the other timeout parameters in Amazon SWF, you cannot specify a value of \"NONE\" for this timeout; there is a one-year max limit on the time that a workflow execution can run.</p> <note> An execution start-to-close timeout must be specified either through this parameter or as a default when the workflow type is registered. If neither this parameter nor a default execution start-to-close timeout is specified, a fault is returned.</note>"
        },
        "tagList":{
          "shape":"TagList",
          "documentation":"<p>The list of tags to associate with the workflow execution. You can specify a maximum of 5 tags. You can list workflow executions with a specific tag by calling <a>ListOpenWorkflowExecutions</a> or <a>ListClosedWorkflowExecutions</a> and specifying a <a>TagFilter</a>.</p>"
        },
        "taskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>Specifies the maximum duration of decision tasks for this workflow execution. This parameter overrides the <code>defaultTaskStartToCloseTimout</code> specified when registering the workflow type using <a>RegisterWorkflowType</a>.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p> <note>A task start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task start-to-close timeout was specified at registration time then a fault will be returned.</note>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>If set, specifies the policy to use for the child workflow executions of this workflow execution if it is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout. This policy overrides the default child policy specified when registering the workflow type using <a>RegisterWorkflowType</a>.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul> <note>A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned.</note>"
        },
        "lambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The ARN of an IAM role that authorizes Amazon SWF to invoke AWS Lambda functions.</p> <note>In order for this workflow execution to invoke AWS Lambda functions, an appropriate IAM role must be specified either as a default for the workflow type or through this field.</note>"
        }
      }
    },
    "Tag":{
      "type":"string",
      "min":1,
      "max":256
    },
    "TagFilter":{
      "type":"structure",
      "required":["tag"],
      "members":{
        "tag":{
          "shape":"Tag",
          "documentation":"<p><b>Required.</b> Specifies the tag that must be associated with the execution for it to meet the filter criteria.</p>"
        }
      },
      "documentation":"<p>Used to filter the workflow executions in visibility APIs based on a tag.</p>"
    },
    "TagList":{
      "type":"list",
      "member":{"shape":"Tag"},
      "max":5
    },
    "TaskList":{
      "type":"structure",
      "required":["name"],
      "members":{
        "name":{
          "shape":"Name",
          "documentation":"<p>The name of the task list.</p>"
        }
      },
      "documentation":"<p>Represents a task list.</p>"
    },
    "TaskPriority":{
      "type":"string",
      "max":11
    },
    "TaskToken":{
      "type":"string",
      "min":1,
      "max":1024
    },
    "TerminateReason":{
      "type":"string",
      "max":256
    },
    "TerminateWorkflowExecutionInput":{
      "type":"structure",
      "required":[
        "domain",
        "workflowId"
      ],
      "members":{
        "domain":{
          "shape":"DomainName",
          "documentation":"<p>The domain of the workflow execution to terminate.</p>"
        },
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The workflowId of the workflow execution to terminate.</p>"
        },
        "runId":{
          "shape":"RunIdOptional",
          "documentation":"<p>The runId of the workflow execution to terminate.</p>"
        },
        "reason":{
          "shape":"TerminateReason",
          "documentation":"<p><i>Optional.</i> A descriptive reason for terminating the workflow execution.</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Details for terminating the workflow execution.</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>If set, specifies the policy to use for the child workflow executions of the workflow execution being terminated. This policy overrides the child policy specified for the workflow execution at registration time or when starting the execution.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul> <note>A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned.</note>"
        }
      }
    },
    "TimerCanceledEventAttributes":{
      "type":"structure",
      "required":[
        "timerId",
        "startedEventId",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "timerId":{
          "shape":"TimerId",
          "documentation":"<p> The unique ID of the timer that was canceled. </p>"
        },
        "startedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>TimerStarted</code> event that was recorded when this timer was started. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>CancelTimer</code> decision to cancel this timer. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p> Provides details of the <code>TimerCanceled</code> event. </p>"
    },
    "TimerFiredEventAttributes":{
      "type":"structure",
      "required":[
        "timerId",
        "startedEventId"
      ],
      "members":{
        "timerId":{
          "shape":"TimerId",
          "documentation":"<p>The unique ID of the timer that fired.</p>"
        },
        "startedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>TimerStarted</code> event that was recorded when this timer was started. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>TimerFired</code> event.</p>"
    },
    "TimerId":{
      "type":"string",
      "min":1,
      "max":256
    },
    "TimerStartedEventAttributes":{
      "type":"structure",
      "required":[
        "timerId",
        "startToFireTimeout",
        "decisionTaskCompletedEventId"
      ],
      "members":{
        "timerId":{
          "shape":"TimerId",
          "documentation":"<p>The unique ID of the timer that was started.</p>"
        },
        "control":{
          "shape":"Data",
          "documentation":"<p><i>Optional.</i> Data attached to the event that can be used by the decider in subsequent workflow tasks.</p>"
        },
        "startToFireTimeout":{
          "shape":"DurationInSeconds",
          "documentation":"<p>The duration of time after which the timer will fire.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>StartTimer</code> decision for this activity task. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>TimerStarted</code> event.</p>"
    },
    "Timestamp":{"type":"timestamp"},
    "Truncated":{"type":"boolean"},
    "TypeAlreadyExistsFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned if the type already exists in the specified domain. You will get this fault even if the existing type is in deprecated status. You can specify another version if the intent is to create a new distinct version of the type.</p>"
    },
    "TypeDeprecatedFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned when the specified activity or workflow type was already deprecated.</p>"
    },
    "UnknownResourceFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>"
    },
    "Version":{
      "type":"string",
      "min":1,
      "max":64
    },
    "VersionOptional":{
      "type":"string",
      "max":64
    },
    "WorkflowExecution":{
      "type":"structure",
      "required":[
        "workflowId",
        "runId"
      ],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The user defined identifier associated with the workflow execution.</p>"
        },
        "runId":{
          "shape":"RunId",
          "documentation":"<p>A system-generated unique identifier for the workflow execution.</p>"
        }
      },
      "documentation":"<p>Represents a workflow execution.</p>"
    },
    "WorkflowExecutionAlreadyStartedFault":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ErrorMessage",
          "documentation":"<p>A description that may help with diagnosing the cause of the fault.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Returned by <a>StartWorkflowExecution</a> when an open execution with the same workflowId is already running in the specified domain.</p>"
    },
    "WorkflowExecutionCancelRequestedCause":{
      "type":"string",
      "enum":["CHILD_POLICY_APPLIED"]
    },
    "WorkflowExecutionCancelRequestedEventAttributes":{
      "type":"structure",
      "members":{
        "externalWorkflowExecution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>The external workflow execution for which the cancellation was requested.</p>"
        },
        "externalInitiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>RequestCancelExternalWorkflowExecutionInitiated</code> event corresponding to the <code>RequestCancelExternalWorkflowExecution</code> decision to cancel this workflow execution.The source event with this ID can be found in the history of the source workflow execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "cause":{
          "shape":"WorkflowExecutionCancelRequestedCause",
          "documentation":"<p>If set, indicates that the request to cancel the workflow execution was automatically generated, and specifies the cause. This happens if the parent workflow execution times out or is terminated, and the child policy is set to cancel child executions.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionCancelRequested</code> event.</p>"
    },
    "WorkflowExecutionCanceledEventAttributes":{
      "type":"structure",
      "required":["decisionTaskCompletedEventId"],
      "members":{
        "details":{
          "shape":"Data",
          "documentation":"<p>Details for the cancellation (if any).</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>CancelWorkflowExecution</code> decision for this cancellation request. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionCanceled</code> event.</p>"
    },
    "WorkflowExecutionCompletedEventAttributes":{
      "type":"structure",
      "required":["decisionTaskCompletedEventId"],
      "members":{
        "result":{
          "shape":"Data",
          "documentation":"<p>The result produced by the workflow execution upon successful completion.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>CompleteWorkflowExecution</code> decision to complete this execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionCompleted</code> event.</p>"
    },
    "WorkflowExecutionConfiguration":{
      "type":"structure",
      "required":[
        "taskStartToCloseTimeout",
        "executionStartToCloseTimeout",
        "taskList",
        "childPolicy"
      ],
      "members":{
        "taskStartToCloseTimeout":{
          "shape":"DurationInSeconds",
          "documentation":"<p>The maximum duration allowed for decision tasks for this workflow execution.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "executionStartToCloseTimeout":{
          "shape":"DurationInSeconds",
          "documentation":"<p>The total duration for this workflow execution.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>The task list used for the decision tasks generated for this workflow execution.</p>"
        },
        "taskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p>The priority assigned to decision tasks for this workflow execution. Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>The policy to use for the child workflow executions if this workflow execution is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "lambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The IAM role used by this workflow execution when invoking AWS Lambda functions.</p>"
        }
      },
      "documentation":"<p>The configuration settings for a workflow execution including timeout values, tasklist etc. These configuration settings are determined from the defaults specified when registering the workflow type and those specified when starting the workflow execution.</p>"
    },
    "WorkflowExecutionContinuedAsNewEventAttributes":{
      "type":"structure",
      "required":[
        "decisionTaskCompletedEventId",
        "newExecutionRunId",
        "taskList",
        "childPolicy",
        "workflowType"
      ],
      "members":{
        "input":{
          "shape":"Data",
          "documentation":"<p>The input provided to the new workflow execution.</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>ContinueAsNewWorkflowExecution</code> decision that started this execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "newExecutionRunId":{
          "shape":"RunId",
          "documentation":"<p>The <code>runId</code> of the new workflow execution.</p>"
        },
        "executionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The total duration allowed for the new workflow execution.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "taskList":{"shape":"TaskList"},
        "taskPriority":{"shape":"TaskPriority"},
        "taskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum duration of decision tasks for the new workflow execution.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>The policy to use for the child workflow executions of the new execution if it is terminated by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "tagList":{
          "shape":"TagList",
          "documentation":"<p>The list of tags associated with the new workflow execution.</p>"
        },
        "workflowType":{"shape":"WorkflowType"},
        "lambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The IAM role attached to this workflow execution to use when invoking AWS Lambda functions.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionContinuedAsNew</code> event.</p>"
    },
    "WorkflowExecutionCount":{
      "type":"structure",
      "required":["count"],
      "members":{
        "count":{
          "shape":"Count",
          "documentation":"<p>The number of workflow executions.</p>"
        },
        "truncated":{
          "shape":"Truncated",
          "documentation":"<p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>"
        }
      },
      "documentation":"<p>Contains the count of workflow executions returned from <a>CountOpenWorkflowExecutions</a> or <a>CountClosedWorkflowExecutions</a></p>"
    },
    "WorkflowExecutionDetail":{
      "type":"structure",
      "required":[
        "executionInfo",
        "executionConfiguration",
        "openCounts"
      ],
      "members":{
        "executionInfo":{
          "shape":"WorkflowExecutionInfo",
          "documentation":"<p>Information about the workflow execution.</p>"
        },
        "executionConfiguration":{
          "shape":"WorkflowExecutionConfiguration",
          "documentation":"<p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>"
        },
        "openCounts":{
          "shape":"WorkflowExecutionOpenCounts",
          "documentation":"<p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>"
        },
        "latestActivityTaskTimestamp":{
          "shape":"Timestamp",
          "documentation":"<p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>"
        },
        "latestExecutionContext":{
          "shape":"Data",
          "documentation":"<p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <a>RespondDecisionTaskCompleted</a>.</p>"
        }
      },
      "documentation":"<p>Contains details about a workflow execution.</p>"
    },
    "WorkflowExecutionFailedEventAttributes":{
      "type":"structure",
      "required":["decisionTaskCompletedEventId"],
      "members":{
        "reason":{
          "shape":"FailureReason",
          "documentation":"<p>The descriptive reason provided for the failure (if any).</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p>The details of the failure (if any).</p>"
        },
        "decisionTaskCompletedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>DecisionTaskCompleted</code> event corresponding to the decision task that resulted in the <code>FailWorkflowExecution</code> decision to fail this execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionFailed</code> event.</p>"
    },
    "WorkflowExecutionFilter":{
      "type":"structure",
      "required":["workflowId"],
      "members":{
        "workflowId":{
          "shape":"WorkflowId",
          "documentation":"<p>The workflowId to pass of match the criteria of this filter.</p>"
        }
      },
      "documentation":"<p>Used to filter the workflow executions in visibility APIs by their <code>workflowId</code>.</p>"
    },
    "WorkflowExecutionInfo":{
      "type":"structure",
      "required":[
        "execution",
        "workflowType",
        "startTimestamp",
        "executionStatus"
      ],
      "members":{
        "execution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>The workflow execution this information is about.</p>"
        },
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The type of the workflow execution.</p>"
        },
        "startTimestamp":{
          "shape":"Timestamp",
          "documentation":"<p>The time when the execution was started.</p>"
        },
        "closeTimestamp":{
          "shape":"Timestamp",
          "documentation":"<p>The time when the workflow execution was closed. Set only if the execution status is CLOSED.</p>"
        },
        "executionStatus":{
          "shape":"ExecutionStatus",
          "documentation":"<p>The current status of the execution.</p>"
        },
        "closeStatus":{
          "shape":"CloseStatus",
          "documentation":"<p>If the execution status is closed then this specifies how the execution was closed:</p> <ul> <li> <code>COMPLETED</code>: the execution was successfully completed.</li> <li> <code>CANCELED</code>: the execution was canceled.Cancellation allows the implementation to gracefully clean up before the execution is closed.</li> <li> <code>TERMINATED</code>: the execution was force terminated.</li> <li> <code>FAILED</code>: the execution failed to complete.</li> <li> <code>TIMED_OUT</code>: the execution did not complete in the alloted time and was automatically timed out.</li> <li> <code>CONTINUED_AS_NEW</code>: the execution is logically continued. This means the current execution was completed and a new execution was started to carry on the workflow.</li> </ul>"
        },
        "parent":{
          "shape":"WorkflowExecution",
          "documentation":"<p>If this workflow execution is a child of another execution then contains the workflow execution that started this execution.</p>"
        },
        "tagList":{
          "shape":"TagList",
          "documentation":"<p>The list of tags associated with the workflow execution. Tags can be used to identify and list workflow executions of interest through the visibility APIs. A workflow execution can have a maximum of 5 tags.</p>"
        },
        "cancelRequested":{
          "shape":"Canceled",
          "documentation":"<p>Set to true if a cancellation is requested for this workflow execution.</p>"
        }
      },
      "documentation":"<p>Contains information about a workflow execution. </p>"
    },
    "WorkflowExecutionInfoList":{
      "type":"list",
      "member":{"shape":"WorkflowExecutionInfo"}
    },
    "WorkflowExecutionInfos":{
      "type":"structure",
      "required":["executionInfos"],
      "members":{
        "executionInfos":{
          "shape":"WorkflowExecutionInfoList",
          "documentation":"<p>The list of workflow information structures.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        }
      },
      "documentation":"<p>Contains a paginated list of information about workflow executions.</p>"
    },
    "WorkflowExecutionOpenCounts":{
      "type":"structure",
      "required":[
        "openActivityTasks",
        "openDecisionTasks",
        "openTimers",
        "openChildWorkflowExecutions"
      ],
      "members":{
        "openActivityTasks":{
          "shape":"Count",
          "documentation":"<p>The count of activity tasks whose status is OPEN.</p>"
        },
        "openDecisionTasks":{
          "shape":"OpenDecisionTasksCount",
          "documentation":"<p>The count of decision tasks whose status is OPEN. A workflow execution can have at most one open decision task.</p>"
        },
        "openTimers":{
          "shape":"Count",
          "documentation":"<p>The count of timers started by this workflow execution that have not fired yet.</p>"
        },
        "openChildWorkflowExecutions":{
          "shape":"Count",
          "documentation":"<p>The count of child workflow executions whose status is OPEN.</p>"
        },
        "openLambdaFunctions":{
          "shape":"Count",
          "documentation":"<p>The count of AWS Lambda functions that are currently executing.</p>"
        }
      },
      "documentation":"<p>Contains the counts of open tasks, child workflow executions and timers for a workflow execution.</p>"
    },
    "WorkflowExecutionSignaledEventAttributes":{
      "type":"structure",
      "required":["signalName"],
      "members":{
        "signalName":{
          "shape":"SignalName",
          "documentation":"<p>The name of the signal received. The decider can use the signal name and inputs to determine how to the process the signal.</p>"
        },
        "input":{
          "shape":"Data",
          "documentation":"<p>Inputs provided with the signal (if any). The decider can use the signal name and inputs to determine how to process the signal.</p>"
        },
        "externalWorkflowExecution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>The workflow execution that sent the signal. This is set only of the signal was sent by another workflow execution.</p>"
        },
        "externalInitiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>SignalExternalWorkflowExecutionInitiated</code> event corresponding to the <code>SignalExternalWorkflow</code> decision to signal this workflow execution.The source event with this ID can be found in the history of the source workflow execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event. This field is set only if the signal was initiated by another workflow execution.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionSignaled</code> event.</p>"
    },
    "WorkflowExecutionStartedEventAttributes":{
      "type":"structure",
      "required":[
        "childPolicy",
        "taskList",
        "workflowType"
      ],
      "members":{
        "input":{
          "shape":"Data",
          "documentation":"<p>The input provided to the workflow execution (if any).</p>"
        },
        "executionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum duration for this workflow execution.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "taskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p>The maximum duration of decision tasks for this workflow type.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>The policy to use for the child workflow executions if this workflow execution is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "taskList":{
          "shape":"TaskList",
          "documentation":"<p>The name of the task list for scheduling the decision tasks for this workflow execution.</p>"
        },
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The workflow type of this execution.</p>"
        },
        "tagList":{
          "shape":"TagList",
          "documentation":"<p>The list of tags associated with this workflow execution. An execution can have up to 5 tags.</p>"
        },
        "taskPriority":{"shape":"TaskPriority"},
        "continuedExecutionRunId":{
          "shape":"RunIdOptional",
          "documentation":"<p>If this workflow execution was started due to a <code>ContinueAsNewWorkflowExecution</code> decision, then it contains the <code>runId</code> of the previous workflow execution that was closed and continued as this execution.</p>"
        },
        "parentWorkflowExecution":{
          "shape":"WorkflowExecution",
          "documentation":"<p>The source workflow execution that started this workflow execution. The member is not set if the workflow execution was not started by a workflow.</p>"
        },
        "parentInitiatedEventId":{
          "shape":"EventId",
          "documentation":"<p>The ID of the <code>StartChildWorkflowExecutionInitiated</code> event corresponding to the <code>StartChildWorkflowExecution</code> decision to start this workflow execution. The source event with this ID can be found in the history of the source workflow execution. This information can be useful for diagnosing problems by tracing back the chain of events leading up to this event.</p>"
        },
        "lambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The IAM role attached to this workflow execution to use when invoking AWS Lambda functions.</p>"
        }
      },
      "documentation":"<p>Provides details of <code>WorkflowExecutionStarted</code> event.</p>"
    },
    "WorkflowExecutionTerminatedCause":{
      "type":"string",
      "enum":[
        "CHILD_POLICY_APPLIED",
        "EVENT_LIMIT_EXCEEDED",
        "OPERATOR_INITIATED"
      ]
    },
    "WorkflowExecutionTerminatedEventAttributes":{
      "type":"structure",
      "required":["childPolicy"],
      "members":{
        "reason":{
          "shape":"TerminateReason",
          "documentation":"<p>The reason provided for the termination (if any).</p>"
        },
        "details":{
          "shape":"Data",
          "documentation":"<p>The details provided for the termination (if any).</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>The policy used for the child workflow executions of this workflow execution.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "cause":{
          "shape":"WorkflowExecutionTerminatedCause",
          "documentation":"<p>If set, indicates that the workflow execution was automatically terminated, and specifies the cause. This happens if the parent workflow execution times out or is terminated and the child policy is set to terminate child executions.</p>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionTerminated</code> event.</p>"
    },
    "WorkflowExecutionTimedOutEventAttributes":{
      "type":"structure",
      "required":[
        "timeoutType",
        "childPolicy"
      ],
      "members":{
        "timeoutType":{
          "shape":"WorkflowExecutionTimeoutType",
          "documentation":"<p>The type of timeout that caused this event.</p>"
        },
        "childPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p>The policy used for the child workflow executions of this workflow execution.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        }
      },
      "documentation":"<p>Provides details of the <code>WorkflowExecutionTimedOut</code> event.</p>"
    },
    "WorkflowExecutionTimeoutType":{
      "type":"string",
      "enum":["START_TO_CLOSE"]
    },
    "WorkflowId":{
      "type":"string",
      "min":1,
      "max":256
    },
    "WorkflowType":{
      "type":"structure",
      "required":[
        "name",
        "version"
      ],
      "members":{
        "name":{
          "shape":"Name",
          "documentation":"<p><b>Required.</b> The name of the workflow type.</p> <note>The combination of workflow type name and version must be unique with in a domain.</note>"
        },
        "version":{
          "shape":"Version",
          "documentation":"<p><b>Required.</b> The version of the workflow type.</p> <note>The combination of workflow type name and version must be unique with in a domain.</note>"
        }
      },
      "documentation":"<p>Represents a workflow type.</p>"
    },
    "WorkflowTypeConfiguration":{
      "type":"structure",
      "members":{
        "defaultTaskStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p><i>Optional.</i> The default maximum duration, specified when registering the workflow type, that a decision task for executions of this workflow type might take before returning completion or failure. If the task does not close in the specified time then the task is automatically timed out and rescheduled. If the decider eventually reports a completion or failure, it is ignored. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "defaultExecutionStartToCloseTimeout":{
          "shape":"DurationInSecondsOptional",
          "documentation":"<p><i>Optional.</i> The default maximum duration, specified when registering the workflow type, for executions of this workflow type. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p> <p>The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.</p>"
        },
        "defaultTaskList":{
          "shape":"TaskList",
          "documentation":"<p><i>Optional.</i> The default task list, specified when registering the workflow type, for decisions tasks scheduled for workflow executions of this type. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p>"
        },
        "defaultTaskPriority":{
          "shape":"TaskPriority",
          "documentation":"<p><i>Optional.</i> The default task priority, specified when registering the workflow type, for all decision tasks of this workflow type. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p> <p>Valid values are integers that range from Java's <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647). Higher numbers indicate higher priority.</p> <p>For more information about setting task priority, see <a href=\"http://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html\">Setting Task Priority</a> in the <i>Amazon Simple Workflow Developer Guide</i>.</p>"
        },
        "defaultChildPolicy":{
          "shape":"ChildPolicy",
          "documentation":"<p><i>Optional.</i> The default policy to use for the child workflow executions when a workflow execution of this type is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code> decision.</p> <p>The supported child policies are:</p> <ul> <li><b>TERMINATE:</b> the child executions will be terminated.</li> <li><b>REQUEST_CANCEL:</b> a request to cancel will be attempted for each child execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.</li> <li><b>ABANDON:</b> no action will be taken. The child executions will continue to run.</li> </ul>"
        },
        "defaultLambdaRole":{
          "shape":"Arn",
          "documentation":"<p>The default IAM role to use when a workflow execution invokes a AWS Lambda function.</p>"
        }
      },
      "documentation":"<p>The configuration settings of a workflow type.</p>"
    },
    "WorkflowTypeDetail":{
      "type":"structure",
      "required":[
        "typeInfo",
        "configuration"
      ],
      "members":{
        "typeInfo":{
          "shape":"WorkflowTypeInfo",
          "documentation":"<p>General information about the workflow type.</p> <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p> <ul> <li> <b>REGISTERED</b>: The type is registered and available. Workers supporting this type should be running.</li> <li> <b>DEPRECATED</b>: The type was deprecated using <a>DeprecateWorkflowType</a>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</li> </ul>"
        },
        "configuration":{
          "shape":"WorkflowTypeConfiguration",
          "documentation":"<p>Configuration settings of the workflow type registered through <a>RegisterWorkflowType</a></p>"
        }
      },
      "documentation":"<p>Contains details about a workflow type.</p>"
    },
    "WorkflowTypeFilter":{
      "type":"structure",
      "required":["name"],
      "members":{
        "name":{
          "shape":"Name",
          "documentation":"<p><b>Required.</b> Name of the workflow type.</p>"
        },
        "version":{
          "shape":"VersionOptional",
          "documentation":"<p>Version of the workflow type.</p>"
        }
      },
      "documentation":"<p>Used to filter workflow execution query results by type. Each parameter, if specified, defines a rule that must be satisfied by each returned result.</p>"
    },
    "WorkflowTypeInfo":{
      "type":"structure",
      "required":[
        "workflowType",
        "status",
        "creationDate"
      ],
      "members":{
        "workflowType":{
          "shape":"WorkflowType",
          "documentation":"<p>The workflow type this information is about.</p>"
        },
        "status":{
          "shape":"RegistrationStatus",
          "documentation":"<p>The current status of the workflow type.</p>"
        },
        "description":{
          "shape":"Description",
          "documentation":"<p>The description of the type registered through <a>RegisterWorkflowType</a>.</p>"
        },
        "creationDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date when this type was registered.</p>"
        },
        "deprecationDate":{
          "shape":"Timestamp",
          "documentation":"<p>If the type is in deprecated state, then it is set to the date when the type was deprecated.</p>"
        }
      },
      "documentation":"<p>Contains information about a workflow type.</p>"
    },
    "WorkflowTypeInfoList":{
      "type":"list",
      "member":{"shape":"WorkflowTypeInfo"}
    },
    "WorkflowTypeInfos":{
      "type":"structure",
      "required":["typeInfos"],
      "members":{
        "typeInfos":{
          "shape":"WorkflowTypeInfoList",
          "documentation":"<p>The list of workflow type information.</p>"
        },
        "nextPageToken":{
          "shape":"PageToken",
          "documentation":"<p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p> <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>"
        }
      },
      "documentation":"<p>Contains a paginated list of information structures about workflow types.</p>"
    }
  },
  "examples":{
  }
}
                                                              usr/local/lib/python2.7/dist-packages/botocore/data/waf/                                            0042755 0000000 0000062 00000000000 13077704402 021530  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/waf/2015-08-24/                                 0042755 0000000 0000062 00000000000 13077704402 022567  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/waf/2015-08-24/service-2.json                   0100644 0000000 0000062 00000470752 13077704371 025300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2015-08-24",
    "endpointPrefix":"waf",
    "jsonVersion":"1.1",
    "protocol":"json",
    "serviceAbbreviation":"WAF",
    "serviceFullName":"AWS WAF",
    "signatureVersion":"v4",
    "targetPrefix":"AWSWAF_20150824"
  },
  "operations":{
    "CreateByteMatchSet":{
      "name":"CreateByteMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateByteMatchSetRequest"},
      "output":{"shape":"CreateByteMatchSetResponse"},
      "errors":[
        {"shape":"WAFDisallowedNameException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Creates a <code>ByteMatchSet</code>. You then use <a>UpdateByteMatchSet</a> to identify the part of a web request that you want AWS WAF to inspect, such as the values of the <code>User-Agent</code> header or the query string. For example, you can create a <code>ByteMatchSet</code> that matches any requests with <code>User-Agent</code> headers that contain the string <code>BadBot</code>. You can then configure AWS WAF to reject those requests.</p> <p>To create and configure a <code>ByteMatchSet</code>, perform the following steps:</p> <ol> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>CreateByteMatchSet</code> request.</li> <li>Submit a <code>CreateByteMatchSet</code> request.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <code>UpdateByteMatchSet</code> request.</li> <li>Submit an <a>UpdateByteMatchSet</a> request to specify the part of the request that you want AWS WAF to inspect (for example, the header or the URI) and the value that you want AWS WAF to watch for.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "CreateIPSet":{
      "name":"CreateIPSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateIPSetRequest"},
      "output":{"shape":"CreateIPSetResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFDisallowedNameException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Creates an <a>IPSet</a>, which you use to specify which web requests you want to allow or block based on the IP addresses that the requests originate from. For example, if you're receiving a lot of requests from one or more individual IP addresses or one or more ranges of IP addresses and you want to block the requests, you can create an <code>IPSet</code> that contains those IP addresses and then configure AWS WAF to block the requests. </p> <p>To create and configure an <code>IPSet</code>, perform the following steps:</p> <ol> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>CreateIPSet</code> request.</li> <li>Submit a <code>CreateIPSet</code> request.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateIPSet</a> request.</li> <li>Submit an <code>UpdateIPSet</code> request to specify the IP addresses that you want AWS WAF to watch for.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "CreateRule":{
      "name":"CreateRule",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateRuleRequest"},
      "output":{"shape":"CreateRuleResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFDisallowedNameException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Creates a <code>Rule</code>, which contains the <code>IPSet</code> objects, <code>ByteMatchSet</code> objects, and other predicates that identify the requests that you want to block. If you add more than one predicate to a <code>Rule</code>, a request must match all of the specifications to be allowed or blocked. For example, suppose you add the following to a <code>Rule</code>:</p> <ul> <li>An <code>IPSet</code> that matches the IP address <code>192.0.2.44/32</code></li> <li>A <code>ByteMatchSet</code> that matches <code>BadBot</code> in the <code>User-Agent</code> header</li> </ul> <p>You then add the <code>Rule</code> to a <code>WebACL</code> and specify that you want to blocks requests that satisfy the <code>Rule</code>. For a request to be blocked, it must come from the IP address 192.0.2.44 <i>and</i> the <code>User-Agent</code> header in the request must contain the value <code>BadBot</code>.</p> <p>To create and configure a <code>Rule</code>, perform the following steps:</p> <ol> <li>Create and update the predicates that you want to include in the <code>Rule</code>. For more information, see <a>CreateByteMatchSet</a>, <a>CreateIPSet</a>, and <a>CreateSqlInjectionMatchSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>CreateRule</code> request.</li> <li>Submit a <code>CreateRule</code> request.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateRule</a> request.</li> <li>Submit an <code>UpdateRule</code> request to specify the predicates that you want to include in the <code>Rule</code>.</li> <li>Create and update a <code>WebACL</code> that contains the <code>Rule</code>. For more information, see <a>CreateWebACL</a>.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "CreateSizeConstraintSet":{
      "name":"CreateSizeConstraintSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateSizeConstraintSetRequest"},
      "output":{"shape":"CreateSizeConstraintSetResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFDisallowedNameException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Creates a <code>SizeConstraintSet</code>. You then use <a>UpdateSizeConstraintSet</a> to identify the part of a web request that you want AWS WAF to check for length, such as the length of the <code>User-Agent</code> header or the length of the query string. For example, you can create a <code>SizeConstraintSet</code> that matches any requests that have a query string that is longer than 100 bytes. You can then configure AWS WAF to reject those requests.</p> <p>To create and configure a <code>SizeConstraintSet</code>, perform the following steps:</p> <ol> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>CreateSizeConstraintSet</code> request.</li> <li>Submit a <code>CreateSizeConstraintSet</code> request.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <code>UpdateSizeConstraintSet</code> request.</li> <li>Submit an <a>UpdateSizeConstraintSet</a> request to specify the part of the request that you want AWS WAF to inspect (for example, the header or the URI) and the value that you want AWS WAF to watch for.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "CreateSqlInjectionMatchSet":{
      "name":"CreateSqlInjectionMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateSqlInjectionMatchSetRequest"},
      "output":{"shape":"CreateSqlInjectionMatchSetResponse"},
      "errors":[
        {"shape":"WAFDisallowedNameException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Creates a <a>SqlInjectionMatchSet</a>, which you use to allow, block, or count requests that contain snippets of SQL code in a specified part of web requests. AWS WAF searches for character sequences that are likely to be malicious strings.</p> <p>To create and configure a <code>SqlInjectionMatchSet</code>, perform the following steps:</p> <ol> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>CreateSqlInjectionMatchSet</code> request.</li> <li>Submit a <code>CreateSqlInjectionMatchSet</code> request.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateSqlInjectionMatchSet</a> request.</li> <li>Submit an <a>UpdateSqlInjectionMatchSet</a> request to specify the parts of web requests in which you want to allow, block, or count malicious SQL code.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "CreateWebACL":{
      "name":"CreateWebACL",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateWebACLRequest"},
      "output":{"shape":"CreateWebACLResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFDisallowedNameException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Creates a <code>WebACL</code>, which contains the <code>Rules</code> that identify the CloudFront web requests that you want to allow, block, or count. AWS WAF evaluates <code>Rules</code> in order based on the value of <code>Priority</code> for each <code>Rule</code>.</p> <p>You also specify a default action, either <code>ALLOW</code> or <code>BLOCK</code>. If a web request doesn't match any of the <code>Rules</code> in a <code>WebACL</code>, AWS WAF responds to the request with the default action. </p> <p>To create and configure a <code>WebACL</code>, perform the following steps:</p> <ol> <li>Create and update the <code>ByteMatchSet</code> objects and other predicates that you want to include in <code>Rules</code>. For more information, see <a>CreateByteMatchSet</a>, <a>UpdateByteMatchSet</a>, <a>CreateIPSet</a>, <a>UpdateIPSet</a>, <a>CreateSqlInjectionMatchSet</a>, and <a>UpdateSqlInjectionMatchSet</a>.</li> <li>Create and update the <code>Rules</code> that you want to include in the <code>WebACL</code>. For more information, see <a>CreateRule</a> and <a>UpdateRule</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>CreateWebACL</code> request.</li> <li>Submit a <code>CreateWebACL</code> request.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateWebACL</a> request.</li> <li>Submit an <a>UpdateWebACL</a> request to specify the <code>Rules</code> that you want to include in the <code>WebACL</code>, to specify the default action, and to associate the <code>WebACL</code> with a CloudFront distribution.</li> </ol> <p>For more information about how to use the AWS WAF API, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "DeleteByteMatchSet":{
      "name":"DeleteByteMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteByteMatchSetRequest"},
      "output":{"shape":"DeleteByteMatchSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFNonEmptyEntityException"}
      ],
      "documentation":"<p>Permanently deletes a <a>ByteMatchSet</a>. You can't delete a <code>ByteMatchSet</code> if it's still used in any <code>Rules</code> or if it still includes any <a>ByteMatchTuple</a> objects (any filters).</p> <p>If you just want to remove a <code>ByteMatchSet</code> from a <code>Rule</code>, use <a>UpdateRule</a>.</p> <p>To permanently delete a <code>ByteMatchSet</code>, perform the following steps:</p> <ol> <li>Update the <code>ByteMatchSet</code> to remove filters, if any. For more information, see <a>UpdateByteMatchSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>DeleteByteMatchSet</code> request.</li> <li>Submit a <code>DeleteByteMatchSet</code> request.</li> </ol>"
    },
    "DeleteIPSet":{
      "name":"DeleteIPSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteIPSetRequest"},
      "output":{"shape":"DeleteIPSetResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFNonEmptyEntityException"}
      ],
      "documentation":"<p>Permanently deletes an <a>IPSet</a>. You can't delete an <code>IPSet</code> if it's still used in any <code>Rules</code> or if it still includes any IP addresses.</p> <p>If you just want to remove an <code>IPSet</code> from a <code>Rule</code>, use <a>UpdateRule</a>.</p> <p>To permanently delete an <code>IPSet</code> from AWS WAF, perform the following steps:</p> <ol> <li>Update the <code>IPSet</code> to remove IP address ranges, if any. For more information, see <a>UpdateIPSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>DeleteIPSet</code> request.</li> <li>Submit a <code>DeleteIPSet</code> request.</li> </ol>"
    },
    "DeleteRule":{
      "name":"DeleteRule",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteRuleRequest"},
      "output":{"shape":"DeleteRuleResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFNonEmptyEntityException"}
      ],
      "documentation":"<p>Permanently deletes a <a>Rule</a>. You can't delete a <code>Rule</code> if it's still used in any <code>WebACL</code> objects or if it still includes any predicates, such as <code>ByteMatchSet</code> objects.</p> <p>If you just want to remove a <code>Rule</code> from a <code>WebACL</code>, use <a>UpdateWebACL</a>.</p> <p>To permanently delete a <code>Rule</code> from AWS WAF, perform the following steps:</p> <ol> <li>Update the <code>Rule</code> to remove predicates, if any. For more information, see <a>UpdateRule</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>DeleteRule</code> request.</li> <li>Submit a <code>DeleteRule</code> request.</li> </ol>"
    },
    "DeleteSizeConstraintSet":{
      "name":"DeleteSizeConstraintSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteSizeConstraintSetRequest"},
      "output":{"shape":"DeleteSizeConstraintSetResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFNonEmptyEntityException"}
      ],
      "documentation":"<p>Permanently deletes a <a>SizeConstraintSet</a>. You can't delete a <code>SizeConstraintSet</code> if it's still used in any <code>Rules</code> or if it still includes any <a>SizeConstraint</a> objects (any filters).</p> <p>If you just want to remove a <code>SizeConstraintSet</code> from a <code>Rule</code>, use <a>UpdateRule</a>.</p> <p>To permanently delete a <code>SizeConstraintSet</code>, perform the following steps:</p> <ol> <li>Update the <code>SizeConstraintSet</code> to remove filters, if any. For more information, see <a>UpdateSizeConstraintSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>DeleteSizeConstraintSet</code> request.</li> <li>Submit a <code>DeleteSizeConstraintSet</code> request.</li> </ol>"
    },
    "DeleteSqlInjectionMatchSet":{
      "name":"DeleteSqlInjectionMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteSqlInjectionMatchSetRequest"},
      "output":{"shape":"DeleteSqlInjectionMatchSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFNonEmptyEntityException"}
      ],
      "documentation":"<p>Permanently deletes a <a>SqlInjectionMatchSet</a>. You can't delete a <code>SqlInjectionMatchSet</code> if it's still used in any <code>Rules</code> or if it still contains any <a>SqlInjectionMatchTuple</a> objects.</p> <p>If you just want to remove a <code>SqlInjectionMatchSet</code> from a <code>Rule</code>, use <a>UpdateRule</a>.</p> <p>To permanently delete a <code>SqlInjectionMatchSet</code> from AWS WAF, perform the following steps:</p> <ol> <li>Update the <code>SqlInjectionMatchSet</code> to remove filters, if any. For more information, see <a>UpdateSqlInjectionMatchSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>DeleteSqlInjectionMatchSet</code> request.</li> <li>Submit a <code>DeleteSqlInjectionMatchSet</code> request.</li> </ol>"
    },
    "DeleteWebACL":{
      "name":"DeleteWebACL",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteWebACLRequest"},
      "output":{"shape":"DeleteWebACLResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFNonEmptyEntityException"}
      ],
      "documentation":"<p>Permanently deletes a <a>WebACL</a>. You can't delete a <code>WebACL</code> if it still contains any <code>Rules</code>.</p> <p>To delete a <code>WebACL</code>, perform the following steps:</p> <ol> <li>Update the <code>WebACL</code> to remove <code>Rules</code>, if any. For more information, see <a>UpdateWebACL</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of a <code>DeleteWebACL</code> request.</li> <li>Submit a <code>DeleteWebACL</code> request.</li> </ol>"
    },
    "GetByteMatchSet":{
      "name":"GetByteMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetByteMatchSetRequest"},
      "output":{"shape":"GetByteMatchSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"}
      ],
      "documentation":"<p>Returns the <a>ByteMatchSet</a> specified by <code>ByteMatchSetId</code>.</p>"
    },
    "GetChangeToken":{
      "name":"GetChangeToken",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetChangeTokenRequest"},
      "output":{"shape":"GetChangeTokenResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"}
      ],
      "documentation":"<p>When you want to create, update, or delete AWS WAF objects, get a change token and include the change token in the create, update, or delete request. Change tokens ensure that your application doesn't submit conflicting requests to AWS WAF.</p> <p>Each create, update, or delete request must use a unique change token. If your application submits a <code>GetChangeToken</code> request and then submits a second <code>GetChangeToken</code> request before submitting a create, update, or delete request, the second <code>GetChangeToken</code> request returns the same value as the first <code>GetChangeToken</code> request.</p> <p>When you use a change token in a create, update, or delete request, the status of the change token changes to <code>PENDING</code>, which indicates that AWS WAF is propagating the change to all AWS WAF servers. Use <code>GetChangeTokenStatus</code> to determine the status of your change token.</p>"
    },
    "GetChangeTokenStatus":{
      "name":"GetChangeTokenStatus",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetChangeTokenStatusRequest"},
      "output":{"shape":"GetChangeTokenStatusResponse"},
      "errors":[
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFInternalErrorException"}
      ],
      "documentation":"<p>Returns the status of a <code>ChangeToken</code> that you got by calling <a>GetChangeToken</a>. <code>ChangeTokenStatus</code> is one of the following values:</p> <ul> <li><code>PROVISIONED</code>: You requested the change token by calling <code>GetChangeToken</code>, but you haven't used it yet in a call to create, update, or delete an AWS WAF object.</li> <li><code>PENDING</code>: AWS WAF is propagating the create, update, or delete request to all AWS WAF servers.</li> <li><code>IN_SYNC</code>: Propagation is complete.</li> </ul>"
    },
    "GetIPSet":{
      "name":"GetIPSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetIPSetRequest"},
      "output":{"shape":"GetIPSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"}
      ],
      "documentation":"<p>Returns the <a>IPSet</a> that is specified by <code>IPSetId</code>.</p>"
    },
    "GetRule":{
      "name":"GetRule",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetRuleRequest"},
      "output":{"shape":"GetRuleResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"}
      ],
      "documentation":"<p>Returns the <a>Rule</a> that is specified by the <code>RuleId</code> that you included in the <code>GetRule</code> request.</p>"
    },
    "GetSampledRequests":{
      "name":"GetSampledRequests",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetSampledRequestsRequest"},
      "output":{"shape":"GetSampledRequestsResponse"},
      "errors":[
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFInternalErrorException"}
      ],
      "documentation":"<p>Gets detailed information about a specified number of requests--a sample--that AWS WAF randomly selects from among the first 5,000 requests that your AWS resource received during a time range that you choose. You can specify a sample size of up to 100 requests, and you can specify any time range in the previous three hours.</p> <p><code>GetSampledRequests</code> returns a time range, which is usually the time range that you specified. However, if your resource (such as a CloudFront distribution) received 5,000 requests before the specified time range elapsed, <code>GetSampledRequests</code> returns an updated time range. This new time range indicates the actual period during which AWS WAF selected the requests in the sample.</p>"
    },
    "GetSizeConstraintSet":{
      "name":"GetSizeConstraintSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetSizeConstraintSetRequest"},
      "output":{"shape":"GetSizeConstraintSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"}
      ],
      "documentation":"<p>Returns the <a>SizeConstraintSet</a> specified by <code>SizeConstraintSetId</code>.</p>"
    },
    "GetSqlInjectionMatchSet":{
      "name":"GetSqlInjectionMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetSqlInjectionMatchSetRequest"},
      "output":{"shape":"GetSqlInjectionMatchSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"}
      ],
      "documentation":"<p>Returns the <a>SqlInjectionMatchSet</a> that is specified by <code>SqlInjectionMatchSetId</code>.</p>"
    },
    "GetWebACL":{
      "name":"GetWebACL",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetWebACLRequest"},
      "output":{"shape":"GetWebACLResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFNonexistentItemException"}
      ],
      "documentation":"<p>Returns the <a>WebACL</a> that is specified by <code>WebACLId</code>.</p>"
    },
    "ListByteMatchSets":{
      "name":"ListByteMatchSets",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListByteMatchSetsRequest"},
      "output":{"shape":"ListByteMatchSetsResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"}
      ],
      "documentation":"<p>Returns an array of <a>ByteMatchSetSummary</a> objects.</p>"
    },
    "ListIPSets":{
      "name":"ListIPSets",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListIPSetsRequest"},
      "output":{"shape":"ListIPSetsResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"}
      ],
      "documentation":"<p>Returns an array of <a>IPSetSummary</a> objects in the response.</p>"
    },
    "ListRules":{
      "name":"ListRules",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListRulesRequest"},
      "output":{"shape":"ListRulesResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"}
      ],
      "documentation":"<p>Returns an array of <a>RuleSummary</a> objects.</p>"
    },
    "ListSizeConstraintSets":{
      "name":"ListSizeConstraintSets",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListSizeConstraintSetsRequest"},
      "output":{"shape":"ListSizeConstraintSetsResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"}
      ],
      "documentation":"<p>Returns an array of <a>SizeConstraintSetSummary</a> objects.</p>"
    },
    "ListSqlInjectionMatchSets":{
      "name":"ListSqlInjectionMatchSets",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListSqlInjectionMatchSetsRequest"},
      "output":{"shape":"ListSqlInjectionMatchSetsResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"}
      ],
      "documentation":"<p>Returns an array of <a>SqlInjectionMatchSet</a> objects.</p>"
    },
    "ListWebACLs":{
      "name":"ListWebACLs",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListWebACLsRequest"},
      "output":{"shape":"ListWebACLsResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"}
      ],
      "documentation":"<p>Returns an array of <a>WebACLSummary</a> objects in the response.</p>"
    },
    "UpdateByteMatchSet":{
      "name":"UpdateByteMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateByteMatchSetRequest"},
      "output":{"shape":"UpdateByteMatchSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidOperationException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFNonexistentContainerException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Inserts or deletes <a>ByteMatchTuple</a> objects (filters) in a <a>ByteMatchSet</a>. For each <code>ByteMatchTuple</code> object, you specify the following values: </p> <ul> <li>Whether to insert or delete the object from the array. If you want to change a <code>ByteMatchSetUpdate</code> object, you delete the existing object and add a new one.</li> <li>The part of a web request that you want AWS WAF to inspect, such as a query string or the value of the <code>User-Agent</code> header. </li> <li>The bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to look for. For more information, including how you specify the values for the AWS WAF API and the AWS CLI or SDKs, see <code>TargetString</code> in the <a>ByteMatchTuple</a> data type. </li> <li>Where to look, such as at the beginning or the end of a query string.</li> <li>Whether to perform any conversions on the request, such as converting it to lowercase, before inspecting it for the specified string.</li> </ul> <p>For example, you can add a <code>ByteMatchSetUpdate</code> object that matches web requests in which <code>User-Agent</code> headers contain the string <code>BadBot</code>. You can then configure AWS WAF to block those requests.</p> <p>To create and configure a <code>ByteMatchSet</code>, perform the following steps:</p> <ol> <li>Create a <code>ByteMatchSet.</code> For more information, see <a>CreateByteMatchSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <code>UpdateByteMatchSet</code> request.</li> <li>Submit an <code>UpdateByteMatchSet</code> request to specify the part of the request that you want AWS WAF to inspect (for example, the header or the URI) and the value that you want AWS WAF to watch for.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "UpdateIPSet":{
      "name":"UpdateIPSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateIPSetRequest"},
      "output":{"shape":"UpdateIPSetResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidOperationException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFNonexistentContainerException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Inserts or deletes <a>IPSetDescriptor</a> objects in an <code>IPSet</code>. For each <code>IPSetDescriptor</code> object, you specify the following values: </p> <ul> <li>Whether to insert or delete the object from the array. If you want to change an <code>IPSetDescriptor</code> object, you delete the existing object and add a new one.</li> <li>The IP address version, <code>IPv4</code>. </li> <li>The IP address in CIDR notation, for example, <code>192.0.2.0/24</code> (for the range of IP addresses from <code>192.0.2.0</code> to <code>192.0.2.255</code>) or <code>192.0.2.44/32</code> (for the individual IP address <code>192.0.2.44</code>). </li> </ul> <p>AWS WAF supports /8, /16, /24, and /32 IP address ranges. For more information about CIDR notation, see the Wikipedia entry <a href=\"https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\">Classless Inter-Domain Routing</a>.</p> <p>You use an <code>IPSet</code> to specify which web requests you want to allow or block based on the IP addresses that the requests originated from. For example, if you're receiving a lot of requests from one or a small number of IP addresses and you want to block the requests, you can create an <code>IPSet</code> that specifies those IP addresses, and then configure AWS WAF to block the requests. </p> <p>To create and configure an <code>IPSet</code>, perform the following steps:</p> <ol> <li>Submit a <a>CreateIPSet</a> request.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateIPSet</a> request.</li> <li>Submit an <code>UpdateIPSet</code> request to specify the IP addresses that you want AWS WAF to watch for.</li> </ol> <p>When you update an <code>IPSet</code>, you specify the IP addresses that you want to add and/or the IP addresses that you want to delete. If you want to change an IP address, you delete the existing IP address and add the new one.</p> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "UpdateRule":{
      "name":"UpdateRule",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateRuleRequest"},
      "output":{"shape":"UpdateRuleResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidOperationException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFNonexistentContainerException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Inserts or deletes <a>Predicate</a> objects in a <code>Rule</code>. Each <code>Predicate</code> object identifies a predicate, such as a <a>ByteMatchSet</a> or an <a>IPSet</a>, that specifies the web requests that you want to allow, block, or count. If you add more than one predicate to a <code>Rule</code>, a request must match all of the specifications to be allowed, blocked, or counted. For example, suppose you add the following to a <code>Rule</code>: </p> <ul> <li>A <code>ByteMatchSet</code> that matches the value <code>BadBot</code> in the <code>User-Agent</code> header</li> <li>An <code>IPSet</code> that matches the IP address <code>192.0.2.44</code></li> </ul> <p>You then add the <code>Rule</code> to a <code>WebACL</code> and specify that you want to block requests that satisfy the <code>Rule</code>. For a request to be blocked, the <code>User-Agent</code> header in the request must contain the value <code>BadBot</code> <i>and</i> the request must originate from the IP address 192.0.2.44.</p> <p>To create and configure a <code>Rule</code>, perform the following steps:</p> <ol> <li>Create and update the predicates that you want to include in the <code>Rule</code>.</li> <li>Create the <code>Rule</code>. See <a>CreateRule</a>.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateRule</a> request.</li> <li>Submit an <code>UpdateRule</code> request to add predicates to the <code>Rule</code>.</li> <li>Create and update a <code>WebACL</code> that contains the <code>Rule</code>. See <a>CreateWebACL</a>.</li> </ol> <p>If you want to replace one <code>ByteMatchSet</code> or <code>IPSet</code> with another, you delete the existing one and add the new one.</p> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "UpdateSizeConstraintSet":{
      "name":"UpdateSizeConstraintSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateSizeConstraintSetRequest"},
      "output":{"shape":"UpdateSizeConstraintSetResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidOperationException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFNonexistentContainerException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Inserts or deletes <a>SizeConstraint</a> objects (filters) in a <a>SizeConstraintSet</a>. For each <code>SizeConstraint</code> object, you specify the following values: </p> <ul> <li>Whether to insert or delete the object from the array. If you want to change a <code>SizeConstraintSetUpdate</code> object, you delete the existing object and add a new one.</li> <li>The part of a web request that you want AWS WAF to evaluate, such as the length of a query string or the length of the <code>User-Agent</code> header.</li> <li>Whether to perform any transformations on the request, such as converting it to lowercase, before checking its length. Note that transformations of the request body are not supported because the AWS resource forwards only the first <code>8192</code> bytes of your request to AWS WAF.</li> <li>A <code>ComparisonOperator</code> used for evaluating the selected part of the request against the specified <code>Size</code>, such as equals, greater than, less than, and so on.</li> <li>The length, in bytes, that you want AWS WAF to watch for in selected part of the request. The length is computed after applying the transformation.</li> </ul> <p>For example, you can add a <code>SizeConstraintSetUpdate</code> object that matches web requests in which the length of the <code>User-Agent</code> header is greater than 100 bytes. You can then configure AWS WAF to block those requests.</p> <p>To create and configure a <code>SizeConstraintSet</code>, perform the following steps:</p> <ol> <li>Create a <code>SizeConstraintSet.</code> For more information, see <a>CreateSizeConstraintSet</a>.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <code>UpdateSizeConstraintSet</code> request.</li> <li>Submit an <code>UpdateSizeConstraintSet</code> request to specify the part of the request that you want AWS WAF to inspect (for example, the header or the URI) and the value that you want AWS WAF to watch for.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "UpdateSqlInjectionMatchSet":{
      "name":"UpdateSqlInjectionMatchSet",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateSqlInjectionMatchSetRequest"},
      "output":{"shape":"UpdateSqlInjectionMatchSetResponse"},
      "errors":[
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidOperationException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFNonexistentContainerException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Inserts or deletes <a>SqlInjectionMatchTuple</a> objects (filters) in a <a>SqlInjectionMatchSet</a>. For each <code>SqlInjectionMatchTuple</code> object, you specify the following values:</p> <ul> <li><code>Action</code>: Whether to insert the object into or delete the object from the array. To change a <code>SqlInjectionMatchTuple</code>, you delete the existing object and add a new one.</li> <li><code>FieldToMatch</code>: The part of web requests that you want AWS WAF to inspect and, if you want AWS WAF to inspect a header, the name of the header.</li> <li><code>TextTransformation</code>: Which text transformation, if any, to perform on the web request before inspecting the request for snippets of malicious SQL code.</li> </ul> <p>You use <code>SqlInjectionMatchSet</code> objects to specify which CloudFront requests you want to allow, block, or count. For example, if you're receiving requests that contain snippets of SQL code in the query string and you want to block the requests, you can create a <code>SqlInjectionMatchSet</code> with the applicable settings, and then configure AWS WAF to block the requests. </p> <p>To create and configure a <code>SqlInjectionMatchSet</code>, perform the following steps:</p> <ol> <li>Submit a <a>CreateSqlInjectionMatchSet</a> request.</li> <li>Use <a>GetChangeToken</a> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateIPSet</a> request.</li> <li>Submit an <code>UpdateSqlInjectionMatchSet</code> request to specify the parts of web requests that you want AWS WAF to inspect for snippets of SQL code.</li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    },
    "UpdateWebACL":{
      "name":"UpdateWebACL",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateWebACLRequest"},
      "output":{"shape":"UpdateWebACLResponse"},
      "errors":[
        {"shape":"WAFStaleDataException"},
        {"shape":"WAFInternalErrorException"},
        {"shape":"WAFInvalidAccountException"},
        {"shape":"WAFInvalidOperationException"},
        {"shape":"WAFInvalidParameterException"},
        {"shape":"WAFNonexistentContainerException"},
        {"shape":"WAFNonexistentItemException"},
        {"shape":"WAFReferencedItemException"},
        {"shape":"WAFLimitsExceededException"}
      ],
      "documentation":"<p>Inserts or deletes <a>ActivatedRule</a> objects in a <code>WebACL</code>. Each <code>Rule</code> identifies web requests that you want to allow, block, or count. When you update a <code>WebACL</code>, you specify the following values:</p> <ul> <li>A default action for the <code>WebACL</code>, either <code>ALLOW</code> or <code>BLOCK</code>. AWS WAF performs the default action if a request doesn't match the criteria in any of the <code>Rules</code> in a <code>WebACL</code>.</li> <li>The <code>Rules</code> that you want to add and/or delete. If you want to replace one <code>Rule</code> with another, you delete the existing <code>Rule</code> and add the new one.</li> <li>For each <code>Rule</code>, whether you want AWS WAF to allow requests, block requests, or count requests that match the conditions in the <code>Rule</code>.</li> <li>The order in which you want AWS WAF to evaluate the <code>Rules</code> in a <code>WebACL</code>. If you add more than one <code>Rule</code> to a <code>WebACL</code>, AWS WAF evaluates each request against the <code>Rules</code> in order based on the value of <code>Priority</code>. (The <code>Rule</code> that has the lowest value for <code>Priority</code> is evaluated first.) When a web request matches all of the predicates (such as <code>ByteMatchSets</code> and <code>IPSets</code>) in a <code>Rule</code>, AWS WAF immediately takes the corresponding action, allow or block, and doesn't evaluate the request against the remaining <code>Rules</code> in the <code>WebACL</code>, if any. </li> <li>The CloudFront distribution that you want to associate with the <code>WebACL</code>.</li> </ul> <p>To create and configure a <code>WebACL</code>, perform the following steps:</p> <ol> <li>Create and update the predicates that you want to include in <code>Rules</code>. For more information, see <a>CreateByteMatchSet</a>, <a>UpdateByteMatchSet</a>, <a>CreateIPSet</a>, <a>UpdateIPSet</a>, <a>CreateSqlInjectionMatchSet</a>, and <a>UpdateSqlInjectionMatchSet</a>.</li> <li>Create and update the <code>Rules</code> that you want to include in the <code>WebACL</code>. For more information, see <a>CreateRule</a> and <a>UpdateRule</a>.</li> <li>Create a <code>WebACL</code>. See <a>CreateWebACL</a>.</li> <li>Use <code>GetChangeToken</code> to get the change token that you provide in the <code>ChangeToken</code> parameter of an <a>UpdateWebACL</a> request.</li> <li>Submit an <code>UpdateWebACL</code> request to specify the <code>Rules</code> that you want to include in the <code>WebACL</code>, to specify the default action, and to associate the <code>WebACL</code> with a CloudFront distribution. </li> </ol> <p>For more information about how to use the AWS WAF API to allow or block HTTP requests, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
    }
  },
  "shapes":{
    "Action":{"type":"string"},
    "ActivatedRule":{
      "type":"structure",
      "required":[
        "Priority",
        "RuleId",
        "Action"
      ],
      "members":{
        "Priority":{
          "shape":"RulePriority",
          "documentation":"<p>Specifies the order in which the <code>Rules</code> in a <code>WebACL</code> are evaluated. Rules with a lower value for <code>Priority</code> are evaluated before <code>Rules</code> with a higher value. The value must be a unique integer. If you add multiple <code>Rules</code> to a <code>WebACL</code>, the values don't need to be consecutive.</p>"
        },
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>RuleId</code> for a <code>Rule</code>. You use <code>RuleId</code> to get more information about a <code>Rule</code> (see <a>GetRule</a>), update a <code>Rule</code> (see <a>UpdateRule</a>), insert a <code>Rule</code> into a <code>WebACL</code> or delete a one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>Rule</code> from AWS WAF (see <a>DeleteRule</a>).</p> <p><code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>"
        },
        "Action":{
          "shape":"WafAction",
          "documentation":"<p>Specifies the action that CloudFront or AWS WAF takes when a web request matches the conditions in the <code>Rule</code>. Valid values for <code>Action</code> include the following:</p> <ul> <li><code>ALLOW</code>: CloudFront responds with the requested object.</li> <li><code>BLOCK</code>: CloudFront responds with an HTTP 403 (Forbidden) status code.</li> <li><code>COUNT</code>: AWS WAF increments a counter of requests that match the conditions in the rule and then continues to inspect the web request based on the remaining rules in the web ACL. </li> </ul>"
        }
      },
      "documentation":"<p>The <code>ActivatedRule</code> object in an <a>UpdateWebACL</a> request specifies a <code>Rule</code> that you want to insert or delete, the priority of the <code>Rule</code> in the <code>WebACL</code>, and the action that you want AWS WAF to take when a web request matches the <code>Rule</code> (<code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>).</p> <p>To specify whether to insert or delete a <code>Rule</code>, use the <code>Action</code> parameter in the <a>WebACLUpdate</a> data type.</p>"
    },
    "ActivatedRules":{
      "type":"list",
      "member":{"shape":"ActivatedRule"}
    },
    "ByteMatchSet":{
      "type":"structure",
      "required":[
        "ByteMatchSetId",
        "ByteMatchTuples"
      ],
      "members":{
        "ByteMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>ByteMatchSetId</code> for a <code>ByteMatchSet</code>. You use <code>ByteMatchSetId</code> to get information about a <code>ByteMatchSet</code> (see <a>GetByteMatchSet</a>), update a <code>ByteMatchSet</code> (see <a>UpdateByteMatchSet</a>, insert a <code>ByteMatchSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>ByteMatchSet</code> from AWS WAF (see <a>DeleteByteMatchSet</a>).</p> <p><code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>ByteMatchSet</a>. You can't change <code>Name</code> after you create a <code>ByteMatchSet</code>.</p>"
        },
        "ByteMatchTuples":{
          "shape":"ByteMatchTuples",
          "documentation":"<p>Specifies the bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings.</p>"
        }
      },
      "documentation":"<p>In a <a>GetByteMatchSet</a> request, <code>ByteMatchSet</code> is a complex type that contains the <code>ByteMatchSetId</code> and <code>Name</code> of a <code>ByteMatchSet</code>, and the values that you specified when you updated the <code>ByteMatchSet</code>. </p> <p>A complex type that contains <code>ByteMatchTuple</code> objects, which specify the parts of web requests that you want AWS WAF to inspect and the values that you want AWS WAF to search for. If a <code>ByteMatchSet</code> contains more than one <code>ByteMatchTuple</code> object, a request needs to match the settings in only one <code>ByteMatchTuple</code> to be considered a match.</p>"
    },
    "ByteMatchSetSummaries":{
      "type":"list",
      "member":{"shape":"ByteMatchSetSummary"}
    },
    "ByteMatchSetSummary":{
      "type":"structure",
      "required":[
        "ByteMatchSetId",
        "Name"
      ],
      "members":{
        "ByteMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>ByteMatchSetId</code> for a <code>ByteMatchSet</code>. You use <code>ByteMatchSetId</code> to get information about a <code>ByteMatchSet</code>, update a <code>ByteMatchSet</code>, remove a <code>ByteMatchSet</code> from a <code>Rule</code>, and delete a <code>ByteMatchSet</code> from AWS WAF.</p> <p><code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>ByteMatchSet</a>. You can't change <code>Name</code> after you create a <code>ByteMatchSet</code>.</p>"
        }
      },
      "documentation":"<p>Returned by <a>ListByteMatchSets</a>. Each <code>ByteMatchSetSummary</code> object includes the <code>Name</code> and <code>ByteMatchSetId</code> for one <a>ByteMatchSet</a>.</p>"
    },
    "ByteMatchSetUpdate":{
      "type":"structure",
      "required":[
        "Action",
        "ByteMatchTuple"
      ],
      "members":{
        "Action":{
          "shape":"ChangeAction",
          "documentation":"<p>Specifies whether to insert or delete a <a>ByteMatchTuple</a>.</p>"
        },
        "ByteMatchTuple":{
          "shape":"ByteMatchTuple",
          "documentation":"<p>Information about the part of a web request that you want AWS WAF to inspect and the value that you want AWS WAF to search for. If you specify <code>DELETE</code> for the value of <code>Action</code>, the <code>ByteMatchTuple</code> values must exactly match the values in the <code>ByteMatchTuple</code> that you want to delete from the <code>ByteMatchSet</code>.</p>"
        }
      },
      "documentation":"<p>In an <a>UpdateByteMatchSet</a> request, <code>ByteMatchSetUpdate</code> specifies whether to insert or delete a <a>ByteMatchTuple</a> and includes the settings for the <code>ByteMatchTuple</code>.</p>"
    },
    "ByteMatchSetUpdates":{
      "type":"list",
      "member":{"shape":"ByteMatchSetUpdate"}
    },
    "ByteMatchTargetString":{"type":"blob"},
    "ByteMatchTuple":{
      "type":"structure",
      "required":[
        "FieldToMatch",
        "TargetString",
        "TextTransformation",
        "PositionalConstraint"
      ],
      "members":{
        "FieldToMatch":{
          "shape":"FieldToMatch",
          "documentation":"<p>The part of a web request that you want AWS WAF to search, such as a specified header or a query string. For more information, see <a>FieldToMatch</a>.</p>"
        },
        "TargetString":{
          "shape":"ByteMatchTargetString",
          "documentation":"<p>The value that you want AWS WAF to search for. AWS WAF searches for the specified string in the part of web requests that you specified in <code>FieldToMatch</code>. The maximum length of the value is 50 bytes.</p> <p>Valid values depend on the values that you specified for <code>FieldToMatch</code>:</p> <ul> <li><code>HEADER</code>: The value that you want AWS WAF to search for in the request header that you specified in <a>FieldToMatch</a>, for example, the value of the <code>User-Agent</code> or <code>Referer</code> header.</li> <li><code>METHOD</code>: The HTTP method, which indicates the type of operation specified in the request. CloudFront supports the following methods: <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, and <code>PUT</code>.</li> <li><code>QUERY_STRING</code>: The value that you want AWS WAF to search for in the query string, which is the part of a URL that appears after a <code>?</code> character.</li> <li><code>URI</code>: The value that you want AWS WAF to search for in the part of a URL that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</li> <li><code>BODY</code>: The part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. The request body immediately follows the request headers. Note that only the first <code>8192</code> bytes of the request body are forwarded to AWS WAF for inspection. To allow or block requests based on the length of the body, you can create a size constraint set. For more information, see <a>CreateSizeConstraintSet</a>. </li> </ul> <p>If <code>TargetString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p> <p><b>If you're using the AWS WAF API</b></p> <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes. </p> <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the value of <code>Data</code> is <code>User-Agent</code>. If you want to search the <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode <code>BadBot</code> using MIME base64 encoding and include the resulting value, <code>QmFkQm90</code>, in the value of <code>TargetString</code>.</p> <p><b>If you're using the AWS CLI or one of the AWS SDKs</b></p> <p>The value that you want AWS WAF to search for. The SDK automatically base64 encodes the value.</p>"
        },
        "TextTransformation":{
          "shape":"TextTransformation",
          "documentation":"<p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on <code>TargetString</code> before inspecting a request for a match.</p> <p><b>CMD_LINE</b></p> <p>When you're concerned that attackers are injecting an operating system commandline command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:</p> <ul> <li>Delete the following characters: \\ \" ' ^</li> <li>Delete spaces before the following characters: / (</li> <li>Replace the following characters with a space: , ;</li> <li>Replace multiple spaces with one space</li> <li>Convert uppercase letters (A-Z) to lowercase (a-z)</li> </ul> <p><b>COMPRESS_WHITE_SPACE</b></p> <p>Use this option to replace the following characters with a space character (decimal 32):</p> <ul> <li>\\f, formfeed, decimal 12</li> <li>\\t, tab, decimal 9</li> <li>\\n, newline, decimal 10</li> <li>\\r, carriage return, decimal 13</li> <li>\\v, vertical tab, decimal 11</li> <li>non-breaking space, decimal 160</li> </ul> <p><code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p> <p><b>HTML_ENTITY_DECODE</b></p> <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs the following operations:</p> <ul> <li>Replaces <code>(ampersand)quot;</code> with <code>\"</code></li> <li>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</li> <li>Replaces <code>(ampersand)lt;</code> with a \"less than\" symbol</li> <li>Replaces <code>(ampersand)gt;</code> with <code>></code></li> <li>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</li> <li>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</li> </ul> <p><b>LOWERCASE</b></p> <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p> <p><b>URL_DECODE</b></p> <p>Use this option to decode a URL-encoded value.</p> <p><b>NONE</b></p> <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>"
        },
        "PositionalConstraint":{
          "shape":"PositionalConstraint",
          "documentation":"<p>Within the portion of a web request that you want to search (for example, in the query string, if any), specify where you want AWS WAF to search. Valid values include the following:</p> <p><b>CONTAINS</b></p> <p>The specified part of the web request must include the value of <code>TargetString</code>, but the location doesn't matter.</p> <p><b>CONTAINS_WORD</b></p> <p>The specified part of the web request must include the value of <code>TargetString</code>, and <code>TargetString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, <code>TargetString</code> must be a word, which means one of the following:</p> <ul> <li><code>TargetString</code> exactly matches the value of the specified part of the web request, such as the value of a header.</li> <li><code>TargetString</code> is at the beginning of the specified part of the web request and is followed by a character other than an alphanumeric character or underscore (_), for example, <code>BadBot;</code>.</li> <li><code>TargetString</code> is at the end of the specified part of the web request and is preceded by a character other than an alphanumeric character or underscore (_), for example, <code>;BadBot</code>.</li> <li><code>TargetString</code> is in the middle of the specified part of the web request and is preceded and followed by characters other than alphanumeric characters or underscore (_), for example, <code>-BadBot;</code>.</li> </ul> <p><b>EXACTLY</b></p> <p>The value of the specified part of the web request must exactly match the value of <code>TargetString</code>.</p> <p><b>STARTS_WITH</b></p> <p>The value of <code>TargetString</code> must appear at the beginning of the specified part of the web request.</p> <p><b>ENDS_WITH</b></p> <p>The value of <code>TargetString</code> must appear at the end of the specified part of the web request.</p>"
        }
      },
      "documentation":"<p>The bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings.</p>"
    },
    "ByteMatchTuples":{
      "type":"list",
      "member":{"shape":"ByteMatchTuple"}
    },
    "ChangeAction":{
      "type":"string",
      "enum":[
        "INSERT",
        "DELETE"
      ]
    },
    "ChangeToken":{"type":"string"},
    "ChangeTokenStatus":{
      "type":"string",
      "enum":[
        "PROVISIONED",
        "PENDING",
        "INSYNC"
      ]
    },
    "ComparisonOperator":{
      "type":"string",
      "enum":[
        "EQ",
        "NE",
        "LE",
        "LT",
        "GE",
        "GT"
      ]
    },
    "Country":{"type":"string"},
    "CreateByteMatchSetRequest":{
      "type":"structure",
      "required":[
        "Name",
        "ChangeToken"
      ],
      "members":{
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>ByteMatchSet</a>. You can't change <code>Name</code> after you create a <code>ByteMatchSet</code>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "CreateByteMatchSetResponse":{
      "type":"structure",
      "members":{
        "ByteMatchSet":{
          "shape":"ByteMatchSet",
          "documentation":"<p>A <a>ByteMatchSet</a> that contains no <code>ByteMatchTuple</code> objects.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>CreateByteMatchSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "CreateIPSetRequest":{
      "type":"structure",
      "required":[
        "Name",
        "ChangeToken"
      ],
      "members":{
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>IPSet</a>. You can't change <code>Name</code> after you create the <code>IPSet</code>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "CreateIPSetResponse":{
      "type":"structure",
      "members":{
        "IPSet":{
          "shape":"IPSet",
          "documentation":"<p>The <a>IPSet</a> returned in the <code>CreateIPSet</code> response.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>CreateIPSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "CreateRuleRequest":{
      "type":"structure",
      "required":[
        "Name",
        "MetricName",
        "ChangeToken"
      ],
      "members":{
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>Rule</a>. You can't change the name of a <code>Rule</code> after you create it.</p>"
        },
        "MetricName":{
          "shape":"MetricName",
          "documentation":"<p>A friendly name or description for the metrics for this <code>Rule</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change the name of the metric after you create the <code>Rule</code>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "CreateRuleResponse":{
      "type":"structure",
      "members":{
        "Rule":{
          "shape":"Rule",
          "documentation":"<p>The <a>Rule</a> returned in the <code>CreateRule</code> response.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>CreateRule</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "CreateSizeConstraintSetRequest":{
      "type":"structure",
      "required":[
        "Name",
        "ChangeToken"
      ],
      "members":{
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>SizeConstraintSet</a>. You can't change <code>Name</code> after you create a <code>SizeConstraintSet</code>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "CreateSizeConstraintSetResponse":{
      "type":"structure",
      "members":{
        "SizeConstraintSet":{
          "shape":"SizeConstraintSet",
          "documentation":"<p>A <a>SizeConstraintSet</a> that contains no <code>SizeConstraint</code> objects.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>CreateSizeConstraintSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "CreateSqlInjectionMatchSetRequest":{
      "type":"structure",
      "required":[
        "Name",
        "ChangeToken"
      ],
      "members":{
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description for the <a>SqlInjectionMatchSet</a> that you're creating. You can't change <code>Name</code> after you create the <code>SqlInjectionMatchSet</code>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      },
      "documentation":"<p>A request to create a <a>SqlInjectionMatchSet</a>.</p>"
    },
    "CreateSqlInjectionMatchSetResponse":{
      "type":"structure",
      "members":{
        "SqlInjectionMatchSet":{
          "shape":"SqlInjectionMatchSet",
          "documentation":"<p>A <a>SqlInjectionMatchSet</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>CreateSqlInjectionMatchSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      },
      "documentation":"<p>The response to a <code>CreateSqlInjectionMatchSet</code> request.</p>"
    },
    "CreateWebACLRequest":{
      "type":"structure",
      "required":[
        "Name",
        "MetricName",
        "DefaultAction",
        "ChangeToken"
      ],
      "members":{
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>WebACL</a>. You can't change <code>Name</code> after you create the <code>WebACL</code>.</p>"
        },
        "MetricName":{
          "shape":"MetricName",
          "documentation":"<p>A friendly name or description for the metrics for this <code>WebACL</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change <code>MetricName</code> after you create the <code>WebACL</code>.</p>"
        },
        "DefaultAction":{
          "shape":"WafAction",
          "documentation":"<p>The action that you want AWS WAF to take when a request doesn't match the criteria specified in any of the <code>Rule</code> objects that are associated with the <code>WebACL</code>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "CreateWebACLResponse":{
      "type":"structure",
      "members":{
        "WebACL":{
          "shape":"WebACL",
          "documentation":"<p>The <a>WebACL</a> returned in the <code>CreateWebACL</code> response.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>CreateWebACL</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "DeleteByteMatchSetRequest":{
      "type":"structure",
      "required":[
        "ByteMatchSetId",
        "ChangeToken"
      ],
      "members":{
        "ByteMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>ByteMatchSetId</code> of the <a>ByteMatchSet</a> that you want to delete. <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "DeleteByteMatchSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>DeleteByteMatchSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "DeleteIPSetRequest":{
      "type":"structure",
      "required":[
        "IPSetId",
        "ChangeToken"
      ],
      "members":{
        "IPSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>IPSetId</code> of the <a>IPSet</a> that you want to delete. <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by <a>ListIPSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "DeleteIPSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>DeleteIPSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "DeleteRuleRequest":{
      "type":"structure",
      "required":[
        "RuleId",
        "ChangeToken"
      ],
      "members":{
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>RuleId</code> of the <a>Rule</a> that you want to delete. <code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "DeleteRuleResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>DeleteRule</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "DeleteSizeConstraintSetRequest":{
      "type":"structure",
      "required":[
        "SizeConstraintSetId",
        "ChangeToken"
      ],
      "members":{
        "SizeConstraintSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>SizeConstraintSetId</code> of the <a>SizeConstraintSet</a> that you want to delete. <code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "DeleteSizeConstraintSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>DeleteSizeConstraintSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "DeleteSqlInjectionMatchSetRequest":{
      "type":"structure",
      "required":[
        "SqlInjectionMatchSetId",
        "ChangeToken"
      ],
      "members":{
        "SqlInjectionMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>SqlInjectionMatchSetId</code> of the <a>SqlInjectionMatchSet</a> that you want to delete. <code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      },
      "documentation":"<p>A request to delete a <a>SqlInjectionMatchSet</a> from AWS WAF.</p>"
    },
    "DeleteSqlInjectionMatchSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>DeleteSqlInjectionMatchSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      },
      "documentation":"<p>The response to a request to delete a <a>SqlInjectionMatchSet</a> from AWS WAF.</p>"
    },
    "DeleteWebACLRequest":{
      "type":"structure",
      "required":[
        "WebACLId",
        "ChangeToken"
      ],
      "members":{
        "WebACLId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>WebACLId</code> of the <a>WebACL</a> that you want to delete. <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        }
      }
    },
    "DeleteWebACLResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>DeleteWebACL</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "FieldToMatch":{
      "type":"structure",
      "required":["Type"],
      "members":{
        "Type":{
          "shape":"MatchFieldType",
          "documentation":"<p>The part of the web request that you want AWS WAF to search for a specified string. Parts of a request that you can search include the following:</p> <ul> <li><code>HEADER</code>: A specified request header, for example, the value of the <code>User-Agent</code> or <code>Referer</code> header. If you choose <code>HEADER</code> for the type, specify the name of the header in <code>Data</code>.</li> <li><code>METHOD</code>: The HTTP method, which indicated the type of operation that the request is asking the origin to perform. Amazon CloudFront supports the following methods: <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, and <code>PUT</code>.</li> <li><code>QUERY_STRING</code>: A query string, which is the part of a URL that appears after a <code>?</code> character, if any.</li> <li><code>URI</code>: The part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</li> <li><code>BODY</code>: The part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. The request body immediately follows the request headers. Note that only the first <code>8192</code> bytes of the request body are forwarded to AWS WAF for inspection. To allow or block requests based on the length of the body, you can create a size constraint set. For more information, see <a>CreateSizeConstraintSet</a>. </li> </ul>"
        },
        "Data":{
          "shape":"MatchFieldData",
          "documentation":"<p>When the value of <code>Type</code> is <code>HEADER</code>, enter the name of the header that you want AWS WAF to search, for example, <code>User-Agent</code> or <code>Referer</code>. If the value of <code>Type</code> is any other value, omit <code>Data</code>.</p> <p>The name of the header is not case sensitive.</p>"
        }
      },
      "documentation":"<p>Specifies where in a web request to look for <code>TargetString</code>.</p>"
    },
    "GetByteMatchSetRequest":{
      "type":"structure",
      "required":["ByteMatchSetId"],
      "members":{
        "ByteMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>ByteMatchSetId</code> of the <a>ByteMatchSet</a> that you want to get. <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>"
        }
      }
    },
    "GetByteMatchSetResponse":{
      "type":"structure",
      "members":{
        "ByteMatchSet":{
          "shape":"ByteMatchSet",
          "documentation":"<p>Information about the <a>ByteMatchSet</a> that you specified in the <code>GetByteMatchSet</code> request. For more information, see the following topics:</p> <ul> <li><a>ByteMatchSet</a>: Contains <code>ByteMatchSetId</code>, <code>ByteMatchTuples</code>, and <code>Name</code></li> <li><code>ByteMatchTuples</code>: Contains an array of <a>ByteMatchTuple</a> objects. Each <code>ByteMatchTuple</code> object contains <a>FieldToMatch</a>, <code>PositionalConstraint</code>, <code>TargetString</code>, and <code>TextTransformation</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      }
    },
    "GetChangeTokenRequest":{
      "type":"structure",
      "members":{
      }
    },
    "GetChangeTokenResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used in the request. Use this value in a <code>GetChangeTokenStatus</code> request to get the current status of the request. </p>"
        }
      }
    },
    "GetChangeTokenStatusRequest":{
      "type":"structure",
      "required":["ChangeToken"],
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The change token for which you want to get the status. This change token was previously returned in the <code>GetChangeToken</code> response.</p>"
        }
      }
    },
    "GetChangeTokenStatusResponse":{
      "type":"structure",
      "members":{
        "ChangeTokenStatus":{
          "shape":"ChangeTokenStatus",
          "documentation":"<p>The status of the change token.</p>"
        }
      }
    },
    "GetIPSetRequest":{
      "type":"structure",
      "required":["IPSetId"],
      "members":{
        "IPSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>IPSetId</code> of the <a>IPSet</a> that you want to get. <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by <a>ListIPSets</a>.</p>"
        }
      }
    },
    "GetIPSetResponse":{
      "type":"structure",
      "members":{
        "IPSet":{
          "shape":"IPSet",
          "documentation":"<p>Information about the <a>IPSet</a> that you specified in the <code>GetIPSet</code> request. For more information, see the following topics:</p> <ul> <li><a>IPSet</a>: Contains <code>IPSetDescriptors</code>, <code>IPSetId</code>, and <code>Name</code></li> <li><code>IPSetDescriptors</code>: Contains an array of <a>IPSetDescriptor</a> objects. Each <code>IPSetDescriptor</code> object contains <code>Type</code> and <code>Value</code></li> </ul>"
        }
      }
    },
    "GetRuleRequest":{
      "type":"structure",
      "required":["RuleId"],
      "members":{
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>RuleId</code> of the <a>Rule</a> that you want to get. <code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>"
        }
      }
    },
    "GetRuleResponse":{
      "type":"structure",
      "members":{
        "Rule":{
          "shape":"Rule",
          "documentation":"<p>Information about the <a>Rule</a> that you specified in the <code>GetRule</code> request. For more information, see the following topics:</p> <ul> <li><a>Rule</a>: Contains <code>MetricName</code>, <code>Name</code>, an array of <code>Predicate</code> objects, and <code>RuleId</code></li> <li><a>Predicate</a>: Each <code>Predicate</code> object contains <code>DataId</code>, <code>Negated</code>, and <code>Type</code></li> </ul>"
        }
      }
    },
    "GetSampledRequestsRequest":{
      "type":"structure",
      "required":[
        "WebAclId",
        "RuleId",
        "TimeWindow",
        "MaxItems"
      ],
      "members":{
        "WebAclId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>WebACLId</code> of the <code>WebACL</code> for which you want <code>GetSampledRequests</code> to return a sample of requests.</p>"
        },
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p><code>RuleId</code> is one of two values:</p> <ul> <li>The <code>RuleId</code> of the <code>Rule</code> for which you want <code>GetSampledRequests</code> to return a sample of requests.</li> <li><code>Default_Action</code>, which causes <code>GetSampledRequests</code> to return a sample of the requests that didn't match any of the rules in the specified <code>WebACL</code>.</li> </ul>"
        },
        "TimeWindow":{
          "shape":"TimeWindow",
          "documentation":"<p>The start date and time and the end date and time of the range for which you want <code>GetSampledRequests</code> to return a sample of requests. Specify the date and time in Unix time format (in seconds). You can specify any time range in the previous three hours.</p>"
        },
        "MaxItems":{
          "shape":"ListMaxItems",
          "documentation":"<p>The number of requests that you want AWS WAF to return from among the first 5,000 requests that your AWS resource received during the time range. If your resource received fewer requests than the value of <code>MaxItems</code>, <code>GetSampledRequests</code> returns information about all of them. </p>"
        }
      }
    },
    "GetSampledRequestsResponse":{
      "type":"structure",
      "members":{
        "SampledRequests":{
          "shape":"SampledHTTPRequests",
          "documentation":"<p>A complex type that contains detailed information about each of the requests in the sample.</p>"
        },
        "PopulationSize":{
          "shape":"PopulationSize",
          "documentation":"<p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests. If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your AWS resource received during the specified time range.</p>"
        },
        "TimeWindow":{
          "shape":"TimeWindow",
          "documentation":"<p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request. However, if your AWS resource received more than 5,000 requests during the time range that you specified in the request, <code>GetSampledRequests</code> returns the time range for the first 5,000 requests.</p>"
        }
      }
    },
    "GetSizeConstraintSetRequest":{
      "type":"structure",
      "required":["SizeConstraintSetId"],
      "members":{
        "SizeConstraintSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>SizeConstraintSetId</code> of the <a>SizeConstraintSet</a> that you want to get. <code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>"
        }
      }
    },
    "GetSizeConstraintSetResponse":{
      "type":"structure",
      "members":{
        "SizeConstraintSet":{
          "shape":"SizeConstraintSet",
          "documentation":"<p>Information about the <a>SizeConstraintSet</a> that you specified in the <code>GetSizeConstraintSet</code> request. For more information, see the following topics:</p> <ul> <li><a>SizeConstraintSet</a>: Contains <code>SizeConstraintSetId</code>, <code>SizeConstraints</code>, and <code>Name</code></li> <li><code>SizeConstraints</code>: Contains an array of <a>SizeConstraint</a> objects. Each <code>SizeConstraint</code> object contains <a>FieldToMatch</a>, <code>TextTransformation</code>, <code>ComparisonOperator</code>, and <code>Size</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      }
    },
    "GetSqlInjectionMatchSetRequest":{
      "type":"structure",
      "required":["SqlInjectionMatchSetId"],
      "members":{
        "SqlInjectionMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>SqlInjectionMatchSetId</code> of the <a>SqlInjectionMatchSet</a> that you want to get. <code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>"
        }
      },
      "documentation":"<p>A request to get a <a>SqlInjectionMatchSet</a>.</p>"
    },
    "GetSqlInjectionMatchSetResponse":{
      "type":"structure",
      "members":{
        "SqlInjectionMatchSet":{
          "shape":"SqlInjectionMatchSet",
          "documentation":"<p>Information about the <a>SqlInjectionMatchSet</a> that you specified in the <code>GetSqlInjectionMatchSet</code> request. For more information, see the following topics:</p> <ul> <li><a>SqlInjectionMatchSet</a>: Contains <code>Name</code>, <code>SqlInjectionMatchSetId</code>, and an array of <code>SqlInjectionMatchTuple</code> objects</li> <li><a>SqlInjectionMatchTuple</a>: Each <code>SqlInjectionMatchTuple</code> object contains <code>FieldToMatch</code> and <code>TextTransformation</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      },
      "documentation":"<p>The response to a <a>GetSqlInjectionMatchSet</a> request.</p>"
    },
    "GetWebACLRequest":{
      "type":"structure",
      "required":["WebACLId"],
      "members":{
        "WebACLId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>WebACLId</code> of the <a>WebACL</a> that you want to get. <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>"
        }
      }
    },
    "GetWebACLResponse":{
      "type":"structure",
      "members":{
        "WebACL":{
          "shape":"WebACL",
          "documentation":"<p>Information about the <a>WebACL</a> that you specified in the <code>GetWebACL</code> request. For more information, see the following topics:</p> <ul> <li><a>WebACL</a>: Contains <code>DefaultAction</code>, <code>MetricName</code>, <code>Name</code>, an array of <code>Rule</code> objects, and <code>WebACLId</code></li> <li><code>DefaultAction</code> (Data type is <a>WafAction</a>): Contains <code>Type</code></li> <li><code>Rules</code>: Contains an array of <code>ActivatedRule</code> objects, which contain <code>Action</code>, <code>Priority</code>, and <code>RuleId</code></li> <li><code>Action</code>: Contains <code>Type</code></li> </ul>"
        }
      }
    },
    "HTTPHeader":{
      "type":"structure",
      "members":{
        "Name":{
          "shape":"HeaderName",
          "documentation":"<p>The name of one of the headers in the sampled web request.</p>"
        },
        "Value":{
          "shape":"HeaderValue",
          "documentation":"<p>The value of one of the headers in the sampled web request.</p>"
        }
      },
      "documentation":"<p>The response from a <a>GetSampledRequests</a> request includes an <code>HTTPHeader</code> complex type that appears as <code>Headers</code> in the response syntax. <code>HTTPHeader</code> contains the names and values of all of the headers that appear in one of the web requests that were returned by <code>GetSampledRequests</code>. </p>"
    },
    "HTTPHeaders":{
      "type":"list",
      "member":{"shape":"HTTPHeader"}
    },
    "HTTPMethod":{"type":"string"},
    "HTTPRequest":{
      "type":"structure",
      "members":{
        "ClientIP":{
          "shape":"IPString",
          "documentation":"<p>The IP address that the request originated from. If the <code>WebACL</code> is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:</p> <ul> <li><code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</li> <li><code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</li> </ul>"
        },
        "Country":{
          "shape":"Country",
          "documentation":"<p>The two-letter country code for the country that the request originated from. For a current list of country codes, see the Wikipedia entry <a href=\"https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\">ISO 3166-1 alpha-2</a>.</p>"
        },
        "URI":{
          "shape":"URIString",
          "documentation":"<p>The part of a web request that identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>"
        },
        "Method":{
          "shape":"HTTPMethod",
          "documentation":"<p>The HTTP method specified in the sampled web request. CloudFront supports the following methods: <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, and <code>PUT</code>. </p>"
        },
        "HTTPVersion":{
          "shape":"HTTPVersion",
          "documentation":"<p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>"
        },
        "Headers":{
          "shape":"HTTPHeaders",
          "documentation":"<p>A complex type that contains two values for each header in the sampled web request: the name of the header and the value of the header.</p>"
        }
      },
      "documentation":"<p>The response from a <a>GetSampledRequests</a> request includes an <code>HTTPRequest</code> complex type that appears as <code>Request</code> in the response syntax. <code>HTTPRequest</code> contains information about one of the web requests that were returned by <code>GetSampledRequests</code>. </p>"
    },
    "HTTPVersion":{"type":"string"},
    "HeaderName":{"type":"string"},
    "HeaderValue":{"type":"string"},
    "IPSet":{
      "type":"structure",
      "required":[
        "IPSetId",
        "IPSetDescriptors"
      ],
      "members":{
        "IPSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>IPSetId</code> for an <code>IPSet</code>. You use <code>IPSetId</code> to get information about an <code>IPSet</code> (see <a>GetIPSet</a>), update an <code>IPSet</code> (see <a>UpdateIPSet</a>), insert an <code>IPSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete an <code>IPSet</code> from AWS WAF (see <a>DeleteIPSet</a>).</p> <p><code>IPSetId</code> is returned by <a>CreateIPSet</a> and by <a>ListIPSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>IPSet</a>. You can't change the name of an <code>IPSet</code> after you create it.</p>"
        },
        "IPSetDescriptors":{
          "shape":"IPSetDescriptors",
          "documentation":"<p>The IP address type (<code>IPV4</code>) and the IP address range (in CIDR notation) that web requests originate from. If the <code>WebACL</code> is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:</p> <ul> <li><code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</li> <li><code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</li> </ul>"
        }
      },
      "documentation":"<p>Contains one or more IP addresses or blocks of IP addresses specified in Classless Inter-Domain Routing (CIDR) notation. To specify an individual IP address, you specify the four-part IP address followed by a <code>/32</code>, for example, 192.0.2.0/31. To block a range of IP addresses, you can specify a <code>/24</code>, a <code>/16</code>, or a <code>/8</code> CIDR. For more information about CIDR notation, perform an Internet search on <code>cidr notation</code>.</p>"
    },
    "IPSetDescriptor":{
      "type":"structure",
      "required":[
        "Type",
        "Value"
      ],
      "members":{
        "Type":{
          "shape":"IPSetDescriptorType",
          "documentation":"<p>Specify <code>IPV4</code>.</p>"
        },
        "Value":{
          "shape":"IPSetDescriptorValue",
          "documentation":"<p>Specify an IPv4 address by using CIDR notation. For example:</p> <ul> <li>To configure AWS WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</li> <li>To configure AWS WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</li> </ul> <p>AWS WAF supports only /8, /16, /24, and /32 IP addresses.</p> <p>For more information about CIDR notation, see the Wikipedia entry <a href=\"https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\">Classless Inter-Domain Routing</a>.</p>"
        }
      },
      "documentation":"<p>Specifies the IP address type (<code>IPV4</code>) and the IP address range (in CIDR format) that web requests originate from.</p>"
    },
    "IPSetDescriptorType":{
      "type":"string",
      "enum":["IPV4"]
    },
    "IPSetDescriptorValue":{"type":"string"},
    "IPSetDescriptors":{
      "type":"list",
      "member":{"shape":"IPSetDescriptor"}
    },
    "IPSetSummaries":{
      "type":"list",
      "member":{"shape":"IPSetSummary"}
    },
    "IPSetSummary":{
      "type":"structure",
      "required":[
        "IPSetId",
        "Name"
      ],
      "members":{
        "IPSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>IPSetId</code> for an <a>IPSet</a>. You can use <code>IPSetId</code> in a <a>GetIPSet</a> request to get detailed information about an <a>IPSet</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>IPSet</a>. You can't change the name of an <code>IPSet</code> after you create it.</p>"
        }
      },
      "documentation":"<p>Contains the identifier and the name of the <code>IPSet</code>.</p>"
    },
    "IPSetUpdate":{
      "type":"structure",
      "required":[
        "Action",
        "IPSetDescriptor"
      ],
      "members":{
        "Action":{
          "shape":"ChangeAction",
          "documentation":"<p>Specifies whether to insert or delete an IP address with <a>UpdateIPSet</a>.</p>"
        },
        "IPSetDescriptor":{
          "shape":"IPSetDescriptor",
          "documentation":"<p>The IP address type (<code>IPV4</code>) and the IP address range (in CIDR notation) that web requests originate from.</p>"
        }
      },
      "documentation":"<p>Specifies the type of update to perform to an <a>IPSet</a> with <a>UpdateIPSet</a>.</p>"
    },
    "IPSetUpdates":{
      "type":"list",
      "member":{"shape":"IPSetUpdate"}
    },
    "IPString":{"type":"string"},
    "ListByteMatchSetsRequest":{
      "type":"structure",
      "required":["Limit"],
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you specify a value for <code>Limit</code> and you have more <code>ByteMatchSets</code> than the value of <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>ByteMatchSets</code>. For the second and subsequent <code>ListByteMatchSets</code> requests, specify the value of <code>NextMarker</code> from the previous response to get information about another batch of <code>ByteMatchSets</code>.</p>"
        },
        "Limit":{
          "shape":"PaginationLimit",
          "documentation":"<p>Specifies the number of <code>ByteMatchSet</code> objects that you want AWS WAF to return for this request. If you have more <code>ByteMatchSets</code> objects than the number you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>ByteMatchSet</code> objects.</p>"
        }
      }
    },
    "ListByteMatchSetsResponse":{
      "type":"structure",
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you have more <code>ByteMatchSet</code> objects than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>ByteMatchSet</code> objects, submit another <code>ListByteMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>"
        },
        "ByteMatchSets":{
          "shape":"ByteMatchSetSummaries",
          "documentation":"<p>An array of <a>ByteMatchSetSummary</a> objects.</p>"
        }
      }
    },
    "ListIPSetsRequest":{
      "type":"structure",
      "required":["Limit"],
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you specify a value for <code>Limit</code> and you have more <code>IPSets</code> than the value of <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>IPSets</code>. For the second and subsequent <code>ListIPSets</code> requests, specify the value of <code>NextMarker</code> from the previous response to get information about another batch of <code>ByteMatchSets</code>.</p>"
        },
        "Limit":{
          "shape":"PaginationLimit",
          "documentation":"<p>Specifies the number of <code>IPSet</code> objects that you want AWS WAF to return for this request. If you have more <code>IPSet</code> objects than the number you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>IPSet</code> objects.</p>"
        }
      }
    },
    "ListIPSetsResponse":{
      "type":"structure",
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you have more <code>IPSet</code> objects than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>IPSet</code> objects, submit another <code>ListIPSets</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>"
        },
        "IPSets":{
          "shape":"IPSetSummaries",
          "documentation":"<p>An array of <a>IPSetSummary</a> objects.</p>"
        }
      }
    },
    "ListMaxItems":{
      "type":"long",
      "max":100,
      "min":1
    },
    "ListRulesRequest":{
      "type":"structure",
      "required":["Limit"],
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you specify a value for <code>Limit</code> and you have more <code>Rules</code> than the value of <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>Rules</code>. For the second and subsequent <code>ListRules</code> requests, specify the value of <code>NextMarker</code> from the previous response to get information about another batch of <code>Rules</code>.</p>"
        },
        "Limit":{
          "shape":"PaginationLimit",
          "documentation":"<p>Specifies the number of <code>Rules</code> that you want AWS WAF to return for this request. If you have more <code>Rules</code> than the number that you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>Rules</code>.</p>"
        }
      }
    },
    "ListRulesResponse":{
      "type":"structure",
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you have more <code>Rules</code> than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>Rules</code>, submit another <code>ListRules</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>"
        },
        "Rules":{
          "shape":"RuleSummaries",
          "documentation":"<p>An array of <a>RuleSummary</a> objects.</p>"
        }
      }
    },
    "ListSizeConstraintSetsRequest":{
      "type":"structure",
      "required":["Limit"],
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you specify a value for <code>Limit</code> and you have more <code>SizeConstraintSets</code> than the value of <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>SizeConstraintSets</code>. For the second and subsequent <code>ListSizeConstraintSets</code> requests, specify the value of <code>NextMarker</code> from the previous response to get information about another batch of <code>SizeConstraintSets</code>.</p>"
        },
        "Limit":{
          "shape":"PaginationLimit",
          "documentation":"<p>Specifies the number of <code>SizeConstraintSet</code> objects that you want AWS WAF to return for this request. If you have more <code>SizeConstraintSets</code> objects than the number you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>SizeConstraintSet</code> objects.</p>"
        }
      }
    },
    "ListSizeConstraintSetsResponse":{
      "type":"structure",
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you have more <code>SizeConstraintSet</code> objects than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>SizeConstraintSet</code> objects, submit another <code>ListSizeConstraintSets</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>"
        },
        "SizeConstraintSets":{
          "shape":"SizeConstraintSetSummaries",
          "documentation":"<p>An array of <a>SizeConstraintSetSummary</a> objects.</p>"
        }
      }
    },
    "ListSqlInjectionMatchSetsRequest":{
      "type":"structure",
      "required":["Limit"],
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you specify a value for <code>Limit</code> and you have more <a>SqlInjectionMatchSet</a> objects than the value of <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>SqlInjectionMatchSets</code>. For the second and subsequent <code>ListSqlInjectionMatchSets</code> requests, specify the value of <code>NextMarker</code> from the previous response to get information about another batch of <code>SqlInjectionMatchSets</code>.</p>"
        },
        "Limit":{
          "shape":"PaginationLimit",
          "documentation":"<p>Specifies the number of <a>SqlInjectionMatchSet</a> objects that you want AWS WAF to return for this request. If you have more <code>SqlInjectionMatchSet</code> objects than the number you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>Rules</code>.</p>"
        }
      },
      "documentation":"<p>A request to list the <a>SqlInjectionMatchSet</a> objects created by the current AWS account.</p>"
    },
    "ListSqlInjectionMatchSetsResponse":{
      "type":"structure",
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you have more <a>SqlInjectionMatchSet</a> objects than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>SqlInjectionMatchSet</code> objects, submit another <code>ListSqlInjectionMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>"
        },
        "SqlInjectionMatchSets":{
          "shape":"SqlInjectionMatchSetSummaries",
          "documentation":"<p>An array of <a>SqlInjectionMatchSetSummary</a> objects.</p>"
        }
      },
      "documentation":"<p>The response to a <a>ListSqlInjectionMatchSets</a> request.</p>"
    },
    "ListWebACLsRequest":{
      "type":"structure",
      "required":["Limit"],
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you specify a value for <code>Limit</code> and you have more <code>WebACL</code> objects than the number that you specify for <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>WebACL</code> objects. For the second and subsequent <code>ListWebACLs</code> requests, specify the value of <code>NextMarker</code> from the previous response to get information about another batch of <code>WebACL</code> objects.</p>"
        },
        "Limit":{
          "shape":"PaginationLimit",
          "documentation":"<p>Specifies the number of <code>WebACL</code> objects that you want AWS WAF to return for this request. If you have more <code>WebACL</code> objects than the number that you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>WebACL</code> objects.</p>"
        }
      }
    },
    "ListWebACLsResponse":{
      "type":"structure",
      "members":{
        "NextMarker":{
          "shape":"NextMarker",
          "documentation":"<p>If you have more <code>WebACL</code> objects than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>WebACL</code> objects, submit another <code>ListWebACLs</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>"
        },
        "WebACLs":{
          "shape":"WebACLSummaries",
          "documentation":"<p>An array of <a>WebACLSummary</a> objects.</p>"
        }
      }
    },
    "MatchFieldData":{"type":"string"},
    "MatchFieldType":{
      "type":"string",
      "enum":[
        "URI",
        "QUERY_STRING",
        "HEADER",
        "METHOD",
        "BODY"
      ]
    },
    "MetricName":{"type":"string"},
    "Negated":{"type":"boolean"},
    "NextMarker":{
      "type":"string",
      "min":1
    },
    "PaginationLimit":{
      "type":"integer",
      "max":100,
      "min":1
    },
    "ParameterExceptionField":{
      "type":"string",
      "enum":[
        "CHANGE_ACTION",
        "WAF_ACTION",
        "PREDICATE_TYPE",
        "IPSET_TYPE",
        "BYTE_MATCH_FIELD_TYPE",
        "SQL_INJECTION_MATCH_FIELD_TYPE",
        "BYTE_MATCH_TEXT_TRANSFORMATION",
        "BYTE_MATCH_POSITIONAL_CONSTRAINT",
        "SIZE_CONSTRAINT_COMPARISON_OPERATOR"
      ]
    },
    "ParameterExceptionParameter":{
      "type":"string",
      "min":1
    },
    "ParameterExceptionReason":{
      "type":"string",
      "enum":[
        "INVALID_OPTION",
        "ILLEGAL_COMBINATION"
      ]
    },
    "PopulationSize":{"type":"long"},
    "PositionalConstraint":{
      "type":"string",
      "enum":[
        "EXACTLY",
        "STARTS_WITH",
        "ENDS_WITH",
        "CONTAINS",
        "CONTAINS_WORD"
      ]
    },
    "Predicate":{
      "type":"structure",
      "required":[
        "Negated",
        "Type",
        "DataId"
      ],
      "members":{
        "Negated":{
          "shape":"Negated",
          "documentation":"<p>Set <code>Negated</code> to <code>False</code> if you want AWS WAF to allow, block, or count requests based on the settings in the specified <a>ByteMatchSet</a>, <a>IPSet</a>, or <a>SqlInjectionMatchSet</a>. For example, if an <code>IPSet</code> includes the IP address <code>192.0.2.44</code>, AWS WAF will allow or block requests based on that IP address.</p> <p>Set <code>Negated</code> to <code>True</code> if you want AWS WAF to allow or block a request based on the negation of the settings in the <a>ByteMatchSet</a>, <a>IPSet</a>, or <a>SqlInjectionMatchSet</a>. For example, if an <code>IPSet</code> includes the IP address <code>192.0.2.44</code>, AWS WAF will allow, block, or count requests based on all IP addresses <i>except</i> <code>192.0.2.44</code>.</p>"
        },
        "Type":{
          "shape":"PredicateType",
          "documentation":"<p>The type of predicate in a <code>Rule</code>, such as <code>ByteMatchSet</code> or <code>IPSet</code>.</p>"
        },
        "DataId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a predicate in a <code>Rule</code>, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>. The ID is returned by the corresponding <code>Create</code> or <code>List</code> command.</p>"
        }
      },
      "documentation":"<p>Specifies the <a>ByteMatchSet</a>, <a>IPSet</a>, and <a>SqlInjectionMatchSet</a> objects that you want to add to a <code>Rule</code> and, for each object, indicates whether you want to negate the settings, for example, requests that do NOT originate from the IP address 192.0.2.44. </p>"
    },
    "PredicateType":{
      "type":"string",
      "enum":[
        "IPMatch",
        "ByteMatch",
        "SqlInjectionMatch",
        "SizeConstraint"
      ]
    },
    "Predicates":{
      "type":"list",
      "member":{"shape":"Predicate"}
    },
    "ResourceId":{
      "type":"string",
      "max":128,
      "min":1
    },
    "ResourceName":{
      "type":"string",
      "max":128,
      "min":1
    },
    "Rule":{
      "type":"structure",
      "required":[
        "RuleId",
        "Predicates"
      ],
      "members":{
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>Rule</code>. You use <code>RuleId</code> to get more information about a <code>Rule</code> (see <a>GetRule</a>), update a <code>Rule</code> (see <a>UpdateRule</a>), insert a <code>Rule</code> into a <code>WebACL</code> or delete a one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>Rule</code> from AWS WAF (see <a>DeleteRule</a>).</p> <p><code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>The friendly name or description for the <code>Rule</code>. You can't change the name of a <code>Rule</code> after you create it.</p>"
        },
        "MetricName":{"shape":"MetricName"},
        "Predicates":{
          "shape":"Predicates",
          "documentation":"<p>The <code>Predicates</code> object contains one <code>Predicate</code> element for each <a>ByteMatchSet</a>, <a>IPSet</a>, or <a>SqlInjectionMatchSet</a> object that you want to include in a <code>Rule</code>.</p>"
        }
      },
      "documentation":"<p>A combination of <a>ByteMatchSet</a>, <a>IPSet</a>, and/or <a>SqlInjectionMatchSet</a> objects that identify the web requests that you want to allow, block, or count. For example, you might create a <code>Rule</code> that includes the following predicates:</p> <ul> <li>An <code>IPSet</code> that causes AWS WAF to search for web requests that originate from the IP address <code>192.0.2.44</code></li> <li>A <code>ByteMatchSet</code> that causes AWS WAF to search for web requests for which the value of the <code>User-Agent</code> header is <code>BadBot</code>.</li> </ul> <p>To match the settings in this <code>Rule</code>, a request must originate from <code>192.0.2.44</code> AND include a <code>User-Agent</code> header for which the value is <code>BadBot</code>.</p>"
    },
    "RulePriority":{"type":"integer"},
    "RuleSummaries":{
      "type":"list",
      "member":{"shape":"RuleSummary"}
    },
    "RuleSummary":{
      "type":"structure",
      "required":[
        "RuleId",
        "Name"
      ],
      "members":{
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>Rule</code>. You use <code>RuleId</code> to get more information about a <code>Rule</code> (see <a>GetRule</a>), update a <code>Rule</code> (see <a>UpdateRule</a>), insert a <code>Rule</code> into a <code>WebACL</code> or delete one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>Rule</code> from AWS WAF (see <a>DeleteRule</a>).</p> <p><code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>Rule</a>. You can't change the name of a <code>Rule</code> after you create it.</p>"
        }
      },
      "documentation":"<p>Contains the identifier and the friendly name or description of the <code>Rule</code>.</p>"
    },
    "RuleUpdate":{
      "type":"structure",
      "required":[
        "Action",
        "Predicate"
      ],
      "members":{
        "Action":{
          "shape":"ChangeAction",
          "documentation":"<p>Specify <code>INSERT</code> to add a <code>Predicate</code> to a <code>Rule</code>. Use <code>DELETE</code> to remove a <code>Predicate</code> from a <code>Rule</code>.</p>"
        },
        "Predicate":{
          "shape":"Predicate",
          "documentation":"<p>The ID of the <code>Predicate</code> (such as an <code>IPSet</code>) that you want to add to a <code>Rule</code>.</p>"
        }
      },
      "documentation":"<p>Specifies a <code>Predicate</code> (such as an <code>IPSet</code>) and indicates whether you want to add it to a <code>Rule</code> or delete it from a <code>Rule</code>.</p>"
    },
    "RuleUpdates":{
      "type":"list",
      "member":{"shape":"RuleUpdate"}
    },
    "SampleWeight":{
      "type":"long",
      "min":0
    },
    "SampledHTTPRequest":{
      "type":"structure",
      "required":[
        "Request",
        "Weight"
      ],
      "members":{
        "Request":{
          "shape":"HTTPRequest",
          "documentation":"<p>A complex type that contains detailed information about the request.</p>"
        },
        "Weight":{
          "shape":"SampleWeight",
          "documentation":"<p>A value that indicates how one result in the response relates proportionally to other results in the response. A result that has a weight of <code>2</code> represents roughly twice as many CloudFront web requests as a result that has a weight of <code>1</code>.</p>"
        },
        "Timestamp":{
          "shape":"Timestamp",
          "documentation":"<p>The time at which AWS WAF received the request from your AWS resource, in Unix time format (in seconds).</p>"
        },
        "Action":{
          "shape":"Action",
          "documentation":"<p>The action for the <code>Rule</code> that the request matched: <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p>"
        }
      },
      "documentation":"<p>The response from a <a>GetSampledRequests</a> request includes a <code>SampledHTTPRequests</code> complex type that appears as <code>SampledRequests</code> in the response syntax. <code>SampledHTTPRequests</code> contains one <code>SampledHTTPRequest</code> object for each web request that is returned by <code>GetSampledRequests</code>.</p>"
    },
    "SampledHTTPRequests":{
      "type":"list",
      "member":{"shape":"SampledHTTPRequest"}
    },
    "Size":{
      "type":"long",
      "min":0
    },
    "SizeConstraint":{
      "type":"structure",
      "required":[
        "FieldToMatch",
        "TextTransformation",
        "ComparisonOperator",
        "Size"
      ],
      "members":{
        "FieldToMatch":{"shape":"FieldToMatch"},
        "TextTransformation":{
          "shape":"TextTransformation",
          "documentation":"<p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on <code>FieldToMatch</code> before inspecting a request for a match.</p> <p>Note that if you choose <code>BODY</code> for the value of <code>Type</code>, you must choose <code>NONE</code> for <code>TextTransformation</code> because CloudFront forwards only the first 8192 bytes for inspection. </p> <p><b>NONE</b></p> <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p> <p><b>CMD_LINE</b></p> <p>When you're concerned that attackers are injecting an operating system command line command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:</p> <ul> <li>Delete the following characters: \\ \" ' ^</li> <li>Delete spaces before the following characters: / (</li> <li>Replace the following characters with a space: , ;</li> <li>Replace multiple spaces with one space</li> <li>Convert uppercase letters (A-Z) to lowercase (a-z)</li> </ul> <p><b>COMPRESS_WHITE_SPACE</b></p> <p>Use this option to replace the following characters with a space character (decimal 32):</p> <ul> <li>\\f, formfeed, decimal 12</li> <li>\\t, tab, decimal 9</li> <li>\\n, newline, decimal 10</li> <li>\\r, carriage return, decimal 13</li> <li>\\v, vertical tab, decimal 11</li> <li>non-breaking space, decimal 160</li> </ul> <p><code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p> <p><b>HTML_ENTITY_DECODE</b></p> <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs the following operations:</p> <ul> <li>Replaces <code>(ampersand)quot;</code> with <code>\"</code></li> <li>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</li> <li>Replaces <code>(ampersand)lt;</code> with a \"less than\" symbol</li> <li>Replaces <code>(ampersand)gt;</code> with <code>></code></li> <li>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</li> <li>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</li> </ul> <p><b>LOWERCASE</b></p> <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p> <p><b>URL_DECODE</b></p> <p>Use this option to decode a URL-encoded value.</p>"
        },
        "ComparisonOperator":{
          "shape":"ComparisonOperator",
          "documentation":"<p>The type of comparison you want AWS WAF to perform. AWS WAF uses this in combination with the provided <code>Size</code> and <code>FieldToMatch</code> to build an expression in the form of \"<code>Size</code> <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>\". If that expression is true, the <code>SizeConstraint</code> is considered to match.</p> <p><b>EQ</b>: Used to test if the <code>Size</code> is equal to the size of the <code>FieldToMatch</code></p> <p><b>NE</b>: Used to test if the <code>Size</code> is not equal to the size of the <code>FieldToMatch</code></p> <p><b>LE</b>: Used to test if the <code>Size</code> is less than or equal to the size of the <code>FieldToMatch</code></p> <p><b>LT</b>: Used to test if the <code>Size</code> is strictly less than the size of the <code>FieldToMatch</code></p> <p><b>GE</b>: Used to test if the <code>Size</code> is greater than or equal to the size of the <code>FieldToMatch</code></p> <p><b>GT</b>: Used to test if the <code>Size</code> is strictly greater than the size of the <code>FieldToMatch</code></p>"
        },
        "Size":{
          "shape":"Size",
          "documentation":"<p>The size in bytes that you want AWS WAF to compare against the size of the specified <code>FieldToMatch</code>. AWS WAF uses this in combination with <code>ComparisonOperator</code> and <code>FieldToMatch</code> to build an expression in the form of \"<code>Size</code> <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>\". If that expression is true, the <code>SizeConstraint</code> is considered to match.</p> <p>Valid values for size are 0 - 21474836480 bytes (0 - 20 GB). </p> <p>If you specify <code>URI</code> for the value of <code>Type</code>, the / in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>"
        }
      },
      "documentation":"<p>Specifies a constraint on the size of a part of the web request. AWS WAF uses the <code>Size</code>, <code>ComparisonOperator</code>, and <code>FieldToMatch</code> to build an expression in the form of \"<code>Size</code> <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>\". If that expression is true, the <code>SizeConstraint</code> is considered to match.</p>"
    },
    "SizeConstraintSet":{
      "type":"structure",
      "required":[
        "SizeConstraintSetId",
        "SizeConstraints"
      ],
      "members":{
        "SizeConstraintSetId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>SizeConstraintSet</code>. You use <code>SizeConstraintSetId</code> to get information about a <code>SizeConstraintSet</code> (see <a>GetSizeConstraintSet</a>), update a <code>SizeConstraintSet</code> (see <a>UpdateSizeConstraintSet</a>, insert a <code>SizeConstraintSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SizeConstraintSet</code> from AWS WAF (see <a>DeleteSizeConstraintSet</a>).</p> <p><code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>The name, if any, of the <code>SizeConstraintSet</code>.</p>"
        },
        "SizeConstraints":{
          "shape":"SizeConstraints",
          "documentation":"<p>Specifies the parts of web requests that you want to inspect the size of.</p>"
        }
      },
      "documentation":"<p>A complex type that contains <code>SizeConstraint</code> objects, which specify the parts of web requests that you want AWS WAF to inspect the size of. If a <code>SizeConstraintSet</code> contains more than one <code>SizeConstraint</code> object, a request only needs to match one constraint to be considered a match.</p>"
    },
    "SizeConstraintSetSummaries":{
      "type":"list",
      "member":{"shape":"SizeConstraintSetSummary"}
    },
    "SizeConstraintSetSummary":{
      "type":"structure",
      "required":[
        "SizeConstraintSetId",
        "Name"
      ],
      "members":{
        "SizeConstraintSetId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>SizeConstraintSet</code>. You use <code>SizeConstraintSetId</code> to get information about a <code>SizeConstraintSet</code> (see <a>GetSizeConstraintSet</a>), update a <code>SizeConstraintSet</code> (see <a>UpdateSizeConstraintSet</a>, insert a <code>SizeConstraintSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SizeConstraintSet</code> from AWS WAF (see <a>DeleteSizeConstraintSet</a>).</p> <p><code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the <code>SizeConstraintSet</code>, if any.</p>"
        }
      },
      "documentation":"<p>The <code>Id</code> and <code>Name</code> of a <code>SizeConstraintSet</code>.</p>"
    },
    "SizeConstraintSetUpdate":{
      "type":"structure",
      "required":[
        "Action",
        "SizeConstraint"
      ],
      "members":{
        "Action":{
          "shape":"ChangeAction",
          "documentation":"<p>Specify <code>INSERT</code> to add a <a>SizeConstraintSetUpdate</a> to a <a>SizeConstraintSet</a>. Use <code>DELETE</code> to remove a <code>SizeConstraintSetUpdate</code> from a <code>SizeConstraintSet</code>.</p>"
        },
        "SizeConstraint":{
          "shape":"SizeConstraint",
          "documentation":"<p>Specifies a constraint on the size of a part of the web request. AWS WAF uses the <code>Size</code>, <code>ComparisonOperator</code>, and <code>FieldToMatch</code> to build an expression in the form of \"<code>Size</code> <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>\". If that expression is true, the <code>SizeConstraint</code> is considered to match.</p>"
        }
      },
      "documentation":"<p>Specifies the part of a web request that you want to inspect the size of and indicates whether you want to add the specification to a <a>SizeConstraintSet</a> or delete it from a <code>SizeConstraintSet</code>.</p>"
    },
    "SizeConstraintSetUpdates":{
      "type":"list",
      "member":{"shape":"SizeConstraintSetUpdate"}
    },
    "SizeConstraints":{
      "type":"list",
      "member":{"shape":"SizeConstraint"}
    },
    "SqlInjectionMatchSet":{
      "type":"structure",
      "required":[
        "SqlInjectionMatchSetId",
        "SqlInjectionMatchTuples"
      ],
      "members":{
        "SqlInjectionMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>SqlInjectionMatchSet</code>. You use <code>SqlInjectionMatchSetId</code> to get information about a <code>SqlInjectionMatchSet</code> (see <a>GetSqlInjectionMatchSet</a>), update a <code>SqlInjectionMatchSet</code> (see <a>UpdateSqlInjectionMatchSet</a>, insert a <code>SqlInjectionMatchSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SqlInjectionMatchSet</code> from AWS WAF (see <a>DeleteSqlInjectionMatchSet</a>).</p> <p><code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>The name, if any, of the <code>SqlInjectionMatchSet</code>.</p>"
        },
        "SqlInjectionMatchTuples":{
          "shape":"SqlInjectionMatchTuples",
          "documentation":"<p>Specifies the parts of web requests that you want to inspect for snippets of malicious SQL code.</p>"
        }
      },
      "documentation":"<p>A complex type that contains <code>SqlInjectionMatchTuple</code> objects, which specify the parts of web requests that you want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header. If a <code>SqlInjectionMatchSet</code> contains more than one <code>SqlInjectionMatchTuple</code> object, a request needs to include snippets of SQL code in only one of the specified parts of the request to be considered a match.</p>"
    },
    "SqlInjectionMatchSetSummaries":{
      "type":"list",
      "member":{"shape":"SqlInjectionMatchSetSummary"}
    },
    "SqlInjectionMatchSetSummary":{
      "type":"structure",
      "required":[
        "SqlInjectionMatchSetId",
        "Name"
      ],
      "members":{
        "SqlInjectionMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>SqlInjectionMatchSet</code>. You use <code>SqlInjectionMatchSetId</code> to get information about a <code>SqlInjectionMatchSet</code> (see <a>GetSqlInjectionMatchSet</a>), update a <code>SqlInjectionMatchSet</code> (see <a>UpdateSqlInjectionMatchSet</a>, insert a <code>SqlInjectionMatchSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SqlInjectionMatchSet</code> from AWS WAF (see <a>DeleteSqlInjectionMatchSet</a>).</p> <p><code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the <code>SqlInjectionMatchSet</code>, if any, specified by <code>Id</code>.</p>"
        }
      },
      "documentation":"<p>The <code>Id</code> and <code>Name</code> of a <code>SqlInjectionMatchSet</code>.</p>"
    },
    "SqlInjectionMatchSetUpdate":{
      "type":"structure",
      "required":[
        "Action",
        "SqlInjectionMatchTuple"
      ],
      "members":{
        "Action":{
          "shape":"ChangeAction",
          "documentation":"<p>Specify <code>INSERT</code> to add a <a>SqlInjectionMatchSetUpdate</a> to a <a>SqlInjectionMatchSet</a>. Use <code>DELETE</code> to remove a <code>SqlInjectionMatchSetUpdate</code> from a <code>SqlInjectionMatchSet</code>.</p>"
        },
        "SqlInjectionMatchTuple":{
          "shape":"SqlInjectionMatchTuple",
          "documentation":"<p>Specifies the part of a web request that you want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header.</p>"
        }
      },
      "documentation":"<p>Specifies the part of a web request that you want to inspect for snippets of malicious SQL code and indicates whether you want to add the specification to a <a>SqlInjectionMatchSet</a> or delete it from a <code>SqlInjectionMatchSet</code>.</p>"
    },
    "SqlInjectionMatchSetUpdates":{
      "type":"list",
      "member":{"shape":"SqlInjectionMatchSetUpdate"}
    },
    "SqlInjectionMatchTuple":{
      "type":"structure",
      "required":[
        "FieldToMatch",
        "TextTransformation"
      ],
      "members":{
        "FieldToMatch":{"shape":"FieldToMatch"},
        "TextTransformation":{
          "shape":"TextTransformation",
          "documentation":"<p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on <code>FieldToMatch</code> before inspecting a request for a match.</p> <p><b>CMD_LINE</b></p> <p>When you're concerned that attackers are injecting an operating system commandline command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:</p> <ul> <li>Delete the following characters: \\ \" ' ^</li> <li>Delete spaces before the following characters: / (</li> <li>Replace the following characters with a space: , ;</li> <li>Replace multiple spaces with one space</li> <li>Convert uppercase letters (A-Z) to lowercase (a-z)</li> </ul> <p><b>COMPRESS_WHITE_SPACE</b></p> <p>Use this option to replace the following characters with a space character (decimal 32):</p> <ul> <li>\\f, formfeed, decimal 12</li> <li>\\t, tab, decimal 9</li> <li>\\n, newline, decimal 10</li> <li>\\r, carriage return, decimal 13</li> <li>\\v, vertical tab, decimal 11</li> <li>non-breaking space, decimal 160</li> </ul> <p><code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p> <p><b>HTML_ENTITY_DECODE</b></p> <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs the following operations:</p> <ul> <li>Replaces <code>(ampersand)quot;</code> with <code>\"</code></li> <li>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</li> <li>Replaces <code>(ampersand)lt;</code> with a \"less than\" symbol</li> <li>Replaces <code>(ampersand)gt;</code> with <code>></code></li> <li>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</li> <li>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</li> </ul> <p><b>LOWERCASE</b></p> <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p> <p><b>URL_DECODE</b></p> <p>Use this option to decode a URL-encoded value.</p> <p><b>NONE</b></p> <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>"
        }
      },
      "documentation":"<p>Specifies the part of a web request that you want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header.</p>"
    },
    "SqlInjectionMatchTuples":{
      "type":"list",
      "member":{"shape":"SqlInjectionMatchTuple"}
    },
    "TextTransformation":{
      "type":"string",
      "enum":[
        "NONE",
        "COMPRESS_WHITE_SPACE",
        "HTML_ENTITY_DECODE",
        "LOWERCASE",
        "CMD_LINE",
        "URL_DECODE"
      ]
    },
    "TimeWindow":{
      "type":"structure",
      "required":[
        "StartTime",
        "EndTime"
      ],
      "members":{
        "StartTime":{
          "shape":"Timestamp",
          "documentation":"<p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your AWS resource received. You can specify any time range in the previous three hours.</p>"
        },
        "EndTime":{
          "shape":"Timestamp",
          "documentation":"<p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your AWS resource received. You can specify any time range in the previous three hours.</p>"
        }
      },
      "documentation":"<p>In a <a>GetSampledRequests</a> request, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range for which you want AWS WAF to return a sample of web requests.</p> <p>In a <a>GetSampledRequests</a> response, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range for which AWS WAF actually returned a sample of web requests. AWS WAF gets the specified number of requests from among the first 5,000 requests that your AWS resource receives during the specified time period. If your resource receives more than 5,000 requests during that period, AWS WAF stops sampling after the 5,000th request. In that case, <code>EndTime</code> is the time that AWS WAF received the 5,000th request. </p>"
    },
    "Timestamp":{"type":"timestamp"},
    "URIString":{"type":"string"},
    "UpdateByteMatchSetRequest":{
      "type":"structure",
      "required":[
        "ByteMatchSetId",
        "ChangeToken",
        "Updates"
      ],
      "members":{
        "ByteMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>ByteMatchSetId</code> of the <a>ByteMatchSet</a> that you want to update. <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        },
        "Updates":{
          "shape":"ByteMatchSetUpdates",
          "documentation":"<p>An array of <code>ByteMatchSetUpdate</code> objects that you want to insert into or delete from a <a>ByteMatchSet</a>. For more information, see the applicable data types:</p> <ul> <li><a>ByteMatchSetUpdate</a>: Contains <code>Action</code> and <code>ByteMatchTuple</code></li> <li><a>ByteMatchTuple</a>: Contains <code>FieldToMatch</code>, <code>PositionalConstraint</code>, <code>TargetString</code>, and <code>TextTransformation</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      }
    },
    "UpdateByteMatchSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>UpdateByteMatchSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "UpdateIPSetRequest":{
      "type":"structure",
      "required":[
        "IPSetId",
        "ChangeToken",
        "Updates"
      ],
      "members":{
        "IPSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>IPSetId</code> of the <a>IPSet</a> that you want to update. <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by <a>ListIPSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        },
        "Updates":{
          "shape":"IPSetUpdates",
          "documentation":"<p>An array of <code>IPSetUpdate</code> objects that you want to insert into or delete from an <a>IPSet</a>. For more information, see the applicable data types:</p> <ul> <li><a>IPSetUpdate</a>: Contains <code>Action</code> and <code>IPSetDescriptor</code></li> <li><a>IPSetDescriptor</a>: Contains <code>Type</code> and <code>Value</code></li> </ul>"
        }
      }
    },
    "UpdateIPSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>UpdateIPSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "UpdateRuleRequest":{
      "type":"structure",
      "required":[
        "RuleId",
        "ChangeToken",
        "Updates"
      ],
      "members":{
        "RuleId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>RuleId</code> of the <code>Rule</code> that you want to update. <code>RuleId</code> is returned by <code>CreateRule</code> and by <a>ListRules</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        },
        "Updates":{
          "shape":"RuleUpdates",
          "documentation":"<p>An array of <code>RuleUpdate</code> objects that you want to insert into or delete from a <a>Rule</a>. For more information, see the applicable data types:</p> <ul> <li><a>RuleUpdate</a>: Contains <code>Action</code> and <code>Predicate</code></li> <li><a>Predicate</a>: Contains <code>DataId</code>, <code>Negated</code>, and <code>Type</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      }
    },
    "UpdateRuleResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>UpdateRule</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "UpdateSizeConstraintSetRequest":{
      "type":"structure",
      "required":[
        "SizeConstraintSetId",
        "ChangeToken",
        "Updates"
      ],
      "members":{
        "SizeConstraintSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>SizeConstraintSetId</code> of the <a>SizeConstraintSet</a> that you want to update. <code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        },
        "Updates":{
          "shape":"SizeConstraintSetUpdates",
          "documentation":"<p>An array of <code>SizeConstraintSetUpdate</code> objects that you want to insert into or delete from a <a>SizeConstraintSet</a>. For more information, see the applicable data types:</p> <ul> <li><a>SizeConstraintSetUpdate</a>: Contains <code>Action</code> and <code>SizeConstraint</code></li> <li><a>SizeConstraint</a>: Contains <code>FieldToMatch</code>, <code>TextTransformation</code>, <code>ComparisonOperator</code>, and <code>Size</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      }
    },
    "UpdateSizeConstraintSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>UpdateSizeConstraintSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "UpdateSqlInjectionMatchSetRequest":{
      "type":"structure",
      "required":[
        "SqlInjectionMatchSetId",
        "ChangeToken",
        "Updates"
      ],
      "members":{
        "SqlInjectionMatchSetId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>SqlInjectionMatchSetId</code> of the <code>SqlInjectionMatchSet</code> that you want to update. <code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        },
        "Updates":{
          "shape":"SqlInjectionMatchSetUpdates",
          "documentation":"<p>An array of <code>SqlInjectionMatchSetUpdate</code> objects that you want to insert into or delete from a <a>SqlInjectionMatchSet</a>. For more information, see the applicable data types:</p> <ul> <li><a>SqlInjectionMatchSetUpdate</a>: Contains <code>Action</code> and <code>SqlInjectionMatchTuple</code></li> <li><a>SqlInjectionMatchTuple</a>: Contains <code>FieldToMatch</code> and <code>TextTransformation</code></li> <li><a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code></li> </ul>"
        }
      },
      "documentation":"<p>A request to update a <a>SqlInjectionMatchSet</a>.</p>"
    },
    "UpdateSqlInjectionMatchSetResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>UpdateSqlInjectionMatchSet</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      },
      "documentation":"<p>The response to an <a>UpdateSqlInjectionMatchSets</a> request.</p>"
    },
    "UpdateWebACLRequest":{
      "type":"structure",
      "required":[
        "WebACLId",
        "ChangeToken"
      ],
      "members":{
        "WebACLId":{
          "shape":"ResourceId",
          "documentation":"<p>The <code>WebACLId</code> of the <a>WebACL</a> that you want to update. <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>"
        },
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>"
        },
        "Updates":{
          "shape":"WebACLUpdates",
          "documentation":"<p>An array of updates to make to the <a>WebACL</a>.</p> <p>An array of <code>WebACLUpdate</code> objects that you want to insert into or delete from a <a>WebACL</a>. For more information, see the applicable data types:</p> <ul> <li><a>WebACLUpdate</a>: Contains <code>Action</code> and <code>ActivatedRule</code></li> <li><a>ActivatedRule</a>: Contains <code>Action</code>, <code>Priority</code>, and <code>RuleId</code></li> <li><a>WafAction</a>: Contains <code>Type</code></li> </ul>"
        },
        "DefaultAction":{"shape":"WafAction"}
      }
    },
    "UpdateWebACLResponse":{
      "type":"structure",
      "members":{
        "ChangeToken":{
          "shape":"ChangeToken",
          "documentation":"<p>The <code>ChangeToken</code> that you used to submit the <code>UpdateWebACL</code> request. You can also use this value to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>"
        }
      }
    },
    "WAFDisallowedNameException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The name specified is invalid.</p>",
      "exception":true
    },
    "WAFInternalErrorException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>",
      "exception":true,
      "fault":true
    },
    "WAFInvalidAccountException":{
      "type":"structure",
      "members":{
      },
      "documentation":"<p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>",
      "exception":true
    },
    "WAFInvalidOperationException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because there was nothing to do. For example:</p> <ul> <li>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</li> <li>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</li> <li>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</li> <li>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</li> <li>You tried to add an IP address to an <code>IPSet</code>, but the IP address already exists in the specified <code>IPSet</code>.</li> <li>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</li> </ul>",
      "exception":true
    },
    "WAFInvalidParameterException":{
      "type":"structure",
      "members":{
        "field":{"shape":"ParameterExceptionField"},
        "parameter":{"shape":"ParameterExceptionParameter"},
        "reason":{"shape":"ParameterExceptionReason"}
      },
      "documentation":"<p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p> <ul> <li>You specified an invalid parameter name.</li> <li>You specified an invalid value.</li> <li>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</li> <li>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</li> <li>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</li> <li>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, QUERY_STRING, or URI.</li> <li>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</li> </ul>",
      "exception":true
    },
    "WAFLimitsExceededException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/limits.html\">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>",
      "exception":true
    },
    "WAFNonEmptyEntityException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because you tried to delete an object that isn't empty. For example:</p> <ul> <li>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</li> <li>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</li> <li>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</li> <li>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</li> </ul>",
      "exception":true
    },
    "WAFNonexistentContainerException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p> <ul> <li>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</li> <li>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</li> <li>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</li> <li>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</li> </ul>",
      "exception":true
    },
    "WAFNonexistentItemException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because the referenced object doesn't exist.</p>",
      "exception":true
    },
    "WAFReferencedItemException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because you tried to delete an object that is still in use. For example: <ul> <li>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</li> <li>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</li> </ul></p>",
      "exception":true
    },
    "WAFStaleDataException":{
      "type":"structure",
      "members":{
        "message":{"shape":"errorMessage"}
      },
      "documentation":"<p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>",
      "exception":true
    },
    "WafAction":{
      "type":"structure",
      "required":["Type"],
      "members":{
        "Type":{
          "shape":"WafActionType",
          "documentation":"<p>Specifies how you want AWS WAF to respond to requests that match the settings in a <code>Rule</code>. Valid settings include the following:</p> <ul> <li><code>ALLOW</code>: AWS WAF allows requests</li> <li><code>BLOCK</code>: AWS WAF blocks requests</li> <li><code>COUNT</code>: AWS WAF increments a counter of the requests that match all of the conditions in the rule. AWS WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify <code>COUNT</code> for the default action for a <code>WebACL</code>.</li> </ul>"
        }
      },
      "documentation":"<p>For the action that is associated with a rule in a <code>WebACL</code>, specifies the action that you want AWS WAF to perform when a web request matches all of the conditions in a rule. For the default action in a <code>WebACL</code>, specifies the action that you want AWS WAF to take when a web request doesn't match all of the conditions in any of the rules in a <code>WebACL</code>. </p>"
    },
    "WafActionType":{
      "type":"string",
      "enum":[
        "BLOCK",
        "ALLOW",
        "COUNT"
      ]
    },
    "WebACL":{
      "type":"structure",
      "required":[
        "WebACLId",
        "DefaultAction",
        "Rules"
      ],
      "members":{
        "WebACLId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>WebACL</code>. You use <code>WebACLId</code> to get information about a <code>WebACL</code> (see <a>GetWebACL</a>), update a <code>WebACL</code> (see <a>UpdateWebACL</a>, and delete a <code>WebACL</code> from AWS WAF (see <a>DeleteWebACL</a>).</p> <p><code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <code>WebACL</code>. You can't change the name of a <code>WebACL</code> after you create it.</p>"
        },
        "MetricName":{"shape":"MetricName"},
        "DefaultAction":{
          "shape":"WafAction",
          "documentation":"<p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. The action is specified by the <a>WafAction</a> object.</p>"
        },
        "Rules":{
          "shape":"ActivatedRules",
          "documentation":"<p>An array that contains the action for each <code>Rule</code> in a <code>WebACL</code>, the priority of the <code>Rule</code>, and the ID of the <code>Rule</code>.</p>"
        }
      },
      "documentation":"<p>Contains the <code>Rules</code> that identify the requests that you want to allow, block, or count. In a <code>WebACL</code>, you also specify a default action (<code>ALLOW</code> or <code>BLOCK</code>), and the action for each <code>Rule</code> that you add to a <code>WebACL</code>, for example, block requests from specified IP addresses or block requests from specified referrers. You also associate the <code>WebACL</code> with a CloudFront distribution to identify the requests that you want AWS WAF to filter. If you add more than one <code>Rule</code> to a <code>WebACL</code>, a request needs to match only one of the specifications to be allowed, blocked, or counted. For more information, see <a>UpdateWebACL</a>.</p>"
    },
    "WebACLSummaries":{
      "type":"list",
      "member":{"shape":"WebACLSummary"}
    },
    "WebACLSummary":{
      "type":"structure",
      "required":[
        "WebACLId",
        "Name"
      ],
      "members":{
        "WebACLId":{
          "shape":"ResourceId",
          "documentation":"<p>A unique identifier for a <code>WebACL</code>. You use <code>WebACLId</code> to get information about a <code>WebACL</code> (see <a>GetWebACL</a>), update a <code>WebACL</code> (see <a>UpdateWebACL</a>, and delete a <code>WebACL</code> from AWS WAF (see <a>DeleteWebACL</a>).</p> <p><code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>"
        },
        "Name":{
          "shape":"ResourceName",
          "documentation":"<p>A friendly name or description of the <a>WebACL</a>. You can't change the name of a <code>WebACL</code> after you create it.</p>"
        }
      },
      "documentation":"<p>Contains the identifier and the name or description of the <a>WebACL</a>.</p>"
    },
    "WebACLUpdate":{
      "type":"structure",
      "required":[
        "Action",
        "ActivatedRule"
      ],
      "members":{
        "Action":{
          "shape":"ChangeAction",
          "documentation":"<p>Specifies whether to insert a <code>Rule</code> into or delete a <code>Rule</code> from a <code>WebACL</code>.</p>"
        },
        "ActivatedRule":{"shape":"ActivatedRule"}
      },
      "documentation":"<p>Specifies whether to insert a <code>Rule</code> into or delete a <code>Rule</code> from a <code>WebACL</code>.</p>"
    },
    "WebACLUpdates":{
      "type":"list",
      "member":{"shape":"WebACLUpdate"}
    },
    "errorMessage":{"type":"string"}
  },
  "documentation":"<p>This is the <i>AWS WAF API Reference</i>. This guide is for developers who need detailed information about the AWS WAF API actions, data types, and errors. For detailed information about AWS WAF features and an overview of how to use the AWS WAF API, see the <a href=\"http://docs.aws.amazon.com/waf/latest/developerguide/\">AWS WAF Developer Guide</a>.</p>"
}
                      usr/local/lib/python2.7/dist-packages/botocore/data/workspaces/                                     0042755 0000000 0000062 00000000000 13077704402 023134  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/workspaces/2015-04-08/                          0042755 0000000 0000062 00000000000 13077704402 024171  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/workspaces/2015-04-08/service-2.json            0100644 0000000 0000062 00000104507 13077704371 026672  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2015-04-08",
    "endpointPrefix":"workspaces",
    "jsonVersion":"1.1",
    "serviceFullName":"Amazon WorkSpaces",
    "signatureVersion":"v4",
    "targetPrefix":"WorkspacesService",
    "protocol":"json"
  },
  "documentation":"<fullname>Amazon WorkSpaces Service</fullname> <p>This is the <i>Amazon WorkSpaces API Reference</i>. This guide provides detailed information about Amazon WorkSpaces operations, data types, parameters, and errors.</p>",
  "operations":{
    "CreateWorkspaces":{
      "name":"CreateWorkspaces",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"CreateWorkspacesRequest",
        "documentation":"<p>Contains the inputs for the <a>CreateWorkspaces</a> operation.</p>"
      },
      "output":{
        "shape":"CreateWorkspacesResult",
        "documentation":"<p>Contains the result of the <a>CreateWorkspaces</a> operation.</p>"
      },
      "errors":[
        {
          "shape":"ResourceLimitExceededException",
          "exception":true,
          "documentation":"<p>Your resource limits have been exceeded.</p>"
        }
      ],
      "documentation":"<p>Creates one or more WorkSpaces.</p> <note> <p>This operation is asynchronous and returns before the WorkSpaces are created.</p> </note>"
    },
    "DescribeWorkspaceBundles":{
      "name":"DescribeWorkspaceBundles",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"DescribeWorkspaceBundlesRequest",
        "documentation":"<p>Contains the inputs for the <a>DescribeWorkspaceBundles</a> operation.</p>"
      },
      "output":{
        "shape":"DescribeWorkspaceBundlesResult",
        "documentation":"<p>Contains the results of the <a>DescribeWorkspaceBundles</a> operation.</p>"
      },
      "errors":[
        {
          "shape":"InvalidParameterValuesException",
          "exception":true,
          "documentation":"<p>One or more parameter values are not valid.</p>"
        }
      ],
      "documentation":"<p>Obtains information about the WorkSpace bundles that are available to your account in the specified region.</p> <p>You can filter the results with either the <code>BundleIds</code> parameter, or the <code>Owner</code> parameter, but not both.</p> <p>This operation supports pagination with the use of the <code>NextToken</code> request and response parameters. If more results are available, the <code>NextToken</code> response member contains a token that you pass in the next call to this operation to retrieve the next set of items.</p>"
    },
    "DescribeWorkspaceDirectories":{
      "name":"DescribeWorkspaceDirectories",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"DescribeWorkspaceDirectoriesRequest",
        "documentation":"<p>Contains the inputs for the <a>DescribeWorkspaceDirectories</a> operation.</p>"
      },
      "output":{
        "shape":"DescribeWorkspaceDirectoriesResult",
        "documentation":"<p>Contains the results of the <a>DescribeWorkspaceDirectories</a> operation.</p>"
      },
      "errors":[
        {
          "shape":"InvalidParameterValuesException",
          "exception":true,
          "documentation":"<p>One or more parameter values are not valid.</p>"
        }
      ],
      "documentation":"<p>Retrieves information about the AWS Directory Service directories in the region that are registered with Amazon WorkSpaces and are available to your account.</p> <p>This operation supports pagination with the use of the <code>NextToken</code> request and response parameters. If more results are available, the <code>NextToken</code> response member contains a token that you pass in the next call to this operation to retrieve the next set of items.</p>"
    },
    "DescribeWorkspaces":{
      "name":"DescribeWorkspaces",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"DescribeWorkspacesRequest",
        "documentation":"<p>Contains the inputs for the <a>DescribeWorkspaces</a> operation.</p>"
      },
      "output":{
        "shape":"DescribeWorkspacesResult",
        "documentation":"<p>Contains the results for the <a>DescribeWorkspaces</a> operation.</p>"
      },
      "errors":[
        {
          "shape":"InvalidParameterValuesException",
          "exception":true,
          "documentation":"<p>One or more parameter values are not valid.</p>"
        },
        {
          "shape":"ResourceUnavailableException",
          "exception":true,
          "documentation":"<p>The specified resource is not available.</p>"
        }
      ],
      "documentation":"<p>Obtains information about the specified WorkSpaces. </p> <p>Only one of the filter parameters, such as <code>BundleId</code>, <code>DirectoryId</code>, or <code>WorkspaceIds</code>, can be specified at a time.</p> <p>This operation supports pagination with the use of the <code>NextToken</code> request and response parameters. If more results are available, the <code>NextToken</code> response member contains a token that you pass in the next call to this operation to retrieve the next set of items.</p>"
    },
    "RebootWorkspaces":{
      "name":"RebootWorkspaces",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"RebootWorkspacesRequest",
        "documentation":"<p>Contains the inputs for the <a>RebootWorkspaces</a> operation.</p>"
      },
      "output":{
        "shape":"RebootWorkspacesResult",
        "documentation":"<p>Contains the results of the <a>RebootWorkspaces</a> operation.</p>"
      },
      "documentation":"<p>Reboots the specified WorkSpaces.</p> <p>To be able to reboot a WorkSpace, the WorkSpace must have a <b>State</b> of <code>AVAILABLE</code>, <code>IMPAIRED</code>, or <code>INOPERABLE</code>.</p> <note> <p>This operation is asynchronous and will return before the WorkSpaces have rebooted.</p> </note>"
    },
    "RebuildWorkspaces":{
      "name":"RebuildWorkspaces",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"RebuildWorkspacesRequest",
        "documentation":"<p>Contains the inputs for the <a>RebuildWorkspaces</a> operation.</p>"
      },
      "output":{
        "shape":"RebuildWorkspacesResult",
        "documentation":"<p>Contains the results of the <a>RebuildWorkspaces</a> operation.</p>"
      },
      "documentation":"<p>Rebuilds the specified WorkSpaces.</p> <p>Rebuilding a WorkSpace is a potentially destructive action that can result in the loss of data. Rebuilding a WorkSpace causes the following to occur:</p> <ul> <li>The system is restored to the image of the bundle that the WorkSpace is created from. Any applications that have been installed, or system settings that have been made since the WorkSpace was created will be lost.</li> <li>The data drive (D drive) is re-created from the last automatic snapshot taken of the data drive. The current contents of the data drive are overwritten. Automatic snapshots of the data drive are taken every 12 hours, so the snapshot can be as much as 12 hours old.</li> </ul> <p>To be able to rebuild a WorkSpace, the WorkSpace must have a <b>State</b> of <code>AVAILABLE</code> or <code>ERROR</code>.</p> <note> <p>This operation is asynchronous and will return before the WorkSpaces have been completely rebuilt.</p> </note>"
    },
    "TerminateWorkspaces":{
      "name":"TerminateWorkspaces",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{
        "shape":"TerminateWorkspacesRequest",
        "documentation":"<p>Contains the inputs for the <a>TerminateWorkspaces</a> operation.</p>"
      },
      "output":{
        "shape":"TerminateWorkspacesResult",
        "documentation":"<p>Contains the results of the <a>TerminateWorkspaces</a> operation.</p>"
      },
      "documentation":"<p>Terminates the specified WorkSpaces.</p> <p>Terminating a WorkSpace is a permanent action and cannot be undone. The user's data is not maintained and will be destroyed. If you need to archive any user data, contact Amazon Web Services before terminating the WorkSpace.</p> <p>You can terminate a WorkSpace that is in any state except <code>SUSPENDED</code>.</p> <note> <p>This operation is asynchronous and will return before the WorkSpaces have been completely terminated.</p> </note>"
    }
  },
  "shapes":{
    "ARN":{
      "type":"string",
      "pattern":"^arn:aws:[A-Za-z0-9][A-za-z0-9_/.-]{0,62}:[A-za-z0-9_/.-]{0,63}:[A-za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-za-z0-9_/.-]{0,127}$"
    },
    "Alias":{"type":"string"},
    "BooleanObject":{"type":"boolean"},
    "BundleId":{
      "type":"string",
      "pattern":"^wsb-[0-9a-z]{8,63}$"
    },
    "BundleIdList":{
      "type":"list",
      "member":{"shape":"BundleId"},
      "min":1,
      "max":25
    },
    "BundleList":{
      "type":"list",
      "member":{"shape":"WorkspaceBundle"}
    },
    "BundleOwner":{"type":"string"},
    "Compute":{
      "type":"string",
      "enum":[
        "VALUE",
        "STANDARD",
        "PERFORMANCE"
      ]
    },
    "ComputeType":{
      "type":"structure",
      "members":{
        "Name":{
          "shape":"Compute",
          "documentation":"<p>The name of the compute type for the bundle.</p>"
        }
      },
      "documentation":"<p>Contains information about the compute type of a WorkSpace bundle.</p>"
    },
    "ComputerName":{"type":"string"},
    "CreateWorkspacesRequest":{
      "type":"structure",
      "required":["Workspaces"],
      "members":{
        "Workspaces":{
          "shape":"WorkspaceRequestList",
          "documentation":"<p>An array of structures that specify the WorkSpaces to create.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>CreateWorkspaces</a> operation.</p>"
    },
    "CreateWorkspacesResult":{
      "type":"structure",
      "members":{
        "FailedRequests":{
          "shape":"FailedCreateWorkspaceRequests",
          "documentation":"<p>An array of structures that represent the WorkSpaces that could not be created.</p>"
        },
        "PendingRequests":{
          "shape":"WorkspaceList",
          "documentation":"<p>An array of structures that represent the WorkSpaces that were created.</p> <p>Because this operation is asynchronous, the identifier in <code>WorkspaceId</code> is not immediately available. If you immediately call <a>DescribeWorkspaces</a> with this identifier, no information will be returned.</p>"
        }
      },
      "documentation":"<p>Contains the result of the <a>CreateWorkspaces</a> operation.</p>"
    },
    "DefaultOu":{"type":"string"},
    "DefaultWorkspaceCreationProperties":{
      "type":"structure",
      "members":{
        "EnableWorkDocs":{
          "shape":"BooleanObject",
          "documentation":"<p>Specifies if the directory is enabled for Amazon WorkDocs.</p>"
        },
        "EnableInternetAccess":{
          "shape":"BooleanObject",
          "documentation":"<p>A public IP address will be attached to all WorkSpaces that are created or rebuilt.</p>"
        },
        "DefaultOu":{
          "shape":"DefaultOu",
          "documentation":"<p>The organizational unit (OU) in the directory that the WorkSpace machine accounts are placed in.</p>"
        },
        "CustomSecurityGroupId":{
          "shape":"SecurityGroupId",
          "documentation":"<p>The identifier of any custom security groups that are applied to the WorkSpaces when they are created.</p>"
        },
        "UserEnabledAsLocalAdministrator":{
          "shape":"BooleanObject",
          "documentation":"<p>The WorkSpace user is an administrator on the WorkSpace.</p>"
        }
      },
      "documentation":"<p>Contains default WorkSpace creation information.</p>"
    },
    "DescribeWorkspaceBundlesRequest":{
      "type":"structure",
      "members":{
        "BundleIds":{
          "shape":"BundleIdList",
          "documentation":"<p>An array of strings that contains the identifiers of the bundles to retrieve. This parameter cannot be combined with any other filter parameter.</p>"
        },
        "Owner":{
          "shape":"BundleOwner",
          "documentation":"<p>The owner of the bundles to retrieve. This parameter cannot be combined with any other filter parameter.</p> <p>This contains one of the following values:</p> <ul> <li>null - Retrieves the bundles that belong to the account making the call.</li> <li> <code>AMAZON</code> - Retrieves the bundles that are provided by AWS.</li> </ul>"
        },
        "NextToken":{
          "shape":"PaginationToken",
          "documentation":"<p>The <code>NextToken</code> value from a previous call to this operation. Pass null if this is the first call.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>DescribeWorkspaceBundles</a> operation.</p>"
    },
    "DescribeWorkspaceBundlesResult":{
      "type":"structure",
      "members":{
        "Bundles":{
          "shape":"BundleList",
          "documentation":"<p>An array of structures that contain information about the bundles.</p>"
        },
        "NextToken":{
          "shape":"PaginationToken",
          "documentation":"<p>If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that timeframe.</p>"
        }
      },
      "documentation":"<p>Contains the results of the <a>DescribeWorkspaceBundles</a> operation.</p>"
    },
    "DescribeWorkspaceDirectoriesRequest":{
      "type":"structure",
      "members":{
        "DirectoryIds":{
          "shape":"DirectoryIdList",
          "documentation":"<p>An array of strings that contains the directory identifiers to retrieve information for. If this member is null, all directories are retrieved.</p>"
        },
        "NextToken":{
          "shape":"PaginationToken",
          "documentation":"<p>The <code>NextToken</code> value from a previous call to this operation. Pass null if this is the first call.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>DescribeWorkspaceDirectories</a> operation.</p>"
    },
    "DescribeWorkspaceDirectoriesResult":{
      "type":"structure",
      "members":{
        "Directories":{
          "shape":"DirectoryList",
          "documentation":"<p>An array of structures that contain information about the directories.</p>"
        },
        "NextToken":{
          "shape":"PaginationToken",
          "documentation":"<p>If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that timeframe.</p>"
        }
      },
      "documentation":"<p>Contains the results of the <a>DescribeWorkspaceDirectories</a> operation.</p>"
    },
    "DescribeWorkspacesRequest":{
      "type":"structure",
      "members":{
        "WorkspaceIds":{
          "shape":"WorkspaceIdList",
          "documentation":"<p>An array of strings that contain the identifiers of the WorkSpaces for which to retrieve information. This parameter cannot be combined with any other filter parameter.</p> <p>Because the <a>CreateWorkspaces</a> operation is asynchronous, the identifier returned by <a>CreateWorkspaces</a> is not immediately available. If you immediately call <a>DescribeWorkspaces</a> with this identifier, no information will be returned.</p>"
        },
        "DirectoryId":{
          "shape":"DirectoryId",
          "documentation":"<p>Specifies the directory identifier to which to limit the WorkSpaces. Optionally, you can specify a specific directory user with the <code>UserName</code> parameter. This parameter cannot be combined with any other filter parameter.</p>"
        },
        "UserName":{
          "shape":"UserName",
          "documentation":"<p>Used with the <code>DirectoryId</code> parameter to specify the directory user for which to obtain the WorkSpace.</p>"
        },
        "BundleId":{
          "shape":"BundleId",
          "documentation":"<p>The identifier of a bundle to obtain the WorkSpaces for. All WorkSpaces that are created from this bundle will be retrieved. This parameter cannot be combined with any other filter parameter.</p>"
        },
        "Limit":{
          "shape":"Limit",
          "documentation":"<p>The maximum number of items to return.</p>"
        },
        "NextToken":{
          "shape":"PaginationToken",
          "documentation":"<p>The <code>NextToken</code> value from a previous call to this operation. Pass null if this is the first call.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>DescribeWorkspaces</a> operation.</p>"
    },
    "DescribeWorkspacesResult":{
      "type":"structure",
      "members":{
        "Workspaces":{
          "shape":"WorkspaceList",
          "documentation":"<p>An array of structures that contain the information about the WorkSpaces.</p> <p>Because the <a>CreateWorkspaces</a> operation is asynchronous, some of this information may be incomplete for a newly-created WorkSpace.</p>"
        },
        "NextToken":{
          "shape":"PaginationToken",
          "documentation":"<p>If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that timeframe.</p>"
        }
      },
      "documentation":"<p>Contains the results for the <a>DescribeWorkspaces</a> operation.</p>"
    },
    "Description":{"type":"string"},
    "DirectoryId":{
      "type":"string",
      "pattern":"^d-[0-9a-f]{8,63}$"
    },
    "DirectoryIdList":{
      "type":"list",
      "member":{"shape":"DirectoryId"},
      "min":1,
      "max":25
    },
    "DirectoryList":{
      "type":"list",
      "member":{"shape":"WorkspaceDirectory"}
    },
    "DirectoryName":{"type":"string"},
    "DnsIpAddresses":{
      "type":"list",
      "member":{"shape":"IpAddress"}
    },
    "ErrorType":{"type":"string"},
    "ExceptionMessage":{"type":"string"},
    "FailedCreateWorkspaceRequest":{
      "type":"structure",
      "members":{
        "WorkspaceRequest":{
          "shape":"WorkspaceRequest",
          "documentation":"<p>A <a>WorkspaceRequest</a> object that contains the information about the WorkSpace that could not be created.</p>"
        },
        "ErrorCode":{
          "shape":"ErrorType",
          "documentation":"<p>The error code.</p>"
        },
        "ErrorMessage":{
          "shape":"Description",
          "documentation":"<p>The textual error message.</p>"
        }
      },
      "documentation":"<p>Contains information about a WorkSpace that could not be created.</p>"
    },
    "FailedCreateWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"FailedCreateWorkspaceRequest"}
    },
    "FailedRebootWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"FailedWorkspaceChangeRequest"}
    },
    "FailedRebuildWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"FailedWorkspaceChangeRequest"}
    },
    "FailedTerminateWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"FailedWorkspaceChangeRequest"}
    },
    "FailedWorkspaceChangeRequest":{
      "type":"structure",
      "members":{
        "WorkspaceId":{
          "shape":"WorkspaceId",
          "documentation":"<p>The identifier of the WorkSpace.</p>"
        },
        "ErrorCode":{
          "shape":"ErrorType",
          "documentation":"<p>The error code.</p>"
        },
        "ErrorMessage":{
          "shape":"Description",
          "documentation":"<p>The textual error message.</p>"
        }
      },
      "documentation":"<p>Contains information about a WorkSpace that could not be rebooted (<a>RebootWorkspaces</a>), rebuilt (<a>RebuildWorkspaces</a>), or terminated (<a>TerminateWorkspaces</a>).</p>"
    },
    "InvalidParameterValuesException":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ExceptionMessage",
          "documentation":"<p>The exception error message.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>One or more parameter values are not valid.</p>"
    },
    "IpAddress":{"type":"string"},
    "Limit":{
      "type":"integer",
      "min":1,
      "max":25
    },
    "NonEmptyString":{
      "type":"string",
      "min":1
    },
    "PaginationToken":{
      "type":"string",
      "min":1,
      "max":63
    },
    "RebootRequest":{
      "type":"structure",
      "required":["WorkspaceId"],
      "members":{
        "WorkspaceId":{
          "shape":"WorkspaceId",
          "documentation":"<p>The identifier of the WorkSpace to reboot.</p>"
        }
      },
      "documentation":"<p>Contains information used with the <a>RebootWorkspaces</a> operation to reboot a WorkSpace.</p>"
    },
    "RebootWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"RebootRequest"},
      "min":1,
      "max":25
    },
    "RebootWorkspacesRequest":{
      "type":"structure",
      "required":["RebootWorkspaceRequests"],
      "members":{
        "RebootWorkspaceRequests":{
          "shape":"RebootWorkspaceRequests",
          "documentation":"<p>An array of structures that specify the WorkSpaces to reboot.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>RebootWorkspaces</a> operation.</p>"
    },
    "RebootWorkspacesResult":{
      "type":"structure",
      "members":{
        "FailedRequests":{
          "shape":"FailedRebootWorkspaceRequests",
          "documentation":"<p>An array of structures that represent any WorkSpaces that could not be rebooted.</p>"
        }
      },
      "documentation":"<p>Contains the results of the <a>RebootWorkspaces</a> operation.</p>"
    },
    "RebuildRequest":{
      "type":"structure",
      "required":["WorkspaceId"],
      "members":{
        "WorkspaceId":{
          "shape":"WorkspaceId",
          "documentation":"<p>The identifier of the WorkSpace to rebuild.</p>"
        }
      },
      "documentation":"<p>Contains information used with the <a>RebuildWorkspaces</a> operation to rebuild a WorkSpace.</p>"
    },
    "RebuildWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"RebuildRequest"},
      "min":1,
      "max":1
    },
    "RebuildWorkspacesRequest":{
      "type":"structure",
      "required":["RebuildWorkspaceRequests"],
      "members":{
        "RebuildWorkspaceRequests":{
          "shape":"RebuildWorkspaceRequests",
          "documentation":"<p>An array of structures that specify the WorkSpaces to rebuild.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>RebuildWorkspaces</a> operation.</p>"
    },
    "RebuildWorkspacesResult":{
      "type":"structure",
      "members":{
        "FailedRequests":{
          "shape":"FailedRebuildWorkspaceRequests",
          "documentation":"<p>An array of structures that represent any WorkSpaces that could not be rebuilt.</p>"
        }
      },
      "documentation":"<p>Contains the results of the <a>RebuildWorkspaces</a> operation.</p>"
    },
    "RegistrationCode":{
      "type":"string",
      "min":1,
      "max":20
    },
    "ResourceLimitExceededException":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ExceptionMessage",
          "documentation":"<p>The exception error message.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>Your resource limits have been exceeded.</p>"
    },
    "ResourceUnavailableException":{
      "type":"structure",
      "members":{
        "message":{
          "shape":"ExceptionMessage",
          "documentation":"<p>The exception error message.</p>"
        },
        "ResourceId":{
          "shape":"NonEmptyString",
          "documentation":"<p>The identifier of the resource that is not available.</p>"
        }
      },
      "exception":true,
      "documentation":"<p>The specified resource is not available.</p>"
    },
    "SecurityGroupId":{
      "type":"string",
      "pattern":"^(sg-[0-9a-f]{8})$"
    },
    "SubnetId":{
      "type":"string",
      "pattern":"^(subnet-[0-9a-f]{8})$"
    },
    "SubnetIds":{
      "type":"list",
      "member":{"shape":"SubnetId"}
    },
    "TerminateRequest":{
      "type":"structure",
      "required":["WorkspaceId"],
      "members":{
        "WorkspaceId":{
          "shape":"WorkspaceId",
          "documentation":"<p>The identifier of the WorkSpace to terminate.</p>"
        }
      },
      "documentation":"<p>Contains information used with the <a>TerminateWorkspaces</a> operation to terminate a WorkSpace.</p>"
    },
    "TerminateWorkspaceRequests":{
      "type":"list",
      "member":{"shape":"TerminateRequest"},
      "min":1,
      "max":25
    },
    "TerminateWorkspacesRequest":{
      "type":"structure",
      "required":["TerminateWorkspaceRequests"],
      "members":{
        "TerminateWorkspaceRequests":{
          "shape":"TerminateWorkspaceRequests",
          "documentation":"<p>An array of structures that specify the WorkSpaces to terminate.</p>"
        }
      },
      "documentation":"<p>Contains the inputs for the <a>TerminateWorkspaces</a> operation.</p>"
    },
    "TerminateWorkspacesResult":{
      "type":"structure",
      "members":{
        "FailedRequests":{
          "shape":"FailedTerminateWorkspaceRequests",
          "documentation":"<p>An array of structures that represent any WorkSpaces that could not be terminated.</p>"
        }
      },
      "documentation":"<p>Contains the results of the <a>TerminateWorkspaces</a> operation.</p>"
    },
    "UserName":{
      "type":"string",
      "min":1,
      "max":63
    },
    "UserStorage":{
      "type":"structure",
      "members":{
        "Capacity":{
          "shape":"NonEmptyString",
          "documentation":"<p>The amount of user storage for the bundle.</p>"
        }
      },
      "documentation":"<p>Contains information about the user storage for a WorkSpace bundle.</p>"
    },
    "VolumeEncryptionKey":{"type":"string"},
    "Workspace":{
      "type":"structure",
      "members":{
        "WorkspaceId":{
          "shape":"WorkspaceId",
          "documentation":"<p>The identifier of the WorkSpace.</p>"
        },
        "DirectoryId":{
          "shape":"DirectoryId",
          "documentation":"<p>The identifier of the AWS Directory Service directory that the WorkSpace belongs to.</p>"
        },
        "UserName":{
          "shape":"UserName",
          "documentation":"<p>The user that the WorkSpace is assigned to.</p>"
        },
        "IpAddress":{
          "shape":"IpAddress",
          "documentation":"<p>The IP address of the WorkSpace.</p>"
        },
        "State":{
          "shape":"WorkspaceState",
          "documentation":"<p>The operational state of the WorkSpace.</p>"
        },
        "BundleId":{
          "shape":"BundleId",
          "documentation":"<p>The identifier of the bundle that the WorkSpace was created from.</p>"
        },
        "SubnetId":{
          "shape":"SubnetId",
          "documentation":"<p>The identifier of the subnet that the WorkSpace is in.</p>"
        },
        "ErrorMessage":{
          "shape":"Description",
          "documentation":"<p>If the WorkSpace could not be created, this contains a textual error message that describes the failure.</p>"
        },
        "ErrorCode":{
          "shape":"WorkspaceErrorCode",
          "documentation":"<p>If the WorkSpace could not be created, this contains the error code.</p>"
        },
        "ComputerName":{
          "shape":"ComputerName",
          "documentation":"<p>The name of the WorkSpace as seen by the operating system.</p>"
        },
        "VolumeEncryptionKey":{
          "shape":"VolumeEncryptionKey",
          "documentation":"<p>The KMS key used to encrypt data stored on your WorkSpace.</p>"
        },
        "UserVolumeEncryptionEnabled":{
          "shape":"BooleanObject",
          "documentation":"<p>Specifies whether the data stored on the user volume, or D: drive, is encrypted.</p>"
        },
        "RootVolumeEncryptionEnabled":{
          "shape":"BooleanObject",
          "documentation":"<p>Specifies whether the data stored on the root volume, or C: drive, is encrypted.</p>"
        }
      },
      "documentation":"<p>Contains information about a WorkSpace.</p>"
    },
    "WorkspaceBundle":{
      "type":"structure",
      "members":{
        "BundleId":{
          "shape":"BundleId",
          "documentation":"<p>The bundle identifier.</p>"
        },
        "Name":{
          "shape":"NonEmptyString",
          "documentation":"<p>The name of the bundle.</p>"
        },
        "Owner":{
          "shape":"BundleOwner",
          "documentation":"<p>The owner of the bundle. This contains the owner's account identifier, or <code>AMAZON</code> if the bundle is provided by AWS.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>The bundle description.</p>"
        },
        "UserStorage":{
          "shape":"UserStorage",
          "documentation":"<p>A <a>UserStorage</a> object that specifies the amount of user storage that the bundle contains.</p>"
        },
        "ComputeType":{
          "shape":"ComputeType",
          "documentation":"<p>A <a>ComputeType</a> object that specifies the compute type for the bundle.</p>"
        }
      },
      "documentation":"<p>Contains information about a WorkSpace bundle.</p>"
    },
    "WorkspaceDirectory":{
      "type":"structure",
      "members":{
        "DirectoryId":{
          "shape":"DirectoryId",
          "documentation":"<p>The directory identifier.</p>"
        },
        "Alias":{
          "shape":"Alias",
          "documentation":"<p>The directory alias.</p>"
        },
        "DirectoryName":{
          "shape":"DirectoryName",
          "documentation":"<p>The name of the directory.</p>"
        },
        "RegistrationCode":{
          "shape":"RegistrationCode",
          "documentation":"<p>The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.</p>"
        },
        "SubnetIds":{
          "shape":"SubnetIds",
          "documentation":"<p>An array of strings that contains the identifiers of the subnets used with the directory.</p>"
        },
        "DnsIpAddresses":{
          "shape":"DnsIpAddresses",
          "documentation":"<p>An array of strings that contains the IP addresses of the DNS servers for the directory.</p>"
        },
        "CustomerUserName":{
          "shape":"UserName",
          "documentation":"<p>The user name for the service account.</p>"
        },
        "IamRoleId":{
          "shape":"ARN",
          "documentation":"<p>The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.</p>"
        },
        "DirectoryType":{
          "shape":"WorkspaceDirectoryType",
          "documentation":"<p>The directory type.</p>"
        },
        "WorkspaceSecurityGroupId":{
          "shape":"SecurityGroupId",
          "documentation":"<p>The identifier of the security group that is assigned to new WorkSpaces.</p>"
        },
        "State":{
          "shape":"WorkspaceDirectoryState",
          "documentation":"<p>The state of the directory's registration with Amazon WorkSpaces</p>"
        },
        "WorkspaceCreationProperties":{
          "shape":"DefaultWorkspaceCreationProperties",
          "documentation":"<p>A structure that specifies the default creation properties for all WorkSpaces in the directory.</p>"
        }
      },
      "documentation":"<p>Contains information about an AWS Directory Service directory for use with Amazon WorkSpaces.</p>"
    },
    "WorkspaceDirectoryState":{
      "type":"string",
      "enum":[
        "REGISTERING",
        "REGISTERED",
        "DEREGISTERING",
        "DEREGISTERED",
        "ERROR"
      ]
    },
    "WorkspaceDirectoryType":{
      "type":"string",
      "enum":[
        "SIMPLE_AD",
        "AD_CONNECTOR"
      ]
    },
    "WorkspaceErrorCode":{"type":"string"},
    "WorkspaceId":{
      "type":"string",
      "pattern":"^ws-[0-9a-z]{8,63}$"
    },
    "WorkspaceIdList":{
      "type":"list",
      "member":{"shape":"WorkspaceId"},
      "min":1,
      "max":25
    },
    "WorkspaceList":{
      "type":"list",
      "member":{"shape":"Workspace"}
    },
    "WorkspaceRequest":{
      "type":"structure",
      "required":[
        "DirectoryId",
        "UserName",
        "BundleId"
      ],
      "members":{
        "DirectoryId":{
          "shape":"DirectoryId",
          "documentation":"<p>The identifier of the AWS Directory Service directory to create the WorkSpace in. You can use the <a>DescribeWorkspaceDirectories</a> operation to obtain a list of the directories that are available.</p>"
        },
        "UserName":{
          "shape":"UserName",
          "documentation":"<p>The username that the WorkSpace is assigned to. This username must exist in the AWS Directory Service directory specified by the <code>DirectoryId</code> member.</p>"
        },
        "BundleId":{
          "shape":"BundleId",
          "documentation":"<p>The identifier of the bundle to create the WorkSpace from. You can use the <a>DescribeWorkspaceBundles</a> operation to obtain a list of the bundles that are available.</p>"
        },
        "VolumeEncryptionKey":{
          "shape":"VolumeEncryptionKey",
          "documentation":"<p>The KMS key used to encrypt data stored on your WorkSpace.</p>"
        },
        "UserVolumeEncryptionEnabled":{
          "shape":"BooleanObject",
          "documentation":"<p>Specifies whether the data stored on the user volume, or D: drive, is encrypted.</p>"
        },
        "RootVolumeEncryptionEnabled":{
          "shape":"BooleanObject",
          "documentation":"<p>Specifies whether the data stored on the root volume, or C: drive, is encrypted.</p>"
        }
      },
      "documentation":"<p>Contains information about a WorkSpace creation request.</p>"
    },
    "WorkspaceRequestList":{
      "type":"list",
      "member":{"shape":"WorkspaceRequest"},
      "min":1,
      "max":25
    },
    "WorkspaceState":{
      "type":"string",
      "enum":[
        "PENDING",
        "AVAILABLE",
        "IMPAIRED",
        "UNHEALTHY",
        "REBOOTING",
        "REBUILDING",
        "TERMINATING",
        "TERMINATED",
        "SUSPENDED",
        "ERROR"
      ]
    }
  },
  "examples":{
  }
}
                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/botocore/docs/                                                0042755 0000000 0000062 00000000000 13077704402 020772  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/docs/__init__.py                                     0100644 0000000 0000062 00000003007 13077704371 023103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import os

from botocore.docs.service import ServiceDocumenter


def generate_docs(root_dir, session):
    """Generates the reference documentation for botocore

    This will go through every available AWS service and output ReSTructured
    text files documenting each service.

    :param root_dir: The directory to write the reference files to. Each
        service's reference documentation is loacated at
        root_dir/reference/services/service-name.rst
    """
    services_doc_path = os.path.join(root_dir, 'reference', 'services')
    if not os.path.exists(services_doc_path):
        os.makedirs(services_doc_path)

    # Generate reference docs and write them out.
    for service_name in session.get_available_services():
        docs = ServiceDocumenter(service_name, session).document_service()
        service_doc_path = os.path.join(
            services_doc_path, service_name + '.rst')
        with open(service_doc_path, 'wb') as f:
            f.write(docs)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/botocore/docs/__init__.pyc                                    0100644 0000000 0000062 00000002266 13077704401 023246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s)   d  d l  Z  d  d l m Z d   Z d S(   iN(   t   ServiceDocumenterc         C   s   t  j j |  d d  } t  j j |  s: t  j |  n  xg | j   D]Y } t | |  j   } t  j j | | d  } t | d   } | j	 |  Wd QXqG Wd S(   sf  Generates the reference documentation for botocore

    This will go through every available AWS service and output ReSTructured
    text files documenting each service.

    :param root_dir: The directory to write the reference files to. Each
        service's reference documentation is loacated at
        root_dir/reference/services/service-name.rst
    t	   referencet   servicess   .rstt   wbN(
   t   ost   patht   joint   existst   makedirst   get_available_servicesR    t   document_servicet   opent   write(   t   root_dirt   sessiont   services_doc_patht   service_namet   docst   service_doc_patht   f(    (    s8   /tmp/pip-build-awuatQ/botocore/botocore/docs/__init__.pyt   generate_docs   s    
	(   R   t   botocore.docs.serviceR    R   (    (    (    s8   /tmp/pip-build-awuatQ/botocore/botocore/docs/__init__.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                             usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/                                          0042755 0000000 0000062 00000000000 13077704402 022044  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/__init__.py                               0100644 0000000 0000062 00000001114 13077704371 024152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
__version__ = '0.16.0'
                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/__init__.pyc                              0100644 0000000 0000062 00000000266 13077704401 024316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s
   d  Z  d S(   s   0.16.0N(   t   __version__(    (    (    s>   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/__init__.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/docevents.py                              0100644 0000000 0000062 00000011175 13077704371 024415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.


DOC_EVENTS = {
    'doc-breadcrumbs': '.%s',
    'doc-title': '.%s',
    'doc-description': '.%s',
    'doc-synopsis-start': '.%s',
    'doc-synopsis-option': '.%s.%s',
    'doc-synopsis-end': '.%s',
    'doc-options-start': '.%s',
    'doc-option': '.%s.%s',
    'doc-option-example': '.%s.%s',
    'doc-options-end': '.%s',
    'doc-examples': '.%s',
    'doc-output': '.%s',
    'doc-subitems-start': '.%s',
    'doc-subitem': '.%s.%s',
    'doc-subitems-end': '.%s',
    'doc-relateditems-start': '.%s',
    'doc-relateditem': '.%s.%s',
    'doc-relateditems-end': '.%s'
    }


def generate_events(session, help_command):
    # Now generate the documentation events
    session.emit('doc-breadcrumbs.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-title.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-description.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-synopsis-start.%s' % help_command.event_class,
                 help_command=help_command)
    if help_command.arg_table:
        for arg_name in help_command.arg_table:
            # An argument can set an '_UNDOCUMENTED' attribute
            # to True to indicate a parameter that exists
            # but shouldn't be documented.  This can be used
            # for backwards compatibility of deprecated arguments.
            if getattr(help_command.arg_table[arg_name],
                       '_UNDOCUMENTED', False):
                continue
            session.emit(
                'doc-synopsis-option.%s.%s' % (help_command.event_class,
                                               arg_name),
                arg_name=arg_name, help_command=help_command)
    session.emit('doc-synopsis-end.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-options-start.%s' % help_command.event_class,
                 help_command=help_command)
    if help_command.arg_table:
        for arg_name in help_command.arg_table:
            if getattr(help_command.arg_table[arg_name],
                       '_UNDOCUMENTED', False):
                continue
            session.emit('doc-option.%s.%s' % (help_command.event_class,
                                               arg_name),
                         arg_name=arg_name, help_command=help_command)
            session.emit('doc-option-example.%s.%s' %
                         (help_command.event_class, arg_name),
                         arg_name=arg_name, help_command=help_command)
    session.emit('doc-options-end.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-subitems-start.%s' % help_command.event_class,
                 help_command=help_command)
    if help_command.command_table:
        for command_name in sorted(help_command.command_table.keys()):
            if hasattr(help_command.command_table[command_name],
                       '_UNDOCUMENTED'):
                continue
            session.emit('doc-subitem.%s.%s'
                         % (help_command.event_class, command_name),
                         command_name=command_name,
                         help_command=help_command)
    session.emit('doc-subitems-end.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-examples.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-output.%s' % help_command.event_class,
                 help_command=help_command)
    session.emit('doc-relateditems-start.%s' % help_command.event_class,
                 help_command=help_command)
    if help_command.related_items:
        for related_item in sorted(help_command.related_items):
            session.emit('doc-relateditem.%s.%s'
                         % (help_command.event_class, related_item),
                         help_command=help_command,
                         related_item=related_item)
    session.emit('doc-relateditems-end.%s' % help_command.event_class,
                 help_command=help_command)
                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/docevents.pyc                             0100644 0000000 0000062 00000004617 13077704401 024555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   i d  d 6d  d 6d  d 6d  d 6d d 6d  d 6d  d 6d d	 6d d
 6d  d 6d  d 6d  d 6d  d 6d d 6d  d 6d  d 6d d 6d  d 6Z  d   Z d S(   s   .%ss   doc-breadcrumbss	   doc-titles   doc-descriptions   doc-synopsis-starts   .%s.%ss   doc-synopsis-options   doc-synopsis-ends   doc-options-starts
   doc-options   doc-option-examples   doc-options-ends   doc-exampless
   doc-outputs   doc-subitems-starts   doc-subitems   doc-subitems-ends   doc-relateditems-starts   doc-relateditems   doc-relateditems-endc         C   s   |  j  d | j d | |  j  d | j d | |  j  d | j d | |  j  d | j d | | j r xY | j D]K } t | j | d t  r q{ n  |  j  d | j | f d | d | q{ Wn  |  j  d	 | j d | |  j  d
 | j d | | j rx | j D]q } t | j | d t  r9qn  |  j  d | j | f d | d | |  j  d | j | f d | d | qWn  |  j  d | j d | |  j  d | j d | | j r.xb t | j j    D]H } t | j | d  rqn  |  j  d | j | f d | d | qWn  |  j  d | j d | |  j  d | j d | |  j  d | j d | |  j  d | j d | | j	 rx@ t | j	  D], } |  j  d | j | f d | d | qWn  |  j  d | j d | d  S(   Ns   doc-breadcrumbs.%st   help_commands   doc-title.%ss   doc-description.%ss   doc-synopsis-start.%st   _UNDOCUMENTEDs   doc-synopsis-option.%s.%st   arg_names   doc-synopsis-end.%ss   doc-options-start.%ss   doc-option.%s.%ss   doc-option-example.%s.%ss   doc-options-end.%ss   doc-subitems-start.%ss   doc-subitem.%s.%st   command_names   doc-subitems-end.%ss   doc-examples.%ss   doc-output.%ss   doc-relateditems-start.%ss   doc-relateditem.%s.%st   related_items   doc-relateditems-end.%s(
   t   emitt   event_classt	   arg_tablet   getattrt   Falset   command_tablet   sortedt   keyst   hasattrt   related_items(   t   sessionR    R   R   R   (    (    s?   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docevents.pyt   generate_events%   sz    		
	
						N(   t
   DOC_EVENTSR   (    (    (    s?   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docevents.pyt   <module>   s&   
                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/docstringparser.py                        0100644 0000000 0000062 00000013401 13077704371 025626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore.compat import six


class DocStringParser(six.moves.html_parser.HTMLParser):
    """
    A simple HTML parser.  Focused on converting the subset of HTML
    that appears in the documentation strings of the JSON models into
    simple ReST format.
    """

    def __init__(self, doc):
        self.tree = None
        self.doc = doc
        six.moves.html_parser.HTMLParser.__init__(self)

    def reset(self):
        six.moves.html_parser.HTMLParser.reset(self)
        self.tree = HTMLTree(self.doc)

    def feed(self, data):
        # HTMLParser is an old style class, so the super() method will not work.
        six.moves.html_parser.HTMLParser.feed(self, data)
        self.tree.write()
        self.tree = HTMLTree(self.doc)

    def close(self):
        six.moves.html_parser.HTMLParser.close(self)
        # Write if there is anything remaining.
        self.tree.write()
        self.tree = HTMLTree(self.doc)

    def handle_starttag(self, tag, attrs):
        self.tree.add_tag(tag, attrs=attrs)

    def handle_endtag(self, tag):
        self.tree.add_tag(tag, is_start=False)

    def handle_data(self, data):
        self.tree.add_data(data)


class HTMLTree(object):
    """
    A tree which handles HTML nodes. Designed to work with a python HTML parser,
    meaning that the current_node will be the most recently opened tag. When
    a tag is closed, the current_node moves up to the parent node.
    """
    def __init__(self, doc):
        self.doc = doc
        self.head = StemNode()
        self.current_node = self.head
        self.unhandled_tags = []

    def add_tag(self, tag, attrs=None, is_start=True):
        if not self._doc_has_handler(tag, is_start):
            self.unhandled_tags.append(tag)
            return

        if is_start:
            if tag == 'li':
                node = LineItemNode(attrs)
            else:
                node = TagNode(tag, attrs)
            self.current_node.add_child(node)
            self.current_node = node
        else:
            self.current_node = self.current_node.parent

    def _doc_has_handler(self, tag, is_start):
        if is_start:
            handler_name = 'start_%s' % tag
        else:
            handler_name = 'end_%s' % tag

        return hasattr(self.doc.style, handler_name)

    def add_data(self, data):
        self.current_node.add_child(DataNode(data))

    def write(self):
        self.head.write(self.doc)


class Node(object):
    def __init__(self, parent=None):
        self.parent = parent

    def write(self, doc):
        raise NotImplementedError


class StemNode(Node):
    def __init__(self, parent=None):
        super(StemNode, self).__init__(parent)
        self.children = []

    def add_child(self, child):
        child.parent = self
        self.children.append(child)

    def write(self, doc):
        self._write_children(doc)

    def _write_children(self, doc):
        for child in self.children:
            child.write(doc)


class TagNode(StemNode):
    """
    A generic Tag node. It will verify that handlers exist before writing.
    """
    def __init__(self, tag, attrs=None, parent=None):
        super(TagNode, self).__init__(parent)
        self.attrs = attrs
        self.tag = tag

    def write(self, doc):
        self._write_start(doc)
        self._write_children(doc)
        self._write_end(doc)

    def _write_start(self, doc):
        handler_name = 'start_%s' % self.tag
        if hasattr(doc.style, handler_name):
            getattr(doc.style, handler_name)(self.attrs)

    def _write_end(self, doc):
        handler_name = 'end_%s' % self.tag
        if hasattr(doc.style, handler_name):
            getattr(doc.style, handler_name)()


class LineItemNode(TagNode):
    def __init__(self, attrs=None, parent=None):
        super(LineItemNode, self).__init__('li', attrs, parent)

    def write(self, doc):
        self._lstrip(self)
        super(LineItemNode, self).write(doc)

    def _lstrip(self, node):
        """
        Traverses the tree, stripping out whitespace until text data is found
        :param node: The node to strip
        :return: True if non-whitespace data was found, False otherwise
        """
        for child in node.children:
            if isinstance(child, DataNode):
                child.lstrip()
                if child.data:
                    return True
            else:
                found = self._lstrip(child)
                if found:
                    return True

        return False


class DataNode(Node):
    """
    A Node that contains only string data.
    """
    def __init__(self, data, parent=None):
        super(DataNode, self).__init__(parent)
        if not isinstance(data, six.string_types):
            raise ValueError("Expecting string type, %s given." % type(data))
        self.data = data

    def lstrip(self):
        self.data = self.data.lstrip()

    def write(self, doc):
        if not self.data:
            return

        if self.data.isspace():
            str_data = ' '
        else:
            end_space = self.data[-1].isspace()
            words = self.data.split()
            words = doc.translate_words(words)
            str_data = ' '.join(words)
            if end_space:
                str_data += ' '

        doc.handle_data(str_data)
                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/docstringparser.pyc                       0100644 0000000 0000062 00000023034 13077704401 025766  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  d l  m Z d e j j j f d     YZ d e f d     YZ d e f d     YZ d e f d	     YZ	 d
 e	 f d     YZ
 d e
 f d     YZ d e f d     YZ d S(   i(   t   sixt   DocStringParserc           B   sM   e  Z d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 RS(   s   
    A simple HTML parser.  Focused on converting the subset of HTML
    that appears in the documentation strings of the JSON models into
    simple ReST format.
    c         C   s,   d  |  _ | |  _ t j j j j |   d  S(   N(   t   Nonet   treet   docR    t   movest   html_parsert
   HTMLParsert   __init__(   t   selfR   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s    		c         C   s,   t  j j j j |   t |  j  |  _ d  S(   N(   R    R   R   R   t   resett   HTMLTreeR   R   (   R	   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR
      s    c         C   s<   t  j j j j |  |  |  j j   t |  j  |  _ d  S(   N(	   R    R   R   R   t   feedR   t   writeR   R   (   R	   t   data(    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR       s    c         C   s9   t  j j j j |   |  j j   t |  j  |  _ d  S(   N(	   R    R   R   R   t   closeR   R   R   R   (   R	   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   &   s    c         C   s   |  j  j | d | d  S(   Nt   attrs(   R   t   add_tag(   R	   t   tagR   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyt   handle_starttag,   s    c         C   s   |  j  j | d t d  S(   Nt   is_start(   R   R   t   False(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyt   handle_endtag/   s    c         C   s   |  j  j |  d  S(   N(   R   t   add_data(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyt   handle_data2   s    (
   t   __name__t
   __module__t   __doc__R   R
   R   R   R   R   R   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s   						R   c           B   sA   e  Z d  Z d   Z d e d  Z d   Z d   Z d   Z	 RS(   s   
    A tree which handles HTML nodes. Designed to work with a python HTML parser,
    meaning that the current_node will be the most recently opened tag. When
    a tag is closed, the current_node moves up to the parent node.
    c         C   s.   | |  _  t   |  _ |  j |  _ g  |  _ d  S(   N(   R   t   StemNodet   headt   current_nodet   unhandled_tags(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   <   s    	c         C   s   |  j  | |  s& |  j j |  d  S| rr | d k rG t |  } n t | |  } |  j j |  | |  _ n |  j j |  _ d  S(   Nt   li(   t   _doc_has_handlerR   t   appendt   LineItemNodet   TagNodeR   t	   add_childt   parent(   R	   R   R   R   t   node(    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   B   s    c         C   s0   | r d | } n
 d | } t  |  j j |  S(   Ns   start_%ss   end_%s(   t   hasattrR   t   style(   R	   R   R   t   handler_name(    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR!   Q   s    
c         C   s   |  j  j t |   d  S(   N(   R   R%   t   DataNode(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   Y   s    c         C   s   |  j  j |  j  d  S(   N(   R   R   R   (   R	   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   \   s    N(
   R   R   R   R   R   t   TrueR   R!   R   R   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   6   s   			t   Nodec           B   s   e  Z d d   Z d   Z RS(   c         C   s   | |  _  d  S(   N(   R&   (   R	   R&   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   a   s    c         C   s
   t   d  S(   N(   t   NotImplementedError(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   d   s    N(   R   R   R   R   R   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR-   `   s   R   c           B   s/   e  Z d d   Z d   Z d   Z d   Z RS(   c         C   s#   t  t |   j |  g  |  _ d  S(   N(   t   superR   R   t   children(   R	   R&   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   i   s    c         C   s   |  | _  |  j j |  d  S(   N(   R&   R0   R"   (   R	   t   child(    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR%   m   s    	c         C   s   |  j  |  d  S(   N(   t   _write_children(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   q   s    c         C   s%   x |  j  D] } | j |  q
 Wd  S(   N(   R0   R   (   R	   R   R1   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR2   t   s    N(   R   R   R   R   R%   R   R2   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   h   s   		R$   c           B   s8   e  Z d  Z d d d  Z d   Z d   Z d   Z RS(   sP   
    A generic Tag node. It will verify that handlers exist before writing.
    c         C   s,   t  t |   j |  | |  _ | |  _ d  S(   N(   R/   R$   R   R   R   (   R	   R   R   R&   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR   }   s    	c         C   s+   |  j  |  |  j |  |  j |  d  S(   N(   t   _write_startR2   t
   _write_end(   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s    c         C   s?   d |  j  } t | j |  r; t | j |  |  j  n  d  S(   Ns   start_%s(   R   R(   R)   t   getattrR   (   R	   R   R*   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR3      s    c         C   s9   d |  j  } t | j |  r5 t | j |    n  d  S(   Ns   end_%s(   R   R(   R)   R5   (   R	   R   R*   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR4      s    N(   R   R   R   R   R   R   R3   R4   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR$   y   s
   		R#   c           B   s)   e  Z d d d   Z d   Z d   Z RS(   c         C   s    t  t |   j d | |  d  S(   NR    (   R/   R#   R   (   R	   R   R&   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s    c         C   s'   |  j  |   t t |   j |  d  S(   N(   t   _lstripR/   R#   R   (   R	   R   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s    c         C   sZ   xS | j  D]H } t | t  r9 | j   | j rR t Sq
 |  j |  } | r
 t Sq
 Wt S(   s   
        Traverses the tree, stripping out whitespace until text data is found
        :param node: The node to strip
        :return: True if non-whitespace data was found, False otherwise
        (   R0   t
   isinstanceR+   t   lstripR   R,   R6   R   (   R	   R'   R1   t   found(    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR6      s    
	N(   R   R   R   R   R   R6   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR#      s   	R+   c           B   s,   e  Z d  Z d d  Z d   Z d   Z RS(   s0   
    A Node that contains only string data.
    c         C   sN   t  t |   j |  t | t j  sA t d t |    n  | |  _ d  S(   Ns    Expecting string type, %s given.(	   R/   R+   R   R7   R    t   string_typest
   ValueErrort   typeR   (   R	   R   R&   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s    c         C   s   |  j  j   |  _  d  S(   N(   R   R8   (   R	   (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR8      s    c         C   s   |  j  s d  S|  j  j   r% d } nS |  j  d j   } |  j  j   } | j |  } d j |  } | rx | d 7} n  | j |  d  S(   Nt    i(   R   t   isspacet   splitt   translate_wordst   joinR   (   R	   R   t   str_datat	   end_spacet   words(    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR      s    		N(   R   R   R   R   R   R8   R   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyR+      s   	N(   t   botocore.compatR    R   R   R   R   t   objectR   R-   R   R$   R#   R+   (    (    (    sE   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/docstringparser.pyt   <module>   s   &*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/restdoc.py                                0100644 0000000 0000062 00000016072 13077704371 024067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import logging

from botocore.compat import OrderedDict
from botocore.docs.bcdoc.docstringparser import DocStringParser
from botocore.docs.bcdoc.style import ReSTStyle

LOG = logging.getLogger('bcdocs')


class ReSTDocument(object):

    def __init__(self, target='man'):
        self.style = ReSTStyle(self)
        self.target = target
        self.parser = DocStringParser(self)
        self.keep_data = True
        self.do_translation = False
        self.translation_map = {}
        self.hrefs = {}
        self._writes = []
        self._last_doc_string = None

    def _write(self, s):
        if self.keep_data and s is not None:
            self._writes.append(s)

    def write(self, content):
        """
        Write content into the document.
        """
        self._write(content)

    def writeln(self, content):
        """
        Write content on a newline.
        """
        self._write('%s%s\n' % (self.style.spaces(), content))

    def peek_write(self):
        """
        Returns the last content written to the document without
        removing it from the stack.
        """
        return self._writes[-1]

    def pop_write(self):
        """
        Removes and returns the last content written to the stack.
        """
        return self._writes.pop()

    def push_write(self, s):
        """
        Places new content on the stack.
        """
        self._writes.append(s)

    def getvalue(self):
        """
        Returns the current content of the document as a string.
        """
        if self.hrefs:
            self.style.new_paragraph()
            for refname, link in self.hrefs.items():
                self.style.link_target_definition(refname, link)
        return ''.join(self._writes).encode('utf-8')

    def translate_words(self, words):
        return [self.translation_map.get(w, w) for w in words]

    def handle_data(self, data):
        if data and self.keep_data:
            self._write(data)

    def include_doc_string(self, doc_string):
        if doc_string:
            try:
                start = len(self._writes)
                self.parser.feed(doc_string)
                self.parser.close()
                end = len(self._writes)
                self._last_doc_string = (start, end)
            except Exception:
                LOG.debug('Error parsing doc string', exc_info=True)
                LOG.debug(doc_string)

    def remove_last_doc_string(self):
        # Removes all writes inserted by last doc string
        if self._last_doc_string is not None:
            start, end = self._last_doc_string
            del self._writes[start:end]


class DocumentStructure(ReSTDocument):
    def __init__(self, name, section_names=None, target='man', context=None):
        """Provides a Hierarichial structure to a ReSTDocument

        You can write to it similiar to as you can to a ReSTDocument but
        has an innate structure for more orginaztion and abstraction.

        :param name: The name of the document
        :param section_names: A list of sections to be included
            in the document.
        :param target: The target documentation of the Document structure
        :param context: A dictionary of data to store with the strucuture. These
            are only stored per section not the entire structure.
        """
        super(DocumentStructure, self).__init__(target=target)
        self._name = name
        self._structure = OrderedDict()
        self._path = [self._name]
        self._context = {}
        if context is not None:
            self._context = context
        if section_names is not None:
            self._generate_structure(section_names)

    @property
    def name(self):
        """The name of the document structure"""
        return self._name

    @property
    def path(self):
        """
        A list of where to find a particular document structure in the
        overlying document structure.
        """
        return self._path

    @path.setter
    def path(self, value):
        self._path = value

    @property
    def available_sections(self):
        return list(self._structure)

    @property
    def context(self):
        return self._context

    def _generate_structure(self, section_names):
        for section_name in section_names:
            self.add_new_section(section_name)

    def add_new_section(self, name, context=None):
        """Adds a new section to the current document structure

        This document structure will be considered a section to the
        current document structure but will in itself be an entirely
        new document structure that can be written to and have sections
        as well

        :param name: The name of the section.
        :param context: A dictionary of data to store with the strucuture. These
            are only stored per section not the entire structure.
        :rtype: DocumentStructure
        :returns: A new document structure to add to but lives as a section
            to the document structure it was instantiated from.
        """
        # Add a new section
        section = self.__class__(name=name, target=self.target,
                                 context=context)
        section.path = self.path + [name]
        # Indent the section apporpriately as well
        section.style.indentation = self.style.indentation
        section.translation_map = self.translation_map
        section.hrefs = self.hrefs
        self._structure[name] = section
        return section

    def get_section(self, name):
        """Retrieve a section"""
        return self._structure[name]

    def delete_section(self, name):
        """Delete a section"""
        del self._structure[name]

    def flush_structure(self):
        """Flushes a doc structure to a ReSTructed string

        The document is flushed out in a DFS style where sections and their
        subsections' values are added to the string as they are visited.
        """
        # We are at the root flush the links at the beginning of the
        # document
        if len(self.path) == 1:
            if self.hrefs:
                self.style.new_paragraph()
                for refname, link in self.hrefs.items():
                    self.style.link_target_definition(refname, link)
        value = self.getvalue()
        for name, section in self._structure.items():
            value += section.flush_structure()
        return value

    def getvalue(self):
        return ''.join(self._writes).encode('utf-8')

    def remove_all_sections(self):
        self._structure = OrderedDict()

    def clear_text(self):
        self._writes = []
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/restdoc.pyc                               0100644 0000000 0000062 00000022533 13077704401 024223  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s{   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z e  j d  Z d e	 f d     YZ
 d e
 f d	     YZ d S(
   iN(   t   OrderedDict(   t   DocStringParser(   t	   ReSTStylet   bcdocst   ReSTDocumentc           B   sw   e  Z d  d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d	   Z
 d
   Z d   Z d   Z RS(   t   manc         C   sa   t  |   |  _ | |  _ t |   |  _ t |  _ t |  _ i  |  _	 i  |  _
 g  |  _ d  |  _ d  S(   N(   R   t   stylet   targetR   t   parsert   Truet	   keep_datat   Falset   do_translationt   translation_mapt   hrefst   _writest   Nonet   _last_doc_string(   t   selfR   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   __init__   s    						c         C   s,   |  j  r( | d  k	 r( |  j j |  n  d  S(   N(   R
   R   R   t   append(   R   t   s(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   _write#   s    c         C   s   |  j  |  d S(   s2   
        Write content into the document.
        N(   R   (   R   t   content(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   write'   s    c         C   s$   |  j  d |  j j   | f  d S(   s-   
        Write content on a newline.
        s   %s%s
N(   R   R   t   spaces(   R   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   writeln-   s    c         C   s   |  j  d S(   sn   
        Returns the last content written to the document without
        removing it from the stack.
        i(   R   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt
   peek_write3   s    c         C   s   |  j  j   S(   sL   
        Removes and returns the last content written to the stack.
        (   R   t   pop(   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt	   pop_write:   s    c         C   s   |  j  j |  d S(   s2   
        Places new content on the stack.
        N(   R   R   (   R   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt
   push_write@   s    c         C   se   |  j  rL |  j j   x3 |  j  j   D] \ } } |  j j | |  q& Wn  d j |  j  j d  S(   sJ   
        Returns the current content of the document as a string.
        t    s   utf-8(   R   R   t   new_paragrapht   itemst   link_target_definitiont   joinR   t   encode(   R   t   refnamet   link(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   getvalueF   s
    	c         C   s&   g  | D] } |  j  j | |  ^ q S(   N(   R   t   get(   R   t   wordst   w(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   translate_wordsP   s    c         C   s#   | r |  j  r |  j |  n  d  S(   N(   R
   R   (   R   t   data(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   handle_dataS   s    c         C   s   | r yN t  |  j  } |  j j |  |  j j   t  |  j  } | | f |  _ Wq t k
 r t j d d t	 t j |  q Xn  d  S(   Ns   Error parsing doc stringt   exc_info(
   t   lenR   R   t   feedt   closeR   t	   Exceptiont   LOGt   debugR	   (   R   t
   doc_stringt   startt   end(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   include_doc_stringW   s    c         C   s2   |  j  d  k	 r. |  j  \ } } |  j | | 5n  d  S(   N(   R   R   R   (   R   R6   R7   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   remove_last_doc_stringc   s    (   t   __name__t
   __module__R   R   R   R   R   R   R   R'   R+   R-   R8   R9   (    (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyR      s   							
			t   DocumentStructurec           B   s   e  Z d d  d d  Z e d    Z e d    Z e j d    Z e d    Z e d    Z	 d   Z
 d d  Z d	   Z d
   Z d   Z d   Z d   Z d   Z RS(   R   c         C   s~   t  t |   j d |  | |  _ t   |  _ |  j g |  _ i  |  _ | d k	 r^ | |  _ n  | d k	 rz |  j	 |  n  d S(   s5  Provides a Hierarichial structure to a ReSTDocument

        You can write to it similiar to as you can to a ReSTDocument but
        has an innate structure for more orginaztion and abstraction.

        :param name: The name of the document
        :param section_names: A list of sections to be included
            in the document.
        :param target: The target documentation of the Document structure
        :param context: A dictionary of data to store with the strucuture. These
            are only stored per section not the entire structure.
        R   N(
   t   superR<   R   t   _nameR    t
   _structuret   _patht   _contextR   t   _generate_structure(   R   t   namet   section_namesR   t   context(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyR   k   s    		c         C   s   |  j  S(   s"   The name of the document structure(   R>   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyRC      s    c         C   s   |  j  S(   sv   
        A list of where to find a particular document structure in the
        overlying document structure.
        (   R@   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   path   s    c         C   s   | |  _  d  S(   N(   R@   (   R   t   value(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyRF      s    c         C   s   t  |  j  S(   N(   t   listR?   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   available_sections   s    c         C   s   |  j  S(   N(   RA   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyRE      s    c         C   s"   x | D] } |  j  |  q Wd  S(   N(   t   add_new_section(   R   RD   t   section_name(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyRB      s    c         C   so   |  j  d | d |  j d |  } |  j | g | _ |  j j | j _ |  j | _ |  j | _ | |  j | <| S(   s  Adds a new section to the current document structure

        This document structure will be considered a section to the
        current document structure but will in itself be an entirely
        new document structure that can be written to and have sections
        as well

        :param name: The name of the section.
        :param context: A dictionary of data to store with the strucuture. These
            are only stored per section not the entire structure.
        :rtype: DocumentStructure
        :returns: A new document structure to add to but lives as a section
            to the document structure it was instantiated from.
        RC   R   RE   (   t	   __class__R   RF   R   t   indentationR   R   R?   (   R   RC   RE   t   section(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyRJ      s    	c         C   s   |  j  | S(   s   Retrieve a section(   R?   (   R   RC   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   get_section   s    c         C   s   |  j  | =d S(   s   Delete a sectionN(   R?   (   R   RC   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   delete_section   s    c         C   s   t  |  j  d k rd |  j rd |  j j   x3 |  j j   D] \ } } |  j j | |  q; Wqd n  |  j   } x- |  j j   D] \ } } | | j	   7} q W| S(   s   Flushes a doc structure to a ReSTructed string

        The document is flushed out in a DFS style where sections and their
        subsections' values are added to the string as they are visited.
        i   (
   R/   RF   R   R   R    R!   R"   R'   R?   t   flush_structure(   R   R%   R&   RG   RC   RN   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyRQ      s    	c         C   s   d j  |  j  j d  S(   NR   s   utf-8(   R#   R   R$   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyR'      s    c         C   s   t    |  _ d  S(   N(   R    R?   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   remove_all_sections   s    c         C   s   g  |  _  d  S(   N(   R   (   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt
   clear_text   s    N(   R:   R;   R   R   t   propertyRC   RF   t   setterRI   RE   RB   RJ   RO   RP   RQ   R'   RR   RS   (    (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyR<   j   s   						(   t   loggingt   botocore.compatR    t#   botocore.docs.bcdoc.docstringparserR   t   botocore.docs.bcdoc.styleR   t	   getLoggerR3   t   objectR   R<   (    (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/restdoc.pyt   <module>   s   T                                                                                                                                                                     usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/style.py                                  0100644 0000000 0000062 00000025261 13077704371 023564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

import logging

logger = logging.getLogger('bcdocs')


class BaseStyle(object):

    def __init__(self, doc, indent_width=2):
        self.doc = doc
        self.indent_width = indent_width
        self._indent = 0
        self.keep_data = True

    @property
    def indentation(self):
        return self._indent

    @indentation.setter
    def indentation(self, value):
        self._indent = value

    def new_paragraph(self):
        return '\n%s' % self.spaces()

    def indent(self):
        self._indent += 1

    def dedent(self):
        if self._indent > 0:
            self._indent -= 1

    def spaces(self):
        return ' ' * (self._indent * self.indent_width)

    def bold(self, s):
        return s

    def ref(self, link, title=None):
        return link

    def h2(self, s):
        return s

    def h3(self, s):
        return s

    def underline(self, s):
        return s

    def italics(self, s):
        return s


class ReSTStyle(BaseStyle):

    def __init__(self, doc, indent_width=2):
        BaseStyle.__init__(self, doc, indent_width)
        self.do_p = True
        self.a_href = None
        self.list_depth = 0

    def new_paragraph(self):
        self.doc.write('\n\n%s' % self.spaces())

    def new_line(self):
        self.doc.write('\n%s' % self.spaces())

    def _start_inline(self, markup):
        self.doc.write(markup)

    def _end_inline(self, markup):
        # Sometimes the HTML markup has whitespace between the end
        # of the text inside the inline markup and the closing element
        # (e.g. <b>foobar </b>).  This trailing space will cause
        # problems in the ReST inline markup so we remove it here
        # by popping the last item written off the stack, striping
        # the whitespace and then pushing it back on the stack.
        last_write = self.doc.pop_write()
        self.doc.push_write(last_write.rstrip(' '))
        self.doc.write(markup + ' ')

    def start_bold(self, attrs=None):
        self._start_inline('**')

    def end_bold(self):
        self._end_inline('**')

    def start_b(self, attrs=None):
        self.doc.do_translation = True
        self.start_bold(attrs)

    def end_b(self):
        self.doc.do_translation = False
        self.end_bold()

    def bold(self, s):
        if s:
            self.start_bold()
            self.doc.write(s)
            self.end_bold()

    def ref(self, title, link=None):
        if link is None:
            link = title
        self.doc.write(':doc:`%s <%s>`' % (title, link))

    def _heading(self, s, border_char):
        border = border_char * len(s)
        self.new_paragraph()
        self.doc.write('%s\n%s\n%s' % (border, s, border))
        self.new_paragraph()

    def h1(self, s):
        self._heading(s, '*')

    def h2(self, s):
        self._heading(s, '=')

    def h3(self, s):
        self._heading(s, '-')

    def start_italics(self, attrs=None):
        self._start_inline('*')

    def end_italics(self):
        self._end_inline('*')

    def italics(self, s):
        if s:
            self.start_italics()
            self.doc.write(s)
            self.end_italics()

    def start_p(self, attrs=None):
        if self.do_p:
            self.doc.write('\n\n%s' % self.spaces())

    def end_p(self):
        if self.do_p:
            self.doc.write('\n\n%s' % self.spaces())

    def start_code(self, attrs=None):
        self.doc.do_translation = True
        self._start_inline('``')

    def end_code(self):
        self.doc.do_translation = False
        self._end_inline('``')

    def code(self, s):
        if s:
            self.start_code()
            self.doc.write(s)
            self.end_code()

    def start_note(self, attrs=None):
        self.new_paragraph()
        self.doc.write('.. note::')
        self.indent()
        self.new_paragraph()

    def end_note(self):
        self.dedent()
        self.new_paragraph()

    def start_important(self, attrs=None):
        self.new_paragraph()
        self.doc.write('.. warning::')
        self.indent()
        self.new_paragraph()

    def end_important(self):
        self.dedent()
        self.new_paragraph()

    def start_a(self, attrs=None):
        if attrs:
            for attr_key, attr_value in attrs:
                if attr_key == 'href':
                    self.a_href = attr_value
                    self.doc.write('`')
        else:
            # There are some model documentation that
            # looks like this: <a>DescribeInstances</a>.
            # In this case we just write out an empty
            # string.
            self.doc.write(' ')
        self.doc.do_translation = True

    def link_target_definition(self, refname, link):
        self.doc.writeln('.. _%s: %s' % (refname, link))

    def sphinx_reference_label(self, label, text=None):
        if text is None:
            text = label
        if self.doc.target == 'html':
            self.doc.write(':ref:`%s <%s>`' % (text, label))
        else:
            self.doc.write(text)

    def end_a(self):
        self.doc.do_translation = False
        if self.a_href:
            last_write = self.doc.pop_write()
            last_write = last_write.rstrip(' ')
            if last_write and last_write != '`':
                if ':' in last_write:
                    last_write = last_write.replace(':', r'\:')
                self.doc.push_write(last_write)
                self.doc.hrefs[last_write] = self.a_href
                self.doc.write('`_')
            elif last_write == '`':
                # Look at start_a().  It will do a self.doc.write('`')
                # which is the start of the link title.  If that is the
                # case then there was no link text.  We should just
                # use an inline link.  The syntax of this is
                # `<http://url>`_
                self.doc.push_write('`<%s>`_' % self.a_href)
            else:
                self.doc.push_write(self.a_href)
                self.doc.hrefs[self.a_href] = self.a_href
                self.doc.write('`_')
            self.a_href = None
        self.doc.write(' ')

    def start_i(self, attrs=None):
        self.doc.do_translation = True
        self.start_italics()

    def end_i(self):
        self.doc.do_translation = False
        self.end_italics()

    def start_li(self, attrs=None):
        self.new_line()
        self.do_p = False
        self.doc.write('* ')

    def end_li(self):
        self.do_p = True
        self.new_line()

    def li(self, s):
        if s:
            self.start_li()
            self.doc.writeln(s)
            self.end_li()

    def start_ul(self, attrs=None):
        if self.list_depth != 0:
            self.indent()
        self.list_depth += 1
        self.new_paragraph()

    def end_ul(self):
        self.list_depth -= 1
        if self.list_depth != 0:
            self.dedent()
        self.new_paragraph()

    def start_ol(self, attrs=None):
        # TODO: Need to control the bullets used for LI items
        if self.list_depth != 0:
            self.indent()
        self.list_depth += 1
        self.new_paragraph()

    def end_ol(self):
        self.list_depth -= 1
        if self.list_depth != 0:
            self.dedent()
        self.new_paragraph()

    def start_examples(self, attrs=None):
        self.doc.keep_data = False

    def end_examples(self):
        self.doc.keep_data = True

    def start_fullname(self, attrs=None):
        self.doc.keep_data = False

    def end_fullname(self):
        self.doc.keep_data = True

    def start_codeblock(self, attrs=None):
        self.doc.write('::')
        self.indent()
        self.new_paragraph()

    def end_codeblock(self):
        self.dedent()
        self.new_paragraph()

    def codeblock(self, code):
        """
        Literal code blocks are introduced by ending a paragraph with
        the special marker ::.  The literal block must be indented
        (and, like all paragraphs, separated from the surrounding
        ones by blank lines).
        """
        self.start_codeblock()
        self.doc.writeln(code)
        self.end_codeblock()

    def toctree(self):
        if self.doc.target == 'html':
            self.doc.write('\n.. toctree::\n')
            self.doc.write('  :maxdepth: 1\n')
            self.doc.write('  :titlesonly:\n\n')
        else:
            self.start_ul()

    def tocitem(self, item, file_name=None):
        if self.doc.target == 'man':
            self.li(item)
        else:
            if file_name:
                self.doc.writeln('  %s' % file_name)
            else:
                self.doc.writeln('  %s' % item)

    def hidden_toctree(self):
        if self.doc.target == 'html':
            self.doc.write('\n.. toctree::\n')
            self.doc.write('  :maxdepth: 1\n')
            self.doc.write('  :hidden:\n\n')

    def hidden_tocitem(self, item):
        if self.doc.target == 'html':
            self.tocitem(item)

    def table_of_contents(self, title=None, depth=None):
        self.doc.write('.. contents:: ')
        if title is not None:
            self.doc.writeln(title)
        if depth is not None:
            self.doc.writeln('   :depth: %s' % depth)

    def start_sphinx_py_class(self, class_name):
        self.new_paragraph()
        self.doc.write('.. py:class:: %s' % class_name)
        self.indent()
        self.new_paragraph()

    def end_sphinx_py_class(self):
        self.dedent()
        self.new_paragraph()

    def start_sphinx_py_method(self, method_name, parameters=None):
        self.new_paragraph()
        content = '.. py:method:: %s' % method_name
        if parameters is not None:
            content += '(%s)' % parameters
        self.doc.write(content)
        self.indent()
        self.new_paragraph()

    def end_sphinx_py_method(self):
        self.dedent()
        self.new_paragraph()

    def start_sphinx_py_attr(self, attr_name):
        self.new_paragraph()
        self.doc.write('.. py:attribute:: %s' % attr_name)
        self.indent()
        self.new_paragraph()

    def end_sphinx_py_attr(self):
        self.dedent()
        self.new_paragraph()

    def write_py_doc_string(self, docstring):
        docstring_lines = docstring.splitlines()
        for docstring_line in docstring_lines:
            self.doc.writeln(docstring_line)
                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/style.pyc                                 0100644 0000000 0000062 00000042615 13077704401 023723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sK   d  d l  Z  e  j d  Z d e f d     YZ d e f d     YZ d S(   iNt   bcdocst	   BaseStylec           B   s   e  Z d  d  Z e d    Z e j d    Z d   Z d   Z d   Z d   Z	 d   Z
 d d	  Z d
   Z d   Z d   Z d   Z RS(   i   c         C   s(   | |  _  | |  _ d |  _ t |  _ d  S(   Ni    (   t   doct   indent_widtht   _indentt   Truet	   keep_data(   t   selfR   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   __init__   s    			c         C   s   |  j  S(   N(   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   indentation   s    c         C   s   | |  _  d  S(   N(   R   (   R   t   value(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR	      s    c         C   s   d |  j    S(   Ns   
%s(   t   spaces(   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   new_paragraph#   s    c         C   s   |  j  d 7_  d  S(   Ni   (   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   indent&   s    c         C   s%   |  j  d k r! |  j  d 8_  n  d  S(   Ni    i   (   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   dedent)   s    c         C   s   d |  j  |  j S(   Nt    (   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR   -   s    c         C   s   | S(   N(    (   R   t   s(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   bold0   s    c         C   s   | S(   N(    (   R   t   linkt   title(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   ref3   s    c         C   s   | S(   N(    (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   h26   s    c         C   s   | S(   N(    (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   h39   s    c         C   s   | S(   N(    (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt	   underline<   s    c         C   s   | S(   N(    (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   italics?   s    N(   t   __name__t
   __module__R   t   propertyR	   t   setterR   R   R   R   R   t   NoneR   R   R   R   R   (    (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR      s   								t	   ReSTStylec           B   s]  e  Z d  d  Z d   Z d   Z d   Z d   Z d< d  Z d   Z	 d< d  Z
 d	   Z d
   Z d< d  Z d   Z d   Z d   Z d   Z d< d  Z d   Z d   Z d< d  Z d   Z d< d  Z d   Z d   Z d< d  Z d   Z d< d  Z d   Z d< d  Z d   Z d< d  Z  d   Z! d< d   Z" d!   Z# d< d"  Z$ d#   Z% d$   Z& d< d%  Z' d&   Z( d< d'  Z) d(   Z* d< d)  Z+ d*   Z, d< d+  Z- d,   Z. d< d-  Z/ d.   Z0 d/   Z1 d0   Z2 d< d1  Z3 d2   Z4 d3   Z5 d< d< d4  Z6 d5   Z7 d6   Z8 d< d7  Z9 d8   Z: d9   Z; d:   Z< d;   Z= RS(=   i   c         C   s2   t  j |  | |  t |  _ d  |  _ d |  _ d  S(   Ni    (   R   R   R   t   do_pR   t   a_hreft
   list_depth(   R   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR   E   s    		c         C   s   |  j  j d |  j    d  S(   Ns   

%s(   R   t   writeR   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR   K   s    c         C   s   |  j  j d |  j    d  S(   Ns   
%s(   R   R"   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   new_lineN   s    c         C   s   |  j  j |  d  S(   N(   R   R"   (   R   t   markup(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   _start_inlineQ   s    c         C   s@   |  j  j   } |  j  j | j d   |  j  j | d  d  S(   NR   (   R   t	   pop_writet
   push_writet   rstripR"   (   R   R$   t
   last_write(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   _end_inlineT   s    c         C   s   |  j  d  d  S(   Ns   **(   R%   (   R   t   attrs(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt
   start_bold_   s    c         C   s   |  j  d  d  S(   Ns   **(   R*   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_boldb   s    c         C   s   t  |  j _ |  j |  d  S(   N(   R   R   t   do_translationR,   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_be   s    c         C   s   t  |  j _ |  j   d  S(   N(   t   FalseR   R.   R-   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_bi   s    c         C   s1   | r- |  j    |  j j |  |  j   n  d  S(   N(   R,   R   R"   R-   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR   m   s    
c         C   s3   | d  k r | } n  |  j j d | | f  d  S(   Ns   :doc:`%s <%s>`(   R   R   R"   (   R   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR   s   s    	c         C   sE   | t  |  } |  j   |  j j d | | | f  |  j   d  S(   Ns   %s
%s
%s(   t   lenR   R   R"   (   R   R   t   border_chart   border(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   _headingx   s    
c         C   s   |  j  | d  d  S(   Nt   *(   R5   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   h1~   s    c         C   s   |  j  | d  d  S(   Nt   =(   R5   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR      s    c         C   s   |  j  | d  d  S(   Nt   -(   R5   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR      s    c         C   s   |  j  d  d  S(   NR6   (   R%   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_italics   s    c         C   s   |  j  d  d  S(   NR6   (   R*   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_italics   s    c         C   s1   | r- |  j    |  j j |  |  j   n  d  S(   N(   R:   R   R"   R;   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR      s    
c         C   s*   |  j  r& |  j j d |  j    n  d  S(   Ns   

%s(   R   R   R"   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_p   s    	c         C   s*   |  j  r& |  j j d |  j    n  d  S(   Ns   

%s(   R   R   R"   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_p   s    	c         C   s   t  |  j _ |  j d  d  S(   Ns   ``(   R   R   R.   R%   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt
   start_code   s    c         C   s   t  |  j _ |  j d  d  S(   Ns   ``(   R0   R   R.   R*   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_code   s    c         C   s1   | r- |  j    |  j j |  |  j   n  d  S(   N(   R>   R   R"   R?   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   code   s    
c         C   s2   |  j    |  j j d  |  j   |  j    d  S(   Ns	   .. note::(   R   R   R"   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt
   start_note   s    

c         C   s   |  j    |  j   d  S(   N(   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_note   s    
c         C   s2   |  j    |  j j d  |  j   |  j    d  S(   Ns   .. warning::(   R   R   R"   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_important   s    

c         C   s   |  j    |  j   d  S(   N(   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_important   s    
c         C   sh   | rH xO | D]4 \ } } | d k r | |  _  |  j j d  q q Wn |  j j d  t |  j _ d  S(   Nt   hreft   `R   (   R    R   R"   R   R.   (   R   R+   t   attr_keyt
   attr_value(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_a   s    	c         C   s   |  j  j d | | f  d  S(   Ns
   .. _%s: %s(   R   t   writeln(   R   t   refnameR   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   link_target_definition   s    c         C   sX   | d  k r | } n  |  j j d k rD |  j j d | | f  n |  j j |  d  S(   Nt   htmls   :ref:`%s <%s>`(   R   R   t   targetR"   (   R   t   labelt   text(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   sphinx_reference_label   s
    	c         C   s  t  |  j _ |  j r|  j j   } | j d  } | r | d k r d | k rf | j d d  } n  |  j j |  |  j |  j j | <|  j j	 d  n_ | d k r |  j j d |  j  n9 |  j j |  j  |  j |  j j |  j <|  j j	 d  d  |  _ n  |  j j	 d  d  S(   NR   RF   t   :s   \:s   `_s   `<%s>`_(   R0   R   R.   R    R&   R(   t   replaceR'   t   hrefsR"   R   (   R   R)   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_a   s"    	c         C   s   t  |  j _ |  j   d  S(   N(   R   R   R.   R:   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_i   s    c         C   s   t  |  j _ |  j   d  S(   N(   R0   R   R.   R;   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_i   s    c         C   s'   |  j    t |  _ |  j j d  d  S(   Ns   * (   R#   R0   R   R   R"   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_li   s    
	c         C   s   t  |  _ |  j   d  S(   N(   R   R   R#   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_li   s    	c         C   s1   | r- |  j    |  j j |  |  j   n  d  S(   N(   RX   R   RJ   RY   (   R   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   li   s    
c         C   s9   |  j  d k r |  j   n  |  j  d 7_  |  j   d  S(   Ni    i   (   R!   R   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_ul  s    c         C   s9   |  j  d 8_  |  j  d k r+ |  j   n  |  j   d  S(   Ni   i    (   R!   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_ul  s    c         C   s9   |  j  d k r |  j   n  |  j  d 7_  |  j   d  S(   Ni    i   (   R!   R   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_ol  s    c         C   s9   |  j  d 8_  |  j  d k r+ |  j   n  |  j   d  S(   Ni   i    (   R!   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_ol  s    c         C   s   t  |  j _ d  S(   N(   R0   R   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_examples  s    c         C   s   t  |  j _ d  S(   N(   R   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_examples"  s    c         C   s   t  |  j _ d  S(   N(   R0   R   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_fullname%  s    c         C   s   t  |  j _ d  S(   N(   R   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_fullname(  s    c         C   s(   |  j  j d  |  j   |  j   d  S(   Ns   ::(   R   R"   R   R   (   R   R+   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_codeblock+  s    
c         C   s   |  j    |  j   d  S(   N(   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_codeblock0  s    
c         C   s(   |  j    |  j j |  |  j   d S(   s   
        Literal code blocks are introduced by ending a paragraph with
        the special marker ::.  The literal block must be indented
        (and, like all paragraphs, separated from the surrounding
        ones by blank lines).
        N(   Rc   R   RJ   Rd   (   R   R@   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt	   codeblock4  s    
c         C   sS   |  j  j d k rE |  j  j d  |  j  j d  |  j  j d  n
 |  j   d  S(   NRM   s   
.. toctree::
s     :maxdepth: 1
s     :titlesonly:

(   R   RN   R"   R[   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   toctree?  s
    c         C   sW   |  j  j d k r" |  j |  n1 | r? |  j  j d |  n |  j  j d |  d  S(   Nt   mans     %s(   R   RN   RZ   RJ   (   R   t   itemt	   file_name(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   tocitemG  s
    c         C   sI   |  j  j d k rE |  j  j d  |  j  j d  |  j  j d  n  d  S(   NRM   s   
.. toctree::
s     :maxdepth: 1
s     :hidden:

(   R   RN   R"   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   hidden_toctreeP  s    c         C   s&   |  j  j d k r" |  j |  n  d  S(   NRM   (   R   RN   Rj   (   R   Rh   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   hidden_tocitemV  s    c         C   sV   |  j  j d  | d  k	 r/ |  j  j |  n  | d  k	 rR |  j  j d |  n  d  S(   Ns   .. contents:: s      :depth: %s(   R   R"   R   RJ   (   R   R   t   depth(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   table_of_contentsZ  s
    c         C   s6   |  j    |  j j d |  |  j   |  j    d  S(   Ns   .. py:class:: %s(   R   R   R"   R   (   R   t
   class_name(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_sphinx_py_classa  s    

c         C   s   |  j    |  j   d  S(   N(   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_sphinx_py_classg  s    
c         C   sY   |  j    d | } | d  k	 r1 | d | 7} n  |  j j |  |  j   |  j    d  S(   Ns   .. py:method:: %ss   (%s)(   R   R   R   R"   R   (   R   t   method_namet
   parameterst   content(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_sphinx_py_methodk  s    


c         C   s   |  j    |  j   d  S(   N(   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_sphinx_py_methodt  s    
c         C   s6   |  j    |  j j d |  |  j   |  j    d  S(   Ns   .. py:attribute:: %s(   R   R   R"   R   (   R   t	   attr_name(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   start_sphinx_py_attrx  s    

c         C   s   |  j    |  j   d  S(   N(   R   R   (   R   (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   end_sphinx_py_attr~  s    
c         C   s1   | j    } x | D] } |  j j |  q Wd  S(   N(   t
   splitlinesR   RJ   (   R   t	   docstringt   docstring_linest   docstring_line(    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   write_py_doc_string  s    N(>   R   R   R   R   R#   R%   R*   R   R,   R-   R/   R1   R   R   R5   R7   R   R   R:   R;   R   R<   R=   R>   R?   R@   RA   RB   RC   RD   RI   RL   RQ   RU   RV   RW   RX   RY   RZ   R[   R\   R]   R^   R_   R`   Ra   Rb   Rc   Rd   Re   Rf   Rj   Rk   Rl   Rn   Rp   Rq   Ru   Rv   Rx   Ry   R~   (    (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyR   C   sv   																																							(   t   loggingt	   getLoggert   loggert   objectR   R   (    (    (    s;   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/style.pyt   <module>   s   0                                                                                                                   usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/textwriter.py                             0100644 0000000 0000062 00000050120 13077704371 024635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
"""

    Custom docutils writer for plain text.
    Based heavily on the Sphinx text writer.  See copyright below.

    :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.

"""
import os
import re
import textwrap

from docutils import nodes, writers


class TextWrapper(textwrap.TextWrapper):
    """Custom subclass that uses a different word separator regex."""

    wordsep_re = re.compile(
        r'(\s+|'                                  # any whitespace
        r'(?<=\s)(?::[a-z-]+:)?`\S+|'             # interpreted text start
        r'[^\s\w]*\w+[a-zA-Z]-(?=\w+[a-zA-Z])|'   # hyphenated words
        r'(?<=[\w\!\"\'\&\.\,\?])-{2,}(?=\w))')   # em-dash


MAXWIDTH = 70
STDINDENT = 3


def my_wrap(text, width=MAXWIDTH, **kwargs):
    w = TextWrapper(width=width, **kwargs)
    return w.wrap(text)


class TextWriter(writers.Writer):
    supported = ('text',)
    settings_spec = ('No options here.', '', ())
    settings_defaults = {}

    output = None

    def __init__(self):
        writers.Writer.__init__(self)

    def translate(self):
        visitor = TextTranslator(self.document)
        self.document.walkabout(visitor)
        self.output = visitor.body


class TextTranslator(nodes.NodeVisitor):
    sectionchars = '*=-~"+`'

    def __init__(self, document):
        nodes.NodeVisitor.__init__(self, document)

        self.nl = os.linesep
        self.states = [[]]
        self.stateindent = [0]
        self.list_counter = []
        self.sectionlevel = 0
        self.table = None

    def add_text(self, text):
        self.states[-1].append((-1, text))

    def new_state(self, indent=STDINDENT):
        self.states.append([])
        self.stateindent.append(indent)

    def end_state(self, wrap=True, end=[''], first=None):
        content = self.states.pop()
        maxindent = sum(self.stateindent)
        indent = self.stateindent.pop()
        result = []
        toformat = []
        def do_format():
            if not toformat:
                return
            if wrap:
                res = my_wrap(''.join(toformat), width=MAXWIDTH-maxindent)
            else:
                res = ''.join(toformat).splitlines()
            if end:
                res += end
            result.append((indent, res))
        for itemindent, item in content:
            if itemindent == -1:
                toformat.append(item)
            else:
                do_format()
                result.append((indent + itemindent, item))
                toformat = []
        do_format()
        if first is not None and result:
            itemindent, item = result[0]
            if item:
                result.insert(0, (itemindent - indent, [first + item[0]]))
                result[1] = (itemindent, item[1:])
        self.states[-1].extend(result)

    def visit_document(self, node):
        self.new_state(0)
    def depart_document(self, node):
        self.end_state()
        self.body = self.nl.join(line and (' '*indent + line)
                                 for indent, lines in self.states[0]
                                 for line in lines)
        # XXX header/footer?

    def visit_highlightlang(self, node):
        raise nodes.SkipNode

    def visit_section(self, node):
        self._title_char = self.sectionchars[self.sectionlevel]
        self.sectionlevel += 1
    def depart_section(self, node):
        self.sectionlevel -= 1

    def visit_topic(self, node):
        self.new_state(0)
    def depart_topic(self, node):
        self.end_state()

    visit_sidebar = visit_topic
    depart_sidebar = depart_topic

    def visit_rubric(self, node):
        self.new_state(0)
        self.add_text('-[ ')

    def depart_rubric(self, node):
        self.add_text(' ]-')
        self.end_state()

    def visit_compound(self, node):
        pass

    def depart_compound(self, node):
        pass

    def visit_glossary(self, node):
        pass
    def depart_glossary(self, node):
        pass

    def visit_title(self, node):
        if isinstance(node.parent, nodes.Admonition):
            self.add_text(node.astext()+': ')
            raise nodes.SkipNode
        self.new_state(0)
    def depart_title(self, node):
        if isinstance(node.parent, nodes.section):
            char = self._title_char
        else:
            char = '^'
        text = ''.join(x[1] for x in self.states.pop() if x[0] == -1)
        self.stateindent.pop()
        self.states[-1].append((0, ['', text, '%s' % (char * len(text)), '']))

    def visit_subtitle(self, node):
        pass
    def depart_subtitle(self, node):
        pass

    def visit_attribution(self, node):
        self.add_text('-- ')
    def depart_attribution(self, node):
        pass

    def visit_desc(self, node):
        pass
    def depart_desc(self, node):
        pass

    def visit_desc_signature(self, node):
        self.new_state(0)
        if node.parent['objtype'] in ('class', 'exception'):
            self.add_text('%s ' % node.parent['objtype'])
    def depart_desc_signature(self, node):
        # XXX: wrap signatures in a way that makes sense
        self.end_state(wrap=False, end=None)

    def visit_desc_name(self, node):
        pass
    def depart_desc_name(self, node):
        pass

    def visit_desc_addname(self, node):
        pass
    def depart_desc_addname(self, node):
        pass

    def visit_desc_type(self, node):
        pass
    def depart_desc_type(self, node):
        pass

    def visit_desc_returns(self, node):
        self.add_text(' -> ')
    def depart_desc_returns(self, node):
        pass

    def visit_desc_parameterlist(self, node):
        self.add_text('(')
        self.first_param = 1
    def depart_desc_parameterlist(self, node):
        self.add_text(')')

    def visit_desc_parameter(self, node):
        if not self.first_param:
            self.add_text(', ')
        else:
            self.first_param = 0
        self.add_text(node.astext())
        raise nodes.SkipNode

    def visit_desc_optional(self, node):
        self.add_text('[')
    def depart_desc_optional(self, node):
        self.add_text(']')

    def visit_desc_annotation(self, node):
        pass
    def depart_desc_annotation(self, node):
        pass

    def visit_refcount(self, node):
        pass
    def depart_refcount(self, node):
        pass

    def visit_desc_content(self, node):
        self.new_state()
        self.add_text(self.nl)
    def depart_desc_content(self, node):
        self.end_state()

    def visit_figure(self, node):
        self.new_state()
    def depart_figure(self, node):
        self.end_state()

    def visit_caption(self, node):
        pass
    def depart_caption(self, node):
        pass

    def visit_productionlist(self, node):
        self.new_state()
        names = []
        for production in node:
            names.append(production['tokenname'])
        maxlen = max(len(name) for name in names)
        for production in node:
            if production['tokenname']:
                self.add_text(production['tokenname'].ljust(maxlen) + ' ::=')
                lastname = production['tokenname']
            else:
                self.add_text('%s    ' % (' '*len(lastname)))
            self.add_text(production.astext() + self.nl)
        self.end_state(wrap=False)
        raise nodes.SkipNode

    def visit_seealso(self, node):
        self.new_state()
    def depart_seealso(self, node):
        self.end_state(first='')

    def visit_footnote(self, node):
        self._footnote = node.children[0].astext().strip()
        self.new_state(len(self._footnote) + 3)
    def depart_footnote(self, node):
        self.end_state(first='[%s] ' % self._footnote)

    def visit_citation(self, node):
        if len(node) and isinstance(node[0], nodes.label):
            self._citlabel = node[0].astext()
        else:
            self._citlabel = ''
        self.new_state(len(self._citlabel) + 3)
    def depart_citation(self, node):
        self.end_state(first='[%s] ' % self._citlabel)

    def visit_label(self, node):
        raise nodes.SkipNode

    # XXX: option list could use some better styling

    def visit_option_list(self, node):
        pass
    def depart_option_list(self, node):
        pass

    def visit_option_list_item(self, node):
        self.new_state(0)
    def depart_option_list_item(self, node):
        self.end_state()

    def visit_option_group(self, node):
        self._firstoption = True
    def depart_option_group(self, node):
        self.add_text('     ')

    def visit_option(self, node):
        if self._firstoption:
            self._firstoption = False
        else:
            self.add_text(', ')
    def depart_option(self, node):
        pass

    def visit_option_string(self, node):
        pass
    def depart_option_string(self, node):
        pass

    def visit_option_argument(self, node):
        self.add_text(node['delimiter'])
    def depart_option_argument(self, node):
        pass

    def visit_description(self, node):
        pass
    def depart_description(self, node):
        pass

    def visit_tabular_col_spec(self, node):
        raise nodes.SkipNode

    def visit_colspec(self, node):
        self.table[0].append(node['colwidth'])
        raise nodes.SkipNode

    def visit_tgroup(self, node):
        pass
    def depart_tgroup(self, node):
        pass

    def visit_thead(self, node):
        pass
    def depart_thead(self, node):
        pass

    def visit_tbody(self, node):
        self.table.append('sep')
    def depart_tbody(self, node):
        pass

    def visit_row(self, node):
        self.table.append([])
    def depart_row(self, node):
        pass

    def visit_entry(self, node):
        if node.has_key('morerows') or node.has_key('morecols'):
            raise NotImplementedError('Column or row spanning cells are '
                                      'not implemented.')
        self.new_state(0)
    def depart_entry(self, node):
        text = self.nl.join(self.nl.join(x[1]) for x in self.states.pop())
        self.stateindent.pop()
        self.table[-1].append(text)

    def visit_table(self, node):
        if self.table:
            raise NotImplementedError('Nested tables are not supported.')
        self.new_state(0)
        self.table = [[]]
    def depart_table(self, node):
        lines = self.table[1:]
        fmted_rows = []
        colwidths = self.table[0]
        realwidths = colwidths[:]
        separator = 0
        # don't allow paragraphs in table cells for now
        for line in lines:
            if line == 'sep':
                separator = len(fmted_rows)
            else:
                cells = []
                for i, cell in enumerate(line):
                    par = my_wrap(cell, width=colwidths[i])
                    if par:
                        maxwidth = max(map(len, par))
                    else:
                        maxwidth = 0
                    realwidths[i] = max(realwidths[i], maxwidth)
                    cells.append(par)
                fmted_rows.append(cells)

        def writesep(char='-'):
            out = ['+']
            for width in realwidths:
                out.append(char * (width+2))
                out.append('+')
            self.add_text(''.join(out) + self.nl)

        def writerow(row):
            lines = zip(*row)
            for line in lines:
                out = ['|']
                for i, cell in enumerate(line):
                    if cell:
                        out.append(' ' + cell.ljust(realwidths[i]+1))
                    else:
                        out.append(' ' * (realwidths[i] + 2))
                    out.append('|')
                self.add_text(''.join(out) + self.nl)

        for i, row in enumerate(fmted_rows):
            if separator and i == separator:
                writesep('=')
            else:
                writesep('-')
            writerow(row)
        writesep('-')
        self.table = None
        self.end_state(wrap=False)

    def visit_acks(self, node):
        self.new_state(0)
        self.add_text(', '.join(n.astext() for n in node.children[0].children)
                      + '.')
        self.end_state()
        raise nodes.SkipNode

    def visit_image(self, node):
        if 'alt' in node.attributes:
            self.add_text(_('[image: %s]') % node['alt'])
        self.add_text(_('[image]'))
        raise nodes.SkipNode

    def visit_transition(self, node):
        indent = sum(self.stateindent)
        self.new_state(0)
        self.add_text('=' * (MAXWIDTH - indent))
        self.end_state()
        raise nodes.SkipNode

    def visit_bullet_list(self, node):
        self.list_counter.append(-1)
    def depart_bullet_list(self, node):
        self.list_counter.pop()

    def visit_enumerated_list(self, node):
        self.list_counter.append(0)
    def depart_enumerated_list(self, node):
        self.list_counter.pop()

    def visit_definition_list(self, node):
        self.list_counter.append(-2)
    def depart_definition_list(self, node):
        self.list_counter.pop()

    def visit_list_item(self, node):
        if self.list_counter[-1] == -1:
            # bullet list
            self.new_state(2)
        elif self.list_counter[-1] == -2:
            # definition list
            pass
        else:
            # enumerated list
            self.list_counter[-1] += 1
            self.new_state(len(str(self.list_counter[-1])) + 2)
    def depart_list_item(self, node):
        if self.list_counter[-1] == -1:
            self.end_state(first='* ', end=None)
        elif self.list_counter[-1] == -2:
            pass
        else:
            self.end_state(first='%s. ' % self.list_counter[-1], end=None)

    def visit_definition_list_item(self, node):
        self._li_has_classifier = len(node) >= 2 and \
                                  isinstance(node[1], nodes.classifier)
    def depart_definition_list_item(self, node):
        pass

    def visit_term(self, node):
        self.new_state(0)
    def depart_term(self, node):
        if not self._li_has_classifier:
            self.end_state(end=None)

    def visit_termsep(self, node):
        self.add_text(', ')
        raise nodes.SkipNode

    def visit_classifier(self, node):
        self.add_text(' : ')
    def depart_classifier(self, node):
        self.end_state(end=None)

    def visit_definition(self, node):
        self.new_state()
    def depart_definition(self, node):
        self.end_state()

    def visit_field_list(self, node):
        pass
    def depart_field_list(self, node):
        pass

    def visit_field(self, node):
        pass
    def depart_field(self, node):
        pass

    def visit_field_name(self, node):
        self.new_state(0)
    def depart_field_name(self, node):
        self.add_text(':')
        self.end_state(end=None)

    def visit_field_body(self, node):
        self.new_state()
    def depart_field_body(self, node):
        self.end_state()

    def visit_centered(self, node):
        pass
    def depart_centered(self, node):
        pass

    def visit_hlist(self, node):
        pass
    def depart_hlist(self, node):
        pass

    def visit_hlistcol(self, node):
        pass
    def depart_hlistcol(self, node):
        pass

    def visit_admonition(self, node):
        self.new_state(0)
    def depart_admonition(self, node):
        self.end_state()

    def visit_versionmodified(self, node):
        self.new_state(0)

    def depart_versionmodified(self, node):
        self.end_state()

    def visit_literal_block(self, node):
        self.new_state()
    def depart_literal_block(self, node):
        self.end_state(wrap=False)

    def visit_doctest_block(self, node):
        self.new_state(0)
    def depart_doctest_block(self, node):
        self.end_state(wrap=False)

    def visit_line_block(self, node):
        self.new_state(0)
    def depart_line_block(self, node):
        self.end_state(wrap=False)

    def visit_line(self, node):
        pass
    def depart_line(self, node):
        pass

    def visit_block_quote(self, node):
        self.new_state()
    def depart_block_quote(self, node):
        self.end_state()

    def visit_compact_paragraph(self, node):
        pass
    def depart_compact_paragraph(self, node):
        pass

    def visit_paragraph(self, node):
        self.new_state(0)

    def depart_paragraph(self, node):
        self.end_state()

    def visit_target(self, node):
        raise nodes.SkipNode

    def visit_index(self, node):
        raise nodes.SkipNode

    def visit_substitution_definition(self, node):
        raise nodes.SkipNode

    def visit_pending_xref(self, node):
        pass
    def depart_pending_xref(self, node):
        pass

    def visit_reference(self, node):
        pass
    def depart_reference(self, node):
        pass

    def visit_download_reference(self, node):
        pass
    def depart_download_reference(self, node):
        pass

    def visit_emphasis(self, node):
        self.add_text('*')
    def depart_emphasis(self, node):
        self.add_text('*')

    def visit_literal_emphasis(self, node):
        self.add_text('*')
    def depart_literal_emphasis(self, node):
        self.add_text('*')

    def visit_strong(self, node):
        self.add_text('**')
    def depart_strong(self, node):
        self.add_text('**')

    def visit_abbreviation(self, node):
        self.add_text('')
    def depart_abbreviation(self, node):
        if node.hasattr('explanation'):
            self.add_text(' (%s)' % node['explanation'])

    def visit_title_reference(self, node):
        self.add_text('*')
    def depart_title_reference(self, node):
        self.add_text('*')

    def visit_literal(self, node):
        self.add_text('"')
    def depart_literal(self, node):
        self.add_text('"')

    def visit_subscript(self, node):
        self.add_text('_')
    def depart_subscript(self, node):
        pass

    def visit_superscript(self, node):
        self.add_text('^')
    def depart_superscript(self, node):
        pass

    def visit_footnote_reference(self, node):
        self.add_text('[%s]' % node.astext())
        raise nodes.SkipNode

    def visit_citation_reference(self, node):
        self.add_text('[%s]' % node.astext())
        raise nodes.SkipNode

    def visit_Text(self, node):
        self.add_text(node.astext())
    def depart_Text(self, node):
        pass

    def visit_generated(self, node):
        pass

    def depart_generated(self, node):
        pass

    def visit_inline(self, node):
        pass

    def depart_inline(self, node):
        pass

    def visit_problematic(self, node):
        self.add_text('>>')

    def depart_problematic(self, node):
        self.add_text('<<')

    def visit_system_message(self, node):
        self.new_state(0)
        self.add_text('<SYSTEM MESSAGE: %s>' % node.astext())
        self.end_state()
        raise nodes.SkipNode

    def visit_comment(self, node):
        raise nodes.SkipNode

    def visit_meta(self, node):
        # only valid for HTML
        raise nodes.SkipNode

    def visit_raw(self, node):
        if 'text' in node.get('format', '').split():
            self.body.append(node.astext())
        raise nodes.SkipNode

    def _visit_admonition(self, node):
        self.new_state(2)
    def _make_depart_admonition(name):
        def depart_admonition(self, node):
            self.end_state(first=name.capitalize() + ': ')
        return depart_admonition

    visit_attention = _visit_admonition
    depart_attention = _make_depart_admonition('attention')
    visit_caution = _visit_admonition
    depart_caution = _make_depart_admonition('caution')
    visit_danger = _visit_admonition
    depart_danger = _make_depart_admonition('danger')
    visit_error = _visit_admonition
    depart_error = _make_depart_admonition('error')
    visit_hint = _visit_admonition
    depart_hint = _make_depart_admonition('hint')
    visit_important = _visit_admonition
    depart_important = _make_depart_admonition('important')
    visit_note = _visit_admonition
    depart_note = _make_depart_admonition('note')
    visit_tip = _visit_admonition
    depart_tip = _make_depart_admonition('tip')
    visit_warning = _visit_admonition
    depart_warning = _make_depart_admonition('warning')

    def unknown_visit(self, node):
        raise NotImplementedError('Unknown node: ' + node.__class__.__name__)
                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/local/lib/python2.7/dist-packages/botocore/docs/bcdoc/textwriter.pyc                            0100644 0000000 0000062 00000127437 13077704401 025012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z m Z d e j f d     YZ d Z d Z	 e d  Z
 d	 e j f d
     YZ d e j f d     YZ d S(   s   

    Custom docutils writer for plain text.
    Based heavily on the Sphinx text writer.  See copyright below.

    :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.

iN(   t   nodest   writerst   TextWrapperc           B   s   e  Z d  Z e j d  Z RS(   s;   Custom subclass that uses a different word separator regex.sf   (\s+|(?<=\s)(?::[a-z-]+:)?`\S+|[^\s\w]*\w+[a-zA-Z]-(?=\w+[a-zA-Z])|(?<=[\w\!\"\'\&\.\,\?])-{2,}(?=\w))(   t   __name__t
   __module__t   __doc__t   ret   compilet
   wordsep_re(    (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyR      s   iF   i   c         K   s   t  d | |  } | j |   S(   Nt   width(   R   t   wrap(   t   textR	   t   kwargst   w(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   my_wrap    s    t
   TextWriterc           B   s;   e  Z d Z d d d f Z i  Z d Z d   Z d   Z RS(   R   s   No options here.t    c         C   s   t  j j |   d  S(   N(   R   t   Writert   __init__(   t   self(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyR   ,   s    c         C   s/   t  |  j  } |  j j |  | j |  _ d  S(   N(   t   TextTranslatort   documentt	   walkaboutt   bodyt   output(   R   t   visitor(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt	   translate/   s    (   s   text(    N(	   R   R   t	   supportedt   settings_spect   settings_defaultst   NoneR   R   R   (    (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyR   %   s   	R   c           B   s  e  Z d  Z d   Z d   Z e d  Z e d g d d  Z	 d   Z
 d   Z d   Z d	   Z d
   Z d   Z d   Z e Z e Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z  d   Z! d   Z" d   Z# d   Z$ d   Z% d    Z& d!   Z' d"   Z( d#   Z) d$   Z* d%   Z+ d&   Z, d'   Z- d(   Z. d)   Z/ d*   Z0 d+   Z1 d,   Z2 d-   Z3 d.   Z4 d/   Z5 d0   Z6 d1   Z7 d2   Z8 d3   Z9 d4   Z: d5   Z; d6   Z< d7   Z= d8   Z> d9   Z? d:   Z@ d;   ZA d<   ZB d=   ZC d>   ZD d?   ZE d@   ZF dA   ZG dB   ZH dC   ZI dD   ZJ dE   ZK dF   ZL dG   ZM dH   ZN dI   ZO dJ   ZP dK   ZQ dL   ZR dM   ZS dN   ZT dO   ZU dP   ZV dQ   ZW dR   ZX dS   ZY dT   ZZ dU   Z[ dV   Z\ dW   Z] dX   Z^ dY   Z_ dZ   Z` d[   Za d\   Zb d]   Zc d^   Zd d_   Ze d`   Zf da   Zg db   Zh dc   Zi dd   Zj de   Zk df   Zl dg   Zm dh   Zn di   Zo dj   Zp dk   Zq dl   Zr dm   Zs dn   Zt do   Zu dp   Zv dq   Zw dr   Zx ds   Zy dt   Zz du   Z{ dv   Z| dw   Z} dx   Z~ dy   Z dz   Z d{   Z d|   Z d}   Z d~   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z e Z e d  Z e Z e d  Z e Z e d  Z e Z e d  Z e Z e d  Z e Z e d  Z e Z e d  Z e Z e d  Z e Z e d  Z d   Z RS(   s   *=-~"+`c         C   sV   t  j j |  |  t j |  _ g  g |  _ d g |  _ g  |  _ d |  _	 d  |  _ d  S(   Ni    (   R    t   NodeVisitorR   t   ost   linesept   nlt   statest   stateindentt   list_countert   sectionlevelR   t   table(   R   R   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyR   8   s    		c         C   s   |  j  d j d | f  d  S(   Ni(   R#   t   append(   R   R   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   add_textB   s    c         C   s$   |  j  j g   |  j j |  d  S(   N(   R#   R(   R$   (   R   t   indent(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt	   new_stateE   s    R   c            s4  |  j  j   } t |  j   |  j j    g   g          f d   } xT | D]L \ } } | d k r  j |  q^ |    j  | | f  g   q^ W|   | d  k	 r r d \ } } | r j d |  | | d g f  | | d f  d <qn  |  j  d j   d  S(   Nc             sq    s
 d  S r2 t  d j   d t  }  n d j   j   }    rZ |    7}  n   j  |  f  d  S(   NR   R	   (   R   t   joint   MAXWIDTHt
   splitlinesR(   (   t   res(   t   endR*   t	   maxindentt   resultt   toformatR
   (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt	   do_formatO   s    "ii    i   (   R#   t   popt   sumR$   R(   R   t   insertt   extend(   R   R
   R0   t   firstt   contentR4   t
   itemindentt   item(    (   R0   R*   R1   R2   R3   R
   s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt	   end_stateI   s&    

%c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   t   node(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_documenth   s    c         C   s4   |  j    |  j j d   |  j d D  |  _ d  S(   Nc         s   s6   |  ], \ } } | D] } | o* d  | | Vq q d S(   t    N(    (   t   .0R*   t   linest   line(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pys	   <genexpr>l   s   	i    (   R=   R"   R,   R#   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_documentj   s    
c         C   s   t  j  d  S(   N(   R    t   SkipNode(   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_highlightlangq   s    c         C   s&   |  j  |  j |  _ |  j d 7_ d  S(   Ni   (   t   sectioncharsR&   t   _title_char(   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_sectiont   s    c         C   s   |  j  d 8_  d  S(   Ni   (   R&   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_sectionw   s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_topicz   s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_topic|   s    c         C   s   |  j  d  |  j d  d  S(   Ni    s   -[ (   R+   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_rubric   s    c         C   s   |  j  d  |  j   d  S(   Ns    ]-(   R)   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_rubric   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_compound   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_compound   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_glossary   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_glossary   s    c         C   sI   t  | j t j  r8 |  j | j   d  t j  n  |  j d  d  S(   Ns   : i    (   t
   isinstancet   parentR    t
   AdmonitionR)   t   astextRE   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_title   s    c         C   s   t  | j t j  r! |  j } n d } d j d   |  j j   D  } |  j j   |  j d j	 d d | d | t
 |  d g f  d  S(   Nt   ^R   c         s   s)   |  ] } | d  d k r | d Vq d S(   i    ii   N(    (   RA   t   x(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pys	   <genexpr>   s    ii    s   %s(   RS   RT   R    t   sectionRH   R,   R#   R5   R$   R(   t   len(   R   R>   t   charR   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_title   s    "c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_subtitle   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_subtitle   s    c         C   s   |  j  d  d  S(   Ns   -- (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_attribution   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_attribution   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   visit_desc   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc   s    c         C   s?   |  j  d  | j d d k r; |  j d | j d  n  d  S(   Ni    t   objtypet   classt	   exceptions   %s (   s   classs	   exception(   R+   RT   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_signature   s    c         C   s   |  j  d t d d   d  S(   NR
   R0   (   R=   t   FalseR   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_signature   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_name   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_name   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_addname   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_addname   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_type   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_type   s    c         C   s   |  j  d  d  S(   Ns    -> (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_returns   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_returns   s    c         C   s   |  j  d  d |  _ d  S(   Nt   (i   (   R)   t   first_param(   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_parameterlist   s    c         C   s   |  j  d  d  S(   Nt   )(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_parameterlist   s    c         C   sB   |  j  s |  j d  n	 d |  _  |  j | j    t j  d  S(   Ns   , i    (   Rs   R)   RV   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_parameter   s
    		c         C   s   |  j  d  d  S(   Nt   [(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_optional   s    c         C   s   |  j  d  d  S(   Nt   ](   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_optional   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_annotation   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_annotation   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_refcount   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_refcount   s    c         C   s   |  j    |  j |  j  d  S(   N(   R+   R)   R"   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_desc_content   s    
c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_desc_content   s    c         C   s   |  j    d  S(   N(   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_figure   s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_figure   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_caption   s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_caption   s    c         C   s   |  j    g  } x | D] } | j | d  q Wt d   | D  } xx | D]p } | d r |  j | d j |  d  | d } n |  j d d t |   |  j | j   |  j  qO W|  j d t	  t
 j  d  S(   Nt	   tokennamec         s   s   |  ] } t  |  Vq d  S(   N(   R[   (   RA   t   name(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pys	   <genexpr>   s    s    ::=s   %s    R@   R
   (   R+   R(   t   maxR)   t   ljustR[   RV   R"   R=   Rh   R    RE   (   R   R>   t   namest
   productiont   maxlent   lastname(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_productionlist   s    

c         C   s   |  j    d  S(   N(   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_seealso  s    c         C   s   |  j  d d  d  S(   NR9   R   (   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_seealso  s    c         C   s:   | j  d j   j   |  _ |  j t |  j  d  d  S(   Ni    i   (   t   childrenRV   t   stript	   _footnoteR+   R[   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_footnote  s    c         C   s   |  j  d d |  j  d  S(   NR9   s   [%s] (   R=   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_footnote  s    c         C   s_   t  |  r8 t | d t j  r8 | d j   |  _ n	 d |  _ |  j t  |  j  d  d  S(   Ni    R   i   (   R[   RS   R    t   labelRV   t	   _citlabelR+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_citation  s    "	c         C   s   |  j  d d |  j  d  S(   NR9   s   [%s] (   R=   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_citation  s    c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_label  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_option_list$  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_option_list&  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_option_list_item)  s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_option_list_item+  s    c         C   s   t  |  _ d  S(   N(   t   Truet   _firstoption(   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_option_group.  s    c         C   s   |  j  d  d  S(   Ns        (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_option_group0  s    c         C   s&   |  j  r t |  _  n |  j d  d  S(   Ns   , (   R   Rh   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_option3  s    	c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_option8  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_option_string;  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_option_string=  s    c         C   s   |  j  | d  d  S(   Nt	   delimiter(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_option_argument@  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_option_argumentB  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_descriptionE  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_descriptionG  s    c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_tabular_col_specJ  s    c         C   s%   |  j  d j | d  t j  d  S(   Ni    t   colwidth(   R'   R(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_colspecM  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_tgroupQ  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_tgroupS  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_theadV  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_theadX  s    c         C   s   |  j  j d  d  S(   Nt   sep(   R'   R(   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_tbody[  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_tbody]  s    c         C   s   |  j  j g   d  S(   N(   R'   R(   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt	   visit_row`  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   depart_rowb  s    c         C   s>   | j  d  s | j  d  r- t d   n  |  j d  d  S(   Nt   morerowst   morecolss1   Column or row spanning cells are not implemented.i    (   t   has_keyt   NotImplementedErrorR+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_entrye  s    c            sP     j  j   f d     j j   D  }   j j     j d j |  d  S(   Nc         3   s%   |  ] }   j  j | d   Vq d S(   i   N(   R"   R,   (   RA   RY   (   R   (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pys	   <genexpr>k  s    i(   R"   R,   R#   R5   R$   R'   R(   (   R   R>   R   (    (   R   s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_entryj  s    +c         C   s5   |  j  r t d   n  |  j d  g  g |  _  d  S(   Ns    Nested tables are not supported.i    (   R'   R   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_tableo  s    	c            s   j  d } g  }  j  d } |   d } x | D] } | d k rU t |  } q4 g  } xx t |  D]j \ } }	 t |	 d | | }
 |
 r t t t |
   } n d } t   | |    | <| j |
  qh W| j |  q4 Wd    f d  }    f d   } xM t |  D]? \ } } | rF| | k rF| d  n
 | d  | |  qW| d  d   _   j d	 t	  d  S(
   Ni   i    R   R	   t   -c            s]   d g } x0   D]( } | j  |  | d  | j  d  q W j d j |   j  d  S(   Nt   +i   R   (   R(   R)   R,   R"   (   R\   t   outR	   (   t
   realwidthsR   (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   writesep  s
    	c            s   t  |    } x | D] } d g } xk t |  D]] \ } } | rf | j d | j   | d   n | j d   | d  | j d  q/ W j d j |   j  q Wd  S(   Nt   |R@   i   i   R   (   t   zipt	   enumerateR(   R   R)   R,   R"   (   t   rowRB   RC   R   t   it   cell(   R   R   (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   writerow  s    	%t   =R
   (
   R'   R[   R   R   R   t   mapR(   R   R=   Rh   (   R   R>   RB   t
   fmted_rowst	   colwidthst	   separatorRC   t   cellsR   R   t   part   maxwidthR   R   R   (    (   R   R   s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_tablet  s6    

	c         C   sR   |  j  d  |  j d j d   | j d j D  d  |  j   t j  d  S(   Ni    s   , c         s   s   |  ] } | j    Vq d  S(   N(   RV   (   RA   t   n(    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pys	   <genexpr>  s    t   .(   R+   R)   R,   R   R=   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   visit_acks  s
    &
c         C   sM   d | j  k r- |  j t d  | d  n  |  j t d   t j  d  S(   Nt   alts   [image: %s]s   [image](   t
   attributesR)   t   _R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_image  s    c         C   sH   t  |  j  } |  j d  |  j d t |  |  j   t j  d  S(   Ni    R   (   R6   R$   R+   R)   R-   R=   R    RE   (   R   R>   R*   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_transition  s
    
c         C   s   |  j  j d  d  S(   Ni(   R%   R(   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_bullet_list  s    c         C   s   |  j  j   d  S(   N(   R%   R5   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_bullet_list  s    c         C   s   |  j  j d  d  S(   Ni    (   R%   R(   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_enumerated_list  s    c         C   s   |  j  j   d  S(   N(   R%   R5   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_enumerated_list  s    c         C   s   |  j  j d  d  S(   Ni(   R%   R(   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_definition_list  s    c         C   s   |  j  j   d  S(   N(   R%   R5   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_definition_list  s    c         C   st   |  j  d d k r# |  j d  nM |  j  d d k r9 n7 |  j  d c d 7<|  j t t |  j  d   d  d  S(   Nii   ii   (   R%   R+   R[   t   str(   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_list_item  s    c         C   sg   |  j  d d k r, |  j d d d d   n7 |  j  d d k rB n! |  j d d |  j  d d d   d  S(   NiR9   s   * R0   is   %s. (   R%   R=   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_list_item  s
    c         C   s/   t  |  d k o% t | d t j  |  _ d  S(   Ni   i   (   R[   RS   R    t
   classifiert   _li_has_classifier(   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_definition_list_item  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_definition_list_item  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   visit_term  s    c         C   s    |  j  s |  j d d   n  d  S(   NR0   (   R   R=   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_term  s    	c         C   s   |  j  d  t j  d  S(   Ns   , (   R)   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_termsep  s    c         C   s   |  j  d  d  S(   Ns    : (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_classifier  s    c         C   s   |  j  d d   d  S(   NR0   (   R=   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_classifier  s    c         C   s   |  j    d  S(   N(   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_definition  s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_definition  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_field_list  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_field_list  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_field  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_field  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_field_name  s    c         C   s!   |  j  d  |  j d d   d  S(   Nt   :R0   (   R)   R=   R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_field_name  s    c         C   s   |  j    d  S(   N(   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_field_body  s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_field_body	  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_centered  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_centered  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_hlist  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_hlist  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_hlistcol  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_hlistcol  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_admonition  s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_admonition  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_versionmodified   s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_versionmodified#  s    c         C   s   |  j    d  S(   N(   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_literal_block&  s    c         C   s   |  j  d t  d  S(   NR
   (   R=   Rh   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_literal_block(  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_doctest_block+  s    c         C   s   |  j  d t  d  S(   NR
   (   R=   Rh   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_doctest_block-  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_line_block0  s    c         C   s   |  j  d t  d  S(   NR
   (   R=   Rh   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_line_block2  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   visit_line5  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_line7  s    c         C   s   |  j    d  S(   N(   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_block_quote:  s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_block_quote<  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_compact_paragraph?  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_compact_paragraphA  s    c         C   s   |  j  d  d  S(   Ni    (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_paragraphD  s    c         C   s   |  j    d  S(   N(   R=   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_paragraphG  s    c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_targetJ  s    c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_indexM  s    c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_substitution_definitionP  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_pending_xrefS  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_pending_xrefU  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_referenceX  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_referenceZ  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_download_reference]  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_download_reference_  s    c         C   s   |  j  d  d  S(   Nt   *(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_emphasisb  s    c         C   s   |  j  d  d  S(   NR  (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_emphasisd  s    c         C   s   |  j  d  d  S(   NR  (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_literal_emphasisg  s    c         C   s   |  j  d  d  S(   NR  (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_literal_emphasisi  s    c         C   s   |  j  d  d  S(   Ns   **(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_strongl  s    c         C   s   |  j  d  d  S(   Ns   **(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_strongn  s    c         C   s   |  j  d  d  S(   NR   (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_abbreviationq  s    c         C   s+   | j  d  r' |  j d | d  n  d  S(   Nt   explanations    (%s)(   t   hasattrR)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_abbreviations  s    c         C   s   |  j  d  d  S(   NR  (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_title_referencew  s    c         C   s   |  j  d  d  S(   NR  (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_title_referencey  s    c         C   s   |  j  d  d  S(   Nt   "(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_literal|  s    c         C   s   |  j  d  d  S(   NR'  (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_literal~  s    c         C   s   |  j  d  d  S(   NR   (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_subscript  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_subscript  s    c         C   s   |  j  d  d  S(   NRX   (   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_superscript  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_superscript  s    c         C   s$   |  j  d | j    t j  d  S(   Ns   [%s](   R)   RV   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_footnote_reference  s    c         C   s$   |  j  d | j    t j  d  S(   Ns   [%s](   R)   RV   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_citation_reference  s    c         C   s   |  j  | j    d  S(   N(   R)   RV   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   visit_Text  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_Text  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_generated  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_generated  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_inline  s    c         C   s   d  S(   N(    (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_inline  s    c         C   s   |  j  d  d  S(   Ns   >>(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_problematic  s    c         C   s   |  j  d  d  S(   Ns   <<(   R)   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   depart_problematic  s    c         C   s;   |  j  d  |  j d | j    |  j   t j  d  S(   Ni    s   <SYSTEM MESSAGE: %s>(   R+   R)   RV   R=   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_system_message  s    
c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   visit_comment  s    c         C   s   t  j  d  S(   N(   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt
   visit_meta  s    c         C   sD   d | j  d d  j   k r7 |  j j | j    n  t j  d  S(   NR   t   formatR   (   t   gett   splitR   R(   RV   R    RE   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt	   visit_raw  s    c         C   s   |  j  d  d  S(   Ni   (   R+   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   _visit_admonition  s    c            s     f d   } | S(   Nc            s   |  j  d   j   d  d  S(   NR9   s   : (   R=   t
   capitalize(   R   R>   (   R   (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyR     s    (    (   R   R   (    (   R   s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   _make_depart_admonition  s    t	   attentiont   cautiont   dangert   errort   hintt	   importantt   notet   tipt   warningc         C   s   t  d | j j   d  S(   Ns   Unknown node: (   R   t	   __class__R   (   R   R>   (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   unknown_visit  s    N(   R   R   RG   R   R)   t	   STDINDENTR+   R   R   R=   R?   RD   RF   RI   RJ   RK   RL   t   visit_sidebart   depart_sidebarRM   RN   RO   RP   RQ   RR   RW   R]   R^   R_   R`   Ra   Rb   Rc   Rg   Ri   Rj   Rk   Rl   Rm   Rn   Ro   Rp   Rq   Rt   Rv   Rw   Ry   R{   R|   R}   R~   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R  R  R  R  R  R  R  R  R	  R
  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R   R!  R$  R%  R&  R(  R)  R*  R+  R,  R-  R.  R/  R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R:  R>  R?  RA  t   visit_attentiont   depart_attentiont   visit_cautiont   depart_cautiont   visit_dangert   depart_dangert   visit_errort   depart_errort
   visit_hintt   depart_hintt   visit_importantt   depart_importantt
   visit_notet   depart_notet	   visit_tipt
   depart_tipt   visit_warningt   depart_warningRL  (    (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyR   5   s  	
																																																																																				3																																																																																													(   R   R    R   t   textwrapt   docutilsR    R   R   R-   RM  R   R   R   R   R   (    (    (    s@   /tmp/pip-build-awuatQ/botocore/botocore/docs/bcdoc/textwriter.pyt   <module>
   s   
                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/docs/client.py                                       0100644 0000000 0000062 00000010744 13077704371 022630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import inspect

from botocore.docs.utils import get_official_service_name
from botocore.docs.method import document_custom_method
from botocore.docs.method import document_model_driven_method
from botocore.docs.method import get_instance_public_methods
from botocore.docs.sharedexample import document_shared_examples


class ClientDocumenter(object):
    def __init__(self, client, shared_examples=None):
        self._client = client
        self._shared_examples = shared_examples
        if self._shared_examples is None:
            self._shared_examples = {}
        self._service_name = self._client.meta.service_model.service_name

    def document_client(self, section):
        """Documents a client and its methods

        :param section: The section to write to.
        """
        self._add_title(section)
        self._add_class_signature(section)
        client_methods = get_instance_public_methods(self._client)
        self._add_client_intro(section, client_methods)
        self._add_client_methods(section, client_methods)

    def _add_title(self, section):
        section.style.h2('Client')

    def _add_client_intro(self, section, client_methods):
        section = section.add_new_section('intro')
        # Write out the top level description for the client.
        official_service_name = get_official_service_name(
            self._client.meta.service_model)
        section.write(
            'A low-level client representing %s' % official_service_name)

        # Write out the client example instantiation.
        self._add_client_creation_example(section)

        # List out all of the possible client methods.
        section.style.new_line()
        section.write('These are the available methods:')
        section.style.new_line()
        for method_name in sorted(client_methods):
            section.style.li(':py:meth:`%s`' % (method_name))

    def _add_class_signature(self, section):
        section.style.start_sphinx_py_class(
            class_name='%s.Client' % self._client.__class__.__name__)

    def _add_client_creation_example(self, section):
        section.style.start_codeblock()
        section.style.new_line()
        section.write(
            'client = session.create_client(\'{service}\')'.format(
                service=self._service_name)
        )
        section.style.end_codeblock()

    def _add_client_methods(self, section, client_methods):
        section = section.add_new_section('methods')
        for method_name in sorted(client_methods):
            self._add_client_method(
                section, method_name, client_methods[method_name])

    def _add_client_method(self, section, method_name, method):
        section = section.add_new_section(method_name)
        if self._is_custom_method(method_name):
            self._add_custom_method(section, method_name, method)
        else:
            self._add_model_driven_method(section, method_name)

    def _is_custom_method(self, method_name):
        return method_name not in self._client.meta.method_to_api_mapping

    def _add_custom_method(self, section, method_name, method):
        document_custom_method(section, method_name, method)

    def _add_model_driven_method(self, section, method_name):
        service_model = self._client.meta.service_model
        operation_name = self._client.meta.method_to_api_mapping[method_name]
        operation_model = service_model.operation_model(operation_name)

        example_prefix = 'response = client.%s' % method_name
        document_model_driven_method(
            section, method_name, operation_model,
            event_emitter=self._client.meta.events,
            method_description=operation_model.documentation,
            example_prefix=example_prefix,
        )

        # Add the shared examples
        shared_examples = self._shared_examples.get(operation_name)
        if shared_examples:
            document_shared_examples(
                section, operation_model, example_prefix, shared_examples)
                            usr/local/lib/python2.7/dist-packages/botocore/docs/client.pyc                                      0100644 0000000 0000062 00000010716 13077704401 022764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sv   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d e	 f d     YZ
 d S(	   iN(   t   get_official_service_name(   t   document_custom_method(   t   document_model_driven_method(   t   get_instance_public_methods(   t   document_shared_examplest   ClientDocumenterc           B   sn   e  Z d d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z RS(   c         C   sF   | |  _  | |  _ |  j d  k r- i  |  _ n  |  j  j j j |  _ d  S(   N(   t   _clientt   _shared_examplest   Nonet   metat   service_modelt   service_namet   _service_name(   t   selft   clientt   shared_examples(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyt   __init__   s
    		c         C   sM   |  j  |  |  j |  t |  j  } |  j | |  |  j | |  d S(   s]   Documents a client and its methods

        :param section: The section to write to.
        N(   t
   _add_titlet   _add_class_signatureR   R   t   _add_client_introt   _add_client_methods(   R   t   sectiont   client_methods(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyt   document_client   s
    c         C   s   | j  j d  d  S(   Nt   Client(   t   stylet   h2(   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR   )   s    c         C   s   | j  d  } t |  j j j  } | j d |  |  j |  | j j   | j d  | j j   x( t	 |  D] } | j j
 d |  qv Wd  S(   Nt   intros"   A low-level client representing %ss    These are the available methods:s   :py:meth:`%s`(   t   add_new_sectionR    R   R	   R
   t   writet   _add_client_creation_exampleR   t   new_linet   sortedt   li(   R   R   R   t   official_service_namet   method_name(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR   ,   s    c         C   s$   | j  j d d |  j j j  d  S(   Nt
   class_names	   %s.Client(   R   t   start_sphinx_py_classR   t	   __class__t   __name__(   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR   >   s    c         C   sG   | j  j   | j  j   | j d j d |  j   | j  j   d  S(   Ns+   client = session.create_client('{service}')t   service(   R   t   start_codeblockR   R   t   formatR   t   end_codeblock(   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR   B   s    	c         C   sA   | j  d  } x+ t |  D] } |  j | | | |  q Wd  S(   Nt   methods(   R   R    t   _add_client_method(   R   R   R   R#   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR   K   s    c         C   sH   | j  |  } |  j |  r4 |  j | | |  n |  j | |  d  S(   N(   R   t   _is_custom_methodt   _add_custom_methodt   _add_model_driven_method(   R   R   R#   t   method(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR-   Q   s    c         C   s   | |  j  j j k S(   N(   R   R	   t   method_to_api_mapping(   R   R#   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR.   X   s    c         C   s   t  | | |  d  S(   N(   R   (   R   R   R#   R1   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR/   [   s    c      
   C   s   |  j  j j } |  j  j j | } | j |  } d | } t | | | d |  j  j j d | j d | |  j j	 |  } | r t
 | | | |  n  d  S(   Ns   response = client.%st   event_emittert   method_descriptiont   example_prefix(   R   R	   R
   R2   t   operation_modelR   t   eventst   documentationR   t   getR   (   R   R   R#   R
   t   operation_nameR6   R5   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR0   ^   s    
	N(   R'   t
   __module__R   R   R   R   R   R   R   R   R-   R.   R/   R0   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyR      s   										(   t   inspectt   botocore.docs.utilsR    t   botocore.docs.methodR   R   R   t   botocore.docs.sharedexampleR   t   objectR   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/client.pyt   <module>   s                                                     usr/local/lib/python2.7/dist-packages/botocore/docs/docstring.py                                    0100644 0000000 0000062 00000007144 13077704371 023346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore.docs.method import document_model_driven_method
from botocore.docs.waiter import document_wait_method
from botocore.docs.paginator import document_paginate_method
from botocore.docs.bcdoc.restdoc import DocumentStructure


class LazyLoadedDocstring(str):
    """Used for lazily loading docstrings

    You can instantiate this class and assign it to a __doc__ value.
    The docstring will not be generated till accessed via __doc__ or
    help(). Note that all docstring classes **must** subclass from
    this class. It cannot be used directly as a docstring.
    """
    def __init__(self, *args, **kwargs):
        """
        The args and kwargs are the same as the underlying document
        generation function. These just get proxied to the underlying
        function.
        """
        super(LazyLoadedDocstring, self).__init__()
        self._gen_args = args
        self._gen_kwargs = kwargs
        self._docstring = None

    def __new__(cls, *args, **kwargs):
        # Needed in order to sub class from str with args and kwargs
        return super(LazyLoadedDocstring, cls).__new__(cls)

    def _write_docstring(self, *args, **kwargs):
        raise NotImplementedError(
            '_write_docstring is not implemented. Please subclass from '
            'this class and provide your own _write_docstring method'
        )

    def expandtabs(self, tabsize=8):
        """Expands tabs to spaces

        So this is a big hack in order to get lazy loaded docstring work
        for the ``help()``. In the ``help()`` function, ``pydoc`` and
        ``inspect`` are used. At some point the ``inspect.cleandoc``
        method is called. To clean the docs ``expandtabs`` is called
        and that is where we override the method to generate and return the
        docstrings.
        """
        if self._docstring is None:
            self._generate()
        return self._docstring.expandtabs(tabsize)

    def __str__(self):
        return self._generate()

    # __doc__ of target will use either __repr__ or __str__ of this class.
    __repr__ = __str__

    def _generate(self):
        # Generate the docstring if it is not already cached.
        if self._docstring is None:
            self._docstring = self._create_docstring()
        return self._docstring

    def _create_docstring(self):
        docstring_structure = DocumentStructure('docstring')
        # Call the document method function with the args and kwargs
        # passed to the class.
        self._write_docstring(
            docstring_structure, *self._gen_args,
            **self._gen_kwargs)
        return docstring_structure.flush_structure().decode('utf-8')


class ClientMethodDocstring(LazyLoadedDocstring):
    def _write_docstring(self, *args, **kwargs):
        document_model_driven_method(*args, **kwargs)


class WaiterDocstring(LazyLoadedDocstring):
    def _write_docstring(self, *args, **kwargs):
        document_wait_method(*args, **kwargs)


class PaginatorDocstring(LazyLoadedDocstring):
    def _write_docstring(self, *args, **kwargs):
        document_paginate_method(*args, **kwargs)
                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/botocore/docs/docstring.pyc                                   0100644 0000000 0000062 00000010706 13077704401 023501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  d l  m Z d  d l m Z d  d l m Z d  d l m Z d e f d     YZ	 d e	 f d     YZ
 d	 e	 f d
     YZ d e	 f d     YZ d S(   i(   t   document_model_driven_method(   t   document_wait_method(   t   document_paginate_method(   t   DocumentStructuret   LazyLoadedDocstringc           B   sV   e  Z d  Z d   Z d   Z d   Z d d  Z d   Z e Z d   Z	 d   Z
 RS(	   s0  Used for lazily loading docstrings

    You can instantiate this class and assign it to a __doc__ value.
    The docstring will not be generated till accessed via __doc__ or
    help(). Note that all docstring classes **must** subclass from
    this class. It cannot be used directly as a docstring.
    c         O   s2   t  t |   j   | |  _ | |  _ d |  _ d S(   s   
        The args and kwargs are the same as the underlying document
        generation function. These just get proxied to the underlying
        function.
        N(   t   superR   t   __init__t	   _gen_argst   _gen_kwargst   Nonet
   _docstring(   t   selft   argst   kwargs(    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR      s    		c         O   s   t  t |   j |   S(   N(   R   R   t   __new__(   t   clsR   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   &   s    c         O   s   t  d   d  S(   Nsq   _write_docstring is not implemented. Please subclass from this class and provide your own _write_docstring method(   t   NotImplementedError(   R   R   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyt   _write_docstring*   s    i   c         C   s,   |  j  d k r |  j   n  |  j  j |  S(   s  Expands tabs to spaces

        So this is a big hack in order to get lazy loaded docstring work
        for the ``help()``. In the ``help()`` function, ``pydoc`` and
        ``inspect`` are used. At some point the ``inspect.cleandoc``
        method is called. To clean the docs ``expandtabs`` is called
        and that is where we override the method to generate and return the
        docstrings.
        N(   R
   R	   t	   _generatet
   expandtabs(   R   t   tabsize(    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   0   s    
c         C   s
   |  j    S(   N(   R   (   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyt   __str__>   s    c         C   s(   |  j  d  k r! |  j   |  _  n  |  j  S(   N(   R
   R	   t   _create_docstring(   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   D   s    c         C   s8   t  d  } |  j | |  j |  j  | j   j d  S(   Nt	   docstrings   utf-8(   R   R   R   R   t   flush_structuret   decode(   R   t   docstring_structure(    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   J   s
    	
(   t   __name__t
   __module__t   __doc__R   R   R   R   R   t   __repr__R   R   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR      s   					t   ClientMethodDocstringc           B   s   e  Z d    Z RS(   c         O   s   t  | |   d  S(   N(   R    (   R   R   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   U   s    (   R   R   R   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   T   s   t   WaiterDocstringc           B   s   e  Z d    Z RS(   c         O   s   t  | |   d  S(   N(   R   (   R   R   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   Z   s    (   R   R   R   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR    Y   s   t   PaginatorDocstringc           B   s   e  Z d    Z RS(   c         O   s   t  | |   d  S(   N(   R   (   R   R   R   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR   _   s    (   R   R   R   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyR!   ^   s   N(   t   botocore.docs.methodR    t   botocore.docs.waiterR   t   botocore.docs.paginatorR   t   botocore.docs.bcdoc.restdocR   t   strR   R   R    R!   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/docstring.pyt   <module>   s   A                                                          usr/local/lib/python2.7/dist-packages/botocore/docs/example.py                                      0100644 0000000 0000062 00000020214 13077704371 022776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore.docs.shape import ShapeDocumenter
from botocore.docs.utils import py_default


class BaseExampleDocumenter(ShapeDocumenter):
    def document_example(self, section, shape, prefix=None, include=None,
                         exclude=None):
        """Generates an example based on a shape

        :param section: The section to write the documentation to.

        :param shape: The shape of the operation.

        :param prefix: Anything to be included before the example

        :type include: Dictionary where keys are parameter names and
            values are the shapes of the parameter names.
        :param include: The parameter shapes to include in the documentation.

        :type exclude: List of the names of the parameters to exclude.
        :param exclude: The names of the parameters to exclude from
            documentation.
        """
        history = []
        section.style.new_line()
        section.style.start_codeblock()
        if prefix is not None:
            section.write(prefix)
        self.traverse_and_document_shape(
            section=section, shape=shape, history=history,
            include=include, exclude=exclude)

    def document_recursive_shape(self, section, shape, **kwargs):
        section.write('{\'... recursive ...\'}')

    def document_shape_default(self, section, shape, history, include=None,
                               exclude=None, **kwargs):
        py_type = self._get_special_py_default(shape)
        if py_type is None:
            py_type = py_default(shape.type_name)

        if self._context.get('streaming_shape') == shape:
            py_type = 'StreamingBody()'
        section.write(py_type)

    def document_shape_type_string(self, section, shape, history,
                                   include=None, exclude=None, **kwargs):
        if 'enum' in shape.metadata:
            for i, enum in enumerate(shape.metadata['enum']):
                section.write('\'%s\'' % enum)
                if i < len(shape.metadata['enum']) - 1:
                    section.write('|')
        else:
            self.document_shape_default(section, shape, history)

    def document_shape_type_list(self, section, shape, history, include=None,
                                 exclude=None, **kwargs):
        param_shape = shape.member
        list_section = section.add_new_section('list-value')
        self._start_nested_param(list_section, '[')
        param_section = list_section.add_new_section(
            'member', context={'shape': param_shape.name})
        self.traverse_and_document_shape(
            section=param_section, shape=param_shape, history=history)
        ending_comma_section = list_section.add_new_section('ending-comma')
        ending_comma_section.write(',')
        ending_bracket_section = list_section.add_new_section(
            'ending-bracket')
        self._end_nested_param(ending_bracket_section, ']')

    def document_shape_type_structure(self, section, shape, history,
                                      include=None, exclude=None, **kwargs):
        section = section.add_new_section('structure-value')
        self._start_nested_param(section, '{')

        input_members = self._add_members_to_shape(shape.members, include)

        for i, param in enumerate(input_members):
            if exclude and param in exclude:
                continue
            param_section = section.add_new_section(param)
            param_section.write('\'%s\': ' % param)
            param_shape = input_members[param]
            param_value_section = param_section.add_new_section(
                'member-value', context={'shape': param_shape.name})
            self.traverse_and_document_shape(
                section=param_value_section, shape=param_shape,
                history=history, name=param)
            if i < len(input_members) - 1:
                ending_comma_section = param_section.add_new_section(
                    'ending-comma')
                ending_comma_section.write(',')
                ending_comma_section.style.new_line()
        self._end_structure(section, '{', '}')

    def document_shape_type_map(self, section, shape, history,
                                include=None, exclude=None, **kwargs):
        map_section = section.add_new_section('map-value')
        self._start_nested_param(map_section, '{')
        value_shape = shape.value
        key_section = map_section.add_new_section(
            'key', context={'shape': shape.key.name})
        key_section.write('\'string\': ')
        value_section = map_section.add_new_section(
            'value', context={'shape': value_shape.name})
        self.traverse_and_document_shape(
            section=value_section, shape=value_shape, history=history)
        end_bracket_section = map_section.add_new_section('ending-bracket')
        self._end_nested_param(end_bracket_section, '}')

    def _add_members_to_shape(self, members, include):
        if include:
            members = members.copy()
            for param in include:
                members[param.name] = param
        return members

    def _start_nested_param(self, section, start=None):
        if start is not None:
            section.write(start)
        section.style.indent()
        section.style.indent()
        section.style.new_line()

    def _end_nested_param(self, section, end=None):
        section.style.dedent()
        section.style.dedent()
        section.style.new_line()
        if end is not None:
            section.write(end)

    def _end_structure(self, section, start, end):
        # If there are no members in the strucuture, then make sure the
        # start and the end bracket are on the same line, by removing all
        # previous text and writing the start and end.
        if not section.available_sections:
            section.clear_text()
            section.write(start + end)
            self._end_nested_param(section)
        else:
            end_bracket_section = section.add_new_section('ending-bracket')
            self._end_nested_param(end_bracket_section, end)


class ResponseExampleDocumenter(BaseExampleDocumenter):
    EVENT_NAME = 'response-example'


class RequestExampleDocumenter(BaseExampleDocumenter):
    EVENT_NAME = 'request-example'


    def document_shape_type_structure(self, section, shape, history,
                                      include=None, exclude=None, **kwargs):
        param_format = '\'%s\''
        operator = ': '
        start = '{'
        end = '}'

        if len(history) <= 1:
            operator = '='
            start = '('
            end = ')'
            param_format = '%s'
        section = section.add_new_section('structure-value')
        self._start_nested_param(section, start)
        input_members = self._add_members_to_shape(shape.members, include)

        for i, param in enumerate(input_members):
            if exclude and param in exclude:
                continue
            param_section = section.add_new_section(param)
            param_section.write(param_format % param)
            param_section.write(operator)
            param_shape = input_members[param]
            param_value_section = param_section.add_new_section(
                'member-value', context={'shape': param_shape.name})
            self.traverse_and_document_shape(
                section=param_value_section, shape=param_shape,
                history=history, name=param)
            if i < len(input_members) - 1:
                ending_comma_section = param_section.add_new_section(
                    'ending-comma')
                ending_comma_section.write(',')
                ending_comma_section.style.new_line()
        self._end_structure(section, start, end)
                                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/botocore/docs/example.pyc                                     0100644 0000000 0000062 00000016302 13077704401 023136  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sf   d  d l  m Z d  d l m Z d e f d     YZ d e f d     YZ d e f d     YZ d	 S(
   i(   t   ShapeDocumenter(   t
   py_defaultt   BaseExampleDocumenterc           B   s   e  Z d d d d   Z d   Z d d d  Z d d d  Z d d d  Z d d d  Z d d d  Z	 d   Z
 d d  Z d d	  Z d
   Z RS(   c         C   sh   g  } | j  j   | j  j   | d k	 r< | j |  n  |  j d | d | d | d | d |  d S(   s]  Generates an example based on a shape

        :param section: The section to write the documentation to.

        :param shape: The shape of the operation.

        :param prefix: Anything to be included before the example

        :type include: Dictionary where keys are parameter names and
            values are the shapes of the parameter names.
        :param include: The parameter shapes to include in the documentation.

        :type exclude: List of the names of the parameters to exclude.
        :param exclude: The names of the parameters to exclude from
            documentation.
        t   sectiont   shapet   historyt   includet   excludeN(   t   stylet   new_linet   start_codeblockt   Nonet   writet   traverse_and_document_shape(   t   selfR   R   t   prefixR   R   R   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_example   s    	c         K   s   | j  d  d  S(   Ns   {'... recursive ...'}(   R   (   R   R   R   t   kwargs(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_recursive_shape-   s    c         K   s_   |  j  |  } | d  k r- t | j  } n  |  j j d  | k rN d } n  | j |  d  S(   Nt   streaming_shapes   StreamingBody()(   t   _get_special_py_defaultR   R   t	   type_namet   _contextt   getR   (   R   R   R   R   R   R   R   t   py_type(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_shape_default0   s    	c   	      K   s   d | j  k rt xu t | j  d  D]J \ } } | j d |  | t | j  d  d k  r# | j d  q# q# Wn |  j | | |  d  S(   Nt   enums   '%s'i   t   |(   t   metadatat	   enumerateR   t   lenR   (	   R   R   R   R   R   R   R   t   iR   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_shape_type_string:   s     c         K   s   | j  } | j d  } |  j | d  | j d d i | j d 6}	 |  j d |	 d | d |  | j d  }
 |
 j d	  | j d
  } |  j | d  d  S(   Ns
   list-valuet   [t   membert   contextR   R   R   s   ending-commat   ,s   ending-brackett   ](   R"   t   add_new_sectiont   _start_nested_paramt   nameR   R   t   _end_nested_param(   R   R   R   R   R   R   R   t   param_shapet   list_sectiont   param_sectiont   ending_comma_sectiont   ending_bracket_section(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_shape_type_listD   s    			c      
   K   s-  | j  d  } |  j | d  |  j | j |  } x t |  D] \ } }	 | re |	 | k re qA n  | j  |	  }
 |
 j d |	  | |	 } |
 j  d d i | j d 6} |  j d | d | d | d	 |	  | t |  d
 k  rA |
 j  d  } | j d  | j	 j
   qA qA W|  j | d d  d  S(   Ns   structure-valuet   {s   '%s': s   member-valueR#   R   R   R   R(   i   s   ending-commaR$   t   }(   R&   R'   t   _add_members_to_shapet   membersR   R   R(   R   R   R   R	   t   _end_structure(   R   R   R   R   R   R   R   t   input_membersR   t   paramR,   R*   t   param_value_sectionR-   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_shape_type_structureS   s(    
		c         K   s   | j  d  } |  j | d  | j } | j  d d i | j j d 6}	 |	 j d  | j  d d i | j d 6}
 |  j d |
 d | d	 |  | j  d
  } |  j | d  d  S(   Ns	   map-valueR0   t   keyR#   R   s
   'string': t   valueR   R   s   ending-bracketR1   (   R&   R'   R:   R9   R(   R   R   R)   (   R   R   R   R   R   R   R   t   map_sectiont   value_shapet   key_sectiont   value_sectiont   end_bracket_section(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   document_shape_type_mapl   s    		c         C   s7   | r3 | j    } x | D] } | | | j <q Wn  | S(   N(   t   copyR(   (   R   R3   R   R6   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyR2   {   s
    c         C   sG   | d  k	 r | j |  n  | j j   | j j   | j j   d  S(   N(   R   R   R   t   indentR	   (   R   R   t   start(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyR'      s
    c         C   sG   | j  j   | j  j   | j  j   | d  k	 rC | j |  n  d  S(   N(   R   t   dedentR	   R   R   (   R   R   t   end(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyR)      s
    c         C   sW   | j  s4 | j   | j | |  |  j |  n | j d  } |  j | |  d  S(   Ns   ending-bracket(   t   available_sectionst
   clear_textR   R)   R&   (   R   R   RC   RE   R?   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyR4      s    	
N(   t   __name__t
   __module__R   R   R   R   R    R/   R8   R@   R2   R'   R)   R4   (    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyR      s   	
		t   ResponseExampleDocumenterc           B   s   e  Z d  Z RS(   s   response-example(   RH   RI   t
   EVENT_NAME(    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyRJ      s   t   RequestExampleDocumenterc           B   s   e  Z d  Z d d d  Z RS(   s   request-examplec      
   K   s  d } d } d }	 d }
 t  |  d k rE d } d }	 d }
 d	 } n  | j d
  } |  j | |	  |  j | j |  } x t |  D] \ } } | r | | k r q n  | j |  } | j | |  | j |  | | } | j d d i | j d 6} |  j d | d | d | d |  | t  |  d k  r | j d  } | j d  | j	 j
   q q W|  j | |	 |
  d  S(   Ns   '%s's   : R0   R1   i   t   =t   (t   )s   %ss   structure-values   member-valueR#   R   R   R   R(   s   ending-commaR$   (   R   R&   R'   R2   R3   R   R   R(   R   R   R	   R4   (   R   R   R   R   R   R   R   t   param_formatt   operatorRC   RE   R5   R   R6   R,   R*   R7   R-   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyR8      s<    	
		N(   RH   RI   RK   R   R8   (    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyRL      s   N(   t   botocore.docs.shapeR    t   botocore.docs.utilsR   R   RJ   RL   (    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/example.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/docs/method.py                                       0100644 0000000 0000062 00000023105 13077704371 022625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import inspect

from botocore.docs.params import RequestParamsDocumenter
from botocore.docs.params import ResponseParamsDocumenter
from botocore.docs.example import ResponseExampleDocumenter
from botocore.docs.example import RequestExampleDocumenter


def get_instance_public_methods(instance):
    """Retrieves an objects public methods

    :param instance: The instance of the class to inspect
    :rtype: dict
    :returns: A dictionary that represents an instance's methods where
        the keys are the name of the methods and the
        values are the handler to the method.
    """
    instance_members = inspect.getmembers(instance)
    instance_methods = {}
    for name, member in instance_members:
        if not name.startswith('_'):
            if inspect.ismethod(member):
                instance_methods[name] = member
    return instance_methods


def document_model_driven_signature(section, name, operation_model,
                                    include=None, exclude=None):
    """Documents the signature of a model-driven method

    :param section: The section to write the documentation to.

    :param name: The name of the method

    :param operation_model: The operation model for the method

    :type include: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include: The parameter shapes to include in the documentation.

    :type exclude: List of the names of the parameters to exclude.
    :param exclude: The names of the parameters to exclude from
        documentation.
    """
    params = {}
    if operation_model.input_shape:
        params = operation_model.input_shape.members

    parameter_names = list(params.keys())

    if include is not None:
        for member in include:
            parameter_names.append(member.name)

    if exclude is not None:
        for member in exclude:
            if member in parameter_names:
                parameter_names.remove(member)

    signature_params = ''
    if parameter_names:
        signature_params = '**kwargs'
    section.style.start_sphinx_py_method(name, signature_params)


def document_custom_signature(section, name, method,
                              include=None, exclude=None):
    """Documents the signature of a custom method

    :param section: The section to write the documentation to.

    :param name: The name of the method

    :param method: The handle to the method being documented

    :type include: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include: The parameter shapes to include in the documentation.

    :type exclude: List of the names of the parameters to exclude.
    :param exclude: The names of the parameters to exclude from
        documentation.
    """
    args, varargs, keywords, defaults = inspect.getargspec(method)
    args = args[1:]
    signature_params = inspect.formatargspec(
        args, varargs, keywords, defaults)
    signature_params = signature_params.lstrip('(')
    signature_params = signature_params.rstrip(')')
    section.style.start_sphinx_py_method(name, signature_params)


def document_custom_method(section, method_name, method):
    """Documents a non-data driven method

    :param section: The section to write the documentation to.

    :param method_name: The name of the method

    :param method: The handle to the method being documented
    """
    document_custom_signature(
        section, method_name, method)
    method_intro_section = section.add_new_section('method-intro')
    method_intro_section.writeln('')
    doc_string = inspect.getdoc(method)
    if doc_string is not None:
        method_intro_section.style.write_py_doc_string(doc_string)


def document_model_driven_method(section, method_name, operation_model,
                                 event_emitter, method_description=None,
                                 example_prefix=None, include_input=None,
                                 include_output=None, exclude_input=None,
                                 exclude_output=None, document_output=True,
                                 include_signature=True):
    """Documents an individual method

    :param section: The section to write to

    :param method_name: The name of the method

    :param operation_model: The model of the operation

    :param event_emitter: The event emitter to use to emit events

    :param example_prefix: The prefix to use in the method example.

    :type include_input: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include_input: The parameter shapes to include in the
        input documentation.

    :type include_output: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include_input: The parameter shapes to include in the
        output documentation.

    :type exclude_input: List of the names of the parameters to exclude.
    :param exclude_input: The names of the parameters to exclude from
        input documentation.

    :type exclude_output: List of the names of the parameters to exclude.
    :param exclude_input: The names of the parameters to exclude from
        output documentation.

    :param document_output: A boolean flag to indicate whether to
        document the output.

    :param include_signature: Whether or not to include the signature.
        It is useful for generating docstrings.
    """
    # Add the signature if specified.
    if include_signature:
        document_model_driven_signature(
            section, method_name, operation_model, include=include_input,
            exclude=exclude_input)

    # Add the description for the method.
    method_intro_section = section.add_new_section('method-intro')
    method_intro_section.include_doc_string(method_description)

    # Add the example section.
    example_section = section.add_new_section('example')
    example_section.style.new_paragraph()
    example_section.style.bold('Request Syntax')

    context = {
        'special_shape_types': {
            'streaming_input_shape': operation_model.get_streaming_input(),
            'streaming_output_shape': operation_model.get_streaming_output()
        }
    }

    if operation_model.input_shape:
        RequestExampleDocumenter(
            service_name=operation_model.service_model.service_name,
            operation_name=operation_model.name,
            event_emitter=event_emitter, context=context).document_example(
                example_section, operation_model.input_shape,
                prefix=example_prefix, include=include_input,
                exclude=exclude_input)
    else:
        example_section.style.new_paragraph()
        example_section.style.start_codeblock()
        example_section.write(example_prefix + '()')

    # Add the request parameter documentation.
    request_params_section = section.add_new_section('request-params')
    if operation_model.input_shape:
        RequestParamsDocumenter(
            service_name=operation_model.service_model.service_name,
            operation_name=operation_model.name,
            event_emitter=event_emitter, context=context).document_params(
                request_params_section, operation_model.input_shape,
                include=include_input, exclude=exclude_input)

    # Add the return value documentation
    return_section = section.add_new_section('return')
    return_section.style.new_line()
    if operation_model.output_shape is not None and document_output:
        return_section.write(':rtype: dict')
        return_section.style.new_line()
        return_section.write(':returns: ')
        return_section.style.indent()
        return_section.style.new_line()

        # Add an example return value
        return_example_section = return_section.add_new_section('example')
        return_example_section.style.new_line()
        return_example_section.style.bold('Response Syntax')
        return_example_section.style.new_paragraph()
        ResponseExampleDocumenter(
            service_name=operation_model.service_model.service_name,
            operation_name=operation_model.name,
            event_emitter=event_emitter,
            context=context).document_example(
                return_example_section, operation_model.output_shape,
                include=include_output, exclude=exclude_output)

        # Add a description for the return value
        return_description_section = return_section.add_new_section(
            'description')
        return_description_section.style.new_line()
        return_description_section.style.bold('Response Structure')
        return_description_section.style.new_paragraph()
        ResponseParamsDocumenter(
            service_name=operation_model.service_model.service_name,
            operation_name=operation_model.name,
            event_emitter=event_emitter,
            context=context).document_params(
                return_description_section, operation_model.output_shape,
                include=include_output, exclude=exclude_output)
    else:
        return_section.write(':returns: None')
                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/local/lib/python2.7/dist-packages/botocore/docs/method.pyc                                      0100644 0000000 0000062 00000016426 13077704401 022772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc        	   @   s   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z d  d l m Z d   Z d d d  Z	 d d d  Z
 d	   Z d d d d d d e e d
  Z d S(   iN(   t   RequestParamsDocumenter(   t   ResponseParamsDocumenter(   t   ResponseExampleDocumenter(   t   RequestExampleDocumenterc         C   s^   t  j |   } i  } xB | D]: \ } } | j d  s t  j |  rV | | | <qV q q W| S(   s  Retrieves an objects public methods

    :param instance: The instance of the class to inspect
    :rtype: dict
    :returns: A dictionary that represents an instance's methods where
        the keys are the name of the methods and the
        values are the handler to the method.
    t   _(   t   inspectt
   getmemberst
   startswitht   ismethod(   t   instancet   instance_memberst   instance_methodst   namet   member(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/method.pyt   get_instance_public_methods   s    	c   	      C   s   i  } | j  r | j  j } n  t | j    } | d k	 r` x! | D] } | j | j  qC Wn  | d k	 r x- | D]" } | | k rs | j |  qs qs Wn  d } | r d } n  |  j j	 | |  d S(   s;  Documents the signature of a model-driven method

    :param section: The section to write the documentation to.

    :param name: The name of the method

    :param operation_model: The operation model for the method

    :type include: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include: The parameter shapes to include in the documentation.

    :type exclude: List of the names of the parameters to exclude.
    :param exclude: The names of the parameters to exclude from
        documentation.
    t    s   **kwargsN(
   t   input_shapet   memberst   listt   keyst   Nonet   appendR   t   removet   stylet   start_sphinx_py_method(	   t   sectionR   t   operation_modelt   includet   excludet   paramst   parameter_namesR   t   signature_params(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/method.pyt   document_model_driven_signature'   s    		c   
      C   sr   t  j |  \ } } } } | d } t  j | | | |  }	 |	 j d  }	 |	 j d  }	 |  j j | |	  d S(   s3  Documents the signature of a custom method

    :param section: The section to write the documentation to.

    :param name: The name of the method

    :param method: The handle to the method being documented

    :type include: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include: The parameter shapes to include in the documentation.

    :type exclude: List of the names of the parameters to exclude.
    :param exclude: The names of the parameters to exclude from
        documentation.
    i   t   (t   )N(   R   t
   getargspect   formatargspect   lstript   rstripR   R   (
   R   R   t   methodR   R   t   argst   varargst   keywordst   defaultsR   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/method.pyt   document_custom_signatureN   s    
c         C   s^   t  |  | |  |  j d  } | j d  t j |  } | d k	 rZ | j j |  n  d S(   s   Documents a non-data driven method

    :param section: The section to write the documentation to.

    :param method_name: The name of the method

    :param method: The handle to the method being documented
    s   method-introR   N(   R,   t   add_new_sectiont   writelnR   t   getdocR   R   t   write_py_doc_string(   R   t   method_nameR'   t   method_intro_sectiont
   doc_string(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/method.pyt   document_custom_methodi   s    	c      	   C   s  | r% t  |  | | d | d | n  |  j d  } | j |  |  j d  } | j j   | j j d  i i | j   d 6| j   d 6d 6} | j r t	 d	 | j
 j d
 | j d | d |  j | | j d | d | d | n+ | j j   | j j   | j | d  |  j d  } | j rrt d	 | j
 j d
 | j d | d |  j | | j d | d | n  |  j d  } | j j   | j d k	 r|
 r| j d  | j j   | j d  | j j   | j j   | j d  } | j j   | j j d  | j j   t d	 | j
 j d
 | j d | d |  j | | j d | d |	 | j d  } | j j   | j j d  | j j   t d	 | j
 j d
 | j d | d |  j | | j d | d |	 n | j d  d S(   s.  Documents an individual method

    :param section: The section to write to

    :param method_name: The name of the method

    :param operation_model: The model of the operation

    :param event_emitter: The event emitter to use to emit events

    :param example_prefix: The prefix to use in the method example.

    :type include_input: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include_input: The parameter shapes to include in the
        input documentation.

    :type include_output: Dictionary where keys are parameter names and
        values are the shapes of the parameter names.
    :param include_input: The parameter shapes to include in the
        output documentation.

    :type exclude_input: List of the names of the parameters to exclude.
    :param exclude_input: The names of the parameters to exclude from
        input documentation.

    :type exclude_output: List of the names of the parameters to exclude.
    :param exclude_input: The names of the parameters to exclude from
        output documentation.

    :param document_output: A boolean flag to indicate whether to
        document the output.

    :param include_signature: Whether or not to include the signature.
        It is useful for generating docstrings.
    R   R   s   method-introt   examples   Request Syntaxt   streaming_input_shapet   streaming_output_shapet   special_shape_typest   service_namet   operation_namet   event_emittert   contextt   prefixs   ()s   request-paramst   returns   :rtype: dicts
   :returns: s   Response Syntaxt   descriptions   Response Structures   :returns: NoneN(   R    R-   t   include_doc_stringR   t   new_paragrapht   boldt   get_streaming_inputt   get_streaming_outputR   R   t   service_modelR9   R   t   document_examplet   start_codeblockt   writeR    t   document_paramst   new_linet   output_shapeR   t   indentR   R   (   R   R1   R   R;   t   method_descriptiont   example_prefixt   include_inputt   include_outputt   exclude_inputt   exclude_outputt   document_outputt   include_signatureR2   t   example_sectionR<   t   request_params_sectiont   return_sectiont   return_example_sectiont   return_description_section(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/method.pyt   document_model_driven_method{   s    +
		
							(   R   t   botocore.docs.paramsR    R   t   botocore.docs.exampleR   R   R   R   R    R,   R4   t   TrueRZ   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/method.pyt   <module>   s   	'	                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/botocore/docs/paginator.py                                    0100644 0000000 0000062 00000015512 13077704371 023334  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore import xform_name
from botocore.compat import OrderedDict
from botocore.docs.utils import DocumentedShape
from botocore.utils import get_service_module_name
from botocore.docs.method import document_model_driven_method


class PaginatorDocumenter(object):
    def __init__(self, client, service_paginator_model):
        self._client = client
        self._service_name = self._client.meta.service_model.service_name
        self._service_paginator_model = service_paginator_model

    def document_paginators(self, section):
        """Documents the various paginators for a service

        param section: The section to write to.
        """
        section.style.h2('Paginators')
        section.style.new_line()
        section.writeln('The available paginators are:')

        paginator_names = sorted(
            self._service_paginator_model._paginator_config)

        # List the available paginators and then document each paginator.
        for paginator_name in paginator_names:
            section.style.li(
                ':py:class:`%s.Paginator.%s`' % (
                    self._client.__class__.__name__, paginator_name))
            self._add_paginator(section, paginator_name)

    def _add_paginator(self, section, paginator_name):
        section = section.add_new_section(paginator_name)

        # Docment the paginator class
        section.style.start_sphinx_py_class(
            class_name='%s.Paginator.%s' % (
                self._client.__class__.__name__, paginator_name))
        section.style.start_codeblock()
        section.style.new_line()

        # Document how to instantiate the paginator.
        section.write(
            'paginator = client.get_paginator(\'%s\')' % xform_name(
                paginator_name)
        )
        section.style.end_codeblock()
        section.style.new_line()
        # Get the pagination model for the particular paginator.
        paginator_config = self._service_paginator_model.get_paginator(
            paginator_name)
        document_paginate_method(
            section=section,
            paginator_name=paginator_name,
            event_emitter=self._client.meta.events,
            service_model=self._client.meta.service_model,
            paginator_config=paginator_config
        )


def document_paginate_method(section, paginator_name, event_emitter,
                             service_model, paginator_config,
                             include_signature=True):
    """Documents the paginate method of a paginator

    :param section: The section to write to

    :param paginator_name: The name of the paginator. It is snake cased.

    :param event_emitter: The event emitter to use to emit events

    :param service_model: The service model

    :param paginator_config: The paginator config associated to a particular
        paginator.

    :param include_signature: Whether or not to include the signature.
        It is useful for generating docstrings.
    """
    # Retrieve the operation model of the underlying operation.
    operation_model = service_model.operation_model(
        paginator_name)

    # Add representations of the request and response parameters
    # we want to include in the description of the paginate method.
    # These are parameters we expose via the botocore interface.
    pagination_config_members = OrderedDict()

    pagination_config_members['MaxItems'] = DocumentedShape(
        name='MaxItems', type_name='integer',
        documentation=(
            '<p>The total number of items to return. If the total '
            'number of items available is more than the value '
            'specified in max-items then a <code>NextToken</code> '
            'will be provided in the output that you can use to '
            'resume pagination.</p>'))

    pagination_config_members['PageSize'] = DocumentedShape(
        name='PageSize', type_name='integer',
        documentation='<p>The size of each page.<p>')

    pagination_config_members['StartingToken'] = DocumentedShape(
        name='StartingToken', type_name='string',
        documentation=(
            '<p>A token to specify where to start paginating. '
            'This is the <code>NextToken</code> from a previous '
            'response.</p>'))

    botocore_pagination_params = [
        DocumentedShape(
            name='PaginationConfig', type_name='structure',
            documentation=(
                '<p>A dictionary that provides parameters to control '
                'pagination.</p>'),
            members=pagination_config_members)
    ]

    botocore_pagination_response_params = [
        DocumentedShape(
            name='NextToken', type_name='string',
            documentation=(
                '<p>A token to resume pagination.</p>'))
    ]

    service_pagination_params = []

    # Add the normal input token of the method to a list
    # of input paramters that we wish to hide since we expose our own.
    if isinstance(paginator_config['input_token'], list):
        service_pagination_params += paginator_config['input_token']
    else:
        service_pagination_params.append(paginator_config['input_token'])

    # Hide the limit key in the documentation.
    if paginator_config.get('limit_key', None):
        service_pagination_params.append(paginator_config['limit_key'])

    # Hide the output tokens in the documentation.
    service_pagination_response_params = []
    if isinstance(paginator_config['output_token'], list):
        service_pagination_response_params += paginator_config[
            'output_token']
    else:
        service_pagination_response_params.append(paginator_config[
            'output_token'])

    paginate_description = (
        'Creates an iterator that will paginate through responses '
        'from :py:meth:`{0}.Client.{1}`.'.format(
            get_service_module_name(service_model), xform_name(paginator_name))
    )

    document_model_driven_method(
        section, 'paginate', operation_model,
        event_emitter=event_emitter,
        method_description=paginate_description,
        example_prefix='response_iterator = paginator.paginate',
        include_input=botocore_pagination_params,
        include_output=botocore_pagination_response_params,
        exclude_input=service_pagination_params,
        exclude_output=service_pagination_response_params,
        include_signature=include_signature
    )
                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/botocore/docs/paginator.pyc                                   0100644 0000000 0000062 00000011622 13077704401 023467  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sv   d  d l  m Z d  d l m Z d  d l m Z d  d l m Z d  d l m	 Z	 d e
 f d     YZ e d  Z d	 S(
   i(   t
   xform_name(   t   OrderedDict(   t   DocumentedShape(   t   get_service_module_name(   t   document_model_driven_methodt   PaginatorDocumenterc           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   s+   | |  _  |  j  j j j |  _ | |  _ d  S(   N(   t   _clientt   metat   service_modelt   service_namet   _service_namet   _service_paginator_model(   t   selft   clientt   service_paginator_model(    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/paginator.pyt   __init__   s    	c         C   s   | j  j d  | j  j   | j d  t |  j j  } xA | D]9 } | j  j d |  j j	 j
 | f  |  j | |  qC Wd S(   sh   Documents the various paginators for a service

        param section: The section to write to.
        t
   Paginatorss   The available paginators are:s   :py:class:`%s.Paginator.%s`N(   t   stylet   h2t   new_linet   writelnt   sortedR   t   _paginator_configt   liR   t	   __class__t   __name__t   _add_paginator(   R   t   sectiont   paginator_namest   paginator_name(    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/paginator.pyt   document_paginators   s    	c         C   s   | j  |  } | j j d d |  j j j | f  | j j   | j j   | j d t	 |   | j j
   | j j   |  j j |  } t d | d | d |  j j j d |  j j j d |  d  S(	   Nt
   class_names   %s.Paginator.%ss&   paginator = client.get_paginator('%s')R   R   t   event_emitterR   t   paginator_config(   t   add_new_sectionR   t   start_sphinx_py_classR   R   R   t   start_codeblockR   t   writeR    t   end_codeblockR   t   get_paginatort   document_paginate_methodR   t   eventsR   (   R   R   R   R!   (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/paginator.pyR   -   s&    		(   R   t
   __module__R   R   R   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/paginator.pyR      s   		c         C   s  | j  |  } t   } t d d d d d d  | d <t d d d d d d  | d <t d d	 d d
 d d  | d	 <t d d d d d d d |  g } t d d d d
 d d  g }	 g  }
 t | d t  r |
 | d 7}
 n |
 j | d  | j d d   r|
 j | d  n  g  } t | d t  rB| | d 7} n | j | d  d j t	 |  t
 |   } t |  d | d | d | d d d | d |	 d |
 d | d | d  S(!   s  Documents the paginate method of a paginator

    :param section: The section to write to

    :param paginator_name: The name of the paginator. It is snake cased.

    :param event_emitter: The event emitter to use to emit events

    :param service_model: The service model

    :param paginator_config: The paginator config associated to a particular
        paginator.

    :param include_signature: Whether or not to include the signature.
        It is useful for generating docstrings.
    t   namet   MaxItemst	   type_namet   integert   documentations   <p>The total number of items to return. If the total number of items available is more than the value specified in max-items then a <code>NextToken</code> will be provided in the output that you can use to resume pagination.</p>t   PageSizes   <p>The size of each page.<p>t   StartingTokent   stringsq   <p>A token to specify where to start paginating. This is the <code>NextToken</code> from a previous response.</p>t   PaginationConfigt	   structuresC   <p>A dictionary that provides parameters to control pagination.</p>t   memberst	   NextTokens$   <p>A token to resume pagination.</p>t   input_tokent	   limit_keyt   output_tokensX   Creates an iterator that will paginate through responses from :py:meth:`{0}.Client.{1}`.t   paginateR    t   method_descriptiont   example_prefixs&   response_iterator = paginator.paginatet   include_inputt   include_outputt   exclude_inputt   exclude_outputt   include_signatureN(   t   operation_modelR   R   t
   isinstancet   listt   appendt   gett   Nonet   formatR   R    R   (   R   R   R    R   R!   RA   RB   t   pagination_config_memberst   botocore_pagination_paramst#   botocore_pagination_response_paramst   service_pagination_paramst"   service_pagination_response_paramst   paginate_description(    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/paginator.pyR(   J   sV    			N(   t   botocoreR    t   botocore.compatR   t   botocore.docs.utilsR   t   botocore.utilsR   t   botocore.docs.methodR   t   objectR   t   TrueR(   (    (    (    s9   /tmp/pip-build-awuatQ/botocore/botocore/docs/paginator.pyt   <module>   s   8                                                                                                              usr/local/lib/python2.7/dist-packages/botocore/docs/params.py                                       0100644 0000000 0000062 00000021363 13077704371 022634  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore.docs.shape import ShapeDocumenter
from botocore.docs.utils import py_type_name


class BaseParamsDocumenter(ShapeDocumenter):
    def document_params(self, section, shape, include=None, exclude=None):
        """Fills out the documentation for a section given a model shape.

        :param section: The section to write the documentation to.

        :param shape: The shape of the operation.

        :type include: Dictionary where keys are parameter names and
            values are the shapes of the parameter names.
        :param include: The parameter shapes to include in the documentation.

        :type exclude: List of the names of the parameters to exclude.
        :param exclude: The names of the parameters to exclude from
            documentation.
        """
        history = []
        self.traverse_and_document_shape(
            section=section, shape=shape, history=history,
            name=None, include=include, exclude=exclude)

    def document_recursive_shape(self, section, shape, **kwargs):
        self._add_member_documentation(section, shape, **kwargs)

    def document_shape_default(self, section, shape, history, include=None,
                               exclude=None, **kwargs):
        self._add_member_documentation(section, shape, **kwargs)

    def document_shape_type_list(self, section, shape, history, include=None,
                                 exclude=None, **kwargs):
        self._add_member_documentation(section, shape, **kwargs)
        param_shape = shape.member
        param_section = section.add_new_section(
            param_shape.name, context={'shape': shape.member.name})
        self._start_nested_param(param_section)
        self.traverse_and_document_shape(
            section=param_section, shape=param_shape,
            history=history, name=None)
        section = section.add_new_section('end-list')
        self._end_nested_param(section)

    def document_shape_type_map(self, section, shape, history, include=None,
                                exclude=None, **kwargs):
        self._add_member_documentation(section, shape, **kwargs)

        key_section = section.add_new_section(
            'key', context={'shape': shape.key.name})
        self._start_nested_param(key_section)
        self._add_member_documentation(key_section, shape.key)

        param_section = section.add_new_section(
            shape.value.name, context={'shape': shape.value.name})
        param_section.style.indent()
        self._start_nested_param(param_section)
        self.traverse_and_document_shape(
            section=param_section, shape=shape.value,
            history=history, name=None)

        end_section = section.add_new_section('end-map')
        self._end_nested_param(end_section)
        self._end_nested_param(end_section)

    def document_shape_type_structure(self, section, shape, history,
                                      include=None, exclude=None,
                                      name=None, **kwargs):
        members = self._add_members_to_shape(shape.members, include)
        self._add_member_documentation(section, shape, name=name)
        for param in members:
            if exclude and param in exclude:
                continue
            param_shape = members[param]
            param_section = section.add_new_section(
                param, context={'shape': param_shape.name})
            self._start_nested_param(param_section)
            self.traverse_and_document_shape(
                section=param_section, shape=param_shape,
                history=history, name=param)
        section = section.add_new_section('end-structure')
        self._end_nested_param(section)

    def _add_member_documentation(self, section, shape, **kwargs):
        pass

    def _add_members_to_shape(self, members, include):
        if include:
            members = members.copy()
            for param in include:
                members[param.name] = param
        return members

    def _document_non_top_level_param_type(self, type_section, shape):
        special_py_type = self._get_special_py_type_name(shape)
        py_type = py_type_name(shape.type_name)

        type_format = '(%s) -- '
        if special_py_type is not None:
            # Special type can reference a linked class.
            # Italicizing it blows away the link.
            type_section.write(type_format % special_py_type)
        else:
            type_section.style.italics(type_format % py_type)

    def _start_nested_param(self, section):
        section.style.indent()
        section.style.new_line()

    def _end_nested_param(self, section):
        section.style.dedent()
        section.style.new_line()


class ResponseParamsDocumenter(BaseParamsDocumenter):
    """Generates the description for the response parameters"""

    EVENT_NAME = 'response-params'


    def _add_member_documentation(self, section, shape, name=None, **kwargs):
        name_section = section.add_new_section('param-name')
        name_section.write('- ')
        if name is not None:
            name_section.style.bold('%s ' % name)
        type_section = section.add_new_section('param-type')
        self._document_non_top_level_param_type(type_section, shape)

        documentation_section = section.add_new_section('param-documentation')
        if shape.documentation:
            documentation_section.style.indent()
            documentation_section.include_doc_string(shape.documentation)
        section.style.new_paragraph()


class RequestParamsDocumenter(BaseParamsDocumenter):
    """Generates the description for the request parameters"""

    EVENT_NAME = 'request-params'


    def document_shape_type_structure(self, section, shape, history,
                                      include=None, exclude=None, **kwargs):
        if len(history) > 1:
            self._add_member_documentation(section, shape, **kwargs)
            section.style.indent()
        members = self._add_members_to_shape(shape.members, include)
        for i, param in enumerate(members):
            if exclude and param in exclude:
                continue
            param_shape = members[param]
            param_section = section.add_new_section(
                param, context={'shape': param_shape.name})
            param_section.style.new_line()
            is_required = param in shape.required_members
            self.traverse_and_document_shape(
                section=param_section, shape=param_shape,
                history=history, name=param, is_required=is_required)
        section = section.add_new_section('end-structure')
        if len(history) > 1:
            section.style.dedent()
        section.style.new_line()

    def _add_member_documentation(self, section, shape, name=None,
                                  is_top_level_param=False, is_required=False,
                                  **kwargs):
        py_type = self._get_special_py_type_name(shape)
        if py_type is None:
            py_type = py_type_name(shape.type_name)
        if is_top_level_param:
            type_section = section.add_new_section('param-type')
            type_section.write(':type %s: %s' % (name, py_type))
            end_type_section = type_section.add_new_section('end-param-type')
            end_type_section.style.new_line()
            name_section = section.add_new_section('param-name')
            name_section.write(':param %s: ' % name)

        else:
            name_section = section.add_new_section('param-name')
            name_section.write('- ')
            if name is not None:
                name_section.style.bold('%s ' % name)
            type_section = section.add_new_section('param-type')
            self._document_non_top_level_param_type(type_section, shape)

        if is_required:
            is_required_section = section.add_new_section('is-required')
            is_required_section.style.indent()
            is_required_section.style.bold('[REQUIRED] ')
        if shape.documentation:
            documentation_section = section.add_new_section(
                'param-documentation')
            documentation_section.style.indent()
            documentation_section.include_doc_string(shape.documentation)
        end_param_section = section.add_new_section('end-param')
        end_param_section.style.new_paragraph()
                                                                                                                                                                                                                                                                             usr/local/lib/python2.7/dist-packages/botocore/docs/params.pyc                                      0100644 0000000 0000062 00000017145 13077704401 022774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sf   d  d l  m Z d  d l m Z d e f d     YZ d e f d     YZ d e f d     YZ d	 S(
   i(   t   ShapeDocumenter(   t   py_type_namet   BaseParamsDocumenterc           B   s   e  Z d d d   Z d   Z d d d  Z d d d  Z d d d  Z d d d d  Z d   Z	 d   Z
 d   Z d	   Z d
   Z RS(   c         C   s8   g  } |  j  d | d | d | d d d | d |  d S(   s3  Fills out the documentation for a section given a model shape.

        :param section: The section to write the documentation to.

        :param shape: The shape of the operation.

        :type include: Dictionary where keys are parameter names and
            values are the shapes of the parameter names.
        :param include: The parameter shapes to include in the documentation.

        :type exclude: List of the names of the parameters to exclude.
        :param exclude: The names of the parameters to exclude from
            documentation.
        t   sectiont   shapet   historyt   namet   includet   excludeN(   t   traverse_and_document_shapet   None(   t   selfR   R   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   document_params   s    	c         K   s   |  j  | | |  d  S(   N(   t   _add_member_documentation(   R   R   R   t   kwargs(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   document_recursive_shape&   s    c         K   s   |  j  | | |  d  S(   N(   R   (   R   R   R   R   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   document_shape_default)   s    c   	   	   K   s   |  j  | | |  | j } | j | j d i | j j d 6} |  j |  |  j d | d | d | d d   | j d  } |  j |  d  S(   Nt   contextR   R   R   R   s   end-list(   R   t   membert   add_new_sectionR   t   _start_nested_paramR	   R
   t   _end_nested_param(	   R   R   R   R   R   R   R   t   param_shapet   param_section(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   document_shape_type_list-   s    		c   
   	   K   s   |  j  | | |  | j d d i | j j d 6} |  j |  |  j  | | j  | j | j j d i | j j d 6} | j j   |  j |  |  j d | d | j d | d d   | j d  }	 |  j
 |	  |  j
 |	  d  S(   Nt   keyR   R   R   R   R   s   end-map(   R   R   R   R   R   t   valuet   stylet   indentR	   R
   R   (
   R   R   R   R   R   R   R   t   key_sectionR   t   end_section(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   document_shape_type_map:   s    "	c      
   K   s   |  j  | j |  } |  j | | d | x~ | D]v }	 | rP |	 | k rP q2 n  | |	 }
 | j |	 d i |
 j d 6} |  j |  |  j d | d |
 d | d |	  q2 W| j d  } |  j |  d  S(   NR   R   R   R   R   s   end-structure(   t   _add_members_to_shapet   membersR   R   R   R   R	   R   (   R   R   R   R   R   R   R   R   R!   t   paramR   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   document_shape_type_structureO   s    
	c         K   s   d  S(   N(    (   R   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR   a   s    c         C   s7   | r3 | j    } x | D] } | | | j <q Wn  | S(   N(   t   copyR   (   R   R!   R   R"   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR    d   s
    c         C   s\   |  j  |  } t | j  } d } | d  k	 rD | j | |  n | j j | |  d  S(   Ns   (%s) -- (   t   _get_special_py_type_nameR   t	   type_nameR
   t   writeR   t   italics(   R   t   type_sectionR   t   special_py_typet   py_typet   type_format(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt"   _document_non_top_level_param_typek   s    c         C   s   | j  j   | j  j   d  S(   N(   R   R   t   new_line(   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR   w   s    c         C   s   | j  j   | j  j   d  S(   N(   R   t   dedentR.   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR   {   s    N(   t   __name__t
   __module__R
   R   R   R   R   R   R#   R   R    R-   R   R   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR      s   					t   ResponseParamsDocumenterc           B   s    e  Z d  Z d Z d d  Z RS(   s5   Generates the description for the response parameterss   response-paramsc         K   s   | j  d  } | j d  | d  k	 r? | j j d |  n  | j  d  } |  j | |  | j  d  } | j r | j j   | j | j  n  | j j	   d  S(   Ns
   param-names   - s   %s s
   param-types   param-documentation(
   R   R'   R
   R   t   boldR-   t   documentationR   t   include_doc_stringt   new_paragraph(   R   R   R   R   R   t   name_sectionR)   t   documentation_section(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR      s    	N(   R0   R1   t   __doc__t
   EVENT_NAMER
   R   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR2      s   t   RequestParamsDocumenterc           B   s5   e  Z d  Z d Z d d d  Z d e e d  Z RS(   s4   Generates the description for the request parameterss   request-paramsc         K   s.  t  |  d k r5 |  j | | |  | j j   n  |  j | j |  } x t |  D] \ } }	 | r{ |	 | k r{ qW n  | |	 }
 | j |	 d i |
 j d 6} | j j	   |	 | j
 k } |  j d | d |
 d | d |	 d |  qW W| j d  } t  |  d k r| j j   n  | j j	   d  S(	   Ni   R   R   R   R   R   t   is_requireds   end-structure(   t   lenR   R   R   R    R!   t	   enumerateR   R   R.   t   required_membersR	   R/   (   R   R   R   R   R   R   R   R!   t   iR"   R   R   R<   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR#      s&    
	c         K   s  |  j  |  } | d  k r- t | j  } n  | r | j d  } | j d | | f  | j d  }	 |	 j j   | j d  }
 |
 j d |  n^ | j d  }
 |
 j d  | d  k	 r |
 j j d |  n  | j d  } |  j	 | |  | r+| j d  } | j j
   | j j d	  n  | j rc| j d
  } | j j
   | j | j  n  | j d  } | j j   d  S(   Ns
   param-types   :type %s: %ss   end-param-types
   param-names   :param %s: s   - s   %s s   is-requireds   [REQUIRED] s   param-documentations	   end-param(   R%   R
   R   R&   R   R'   R   R.   R3   R-   R   R4   R5   R6   (   R   R   R   R   t   is_top_level_paramR<   R   R+   R)   t   end_type_sectionR7   t   is_required_sectionR8   t   end_param_section(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR      s6    		N(   R0   R1   R9   R:   R
   R#   t   FalseR   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyR;      s
   N(   t   botocore.docs.shapeR    t   botocore.docs.utilsR   R   R2   R;   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/params.pyt   <module>   s   o                                                                                                                                                                                                                                                                                                                                                                                                                           usr/local/lib/python2.7/dist-packages/botocore/docs/service.py                                      0100644 0000000 0000062 00000006575 13077704371 023021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore.exceptions import DataNotFoundError
from botocore.docs.utils import get_official_service_name
from botocore.docs.client import ClientDocumenter
from botocore.docs.waiter import WaiterDocumenter
from botocore.docs.paginator import PaginatorDocumenter
from botocore.docs.bcdoc.restdoc import DocumentStructure


class ServiceDocumenter(object):
    def __init__(self, service_name, session):
        self._session = session
        self._service_name = service_name

        self._client = self._session.create_client(
            service_name, region_name='us-east-1', aws_access_key_id='foo',
            aws_secret_access_key='bar')

        self.sections = [
            'title',
            'table-of-contents',
            'client-api',
            'paginator-api',
            'waiter-api'
        ]

    def document_service(self):
        """Documents an entire service.

        :returns: The reStructured text of the documented service.
        """
        doc_structure = DocumentStructure(
            self._service_name, section_names=self.sections)
        self.title(doc_structure.get_section('title'))
        self.table_of_contents(doc_structure.get_section('table-of-contents'))
        self.client_api(doc_structure.get_section('client-api'))
        self.paginator_api(doc_structure.get_section('paginator-api'))
        self.waiter_api(doc_structure.get_section('waiter-api'))
        return doc_structure.flush_structure()

    def title(self, section):
        section.style.h1(self._client.__class__.__name__)

    def table_of_contents(self, section):
        section.style.table_of_contents(title='Table of Contents', depth=2)

    def client_api(self, section):
        examples = None
        try:
            examples = self.get_examples(self._service_name)
        except DataNotFoundError:
            pass

        ClientDocumenter(self._client, examples).document_client(section)

    def paginator_api(self, section):
        try:
            service_paginator_model = self._session.get_paginator_model(
                self._service_name)
        except DataNotFoundError:
            return
        paginator_documenter = PaginatorDocumenter(
            self._client, service_paginator_model)
        paginator_documenter.document_paginators(section)

    def waiter_api(self, section):
        if self._client.waiter_names:
            service_waiter_model = self._session.get_waiter_model(
                self._service_name)
            waiter_documenter = WaiterDocumenter(
                self._client, service_waiter_model)
            waiter_documenter.document_waiters(section)

    def get_examples(self, service_name, api_version=None):
        loader = self._session.get_component('data_loader')
        examples = loader.load_service_model(
            service_name, 'examples-1', api_version)
        return examples['examples']
                                                                                                                                   usr/local/lib/python2.7/dist-packages/botocore/docs/service.pyc                                     0100644 0000000 0000062 00000007424 13077704401 023150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sz   d  d l  m Z d  d l m Z d  d l m Z d  d l m Z d  d l m	 Z	 d  d l
 m Z d e f d     YZ d	 S(
   i(   t   DataNotFoundError(   t   get_official_service_name(   t   ClientDocumenter(   t   WaiterDocumenter(   t   PaginatorDocumenter(   t   DocumentStructuret   ServiceDocumenterc           B   sS   e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d d  Z
 RS(	   c         C   sU   | |  _  | |  _ |  j  j | d d d d d d |  _ d d d	 d
 d g |  _ d  S(   Nt   region_names	   us-east-1t   aws_access_key_idt   foot   aws_secret_access_keyt   bart   titles   table-of-contentss
   client-apis   paginator-apis
   waiter-api(   t   _sessiont   _service_namet   create_clientt   _clientt   sections(   t   selft   service_namet   session(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyt   __init__   s    			c         C   s   t  |  j d |  j } |  j | j d   |  j | j d   |  j | j d   |  j | j d   |  j | j d   | j	   S(   si   Documents an entire service.

        :returns: The reStructured text of the documented service.
        t   section_namesR   s   table-of-contentss
   client-apis   paginator-apis
   waiter-api(
   R   R   R   R   t   get_sectiont   table_of_contentst
   client_apit   paginator_apit
   waiter_apit   flush_structure(   R   t   doc_structure(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyt   document_service&   s    c         C   s   | j  j |  j j j  d  S(   N(   t   stylet   h1R   t	   __class__t   __name__(   R   t   section(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR   4   s    c         C   s   | j  j d d d d  d  S(   NR   s   Table of Contentst   depthi   (   R   R   (   R   R#   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR   7   s    c         C   sM   d  } y |  j |  j  } Wn t k
 r/ n Xt |  j |  j |  d  S(   N(   t   Nonet   get_examplesR   R    R   R   t   document_client(   R   R#   t   examples(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR   :   s    c         C   sQ   y |  j  j |  j  } Wn t k
 r- d  SXt |  j |  } | j |  d  S(   N(   R   t   get_paginator_modelR   R    R   R   t   document_paginators(   R   R#   t   service_paginator_modelt   paginator_documenter(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR   C   s    	c         C   sG   |  j  j rC |  j j |  j  } t |  j  |  } | j |  n  d  S(   N(   R   t   waiter_namesR   t   get_waiter_modelR   R   t   document_waiters(   R   R#   t   service_waiter_modelt   waiter_documenter(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR   M   s    	c         C   s/   |  j  j d  } | j | d |  } | d S(   Nt   data_loaders
   examples-1R(   (   R   t   get_componentt   load_service_model(   R   R   t   api_versiont   loaderR(   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR&   U   s    N(   R"   t
   __module__R   R   R   R   R   R   R   R%   R&   (    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyR      s   							
	N(   t   botocore.exceptionsR    t   botocore.docs.utilsR   t   botocore.docs.clientR   t   botocore.docs.waiterR   t   botocore.docs.paginatorR   t   botocore.docs.bcdoc.restdocR   t   objectR   (    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/docs/service.pyt   <module>   s                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/botocore/docs/shape.py                                        0100644 0000000 0000062 00000010606 13077704371 022447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.


# NOTE: This class should not be instantiated and its
# ``traverse_and_document_shape`` method called directly. It should be
# inherited from a Documenter class with the appropriate methods
# and attributes.
class ShapeDocumenter(object):
    EVENT_NAME = ''

    def __init__(self, service_name, operation_name, event_emitter,
                 context=None):
        self._service_name = service_name
        self._operation_name = operation_name
        self._event_emitter = event_emitter
        self._context = context
        if context is None:
            self._context = {
                'special_shape_types': {}
            }

    def traverse_and_document_shape(self, section, shape, history,
                                    include=None, exclude=None, name=None,
                                    is_required=False):
        """Traverses and documents a shape

        Will take a self class and call its appropriate methods as a shape
        is traversed.

        :param section: The section to document.

        :param history: A list of the names of the shapes that have been
            traversed.

        :type include: Dictionary where keys are parameter names and
            values are the shapes of the parameter names.
        :param include: The parameter shapes to include in the documentation.

        :type exclude: List of the names of the parameters to exclude.
        :param exclude: The names of the parameters to exclude from
            documentation.

        :param name: The name of the shape.

        :param is_required: If the shape is a required member.
        """
        param_type = shape.type_name
        if shape.name in history:
            self.document_recursive_shape(section, shape, name=name)
        else:
            history.append(shape.name)
            is_top_level_param = (len(history) == 2)
            getattr(self, 'document_shape_type_%s' % param_type,
                    self.document_shape_default)(
                        section, shape, history=history, name=name,
                        include=include, exclude=exclude,
                        is_top_level_param=is_top_level_param,
                        is_required=is_required)
            if is_top_level_param:
                self._event_emitter.emit(
                    'docs.%s.%s.%s.%s' % (self.EVENT_NAME,
                                          self._service_name,
                                          self._operation_name,
                                          name),
                    section=section)
            at_overlying_method_section = (len(history) == 1)
            if at_overlying_method_section:
                self._event_emitter.emit(
                    'docs.%s.%s.%s.complete-section' % (self.EVENT_NAME,
                                                        self._service_name,
                                                        self._operation_name),
                    section=section)
            history.pop()

    def _get_special_py_default(self, shape):
        special_defaults = {
            'streaming_input_shape': 'b\'bytes\'|file',
            'streaming_output_shape': 'StreamingBody()'
        }
        return self._get_value_for_special_type(shape, special_defaults)

    def _get_special_py_type_name(self, shape):
        special_type_names = {
            'streaming_input_shape': 'bytes or seekable file-like object',
            'streaming_output_shape': ':class:`.StreamingBody`'
        }
        return self._get_value_for_special_type(shape, special_type_names)

    def _get_value_for_special_type(self, shape, special_type_map):
        for special_type, marked_shape in self._context[
                'special_shape_types'].items():
            if special_type in special_type_map:
                if shape == marked_shape:
                    return special_type_map[special_type]
        return None
                                                                                                                          usr/local/lib/python2.7/dist-packages/botocore/docs/shape.pyc                                       0100644 0000000 0000062 00000006677 13077704401 022621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  e  f d     YZ d S(   t   ShapeDocumenterc           B   sJ   e  Z d  Z d d  Z d d d e d  Z d   Z d   Z d   Z	 RS(   t    c         C   sG   | |  _  | |  _ | |  _ | |  _ | d  k rC i i  d 6|  _ n  d  S(   Nt   special_shape_types(   t   _service_namet   _operation_namet   _event_emittert   _contextt   None(   t   selft   service_namet   operation_namet   event_emittert   context(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyt   __init__   s    				c         C   s$  | j  } | j | k r1 |  j | | d | n | j | j  t |  d k }	 t |  d | |  j  | | d | d | d | d | d |	 d | |	 r |  j j d	 |  j	 |  j
 |  j | f d
 | n  t |  d k }
 |
 r|  j j d |  j	 |  j
 |  j f d
 | n  | j   d S(   s  Traverses and documents a shape

        Will take a self class and call its appropriate methods as a shape
        is traversed.

        :param section: The section to document.

        :param history: A list of the names of the shapes that have been
            traversed.

        :type include: Dictionary where keys are parameter names and
            values are the shapes of the parameter names.
        :param include: The parameter shapes to include in the documentation.

        :type exclude: List of the names of the parameters to exclude.
        :param exclude: The names of the parameters to exclude from
            documentation.

        :param name: The name of the shape.

        :param is_required: If the shape is a required member.
        t   namei   s   document_shape_type_%st   historyt   includet   excludet   is_top_level_paramt   is_requireds   docs.%s.%s.%s.%st   sectioni   s   docs.%s.%s.%s.complete-sectionN(   t	   type_nameR   t   document_recursive_shapet   appendt   lent   getattrt   document_shape_defaultR   t   emitt
   EVENT_NAMER   R   t   pop(   R   R   t   shapeR   R   R   R   R   t
   param_typeR   t   at_overlying_method_section(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyt   traverse_and_document_shape!   s4    				

		
c         C   s$   i d d 6d d 6} |  j  | |  S(   Ns   b'bytes'|filet   streaming_input_shapes   StreamingBody()t   streaming_output_shape(   t   _get_value_for_special_type(   R   R   t   special_defaults(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyt   _get_special_py_defaultV   s    
c         C   s$   i d d 6d d 6} |  j  | |  S(   Ns"   bytes or seekable file-like objectR"   s   :class:`.StreamingBody`R#   (   R$   (   R   R   t   special_type_names(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyt   _get_special_py_type_name]   s    
c         C   sK   xD |  j  d j   D]/ \ } } | | k r | | k rC | | Sq q Wd  S(   NR   (   R   t   itemsR   (   R   R   t   special_type_mapt   special_typet   marked_shape(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyR$   d   s    	N(
   t   __name__t
   __module__R   R   R   t   FalseR!   R&   R(   R$   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyR       s   	3		N(   t   objectR    (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/shape.pyt   <module>   s                                                                     usr/local/lib/python2.7/dist-packages/botocore/docs/sharedexample.py                                0100644 0000000 0000062 00000021767 13077704371 024203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import re
import numbers
from botocore.utils import parse_timestamp
from datetime import datetime


class SharedExampleDocumenter(object):
    def document_shared_example(self, example, prefix, section,
                                operation_model):
        """Documents a single shared example based on its definition.

        :param example: The model of the example

        :param prefix: The prefix to use in the method example.

        :param section: The section to write to.

        :param operation_model: The model of the operation used in the example
        """
        section.style.new_paragraph()
        section.write(example.get('description'))
        section.style.new_line()
        self.document_input(section, example, prefix,
                            operation_model.input_shape)
        self.document_output(section, example, operation_model.output_shape)

    def document_input(self, section, example, prefix, shape):
        input_section = section.add_new_section('input')
        input_section.style.start_codeblock()
        if prefix is not None:
            input_section.write(prefix)
        params = example['input']
        comments = example.get('comments')
        if comments:
            comments = comments.get('input')
        param_section = input_section.add_new_section('parameters')
        self._document_params(param_section, params, comments, [], shape)
        closing_section = input_section.add_new_section('input-close')
        closing_section.style.new_line()
        closing_section.style.new_line()
        closing_section.write('print(response)')
        closing_section.style.end_codeblock()

    def document_output(self, section, example, shape):
        output_section = section.add_new_section('output')
        output_section.style.new_line()
        output_section.write('Expected Output:')
        output_section.style.new_line()
        output_section.style.start_codeblock()
        params = example.get('output', {})

        # There might not be an output, but we will return metadata anyway
        params['ResponseMetadata'] = {"...": "..."}
        comments = example.get('comments')
        if comments:
            comments = comments.get('output')
        self._document_dict(output_section, params, comments, [], shape, True)
        closing_section = output_section.add_new_section('output-close')
        closing_section.style.end_codeblock()

    def _document(self, section, value, comments, path, shape):
        """
        :param section: The section to add the docs to.

        :param value: The input / output values representing the parameters that
                      are included in the example.

        :param comments: The dictionary containing all the comments to be
                         applied to the example.

        :param path: A list describing where the documenter is in traversing the
                     parameters. This is used to find the equivalent location
                     in the comments dictionary.
        """
        if isinstance(value, dict):
            self._document_dict(section, value, comments, path, shape)
        elif isinstance(value, list):
            self._document_list(section, value, comments, path, shape)
        elif isinstance(value, numbers.Number):
            self._document_number(section, value, path)
        elif shape and shape.type_name == 'timestamp':
            self._document_datetime(section, value, path)
        else:
            self._document_str(section, value, path)

    def _document_dict(self, section, value, comments, path, shape,
                       top_level=False):
        dict_section = section.add_new_section('dict-value')
        self._start_nested_value(dict_section, '{')
        for key, val in value.items():
            path.append('.%s' % key)
            item_section = dict_section.add_new_section(key)
            item_section.style.new_line()
            item_comment = self._get_comment(path, comments)
            if item_comment:
                item_section.write(item_comment)
                item_section.style.new_line()
            item_section.write("'%s': " % key)

            # Shape could be none if there is no output besides ResponseMetadata
            item_shape = None
            if shape:
                if shape.type_name == 'structure':
                    item_shape = shape.members.get(key)
                elif shape.type_name == 'map':
                    item_shape = shape.value
            self._document(item_section, val, comments, path, item_shape)
            path.pop()
        dict_section_end = dict_section.add_new_section('ending-brace')
        self._end_nested_value(dict_section_end, '}')
        if not top_level:
            dict_section_end.write(',')

    def _document_params(self, section, value, comments, path, shape):
        param_section = section.add_new_section('param-values')
        self._start_nested_value(param_section, '(')
        for key, val in value.items():
            path.append('.%s' % key)
            item_section = param_section.add_new_section(key)
            item_section.style.new_line()
            item_comment = self._get_comment(path, comments)
            if item_comment:
                item_section.write(item_comment)
                item_section.style.new_line()
            item_section.write(key + '=')

            # Shape could be none if there are no input parameters
            item_shape = None
            if shape:
                item_shape = shape.members.get(key)
            self._document(item_section, val, comments, path, item_shape)
            path.pop()
        param_section_end = param_section.add_new_section('ending-parenthesis')
        self._end_nested_value(param_section_end, ')')

    def _document_list(self, section, value, comments, path, shape):
        list_section = section.add_new_section('list-section')
        self._start_nested_value(list_section, '[')
        item_shape = shape.member
        for index, val in enumerate(value):
            item_section = list_section.add_new_section(index)
            item_section.style.new_line()
            path.append('[%s]' % index)
            item_comment = self._get_comment(path, comments)
            if item_comment:
                item_section.write(item_comment)
                item_section.style.new_line()
            self._document(item_section, val, comments, path, item_shape)
            path.pop()
        list_section_end = list_section.add_new_section('ending-bracket')
        self._end_nested_value(list_section_end, '],')

    def _document_str(self, section, value, path):
        # We do the string conversion because this might accept a type that
        # we don't specifically address.
        section.write("'%s'," % str(value))

    def _document_number(self, section, value, path):
        section.write("%s," % str(value))

    def _document_datetime(self, section, value, path):
        datetime_tuple = parse_timestamp(value).timetuple()
        datetime_str = str(datetime_tuple[0])
        for i in range(1, len(datetime_tuple)):
            datetime_str += ", " + str(datetime_tuple[i])
        section.write("datetime(%s)," % datetime_str)

    def _get_comment(self, path, comments):
        key = re.sub('^\.', '', ''.join(path))
        if comments and key in comments:
            return '# ' + comments[key]
        else:
            return ''

    def _start_nested_value(self, section, start):
        section.write(start)
        section.style.indent()
        section.style.indent()

    def _end_nested_value(self, section, end):
        section.style.dedent()
        section.style.dedent()
        section.style.new_line()
        section.write(end)


def document_shared_examples(section, operation_model, example_prefix,
                             shared_examples):
    """Documents the shared examples

    :param section: The section to write to.

    :param operation_model: The model of the operation.

    :param example_prefix: The prefix to use in the method example.

    :param shared_examples: The shared JSON examples from the model.
    """
    container_section = section.add_new_section('shared-examples')
    container_section.style.new_paragraph()
    container_section.style.bold('Examples')
    documenter = SharedExampleDocumenter()
    for example in shared_examples:
        documenter.document_shared_example(
            example=example,
            section=container_section.add_new_section(example['id']),
            prefix=example_prefix,
            operation_model=operation_model
        )
         usr/local/lib/python2.7/dist-packages/botocore/docs/sharedexample.pyc                               0100644 0000000 0000062 00000020201 13077704401 024316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s[   d  d l  Z  d  d l Z d  d l m Z d  d l m Z d e f d     YZ d   Z d S(   iN(   t   parse_timestamp(   t   datetimet   SharedExampleDocumenterc           B   s   e  Z d    Z d   Z d   Z d   Z e d  Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z d   Z d   Z RS(   c         C   sc   | j  j   | j | j d   | j  j   |  j | | | | j  |  j | | | j  d S(   s8  Documents a single shared example based on its definition.

        :param example: The model of the example

        :param prefix: The prefix to use in the method example.

        :param section: The section to write to.

        :param operation_model: The model of the operation used in the example
        t   descriptionN(	   t   stylet   new_paragrapht   writet   gett   new_linet   document_inputt   input_shapet   document_outputt   output_shape(   t   selft   examplet   prefixt   sectiont   operation_model(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyt   document_shared_example   s    
c   
      C   s   | j  d  } | j j   | d  k	 r8 | j |  n  | d } | j d  } | ri | j d  } n  | j  d  } |  j | | | g  |  | j  d  }	 |	 j j   |	 j j   |	 j d  |	 j j   d  S(   Nt   inputt   commentst
   parameterss   input-closes   print(response)(	   t   add_new_sectionR   t   start_codeblockt   NoneR   R   t   _document_paramsR   t   end_codeblock(
   R   R   R   R   t   shapet   input_sectiont   paramsR   t   param_sectiont   closing_section(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR	   '   s    
c         C   s   | j  d  } | j j   | j d  | j j   | j j   | j d i   } i d d 6| d <| j d  } | r | j d  } n  |  j | | | g  | t  | j  d  } | j j   d  S(   Nt   outputs   Expected Output:s   ...t   ResponseMetadataR   s   output-close(	   R   R   R   R   R   R   t   _document_dictt   TrueR   (   R   R   R   R   t   output_sectionR   R   R   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR   8   s    c         C   s   t  | t  r+ |  j | | | | |  n t  | t  rV |  j | | | | |  nf t  | t j  r~ |  j | | |  n> | r | j d k r |  j	 | | |  n |  j
 | | |  d S(   s  
        :param section: The section to add the docs to.

        :param value: The input / output values representing the parameters that
                      are included in the example.

        :param comments: The dictionary containing all the comments to be
                         applied to the example.

        :param path: A list describing where the documenter is in traversing the
                     parameters. This is used to find the equivalent location
                     in the comments dictionary.
        t	   timestampN(   t
   isinstancet   dictR"   t   listt   _document_listt   numberst   Numbert   _document_numbert	   type_namet   _document_datetimet   _document_str(   R   R   t   valueR   t   pathR   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyt	   _documentI   s    c         C   sY  | j  d  } |  j | d  x | j   D] \ } }	 | j d |  | j  |  }
 |
 j j   |  j | |  } | r |
 j |  |
 j j   n  |
 j d |  d  } | r | j	 d k r | j
 j |  } q | j	 d k r | j } q n  |  j |
 |	 | | |  | j   q, W| j  d  } |  j | d  | sU| j d	  n  d  S(
   Ns
   dict-valuet   {s   .%ss   '%s': t	   structuret   maps   ending-bracet   }t   ,(   R   t   _start_nested_valuet   itemst   appendR   R   t   _get_commentR   R   R-   t   membersR   R0   R2   t   popt   _end_nested_value(   R   R   R0   R   R1   R   t	   top_levelt   dict_sectiont   keyt   valt   item_sectiont   item_commentt
   item_shapet   dict_section_end(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR"   b   s.    c         C   s  | j  d  } |  j | d  x | j   D] \ } } | j d |  | j  |  }	 |	 j j   |  j | |  }
 |
 r |	 j |
  |	 j j   n  |	 j | d  d  } | r | j	 j
 |  } n  |  j |	 | | | |  | j   q, W| j  d  } |  j | d  d  S(   Ns   param-valuest   (s   .%st   =s   ending-parenthesist   )(   R   R8   R9   R:   R   R   R;   R   R   R<   R   R2   R=   R>   (   R   R   R0   R   R1   R   R   RA   RB   RC   RD   RE   t   param_section_end(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR   ~   s$    c         C   s   | j  d  } |  j | d  | j } x t |  D] \ } }	 | j  |  }
 |
 j j   | j d |  |  j | |  } | r |
 j |  |
 j j   n  |  j	 |
 |	 | | |  | j
   q5 W| j  d  } |  j | d  d  S(   Ns   list-sectiont   [s   [%s]s   ending-brackets   ],(   R   R8   t   membert	   enumerateR   R   R:   R;   R   R2   R=   R>   (   R   R   R0   R   R1   R   t   list_sectionRE   t   indexRB   RC   RD   t   list_section_end(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR)      s    	c         C   s   | j  d t |   d  S(   Ns   '%s',(   R   t   str(   R   R   R0   R1   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR/      s    c         C   s   | j  d t |   d  S(   Ns   %s,(   R   RQ   (   R   R   R0   R1   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR,      s    c         C   so   t  |  j   } t | d  } x5 t d t |   D] } | d t | |  7} q8 W| j d |  d  S(   Ni    i   s   , s   datetime(%s),(   R    t	   timetupleRQ   t   ranget   lenR   (   R   R   R0   R1   t   datetime_tuplet   datetime_strt   i(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR.      s
    c         C   sD   t  j d d d j |   } | r< | | k r< d | | Sd Sd  S(   Ns   ^\.t    s   # (   t   ret   subt   join(   R   R1   R   RA   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR;      s    c         C   s+   | j  |  | j j   | j j   d  S(   N(   R   R   t   indent(   R   R   t   start(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR8      s    c         C   s8   | j  j   | j  j   | j  j   | j |  d  S(   N(   R   t   dedentR   R   (   R   R   t   end(    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR>      s    (   t   __name__t
   __module__R   R	   R   R2   t   FalseR"   R   R)   R/   R,   R.   R;   R8   R>   (    (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyR      s   											c      
   C   sy   |  j  d  } | j j   | j j d  t   } x= | D]5 } | j d | d | j  | d  d | d |  q< Wd S(	   s  Documents the shared examples

    :param section: The section to write to.

    :param operation_model: The model of the operation.

    :param example_prefix: The prefix to use in the method example.

    :param shared_examples: The shared JSON examples from the model.
    s   shared-examplest   ExamplesR   R   t   idR   R   N(   R   R   R   t   boldR   R   (   R   R   t   example_prefixt   shared_examplest   container_sectiont
   documenterR   (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyt   document_shared_examples   s    		(   RY   R*   t   botocore.utilsR    R   t   objectR   Rj   (    (    (    s=   /tmp/pip-build-awuatQ/botocore/botocore/docs/sharedexample.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/botocore/docs/utils.py                                        0100644 0000000 0000062 00000015055 13077704371 022512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from collections import namedtuple


def py_type_name(type_name):
    """Get the Python type name for a given model type.

        >>> py_type_name('list')
        'list'
        >>> py_type_name('structure')
        'dict'

    :rtype: string
    """
    return {
        'blob': 'bytes',
        'character': 'string',
        'double': 'float',
        'long': 'integer',
        'map': 'dict',
        'structure': 'dict',
        'timestamp': 'datetime',
    }.get(type_name, type_name)


def py_default(type_name):
    """Get the Python default value for a given model type.

        >>> py_default('string')
        '\'string\''
        >>> py_default('list')
        '[...]'
        >>> py_default('unknown')
        '...'

    :rtype: string
    """
    return {
        'double': '123.0',
        'long': '123',
        'integer': '123',
        'string': "'string'",
        'blob': "b'bytes'",
        'boolean': 'True|False',
        'list': '[...]',
        'map': '{...}',
        'structure': '{...}',
        'timestamp': 'datetime(2015, 1, 1)',
    }.get(type_name, '...')


def get_official_service_name(service_model):
    """Generate the official name of an AWS Service

    :param service_model: The service model representing the service
    """
    official_name = service_model.metadata.get('serviceFullName')
    short_name = service_model.metadata.get('serviceAbbreviation', '')
    if short_name.startswith('Amazon'):
        short_name = short_name[7:]
    if short_name.startswith('AWS'):
        short_name = short_name[4:]
    if short_name and short_name.lower() not in official_name.lower():
        official_name += ' ({0})'.format(short_name)
    return official_name


_DocumentedShape = namedtuple(
    'DocumentedShape', ['name', 'type_name', 'documentation', 'metadata',
                        'members', 'required_members'])


class DocumentedShape (_DocumentedShape):
    """Use this class to inject new shapes into a model for documentation"""
    def __new__(cls, name, type_name, documentation, metadata=None,
                members=None, required_members=None):
        if metadata is None:
            metadata = []
        if members is None:
            members = []
        if required_members is None:
            required_members = []
        return super(DocumentedShape, cls).__new__(
            cls, name, type_name, documentation, metadata, members,
            required_members)


class AutoPopulatedParam(object):
    def __init__(self, name, param_description=None):
        self.name = name
        self.param_description = param_description
        if param_description is None:
            self.param_description = (
                'Please note that this parameter is automatically populated '
                'if it is not provided. Including this parameter is not '
                'required\n')

    def document_auto_populated_param(self, event_name, section, **kwargs):
        """Documents auto populated parameters

        It will remove any required marks for the parameter, remove the
        parameter from the example, and add a snippet about the parameter
        being autopopulated in the description.
        """
        if event_name.startswith('docs.request-params'):
            if self.name in section.available_sections:
                section = section.get_section(self.name)
                if 'is-required' in section.available_sections:
                    section.delete_section('is-required')
                description_section = section.get_section(
                    'param-documentation')
                description_section.writeln(self.param_description)
        elif event_name.startswith('docs.request-example'):
            section = section.get_section('structure-value')
            if self.name in section.available_sections:
                section.delete_section(self.name)


class HideParamFromOperations(object):
    """Hides a single parameter from multiple operations.

    This method will remove a parameter from documentation and from
    examples. This method is typically used for things that are
    automatically populated because a user would be unable to provide
    a value (e.g., a checksum of a serialized XML request body)."""
    def __init__(self, service_name, parameter_name, operation_names):
        """
        :type service_name: str
        :param service_name: Name of the service to modify.

        :type parameter_name: str
        :param parameter_name: Name of the parameter to modify.

        :type operation_names: list
        :param operation_names: Operation names to modify.
        """
        self._parameter_name = parameter_name
        self._params_events = set()
        self._example_events = set()
        # Build up the sets of relevant event names.
        param_template = 'docs.request-params.%s.%s.complete-section'
        example_template = 'docs.request-example.%s.%s.complete-section'
        for name in operation_names:
            self._params_events.add(param_template % (service_name, name))
            self._example_events.add(example_template % (service_name, name))

    def hide_param(self, event_name, section, **kwargs):
        if event_name in self._example_events:
            # Modify the structure value for example events.
            section = section.get_section('structure-value')
        elif event_name not in self._params_events:
            return
        if self._parameter_name in section.available_sections:
            section.delete_section(self._parameter_name)


class AppendParamDocumentation(object):
    """Appends documentation to a specific parameter"""
    def __init__(self, parameter_name, doc_string):
        self._parameter_name = parameter_name
        self._doc_string = doc_string

    def append_documentation(self, event_name, section, **kwargs):
        if self._parameter_name in section.available_sections:
            section = section.get_section(self._parameter_name)
            description_section = section.get_section(
                'param-documentation')
            description_section.writeln(self._doc_string)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/python2.7/dist-packages/botocore/docs/utils.pyc                                       0100644 0000000 0000062 00000015241 13077704401 022644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  d l  m Z d   Z d   Z d   Z e d d d d d	 d
 d g  Z d e f d     YZ d e f d     YZ d e f d     YZ	 d e f d     YZ
 d S(   i(   t
   namedtuplec         C   sA   i d d 6d d 6d d 6d d 6d	 d
 6d	 d 6d d 6j  |  |   S(   s   Get the Python type name for a given model type.

        >>> py_type_name('list')
        'list'
        >>> py_type_name('structure')
        'dict'

    :rtype: string
    t   bytest   blobt   stringt	   charactert   floatt   doublet   integert   longt   dictt   mapt	   structuret   datetimet	   timestamp(   t   get(   t	   type_name(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt   py_type_name   s    

c         C   sV   i
 d d 6d d 6d d 6d d 6d d	 6d
 d 6d d 6d d 6d d 6d d 6j  |  d  S(   s   Get the Python default value for a given model type.

        >>> py_default('string')
        ''string''
        >>> py_default('list')
        '[...]'
        >>> py_default('unknown')
        '...'

    :rtype: string
    s   123.0R   t   123R   R   s   'string'R   s   b'bytes'R   s
   True|Falset   booleans   [...]t   lists   {...}R
   R   s   datetime(2015, 1, 1)R   s   ...(   R   (   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt
   py_default%   s    
c         C   s   |  j  j d  } |  j  j d d  } | j d  rC | d } n  | j d  r_ | d } n  | r | j   | j   k r | d j |  7} n  | S(	   sw   Generate the official name of an AWS Service

    :param service_model: The service model representing the service
    t   serviceFullNamet   serviceAbbreviationt    t   Amazoni   t   AWSi   s    ({0})(   t   metadataR   t
   startswitht   lowert   format(   t   service_modelt   official_namet
   short_name(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt   get_official_service_name?   s    t   DocumentedShapet   nameR   t   documentationR   t   memberst   required_membersc           B   s    e  Z d  Z d d d d  Z RS(   sB   Use this class to inject new shapes into a model for documentationc         C   sg   | d  k r g  } n  | d  k r* g  } n  | d  k r? g  } n  t t |   j |  | | | | | |  S(   N(   t   Nonet   superR"   t   __new__(   t   clsR#   R   R$   R   R%   R&   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyR)   V   s    			N(   t   __name__t
   __module__t   __doc__R'   R)   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyR"   T   s   t   AutoPopulatedParamc           B   s   e  Z d d   Z d   Z RS(   c         C   s.   | |  _  | |  _ | d  k r* d |  _ n  d  S(   Ns{   Please note that this parameter is automatically populated if it is not provided. Including this parameter is not required
(   R#   t   param_descriptionR'   (   t   selfR#   R/   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt   __init__d   s    		c         K   s   | j  d  rw |  j | j k r | j |  j  } d | j k rR | j d  n  | j d  } | j |  j  q nF | j  d  r | j d  } |  j | j k r | j |  j  q n  d S(   s   Documents auto populated parameters

        It will remove any required marks for the parameter, remove the
        parameter from the example, and add a snippet about the parameter
        being autopopulated in the description.
        s   docs.request-paramss   is-requireds   param-documentations   docs.request-examples   structure-valueN(   R   R#   t   available_sectionst   get_sectiont   delete_sectiont   writelnR/   (   R0   t
   event_namet   sectiont   kwargst   description_section(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt   document_auto_populated_paramm   s    	N(   R+   R,   R'   R1   R:   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyR.   c   s   	t   HideParamFromOperationsc           B   s    e  Z d  Z d   Z d   Z RS(   s>  Hides a single parameter from multiple operations.

    This method will remove a parameter from documentation and from
    examples. This method is typically used for things that are
    automatically populated because a user would be unable to provide
    a value (e.g., a checksum of a serialized XML request body).c         C   sv   | |  _  t   |  _ t   |  _ d } d } xB | D]: } |  j j | | | f  |  j j | | | f  q4 Wd S(   s(  
        :type service_name: str
        :param service_name: Name of the service to modify.

        :type parameter_name: str
        :param parameter_name: Name of the parameter to modify.

        :type operation_names: list
        :param operation_names: Operation names to modify.
        s*   docs.request-params.%s.%s.complete-sections+   docs.request-example.%s.%s.complete-sectionN(   t   _parameter_namet   sett   _params_eventst   _example_eventst   add(   R0   t   service_namet   parameter_namet   operation_namest   param_templatet   example_templateR#   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyR1      s    	c         K   s]   | |  j  k r! | j d  } n | |  j k r4 d  S|  j | j k rY | j |  j  n  d  S(   Ns   structure-value(   R?   R3   R>   R<   R2   R4   (   R0   R6   R7   R8   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt
   hide_param   s    (   R+   R,   R-   R1   RF   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyR;      s   	t   AppendParamDocumentationc           B   s    e  Z d  Z d   Z d   Z RS(   s-   Appends documentation to a specific parameterc         C   s   | |  _  | |  _ d  S(   N(   R<   t   _doc_string(   R0   RB   t
   doc_string(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyR1      s    	c         K   sJ   |  j  | j k rF | j |  j   } | j d  } | j |  j  n  d  S(   Ns   param-documentation(   R<   R2   R3   R5   RH   (   R0   R6   R7   R8   R9   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt   append_documentation   s
    	(   R+   R,   R-   R1   RJ   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyRG      s   	N(   t   collectionsR    R   R   R!   t   _DocumentedShapeR"   t   objectR.   R;   RG   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/docs/utils.pyt   <module>   s   			&                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/botocore/docs/waiter.py                                       0100644 0000000 0000062 00000007361 13077704371 022646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore import xform_name
from botocore.utils import get_service_module_name
from botocore.docs.method import document_model_driven_method


class WaiterDocumenter(object):
    def __init__(self, client, service_waiter_model):
        self._client = client
        self._service_name = self._client.meta.service_model.service_name
        self._service_waiter_model = service_waiter_model

    def document_waiters(self, section):
        """Documents the various waiters for a service.

        :param section: The section to write to.
        """
        section.style.h2('Waiters')
        section.style.new_line()
        section.writeln('The available waiters are:')
        for waiter_name in self._service_waiter_model.waiter_names:
            section.style.li(
                ':py:class:`%s.Waiter.%s`' % (
                    self._client.__class__.__name__, waiter_name))
            self._add_single_waiter(section, waiter_name)

    def _add_single_waiter(self, section, waiter_name):
        section = section.add_new_section(waiter_name)
        section.style.start_sphinx_py_class(
            class_name='%s.Waiter.%s' % (
                self._client.__class__.__name__, waiter_name))

        # Add example on how to instantiate waiter.
        section.style.start_codeblock()
        section.style.new_line()
        section.write(
            'waiter = client.get_waiter(\'%s\')' % xform_name(waiter_name)
        )
        section.style.end_codeblock()

        # Add information on the wait() method
        section.style.new_line()
        document_wait_method(
            section=section,
            waiter_name=waiter_name,
            event_emitter=self._client.meta.events,
            service_model=self._client.meta.service_model,
            service_waiter_model=self._service_waiter_model
        )


def document_wait_method(section, waiter_name, event_emitter,
                         service_model, service_waiter_model,
                         include_signature=True):
    """Documents a the wait method of a waiter

    :param section: The section to write to

    :param waiter_name: The name of the waiter

    :param event_emitter: The event emitter to use to emit events

    :param service_model: The service model

    :param service_waiter_model: The waiter model associated to the service

    :param include_signature: Whether or not to include the signature.
        It is useful for generating docstrings.
    """
    waiter_model = service_waiter_model.get_waiter(waiter_name)
    operation_model = service_model.operation_model(
        waiter_model.operation)

    wait_description = (
        'Polls :py:meth:`{0}.Client.{1}` every {2} '
        'seconds until a successful state is reached. An error is '
        'returned after {3} failed checks.'.format(
            get_service_module_name(service_model),
            xform_name(waiter_model.operation),
            waiter_model.delay, waiter_model.max_attempts)
    )

    document_model_driven_method(
        section, 'wait', operation_model,
        event_emitter=event_emitter,
        method_description=wait_description,
        example_prefix='waiter.wait',
        document_output=False,
        include_signature=include_signature
    )
                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/botocore/docs/waiter.pyc                                      0100644 0000000 0000062 00000006471 13077704401 023004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   sV   d  d l  m Z d  d l m Z d  d l m Z d e f d     YZ e d  Z	 d S(   i(   t
   xform_name(   t   get_service_module_name(   t   document_model_driven_methodt   WaiterDocumenterc           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   s+   | |  _  |  j  j j j |  _ | |  _ d  S(   N(   t   _clientt   metat   service_modelt   service_namet   _service_namet   _service_waiter_model(   t   selft   clientt   service_waiter_model(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/waiter.pyt   __init__   s    	c         C   sx   | j  j d  | j  j   | j d  xG |  j j D]9 } | j  j d |  j j j	 | f  |  j
 | |  q7 Wd S(   sg   Documents the various waiters for a service.

        :param section: The section to write to.
        t   Waiterss   The available waiters are:s   :py:class:`%s.Waiter.%s`N(   t   stylet   h2t   new_linet   writelnR	   t   waiter_namest   liR   t	   __class__t   __name__t   _add_single_waiter(   R
   t   sectiont   waiter_name(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/waiter.pyt   document_waiters   s    	c         C   s   | j  |  } | j j d d |  j j j | f  | j j   | j j   | j d t	 |   | j j
   | j j   t d | d | d |  j j j d |  j j j d |  j  d  S(	   Nt
   class_names   %s.Waiter.%ss    waiter = client.get_waiter('%s')R   R   t   event_emitterR   R   (   t   add_new_sectionR   t   start_sphinx_py_classR   R   R   t   start_codeblockR   t   writeR    t   end_codeblockt   document_wait_methodR   t   eventsR   R	   (   R
   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/waiter.pyR   &   s     (   R   t
   __module__R   R   R   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/waiter.pyR      s   		c   	      C   s   | j  |  } | j | j  } d j t |  t | j  | j | j  } t |  d | d | d | d d d t	 d | d	 S(
   s  Documents a the wait method of a waiter

    :param section: The section to write to

    :param waiter_name: The name of the waiter

    :param event_emitter: The event emitter to use to emit events

    :param service_model: The service model

    :param service_waiter_model: The waiter model associated to the service

    :param include_signature: Whether or not to include the signature.
        It is useful for generating docstrings.
    s   Polls :py:meth:`{0}.Client.{1}` every {2} seconds until a successful state is reached. An error is returned after {3} failed checks.t   waitR   t   method_descriptiont   example_prefixs   waiter.waitt   document_outputt   include_signatureN(
   t
   get_waitert   operation_modelt	   operationt   formatR   R    t   delayt   max_attemptsR   t   False(	   R   R   R   R   R   R)   t   waiter_modelR+   t   wait_description(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/waiter.pyR"   ?   s    	N(
   t   botocoreR    t   botocore.utilsR   t   botocore.docs.methodR   t   objectR   t   TrueR"   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/docs/waiter.pyt   <module>   s   /                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/botocore/endpoint.py                                          0100644 0000000 0000062 00000025512 13077704371 022241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

import os
import logging
import time
import threading

from botocore.vendored.requests.sessions import Session
from botocore.vendored.requests.utils import get_environ_proxies
from botocore.vendored.requests.exceptions import ConnectionError
from botocore.vendored import six

from botocore.awsrequest import create_request_object
from botocore.exceptions import UnknownEndpointError
from botocore.exceptions import EndpointConnectionError
from botocore.exceptions import ConnectionClosedError
from botocore.compat import filter_ssl_warnings
from botocore.utils import is_valid_endpoint_url
from botocore.hooks import first_non_none_response
from botocore.response import StreamingBody
from botocore import parsers


logger = logging.getLogger(__name__)
DEFAULT_TIMEOUT = 60
filter_ssl_warnings()

try:
    from botocore.vendored.requests.packages.urllib3.contrib import pyopenssl
    pyopenssl.extract_from_urllib3()
except ImportError:
    pass


def convert_to_response_dict(http_response, operation_model):
    """Convert an HTTP response object to a request dict.

    This converts the requests library's HTTP response object to
    a dictionary.

    :type http_response: botocore.vendored.requests.model.Response
    :param http_response: The HTTP response from an AWS service request.

    :rtype: dict
    :return: A response dictionary which will contain the following keys:
        * headers (dict)
        * status_code (int)
        * body (string or file-like object)

    """
    response_dict = {
        'headers': http_response.headers,
        'status_code': http_response.status_code,
    }
    if response_dict['status_code'] >= 300:
        response_dict['body'] = http_response.content
    elif operation_model.has_streaming_output:
        response_dict['body'] = StreamingBody(
            http_response.raw, response_dict['headers'].get('content-length'))
    else:
        response_dict['body'] = http_response.content
    return response_dict


class PreserveAuthSession(Session):
    def rebuild_auth(self, prepared_request, response):
        pass


class Endpoint(object):
    """
    Represents an endpoint for a particular service in a specific
    region.  Only an endpoint can make requests.

    :ivar service: The Service object that describes this endpoints
        service.
    :ivar host: The fully qualified endpoint hostname.
    :ivar session: The session object.
    """

    def __init__(self, host, endpoint_prefix,
                 event_emitter, proxies=None, verify=True,
                 timeout=DEFAULT_TIMEOUT, response_parser_factory=None):
        self._endpoint_prefix = endpoint_prefix
        self._event_emitter = event_emitter
        self.host = host
        self.verify = verify
        if proxies is None:
            proxies = {}
        self.proxies = proxies
        self.http_session = PreserveAuthSession()
        self.timeout = timeout
        logger.debug('Setting %s timeout as %s', endpoint_prefix, self.timeout)
        self._lock = threading.Lock()
        if response_parser_factory is None:
            response_parser_factory = parsers.ResponseParserFactory()
        self._response_parser_factory = response_parser_factory

    def __repr__(self):
        return '%s(%s)' % (self._endpoint_prefix, self.host)

    def make_request(self, operation_model, request_dict):
        logger.debug("Making request for %s (verify_ssl=%s) with params: %s",
                     operation_model, self.verify, request_dict)
        return self._send_request(request_dict, operation_model)

    def create_request(self, params, operation_model=None):
        request = create_request_object(params)
        if operation_model:
            event_name = 'request-created.{endpoint_prefix}.{op_name}'.format(
                endpoint_prefix=self._endpoint_prefix,
                op_name=operation_model.name)
            self._event_emitter.emit(event_name, request=request,
                                     operation_name=operation_model.name)
        prepared_request = self.prepare_request(request)
        return prepared_request

    def _encode_headers(self, headers):
        # In place encoding of headers to utf-8 if they are unicode.
        for key, value in headers.items():
            if isinstance(value, six.text_type):
                headers[key] = value.encode('utf-8')

    def prepare_request(self, request):
        self._encode_headers(request.headers)
        return request.prepare()

    def _send_request(self, request_dict, operation_model):
        attempts = 1
        request = self.create_request(request_dict, operation_model)
        success_response, exception = self._get_response(
            request, operation_model, attempts)
        while self._needs_retry(attempts, operation_model,
                                success_response, exception):
            attempts += 1
            # If there is a stream associated with the request, we need
            # to reset it before attempting to send the request again.
            # This will ensure that we resend the entire contents of the
            # body.
            request.reset_stream()
            # Create a new request when retried (including a new signature).
            request = self.create_request(
                request_dict, operation_model=operation_model)
            success_response, exception = self._get_response(
                request, operation_model, attempts)
        if exception is not None:
            raise exception
        else:
            return success_response

    def _get_response(self, request, operation_model, attempts):
        # This will return a tuple of (success_response, exception)
        # and success_response is itself a tuple of
        # (http_response, parsed_dict).
        # If an exception occurs then the success_response is None.
        # If no exception occurs then exception is None.
        try:
            logger.debug("Sending http request: %s", request)
            http_response = self.http_session.send(
                request, verify=self.verify,
                stream=operation_model.has_streaming_output,
                proxies=self.proxies, timeout=self.timeout)
        except ConnectionError as e:
            # For a connection error, if it looks like it's a DNS
            # lookup issue, 99% of the time this is due to a misconfigured
            # region/endpoint so we'll raise a more specific error message
            # to help users.
            logger.debug("ConnectionError received when sending HTTP request.",
                         exc_info=True)
            if self._looks_like_dns_error(e):
                endpoint_url = e.request.url
                better_exception = EndpointConnectionError(
                    endpoint_url=endpoint_url, error=e)
                return (None, better_exception)
            elif self._looks_like_bad_status_line(e):
                better_exception = ConnectionClosedError(
                    endpoint_url=e.request.url, request=e.request)
                return (None, better_exception)
            else:
                return (None, e)
        except Exception as e:
            logger.debug("Exception received when sending HTTP request.",
                         exc_info=True)
            return (None, e)
        # This returns the http_response and the parsed_data.
        response_dict = convert_to_response_dict(http_response,
                                                 operation_model)
        parser = self._response_parser_factory.create_parser(
            operation_model.metadata['protocol'])
        return ((http_response,
                 parser.parse(response_dict, operation_model.output_shape)),
                None)

    def _looks_like_dns_error(self, e):
        return 'gaierror' in str(e) and e.request is not None

    def _looks_like_bad_status_line(self, e):
        return 'BadStatusLine' in str(e) and e.request is not None

    def _needs_retry(self, attempts, operation_model, response=None,
                     caught_exception=None):
        event_name = 'needs-retry.%s.%s' % (self._endpoint_prefix,
                                            operation_model.name)
        responses = self._event_emitter.emit(
            event_name, response=response, endpoint=self,
            operation=operation_model, attempts=attempts,
            caught_exception=caught_exception)
        handler_response = first_non_none_response(responses)
        if handler_response is None:
            return False
        else:
            # Request needs to be retried, and we need to sleep
            # for the specified number of times.
            logger.debug("Response received to retry, sleeping for "
                         "%s seconds", handler_response)
            time.sleep(handler_response)
            return True


class EndpointCreator(object):
    def __init__(self, event_emitter):
        self._event_emitter = event_emitter

    def create_endpoint(self, service_model, region_name, endpoint_url,
                        verify=None, response_parser_factory=None,
                        timeout=DEFAULT_TIMEOUT):
        if not is_valid_endpoint_url(endpoint_url):
            raise ValueError("Invalid endpoint: %s" % endpoint_url)
        return Endpoint(
            endpoint_url,
            endpoint_prefix=service_model.endpoint_prefix,
            event_emitter=self._event_emitter,
            proxies=self._get_proxies(endpoint_url),
            verify=self._get_verify_value(verify),
            timeout=timeout,
            response_parser_factory=response_parser_factory)

    def _get_proxies(self, url):
        # We could also support getting proxies from a config file,
        # but for now proxy support is taken from the environment.
        return get_environ_proxies(url)

    def _get_verify_value(self, verify):
        # This is to account for:
        # https://github.com/kennethreitz/requests/issues/1436
        # where we need to honor REQUESTS_CA_BUNDLE because we're creating our
        # own request objects.
        # First, if verify is not None, then the user explicitly specified
        # a value so this automatically wins.
        if verify is not None:
            return verify
        # Otherwise use the value from REQUESTS_CA_BUNDLE, or default to
        # True if the env var does not exist.
        return os.environ.get('REQUESTS_CA_BUNDLE', True)
                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/botocore/endpoint.pyc                                         0100644 0000000 0000062 00000022062 13077704401 022373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z d  d l m	 Z	 d  d l
 m Z d  d l m Z d  d l m Z d  d l m Z d  d	 l m Z d  d
 l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z e j e  Z d Z e   y d  d l  m! Z! e! j"   Wn e# k
 rMn Xd   Z$ d e f d     YZ% d e& f d     YZ' d e& f d     YZ( d S(   iN(   t   Session(   t   get_environ_proxies(   t   ConnectionError(   t   six(   t   create_request_object(   t   UnknownEndpointError(   t   EndpointConnectionError(   t   ConnectionClosedError(   t   filter_ssl_warnings(   t   is_valid_endpoint_url(   t   first_non_none_response(   t   StreamingBody(   t   parsersi<   (   t	   pyopensslc         C   sz   i |  j  d 6|  j d 6} | d d k r: |  j | d <n< | j ri t |  j | d j d   | d <n |  j | d <| S(   s  Convert an HTTP response object to a request dict.

    This converts the requests library's HTTP response object to
    a dictionary.

    :type http_response: botocore.vendored.requests.model.Response
    :param http_response: The HTTP response from an AWS service request.

    :rtype: dict
    :return: A response dictionary which will contain the following keys:
        * headers (dict)
        * status_code (int)
        * body (string or file-like object)

    t   headerst   status_codei,  t   bodys   content-length(   R   R   t   contentt   has_streaming_outputR   t   rawt   get(   t   http_responset   operation_modelt   response_dict(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   convert_to_response_dict/   s    
	#t   PreserveAuthSessionc           B   s   e  Z d    Z RS(   c         C   s   d  S(   N(    (   t   selft   prepared_requestt   response(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   rebuild_authN   s    (   t   __name__t
   __module__R   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyR   M   s   t   Endpointc           B   s   e  Z d  Z d e e d d  Z d   Z d   Z d d  Z	 d   Z
 d   Z d   Z d   Z d	   Z d
   Z d d d  Z RS(   s,  
    Represents an endpoint for a particular service in a specific
    region.  Only an endpoint can make requests.

    :ivar service: The Service object that describes this endpoints
        service.
    :ivar host: The fully qualified endpoint hostname.
    :ivar session: The session object.
    c         C   s   | |  _  | |  _ | |  _ | |  _ | d  k r9 i  } n  | |  _ t   |  _ | |  _ t	 j
 d | |  j  t j   |  _ | d  k r t j   } n  | |  _ d  S(   Ns   Setting %s timeout as %s(   t   _endpoint_prefixt   _event_emittert   hostt   verifyt   Nonet   proxiesR   t   http_sessiont   timeoutt   loggert   debugt	   threadingt   Lockt   _lockR   t   ResponseParserFactoryt   _response_parser_factory(   R   R#   t   endpoint_prefixt   event_emitterR&   R$   R(   t   response_parser_factory(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   __init__]   s    							c         C   s   d |  j  |  j f S(   Ns   %s(%s)(   R!   R#   (   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   __repr__o   s    c         C   s)   t  j d | |  j |  |  j | |  S(   Ns5   Making request for %s (verify_ssl=%s) with params: %s(   R)   R*   R$   t   _send_request(   R   R   t   request_dict(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   make_requestr   s    	c         C   se   t  |  } | rR d j d |  j d | j  } |  j j | d | d | j n  |  j |  } | S(   Ns+   request-created.{endpoint_prefix}.{op_name}R0   t   op_namet   requestt   operation_name(   R   t   formatR!   t   nameR"   t   emitt   prepare_request(   R   t   paramsR   R9   t
   event_nameR   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   create_requestw   s    		c         C   sI   xB | j    D]4 \ } } t | t j  r | j d  | | <q q Wd  S(   Ns   utf-8(   t   itemst
   isinstanceR   t	   text_typet   encode(   R   R   t   keyt   value(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   _encode_headers   s    c         C   s   |  j  | j  | j   S(   N(   RH   R   t   prepare(   R   R9   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyR>      s    c         C   s   d } |  j  | |  } |  j | | |  \ } } x` |  j | | | |  r | d 7} | j   |  j  | d | } |  j | | |  \ } } q6 W| d  k	 r |  n | Sd  S(   Ni   R   (   RA   t   _get_responset   _needs_retryt   reset_streamR%   (   R   R6   R   t   attemptsR9   t   success_responset	   exception(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyR5      s    

	c   
   
   C   sa  yJ t  j d |  |  j j | d |  j d | j d |  j d |  j } Wn t k
 r } t  j d d t	 |  j
 |  r | j j } t d | d	 |  } d  | f S|  j |  r t d | j j d
 | j  } d  | f Sd  | f Sn- t k
 r} t  j d d t	 d  | f SXt | |  } |  j j | j d  }	 | |	 j | | j  f d  f S(   Ns   Sending http request: %sR$   t   streamR&   R(   s3   ConnectionError received when sending HTTP request.t   exc_infot   endpoint_urlt   errorR9   s-   Exception received when sending HTTP request.t   protocol(   R)   R*   R'   t   sendR$   R   R&   R(   R   t   Truet   _looks_like_dns_errorR9   t   urlR   R%   t   _looks_like_bad_status_lineR   t	   ExceptionR   R/   t   create_parsert   metadatat   parset   output_shape(
   R   R9   R   RM   R   t   eRR   t   better_exceptionR   t   parser(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRJ      s<    		

		c         C   s   d t  |  k o | j d  k	 S(   Nt   gaierror(   t   strR9   R%   (   R   R_   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRW      s    c         C   s   d t  |  k o | j d  k	 S(   Nt   BadStatusLine(   Rc   R9   R%   (   R   R_   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRY      s    c         C   s   d |  j  | j f } |  j j | d | d |  d | d | d | } t |  } | d  k rb t St j d |  t	 j
 |  t Sd  S(   Ns   needs-retry.%s.%sR   t   endpointt	   operationRM   t   caught_exceptions3   Response received to retry, sleeping for %s seconds(   R!   R<   R"   R=   R
   R%   t   FalseR)   R*   t   timet   sleepRV   (   R   RM   R   R   Rg   R@   t	   responsest   handler_response(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRK      s    				N(   R   R   t   __doc__R%   RV   t   DEFAULT_TIMEOUTR3   R4   R7   RA   RH   R>   R5   RJ   RW   RY   RK   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyR    R   s   							+		t   EndpointCreatorc           B   s5   e  Z d    Z d d e d  Z d   Z d   Z RS(   c         C   s   | |  _  d  S(   N(   R"   (   R   R1   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyR3      s    c         C   se   t  |  s t d |   n  t | d | j d |  j d |  j |  d |  j |  d | d | S(   Ns   Invalid endpoint: %sR0   R1   R&   R$   R(   R2   (   R	   t
   ValueErrorR    R0   R"   t   _get_proxiest   _get_verify_value(   R   t   service_modelt   region_nameRR   R$   R2   R(   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   create_endpoint   s    		c         C   s
   t  |  S(   N(   R   (   R   RX   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRq      s    c         C   s#   | d  k	 r | St j j d t  S(   Nt   REQUESTS_CA_BUNDLE(   R%   t   ost   environR   RV   (   R   R$   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRr      s    N(   R   R   R3   R%   Rn   Ru   Rq   Rr   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyRo      s
   		()   Rw   t   loggingRi   R+   t#   botocore.vendored.requests.sessionsR    t    botocore.vendored.requests.utilsR   t%   botocore.vendored.requests.exceptionsR   t   botocore.vendoredR   t   botocore.awsrequestR   t   botocore.exceptionsR   R   R   t   botocore.compatR   t   botocore.utilsR	   t   botocore.hooksR
   t   botocore.responseR   t   botocoreR   t	   getLoggerR   R)   Rn   t3   botocore.vendored.requests.packages.urllib3.contribR   t   extract_from_urllib3t   ImportErrorR   R   t   objectR    Ro   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/endpoint.pyt   <module>   s8   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/botocore/exceptions.py                                        0100644 0000000 0000062 00000026011 13077704371 022575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
from botocore.vendored.requests.exceptions import ConnectionError


class BotoCoreError(Exception):
    """
    The base exception class for BotoCore exceptions.

    :ivar msg: The descriptive message associated with the error.
    """
    fmt = 'An unspecified error occurred'

    def __init__(self, **kwargs):
        msg = self.fmt.format(**kwargs)
        Exception.__init__(self, msg)
        self.kwargs = kwargs


class DataNotFoundError(BotoCoreError):
    """
    The data associated with a particular path could not be loaded.

    :ivar path: The data path that the user attempted to load.
    """
    fmt = 'Unable to load data for: {data_path}'


class UnknownServiceError(DataNotFoundError):
    """Raised when trying to load data for an unknown service.

    :ivar service_name: The name of the unknown service.

    """
    fmt = (
        "Unknown service: '{service_name}'. Valid service names are: "
        "{known_service_names}")


class ApiVersionNotFoundError(BotoCoreError):
    """
    The data associated with either that API version or a compatible one
    could not be loaded.

    :ivar path: The data path that the user attempted to load.
    :ivar path: The API version that the user attempted to load.
    """
    fmt = 'Unable to load data {data_path} for: {api_version}'


class EndpointConnectionError(BotoCoreError):
    fmt = (
        'Could not connect to the endpoint URL: "{endpoint_url}"')


class ConnectionClosedError(ConnectionError):
    fmt = (
        'Connection was closed before we received a valid response '
        'from endpoint URL: "{endpoint_url}".')
    def __init__(self, **kwargs):
        msg = self.fmt.format(**kwargs)
        kwargs.pop('endpoint_url')
        super(ConnectionClosedError, self).__init__(msg, **kwargs)


class NoCredentialsError(BotoCoreError):
    """
    No credentials could be found
    """
    fmt = 'Unable to locate credentials'


class PartialCredentialsError(BotoCoreError):
    """
    Only partial credentials were found.

    :ivar cred_var: The missing credential variable name.

    """
    fmt = 'Partial credentials found in {provider}, missing: {cred_var}'


class UnknownSignatureVersionError(BotoCoreError):
    """
    Requested Signature Version is not known.

    :ivar signature_version: The name of the requested signature version.
    """
    fmt = 'Unknown Signature Version: {signature_version}.'


class ServiceNotInRegionError(BotoCoreError):
    """
    The service is not available in requested region.

    :ivar service_name: The name of the service.
    :ivar region_name: The name of the region.
    """
    fmt = 'Service {service_name} not available in region {region_name}'


class BaseEndpointResolverError(BotoCoreError):
    """Base error for endpoint resolving errors.

    Should never be raised directly, but clients can catch
    this exception if they want to generically handle any errors
    during the endpoint resolution process.

    """


class NoRegionError(BaseEndpointResolverError):
    """No region was specified."""
    fmt = 'You must specify a region.'


class UnknownEndpointError(BaseEndpointResolverError, ValueError):
    """
    Could not construct an endpoint.

    :ivar service_name: The name of the service.
    :ivar region_name: The name of the region.
    """
    fmt = (
        'Unable to construct an endpoint for '
        '{service_name} in region {region_name}')


class ProfileNotFound(BotoCoreError):
    """
    The specified configuration profile was not found in the
    configuration file.

    :ivar profile: The name of the profile the user attempted to load.
    """
    fmt = 'The config profile ({profile}) could not be found'


class ConfigParseError(BotoCoreError):
    """
    The configuration file could not be parsed.

    :ivar path: The path to the configuration file.
    """
    fmt = 'Unable to parse config file: {path}'


class ConfigNotFound(BotoCoreError):
    """
    The specified configuration file could not be found.

    :ivar path: The path to the configuration file.
    """
    fmt = 'The specified config file ({path}) could not be found.'


class MissingParametersError(BotoCoreError):
    """
    One or more required parameters were not supplied.

    :ivar object: The object that has missing parameters.
        This can be an operation or a parameter (in the
        case of inner params).  The str() of this object
        will be used so it doesn't need to implement anything
        other than str().
    :ivar missing: The names of the missing parameters.
    """
    fmt = ('The following required parameters are missing for '
           '{object_name}: {missing}')


class ValidationError(BotoCoreError):
    """
    An exception occurred validating parameters.

    Subclasses must accept a ``value`` and ``param``
    argument in their ``__init__``.

    :ivar value: The value that was being validated.
    :ivar param: The parameter that failed validation.
    :ivar type_name: The name of the underlying type.
    """
    fmt = ("Invalid value ('{value}') for param {param} "
           "of type {type_name} ")


class ParamValidationError(BotoCoreError):
    fmt = 'Parameter validation failed:\n{report}'


# These exceptions subclass from ValidationError so that code
# can just 'except ValidationError' to catch any possibly validation
# error.
class UnknownKeyError(ValidationError):
    """
    Unknown key in a struct paramster.

    :ivar value: The value that was being checked.
    :ivar param: The name of the parameter.
    :ivar choices: The valid choices the value can be.
    """
    fmt = ("Unknown key '{value}' for param '{param}'.  Must be one "
           "of: {choices}")


class RangeError(ValidationError):
    """
    A parameter value was out of the valid range.

    :ivar value: The value that was being checked.
    :ivar param: The parameter that failed validation.
    :ivar min_value: The specified minimum value.
    :ivar max_value: The specified maximum value.
    """
    fmt = ('Value out of range for param {param}: '
           '{min_value} <= {value} <= {max_value}')


class UnknownParameterError(ValidationError):
    """
    Unknown top level parameter.

    :ivar name: The name of the unknown parameter.
    :ivar operation: The name of the operation.
    :ivar choices: The valid choices the parameter name can be.
    """
    fmt = (
        "Unknown parameter '{name}' for operation {operation}.  Must be one "
        "of: {choices}"
    )


class UnknownServiceStyle(BotoCoreError):
    """
    Unknown style of service invocation.

    :ivar service_style: The style requested.
    """
    fmt = 'The service style ({service_style}) is not understood.'


class PaginationError(BotoCoreError):
    fmt = 'Error during pagination: {message}'


class OperationNotPageableError(BotoCoreError):
    fmt = 'Operation cannot be paginated: {operation_name}'


class ChecksumError(BotoCoreError):
    """The expected checksum did not match the calculated checksum.

    """
    fmt = ('Checksum {checksum_type} failed, expected checksum '
           '{expected_checksum} did not match calculated checksum '
           '{actual_checksum}.')


class UnseekableStreamError(BotoCoreError):
    """Need to seek a stream, but stream does not support seeking.

    """
    fmt = ('Need to rewind the stream {stream_object}, but stream '
           'is not seekable.')


class WaiterError(BotoCoreError):
    """Waiter failed to reach desired state."""
    fmt = 'Waiter {name} failed: {reason}'


class IncompleteReadError(BotoCoreError):
    """HTTP response did not return expected number of bytes."""
    fmt = ('{actual_bytes} read, but total bytes '
           'expected is {expected_bytes}.')


class InvalidExpressionError(BotoCoreError):
    """Expression is either invalid or too complex."""
    fmt = 'Invalid expression {expression}: Only dotted lookups are supported.'


class UnknownCredentialError(BotoCoreError):
    """Tried to insert before/after an unregistered credential type."""
    fmt = 'Credential named {name} not found.'


class WaiterConfigError(BotoCoreError):
    """Error when processing waiter configuration."""
    fmt = 'Error processing waiter config: {error_msg}'


class UnknownClientMethodError(BotoCoreError):
    """Error when trying to access a method on a client that does not exist."""
    fmt = 'Client does not have method: {method_name}'


class UnsupportedSignatureVersionError(BotoCoreError):
    """Error when trying to access a method on a client that does not exist."""
    fmt = 'Signature version is not supported: {signature_version}'


class ClientError(Exception):
    MSG_TEMPLATE = (
        'An error occurred ({error_code}) when calling the {operation_name} '
        'operation: {error_message}')

    def __init__(self, error_response, operation_name):
        msg = self.MSG_TEMPLATE.format(
            error_code=error_response['Error'].get('Code', 'Unknown'),
            error_message=error_response['Error'].get('Message', 'Unknown'),
            operation_name=operation_name)
        super(ClientError, self).__init__(msg)
        self.response = error_response


class UnsupportedTLSVersionWarning(Warning):
    """Warn when an openssl version that uses TLS 1.2 is required"""
    pass


class ImminentRemovalWarning(Warning):
    pass


class InvalidDNSNameError(BotoCoreError):
    """Error when virtual host path is forced on a non-DNS compatible bucket"""
    fmt = (
        'Bucket named {bucket_name} is not DNS compatible. Virtual '
        'hosted-style addressing cannot be used. The addressing style '
        'can be configured by removing the addressing_style value '
        'or setting that value to \'path\' or \'auto\' in the AWS Config '
        'file or in the botocore.client.Config object.'
    )


class InvalidS3AddressingStyleError(BotoCoreError):
    """Error when an invalid path style is specified"""
    fmt = (
        'S3 addressing style {s3_addressing_style} is invaild. Valid options '
        'are: \'auto\', \'virtual\', and \'path\''
    )


class StubResponseError(BotoCoreError):
    fmt = 'Error getting response stub for operation {operation_name}: {reason}'


class StubAssertionError(StubResponseError, AssertionError):
    fmt = 'Error getting response stub for operation {operation_name}: {reason}'


class InvalidConfigError(BotoCoreError):
    fmt = '{error_msg}'


class RefreshWithMFAUnsupportedError(BotoCoreError):
    fmt = 'Cannot refresh credentials: MFA token required.'


class MD5UnavailableError(BotoCoreError):
    fmt = "This system does not support MD5 generation."
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/botocore/exceptions.pyc                                       0100644 0000000 0000062 00000042077 13077704401 022744  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s  d  d l  m Z d e f d     YZ d e f d     YZ d e f d     YZ d e f d	     YZ d
 e f d     YZ d e f d     YZ d e f d     YZ	 d e f d     YZ
 d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e e f d     YZ d e f d     YZ d e f d     YZ d  e f d!     YZ d" e f d#     YZ d$ e f d%     YZ d& e f d'     YZ d( e f d)     YZ d* e f d+     YZ d, e f d-     YZ d. e f d/     YZ d0 e f d1     YZ d2 e f d3     YZ d4 e f d5     YZ d6 e f d7     YZ d8 e f d9     YZ d: e f d;     YZ  d< e f d=     YZ! d> e f d?     YZ" d@ e f dA     YZ# dB e f dC     YZ$ dD e f dE     YZ% dF e f dG     YZ& dH e' f dI     YZ( dJ e' f dK     YZ) dL e f dM     YZ* dN e f dO     YZ+ dP e f dQ     YZ, dR e, e- f dS     YZ. dT e f dU     YZ/ dV e f dW     YZ0 dX e f dY     YZ1 dZ S([   i(   t   ConnectionErrort   BotoCoreErrorc           B   s   e  Z d  Z d Z d   Z RS(   s~   
    The base exception class for BotoCore exceptions.

    :ivar msg: The descriptive message associated with the error.
    s   An unspecified error occurredc         K   s/   |  j  j |   } t j |  |  | |  _ d  S(   N(   t   fmtt   formatt	   Exceptiont   __init__t   kwargs(   t   selfR   t   msg(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s    (   t   __name__t
   __module__t   __doc__R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   t   DataNotFoundErrorc           B   s   e  Z d  Z d Z RS(   s   
    The data associated with a particular path could not be loaded.

    :ivar path: The data path that the user attempted to load.
    s$   Unable to load data for: {data_path}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   t   UnknownServiceErrorc           B   s   e  Z d  Z d Z RS(   sw   Raised when trying to load data for an unknown service.

    :ivar service_name: The name of the unknown service.

    sQ   Unknown service: '{service_name}'. Valid service names are: {known_service_names}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   (   s   t   ApiVersionNotFoundErrorc           B   s   e  Z d  Z d Z RS(   s   
    The data associated with either that API version or a compatible one
    could not be loaded.

    :ivar path: The data path that the user attempted to load.
    :ivar path: The API version that the user attempted to load.
    s2   Unable to load data {data_path} for: {api_version}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   3   s   t   EndpointConnectionErrorc           B   s   e  Z d  Z RS(   s7   Could not connect to the endpoint URL: "{endpoint_url}"(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   >   s   t   ConnectionClosedErrorc           B   s   e  Z d  Z d   Z RS(   s^   Connection was closed before we received a valid response from endpoint URL: "{endpoint_url}".c         K   s<   |  j  j |   } | j d  t t |   j | |  d  S(   Nt   endpoint_url(   R   R   t   popt   superR   R   (   R   R   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   G   s    (   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   C   s   t   NoCredentialsErrorc           B   s   e  Z d  Z d Z RS(   s'   
    No credentials could be found
    s   Unable to locate credentials(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   M   s   t   PartialCredentialsErrorc           B   s   e  Z d  Z d Z RS(   sj   
    Only partial credentials were found.

    :ivar cred_var: The missing credential variable name.

    s<   Partial credentials found in {provider}, missing: {cred_var}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   T   s   t   UnknownSignatureVersionErrorc           B   s   e  Z d  Z d Z RS(   s~   
    Requested Signature Version is not known.

    :ivar signature_version: The name of the requested signature version.
    s/   Unknown Signature Version: {signature_version}.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   ^   s   t   ServiceNotInRegionErrorc           B   s   e  Z d  Z d Z RS(   s   
    The service is not available in requested region.

    :ivar service_name: The name of the service.
    :ivar region_name: The name of the region.
    s<   Service {service_name} not available in region {region_name}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   g   s   t   BaseEndpointResolverErrorc           B   s   e  Z d  Z RS(   s   Base error for endpoint resolving errors.

    Should never be raised directly, but clients can catch
    this exception if they want to generically handle any errors
    during the endpoint resolution process.

    (   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   q   s   t   NoRegionErrorc           B   s   e  Z d  Z d Z RS(   s   No region was specified.s   You must specify a region.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   {   s   t   UnknownEndpointErrorc           B   s   e  Z d  Z d Z RS(   s   
    Could not construct an endpoint.

    :ivar service_name: The name of the service.
    :ivar region_name: The name of the region.
    sJ   Unable to construct an endpoint for {service_name} in region {region_name}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   t   ProfileNotFoundc           B   s   e  Z d  Z d Z RS(   s   
    The specified configuration profile was not found in the
    configuration file.

    :ivar profile: The name of the profile the user attempted to load.
    s1   The config profile ({profile}) could not be found(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   t   ConfigParseErrorc           B   s   e  Z d  Z d Z RS(   sj   
    The configuration file could not be parsed.

    :ivar path: The path to the configuration file.
    s#   Unable to parse config file: {path}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   t   ConfigNotFoundc           B   s   e  Z d  Z d Z RS(   ss   
    The specified configuration file could not be found.

    :ivar path: The path to the configuration file.
    s6   The specified config file ({path}) could not be found.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   t   MissingParametersErrorc           B   s   e  Z d  Z d Z RS(   sx  
    One or more required parameters were not supplied.

    :ivar object: The object that has missing parameters.
        This can be an operation or a parameter (in the
        case of inner params).  The str() of this object
        will be used so it doesn't need to implement anything
        other than str().
    :ivar missing: The names of the missing parameters.
    sJ   The following required parameters are missing for {object_name}: {missing}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   
t   ValidationErrorc           B   s   e  Z d  Z d Z RS(   s3  
    An exception occurred validating parameters.

    Subclasses must accept a ``value`` and ``param``
    argument in their ``__init__``.

    :ivar value: The value that was being validated.
    :ivar param: The parameter that failed validation.
    :ivar type_name: The name of the underlying type.
    s@   Invalid value ('{value}') for param {param} of type {type_name} (   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR      s   
t   ParamValidationErrorc           B   s   e  Z d  Z RS(   s%   Parameter validation failed:
{report}(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR       s   t   UnknownKeyErrorc           B   s   e  Z d  Z d Z RS(   s   
    Unknown key in a struct paramster.

    :ivar value: The value that was being checked.
    :ivar param: The name of the parameter.
    :ivar choices: The valid choices the value can be.
    sE   Unknown key '{value}' for param '{param}'.  Must be one of: {choices}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR!      s   t
   RangeErrorc           B   s   e  Z d  Z d Z RS(   s  
    A parameter value was out of the valid range.

    :ivar value: The value that was being checked.
    :ivar param: The parameter that failed validation.
    :ivar min_value: The specified minimum value.
    :ivar max_value: The specified maximum value.
    sK   Value out of range for param {param}: {min_value} <= {value} <= {max_value}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR"      s   t   UnknownParameterErrorc           B   s   e  Z d  Z d Z RS(   s   
    Unknown top level parameter.

    :ivar name: The name of the unknown parameter.
    :ivar operation: The name of the operation.
    :ivar choices: The valid choices the parameter name can be.
    sP   Unknown parameter '{name}' for operation {operation}.  Must be one of: {choices}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR#      s   t   UnknownServiceStylec           B   s   e  Z d  Z d Z RS(   s]   
    Unknown style of service invocation.

    :ivar service_style: The style requested.
    s6   The service style ({service_style}) is not understood.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR$      s   t   PaginationErrorc           B   s   e  Z d  Z RS(   s"   Error during pagination: {message}(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR%      s   t   OperationNotPageableErrorc           B   s   e  Z d  Z RS(   s/   Operation cannot be paginated: {operation_name}(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR&     s   t   ChecksumErrorc           B   s   e  Z d  Z d Z RS(   sB   The expected checksum did not match the calculated checksum.

    s{   Checksum {checksum_type} failed, expected checksum {expected_checksum} did not match calculated checksum {actual_checksum}.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR'     s   t   UnseekableStreamErrorc           B   s   e  Z d  Z d Z RS(   sA   Need to seek a stream, but stream does not support seeking.

    sF   Need to rewind the stream {stream_object}, but stream is not seekable.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR(     s   t   WaiterErrorc           B   s   e  Z d  Z d Z RS(   s%   Waiter failed to reach desired state.s   Waiter {name} failed: {reason}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR)     s   t   IncompleteReadErrorc           B   s   e  Z d  Z d Z RS(   s6   HTTP response did not return expected number of bytes.sB   {actual_bytes} read, but total bytes expected is {expected_bytes}.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR*     s   t   InvalidExpressionErrorc           B   s   e  Z d  Z d Z RS(   s,   Expression is either invalid or too complex.sC   Invalid expression {expression}: Only dotted lookups are supported.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR+   !  s   t   UnknownCredentialErrorc           B   s   e  Z d  Z d Z RS(   s=   Tried to insert before/after an unregistered credential type.s"   Credential named {name} not found.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR,   &  s   t   WaiterConfigErrorc           B   s   e  Z d  Z d Z RS(   s+   Error when processing waiter configuration.s+   Error processing waiter config: {error_msg}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR-   +  s   t   UnknownClientMethodErrorc           B   s   e  Z d  Z d Z RS(   sE   Error when trying to access a method on a client that does not exist.s*   Client does not have method: {method_name}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR.   0  s   t    UnsupportedSignatureVersionErrorc           B   s   e  Z d  Z d Z RS(   sE   Error when trying to access a method on a client that does not exist.s7   Signature version is not supported: {signature_version}(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR/   5  s   t   ClientErrorc           B   s   e  Z d  Z d   Z RS(   s]   An error occurred ({error_code}) when calling the {operation_name} operation: {error_message}c         C   sd   |  j  j d | d j d d  d | d j d d  d |  } t t |   j |  | |  _ d  S(   Nt
   error_codet   Errort   Codet   Unknownt   error_messaget   Messaget   operation_name(   t   MSG_TEMPLATER   t   getR   R0   R   t   response(   R   t   error_responseR7   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR   ?  s    	(   R	   R
   R8   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR0   :  s   t   UnsupportedTLSVersionWarningc           B   s   e  Z d  Z RS(   s:   Warn when an openssl version that uses TLS 1.2 is required(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR<   H  s   t   ImminentRemovalWarningc           B   s   e  Z RS(    (   R	   R
   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR=   M  s   t   InvalidDNSNameErrorc           B   s   e  Z d  Z d Z RS(   sE   Error when virtual host path is forced on a non-DNS compatible buckets  Bucket named {bucket_name} is not DNS compatible. Virtual hosted-style addressing cannot be used. The addressing style can be configured by removing the addressing_style value or setting that value to 'path' or 'auto' in the AWS Config file or in the botocore.client.Config object.(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR>   Q  s   t   InvalidS3AddressingStyleErrorc           B   s   e  Z d  Z d Z RS(   s-   Error when an invalid path style is specifiedsf   S3 addressing style {s3_addressing_style} is invaild. Valid options are: 'auto', 'virtual', and 'path'(   R	   R
   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR?   \  s   t   StubResponseErrorc           B   s   e  Z d  Z RS(   sD   Error getting response stub for operation {operation_name}: {reason}(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyR@   d  s   t   StubAssertionErrorc           B   s   e  Z d  Z RS(   sD   Error getting response stub for operation {operation_name}: {reason}(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyRA   h  s   t   InvalidConfigErrorc           B   s   e  Z d  Z RS(   s   {error_msg}(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyRB   l  s   t   RefreshWithMFAUnsupportedErrorc           B   s   e  Z d  Z RS(   s/   Cannot refresh credentials: MFA token required.(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyRC   p  s   t   MD5UnavailableErrorc           B   s   e  Z d  Z RS(   s,   This system does not support MD5 generation.(   R	   R
   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyRD   t  s   N(2   t%   botocore.vendored.requests.exceptionsR    R   R   R   R   R   R   R   R   R   R   R   R   R   t
   ValueErrorR   R   R   R   R   R   R    R!   R"   R#   R$   R%   R&   R'   R(   R)   R*   R+   R,   R-   R.   R/   R0   t   WarningR<   R=   R>   R?   R@   t   AssertionErrorRA   RB   RC   RD   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/exceptions.pyt   <module>   sX   	

	


				                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/handlers.py                                          0100644 0000000 0000062 00000075777 13077704371 022243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

"""Builtin event handlers.

This module contains builtin handlers for events emitted by botocore.
"""

import base64
import logging
import xml.etree.cElementTree
import copy
import re
import warnings

from botocore.compat import urlsplit, urlunsplit, unquote, \
    json, quote, six, unquote_str, ensure_bytes, get_md5, MD5_AVAILABLE
from botocore.docs.utils import AutoPopulatedParam
from botocore.docs.utils import HideParamFromOperations
from botocore.docs.utils import AppendParamDocumentation
from botocore.signers import add_generate_presigned_url
from botocore.signers import add_generate_presigned_post
from botocore.exceptions import ParamValidationError
from botocore.exceptions import UnsupportedTLSVersionWarning
from botocore.utils import percent_encode, SAFE_CHARS

from botocore import retryhandler
from botocore import utils
from botocore import translate
import botocore
import botocore.auth


logger = logging.getLogger(__name__)

REGISTER_FIRST = object()
REGISTER_LAST = object()
# From the S3 docs:
# The rules for bucket names in the US Standard region allow bucket names
# to be as long as 255 characters, and bucket names can contain any
# combination of uppercase letters, lowercase letters, numbers, periods
# (.), hyphens (-), and underscores (_).
VALID_BUCKET = re.compile('^[a-zA-Z0-9.\-_]{1,255}$')
VERSION_ID_SUFFIX = re.compile(r'\?versionId=[^\s]+$')


def check_for_200_error(response, **kwargs):
    # From: http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html
    # There are two opportunities for a copy request to return an error. One
    # can occur when Amazon S3 receives the copy request and the other can
    # occur while Amazon S3 is copying the files. If the error occurs before
    # the copy operation starts, you receive a standard Amazon S3 error. If the
    # error occurs during the copy operation, the error response is embedded in
    # the 200 OK response. This means that a 200 OK response can contain either
    # a success or an error. Make sure to design your application to parse the
    # contents of the response and handle it appropriately.
    #
    # So this handler checks for this case.  Even though the server sends a
    # 200 response, conceptually this should be handled exactly like a
    # 500 response (with respect to raising exceptions, retries, etc.)
    # We're connected *before* all the other retry logic handlers, so as long
    # as we switch the error code to 500, we'll retry the error as expected.
    if response is None:
        # A None response can happen if an exception is raised while
        # trying to retrieve the response.  See Endpoint._get_response().
        return
    http_response, parsed = response
    if _looks_like_special_case_error(http_response):
        logger.debug("Error found for response with 200 status code, "
                     "errors: %s, changing status code to "
                     "500.", parsed)
        http_response.status_code = 500


def _looks_like_special_case_error(http_response):
    if http_response.status_code == 200:
        parser = xml.etree.cElementTree.XMLParser(
            target=xml.etree.cElementTree.TreeBuilder(),
            encoding='utf-8')
        parser.feed(http_response.content)
        root = parser.close()
        if root.tag == 'Error':
            return True
    return False


def decode_console_output(parsed, **kwargs):
    if 'Output' in parsed:
        try:
            value = base64.b64decode(six.b(parsed['Output'])).decode('utf-8')
            parsed['Output'] = value
        except (ValueError, TypeError, AttributeError):
            logger.debug('Error decoding base64', exc_info=True)


def decode_quoted_jsondoc(value):
    try:
        value = json.loads(unquote(value))
    except (ValueError, TypeError):
        logger.debug('Error loading quoted JSON', exc_info=True)
    return value


def json_decode_template_body(parsed, **kwargs):
    if 'TemplateBody' in parsed:
        try:
            value = json.loads(parsed['TemplateBody'])
            parsed['TemplateBody'] = value
        except (ValueError, TypeError):
            logger.debug('error loading JSON', exc_info=True)


def calculate_md5(params, **kwargs):
    request_dict = params
    if request_dict['body'] and 'Content-MD5' not in params['headers']:
        body = request_dict['body']
        if isinstance(body, bytes):
            binary_md5 = _calculate_md5_from_bytes(body)
        else:
            binary_md5 = _calculate_md5_from_file(body)
        base64_md5 = base64.b64encode(binary_md5).decode('ascii')
        params['headers']['Content-MD5'] = base64_md5


def _calculate_md5_from_bytes(body_bytes):
    md5 = get_md5(body_bytes)
    return md5.digest()


def _calculate_md5_from_file(fileobj):
    start_position = fileobj.tell()
    md5 = get_md5()
    for chunk in iter(lambda: fileobj.read(1024 * 1024), b''):
        md5.update(chunk)
    fileobj.seek(start_position)
    return md5.digest()


def conditionally_calculate_md5(params, **kwargs):
    """Only add a Content-MD5 when not using sigv4"""
    signer = kwargs['request_signer']
    if signer.signature_version not in ['v4', 's3v4'] and MD5_AVAILABLE:
        calculate_md5(params, **kwargs)


def validate_bucket_name(params, **kwargs):
    if 'Bucket' not in params:
        return
    bucket = params['Bucket']
    if VALID_BUCKET.search(bucket) is None:
        error_msg = (
            'Invalid bucket name "%s": Bucket name must match '
            'the regex "%s"' % (bucket, VALID_BUCKET.pattern))
        raise ParamValidationError(report=error_msg)


def sse_md5(params, **kwargs):
    """
    S3 server-side encryption requires the encryption key to be sent to the
    server base64 encoded, as well as a base64-encoded MD5 hash of the
    encryption key. This handler does both if the MD5 has not been set by
    the caller.
    """
    _sse_md5(params, 'SSECustomer')


def copy_source_sse_md5(params, **kwargs):
    """
    S3 server-side encryption requires the encryption key to be sent to the
    server base64 encoded, as well as a base64-encoded MD5 hash of the
    encryption key. This handler does both if the MD5 has not been set by
    the caller specifically if the parameter is for the copy-source sse-c key.
    """
    _sse_md5(params, 'CopySourceSSECustomer')


def _sse_md5(params, sse_member_prefix='SSECustomer'):
    if not _needs_s3_sse_customization(params, sse_member_prefix):
        return

    sse_key_member = sse_member_prefix + 'Key'
    sse_md5_member = sse_member_prefix + 'KeyMD5'
    key_as_bytes = params[sse_key_member]
    if isinstance(key_as_bytes, six.text_type):
        key_as_bytes = key_as_bytes.encode('utf-8')
    key_md5_str = base64.b64encode(
        get_md5(key_as_bytes).digest()).decode('utf-8')
    key_b64_encoded = base64.b64encode(key_as_bytes).decode('utf-8')
    params[sse_key_member] = key_b64_encoded
    params[sse_md5_member] = key_md5_str


def _needs_s3_sse_customization(params, sse_member_prefix):
    return (params.get(sse_member_prefix + 'Key') is not None and
            sse_member_prefix + 'KeyMD5' not in params)


def register_retries_for_service(service_data, session,
                                 service_name, **kwargs):
    loader = session.get_component('data_loader')
    endpoint_prefix = service_data.get('metadata', {}).get('endpointPrefix')
    if endpoint_prefix is None:
        logger.debug("Not registering retry handlers, could not endpoint "
                     "prefix from model for service %s", service_name)
        return
    config = _load_retry_config(loader, endpoint_prefix)
    if not config:
        return
    logger.debug("Registering retry handlers for service: %s", service_name)
    handler = retryhandler.create_retry_handler(
        config, endpoint_prefix)
    unique_id = 'retry-config-%s' % endpoint_prefix
    session.register('needs-retry.%s' % endpoint_prefix,
                     handler, unique_id=unique_id)
    _register_for_operations(config, session,
                             service_name=endpoint_prefix)


def _load_retry_config(loader, endpoint_prefix):
    original_config = loader.load_data('_retry')
    retry_config = translate.build_retry_config(
        endpoint_prefix, original_config['retry'],
        original_config.get('definitions', {}))
    return retry_config


def _register_for_operations(config, session, service_name):
    # There's certainly a tradeoff for registering the retry config
    # for the operations when the service is created.  In practice,
    # there aren't a whole lot of per operation retry configs so
    # this is ok for now.
    for key in config:
        if key == '__default__':
            continue
        handler = retryhandler.create_retry_handler(config, key)
        unique_id = 'retry-config-%s-%s' % (service_name, key)
        session.register('needs-retry.%s.%s' % (service_name, key),
                         handler, unique_id=unique_id)


def disable_signing(**kwargs):
    """
    This handler disables request signing by setting the signer
    name to a special sentinel value.
    """
    return botocore.UNSIGNED


def add_expect_header(model, params, **kwargs):
    if model.http.get('method', '') not in ['PUT', 'POST']:
        return
    if 'body' in params:
        body = params['body']
        if hasattr(body, 'read'):
            # Any file like object will use an expect 100-continue
            # header regardless of size.
            logger.debug("Adding expect 100 continue header to request.")
            params['headers']['Expect'] = '100-continue'


def document_copy_source_form(section, event_name, **kwargs):
    if 'request-example' in event_name:
        parent = section.get_section('structure-value')
        param_line = parent.get_section('CopySource')
        value_portion = param_line.get_section('member-value')
        value_portion.clear_text()
        value_portion.write("'string' or {'Bucket': 'string', "
                            "'Key': 'string', 'VersionId': 'string'}")
    elif 'request-params' in event_name:
        param_section = section.get_section('CopySource')
        type_section = param_section.get_section('param-type')
        type_section.clear_text()
        type_section.write(':type CopySource: str or dict')
        doc_section = param_section.get_section('param-documentation')
        doc_section.clear_text()
        doc_section.write(
            "The name of the source bucket, key name of the source object, "
            "and optional version ID of the source object.  You can either "
            "provide this value as a string or a dictionary.  The "
            "string form is {bucket}/{key} or "
            "{bucket}/{key}?versionId={versionId} if you want to copy a "
            "specific version.  You can also provide this value as a "
            "dictionary.  The dictionary format is recommended over "
            "the string format because it is more explicit.  The dictionary "
            "format is: {'Bucket': 'bucket', 'Key': 'key', 'VersionId': 'id'}."
            "  Note that the VersionId key is optional and may be omitted."
        )


def handle_copy_source_param(params, **kwargs):
    """Convert CopySource param for CopyObject/UploadPartCopy.

    This handler will deal with two cases:

        * CopySource provided as a string.  We'll make a best effort
          to URL encode the key name as required.  This will require
          parsing the bucket and version id from the CopySource value
          and only encoding the key.
        * CopySource provided as a dict.  In this case we're
          explicitly given the Bucket, Key, and VersionId so we're
          able to encode the key and ensure this value is serialized
          and correctly sent to S3.

    """
    source = params.get('CopySource')
    if source is None:
        # The call will eventually fail but we'll let the
        # param validator take care of this.  It will
        # give a better error message.
        return
    if isinstance(source, six.string_types):
        params['CopySource'] = _quote_source_header(source)
    elif isinstance(source, dict):
        params['CopySource'] = _quote_source_header_from_dict(source)


def _quote_source_header_from_dict(source_dict):
    try:
        bucket = source_dict['Bucket']
        key = percent_encode(source_dict['Key'], safe=SAFE_CHARS + '/')
        version_id = source_dict.get('VersionId')
    except KeyError as e:
        raise ParamValidationError(
            report='Missing required parameter: %s' % str(e))
    final =  '%s/%s' % (bucket, key)
    if version_id is not None:
        final += '?versionId=%s' % version_id
    return final


def _quote_source_header(value):
    result = VERSION_ID_SUFFIX.search(value)
    if result is None:
        return percent_encode(value, safe=SAFE_CHARS + '/')
    else:
        first, version_id = value[:result.start()], value[result.start():]
        return percent_encode(first, safe=SAFE_CHARS + '/') + version_id


def copy_snapshot_encrypted(params, request_signer, **kwargs):
    # The presigned URL that facilities copying an encrypted snapshot.
    # If the user does not provide this value, we will automatically
    # calculate on behalf of the user and inject the PresignedUrl
    # into the requests.
    # The params sent in the event don't quite sync up 100% so we're
    # renaming them here until they can be updated in the event.
    request_dict = params
    params = request_dict['body']
    if 'PresignedUrl' in params:
        # If the customer provided this value, then there's nothing for
        # us to do.
        return
    destination_region = request_signer._region_name
    params['DestinationRegion'] = destination_region
    # The request will be sent to the destination region, so we need
    # to create an endpoint to the source region and create a presigned
    # url based on the source endpoint.
    source_region = params['SourceRegion']

    # The better way to do this is to actually get the
    # endpoint_resolver and get the endpoint_url given the
    # source region.  In this specific case, we know that
    # we can safely replace the dest region with the source
    # region because of the supported EC2 regions, but in
    # general this is not a safe assumption to make.
    # I think eventually we should try to plumb through something
    # that allows us to resolve endpoints from regions.
    request_dict_copy = copy.deepcopy(request_dict)
    request_dict_copy['url'] = request_dict['url'].replace(
        destination_region, source_region)
    request_dict_copy['method'] = 'GET'
    request_dict_copy['headers'] = {}
    presigned_url = request_signer.generate_presigned_url(
        request_dict_copy, region_name=source_region)
    params['PresignedUrl'] = presigned_url


def json_decode_policies(parsed, model, **kwargs):
    # Any time an IAM operation returns a policy document
    # it is a string that is json that has been urlencoded,
    # i.e urlencode(json.dumps(policy_document)).
    # To give users something more useful, we will urldecode
    # this value and json.loads() the result so that they have
    # the policy document as a dictionary.
    output_shape = model.output_shape
    if output_shape is not None:
        _decode_policy_types(parsed, model.output_shape)


def _decode_policy_types(parsed, shape):
    # IAM consistently uses the policyDocumentType shape to indicate
    # strings that have policy documents.
    shape_name = 'policyDocumentType'
    if shape.type_name == 'structure':
        for member_name, member_shape in shape.members.items():
            if member_shape.type_name == 'string' and \
                    member_shape.name == shape_name and \
                    member_name in parsed:
                parsed[member_name] = decode_quoted_jsondoc(
                    parsed[member_name])
            elif member_name in parsed:
                _decode_policy_types(parsed[member_name], member_shape)
    if shape.type_name == 'list':
        shape_member = shape.member
        for item in parsed:
            _decode_policy_types(item, shape_member)


def parse_get_bucket_location(parsed, http_response, **kwargs):
    # s3.GetBucketLocation cannot be modeled properly.  To
    # account for this we just manually parse the XML document.
    # The "parsed" passed in only has the ResponseMetadata
    # filled out.  This handler will fill in the LocationConstraint
    # value.
    response_body = http_response.content
    parser = xml.etree.cElementTree.XMLParser(
        target=xml.etree.cElementTree.TreeBuilder(),
        encoding='utf-8')
    parser.feed(response_body)
    root = parser.close()
    region = root.text
    parsed['LocationConstraint'] = region


def base64_encode_user_data(params, **kwargs):
    if 'UserData' in params:
        if isinstance(params['UserData'], six.text_type):
            # Encode it to bytes if it is text.
            params['UserData'] = params['UserData'].encode('utf-8')
        params['UserData'] = base64.b64encode(
            params['UserData']).decode('utf-8')


def document_base64_encoding(param):
    description = ('**This value will be base64 encoded automatically. Do '
                   'not base64 encode this value prior to performing the '
                   'operation.**')
    append = AppendParamDocumentation(param, description)
    return append.append_documentation


def fix_route53_ids(params, model, **kwargs):
    """
    Check for and split apart Route53 resource IDs, setting
    only the last piece. This allows the output of one operation
    (e.g. ``'foo/1234'``) to be used as input in another
    operation (e.g. it expects just ``'1234'``).
    """
    input_shape = model.input_shape
    if not input_shape or not hasattr(input_shape, 'members'):
        return

    members = [name for (name, shape) in input_shape.members.items()
               if shape.name in ['ResourceId', 'DelegationSetId']]

    for name in members:
        if name in params:
            orig_value = params[name]
            params[name] = orig_value.split('/')[-1]
            logger.debug('%s %s -> %s', name, orig_value, params[name])


def inject_account_id(params, **kwargs):
    if params.get('accountId') is None:
        # Glacier requires accountId, but allows you
        # to specify '-' for the current owners account.
        # We add this default value if the user does not
        # provide the accountId as a convenience.
        params['accountId'] = '-'


def add_glacier_version(model, params, **kwargs):
    request_dict = params
    request_dict['headers']['x-amz-glacier-version'] = model.metadata[
        'apiVersion']


def add_accept_header(model, params, **kwargs):
    request_dict = params
    request_dict['headers']['Accept'] = 'application/json'


def add_glacier_checksums(params, **kwargs):
    """Add glacier checksums to the http request.

    This will add two headers to the http request:

        * x-amz-content-sha256
        * x-amz-sha256-tree-hash

    These values will only be added if they are not present
    in the HTTP request.

    """
    request_dict = params
    headers = request_dict['headers']
    body = request_dict['body']
    if isinstance(body, six.binary_type):
        # If the user provided a bytes type instead of a file
        # like object, we're temporarily create a BytesIO object
        # so we can use the util functions to calculate the
        # checksums which assume file like objects.  Note that
        # we're not actually changing the body in the request_dict.
        body = six.BytesIO(body)
    starting_position = body.tell()
    if 'x-amz-content-sha256' not in headers:
        headers['x-amz-content-sha256'] = utils.calculate_sha256(
            body, as_hex=True)
    body.seek(starting_position)
    if 'x-amz-sha256-tree-hash' not in headers:
        headers['x-amz-sha256-tree-hash'] = utils.calculate_tree_hash(body)
    body.seek(starting_position)


def document_glacier_tree_hash_checksum():
    doc = '''
        This is a required field.

        Ideally you will want to compute this value with checksums from
        previous uploaded parts, using the algorithm described in
        `Glacier documentation <http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html>`_.

        But if you prefer, you can also use botocore.util.calculate_tree_hash()
        to compute it from raw file by::

            checksum = calculate_tree_hash(open('your_file.txt', 'rb'))

        '''
    return AppendParamDocumentation('checksum', doc).append_documentation


def switch_host_machinelearning(request, **kwargs):
    switch_host_with_param(request, 'PredictEndpoint')


def switch_host_with_param(request, param_name):
    request_json = json.loads(request.data.decode('utf-8'))
    if request_json.get(param_name):
        new_endpoint = request_json[param_name]
        new_endpoint_components = urlsplit(new_endpoint)
        original_endpoint = request.url
        original_endpoint_components = urlsplit(original_endpoint)
        final_endpoint_components = (
            new_endpoint_components.scheme,
            new_endpoint_components.netloc,
            original_endpoint_components.path,
            original_endpoint_components.query,
            ''
        )
        final_endpoint = urlunsplit(final_endpoint_components)
        request.url = final_endpoint


def check_openssl_supports_tls_version_1_2(**kwargs):
    import ssl
    try:
        openssl_version_tuple = ssl.OPENSSL_VERSION_INFO
        if openssl_version_tuple[0] < 1 or openssl_version_tuple[2] < 1:
            warnings.warn(
                'Currently installed openssl version: %s does not '
                'support TLS 1.2, which is required for use of iot-data. '
                'Please use python installed with openssl version 1.0.1 or '
                'higher.' % (ssl.OPENSSL_VERSION),
                UnsupportedTLSVersionWarning
            )
    # We cannot check the openssl version on python2.6, so we should just
    # pass on this conveniency check.
    except AttributeError:
        pass


def change_get_to_post(request, **kwargs):
    # This is useful when we need to change a potentially large GET request
    # into a POST with x-www-form-urlencoded encoding.
    if request.method == 'GET' and '?' in request.url:
        request.headers['Content-Type'] = 'application/x-www-form-urlencoded'
        request.method = 'POST'
        request.url, request.data = request.url.split('?', 1)


def set_list_objects_encoding_type_url(params, context, **kwargs):
    if 'EncodingType' not in params:
        # We set this context so that we know it wasn't the customer that
        # requested the encoding.
        context['EncodingTypeAutoSet'] = True
        params['EncodingType'] = 'url'


def decode_list_object(parsed, context, **kwargs):
    # This is needed because we are passing url as the encoding type. Since the
    # paginator is based on the key, we need to handle it before it can be
    # round tripped.
    #
    # From the documentation: If you specify encoding-type request parameter,
    # Amazon S3 includes this element in the response, and returns encoded key
    # name values in the following response elements:
    # Delimiter, Marker, Prefix, NextMarker, Key.
    if parsed.get('EncodingType') == 'url' and \
                    context.get('EncodingTypeAutoSet'):
        # URL decode top-level keys in the response if present.
        top_level_keys = ['Delimiter', 'Marker', 'NextMarker']
        for key in top_level_keys:
            if key in parsed:
                parsed[key] = unquote_str(parsed[key])
        # URL decode nested keys from the response if present.
        nested_keys = [('Contents', 'Key'), ('CommonPrefixes', 'Prefix')]
        for (top_key, child_key) in nested_keys:
            if top_key in parsed:
                for member in parsed[top_key]:
                    member[child_key] = unquote_str(member[child_key])


def convert_body_to_file_like_object(params, **kwargs):
    if 'Body' in params:
        if isinstance(params['Body'], six.string_types):
            params['Body'] = six.BytesIO(ensure_bytes(params['Body']))
        elif isinstance(params['Body'], six.binary_type):
            params['Body'] = six.BytesIO(params['Body'])


# This is a list of (event_name, handler).
# When a Session is created, everything in this list will be
# automatically registered with that Session.

BUILTIN_HANDLERS = [
    ('before-parameter-build.s3.UploadPart',
     convert_body_to_file_like_object, REGISTER_LAST),
    ('before-parameter-build.s3.PutObject',
     convert_body_to_file_like_object, REGISTER_LAST),
    ('creating-client-class', add_generate_presigned_url),
    ('creating-client-class.s3', add_generate_presigned_post),
    ('creating-client-class.iot-data', check_openssl_supports_tls_version_1_2),
    ('after-call.iam', json_decode_policies),

    ('after-call.ec2.GetConsoleOutput', decode_console_output),
    ('after-call.cloudformation.GetTemplate', json_decode_template_body),
    ('after-call.s3.GetBucketLocation', parse_get_bucket_location),

    ('before-parameter-build.s3', validate_bucket_name),

    ('before-parameter-build.s3.ListObjects',
     set_list_objects_encoding_type_url),
    ('before-call.s3.PutBucketTagging', calculate_md5),
    ('before-call.s3.PutBucketLifecycle', calculate_md5),
    ('before-call.s3.PutBucketLifecycleConfiguration', calculate_md5),
    ('before-call.s3.PutBucketCors', calculate_md5),
    ('before-call.s3.DeleteObjects', calculate_md5),
    ('before-call.s3.PutBucketReplication', calculate_md5),
    ('before-call.s3.PutObject', conditionally_calculate_md5),
    ('before-call.s3.UploadPart', conditionally_calculate_md5),
    ('before-call.s3.PutBucketAcl', conditionally_calculate_md5),
    ('before-call.s3.PutBucketLogging', conditionally_calculate_md5),
    ('before-call.s3.PutBucketNotification', conditionally_calculate_md5),
    ('before-call.s3.PutBucketPolicy', conditionally_calculate_md5),
    ('before-call.s3.PutBucketRequestPayment', conditionally_calculate_md5),
    ('before-call.s3.PutBucketVersioning', conditionally_calculate_md5),
    ('before-call.s3.PutBucketWebsite', conditionally_calculate_md5),
    ('before-call.s3.PutObjectAcl', conditionally_calculate_md5),

    ('before-parameter-build.s3.CopyObject',
     handle_copy_source_param),
    ('before-parameter-build.s3.UploadPartCopy',
     handle_copy_source_param),
    ('docs.*.s3.CopyObject.complete-section', document_copy_source_form),
    ('docs.*.s3.UploadPartCopy.complete-section', document_copy_source_form),

    ('before-call.s3', add_expect_header),
    ('before-call.glacier', add_glacier_version),
    ('before-call.apigateway', add_accept_header),
    ('before-call.glacier.UploadArchive', add_glacier_checksums),
    ('before-call.glacier.UploadMultipartPart', add_glacier_checksums),
    ('before-call.ec2.CopySnapshot', copy_snapshot_encrypted),
    ('request-created.machinelearning.Predict', switch_host_machinelearning),
    ('needs-retry.s3.UploadPartCopy', check_for_200_error, REGISTER_FIRST),
    ('needs-retry.s3.CopyObject', check_for_200_error, REGISTER_FIRST),
    ('needs-retry.s3.CompleteMultipartUpload', check_for_200_error,
     REGISTER_FIRST),
    ('service-data-loaded', register_retries_for_service),
    ('choose-signer.cognito-identity.GetId', disable_signing),
    ('choose-signer.cognito-identity.GetOpenIdToken', disable_signing),
    ('choose-signer.cognito-identity.UnlinkIdentity', disable_signing),
    ('choose-signer.cognito-identity.GetCredentialsForIdentity',
        disable_signing),
    ('choose-signer.sts.AssumeRoleWithSAML', disable_signing),
    ('choose-signer.sts.AssumeRoleWithWebIdentity', disable_signing),
    ('before-sign.s3', utils.fix_s3_host),
    ('before-parameter-build.s3.HeadObject', sse_md5),
    ('before-parameter-build.s3.GetObject', sse_md5),
    ('before-parameter-build.s3.PutObject', sse_md5),
    ('before-parameter-build.s3.CopyObject', sse_md5),
    ('before-parameter-build.s3.CopyObject', copy_source_sse_md5),
    ('before-parameter-build.s3.CreateMultipartUpload', sse_md5),
    ('before-parameter-build.s3.UploadPart', sse_md5),
    ('before-parameter-build.s3.UploadPartCopy', sse_md5),
    ('before-parameter-build.s3.UploadPartCopy', copy_source_sse_md5),
    ('before-parameter-build.ec2.RunInstances', base64_encode_user_data),
    ('before-parameter-build.autoscaling.CreateLaunchConfiguration',
     base64_encode_user_data),
    ('before-parameter-build.route53', fix_route53_ids),
    ('before-parameter-build.glacier', inject_account_id),
    ('after-call.s3.ListObjects', decode_list_object),

    # Cloudsearchdomain search operation will be sent by HTTP POST
    ('request-created.cloudsearchdomain.Search',
     change_get_to_post),
    # Glacier documentation customizations
    ('docs.*.glacier.*.complete-section',
     AutoPopulatedParam('accountId', 'Note: this parameter is set to "-" by \
                         default if no value is not specified.')
     .document_auto_populated_param),
    ('docs.*.glacier.UploadArchive.complete-section',
     AutoPopulatedParam('checksum').document_auto_populated_param),
    ('docs.*.glacier.UploadMultipartPart.complete-section',
     AutoPopulatedParam('checksum').document_auto_populated_param),
    ('docs.request-params.glacier.CompleteMultipartUpload.complete-section',
     document_glacier_tree_hash_checksum()),

    # UserData base64 encoding documentation customizations
    ('docs.*.ec2.RunInstances.complete-section',
     document_base64_encoding('UserData')),
    ('docs.*.autoscaling.CreateLaunchConfiguration.complete-section',
     document_base64_encoding('UserData')),
    # EC2 CopySnapshot documentation customizations
    ('docs.*.ec2.CopySnapshot.complete-section',
     AutoPopulatedParam('PresignedUrl').document_auto_populated_param),
    ('docs.*.ec2.CopySnapshot.complete-section',
     AutoPopulatedParam('DestinationRegion').document_auto_populated_param),
    # S3 SSE documentation modifications
    ('docs.*.s3.*.complete-section',
     AutoPopulatedParam('SSECustomerKeyMD5').document_auto_populated_param),
    # S3 SSE Copy Source documentation modifications
    ('docs.*.s3.*.complete-section',
     AutoPopulatedParam(
        'CopySourceSSECustomerKeyMD5').document_auto_populated_param),
    # Add base64 information to Lambda
    ('docs.*.lambda.UpdateFunctionCode.complete-section',
     document_base64_encoding('ZipFile')),
    # The following S3 operations cannot actually accept a ContentMD5
    ('docs.*.s3.*.complete-section',
     HideParamFromOperations(
         's3', 'ContentMD5',
         ['DeleteObjects', 'PutBucketAcl', 'PutBucketCors',
          'PutBucketLifecycle', 'PutBucketLogging', 'PutBucketNotification',
          'PutBucketPolicy', 'PutBucketReplication', 'PutBucketRequestPayment',
          'PutBucketTagging', 'PutBucketVersioning', 'PutBucketWebsite',
          'PutObjectAcl']).hide_param)
]
 usr/local/lib/python2.7/dist-packages/botocore/handlers.pyc                                         0100644 0000000 0000062 00000063031 13077704401 022354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc        \   @   ss  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m	 Z	 m
 Z
 m Z m Z m Z m Z m Z m Z m Z m Z d d l m Z d d l m Z d d l m Z d d l m Z d d l m Z d d	 l m Z d d
 l m Z d d l m Z m Z d d l  m! Z! d d l  m" Z" d d l  m# Z# d d l  Z  d d l$ Z  e j% e&  Z' e(   Z) e(   Z* e j+ d  Z, e j+ d  Z- d   Z. d   Z/ d   Z0 d   Z1 d   Z2 d   Z3 d   Z4 d   Z5 d   Z6 d   Z7 d   Z8 d   Z9 d d  Z: d   Z; d    Z< d!   Z= d"   Z> d#   Z? d$   Z@ d%   ZA d&   ZB d'   ZC d(   ZD d)   ZE d*   ZF d+   ZG d,   ZH d-   ZI d.   ZJ d/   ZK d0   ZL d1   ZM d2   ZN d3   ZO d4   ZP d5   ZQ d6   ZR d7   ZS d8   ZT d9   ZU d:   ZV d;   ZW d< eW e* f d= eW e* f d> e f d? e f d@ eS f dA eF f dB e0 f dC e2 f dD eH f dE e7 f dF eU f dG e3 f dH e3 f dI e3 f dJ e3 f dK e3 f dL e3 f dM e6 f dN e6 f dO e6 f dP e6 f dQ e6 f dR e6 f dS e6 f dT e6 f dU e6 f dV e6 f dW eB f dX eB f dY eA f dZ eA f d[ e@ f d\ eM f d] eN f d^ eO f d_ eO f d` eE f da eQ f db e. e) f dc e. e) f dd e. e) f de e< f df e? f dg e? f dh e? f di e? f dj e? f dk e? f dl e" jX f dm e8 f dn e8 f d= e8 f dW e8 f dW e9 f do e8 f d< e8 f dX e8 f dX e9 f dp eI f dq eI f dr eK f ds eL f dt eV f du eT f dv e dw dx  jY f dy e dz  jY f d{ e dz  jY f d| eP   f d} eJ d~  f d eJ d~  f d e d  jY f d e d  jY f d e d  jY f d e d  jY f d eJ d  f d e d d d d d d d d d d d d d d d g  jZ f gL Z[ d S(   s_   Builtin event handlers.

This module contains builtin handlers for events emitted by botocore.
iN(
   t   urlsplitt
   urlunsplitt   unquotet   jsont   quotet   sixt   unquote_strt   ensure_bytest   get_md5t   MD5_AVAILABLE(   t   AutoPopulatedParam(   t   HideParamFromOperations(   t   AppendParamDocumentation(   t   add_generate_presigned_url(   t   add_generate_presigned_post(   t   ParamValidationError(   t   UnsupportedTLSVersionWarning(   t   percent_encodet
   SAFE_CHARS(   t   retryhandler(   t   utils(   t	   translates   ^[a-zA-Z0-9.\-_]{1,255}$s   \?versionId=[^\s]+$c         K   sH   |  d  k r d  S|  \ } } t |  rD t j d |  d | _ n  d  S(   NsW   Error found for response with 200 status code, errors: %s, changing status code to 500.i  (   t   Nonet   _looks_like_special_case_errort   loggert   debugt   status_code(   t   responset   kwargst   http_responset   parsed(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   check_for_200_error9   s    	c         C   so   |  j  d k rk t j j j d t j j j   d d  } | j |  j  | j   } | j	 d k rk t
 Sn  t S(   Ni   t   targett   encodings   utf-8t   Error(   R   t   xmlt   etreet   cElementTreet	   XMLParsert   TreeBuildert   feedt   contentt   closet   tagt   Truet   False(   R   t   parsert   root(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR   U   s    	c         K   sv   d |  k rr y3 t  j t j |  d   j d  } | |  d <Wqr t t t f k
 rn t j	 d d t
 qr Xn  d  S(   Nt   Outputs   utf-8s   Error decoding base64t   exc_info(   t   base64t	   b64decodeR   t   bt   decodet
   ValueErrort	   TypeErrort   AttributeErrorR   R   R,   (   R   R   t   value(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   decode_console_outputa   s    %c         C   sJ   y t  j t |    }  Wn* t t f k
 rE t j d d t n X|  S(   Ns   Error loading quoted JSONR1   (   R   t   loadsR   R6   R7   R   R   R,   (   R9   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   decode_quoted_jsondocj   s
    c         K   sa   d |  k r] y! t  j |  d  } | |  d <Wq] t t f k
 rY t j d d t q] Xn  d  S(   Nt   TemplateBodys   error loading JSONR1   (   R   R;   R6   R7   R   R   R,   (   R   R   R9   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   json_decode_template_bodyr   s    c         K   s   |  } | d r} d |  d k r} | d } t  | t  rH t |  } n t |  } t j |  j d  } | |  d d <n  d  S(   Nt   bodys   Content-MD5t   headerst   ascii(   t
   isinstancet   bytest   _calculate_md5_from_bytest   _calculate_md5_from_fileR2   t	   b64encodeR5   (   t   paramsR   t   request_dictR?   t
   binary_md5t
   base64_md5(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   calculate_md5{   s    
c         C   s   t  |   } | j   S(   N(   R   t   digest(   t
   body_bytest   md5(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyRD      s    c            s\     j    } t   } x- t   f d   d  D] } | j |  q. W  j |  | j   S(   Nc              s     j  d  S(   Ni   i   (   t   read(    (   t   fileobj(    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   <lambda>   s    t    (   t   tellR   t   itert   updatet   seekRL   (   RP   t   start_positionRN   t   chunk(    (   RP   s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyRE      s    	c         K   s3   | d } | j  d k r/ t r/ t |  |  n  d S(   s+   Only add a Content-MD5 when not using sigv4t   request_signert   v4t   s3v4N(   RZ   R[   (   t   signature_versionR	   RK   (   RG   R   t   signer(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   conditionally_calculate_md5   s    
c         K   sX   d |  k r d  S|  d } t  j |  d  k rT d | t  j f } t d |   n  d  S(   Nt   Buckets?   Invalid bucket name "%s": Bucket name must match the regex "%s"t   report(   t   VALID_BUCKETt   searchR   t   patternR   (   RG   R   t   buckett	   error_msg(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   validate_bucket_name   s    
c         K   s   t  |  d  d S(   s   
    S3 server-side encryption requires the encryption key to be sent to the
    server base64 encoded, as well as a base64-encoded MD5 hash of the
    encryption key. This handler does both if the MD5 has not been set by
    the caller.
    t   SSECustomerN(   t   _sse_md5(   RG   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   sse_md5   s    c         K   s   t  |  d  d S(   s1  
    S3 server-side encryption requires the encryption key to be sent to the
    server base64 encoded, as well as a base64-encoded MD5 hash of the
    encryption key. This handler does both if the MD5 has not been set by
    the caller specifically if the parameter is for the copy-source sse-c key.
    t   CopySourceSSECustomerN(   Rh   (   RG   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   copy_source_sse_md5   s    Rg   c         C   s   t  |  |  s d  S| d } | d } |  | } t | t j  rU | j d  } n  t j t |  j    j	 d  } t j |  j	 d  } | |  | <| |  | <d  S(   Nt   Keyt   KeyMD5s   utf-8(
   t   _needs_s3_sse_customizationRB   R   t	   text_typet   encodeR2   RF   R   RL   R5   (   RG   t   sse_member_prefixt   sse_key_membert   sse_md5_membert   key_as_bytest   key_md5_strt   key_b64_encoded(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyRh      s    



c         C   s'   |  j  | d  d  k	 o& | d |  k S(   NRl   Rm   (   t   getR   (   RG   Rq   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyRn      s    c   	      K   s   | j  d  } |  j d i   j d  } | d  k rJ t j d |  d  St | |  } | sc d  St j d |  t j | |  } d | } | j d | | d | t	 | | d	 | d  S(
   Nt   data_loadert   metadatat   endpointPrefixsS   Not registering retry handlers, could not endpoint prefix from model for service %ss*   Registering retry handlers for service: %ss   retry-config-%ss   needs-retry.%st	   unique_idt   service_name(
   t   get_componentRw   R   R   R   t   _load_retry_configR   t   create_retry_handlert   registert   _register_for_operations(	   t   service_datat   sessionR|   R   t   loadert   endpoint_prefixt   configt   handlerR{   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   register_retries_for_service   s"    	
c         C   s8   |  j  d  } t j | | d | j d i    } | S(   Nt   _retryt   retryt   definitions(   t	   load_dataR   t   build_retry_configRw   (   R   R   t   original_configt   retry_config(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR~      s
    
c         C   si   xb |  D]Z } | d k r q n  t  j |  |  } d | | f } | j d | | f | d | q Wd  S(   Nt   __default__s   retry-config-%s-%ss   needs-retry.%s.%sR{   (   R   R   R   (   R   R   R|   t   keyR   R{   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR      s    c          K   s   t  j S(   sk   
    This handler disables request signing by setting the signer
    name to a special sentinel value.
    (   t   botocoret   UNSIGNED(   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   disable_signing   s    c         K   si   |  j  j d d  d k r d  Sd | k re | d } t | d  re t j d  d | d	 d
 <qe n  d  S(   Nt   methodRR   t   PUTt   POSTR?   RO   s-   Adding expect 100 continue header to request.s   100-continueR@   t   Expect(   s   PUTs   POST(   t   httpRw   t   hasattrR   R   (   t   modelRG   R   R?   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   add_expect_header  s    
c   	      K   s   d | k rS |  j  d  } | j  d  } | j  d  } | j   | j d  nj d | k r |  j  d  } | j  d  } | j   | j d  | j  d	  } | j   | j d
  n  d  S(   Ns   request-examples   structure-valuet
   CopySources   member-valuesH   'string' or {'Bucket': 'string', 'Key': 'string', 'VersionId': 'string'}s   request-paramss
   param-types   :type CopySource: str or dicts   param-documentations9  The name of the source bucket, key name of the source object, and optional version ID of the source object.  You can either provide this value as a string or a dictionary.  The string form is {bucket}/{key} or {bucket}/{key}?versionId={versionId} if you want to copy a specific version.  You can also provide this value as a dictionary.  The dictionary format is recommended over the string format because it is more explicit.  The dictionary format is: {'Bucket': 'bucket', 'Key': 'key', 'VersionId': 'id'}.  Note that the VersionId key is optional and may be omitted.(   t   get_sectiont
   clear_textt   write(	   t   sectiont
   event_nameR   t   parentt
   param_linet   value_portiont   param_sectiont   type_sectiont   doc_section(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   document_copy_source_form  s    


c         K   sj   |  j  d  } | d k r d St | t j  rD t |  |  d <n" t | t  rf t |  |  d <n  d S(   sH  Convert CopySource param for CopyObject/UploadPartCopy.

    This handler will deal with two cases:

        * CopySource provided as a string.  We'll make a best effort
          to URL encode the key name as required.  This will require
          parsing the bucket and version id from the CopySource value
          and only encoding the key.
        * CopySource provided as a dict.  In this case we're
          explicitly given the Bucket, Key, and VersionId so we're
          able to encode the key and ensure this value is serialized
          and correctly sent to S3.

    R   N(   Rw   R   RB   R   t   string_typest   _quote_source_headert   dictt   _quote_source_header_from_dict(   RG   R   t   source(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   handle_copy_source_param,  s    c         C   s   y7 |  d } t  |  d d t d } |  j d  } Wn, t k
 re } t d d t |    n Xd | | f } | d  k	 r | d	 | 7} n  | S(
   NR_   Rl   t   safet   /t	   VersionIdR`   s   Missing required parameter: %ss   %s/%ss   ?versionId=%s(   R   R   Rw   t   KeyErrorR   t   strR   (   t   source_dictRd   R   t
   version_idt   et   final(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR   G  s    
c         C   sl   t  j |   } | d  k r/ t |  d t d S|  | j    |  | j   } } t | d t d | Sd  S(   NR   R   (   t   VERSION_ID_SUFFIXRb   R   R   R   t   start(   R9   t   resultt   firstR   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR   U  s
    !c         K   s   |  } | d }  d |  k r  d  S| j  } | |  d <|  d } t j |  } | d j | |  | d <d | d <i  | d <| j | d	 | } | |  d <d  S(
   NR?   t   PresignedUrlt   DestinationRegiont   SourceRegiont   urlt   GETR   R@   t   region_name(   t   _region_namet   copyt   deepcopyt   replacet   generate_presigned_url(   RG   RY   R   RH   t   destination_regiont   source_regiont   request_dict_copyt   presigned_url(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   copy_snapshot_encrypted^  s    
	





c         K   s,   | j  } | d  k	 r( t |  | j   n  d  S(   N(   t   output_shapeR   t   _decode_policy_types(   R   R   R   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   json_decode_policies  s    	c         C   s   d } | j  d k r x | j j   D]m \ } } | j  d k rr | j | k rr | |  k rr t |  |  |  | <q% | |  k r% t |  | |  q% q% Wn  | j  d k r | j } x |  D] } t | |  q Wn  d  S(   Nt   policyDocumentTypet	   structuret   stringt   list(   t	   type_namet   memberst   itemst   nameR<   R   t   member(   R   t   shapet
   shape_namet   member_namet   member_shapet   shape_membert   item(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR     s    	c         K   sc   | j  } t j j j d t j j j   d d  } | j |  | j   } | j } | |  d <d  S(   NR    R!   s   utf-8t   LocationConstraint(	   R)   R#   R$   R%   R&   R'   R(   R*   t   text(   R   R   R   t   response_bodyR.   R/   t   region(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   parse_get_bucket_location  s    			c         K   sc   d |  k r_ t  |  d t j  r< |  d j d  |  d <n  t j |  d  j d  |  d <n  d  S(   Nt   UserDatas   utf-8(   RB   R   Ro   Rp   R2   RF   R5   (   RG   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   base64_encode_user_data  s
    c         C   s   d } t  |  |  } | j S(   Nsw   **This value will be base64 encoded automatically. Do not base64 encode this value prior to performing the operation.**(   R   t   append_documentation(   t   paramt   descriptiont   append(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   document_base64_encoding  s    c         K   s   | j  } | s  t | d  r$ d Sg  | j j   D]! \ } } | j d k r4 | ^ q4 } xX | D]P } | |  k rb |  | } | j d  d |  | <t j d | | |  |  qb qb Wd S(	   s   
    Check for and split apart Route53 resource IDs, setting
    only the last piece. This allows the output of one operation
    (e.g. ``'foo/1234'``) to be used as input in another
    operation (e.g. it expects just ``'1234'``).
    R   Nt
   ResourceIdt   DelegationSetIdR   is   %s %s -> %s(   R   R   (   t   input_shapeR   R   R   R   t   splitR   R   (   RG   R   R   R   R   R   R   t
   orig_value(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   fix_route53_ids  s    	
c         K   s&   |  j  d  d  k r" d |  d <n  d  S(   Nt	   accountIdt   -(   Rw   R   (   RG   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   inject_account_id  s    c         K   s   | } |  j  d | d d <d  S(   Nt
   apiVersionR@   s   x-amz-glacier-version(   Ry   (   R   RG   R   RH   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   add_glacier_version  s    c         K   s   | } d | d d <d  S(   Ns   application/jsonR@   t   Accept(    (   R   RG   R   RH   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   add_accept_header  s    c         K   s   |  } | d } | d } t  | t j  r> t j |  } n  | j   } d | k rr t j | d t | d <n  | j |  d | k r t j	 |  | d <n  | j |  d S(   s   Add glacier checksums to the http request.

    This will add two headers to the http request:

        * x-amz-content-sha256
        * x-amz-sha256-tree-hash

    These values will only be added if they are not present
    in the HTTP request.

    R@   R?   s   x-amz-content-sha256t   as_hexs   x-amz-sha256-tree-hashN(
   RB   R   t   binary_typet   BytesIORS   R   t   calculate_sha256R,   RV   t   calculate_tree_hash(   RG   R   RH   R@   R?   t   starting_position(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   add_glacier_checksums  s    

c          C   s   d }  t  d |   j S(   Ns  
        This is a required field.

        Ideally you will want to compute this value with checksums from
        previous uploaded parts, using the algorithm described in
        `Glacier documentation <http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html>`_.

        But if you prefer, you can also use botocore.util.calculate_tree_hash()
        to compute it from raw file by::

            checksum = calculate_tree_hash(open('your_file.txt', 'rb'))

        t   checksum(   R   R   (   t   doc(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt#   document_glacier_tree_hash_checksum  s    c         K   s   t  |  d  d  S(   Nt   PredictEndpoint(   t   switch_host_with_param(   t   requestR   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   switch_host_machinelearning  s    c   	      C   s   t  j |  j j d   } | j |  r | | } t |  } |  j } t |  } | j | j | j	 | j
 d f } t |  } | |  _ n  d  S(   Ns   utf-8RR   (   R   R;   t   dataR5   Rw   R    R   t   schemet   netloct   patht   queryR   (	   R  t
   param_namet   request_jsont   new_endpointt   new_endpoint_componentst   original_endpointt   original_endpoint_componentst   final_endpoint_componentst   final_endpoint(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyR  "  s    
		c          K   sk   d d  l  } yG | j } | d d k  s8 | d d k  rR t j d | j t  n  Wn t k
 rf n Xd  S(   Nii    i   i   s   Currently installed openssl version: %s does not support TLS 1.2, which is required for use of iot-data. Please use python installed with openssl version 1.0.1 or higher.(   t   sslt   OPENSSL_VERSION_INFOt   warningst   warnt   OPENSSL_VERSIONR   R8   (   R   R  t   openssl_version_tuple(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt&   check_openssl_supports_tls_version_1_24  s    	 c         K   s\   |  j  d k rX d |  j k rX d |  j d <d |  _  |  j j d d  \ |  _ |  _ n  d  S(   NR   t   ?s!   application/x-www-form-urlencodeds   Content-TypeR   i   (   R   R   R@   R   R  (   R  R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   change_get_to_postF  s    	c         K   s'   d |  k r# t  | d <d |  d <n  d  S(   Nt   EncodingTypet   EncodingTypeAutoSetR   (   R,   (   RG   t   contextR   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt"   set_list_objects_encoding_type_urlO  s    
c   	      K   s   |  j  d  d k r | j  d  r d d d g } x1 | D]) } | |  k r: t |  |  |  | <q: q: Wd d g } xO | D]D \ } } | |  k rz x) |  | D] } t | |  | | <q Wqz qz Wn  d  S(   NR  R   R  t	   Delimitert   Markert
   NextMarkert   ContentsRl   t   CommonPrefixest   Prefix(   R#  s   Key(   R$  R%  (   Rw   R   (	   R   R  R   t   top_level_keysR   t   nested_keyst   top_keyt	   child_keyR   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   decode_list_objectW  s    	c         K   sy   d |  k ru t  |  d t j  rB t j t |  d   |  d <qu t  |  d t j  ru t j |  d  |  d <qu n  d  S(   Nt   Body(   RB   R   R   R   R   R   (   RG   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt    convert_body_to_file_like_objecto  s
     s$   before-parameter-build.s3.UploadParts#   before-parameter-build.s3.PutObjects   creating-client-classs   creating-client-class.s3s   creating-client-class.iot-datas   after-call.iams   after-call.ec2.GetConsoleOutputs%   after-call.cloudformation.GetTemplates   after-call.s3.GetBucketLocations   before-parameter-build.s3s%   before-parameter-build.s3.ListObjectss   before-call.s3.PutBucketTaggings!   before-call.s3.PutBucketLifecycles.   before-call.s3.PutBucketLifecycleConfigurations   before-call.s3.PutBucketCorss   before-call.s3.DeleteObjectss#   before-call.s3.PutBucketReplications   before-call.s3.PutObjects   before-call.s3.UploadParts   before-call.s3.PutBucketAcls   before-call.s3.PutBucketLoggings$   before-call.s3.PutBucketNotifications   before-call.s3.PutBucketPolicys&   before-call.s3.PutBucketRequestPayments"   before-call.s3.PutBucketVersionings   before-call.s3.PutBucketWebsites   before-call.s3.PutObjectAcls$   before-parameter-build.s3.CopyObjects(   before-parameter-build.s3.UploadPartCopys%   docs.*.s3.CopyObject.complete-sections)   docs.*.s3.UploadPartCopy.complete-sections   before-call.s3s   before-call.glaciers   before-call.apigateways!   before-call.glacier.UploadArchives'   before-call.glacier.UploadMultipartParts   before-call.ec2.CopySnapshots'   request-created.machinelearning.Predicts   needs-retry.s3.UploadPartCopys   needs-retry.s3.CopyObjects&   needs-retry.s3.CompleteMultipartUploads   service-data-loadeds$   choose-signer.cognito-identity.GetIds-   choose-signer.cognito-identity.GetOpenIdTokens-   choose-signer.cognito-identity.UnlinkIdentitys8   choose-signer.cognito-identity.GetCredentialsForIdentitys$   choose-signer.sts.AssumeRoleWithSAMLs+   choose-signer.sts.AssumeRoleWithWebIdentitys   before-sign.s3s$   before-parameter-build.s3.HeadObjects#   before-parameter-build.s3.GetObjects/   before-parameter-build.s3.CreateMultipartUploads'   before-parameter-build.ec2.RunInstancess<   before-parameter-build.autoscaling.CreateLaunchConfigurations   before-parameter-build.route53s   before-parameter-build.glaciers   after-call.s3.ListObjectss(   request-created.cloudsearchdomain.Searchs!   docs.*.glacier.*.complete-sectionR   sd   Note: this parameter is set to "-" by                          default if no value is not specified.s-   docs.*.glacier.UploadArchive.complete-sectionR   s3   docs.*.glacier.UploadMultipartPart.complete-sectionsD   docs.request-params.glacier.CompleteMultipartUpload.complete-sections(   docs.*.ec2.RunInstances.complete-sectionR   s=   docs.*.autoscaling.CreateLaunchConfiguration.complete-sections(   docs.*.ec2.CopySnapshot.complete-sectionR   R   s   docs.*.s3.*.complete-sectiont   SSECustomerKeyMD5t   CopySourceSSECustomerKeyMD5s1   docs.*.lambda.UpdateFunctionCode.complete-sectiont   ZipFilet   s3t
   ContentMD5t   DeleteObjectst   PutBucketAclt   PutBucketCorst   PutBucketLifecyclet   PutBucketLoggingt   PutBucketNotificationt   PutBucketPolicyt   PutBucketReplicationt   PutBucketRequestPaymentt   PutBucketTaggingt   PutBucketVersioningt   PutBucketWebsitet   PutObjectAcl(\   t   __doc__R2   t   loggingt   xml.etree.cElementTreeR#   R   t   reR  t   botocore.compatR    R   R   R   R   R   R   R   R   R	   t   botocore.docs.utilsR
   R   R   t   botocore.signersR   R   t   botocore.exceptionsR   R   t   botocore.utilsR   R   R   R   R   R   t   botocore.autht	   getLoggert   __name__R   t   objectt   REGISTER_FIRSTt   REGISTER_LASTt   compileRa   R   R   R   R:   R<   R>   RK   RD   RE   R^   Rf   Ri   Rk   Rh   Rn   R   R~   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R  R  R  R  R  R  R*  R,  t   fix_s3_hostt   document_auto_populated_paramt
   hide_paramt   BUILTIN_HANDLERS(    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/handlers.pyt   <module>   sX  F																
	
												&												 																																																																				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/botocore/hooks.py                                             0100644 0000000 0000062 00000050512 13077704371 021542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import copy
import logging
from collections import defaultdict, deque, namedtuple
from botocore.compat import accepts_kwargs, six

logger = logging.getLogger(__name__)


_NodeList = namedtuple('NodeList', ['first', 'middle', 'last'])
_FIRST = 0
_MIDDLE = 1
_LAST = 2

class NodeList(_NodeList):

    def __copy__(self):
        first_copy = copy.copy(self.first)
        middle_copy = copy.copy(self.middle)
        last_copy = copy.copy(self.last)
        copied = NodeList(first_copy, middle_copy, last_copy)
        return copied


def first_non_none_response(responses, default=None):
    """Find first non None response in a list of tuples.

    This function can be used to find the first non None response from
    handlers connected to an event.  This is useful if you are interested
    in the returned responses from event handlers. Example usage::

        print(first_non_none_response([(func1, None), (func2, 'foo'),
                                       (func3, 'bar')]))
        # This will print 'foo'

    :type responses: list of tuples
    :param responses: The responses from the ``EventHooks.emit`` method.
        This is a list of tuples, and each tuple is
        (handler, handler_response).

    :param default: If no non-None responses are found, then this default
        value will be returned.

    :return: The first non-None response in the list of tuples.

    """
    for response in responses:
        if response[1] is not None:
            return response[1]
    return default


class BaseEventHooks(object):
    def emit(self, event_name, **kwargs):
        """Call all handlers subscribed to an event.

        :type event_name: str
        :param event_name: The name of the event to emit.

        :type **kwargs: dict
        :param **kwargs: Arbitrary kwargs to pass through to the
            subscribed handlers.  The ``event_name`` will be injected
            into the kwargs so it's not necesary to add this to **kwargs.

        :rtype: list of tuples
        :return: A list of ``(handler_func, handler_func_return_value)``

        """
        return []

    def register(self, event_name, handler, unique_id=None,
                 unique_id_uses_count=False):
        """Register an event handler for a given event.

        If a ``unique_id`` is given, the handler will not be registered
        if a handler with the ``unique_id`` has already been registered.

        Handlers are called in the order they have been registered.
        Note handlers can also be registered with ``register_first()``
        and ``register_last()``.  All handlers registered with
        ``register_first()`` are called before handlers registered
        with ``register()`` which are called before handlers registered
        with ``register_last()``.

        """
        self._verify_and_register(event_name, handler, unique_id,
                                  register_method=self._register,
                                  unique_id_uses_count=unique_id_uses_count)

    def register_first(self, event_name, handler, unique_id=None,
                       unique_id_uses_count=False):
        """Register an event handler to be called first for an event.

        All event handlers registered with ``register_first()`` will
        be called before handlers registered with ``register()`` and
        ``register_last()``.

        """
        self._verify_and_register(event_name, handler, unique_id,
                                  register_method=self._register_first,
                                  unique_id_uses_count=unique_id_uses_count)

    def register_last(self, event_name, handler, unique_id=None,
                      unique_id_uses_count=False):
        """Register an event handler to be called last for an event.

        All event handlers registered with ``register_last()`` will be called
        after handlers registered with ``register_first()`` and ``register()``.

        """
        self._verify_and_register(event_name, handler, unique_id,
                                  register_method=self._register_last,
                                  unique_id_uses_count=unique_id_uses_count)

    def _verify_and_register(self, event_name, handler, unique_id,
                             register_method, unique_id_uses_count):
        self._verify_is_callable(handler)
        self._verify_accept_kwargs(handler)
        register_method(event_name, handler, unique_id, unique_id_uses_count)

    def unregister(self, event_name, handler=None, unique_id=None,
                   unique_id_uses_count=False):
        """Unregister an event handler for a given event.

        If no ``unique_id`` was given during registration, then the
        first instance of the event handler is removed (if the event
        handler has been registered multiple times).

        """
        pass

    def _verify_is_callable(self, func):
        if not six.callable(func):
            raise ValueError("Event handler %s must be callable." % func)

    def _verify_accept_kwargs(self, func):
        """Verifies a callable accepts kwargs

        :type func: callable
        :param func: A callable object.

        :returns: True, if ``func`` accepts kwargs, otherwise False.

        """
        try:
            if not accepts_kwargs(func):
                raise ValueError("Event handler %s must accept keyword "
                                 "arguments (**kwargs)" % func)
        except TypeError:
            return False


class HierarchicalEmitter(BaseEventHooks):
    def __init__(self):
        # We keep a reference to the handlers for quick
        # read only access (we never modify self._handlers).
        # A cache of event name to handler list.
        self._lookup_cache = {}
        self._handlers = _PrefixTrie()
        # This is used to ensure that unique_id's are only
        # registered once.
        self._unique_id_handlers = {}

    def _emit(self, event_name, kwargs, stop_on_response=False):
        """
        Emit an event with optional keyword arguments.

        :type event_name: string
        :param event_name: Name of the event
        :type kwargs: dict
        :param kwargs: Arguments to be passed to the handler functions.
        :type stop_on_response: boolean
        :param stop_on_response: Whether to stop on the first non-None
                                response. If False, then all handlers
                                will be called. This is especially useful
                                to handlers which mutate data and then
                                want to stop propagation of the event.
        :rtype: list
        :return: List of (handler, response) tuples from all processed
                 handlers.
        """
        responses = []
        # Invoke the event handlers from most specific
        # to least specific, each time stripping off a dot.
        handlers_to_call = self._lookup_cache.get(event_name)
        if handlers_to_call is None:
            handlers_to_call = self._handlers.prefix_search(event_name)
            self._lookup_cache[event_name] = handlers_to_call
        elif not handlers_to_call:
            # Short circuit and return an empty response is we have
            # no handlers to call.  This is the common case where
            # for the majority of signals, nothing is listening.
            return []
        kwargs['event_name'] = event_name
        responses = []
        for handler in handlers_to_call:
            logger.debug('Event %s: calling handler %s', event_name, handler)
            response = handler(**kwargs)
            responses.append((handler, response))
            if stop_on_response and response is not None:
                return responses
        return responses

    def emit(self, event_name, **kwargs):
        """
        Emit an event by name with arguments passed as keyword args.

            >>> responses = emitter.emit(
            ...     'my-event.service.operation', arg1='one', arg2='two')

        :rtype: list
        :return: List of (handler, response) tuples from all processed
                 handlers.
        """
        return self._emit(event_name, kwargs)

    def emit_until_response(self, event_name, **kwargs):
        """
        Emit an event by name with arguments passed as keyword args,
        until the first non-``None`` response is received. This
        method prevents subsequent handlers from being invoked.

            >>> handler, response = emitter.emit_until_response(
                'my-event.service.operation', arg1='one', arg2='two')

        :rtype: tuple
        :return: The first (handler, response) tuple where the response
                 is not ``None``, otherwise (``None``, ``None``).
        """
        responses = self._emit(event_name, kwargs, stop_on_response=True)
        if responses:
            return responses[-1]
        else:
            return (None, None)

    def _register(self, event_name, handler, unique_id=None,
                  unique_id_uses_count=False):
        self._register_section(event_name, handler, unique_id,
                               unique_id_uses_count, section=_MIDDLE)

    def _register_first(self, event_name, handler, unique_id=None,
                        unique_id_uses_count=False):
        self._register_section(event_name, handler, unique_id,
                               unique_id_uses_count, section=_FIRST)

    def _register_last(self, event_name, handler, unique_id,
                       unique_id_uses_count=False):
        self._register_section(event_name, handler, unique_id,
                               unique_id_uses_count, section=_LAST)


    def _register_section(self, event_name, handler, unique_id,
                          unique_id_uses_count, section):
        if unique_id is not None:
            if unique_id in self._unique_id_handlers:
                # We've already registered a handler using this unique_id
                # so we don't need to register it again.
                count = self._unique_id_handlers[unique_id].get('count', None)
                if unique_id_uses_count:
                    if not count:
                        raise ValueError("Initial registration of"
                            " unique id %s was specified to use a counter."
                            " Subsequent register calls to unique id must"
                            " specify use of a counter as well." % unique_id)
                    else:
                        self._unique_id_handlers[unique_id]['count'] += 1
                else:
                    if count:
                        raise ValueError("Initial registration of"
                            " unique id %s was specified to not use a counter."
                            " Subsequent register calls to unique id must"
                            " specify not to use a counter as well." %
                            unique_id)
                return
            else:
                # Note that the trie knows nothing about the unique
                # id.  We track uniqueness in this class via the
                # _unique_id_handlers.
                self._handlers.append_item(event_name, handler,
                                           section=section)
                unique_id_handler_item = {'handler': handler}
                if unique_id_uses_count:
                    unique_id_handler_item['count'] = 1
                self._unique_id_handlers[unique_id] = unique_id_handler_item
        else:
            self._handlers.append_item(event_name, handler, section=section)
        # Super simple caching strategy for now, if we change the registrations
        # clear the cache.  This has the opportunity for smarter invalidations.
        self._lookup_cache = {}

    def unregister(self, event_name, handler=None, unique_id=None,
                   unique_id_uses_count=False):
        if unique_id is not None:
            try:
                count = self._unique_id_handlers[unique_id].get('count', None)
            except KeyError:
                # There's no handler matching that unique_id so we have
                # nothing to unregister.
                return
            if unique_id_uses_count:
                if count == None:
                    raise ValueError("Initial registration of"
                        " unique id %s was specified to use a counter."
                        " Subsequent unregister calls to unique id must"
                        " specify use of a counter as well." % unique_id)
                elif count == 1:
                    handler = self._unique_id_handlers.pop(unique_id)['handler']
                else:
                    self._unique_id_handlers[unique_id]['count'] -= 1
                    return
            else:
                if count:
                    raise ValueError("Initial registration of"
                        " unique id %s was specified to not use a counter."
                        " Subsequent unregister calls to unique id must"
                        " specify not to use a counter as well." % 
                        unique_id)
                handler = self._unique_id_handlers.pop(unique_id)['handler']
        try:
            self._handlers.remove_item(event_name, handler)
            self._lookup_cache = {}
        except ValueError:
            pass

    def __copy__(self):
        new_instance = self.__class__()
        new_state = self.__dict__.copy()
        new_state['_handlers'] = copy.copy(self._handlers)
        new_state['_unique_id_handlers'] = copy.copy(self._unique_id_handlers)
        new_instance.__dict__ = new_state
        return new_instance


class _PrefixTrie(object):
    """Specialized prefix trie that handles wildcards.

    The prefixes in this case are based on dot separated
    names so 'foo.bar.baz' is::

        foo -> bar -> baz

    Wildcard support just means that having a key such as 'foo.bar.*.baz' will
    be matched with a call to ``get_items(key='foo.bar.ANYTHING.baz')``.

    You can think of this prefix trie as the equivalent as defaultdict(list),
    except that it can do prefix searches:

        foo.bar.baz -> A
        foo.bar -> B
        foo -> C

    Calling ``get_items('foo.bar.baz')`` will return [A + B + C], from
    most specific to least specific.

    """
    def __init__(self):
        # Each dictionary can be though of as a node, where a node
        # has values associated with the node, and children is a link
        # to more nodes.  So 'foo.bar' would have a 'foo' node with
        # a 'bar' node as a child of foo.
        # {'foo': {'children': {'bar': {...}}}}.
        self._root = {'chunk': None, 'children': {}, 'values': None}

    def append_item(self, key, value, section=_MIDDLE):
        """Add an item to a key.

        If a value is already associated with that key, the new
        value is appended to the list for the key.
        """
        key_parts = key.split('.')
        current = self._root
        for part in key_parts:
            if part not in current['children']:
                new_child = {'chunk': part, 'values': None, 'children': {}}
                current['children'][part] = new_child
                current = new_child
            else:
                current = current['children'][part]
        if current['values'] is None:
            current['values'] = NodeList([], [], [])
        current['values'][section].append(value)

    def prefix_search(self, key):
        """Collect all items that are prefixes of key.

        Prefix in this case are delineated by '.' characters so
        'foo.bar.baz' is a 3 chunk sequence of 3 "prefixes" (
        "foo", "bar", and "baz").

        """
        collected = deque()
        key_parts = key.split('.')
        current = self._root
        self._get_items(current, key_parts, collected, 0)
        return collected

    def _get_items(self, starting_node, key_parts, collected, starting_index):
        stack = [(starting_node, starting_index)]
        key_parts_len = len(key_parts)
        # Traverse down the nodes, where at each level we add the
        # next part from key_parts as well as the wildcard element '*'.
        # This means for each node we see we potentially add two more
        # elements to our stack.
        while stack:
            current_node, index = stack.pop()
            if current_node['values']:
                # We're using extendleft because we want
                # the values associated with the node furthest
                # from the root to come before nodes closer
                # to the root.  extendleft() also adds its items
                # in right-left order so .extendleft([1, 2, 3])
                # will result in final_list = [3, 2, 1], which is
                # why we reverse the lists.
                node_list = current_node['values']
                complete_order = (node_list.first + node_list.middle +
                                  node_list.last)
                collected.extendleft(reversed(complete_order))
            if not index == key_parts_len:
                children = current_node['children']
                directs = children.get(key_parts[index])
                wildcard = children.get('*')
                next_index = index + 1
                if wildcard is not None:
                    stack.append((wildcard, next_index))
                if directs is not None:
                    stack.append((directs, next_index))

    def remove_item(self, key, value):
        """Remove an item associated with a key.

        If the value is not associated with the key a ``ValueError``
        will be raised.  If the key does not exist in the trie, a
        ``ValueError`` will be raised.

        """
        key_parts = key.split('.')
        current = self._root
        self._remove_item(current, key_parts, value, index=0)

    def _remove_item(self, current_node, key_parts, value, index):
        if current_node is None:
            return
        elif index < len(key_parts):
            next_node = current_node['children'].get(key_parts[index])
            if next_node is not None:
                self._remove_item(next_node, key_parts, value, index + 1)
                if index == len(key_parts) - 1:
                    node_list = next_node['values']
                    if value in node_list.first:
                        node_list.first.remove(value)
                    elif value in node_list.middle:
                        node_list.middle.remove(value)
                    elif value in node_list.last:
                        node_list.last.remove(value)
                if not next_node['children'] and not next_node['values']:
                    # Then this is a leaf node with no values so
                    # we can just delete this link from the parent node.
                    # This makes subsequent search faster in the case
                    # where a key does not exist.
                    del current_node['children'][key_parts[index]]
            else:
                raise ValueError(
                    "key is not in trie: %s" % '.'.join(key_parts))

    def __copy__(self):
        # The fact that we're using a nested dict under the covers
        # is an implementation detail, and the user shouldn't have
        # to know that they'd normally need a deepcopy so we expose
        # __copy__ instead of __deepcopy__.
        new_copy = self.__class__()
        copied_attrs = self._recursive_copy(self.__dict__)
        new_copy.__dict__ = copied_attrs
        return new_copy

    def _recursive_copy(self, node):
        # We can't use copy.deepcopy because we actually only want to copy
        # the structure of the trie, not the handlers themselves.
        # Each node has a chunk, children, and values.
        copied_node = {}
        for key, value in node.items():
            if isinstance(value, NodeList):
                copied_node[key] = copy.copy(value)
            elif isinstance(value, dict):
                copied_node[key] = self._recursive_copy(value)
            else:
                copied_node[key] = value
        return copied_node
                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/botocore/hooks.pyc                                            0100644 0000000 0000062 00000040417 13077704401 021702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  d l  Z  d  d l Z d  d l m Z m Z m Z d  d l m Z m Z e j	 e
  Z e d d d d g  Z d Z d	 Z d
 Z d e f d     YZ d d  Z d e f d     YZ d e f d     YZ d e f d     YZ d S(   iN(   t   defaultdictt   dequet
   namedtuple(   t   accepts_kwargst   sixt   NodeListt   firstt   middlet   lasti    i   i   c           B   s   e  Z d    Z RS(   c         C   sL   t  j  |  j  } t  j  |  j  } t  j  |  j  } t | | |  } | S(   N(   t   copyR   R   R   R   (   t   selft
   first_copyt   middle_copyt	   last_copyt   copied(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   __copy__   s
    (   t   __name__t
   __module__R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR      s   c         C   s-   x& |  D] } | d d k	 r | d Sq W| S(   s  Find first non None response in a list of tuples.

    This function can be used to find the first non None response from
    handlers connected to an event.  This is useful if you are interested
    in the returned responses from event handlers. Example usage::

        print(first_non_none_response([(func1, None), (func2, 'foo'),
                                       (func3, 'bar')]))
        # This will print 'foo'

    :type responses: list of tuples
    :param responses: The responses from the ``EventHooks.emit`` method.
        This is a list of tuples, and each tuple is
        (handler, handler_response).

    :param default: If no non-None responses are found, then this default
        value will be returned.

    :return: The first non-None response in the list of tuples.

    i   N(   t   None(   t	   responsest   defaultt   response(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   first_non_none_response$   s    t   BaseEventHooksc           B   sk   e  Z d    Z d e d  Z d e d  Z d e d  Z d   Z d d e d  Z	 d   Z
 d   Z RS(	   c         K   s   g  S(   s  Call all handlers subscribed to an event.

        :type event_name: str
        :param event_name: The name of the event to emit.

        :type **kwargs: dict
        :param **kwargs: Arbitrary kwargs to pass through to the
            subscribed handlers.  The ``event_name`` will be injected
            into the kwargs so it's not necesary to add this to **kwargs.

        :rtype: list of tuples
        :return: A list of ``(handler_func, handler_func_return_value)``

        (    (   R
   t
   event_namet   kwargs(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   emitA   s    c         C   s&   |  j  | | | d |  j d | d S(   s@  Register an event handler for a given event.

        If a ``unique_id`` is given, the handler will not be registered
        if a handler with the ``unique_id`` has already been registered.

        Handlers are called in the order they have been registered.
        Note handlers can also be registered with ``register_first()``
        and ``register_last()``.  All handlers registered with
        ``register_first()`` are called before handlers registered
        with ``register()`` which are called before handlers registered
        with ``register_last()``.

        t   register_methodt   unique_id_uses_countN(   t   _verify_and_registert	   _register(   R
   R   t   handlert	   unique_idR   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   registerR   s    	c         C   s&   |  j  | | | d |  j d | d S(   s   Register an event handler to be called first for an event.

        All event handlers registered with ``register_first()`` will
        be called before handlers registered with ``register()`` and
        ``register_last()``.

        R   R   N(   R   t   _register_first(   R
   R   R   R    R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   register_firste   s    		c         C   s&   |  j  | | | d |  j d | d S(   s   Register an event handler to be called last for an event.

        All event handlers registered with ``register_last()`` will be called
        after handlers registered with ``register_first()`` and ``register()``.

        R   R   N(   R   t   _register_last(   R
   R   R   R    R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   register_lastr   s    	c         C   s1   |  j  |  |  j |  | | | | |  d  S(   N(   t   _verify_is_callablet   _verify_accept_kwargs(   R
   R   R   R    R   R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR   ~   s    c         C   s   d S(   s   Unregister an event handler for a given event.

        If no ``unique_id`` was given during registration, then the
        first instance of the event handler is removed (if the event
        handler has been registered multiple times).

        N(    (   R
   R   R   R    R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt
   unregister   s    	c         C   s&   t  j |  s" t d |   n  d  S(   Ns"   Event handler %s must be callable.(   R   t   callablet
   ValueError(   R
   t   func(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR&      s    c         C   s<   y# t  |  s" t d |   n  Wn t k
 r7 t SXd S(   s   Verifies a callable accepts kwargs

        :type func: callable
        :param func: A callable object.

        :returns: True, if ``func`` accepts kwargs, otherwise False.

        s9   Event handler %s must accept keyword arguments (**kwargs)N(   R   R*   t	   TypeErrort   False(   R
   R+   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR'      s    	N(   R   R   R   R   R-   R!   R#   R%   R   R(   R&   R'   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR   @   s   		
	t   HierarchicalEmitterc           B   s}   e  Z d    Z e d  Z d   Z d   Z d
 e d  Z d
 e d  Z	 e d  Z
 d   Z d
 d
 e d  Z d	   Z RS(   c         C   s"   i  |  _  t   |  _ i  |  _ d  S(   N(   t   _lookup_cachet   _PrefixTriet	   _handlerst   _unique_id_handlers(   R
   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   __init__   s    	c         C   s   g  } |  j  j |  } | d k rF |  j j |  } | |  j  | <n
 | sP g  S| | d <g  } xV | D]N } t j d | |  | |   } | j | | f  | rg | d k	 rg | Sqg W| S(   s  
        Emit an event with optional keyword arguments.

        :type event_name: string
        :param event_name: Name of the event
        :type kwargs: dict
        :param kwargs: Arguments to be passed to the handler functions.
        :type stop_on_response: boolean
        :param stop_on_response: Whether to stop on the first non-None
                                response. If False, then all handlers
                                will be called. This is especially useful
                                to handlers which mutate data and then
                                want to stop propagation of the event.
        :rtype: list
        :return: List of (handler, response) tuples from all processed
                 handlers.
        R   s   Event %s: calling handler %sN(   R/   t   getR   R1   t   prefix_searcht   loggert   debugt   append(   R
   R   R   t   stop_on_responseR   t   handlers_to_callR   R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   _emit   s     
c         K   s   |  j  | |  S(   s;  
        Emit an event by name with arguments passed as keyword args.

            >>> responses = emitter.emit(
            ...     'my-event.service.operation', arg1='one', arg2='two')

        :rtype: list
        :return: List of (handler, response) tuples from all processed
                 handlers.
        (   R;   (   R
   R   R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR      s    c         K   s.   |  j  | | d t } | r& | d Sd Sd S(   s  
        Emit an event by name with arguments passed as keyword args,
        until the first non-``None`` response is received. This
        method prevents subsequent handlers from being invoked.

            >>> handler, response = emitter.emit_until_response(
                'my-event.service.operation', arg1='one', arg2='two')

        :rtype: tuple
        :return: The first (handler, response) tuple where the response
                 is not ``None``, otherwise (``None``, ``None``).
        R9   iN(   NN(   R;   t   TrueR   (   R
   R   R   R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   emit_until_response   s    c         C   s    |  j  | | | | d t d  S(   Nt   section(   t   _register_sectiont   _MIDDLE(   R
   R   R   R    R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR      s    c         C   s    |  j  | | | | d t d  S(   NR>   (   R?   t   _FIRST(   R
   R   R   R    R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR"      s    c         C   s    |  j  | | | | d t d  S(   NR>   (   R?   t   _LAST(   R
   R   R   R    R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR$     s    c         C   s   | d  k	 r | |  j k r |  j | j d d   } | rm | sS t d |   q |  j | d c d 7<n | r t d |   n  d  S|  j j | | d | i | d 6} | r d | d <n  | |  j | <n |  j j | | d | i  |  _ d  S(   Nt   counts   Initial registration of unique id %s was specified to use a counter. Subsequent register calls to unique id must specify use of a counter as well.i   s   Initial registration of unique id %s was specified to not use a counter. Subsequent register calls to unique id must specify not to use a counter as well.R>   R   (   R   R2   R4   R*   R1   t   append_itemR/   (   R
   R   R   R    R   R>   RC   t   unique_id_handler_item(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR?     s(    c         C   s  | d  k	 r y |  j | j d d   } Wn t k
 r= d  SX| r | d  k rc t d |   q | d k r |  j j |  d } q |  j | d c d 8<d  Sq | r t d |   n  |  j j |  d } n  y  |  j j | |  i  |  _ Wn t k
 rn Xd  S(   NRC   s   Initial registration of unique id %s was specified to use a counter. Subsequent unregister calls to unique id must specify use of a counter as well.i   R   s   Initial registration of unique id %s was specified to not use a counter. Subsequent unregister calls to unique id must specify not to use a counter as well.(	   R   R2   R4   t   KeyErrorR*   t   popR1   t   remove_itemR/   (   R
   R   R   R    R   RC   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR(   .  s,    c         C   sT   |  j    } |  j j   } t j |  j  | d <t j |  j  | d <| | _ | S(   NR1   R2   (   t	   __class__t   __dict__R	   R1   R2   (   R
   t   new_instancet	   new_state(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR   P  s    	N(   R   R   R3   R-   R;   R   R=   R   R   R"   R$   R?   R(   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR.      s   	
(			'!R0   c           B   sY   e  Z d  Z d   Z e d  Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z RS(	   sj  Specialized prefix trie that handles wildcards.

    The prefixes in this case are based on dot separated
    names so 'foo.bar.baz' is::

        foo -> bar -> baz

    Wildcard support just means that having a key such as 'foo.bar.*.baz' will
    be matched with a call to ``get_items(key='foo.bar.ANYTHING.baz')``.

    You can think of this prefix trie as the equivalent as defaultdict(list),
    except that it can do prefix searches:

        foo.bar.baz -> A
        foo.bar -> B
        foo -> C

    Calling ``get_items('foo.bar.baz')`` will return [A + B + C], from
    most specific to least specific.

    c         C   s"   i d  d 6i  d 6d  d 6|  _ d  S(   Nt   chunkt   childrent   values(   R   t   _root(   R
   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR3   o  s    c         C   s   | j  d  } |  j } x^ | D]V } | | d k rg i | d 6d d 6i  d 6} | | d | <| } q | d | } q W| d d k r t g  g  g   | d <n  | d | j |  d S(   s   Add an item to a key.

        If a value is already associated with that key, the new
        value is appended to the list for the key.
        t   .RN   RM   RO   N(   t   splitRP   R   R   R8   (   R
   t   keyt   valueR>   t	   key_partst   currentt   partt	   new_child(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyRD   w  s    		c         C   s;   t    } | j d  } |  j } |  j | | | d  | S(   s   Collect all items that are prefixes of key.

        Prefix in this case are delineated by '.' characters so
        'foo.bar.baz' is a 3 chunk sequence of 3 "prefixes" (
        "foo", "bar", and "baz").

        RQ   i    (   R   RR   RP   t
   _get_items(   R
   RS   t	   collectedRU   RV   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR5     s
    		c         C   s  | | f g } t  |  } x | r| j   \ } } | d rw | d }	 |	 j |	 j |	 j }
 | j t |
   n  | | k s | d } | j | |  } | j d  } | d } | d  k	 r | j	 | | f  n  | d  k	 r | j	 | | f  q q q Wd  S(   NRO   RN   t   *i   (
   t   lenRG   R   R   R   t
   extendleftt   reversedR4   R   R8   (   R
   t   starting_nodeRU   RZ   t   starting_indext   stackt   key_parts_lent   current_nodet   indext	   node_listt   complete_orderRN   t   directst   wildcardt
   next_index(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyRY     s$    	




c         C   s5   | j  d  } |  j } |  j | | | d d d S(   s   Remove an item associated with a key.

        If the value is not associated with the key a ``ValueError``
        will be raised.  If the key does not exist in the trie, a
        ``ValueError`` will be raised.

        RQ   Rd   i    N(   RR   RP   t   _remove_item(   R
   RS   RT   RU   RV   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyRH     s    	c         C   s3  | d  k r d  S| t |  k  r/| d j | |  } | d  k	 r|  j | | | | d  | t |  d k r | d } | | j k r | j j |  q | | j k r | j j |  q | | j k r | j j |  q n  | d r,| d r,| d | | =q,q/t d d j	 |    n  d  S(   NRN   i   RO   s   key is not in trie: %sRQ   (
   R   R\   R4   Rj   R   t   removeR   R   R*   t   join(   R
   Rc   RU   RT   Rd   t	   next_nodeRe   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyRj     s$    
c         C   s+   |  j    } |  j |  j  } | | _ | S(   N(   RI   t   _recursive_copyRJ   (   R
   t   new_copyt   copied_attrs(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR     s    	c         C   s{   i  } xn | j    D]` \ } } t | t  rD t j |  | | <q t | t  ri |  j |  | | <q | | | <q W| S(   N(   t   itemst
   isinstanceR   R	   t   dictRn   (   R
   t   nodet   copied_nodeRS   RT   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyRn     s    (   R   R   t   __doc__R3   R@   RD   R5   RY   RH   Rj   R   Rn   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyR0   Y  s   						
(   R	   t   loggingt   collectionsR    R   R   t   botocore.compatR   R   t	   getLoggerR   R6   t	   _NodeListRA   R@   RB   R   R   R   t   objectR   R.   R0   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/hooks.pyt   <module>   s   
d                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/loaders.py                                           0100644 0000000 0000062 00000034703 13077704371 022054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
"""Module for loading various model files.

This module provides the classes that are used to load models used
by botocore.  This can include:

    * Service models (e.g. the model for EC2, S3, DynamoDB, etc.)
    * Other models associated with a service (pagination, waiters)
    * Non service-specific config (Endpoint data, retry config)

Loading a module is broken down into several steps:

    * Determining the path to load
    * Search the data_path for files to load
    * The mechanics of loading the file

The last item is used so that other faster loading mechanism
besides the default JSON loader can be used.

The Search Path
===============

Similar to how the PATH environment variable is to finding executables
and the PYTHONPATH environment variable is to finding python modules
to import, the botocore loaders have the concept of a data path exposed
through AWS_DATA_PATH.

This enables end users to provide additional search paths where we
will attempt to load models outside of the models we ship with
botocore.  When you create a ``Loader``, there are two paths
automatically added to the model search path:

    * <botocore root>/data/
    * ~/.aws/models

The first value is the path where all the model files shipped with
botocore are located.

The second path is so that users can just drop new model files in
``~/.aws/models`` without having to mess around with the AWS_DATA_PATH.

The AWS_DATA_PATH using the platform specific path separator to
separate entries (typically ``:`` on linux and ``;`` on windows).


Directory Layout
================

The Loader expects a particular directory layout.  In order for any
directory specified in AWS_DATA_PATH to be considered, it must have
this structure for service models::

    <root>
      |
      |-- servicename1
      |   |-- 2012-10-25
      |       |-- service-2.json
      |-- ec2
      |   |-- 2014-01-01
      |   |   |-- paginators-1.json
      |   |   |-- service-2.json
      |   |   |-- waiters-2.json
      |   |-- 2015-03-01
      |       |-- paginators-1.json
      |       |-- service-2.json
      |       |-- waiters-2.json


That is:

    * The root directory contains sub directories that are the name
      of the services.
    * Within each service directory, there's a sub directory for each
      available API version.
    * Within each API version, there are model specific files, including
      (but not limited to): service-2.json, waiters-2.json, paginators-1.json

The ``-1`` and ``-2`` suffix at the end of the model files denote which version
schema is used within the model.  Even though this information is available in
the ``version`` key within the model, this version is also part of the filename
so that code does not need to load the JSON model in order to determine which
version to use.

"""
import os

from botocore import BOTOCORE_ROOT
from botocore.compat import json
from botocore.compat import OrderedDict
from botocore.exceptions import DataNotFoundError, UnknownServiceError


def instance_cache(func):
    """Cache the result of a method on a per instance basis.

    This is not a general purpose caching decorator.  In order
    for this to be used, it must be used on methods on an
    instance, and that instance *must* provide a
    ``self._cache`` dictionary.

    """
    def _wrapper(self, *args, **kwargs):
        key = (func.__name__,) + args
        for pair in sorted(kwargs.items()):
            key += pair
        if key in self._cache:
            return self._cache[key]
        data = func(self, *args, **kwargs)
        self._cache[key] = data
        return data
    return _wrapper


class JSONFileLoader(object):
    """Loader JSON files.

    This class can load the default format of models, which is a JSON file.

    """
    def exists(self, file_path):
        """Checks if the file exists.

        :type file_path: str
        :param file_path: The full path to the file to load without
            the '.json' extension.

        :return: True if file path exists, False otherwise.

        """
        return os.path.isfile(file_path + '.json')

    def load_file(self, file_path):
        """Attempt to load the file path.

        :type file_path: str
        :param file_path: The full path to the file to load without
            the '.json' extension.

        :return: The loaded data if it exists, otherwise None.

        """
        full_path = file_path + '.json'
        if not os.path.isfile(full_path):
            return

        # By default the file will be opened with locale encoding on Python 3.
        # We specify "utf8" here to ensure the correct behavior.
        with open(full_path, 'rb') as fp:
            payload = fp.read().decode('utf-8')
            return json.loads(payload, object_pairs_hook=OrderedDict)


def create_loader(search_path_string=None):
    """Create a Loader class.

    This factory function creates a loader given a search string path.

    :type search_string_path: str
    :param search_string_path: The AWS_DATA_PATH value.  A string
        of data path values separated by the ``os.path.pathsep`` value,
        which is typically ``:`` on POSIX platforms and ``;`` on
        windows.

    :return: A ``Loader`` instance.

    """
    if search_path_string is None:
        return Loader()
    paths = []
    extra_paths = search_path_string.split(os.pathsep)
    for path in extra_paths:
        path = os.path.expanduser(os.path.expandvars(path))
        paths.append(path)
    return Loader(extra_search_paths=paths)


class Loader(object):
    """Find and load data models.

    This class will handle searching for and loading data models.

    The main method used here is ``load_service_model``, which is a
    convenience method over ``load_data`` and ``determine_latest_version``.

    """
    FILE_LOADER_CLASS = JSONFileLoader
    # The included models in botocore/data/ that we ship with botocore.
    BUILTIN_DATA_PATH = os.path.join(BOTOCORE_ROOT, 'data')
    # For convenience we automatically add ~/.aws/models to the data path.
    CUSTOMER_DATA_PATH = os.path.join(os.path.expanduser('~'),
                                      '.aws', 'models')

    def __init__(self, extra_search_paths=None, file_loader=None,
                 cache=None, include_default_search_paths=True):
        self._cache = {}
        if file_loader is None:
            file_loader = self.FILE_LOADER_CLASS()
        self.file_loader = file_loader
        if extra_search_paths is not None:
            self._search_paths = extra_search_paths
        else:
            self._search_paths = []
        if include_default_search_paths:
            self._search_paths.extend([self.CUSTOMER_DATA_PATH,
                                       self.BUILTIN_DATA_PATH])

    @property
    def search_paths(self):
        return self._search_paths

    @instance_cache
    def list_available_services(self, type_name):
        """List all known services.

        This will traverse the search path and look for all known
        services.

        :type type_name: str
        :param type_name: The type of the service (service-2,
            paginators-1, waiters-2, etc).  This is needed because
            the list of available services depends on the service
            type.  For example, the latest API version available for
            a resource-1.json file may not be the latest API version
            available for a services-2.json file.

        :return: A list of all services.  The list of services will
            be sorted.

        """
        services = set()
        for possible_path in self._potential_locations():
            # Any directory in the search path is potentially a service.
            # We'll collect any initial list of potential services,
            # but we'll then need to further process these directories
            # by searching for the corresponding type_name in each
            # potential directory.
            possible_services = [
                d for d in os.listdir(possible_path)
                if os.path.isdir(os.path.join(possible_path, d))]
            for service_name in possible_services:
                full_dirname = os.path.join(possible_path, service_name)
                api_versions = os.listdir(full_dirname)
                for api_version in api_versions:
                    full_load_path = os.path.join(full_dirname,
                                                  api_version,
                                                  type_name)
                    if self.file_loader.exists(full_load_path):
                        services.add(service_name)
                        break
        return sorted(services)

    @instance_cache
    def determine_latest_version(self, service_name, type_name):
        """Find the latest API version available for a service.

        :type service_name: str
        :param service_name: The name of the service.

        :type type_name: str
        :param type_name: The type of the service (service-2,
            paginators-1, waiters-2, etc).  This is needed because
            the latest API version available can depend on the service
            type.  For example, the latest API version available for
            a resource-1.json file may not be the latest API version
            available for a services-2.json file.

        :rtype: str
        :return: The latest API version.  If the service does not exist
            or does not have any available API data, then a
            ``DataNotFoundError`` exception will be raised.

        """
        return max(self.list_api_versions(service_name, type_name))

    @instance_cache
    def list_api_versions(self, service_name, type_name):
        """List all API versions available for a particular service type

        :type service_name: str
        :param service_name: The name of the service

        :type type_name: str
        :param type_name: The type name for the service (i.e service-2,
            paginators-1, etc.)

        :rtype: list
        :return: A list of API version strings in sorted order.

        """
        known_api_versions = set()
        for possible_path in self._potential_locations(service_name,
                                                       must_exist=True,
                                                       is_dir=True):
            for dirname in os.listdir(possible_path):
                full_path = os.path.join(possible_path, dirname, type_name)
                # Only add to the known_api_versions if the directory
                # contains a service-2, paginators-1, etc. file corresponding
                # to the type_name passed in.
                if self.file_loader.exists(full_path):
                    known_api_versions.add(dirname)
        if not known_api_versions:
            raise DataNotFoundError(data_path=service_name)
        return sorted(known_api_versions)

    @instance_cache
    def load_service_model(self, service_name, type_name, api_version=None):
        """Load a botocore service model

        This is the main method for loading botocore models (e.g. a service
        model, pagination configs, waiter configs, etc.).

        :type service_name: str
        :param service_name: The name of the service (e.g ``ec2``, ``s3``).

        :type type_name: str
        :param type_name: The model type.  Valid types include, but are not
            limited to: ``service-2``, ``paginators-1``, ``waiters-2``.

        :type api_version: str
        :param api_version: The API version to load.  If this is not
            provided, then the latest API version will be used.

        :raises: UnknownServiceError if there is no known service with
            the provided service_name.

        :raises: DataNotFoundError if no data could be found for the
            service_name/type_name/api_version.

        :return: The loaded data, as a python type (e.g. dict, list, etc).
        """
        # Wrapper around the load_data.  This will calculate the path
        # to call load_data with.
        known_services = self.list_available_services(type_name)
        if service_name not in known_services:
            raise UnknownServiceError(
                service_name=service_name,
                known_service_names=', '.join(sorted(known_services)))
        if api_version is None:
            api_version = self.determine_latest_version(
                service_name, type_name)
        full_path = os.path.join(service_name, api_version, type_name)
        return self.load_data(full_path)

    @instance_cache
    def load_data(self, name):
        """Load data given a data path.

        This is a low level method that will search through the various
        search paths until it's able to load a value.  This is typically
        only needed to load *non* model files (such as _endpoints and
        _retry).  If you need to load model files, you should prefer
        ``load_service_model``.

        :type name: str
        :param name: The data path, i.e ``ec2/2015-03-01/service-2``.

        :return: The loaded data.  If no data could be found then
            a DataNotFoundError is raised.

        """
        for possible_path in self._potential_locations(name):
            found = self.file_loader.load_file(possible_path)
            if found is not None:
                return found
        # We didn't find anything that matched on any path.
        raise DataNotFoundError(data_path=name)

    def _potential_locations(self, name=None, must_exist=False,
                             is_dir=False):
        # Will give an iterator over the full path of potential locations
        # according to the search path.
        for path in self.search_paths:
            if os.path.isdir(path):
                full_path = path
                if name is not None:
                    full_path = os.path.join(path, name)
                if not must_exist:
                    yield full_path
                else:
                    if is_dir and os.path.isdir(full_path):
                        yield full_path
                    elif os.path.exists(full_path):
                        yield full_path
                                                             usr/local/lib/python2.7/dist-packages/botocore/loaders.pyc                                          0100644 0000000 0000062 00000032204 13077704401 022203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  Z  d d l Z d d l m Z d d l m Z d d l m Z d d l m Z m	 Z	 d   Z
 d e f d	     YZ d d
  Z d e f d     YZ d S(   s
  Module for loading various model files.

This module provides the classes that are used to load models used
by botocore.  This can include:

    * Service models (e.g. the model for EC2, S3, DynamoDB, etc.)
    * Other models associated with a service (pagination, waiters)
    * Non service-specific config (Endpoint data, retry config)

Loading a module is broken down into several steps:

    * Determining the path to load
    * Search the data_path for files to load
    * The mechanics of loading the file

The last item is used so that other faster loading mechanism
besides the default JSON loader can be used.

The Search Path
===============

Similar to how the PATH environment variable is to finding executables
and the PYTHONPATH environment variable is to finding python modules
to import, the botocore loaders have the concept of a data path exposed
through AWS_DATA_PATH.

This enables end users to provide additional search paths where we
will attempt to load models outside of the models we ship with
botocore.  When you create a ``Loader``, there are two paths
automatically added to the model search path:

    * <botocore root>/data/
    * ~/.aws/models

The first value is the path where all the model files shipped with
botocore are located.

The second path is so that users can just drop new model files in
``~/.aws/models`` without having to mess around with the AWS_DATA_PATH.

The AWS_DATA_PATH using the platform specific path separator to
separate entries (typically ``:`` on linux and ``;`` on windows).


Directory Layout
================

The Loader expects a particular directory layout.  In order for any
directory specified in AWS_DATA_PATH to be considered, it must have
this structure for service models::

    <root>
      |
      |-- servicename1
      |   |-- 2012-10-25
      |       |-- service-2.json
      |-- ec2
      |   |-- 2014-01-01
      |   |   |-- paginators-1.json
      |   |   |-- service-2.json
      |   |   |-- waiters-2.json
      |   |-- 2015-03-01
      |       |-- paginators-1.json
      |       |-- service-2.json
      |       |-- waiters-2.json


That is:

    * The root directory contains sub directories that are the name
      of the services.
    * Within each service directory, there's a sub directory for each
      available API version.
    * Within each API version, there are model specific files, including
      (but not limited to): service-2.json, waiters-2.json, paginators-1.json

The ``-1`` and ``-2`` suffix at the end of the model files denote which version
schema is used within the model.  Even though this information is available in
the ``version`` key within the model, this version is also part of the filename
so that code does not need to load the JSON model in order to determine which
version to use.

iN(   t   BOTOCORE_ROOT(   t   json(   t   OrderedDict(   t   DataNotFoundErrort   UnknownServiceErrorc            s     f d   } | S(   s  Cache the result of a method on a per instance basis.

    This is not a general purpose caching decorator.  In order
    for this to be used, it must be used on methods on an
    instance, and that instance *must* provide a
    ``self._cache`` dictionary.

    c            st     j  f | } x$ t | j    D] } | | 7} q# W| |  j k rQ |  j | S  |  | |  } | |  j | <| S(   N(   t   __name__t   sortedt   itemst   _cache(   t   selft   argst   kwargst   keyt   pairt   data(   t   func(    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   _wrapperq   s    (    (   R   R   (    (   R   s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   instance_cacheh   s    		t   JSONFileLoaderc           B   s    e  Z d  Z d   Z d   Z RS(   se   Loader JSON files.

    This class can load the default format of models, which is a JSON file.

    c         C   s   t  j j | d  S(   s   Checks if the file exists.

        :type file_path: str
        :param file_path: The full path to the file to load without
            the '.json' extension.

        :return: True if file path exists, False otherwise.

        s   .json(   t   ost   patht   isfile(   R	   t	   file_path(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   exists   s    
c         C   sd   | d } t  j j |  s  d St | d  / } | j   j d  } t j | d t SWd QXd S(   s   Attempt to load the file path.

        :type file_path: str
        :param file_path: The full path to the file to load without
            the '.json' extension.

        :return: The loaded data if it exists, otherwise None.

        s   .jsonNt   rbs   utf-8t   object_pairs_hook(	   R   R   R   t   opent   readt   decodeR   t   loadsR   (   R	   R   t	   full_patht   fpt   payload(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt	   load_file   s    

(   R   t
   __module__t   __doc__R   R!   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyR   }   s   	c         C   st   |  d k r t   Sg  } |  j t j  } x9 | D]1 } t j j t j j |   } | j |  q2 Wt d |  S(   s  Create a Loader class.

    This factory function creates a loader given a search string path.

    :type search_string_path: str
    :param search_string_path: The AWS_DATA_PATH value.  A string
        of data path values separated by the ``os.path.pathsep`` value,
        which is typically ``:`` on POSIX platforms and ``;`` on
        windows.

    :return: A ``Loader`` instance.

    t   extra_search_pathsN(	   t   Nonet   Loadert   splitR   t   pathsepR   t
   expandusert
   expandvarst   append(   t   search_path_stringt   pathst   extra_pathsR   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   create_loader   s    R&   c           B   s   e  Z d  Z e Z e j j e d  Z	 e j j e j j
 d  d d  Z d d d e d  Z e d    Z e d    Z e d    Z e d	    Z e d d
   Z e d    Z d e e d  Z RS(   s   Find and load data models.

    This class will handle searching for and loading data models.

    The main method used here is ``load_service_model``, which is a
    convenience method over ``load_data`` and ``determine_latest_version``.

    R   t   ~s   .awst   modelsc         C   sw   i  |  _  | d  k r$ |  j   } n  | |  _ | d  k	 rE | |  _ n	 g  |  _ | rs |  j j |  j |  j g  n  d  S(   N(   R   R%   t   FILE_LOADER_CLASSt   file_loadert   _search_pathst   extendt   CUSTOMER_DATA_PATHt   BUILTIN_DATA_PATH(   R	   R$   R3   t   cachet   include_default_search_paths(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   __init__   s    			c         C   s   |  j  S(   N(   R4   (   R	   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   search_paths   s    c         C   s   t    } x |  j   D] } g  t j |  D]- } t j j t j j | |   r, | ^ q, } x~ | D]v } t j j | |  } t j |  } xI | D]A }	 t j j | |	 |  }
 |  j j |
  r | j	 |  Pq q Wqf Wq Wt
 |  S(   sp  List all known services.

        This will traverse the search path and look for all known
        services.

        :type type_name: str
        :param type_name: The type of the service (service-2,
            paginators-1, waiters-2, etc).  This is needed because
            the list of available services depends on the service
            type.  For example, the latest API version available for
            a resource-1.json file may not be the latest API version
            available for a services-2.json file.

        :return: A list of all services.  The list of services will
            be sorted.

        (   t   sett   _potential_locationsR   t   listdirR   t   isdirt   joinR3   R   t   addR   (   R	   t	   type_namet   servicest   possible_patht   dt   possible_servicest   service_namet   full_dirnamet   api_versionst   api_versiont   full_load_path(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   list_available_services   s    	-	c         C   s   t  |  j | |   S(   s  Find the latest API version available for a service.

        :type service_name: str
        :param service_name: The name of the service.

        :type type_name: str
        :param type_name: The type of the service (service-2,
            paginators-1, waiters-2, etc).  This is needed because
            the latest API version available can depend on the service
            type.  For example, the latest API version available for
            a resource-1.json file may not be the latest API version
            available for a services-2.json file.

        :rtype: str
        :return: The latest API version.  If the service does not exist
            or does not have any available API data, then a
            ``DataNotFoundError`` exception will be raised.

        (   t   maxt   list_api_versions(   R	   RG   RB   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   determine_latest_version  s    c         C   s   t    } xw |  j | d t d t D]Z } xQ t j |  D]@ } t j j | | |  } |  j j |  r; | j	 |  q; q; Wq% W| s t
 d |   n  t |  S(   sy  List all API versions available for a particular service type

        :type service_name: str
        :param service_name: The name of the service

        :type type_name: str
        :param type_name: The type name for the service (i.e service-2,
            paginators-1, etc.)

        :rtype: list
        :return: A list of API version strings in sorted order.

        t
   must_existt   is_dirt	   data_path(   R<   R=   t   TrueR   R>   R   R@   R3   R   RA   R   R   (   R	   RG   RB   t   known_api_versionsRD   t   dirnameR   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyRN     s    	c         C   s   |  j  |  } | | k rB t d | d d j t |     n  | d k rc |  j | |  } n  t j j | | |  } |  j |  S(   s  Load a botocore service model

        This is the main method for loading botocore models (e.g. a service
        model, pagination configs, waiter configs, etc.).

        :type service_name: str
        :param service_name: The name of the service (e.g ``ec2``, ``s3``).

        :type type_name: str
        :param type_name: The model type.  Valid types include, but are not
            limited to: ``service-2``, ``paginators-1``, ``waiters-2``.

        :type api_version: str
        :param api_version: The API version to load.  If this is not
            provided, then the latest API version will be used.

        :raises: UnknownServiceError if there is no known service with
            the provided service_name.

        :raises: DataNotFoundError if no data could be found for the
            service_name/type_name/api_version.

        :return: The loaded data, as a python type (e.g. dict, list, etc).
        RG   t   known_service_namess   , N(	   RL   R   R@   R   R%   RO   R   R   t	   load_data(   R	   RG   RB   RJ   t   known_servicesR   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   load_service_model<  s    c         C   sO   x9 |  j  |  D]( } |  j j |  } | d k	 r | Sq Wt d |   d S(   s0  Load data given a data path.

        This is a low level method that will search through the various
        search paths until it's able to load a value.  This is typically
        only needed to load *non* model files (such as _endpoints and
        _retry).  If you need to load model files, you should prefer
        ``load_service_model``.

        :type name: str
        :param name: The data path, i.e ``ec2/2015-03-01/service-2``.

        :return: The loaded data.  If no data could be found then
            a DataNotFoundError is raised.

        RR   N(   R=   R3   R!   R%   R   (   R	   t   nameRD   t   found(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyRW   c  s
    c         c   s   x |  j  D] } t j j |  r
 | } | d  k	 rL t j j | |  } n  | sZ | Vq | rz t j j |  rz | Vq t j j |  r | Vq q
 q
 Wd  S(   N(   R;   R   R   R?   R%   R@   R   (   R	   RZ   RP   RQ   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyR=   {  s    N(   R   R"   R#   R   R2   R   R   R@   R    R7   R)   R6   R%   RS   R:   t   propertyR;   R   RL   RO   RN   RY   RW   t   FalseR=   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyR&      s    )&(   R#   R   t   botocoreR    t   botocore.compatR   R   t   botocore.exceptionsR   R   R   t   objectR   R%   R/   R&   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/loaders.pyt   <module>_   s   	'                                                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/botocore/model.py                                             0100644 0000000 0000062 00000055311 13077704371 021521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
"""Abstractions to interact with service models."""
from collections import defaultdict

from botocore.utils import CachedProperty, instance_cache
from botocore.compat import OrderedDict


NOT_SET = object()


class NoShapeFoundError(Exception):
    pass


class InvalidShapeError(Exception):
    pass


class OperationNotFoundError(Exception):
    pass


class InvalidShapeReferenceError(Exception):
    pass


class UndefinedModelAttributeError(Exception):
    pass


class Shape(object):
    """Object representing a shape from the service model."""
    # To simplify serialization logic, all shape params that are
    # related to serialization are moved from the top level hash into
    # a 'serialization' hash.  This list below contains the names of all
    # the attributes that should be moved.
    SERIALIZED_ATTRS = ['locationName', 'queryName', 'flattened', 'location',
                        'payload', 'streaming', 'timestampFormat',
                        'xmlNamespace', 'resultWrapper', 'xmlAttribute']
    METADATA_ATTRS = ['required', 'min', 'max', 'sensitive', 'enum']
    MAP_TYPE = OrderedDict

    def __init__(self, shape_name, shape_model, shape_resolver=None):
        """

        :type shape_name: string
        :param shape_name: The name of the shape.

        :type shape_model: dict
        :param shape_model: The shape model.  This would be the value
            associated with the key in the "shapes" dict of the
            service model (i.e ``model['shapes'][shape_name]``)

        :type shape_resolver: botocore.model.ShapeResolver
        :param shape_resolver: A shape resolver object.  This is used to
            resolve references to other shapes.  For scalar shape types
            (string, integer, boolean, etc.), this argument is not
            required.  If a shape_resolver is not provided for a complex
            type, then a ``ValueError`` will be raised when an attempt
            to resolve a shape is made.

        """
        self.name = shape_name
        self.type_name = shape_model['type']
        self.documentation = shape_model.get('documentation', '')
        self._shape_model = shape_model
        if shape_resolver is None:
            # If a shape_resolver is not provided, we create an object
            # that will throw errors if you attempt to resolve
            # a shape.  This is actually ok for scalar shapes
            # because they don't need to resolve shapes and shouldn't
            # be required to provide an object they won't use.
            shape_resolver = UnresolvableShapeMap()
        self._shape_resolver = shape_resolver
        self._cache = {}

    @CachedProperty
    def serialization(self):
        """Serialization information about the shape.

        This contains information that may be needed for input serialization
        or response parsing.  This can include:

            * name
            * queryName
            * flattened
            * location
            * payload
            * streaming
            * xmlNamespace
            * resultWrapper
            * xmlAttribute

        :rtype: dict
        :return: Serialization information about the shape.

        """
        model = self._shape_model
        serialization = {}
        for attr in self.SERIALIZED_ATTRS:
            if attr in self._shape_model:
                serialization[attr] = model[attr]
        # For consistency, locationName is renamed to just 'name'.
        if 'locationName' in serialization:
            serialization['name'] = serialization.pop('locationName')
        return serialization

    @CachedProperty
    def metadata(self):
        """Metadata about the shape.

        This requires optional information about the shape, including:

            * min
            * max
            * enum
            * sensitive
            * required

        :rtype: dict
        :return: Metadata about the shape.

        """
        model = self._shape_model
        metadata = {}
        for attr in self.METADATA_ATTRS:
            if attr in self._shape_model:
                metadata[attr] = model[attr]
        return metadata

    @CachedProperty
    def required_members(self):
        """A list of members that are required.

        A structure shape can define members that are required.
        This value will return a list of required members.  If there
        are no required members an empty list is returned.

        """
        return self.metadata.get('required', [])

    def _resolve_shape_ref(self, shape_ref):
        return self._shape_resolver.resolve_shape_ref(shape_ref)

    def __repr__(self):
        return "<%s(%s)>" % (self.__class__.__name__,
                             self.name)


class StructureShape(Shape):
    @CachedProperty
    def members(self):
        members = self._shape_model['members']
        # The members dict looks like:
        #    'members': {
        #        'MemberName': {'shape': 'shapeName'},
        #        'MemberName2': {'shape': 'shapeName'},
        #    }
        # We return a dict of member name to Shape object.
        shape_members = self.MAP_TYPE()
        for name, shape_ref in members.items():
            shape_members[name] = self._resolve_shape_ref(shape_ref)
        return shape_members


class ListShape(Shape):
    @CachedProperty
    def member(self):
        return self._resolve_shape_ref(self._shape_model['member'])


class MapShape(Shape):
    @CachedProperty
    def key(self):
        return self._resolve_shape_ref(self._shape_model['key'])

    @CachedProperty
    def value(self):
        return self._resolve_shape_ref(self._shape_model['value'])


class StringShape(Shape):
    @CachedProperty
    def enum(self):
        return self.metadata.get('enum', [])


class ServiceModel(object):
    """

    :ivar service_description: The parsed service description dictionary.

    """

    def __init__(self, service_description, service_name=None):
        """

        :type service_description: dict
        :param service_description: The service description model.  This value
            is obtained from a botocore.loader.Loader, or from directly loading
            the file yourself::

                service_description = json.load(
                    open('/path/to/service-description-model.json'))
                model = ServiceModel(service_description)

        :type service_name: str
        :param service_name: The name of the service.  Normally this is
            the endpoint prefix defined in the service_description.  However,
            you can override this value to provide a more convenient name.
            This is done in a few places in botocore (ses instead of email,
            emr instead of elasticmapreduce).  If this value is not provided,
            it will default to the endpointPrefix defined in the model.

        """
        self._service_description = service_description
        # We want clients to be able to access metadata directly.
        self.metadata = service_description.get('metadata', {})
        self._shape_resolver = ShapeResolver(
            service_description.get('shapes', {}))
        self._signature_version = NOT_SET
        self._service_name = service_name
        self._instance_cache = {}

    def shape_for(self, shape_name, member_traits=None):
        return self._shape_resolver.get_shape_by_name(
            shape_name, member_traits)

    def resolve_shape_ref(self, shape_ref):
        return self._shape_resolver.resolve_shape_ref(shape_ref)

    @instance_cache
    def operation_model(self, operation_name):
        try:
            model = self._service_description['operations'][operation_name]
        except KeyError:
            raise OperationNotFoundError(operation_name)
        return OperationModel(model, self, operation_name)

    @CachedProperty
    def documentation(self):
        return self._service_description.get('documentation', '')

    @CachedProperty
    def operation_names(self):
        return list(self._service_description.get('operations', []))

    @CachedProperty
    def service_name(self):
        """The name of the service.

        This defaults to the endpointPrefix defined in the service model.
        However, this value can be overriden when a ``ServiceModel`` is
        created.  If a service_name was not provided when the ``ServiceModel``
        was created and if there is no endpointPrefix defined in the
        service model, then an ``UndefinedModelAttributeError`` exception
        will be raised.

        """
        if self._service_name is not None:
            return self._service_name
        else:
            return self.endpoint_prefix

    @CachedProperty
    def signing_name(self):
        """The name to use when computing signatures.

        If the model does not define a signing name, this
        value will be the endpoint prefix defined in the model.
        """
        signing_name = self.metadata.get('signingName')
        if signing_name is None:
            signing_name = self.endpoint_prefix
        return signing_name

    @CachedProperty
    def api_version(self):
        return self._get_metadata_property('apiVersion')

    @CachedProperty
    def protocol(self):
        return self._get_metadata_property('protocol')

    @CachedProperty
    def endpoint_prefix(self):
        return self._get_metadata_property('endpointPrefix')

    def _get_metadata_property(self, name):
        try:
            return self.metadata[name]
        except KeyError:
            raise UndefinedModelAttributeError(
                '"%s" not defined in the metadata of the the model: %s' %
                (name, self))

    # Signature version is one of the rare properties
    # than can be modified so a CachedProperty is not used here.

    @property
    def signature_version(self):
        if self._signature_version is NOT_SET:
            signature_version = self.metadata.get('signatureVersion')
            self._signature_version = signature_version
        return self._signature_version

    @signature_version.setter
    def signature_version(self, value):
        self._signature_version = value


class OperationModel(object):
    def __init__(self, operation_model, service_model, name=None):
        """

        :type operation_model: dict
        :param operation_model: The operation model.  This comes from the
            service model, and is the value associated with the operation
            name in the service model (i.e ``model['operations'][op_name]``).

        :type service_model: botocore.model.ServiceModel
        :param service_model: The service model associated with the operation.

        :type name: string
        :param name: The operation name.  This is the operation name exposed to
            the users of this model.  This can potentially be different from
            the "wire_name", which is the operation name that *must* by
            provided over the wire.  For example, given::

               "CreateCloudFrontOriginAccessIdentity":{
                 "name":"CreateCloudFrontOriginAccessIdentity2014_11_06",
                  ...
              }

           The ``name`` would be ``CreateCloudFrontOriginAccessIdentity``,
           but the ``self.wire_name`` would be
           ``CreateCloudFrontOriginAccessIdentity2014_11_06``, which is the
           value we must send in the corresponding HTTP request.

        """
        self._operation_model = operation_model
        self._service_model = service_model
        self._api_name = name
        # Clients can access '.name' to get the operation name
        # and '.metadata' to get the top level metdata of the service.
        self._wire_name = operation_model.get('name')
        self.metadata = service_model.metadata
        self.http = operation_model.get('http', {})

    @CachedProperty
    def name(self):
        if self._api_name is not None:
            return self._api_name
        else:
            return self.wire_name

    @property
    def wire_name(self):
        """The wire name of the operation.

        In many situations this is the same value as the
        ``name``, value, but in some services, the operation name
        exposed to the user is different from the operaiton name
        we send across the wire (e.g cloudfront).

        Any serialization code should use ``wire_name``.

        """
        return self._operation_model.get('name')

    @property
    def service_model(self):
        return self._service_model

    @CachedProperty
    def documentation(self):
        return self._operation_model.get('documentation', '')

    @CachedProperty
    def input_shape(self):
        if 'input' not in self._operation_model:
            # Some operations do not accept any input and do not define an
            # input shape.
            return None
        return self._service_model.resolve_shape_ref(
            self._operation_model['input'])

    @CachedProperty
    def output_shape(self):
        if 'output' not in self._operation_model:
            # Some operations do not define an output shape,
            # in which case we return None to indicate the
            # operation has no expected output.
            return None
        return self._service_model.resolve_shape_ref(
            self._operation_model['output'])

    @CachedProperty
    def has_streaming_input(self):
        return self.get_streaming_input() is not None

    @CachedProperty
    def has_streaming_output(self):
        return self.get_streaming_output() is not None

    def get_streaming_input(self):
        return self._get_streaming_body(self.input_shape)

    def get_streaming_output(self):
        return self._get_streaming_body(self.output_shape)

    def _get_streaming_body(self, shape):
        """Returns the streaming member's shape if any; or None otherwise."""
        if shape is None:
            return None
        payload = shape.serialization.get('payload')
        if payload is not None:
            payload_shape = shape.members[payload]
            if payload_shape.type_name == 'blob':
                return payload_shape
        return None


class ShapeResolver(object):
    """Resolves shape references."""

    # Any type not in this mapping will default to the Shape class.
    SHAPE_CLASSES = {
        'structure': StructureShape,
        'list': ListShape,
        'map': MapShape,
        'string': StringShape
    }

    def __init__(self, shape_map):
        self._shape_map = shape_map
        self._shape_cache = {}

    def get_shape_by_name(self, shape_name, member_traits=None):
        try:
            shape_model = self._shape_map[shape_name]
        except KeyError:
            raise NoShapeFoundError(shape_name)
        try:
            shape_cls = self.SHAPE_CLASSES.get(shape_model['type'], Shape)
        except KeyError:
            raise InvalidShapeError("Shape is missing required key 'type': %s"
                                    % shape_model)
        if member_traits:
            shape_model = shape_model.copy()
            shape_model.update(member_traits)
        result = shape_cls(shape_name, shape_model, self)
        return result

    def resolve_shape_ref(self, shape_ref):
        # A shape_ref is a dict that has a 'shape' key that
        # refers to a shape name as well as any additional
        # member traits that are then merged over the shape
        # definition.  For example:
        # {"shape": "StringType", "locationName": "Foobar"}
        if len(shape_ref) == 1 and 'shape' in shape_ref:
            # It's just a shape ref with no member traits, we can avoid
            # a .copy().  This is the common case so it's specifically
            # called out here.
            return self.get_shape_by_name(shape_ref['shape'])
        else:
            member_traits = shape_ref.copy()
            try:
                shape_name = member_traits.pop('shape')
            except KeyError:
                raise InvalidShapeReferenceError(
                    "Invalid model, missing shape reference: %s" % shape_ref)
            return self.get_shape_by_name(shape_name, member_traits)


class UnresolvableShapeMap(object):
    """A ShapeResolver that will throw ValueErrors when shapes are resolved.
    """
    def get_shape_by_name(self, shape_name, member_traits=None):
        raise ValueError("Attempted to lookup shape '%s', but no shape "
                         "map was provided.")

    def resolve_shape_ref(self, shape_ref):
        raise ValueError("Attempted to resolve shape '%s', but no shape "
                         "map was provided.")


class DenormalizedStructureBuilder(object):
    """Build a StructureShape from a denormalized model.

    This is a convenience builder class that makes it easy to construct
    ``StructureShape``s based on a denormalized model.

    It will handle the details of creating unique shape names and creating
    the appropriate shape map needed by the ``StructureShape`` class.

    Example usage::

        builder = DenormalizedStructureBuilder()
        shape = builder.with_members({
            'A': {
                'type': 'structure',
                'members': {
                    'B': {
                        'type': 'structure',
                        'members': {
                            'C': {
                                'type': 'string',
                            }
                        }
                    }
                }
            }
        }).build_model()
        # ``shape`` is now an instance of botocore.model.StructureShape

    :type dict_type: class
    :param dict_type: The dictionary type to use, allowing you to opt-in
                      to using OrderedDict or another dict type. This can
                      be particularly useful for testing when order
                      matters, such as for documentation.

    """
    def __init__(self, name=None):
        self.members = OrderedDict()
        self._name_generator = ShapeNameGenerator()
        if name is None:
            self.name = self._name_generator.new_shape_name('structure')

    def with_members(self, members):
        """

        :type members: dict
        :param members: The denormalized members.

        :return: self

        """
        self._members = members
        return self

    def build_model(self):
        """Build the model based on the provided members.

        :rtype: botocore.model.StructureShape
        :return: The built StructureShape object.

        """
        shapes = OrderedDict()
        denormalized = {
            'type': 'structure',
            'members': self._members,
        }
        self._build_model(denormalized, shapes, self.name)
        resolver = ShapeResolver(shape_map=shapes)
        return StructureShape(shape_name=self.name,
                              shape_model=shapes[self.name],
                              shape_resolver=resolver)

    def _build_model(self, model, shapes, shape_name):
        if model['type'] == 'structure':
            shapes[shape_name] = self._build_structure(model, shapes)
        elif model['type'] == 'list':
            shapes[shape_name] = self._build_list(model, shapes)
        elif model['type'] == 'map':
            shapes[shape_name] = self._build_map(model, shapes)
        elif model['type'] in ['string', 'integer', 'boolean', 'blob', 'float',
                               'timestamp', 'long', 'double', 'char']:
            shapes[shape_name] = self._build_scalar(model)
        else:
            raise InvalidShapeError("Unknown shape type: %s" % model['type'])

    def _build_structure(self, model, shapes):
        members = OrderedDict()
        shape = self._build_initial_shape(model)
        shape['members'] = members

        for name, member_model in model['members'].items():
            member_shape_name = self._get_shape_name(member_model)
            members[name] = {'shape': member_shape_name}
            self._build_model(member_model, shapes, member_shape_name)
        return shape

    def _build_list(self, model, shapes):
        member_shape_name = self._get_shape_name(model)
        shape = self._build_initial_shape(model)
        shape['member'] = {'shape': member_shape_name}
        self._build_model(model['member'], shapes, member_shape_name)
        return shape

    def _build_map(self, model, shapes):
        key_shape_name = self._get_shape_name(model['key'])
        value_shape_name = self._get_shape_name(model['value'])
        shape = self._build_initial_shape(model)
        shape['key'] = {'shape': key_shape_name}
        shape['value'] = {'shape': value_shape_name}
        self._build_model(model['key'], shapes, key_shape_name)
        self._build_model(model['value'], shapes, value_shape_name)
        return shape

    def _build_initial_shape(self, model):
        shape = {
            'type': model['type'],
        }
        if 'documentation' in model:
            shape['documentation'] = model['documentation']
        if 'enum' in model:
            shape['enum'] = model['enum']
        return shape

    def _build_scalar(self, model):
        return self._build_initial_shape(model)

    def _get_shape_name(self, model):
        if 'shape_name' in model:
            return model['shape_name']
        else:
            return self._name_generator.new_shape_name(model['type'])


class ShapeNameGenerator(object):
    """Generate unique shape names for a type.

    This class can be used in conjunction with the DenormalizedStructureBuilder
    to generate unique shape names for a given type.

    """
    def __init__(self):
        self._name_cache = defaultdict(int)

    def new_shape_name(self, type_name):
        """Generate a unique shape name.

        This method will guarantee a unique shape name each time it is
        called with the same type.

        ::

            >>> s = ShapeNameGenerator()
            >>> s.new_shape_name('structure')
            'StructureType1'
            >>> s.new_shape_name('structure')
            'StructureType2'
            >>> s.new_shape_name('list')
            'ListType1'
            >>> s.new_shape_name('list')
            'ListType2'


        :type type_name: string
        :param type_name: The type name (structure, list, map, string, etc.)

        :rtype: string
        :return: A unique shape name for the given type

        """
        self._name_cache[type_name] += 1
        current_index = self._name_cache[type_name]
        return '%sType%s' % (type_name.capitalize(),
                             current_index)
                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/botocore/model.pyc                                            0100644 0000000 0000062 00000061310 13077704401 021652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s  d  Z  d d l m Z d d l m Z m Z d d l m Z e   Z	 d e
 f d     YZ d e
 f d     YZ d	 e
 f d
     YZ d e
 f d     YZ d e
 f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d      YZ d! e f d"     YZ d# e f d$     YZ d% S(&   s-   Abstractions to interact with service models.i(   t   defaultdict(   t   CachedPropertyt   instance_cache(   t   OrderedDictt   NoShapeFoundErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR      s   t   InvalidShapeErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR      s   t   OperationNotFoundErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR      s   t   InvalidShapeReferenceErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR	   #   s   t   UndefinedModelAttributeErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR
   '   s   t   Shapec        
   B   s   e  Z d  Z d d d d d d d d d	 d
 g
 Z d d d d d g Z e Z d d  Z e	 d    Z
 e	 d    Z e	 d    Z d   Z d   Z RS(   s3   Object representing a shape from the service model.t   locationNamet	   queryNamet	   flattenedt   locationt   payloadt	   streamingt   timestampFormatt   xmlNamespacet   resultWrappert   xmlAttributet   requiredt   mint   maxt	   sensitivet   enumc         C   sb   | |  _  | d |  _ | j d d  |  _ | |  _ | d k rL t   } n  | |  _ i  |  _ d S(   s  

        :type shape_name: string
        :param shape_name: The name of the shape.

        :type shape_model: dict
        :param shape_model: The shape model.  This would be the value
            associated with the key in the "shapes" dict of the
            service model (i.e ``model['shapes'][shape_name]``)

        :type shape_resolver: botocore.model.ShapeResolver
        :param shape_resolver: A shape resolver object.  This is used to
            resolve references to other shapes.  For scalar shape types
            (string, integer, boolean, etc.), this argument is not
            required.  If a shape_resolver is not provided for a complex
            type, then a ``ValueError`` will be raised when an attempt
            to resolve a shape is made.

        t   typet   documentationt    N(	   t   namet	   type_namet   getR   t   _shape_modelt   Nonet   UnresolvableShapeMapt   _shape_resolvert   _cache(   t   selft
   shape_namet   shape_modelt   shape_resolver(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   __init__7   s    			c         C   si   |  j  } i  } x1 |  j D]& } | |  j  k r | | | | <q q Wd | k re | j d  | d <n  | S(   s  Serialization information about the shape.

        This contains information that may be needed for input serialization
        or response parsing.  This can include:

            * name
            * queryName
            * flattened
            * location
            * payload
            * streaming
            * xmlNamespace
            * resultWrapper
            * xmlAttribute

        :rtype: dict
        :return: Serialization information about the shape.

        R   R   (   R!   t   SERIALIZED_ATTRSt   pop(   R&   t   modelt   serializationt   attr(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR.   Y   s    	c         C   sG   |  j  } i  } x1 |  j D]& } | |  j  k r | | | | <q q W| S(   s  Metadata about the shape.

        This requires optional information about the shape, including:

            * min
            * max
            * enum
            * sensitive
            * required

        :rtype: dict
        :return: Metadata about the shape.

        (   R!   t   METADATA_ATTRS(   R&   R-   t   metadataR/   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR1   x   s    	c         C   s   |  j  j d g   S(   s   A list of members that are required.

        A structure shape can define members that are required.
        This value will return a list of required members.  If there
        are no required members an empty list is returned.

        R   (   R1   R    (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   required_members   s    	c         C   s   |  j  j |  S(   N(   R$   t   resolve_shape_ref(   R&   t	   shape_ref(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   _resolve_shape_ref   s    c         C   s   d |  j  j |  j f S(   Ns   <%s(%s)>(   t	   __class__R   R   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   __repr__   s    N(   R   R   t   __doc__R+   R0   R   t   MAP_TYPER"   R*   R   R.   R1   R2   R5   R7   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   +   s   	"	t   StructureShapec           B   s   e  Z e d     Z RS(   c         C   sM   |  j  d } |  j   } x- | j   D] \ } } |  j |  | | <q& W| S(   Nt   members(   R!   R9   t   itemsR5   (   R&   R;   t   shape_membersR   R4   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR;      s
    (   R   R   R   R;   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR:      s   t	   ListShapec           B   s   e  Z e d     Z RS(   c         C   s   |  j  |  j d  S(   Nt   member(   R5   R!   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR?      s    (   R   R   R   R?   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR>      s   t   MapShapec           B   s&   e  Z e d     Z e d    Z RS(   c         C   s   |  j  |  j d  S(   Nt   key(   R5   R!   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRA      s    c         C   s   |  j  |  j d  S(   Nt   value(   R5   R!   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRB      s    (   R   R   R   RA   RB   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR@      s   t   StringShapec           B   s   e  Z e d     Z RS(   c         C   s   |  j  j d g   S(   NR   (   R1   R    (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR      s    (   R   R   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRC      s   t   ServiceModelc           B   s   e  Z d  Z d d  Z d d  Z d   Z e d    Z e	 d    Z
 e	 d    Z e	 d    Z e	 d    Z e	 d	    Z e	 d
    Z e	 d    Z d   Z e d    Z e j d    Z RS(   sQ   

    :ivar service_description: The parsed service description dictionary.

    c         C   sX   | |  _  | j d i   |  _ t | j d i    |  _ t |  _ | |  _ i  |  _ d S(   s  

        :type service_description: dict
        :param service_description: The service description model.  This value
            is obtained from a botocore.loader.Loader, or from directly loading
            the file yourself::

                service_description = json.load(
                    open('/path/to/service-description-model.json'))
                model = ServiceModel(service_description)

        :type service_name: str
        :param service_name: The name of the service.  Normally this is
            the endpoint prefix defined in the service_description.  However,
            you can override this value to provide a more convenient name.
            This is done in a few places in botocore (ses instead of email,
            emr instead of elasticmapreduce).  If this value is not provided,
            it will default to the endpointPrefix defined in the model.

        R1   t   shapesN(	   t   _service_descriptionR    R1   t   ShapeResolverR$   t   NOT_SETt   _signature_versiont   _service_namet   _instance_cache(   R&   t   service_descriptiont   service_name(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR*      s    			c         C   s   |  j  j | |  S(   N(   R$   t   get_shape_by_name(   R&   R'   t   member_traits(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt	   shape_for   s    	c         C   s   |  j  j |  S(   N(   R$   R3   (   R&   R4   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR3      s    c         C   sE   y |  j  d | } Wn t k
 r4 t |   n Xt | |  |  S(   Nt
   operations(   RF   t   KeyErrorR   t   OperationModel(   R&   t   operation_nameR-   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   operation_model   s
    c         C   s   |  j  j d d  S(   NR   R   (   RF   R    (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR      s    c         C   s   t  |  j j d g    S(   NRQ   (   t   listRF   R    (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   operation_names   s    c         C   s!   |  j  d k	 r |  j  S|  j Sd S(   s  The name of the service.

        This defaults to the endpointPrefix defined in the service model.
        However, this value can be overriden when a ``ServiceModel`` is
        created.  If a service_name was not provided when the ``ServiceModel``
        was created and if there is no endpointPrefix defined in the
        service model, then an ``UndefinedModelAttributeError`` exception
        will be raised.

        N(   RJ   R"   t   endpoint_prefix(   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRM     s    c         C   s.   |  j  j d  } | d k r* |  j } n  | S(   s   The name to use when computing signatures.

        If the model does not define a signing name, this
        value will be the endpoint prefix defined in the model.
        t   signingNameN(   R1   R    R"   RX   (   R&   t   signing_name(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRZ     s    c         C   s   |  j  d  S(   Nt
   apiVersion(   t   _get_metadata_property(   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   api_version!  s    c         C   s   |  j  d  S(   Nt   protocol(   R\   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR^   %  s    c         C   s   |  j  d  S(   Nt   endpointPrefix(   R\   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRX   )  s    c         C   s=   y |  j  | SWn' t k
 r8 t d | |  f   n Xd  S(   Ns5   "%s" not defined in the metadata of the the model: %s(   R1   RR   R
   (   R&   R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR\   -  s    c         C   s4   |  j  t k r- |  j j d  } | |  _  n  |  j  S(   Nt   signatureVersion(   RI   RH   R1   R    (   R&   t   signature_version(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRa   8  s    c         C   s   | |  _  d  S(   N(   RI   (   R&   RB   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRa   ?  s    N(   R   R   R8   R"   R*   RP   R3   R   RU   R   R   RW   RM   RZ   R]   R^   RX   R\   t   propertyRa   t   setter(    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRD      s   		RS   c           B   s   e  Z d d   Z e d    Z e d    Z e d    Z e d    Z	 e d    Z
 e d    Z e d    Z e d    Z d	   Z d
   Z d   Z RS(   c         C   sR   | |  _  | |  _ | |  _ | j d  |  _ | j |  _ | j d i   |  _ d S(   s  

        :type operation_model: dict
        :param operation_model: The operation model.  This comes from the
            service model, and is the value associated with the operation
            name in the service model (i.e ``model['operations'][op_name]``).

        :type service_model: botocore.model.ServiceModel
        :param service_model: The service model associated with the operation.

        :type name: string
        :param name: The operation name.  This is the operation name exposed to
            the users of this model.  This can potentially be different from
            the "wire_name", which is the operation name that *must* by
            provided over the wire.  For example, given::

               "CreateCloudFrontOriginAccessIdentity":{
                 "name":"CreateCloudFrontOriginAccessIdentity2014_11_06",
                  ...
              }

           The ``name`` would be ``CreateCloudFrontOriginAccessIdentity``,
           but the ``self.wire_name`` would be
           ``CreateCloudFrontOriginAccessIdentity2014_11_06``, which is the
           value we must send in the corresponding HTTP request.

        R   t   httpN(   t   _operation_modelt   _service_modelt	   _api_nameR    t
   _wire_nameR1   Rd   (   R&   RU   t   service_modelR   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR*   E  s    			c         C   s!   |  j  d  k	 r |  j  S|  j Sd  S(   N(   Rg   R"   t	   wire_name(   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   j  s    c         C   s   |  j  j d  S(   sR  The wire name of the operation.

        In many situations this is the same value as the
        ``name``, value, but in some services, the operation name
        exposed to the user is different from the operaiton name
        we send across the wire (e.g cloudfront).

        Any serialization code should use ``wire_name``.

        R   (   Re   R    (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRj   q  s    c         C   s   |  j  S(   N(   Rf   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRi     s    c         C   s   |  j  j d d  S(   NR   R   (   Re   R    (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR     s    c         C   s*   d |  j  k r d  S|  j j |  j  d  S(   Nt   input(   Re   R"   Rf   R3   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   input_shape  s    	c         C   s*   d |  j  k r d  S|  j j |  j  d  S(   Nt   output(   Re   R"   Rf   R3   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   output_shape  s    	c         C   s   |  j    d  k	 S(   N(   t   get_streaming_inputR"   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   has_streaming_input  s    c         C   s   |  j    d  k	 S(   N(   t   get_streaming_outputR"   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   has_streaming_output  s    c         C   s   |  j  |  j  S(   N(   t   _get_streaming_bodyRl   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRo     s    c         C   s   |  j  |  j  S(   N(   Rs   Rn   (   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRq     s    c         C   sU   | d k r d S| j j d  } | d k	 rQ | j | } | j d k rQ | Sn  d S(   s?   Returns the streaming member's shape if any; or None otherwise.R   t   blobN(   R"   R.   R    R;   R   (   R&   t   shapeR   t   payload_shape(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRs     s    N(   R   R   R"   R*   R   R   Rb   Rj   Ri   R   Rl   Rn   Rp   Rr   Ro   Rq   Rs   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRS   D  s   %	
		RG   c           B   sN   e  Z d  Z i e d 6e d 6e d 6e d 6Z d   Z d d  Z
 d   Z RS(	   s   Resolves shape references.t	   structureRV   t   mapt   stringc         C   s   | |  _  i  |  _ d  S(   N(   t
   _shape_mapt   _shape_cache(   R&   t	   shape_map(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR*     s    	c         C   s   y |  j  | } Wn t k
 r0 t |   n Xy |  j j | d t  } Wn! t k
 rq t d |   n X| r | j   } | j |  n  | | | |   } | S(   NR   s(   Shape is missing required key 'type': %s(	   Rz   RR   R   t   SHAPE_CLASSESR    R   R   t   copyt   update(   R&   R'   RO   R(   t	   shape_clst   result(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRN     s    c         C   s   t  |  d k r/ d | k r/ |  j | d  S| j   } y | j d  } Wn! t k
 rq t d |   n X|  j | |  Sd  S(   Ni   Ru   s*   Invalid model, missing shape reference: %s(   t   lenRN   R~   R,   RR   R	   (   R&   R4   RO   R'   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR3     s    N(   R   R   R8   R:   R>   R@   RC   R}   R*   R"   RN   R3   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRG     s   
	R#   c           B   s#   e  Z d  Z d d  Z d   Z RS(   sJ   A ShapeResolver that will throw ValueErrors when shapes are resolved.
    c         C   s   t  d   d  S(   Ns>   Attempted to lookup shape '%s', but no shape map was provided.(   t
   ValueError(   R&   R'   RO   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyRN     s    c         C   s   t  d   d  S(   Ns?   Attempted to resolve shape '%s', but no shape map was provided.(   R   (   R&   R4   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR3     s    N(   R   R   R8   R"   RN   R3   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR#     s   t   DenormalizedStructureBuilderc           B   sk   e  Z d  Z d d  Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z RS(   s  Build a StructureShape from a denormalized model.

    This is a convenience builder class that makes it easy to construct
    ``StructureShape``s based on a denormalized model.

    It will handle the details of creating unique shape names and creating
    the appropriate shape map needed by the ``StructureShape`` class.

    Example usage::

        builder = DenormalizedStructureBuilder()
        shape = builder.with_members({
            'A': {
                'type': 'structure',
                'members': {
                    'B': {
                        'type': 'structure',
                        'members': {
                            'C': {
                                'type': 'string',
                            }
                        }
                    }
                }
            }
        }).build_model()
        # ``shape`` is now an instance of botocore.model.StructureShape

    :type dict_type: class
    :param dict_type: The dictionary type to use, allowing you to opt-in
                      to using OrderedDict or another dict type. This can
                      be particularly useful for testing when order
                      matters, such as for documentation.

    c         C   s@   t    |  _ t   |  _ | d  k r< |  j j d  |  _ n  d  S(   NRw   (   R   R;   t   ShapeNameGeneratort   _name_generatorR"   t   new_shape_nameR   (   R&   R   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR*     s    c         C   s   | |  _  |  S(   sp   

        :type members: dict
        :param members: The denormalized members.

        :return: self

        (   t   _members(   R&   R;   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   with_members  s    		c         C   sh   t    } i d d 6|  j d 6} |  j | | |  j  t d |  } t d |  j d | |  j d |  S(   s   Build the model based on the provided members.

        :rtype: botocore.model.StructureShape
        :return: The built StructureShape object.

        Rw   R   R;   R|   R'   R(   R)   (   R   R   t   _build_modelR   RG   R:   (   R&   RE   t   denormalizedt   resolver(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   build_model*  s    	c      
   C   s   | d d k r) |  j  | |  | | <n | d d k rR |  j | |  | | <nc | d d k r{ |  j | |  | | <n: | d d k r |  j |  | | <n t d | d   d  S(   NR   Rw   RV   Rx   Ry   t   integert   booleanRt   t   floatt	   timestampt   longt   doublet   chars   Unknown shape type: %s(	   s   strings   integers   booleans   blobs   floats	   timestamps   longs   doubles   char(   t   _build_structuret   _build_listt
   _build_mapt   _build_scalarR   (   R&   R-   RE   R'   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   <  s    	c         C   sz   t    } |  j |  } | | d <xQ | d j   D]? \ } } |  j |  } i | d 6| | <|  j | | |  q3 W| S(   NR;   Ru   (   R   t   _build_initial_shapeR<   t   _get_shape_nameR   (   R&   R-   RE   R;   Ru   R   t   member_modelt   member_shape_name(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   I  s    	
c         C   sJ   |  j  |  } |  j |  } i | d 6| d <|  j | d | |  | S(   NRu   R?   (   R   R   R   (   R&   R-   RE   R   Ru   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   T  s
    c         C   s   |  j  | d  } |  j  | d  } |  j |  } i | d 6| d <i | d 6| d <|  j | d | |  |  j | d | |  | S(   NRA   RB   Ru   (   R   R   R   (   R&   R-   RE   t   key_shape_namet   value_shape_nameRu   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   [  s    c         C   sO   i | d d 6} d | k r. | d | d <n  d | k rK | d | d <n  | S(   NR   R   R   (    (   R&   R-   Ru   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   e  s    c         C   s   |  j  |  S(   N(   R   (   R&   R-   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   o  s    c         C   s,   d | k r | d S|  j  j | d  Sd  S(   NR'   R   (   R   R   (   R&   R-   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   r  s    N(   R   R   R8   R"   R*   R   R   R   R   R   R   R   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR     s   #						
	
	R   c           B   s    e  Z d  Z d   Z d   Z RS(   s   Generate unique shape names for a type.

    This class can be used in conjunction with the DenormalizedStructureBuilder
    to generate unique shape names for a given type.

    c         C   s   t  t  |  _ d  S(   N(   R    t   intt   _name_cache(   R&   (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR*     s    c         C   s4   |  j  | c d 7<|  j  | } d | j   | f S(   s  Generate a unique shape name.

        This method will guarantee a unique shape name each time it is
        called with the same type.

        ::

            >>> s = ShapeNameGenerator()
            >>> s.new_shape_name('structure')
            'StructureType1'
            >>> s.new_shape_name('structure')
            'StructureType2'
            >>> s.new_shape_name('list')
            'ListType1'
            >>> s.new_shape_name('list')
            'ListType2'


        :type type_name: string
        :param type_name: The type name (structure, list, map, string, etc.)

        :rtype: string
        :return: A unique shape name for the given type

        i   s   %sType%s(   R   t
   capitalize(   R&   R   t   current_index(    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR     s    (   R   R   R8   R*   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyR   y  s   	N(   R8   t   collectionsR    t   botocore.utilsR   R   t   botocore.compatR   t   objectRH   t	   ExceptionR   R   R   R	   R
   R   R:   R>   R@   RC   RD   RS   RG   R#   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/botocore/botocore/model.pyt   <module>   s(   	w
|p4                                                                                                                                                                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/paginate.py                                          0100644 0000000 0000062 00000044437 13077704371 022220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

from itertools import tee

from six import string_types

import jmespath
import json
import base64
from botocore.exceptions import PaginationError
from botocore.compat import zip
from botocore.utils import set_value_from_jmespath, merge_dicts


class PaginatorModel(object):
    def __init__(self, paginator_config):
        self._paginator_config = paginator_config['pagination']

    def get_paginator(self, operation_name):
        try:
            single_paginator_config = self._paginator_config[operation_name]
        except KeyError:
            raise ValueError("Paginator for operation does not exist: %s"
                             % operation_name)
        return single_paginator_config


class PageIterator(object):
    def __init__(self, method, input_token, output_token, more_results,
                 result_keys, non_aggregate_keys, limit_key, max_items,
                 starting_token, page_size, op_kwargs):
        self._method = method
        self._op_kwargs = op_kwargs
        self._input_token = input_token
        self._output_token = output_token
        self._more_results = more_results
        self._result_keys = result_keys
        self._max_items = max_items
        self._limit_key = limit_key
        self._starting_token = starting_token
        self._page_size = page_size
        self._op_kwargs = op_kwargs
        self._resume_token = None
        self._non_aggregate_key_exprs = non_aggregate_keys
        self._non_aggregate_part = {}

    @property
    def result_keys(self):
        return self._result_keys

    @property
    def resume_token(self):
        """Token to specify to resume pagination."""
        return self._resume_token

    @resume_token.setter
    def resume_token(self, value):
        if not isinstance(value, dict):
            raise ValueError("Bad starting token: %s" % value)

        if 'boto_truncate_amount' in value:
            token_keys = sorted(self._input_token + ['boto_truncate_amount'])
        else:
            token_keys = sorted(self._input_token)
        dict_keys = sorted(value.keys())

        if token_keys == dict_keys:
            self._resume_token = base64.b64encode(
                json.dumps(value).encode('utf-8')).decode('utf-8')
        else:
            raise ValueError("Bad starting token: %s" % value)

    @property
    def non_aggregate_part(self):
        return self._non_aggregate_part

    def __iter__(self):
        current_kwargs = self._op_kwargs
        previous_next_token = None
        next_token = dict((key, None) for key in self._input_token)
        # The number of items from result_key we've seen so far.
        total_items = 0
        first_request = True
        primary_result_key = self.result_keys[0]
        starting_truncation = 0
        self._inject_starting_params(current_kwargs)
        while True:
            response = self._make_request(current_kwargs)
            parsed = self._extract_parsed_response(response)
            if first_request:
                # The first request is handled differently.  We could
                # possibly have a resume/starting token that tells us where
                # to index into the retrieved page.
                if self._starting_token is not None:
                    starting_truncation = self._handle_first_request(
                        parsed, primary_result_key, starting_truncation)
                first_request = False
                self._record_non_aggregate_key_values(parsed)
            current_response = primary_result_key.search(parsed)
            if current_response is None:
                current_response = []
            num_current_response = len(current_response)
            truncate_amount = 0
            if self._max_items is not None:
                truncate_amount = (total_items + num_current_response) \
                                  - self._max_items
            if truncate_amount > 0:
                self._truncate_response(parsed, primary_result_key,
                                        truncate_amount, starting_truncation,
                                        next_token)
                yield response
                break
            else:
                yield response
                total_items += num_current_response
                next_token = self._get_next_token(parsed)
                if all(t is None for t in next_token.values()):
                    break
                if self._max_items is not None and \
                                total_items == self._max_items:
                    # We're on a page boundary so we can set the current
                    # next token to be the resume token.
                    self.resume_token = next_token
                    break
                if previous_next_token is not None and \
                                previous_next_token == next_token:
                    message = ("The same next token was received "
                               "twice: %s" % next_token)
                    raise PaginationError(message=message)
                self._inject_token_into_kwargs(current_kwargs, next_token)
                previous_next_token = next_token

    def search(self, expression):
        """Applies a JMESPath expression to a paginator

        Each page of results is searched using the provided JMESPath
        expression. If the result is not a list, it is yielded
        directly. If the result is a list, each element in the result
        is yielded individually (essentially implementing a flatmap in
        which the JMESPath search is the mapping function).

        :type expression: str
        :param expression: JMESPath expression to apply to each page.

        :return: Returns an iterator that yields the individual
            elements of applying a JMESPath expression to each page of
            results.
        """
        compiled = jmespath.compile(expression)
        for page in self:
            results = compiled.search(page)
            if isinstance(results, list):
                for element in results:
                    yield element
            else:
                # Yield result directly if it is not a list.
                yield results

    def _make_request(self, current_kwargs):
        return self._method(**current_kwargs)

    def _extract_parsed_response(self, response):
        return response

    def _record_non_aggregate_key_values(self, response):
        non_aggregate_keys = {}
        for expression in self._non_aggregate_key_exprs:
            result = expression.search(response)
            set_value_from_jmespath(non_aggregate_keys,
                                    expression.expression,
                                    result)
        self._non_aggregate_part = non_aggregate_keys

    def _inject_starting_params(self, op_kwargs):
        # If the user has specified a starting token we need to
        # inject that into the operation's kwargs.
        if self._starting_token is not None:
            # Don't need to do anything special if there is no starting
            # token specified.
            next_token = self._parse_starting_token()[0]
            self._inject_token_into_kwargs(op_kwargs, next_token)
        if self._page_size is not None:
            # Pass the page size as the parameter name for limiting
            # page size, also known as the limit_key.
            op_kwargs[self._limit_key] = self._page_size

    def _inject_token_into_kwargs(self, op_kwargs, next_token):
        for name, token in next_token.items():
            if token is None or token == 'None':
                continue
            op_kwargs[name] = token

    def _handle_first_request(self, parsed, primary_result_key,
                              starting_truncation):
        # If the payload is an array or string, we need to slice into it
        # and only return the truncated amount.
        starting_truncation = self._parse_starting_token()[1]
        all_data = primary_result_key.search(parsed)
        if isinstance(all_data, (list, string_types)):
            data = all_data[starting_truncation:]
        else:
            data = None
        set_value_from_jmespath(
            parsed,
            primary_result_key.expression,
            data
        )
        # We also need to truncate any secondary result keys
        # because they were not truncated in the previous last
        # response.
        for token in self.result_keys:
            if token == primary_result_key:
                continue
            sample = token.search(parsed)
            if isinstance(sample, list):
                empty_value = []
            elif isinstance(sample, string_types):
                empty_value = ''
            elif isinstance(sample, (int, float)):
                empty_value = 0
            else:
                empty_value = None
            set_value_from_jmespath(parsed, token.expression, empty_value)
        return starting_truncation

    def _truncate_response(self, parsed, primary_result_key, truncate_amount,
                           starting_truncation, next_token):
        original = primary_result_key.search(parsed)
        if original is None:
            original = []
        amount_to_keep = len(original) - truncate_amount
        truncated = original[:amount_to_keep]
        set_value_from_jmespath(
            parsed,
            primary_result_key.expression,
            truncated
        )
        # The issue here is that even though we know how much we've truncated
        # we need to account for this globally including any starting
        # left truncation. For example:
        # Raw response: [0,1,2,3]
        # Starting index: 1
        # Max items: 1
        # Starting left truncation: [1, 2, 3]
        # End right truncation for max items: [1]
        # However, even though we only kept 1, this is post
        # left truncation so the next starting index should be 2, not 1
        # (left_truncation + amount_to_keep).
        next_token['boto_truncate_amount'] = \
            amount_to_keep + starting_truncation
        self.resume_token = next_token

    def _get_next_token(self, parsed):
        if self._more_results is not None:
            if not self._more_results.search(parsed):
                return {}
        next_tokens = {}
        for output_token, input_key in \
                zip(self._output_token, self._input_token):
            next_token = output_token.search(parsed)
            # We do not want to include any empty strings as actual tokens.
            # Treat them as None.
            if next_token:
                next_tokens[input_key] = next_token
            else:
                next_tokens[input_key] = None
        return next_tokens

    def result_key_iters(self):
        teed_results = tee(self, len(self.result_keys))
        return [ResultKeyIterator(i, result_key) for i, result_key
                in zip(teed_results, self.result_keys)]

    def build_full_result(self):
        complete_result = {}
        for response in self:
            page = response
            # We want to try to catch operation object pagination
            # and format correctly for those. They come in the form
            # of a tuple of two elements: (http_response, parsed_responsed).
            # We want the parsed_response as that is what the page iterator
            # uses. We can remove it though once operation objects are removed.
            if isinstance(response, tuple) and len(response) == 2:
                page = response[1]
            # We're incrementally building the full response page
            # by page.  For each page in the response we need to
            # inject the necessary components from the page
            # into the complete_result.
            for result_expression in self.result_keys:
                # In order to incrementally update a result key
                # we need to search the existing value from complete_result,
                # then we need to search the _current_ page for the
                # current result key value.  Then we append the current
                # value onto the existing value, and re-set that value
                # as the new value.
                result_value = result_expression.search(page)
                if result_value is None:
                    continue
                existing_value = result_expression.search(complete_result)
                if existing_value is None:
                    # Set the initial result
                    set_value_from_jmespath(
                        complete_result, result_expression.expression,
                        result_value)
                    continue
                # Now both result_value and existing_value contain something
                if isinstance(result_value, list):
                    existing_value.extend(result_value)
                elif isinstance(result_value, (int, float, string_types)):
                    # Modify the existing result with the sum or concatenation
                    set_value_from_jmespath(
                        complete_result, result_expression.expression,
                        existing_value + result_value)
        merge_dicts(complete_result, self.non_aggregate_part)
        if self.resume_token is not None:
            complete_result['NextToken'] = self.resume_token
        return complete_result

    def _parse_starting_token(self):
        if self._starting_token is None:
            return None

        # The starting token is a dict passed as a base64 encoded string.
        next_token = self._starting_token
        try:
            next_token = json.loads(
                base64.b64decode(next_token).decode('utf-8'))
            index = 0
            if 'boto_truncate_amount' in next_token:
                index = next_token.get('boto_truncate_amount')
                del next_token['boto_truncate_amount']
        except (ValueError, TypeError):
            raise ValueError("Bad starting token: %s" % self._starting_token)
        return next_token, index


class Paginator(object):
    PAGE_ITERATOR_CLS = PageIterator

    def __init__(self, method, pagination_config):
        self._method = method
        self._pagination_cfg = pagination_config
        self._output_token = self._get_output_tokens(self._pagination_cfg)
        self._input_token = self._get_input_tokens(self._pagination_cfg)
        self._more_results = self._get_more_results_token(self._pagination_cfg)
        self._non_aggregate_keys = self._get_non_aggregate_keys(
            self._pagination_cfg)
        self._result_keys = self._get_result_keys(self._pagination_cfg)
        self._limit_key = self._get_limit_key(self._pagination_cfg)

    @property
    def result_keys(self):
        return self._result_keys

    def _get_non_aggregate_keys(self, config):
        keys = []
        for key in config.get('non_aggregate_keys', []):
            keys.append(jmespath.compile(key))
        return keys

    def _get_output_tokens(self, config):
        output = []
        output_token = config['output_token']
        if not isinstance(output_token, list):
            output_token = [output_token]
        for config in output_token:
            output.append(jmespath.compile(config))
        return output

    def _get_input_tokens(self, config):
        input_token = self._pagination_cfg['input_token']
        if not isinstance(input_token, list):
            input_token = [input_token]
        return input_token

    def _get_more_results_token(self, config):
        more_results = config.get('more_results')
        if more_results is not None:
            return jmespath.compile(more_results)

    def _get_result_keys(self, config):
        result_key = config.get('result_key')
        if result_key is not None:
            if not isinstance(result_key, list):
                result_key = [result_key]
            result_key = [jmespath.compile(rk) for rk in result_key]
            return result_key

    def _get_limit_key(self, config):
        return config.get('limit_key')

    def paginate(self, **kwargs):
        """Create paginator object for an operation.

        This returns an iterable object.  Iterating over
        this object will yield a single page of a response
        at a time.

        """
        page_params = self._extract_paging_params(kwargs)
        return self.PAGE_ITERATOR_CLS(
            self._method, self._input_token,
            self._output_token, self._more_results,
            self._result_keys, self._non_aggregate_keys,
            self._limit_key,
            page_params['MaxItems'],
            page_params['StartingToken'],
            page_params['PageSize'],
            kwargs)

    def _extract_paging_params(self, kwargs):
        pagination_config = kwargs.pop('PaginationConfig', {})
        max_items = pagination_config.get('MaxItems', None)
        if max_items is not None:
            max_items = int(max_items)
        page_size = pagination_config.get('PageSize', None)
        if page_size is not None:
            page_size = int(page_size)
        return {
            'MaxItems': max_items,
            'StartingToken': pagination_config.get('StartingToken', None),
            'PageSize': page_size,
        }


class ResultKeyIterator(object):
    """Iterates over the results of paginated responses.

    Each iterator is associated with a single result key.
    Iterating over this object will give you each element in
    the result key list.

    :param pages_iterator: An iterator that will give you
        pages of results (a ``PageIterator`` class).
    :param result_key: The JMESPath expression representing
        the result key.

    """

    def __init__(self, pages_iterator, result_key):
        self._pages_iterator = pages_iterator
        self.result_key = result_key

    def __iter__(self):
        for page in self._pages_iterator:
            results = self.result_key.search(page)
            if results is None:
                results = []
            for result in results:
                yield result
                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/paginate.pyc                                         0100644 0000000 0000062 00000034244 13077704401 022350  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  d l  m Z d  d l m Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l	 m
 Z
 d  d l m Z m Z d e f d     YZ d	 e f d
     YZ d e f d     YZ d e f d     YZ d S(   i(   t   tee(   t   string_typesN(   t   PaginationError(   t   zip(   t   set_value_from_jmespatht   merge_dictst   PaginatorModelc           B   s   e  Z d    Z d   Z RS(   c         C   s   | d |  _  d  S(   Nt
   pagination(   t   _paginator_config(   t   selft   paginator_config(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   __init__   s    c         C   s9   y |  j  | } Wn! t k
 r4 t d |   n X| S(   Ns*   Paginator for operation does not exist: %s(   R   t   KeyErrort
   ValueError(   R	   t   operation_namet   single_paginator_config(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   get_paginator   s    (   t   __name__t
   __module__R   R   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR      s   	t   PageIteratorc           B   s   e  Z d    Z e d    Z e d    Z e j d    Z e d    Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z RS(   c         C   s   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ |	 |  _ |
 |  _	 | |  _ d  |  _ | |  _ i  |  _ d  S(   N(   t   _methodt
   _op_kwargst   _input_tokent   _output_tokent   _more_resultst   _result_keyst
   _max_itemst
   _limit_keyt   _starting_tokent
   _page_sizet   Nonet   _resume_tokent   _non_aggregate_key_exprst   _non_aggregate_part(   R	   t   methodt   input_tokent   output_tokent   more_resultst   result_keyst   non_aggregate_keyst	   limit_keyt	   max_itemst   starting_tokent	   page_sizet	   op_kwargs(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   (   s    													c         C   s   |  j  S(   N(   R   (   R	   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR&   :   s    c         C   s   |  j  S(   s&   Token to specify to resume pagination.(   R   (   R	   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   resume_token>   s    c         C   s   t  | t  s" t d |   n  d | k rG t |  j d g  } n t |  j  } t | j    } | | k r t j t j	 |  j
 d   j d  |  _ n t d |   d  S(   Ns   Bad starting token: %st   boto_truncate_amounts   utf-8(   t
   isinstancet   dictR   t   sortedR   t   keyst   base64t	   b64encodet   jsont   dumpst   encodet   decodeR   (   R	   t   valuet
   token_keyst	   dict_keys(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR-   C   s    *c         C   s   |  j  S(   N(   R!   (   R	   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   non_aggregate_partT   s    c         c   s   |  j  } d  } t d   |  j D  } d } t } |  j d } d } |  j |  xt r|  j |  } |  j |  }	 | r |  j	 d  k	 r |  j
 |	 | |  } n  t } |  j |	  n  | j |	  }
 |
 d  k r g  }
 n  t |
  } d } |  j d  k	 r| | |  j } n  | d k rE|  j |	 | | | |  | VPqW | V| | 7} |  j |	  } t d   | j   D  rPn  |  j d  k	 r| |  j k r| |  _ Pn  | d  k	 r| | k rd | } t d |   n  |  j | |  | } qW Wd  S(   Nc         s   s   |  ] } | d  f Vq d  S(   N(   R   (   t   .0t   key(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pys	   <genexpr>[   s    i    c         s   s   |  ] } | d  k Vq d  S(   N(   R   (   R=   t   t(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pys	   <genexpr>   s    s*   The same next token was received twice: %st   message(   R   R   R0   R   t   TrueR&   t   _inject_starting_paramst   _make_requestt   _extract_parsed_responseR   t   _handle_first_requestt   Falset    _record_non_aggregate_key_valuest   searcht   lenR   t   _truncate_responset   _get_next_tokent   allt   valuesR-   R   t   _inject_token_into_kwargs(   R	   t   current_kwargst   previous_next_tokent
   next_tokent   total_itemst   first_requestt   primary_result_keyt   starting_truncationt   responset   parsedt   current_responset   num_current_responset   truncate_amountR@   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   __iter__X   s^    			
	c         c   s`   t  j |  } xJ |  D]B } | j |  } t | t  rS x | D] } | VqA Wq | Vq Wd S(   s  Applies a JMESPath expression to a paginator

        Each page of results is searched using the provided JMESPath
        expression. If the result is not a list, it is yielded
        directly. If the result is a list, each element in the result
        is yielded individually (essentially implementing a flatmap in
        which the JMESPath search is the mapping function).

        :type expression: str
        :param expression: JMESPath expression to apply to each page.

        :return: Returns an iterator that yields the individual
            elements of applying a JMESPath expression to each page of
            results.
        N(   t   jmespatht   compileRH   R/   t   list(   R	   t
   expressiont   compiledt   paget   resultst   element(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRH      s    c         C   s   |  j  |   S(   N(   R   (   R	   RO   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRC      s    c         C   s   | S(   N(    (   R	   RV   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRD      s    c         C   sI   i  } x3 |  j  D]( } | j |  } t | | j |  q W| |  _ d  S(   N(   R    RH   R   R_   R!   (   R	   RV   R'   R_   t   result(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRG      s    c         C   sX   |  j  d  k	 r2 |  j   d } |  j | |  n  |  j d  k	 rT |  j | |  j <n  d  S(   Ni    (   R   R   t   _parse_starting_tokenRN   R   R   (   R	   R,   RQ   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRB      s
    c         C   sI   xB | j    D]4 \ } } | d  k s | d k r7 q n  | | | <q Wd  S(   NR   (   t   itemsR   (   R	   R,   RQ   t   namet   token(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRN      s    c   	      C   s   |  j    d } | j |  } t | t t f  rA | | } n d  } t | | j |  x |  j D] } | | k r| qd n  | j |  } t | t  r g  } n< t | t  r d } n$ t | t	 t
 f  r d } n d  } t | | j |  qd W| S(   Ni   t    i    (   Re   RH   R/   R^   R   R   R   R_   R&   t   intt   float(	   R	   RW   RT   RU   t   all_datat   dataRh   t   samplet   empty_value(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRE      s,    			c   	      C   sl   | j  |  } | d  k r$ g  } n  t |  | } | |  } t | | j |  | | | d <| |  _ d  S(   NR.   (   RH   R   RI   R   R_   R-   (	   R	   RW   RT   RZ   RU   RQ   t   originalt   amount_to_keept	   truncated(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRJ      s    	
c         C   s   |  j  d  k	 r( |  j  j |  s( i  Sn  i  } xO t |  j |  j  D]8 \ } } | j |  } | rr | | | <qD d  | | <qD W| S(   N(   R   R   RH   R   R   R   (   R	   RW   t   next_tokensR$   t	   input_keyRQ   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRK     s    c         C   sJ   t  |  t |  j   } g  t | |  j  D] \ } } t | |  ^ q+ S(   N(   R    RI   R&   R   t   ResultKeyIterator(   R	   t   teed_resultst   it
   result_key(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   result_key_iters  s    c         C   s8  i  } x |  D] } | } t  | t  rG t |  d k rG | d } n  x |  j D] } | j |  } | d  k rx qQ n  | j |  } | d  k r t | | j |  qQ n  t  | t  r | j	 |  qQ t  | t
 t t f  rQ t | | j | |  qQ qQ Wq Wt | |  j  |  j d  k	 r4|  j | d <n  | S(   Ni   i   t	   NextToken(   R/   t   tupleRI   R&   RH   R   R   R_   R^   t   extendRj   Rk   R   R   R<   R-   (   R	   t   complete_resultRV   Ra   t   result_expressiont   result_valuet   existing_value(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   build_full_result  s2    !		c         C   s   |  j  d  k r d  S|  j  } yP t j t j |  j d   } d } d | k rk | j d  } | d =n  Wn* t t	 f k
 r t d |  j    n X| | f S(   Ns   utf-8i    R.   s   Bad starting token: %s(
   R   R   R5   t   loadsR3   t	   b64decodeR8   t   getR   t	   TypeError(   R	   RQ   t   index(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRe   J  s    	(   R   R   R   t   propertyR&   R-   t   setterR<   R[   RH   RC   RD   RG   RB   RN   RE   RJ   RK   Ry   R   Re   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   '   s$   		8								!				-t	   Paginatorc           B   sn   e  Z e Z d    Z e d    Z d   Z d   Z d   Z	 d   Z
 d   Z d   Z d   Z d	   Z RS(
   c         C   s   | |  _  | |  _ |  j |  j  |  _ |  j |  j  |  _ |  j |  j  |  _ |  j |  j  |  _	 |  j
 |  j  |  _ |  j |  j  |  _ d  S(   N(   R   t   _pagination_cfgt   _get_output_tokensR   t   _get_input_tokensR   t   _get_more_results_tokenR   t   _get_non_aggregate_keyst   _non_aggregate_keyst   _get_result_keysR   t   _get_limit_keyR   (   R	   R"   t   pagination_config(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   _  s    		c         C   s   |  j  S(   N(   R   (   R	   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR&   j  s    c         C   s=   g  } x0 | j  d g   D] } | j t j |   q W| S(   NR'   (   R   t   appendR\   R]   (   R	   t   configR2   R>   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   n  s    c         C   sV   g  } | d } t  | t  s+ | g } n  x$ | D] } | j t j |   q2 W| S(   NR$   (   R/   R^   R   R\   R]   (   R	   R   t   outputR$   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   t  s    
c         C   s,   |  j  d } t | t  s( | g } n  | S(   NR#   (   R   R/   R^   (   R	   R   R#   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   }  s    c         C   s,   | j  d  } | d  k	 r( t j |  Sd  S(   NR%   (   R   R   R\   R]   (   R	   R   R%   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR     s    c         C   s`   | j  d  } | d  k	 r\ t | t  s6 | g } n  g  | D] } t j |  ^ q= } | Sd  S(   NRx   (   R   R   R/   R^   R\   R]   (   R	   R   Rx   t   rk(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR     s    "c         C   s   | j  d  S(   NR(   (   R   (   R	   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR     s    c         K   s[   |  j  |  } |  j |  j |  j |  j |  j |  j |  j |  j | d | d | d |  S(   s   Create paginator object for an operation.

        This returns an iterable object.  Iterating over
        this object will yield a single page of a response
        at a time.

        t   MaxItemst   StartingTokent   PageSize(	   t   _extract_paging_paramst   PAGE_ITERATOR_CLSR   R   R   R   R   R   R   (   R	   t   kwargst   page_params(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   paginate  s    c         C   s   | j  d i   } | j d d   } | d  k	 r? t |  } n  | j d d   } | d  k	 rl t |  } n  i | d 6| j d d   d 6| d 6S(   Nt   PaginationConfigR   R   R   (   t   popR   R   Rj   (   R	   R   R   R)   R+   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR     s    (   R   R   R   R   R   R   R&   R   R   R   R   R   R   R   R   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR   \  s   									Ru   c           B   s    e  Z d  Z d   Z d   Z RS(   s  Iterates over the results of paginated responses.

    Each iterator is associated with a single result key.
    Iterating over this object will give you each element in
    the result key list.

    :param pages_iterator: An iterator that will give you
        pages of results (a ``PageIterator`` class).
    :param result_key: The JMESPath expression representing
        the result key.

    c         C   s   | |  _  | |  _ d  S(   N(   t   _pages_iteratorRx   (   R	   t   pages_iteratorRx   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR     s    	c         c   sU   xN |  j  D]C } |  j j |  } | d  k r7 g  } n  x | D] } | Vq> Wq
 Wd  S(   N(   R   Rx   RH   R   (   R	   Ra   Rb   Rd   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyR[     s    	(   R   R   t   __doc__R   R[   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyRu     s   	(   t	   itertoolsR    t   sixR   R\   R5   R3   t   botocore.exceptionsR   t   botocore.compatR   t   botocore.utilsR   R   t   objectR   R   R   Ru   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/paginate.pyt   <module>   s    6Y                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/botocore/parsers.py                                           0100644 0000000 0000062 00000072676 13077704371 022115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
"""Response parsers for the various protocol types.

The module contains classes that can take an HTTP response, and given
an output shape, parse the response into a dict according to the
rules in the output shape.

There are many similarities amongst the different protocols with regard
to response parsing, and the code is structured in a way to avoid
code duplication when possible.  The diagram below is a diagram
showing the inheritance hierarchy of the response classes.

::



                                 +--------------+
                                 |ResponseParser|
                                 +--------------+
                                    ^    ^    ^
               +--------------------+    |    +-------------------+
               |                         |                        |
    +----------+----------+       +------+-------+        +-------+------+
    |BaseXMLResponseParser|       |BaseRestParser|        |BaseJSONParser|
    +---------------------+       +--------------+        +--------------+
              ^         ^          ^           ^           ^        ^
              |         |          |           |           |        |
              |         |          |           |           |        |
              |        ++----------+-+       +-+-----------++       |
              |        |RestXMLParser|       |RestJSONParser|       |
        +-----+-----+  +-------------+       +--------------+  +----+-----+
        |QueryParser|                                          |JSONParser|
        +-----------+                                          +----------+


The diagram above shows that there is a base class, ``ResponseParser`` that
contains logic that is similar amongst all the different protocols (``query``,
``json``, ``rest-json``, ``rest-xml``).  Amongst the various services there
is shared logic that can be grouped several ways:

* The ``query`` and ``rest-xml`` both have XML bodies that are parsed in the
  same way.
* The ``json`` and ``rest-json`` protocols both have JSON bodies that are
  parsed in the same way.
* The ``rest-json`` and ``rest-xml`` protocols have additional attributes
  besides body parameters that are parsed the same (headers, query string,
  status code).

This is reflected in the class diagram above.  The ``BaseXMLResponseParser``
and the BaseJSONParser contain logic for parsing the XML/JSON body,
and the BaseRestParser contains logic for parsing out attributes that
come from other parts of the HTTP response.  Classes like the
``RestXMLParser`` inherit from the ``BaseXMLResponseParser`` to get the
XML body parsing logic and the ``BaseRestParser`` to get the HTTP
header/status code/query string parsing.

Return Values
=============

Each call to ``parse()`` returns a dict has this form::

    Standard Response

    {
      "ResponseMetadata": {"RequestId": <requestid>}
      <response keys>
    }

    Error response

    {
      "ResponseMetadata": {"RequestId": <requestid>}
      "Error": {
        "Code": <string>,
        "Message": <string>,
        "Type": <string>,
        <additional keys>
      }
    }

"""
import re
import base64
import json
import xml.etree.cElementTree
import logging

from botocore.compat import six, XMLParseError

from botocore.utils import parse_timestamp, merge_dicts

LOG = logging.getLogger(__name__)

DEFAULT_TIMESTAMP_PARSER = parse_timestamp


class ResponseParserFactory(object):
    def __init__(self):
        self._defaults = {}

    def set_parser_defaults(self, **kwargs):
        """Set default arguments when a parser instance is created.

        You can specify any kwargs that are allowed by a ResponseParser
        class.  There are currently two arguments:

            * timestamp_parser - A callable that can parse a timetsamp string
            * blob_parser - A callable that can parse a blob type

        """
        self._defaults.update(kwargs)

    def create_parser(self, protocol_name):
        parser_cls = PROTOCOL_PARSERS[protocol_name]
        return parser_cls(**self._defaults)


def create_parser(protocol):
    return ResponseParserFactory().create_parser(protocol)


def _text_content(func):
    # This decorator hides the difference between
    # an XML node with text or a plain string.  It's used
    # to ensure that scalar processing operates only on text
    # strings, which allows the same scalar handlers to be used
    # for XML nodes from the body and HTTP headers.
    def _get_text_content(self, shape, node_or_string):
        if hasattr(node_or_string, 'text'):
            text = node_or_string.text
            if text is None:
                # If an XML node is empty <foo></foo>,
                # we want to parse that as an empty string,
                # not as a null/None value.
                text = ''
        else:
            text = node_or_string
        return func(self, shape, text)
    return _get_text_content


class ResponseParserError(Exception):
    pass


class ResponseParser(object):
    """Base class for response parsing.

    This class represents the interface that all ResponseParsers for the
    various protocols must implement.

    This class will take an HTTP response and a model shape and parse the
    HTTP response into a dictionary.

    There is a single public method exposed: ``parse``.  See the ``parse``
    docstring for more info.

    """
    DEFAULT_ENCODING = 'utf-8'

    def __init__(self, timestamp_parser=None, blob_parser=None):
        if timestamp_parser is None:
            timestamp_parser = DEFAULT_TIMESTAMP_PARSER
        self._timestamp_parser = timestamp_parser
        if blob_parser is None:
            blob_parser = self._default_blob_parser
        self._blob_parser = blob_parser

    def _default_blob_parser(self, value):
        # Blobs are always returned as bytes type (this matters on python3).
        # We don't decode this to a str because it's entirely possible that the
        # blob contains binary data that actually can't be decoded.
        return base64.b64decode(value)

    def parse(self, response, shape):
        """Parse the HTTP response given a shape.

        :param response: The HTTP response dictionary.  This is a dictionary
            that represents the HTTP request.  The dictionary must have the
            following keys, ``body``, ``headers``, and ``status_code``.

        :param shape: The model shape describing the expected output.
        :return: Returns a dictionary representing the parsed response
            described by the model.  In addition to the shape described from
            the model, each response will also have a ``ResponseMetadata``
            which contains metadata about the response, which contains at least
            two keys containing ``RequestId`` and ``HTTPStatusCode``.  Some
            responses may populate additional keys, but ``RequestId`` will
            always be present.

        """
        LOG.debug('Response headers: %s', response['headers'])
        LOG.debug('Response body:\n%s', response['body'])
        if response['status_code'] >= 301:
            parsed = self._do_error_parse(response, shape)
        else:
            parsed = self._do_parse(response, shape)
        # Inject HTTPStatusCode key in the response metadata if the
        # response metadata exists.
        if isinstance(parsed, dict) and 'ResponseMetadata' in parsed:
            parsed['ResponseMetadata']['HTTPStatusCode'] = (
                response['status_code'])
        return parsed

    def _do_parse(self, response, shape):
        raise NotImplementedError("%s._do_parse" % self.__class__.__name__)

    def _do_error_parse(self, response, shape):
        raise NotImplementedError(
            "%s._do_error_parse" % self.__class__.__name__)

    def _parse_shape(self, shape, node):
        handler = getattr(self, '_handle_%s' % shape.type_name,
                          self._default_handle)
        return handler(shape, node)

    def _handle_list(self, shape, node):
        # Enough implementations share list serialization that it's moved
        # up here in the base class.
        parsed = []
        member_shape = shape.member
        for item in node:
            parsed.append(self._parse_shape(member_shape, item))
        return parsed

    def _default_handle(self, shape, value):
        return value


class BaseXMLResponseParser(ResponseParser):
    def __init__(self, timestamp_parser=None, blob_parser=None):
        super(BaseXMLResponseParser, self).__init__(timestamp_parser,
                                                    blob_parser)
        self._namespace_re = re.compile('{.*}')

    def _handle_map(self, shape, node):
        parsed = {}
        key_shape = shape.key
        value_shape = shape.value
        key_location_name = key_shape.serialization.get('name') or 'key'
        value_location_name = value_shape.serialization.get('name') or 'value'
        if shape.serialization.get('flattened') and not isinstance(node, list):
            node = [node]
        for keyval_node in node:
            for single_pair in keyval_node:
                # Within each <entry> there's a <key> and a <value>
                tag_name = self._node_tag(single_pair)
                if tag_name == key_location_name:
                    key_name = self._parse_shape(key_shape, single_pair)
                elif tag_name == value_location_name:
                    val_name = self._parse_shape(value_shape, single_pair)
                else:
                    raise ResponseParserError("Unknown tag: %s" % tag_name)
            parsed[key_name] = val_name
        return parsed

    def _node_tag(self, node):
        return self._namespace_re.sub('', node.tag)

    def _handle_list(self, shape, node):
        # When we use _build_name_to_xml_node, repeated elements are aggregated
        # into a list.  However, we can't tell the difference between a scalar
        # value and a single element flattened list.  So before calling the
        # real _handle_list, we know that "node" should actually be a list if
        # it's flattened, and if it's not, then we make it a one element list.
        if shape.serialization.get('flattened') and not isinstance(node, list):
            node = [node]
        return super(BaseXMLResponseParser, self)._handle_list(shape, node)

    def _handle_structure(self, shape, node):
        parsed = {}
        members = shape.members
        xml_dict = self._build_name_to_xml_node(node)
        for member_name in members:
            member_shape = members[member_name]
            if 'location' in member_shape.serialization:
                # All members with locations have already been handled,
                # so we don't need to parse these members.
                continue
            xml_name = self._member_key_name(member_shape, member_name)
            member_node = xml_dict.get(xml_name)
            if member_node is not None:
                parsed[member_name] = self._parse_shape(
                    member_shape, member_node)
            elif member_shape.serialization.get('xmlAttribute'):
                attribs = {}
                location_name = member_shape.serialization['name']
                for key, value in node.attrib.items():
                    new_key = self._namespace_re.sub(
                        location_name.split(':')[0] + ':', key)
                    attribs[new_key] = value
                if location_name in attribs:
                    parsed[member_name] = attribs[location_name]
        return parsed

    def _member_key_name(self, shape, member_name):
        # This method is needed because we have to special case flattened list
        # with a serialization name.  If this is the case we use the
        # locationName from the list's member shape as the key name for the
        # surrounding structure.
        if shape.type_name == 'list' and shape.serialization.get('flattened'):
            list_member_serialized_name = shape.member.serialization.get(
                'name')
            if list_member_serialized_name is not None:
                return list_member_serialized_name
        serialized_name = shape.serialization.get('name')
        if serialized_name is not None:
            return serialized_name
        return member_name

    def _build_name_to_xml_node(self, parent_node):
        # If the parent node is actually a list. We should not be trying
        # to serialize it to a dictionary. Instead, return the first element
        # in the list.
        if isinstance(parent_node, list):
            return self._build_name_to_xml_node(parent_node[0])
        xml_dict = {}
        for item in parent_node:
            key = self._node_tag(item)
            if key in xml_dict:
                # If the key already exists, the most natural
                # way to handle this is to aggregate repeated
                # keys into a single list.
                # <foo>1</foo><foo>2</foo> -> {'foo': [Node(1), Node(2)]}
                if isinstance(xml_dict[key], list):
                    xml_dict[key].append(item)
                else:
                    # Convert from a scalar to a list.
                    xml_dict[key] = [xml_dict[key], item]
            else:
                xml_dict[key] = item
        return xml_dict

    def _parse_xml_string_to_dom(self, xml_string):
        try:
            parser = xml.etree.cElementTree.XMLParser(
                target=xml.etree.cElementTree.TreeBuilder(),
                encoding=self.DEFAULT_ENCODING)
            parser.feed(xml_string)
            root = parser.close()
        except XMLParseError as e:
            raise ResponseParserError(
                "Unable to parse response (%s), "
                "invalid XML received:\n%s" % (e, xml_string))
        return root

    def _replace_nodes(self, parsed):
        for key, value in parsed.items():
            if value.getchildren():
                sub_dict = self._build_name_to_xml_node(value)
                parsed[key] = self._replace_nodes(sub_dict)
            else:
                parsed[key] = value.text
        return parsed

    @_text_content
    def _handle_boolean(self, shape, text):
        if text == 'true':
            return True
        else:
            return False

    @_text_content
    def _handle_float(self, shape, text):
        return float(text)

    @_text_content
    def _handle_timestamp(self, shape, text):
        return self._timestamp_parser(text)

    @_text_content
    def _handle_integer(self, shape, text):
        return int(text)

    @_text_content
    def _handle_string(self, shape, text):
        return text

    @_text_content
    def _handle_blob(self, shape, text):
        return self._blob_parser(text)

    _handle_character = _handle_string
    _handle_double = _handle_float
    _handle_long = _handle_integer


class QueryParser(BaseXMLResponseParser):

    def _do_error_parse(self, response, shape):
        xml_contents = response['body']
        root = self._parse_xml_string_to_dom(xml_contents)
        parsed = self._build_name_to_xml_node(root)
        self._replace_nodes(parsed)
        # Once we've converted xml->dict, we need to make one or two
        # more adjustments to extract nested errors and to be consistent
        # with ResponseMetadata for non-error responses:
        # 1. {"Errors": {"Error": {...}}} -> {"Error": {...}}
        # 2. {"RequestId": "id"} -> {"ResponseMetadata": {"RequestId": "id"}}
        if 'Errors' in parsed:
            parsed.update(parsed.pop('Errors'))
        if 'RequestId' in parsed:
            parsed['ResponseMetadata'] = {'RequestId': parsed.pop('RequestId')}
        return parsed

    def _do_parse(self, response, shape):
        xml_contents = response['body']
        root = self._parse_xml_string_to_dom(xml_contents)
        parsed = {}
        if shape is not None:
            start = root
            if 'resultWrapper' in shape.serialization:
                start = self._find_result_wrapped_shape(
                    shape.serialization['resultWrapper'],
                    root)
            parsed = self._parse_shape(shape, start)
        self._inject_response_metadata(root, parsed)
        return parsed

    def _find_result_wrapped_shape(self, element_name, xml_root_node):
        mapping = self._build_name_to_xml_node(xml_root_node)
        return mapping[element_name]

    def _inject_response_metadata(self, node, inject_into):
        mapping = self._build_name_to_xml_node(node)
        child_node = mapping.get('ResponseMetadata')
        if child_node is not None:
            sub_mapping = self._build_name_to_xml_node(child_node)
            for key, value in sub_mapping.items():
                sub_mapping[key] = value.text
            inject_into['ResponseMetadata'] = sub_mapping


class EC2QueryParser(QueryParser):

    def _inject_response_metadata(self, node, inject_into):
        mapping = self._build_name_to_xml_node(node)
        child_node = mapping.get('requestId')
        if child_node is not None:
            inject_into['ResponseMetadata'] = {'RequestId': child_node.text}

    def _do_error_parse(self, response, shape):
        # EC2 errors look like:
        # <Response>
        #   <Errors>
        #     <Error>
        #       <Code>InvalidInstanceID.Malformed</Code>
        #       <Message>Invalid id: "1343124"</Message>
        #     </Error>
        #   </Errors>
        #   <RequestID>12345</RequestID>
        # </Response>
        # This is different from QueryParser in that it's RequestID,
        # not RequestId
        original = super(EC2QueryParser, self)._do_error_parse(response, shape)
        original['ResponseMetadata'] = {
            'RequestId': original.pop('RequestID')
        }
        return original


class BaseJSONParser(ResponseParser):

    def _handle_structure(self, shape, value):
        member_shapes = shape.members
        if value is None:
            # If the comes across the wire as "null" (None in python),
            # we should be returning this unchanged, instead of as an
            # empty dict.
            return None
        final_parsed = {}
        for member_name in member_shapes:
            member_shape = member_shapes[member_name]
            json_name = member_shape.serialization.get('name', member_name)
            raw_value = value.get(json_name)
            if raw_value is not None:
                final_parsed[member_name] = self._parse_shape(
                    member_shapes[member_name],
                    raw_value)
        return final_parsed

    def _handle_map(self, shape, value):
        parsed = {}
        key_shape = shape.key
        value_shape = shape.value
        for key, value in value.items():
            actual_key = self._parse_shape(key_shape, key)
            actual_value = self._parse_shape(value_shape, value)
            parsed[actual_key] = actual_value
        return parsed

    def _handle_blob(self, shape, value):
        return self._blob_parser(value)

    def _handle_timestamp(self, shape, value):
        return self._timestamp_parser(value)

    def _do_error_parse(self, response, shape):
        body = self._parse_body_as_json(response['body'])
        error = {"Error": {"Message": '', "Code": ''}, "ResponseMetadata": {}}
        # Error responses can have slightly different structures for json.
        # The basic structure is:
        #
        # {"__type":"ConnectClientException",
        #  "message":"The error message."}

        # The error message can either come in the 'message' or 'Message' key
        # so we need to check for both.
        error['Error']['Message'] = body.get('message',
                                             body.get('Message', ''))
        code = body.get('__type')
        if code is not None:
            # code has a couple forms as well:
            # * "com.aws.dynamodb.vAPI#ProvisionedThroughputExceededException"
            # * "ResourceNotFoundException"
            if '#' in code:
                code = code.rsplit('#', 1)[1]
            error['Error']['Code'] = code
        self._inject_response_metadata(error, response['headers'])
        return error

    def _inject_response_metadata(self, parsed, headers):
        if 'x-amzn-requestid' in headers:
            parsed.setdefault('ResponseMetadata', {})['RequestId'] = (
                headers['x-amzn-requestid'])

    def _parse_body_as_json(self, body_contents):
        if not body_contents:
            return {}
        body = body_contents.decode(self.DEFAULT_ENCODING)
        original_parsed = json.loads(body)
        return original_parsed


class JSONParser(BaseJSONParser):
    """Response parse for the "json" protocol."""
    def _do_parse(self, response, shape):
        # The json.loads() gives us the primitive JSON types,
        # but we need to traverse the parsed JSON data to convert
        # to richer types (blobs, timestamps, etc.
        parsed = {}
        if shape is not None:
            original_parsed = self._parse_body_as_json(response['body'])
            parsed = self._parse_shape(shape, original_parsed)
        self._inject_response_metadata(parsed, response['headers'])
        return parsed


class BaseRestParser(ResponseParser):

    def _do_parse(self, response, shape):
        final_parsed = {}
        final_parsed['ResponseMetadata'] = self._populate_response_metadata(
            response)
        if shape is None:
            return final_parsed
        member_shapes = shape.members
        self._parse_non_payload_attrs(response, shape,
                                      member_shapes, final_parsed)
        self._parse_payload(response, shape, member_shapes, final_parsed)
        return final_parsed

    def _populate_response_metadata(self, response):
        metadata = {}
        headers = response['headers']
        if 'x-amzn-requestid' in headers:
            metadata['RequestId'] = headers['x-amzn-requestid']
        elif 'x-amz-request-id' in headers:
            metadata['RequestId'] = headers['x-amz-request-id']
            # HostId is what it's called whenver this value is returned
            # in an XML response body, so to be consistent, we'll always
            # call is HostId.
            metadata['HostId'] = headers.get('x-amz-id-2', '')
        return metadata

    def _parse_payload(self, response, shape, member_shapes, final_parsed):
        if 'payload' in shape.serialization:
            # If a payload is specified in the output shape, then only that
            # shape is used for the body payload.
            payload_member_name = shape.serialization['payload']
            body_shape = member_shapes[payload_member_name]
            if body_shape.type_name in ['string', 'blob']:
                # This is a stream
                body = response['body']
                if isinstance(body, bytes):
                    body = body.decode(self.DEFAULT_ENCODING)
                final_parsed[payload_member_name] = body
            else:
                original_parsed = self._initial_body_parse(response['body'])
                final_parsed[payload_member_name] = self._parse_shape(
                    body_shape, original_parsed)
        else:
            original_parsed = self._initial_body_parse(response['body'])
            body_parsed = self._parse_shape(shape, original_parsed)
            final_parsed.update(body_parsed)

    def _parse_non_payload_attrs(self, response, shape,
                                 member_shapes, final_parsed):
        headers = response['headers']
        for name in member_shapes:
            member_shape = member_shapes[name]
            location = member_shape.serialization.get('location')
            if location is None:
                continue
            elif location == 'statusCode':
                final_parsed[name] = self._parse_shape(
                    member_shape, response['status_code'])
            elif location == 'headers':
                final_parsed[name] = self._parse_header_map(member_shape,
                                                            headers)
            elif location == 'header':
                header_name = member_shape.serialization.get('name', name)
                if header_name in headers:
                    final_parsed[name] = self._parse_shape(
                        member_shape, headers[header_name])

    def _parse_header_map(self, shape, headers):
        # Note that headers are case insensitive, so we .lower()
        # all header names and header prefixes.
        parsed = {}
        prefix = shape.serialization.get('name', '').lower()
        for header_name in headers:
            if header_name.lower().startswith(prefix):
                # The key name inserted into the parsed hash
                # strips off the prefix.
                name = header_name[len(prefix):]
                parsed[name] = headers[header_name]
        return parsed

    def _initial_body_parse(self, body_contents):
        # This method should do the initial xml/json parsing of the
        # body.  We we still need to walk the parsed body in order
        # to convert types, but this method will do the first round
        # of parsing.
        raise NotImplementedError("_initial_body_parse")


class RestJSONParser(BaseRestParser, BaseJSONParser):

    def _initial_body_parse(self, body_contents):
        return self._parse_body_as_json(body_contents)

    def _do_error_parse(self, response, shape):
        error = super(RestJSONParser, self)._do_error_parse(response, shape)
        self._inject_error_code(error, response)
        return error

    def _inject_error_code(self, error, response):
        # The "Code" value can come from either a response
        # header or a value in the JSON body.
        body = self._initial_body_parse(response['body'])
        if 'x-amzn-errortype' in response['headers']:
            code = response['headers']['x-amzn-errortype']
            # Could be:
            # x-amzn-errortype: ValidationException:
            code = code.split(':')[0]
            error['Error']['Code'] = code
        elif 'code' in body or 'Code' in body:
            error['Error']['Code'] = body.get(
                'code', body.get('Code', ''))


class RestXMLParser(BaseRestParser, BaseXMLResponseParser):

    def _initial_body_parse(self, xml_string):
        if not xml_string:
            return xml.etree.cElementTree.Element('')
        return self._parse_xml_string_to_dom(xml_string)

    def _do_error_parse(self, response, shape):
        # We're trying to be service agnostic here, but S3 does have a slightly
        # different response structure for its errors compared to other
        # rest-xml serivces (route53/cloudfront).  We handle this by just
        # trying to parse both forms.
        # First:
        # <ErrorResponse xmlns="...">
        #   <Error>
        #     <Type>Sender</Type>
        #     <Code>InvalidInput</Code>
        #     <Message>Invalid resource type: foo</Message>
        #   </Error>
        #   <RequestId>request-id</RequestId>
        # </ErrorResponse>
        if response['body']:
            # If the body ends up being invalid xml, the xml parser should not
            # blow up. It should at least try to pull information about the
            # the error response from other sources like the HTTP status code.
            try:
                return self._parse_error_from_body(response)
            except ResponseParserError as e:
                LOG.debug(
                    'Exception caught when parsing error response body:',
                    exc_info=True)
        return self._parse_error_from_http_status(response)

    def _parse_error_from_http_status(self, response):
        return {
            'Error': {
                'Code': str(response['status_code']),
                'Message': six.moves.http_client.responses.get(
                    response['status_code'], ''),
            },
            'ResponseMetadata': {
                'RequestId': response['headers'].get('x-amz-request-id', ''),
                'HostId': response['headers'].get('x-amz-id-2', ''),
            }
        }

    def _parse_error_from_body(self, response):
        xml_contents = response['body']
        root = self._parse_xml_string_to_dom(xml_contents)
        parsed = self._build_name_to_xml_node(root)
        self._replace_nodes(parsed)
        if root.tag == 'Error':
            # This is an S3 error response.  First we'll populate the
            # response metadata.
            metadata = self._populate_response_metadata(response)
            # The RequestId and the HostId are already in the
            # ResponseMetadata, but are also duplicated in the XML
            # body.  We don't need these values in both places,
            # we'll just remove them from the parsed XML body.
            parsed.pop('RequestId', '')
            parsed.pop('HostId', '')
            return {'Error': parsed, 'ResponseMetadata': metadata}
        elif 'RequestId' in parsed:
            # Other rest-xml serivces:
            parsed['ResponseMetadata'] = {'RequestId': parsed.pop('RequestId')}
        default = {'Error': {'Message': '', 'Code': ''}}
        merge_dicts(default, parsed)
        return default


PROTOCOL_PARSERS = {
    'ec2': EC2QueryParser,
    'query': QueryParser,
    'json': JSONParser,
    'rest-json': RestJSONParser,
    'rest-xml': RestXMLParser,
}
                                                                  usr/local/lib/python2.7/dist-packages/botocore/parsers.pyc                                          0100644 0000000 0000062 00000061267 13077704401 022244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z m	 Z	 d d l
 m Z m Z e j e  Z e Z d e f d     YZ d   Z d   Z d	 e f d
     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e e f d     YZ d e e f d     YZ i e d 6e d 6e d 6e d  6e d! 6Z  d S("   s9  Response parsers for the various protocol types.

The module contains classes that can take an HTTP response, and given
an output shape, parse the response into a dict according to the
rules in the output shape.

There are many similarities amongst the different protocols with regard
to response parsing, and the code is structured in a way to avoid
code duplication when possible.  The diagram below is a diagram
showing the inheritance hierarchy of the response classes.

::



                                 +--------------+
                                 |ResponseParser|
                                 +--------------+
                                    ^    ^    ^
               +--------------------+    |    +-------------------+
               |                         |                        |
    +----------+----------+       +------+-------+        +-------+------+
    |BaseXMLResponseParser|       |BaseRestParser|        |BaseJSONParser|
    +---------------------+       +--------------+        +--------------+
              ^         ^          ^           ^           ^        ^
              |         |          |           |           |        |
              |         |          |           |           |        |
              |        ++----------+-+       +-+-----------++       |
              |        |RestXMLParser|       |RestJSONParser|       |
        +-----+-----+  +-------------+       +--------------+  +----+-----+
        |QueryParser|                                          |JSONParser|
        +-----------+                                          +----------+


The diagram above shows that there is a base class, ``ResponseParser`` that
contains logic that is similar amongst all the different protocols (``query``,
``json``, ``rest-json``, ``rest-xml``).  Amongst the various services there
is shared logic that can be grouped several ways:

* The ``query`` and ``rest-xml`` both have XML bodies that are parsed in the
  same way.
* The ``json`` and ``rest-json`` protocols both have JSON bodies that are
  parsed in the same way.
* The ``rest-json`` and ``rest-xml`` protocols have additional attributes
  besides body parameters that are parsed the same (headers, query string,
  status code).

This is reflected in the class diagram above.  The ``BaseXMLResponseParser``
and the BaseJSONParser contain logic for parsing the XML/JSON body,
and the BaseRestParser contains logic for parsing out attributes that
come from other parts of the HTTP response.  Classes like the
``RestXMLParser`` inherit from the ``BaseXMLResponseParser`` to get the
XML body parsing logic and the ``BaseRestParser`` to get the HTTP
header/status code/query string parsing.

Return Values
=============

Each call to ``parse()`` returns a dict has this form::

    Standard Response

    {
      "ResponseMetadata": {"RequestId": <requestid>}
      <response keys>
    }

    Error response

    {
      "ResponseMetadata": {"RequestId": <requestid>}
      "Error": {
        "Code": <string>,
        "Message": <string>,
        "Type": <string>,
        <additional keys>
      }
    }

iN(   t   sixt   XMLParseError(   t   parse_timestampt   merge_dictst   ResponseParserFactoryc           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   s   i  |  _  d  S(   N(   t	   _defaults(   t   self(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   __init__m   s    c         K   s   |  j  j |  d S(   sO  Set default arguments when a parser instance is created.

        You can specify any kwargs that are allowed by a ResponseParser
        class.  There are currently two arguments:

            * timestamp_parser - A callable that can parse a timetsamp string
            * blob_parser - A callable that can parse a blob type

        N(   R   t   update(   R   t   kwargs(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   set_parser_defaultsp   s    
c         C   s   t  | } | |  j   S(   N(   t   PROTOCOL_PARSERSR   (   R   t   protocol_namet
   parser_cls(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   create_parser|   s    
(   t   __name__t
   __module__R   R
   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   l   s   		c         C   s   t    j |   S(   N(   R   R   (   t   protocol(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR      s    c            s     f d   } | S(   Nc            sF   t  | d  r0 | j } | d  k r6 d } q6 n | }   |  | |  S(   Nt   textt    (   t   hasattrR   t   None(   R   t   shapet   node_or_stringR   (   t   func(    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _get_text_content   s    	(    (   R   R   (    (   R   s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _text_content   s    t   ResponseParserErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR      s   t   ResponseParserc           B   sb   e  Z d  Z d Z d
 d
 d  Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z RS(   so  Base class for response parsing.

    This class represents the interface that all ResponseParsers for the
    various protocols must implement.

    This class will take an HTTP response and a model shape and parse the
    HTTP response into a dictionary.

    There is a single public method exposed: ``parse``.  See the ``parse``
    docstring for more info.

    s   utf-8c         C   sC   | d  k r t } n  | |  _ | d  k r6 |  j } n  | |  _ d  S(   N(   R   t   DEFAULT_TIMESTAMP_PARSERt   _timestamp_parsert   _default_blob_parsert   _blob_parser(   R   t   timestamp_parsert   blob_parser(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR      s    		c         C   s   t  j |  S(   N(   t   base64t	   b64decode(   R   t   value(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR      s    c         C   s   t  j d | d  t  j d | d  | d d k rM |  j | |  } n |  j | |  } t | t  r d | k r | d | d d <n  | S(	   s>  Parse the HTTP response given a shape.

        :param response: The HTTP response dictionary.  This is a dictionary
            that represents the HTTP request.  The dictionary must have the
            following keys, ``body``, ``headers``, and ``status_code``.

        :param shape: The model shape describing the expected output.
        :return: Returns a dictionary representing the parsed response
            described by the model.  In addition to the shape described from
            the model, each response will also have a ``ResponseMetadata``
            which contains metadata about the response, which contains at least
            two keys containing ``RequestId`` and ``HTTPStatusCode``.  Some
            responses may populate additional keys, but ``RequestId`` will
            always be present.

        s   Response headers: %st   headerss   Response body:
%st   bodyt   status_codei-  t   ResponseMetadatat   HTTPStatusCode(   t   LOGt   debugt   _do_error_parset	   _do_parset
   isinstancet   dict(   R   t   responseR   t   parsed(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   parse   s    c         C   s   t  d |  j j   d  S(   Ns   %s._do_parse(   t   NotImplementedErrort	   __class__R   (   R   R1   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR.      s    c         C   s   t  d |  j j   d  S(   Ns   %s._do_error_parse(   R4   R5   R   (   R   R1   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR-      s    c         C   s)   t  |  d | j |  j  } | | |  S(   Ns
   _handle_%s(   t   getattrt	   type_namet   _default_handle(   R   R   t   nodet   handler(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _parse_shape   s    c         C   s=   g  } | j  } x' | D] } | j |  j | |   q W| S(   N(   t   membert   appendR;   (   R   R   R9   R2   t   member_shapet   item(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_list   s
    	c         C   s   | S(   N(    (   R   R   R%   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR8      s    N(   R   R   t   __doc__t   DEFAULT_ENCODINGR   R   R   R3   R.   R-   R;   R@   R8   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR      s   							t   BaseXMLResponseParserc           B   s   e  Z d d d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z e d	    Z e d
    Z e d    Z e d    Z e d    Z e d    Z e Z e Z e Z RS(   c         C   s/   t  t |   j | |  t j d  |  _ d  S(   Ns   {.*}(   t   superRC   R   t   ret   compilet   _namespace_re(   R   R!   R"   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR      s    c         C   s  i  } | j  } | j } | j j d  p- d } | j j d  pE d } | j j d  rv t | t  rv | g } n  x | D] } xo | D]g }	 |  j |	  }
 |
 | k r |  j | |	  } q |
 | k r |  j | |	  } q t d |
   q W| | | <q} W| S(   Nt   namet   keyR%   t	   flatteneds   Unknown tag: %s(	   RI   R%   t   serializationt   getR/   t   listt	   _node_tagR;   R   (   R   R   R9   R2   t	   key_shapet   value_shapet   key_location_namet   value_location_namet   keyval_nodet   single_pairt   tag_namet   key_namet   val_name(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_map   s"    		"c         C   s   |  j  j d | j  S(   NR   (   RG   t   subt   tag(   R   R9   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyRN     s    c         C   sG   | j  j d  r. t | t  r. | g } n  t t |   j | |  S(   NRJ   (   RK   RL   R/   RM   RD   RC   R@   (   R   R   R9   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR@     s    "c         C   s-  i  } | j  } |  j |  } x| D] } | | } d | j k rJ q% n  |  j | |  } | j |  }	 |	 d  k	 r |  j | |	  | | <q% | j j d  r% i  }
 | j d } xM | j j   D]< \ } } |  j	 j
 | j d  d d |  } | |
 | <q W| |
 k r%|
 | | | <q%q% q% W| S(   Nt   locationt   xmlAttributeRH   t   :i    (   t   memberst   _build_name_to_xml_nodeRK   t   _member_key_nameRL   R   R;   t   attribt   itemsRG   RY   t   split(   R   R   R9   R2   R^   t   xml_dictt   member_nameR>   t   xml_namet   member_nodet   attribst   location_nameRI   R%   t   new_key(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_structure  s,    	
	c         C   so   | j  d k rI | j j d  rI | j j j d  } | d  k	 rI | Sn  | j j d  } | d  k	 rk | S| S(   NRM   RJ   RH   (   R7   RK   RL   R<   R   (   R   R   Re   t   list_member_serialized_namet   serialized_name(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR`   3  s    !	c         C   s   t  | t  r  |  j | d  Si  } xq | D]i } |  j |  } | | k r t  | | t  ru | | j |  q | | | g | | <q- | | | <q- W| S(   Ni    (   R/   RM   R_   RN   R=   (   R   t   parent_nodeRd   R?   RI   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR_   B  s    c         C   sz   yJ t  j j j d t  j j j   d |  j  } | j |  | j   } Wn) t k
 ru } t	 d | | f   n X| S(   Nt   targett   encodings7   Unable to parse response (%s), invalid XML received:
%s(
   t   xmlt   etreet   cElementTreet	   XMLParsert   TreeBuilderRB   t   feedt   closeR   R   (   R   t
   xml_stringt   parsert   roott   e(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _parse_xml_string_to_domY  s    c         C   s_   xX | j    D]J \ } } | j   rJ |  j |  } |  j |  | | <q | j | | <q W| S(   N(   Rb   t   getchildrenR_   t   _replace_nodesR   (   R   R2   RI   R%   t   sub_dict(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR~   f  s    c         C   s   | d k r t  St Sd  S(   Nt   true(   t   Truet   False(   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_booleano  s    c         C   s
   t  |  S(   N(   t   float(   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_floatv  s    c         C   s   |  j  |  S(   N(   R   (   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_timestampz  s    c         C   s
   t  |  S(   N(   t   int(   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_integer~  s    c         C   s   | S(   N(    (   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_string  s    c         C   s   |  j  |  S(   N(   R    (   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   _handle_blob  s    N(   R   R   R   R   RX   RN   R@   Rk   R`   R_   R|   R~   R   R   R   R   R   R   R   t   _handle_charactert   _handle_doublet   _handle_long(    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyRC      s$   			
						t   QueryParserc           B   s,   e  Z d    Z d   Z d   Z d   Z RS(   c         C   s   | d } |  j  |  } |  j |  } |  j |  d | k rZ | j | j d   n  d | k r i | j d  d 6| d <n  | S(   NR'   t   Errorst	   RequestIdR)   (   R|   R_   R~   R   t   pop(   R   R1   R   t   xml_contentsRz   R2   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR-     s    
c         C   s   | d } |  j  |  } i  } | d  k	 rq | } d | j k r\ |  j | j d |  } n  |  j | |  } n  |  j | |  | S(   NR'   t   resultWrapper(   R|   R   RK   t   _find_result_wrapped_shapeR;   t   _inject_response_metadata(   R   R1   R   R   Rz   R2   t   start(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR.     s    

c         C   s   |  j  |  } | | S(   N(   R_   (   R   t   element_namet   xml_root_nodet   mapping(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   st   |  j  |  } | j d  } | d  k	 rp |  j  |  } x' | j   D] \ } } | j | | <qF W| | d <n  d  S(   NR)   (   R_   RL   R   Rb   R   (   R   R9   t   inject_intoR   t
   child_nodet   sub_mappingRI   R%   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    (   R   R   R-   R.   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s   			t   EC2QueryParserc           B   s   e  Z d    Z d   Z RS(   c         C   sE   |  j  |  } | j d  } | d  k	 rA i | j d 6| d <n  d  S(   Nt	   requestIdR   R)   (   R_   RL   R   R   (   R   R9   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   s9   t  t |   j | |  } i | j d  d 6| d <| S(   Nt	   RequestIDR   R)   (   RD   R   R-   R   (   R   R1   R   t   original(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR-     s    (   R   R   R   R-   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s   	t   BaseJSONParserc           B   sG   e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z RS(   c   	      C   s   | j  } | d  k r d  Si  } xe | D]] } | | } | j j d |  } | j |  } | d  k	 r& |  j | | |  | | <q& q& W| S(   NRH   (   R^   R   RK   RL   R;   (	   R   R   R%   t   member_shapest   final_parsedRe   R>   t	   json_namet	   raw_value(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyRk     s    	
c   	      C   sg   i  } | j  } | j } xH | j   D]: \ } } |  j | |  } |  j | |  } | | | <q% W| S(   N(   RI   R%   Rb   R;   (	   R   R   R%   R2   RO   RP   RI   t
   actual_keyt   actual_value(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyRX     s    		c         C   s   |  j  |  S(   N(   R    (   R   R   R%   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   s   |  j  |  S(   N(   R   (   R   R   R%   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   s   |  j  | d  } i i d d 6d d 6d 6i  d 6} | j d | j d d   | d d <| j d  } | d  k	 r d	 | k r | j d	 d
  d
 } n  | | d d <n  |  j | | d  | S(   NR'   R   t   Messaget   Codet   ErrorR)   t   messaget   __typet   #i   R&   (   t   _parse_body_as_jsonRL   R   t   rsplitR   (   R   R1   R   R'   t   errort   code(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR-     s    "		c         C   s-   d | k r) | d | j  d i   d <n  d  S(   Ns   x-amzn-requestidR)   R   (   t
   setdefault(   R   R2   R&   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   s/   | s
 i  S| j  |  j  } t j |  } | S(   N(   t   decodeRB   t   jsont   loads(   R   t   body_contentsR'   t   original_parsed(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s
    (	   R   R   Rk   RX   R   R   R-   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s   		
				t
   JSONParserc           B   s   e  Z d  Z d   Z RS(   s'   Response parse for the "json" protocol.c         C   sR   i  } | d  k	 r: |  j | d  } |  j | |  } n  |  j | | d  | S(   NR'   R&   (   R   R   R;   R   (   R   R1   R   R2   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR.   $  s    (   R   R   RA   R.   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   "  s   t   BaseRestParserc           B   s>   e  Z d    Z d   Z d   Z d   Z d   Z d   Z RS(   c         C   sb   i  } |  j  |  | d <| d  k r) | S| j } |  j | | | |  |  j | | | |  | S(   NR)   (   t   _populate_response_metadataR   R^   t   _parse_non_payload_attrst   _parse_payload(   R   R1   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR.   2  s    	
c         C   sd   i  } | d } d | k r- | d | d <n3 d | k r` | d | d <| j  d d  | d <n  | S(   NR&   s   x-amzn-requestidR   s   x-amz-request-ids
   x-amz-id-2R   t   HostId(   RL   (   R   R1   t   metadataR&   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   >  s    
c   
      C   s   d | j  k r | j  d } | | } | j d k rp | d } t | t  rc | j |  j  } n  | | | <q |  j | d  } |  j | |  | | <n2 |  j | d  } |  j | |  }	 | j |	  d  S(   Nt   payloadt   stringt   blobR'   (   s   stringR   (	   RK   R7   R/   t   bytesR   RB   t   _initial_body_parseR;   R   (
   R   R1   R   R   R   t   payload_member_namet
   body_shapeR'   R   t   body_parsed(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   K  s    

c   
      C   s   | d } x | D] } | | } | j  j d  } | d  k rE q q | d k rn |  j | | d  | | <q | d k r |  j | |  | | <q | d k r | j  j d |  }	 |	 | k r |  j | | |	  | | <q q q Wd  S(   NR&   R[   t
   statusCodeR(   t   headerRH   (   RK   RL   R   R;   t   _parse_header_map(
   R   R1   R   R   R   R&   RH   R>   R[   t   header_name(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   `  s"    

	c         C   sl   i  } | j  j d d  j   } xD | D]< } | j   j |  r( | t |  } | | | | <q( q( W| S(   NRH   R   (   RK   RL   t   lowert
   startswitht   len(   R   R   R&   R2   t   prefixR   RH   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   t  s    c         C   s   t  d   d  S(   NR   (   R4   (   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    (   R   R   R.   R   R   R   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR   0  s   					t   RestJSONParserc           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   s   |  j  |  S(   N(   R   (   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   s/   t  t |   j | |  } |  j | |  | S(   N(   RD   R   R-   t   _inject_error_code(   R   R1   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR-     s    c         C   s   |  j  | d  } d | d k rU | d d } | j d  d } | | d d <nA d | k sm d | k r | j d | j d d	   | d d <n  d  S(
   NR'   s   x-amzn-errortypeR&   R]   i    R   R   R   R   (   R   Rc   RL   (   R   R   R1   R'   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    (   R   R   R   R-   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s   		t   RestXMLParserc           B   s,   e  Z d    Z d   Z d   Z d   Z RS(   c         C   s&   | s t  j j j d  S|  j |  S(   NR   (   Rq   Rr   Rs   t   ElementR|   (   R   Rx   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   sT   | d rG y |  j  |  SWqG t k
 rC } t j d d t qG Xn  |  j |  S(   NR'   s2   Exception caught when parsing error response body:t   exc_info(   t   _parse_error_from_bodyR   R+   R,   R   t   _parse_error_from_http_status(   R   R1   R   R{   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR-     s    
c         C   sq   i i t  | d  d 6t j j j j | d d  d 6d 6i | d j d d  d 6| d j d	 d  d
 6d 6S(   NR(   R   R   R   R   R&   s   x-amz-request-idR   s
   x-amz-id-2R   R)   (   t   strR    t   movest   http_clientt	   responsesRL   (   R   R1   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    c         C   s   | d } |  j  |  } |  j |  } |  j |  | j d k r |  j |  } | j d d  | j d d  i | d 6| d 6Sd | k r i | j d  d 6| d <n  i i d d 6d d 6d 6} t | |  | S(	   NR'   R   R   R   R   R)   R   R   (   R|   R_   R~   RZ   R   R   R   (   R   R1   R   Rz   R2   R   t   default(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s    
(   R   R   R   R-   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyR     s   			t   ec2t   queryR   s	   rest-jsons   rest-xml(!   RA   RE   R#   R   t   xml.etree.cElementTreeRq   t   loggingt   botocore.compatR    R   t   botocore.utilsR   R   t	   getLoggerR   R+   R   t   objectR   R   R   t	   ExceptionR   R   RC   R   R   R   R   R   R   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/parsers.pyt   <module>\   s8   		T.IYF                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/botocore/regions.py                                           0100644 0000000 0000062 00000020257 13077704371 022070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
"""Resolves regions and endpoints.

This module implements endpoint resolution, including resolving endpoints for a
given service and region and resolving the available endpoints for a service
in a specific AWS partition.
"""
import logging
import re

from botocore.exceptions import NoRegionError

LOG = logging.getLogger(__name__)
DEFAULT_URI_TEMPLATE = '{service}.{region}.{dnsSuffix}'
DEFAULT_SERVICE_DATA = {'endpoints': {}}


class BaseEndpointResolver(object):
    """Resolves regions and endpoints. Must be subclassed."""
    def construct_endpoint(self, service_name, region_name=None):
        """Resolves an endpoint for a service and region combination.

        :type service_name: string
        :param service_name: Name of the service to resolve an endpoint for
            (e.g., s3)

        :type region_name: string
        :param region_name: Region/endpoint name to resolve (e.g., us-east-1)
            if no region is provided, the first found partition-wide endpoint
            will be used if available.

        :rtype: dict
        :return: Returns a dict containing the following keys:
            - partition: (string, required) Resolved partition name
            - endpointName: (string, required) Resolved endpoint name
            - hostname: (string, required) Hostname to use for this endpoint
            - sslCommonName: (string) sslCommonName to use for this endpoint.
            - credentialScope: (dict) Signature version 4 credential scope
              - region: (string) region name override when signing.
              - service: (string) service name override when signing.
            - signatureVersions: (list<string>) A list of possible signature
              versions, including s3, v4, v2, and s3v4
            - protocols: (list<string>) A list of supported protocols
              (e.g., http, https)
            - ...: Other keys may be included as well based on the metadata
        """
        raise NotImplementedError

    def get_available_partitions(self):
        """Lists the partitions available to the endpoint resolver.

        :return: Returns a list of partition names (e.g., ["aws", "aws-cn"]).
        """
        raise NotImplementedError

    def get_available_endpoints(self, service_name, partition_name='aws',
                                allow_non_regional=False):
        """Lists the endpoint names of a particular partition.

        :type service_name: string
        :param service_name: Name of a service to list endpoint for (e.g., s3)

        :type partition_name: string
        :param partition_name: Name of the partition to limit endpoints to.
            (e.g., aws for the public AWS endpoints, aws-cn for AWS China
            endpoints, aws-us-gov for AWS GovCloud (US) Endpoints, etc.

        :type allow_non_regional: bool
        :param allow_non_regional: Set to True to include endpoints that are
             not regional endpoints (e.g., s3-external-1,
             fips-us-gov-west-1, etc).
        :return: Returns a list of endpoint names (e.g., ["us-east-1"]).
        """
        raise NotImplementedError


class EndpointResolver(BaseEndpointResolver):
    """Resolves endpoints based on partition endpoint metadata"""
    def __init__(self, endpoint_data):
        """
        :param endpoint_data: A dict of partition data.
        """
        if 'partitions' not in endpoint_data:
            raise ValueError('Missing "partitions" in endpoint data')
        self._endpoint_data = endpoint_data

    def get_available_partitions(self):
        result = []
        for partition in self._endpoint_data['partitions']:
            result.append(partition['partition'])
        return result

    def get_available_endpoints(self, service_name, partition_name='aws',
                                allow_non_regional=False):
        result = []
        for partition in self._endpoint_data['partitions']:
            if partition['partition'] != partition_name:
                continue
            services = partition['services']
            if service_name not in services:
                continue
            for endpoint_name in services[service_name]['endpoints']:
                if allow_non_regional or endpoint_name in partition['regions']:
                    result.append(endpoint_name)
        return result

    def construct_endpoint(self, service_name, region_name=None):
        # Iterate over each partition until a match is found.
        for partition in self._endpoint_data['partitions']:
            result = self._endpoint_for_partition(
                partition, service_name, region_name)
            if result:
                return result

    def _endpoint_for_partition(self, partition, service_name, region_name):
        # Get the service from the partition, or an empty template.
        service_data = partition['services'].get(
            service_name, DEFAULT_SERVICE_DATA)
        # Use the partition endpoint if no region is supplied.
        if region_name is None:
            if 'partitionEndpoint' in service_data:
                region_name = service_data['partitionEndpoint']
            else:
                raise NoRegionError()
        # Attempt to resolve the exact region for this partition.
        if region_name in service_data['endpoints']:
            return self._resolve(
                partition, service_name, service_data, region_name)
        # Check to see if the endpoint provided is valid for the partition.
        if self._region_match(partition, region_name):
            # Use the partition endpoint if set and not regionalized.
            partition_endpoint = service_data.get('partitionEndpoint')
            is_regionalized = service_data.get('isRegionalized', True)
            if partition_endpoint and not is_regionalized:
                LOG.debug('Using partition endpoint for %s, %s: %s',
                          service_name, region_name, partition_endpoint)
                return self._resolve(
                    partition, service_name, service_data, partition_endpoint)
            LOG.debug('Creating a regex based endpoint for %s, %s',
                      service_name, region_name)
            return self._resolve(
                partition, service_name, service_data, region_name)

    def _region_match(self, partition, region_name):
        if region_name in partition['regions']:
            return True
        if 'regionRegex' in partition:
            return re.compile(partition['regionRegex']).match(region_name)
        return False

    def _resolve(self, partition, service_name, service_data, endpoint_name):
        result = service_data['endpoints'].get(endpoint_name, {})
        result['partition'] = partition['partition']
        result['endpointName'] = endpoint_name
        # Merge in the service defaults then the partition defaults.
        self._merge_keys(service_data.get('defaults', {}), result)
        self._merge_keys(partition.get('defaults', {}), result)
        hostname = result.get('hostname', DEFAULT_URI_TEMPLATE)
        result['hostname'] = self._expand_template(
            partition, result['hostname'], service_name, endpoint_name)
        if 'sslCommonName' in result:
            result['sslCommonName'] = self._expand_template(
                partition, result['sslCommonName'], service_name,
                endpoint_name)
        return result

    def _merge_keys(self, from_data, result):
        for key in from_data:
            if key not in result:
                result[key] = from_data[key]

    def _expand_template(self, partition, template, service_name,
                         endpoint_name):
        return template.format(
            service=service_name, region=endpoint_name,
            dnsSuffix=partition['dnsSuffix'])
                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/regions.pyc                                          0100644 0000000 0000062 00000016371 13077704401 022227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  Z  d d l Z d d l Z d d l m Z e j e  Z d Z i i  d 6Z	 d e
 f d     YZ d e f d	     YZ d S(
   s   Resolves regions and endpoints.

This module implements endpoint resolution, including resolving endpoints for a
given service and region and resolving the available endpoints for a service
in a specific AWS partition.
iN(   t   NoRegionErrors   {service}.{region}.{dnsSuffix}t	   endpointst   BaseEndpointResolverc           B   s2   e  Z d  Z d d  Z d   Z d e d  Z RS(   s3   Resolves regions and endpoints. Must be subclassed.c         C   s
   t   d S(   s7  Resolves an endpoint for a service and region combination.

        :type service_name: string
        :param service_name: Name of the service to resolve an endpoint for
            (e.g., s3)

        :type region_name: string
        :param region_name: Region/endpoint name to resolve (e.g., us-east-1)
            if no region is provided, the first found partition-wide endpoint
            will be used if available.

        :rtype: dict
        :return: Returns a dict containing the following keys:
            - partition: (string, required) Resolved partition name
            - endpointName: (string, required) Resolved endpoint name
            - hostname: (string, required) Hostname to use for this endpoint
            - sslCommonName: (string) sslCommonName to use for this endpoint.
            - credentialScope: (dict) Signature version 4 credential scope
              - region: (string) region name override when signing.
              - service: (string) service name override when signing.
            - signatureVersions: (list<string>) A list of possible signature
              versions, including s3, v4, v2, and s3v4
            - protocols: (list<string>) A list of supported protocols
              (e.g., http, https)
            - ...: Other keys may be included as well based on the metadata
        N(   t   NotImplementedError(   t   selft   service_namet   region_name(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyt   construct_endpoint   s    c         C   s
   t   d S(   s   Lists the partitions available to the endpoint resolver.

        :return: Returns a list of partition names (e.g., ["aws", "aws-cn"]).
        N(   R   (   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyt   get_available_partitions<   s    t   awsc         C   s
   t   d S(   s  Lists the endpoint names of a particular partition.

        :type service_name: string
        :param service_name: Name of a service to list endpoint for (e.g., s3)

        :type partition_name: string
        :param partition_name: Name of the partition to limit endpoints to.
            (e.g., aws for the public AWS endpoints, aws-cn for AWS China
            endpoints, aws-us-gov for AWS GovCloud (US) Endpoints, etc.

        :type allow_non_regional: bool
        :param allow_non_regional: Set to True to include endpoints that are
             not regional endpoints (e.g., s3-external-1,
             fips-us-gov-west-1, etc).
        :return: Returns a list of endpoint names (e.g., ["us-east-1"]).
        N(   R   (   R   R   t   partition_namet   allow_non_regional(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyt   get_available_endpointsC   s    N(   t   __name__t
   __module__t   __doc__t   NoneR   R   t   FalseR   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR      s
   	t   EndpointResolverc           B   sh   e  Z d  Z d   Z d   Z d e d  Z d d  Z d   Z	 d   Z
 d   Z d	   Z d
   Z RS(   s7   Resolves endpoints based on partition endpoint metadatac         C   s(   d | k r t  d   n  | |  _ d S(   sA   
        :param endpoint_data: A dict of partition data.
        t
   partitionss%   Missing "partitions" in endpoint dataN(   t
   ValueErrort   _endpoint_data(   R   t   endpoint_data(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyt   __init__Z   s    c         C   s3   g  } x& |  j  d D] } | j | d  q W| S(   NR   t	   partition(   R   t   append(   R   t   resultR   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR   b   s    R	   c         C   s   g  } x |  j  d D]w } | d | k r0 q n  | d } | | k rL q n  x< | | d D], } | sw | | d k r[ | j |  q[ q[ Wq W| S(   NR   R   t   servicesR   t   regions(   R   R   (   R   R   R
   R   R   R   R   t   endpoint_name(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR   h   s    
c         C   s;   x4 |  j  d D]% } |  j | | |  } | r | Sq Wd  S(   NR   (   R   t   _endpoint_for_partition(   R   R   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR   v   s
    c         C   s  | d j  | t  } | d  k rG d | k r; | d } qG t    n  | | d k rm |  j | | | |  S|  j | |  r| j  d  } | j  d t  } | r | r t j d | | |  |  j | | | |  St j d | |  |  j | | | |  Sd  S(   NR   t   partitionEndpointR   t   isRegionalizeds'   Using partition endpoint for %s, %s: %ss*   Creating a regex based endpoint for %s, %s(	   t   gett   DEFAULT_SERVICE_DATAR   R    t   _resolvet   _region_matcht   Truet   LOGt   debug(   R   R   R   R   t   service_datat   partition_endpointt   is_regionalized(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR   ~   s*    
		
c         C   s>   | | d k r t  Sd | k r: t j | d  j |  St S(   NR   t   regionRegex(   R%   t   ret   compilet   matchR   (   R   R   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR$      s
    c         C   s   | d j  | i   } | d | d <| | d <|  j | j  d i   |  |  j | j  d i   |  | j  d t  } |  j | | d | |  | d <d | k r |  j | | d | |  | d <n  | S(   NR   R   t   endpointNamet   defaultst   hostnamet   sslCommonName(   R!   t   _merge_keyst   DEFAULT_URI_TEMPLATEt   _expand_template(   R   R   R   R(   R   R   R1   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR#      s    
c         C   s2   x+ | D]# } | | k r | | | | <q q Wd  S(   N(    (   R   t	   from_dataR   t   key(    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR3      s    c         C   s    | j  d | d | d | d  S(   Nt   servicet   regiont	   dnsSuffix(   t   format(   R   R   t   templateR   R   (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR5      s    	N(   R   R   R   R   R   R   R   R   R   R   R$   R#   R3   R5   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyR   X   s   						(   R   t   loggingR,   t   botocore.exceptionsR    t	   getLoggerR   R&   R4   R"   t   objectR   R   (    (    (    s2   /tmp/pip-build-awuatQ/botocore/botocore/regions.pyt   <module>   s   ;                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/botocore/response.py                                          0100644 0000000 0000062 00000011712 13077704371 022254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

import sys
import xml.etree.cElementTree
import logging

from botocore import ScalarTypes
from botocore.hooks import first_non_none_response
from botocore.compat import json, set_socket_timeout, XMLParseError
from botocore.exceptions import IncompleteReadError
from botocore import parsers


logger = logging.getLogger(__name__)


class StreamingBody(object):
    """Wrapper class for an http response body.

    This provides a few additional conveniences that do not exist
    in the urllib3 model:

        * Set the timeout on the socket (i.e read() timeouts)
        * Auto validation of content length, if the amount of bytes
          we read does not match the content length, an exception
          is raised.

    """
    def __init__(self, raw_stream, content_length):
        self._raw_stream = raw_stream
        self._content_length = content_length
        self._amount_read = 0

    def set_socket_timeout(self, timeout):
        """Set the timeout seconds on the socket."""
        # The problem we're trying to solve is to prevent .read() calls from
        # hanging.  This can happen in rare cases.  What we'd like to ideally
        # do is set a timeout on the .read() call so that callers can retry
        # the request.
        # Unfortunately, this isn't currently possible in requests.
        # See: https://github.com/kennethreitz/requests/issues/1803
        # So what we're going to do is reach into the guts of the stream and
        # grab the socket object, which we can set the timeout on.  We're
        # putting in a check here so in case this interface goes away, we'll
        # know.
        try:
            # To further complicate things, the way to grab the
            # underlying socket object from an HTTPResponse is different
            # in py2 and py3.  So this code has been pushed to botocore.compat.
            set_socket_timeout(self._raw_stream, timeout)
        except AttributeError:
            logger.error("Cannot access the socket object of "
                         "a streaming response.  It's possible "
                         "the interface has changed.", exc_info=True)
            raise

    def read(self, amt=None):
        """Read at most amt bytes from the stream.

        If the amt argument is omitted, read all data.
        """
        chunk = self._raw_stream.read(amt)
        self._amount_read += len(chunk)
        if not chunk or amt is None:
            # If the server sends empty contents or
            # we ask to read all of the contents, then we know
            # we need to verify the content length.
            self._verify_content_length()
        return chunk

    def _verify_content_length(self):
        if self._content_length is not None and \
                self._amount_read != int(self._content_length):
            raise IncompleteReadError(
                actual_bytes=self._amount_read,
                expected_bytes=int(self._content_length))

    def close(self):
        """Close the underlying http response stream."""
        self._raw_stream.close()


def _validate_content_length(expected_content_length, body_length):
    # See: https://github.com/kennethreitz/requests/issues/1855
    # Basically, our http library doesn't do this for us, so we have
    # to do this ourself.
    if expected_content_length is not None:
        if int(expected_content_length) != body_length:
            raise IncompleteReadError(
                actual_bytes=body_length,
                expected_bytes=int(expected_content_length))


def get_response(operation_model, http_response):
    protocol = operation_model.metadata['protocol']
    response_dict = {
        'headers': http_response.headers,
        'status_code': http_response.status_code,
    }
    # TODO: Unfortunately, we have to have error logic here.
    # If it looks like an error, in the streaming response case we
    # need to actually grab the contents.
    if response_dict['status_code'] >= 300:
        response_dict['body'] = http_response.content
    elif operation_model.has_streaming_output:
        response_dict['body'] = StreamingBody(
            http_response.raw, response_dict['headers'].get('content-length'))
    else:
        response_dict['body'] = http_response.content

    parser = parsers.create_parser(protocol)
    return http_response, parser.parse(response_dict,
                                       operation_model.output_shape)
                                                      usr/local/lib/python2.7/dist-packages/botocore/response.pyc                                         0100644 0000000 0000062 00000007362 13077704401 022417  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s   d  d l  Z  d  d l Z d  d l Z d  d l m Z d  d l m Z d  d l m	 Z	 m
 Z
 m Z d  d l m Z d  d l m Z e j e  Z d e f d     YZ d	   Z d
   Z d S(   iN(   t   ScalarTypes(   t   first_non_none_response(   t   jsont   set_socket_timeoutt   XMLParseError(   t   IncompleteReadError(   t   parserst   StreamingBodyc           B   s>   e  Z d  Z d   Z d   Z d d  Z d   Z d   Z RS(   se  Wrapper class for an http response body.

    This provides a few additional conveniences that do not exist
    in the urllib3 model:

        * Set the timeout on the socket (i.e read() timeouts)
        * Auto validation of content length, if the amount of bytes
          we read does not match the content length, an exception
          is raised.

    c         C   s   | |  _  | |  _ d |  _ d  S(   Ni    (   t   _raw_streamt   _content_lengtht   _amount_read(   t   selft
   raw_streamt   content_length(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyt   __init__)   s    		c         C   sB   y t  |  j |  Wn' t k
 r= t j d d t   n Xd S(   s&   Set the timeout seconds on the socket.sb   Cannot access the socket object of a streaming response.  It's possible the interface has changed.t   exc_infoN(   R   R   t   AttributeErrort   loggert   errort   True(   R   t   timeout(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyR   .   s    c         C   sK   |  j  j |  } |  j t |  7_ | s: | d k rG |  j   n  | S(   sh   Read at most amt bytes from the stream.

        If the amt argument is omitted, read all data.
        N(   R   t   readR
   t   lent   Nonet   _verify_content_length(   R   t   amtt   chunk(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyR   E   s
    c         C   sO   |  j  d  k	 rK |  j t |  j   k rK t d |  j d t |  j     n  d  S(   Nt   actual_bytest   expected_bytes(   R	   R   R
   t   intR   (   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyR   S   s
    	c         C   s   |  j  j   d S(   s*   Close the underlying http response stream.N(   R   t   close(   R   (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyR   Z   s    N(	   t   __name__t
   __module__t   __doc__R   R   R   R   R   R   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyR      s   			c         C   sC   |  d  k	 r? t |   | k r? t d | d t |     q? n  d  S(   NR   R   (   R   R   R   (   t   expected_content_lengtht   body_length(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyt   _validate_content_length_   s
    c         C   s   |  j  d } i | j d 6| j d 6} | d d k rG | j | d <n< |  j rv t | j | d j d   | d <n | j | d <t j	 |  } | | j
 | |  j  f S(   Nt   protocolt   headerst   status_codei,  t   bodys   content-length(   t   metadataR&   R'   t   contentt   has_streaming_outputR   t   rawt   getR   t   create_parsert   parset   output_shape(   t   operation_modelt   http_responseR%   t   response_dictt   parser(    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyt   get_responsej   s    
	#(   t   syst   xml.etree.cElementTreet   xmlt   loggingt   botocoreR    t   botocore.hooksR   t   botocore.compatR   R   R   t   botocore.exceptionsR   R   t	   getLoggerR   R   t   objectR   R$   R5   (    (    (    s3   /tmp/pip-build-awuatQ/botocore/botocore/response.pyt   <module>   s   B	                                                                                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/botocore/retryhandler.py                                      0100644 0000000 0000062 00000032456 13077704371 023131  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

import random
import functools
import logging
from binascii import crc32

from botocore.vendored.requests import ConnectionError, Timeout
from botocore.vendored.requests.packages.urllib3.exceptions import ClosedPoolError

from botocore.exceptions import ChecksumError, EndpointConnectionError


logger = logging.getLogger(__name__)
# The only supported error for now is GENERAL_CONNECTION_ERROR
# which maps to requests generic ConnectionError.  If we're able
# to get more specific exceptions from requests we can update
# this mapping with more specific exceptions.
EXCEPTION_MAP = {
    'GENERAL_CONNECTION_ERROR': [
        ConnectionError, ClosedPoolError, Timeout,
        EndpointConnectionError
    ],
}


def delay_exponential(base, growth_factor, attempts):
    """Calculate time to sleep based on exponential function.

    The format is::

        base * growth_factor ^ (attempts - 1)

    If ``base`` is set to 'rand' then a random number between
    0 and 1 will be used as the base.
    Base must be greater than 0, otherwise a ValueError will be
    raised.

    """
    if base == 'rand':
        base = random.random()
    elif base <= 0:
        raise ValueError("The 'base' param must be greater than 0, "
                         "got: %s" % base)
    time_to_sleep = base * (growth_factor ** (attempts - 1))
    return time_to_sleep


def create_exponential_delay_function(base, growth_factor):
    """Create an exponential delay function based on the attempts.

    This is used so that you only have to pass it the attempts
    parameter to calculate the delay.

    """
    return functools.partial(
        delay_exponential, base=base, growth_factor=growth_factor)


def create_retry_handler(config, operation_name=None):
    checker = create_checker_from_retry_config(
        config, operation_name=operation_name)
    action = create_retry_action_from_config(
        config, operation_name=operation_name)
    return RetryHandler(checker=checker, action=action)


def create_retry_action_from_config(config, operation_name=None):
    # The spec has the possibility of supporting per policy
    # actions, but right now, we assume this comes from the
    # default section, which means that delay functions apply
    # for every policy in the retry config (per service).
    delay_config = config['__default__']['delay']
    if delay_config['type'] == 'exponential':
        return create_exponential_delay_function(
            base=delay_config['base'],
            growth_factor=delay_config['growth_factor'])


def create_checker_from_retry_config(config, operation_name=None):
    checkers = []
    max_attempts = None
    retryable_exceptions = []
    if '__default__' in config:
        policies = config['__default__'].get('policies', [])
        max_attempts = config['__default__']['max_attempts']
        for key in policies:
            current_config = policies[key]
            checkers.append(_create_single_checker(current_config))
            retry_exception = _extract_retryable_exception(current_config)
            if retry_exception is not None:
                retryable_exceptions.extend(retry_exception)
    if operation_name is not None and config.get(operation_name) is not None:
        operation_policies = config[operation_name]['policies']
        for key in operation_policies:
            checkers.append(_create_single_checker(operation_policies[key]))
            retry_exception = _extract_retryable_exception(
                operation_policies[key])
            if retry_exception is not None:
                retryable_exceptions.extend(retry_exception)
    if len(checkers) == 1:
        # Don't need to use a MultiChecker
        return MaxAttemptsDecorator(checkers[0], max_attempts=max_attempts)
    else:
        multi_checker = MultiChecker(checkers)
        return MaxAttemptsDecorator(
            multi_checker, max_attempts=max_attempts,
            retryable_exceptions=tuple(retryable_exceptions))


def _create_single_checker(config):
    if 'response' in config['applies_when']:
        return _create_single_response_checker(
            config['applies_when']['response'])
    elif 'socket_errors' in config['applies_when']:
        return ExceptionRaiser()


def _create_single_response_checker(response):
    if 'service_error_code' in response:
        checker = ServiceErrorCodeChecker(
            status_code=response['http_status_code'],
            error_code=response['service_error_code'])
    elif 'http_status_code' in response:
        checker = HTTPStatusCodeChecker(
            status_code=response['http_status_code'])
    elif 'crc32body' in response:
        checker = CRC32Checker(header=response['crc32body'])
    else:
        # TODO: send a signal.
        raise ValueError("Unknown retry policy: %s" % config)
    return checker


def _extract_retryable_exception(config):
    applies_when = config['applies_when']
    if 'crc32body' in applies_when.get('response', {}):
        return [ChecksumError]
    elif 'socket_errors' in applies_when:
        exceptions = []
        for name in applies_when['socket_errors']:
            exceptions.extend(EXCEPTION_MAP[name])
        return exceptions


class RetryHandler(object):
    """Retry handler.

    The retry handler takes two params, ``checker`` object
    and an ``action`` object.

    The ``checker`` object must be a callable object and based on a response
    and an attempt number, determines whether or not sufficient criteria for
    a retry has been met.  If this is the case then the ``action`` object
    (which also is a callable) determines what needs to happen in the event
    of a retry.

    """

    def __init__(self, checker, action):
        self._checker = checker
        self._action = action

    def __call__(self, attempts, response, caught_exception, **kwargs):
        """Handler for a retry.

        Intended to be hooked up to an event handler (hence the **kwargs),
        this will process retries appropriately.

        """
        if self._checker(attempts, response, caught_exception):
            result = self._action(attempts=attempts)
            logger.debug("Retry needed, action of: %s", result)
            return result
        logger.debug("No retry needed.")


class BaseChecker(object):
    """Base class for retry checkers.

    Each class is responsible for checking a single criteria that determines
    whether or not a retry should not happen.

    """
    def __call__(self, attempt_number, response, caught_exception):
        """Determine if retry criteria matches.

        Note that either ``response`` is not None and ``caught_exception`` is
        None or ``response`` is None and ``caught_exception`` is not None.

        :type attempt_number: int
        :param attempt_number: The total number of times we've attempted
            to send the request.

        :param response: The HTTP response (if one was received).

        :type caught_exception: Exception
        :param caught_exception: Any exception that was caught while trying to
            send the HTTP response.

        :return: True, if the retry criteria matches (and therefore a retry
            should occur.  False if the criteria does not match.

        """
        # The default implementation allows subclasses to not have to check
        # whether or not response is None or not.
        if response is not None:
            return self._check_response(attempt_number, response)
        elif caught_exception is not None:
            return self._check_caught_exception(attempt_number, caught_exception)
        else:
            raise ValueError("Both response and caught_exception are None.")

    def _check_response(self, attempt_number, response):
        pass

    def _check_caught_exception(self, attempt_number, caught_exception):
        pass


class MaxAttemptsDecorator(BaseChecker):
    """Allow retries up to a maximum number of attempts.

    This will pass through calls to the decorated retry checker, provided
    that the number of attempts does not exceed max_attempts.  It will
    also catch any retryable_exceptions passed in.  Once max_attempts has
    been exceeded, then False will be returned or the retryable_exceptions
    that was previously being caught will be raised.

    """
    def __init__(self, checker, max_attempts, retryable_exceptions=None):
        self._checker = checker
        self._max_attempts = max_attempts
        self._retryable_exceptions = retryable_exceptions

    def __call__(self, attempt_number, response, caught_exception):
        should_retry = self._should_retry(attempt_number, response,
                                          caught_exception)
        if should_retry:
            if attempt_number >= self._max_attempts:
                logger.debug("Reached the maximum number of retry "
                             "attempts: %s", attempt_number)
                return False
            else:
                return should_retry
        else:
            return False

    def _should_retry(self, attempt_number, response, caught_exception):
        if self._retryable_exceptions and \
                attempt_number < self._max_attempts:
            try:
                return self._checker(attempt_number, response, caught_exception)
            except self._retryable_exceptions as e:
                logger.debug("retry needed, retryable exception caught: %s",
                             e, exc_info=True)
                return True
        else:
            # If we've exceeded the max attempts we just let the exception
            # propogate if one has occurred.
            return self._checker(attempt_number, response, caught_exception)


class HTTPStatusCodeChecker(BaseChecker):
    def __init__(self, status_code):
        self._status_code = status_code

    def _check_response(self, attempt_number, response):
        if response[0].status_code == self._status_code:
            logger.debug(
                "retry needed: retryable HTTP status code received: %s",
                self._status_code)
            return True
        else:
            return False


class ServiceErrorCodeChecker(BaseChecker):
    def __init__(self, status_code, error_code):
        self._status_code = status_code
        self._error_code = error_code

    def _check_response(self, attempt_number, response):
        if response[0].status_code == self._status_code:
            actual_error_code = response[1].get('Error', {}).get('Code')
            if actual_error_code == self._error_code:
                logger.debug(
                    "retry needed: matching HTTP status and error code seen: "
                    "%s, %s", self._status_code, self._error_code)
                return True
        return False


class MultiChecker(BaseChecker):
    def __init__(self, checkers):
        self._checkers = checkers

    def __call__(self, attempt_number, response, caught_exception):
        for checker in self._checkers:
            checker_response = checker(attempt_number, response,
                                       caught_exception)
            if checker_response:
                return checker_response
        return False


class CRC32Checker(BaseChecker):
    def __init__(self, header):
        # The header where the expected crc32 is located.
        self._header_name = header

    def _check_response(self, attempt_number, response):
        http_response = response[0]
        expected_crc = http_response.headers.get(self._header_name)
        if expected_crc is None:
            logger.debug("crc32 check skipped, the %s header is not "
                         "in the http response.", self._header_name)
        else:
            actual_crc32 = crc32(response[0].content) & 0xffffffff
            if not actual_crc32 == int(expected_crc):
                logger.debug(
                    "retry needed: crc32 check failed, expected != actual: "
                    "%s != %s", int(expected_crc), actual_crc32)
                raise ChecksumError(checksum_type='crc32',
                                    expected_checksum=int(expected_crc),
                                    actual_checksum=actual_crc32)


class ExceptionRaiser(BaseChecker):
    """Raise any caught exceptions.

    This class will raise any non None ``caught_exception``.

    """
    def _check_caught_exception(self, attempt_number, caught_exception):
        # This is implementation specific, but this class is useful by
        # coordinating with the MaxAttemptsDecorator.
        # The MaxAttemptsDecorator has a list of exceptions it should catch
        # and retry, but something needs to come along and actually raise the
        # caught_exception.  That's what this class is being used for.  If
        # the MaxAttemptsDecorator is not interested in retrying the exception
        # then this exception just propogates out past the retry code.
        raise caught_exception
                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/botocore/retryhandler.pyc                                     0100644 0000000 0000062 00000031230 13077704401 023253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
Xc           @   s  d  d l  Z  d  d l Z d  d l Z d  d l m Z d  d l m Z m Z d  d l m	 Z	 d  d l
 m Z m Z e j e  Z i e e	 e e g d 6Z d   Z d   Z d d	  Z d d
  Z d d  Z d   Z d   Z d   Z d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ  d e f d     YZ! d e f d     YZ" d S(   iN(   t   crc32(   t   ConnectionErrort   Timeout(   t   ClosedPoolError(   t   ChecksumErrort   EndpointConnectionErrort   GENERAL_CONNECTION_ERRORc         C   sP   |  d k r t  j    }  n |  d k r: t d |    n  |  | | d } | S(   s1  Calculate time to sleep based on exponential function.

    The format is::

        base * growth_factor ^ (attempts - 1)

    If ``base`` is set to 'rand' then a random number between
    0 and 1 will be used as the base.
    Base must be greater than 0, otherwise a ValueError will be
    raised.

    t   randi    s0   The 'base' param must be greater than 0, got: %si   (   t   randomt
   ValueError(   t   baset   growth_factort   attemptst   time_to_sleep(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/retryhandler.pyt   delay_exponential'   s    c         C   s   t  j t d |  d | S(   s   Create an exponential delay function based on the attempts.

    This is used so that you only have to pass it the attempts
    parameter to calculate the delay.

    R
 