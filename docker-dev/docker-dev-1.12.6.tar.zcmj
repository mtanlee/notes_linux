20\e020"
& "\e101\e101"\fR) is not a false value in Perl. You need:
.PP
.Vb 3
\&    if ( ("\e020\e020" & "\e101\e101") !~ /[^\e000]/) {
\&        # ...
\&    }
.Ve
.SS "How do I multiply matrices?"
.IX Subsection "How do I multiply matrices?"
Use the Math::Matrix or Math::MatrixReal modules (available from \s-1CPAN\s0)
or the \s-1PDL\s0 extension (also available from \s-1CPAN\s0).
.SS "How do I perform an operation on a series of integers?"
.IX Subsection "How do I perform an operation on a series of integers?"
To call a function on each element in an array, and collect the
results, use:
.PP
.Vb 1
\&    my @results = map { my_func($_) } @array;
.Ve
.PP
For example:
.PP
.Vb 1
\&    my @triple = map { 3 * $_ } @single;
.Ve
.PP
To call a function on each element of an array, but ignore the
results:
.PP
.Vb 3
\&    foreach my $iterator (@array) {
\&        some_func($iterator);
\&    }
.Ve
.PP
To call a function on each integer in a (small) range, you \fBcan\fR use:
.PP
.Vb 1
\&    my @results = map { some_func($_) } (5 .. 25);
.Ve
.PP
but you should be aware that in this form, the \f(CW\*(C`..\*(C'\fR operator
creates a list of all integers in the range, which can take a lot of
memory for large ranges. However, the problem does not occur when
using \f(CW\*(C`..\*(C'\fR within a \f(CW\*(C`for\*(C'\fR loop, because in that case the range
operator is optimized to \fIiterate\fR over the range, without creating
the entire list. So
.PP
.Vb 4
\&    my @results = ();
\&    for my $i (5 .. 500_005) {
\&        push(@results, some_func($i));
\&    }
.Ve
.PP
or even
.PP
.Vb 1
\&   push(@results, some_func($_)) for 5 .. 500_005;
.Ve
.PP
will not create an intermediate list of 500,000 integers.
.SS "How can I output Roman numerals?"
.IX Subsection "How can I output Roman numerals?"
Get the <http://www.cpan.org/modules/by\-module/Roman> module.
.SS "Why aren't my random numbers random?"
.IX Subsection "Why aren't my random numbers random?"
If you're using a version of Perl before 5.004, you must call \f(CW\*(C`srand\*(C'\fR
once at the start of your program to seed the random number generator.
.PP
.Vb 1
\&     BEGIN { srand() if $] < 5.004 }
.Ve
.PP
5.004 and later automatically call \f(CW\*(C`srand\*(C'\fR at the beginning. Don't
call \f(CW\*(C`srand\*(C'\fR more than once\*(--you make your numbers less random,
rather than more.
.PP
Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :\-). The
\&\fIrandom\fR article in the \*(L"Far More Than You Ever Wanted To Know\*(R"
collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>, courtesy
of Tom Phoenix, talks more about this. John von Neumann said, \*(L"Anyone
who attempts to generate random numbers by deterministic means is, of
course, living in a state of sin.\*(R"
.PP
Perl relies on the underlying system for the implementation of
\&\f(CW\*(C`rand\*(C'\fR and \f(CW\*(C`srand\*(C'\fR; on some systems, the generated numbers are
not random enough (especially on Windows : see
<http://www.perlmonks.org/?node_id=803632>).
Several \s-1CPAN\s0 modules in the \f(CW\*(C`Math\*(C'\fR namespace implement better
pseudorandom generators; see for example
Math::Random::MT (\*(L"Mersenne Twister\*(R", fast), or
Math::TrulyRandom (uses the imperfections in the system's
timer to generate random numbers, which is rather slow).
More algorithms for random numbers are described in
\&\*(L"Numerical Recipes in C\*(R" at <http://www.nr.com/>
.SS "How do I get a random number between X and Y?"
.IX Subsection "How do I get a random number between X and Y?"
To get a random number between two values, you can use the \f(CW\*(C`rand()\*(C'\fR
built-in to get a random number between 0 and 1. From there, you shift
that into the range that you want.
.PP
\&\f(CW\*(C`rand($x)\*(C'\fR returns a number such that \f(CW\*(C`0 <= rand($x) < $x\*(C'\fR. Thus
what you want to have perl figure out is a random number in the range
from 0 to the difference between your \fIX\fR and \fIY\fR.
.PP
That is, to get a number between 10 and 15, inclusive, you want a
random number between 0 and 5 that you can then add to 10.
.PP
.Vb 1
\&    my $number = 10 + int rand( 15\-10+1 ); # ( 10,11,12,13,14, or 15 )
.Ve
.PP
Hence you derive the following simple function to abstract
that. It selects a random integer between the two given
integers (inclusive), For example: \f(CW\*(C`random_int_between(50,120)\*(C'\fR.
.PP
.Vb 7
\&    sub random_int_between {
\&        my($min, $max) = @_;
\&        # Assumes that the two arguments are integers themselves!
\&        return $min if $min == $max;
\&        ($min, $max) = ($max, $min)  if  $min > $max;
\&        return $min + int rand(1 + $max \- $min);
\&    }
.Ve
.SH "Data: Dates"
.IX Header "Data: Dates"
.SS "How do I find the day or week of the year?"
.IX Subsection "How do I find the day or week of the year?"
The day of the year is in the list returned
by the \f(CW\*(C`localtime\*(C'\fR function. Without an
argument \f(CW\*(C`localtime\*(C'\fR uses the current time.
.PP
.Vb 1
\&    my $day_of_year = (localtime)[7];
.Ve
.PP
The \s-1POSIX\s0 module can also format a date as the day of the year or
week of the year.
.PP
.Vb 3
\&    use POSIX qw/strftime/;
\&    my $day_of_year  = strftime "%j", localtime;
\&    my $week_of_year = strftime "%W", localtime;
.Ve
.PP
To get the day of year for any date, use \s-1POSIX\s0's \f(CW\*(C`mktime\*(C'\fR to get
a time in epoch seconds for the argument to \f(CW\*(C`localtime\*(C'\fR.
.PP
.Vb 3
\&    use POSIX qw/mktime strftime/;
\&    my $week_of_year = strftime "%W",
\&        localtime( mktime( 0, 0, 0, 18, 11, 87 ) );
.Ve
.PP
You can also use Time::Piece, which comes with Perl and provides a
\&\f(CW\*(C`localtime\*(C'\fR that returns an object:
.PP
.Vb 3
\&    use Time::Piece;
\&    my $day_of_year  = localtime\->yday;
\&    my $week_of_year = localtime\->week;
.Ve
.PP
The Date::Calc module provides two functions to calculate these, too:
.PP
.Vb 3
\&    use Date::Calc;
\&    my $day_of_year  = Day_of_Year(  1987, 12, 18 );
\&    my $week_of_year = Week_of_Year( 1987, 12, 18 );
.Ve
.SS "How do I find the current century or millennium?"
.IX Subsection "How do I find the current century or millennium?"
Use the following simple functions:
.PP
.Vb 3
\&    sub get_century    {
\&        return int((((localtime(shift || time))[5] + 1999))/100);
\&    }
\&
\&    sub get_millennium {
\&        return 1+int((((localtime(shift || time))[5] + 1899))/1000);
\&    }
.Ve
.PP
On some systems, the \s-1POSIX\s0 module's \f(CW\*(C`strftime()\*(C'\fR function has been
extended in a non-standard way to use a \f(CW%C\fR format, which they
sometimes claim is the \*(L"century\*(R". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to determine reliably the current century or
millennium.
.SS "How can I compare two dates and find the difference?"
.IX Subsection "How can I compare two dates and find the difference?"
(contributed by brian d foy)
.PP
You could just store all your dates as a number and then subtract.
Life isn't always that simple though.
.PP
The Time::Piece module, which comes with Perl, replaces localtime
with a version that returns an object. It also overloads the comparison
operators so you can compare them directly:
.PP
.Vb 3
\&    use Time::Piece;
\&    my $date1 = localtime( $some_time );
\&    my $date2 = localtime( $some_other_time );
\&
\&    if( $date1 < $date2 ) {
\&        print "The date was in the past\en";
\&    }
.Ve
.PP
You can also get differences with a subtraction, which returns a
Time::Seconds object:
.PP
.Vb 2
\&    my $diff = $date1 \- $date2;
\&    print "The difference is ", $date_diff\->days, " days\en";
.Ve
.PP
If you want to work with formatted dates, the Date::Manip,
Date::Calc, or DateTime modules can help you.
.SS "How can I take a string and turn it into epoch seconds?"
.IX Subsection "How can I take a string and turn it into epoch seconds?"
If it's a regular enough string that it always has the same format,
you can split it up and pass the parts to \f(CW\*(C`timelocal\*(C'\fR in the standard
Time::Local module. Otherwise, you should look into the Date::Calc,
Date::Parse, and Date::Manip modules from \s-1CPAN.\s0
.SS "How can I find the Julian Day?"
.IX Subsection "How can I find the Julian Day?"
(contributed by brian d foy and Dave Cross)
.PP
You can use the Time::Piece module, part of the Standard Library,
which can convert a date/time to a Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->julian_day\*(Aq
\&    2455607.7959375
.Ve
.PP
Or the modified Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->mjd\*(Aq
\&    55607.2961226851
.Ve
.PP
Or even the day of the year (which is what some people think of as a
Julian day):
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->yday\*(Aq
\&    45
.Ve
.PP
You can also do the same things with the DateTime module:
.PP
.Vb 6
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->jd\*(Aq
\&    2453401.5
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->mjd\*(Aq
\&    53401
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->doy\*(Aq
\&    31
.Ve
.PP
You can use the Time::JulianDay module available on \s-1CPAN.\s0 Ensure
that you really want to find a Julian day, though, as many people have
different ideas about Julian days (see <http://www.hermetic.ch/cal_stud/jdn.htm>
for instance):
.PP
.Vb 2
\&    $  perl \-MTime::JulianDay \-le \*(Aqprint local_julian_day( time )\*(Aq
\&    55608
.Ve
.SS "How do I find yesterday's date?"
.IX Xref "date yesterday DateTime Date::Calc Time::Local daylight saving time day Today_and_Now localtime timelocal"
.IX Subsection "How do I find yesterday's date?"
(contributed by brian d foy)
.PP
To do it correctly, you can use one of the \f(CW\*(C`Date\*(C'\fR modules since they
work with calendars instead of times. The DateTime module makes it
simple, and give you the same time of day, only the day before,
despite daylight saving time changes:
.PP
.Vb 1
\&    use DateTime;
\&
\&    my $yesterday = DateTime\->now\->subtract( days => 1 );
\&
\&    print "Yesterday was $yesterday\en";
.Ve
.PP
You can also use the Date::Calc module using its \f(CW\*(C`Today_and_Now\*(C'\fR
function.
.PP
.Vb 1
\&    use Date::Calc qw( Today_and_Now Add_Delta_DHMS );
\&
\&    my @date_time = Add_Delta_DHMS( Today_and_Now(), \-1, 0, 0, 0 );
\&
\&    print "@date_time\en";
.Ve
.PP
Most people try to use the time rather than the calendar to figure out
dates, but that assumes that days are twenty-four hours each. For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. For example, the rest of the
suggestions will be wrong sometimes:
.PP
Starting with Perl 5.10, Time::Piece and Time::Seconds are part
of the standard distribution, so you might think that you could do
something like this:
.PP
.Vb 2
\&    use Time::Piece;
\&    use Time::Seconds;
\&
\&    my $yesterday = localtime() \- ONE_DAY; # WRONG
\&    print "Yesterday was $yesterday\en";
.Ve
.PP
The Time::Piece module exports a new \f(CW\*(C`localtime\*(C'\fR that returns an
object, and Time::Seconds exports the \f(CW\*(C`ONE_DAY\*(C'\fR constant that is a
set number of seconds. This means that it always gives the time 24
hours ago, which is not always yesterday. This can cause problems
around the end of daylight saving time when there's one day that is 25
hours long.
.PP
You have the same problem with Time::Local, which will give the wrong
answer for those same special cases:
.PP
.Vb 5
\&    # contributed by Gunnar Hjalmarsson
\&     use Time::Local;
\&     my $today = timelocal 0, 0, 12, ( localtime )[3..5];
\&     my ($d, $m, $y) = ( localtime $today\-86400 )[3..5]; # WRONG
\&     printf "Yesterday: %d\-%02d\-%02d\en", $y+1900, $m+1, $d;
.Ve
.SS "Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?"
.IX Subsection "Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?"
(contributed by brian d foy)
.PP
Perl itself never had a Y2K problem, although that never stopped people
from creating Y2K problems on their own. See the documentation for
\&\f(CW\*(C`localtime\*(C'\fR for its proper use.
.PP
Starting with Perl 5.12, \f(CW\*(C`localtime\*(C'\fR and \f(CW\*(C`gmtime\*(C'\fR can handle dates past
03:14:08 January 19, 2038, when a 32\-bit based time would overflow. You
still might get a warning on a 32\-bit \f(CW\*(C`perl\*(C'\fR:
.PP
.Vb 3
\&    % perl5.12 \-E \*(Aqsay scalar localtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Integer overflow in hexadecimal number at \-e line 1.
\&    Wed Nov  1 19:42:39 5576711
.Ve
.PP
On a 64\-bit \f(CW\*(C`perl\*(C'\fR, you can get even larger dates for those really long
running projects:
.PP
.Vb 2
\&    % perl5.12 \-E \*(Aqsay scalar gmtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Thu Nov  2 00:42:39 5576711
.Ve
.PP
You're still out of luck if you need to keep track of decaying protons
though.
.SH "Data: Strings"
.IX Header "Data: Strings"
.SS "How do I validate input?"
.IX Subsection "How do I validate input?"
(contributed by brian d foy)
.PP
There are many ways to ensure that values are what you expect or
want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with \*(L"Assert\*(R" and \*(L"Validate\*(R"
in their names, along with other modules such as Regexp::Common.
.PP
Some modules have validation for particular types of input, such
as Business::ISBN, Business::CreditCard, Email::Valid,
and Data::Validate::IP.
.SS "How do I unescape a string?"
.IX Subsection "How do I unescape a string?"
It depends just what you mean by \*(L"escape\*(R". \s-1URL\s0 escapes are dealt
with in perlfaq9. Shell escapes with the backslash (\f(CW\*(C`\e\*(C'\fR)
character are removed with
.PP
.Vb 1
\&    s/\e\e(.)/$1/g;
.Ve
.PP
This won't expand \f(CW"\en"\fR or \f(CW"\et"\fR or any other special escapes.
.SS "How do I remove consecutive pairs of characters?"
.IX Subsection "How do I remove consecutive pairs of characters?"
(contributed by brian d foy)
.PP
You can use the substitution operator to find pairs of characters (or
runs of characters) and replace them with a single instance. In this
substitution, we find a character in \f(CW\*(C`(.)\*(C'\fR. The memory parentheses
store the matched character in the back-reference \f(CW\*(C`\eg1\*(C'\fR and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in \f(CW$1\fR.
.PP
.Vb 1
\&    s/(.)\eg1/$1/g;
.Ve
.PP
We can also use the transliteration operator, \f(CW\*(C`tr///\*(C'\fR. In this
example, the search list side of our \f(CW\*(C`tr///\*(C'\fR contains nothing, but
the \f(CW\*(C`c\*(C'\fR option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the \f(CW\*(C`s\*(C'\fR option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself
.PP
.Vb 2
\&    my $str = \*(AqHaarlem\*(Aq;   # in the Netherlands
\&    $str =~ tr///cs;       # Now Harlem, like in New York
.Ve
.SS "How do I expand function calls in a string?"
.IX Subsection "How do I expand function calls in a string?"
(contributed by brian d foy)
.PP
This is documented in perlref, and although it's not the easiest
thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.
.PP
.Vb 1
\&    print "The time values are @{ [localtime] }.\en";
.Ve
.PP
If we want to call the function in scalar context, we have to do a bit
more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need \f(CW\*(C`scalar\*(C'\fR to
force the scalar context on the function:
.PP
.Vb 1
\&    print "The time is ${\e(scalar localtime)}.\en"
\&
\&    print "The time is ${ my $x = localtime; \e$x }.\en";
.Ve
.PP
If your function already returns a reference, you don't need to create
the reference yourself.
.PP
.Vb 1
\&    sub timestamp { my $t = localtime; \e$t }
\&
\&    print "The time is ${ timestamp() }.\en";
.Ve
.PP
The \f(CW\*(C`Interpolation\*(C'\fR module can also do a lot of magic for you. You can
specify a variable name, in this case \f(CW\*(C`E\*(C'\fR, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.
.PP
.Vb 2
\&    use Interpolation E => \*(Aqeval\*(Aq;
\&    print "The time values are $E{localtime()}.\en";
.Ve
.PP
In most cases, it is probably easier to simply use string concatenation,
which also forces scalar context.
.PP
.Vb 1
\&    print "The time is " . localtime() . ".\en";
.Ve
.SS "How do I find matching/nesting anything?"
.IX Subsection "How do I find matching/nesting anything?"
To find something between two single
characters, a pattern like \f(CW\*(C`/x([^x]*)x/\*(C'\fR will get the intervening
bits in \f(CW$1\fR. For multiple ones, then something more like
\&\f(CW\*(C`/alpha(.*?)omega/\*(C'\fR would be needed. For nested patterns
and/or balanced expressions, see the so-called
(?PARNO)
construct (available since perl 5.10).
The \s-1CPAN\s0 module Regexp::Common can help to build such
regular expressions (see in particular
Regexp::Common::balanced and Regexp::Common::delimited).
.PP
More complex cases will require to write a parser, probably
using a parsing module from \s-1CPAN,\s0 like
Regexp::Grammars, Parse::RecDescent, Parse::Yapp,
Text::Balanced, or Marpa::XS.
.SS "How do I reverse a string?"
.IX Subsection "How do I reverse a string?"
Use \f(CW\*(C`reverse()\*(C'\fR in scalar context, as documented in
\&\*(L"reverse\*(R" in perlfunc.
.PP
.Vb 1
\&    my $reversed = reverse $string;
.Ve
.SS "How do I expand tabs in a string?"
.IX Subsection "How do I expand tabs in a string?"
You can do it yourself:
.PP
.Vb 1
\&    1 while $string =~ s/\et+/\*(Aq \*(Aq x (length($&) * 8 \- length($\`) % 8)/e;
.Ve
.PP
Or you can just use the Text::Tabs module (part of the standard Perl
distribution).
.PP
.Vb 2
\&    use Text::Tabs;
\&    my @expanded_lines = expand(@lines_with_tabs);
.Ve
.SS "How do I reformat a paragraph?"
.IX Subsection "How do I reformat a paragraph?"
Use Text::Wrap (part of the standard Perl distribution):
.PP
.Vb 2
\&    use Text::Wrap;
\&    print wrap("\et", \*(Aq  \*(Aq, @paragraphs);
.Ve
.PP
The paragraphs you give to Text::Wrap should not contain embedded
newlines. Text::Wrap doesn't justify the lines (flush-right).
.PP
Or use the \s-1CPAN\s0 module Text::Autoformat. Formatting files can be
easily done by making a shell alias, like so:
.PP
.Vb 2
\&    alias fmt="perl \-i \-MText::Autoformat \-n0777 \e
\&        \-e \*(Aqprint autoformat $_, {all=>1}\*(Aq $*"
.Ve
.PP
See the documentation for Text::Autoformat to appreciate its many
capabilities.
.SS "How can I access or change N characters of a string?"
.IX Subsection "How can I access or change N characters of a string?"
You can access the first characters of a string with \fIsubstr()\fR.
To get the first character, for example, start at position 0
and grab the string of length 1.
.PP
.Vb 2
\&    my $string = "Just another Perl Hacker";
\&    my $first_char = substr( $string, 0, 1 );  #  \*(AqJ\*(Aq
.Ve
.PP
To change part of a string, you can use the optional fourth
argument which is the replacement string.
.PP
.Vb 1
\&    substr( $string, 13, 4, "Perl 5.8.0" );
.Ve
.PP
You can also use \fIsubstr()\fR as an lvalue.
.PP
.Vb 1
\&    substr( $string, 13, 4 ) =  "Perl 5.8.0";
.Ve
.SS "How do I change the Nth occurrence of something?"
.IX Subsection "How do I change the Nth occurrence of something?"
You have to keep track of N yourself. For example, let's say you want
to change the fifth occurrence of \f(CW"whoever"\fR or \f(CW"whomever"\fR into
\&\f(CW"whosoever"\fR or \f(CW"whomsoever"\fR, case insensitively. These
all assume that \f(CW$_\fR contains the string to be altered.
.PP
.Vb 6
\&    $count = 0;
\&    s{((whom?)ever)}{
\&    ++$count == 5       # is it the 5th?
\&        ? "${2}soever"  # yes, swap
\&        : $1            # renege and leave it there
\&        }ige;
.Ve
.PP
In the more general case, you can use the \f(CW\*(C`/g\*(C'\fR modifier in a \f(CW\*(C`while\*(C'\fR
loop, keeping count of matches.
.PP
.Vb 8
\&    $WANT = 3;
\&    $count = 0;
\&    $_ = "One fish two fish red fish blue fish";
\&    while (/(\ew+)\es+fish\eb/gi) {
\&        if (++$count == $WANT) {
\&            print "The third fish is a $1 one.\en";
\&        }
\&    }
.Ve
.PP
That prints out: \f(CW"The third fish is a red one."\fR  You can also use a
repetition count and repeated pattern like this:
.PP
.Vb 1
\&    /(?:\ew+\es+fish\es+){2}(\ew+)\es+fish/i;
.Ve
.SS "How can I count the number of occurrences of a substring within a string?"
.IX Subsection "How can I count the number of occurrences of a substring within a string?"
There are a number of ways, with varying efficiency. If you want a
count of a certain single character (X) within a string, you can use the
\&\f(CW\*(C`tr///\*(C'\fR function like so:
.PP
.Vb 3
\&    my $string = "ThisXlineXhasXsomeXx\*(AqsXinXit";
\&    my $count = ($string =~ tr/X//);
\&    print "There are $count X characters in the string";
.Ve
.PP
This is fine if you are just looking for a single character. However,
if you are trying to count multiple character substrings within a
larger string, \f(CW\*(C`tr///\*(C'\fR won't work. What you can do is wrap a \fIwhile()\fR
loop around a global pattern match. For example, let's count negative
integers:
.PP
.Vb 4
\&    my $string = "\-9 55 48 \-2 23 \-76 4 14 \-44";
\&    my $count = 0;
\&    while ($string =~ /\-\ed+/g) { $count++ }
\&    print "There are $count negative numbers in the string";
.Ve
.PP
Another version uses a global match in list context, then assigns the
result to a scalar, producing a count of the number of matches.
.PP
.Vb 1
\&    my $count = () = $string =~ /\-\ed+/g;
.Ve
.SS "How do I capitalize all the words on one line?"
.IX Xref "Text::Autoformat capitalize case, title case, sentence"
.IX Subsection "How do I capitalize all the words on one line?"
(contributed by brian d foy)
.PP
Damian Conway's Text::Autoformat handles all of the thinking
for you.
.PP
.Vb 3
\&    use Text::Autoformat;
\&    my $x = "Dr. Strangelove or: How I Learned to Stop ".
\&      "Worrying and Love the Bomb";
\&
\&    print $x, "\en";
\&    for my $style (qw( sentence title highlight )) {
\&        print autoformat($x, { case => $style }), "\en";
\&    }
.Ve
.PP
How do you want to capitalize those words?
.PP
.Vb 3
\&    FRED AND BARNEY\*(AqS LODGE        # all uppercase
\&    Fred And Barney\*(Aqs Lodge        # title case
\&    Fred and Barney\*(Aqs Lodge        # highlight case
.Ve
.PP
It's not as easy a problem as it looks. How many words do you think
are in there? Wait for it... wait for it.... If you answered 5
you're right. Perl words are groups of \f(CW\*(C`\ew+\*(C'\fR, but that's not what
you want to capitalize. How is Perl supposed to know not to capitalize
that \f(CW\*(C`s\*(C'\fR after the apostrophe? You could try a regular expression:
.PP
.Vb 6
\&    $string =~ s/ (
\&                 (^\ew)    #at the beginning of the line
\&                   |      # or
\&                 (\es\ew)   #preceded by whitespace
\&                   )
\&                /\eU$1/xg;
\&
\&    $string =~ s/([\ew\*(Aq]+)/\eu\eL$1/g;
.Ve
.PP
Now, what if you don't want to capitalize that \*(L"and\*(R"? Just use
Text::Autoformat and get on with the next problem. :)
.SS "How can I split a [character]\-delimited string except when inside [character]?"
.IX Subsection "How can I split a [character]-delimited string except when inside [character]?"
Several modules can handle this sort of parsing\*(--Text::Balanced,
Text::CSV, Text::CSV_XS, and Text::ParseWords, among others.
.PP
Take the example case of trying to split a string that is
comma-separated into its different fields. You can't use \f(CW\*(C`split(/,/)\*(C'\fR
because you shouldn't split if the comma is inside quotes. For
example, take a data line like this:
.PP
.Vb 1
\&    SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"
.Ve
.PP
Due to the restriction of the quotes, this is a fairly complex
problem. Thankfully, we have Jeffrey Friedl, author of
\&\fIMastering Regular Expressions\fR, to handle these for us. He
suggests (assuming your string is contained in \f(CW$text\fR):
.PP
.Vb 7
\&     my @new = ();
\&     push(@new, $+) while $text =~ m{
\&         "([^\e"\e\e]*(?:\e\e.[^\e"\e\e]*)*)",? # groups the phrase inside the quotes
\&        | ([^,]+),?
\&        | ,
\&     }gx;
\&     push(@new, undef) if substr($text,\-1,1) eq \*(Aq,\*(Aq;
.Ve
.PP
If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg,
\&\f(CW"like \e"this\e""\fR.
.PP
Alternatively, the Text::ParseWords module (part of the standard
Perl distribution) lets you say:
.PP
.Vb 2
\&    use Text::ParseWords;
\&    @new = quotewords(",", 0, $text);
.Ve
.PP
For parsing or generating \s-1CSV,\s0 though, using Text::CSV rather than
implementing it yourself is highly recommended; you'll save yourself odd bugs
popping up later by just using code which has already been tried and tested in
production for years.
.SS "How do I strip blank space from the beginning/end of a string?"
.IX Subsection "How do I strip blank space from the beginning/end of a string?"
(contributed by brian d foy)
.PP
A substitution can do this for you. For a single line, you want to
replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions:
.PP
.Vb 2
\&    s/^\es+//;
\&    s/\es+$//;
.Ve
.PP
You can also write that as a single substitution, although it turns
out the combined statement is slower than the separate ones. That
might not matter to you, though:
.PP
.Vb 1
\&    s/^\es+|\es+$//g;
.Ve
.PP
In this regular expression, the alternation matches either at the
beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the \f(CW\*(C`/g\*(C'\fR flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the \f(CW\*(C`\es+\*(C'\fR, and  the \f(CW\*(C`$\*(C'\fR anchor can match to the
absolute end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
\&\*(L"blank\*(R" (consisting entirely of whitespace) lines which the \f(CW\*(C`^\es+\*(C'\fR
would remove all by itself:
.PP
.Vb 4
\&    while( <> ) {
\&        s/^\es+|\es+$//g;
\&        print "$_\en";
\&    }
.Ve
.PP
For a multi-line string, you can apply the regular expression to each
logical line in the string by adding the \f(CW\*(C`/m\*(C'\fR flag (for
\&\*(L"multi-line\*(R"). With the \f(CW\*(C`/m\*(C'\fR flag, the \f(CW\*(C`$\*(C'\fR matches \fIbefore\fR an
embedded newline, so it doesn't remove it. This pattern still removes
the newline at the end of the string:
.PP
.Vb 1
\&    $string =~ s/^\es+|\es+$//gm;
.Ve
.PP
Remember that lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire string
and replace it with nothing. If you need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace:
.PP
.Vb 1
\&    $string =~ s/^[\et\ef ]+|[\et\ef ]+$//mg;
.Ve
.SS "How do I pad a string with blanks or pad a number with zeroes?"
.IX Subsection "How do I pad a string with blanks or pad a number with zeroes?"
In the following examples, \f(CW$pad_len\fR is the length to which you wish
to pad the string, \f(CW$text\fR or \f(CW$num\fR contains the string to be padded,
and \f(CW$pad_char\fR contains the padding character. You can use a single
character string constant instead of the \f(CW$pad_char\fR variable if you
know what it is in advance. And in the same way you can use an integer in
place of \f(CW$pad_len\fR if you know the pad length in advance.
.PP
The simplest method uses the \f(CW\*(C`sprintf\*(C'\fR function. It can pad on the left
or right with blanks and on the left with zeroes and it will not
truncate the result. The \f(CW\*(C`pack\*(C'\fR function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
\&\f(CW$pad_len\fR.
.PP
.Vb 3
\&    # Left padding a string with blanks (no truncation):
\&    my $padded = sprintf("%${pad_len}s", $text);
\&    my $padded = sprintf("%*s", $pad_len, $text);  # same thing
\&
\&    # Right padding a string with blanks (no truncation):
\&    my $padded = sprintf("%\-${pad_len}s", $text);
\&    my $padded = sprintf("%\-*s", $pad_len, $text); # same thing
\&
\&    # Left padding a number with 0 (no truncation):
\&    my $padded = sprintf("%0${pad_len}d", $num);
\&    my $padded = sprintf("%0*d", $pad_len, $num); # same thing
\&
\&    # Right padding a string with blanks using pack (will truncate):
\&    my $padded = pack("A$pad_len",$text);
.Ve
.PP
If you need to pad with a character other than blank or zero you can use
one of the following methods. They all generate a pad string with the
\&\f(CW\*(C`x\*(C'\fR operator and combine that with \f(CW$text\fR. These methods do
not truncate \f(CW$text\fR.
.PP
Left and right padding with any character, creating a new string:
.PP
.Vb 2
\&    my $padded = $pad_char x ( $pad_len \- length( $text ) ) . $text;
\&    my $padded = $text . $pad_char x ( $pad_len \- length( $text ) );
.Ve
.PP
Left and right padding with any character, modifying \f(CW$text\fR directly:
.PP
.Vb 2
\&    substr( $text, 0, 0 ) = $pad_char x ( $pad_len \- length( $text ) );
\&    $text .= $pad_char x ( $pad_len \- length( $text ) );
.Ve
.SS "How do I extract selected columns from a string?"
.IX Subsection "How do I extract selected columns from a string?"
(contributed by brian d foy)
.PP
If you know the columns that contain the data, you can
use \f(CW\*(C`substr\*(C'\fR to extract a single column.
.PP
.Vb 1
\&    my $column = substr( $line, $start_column, $length );
.Ve
.PP
You can use \f(CW\*(C`split\*(C'\fR if the columns are separated by whitespace or
some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.
.PP
.Vb 3
\&    my $line    = \*(Aq fred barney   betty   \*(Aq;
\&    my @columns = split /\es+/, $line;
\&        # ( \*(Aq\*(Aq, \*(Aqfred\*(Aq, \*(Aqbarney\*(Aq, \*(Aqbetty\*(Aq );
\&
\&    my $line    = \*(Aqfred||barney||betty\*(Aq;
\&    my @columns = split /\e|/, $line;
\&        # ( \*(Aqfred\*(Aq, \*(Aq\*(Aq, \*(Aqbarney\*(Aq, \*(Aq\*(Aq, \*(Aqbetty\*(Aq );
.Ve
.PP
If you want to work with comma-separated values, don't do this since
that format is a bit more complicated. Use one of the modules that
handle that format, such as Text::CSV, Text::CSV_XS, or
Text::CSV_PP.
.PP
If you want to break apart an entire line of fixed columns, you can use
\&\f(CW\*(C`unpack\*(C'\fR with the A (\s-1ASCII\s0) format. By using a number after the format
specifier, you can denote the column width. See the \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
entries in perlfunc for more details.
.PP
.Vb 1
\&    my @fields = unpack( $line, "A8 A8 A8 A16 A4" );
.Ve
.PP
Note that spaces in the format argument to \f(CW\*(C`unpack\*(C'\fR do not denote literal
spaces. If you have space separated data, you may want \f(CW\*(C`split\*(C'\fR instead.
.SS "How do I find the soundex value of a string?"
.IX Subsection "How do I find the soundex value of a string?"
(contributed by brian d foy)
.PP
You can use the \f(CW\*(C`Text::Soundex\*(C'\fR module. If you want to do fuzzy or close
matching, you might also try the String::Approx, and
Text::Metaphone, and Text::DoubleMetaphone modules.
.SS "How can I expand variables in text strings?"
.IX Subsection "How can I expand variables in text strings?"
(contributed by brian d foy)
.PP
If you can avoid it, don't, or if you can use a templating system,
such as Text::Template or Template Toolkit, do that instead. You
might even be able to get the job done with \f(CW\*(C`sprintf\*(C'\fR or \f(CW\*(C`printf\*(C'\fR:
.PP
.Vb 1
\&    my $string = sprintf \*(AqSay hello to %s and %s\*(Aq, $foo, $bar;
.Ve
.PP
However, for the one-off simple case where I don't want to pull out a
full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand \f(CW$foo\fR and \f(CW$bar\fR
to their variable's values:
.PP
.Vb 3
\&    my $foo = \*(AqFred\*(Aq;
\&    my $bar = \*(AqBarney\*(Aq;
\&    $string = \*(AqSay hello to $foo and $bar\*(Aq;
.Ve
.PP
One way I can do this involves the substitution operator and a double
\&\f(CW\*(C`/e\*(C'\fR flag. The first \f(CW\*(C`/e\*(C'\fR evaluates \f(CW$1\fR on the replacement side and
turns it into \f(CW$foo\fR. The second /e starts with \f(CW$foo\fR and replaces
it with its value. \f(CW$foo\fR, then, turns into 'Fred', and that's finally
what's left in the string:
.PP
.Vb 1
\&    $string =~ s/(\e$\ew+)/$1/eeg; # \*(AqSay hello to Fred and Barney\*(Aq
.Ve
.PP
The \f(CW\*(C`/e\*(C'\fR will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since I'm using the
\&\f(CW\*(C`/e\*(C'\fR flag (twice even!), I have all of the same security problems I
have with \f(CW\*(C`eval\*(C'\fR in its string form. If there's something odd in
\&\f(CW$foo\fR, perhaps something like \f(CW\*(C`@{[ system "rm \-rf /" ]}\*(C'\fR, then
I could get myself in trouble.
.PP
To get around the security problem, I could also pull the values from
a hash instead of evaluating variable names. Using a single \f(CW\*(C`/e\*(C'\fR, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case \f(CW\*(C`???\*(C'\fR to
signal that I missed something:
.PP
.Vb 1
\&    my $string = \*(AqThis has $foo and $bar\*(Aq;
\&
\&    my %Replacements = (
\&        foo  => \*(AqFred\*(Aq,
\&        );
\&
\&    # $string =~ s/\e$(\ew+)/$Replacements{$1}/g;
\&    $string =~ s/\e$(\ew+)/
\&        exists $Replacements{$1} ? $Replacements{$1} : \*(Aq???\*(Aq
\&        /eg;
\&
\&    print $string;
.Ve
.ie n .SS "What's wrong with always quoting ""$vars""?"
.el .SS "What's wrong with always quoting ``$vars''?"
.IX Subsection "What's wrong with always quoting $vars?"
The problem is that those double-quotes force
stringification\*(--coercing numbers and references into strings\*(--even
when you don't want them to be strings. Think of it this way:
double-quote expansion is used to produce new strings. If you already
have a string, why do you need more?
.PP
If you get used to writing odd things like these:
.PP
.Vb 3
\&    print "$var";       # BAD
\&    my $new = "$old";       # BAD
\&    somefunc("$var");    # BAD
.Ve
.PP
You'll be in trouble. Those should (in 99.8% of the cases) be
the simpler and more direct:
.PP
.Vb 3
\&    print $var;
\&    my $new = $old;
\&    somefunc($var);
.Ve
.PP
Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but
a reference:
.PP
.Vb 5
\&    func(\e@array);
\&    sub func {
\&        my $aref = shift;
\&        my $oref = "$aref";  # WRONG
\&    }
.Ve
.PP
You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a
number, such as the magical \f(CW\*(C`++\*(C'\fR autoincrement operator or the
\&\fIsyscall()\fR function.
.PP
Stringification also destroys arrays.
.PP
.Vb 3
\&    my @lines = \`command\`;
\&    print "@lines";     # WRONG \- extra blanks
\&    print @lines;       # right
.Ve
.SS "Why don't my <<\s-1HERE\s0 documents work?"
.IX Subsection "Why don't my <<HERE documents work?"
Here documents are found in perlop. Check for these three things:
.IP "There must be no space after the << part." 4
.IX Item "There must be no space after the << part."
.PD 0
.IP "There (probably) should be a semicolon at the end of the opening token" 4
.IX Item "There (probably) should be a semicolon at the end of the opening token"
.IP "You can't (easily) have any space in front of the tag." 4
.IX Item "You can't (easily) have any space in front of the tag."
.IP "There needs to be at least a line separator after the end token." 4
.IX Item "There needs to be at least a line separator after the end token."
.PD
.PP
If you want to indent the text in the here document, you
can do this:
.PP
.Vb 5
\&    # all in one
\&    (my $VAR = <<HERE_TARGET) =~ s/^\es+//gm;
\&        your text
\&        goes here
\&    HERE_TARGET
.Ve
.PP
But the \s-1HERE_TARGET\s0 must still be flush against the margin.
If you want that indented also, you'll have to quote
in the indentation.
.PP
.Vb 7
\&    (my $quote = <<\*(Aq    FINIS\*(Aq) =~ s/^\es+//gm;
\&            ...we will have peace, when you and all your works have
\&            perished\-\-and the works of your dark master to whom you
\&            would deliver us. You are a liar, Saruman, and a corrupter
\&            of men\*(Aqs hearts. \-\-Theoden in /usr/src/perl/taint.c
\&        FINIS
\&    $quote =~ s/\es+\-\-/\en\-\-/;
.Ve
.PP
A nice general-purpose fixer-upper function for indented here documents
follows. It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that substring off. Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
subsequent line.
.PP
.Vb 11
\&    sub fix {
\&        local $_ = shift;
\&        my ($white, $leader);  # common whitespace and common leading string
\&        if (/^\es*(?:([^\ew\es]+)(\es*).*\en)(?:\es*\eg1\eg2?.*\en)+$/) {
\&            ($white, $leader) = ($2, quotemeta($1));
\&        } else {
\&            ($white, $leader) = (/^(\es+)/, \*(Aq\*(Aq);
\&        }
\&        s/^\es*?$leader(?:$white)?//gm;
\&        return $_;
\&    }
.Ve
.PP
This works with leading special strings, dynamically determined:
.PP
.Vb 10
\&    my $remember_the_main = fix<<\*(Aq    MAIN_INTERPRETER_LOOP\*(Aq;
\&    @@@ int
\&    @@@ runops() {
\&    @@@     SAVEI32(runlevel);
\&    @@@     runlevel++;
\&    @@@     while ( op = (*op\->op_ppaddr)() );
\&    @@@     TAINT_NOT;
\&    @@@     return 0;
\&    @@@ }
\&    MAIN_INTERPRETER_LOOP
.Ve
.PP
Or with a fixed amount of leading whitespace, with remaining
indentation correctly preserved:
.PP
.Vb 9
\&    my $poem = fix<<EVER_ON_AND_ON;
\&       Now far ahead the Road has gone,
\&      And I must follow, if I can,
\&       Pursuing it with eager feet,
\&      Until it joins some larger way
\&       Where many paths and errands meet.
\&      And whither then? I cannot say.
\&        \-\-Bilbo in /usr/src/perl/pp_ctl.c
\&    EVER_ON_AND_ON
.Ve
.SH "Data: Arrays"
.IX Header "Data: Arrays"
.SS "What is the difference between a list and an array?"
.IX Subsection "What is the difference between a list and an array?"
(contributed by brian d foy)
.PP
A list is a fixed collection of scalars. An array is a variable that
holds a variable collection of scalars. An array can supply its collection
for list operations, so list operations also work on arrays:
.PP
.Vb 3
\&    # slices
\&    ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq )[2,3];
\&    @animals[2,3];
\&
\&    # iteration
\&    foreach ( qw( dog cat bird ) ) { ... }
\&    foreach ( @animals ) { ... }
\&
\&    my @three = grep { length == 3 } qw( dog cat bird );
\&    my @three = grep { length == 3 } @animals;
\&
\&    # supply an argument list
\&    wash_animals( qw( dog cat bird ) );
\&    wash_animals( @animals );
.Ve
.PP
Array operations, which change the scalars, rearrange them, or add
or subtract some scalars, only work on arrays. These can't work on a
list, which is fixed. Array operations include \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR,
\&\f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, and \f(CW\*(C`splice\*(C'\fR.
.PP
An array can also change its length:
.PP
.Vb 2
\&    $#animals = 1;  # truncate to two elements
\&    $#animals = 10000; # pre\-extend to 10,001 elements
.Ve
.PP
You can change an array element, but you can't change a list element:
.PP
.Vb 2
\&    $animals[0] = \*(AqRottweiler\*(Aq;
\&    qw( dog cat bird )[0] = \*(AqRottweiler\*(Aq; # syntax error!
\&
\&    foreach ( @animals ) {
\&        s/^d/fr/;  # works fine
\&    }
\&
\&    foreach ( qw( dog cat bird ) ) {
\&        s/^d/fr/;  # Error! Modification of read only value!
\&    }
.Ve
.PP
However, if the list element is itself a variable, it appears that you
can change a list element. However, the list element is the variable, not
the data. You're not changing the list element, but something the list
element refers to. The list element itself doesn't change: it's still
the same variable.
.PP
You also have to be careful about context. You can assign an array to
a scalar to get the number of elements in the array. This only works
for arrays, though:
.PP
.Vb 1
\&    my $count = @animals;  # only works with arrays
.Ve
.PP
If you try to do the same thing with what you think is a list, you
get a quite different result. Although it looks like you have a list
on the righthand side, Perl actually sees a bunch of scalars separated
by a comma:
.PP
.Vb 1
\&    my $scalar = ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq );  # $scalar gets bird
.Ve
.PP
Since you're assigning to a scalar, the righthand side is in scalar
context. The comma operator (yes, it's an operator!) in scalar
context evaluates its lefthand side, throws away the result, and
evaluates it's righthand side and returns the result. In effect,
that list-lookalike assigns to \f(CW$scalar\fR it's rightmost value. Many
people mess this up because they choose a list-lookalike whose
last element is also the count they expect:
.PP
.Vb 1
\&    my $scalar = ( 1, 2, 3 );  # $scalar gets 3, accidentally
.Ve
.ie n .SS "What is the difference between $array[1] and @array[1]?"
.el .SS "What is the difference between \f(CW$array\fP[1] and \f(CW@array\fP[1]?"
.IX Subsection "What is the difference between $array[1] and @array[1]?"
(contributed by brian d foy)
.PP
The difference is the sigil, that special character in front of the
array name. The \f(CW\*(C`$\*(C'\fR sigil means \*(L"exactly one item\*(R", while the \f(CW\*(C`@\*(C'\fR
sigil means \*(L"zero or more items\*(R". The \f(CW\*(C`$\*(C'\fR gets you a single scalar,
while the \f(CW\*(C`@\*(C'\fR gets you a list.
.PP
The confusion arises because people incorrectly assume that the sigil
denotes the variable type.
.PP
The \f(CW$array[1]\fR is a single-element access to the array. It's going
to return the item in index 1 (or undef if there is no item there).
If you intend to get exactly one element from the array, this is the
form you should use.
.PP
The \f(CW@array[1]\fR is an array slice, although it has only one index.
You can pull out multiple elements simultaneously by specifying
additional indices as a list, like \f(CW@array[1,4,3,0]\fR.
.PP
Using a slice on the lefthand side of the assignment supplies list
context to the righthand side. This can lead to unexpected results.
For instance, if you want to read a single line from a filehandle,
assigning to a scalar value is fine:
.PP
.Vb 1
\&    $array[1] = <STDIN>;
.Ve
.PP
However, in list context, the line input operator returns all of the
lines as a list. The first line goes into \f(CW@array[1]\fR and the rest
of the lines mysteriously disappear:
.PP
.Vb 1
\&    @array[1] = <STDIN>;  # most likely not what you want
.Ve
.PP
Either the \f(CW\*(C`use warnings\*(C'\fR pragma or the \fB\-w\fR flag will warn you when
you use an array slice with a single index.
.SS "How can I remove duplicate elements from a list or array?"
.IX Subsection "How can I remove duplicate elements from a list or array?"
(contributed by brian d foy)
.PP
Use a hash. When you think the words \*(L"unique\*(R" or \*(L"duplicated\*(R", think
\&\*(L"hash keys\*(R".
.PP
If you don't care about the order of the elements, you could just
create the hash then extract the keys. It's not important how you
create that hash: just that you use \f(CW\*(C`keys\*(C'\fR to get the unique
elements.
.PP
.Vb 3
\&    my %hash   = map { $_, 1 } @array;
\&    # or a hash slice: @hash{ @array } = ();
\&    # or a foreach: $hash{$_} = 1 foreach ( @array );
\&
\&    my @unique = keys %hash;
.Ve
.PP
If you want to use a module, try the \f(CW\*(C`uniq\*(C'\fR function from
List::MoreUtils. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.
.PP
.Vb 1
\&    use List::MoreUtils qw(uniq);
\&
\&    my @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
\&    my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7
.Ve
.PP
You can also go through each element and skip the ones you've seen
before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in \f(CW%Seen\fR. The \f(CW\*(C`next\*(C'\fR statement
creates the key and immediately uses its value, which is \f(CW\*(C`undef\*(C'\fR, so
the loop continues to the \f(CW\*(C`push\*(C'\fR and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash \fIand\fR the value for that key is true (since it's not 0 or
\&\f(CW\*(C`undef\*(C'\fR), so the next skips that iteration and the loop goes to the
next element.
.PP
.Vb 2
\&    my @unique = ();
\&    my %seen   = ();
\&
\&    foreach my $elem ( @array ) {
\&        next if $seen{ $elem }++;
\&        push @unique, $elem;
\&    }
.Ve
.PP
You can write this more briefly using a grep, which does the
same thing.
.PP
.Vb 2
\&    my %seen = ();
\&    my @unique = grep { ! $seen{ $_ }++ } @array;
.Ve
.SS "How can I tell whether a certain element is contained in a list or array?"
.IX Subsection "How can I tell whether a certain element is contained in a list or array?"
(portions of this answer contributed by Anno Siegel and brian d foy)
.PP
Hearing the word \*(L"in\*(R" is an \fIin\fRdication that you probably should have
used a hash, not a list or array, to store your data. Hashes are
designed to answer this question quickly and efficiently. Arrays aren't.
.PP
That being said, there are several ways to approach this. In Perl 5.10
and later, you can use the smart match operator to check that an item is
contained in an array or a hash:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( $item ~~ @array ) {
\&        say "The array contains $item"
\&    }
\&
\&    if( $item ~~ %hash ) {
\&        say "The hash contains $item"
\&    }
.Ve
.PP
With earlier versions of Perl, you have to do a bit more work. If you
are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values:
.PP
.Vb 3
\&    my @blues = qw/azure cerulean teal turquoise lapis\-lazuli/;
\&    my %is_blue = ();
\&    for (@blues) { $is_blue{$_} = 1 }
.Ve
.PP
Now you can check whether \f(CW$is_blue{$some_color}\fR. It might have
been a good idea to keep the blues all in a hash in the first place.
.PP
If the values are all small integers, you could use a simple indexed
array. This kind of an array will take up less space:
.PP
.Vb 4
\&    my @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
\&    my @is_tiny_prime = ();
\&    for (@primes) { $is_tiny_prime[$_] = 1 }
\&    # or simply  @istiny_prime[@primes] = (1) x @primes;
.Ve
.PP
Now you check whether \f(CW$is_tiny_prime\fR[$some_number].
.PP
If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:
.PP
.Vb 3
\&    my @articles = ( 1..10, 150..2000, 2017 );
\&    undef $read;
\&    for (@articles) { vec($read,$_,1) = 1 }
.Ve
.PP
Now check whether \f(CW\*(C`vec($read,$n,1)\*(C'\fR is true for some \f(CW$n\fR.
.PP
These methods guarantee fast individual tests but require a re-organization
of the original list or array. They only pay off if you have to test
multiple values against the same array.
.PP
If you are testing only once, the standard module List::Util exports
the function \f(CW\*(C`first\*(C'\fR for this purpose. It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalent
looks like this subroutine:
.PP
.Vb 7
\&    sub first (&@) {
\&        my $code = shift;
\&        foreach (@_) {
\&            return $_ if &{$code}();
\&        }
\&        undef;
\&    }
.Ve
.PP
If speed is of little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.
.PP
.Vb 1
\&    my $is_there = grep $_ eq $whatever, @array;
.Ve
.PP
If you want to actually extract the matching elements, simply use grep in
list context.
.PP
.Vb 1
\&    my @matches = grep $_ eq $whatever, @array;
.Ve
.SS "How do I compute the difference of two arrays? How do I compute the intersection of two arrays?"
.IX Subsection "How do I compute the difference of two arrays? How do I compute the intersection of two arrays?"
Use a hash. Here's code to do both and more. It assumes that each
element is unique in a given array:
.PP
.Vb 7
\&    my (@union, @intersection, @difference);
\&    my %count = ();
\&    foreach my $element (@array1, @array2) { $count{$element}++ }
\&    foreach my $element (keys %count) {
\&        push @union, $element;
\&        push @{ $count{$element} > 1 ? \e@intersection : \e@difference }, $element;
\&    }
.Ve
.PP
Note that this is the \fIsymmetric difference\fR, that is, all elements
in either A or in B but not in both. Think of it as an xor operation.
.SS "How do I test whether two arrays or hashes are equal?"
.IX Subsection "How do I test whether two arrays or hashes are equal?"
With Perl 5.10 and later, the smart match operator can give you the answer
with the least amount of work:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( @array1 ~~ @array2 ) {
\&        say "The arrays are the same";
\&    }
\&
\&    if( %hash1 ~~ %hash2 ) # doesn\*(Aqt check values!  {
\&        say "The hash keys are the same";
\&    }
.Ve
.PP
The following code works for single-level arrays. It uses a
stringwise comparison, and does not distinguish defined versus
undefined empty strings. Modify if you have other needs.
.PP
.Vb 1
\&    $are_equal = compare_arrays(\e@frogs, \e@toads);
\&
\&    sub compare_arrays {
\&        my ($first, $second) = @_;
\&        no warnings;  # silence spurious \-w undef complaints
\&        return 0 unless @$first == @$second;
\&        for (my $i = 0; $i < @$first; $i++) {
\&            return 0 if $first\->[$i] ne $second\->[$i];
\&        }
\&        return 1;
\&    }
.Ve
.PP
For multilevel structures, you may wish to use an approach more
like this one. It uses the \s-1CPAN\s0 module FreezeThaw:
.PP
.Vb 2
\&    use FreezeThaw qw(cmpStr);
\&    my @a = my @b = ( "this", "that", [ "more", "stuff" ] );
\&
\&    printf "a and b contain %s arrays\en",
\&        cmpStr(\e@a, \e@b) == 0
\&        ? "the same"
\&        : "different";
.Ve
.PP
This approach also works for comparing hashes. Here we'll demonstrate
two different answers:
.PP
.Vb 1
\&    use FreezeThaw qw(cmpStr cmpStrHard);
\&
\&    my %a = my %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
\&    $a{EXTRA} = \e%b;
\&    $b{EXTRA} = \e%a;
\&
\&    printf "a and b contain %s hashes\en",
\&    cmpStr(\e%a, \e%b) == 0 ? "the same" : "different";
\&
\&    printf "a and b contain %s hashes\en",
\&    cmpStrHard(\e%a, \e%b) == 0 ? "the same" : "different";
.Ve
.PP
The first reports that both those the hashes contain the same data,
while the second reports that they do not. Which you prefer is left as
an exercise to the reader.
.SS "How do I find the first array element for which a condition is true?"
.IX Subsection "How do I find the first array element for which a condition is true?"
To find the first array element which satisfies a condition, you can
use the \f(CW\*(C`first()\*(C'\fR function in the List::Util module, which comes
with Perl 5.8. This example finds the first element that contains
\&\*(L"Perl\*(R".
.PP
.Vb 1
\&    use List::Util qw(first);
\&
\&    my $element = first { /Perl/ } @array;
.Ve
.PP
If you cannot use List::Util, you can make your own loop to do the
same thing. Once you find the element, you stop the loop with last.
.PP
.Vb 4
\&    my $found;
\&    foreach ( @array ) {
\&        if( /Perl/ ) { $found = $_; last }
\&    }
.Ve
.PP
If you want the array index, use the \f(CW\*(C`firstidx()\*(C'\fR function from
\&\f(CW\*(C`List::MoreUtils\*(C'\fR:
.PP
.Vb 2
\&    use List::MoreUtils qw(firstidx);
\&    my $index = firstidx { /Perl/ } @array;
.Ve
.PP
Or write it yourself, iterating through the indices
and checking the array element at each index until you find one
that satisfies the condition:
.PP
.Vb 8
\&    my( $found, $index ) = ( undef, \-1 );
\&    for( $i = 0; $i < @array; $i++ ) {
\&        if( $array[$i] =~ /Perl/ ) {
\&            $found = $array[$i];
\&            $index = $i;
\&            last;
\&        }
\&    }
.Ve
.SS "How do I handle linked lists?"
.IX Subsection "How do I handle linked lists?"
(contributed by brian d foy)
.PP
Perl's arrays do not have a fixed size, so you don't need linked lists
if you just want to add or remove items. You can use array operations
such as \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, or \f(CW\*(C`splice\*(C'\fR to do
that.
.PP
Sometimes, however, linked lists can be useful in situations where you
want to \*(L"shard\*(R" an array so you have have many small arrays instead of
a single big array. You can keep arrays longer than Perl's largest
array index, lock smaller arrays separately in threaded programs,
reallocate less memory, or quickly insert elements in the middle of
the chain.
.PP
Steve Lembark goes through the details in his \s-1YAPC::NA 2009\s0 talk \*(L"Perly
Linked Lists\*(R" ( <http://www.slideshare.net/lembark/perly\-linked\-lists> ),
although you can just use his LinkedList::Single module.
.SS "How do I handle circular lists?"
.IX Xref "circular array Tie::Cycle Array::Iterator::Circular cycle modulus"
.IX Subsection "How do I handle circular lists?"
(contributed by brian d foy)
.PP
If you want to cycle through an array endlessly, you can increment the
index modulo the number of elements in the array:
.PP
.Vb 2
\&    my @array = qw( a b c );
\&    my $i = 0;
\&
\&    while( 1 ) {
\&        print $array[ $i++ % @array ], "\en";
\&        last if $i > 20;
\&    }
.Ve
.PP
You can also use Tie::Cycle to use a scalar that always has the
next element of the circular array:
.PP
.Vb 1
\&    use Tie::Cycle;
\&
\&    tie my $cycle, \*(AqTie::Cycle\*(Aq, [ qw( FFFFFF 000000 FFFF00 ) ];
\&
\&    print $cycle; # FFFFFF
\&    print $cycle; # 000000
\&    print $cycle; # FFFF00
.Ve
.PP
The Array::Iterator::Circular creates an iterator object for
circular arrays:
.PP
.Vb 1
\&    use Array::Iterator::Circular;
\&
\&    my $color_iterator = Array::Iterator::Circular\->new(
\&        qw(red green blue orange)
\&        );
\&
\&    foreach ( 1 .. 20 ) {
\&        print $color_iterator\->next, "\en";
\&    }
.Ve
.SS "How do I shuffle an array randomly?"
.IX Subsection "How do I shuffle an array randomly?"
If you either have Perl 5.8.0 or later installed, or if you have
Scalar-List-Utils 1.03 or later installed, you can say:
.PP
.Vb 1
\&    use List::Util \*(Aqshuffle\*(Aq;
\&
\&    @shuffled = shuffle(@list);
.Ve
.PP
If not, you can use a Fisher-Yates shuffle.
.PP
.Vb 3
\&    sub fisher_yates_shuffle {
\&        my $deck = shift;  # $deck is a reference to an array
\&        return unless @$deck; # must not be empty!
\&
\&        my $i = @$deck;
\&        while (\-\-$i) {
\&            my $j = int rand ($i+1);
\&            @$deck[$i,$j] = @$deck[$j,$i];
\&        }
\&    }
\&
\&    # shuffle my mpeg collection
\&    #
\&    my @mpeg = <audio/*/*.mp3>;
\&    fisher_yates_shuffle( \e@mpeg );    # randomize @mpeg in place
\&    print @mpeg;
.Ve
.PP
Note that the above implementation shuffles an array in place,
unlike the \f(CW\*(C`List::Util::shuffle()\*(C'\fR which takes a list and returns
a new shuffled list.
.PP
You've probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element with
.PP
.Vb 6
\&    srand;
\&    @new = ();
\&    @old = 1 .. 10;  # just a demo
\&    while (@old) {
\&        push(@new, splice(@old, rand @old, 1));
\&    }
.Ve
.PP
This is bad because splice is already O(N), and since you do it N
times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.
.SS "How do I process/modify each element of an array?"
.IX Subsection "How do I process/modify each element of an array?"
Use \f(CW\*(C`for\*(C'\fR/\f(CW\*(C`foreach\*(C'\fR:
.PP
.Vb 4
\&    for (@lines) {
\&        s/foo/bar/;    # change that word
\&        tr/XZ/ZX/;    # swap those letters
\&    }
.Ve
.PP
Here's another; let's compute spherical volumes:
.PP
.Vb 5
\&    my @volumes = @radii;
\&    for (@volumes) {   # @volumes has changed parts
\&        $_ **= 3;
\&        $_ *= (4/3) * 3.14159;  # this will be constant folded
\&    }
.Ve
.PP
which can also be done with \f(CW\*(C`map()\*(C'\fR which is made to transform
one list into another:
.PP
.Vb 1
\&    my @volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;
.Ve
.PP
If you want to do the same thing to modify the values of the
hash, you can use the \f(CW\*(C`values\*(C'\fR function. As of Perl 5.6
the values are not copied, so if you modify \f(CW$orbit\fR (in this
case), you modify the value.
.PP
.Vb 3
\&    for my $orbit ( values %orbits ) {
\&        ($orbit **= 3) *= (4/3) * 3.14159;
\&    }
.Ve
.PP
Prior to perl 5.6 \f(CW\*(C`values\*(C'\fR returned copies of the values,
so older perl code often contains constructions such as
\&\f(CW@orbits{keys %orbits}\fR instead of \f(CW\*(C`values %orbits\*(C'\fR where
the hash is to be modified.
.SS "How do I select a random element from an array?"
.IX Subsection "How do I select a random element from an array?"
Use the \f(CW\*(C`rand()\*(C'\fR function (see \*(L"rand\*(R" in perlfunc):
.PP
.Vb 2
\&    my $index   = rand @array;
\&    my $element = $array[$index];
.Ve
.PP
Or, simply:
.PP
.Vb 1
\&    my $element = $array[ rand @array ];
.Ve
.SS "How do I permute N elements of a list?"
.IX Xref "List::Permutor permute Algorithm::Loops Knuth The Art of Computer Programming Fischer-Krause"
.IX Subsection "How do I permute N elements of a list?"
Use the List::Permutor module on \s-1CPAN.\s0 If the list is actually an
array, try the Algorithm::Permute module (also on \s-1CPAN\s0). It's
written in \s-1XS\s0 code and is very efficient:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    my @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&    my $p_iterator = Algorithm::Permute\->new ( \e@array );
\&
\&    while (my @perm = $p_iterator\->next) {
\&       print "next permutation: (@perm)\en";
\&    }
.Ve
.PP
For even faster execution, you could do:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    my @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&
\&    Algorithm::Permute::permute {
\&        print "next permutation: (@array)\en";
\&    } @array;
.Ve
.PP
Here's a little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
\&\f(CW\*(C`permute()\*(C'\fR function is discussed in Volume 4 (still unpublished) of
Knuth's \fIThe Art of Computer Programming\fR and will work on any list:
.PP
.Vb 2
\&    #!/usr/bin/perl \-n
\&    # Fischer\-Krause ordered permutation generator
\&
\&    sub permute (&@) {
\&        my $code = shift;
\&        my @idx = 0..$#_;
\&        while ( $code\->(@_[@idx]) ) {
\&            my $p = $#idx;
\&            \-\-$p while $idx[$p\-1] > $idx[$p];
\&            my $q = $p or return;
\&            push @idx, reverse splice @idx, $p;
\&            ++$q while $idx[$p\-1] > $idx[$q];
\&            @idx[$p\-1,$q]=@idx[$q,$p\-1];
\&        }
\&    }
\&
\&    permute { print "@_\en" } split;
.Ve
.PP
The Algorithm::Loops module also provides the \f(CW\*(C`NextPermute\*(C'\fR and
\&\f(CW\*(C`NextPermuteNum\*(C'\fR functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.
.PP
\&\f(CW\*(C`NextPermute\*(C'\fR uses string order and \f(CW\*(C`NextPermuteNum\*(C'\fR numeric order, so
you can enumerate all the permutations of \f(CW0..9\fR like this:
.PP
.Vb 1
\&    use Algorithm::Loops qw(NextPermuteNum);
\&
\&    my @list= 0..9;
\&    do { print "@list\en" } while NextPermuteNum @list;
.Ve
.SS "How do I sort an array by (anything)?"
.IX Subsection "How do I sort an array by (anything)?"
Supply a comparison function to \fIsort()\fR (described in \*(L"sort\*(R" in perlfunc):
.PP
.Vb 1
\&    @list = sort { $a <=> $b } @list;
.Ve
.PP
The default sort function is cmp, string comparison, which would
sort \f(CW\*(C`(1, 2, 10)\*(C'\fR into \f(CW\*(C`(1, 10, 2)\*(C'\fR. \f(CW\*(C`<=>\*(C'\fR, used above, is
the numerical comparison operator.
.PP
If you have a complicated function needed to pull out the part you
want to sort on, then don't do it inside the sort function. Pull it
out first, because the sort \s-1BLOCK\s0 can be called many times for the
same element. Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.
.PP
.Vb 7
\&    my @idx;
\&    for (@data) {
\&        my $item;
\&        ($item) = /\ed+\es*(\eS+)/;
\&        push @idx, uc($item);
\&    }
\&    my @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
.Ve
.PP
which could also be written this way, using a trick
that's come to be known as the Schwartzian Transform:
.PP
.Vb 3
\&    my @sorted = map  { $_\->[0] }
\&        sort { $a\->[1] cmp $b\->[1] }
\&        map  { [ $_, uc( (/\ed+\es*(\eS+)/)[0]) ] } @data;
.Ve
.PP
If you need to sort on several fields, the following paradigm is useful.
.PP
.Vb 5
\&    my @sorted = sort {
\&        field1($a) <=> field1($b) ||
\&        field2($a) cmp field2($b) ||
\&        field3($a) cmp field3($b)
\&    } @data;
.Ve
.PP
This can be conveniently combined with precalculation of keys as given
above.
.PP
See the \fIsort\fR article in the \*(L"Far More Than You Ever Wanted
To Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> for
more about this approach.
.PP
See also the question later in perlfaq4 on sorting hashes.
.SS "How do I manipulate arrays of bits?"
.IX Subsection "How do I manipulate arrays of bits?"
Use \f(CW\*(C`pack()\*(C'\fR and \f(CW\*(C`unpack()\*(C'\fR, or else \f(CW\*(C`vec()\*(C'\fR and the bitwise
operations.
.PP
For example, you don't have to store individual bits in an array
(which would mean that you're wasting a lot of space). To convert an
array of bits to a string, use \f(CW\*(C`vec()\*(C'\fR to set the right bits. This
sets \f(CW$vec\fR to have bit N set only if \f(CW$ints[N]\fR was set:
.PP
.Vb 5
\&    my @ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
\&    my $vec = \*(Aq\*(Aq;
\&    foreach( 0 .. $#ints ) {
\&        vec($vec,$_,1) = 1 if $ints[$_];
\&    }
.Ve
.PP
The string \f(CW$vec\fR only takes up as many bits as it needs. For
instance, if you had 16 entries in \f(CW@ints\fR, \f(CW$vec\fR only needs two
bytes to store them (not counting the scalar variable overhead).
.PP
Here's how, given a vector in \f(CW$vec\fR, you can get those bits into
your \f(CW@ints\fR array:
.PP
.Vb 7
\&    sub bitvec_to_list {
\&        my $vec = shift;
\&        my @ints;
\&        # Find null\-byte density then select best algorithm
\&        if ($vec =~ tr/\e0// / length $vec > 0.95) {
\&            use integer;
\&            my $i;
\&
\&            # This method is faster with mostly null\-bytes
\&            while($vec =~ /[^\e0]/g ) {
\&                $i = \-9 + 8 * pos $vec;
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&            }
\&        }
\&        else {
\&            # This method is a fast general algorithm
\&            use integer;
\&            my $bits = unpack "b*", $vec;
\&            push @ints, 0 if $bits =~ s/^(\ed)// && $1;
\&            push @ints, pos $bits while($bits =~ /1/g);
\&        }
\&
\&        return \e@ints;
\&    }
.Ve
.PP
This method gets faster the more sparse the bit vector is.
(Courtesy of Tim Bunce and Winfried Koenig.)
.PP
You can make the while loop a lot shorter with this suggestion
from Benjamin Goldberg:
.PP
.Vb 3
\&    while($vec =~ /[^\e0]+/g ) {
\&        push @ints, grep vec($vec, $_, 1), $\-[0] * 8 .. $+[0] * 8;
\&    }
.Ve
.PP
Or use the \s-1CPAN\s0 module Bit::Vector:
.PP
.Vb 3
\&    my $vector = Bit::Vector\->new($num_of_bits);
\&    $vector\->Index_List_Store(@ints);
\&    my @ints = $vector\->Index_List_Read();
.Ve
.PP
Bit::Vector provides efficient methods for bit vector, sets of
small integers and \*(L"big int\*(R" math.
.PP
Here's a more extensive illustration using \fIvec()\fR:
.PP
.Vb 7
\&    # vec demo
\&    my $vector = "\exff\ex0f\exef\exfe";
\&    print "Ilya\*(Aqs string \e\exff\e\ex0f\e\exef\e\exfe represents the number ",
\&    unpack("N", $vector), "\en";
\&    my $is_set = vec($vector, 23, 1);
\&    print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\en";
\&    pvec($vector);
\&
\&    set_vec(1,1,1);
\&    set_vec(3,1,1);
\&    set_vec(23,1,1);
\&
\&    set_vec(3,1,3);
\&    set_vec(3,2,3);
\&    set_vec(3,4,3);
\&    set_vec(3,4,7);
\&    set_vec(3,8,3);
\&    set_vec(3,8,7);
\&
\&    set_vec(0,32,17);
\&    set_vec(1,32,17);
\&
\&    sub set_vec {
\&        my ($offset, $width, $value) = @_;
\&        my $vector = \*(Aq\*(Aq;
\&        vec($vector, $offset, $width) = $value;
\&        print "offset=$offset width=$width value=$value\en";
\&        pvec($vector);
\&    }
\&
\&    sub pvec {
\&        my $vector = shift;
\&        my $bits = unpack("b*", $vector);
\&        my $i = 0;
\&        my $BASE = 8;
\&
\&        print "vector length in bytes: ", length($vector), "\en";
\&        @bytes = unpack("A8" x length($vector), $bits);
\&        print "bits are: @bytes\en\en";
\&    }
.Ve
.SS "Why does \fIdefined()\fP return true on empty arrays and hashes?"
.IX Subsection "Why does defined() return true on empty arrays and hashes?"
The short story is that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes). See \*(L"defined\*(R" in perlfunc
in the 5.004 release or later of Perl for more detail.
.SH "Data: Hashes (Associative Arrays)"
.IX Header "Data: Hashes (Associative Arrays)"
.SS "How do I process an entire hash?"
.IX Subsection "How do I process an entire hash?"
(contributed by brian d foy)
.PP
There are a couple of ways that you can process an entire hash. You
can get a list of keys, then go through each key, or grab a one
key-value pair at a time.
.PP
To go through all of the keys, use the \f(CW\*(C`keys\*(C'\fR function. This extracts
all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:
.PP
.Vb 4
\&    foreach my $key ( keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Once you have the list of keys, you can process that list before you
process the hash elements. For instance, you can sort the keys so you
can process them in lexical order:
.PP
.Vb 4
\&    foreach my $key ( sort keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Or, you might want to only process some of the items. If you only want
to deal with the keys that start with \f(CW\*(C`text:\*(C'\fR, you can select just
those using \f(CW\*(C`grep\*(C'\fR:
.PP
.Vb 4
\&    foreach my $key ( grep /^text:/, keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
If the hash is very large, you might not want to create a long list of
keys. To save some memory, you can grab one key-value pair at a time using
\&\f(CW\*(C`each()\*(C'\fR, which returns a pair you haven't seen yet:
.PP
.Vb 3
\&    while( my( $key, $value ) = each( %hash ) ) {
\&        ...
\&    }
.Ve
.PP
The \f(CW\*(C`each\*(C'\fR operator returns the pairs in apparently random order, so if
ordering matters to you, you'll have to stick with the \f(CW\*(C`keys\*(C'\fR method.
.PP
The \f(CW\*(C`each()\*(C'\fR operator can be a bit tricky though. You can't add or
delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you mix \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, or \f(CW\*(C`each\*(C'\fR on the same hash, you risk resetting
the iterator and messing up your processing. See the \f(CW\*(C`each\*(C'\fR entry in
perlfunc for more details.
.SS "How do I merge two hashes?"
.IX Xref "hash merge slice, hash"
.IX Subsection "How do I merge two hashes?"
(contributed by brian d foy)
.PP
Before you decide to merge two hashes, you have to decide what to do
if both hashes contain keys that are the same and if you want to leave
the original hashes as they were.
.PP
If you want to preserve the original hashes, copy one hash (\f(CW%hash1\fR)
to a new hash (\f(CW%new_hash\fR), then add the keys from the other hash
(\f(CW%hash2\fR to the new hash. Checking that the key already exists in
\&\f(CW%new_hash\fR gives you a chance to decide what to do with the
duplicates:
.PP
.Vb 1
\&    my %new_hash = %hash1; # make a copy; leave %hash1 alone
\&
\&    foreach my $key2 ( keys %hash2 ) {
\&        if( exists $new_hash{$key2} ) {
\&            warn "Key [$key2] is in both hashes!";
\&            # handle the duplicate (perhaps only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $new_hash{$key2} = $hash2{$key2};
\&        }
\&    }
.Ve
.PP
If you don't want to create a new hash, you can still use this looping
technique; just change the \f(CW%new_hash\fR to \f(CW%hash1\fR.
.PP
.Vb 11
\&    foreach my $key2 ( keys %hash2 ) {
\&        if( exists $hash1{$key2} ) {
\&            warn "Key [$key2] is in both hashes!";
\&            # handle the duplicate (perhaps only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $hash1{$key2} = $hash2{$key2};
\&        }
\&      }
.Ve
.PP
If you don't care that one hash overwrites keys and values from the other, you
could just use a hash slice to add one hash to another. In this case, values
from \f(CW%hash2\fR replace values from \f(CW%hash1\fR when they have keys in common:
.PP
.Vb 1
\&    @hash1{ keys %hash2 } = values %hash2;
.Ve
.SS "What happens if I add or remove keys from a hash while iterating over it?"
.IX Subsection "What happens if I add or remove keys from a hash while iterating over it?"
(contributed by brian d foy)
.PP
The easy answer is \*(L"Don't do that!\*(R"
.PP
If you iterate through the hash with \fIeach()\fR, you can delete the key
most recently returned without worrying about it. If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table. See the
entry for \f(CW\*(C`each()\*(C'\fR in perlfunc.
.SS "How do I look up a hash element by value?"
.IX Subsection "How do I look up a hash element by value?"
Create a reverse hash:
.PP
.Vb 2
\&    my %by_value = reverse %by_key;
\&    my $key = $by_value{$value};
.Ve
.PP
That's not particularly efficient. It would be more space-efficient
to use:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&        $by_value{$value} = $key;
\&    }
.Ve
.PP
If your hash could have repeated values, the methods above will only find
one of the associated keys.  This may or may not worry you. If it does
worry you, you can always reverse the hash into a hash of arrays instead:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&         push @{$key_list_by_value{$value}}, $key;
\&    }
.Ve
.SS "How can I know how many entries are in a hash?"
.IX Subsection "How can I know how many entries are in a hash?"
(contributed by brian d foy)
.PP
This is very similar to \*(L"How do I process an entire hash?\*(R", also in
perlfaq4, but a bit simpler in the common cases.
.PP
You can use the \f(CW\*(C`keys()\*(C'\fR built-in function in scalar context to find out
have many entries you have in a hash:
.PP
.Vb 1
\&    my $key_count = keys %hash; # must be scalar context!
.Ve
.PP
If you want to find out how many entries have a defined value, that's
a bit different. You have to check each value. A \f(CW\*(C`grep\*(C'\fR is handy:
.PP
.Vb 1
\&    my $defined_value_count = grep { defined } values %hash;
.Ve
.PP
You can use that same structure to count the entries any way that
you like. If you want the count of the keys with vowels in them,
you just test for that instead:
.PP
.Vb 1
\&    my $vowel_count = grep { /[aeiou]/ } keys %hash;
.Ve
.PP
The \f(CW\*(C`grep\*(C'\fR in scalar context returns the count. If you want the list
of matching items, just use it in list context instead:
.PP
.Vb 1
\&    my @defined_values = grep { defined } values %hash;
.Ve
.PP
The \f(CW\*(C`keys()\*(C'\fR function also resets the iterator, which means that you may
see strange results if you use this between uses of other hash operators
such as \f(CW\*(C`each()\*(C'\fR.
.SS "How do I sort a hash (optionally by value instead of key)?"
.IX Subsection "How do I sort a hash (optionally by value instead of key)?"
(contributed by brian d foy)
.PP
To sort a hash, start with the keys. In this example, we give the list of
keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.
.PP
.Vb 1
\&    my @keys = sort { $a cmp $b } keys %hash;
\&
\&    foreach my $key ( @keys ) {
\&        printf "%\-20s %6d\en", $key, $hash{$key};
\&    }
.Ve
.PP
We could get more fancy in the \f(CW\*(C`sort()\*(C'\fR block though. Instead of
comparing the keys, we can compute a value with them and use that
value as the comparison.
.PP
For instance, to make our report order case-insensitive, we use
\&\f(CW\*(C`lc\*(C'\fR to lowercase the keys before comparing them:
.PP
.Vb 1
\&    my @keys = sort { lc $a cmp lc $b } keys %hash;
.Ve
.PP
Note: if the computation is expensive or the hash has many elements,
you may want to look at the Schwartzian Transform to cache the
computation results.
.PP
If we want to sort by the hash value instead, we use the hash key
to look it up. We still get out a list of keys, but this time they
are ordered by their value.
.PP
.Vb 1
\&    my @keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;
.Ve
.PP
From there we can get more complex. If the hash values are the same,
we can provide a secondary sort on the hash key.
.PP
.Vb 5
\&    my @keys = sort {
\&        $hash{$a} <=> $hash{$b}
\&            or
\&        "\eL$a" cmp "\eL$b"
\&    } keys %hash;
.Ve
.SS "How can I always keep my hash sorted?"
.IX Xref "hash tie sort DB_File Tie::IxHash"
.IX Subsection "How can I always keep my hash sorted?"
You can look into using the \f(CW\*(C`DB_File\*(C'\fR module and \f(CW\*(C`tie()\*(C'\fR using the
\&\f(CW$DB_BTREE\fR hash bindings as documented in \*(L"In Memory
Databases\*(R" in DB_File. The Tie::IxHash module from \s-1CPAN\s0 might also be
instructive. Although this does keep your hash sorted, you might not
like the slowdown you suffer from the tie interface. Are you sure you
need to do this? :)
.ie n .SS "What's the difference between ""delete"" and ""undef"" with hashes?"
.el .SS "What's the difference between ``delete'' and ``undef'' with hashes?"
.IX Subsection "What's the difference between delete and undef with hashes?"
Hashes contain pairs of scalars: the first is the key, the
second is the value. The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference. If a key \f(CW$key\fR is present in
\&\f(CW%hash\fR, \f(CW\*(C`exists($hash{$key})\*(C'\fR will return true. The value
for a given key can be \f(CW\*(C`undef\*(C'\fR, in which case
\&\f(CW$hash{$key}\fR will be \f(CW\*(C`undef\*(C'\fR while \f(CW\*(C`exists $hash{$key}\*(C'\fR
will return true. This corresponds to (\f(CW$key\fR, \f(CW\*(C`undef\*(C'\fR)
being in the hash.
.PP
Pictures help... Here's the \f(CW%hash\fR table:
.PP
.Vb 7
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   |  3   |
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
And these conditions hold
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is true
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is true
\&    exists $hash{\*(Aqa\*(Aq}                is true (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
If you now say
.PP
.Vb 1
\&    undef $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 7
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   | undef|
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is FALSE
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is FALSE
\&    exists $hash{\*(Aqa\*(Aq}                is true (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
Notice the last two: you have an undef value, but a defined key!
.PP
Now, consider this:
.PP
.Vb 1
\&    delete $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 6
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is false
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is false
\&    exists $hash{\*(Aqa\*(Aq}                is FALSE (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is FALSE
.Ve
.PP
See, the whole entry is gone!
.SS "Why don't my tied hashes make the defined/exists distinction?"
.IX Subsection "Why don't my tied hashes make the defined/exists distinction?"
This depends on the tied hash's implementation of \s-1\fIEXISTS\s0()\fR.
For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that \fIexists()\fR and
\&\fIdefined()\fR do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.
.SS "How do I reset an \fIeach()\fP operation part-way through?"
.IX Subsection "How do I reset an each() operation part-way through?"
(contributed by brian d foy)
.PP
You can use the \f(CW\*(C`keys\*(C'\fR or \f(CW\*(C`values\*(C'\fR functions to reset \f(CW\*(C`each\*(C'\fR. To
simply reset the iterator used by \f(CW\*(C`each\*(C'\fR without doing anything else,
use one of them in void context:
.PP
.Vb 2
\&    keys %hash; # resets iterator, nothing else.
\&    values %hash; # resets iterator, nothing else.
.Ve
.PP
See the documentation for \f(CW\*(C`each\*(C'\fR in perlfunc.
.SS "How can I get the unique keys from two hashes?"
.IX Subsection "How can I get the unique keys from two hashes?"
First you extract the keys from the hashes into lists, then solve
the \*(L"removing duplicates\*(R" problem described above. For example:
.PP
.Vb 5
\&    my %seen = ();
\&    for my $element (keys(%foo), keys(%bar)) {
\&        $seen{$element}++;
\&    }
\&    my @uniq = keys %seen;
.Ve
.PP
Or more succinctly:
.PP
.Vb 1
\&    my @uniq = keys %{{%foo,%bar}};
.Ve
.PP
Or if you really want to save space:
.PP
.Vb 8
\&    my %seen = ();
\&    while (defined ($key = each %foo)) {
\&        $seen{$key}++;
\&    }
\&    while (defined ($key = each %bar)) {
\&        $seen{$key}++;
\&    }
\&    my @uniq = keys %seen;
.Ve
.SS "How can I store a multidimensional array in a \s-1DBM\s0 file?"
.IX Subsection "How can I store a multidimensional array in a DBM file?"
Either stringify the structure yourself (no fun), or else
get the \s-1MLDBM \s0(which uses Data::Dumper) module from \s-1CPAN\s0 and layer
it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but
it can be a bit slow.
.SS "How can I make my hash remember the order I put elements into it?"
.IX Subsection "How can I make my hash remember the order I put elements into it?"
Use the Tie::IxHash from \s-1CPAN.\s0
.PP
.Vb 1
\&    use Tie::IxHash;
\&
\&    tie my %myhash, \*(AqTie::IxHash\*(Aq;
\&
\&    for (my $i=0; $i<20; $i++) {
\&        $myhash{$i} = 2*$i;
\&    }
\&
\&    my @keys = keys %myhash;
\&    # @keys = (0,1,2,3,...)
.Ve
.SS "Why does passing a subroutine an undefined element in a hash create it?"
.IX Subsection "Why does passing a subroutine an undefined element in a hash create it?"
(contributed by brian d foy)
.PP
Are you using a really old version of Perl?
.PP
Normally, accessing a hash key's value for a nonexistent key will
\&\fInot\fR create the key.
.PP
.Vb 3
\&    my %hash  = ();
\&    my $value = $hash{ \*(Aqfoo\*(Aq };
\&    print "This won\*(Aqt print\en" if exists $hash{ \*(Aqfoo\*(Aq };
.Ve
.PP
Passing \f(CW$hash{ \*(Aqfoo\*(Aq }\fR to a subroutine used to be a special case, though.
Since you could assign directly to \f(CW$_[0]\fR, Perl had to be ready to
make that assignment so it created the hash key ahead of time:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print before 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        # $_[0] = \*(Aqbar\*(Aq; # create hash key in case you do this
\&        1;
\&    }
.Ve
.PP
Since Perl 5.004, however, this situation is a special case and Perl
creates the hash key only when you make the assignment:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print, even after 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        $_[0] = \*(Aqbar\*(Aq;
\&    }
.Ve
.PP
However, if you want the old behavior (and think carefully about that
because it's a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make this a special case:
.PP
.Vb 1
\&    my_sub( @hash{ qw/foo/ } );
.Ve
.SS "How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?"
.IX Subsection "How can I make the Perl equivalent of a C structure/ class/hash or array of hashes or arrays?"
Usually a hash ref, perhaps like this:
.PP
.Vb 8
\&    $record = {
\&        NAME   => "Jason",
\&        EMPNO  => 132,
\&        TITLE  => "deputy peon",
\&        AGE    => 23,
\&        SALARY => 37_000,
\&        PALS   => [ "Norbert", "Rhys", "Phineas"],
\&    };
.Ve
.PP
References are documented in perlref and perlreftut.
Examples of complex data structures are given in perldsc and
perllol. Examples of structures and object-oriented classes are
in perltoot.
.SS "How can I use a reference as a hash key?"
.IX Subsection "How can I use a reference as a hash key?"
(contributed by brian d foy and Ben Morrow)
.PP
Hash keys are strings, so you can't really use a reference as the key.
When you try to do that, perl turns the reference into its stringified
form (for instance, \f(CW\*(C`HASH(0xDEADBEEF)\*(C'\fR). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own.
.PP
Remember that the entry in the hash will still be there even if
the referenced variable  goes out of scope, and that it is entirely
possible for Perl to subsequently allocate a different variable at
the same address. This will mean a new variable might accidentally
be associated with the value for an old.
.PP
If you have Perl 5.10 or later, and you just want to store a value
against the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also handle renaming the
keys if you use multiple threads (which causes all variables to be
reallocated at new addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable goes out
of scope.
.PP
If you actually need to be able to get a real reference back from
each hash entry, you can use the Tie::RefHash module, which does the
required work for you.
.SS "How can I check if a key exists in a multilevel hash?"
.IX Subsection "How can I check if a key exists in a multilevel hash?"
(contributed by brian d foy)
.PP
The trick to this problem is avoiding accidental autovivification. If
you want to check three keys deep, you might nai\*:vely try this:
.PP
.Vb 4
\&    my %hash;
\&    if( exists $hash{key1}{key2}{key3} ) {
\&        ...;
\&    }
.Ve
.PP
Even though you started with a completely empty hash, after that call to
\&\f(CW\*(C`exists\*(C'\fR you've created the structure you needed to check for \f(CW\*(C`key3\*(C'\fR:
.PP
.Vb 5
\&    %hash = (
\&              \*(Aqkey1\*(Aq => {
\&                          \*(Aqkey2\*(Aq => {}
\&                        }
\&            );
.Ve
.PP
That's autovivification. You can get around this in a few ways. The
easiest way is to just turn it off. The lexical \f(CW\*(C`autovivification\*(C'\fR
pragma is available on \s-1CPAN.\s0 Now you don't add to the hash:
.PP
.Vb 7
\&    {
\&        no autovivification;
\&        my %hash;
\&        if( exists $hash{key1}{key2}{key3} ) {
\&            ...;
\&        }
\&    }
.Ve
.PP
The Data::Diver module on \s-1CPAN\s0 can do it for you too. Its \f(CW\*(C`Dive\*(C'\fR
subroutine can tell you not only if the keys exist but also get the
value:
.PP
.Vb 1
\&    use Data::Diver qw(Dive);
\&
\&    my @exists = Dive( \e%hash, qw(key1 key2 key3) );
\&    if(  ! @exists  ) {
\&        ...; # keys do not exist
\&    }
\&    elsif(  ! defined $exists[0]  ) {
\&        ...; # keys exist but value is undef
\&    }
.Ve
.PP
You can easily do this yourself too by checking each level of the hash
before you move onto the next level. This is essentially what
Data::Diver does for you:
.PP
.Vb 3
\&    if( check_hash( \e%hash, qw(key1 key2 key3) ) ) {
\&        ...;
\&    }
\&
\&    sub check_hash {
\&       my( $hash, @keys ) = @_;
\&
\&       return unless @keys;
\&
\&       foreach my $key ( @keys ) {
\&           return unless eval { exists $hash\->{$key} };
\&           $hash = $hash\->{$key};
\&        }
\&
\&       return 1;
\&    }
.Ve
.SS "How can I prevent addition of unwanted keys into a hash?"
.IX Subsection "How can I prevent addition of unwanted keys into a hash?"
Since version 5.8.0, hashes can be \fIrestricted\fR to a fixed number
of given keys. Methods for creating and dealing with restricted hashes
are exported by the Hash::Util module.
.SH "Data: Misc"
.IX Header "Data: Misc"
.SS "How do I handle binary data correctly?"
.IX Subsection "How do I handle binary data correctly?"
Perl is binary-clean, so it can handle binary data just fine.
On Windows or \s-1DOS,\s0 however, you have to use \f(CW\*(C`binmode\*(C'\fR for binary
files to avoid conversions for line endings. In general, you should
use \f(CW\*(C`binmode\*(C'\fR any time you want to work with binary data.
.PP
Also see \*(L"binmode\*(R" in perlfunc or perlopentut.
.PP
If you're concerned about 8\-bit textual data then see perllocale.
If you want to deal with multibyte characters, however, there are
some gotchas. See the section on Regular Expressions.
.SS "How do I determine whether a scalar is a number/whole/integer/float?"
.IX Subsection "How do I determine whether a scalar is a number/whole/integer/float?"
Assuming that you don't care about \s-1IEEE\s0 notations like \*(L"NaN\*(R" or
\&\*(L"Infinity\*(R", you probably just want to use a regular expression:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given( $number ) {
\&        when( /\eD/ )
\&            { say "\ethas nondigits"; continue }
\&        when( /^\ed+\ez/ )
\&            { say "\etis a whole number"; continue }
\&        when( /^\-?\ed+\ez/ )
\&            { say "\etis an integer"; continue }
\&        when( /^[+\-]?\ed+\ez/ )
\&            { say "\etis a +/\- integer"; continue }
\&        when( /^\-?(?:\ed+\e.?|\e.\ed)\ed*\ez/ )
\&            { say "\etis a real number"; continue }
\&        when( /^[+\-]?(?=\e.?\ed)\ed*\e.?\ed*(?:e[+\-]?\ed+)?\ez/i)
\&            { say "\etis a C float" }
\&    }
.Ve
.PP
There are also some commonly used modules for the task.
Scalar::Util (distributed with 5.8) provides access to perl's
internal function \f(CW\*(C`looks_like_number\*(C'\fR for determining whether a
variable looks like a number. Data::Types exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is Regexp::Common which has regular
expressions to match various types of numbers. Those three modules are
available from the \s-1CPAN.\s0
.PP
If you're on a \s-1POSIX\s0 system, Perl supports the \f(CW\*(C`POSIX::strtod\*(C'\fR
function for converting strings to doubles (and also \f(CW\*(C`POSIX::strtol\*(C'\fR
for longs). Its semantics are somewhat cumbersome, so here's a
\&\f(CW\*(C`getnum\*(C'\fR wrapper function for more convenient access. This function
takes a string and returns the number it found, or \f(CW\*(C`undef\*(C'\fR for input
that isn't a C float. The \f(CW\*(C`is_numeric\*(C'\fR function is a front end to
\&\f(CW\*(C`getnum\*(C'\fR if you just want to say, \*(L"Is this a float?\*(R"
.PP
.Vb 10
\&    sub getnum {
\&        use POSIX qw(strtod);
\&        my $str = shift;
\&        $str =~ s/^\es+//;
\&        $str =~ s/\es+$//;
\&        $! = 0;
\&        my($num, $unparsed) = strtod($str);
\&        if (($str eq \*(Aq\*(Aq) || ($unparsed != 0) || $!) {
\&                return undef;
\&        }
\&        else {
\&            return $num;
\&        }
\&    }
\&
\&    sub is_numeric { defined getnum($_[0]) }
.Ve
.PP
Or you could check out the String::Scanf module on the \s-1CPAN\s0
instead.
.SS "How do I keep persistent data across program calls?"
.IX Subsection "How do I keep persistent data across program calls?"
For some specific applications, you can use one of the \s-1DBM\s0 modules.
See AnyDBM_File. More generically, you should consult the FreezeThaw
or Storable modules from \s-1CPAN.\s0 Starting from Perl 5.8, Storable is part
of the standard distribution. Here's one example using Storable's \f(CW\*(C`store\*(C'\fR
and \f(CW\*(C`retrieve\*(C'\fR functions:
.PP
.Vb 2
\&    use Storable;
\&    store(\e%hash, "filename");
\&
\&    # later on...
\&    $href = retrieve("filename");        # by ref
\&    %hash = %{ retrieve("filename") };   # direct to hash
.Ve
.SS "How do I print out or copy a recursive data structure?"
.IX Subsection "How do I print out or copy a recursive data structure?"
The Data::Dumper module on \s-1CPAN \s0(or the 5.005 release of Perl) is great
for printing out data structures. The Storable module on \s-1CPAN \s0(or the
5.8 release of Perl), provides a function called \f(CW\*(C`dclone\*(C'\fR that recursively
copies its argument.
.PP
.Vb 2
\&    use Storable qw(dclone);
\&    $r2 = dclone($r1);
.Ve
.PP
Where \f(CW$r1\fR can be a reference to any kind of data structure you'd like.
It will be deeply copied. Because \f(CW\*(C`dclone\*(C'\fR takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.
.PP
.Vb 1
\&    %newhash = %{ dclone(\e%oldhash) };
.Ve
.SS "How do I define methods for every class/object?"
.IX Subsection "How do I define methods for every class/object?"
(contributed by Ben Morrow)
.PP
You can use the \f(CW\*(C`UNIVERSAL\*(C'\fR class (see \s-1UNIVERSAL\s0). However, please
be very careful to consider the consequences of doing this: adding
methods to every object is very likely to have unintended
consequences. If possible, it would be better to have all your object
inherit from some common base class, or to use an object system like
Moose that supports roles.
.SS "How do I verify a credit card checksum?"
.IX Subsection "How do I verify a credit card checksum?"
Get the Business::CreditCard module from \s-1CPAN.\s0
.SS "How do I pack arrays of doubles or floats for \s-1XS\s0 code?"
.IX Subsection "How do I pack arrays of doubles or floats for XS code?"
The arrays.h/arrays.c code in the \s-1PGPLOT\s0 module on \s-1CPAN\s0 does just this.
If you're doing a lot of float or double processing, consider using
the \s-1PDL\s0 module from \s-1CPAN\s0 instead\*(--it makes number-crunching easy.
.PP
See <http://search.cpan.org/dist/PGPLOT> for the code.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq5.1                                   0100644 0001750 0001750 00000206666 12566207437 022503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ5 1"
.TH PERLFAQ5 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq5 \- Files and Formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with I/O and the \*(L"f\*(R" issues: filehandles, flushing,
formats, and footers.
.SS "How do I flush/unbuffer an output filehandle? Why must I do this?"
.IX Xref "flush buffer unbuffer autoflush"
.IX Subsection "How do I flush/unbuffer an output filehandle? Why must I do this?"
(contributed by brian d foy)
.PP
You might like to read Mark Jason Dominus's \*(L"Suffering From Buffering\*(R"
at <http://perl.plover.com/FAQs/Buffering.html> .
.PP
Perl normally buffers output so it doesn't make a system call for every
bit of output. By saving up output, it makes fewer expensive system calls.
For instance, in this little bit of code, you want to print a dot to the
screen for every line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the output and you
have a long wait before you see a row of 50 dots all at once:
.PP
.Vb 4
\&    # long wait, then row of dots all at once
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... expensive line processing operations
\&    }
.Ve
.PP
To get around this, you have to unbuffer the output filehandle, in this
case, \f(CW\*(C`STDOUT\*(C'\fR. You can set the special variable \f(CW$|\fR to a true value
(mnemonic: making your filehandles \*(L"piping hot\*(R"):
.PP
.Vb 1
\&    $|++;
\&
\&    # dot shown immediately
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... expensive line processing operations
\&    }
.Ve
.PP
The \f(CW$|\fR is one of the per-filehandle special variables, so each
filehandle has its own copy of its value. If you want to merge
standard output and standard error for instance, you have to unbuffer
each (although \s-1STDERR\s0 might be unbuffered by default):
.PP
.Vb 7
\&    {
\&        my $previous_default = select(STDOUT);  # save previous default
\&        $|++;                                   # autoflush STDOUT
\&        select(STDERR);
\&        $|++;                                   # autoflush STDERR, to be sure
\&        select($previous_default);              # restore previous default
\&    }
\&
\&    # now should alternate . and +
\&    while( 1 ) {
\&        sleep 1;
\&        print STDOUT ".";
\&        print STDERR "+";
\&        print STDOUT "\en" unless ++$count % 25;
\&    }
.Ve
.PP
Besides the \f(CW$|\fR special variable, you can use \f(CW\*(C`binmode\*(C'\fR to give
your filehandle a \f(CW\*(C`:unix\*(C'\fR layer, which is unbuffered:
.PP
.Vb 1
\&    binmode( STDOUT, ":unix" );
\&
\&    while( 1 ) {
\&        sleep 1;
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&    }
.Ve
.PP
For more information on output layers, see the entries for \f(CW\*(C`binmode\*(C'\fR
and open in perlfunc, and the PerlIO module documentation.
.PP
If you are using IO::Handle or one of its subclasses, you can
call the \f(CW\*(C`autoflush\*(C'\fR method to change the settings of the
filehandle:
.PP
.Vb 3
\&    use IO::Handle;
\&    open my( $io_fh ), ">", "output.txt";
\&    $io_fh\->autoflush(1);
.Ve
.PP
The IO::Handle objects also have a \f(CW\*(C`flush\*(C'\fR method. You can flush
the buffer any time you want without auto-buffering
.PP
.Vb 1
\&    $io_fh\->flush;
.Ve
.SS "How do I change, delete, or insert a line in a file, or append to the beginning of a file?"
.IX Xref "file, editing"
.IX Subsection "How do I change, delete, or insert a line in a file, or append to the beginning of a file?"
(contributed by brian d foy)
.PP
The basic idea of inserting, changing, or deleting a line from a text
file involves reading and printing the file to the point you want to
make the change, making the change, then reading and printing the rest
of the file. Perl doesn't provide random access to lines (especially
since the record input separator, \f(CW$/\fR, is mutable), although modules
such as Tie::File can fake it.
.PP
A Perl program to do these tasks takes the basic form of opening a
file, printing its lines, then closing the file:
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
Within that basic form, add the parts that you need to insert, change,
or delete lines.
.PP
To prepend lines to the beginning, print those lines before you enter
the loop that prints the existing lines.
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    print $out "# Add this line to the top\en"; # <\-\-\- HERE\*(AqS THE MAGIC
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To change existing lines, insert the code to modify the lines inside
the \f(CW\*(C`while\*(C'\fR loop. In this case, the code finds all lowercased
versions of \*(L"perl\*(R" and uppercases them. The happens for every line, so
be sure that you're supposed to do that on every line!
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    print $out "# Add this line to the top\en";
\&
\&    while( <$in> ) {
\&        s/\eb(perl)\eb/Perl/g;
\&        print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To change only a particular line, the input line number, \f(CW$.\fR, is
useful. First read and print the lines up to the one you  want to
change. Next, read the single line you want to change, change it, and
print it. After that, read the rest of the lines and print those:
.PP
.Vb 4
\&    while( <$in> ) { # print the lines before the change
\&        print $out $_;
\&        last if $. == 4; # line number before change
\&    }
\&
\&    my $line = <$in>;
\&    $line =~ s/\eb(perl)\eb/Perl/g;
\&    print $out $line;
\&
\&    while( <$in> ) { # print the rest of the lines
\&        print $out $_;
\&    }
.Ve
.PP
To skip lines, use the looping controls. The \f(CW\*(C`next\*(C'\fR in this example
skips comment lines, and the \f(CW\*(C`last\*(C'\fR stops all processing once it
encounters either \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.PP
.Vb 5
\&    while( <$in> ) {
\&        next if /^\es+#/;             # skip comment lines
\&        last if /^_\|_(END|DATA)_\|_$/;  # stop at end of code marker
\&        print $out $_;
\&    }
.Ve
.PP
Do the same sort of thing to delete a particular line by using \f(CW\*(C`next\*(C'\fR
to skip the lines you don't want to show up in the output. This
example skips every fifth line:
.PP
.Vb 4
\&    while( <$in> ) {
\&        next unless $. % 5;
\&        print $out $_;
\&    }
.Ve
.PP
If, for some odd reason, you really want to see the whole file at once
rather than processing line-by-line, you can slurp it in (as long as
you can fit the whole thing in memory!):
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!"
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    my $content = do { local $/; <$in> }; # slurp!
\&
\&        # do your magic here
\&
\&    print $out $content;
.Ve
.PP
Modules such as File::Slurp and Tie::File can help with that
too. If you can, however, avoid reading the entire file at once. Perl
won't give that memory back to the operating system until the process
finishes.
.PP
You can also use Perl one-liners to modify a file in-place. The
following changes all 'Fred' to 'Barney' in \fIinFile.txt\fR, overwriting
the file with the new contents. With the \f(CW\*(C`\-p\*(C'\fR switch, Perl wraps a
\&\f(CW\*(C`while\*(C'\fR loop around the code you specify with \f(CW\*(C`\-e\*(C'\fR, and \f(CW\*(C`\-i\*(C'\fR turns
on in-place editing. The current line is in \f(CW$_\fR. With \f(CW\*(C`\-p\*(C'\fR, Perl
automatically prints the value of \f(CW$_\fR at the end of the loop. See
perlrun for more details.
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To make a backup of \f(CW\*(C`inFile.txt\*(C'\fR, give \f(CW\*(C`\-i\*(C'\fR a file extension to add:
.PP
.Vb 1
\&    perl \-pi.bak \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To change only the fifth line, you can add a test checking \f(CW$.\fR, the
input line number, then only perform the operation when the test
passes:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/ if $. == 5\*(Aq inFile.txt
.Ve
.PP
To add lines before a certain line, you can add a line (or lines!)
before Perl prints \f(CW$_\fR:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before third line\en" if $. == 3\*(Aq inFile.txt
.Ve
.PP
You can even add a line to the beginning of a file, since the current
line prints at the end of the loop:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before first line\en" if $. == 1\*(Aq inFile.txt
.Ve
.PP
To insert a line after one already in the file, use the \f(CW\*(C`\-n\*(C'\fR switch.
It's just like \f(CW\*(C`\-p\*(C'\fR except that it doesn't print \f(CW$_\fR at the end of
the loop, so you have to do that yourself. In this case, print \f(CW$_\fR
first, then print the line that you want to add.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint; print "Put after fifth line\en" if $. == 5\*(Aq inFile.txt
.Ve
.PP
To delete lines, only print the ones that you want.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint if /d/\*(Aq inFile.txt
.Ve
.SS "How do I count the number of lines in a file?"
.IX Xref "file, counting lines lines line"
.IX Subsection "How do I count the number of lines in a file?"
(contributed by brian d foy)
.PP
Conceptually, the easiest way to count the lines in a file is to
simply read them and count them:
.PP
.Vb 2
\&    my $count = 0;
\&    while( <$fh> ) { $count++; }
.Ve
.PP
You don't really have to count them yourself, though, since Perl
already does that with the \f(CW$.\fR variable, which is the current line
number from the last filehandle read:
.PP
.Vb 2
\&    1 while( <$fh> );
\&    my $count = $.;
.Ve
.PP
If you want to use \f(CW$.\fR, you can reduce it to a simple one-liner,
like one of these:
.PP
.Vb 1
\&    % perl \-lne \*(Aq} print $.; {\*(Aq    file
\&
\&    % perl \-lne \*(AqEND { print $. }\*(Aq file
.Ve
.PP
Those can be rather inefficient though. If they aren't fast enough for
you, you might just read chunks of data and count the number of
newlines:
.PP
.Vb 6
\&    my $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or die "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ tr/\en// );
\&    }
\&    close FILE;
.Ve
.PP
However, that doesn't work if the line ending isn't a newline. You
might change that \f(CW\*(C`tr///\*(C'\fR to a \f(CW\*(C`s///\*(C'\fR so you can count the number of
times the input record separator, \f(CW$/\fR, shows up:
.PP
.Vb 6
\&    my $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or die "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ s|$/||g; );
\&    }
\&    close FILE;
.Ve
.PP
If you don't mind shelling out, the \f(CW\*(C`wc\*(C'\fR command is usually the
fastest, even with the extra interprocess overhead. Ensure that you
have an untainted filename though:
.PP
.Vb 1
\&    #!perl \-T
\&
\&    $ENV{PATH} = undef;
\&
\&    my $lines;
\&    if( $filename =~ /^([0\-9a\-z_.]+)\ez/ ) {
\&        $lines = \`/usr/bin/wc \-l $1\`
\&        chomp $lines;
\&    }
.Ve
.SS "How do I delete the last N lines from a file?"
.IX Xref "lines file"
.IX Subsection "How do I delete the last N lines from a file?"
(contributed by brian d foy)
.PP
The easiest conceptual solution is to count the lines in the
file then start at the beginning and print the number of lines
(minus the last N) to a new file.
.PP
Most often, the real question is how you can delete the last N lines
without making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard reality when
you might have millions of lines in your file.
.PP
One trick is to use File::ReadBackwards, which starts at the end of
the file. That module provides an object that wraps the real filehandle
to make it easy for you to move around the file. Once you get to the
spot you need, you can get the actual filehandle and work with it as
normal. In this case, you get the file position at the end of the last
line you want to keep and truncate the file to that point:
.PP
.Vb 1
\&    use File::ReadBackwards;
\&
\&    my $filename = \*(Aqtest.txt\*(Aq;
\&    my $Lines_to_truncate = 2;
\&
\&    my $bw = File::ReadBackwards\->new( $filename )
\&        or die "Could not read backwards in [$filename]: $!";
\&
\&    my $lines_from_end = 0;
\&    until( $bw\->eof or $lines_from_end == $Lines_to_truncate ) {
\&        print "Got: ", $bw\->readline;
\&        $lines_from_end++;
\&    }
\&
\&    truncate( $filename, $bw\->tell );
.Ve
.PP
The File::ReadBackwards module also has the advantage of setting
the input record separator to a regular expression.
.PP
You can also use the Tie::File module which lets you access
the lines through a tied array. You can use normal array operations
to modify your file, including setting the last index and using
\&\f(CW\*(C`splice\*(C'\fR.
.ie n .SS "How can I use Perl's ""\-i"" option from within a program?"
.el .SS "How can I use Perl's \f(CW\-i\fP option from within a program?"
.IX Xref "-i in-place"
.IX Subsection "How can I use Perl's -i option from within a program?"
\&\f(CW\*(C`\-i\*(C'\fR sets the value of Perl's \f(CW$^I\fR variable, which in turn affects
the behavior of \f(CW\*(C`<>\*(C'\fR; see perlrun for more details. By
modifying the appropriate variables directly, you can get the same
behavior within a larger program. For example:
.PP
.Vb 10
\&    # ...
\&    {
\&        local($^I, @ARGV) = (\*(Aq.orig\*(Aq, glob("*.c"));
\&        while (<>) {
\&            if ($. == 1) {
\&                print "This line should appear at the top of each file\en";
\&            }
\&            s/\eb(p)earl\eb/${1}erl/i;        # Correct typos, preserving case
\&            print;
\&            close ARGV if eof;              # Reset $.
\&        }
\&    }
\&    # $^I and @ARGV return to their old values here
.Ve
.PP
This block modifies all the \f(CW\*(C`.c\*(C'\fR files in the current directory,
leaving a backup of the original data from each file in a new
\&\f(CW\*(C`.c.orig\*(C'\fR file.
.SS "How can I copy a file?"
.IX Xref "copy file, copy File::Copy"
.IX Subsection "How can I copy a file?"
(contributed by brian d foy)
.PP
Use the File::Copy module. It comes with Perl and can do a
true copy across file systems, and it does its magic in
a portable fashion.
.PP
.Vb 1
\&    use File::Copy;
\&
\&    copy( $original, $new_copy ) or die "Copy failed: $!";
.Ve
.PP
If you can't use File::Copy, you'll have to do the work yourself:
open the original file, open the destination file, then print
to the destination file as you read the original. You also have to
remember to copy the permissions, owner, and group to the new file.
.SS "How do I make a temporary file name?"
.IX Xref "file, temporary"
.IX Subsection "How do I make a temporary file name?"
If you don't need to know the name of the file, you can use \f(CW\*(C`open()\*(C'\fR
with \f(CW\*(C`undef\*(C'\fR in place of the file name. In Perl 5.8 or later, the
\&\f(CW\*(C`open()\*(C'\fR function creates an anonymous temporary file:
.PP
.Vb 1
\&    open my $tmp, \*(Aq+>\*(Aq, undef or die $!;
.Ve
.PP
Otherwise, you can use the File::Temp module.
.PP
.Vb 1
\&    use File::Temp qw/ tempfile tempdir /;
\&
\&    my $dir = tempdir( CLEANUP => 1 );
\&    ($fh, $filename) = tempfile( DIR => $dir );
\&
\&    # or if you don\*(Aqt need to know the filename
\&
\&    my $fh = tempfile( DIR => $dir );
.Ve
.PP
The File::Temp has been a standard module since Perl 5.6.1. If you
don't have a modern enough Perl installed, use the \f(CW\*(C`new_tmpfile\*(C'\fR
class method from the IO::File module to get a filehandle opened for
reading and writing. Use it if you don't need to know the file's name:
.PP
.Vb 3
\&    use IO::File;
\&    my $fh = IO::File\->new_tmpfile()
\&        or die "Unable to make new temporary file: $!";
.Ve
.PP
If you're committed to creating a temporary file by hand, use the
process \s-1ID\s0 and/or the current time-value. If you need to have many
temporary files in one process, use a counter:
.PP
.Vb 4
\&    BEGIN {
\&        use Fcntl;
\&        my $temp_dir = \-d \*(Aq/tmp\*(Aq ? \*(Aq/tmp\*(Aq : $ENV{TMPDIR} || $ENV{TEMP};
\&        my $base_name = sprintf "%s/%d\-%d\-0000", $temp_dir, $$, time;
\&
\&        sub temp_file {
\&            my $fh;
\&            my $count = 0;
\&            until( defined(fileno($fh)) || $count++ > 100 ) {
\&                $base_name =~ s/\-(\ed+)$/"\-" . (1 + $1)/e;
\&                # O_EXCL is required for security reasons.
\&                sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT;
\&            }
\&
\&            if( defined fileno($fh) ) {
\&                return ($fh, $base_name);
\&            }
\&            else {
\&                return ();
\&            }
\&        }
\&    }
.Ve
.SS "How can I manipulate fixed-record-length files?"
.IX Xref "fixed-length file, fixed-length records"
.IX Subsection "How can I manipulate fixed-record-length files?"
The most efficient way is using \fIpack()\fR and
\&\fIunpack()\fR. This is faster than using
\&\fIsubstr()\fR when taking many, many strings. It is
slower for just a few.
.PP
Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:
.PP
.Vb 10
\&    # sample input line:
\&    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now\-what
\&    my $PS_T = \*(AqA6 A4 A7 A5 A*\*(Aq;
\&    open my $ps, \*(Aq\-|\*(Aq, \*(Aqps\*(Aq;
\&    print scalar <$ps>;
\&    my @fields = qw( pid tt stat time command );
\&    while (<$ps>) {
\&        my %process;
\&        @process{@fields} = unpack($PS_T, $_);
\&        for my $field ( @fields ) {
\&            print "$field: <$process{$field}>\en";
\&        }
\&        print \*(Aqline=\*(Aq, pack($PS_T, @process{@fields} ), "\en";
\&    }
.Ve
.PP
We've used a hash slice in order to easily handle the fields of each row.
Storing the keys in an array makes it easy to operate on them as a
group or loop over them with \f(CW\*(C`for\*(C'\fR. It also avoids polluting the program
with global variables and using symbolic references.
.SS "How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?"
.IX Xref "filehandle, local filehandle, passing filehandle, reference"
.IX Subsection "How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?"
As of perl5.6, \fIopen()\fR autovivifies file and directory handles
as references if you pass it an uninitialized scalar variable.
You can then pass these references just like any other scalar,
and use them in the place of named handles.
.PP
.Vb 1
\&    open my    $fh, $file_name;
\&
\&    open local $fh, $file_name;
\&
\&    print $fh "Hello World!\en";
\&
\&    process_file( $fh );
.Ve
.PP
If you like, you can store these filehandles in an array or a hash.
If you access them directly, they aren't simple scalars and you
need to give \f(CW\*(C`print\*(C'\fR a little help by placing the filehandle
reference in braces. Perl can only figure it out on its own when
the filehandle reference is a simple scalar.
.PP
.Vb 1
\&    my @fhs = ( $fh1, $fh2, $fh3 );
\&
\&    for( $i = 0; $i <= $#fhs; $i++ ) {
\&        print {$fhs[$i]} "just another Perl answer, \en";
\&    }
.Ve
.PP
Before perl5.6, you had to deal with various typeglob idioms
which you may see in older code.
.PP
.Vb 3
\&    open FILE, "> $filename";
\&    process_typeglob(   *FILE );
\&    process_reference( \e*FILE );
\&
\&    sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
\&    sub process_reference { local $fh = shift; print $fh "Reference!" }
.Ve
.PP
If you want to create many anonymous handles, you should
check out the Symbol or IO::Handle modules.
.SS "How can I use a filehandle indirectly?"
.IX Xref "filehandle, indirect"
.IX Subsection "How can I use a filehandle indirectly?"
An indirect filehandle is the use of something other than a symbol
in a place that a filehandle is expected. Here are ways
to get indirect filehandles:
.PP
.Vb 5
\&    $fh =   SOME_FH;       # bareword is strict\-subs hostile
\&    $fh =  "SOME_FH";      # strict\-refs hostile; same package only
\&    $fh =  *SOME_FH;       # typeglob
\&    $fh = \e*SOME_FH;       # ref to typeglob (bless\-able)
\&    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
.Ve
.PP
Or, you can use the \f(CW\*(C`new\*(C'\fR method from one of the IO::* modules to
create an anonymous filehandle and store that in a scalar variable.
.PP
.Vb 2
\&    use IO::Handle;                     # 5.004 or higher
\&    my $fh = IO::Handle\->new();
.Ve
.PP
Then use any of those as you would a normal filehandle. Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains
a filehandle. Functions like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, or
the \f(CW\*(C`<FH>\*(C'\fR diamond operator will accept either a named filehandle
or a scalar variable containing one:
.PP
.Vb 4
\&    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
\&    print $ofh "Type it: ";
\&    my $got = <$ifh>
\&    print $efh "What was that: $got";
.Ve
.PP
If you're passing a filehandle to a function, you can write
the function in two ways:
.PP
.Vb 4
\&    sub accept_fh {
\&        my $fh = shift;
\&        print $fh "Sending to indirect filehandle\en";
\&    }
.Ve
.PP
Or it can localize a typeglob and use the filehandle directly:
.PP
.Vb 4
\&    sub accept_fh {
\&        local *FH = shift;
\&        print  FH "Sending to localized filehandle\en";
\&    }
.Ve
.PP
Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this
is risky.)
.PP
.Vb 2
\&    accept_fh(*STDOUT);
\&    accept_fh($handle);
.Ve
.PP
In the examples above, we assigned the filehandle to a scalar variable
before using it. That is because only simple scalar variables, not
expressions or subscripts of hashes or arrays, can be used with
built-ins like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, or the diamond operator. Using
something other than a simple scalar variable as a filehandle is
illegal and won't even compile:
.PP
.Vb 4
\&    my @fd = (*STDIN, *STDOUT, *STDERR);
\&    print $fd[1] "Type it: ";                           # WRONG
\&    my $got = <$fd[0]>                                  # WRONG
\&    print $fd[2] "What was that: $got";                 # WRONG
.Ve
.PP
With \f(CW\*(C`print\*(C'\fR and \f(CW\*(C`printf\*(C'\fR, you get around this by using a block and
an expression where you would place the filehandle:
.PP
.Vb 3
\&    print  { $fd[1] } "funny stuff\en";
\&    printf { $fd[1] } "Pity the poor %x.\en", 3_735_928_559;
\&    # Pity the poor deadbeef.
.Ve
.PP
That block is a proper block like any other, so you can put more
complicated code there. This sends the message out to one of two places:
.PP
.Vb 3
\&    my $ok = \-x "/bin/cat";
\&    print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\en";
\&    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\en";
.Ve
.PP
This approach of treating \f(CW\*(C`print\*(C'\fR and \f(CW\*(C`printf\*(C'\fR like object methods
calls doesn't work for the diamond operator. That's because it's a
real operator, not just a function with a comma-less argument. Assuming
you've been storing typeglobs in your structure as we did above, you
can use the built-in function named \f(CW\*(C`readline\*(C'\fR to read a record just
as \f(CW\*(C`<>\*(C'\fR does. Given the initialization shown above for \f(CW@fd\fR, this
would work, but only because \fIreadline()\fR requires a typeglob. It doesn't
work with objects or strings, which might be a bug we haven't fixed yet.
.PP
.Vb 1
\&    $got = readline($fd[0]);
.Ve
.PP
Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators. Playing the object
game doesn't help you at all here.
.SS "How can I set up a footer format to be used with \fIwrite()\fP?"
.IX Xref "footer"
.IX Subsection "How can I set up a footer format to be used with write()?"
There's no builtin way to do this, but perlform has a couple of
techniques to make it possible for the intrepid hacker.
.SS "How can I \fIwrite()\fP into a string?"
.IX Xref "write, into a string"
.IX Subsection "How can I write() into a string?"
(contributed by brian d foy)
.PP
If you want to \f(CW\*(C`write\*(C'\fR into a string, you just have to <open> a
filehandle to a string, which Perl has been able to do since Perl 5.6:
.PP
.Vb 2
\&    open FH, \*(Aq>\*(Aq, \emy $string;
\&    write( FH );
.Ve
.PP
Since you want to be a good programmer, you probably want to use a lexical
filehandle, even though formats are designed to work with bareword filehandles
since the default format names take the filehandle name. However, you can
control this with some Perl special per-filehandle variables: \f(CW$^\fR, which
names the top-of-page format, and \f(CW$~\fR which shows the line format. You have
to change the default filehandle to set these variables:
.PP
.Vb 1
\&    open my($fh), \*(Aq>\*(Aq, \emy $string;
\&
\&    { # set per\-filehandle variables
\&        my $old_fh = select( $fh );
\&        $~ = \*(AqANIMAL\*(Aq;
\&        $^ = \*(AqANIMAL_TOP\*(Aq;
\&        select( $old_fh );
\&    }
\&
\&    format ANIMAL_TOP =
\&     ID  Type    Name
\&    .
\&
\&    format ANIMAL =
\&    @##   @<<<    @<<<<<<<<<<<<<<
\&    $id,  $type,  $name
\&    .
.Ve
.PP
Although write can work with lexical or package variables, whatever variables
you use have to scope in the format. That most likely means you'll want to
localize some package variables:
.PP
.Vb 4
\&    {
\&        local( $id, $type, $name ) = qw( 12 cat Buster );
\&        write( $fh );
\&    }
\&
\&    print $string;
.Ve
.PP
There are also some tricks that you can play with \f(CW\*(C`formline\*(C'\fR and the
accumulator variable \f(CW$^A\fR, but you lose a lot of the value of formats
since \f(CW\*(C`formline\*(C'\fR won't handle paging and so on. You end up reimplementing
formats when you use them.
.SS "How can I open a filehandle to a string?"
.IX Xref "string open IO::String filehandle"
.IX Subsection "How can I open a filehandle to a string?"
(contributed by Peter J. Holzer, hjp\-usenet2@hjp.at)
.PP
Since Perl 5.8.0 a file handle referring to a string can be created by
calling open with a reference to that string instead of the filename.
This file handle can then be used to read from or write to the string:
.PP
.Vb 3
\&    open(my $fh, \*(Aq>\*(Aq, \e$string) or die "Could not open string for writing";
\&    print $fh "foo\en";
\&    print $fh "bar\en";    # $string now contains "foo\enbar\en"
\&
\&    open(my $fh, \*(Aq<\*(Aq, \e$string) or die "Could not open string for reading";
\&    my $x = <$fh>;    # $x now contains "foo\en"
.Ve
.PP
With older versions of Perl, the IO::String module provides similar
functionality.
.SS "How can I output my numbers with commas added?"
.IX Xref "number, commify"
.IX Subsection "How can I output my numbers with commas added?"
(contributed by brian d foy and Benjamin Goldberg)
.PP
You can use Number::Format to separate places in a number.
It handles locale information for those of you who want to insert
full stops instead (or anything else that they want to use,
really).
.PP
This subroutine will add commas to your number:
.PP
.Vb 5
\&    sub commify {
\&        local $_  = shift;
\&        1 while s/^([\-+]?\ed+)(\ed{3})/$1,$2/;
\&        return $_;
\&    }
.Ve
.PP
This regex from Benjamin Goldberg will add commas to numbers:
.PP
.Vb 1
\&    s/(^[\-+]?\ed+?(?=(?>(?:\ed{3})+)(?!\ed))|\eG\ed{3}(?=\ed))/$1,/g;
.Ve
.PP
It is easier to see with comments:
.PP
.Vb 11
\&    s/(
\&        ^[\-+]?             # beginning of number.
\&        \ed+?               # first digits before first comma
\&        (?=                # followed by, (but not included in the match) :
\&            (?>(?:\ed{3})+) # some positive multiple of three digits.
\&            (?!\ed)         # an *exact* multiple, not x * 3 + 1 or whatever.
\&        )
\&        |                  # or:
\&        \eG\ed{3}            # after the last group, get three digits
\&        (?=\ed)             # but they have to have more digits after them.
\&    )/$1,/xg;
.Ve
.SS "How can I translate tildes (~) in a filename?"
.IX Xref "tilde tilde expansion"
.IX Subsection "How can I translate tildes (~) in a filename?"
Use the <> (\f(CW\*(C`glob()\*(C'\fR) operator, documented in perlfunc.
Versions of Perl older than 5.6 require that you have a shell
installed that groks tildes. Later versions of Perl have this feature
built in. The File::KGlob module (available from \s-1CPAN\s0) gives more
portable glob functionality.
.PP
Within Perl, you may use this directly:
.PP
.Vb 11
\&    $filename =~ s{
\&      ^ ~             # find a leading tilde
\&      (               # save this in $1
\&          [^/]        # a non\-slash character
\&                *     # repeated 0 or more times (0 means me)
\&      )
\&    }{
\&      $1
\&          ? (getpwnam($1))[7]
\&          : ( $ENV{HOME} || $ENV{LOGDIR} )
\&    }ex;
.Ve
.SS "How come when I open a file read-write it wipes it out?"
.IX Xref "clobber read-write clobbering truncate truncating"
.IX Subsection "How come when I open a file read-write it wipes it out?"
Because you're using something like this, which truncates the file
\&\fIthen\fR gives you read-write access:
.PP
.Vb 1
\&    open my $fh, \*(Aq+>\*(Aq, \*(Aq/path/name\*(Aq; # WRONG (almost always)
.Ve
.PP
Whoops. You should instead use this, which will fail if the file
doesn't exist:
.PP
.Vb 1
\&    open my $fh, \*(Aq+<\*(Aq, \*(Aq/path/name\*(Aq; # open for update
.Ve
.PP
Using \*(L">\*(R" always clobbers or creates. Using \*(L"<\*(R" never does
either. The \*(L"+\*(R" doesn't change this.
.PP
Here are examples of many kinds of file opens. Those using \f(CW\*(C`sysopen\*(C'\fR
all assume that you've pulled in the constants from Fcntl:
.PP
.Vb 1
\&    use Fcntl;
.Ve
.PP
To open file for reading:
.PP
.Vb 2
\&    open my $fh, \*(Aq<\*(Aq, $path                               or die $!;
\&    sysopen my $fh, $path, O_RDONLY                       or die $!;
.Ve
.PP
To open file for writing, create new file if needed or else truncate old file:
.PP
.Vb 3
\&    open my $fh, \*(Aq>\*(Aq, $path                               or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT       or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die $!;
.Ve
.PP
To open file for writing, create new file, file must not exist:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT        or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666  or die $!;
.Ve
.PP
To open file for appending, create if necessary:
.PP
.Vb 3
\&    open my $fh, \*(Aq>>\*(Aq $path                               or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT      or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or die $!;
.Ve
.PP
To open file for appending, file must exist:
.PP
.Vb 1
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND              or die $!;
.Ve
.PP
To open file for update, file must exist:
.PP
.Vb 2
\&    open my $fh, \*(Aq+<\*(Aq, $path                              or die $!;
\&    sysopen my $fh, $path, O_RDWR                         or die $!;
.Ve
.PP
To open file for update, create file if necessary:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_RDWR|O_CREAT                 or die $!;
\&    sysopen my $fh, $path, O_RDWR|O_CREAT, 0666           or die $!;
.Ve
.PP
To open file for update, file must not exist:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT          or die $!;
\&    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666    or die $!;
.Ve
.PP
To open a file without blocking, creating if necessary:
.PP
.Vb 2
\&    sysopen my $fh, \*(Aq/foo/somefile\*(Aq, O_WRONLY|O_NDELAY|O_CREAT
\&        or die "can\*(Aqt open /foo/somefile: $!":
.Ve
.PP
Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over \s-1NFS.\s0 That is, two processes might both
successfully create or unlink the same file! Therefore O_EXCL
isn't as exclusive as you might wish.
.PP
See also perlopentut.
.ie n .SS "Why do I sometimes get an ""Argument list too long"" when I use <*>?"
.el .SS "Why do I sometimes get an ``Argument list too long'' when I use <*>?"
.IX Xref "argument list too long"
.IX Subsection "Why do I sometimes get an Argument list too long when I use <*>?"
The \f(CW\*(C`<>\*(C'\fR operator performs a globbing operation (see above).
In Perl versions earlier than v5.6.0, the internal \fIglob()\fR operator forks
\&\fIcsh\fR\|(1) to do the actual glob expansion, but
csh can't handle more than 127 items and so gives the error message
\&\f(CW\*(C`Argument list too long\*(C'\fR. People who installed tcsh as csh won't
have this problem, but their users may be surprised by it.
.PP
To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with \fIreaddir()\fR and patterns, or use a module like File::Glob,
one that doesn't use the shell to do globbing.
.ie n .SS "How can I open a file with a leading "">"" or trailing blanks?"
.el .SS "How can I open a file with a leading ``>'' or trailing blanks?"
.IX Xref "filename, special characters"
.IX Subsection "How can I open a file with a leading > or trailing blanks?"
(contributed by Brian McCauley)
.PP
The special two-argument form of Perl's \fIopen()\fR function ignores
trailing blanks in filenames and infers the mode from certain leading
characters (or a trailing \*(L"|\*(R"). In older versions of Perl this was the
only version of \fIopen()\fR and so it is prevalent in old code and books.
.PP
Unless you have a particular reason to use the two-argument form you
should use the three-argument form of \fIopen()\fR which does not treat any
characters in the filename as special.
.PP
.Vb 2
\&    open my $fh, "<", "  file  ";  # filename is "   file   "
\&    open my $fh, ">", ">file";     # filename is ">file"
.Ve
.SS "How can I reliably rename a file?"
.IX Xref "rename mv move file, rename"
.IX Subsection "How can I reliably rename a file?"
If your operating system supports a proper \fImv\fR\|(1) utility or its
functional equivalent, this works:
.PP
.Vb 1
\&    rename($old, $new) or system("mv", $old, $new);
.Ve
.PP
It may be more portable to use the File::Copy module instead.
You just copy to the new file to the new name (checking return
values), then delete the old one. This isn't really the same
semantically as a \f(CW\*(C`rename()\*(C'\fR, which preserves meta-information like
permissions, timestamps, inode info, etc.
.SS "How can I lock a file?"
.IX Xref "lock file, lock flock"
.IX Subsection "How can I lock a file?"
Perl's builtin \fIflock()\fR function (see perlfunc for details) will call
\&\fIflock\fR\|(2) if that exists, \fIfcntl\fR\|(2) if it doesn't (on perl version 5.004 and
later), and \fIlockf\fR\|(3) if neither of the two previous system calls exists.
On some systems, it may even use a different form of native locking.
Here are some gotchas with Perl's \fIflock()\fR:
.IP "1." 4
Produces a fatal error if none of the three system calls (or their
close equivalent) exists.
.IP "2." 4
\&\fIlockf\fR\|(3) does not provide shared locking, and requires that the
filehandle be open for writing (or appending, or read/writing).
.IP "3." 4
Some versions of \fIflock()\fR can't lock files over a network (e.g. on \s-1NFS\s0 file
systems), so you'd need to force the use of \fIfcntl\fR\|(2) when you build Perl.
But even this is dubious at best. See the flock entry of perlfunc
and the \fI\s-1INSTALL\s0\fR file in the source distribution for information on
building Perl to do this.
.Sp
Two potentially non-obvious but traditional flock semantics are that
it waits indefinitely until the lock is granted, and that its locks are
\&\fImerely advisory\fR. Such discretionary locks are more flexible, but
offer fewer guarantees. This means that files locked with \fIflock()\fR may
be modified by programs that do not also use \fIflock()\fR. Cars that stop
for red lights get on well with each other, but not with cars that don't
stop for red lights. See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details. It's
best to assume traditional behavior if you're writing portable programs.
(If you're not, you should as always feel perfectly free to write
for your own system's idiosyncrasies (sometimes called \*(L"features\*(R").
Slavish adherence to portability concerns shouldn't get in the way of
your getting your job done.)
.Sp
For more information on file locking, see also
\&\*(L"File Locking\*(R" in perlopentut if you have it (new for 5.6).
.ie n .SS "Why can't I just open(\s-1FH, ""\s0>file.lock"")?"
.el .SS "Why can't I just open(\s-1FH, ``\s0>file.lock'')?"
.IX Xref "lock, lockfile race condition"
.IX Subsection "Why can't I just open(FH, >file.lock)?"
A common bit of code \fB\s-1NOT TO USE\s0\fR is this:
.PP
.Vb 2
\&    sleep(3) while \-e \*(Aqfile.lock\*(Aq;    # PLEASE DO NOT USE
\&    open my $lock, \*(Aq>\*(Aq, \*(Aqfile.lock\*(Aq; # THIS BROKEN CODE
.Ve
.PP
This is a classic race condition: you take two steps to do something
which must be done in one. That's why computer hardware provides an
atomic test-and-set instruction. In theory, this \*(L"ought\*(R" to work:
.PP
.Vb 2
\&    sysopen my $fh, "file.lock", O_WRONLY|O_EXCL|O_CREAT
\&        or die "can\*(Aqt open  file.lock: $!";
.Ve
.PP
except that lamentably, file creation (and deletion) is not atomic
over \s-1NFS,\s0 so this won't work (at least, not every time) over the net.
Various schemes involving \fIlink()\fR have been suggested, but
these tend to involve busy-wait, which is also less than desirable.
.SS "I still don't get locking. I just want to increment the number in the file. How can I do this?"
.IX Xref "counter file, counter"
.IX Subsection "I still don't get locking. I just want to increment the number in the file. How can I do this?"
Didn't anyone ever tell you web-page hit counters were useless?
They don't count number of hits, they're a waste of time, and they serve
only to stroke the writer's vanity. It's better to pick a random number;
they're more realistic.
.PP
Anyway, this is what you can do if you can't help yourself.
.PP
.Vb 8
\&    use Fcntl qw(:DEFAULT :flock);
\&    sysopen my $fh, "numfile", O_RDWR|O_CREAT or die "can\*(Aqt open numfile: $!";
\&    flock $fh, LOCK_EX                        or die "can\*(Aqt flock numfile: $!";
\&    my $num = <$fh> || 0;
\&    seek $fh, 0, 0                            or die "can\*(Aqt rewind numfile: $!";
\&    truncate $fh, 0                           or die "can\*(Aqt truncate numfile: $!";
\&    (print $fh $num+1, "\en")                  or die "can\*(Aqt write numfile: $!";
\&    close $fh                                 or die "can\*(Aqt close numfile: $!";
.Ve
.PP
Here's a much better web-page hit counter:
.PP
.Vb 1
\&    $hits = int( (time() \- 850_000_000) / rand(1_000) );
.Ve
.PP
If the count doesn't impress your friends, then the code might. :\-)
.SS "All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?"
.IX Xref "append file, append"
.IX Subsection "All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?"
If you are on a system that correctly implements \f(CW\*(C`flock\*(C'\fR and you use
the example appending code from \*(L"perldoc \-f flock\*(R" everything will be
\&\s-1OK\s0 even if the \s-1OS\s0 you are on doesn't implement append mode correctly
(if such a system exists). So if you are happy to restrict yourself to
OSs that implement \f(CW\*(C`flock\*(C'\fR (and that's not really much of a
restriction) then that is what you should do.
.PP
If you know you are only going to use a system that does correctly
implement appending (i.e. not Win32) then you can omit the \f(CW\*(C`seek\*(C'\fR
from the code in the previous answer.
.PP
If you know you are only writing code to run on an \s-1OS\s0 and filesystem
that does implement append mode correctly (a local filesystem on a
modern Unix for example), and you keep the file in block-buffered mode
and you write less than one buffer-full of output between each manual
flushing of the buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else's output. You can also use the
\&\f(CW\*(C`syswrite\*(C'\fR function which is simply a wrapper around your system's
\&\f(CWwrite(2)\fR system call.
.PP
There is still a small theoretical chance that a signal will interrupt
the system-level \f(CW\*(C`write()\*(C'\fR operation before completion. There is also
a possibility that some \s-1STDIO\s0 implementations may call multiple system
level \f(CW\*(C`write()\*(C'\fRs even if the buffer was empty to start. There may be
some systems where this probability is reduced to zero, and this is
not a concern when using \f(CW\*(C`:perlio\*(C'\fR instead of your system's \s-1STDIO.\s0
.SS "How do I randomly update a binary file?"
.IX Xref "file, binary patch"
.IX Subsection "How do I randomly update a binary file?"
If you're just trying to patch a binary, in many cases something as
simple as this works:
.PP
.Vb 1
\&    perl \-i \-pe \*(Aqs{window manager}{window mangler}g\*(Aq /usr/bin/emacs
.Ve
.PP
However, if you have fixed sized records, then you might do something more
like this:
.PP
.Vb 9
\&    my $RECSIZE = 220; # size of record, in bytes
\&    my $recno   = 37;  # which record to update
\&    open my $fh, \*(Aq+<\*(Aq, \*(Aqsomewhere\*(Aq or die "can\*(Aqt update somewhere: $!";
\&    seek $fh, $recno * $RECSIZE, 0;
\&    read $fh, $record, $RECSIZE == $RECSIZE or die "can\*(Aqt read record $recno: $!";
\&    # munge the record
\&    seek $fh, \-$RECSIZE, 1;
\&    print $fh $record;
\&    close $fh;
.Ve
.PP
Locking and error checking are left as an exercise for the reader.
Don't forget them or you'll be quite sorry.
.SS "How do I get a file's timestamp in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How do I get a file's timestamp in perl?"
If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the \fB\-A\fR,
\&\fB\-M\fR, or \fB\-C\fR file test operations as documented in perlfunc.
These retrieve the age of the file (measured against the start-time of
your program) in days as a floating point number. Some platforms may
not have all of these times. See perlport for details. To retrieve
the \*(L"raw\*(R" time in seconds since the epoch, you would call the stat
function, then use \f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`gmtime()\*(C'\fR, or
\&\f(CW\*(C`POSIX::strftime()\*(C'\fR to convert this into human-readable form.
.PP
Here's an example:
.PP
.Vb 3
\&    my $write_secs = (stat($file))[9];
\&    printf "file %s updated at %s\en", $file,
\&        scalar localtime($write_secs);
.Ve
.PP
If you prefer something more legible, use the File::stat module
(part of the standard distribution in version 5.004 and later):
.PP
.Vb 5
\&    # error checking left as an exercise for reader.
\&    use File::stat;
\&    use Time::localtime;
\&    my $date_string = ctime(stat($file)\->mtime);
\&    print "file $file updated at $date_string\en";
.Ve
.PP
The \fIPOSIX::strftime()\fR approach has the benefit of being,
in theory, independent of the current locale. See perllocale
for details.
.SS "How do I set a file's timestamp in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How do I set a file's timestamp in perl?"
You use the \fIutime()\fR function documented in \*(L"utime\*(R" in perlfunc.
By way of example, here's a little program that copies the
read and write times from its first argument to all the rest
of them.
.PP
.Vb 6
\&    if (@ARGV < 2) {
\&        die "usage: cptimes timestamp_file other_files ...\en";
\&    }
\&    my $timestamp = shift;
\&    my($atime, $mtime) = (stat($timestamp))[8,9];
\&    utime $atime, $mtime, @ARGV;
.Ve
.PP
Error checking is, as usual, left as an exercise for the reader.
.PP
The perldoc for utime also has an example that has the same
effect as \fItouch\fR\|(1) on files that \fIalready exist\fR.
.PP
Certain file systems have a limited ability to store the times
on a file at the expected level of precision. For example, the
\&\s-1FAT\s0 and \s-1HPFS\s0 filesystem are unable to create dates on files with
a finer granularity than two seconds. This is a limitation of
the filesystems, not of \fIutime()\fR.
.SS "How do I print to more than one file at once?"
.IX Xref "print, to multiple files"
.IX Subsection "How do I print to more than one file at once?"
To connect one filehandle to several output filehandles,
you can use the IO::Tee or Tie::FileHandle::Multiplex modules.
.PP
If you only have to do this once, you can print individually
to each filehandle.
.PP
.Vb 1
\&    for my $fh ($fh1, $fh2, $fh3) { print $fh "whatever\en" }
.Ve
.SS "How can I read in an entire file all at once?"
.IX Xref "slurp file, slurping"
.IX Subsection "How can I read in an entire file all at once?"
The customary Perl approach for processing all the lines in a file is to
do so one line at a time:
.PP
.Vb 6
\&    open my $input, \*(Aq<\*(Aq, $file or die "can\*(Aqt open $file: $!";
\&    while (<$input>) {
\&        chomp;
\&        # do something with $_
\&    }
\&    close $input or die "can\*(Aqt close $file: $!";
.Ve
.PP
This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often\*(--if not almost always\*(--the wrong approach. Whenever
you see someone do this:
.PP
.Vb 1
\&    my @lines = <INPUT>;
.Ve
.PP
You should think long and hard about why you need everything loaded at
once. It's just not a scalable solution.
.PP
If you \*(L"mmap\*(R" the file with the File::Map module from
\&\s-1CPAN,\s0 you can virtually load the entire file into a
string without actually storing it in memory:
.PP
.Vb 1
\&    use File::Map qw(map_file);
\&
\&    map_file my $string, $filename;
.Ve
.PP
Once mapped, you can treat \f(CW$string\fR as you would any other string.
Since you don't necessarily have to load the data, mmap-ing can be
very fast and may not increase your memory footprint.
.PP
You might also find it more
fun to use the standard Tie::File module, or the DB_File module's
\&\f(CW$DB_RECNO\fR bindings, which allow you to tie an array to a file so that
accessing an element of the array actually accesses the corresponding
line in the file.
.PP
If you want to load the entire file, you can use the File::Slurp
module to do it in one one simple and efficient step:
.PP
.Vb 1
\&    use File::Slurp;
\&
\&    my $all_of_it = read_file($filename); # entire file in scalar
\&    my @all_lines = read_file($filename); # one line per element
.Ve
.PP
Or you can read the entire file contents into a scalar like this:
.PP
.Vb 6
\&    my $var;
\&    {
\&        local $/;
\&        open my $fh, \*(Aq<\*(Aq, $file or die "can\*(Aqt open $file: $!";
\&        $var = <$fh>;
\&    }
.Ve
.PP
That temporarily undefs your record separator, and will automatically
close the file at block exit. If the file is already open, just use this:
.PP
.Vb 1
\&    my $var = do { local $/; <$fh> };
.Ve
.PP
You can also use a localized \f(CW@ARGV\fR to eliminate the \f(CW\*(C`open\*(C'\fR:
.PP
.Vb 1
\&    my $var = do { local( @ARGV, $/ ) = $file; <> };
.Ve
.PP
For ordinary files you can also use the \f(CW\*(C`read\*(C'\fR function.
.PP
.Vb 1
\&    read( $fh, $var, \-s $fh );
.Ve
.PP
That third argument tests the byte size of the data on the \f(CW$fh\fR filehandle
and reads that many bytes into the buffer \f(CW$var\fR.
.SS "How can I read in a file by paragraphs?"
.IX Xref "file, reading by paragraphs"
.IX Subsection "How can I read in a file by paragraphs?"
Use the \f(CW$/\fR variable (see perlvar for details). You can either
set it to \f(CW""\fR to eliminate empty paragraphs (\f(CW"abc\en\en\en\endef"\fR,
for instance, gets treated as two paragraphs and not three), or
\&\f(CW"\en\en"\fR to accept empty paragraphs.
.PP
Note that a blank line must have no blanks in it. Thus
\&\f(CW"fred\en\ \enstuff\en\en"\fR is one paragraph, but \f(CW"fred\en\enstuff\en\en"\fR is two.
.SS "How can I read a single character from a file? From the keyboard?"
.IX Xref "getc file, reading one character at a time"
.IX Subsection "How can I read a single character from a file? From the keyboard?"
You can use the builtin \f(CW\*(C`getc()\*(C'\fR function for most filehandles, but
it won't (easily) work on a terminal device. For \s-1STDIN,\s0 either use
the Term::ReadKey module from \s-1CPAN\s0 or use the sample code in
\&\*(L"getc\*(R" in perlfunc.
.PP
If your system supports the portable operating system programming
interface (\s-1POSIX\s0), you can use the following code, which you'll note
turns off echo processing as well.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    $| = 1;
\&    for (1..4) {
\&        print "gimme: ";
\&        my $got = getone();
\&        print "\-\-> $got\en";
\&    }
\&    exit;
\&
\&    BEGIN {
\&        use POSIX qw(:termios_h);
\&
\&        my ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&        my $fd_stdin = fileno(STDIN);
\&
\&        $term     = POSIX::Termios\->new();
\&        $term\->getattr($fd_stdin);
\&        $oterm     = $term\->getlflag();
\&
\&        $echo     = ECHO | ECHOK | ICANON;
\&        $noecho   = $oterm & ~$echo;
\&
\&        sub cbreak {
\&            $term\->setlflag($noecho);
\&            $term\->setcc(VTIME, 1);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub cooked {
\&            $term\->setlflag($oterm);
\&            $term\->setcc(VTIME, 0);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub getone {
\&            my $key = \*(Aq\*(Aq;
\&            cbreak();
\&            sysread(STDIN, $key, 1);
\&            cooked();
\&            return $key;
\&        }
\&    }
\&
\&    END { cooked() }
.Ve
.PP
The Term::ReadKey module from \s-1CPAN\s0 may be easier to use. Recent versions
include also support for non-portable systems as well.
.PP
.Vb 8
\&    use Term::ReadKey;
\&    open my $tty, \*(Aq<\*(Aq, \*(Aq/dev/tty\*(Aq;
\&    print "Gimme a char: ";
\&    ReadMode "raw";
\&    my $key = ReadKey 0, $tty;
\&    ReadMode "normal";
\&    printf "\enYou said %s, char number %03d\en",
\&        $key, ord $key;
.Ve
.SS "How can I tell whether there's a character waiting on a filehandle?"
.IX Subsection "How can I tell whether there's a character waiting on a filehandle?"
The very first thing you should do is look into getting the Term::ReadKey
extension from \s-1CPAN.\s0 As we mentioned earlier, it now even has limited
support for non-portable (read: not open systems, closed, proprietary,
not \s-1POSIX,\s0 not Unix, etc.) systems.
.PP
You should also check out the Frequently Asked Questions list in
comp.unix.* for things like this: the answer is essentially the same.
It's very system-dependent. Here's one solution that works on \s-1BSD\s0
systems:
.PP
.Vb 5
\&    sub key_ready {
\&        my($rin, $nfd);
\&        vec($rin, fileno(STDIN), 1) = 1;
\&        return $nfd = select($rin,undef,undef,0);
\&    }
.Ve
.PP
If you want to find out how many characters are waiting, there's
also the \s-1FIONREAD\s0 ioctl call to be looked at. The \fIh2ph\fR tool that
comes with Perl tries to convert C include files to Perl code, which
can be \f(CW\*(C`require\*(C'\fRd. \s-1FIONREAD\s0 ends up defined as a function in the
\&\fIsys/ioctl.ph\fR file:
.PP
.Vb 1
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, FIONREAD(), $size)    or die "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
If \fIh2ph\fR wasn't installed or doesn't work for you, you can
\&\fIgrep\fR the include files by hand:
.PP
.Vb 2
\&    % grep FIONREAD /usr/include/*/*
\&    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
.Ve
.PP
Or write a small C program using the editor of champions:
.PP
.Vb 9
\&    % cat > fionread.c
\&    #include <sys/ioctl.h>
\&    main() {
\&        printf("%#08x\en", FIONREAD);
\&    }
\&    ^D
\&    % cc \-o fionread fionread.c
\&    % ./fionread
\&    0x4004667f
.Ve
.PP
And then hard-code it, leaving porting as an exercise to your successor.
.PP
.Vb 1
\&    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, $FIONREAD, $size)     or die "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
\&\s-1FIONREAD\s0 requires a filehandle connected to a stream, meaning that sockets,
pipes, and tty devices work, but \fInot\fR files.
.ie n .SS "How do I do a ""tail \-f"" in perl?"
.el .SS "How do I do a \f(CWtail \-f\fP in perl?"
.IX Xref "tail IO::Handle File::Tail clearerr"
.IX Subsection "How do I do a tail -f in perl?"
First try
.PP
.Vb 1
\&    seek($gw_fh, 0, 1);
.Ve
.PP
The statement \f(CW\*(C`seek($gw_fh, 0, 1)\*(C'\fR doesn't change the current position,
but it does clear the end-of-file condition on the handle, so that the
next \f(CW\*(C`<$gw_fh>\*(C'\fR makes Perl try again to read something.
.PP
If that doesn't work (it relies on features of your stdio implementation),
then you need something more like this:
.PP
.Vb 7
\&    for (;;) {
\&      for ($curpos = tell($gw_fh); <$gw_fh>; $curpos =tell($gw_fh)) {
\&        # search for some stuff and put it into files
\&      }
\&      # sleep for a while
\&      seek($gw_fh, $curpos, 0);  # seek to where we had been
\&    }
.Ve
.PP
If this still doesn't work, look into the \f(CW\*(C`clearerr\*(C'\fR method
from IO::Handle, which resets the error and end-of-file states
on the handle.
.PP
There's also a File::Tail module from \s-1CPAN.\s0
.SS "How do I \fIdup()\fP a filehandle in Perl?"
.IX Xref "dup"
.IX Subsection "How do I dup() a filehandle in Perl?"
If you check \*(L"open\*(R" in perlfunc, you'll see that several of the ways
to call \fIopen()\fR should do the trick. For example:
.PP
.Vb 2
\&    open my $log, \*(Aq>>\*(Aq, \*(Aq/foo/logfile\*(Aq;
\&    open STDERR, \*(Aq>&\*(Aq, $log;
.Ve
.PP
Or even with a literal numeric descriptor:
.PP
.Vb 2
\&    my $fd = $ENV{MHCONTEXTFD};
\&    open $mhcontext, "<&=$fd";  # like fdopen(3S)
.Ve
.PP
Note that \*(L"<&STDIN\*(R" makes a copy, but \*(L"<&=STDIN\*(R" makes
an alias. That means if you close an aliased handle, all
aliases become inaccessible. This is not true with
a copied one.
.PP
Error checking, as always, has been left as an exercise for the reader.
.SS "How do I close a file descriptor by number?"
.IX Xref "file, closing file descriptors POSIX close"
.IX Subsection "How do I close a file descriptor by number?"
If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used \f(CW\*(C`POSIX::open\*(C'\fR), you can use the
\&\f(CW\*(C`close()\*(C'\fR function from the \s-1POSIX\s0 module:
.PP
.Vb 1
\&    use POSIX ();
\&
\&    POSIX::close( $fd );
.Ve
.PP
This should rarely be necessary, as the Perl \f(CW\*(C`close()\*(C'\fR function is to be
used for things that Perl opened itself, even if it was a dup of a
numeric descriptor as with \f(CW\*(C`MHCONTEXT\*(C'\fR above. But if you really have
to, you may be able to do this:
.PP
.Vb 3
\&    require \*(Aqsys/syscall.ph\*(Aq;
\&    my $rc = syscall(SYS_close(), $fd + 0);  # must force numeric
\&    die "can\*(Aqt sysclose $fd: $!" unless $rc == \-1;
.Ve
.PP
Or, just use the fdopen(3S) feature of \f(CW\*(C`open()\*(C'\fR:
.PP
.Vb 4
\&    {
\&        open my $fh, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
\&        close $fh;
\&    }
.Ve
.ie n .SS "Why can't I use ""C:\etemp\efoo"" in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?"
.el .SS "Why can't I use ``C:\etemp\efoo'' in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?"
.IX Xref "filename, DOS issues"
.IX Subsection "Why can't I use C:tempfoo in DOS paths? Why doesn't `C:tempfoo.exe` work?"
Whoops!  You just put a tab and a formfeed into that filename!
Remember that within double quoted strings (\*(L"like\ethis\*(R"), the
backslash is an escape character. The full list of these is in
\&\*(L"Quote and Quote-like Operators\*(R" in perlop. Unsurprisingly, you don't
have a file called \*(L"c:(tab)emp(formfeed)oo\*(R" or
\&\*(L"c:(tab)emp(formfeed)oo.exe\*(R" on your legacy \s-1DOS\s0 filesystem.
.PP
Either single-quote your strings, or (preferably) use forward slashes.
Since all \s-1DOS\s0 and Windows versions since something like MS-DOS 2.0 or so
have treated \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`\e\*(C'\fR the same in a path, you might as well use the
one that doesn't clash with Perl\*(--or the \s-1POSIX\s0 shell, \s-1ANSI C\s0 and \*(C+,
awk, Tcl, Java, or Python, just to mention a few. \s-1POSIX\s0 paths
are more portable, too.
.ie n .SS "Why doesn't glob(""*.*"") get all the files?"
.el .SS "Why doesn't glob(``*.*'') get all the files?"
.IX Xref "glob"
.IX Subsection "Why doesn't glob(*.*) get all the files?"
Because even on non-Unix ports, Perl's glob function follows standard
Unix globbing semantics. You'll need \f(CW\*(C`glob("*")\*(C'\fR to get all (non-hidden)
files. This makes \fIglob()\fR portable even to legacy systems. Your
port may include proprietary globbing functions as well. Check its
documentation for details.
.ie n .SS "Why does Perl let me delete read-only files? Why does ""\-i"" clobber protected files? Isn't this a bug in Perl?"
.el .SS "Why does Perl let me delete read-only files? Why does \f(CW\-i\fP clobber protected files? Isn't this a bug in Perl?"
.IX Subsection "Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?"
This is elaborately and painstakingly described in the
\&\fIfile-dir-perms\fR article in the \*(L"Far More Than You Ever Wanted To
Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> .
.PP
The executive summary: learn how your filesystem works. The
permissions on a file say what can happen to the data in that file.
The permissions on a directory say what can happen to the list of
files in that directory. If you delete a file, you're removing its
name from the directory (so the operation depends on the permissions
of the directory, not of the file). If you try to write to the file,
the permissions of the file govern whether you're allowed to.
.SS "How do I select a random line from a file?"
.IX Xref "file, selecting a random line"
.IX Subsection "How do I select a random line from a file?"
Short of loading the file into a database or pre-indexing the lines in
the file, there are a couple of things that you can do.
.PP
Here's a reservoir-sampling algorithm from the Camel Book:
.PP
.Vb 2
\&    srand;
\&    rand($.) < 1 && ($line = $_) while <>;
.Ve
.PP
This has a significant advantage in space over reading the whole file
in. You can find a proof of this method in \fIThe Art of Computer
Programming\fR, Volume 2, Section 3.4.2, by Donald E. Knuth.
.PP
You can use the File::Random module which provides a function
for that algorithm:
.PP
.Vb 2
\&    use File::Random qw/random_line/;
\&    my $line = random_line($filename);
.Ve
.PP
Another way is to use the Tie::File module, which treats the entire
file as an array. Simply access a random array element.
.SS "Why do I get weird spaces when I print an array of lines?"
.IX Subsection "Why do I get weird spaces when I print an array of lines?"
(contributed by brian d foy)
.PP
If you are seeing spaces between the elements of your array when
you print the array, you are probably interpolating the array in
double quotes:
.PP
.Vb 2
\&    my @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: @animals\en";
.Ve
.PP
It's the double quotes, not the \f(CW\*(C`print\*(C'\fR, doing this. Whenever you
interpolate an array in a double quote context, Perl joins the
elements with spaces (or whatever is in \f(CW$"\fR, which is a space by
default):
.PP
.Vb 1
\&    animals are: camel llama alpaca vicuna
.Ve
.PP
This is different than printing the array without the interpolation:
.PP
.Vb 2
\&    my @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: ", @animals, "\en";
.Ve
.PP
Now the output doesn't have the spaces between the elements because
the elements of \f(CW@animals\fR simply become part of the list to
\&\f(CW\*(C`print\*(C'\fR:
.PP
.Vb 1
\&    animals are: camelllamaalpacavicuna
.Ve
.PP
You might notice this when each of the elements of \f(CW@array\fR end with
a newline. You expect to print one element per line, but notice that
every line after the first is indented:
.PP
.Vb 3
\&    this is a line
\&     this is another line
\&     this is the third line
.Ve
.PP
That extra space comes from the interpolation of the array. If you
don't want to put anything between your array elements, don't use the
array in double quotes. You can send it to print without them:
.PP
.Vb 1
\&    print @lines;
.Ve
.SS "How do I traverse a directory tree?"
.IX Subsection "How do I traverse a directory tree?"
(contributed by brian d foy)
.PP
The File::Find module, which comes with Perl, does all of the hard
work to traverse a directory structure. It comes with Perl. You simply
call the \f(CW\*(C`find\*(C'\fR subroutine with a callback subroutine and the
directories you want to traverse:
.PP
.Vb 1
\&    use File::Find;
\&
\&    find( \e&wanted, @directories );
\&
\&    sub wanted {
\&        # full path in $File::Find::name
\&        # just filename in $_
\&        ... do whatever you want to do ...
\&    }
.Ve
.PP
The File::Find::Closures, which you can download from \s-1CPAN,\s0 provides
many ready-to-use subroutines that you can use with File::Find.
.PP
The File::Finder, which you can download from \s-1CPAN,\s0 can help you
create the callback subroutine using something closer to the syntax of
the \f(CW\*(C`find\*(C'\fR command-line utility:
.PP
.Vb 2
\&    use File::Find;
\&    use File::Finder;
\&
\&    my $deep_dirs = File::Finder\->depth\->type(\*(Aqd\*(Aq)\->ls\->exec(\*(Aqrmdir\*(Aq,\*(Aq{}\*(Aq);
\&
\&    find( $deep_dirs\->as_options, @places );
.Ve
.PP
The File::Find::Rule module, which you can download from \s-1CPAN,\s0 has
a similar interface, but does the traversal for you too:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    my @files = File::Find::Rule\->file()
\&                             \->name( \*(Aq*.pm\*(Aq )
\&                             \->in( @INC );
.Ve
.SS "How do I delete a directory tree?"
.IX Subsection "How do I delete a directory tree?"
(contributed by brian d foy)
.PP
If you have an empty directory, you can use Perl's built-in \f(CW\*(C`rmdir\*(C'\fR.
If the directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot of work) or use a module to
help you.
.PP
The File::Path module, which comes with Perl, has a \f(CW\*(C`remove_tree\*(C'\fR
which can take care of all of the hard work for you:
.PP
.Vb 1
\&    use File::Path qw(remove_tree);
\&
\&    remove_tree( @directories );
.Ve
.PP
The File::Path module also has a legacy interface to the older
\&\f(CW\*(C`rmtree\*(C'\fR subroutine.
.SS "How do I copy an entire directory?"
.IX Subsection "How do I copy an entire directory?"
(contributed by Shlomi Fish)
.PP
To do the equivalent of \f(CW\*(C`cp \-R\*(C'\fR (i.e. copy an entire directory tree
recursively) in portable Perl, you'll either need to write something yourself
or find a good \s-1CPAN\s0 module such as  File::Copy::Recursive.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq5.16.1                                0100644 0001750 0001750 00000070614 12566207416 022715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ 1"
.TH PERLFAQ 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq \- frequently asked questions about Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The perlfaq comprises several documents that answer the most commonly
asked questions about Perl and Perl programming. It's divided by topic
into nine major sections outlined in this document.
.SS "Where to find the perlfaq"
.IX Subsection "Where to find the perlfaq"
The perlfaq is an evolving document.  Read the latest version at
<http://learn.perl.org/faq/>.  It is also included in the standard Perl
distribution.
.SS "How to use the perlfaq"
.IX Subsection "How to use the perlfaq"
The \f(CW\*(C`perldoc\*(C'\fR command line tool is part of the standard Perl distribution. To
read the perlfaq:
.PP
.Vb 1
\&    $ perldoc perlfaq
.Ve
.PP
To search the perlfaq question headings:
.PP
.Vb 1
\&    $ perldoc \-q open
.Ve
.SS "How to contribute to the perlfaq"
.IX Subsection "How to contribute to the perlfaq"
Review https://github.com/perl\-doc\-cats/perlfaq/wiki <https://github.com/perl-doc-cats/perlfaq/wiki>.  If you don't find
your suggestion create an issue or pull request against
https://github.com/perl\-doc\-cats/perlfaq <https://github.com/perl-doc-cats/perlfaq>.
.PP
Once approved, changes are merged into <https://github.com/tpf/perlfaq>, the
repository which drives <http://learn.perl.org/faq/>, and they are
distributed with the next Perl 5 release.
.SS "What if my question isn't answered in the \s-1FAQ\s0?"
.IX Subsection "What if my question isn't answered in the FAQ?"
Try the resources in perlfaq2.
.SH "TABLE OF CONTENTS"
.IX Header "TABLE OF CONTENTS"
.IP "perlfaq1 \- General Questions About Perl" 4
.IX Item "perlfaq1 - General Questions About Perl"
.PD 0
.IP "perlfaq2 \- Obtaining and Learning about Perl" 4
.IX Item "perlfaq2 - Obtaining and Learning about Perl"
.IP "perlfaq3 \- Programming Tools" 4
.IX Item "perlfaq3 - Programming Tools"
.IP "perlfaq4 \- Data Manipulation" 4
.IX Item "perlfaq4 - Data Manipulation"
.IP "perlfaq5 \- Files and Formats" 4
.IX Item "perlfaq5 - Files and Formats"
.IP "perlfaq6 \- Regular Expressions" 4
.IX Item "perlfaq6 - Regular Expressions"
.IP "perlfaq7 \- General Perl Language Issues" 4
.IX Item "perlfaq7 - General Perl Language Issues"
.IP "perlfaq8 \- System Interaction" 4
.IX Item "perlfaq8 - System Interaction"
.IP "perlfaq9 \- Web, Email and Networking" 4
.IX Item "perlfaq9 - Web, Email and Networking"
.PD
.SH "THE QUESTIONS"
.IX Header "THE QUESTIONS"
.SS "perlfaq1: General Questions About Perl"
.IX Subsection "perlfaq1: General Questions About Perl"
This section of the \s-1FAQ\s0 answers very general, high-level questions about Perl.
.IP "\(bu" 4
What is Perl?
.IP "\(bu" 4
Who supports Perl? Who develops it? Why is it free?
.IP "\(bu" 4
Which version of Perl should I use?
.IP "\(bu" 4
What are Perl 4, Perl 5, or Perl 6?
.IP "\(bu" 4
What is Perl 6?
.IP "\(bu" 4
How stable is Perl?
.IP "\(bu" 4
Is Perl difficult to learn?
.IP "\(bu" 4
How does Perl compare with other languages like Java, Python, \s-1REXX\s0, Scheme, or Tcl?
.IP "\(bu" 4
Can I do [task] in Perl?
.IP "\(bu" 4
When shouldn't I program in Perl?
.IP "\(bu" 4
What's the difference between \*(L"perl\*(R" and \*(L"Perl\*(R"?
.IP "\(bu" 4
What is a \s-1JAPH\s0?
.IP "\(bu" 4
How can I convince others to use Perl?
.SS "perlfaq2: Obtaining and Learning about Perl"
.IX Subsection "perlfaq2: Obtaining and Learning about Perl"
This section of the \s-1FAQ\s0 answers questions about where to find source and documentation for Perl, support, and related matters.
.IP "\(bu" 4
What machines support Perl? Where do I get it?
.IP "\(bu" 4
How can I get a binary version of Perl?
.IP "\(bu" 4
I don't have a C compiler. How can I build my own Perl interpreter?
.IP "\(bu" 4
I copied the Perl binary from one machine to another, but scripts don't work.
.IP "\(bu" 4
I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?
.IP "\(bu" 4
What modules and extensions are available for Perl? What is \s-1CPAN\s0?
.IP "\(bu" 4
Where can I get information on Perl?
.IP "\(bu" 4
What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?
.IP "\(bu" 4
Where can I post questions?
.IP "\(bu" 4
Perl Books
.IP "\(bu" 4
Which magazines have Perl content?
.IP "\(bu" 4
Which Perl blogs should I read?
.IP "\(bu" 4
What mailing lists are there for Perl?
.IP "\(bu" 4
Where can I buy a commercial version of Perl?
.IP "\(bu" 4
Where do I send bug reports?
.SS "perlfaq3: Programming Tools"
.IX Subsection "perlfaq3: Programming Tools"
This section of the \s-1FAQ\s0 answers questions related to programmer tools and programming support.
.IP "\(bu" 4
How do I do (anything)?
.IP "\(bu" 4
How can I use Perl interactively?
.IP "\(bu" 4
How do I find which modules are installed on my system?
.IP "\(bu" 4
How do I debug my Perl programs?
.IP "\(bu" 4
How do I profile my Perl programs?
.IP "\(bu" 4
How do I cross-reference my Perl programs?
.IP "\(bu" 4
Is there a pretty-printer (formatter) for Perl?
.IP "\(bu" 4
Is there an \s-1IDE\s0 or Windows Perl Editor?
.IP "\(bu" 4
Where can I get Perl macros for vi?
.IP "\(bu" 4
Where can I get perl-mode or cperl-mode for emacs?
.IP "\(bu" 4
How can I use curses with Perl?
.IP "\(bu" 4
How can I write a \s-1GUI\s0 (X, Tk, Gtk, etc.) in Perl?
.IP "\(bu" 4
How can I make my Perl program run faster?
.IP "\(bu" 4
How can I make my Perl program take less memory?
.IP "\(bu" 4
Is it safe to return a reference to local or lexical data?
.IP "\(bu" 4
How can I free an array or hash so my program shrinks?
.IP "\(bu" 4
How can I make my \s-1CGI\s0 script more efficient?
.IP "\(bu" 4
How can I hide the source for my Perl program?
.IP "\(bu" 4
How can I compile my Perl program into byte code or C?
.IP "\(bu" 4
How can I get \f(CW\*(C`#!perl\*(C'\fR to work on [\s-1MS\-DOS\s0,NT,...]?
.IP "\(bu" 4
Can I write useful Perl programs on the command line?
.IP "\(bu" 4
Why don't Perl one-liners work on my DOS/Mac/VMS system?
.IP "\(bu" 4
Where can I learn about \s-1CGI\s0 or Web programming in Perl?
.IP "\(bu" 4
Where can I learn about object-oriented Perl programming?
.IP "\(bu" 4
Where can I learn about linking C with Perl?
.IP "\(bu" 4
I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?
.IP "\(bu" 4
When I tried to run my script, I got this message. What does it mean?
.IP "\(bu" 4
What's MakeMaker?
.SS "perlfaq4: Data Manipulation"
.IX Subsection "perlfaq4: Data Manipulation"
This section of the \s-1FAQ\s0 answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
.IP "\(bu" 4
Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?
.IP "\(bu" 4
Why is \fIint()\fR broken?
.IP "\(bu" 4
Why isn't my octal data interpreted correctly?
.IP "\(bu" 4
Does Perl have a \fIround()\fR function? What about \fIceil()\fR and \fIfloor()\fR? Trig functions?
.IP "\(bu" 4
How do I convert between numeric representations/bases/radixes?
.IP "\(bu" 4
Why doesn't & work the way I want it to?
.IP "\(bu" 4
How do I multiply matrices?
.IP "\(bu" 4
How do I perform an operation on a series of integers?
.IP "\(bu" 4
How can I output Roman numerals?
.IP "\(bu" 4
Why aren't my random numbers random?
.IP "\(bu" 4
How do I get a random number between X and Y?
.IP "\(bu" 4
How do I find the day or week of the year?
.IP "\(bu" 4
How do I find the current century or millennium?
.IP "\(bu" 4
How can I compare two dates and find the difference?
.IP "\(bu" 4
How can I take a string and turn it into epoch seconds?
.IP "\(bu" 4
How can I find the Julian Day?
.IP "\(bu" 4
How do I find yesterday's date?
.IP "\(bu" 4
Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?
.IP "\(bu" 4
How do I validate input?
.IP "\(bu" 4
How do I unescape a string?
.IP "\(bu" 4
How do I remove consecutive pairs of characters?
.IP "\(bu" 4
How do I expand function calls in a string?
.IP "\(bu" 4
How do I find matching/nesting anything?
.IP "\(bu" 4
How do I reverse a string?
.IP "\(bu" 4
How do I expand tabs in a string?
.IP "\(bu" 4
How do I reformat a paragraph?
.IP "\(bu" 4
How can I access or change N characters of a string?
.IP "\(bu" 4
How do I change the Nth occurrence of something?
.IP "\(bu" 4
How can I count the number of occurrences of a substring within a string?
.IP "\(bu" 4
How do I capitalize all the words on one line?
.IP "\(bu" 4
How can I split a [character]\-delimited string except when inside [character]?
.IP "\(bu" 4
How do I strip blank space from the beginning/end of a string?
.IP "\(bu" 4
How do I pad a string with blanks or pad a number with zeroes?
.IP "\(bu" 4
How do I extract selected columns from a string?
.IP "\(bu" 4
How do I find the soundex value of a string?
.IP "\(bu" 4
How can I expand variables in text strings?
.IP "\(bu" 4
What's wrong with always quoting \*(L"$vars\*(R"?
.IP "\(bu" 4
Why don't my <<\s-1HERE\s0 documents work?
.IP "\(bu" 4
What is the difference between a list and an array?
.IP "\(bu" 4
What is the difference between \f(CW$array\fR[1] and \f(CW@array\fR[1]?
.IP "\(bu" 4
How can I remove duplicate elements from a list or array?
.IP "\(bu" 4
How can I tell whether a certain element is contained in a list or array?
.IP "\(bu" 4
How do I compute the difference of two arrays? How do I compute the intersection of two arrays?
.IP "\(bu" 4
How do I test whether two arrays or hashes are equal?
.IP "\(bu" 4
How do I find the first array element for which a condition is true?
.IP "\(bu" 4
How do I handle linked lists?
.IP "\(bu" 4
How do I handle circular lists?
.IP "\(bu" 4
How do I shuffle an array randomly?
.IP "\(bu" 4
How do I process/modify each element of an array?
.IP "\(bu" 4
How do I select a random element from an array?
.IP "\(bu" 4
How do I permute N elements of a list?
.IP "\(bu" 4
How do I sort an array by (anything)?
.IP "\(bu" 4
How do I manipulate arrays of bits?
.IP "\(bu" 4
Why does \fIdefined()\fR return true on empty arrays and hashes?
.IP "\(bu" 4
How do I process an entire hash?
.IP "\(bu" 4
How do I merge two hashes?
.IP "\(bu" 4
What happens if I add or remove keys from a hash while iterating over it?
.IP "\(bu" 4
How do I look up a hash element by value?
.IP "\(bu" 4
How can I know how many entries are in a hash?
.IP "\(bu" 4
How do I sort a hash (optionally by value instead of key)?
.IP "\(bu" 4
How can I always keep my hash sorted?
.IP "\(bu" 4
What's the difference between \*(L"delete\*(R" and \*(L"undef\*(R" with hashes?
.IP "\(bu" 4
Why don't my tied hashes make the defined/exists distinction?
.IP "\(bu" 4
How do I reset an \fIeach()\fR operation part-way through?
.IP "\(bu" 4
How can I get the unique keys from two hashes?
.IP "\(bu" 4
How can I store a multidimensional array in a \s-1DBM\s0 file?
.IP "\(bu" 4
How can I make my hash remember the order I put elements into it?
.IP "\(bu" 4
Why does passing a subroutine an undefined element in a hash create it?
.IP "\(bu" 4
How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?
.IP "\(bu" 4
How can I use a reference as a hash key?
.IP "\(bu" 4
How can I check if a key exists in a multilevel hash?
.IP "\(bu" 4
How can I prevent addition of unwanted keys into a hash?
.IP "\(bu" 4
How do I handle binary data correctly?
.IP "\(bu" 4
How do I determine whether a scalar is a number/whole/integer/float?
.IP "\(bu" 4
How do I keep persistent data across program calls?
.IP "\(bu" 4
How do I print out or copy a recursive data structure?
.IP "\(bu" 4
How do I define methods for every class/object?
.IP "\(bu" 4
How do I verify a credit card checksum?
.IP "\(bu" 4
How do I pack arrays of doubles or floats for \s-1XS\s0 code?
.SS "perlfaq5: Files and Formats"
.IX Subsection "perlfaq5: Files and Formats"
This section deals with I/O and the \*(L"f\*(R" issues: filehandles, flushing, formats, and footers.
.IP "\(bu" 4
How do I flush/unbuffer an output filehandle? Why must I do this?
.IP "\(bu" 4
How do I change, delete, or insert a line in a file, or append to the beginning of a file?
.IP "\(bu" 4
How do I count the number of lines in a file?
.IP "\(bu" 4
How do I delete the last N lines from a file?
.IP "\(bu" 4
How can I use Perl's \f(CW\*(C`\-i\*(C'\fR option from within a program?
.IP "\(bu" 4
How can I copy a file?
.IP "\(bu" 4
How do I make a temporary file name?
.IP "\(bu" 4
How can I manipulate fixed-record-length files?
.IP "\(bu" 4
How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?
.IP "\(bu" 4
How can I use a filehandle indirectly?
.IP "\(bu" 4
How can I set up a footer format to be used with \fIwrite()\fR?
.IP "\(bu" 4
How can I \fIwrite()\fR into a string?
.IP "\(bu" 4
How can I open a filehandle to a string?
.IP "\(bu" 4
How can I output my numbers with commas added?
.IP "\(bu" 4
How can I translate tildes (~) in a filename?
.IP "\(bu" 4
How come when I open a file read-write it wipes it out?
.IP "\(bu" 4
Why do I sometimes get an \*(L"Argument list too long\*(R" when I use <*>?
.IP "\(bu" 4
How can I open a file with a leading \*(L">\*(R" or trailing blanks?
.IP "\(bu" 4
How can I reliably rename a file?
.IP "\(bu" 4
How can I lock a file?
.IP "\(bu" 4
Why can't I just open(\s-1FH\s0, \*(L">file.lock\*(R")?
.IP "\(bu" 4
I still don't get locking. I just want to increment the number in the file. How can I do this?
.IP "\(bu" 4
All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?
.IP "\(bu" 4
How do I randomly update a binary file?
.IP "\(bu" 4
How do I get a file's timestamp in perl?
.IP "\(bu" 4
How do I set a file's timestamp in perl?
.IP "\(bu" 4
How do I print to more than one file at once?
.IP "\(bu" 4
How can I read in an entire file all at once?
.IP "\(bu" 4
How can I read in a file by paragraphs?
.IP "\(bu" 4
How can I read a single character from a file? From the keyboard?
.IP "\(bu" 4
How can I tell whether there's a character waiting on a filehandle?
.IP "\(bu" 4
How do I do a \f(CW\*(C`tail \-f\*(C'\fR in perl?
.IP "\(bu" 4
How do I \fIdup()\fR a filehandle in Perl?
.IP "\(bu" 4
How do I close a file descriptor by number?
.IP "\(bu" 4
Why can't I use \*(L"C:\etemp\efoo\*(R" in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?
.IP "\(bu" 4
Why doesn't glob(\*(L"*.*\*(R") get all the files?
.IP "\(bu" 4
Why does Perl let me delete read-only files? Why does \f(CW\*(C`\-i\*(C'\fR clobber protected files? Isn't this a bug in Perl?
.IP "\(bu" 4
How do I select a random line from a file?
.IP "\(bu" 4
Why do I get weird spaces when I print an array of lines?
.IP "\(bu" 4
How do I traverse a directory tree?
.IP "\(bu" 4
How do I delete a directory tree?
.IP "\(bu" 4
How do I copy an entire directory?
.SS "perlfaq6: Regular Expressions"
.IX Subsection "perlfaq6: Regular Expressions"
This section is surprisingly small because the rest of the \s-1FAQ\s0 is littered with answers involving regular expressions. For example, decoding a \s-1URL\s0 and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : \*(L"How do I decode or create those %\-encodings on the web\*(R" and perlfaq4 : \*(L"How do I determine whether a scalar is a number/whole/integer/float\*(R", to be precise).
.IP "\(bu" 4
How can I hope to use regular expressions without creating illegible and unmaintainable code?
.IP "\(bu" 4
I'm having trouble matching over more than one line. What's wrong?
.IP "\(bu" 4
How can I pull out lines between two patterns that are themselves on different lines?
.IP "\(bu" 4
How do I match \s-1XML\s0, \s-1HTML\s0, or other nasty, ugly things with a regex?
.IP "\(bu" 4
I put a regular expression into $/ but it didn't work. What's wrong?
.IP "\(bu" 4
How do I substitute case-insensitively on the \s-1LHS\s0 while preserving case on the \s-1RHS\s0?
.IP "\(bu" 4
How can I make \f(CW\*(C`\ew\*(C'\fR match national character sets?
.IP "\(bu" 4
How can I match a locale-smart version of \f(CW\*(C`/[a\-zA\-Z]/\*(C'\fR ?
.IP "\(bu" 4
How can I quote a variable to use in a regex?
.IP "\(bu" 4
What is \f(CW\*(C`/o\*(C'\fR really for?
.IP "\(bu" 4
How do I use a regular expression to strip C\-style comments from a file?
.IP "\(bu" 4
Can I use Perl regular expressions to match balanced text?
.IP "\(bu" 4
What does it mean that regexes are greedy? How can I get around it?
.IP "\(bu" 4
How do I process each word on each line?
.IP "\(bu" 4
How can I print out a word-frequency or line-frequency summary?
.IP "\(bu" 4
How can I do approximate matching?
.IP "\(bu" 4
How do I efficiently match many regular expressions at once?
.IP "\(bu" 4
Why don't word-boundary searches with \f(CW\*(C`\eb\*(C'\fR work for me?
.IP "\(bu" 4
Why does using $&, $`, or $' slow my program down?
.IP "\(bu" 4
What good is \f(CW\*(C`\eG\*(C'\fR in a regular expression?
.IP "\(bu" 4
Are Perl regexes DFAs or NFAs? Are they \s-1POSIX\s0 compliant?
.IP "\(bu" 4
What's wrong with using grep in a void context?
.IP "\(bu" 4
How can I match strings with multibyte characters?
.IP "\(bu" 4
How do I match a regular expression that's in a variable?
.SS "perlfaq7: General Perl Language Issues"
.IX Subsection "perlfaq7: General Perl Language Issues"
This section deals with general Perl language issues that don't clearly fit into any of the other sections.
.IP "\(bu" 4
Can I get a BNF/yacc/RE for the Perl language?
.IP "\(bu" 4
What are all these $@%&* punctuation signs, and how do I know when to use them?
.IP "\(bu" 4
Do I always/never have to quote my strings or use semicolons and commas?
.IP "\(bu" 4
How do I skip some return values?
.IP "\(bu" 4
How do I temporarily block warnings?
.IP "\(bu" 4
What's an extension?
.IP "\(bu" 4
Why do Perl operators have different precedence than C operators?
.IP "\(bu" 4
How do I declare/create a structure?
.IP "\(bu" 4
How do I create a module?
.IP "\(bu" 4
How do I adopt or take over a module already on \s-1CPAN\s0?
.IP "\(bu" 4
How do I create a class?
.IP "\(bu" 4
How can I tell if a variable is tainted?
.IP "\(bu" 4
What's a closure?
.IP "\(bu" 4
What is variable suicide and how can I prevent it?
.IP "\(bu" 4
How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?
.IP "\(bu" 4
How do I create a static variable?
.IP "\(bu" 4
What's the difference between dynamic and lexical (static) scoping? Between \fIlocal()\fR and \fImy()\fR?
.IP "\(bu" 4
How can I access a dynamic variable while a similarly named lexical is in scope?
.IP "\(bu" 4
What's the difference between deep and shallow binding?
.IP "\(bu" 4
Why doesn't \*(L"my($foo) = <$fh>;\*(R" work right?
.IP "\(bu" 4
How do I redefine a builtin function, operator, or method?
.IP "\(bu" 4
What's the difference between calling a function as &foo and \fIfoo()\fR?
.IP "\(bu" 4
How do I create a switch or case statement?
.IP "\(bu" 4
How can I catch accesses to undefined variables, functions, or methods?
.IP "\(bu" 4
Why can't a method included in this same file be found?
.IP "\(bu" 4
How can I find out my current or calling package?
.IP "\(bu" 4
How can I comment out a large block of Perl code?
.IP "\(bu" 4
How do I clear a package?
.IP "\(bu" 4
How can I use a variable as a variable name?
.IP "\(bu" 4
What does \*(L"bad interpreter\*(R" mean?
.SS "perlfaq8: System Interaction"
.IX Subsection "perlfaq8: System Interaction"
This section of the Perl \s-1FAQ\s0 covers questions involving operating system interaction. Topics include interprocess communication (\s-1IPC\s0), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.
.IP "\(bu" 4
How do I find out which operating system I'm running under?
.IP "\(bu" 4
How come \fIexec()\fR doesn't return?
.IP "\(bu" 4
How do I do fancy stuff with the keyboard/screen/mouse?
.IP "\(bu" 4
How do I print something out in color?
.IP "\(bu" 4
How do I read just one key without waiting for a return key?
.IP "\(bu" 4
How do I check whether input is ready on the keyboard?
.IP "\(bu" 4
How do I clear the screen?
.IP "\(bu" 4
How do I get the screen size?
.IP "\(bu" 4
How do I ask the user for a password?
.IP "\(bu" 4
How do I read and write the serial port?
.IP "\(bu" 4
How do I decode encrypted password files?
.IP "\(bu" 4
How do I start a process in the background?
.IP "\(bu" 4
How do I trap control characters/signals?
.IP "\(bu" 4
How do I modify the shadow password file on a Unix system?
.IP "\(bu" 4
How do I set the time and date?
.IP "\(bu" 4
How can I \fIsleep()\fR or \fIalarm()\fR for under a second?
.IP "\(bu" 4
How can I measure time under a second?
.IP "\(bu" 4
How can I do an \fIatexit()\fR or \fIsetjmp()\fR/\fIlongjmp()\fR? (Exception handling)
.IP "\(bu" 4
Why doesn't my sockets program work under System V (Solaris)? What does the error message \*(L"Protocol not supported\*(R" mean?
.IP "\(bu" 4
How can I call my system's unique C functions from Perl?
.IP "\(bu" 4
Where do I get the include files to do \fIioctl()\fR or \fIsyscall()\fR?
.IP "\(bu" 4
Why do setuid perl scripts complain about kernel problems?
.IP "\(bu" 4
How can I open a pipe both to and from a command?
.IP "\(bu" 4
Why can't I get the output of a command with \fIsystem()\fR?
.IP "\(bu" 4
How can I capture \s-1STDERR\s0 from an external command?
.IP "\(bu" 4
Why doesn't \fIopen()\fR return an error when a pipe open fails?
.IP "\(bu" 4
What's wrong with using backticks in a void context?
.IP "\(bu" 4
How can I call backticks without shell processing?
.IP "\(bu" 4
Why can't my script read from \s-1STDIN\s0 after I gave it \s-1EOF\s0 (^D on Unix, ^Z on MS-DOS)?
.IP "\(bu" 4
How can I convert my shell script to perl?
.IP "\(bu" 4
Can I use perl to run a telnet or ftp session?
.IP "\(bu" 4
How can I write expect in Perl?
.IP "\(bu" 4
Is there a way to hide perl's command line from programs such as \*(L"ps\*(R"?
.IP "\(bu" 4
I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?
.IP "\(bu" 4
How do I close a process's filehandle without waiting for it to complete?
.IP "\(bu" 4
How do I fork a daemon process?
.IP "\(bu" 4
How do I find out if I'm running interactively or not?
.IP "\(bu" 4
How do I timeout a slow event?
.IP "\(bu" 4
How do I set \s-1CPU\s0 limits?
.IP "\(bu" 4
How do I avoid zombies on a Unix system?
.IP "\(bu" 4
How do I use an \s-1SQL\s0 database?
.IP "\(bu" 4
How do I make a \fIsystem()\fR exit on control-C?
.IP "\(bu" 4
How do I open a file without blocking?
.IP "\(bu" 4
How do I tell the difference between errors from the shell and perl?
.IP "\(bu" 4
How do I install a module from \s-1CPAN\s0?
.IP "\(bu" 4
What's the difference between require and use?
.IP "\(bu" 4
How do I keep my own module/library directory?
.IP "\(bu" 4
How do I add the directory my program lives in to the module/library search path?
.IP "\(bu" 4
How do I add a directory to my include path (@INC) at runtime?
.IP "\(bu" 4
What is socket.ph and where do I get it?
.SS "perlfaq9: Web, Email and Networking"
.IX Subsection "perlfaq9: Web, Email and Networking"
This section deals with questions related to running web sites, sending and receiving email as well as general networking.
.IP "\(bu" 4
Should I use a web framework?
.IP "\(bu" 4
Which web framework should I use?
.IP "\(bu" 4
What is Plack and \s-1PSGI\s0?
.IP "\(bu" 4
How do I remove \s-1HTML\s0 from a string?
.IP "\(bu" 4
How do I extract URLs?
.IP "\(bu" 4
How do I fetch an \s-1HTML\s0 file?
.IP "\(bu" 4
How do I automate an \s-1HTML\s0 form submission?
.IP "\(bu" 4
How do I decode or create those %\-encodings on the web?
.IP "\(bu" 4
How do I redirect to another page?
.IP "\(bu" 4
How do I put a password on my web pages?
.IP "\(bu" 4
How do I make sure users can't enter values into a form that causes my \s-1CGI\s0 script to do bad things?
.IP "\(bu" 4
How do I parse a mail header?
.IP "\(bu" 4
How do I check a valid mail address?
.IP "\(bu" 4
How do I decode a \s-1MIME/BASE64\s0 string?
.IP "\(bu" 4
How do I find the user's mail address?
.IP "\(bu" 4
How do I send email?
.IP "\(bu" 4
How do I use \s-1MIME\s0 to make an attachment to a mail message?
.IP "\(bu" 4
How do I read email?
.IP "\(bu" 4
How do I find out my hostname, domainname, or \s-1IP\s0 address?
.IP "\(bu" 4
How do I fetch/put an (S)FTP file?
.IP "\(bu" 4
How can I do \s-1RPC\s0 in Perl?
.SH "CREDITS"
.IX Header "CREDITS"
Tom Christiansen wrote the original perlfaq then expanded it with the
help of Nat Torkington. brian d foy substantialy edited and expanded
the perlfaq. perlfaq-workers and others have also supplied feedback,
patches and corrections over the years.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Tom Christiansen wrote the original version of this document.
brian d foy \f(CW\*(C`<bdfoy@cpan.org>\*(C'\fR wrote this version. See the
individual perlfaq documents for additional copyright information.
.PP
This document is available under the same terms as Perl itself. Code
examples in all the perlfaq documents are in the public domain. Use
them as you see fit (and at your own risk with no warranty from anyone).
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq5.18.1                                0100644 0001750 0001750 00000070777 12566207436 022733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ 1"
.TH PERLFAQ 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq \- frequently asked questions about Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The perlfaq comprises several documents that answer the most commonly
asked questions about Perl and Perl programming. It's divided by topic
into nine major sections outlined in this document.
.SS "Where to find the perlfaq"
.IX Subsection "Where to find the perlfaq"
The perlfaq is an evolving document.  Read the latest version at
<http://learn.perl.org/faq/>.  It is also included in the standard Perl
distribution.
.SS "How to use the perlfaq"
.IX Subsection "How to use the perlfaq"
The \f(CW\*(C`perldoc\*(C'\fR command line tool is part of the standard Perl distribution. To
read the perlfaq:
.PP
.Vb 1
\&    $ perldoc perlfaq
.Ve
.PP
To search the perlfaq question headings:
.PP
.Vb 1
\&    $ perldoc \-q open
.Ve
.SS "How to contribute to the perlfaq"
.IX Subsection "How to contribute to the perlfaq"
Review <https://github.com/perl\-doc\-cats/perlfaq/wiki>.  If you don't find
your suggestion create an issue or pull request against
<https://github.com/perl\-doc\-cats/perlfaq>.
.PP
Once approved, changes are merged into <https://github.com/tpf/perlfaq>, the
repository which drives <http://learn.perl.org/faq/>, and they are
distributed with the next Perl 5 release.
.SS "What if my question isn't answered in the \s-1FAQ\s0?"
.IX Subsection "What if my question isn't answered in the FAQ?"
Try the resources in perlfaq2.
.SH "TABLE OF CONTENTS"
.IX Header "TABLE OF CONTENTS"
.IP "perlfaq1 \- General Questions About Perl" 4
.IX Item "perlfaq1 - General Questions About Perl"
.PD 0
.IP "perlfaq2 \- Obtaining and Learning about Perl" 4
.IX Item "perlfaq2 - Obtaining and Learning about Perl"
.IP "perlfaq3 \- Programming Tools" 4
.IX Item "perlfaq3 - Programming Tools"
.IP "perlfaq4 \- Data Manipulation" 4
.IX Item "perlfaq4 - Data Manipulation"
.IP "perlfaq5 \- Files and Formats" 4
.IX Item "perlfaq5 - Files and Formats"
.IP "perlfaq6 \- Regular Expressions" 4
.IX Item "perlfaq6 - Regular Expressions"
.IP "perlfaq7 \- General Perl Language Issues" 4
.IX Item "perlfaq7 - General Perl Language Issues"
.IP "perlfaq8 \- System Interaction" 4
.IX Item "perlfaq8 - System Interaction"
.IP "perlfaq9 \- Web, Email and Networking" 4
.IX Item "perlfaq9 - Web, Email and Networking"
.PD
.SH "THE QUESTIONS"
.IX Header "THE QUESTIONS"
.SS "perlfaq1: General Questions About Perl"
.IX Subsection "perlfaq1: General Questions About Perl"
This section of the \s-1FAQ\s0 answers very general, high-level questions about Perl.
.IP "\(bu" 4
What is Perl?
.IP "\(bu" 4
Who supports Perl? Who develops it? Why is it free?
.IP "\(bu" 4
Which version of Perl should I use?
.IP "\(bu" 4
What are Perl 4, Perl 5, or Perl 6?
.IP "\(bu" 4
What is Perl 6?
.IP "\(bu" 4
How stable is Perl?
.IP "\(bu" 4
Is Perl difficult to learn?
.IP "\(bu" 4
How does Perl compare with other languages like Java, Python, \s-1REXX,\s0 Scheme, or Tcl?
.IP "\(bu" 4
Can I do [task] in Perl?
.IP "\(bu" 4
When shouldn't I program in Perl?
.IP "\(bu" 4
What's the difference between \*(L"perl\*(R" and \*(L"Perl\*(R"?
.IP "\(bu" 4
What is a \s-1JAPH\s0?
.IP "\(bu" 4
How can I convince others to use Perl?
.SS "perlfaq2: Obtaining and Learning about Perl"
.IX Subsection "perlfaq2: Obtaining and Learning about Perl"
This section of the \s-1FAQ\s0 answers questions about where to find source and documentation for Perl, support, and related matters.
.IP "\(bu" 4
What machines support Perl? Where do I get it?
.IP "\(bu" 4
How can I get a binary version of Perl?
.IP "\(bu" 4
I don't have a C compiler. How can I build my own Perl interpreter?
.IP "\(bu" 4
I copied the Perl binary from one machine to another, but scripts don't work.
.IP "\(bu" 4
I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?
.IP "\(bu" 4
What modules and extensions are available for Perl? What is \s-1CPAN\s0?
.IP "\(bu" 4
Where can I get information on Perl?
.IP "\(bu" 4
What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?
.IP "\(bu" 4
Where can I post questions?
.IP "\(bu" 4
Perl Books
.IP "\(bu" 4
Which magazines have Perl content?
.IP "\(bu" 4
Which Perl blogs should I read?
.IP "\(bu" 4
What mailing lists are there for Perl?
.IP "\(bu" 4
Where can I buy a commercial version of Perl?
.IP "\(bu" 4
Where do I send bug reports?
.SS "perlfaq3: Programming Tools"
.IX Subsection "perlfaq3: Programming Tools"
This section of the \s-1FAQ\s0 answers questions related to programmer tools and programming support.
.IP "\(bu" 4
How do I do (anything)?
.IP "\(bu" 4
How can I use Perl interactively?
.IP "\(bu" 4
How do I find which modules are installed on my system?
.IP "\(bu" 4
How do I debug my Perl programs?
.IP "\(bu" 4
How do I profile my Perl programs?
.IP "\(bu" 4
How do I cross-reference my Perl programs?
.IP "\(bu" 4
Is there a pretty-printer (formatter) for Perl?
.IP "\(bu" 4
Is there an \s-1IDE\s0 or Windows Perl Editor?
.IP "\(bu" 4
Where can I get Perl macros for vi?
.IP "\(bu" 4
Where can I get perl-mode or cperl-mode for emacs?
.IP "\(bu" 4
How can I use curses with Perl?
.IP "\(bu" 4
How can I write a \s-1GUI \s0(X, Tk, Gtk, etc.) in Perl?
.IP "\(bu" 4
How can I make my Perl program run faster?
.IP "\(bu" 4
How can I make my Perl program take less memory?
.IP "\(bu" 4
Is it safe to return a reference to local or lexical data?
.IP "\(bu" 4
How can I free an array or hash so my program shrinks?
.IP "\(bu" 4
How can I make my \s-1CGI\s0 script more efficient?
.IP "\(bu" 4
How can I hide the source for my Perl program?
.IP "\(bu" 4
How can I compile my Perl program into byte code or C?
.IP "\(bu" 4
How can I get \f(CW\*(C`#!perl\*(C'\fR to work on [\s-1MS\-DOS,NT,...\s0]?
.IP "\(bu" 4
Can I write useful Perl programs on the command line?
.IP "\(bu" 4
Why don't Perl one-liners work on my DOS/Mac/VMS system?
.IP "\(bu" 4
Where can I learn about \s-1CGI\s0 or Web programming in Perl?
.IP "\(bu" 4
Where can I learn about object-oriented Perl programming?
.IP "\(bu" 4
Where can I learn about linking C with Perl?
.IP "\(bu" 4
I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?
.IP "\(bu" 4
When I tried to run my script, I got this message. What does it mean?
.IP "\(bu" 4
What's MakeMaker?
.SS "perlfaq4: Data Manipulation"
.IX Subsection "perlfaq4: Data Manipulation"
This section of the \s-1FAQ\s0 answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
.IP "\(bu" 4
Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?
.IP "\(bu" 4
Why is \fIint()\fR broken?
.IP "\(bu" 4
Why isn't my octal data interpreted correctly?
.IP "\(bu" 4
Does Perl have a \fIround()\fR function? What about \fIceil()\fR and \fIfloor()\fR? Trig functions?
.IP "\(bu" 4
How do I convert between numeric representations/bases/radixes?
.IP "\(bu" 4
Why doesn't & work the way I want it to?
.IP "\(bu" 4
How do I multiply matrices?
.IP "\(bu" 4
How do I perform an operation on a series of integers?
.IP "\(bu" 4
How can I output Roman numerals?
.IP "\(bu" 4
Why aren't my random numbers random?
.IP "\(bu" 4
How do I get a random number between X and Y?
.IP "\(bu" 4
How do I find the day or week of the year?
.IP "\(bu" 4
How do I find the current century or millennium?
.IP "\(bu" 4
How can I compare two dates and find the difference?
.IP "\(bu" 4
How can I take a string and turn it into epoch seconds?
.IP "\(bu" 4
How can I find the Julian Day?
.IP "\(bu" 4
How do I find yesterday's date?
.IP "\(bu" 4
Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?
.IP "\(bu" 4
How do I validate input?
.IP "\(bu" 4
How do I unescape a string?
.IP "\(bu" 4
How do I remove consecutive pairs of characters?
.IP "\(bu" 4
How do I expand function calls in a string?
.IP "\(bu" 4
How do I find matching/nesting anything?
.IP "\(bu" 4
How do I reverse a string?
.IP "\(bu" 4
How do I expand tabs in a string?
.IP "\(bu" 4
How do I reformat a paragraph?
.IP "\(bu" 4
How can I access or change N characters of a string?
.IP "\(bu" 4
How do I change the Nth occurrence of something?
.IP "\(bu" 4
How can I count the number of occurrences of a substring within a string?
.IP "\(bu" 4
How do I capitalize all the words on one line?
.IP "\(bu" 4
How can I split a [character]\-delimited string except when inside [character]?
.IP "\(bu" 4
How do I strip blank space from the beginning/end of a string?
.IP "\(bu" 4
How do I pad a string with blanks or pad a number with zeroes?
.IP "\(bu" 4
How do I extract selected columns from a string?
.IP "\(bu" 4
How do I find the soundex value of a string?
.IP "\(bu" 4
How can I expand variables in text strings?
.IP "\(bu" 4
What's wrong with always quoting \*(L"$vars\*(R"?
.IP "\(bu" 4
Why don't my <<\s-1HERE\s0 documents work?
.IP "\(bu" 4
What is the difference between a list and an array?
.IP "\(bu" 4
What is the difference between \f(CW$array\fR[1] and \f(CW@array\fR[1]?
.IP "\(bu" 4
How can I remove duplicate elements from a list or array?
.IP "\(bu" 4
How can I tell whether a certain element is contained in a list or array?
.IP "\(bu" 4
How do I compute the difference of two arrays? How do I compute the intersection of two arrays?
.IP "\(bu" 4
How do I test whether two arrays or hashes are equal?
.IP "\(bu" 4
How do I find the first array element for which a condition is true?
.IP "\(bu" 4
How do I handle linked lists?
.IP "\(bu" 4
How do I handle circular lists?
.IP "\(bu" 4
How do I shuffle an array randomly?
.IP "\(bu" 4
How do I process/modify each element of an array?
.IP "\(bu" 4
How do I select a random element from an array?
.IP "\(bu" 4
How do I permute N elements of a list?
.IP "\(bu" 4
How do I sort an array by (anything)?
.IP "\(bu" 4
How do I manipulate arrays of bits?
.IP "\(bu" 4
Why does \fIdefined()\fR return true on empty arrays and hashes?
.IP "\(bu" 4
How do I process an entire hash?
.IP "\(bu" 4
How do I merge two hashes?
.IP "\(bu" 4
What happens if I add or remove keys from a hash while iterating over it?
.IP "\(bu" 4
How do I look up a hash element by value?
.IP "\(bu" 4
How can I know how many entries are in a hash?
.IP "\(bu" 4
How do I sort a hash (optionally by value instead of key)?
.IP "\(bu" 4
How can I always keep my hash sorted?
.IP "\(bu" 4
What's the difference between \*(L"delete\*(R" and \*(L"undef\*(R" with hashes?
.IP "\(bu" 4
Why don't my tied hashes make the defined/exists distinction?
.IP "\(bu" 4
How do I reset an \fIeach()\fR operation part-way through?
.IP "\(bu" 4
How can I get the unique keys from two hashes?
.IP "\(bu" 4
How can I store a multidimensional array in a \s-1DBM\s0 file?
.IP "\(bu" 4
How can I make my hash remember the order I put elements into it?
.IP "\(bu" 4
Why does passing a subroutine an undefined element in a hash create it?
.IP "\(bu" 4
How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?
.IP "\(bu" 4
How can I use a reference as a hash key?
.IP "\(bu" 4
How can I check if a key exists in a multilevel hash?
.IP "\(bu" 4
How can I prevent addition of unwanted keys into a hash?
.IP "\(bu" 4
How do I handle binary data correctly?
.IP "\(bu" 4
How do I determine whether a scalar is a number/whole/integer/float?
.IP "\(bu" 4
How do I keep persistent data across program calls?
.IP "\(bu" 4
How do I print out or copy a recursive data structure?
.IP "\(bu" 4
How do I define methods for every class/object?
.IP "\(bu" 4
How do I verify a credit card checksum?
.IP "\(bu" 4
How do I pack arrays of doubles or floats for \s-1XS\s0 code?
.SS "perlfaq5: Files and Formats"
.IX Subsection "perlfaq5: Files and Formats"
This section deals with I/O and the \*(L"f\*(R" issues: filehandles, flushing, formats, and footers.
.IP "\(bu" 4
How do I flush/unbuffer an output filehandle? Why must I do this?
.IP "\(bu" 4
How do I change, delete, or insert a line in a file, or append to the beginning of a file?
.IP "\(bu" 4
How do I count the number of lines in a file?
.IP "\(bu" 4
How do I delete the last N lines from a file?
.IP "\(bu" 4
How can I use Perl's \f(CW\*(C`\-i\*(C'\fR option from within a program?
.IP "\(bu" 4
How can I copy a file?
.IP "\(bu" 4
How do I make a temporary file name?
.IP "\(bu" 4
How can I manipulate fixed-record-length files?
.IP "\(bu" 4
How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?
.IP "\(bu" 4
How can I use a filehandle indirectly?
.IP "\(bu" 4
How can I set up a footer format to be used with \fIwrite()\fR?
.IP "\(bu" 4
How can I \fIwrite()\fR into a string?
.IP "\(bu" 4
How can I open a filehandle to a string?
.IP "\(bu" 4
How can I output my numbers with commas added?
.IP "\(bu" 4
How can I translate tildes (~) in a filename?
.IP "\(bu" 4
How come when I open a file read-write it wipes it out?
.IP "\(bu" 4
Why do I sometimes get an \*(L"Argument list too long\*(R" when I use <*>?
.IP "\(bu" 4
How can I open a file with a leading \*(L">\*(R" or trailing blanks?
.IP "\(bu" 4
How can I reliably rename a file?
.IP "\(bu" 4
How can I lock a file?
.IP "\(bu" 4
Why can't I just open(\s-1FH, \*(L"\s0>file.lock\*(R")?
.IP "\(bu" 4
I still don't get locking. I just want to increment the number in the file. How can I do this?
.IP "\(bu" 4
All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?
.IP "\(bu" 4
How do I randomly update a binary file?
.IP "\(bu" 4
How do I get a file's timestamp in perl?
.IP "\(bu" 4
How do I set a file's timestamp in perl?
.IP "\(bu" 4
How do I print to more than one file at once?
.IP "\(bu" 4
How can I read in an entire file all at once?
.IP "\(bu" 4
How can I read in a file by paragraphs?
.IP "\(bu" 4
How can I read a single character from a file? From the keyboard?
.IP "\(bu" 4
How can I tell whether there's a character waiting on a filehandle?
.IP "\(bu" 4
How do I do a \f(CW\*(C`tail \-f\*(C'\fR in perl?
.IP "\(bu" 4
How do I \fIdup()\fR a filehandle in Perl?
.IP "\(bu" 4
How do I close a file descriptor by number?
.IP "\(bu" 4
Why can't I use \*(L"C:\etemp\efoo\*(R" in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?
.IP "\(bu" 4
Why doesn't glob(\*(L"*.*\*(R") get all the files?
.IP "\(bu" 4
Why does Perl let me delete read-only files? Why does \f(CW\*(C`\-i\*(C'\fR clobber protected files? Isn't this a bug in Perl?
.IP "\(bu" 4
How do I select a random line from a file?
.IP "\(bu" 4
Why do I get weird spaces when I print an array of lines?
.IP "\(bu" 4
How do I traverse a directory tree?
.IP "\(bu" 4
How do I delete a directory tree?
.IP "\(bu" 4
How do I copy an entire directory?
.SS "perlfaq6: Regular Expressions"
.IX Subsection "perlfaq6: Regular Expressions"
This section is surprisingly small because the rest of the \s-1FAQ\s0 is littered with answers involving regular expressions. For example, decoding a \s-1URL\s0 and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : \*(L"How do I decode or create those %\-encodings on the web\*(R" and perlfaq4 : \*(L"How do I determine whether a scalar is a number/whole/integer/float\*(R", to be precise).
.IP "\(bu" 4
How can I hope to use regular expressions without creating illegible and unmaintainable code?
.IP "\(bu" 4
I'm having trouble matching over more than one line. What's wrong?
.IP "\(bu" 4
How can I pull out lines between two patterns that are themselves on different lines?
.IP "\(bu" 4
How do I match \s-1XML, HTML,\s0 or other nasty, ugly things with a regex?
.IP "\(bu" 4
I put a regular expression into $/ but it didn't work. What's wrong?
.IP "\(bu" 4
How do I substitute case-insensitively on the \s-1LHS\s0 while preserving case on the \s-1RHS\s0?
.IP "\(bu" 4
How can I make \f(CW\*(C`\ew\*(C'\fR match national character sets?
.IP "\(bu" 4
How can I match a locale-smart version of \f(CW\*(C`/[a\-zA\-Z]/\*(C'\fR ?
.IP "\(bu" 4
How can I quote a variable to use in a regex?
.IP "\(bu" 4
What is \f(CW\*(C`/o\*(C'\fR really for?
.IP "\(bu" 4
How do I use a regular expression to strip C\-style comments from a file?
.IP "\(bu" 4
Can I use Perl regular expressions to match balanced text?
.IP "\(bu" 4
What does it mean that regexes are greedy? How can I get around it?
.IP "\(bu" 4
How do I process each word on each line?
.IP "\(bu" 4
How can I print out a word-frequency or line-frequency summary?
.IP "\(bu" 4
How can I do approximate matching?
.IP "\(bu" 4
How do I efficiently match many regular expressions at once?
.IP "\(bu" 4
Why don't word-boundary searches with \f(CW\*(C`\eb\*(C'\fR work for me?
.IP "\(bu" 4
Why does using $&, $`, or $' slow my program down?
.IP "\(bu" 4
What good is \f(CW\*(C`\eG\*(C'\fR in a regular expression?
.IP "\(bu" 4
Are Perl regexes DFAs or NFAs? Are they \s-1POSIX\s0 compliant?
.IP "\(bu" 4
What's wrong with using grep in a void context?
.IP "\(bu" 4
How can I match strings with multibyte characters?
.IP "\(bu" 4
How do I match a regular expression that's in a variable?
.SS "perlfaq7: General Perl Language Issues"
.IX Subsection "perlfaq7: General Perl Language Issues"
This section deals with general Perl language issues that don't clearly fit into any of the other sections.
.IP "\(bu" 4
Can I get a BNF/yacc/RE for the Perl language?
.IP "\(bu" 4
What are all these $@%&* punctuation signs, and how do I know when to use them?
.IP "\(bu" 4
Do I always/never have to quote my strings or use semicolons and commas?
.IP "\(bu" 4
How do I skip some return values?
.IP "\(bu" 4
How do I temporarily block warnings?
.IP "\(bu" 4
What's an extension?
.IP "\(bu" 4
Why do Perl operators have different precedence than C operators?
.IP "\(bu" 4
How do I declare/create a structure?
.IP "\(bu" 4
How do I create a module?
.IP "\(bu" 4
How do I adopt or take over a module already on \s-1CPAN\s0?
.IP "\(bu" 4
How do I create a class?
.IP "\(bu" 4
How can I tell if a variable is tainted?
.IP "\(bu" 4
What's a closure?
.IP "\(bu" 4
What is variable suicide and how can I prevent it?
.IP "\(bu" 4
How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?
.IP "\(bu" 4
How do I create a static variable?
.IP "\(bu" 4
What's the difference between dynamic and lexical (static) scoping? Between \fIlocal()\fR and \fImy()\fR?
.IP "\(bu" 4
How can I access a dynamic variable while a similarly named lexical is in scope?
.IP "\(bu" 4
What's the difference between deep and shallow binding?
.IP "\(bu" 4
Why doesn't \*(L"my($foo) = <$fh>;\*(R" work right?
.IP "\(bu" 4
How do I redefine a builtin function, operator, or method?
.IP "\(bu" 4
What's the difference between calling a function as &foo and \fIfoo()\fR?
.IP "\(bu" 4
How do I create a switch or case statement?
.IP "\(bu" 4
How can I catch accesses to undefined variables, functions, or methods?
.IP "\(bu" 4
Why can't a method included in this same file be found?
.IP "\(bu" 4
How can I find out my current or calling package?
.IP "\(bu" 4
How can I comment out a large block of Perl code?
.IP "\(bu" 4
How do I clear a package?
.IP "\(bu" 4
How can I use a variable as a variable name?
.IP "\(bu" 4
What does \*(L"bad interpreter\*(R" mean?
.SS "perlfaq8: System Interaction"
.IX Subsection "perlfaq8: System Interaction"
This section of the Perl \s-1FAQ\s0 covers questions involving operating system interaction. Topics include interprocess communication (\s-1IPC\s0), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.
.IP "\(bu" 4
How do I find out which operating system I'm running under?
.IP "\(bu" 4
How come \fIexec()\fR doesn't return?
.IP "\(bu" 4
How do I do fancy stuff with the keyboard/screen/mouse?
.IP "\(bu" 4
How do I print something out in color?
.IP "\(bu" 4
How do I read just one key without waiting for a return key?
.IP "\(bu" 4
How do I check whether input is ready on the keyboard?
.IP "\(bu" 4
How do I clear the screen?
.IP "\(bu" 4
How do I get the screen size?
.IP "\(bu" 4
How do I ask the user for a password?
.IP "\(bu" 4
How do I read and write the serial port?
.IP "\(bu" 4
How do I decode encrypted password files?
.IP "\(bu" 4
How do I start a process in the background?
.IP "\(bu" 4
How do I trap control characters/signals?
.IP "\(bu" 4
How do I modify the shadow password file on a Unix system?
.IP "\(bu" 4
How do I set the time and date?
.IP "\(bu" 4
How can I \fIsleep()\fR or \fIalarm()\fR for under a second?
.IP "\(bu" 4
How can I measure time under a second?
.IP "\(bu" 4
How can I do an \fIatexit()\fR or \fIsetjmp()\fR/\fIlongjmp()\fR? (Exception handling)
.IP "\(bu" 4
Why doesn't my sockets program work under System V (Solaris)? What does the error message \*(L"Protocol not supported\*(R" mean?
.IP "\(bu" 4
How can I call my system's unique C functions from Perl?
.IP "\(bu" 4
Where do I get the include files to do \fIioctl()\fR or \fIsyscall()\fR?
.IP "\(bu" 4
Why do setuid perl scripts complain about kernel problems?
.IP "\(bu" 4
How can I open a pipe both to and from a command?
.IP "\(bu" 4
Why can't I get the output of a command with \fIsystem()\fR?
.IP "\(bu" 4
How can I capture \s-1STDERR\s0 from an external command?
.IP "\(bu" 4
Why doesn't \fIopen()\fR return an error when a pipe open fails?
.IP "\(bu" 4
What's wrong with using backticks in a void context?
.IP "\(bu" 4
How can I call backticks without shell processing?
.IP "\(bu" 4
Why can't my script read from \s-1STDIN\s0 after I gave it \s-1EOF \s0(^D on Unix, ^Z on MS-DOS)?
.IP "\(bu" 4
How can I convert my shell script to perl?
.IP "\(bu" 4
Can I use perl to run a telnet or ftp session?
.IP "\(bu" 4
How can I write expect in Perl?
.IP "\(bu" 4
Is there a way to hide perl's command line from programs such as \*(L"ps\*(R"?
.IP "\(bu" 4
I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?
.IP "\(bu" 4
How do I close a process's filehandle without waiting for it to complete?
.IP "\(bu" 4
How do I fork a daemon process?
.IP "\(bu" 4
How do I find out if I'm running interactively or not?
.IP "\(bu" 4
How do I timeout a slow event?
.IP "\(bu" 4
How do I set \s-1CPU\s0 limits?
.IP "\(bu" 4
How do I avoid zombies on a Unix system?
.IP "\(bu" 4
How do I use an \s-1SQL\s0 database?
.IP "\(bu" 4
How do I make a \fIsystem()\fR exit on control-C?
.IP "\(bu" 4
How do I open a file without blocking?
.IP "\(bu" 4
How do I tell the difference between errors from the shell and perl?
.IP "\(bu" 4
How do I install a module from \s-1CPAN\s0?
.IP "\(bu" 4
What's the difference between require and use?
.IP "\(bu" 4
How do I keep my own module/library directory?
.IP "\(bu" 4
How do I add the directory my program lives in to the module/library search path?
.IP "\(bu" 4
How do I add a directory to my include path (@INC) at runtime?
.IP "\(bu" 4
What is socket.ph and where do I get it?
.SS "perlfaq9: Web, Email and Networking"
.IX Subsection "perlfaq9: Web, Email and Networking"
This section deals with questions related to running web sites, sending and receiving email as well as general networking.
.IP "\(bu" 4
Should I use a web framework?
.IP "\(bu" 4
Which web framework should I use?
.IP "\(bu" 4
What is Plack and \s-1PSGI\s0?
.IP "\(bu" 4
How do I remove \s-1HTML\s0 from a string?
.IP "\(bu" 4
How do I extract URLs?
.IP "\(bu" 4
How do I fetch an \s-1HTML\s0 file?
.IP "\(bu" 4
How do I automate an \s-1HTML\s0 form submission?
.IP "\(bu" 4
How do I decode or create those %\-encodings on the web?
.IP "\(bu" 4
How do I redirect to another page?
.IP "\(bu" 4
How do I put a password on my web pages?
.IP "\(bu" 4
How do I make sure users can't enter values into a form that causes my \s-1CGI\s0 script to do bad things?
.IP "\(bu" 4
How do I parse a mail header?
.IP "\(bu" 4
How do I check a valid mail address?
.IP "\(bu" 4
How do I decode a \s-1MIME/BASE64\s0 string?
.IP "\(bu" 4
How do I find the user's mail address?
.IP "\(bu" 4
How do I send email?
.IP "\(bu" 4
How do I use \s-1MIME\s0 to make an attachment to a mail message?
.IP "\(bu" 4
How do I read email?
.IP "\(bu" 4
How do I find out my hostname, domainname, or \s-1IP\s0 address?
.IP "\(bu" 4
How do I fetch/put an (S)FTP file?
.IP "\(bu" 4
How can I do \s-1RPC\s0 in Perl?
.SH "CREDITS"
.IX Header "CREDITS"
Tom Christiansen wrote the original perlfaq then expanded it with the
help of Nat Torkington. brian d foy substantialy edited and expanded
the perlfaq. perlfaq-workers and others have also supplied feedback,
patches and corrections over the years.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Tom Christiansen wrote the original version of this document.
brian d foy \f(CW\*(C`<bdfoy@cpan.org>\*(C'\fR wrote this version. See the
individual perlfaq documents for additional copyright information.
.PP
This document is available under the same terms as Perl itself. Code
examples in all the perlfaq documents are in the public domain. Use
them as you see fit (and at your own risk with no warranty from anyone).
 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq55.16.1                               0100644 0001750 0001750 00000206356 12566207416 023006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ5 1"
.TH PERLFAQ5 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq5 \- Files and Formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with I/O and the \*(L"f\*(R" issues: filehandles, flushing,
formats, and footers.
.SS "How do I flush/unbuffer an output filehandle? Why must I do this?"
.IX Xref "flush buffer unbuffer autoflush"
.IX Subsection "How do I flush/unbuffer an output filehandle? Why must I do this?"
(contributed by brian d foy)
.PP
You might like to read Mark Jason Dominus's \*(L"Suffering From Buffering\*(R"
at <http://perl.plover.com/FAQs/Buffering.html> .
.PP
Perl normally buffers output so it doesn't make a system call for every
bit of output. By saving up output, it makes fewer expensive system calls.
For instance, in this little bit of code, you want to print a dot to the
screen for every line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the output and you
have a long wait before you see a row of 50 dots all at once:
.PP
.Vb 4
\&    # long wait, then row of dots all at once
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... expensive line processing operations
\&    }
.Ve
.PP
To get around this, you have to unbuffer the output filehandle, in this
case, \f(CW\*(C`STDOUT\*(C'\fR. You can set the special variable \f(CW$|\fR to a true value
(mnemonic: making your filehandles \*(L"piping hot\*(R"):
.PP
.Vb 1
\&    $|++;
\&
\&    # dot shown immediately
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... expensive line processing operations
\&    }
.Ve
.PP
The \f(CW$|\fR is one of the per-filehandle special variables, so each
filehandle has its own copy of its value. If you want to merge
standard output and standard error for instance, you have to unbuffer
each (although \s-1STDERR\s0 might be unbuffered by default):
.PP
.Vb 7
\&    {
\&        my $previous_default = select(STDOUT);  # save previous default
\&        $|++;                                   # autoflush STDOUT
\&        select(STDERR);
\&        $|++;                                   # autoflush STDERR, to be sure
\&        select($previous_default);              # restore previous default
\&    }
\&
\&    # now should alternate . and +
\&    while( 1 ) {
\&        sleep 1;
\&        print STDOUT ".";
\&        print STDERR "+";
\&        print STDOUT "\en" unless ++$count % 25;
\&    }
.Ve
.PP
Besides the \f(CW$|\fR special variable, you can use \f(CW\*(C`binmode\*(C'\fR to give
your filehandle a \f(CW\*(C`:unix\*(C'\fR layer, which is unbuffered:
.PP
.Vb 1
\&    binmode( STDOUT, ":unix" );
\&
\&    while( 1 ) {
\&        sleep 1;
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&    }
.Ve
.PP
For more information on output layers, see the entries for \f(CW\*(C`binmode\*(C'\fR
and open in perlfunc, and the PerlIO module documentation.
.PP
If you are using IO::Handle or one of its subclasses, you can
call the \f(CW\*(C`autoflush\*(C'\fR method to change the settings of the
filehandle:
.PP
.Vb 3
\&    use IO::Handle;
\&    open my( $io_fh ), ">", "output.txt";
\&    $io_fh\->autoflush(1);
.Ve
.PP
The IO::Handle objects also have a \f(CW\*(C`flush\*(C'\fR method. You can flush
the buffer any time you want without auto-buffering
.PP
.Vb 1
\&    $io_fh\->flush;
.Ve
.SS "How do I change, delete, or insert a line in a file, or append to the beginning of a file?"
.IX Xref "file, editing"
.IX Subsection "How do I change, delete, or insert a line in a file, or append to the beginning of a file?"
(contributed by brian d foy)
.PP
The basic idea of inserting, changing, or deleting a line from a text
file involves reading and printing the file to the point you want to
make the change, making the change, then reading and printing the rest
of the file. Perl doesn't provide random access to lines (especially
since the record input separator, \f(CW$/\fR, is mutable), although modules
such as Tie::File can fake it.
.PP
A Perl program to do these tasks takes the basic form of opening a
file, printing its lines, then closing the file:
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
Within that basic form, add the parts that you need to insert, change,
or delete lines.
.PP
To prepend lines to the beginning, print those lines before you enter
the loop that prints the existing lines.
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    print $out "# Add this line to the top\en"; # <\-\-\- HERE\*(AqS THE MAGIC
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To change existing lines, insert the code to modify the lines inside
the \f(CW\*(C`while\*(C'\fR loop. In this case, the code finds all lowercased
versions of \*(L"perl\*(R" and uppercases them. The happens for every line, so
be sure that you're supposed to do that on every line!
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    print $out "# Add this line to the top\en";
\&
\&    while( <$in> ) {
\&        s/\eb(perl)\eb/Perl/g;
\&        print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To change only a particular line, the input line number, \f(CW$.\fR, is
useful. First read and print the lines up to the one you  want to
change. Next, read the single line you want to change, change it, and
print it. After that, read the rest of the lines and print those:
.PP
.Vb 4
\&    while( <$in> ) { # print the lines before the change
\&        print $out $_;
\&        last if $. == 4; # line number before change
\&    }
\&
\&    my $line = <$in>;
\&    $line =~ s/\eb(perl)\eb/Perl/g;
\&    print $out $line;
\&
\&    while( <$in> ) { # print the rest of the lines
\&        print $out $_;
\&    }
.Ve
.PP
To skip lines, use the looping controls. The \f(CW\*(C`next\*(C'\fR in this example
skips comment lines, and the \f(CW\*(C`last\*(C'\fR stops all processing once it
encounters either \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.PP
.Vb 5
\&    while( <$in> ) {
\&        next if /^\es+#/;             # skip comment lines
\&        last if /^_\|_(END|DATA)_\|_$/;  # stop at end of code marker
\&        print $out $_;
\&    }
.Ve
.PP
Do the same sort of thing to delete a particular line by using \f(CW\*(C`next\*(C'\fR
to skip the lines you don't want to show up in the output. This
example skips every fifth line:
.PP
.Vb 4
\&    while( <$in> ) {
\&        next unless $. % 5;
\&        print $out $_;
\&    }
.Ve
.PP
If, for some odd reason, you really want to see the whole file at once
rather than processing line-by-line, you can slurp it in (as long as
you can fit the whole thing in memory!):
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!"
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    my @lines = do { local $/; <$in> }; # slurp!
\&
\&        # do your magic here
\&
\&    print $out @lines;
.Ve
.PP
Modules such as File::Slurp and Tie::File can help with that
too. If you can, however, avoid reading the entire file at once. Perl
won't give that memory back to the operating system until the process
finishes.
.PP
You can also use Perl one-liners to modify a file in-place. The
following changes all 'Fred' to 'Barney' in \fIinFile.txt\fR, overwriting
the file with the new contents. With the \f(CW\*(C`\-p\*(C'\fR switch, Perl wraps a
\&\f(CW\*(C`while\*(C'\fR loop around the code you specify with \f(CW\*(C`\-e\*(C'\fR, and \f(CW\*(C`\-i\*(C'\fR turns
on in-place editing. The current line is in \f(CW$_\fR. With \f(CW\*(C`\-p\*(C'\fR, Perl
automatically prints the value of \f(CW$_\fR at the end of the loop. See
perlrun for more details.
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To make a backup of \f(CW\*(C`inFile.txt\*(C'\fR, give \f(CW\*(C`\-i\*(C'\fR a file extension to add:
.PP
.Vb 1
\&    perl \-pi.bak \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To change only the fifth line, you can add a test checking \f(CW$.\fR, the
input line number, then only perform the operation when the test
passes:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/ if $. == 5\*(Aq inFile.txt
.Ve
.PP
To add lines before a certain line, you can add a line (or lines!)
before Perl prints \f(CW$_\fR:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before third line\en" if $. == 3\*(Aq inFile.txt
.Ve
.PP
You can even add a line to the beginning of a file, since the current
line prints at the end of the loop:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before first line\en" if $. == 1\*(Aq inFile.txt
.Ve
.PP
To insert a line after one already in the file, use the \f(CW\*(C`\-n\*(C'\fR switch.
It's just like \f(CW\*(C`\-p\*(C'\fR except that it doesn't print \f(CW$_\fR at the end of
the loop, so you have to do that yourself. In this case, print \f(CW$_\fR
first, then print the line that you want to add.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint; print "Put after fifth line\en" if $. == 5\*(Aq inFile.txt
.Ve
.PP
To delete lines, only print the ones that you want.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint if /d/\*(Aq inFile.txt
.Ve
.SS "How do I count the number of lines in a file?"
.IX Xref "file, counting lines lines line"
.IX Subsection "How do I count the number of lines in a file?"
(contributed by brian d foy)
.PP
Conceptually, the easiest way to count the lines in a file is to
simply read them and count them:
.PP
.Vb 2
\&    my $count = 0;
\&    while( <$fh> ) { $count++; }
.Ve
.PP
You don't really have to count them yourself, though, since Perl
already does that with the \f(CW$.\fR variable, which is the current line
number from the last filehandle read:
.PP
.Vb 2
\&    1 while( <$fh> );
\&    my $count = $.;
.Ve
.PP
If you want to use \f(CW$.\fR, you can reduce it to a simple one-liner,
like one of these:
.PP
.Vb 1
\&    % perl \-lne \*(Aq} print $.; {\*(Aq    file
\&
\&    % perl \-lne \*(AqEND { print $. }\*(Aq file
.Ve
.PP
Those can be rather inefficient though. If they aren't fast enough for
you, you might just read chunks of data and count the number of
newlines:
.PP
.Vb 6
\&    my $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or die "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ tr/\en// );
\&    }
\&    close FILE;
.Ve
.PP
However, that doesn't work if the line ending isn't a newline. You
might change that \f(CW\*(C`tr///\*(C'\fR to a \f(CW\*(C`s///\*(C'\fR so you can count the number of
times the input record separator, \f(CW$/\fR, shows up:
.PP
.Vb 6
\&    my $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or die "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ s|$/||g; );
\&    }
\&    close FILE;
.Ve
.PP
If you don't mind shelling out, the \f(CW\*(C`wc\*(C'\fR command is usually the
fastest, even with the extra interprocess overhead. Ensure that you
have an untainted filename though:
.PP
.Vb 1
\&    #!perl \-T
\&
\&    $ENV{PATH} = undef;
\&
\&    my $lines;
\&    if( $filename =~ /^([0\-9a\-z_.]+)\ez/ ) {
\&        $lines = \`/usr/bin/wc \-l $1\`
\&        chomp $lines;
\&    }
.Ve
.SS "How do I delete the last N lines from a file?"
.IX Xref "lines file"
.IX Subsection "How do I delete the last N lines from a file?"
(contributed by brian d foy)
.PP
The easiest conceptual solution is to count the lines in the
file then start at the beginning and print the number of lines
(minus the last N) to a new file.
.PP
Most often, the real question is how you can delete the last N lines
without making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard reality when
you might have millions of lines in your file.
.PP
One trick is to use File::ReadBackwards, which starts at the end of
the file. That module provides an object that wraps the real filehandle
to make it easy for you to move around the file. Once you get to the
spot you need, you can get the actual filehandle and work with it as
normal. In this case, you get the file position at the end of the last
line you want to keep and truncate the file to that point:
.PP
.Vb 1
\&    use File::ReadBackwards;
\&
\&    my $filename = \*(Aqtest.txt\*(Aq;
\&    my $Lines_to_truncate = 2;
\&
\&    my $bw = File::ReadBackwards\->new( $filename )
\&        or die "Could not read backwards in [$filename]: $!";
\&
\&    my $lines_from_end = 0;
\&    until( $bw\->eof or $lines_from_end == $Lines_to_truncate ) {
\&        print "Got: ", $bw\->readline;
\&        $lines_from_end++;
\&    }
\&
\&    truncate( $filename, $bw\->tell );
.Ve
.PP
The File::ReadBackwards module also has the advantage of setting
the input record separator to a regular expression.
.PP
You can also use the Tie::File module which lets you access
the lines through a tied array. You can use normal array operations
to modify your file, including setting the last index and using
\&\f(CW\*(C`splice\*(C'\fR.
.ie n .SS "How can I use Perl's ""\-i"" option from within a program?"
.el .SS "How can I use Perl's \f(CW\-i\fP option from within a program?"
.IX Xref "-i in-place"
.IX Subsection "How can I use Perl's -i option from within a program?"
\&\f(CW\*(C`\-i\*(C'\fR sets the value of Perl's \f(CW$^I\fR variable, which in turn affects
the behavior of \f(CW\*(C`<>\*(C'\fR; see perlrun for more details. By
modifying the appropriate variables directly, you can get the same
behavior within a larger program. For example:
.PP
.Vb 10
\&    # ...
\&    {
\&        local($^I, @ARGV) = (\*(Aq.orig\*(Aq, glob("*.c"));
\&        while (<>) {
\&            if ($. == 1) {
\&                print "This line should appear at the top of each file\en";
\&            }
\&            s/\eb(p)earl\eb/${1}erl/i;        # Correct typos, preserving case
\&            print;
\&            close ARGV if eof;              # Reset $.
\&        }
\&    }
\&    # $^I and @ARGV return to their old values here
.Ve
.PP
This block modifies all the \f(CW\*(C`.c\*(C'\fR files in the current directory,
leaving a backup of the original data from each file in a new
\&\f(CW\*(C`.c.orig\*(C'\fR file.
.SS "How can I copy a file?"
.IX Xref "copy file, copy File::Copy"
.IX Subsection "How can I copy a file?"
(contributed by brian d foy)
.PP
Use the File::Copy module. It comes with Perl and can do a
true copy across file systems, and it does its magic in
a portable fashion.
.PP
.Vb 1
\&    use File::Copy;
\&
\&    copy( $original, $new_copy ) or die "Copy failed: $!";
.Ve
.PP
If you can't use File::Copy, you'll have to do the work yourself:
open the original file, open the destination file, then print
to the destination file as you read the original. You also have to
remember to copy the permissions, owner, and group to the new file.
.SS "How do I make a temporary file name?"
.IX Xref "file, temporary"
.IX Subsection "How do I make a temporary file name?"
If you don't need to know the name of the file, you can use \f(CW\*(C`open()\*(C'\fR
with \f(CW\*(C`undef\*(C'\fR in place of the file name. In Perl 5.8 or later, the
\&\f(CW\*(C`open()\*(C'\fR function creates an anonymous temporary file:
.PP
.Vb 1
\&    open my $tmp, \*(Aq+>\*(Aq, undef or die $!;
.Ve
.PP
Otherwise, you can use the File::Temp module.
.PP
.Vb 1
\&    use File::Temp qw/ tempfile tempdir /;
\&
\&    my $dir = tempdir( CLEANUP => 1 );
\&    ($fh, $filename) = tempfile( DIR => $dir );
\&
\&    # or if you don\*(Aqt need to know the filename
\&
\&    my $fh = tempfile( DIR => $dir );
.Ve
.PP
The File::Temp has been a standard module since Perl 5.6.1. If you
don't have a modern enough Perl installed, use the \f(CW\*(C`new_tmpfile\*(C'\fR
class method from the IO::File module to get a filehandle opened for
reading and writing. Use it if you don't need to know the file's name:
.PP
.Vb 3
\&    use IO::File;
\&    my $fh = IO::File\->new_tmpfile()
\&        or die "Unable to make new temporary file: $!";
.Ve
.PP
If you're committed to creating a temporary file by hand, use the
process \s-1ID\s0 and/or the current time-value. If you need to have many
temporary files in one process, use a counter:
.PP
.Vb 4
\&    BEGIN {
\&        use Fcntl;
\&        my $temp_dir = \-d \*(Aq/tmp\*(Aq ? \*(Aq/tmp\*(Aq : $ENV{TMPDIR} || $ENV{TEMP};
\&        my $base_name = sprintf "%s/%d\-%d\-0000", $temp_dir, $$, time;
\&
\&        sub temp_file {
\&            my $fh;
\&            my $count = 0;
\&            until( defined(fileno($fh)) || $count++ > 100 ) {
\&                $base_name =~ s/\-(\ed+)$/"\-" . (1 + $1)/e;
\&                # O_EXCL is required for security reasons.
\&                sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT;
\&            }
\&
\&            if( defined fileno($fh) ) {
\&                return ($fh, $base_name);
\&            }
\&            else {
\&                return ();
\&            }
\&        }
\&    }
.Ve
.SS "How can I manipulate fixed-record-length files?"
.IX Xref "fixed-length file, fixed-length records"
.IX Subsection "How can I manipulate fixed-record-length files?"
The most efficient way is using \fIpack()\fR and
\&\fIunpack()\fR. This is faster than using
\&\fIsubstr()\fR when taking many, many strings. It is
slower for just a few.
.PP
Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:
.PP
.Vb 10
\&    # sample input line:
\&    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now\-what
\&    my $PS_T = \*(AqA6 A4 A7 A5 A*\*(Aq;
\&    open my $ps, \*(Aq\-|\*(Aq, \*(Aqps\*(Aq;
\&    print scalar <$ps>;
\&    my @fields = qw( pid tt stat time command );
\&    while (<$ps>) {
\&        my %process;
\&        @process{@fields} = unpack($PS_T, $_);
\&        for my $field ( @fields ) {
\&            print "$field: <$process{$field}>\en";
\&        }
\&        print \*(Aqline=\*(Aq, pack($PS_T, @process{@fields} ), "\en";
\&    }
.Ve
.PP
We've used a hash slice in order to easily handle the fields of each row.
Storing the keys in an array makes it easy to operate on them as a
group or loop over them with \f(CW\*(C`for\*(C'\fR. It also avoids polluting the program
with global variables and using symbolic references.
.SS "How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?"
.IX Xref "filehandle, local filehandle, passing filehandle, reference"
.IX Subsection "How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?"
As of perl5.6, \fIopen()\fR autovivifies file and directory handles
as references if you pass it an uninitialized scalar variable.
You can then pass these references just like any other scalar,
and use them in the place of named handles.
.PP
.Vb 1
\&    open my    $fh, $file_name;
\&
\&    open local $fh, $file_name;
\&
\&    print $fh "Hello World!\en";
\&
\&    process_file( $fh );
.Ve
.PP
If you like, you can store these filehandles in an array or a hash.
If you access them directly, they aren't simple scalars and you
need to give \f(CW\*(C`print\*(C'\fR a little help by placing the filehandle
reference in braces. Perl can only figure it out on its own when
the filehandle reference is a simple scalar.
.PP
.Vb 1
\&    my @fhs = ( $fh1, $fh2, $fh3 );
\&
\&    for( $i = 0; $i <= $#fhs; $i++ ) {
\&        print {$fhs[$i]} "just another Perl answer, \en";
\&    }
.Ve
.PP
Before perl5.6, you had to deal with various typeglob idioms
which you may see in older code.
.PP
.Vb 3
\&    open FILE, "> $filename";
\&    process_typeglob(   *FILE );
\&    process_reference( \e*FILE );
\&
\&    sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
\&    sub process_reference { local $fh = shift; print $fh "Reference!" }
.Ve
.PP
If you want to create many anonymous handles, you should
check out the Symbol or IO::Handle modules.
.SS "How can I use a filehandle indirectly?"
.IX Xref "filehandle, indirect"
.IX Subsection "How can I use a filehandle indirectly?"
An indirect filehandle is the use of something other than a symbol
in a place that a filehandle is expected. Here are ways
to get indirect filehandles:
.PP
.Vb 5
\&    $fh =   SOME_FH;       # bareword is strict\-subs hostile
\&    $fh =  "SOME_FH";      # strict\-refs hostile; same package only
\&    $fh =  *SOME_FH;       # typeglob
\&    $fh = \e*SOME_FH;       # ref to typeglob (bless\-able)
\&    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
.Ve
.PP
Or, you can use the \f(CW\*(C`new\*(C'\fR method from one of the IO::* modules to
create an anonymous filehandle and store that in a scalar variable.
.PP
.Vb 2
\&    use IO::Handle;                     # 5.004 or higher
\&    my $fh = IO::Handle\->new();
.Ve
.PP
Then use any of those as you would a normal filehandle. Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains
a filehandle. Functions like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, or
the \f(CW\*(C`<FH>\*(C'\fR diamond operator will accept either a named filehandle
or a scalar variable containing one:
.PP
.Vb 4
\&    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
\&    print $ofh "Type it: ";
\&    my $got = <$ifh>
\&    print $efh "What was that: $got";
.Ve
.PP
If you're passing a filehandle to a function, you can write
the function in two ways:
.PP
.Vb 4
\&    sub accept_fh {
\&        my $fh = shift;
\&        print $fh "Sending to indirect filehandle\en";
\&    }
.Ve
.PP
Or it can localize a typeglob and use the filehandle directly:
.PP
.Vb 4
\&    sub accept_fh {
\&        local *FH = shift;
\&        print  FH "Sending to localized filehandle\en";
\&    }
.Ve
.PP
Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this
is risky.)
.PP
.Vb 2
\&    accept_fh(*STDOUT);
\&    accept_fh($handle);
.Ve
.PP
In the examples above, we assigned the filehandle to a scalar variable
before using it. That is because only simple scalar variables, not
expressions or subscripts of hashes or arrays, can be used with
built-ins like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, or the diamond operator. Using
something other than a simple scalar variable as a filehandle is
illegal and won't even compile:
.PP
.Vb 4
\&    my @fd = (*STDIN, *STDOUT, *STDERR);
\&    print $fd[1] "Type it: ";                           # WRONG
\&    my $got = <$fd[0]>                                  # WRONG
\&    print $fd[2] "What was that: $got";                 # WRONG
.Ve
.PP
With \f(CW\*(C`print\*(C'\fR and \f(CW\*(C`printf\*(C'\fR, you get around this by using a block and
an expression where you would place the filehandle:
.PP
.Vb 3
\&    print  { $fd[1] } "funny stuff\en";
\&    printf { $fd[1] } "Pity the poor %x.\en", 3_735_928_559;
\&    # Pity the poor deadbeef.
.Ve
.PP
That block is a proper block like any other, so you can put more
complicated code there. This sends the message out to one of two places:
.PP
.Vb 3
\&    my $ok = \-x "/bin/cat";
\&    print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\en";
\&    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\en";
.Ve
.PP
This approach of treating \f(CW\*(C`print\*(C'\fR and \f(CW\*(C`printf\*(C'\fR like object methods
calls doesn't work for the diamond operator. That's because it's a
real operator, not just a function with a comma-less argument. Assuming
you've been storing typeglobs in your structure as we did above, you
can use the built-in function named \f(CW\*(C`readline\*(C'\fR to read a record just
as \f(CW\*(C`<>\*(C'\fR does. Given the initialization shown above for \f(CW@fd\fR, this
would work, but only because \fIreadline()\fR requires a typeglob. It doesn't
work with objects or strings, which might be a bug we haven't fixed yet.
.PP
.Vb 1
\&    $got = readline($fd[0]);
.Ve
.PP
Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators. Playing the object
game doesn't help you at all here.
.SS "How can I set up a footer format to be used with \fIwrite()\fP?"
.IX Xref "footer"
.IX Subsection "How can I set up a footer format to be used with write()?"
There's no builtin way to do this, but perlform has a couple of
techniques to make it possible for the intrepid hacker.
.SS "How can I \fIwrite()\fP into a string?"
.IX Xref "write, into a string"
.IX Subsection "How can I write() into a string?"
(contributed by brian d foy)
.PP
If you want to \f(CW\*(C`write\*(C'\fR into a string, you just have to <open> a
filehandle to a string, which Perl has been able to do since Perl 5.6:
.PP
.Vb 2
\&    open FH, \*(Aq>\*(Aq, \emy $string;
\&    write( FH );
.Ve
.PP
Since you want to be a good programmer, you probably want to use a lexical
filehandle, even though formats are designed to work with bareword filehandles
since the default format names take the filehandle name. However, you can
control this with some Perl special per-filehandle variables: \f(CW$^\fR, which
names the top-of-page format, and \f(CW$~\fR which shows the line format. You have
to change the default filehandle to set these variables:
.PP
.Vb 1
\&    open my($fh), \*(Aq>\*(Aq, \emy $string;
\&
\&    { # set per\-filehandle variables
\&        my $old_fh = select( $fh );
\&        $~ = \*(AqANIMAL\*(Aq;
\&        $^ = \*(AqANIMAL_TOP\*(Aq;
\&        select( $old_fh );
\&    }
\&
\&    format ANIMAL_TOP =
\&     ID  Type    Name
\&    .
\&
\&    format ANIMAL =
\&    @##   @<<<    @<<<<<<<<<<<<<<
\&    $id,  $type,  $name
\&    .
.Ve
.PP
Although write can work with lexical or package variables, whatever variables
you use have to scope in the format. That most likely means you'll want to
localize some package variables:
.PP
.Vb 4
\&    {
\&        local( $id, $type, $name ) = qw( 12 cat Buster );
\&        write( $fh );
\&    }
\&
\&    print $string;
.Ve
.PP
There are also some tricks that you can play with \f(CW\*(C`formline\*(C'\fR and the
accumulator variable \f(CW$^A\fR, but you lose a lot of the value of formats
since \f(CW\*(C`formline\*(C'\fR won't handle paging and so on. You end up reimplementing
formats when you use them.
.SS "How can I open a filehandle to a string?"
.IX Xref "string open IO::String filehandle"
.IX Subsection "How can I open a filehandle to a string?"
(contributed by Peter J. Holzer, hjp\-usenet2@hjp.at)
.PP
Since Perl 5.8.0 a file handle referring to a string can be created by
calling open with a reference to that string instead of the filename.
This file handle can then be used to read from or write to the string:
.PP
.Vb 3
\&    open(my $fh, \*(Aq>\*(Aq, \e$string) or die "Could not open string for writing";
\&    print $fh "foo\en";
\&    print $fh "bar\en";    # $string now contains "foo\enbar\en"
\&
\&    open(my $fh, \*(Aq<\*(Aq, \e$string) or die "Could not open string for reading";
\&    my $x = <$fh>;    # $x now contains "foo\en"
.Ve
.PP
With older versions of Perl, the IO::String module provides similar
functionality.
.SS "How can I output my numbers with commas added?"
.IX Xref "number, commify"
.IX Subsection "How can I output my numbers with commas added?"
(contributed by brian d foy and Benjamin Goldberg)
.PP
You can use Number::Format to separate places in a number.
It handles locale information for those of you who want to insert
full stops instead (or anything else that they want to use,
really).
.PP
This subroutine will add commas to your number:
.PP
.Vb 5
\&    sub commify {
\&        local $_  = shift;
\&        1 while s/^([\-+]?\ed+)(\ed{3})/$1,$2/;
\&        return $_;
\&    }
.Ve
.PP
This regex from Benjamin Goldberg will add commas to numbers:
.PP
.Vb 1
\&    s/(^[\-+]?\ed+?(?=(?>(?:\ed{3})+)(?!\ed))|\eG\ed{3}(?=\ed))/$1,/g;
.Ve
.PP
It is easier to see with comments:
.PP
.Vb 11
\&    s/(
\&        ^[\-+]?             # beginning of number.
\&        \ed+?               # first digits before first comma
\&        (?=                # followed by, (but not included in the match) :
\&            (?>(?:\ed{3})+) # some positive multiple of three digits.
\&            (?!\ed)         # an *exact* multiple, not x * 3 + 1 or whatever.
\&        )
\&        |                  # or:
\&        \eG\ed{3}            # after the last group, get three digits
\&        (?=\ed)             # but they have to have more digits after them.
\&    )/$1,/xg;
.Ve
.SS "How can I translate tildes (~) in a filename?"
.IX Xref "tilde tilde expansion"
.IX Subsection "How can I translate tildes (~) in a filename?"
Use the <> (\f(CW\*(C`glob()\*(C'\fR) operator, documented in perlfunc.
Versions of Perl older than 5.6 require that you have a shell
installed that groks tildes. Later versions of Perl have this feature
built in. The File::KGlob module (available from \s-1CPAN\s0) gives more
portable glob functionality.
.PP
Within Perl, you may use this directly:
.PP
.Vb 11
\&    $filename =~ s{
\&      ^ ~             # find a leading tilde
\&      (               # save this in $1
\&          [^/]        # a non\-slash character
\&                *     # repeated 0 or more times (0 means me)
\&      )
\&    }{
\&      $1
\&          ? (getpwnam($1))[7]
\&          : ( $ENV{HOME} || $ENV{LOGDIR} )
\&    }ex;
.Ve
.SS "How come when I open a file read-write it wipes it out?"
.IX Xref "clobber read-write clobbering truncate truncating"
.IX Subsection "How come when I open a file read-write it wipes it out?"
Because you're using something like this, which truncates the file
\&\fIthen\fR gives you read-write access:
.PP
.Vb 1
\&    open my $fh, \*(Aq+>\*(Aq, \*(Aq/path/name\*(Aq; # WRONG (almost always)
.Ve
.PP
Whoops. You should instead use this, which will fail if the file
doesn't exist:
.PP
.Vb 1
\&    open my $fh, \*(Aq+<\*(Aq, \*(Aq/path/name\*(Aq; # open for update
.Ve
.PP
Using \*(L">\*(R" always clobbers or creates. Using \*(L"<\*(R" never does
either. The \*(L"+\*(R" doesn't change this.
.PP
Here are examples of many kinds of file opens. Those using \f(CW\*(C`sysopen\*(C'\fR
all assume that you've pulled in the constants from Fcntl:
.PP
.Vb 1
\&    use Fcntl;
.Ve
.PP
To open file for reading:
.PP
.Vb 2
\&    open my $fh, \*(Aq<\*(Aq, $path                               or die $!;
\&    sysopen my $fh, $path, O_RDONLY                       or die $!;
.Ve
.PP
To open file for writing, create new file if needed or else truncate old file:
.PP
.Vb 3
\&    open my $fh, \*(Aq>\*(Aq, $path                               or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT       or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die $!;
.Ve
.PP
To open file for writing, create new file, file must not exist:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT        or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666  or die $!;
.Ve
.PP
To open file for appending, create if necessary:
.PP
.Vb 3
\&    open my $fh, \*(Aq>>\*(Aq $path                               or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT      or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or die $!;
.Ve
.PP
To open file for appending, file must exist:
.PP
.Vb 1
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND              or die $!;
.Ve
.PP
To open file for update, file must exist:
.PP
.Vb 2
\&    open my $fh, \*(Aq+<\*(Aq, $path                              or die $!;
\&    sysopen my $fh, $path, O_RDWR                         or die $!;
.Ve
.PP
To open file for update, create file if necessary:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_RDWR|O_CREAT                 or die $!;
\&    sysopen my $fh, $path, O_RDWR|O_CREAT, 0666           or die $!;
.Ve
.PP
To open file for update, file must not exist:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT          or die $!;
\&    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666    or die $!;
.Ve
.PP
To open a file without blocking, creating if necessary:
.PP
.Vb 2
\&    sysopen my $fh, \*(Aq/foo/somefile\*(Aq, O_WRONLY|O_NDELAY|O_CREAT
\&        or die "can\*(Aqt open /foo/somefile: $!":
.Ve
.PP
Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over \s-1NFS\s0. That is, two processes might both
successfully create or unlink the same file! Therefore O_EXCL
isn't as exclusive as you might wish.
.PP
See also perlopentut.
.ie n .SS "Why do I sometimes get an ""Argument list too long"" when I use <*>?"
.el .SS "Why do I sometimes get an ``Argument list too long'' when I use <*>?"
.IX Xref "argument list too long"
.IX Subsection "Why do I sometimes get an Argument list too long when I use <*>?"
The \f(CW\*(C`<>\*(C'\fR operator performs a globbing operation (see above).
In Perl versions earlier than v5.6.0, the internal \fIglob()\fR operator forks
\&\fIcsh\fR\|(1) to do the actual glob expansion, but
csh can't handle more than 127 items and so gives the error message
\&\f(CW\*(C`Argument list too long\*(C'\fR. People who installed tcsh as csh won't
have this problem, but their users may be surprised by it.
.PP
To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with \fIreaddir()\fR and patterns, or use a module like File::Glob,
one that doesn't use the shell to do globbing.
.ie n .SS "How can I open a file with a leading "">"" or trailing blanks?"
.el .SS "How can I open a file with a leading ``>'' or trailing blanks?"
.IX Xref "filename, special characters"
.IX Subsection "How can I open a file with a leading > or trailing blanks?"
(contributed by Brian McCauley)
.PP
The special two-argument form of Perl's \fIopen()\fR function ignores
trailing blanks in filenames and infers the mode from certain leading
characters (or a trailing \*(L"|\*(R"). In older versions of Perl this was the
only version of \fIopen()\fR and so it is prevalent in old code and books.
.PP
Unless you have a particular reason to use the two-argument form you
should use the three-argument form of \fIopen()\fR which does not treat any
characters in the filename as special.
.PP
.Vb 2
\&    open my $fh, "<", "  file  ";  # filename is "   file   "
\&    open my $fh, ">", ">file";     # filename is ">file"
.Ve
.SS "How can I reliably rename a file?"
.IX Xref "rename mv move file, rename"
.IX Subsection "How can I reliably rename a file?"
If your operating system supports a proper \fImv\fR\|(1) utility or its
functional equivalent, this works:
.PP
.Vb 1
\&    rename($old, $new) or system("mv", $old, $new);
.Ve
.PP
It may be more portable to use the File::Copy module instead.
You just copy to the new file to the new name (checking return
values), then delete the old one. This isn't really the same
semantically as a \f(CW\*(C`rename()\*(C'\fR, which preserves meta-information like
permissions, timestamps, inode info, etc.
.SS "How can I lock a file?"
.IX Xref "lock file, lock flock"
.IX Subsection "How can I lock a file?"
Perl's builtin \fIflock()\fR function (see perlfunc for details) will call
\&\fIflock\fR\|(2) if that exists, \fIfcntl\fR\|(2) if it doesn't (on perl version 5.004 and
later), and \fIlockf\fR\|(3) if neither of the two previous system calls exists.
On some systems, it may even use a different form of native locking.
Here are some gotchas with Perl's \fIflock()\fR:
.IP "1." 4
Produces a fatal error if none of the three system calls (or their
close equivalent) exists.
.IP "2." 4
\&\fIlockf\fR\|(3) does not provide shared locking, and requires that the
filehandle be open for writing (or appending, or read/writing).
.IP "3." 4
Some versions of \fIflock()\fR can't lock files over a network (e.g. on \s-1NFS\s0 file
systems), so you'd need to force the use of \fIfcntl\fR\|(2) when you build Perl.
But even this is dubious at best. See the flock entry of perlfunc
and the \fI\s-1INSTALL\s0\fR file in the source distribution for information on
building Perl to do this.
.Sp
Two potentially non-obvious but traditional flock semantics are that
it waits indefinitely until the lock is granted, and that its locks are
\&\fImerely advisory\fR. Such discretionary locks are more flexible, but
offer fewer guarantees. This means that files locked with \fIflock()\fR may
be modified by programs that do not also use \fIflock()\fR. Cars that stop
for red lights get on well with each other, but not with cars that don't
stop for red lights. See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details. It's
best to assume traditional behavior if you're writing portable programs.
(If you're not, you should as always feel perfectly free to write
for your own system's idiosyncrasies (sometimes called \*(L"features\*(R").
Slavish adherence to portability concerns shouldn't get in the way of
your getting your job done.)
.Sp
For more information on file locking, see also
\&\*(L"File Locking\*(R" in perlopentut if you have it (new for 5.6).
.ie n .SS "Why can't I just open(\s-1FH\s0, "">file.lock"")?"
.el .SS "Why can't I just open(\s-1FH\s0, ``>file.lock'')?"
.IX Xref "lock, lockfile race condition"
.IX Subsection "Why can't I just open(FH, >file.lock)?"
A common bit of code \fB\s-1NOT\s0 \s-1TO\s0 \s-1USE\s0\fR is this:
.PP
.Vb 2
\&    sleep(3) while \-e \*(Aqfile.lock\*(Aq;    # PLEASE DO NOT USE
\&    open my $lock, \*(Aq>\*(Aq, \*(Aqfile.lock\*(Aq; # THIS BROKEN CODE
.Ve
.PP
This is a classic race condition: you take two steps to do something
which must be done in one. That's why computer hardware provides an
atomic test-and-set instruction. In theory, this \*(L"ought\*(R" to work:
.PP
.Vb 2
\&    sysopen my $fh, "file.lock", O_WRONLY|O_EXCL|O_CREAT
\&        or die "can\*(Aqt open  file.lock: $!";
.Ve
.PP
except that lamentably, file creation (and deletion) is not atomic
over \s-1NFS\s0, so this won't work (at least, not every time) over the net.
Various schemes involving \fIlink()\fR have been suggested, but
these tend to involve busy-wait, which is also less than desirable.
.SS "I still don't get locking. I just want to increment the number in the file. How can I do this?"
.IX Xref "counter file, counter"
.IX Subsection "I still don't get locking. I just want to increment the number in the file. How can I do this?"
Didn't anyone ever tell you web-page hit counters were useless?
They don't count number of hits, they're a waste of time, and they serve
only to stroke the writer's vanity. It's better to pick a random number;
they're more realistic.
.PP
Anyway, this is what you can do if you can't help yourself.
.PP
.Vb 8
\&    use Fcntl qw(:DEFAULT :flock);
\&    sysopen my $fh, "numfile", O_RDWR|O_CREAT or die "can\*(Aqt open numfile: $!";
\&    flock $fh, LOCK_EX                        or die "can\*(Aqt flock numfile: $!";
\&    my $num = <$fh> || 0;
\&    seek $fh, 0, 0                            or die "can\*(Aqt rewind numfile: $!";
\&    truncate $fh, 0                           or die "can\*(Aqt truncate numfile: $!";
\&    (print $fh $num+1, "\en")                  or die "can\*(Aqt write numfile: $!";
\&    close $fh                                 or die "can\*(Aqt close numfile: $!";
.Ve
.PP
Here's a much better web-page hit counter:
.PP
.Vb 1
\&    $hits = int( (time() \- 850_000_000) / rand(1_000) );
.Ve
.PP
If the count doesn't impress your friends, then the code might. :\-)
.SS "All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?"
.IX Xref "append file, append"
.IX Subsection "All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?"
If you are on a system that correctly implements \f(CW\*(C`flock\*(C'\fR and you use
the example appending code from \*(L"perldoc \-f flock\*(R" everything will be
\&\s-1OK\s0 even if the \s-1OS\s0 you are on doesn't implement append mode correctly
(if such a system exists). So if you are happy to restrict yourself to
OSs that implement \f(CW\*(C`flock\*(C'\fR (and that's not really much of a
restriction) then that is what you should do.
.PP
If you know you are only going to use a system that does correctly
implement appending (i.e. not Win32) then you can omit the \f(CW\*(C`seek\*(C'\fR
from the code in the previous answer.
.PP
If you know you are only writing code to run on an \s-1OS\s0 and filesystem
that does implement append mode correctly (a local filesystem on a
modern Unix for example), and you keep the file in block-buffered mode
and you write less than one buffer-full of output between each manual
flushing of the buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else's output. You can also use the
\&\f(CW\*(C`syswrite\*(C'\fR function which is simply a wrapper around your system's
\&\f(CWwrite(2)\fR system call.
.PP
There is still a small theoretical chance that a signal will interrupt
the system-level \f(CW\*(C`write()\*(C'\fR operation before completion. There is also
a possibility that some \s-1STDIO\s0 implementations may call multiple system
level \f(CW\*(C`write()\*(C'\fRs even if the buffer was empty to start. There may be
some systems where this probability is reduced to zero, and this is
not a concern when using \f(CW\*(C`:perlio\*(C'\fR instead of your system's \s-1STDIO\s0.
.SS "How do I randomly update a binary file?"
.IX Xref "file, binary patch"
.IX Subsection "How do I randomly update a binary file?"
If you're just trying to patch a binary, in many cases something as
simple as this works:
.PP
.Vb 1
\&    perl \-i \-pe \*(Aqs{window manager}{window mangler}g\*(Aq /usr/bin/emacs
.Ve
.PP
However, if you have fixed sized records, then you might do something more
like this:
.PP
.Vb 9
\&    my $RECSIZE = 220; # size of record, in bytes
\&    my $recno   = 37;  # which record to update
\&    open my $fh, \*(Aq+<\*(Aq, \*(Aqsomewhere\*(Aq or die "can\*(Aqt update somewhere: $!";
\&    seek $fh, $recno * $RECSIZE, 0;
\&    read $fh, $record, $RECSIZE == $RECSIZE or die "can\*(Aqt read record $recno: $!";
\&    # munge the record
\&    seek $fh, \-$RECSIZE, 1;
\&    print $fh $record;
\&    close $fh;
.Ve
.PP
Locking and error checking are left as an exercise for the reader.
Don't forget them or you'll be quite sorry.
.SS "How do I get a file's timestamp in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How do I get a file's timestamp in perl?"
If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the \fB\-A\fR,
\&\fB\-M\fR, or \fB\-C\fR file test operations as documented in perlfunc.
These retrieve the age of the file (measured against the start-time of
your program) in days as a floating point number. Some platforms may
not have all of these times. See perlport for details. To retrieve
the \*(L"raw\*(R" time in seconds since the epoch, you would call the stat
function, then use \f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`gmtime()\*(C'\fR, or
\&\f(CW\*(C`POSIX::strftime()\*(C'\fR to convert this into human-readable form.
.PP
Here's an example:
.PP
.Vb 3
\&    my $write_secs = (stat($file))[9];
\&    printf "file %s updated at %s\en", $file,
\&        scalar localtime($write_secs);
.Ve
.PP
If you prefer something more legible, use the File::stat module
(part of the standard distribution in version 5.004 and later):
.PP
.Vb 5
\&    # error checking left as an exercise for reader.
\&    use File::stat;
\&    use Time::localtime;
\&    my $date_string = ctime(stat($file)\->mtime);
\&    print "file $file updated at $date_string\en";
.Ve
.PP
The \fIPOSIX::strftime()\fR approach has the benefit of being,
in theory, independent of the current locale. See perllocale
for details.
.SS "How do I set a file's timestamp in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How do I set a file's timestamp in perl?"
You use the \fIutime()\fR function documented in \*(L"utime\*(R" in perlfunc.
By way of example, here's a little program that copies the
read and write times from its first argument to all the rest
of them.
.PP
.Vb 6
\&    if (@ARGV < 2) {
\&        die "usage: cptimes timestamp_file other_files ...\en";
\&    }
\&    my $timestamp = shift;
\&    my($atime, $mtime) = (stat($timestamp))[8,9];
\&    utime $atime, $mtime, @ARGV;
.Ve
.PP
Error checking is, as usual, left as an exercise for the reader.
.PP
The perldoc for utime also has an example that has the same
effect as \fItouch\fR\|(1) on files that \fIalready exist\fR.
.PP
Certain file systems have a limited ability to store the times
on a file at the expected level of precision. For example, the
\&\s-1FAT\s0 and \s-1HPFS\s0 filesystem are unable to create dates on files with
a finer granularity than two seconds. This is a limitation of
the filesystems, not of \fIutime()\fR.
.SS "How do I print to more than one file at once?"
.IX Xref "print, to multiple files"
.IX Subsection "How do I print to more than one file at once?"
To connect one filehandle to several output filehandles,
you can use the IO::Tee or Tie::FileHandle::Multiplex modules.
.PP
If you only have to do this once, you can print individually
to each filehandle.
.PP
.Vb 1
\&    for my $fh ($fh1, $fh2, $fh3) { print $fh "whatever\en" }
.Ve
.SS "How can I read in an entire file all at once?"
.IX Xref "slurp file, slurping"
.IX Subsection "How can I read in an entire file all at once?"
The customary Perl approach for processing all the lines in a file is to
do so one line at a time:
.PP
.Vb 6
\&    open my $input, \*(Aq<\*(Aq, $file or die "can\*(Aqt open $file: $!";
\&    while (<$input>) {
\&        chomp;
\&        # do something with $_
\&    }
\&    close $input or die "can\*(Aqt close $file: $!";
.Ve
.PP
This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often\*(--if not almost always\*(--the wrong approach. Whenever
you see someone do this:
.PP
.Vb 1
\&    my @lines = <INPUT>;
.Ve
.PP
You should think long and hard about why you need everything loaded at
once. It's just not a scalable solution.
.PP
If you \*(L"mmap\*(R" the file with the File::Map module from
\&\s-1CPAN\s0, you can virtually load the entire file into a
string without actually storing it in memory:
.PP
.Vb 1
\&    use File::Map qw(map_file);
\&
\&    map_file my $string, $filename;
.Ve
.PP
Once mapped, you can treat \f(CW$string\fR as you would any other string.
Since you don't necessarily have to load the data, mmap-ing can be
very fast and may not increase your memory footprint.
.PP
You might also find it more
fun to use the standard Tie::File module, or the DB_File module's
\&\f(CW$DB_RECNO\fR bindings, which allow you to tie an array to a file so that
accessing an element of the array actually accesses the corresponding
line in the file.
.PP
If you want to load the entire file, you can use the File::Slurp
module to do it in one one simple and efficient step:
.PP
.Vb 1
\&    use File::Slurp;
\&
\&    my $all_of_it = read_file($filename); # entire file in scalar
\&    my @all_lines = read_file($filename); # one line per element
.Ve
.PP
Or you can read the entire file contents into a scalar like this:
.PP
.Vb 6
\&    my $var;
\&    {
\&        local $/;
\&        open my $fh, \*(Aq<\*(Aq, $file or die "can\*(Aqt open $file: $!";
\&        $var = <$fh>;
\&    }
.Ve
.PP
That temporarily undefs your record separator, and will automatically
close the file at block exit. If the file is already open, just use this:
.PP
.Vb 1
\&    my $var = do { local $/; <$fh> };
.Ve
.PP
You can also use a localized \f(CW@ARGV\fR to eliminate the \f(CW\*(C`open\*(C'\fR:
.PP
.Vb 1
\&    my $var = do { local( @ARGV, $/ ) = $file; <> };
.Ve
.PP
For ordinary files you can also use the \f(CW\*(C`read\*(C'\fR function.
.PP
.Vb 1
\&    read( $fh, $var, \-s $fh );
.Ve
.PP
That third argument tests the byte size of the data on the \f(CW$fh\fR filehandle
and reads that many bytes into the buffer \f(CW$var\fR.
.SS "How can I read in a file by paragraphs?"
.IX Xref "file, reading by paragraphs"
.IX Subsection "How can I read in a file by paragraphs?"
Use the \f(CW$/\fR variable (see perlvar for details). You can either
set it to \f(CW""\fR to eliminate empty paragraphs (\f(CW"abc\en\en\en\endef"\fR,
for instance, gets treated as two paragraphs and not three), or
\&\f(CW"\en\en"\fR to accept empty paragraphs.
.PP
Note that a blank line must have no blanks in it. Thus
\&\f(CW"fred\en\ \enstuff\en\en"\fR is one paragraph, but \f(CW"fred\en\enstuff\en\en"\fR is two.
.SS "How can I read a single character from a file? From the keyboard?"
.IX Xref "getc file, reading one character at a time"
.IX Subsection "How can I read a single character from a file? From the keyboard?"
You can use the builtin \f(CW\*(C`getc()\*(C'\fR function for most filehandles, but
it won't (easily) work on a terminal device. For \s-1STDIN\s0, either use
the Term::ReadKey module from \s-1CPAN\s0 or use the sample code in
\&\*(L"getc\*(R" in perlfunc.
.PP
If your system supports the portable operating system programming
interface (\s-1POSIX\s0), you can use the following code, which you'll note
turns off echo processing as well.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    $| = 1;
\&    for (1..4) {
\&        print "gimme: ";
\&        my $got = getone();
\&        print "\-\-> $got\en";
\&    }
\&    exit;
\&
\&    BEGIN {
\&        use POSIX qw(:termios_h);
\&
\&        my ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&        my $fd_stdin = fileno(STDIN);
\&
\&        $term     = POSIX::Termios\->new();
\&        $term\->getattr($fd_stdin);
\&        $oterm     = $term\->getlflag();
\&
\&        $echo     = ECHO | ECHOK | ICANON;
\&        $noecho   = $oterm & ~$echo;
\&
\&        sub cbreak {
\&            $term\->setlflag($noecho);
\&            $term\->setcc(VTIME, 1);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub cooked {
\&            $term\->setlflag($oterm);
\&            $term\->setcc(VTIME, 0);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub getone {
\&            my $key = \*(Aq\*(Aq;
\&            cbreak();
\&            sysread(STDIN, $key, 1);
\&            cooked();
\&            return $key;
\&        }
\&    }
\&
\&    END { cooked() }
.Ve
.PP
The Term::ReadKey module from \s-1CPAN\s0 may be easier to use. Recent versions
include also support for non-portable systems as well.
.PP
.Vb 8
\&    use Term::ReadKey;
\&    open my $tty, \*(Aq<\*(Aq, \*(Aq/dev/tty\*(Aq;
\&    print "Gimme a char: ";
\&    ReadMode "raw";
\&    my $key = ReadKey 0, $tty;
\&    ReadMode "normal";
\&    printf "\enYou said %s, char number %03d\en",
\&        $key, ord $key;
.Ve
.SS "How can I tell whether there's a character waiting on a filehandle?"
.IX Subsection "How can I tell whether there's a character waiting on a filehandle?"
The very first thing you should do is look into getting the Term::ReadKey
extension from \s-1CPAN\s0. As we mentioned earlier, it now even has limited
support for non-portable (read: not open systems, closed, proprietary,
not \s-1POSIX\s0, not Unix, etc.) systems.
.PP
You should also check out the Frequently Asked Questions list in
comp.unix.* for things like this: the answer is essentially the same.
It's very system-dependent. Here's one solution that works on \s-1BSD\s0
systems:
.PP
.Vb 5
\&    sub key_ready {
\&        my($rin, $nfd);
\&        vec($rin, fileno(STDIN), 1) = 1;
\&        return $nfd = select($rin,undef,undef,0);
\&    }
.Ve
.PP
If you want to find out how many characters are waiting, there's
also the \s-1FIONREAD\s0 ioctl call to be looked at. The \fIh2ph\fR tool that
comes with Perl tries to convert C include files to Perl code, which
can be \f(CW\*(C`require\*(C'\fRd. \s-1FIONREAD\s0 ends up defined as a function in the
\&\fIsys/ioctl.ph\fR file:
.PP
.Vb 1
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, FIONREAD(), $size)    or die "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
If \fIh2ph\fR wasn't installed or doesn't work for you, you can
\&\fIgrep\fR the include files by hand:
.PP
.Vb 2
\&    % grep FIONREAD /usr/include/*/*
\&    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
.Ve
.PP
Or write a small C program using the editor of champions:
.PP
.Vb 9
\&    % cat > fionread.c
\&    #include <sys/ioctl.h>
\&    main() {
\&        printf("%#08x\en", FIONREAD);
\&    }
\&    ^D
\&    % cc \-o fionread fionread.c
\&    % ./fionread
\&    0x4004667f
.Ve
.PP
And then hard-code it, leaving porting as an exercise to your successor.
.PP
.Vb 1
\&    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, $FIONREAD, $size)     or die "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
\&\s-1FIONREAD\s0 requires a filehandle connected to a stream, meaning that sockets,
pipes, and tty devices work, but \fInot\fR files.
.ie n .SS "How do I do a ""tail \-f"" in perl?"
.el .SS "How do I do a \f(CWtail \-f\fP in perl?"
.IX Xref "tail IO::Handle File::Tail clearerr"
.IX Subsection "How do I do a tail -f in perl?"
First try
.PP
.Vb 1
\&    seek($gw_fh, 0, 1);
.Ve
.PP
The statement \f(CW\*(C`seek($gw_fh, 0, 1)\*(C'\fR doesn't change the current position,
but it does clear the end-of-file condition on the handle, so that the
next \f(CW\*(C`<$gw_fh>\*(C'\fR makes Perl try again to read something.
.PP
If that doesn't work (it relies on features of your stdio implementation),
then you need something more like this:
.PP
.Vb 7
\&    for (;;) {
\&      for ($curpos = tell($gw_fh); <$gw_fh>; $curpos =tell($gw_fh)) {
\&        # search for some stuff and put it into files
\&      }
\&      # sleep for a while
\&      seek($gw_fh, $curpos, 0);  # seek to where we had been
\&    }
.Ve
.PP
If this still doesn't work, look into the \f(CW\*(C`clearerr\*(C'\fR method
from IO::Handle, which resets the error and end-of-file states
on the handle.
.PP
There's also a File::Tail module from \s-1CPAN\s0.
.SS "How do I \fIdup()\fP a filehandle in Perl?"
.IX Xref "dup"
.IX Subsection "How do I dup() a filehandle in Perl?"
If you check \*(L"open\*(R" in perlfunc, you'll see that several of the ways
to call \fIopen()\fR should do the trick. For example:
.PP
.Vb 2
\&    open my $log, \*(Aq>>\*(Aq, \*(Aq/foo/logfile\*(Aq;
\&    open STDERR, \*(Aq>&\*(Aq, $log;
.Ve
.PP
Or even with a literal numeric descriptor:
.PP
.Vb 2
\&    my $fd = $ENV{MHCONTEXTFD};
\&    open $mhcontext, "<&=$fd";  # like fdopen(3S)
.Ve
.PP
Note that \*(L"<&STDIN\*(R" makes a copy, but \*(L"<&=STDIN\*(R" makes
an alias. That means if you close an aliased handle, all
aliases become inaccessible. This is not true with
a copied one.
.PP
Error checking, as always, has been left as an exercise for the reader.
.SS "How do I close a file descriptor by number?"
.IX Xref "file, closing file descriptors POSIX close"
.IX Subsection "How do I close a file descriptor by number?"
If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used \f(CW\*(C`POSIX::open\*(C'\fR), you can use the
\&\f(CW\*(C`close()\*(C'\fR function from the \s-1POSIX\s0 module:
.PP
.Vb 1
\&    use POSIX ();
\&
\&    POSIX::close( $fd );
.Ve
.PP
This should rarely be necessary, as the Perl \f(CW\*(C`close()\*(C'\fR function is to be
used for things that Perl opened itself, even if it was a dup of a
numeric descriptor as with \f(CW\*(C`MHCONTEXT\*(C'\fR above. But if you really have
to, you may be able to do this:
.PP
.Vb 3
\&    require \*(Aqsys/syscall.ph\*(Aq;
\&    my $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
\&    die "can\*(Aqt sysclose $fd: $!" unless $rc == \-1;
.Ve
.PP
Or, just use the fdopen(3S) feature of \f(CW\*(C`open()\*(C'\fR:
.PP
.Vb 4
\&    {
\&        open my $fh, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
\&        close $fh;
\&    }
.Ve
.ie n .SS "Why can't I use ""C:\etemp\efoo"" in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?"
.el .SS "Why can't I use ``C:\etemp\efoo'' in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?"
.IX Xref "filename, DOS issues"
.IX Subsection "Why can't I use C:tempfoo in DOS paths? Why doesn't `C:tempfoo.exe` work?"
Whoops!  You just put a tab and a formfeed into that filename!
Remember that within double quoted strings (\*(L"like\ethis\*(R"), the
backslash is an escape character. The full list of these is in
\&\*(L"Quote and Quote-like Operators\*(R" in perlop. Unsurprisingly, you don't
have a file called \*(L"c:(tab)emp(formfeed)oo\*(R" or
\&\*(L"c:(tab)emp(formfeed)oo.exe\*(R" on your legacy \s-1DOS\s0 filesystem.
.PP
Either single-quote your strings, or (preferably) use forward slashes.
Since all \s-1DOS\s0 and Windows versions since something like MS-DOS 2.0 or so
have treated \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`\e\*(C'\fR the same in a path, you might as well use the
one that doesn't clash with Perl\*(--or the \s-1POSIX\s0 shell, \s-1ANSI\s0 C and \*(C+,
awk, Tcl, Java, or Python, just to mention a few. \s-1POSIX\s0 paths
are more portable, too.
.ie n .SS "Why doesn't glob(""*.*"") get all the files?"
.el .SS "Why doesn't glob(``*.*'') get all the files?"
.IX Xref "glob"
.IX Subsection "Why doesn't glob(*.*) get all the files?"
Because even on non-Unix ports, Perl's glob function follows standard
Unix globbing semantics. You'll need \f(CW\*(C`glob("*")\*(C'\fR to get all (non-hidden)
files. This makes \fIglob()\fR portable even to legacy systems. Your
port may include proprietary globbing functions as well. Check its
documentation for details.
.ie n .SS "Why does Perl let me delete read-only files? Why does ""\-i"" clobber protected files? Isn't this a bug in Perl?"
.el .SS "Why does Perl let me delete read-only files? Why does \f(CW\-i\fP clobber protected files? Isn't this a bug in Perl?"
.IX Subsection "Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?"
This is elaborately and painstakingly described in the
\&\fIfile-dir-perms\fR article in the \*(L"Far More Than You Ever Wanted To
Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> .
.PP
The executive summary: learn how your filesystem works. The
permissions on a file say what can happen to the data in that file.
The permissions on a directory say what can happen to the list of
files in that directory. If you delete a file, you're removing its
name from the directory (so the operation depends on the permissions
of the directory, not of the file). If you try to write to the file,
the permissions of the file govern whether you're allowed to.
.SS "How do I select a random line from a file?"
.IX Xref "file, selecting a random line"
.IX Subsection "How do I select a random line from a file?"
Short of loading the file into a database or pre-indexing the lines in
the file, there are a couple of things that you can do.
.PP
Here's a reservoir-sampling algorithm from the Camel Book:
.PP
.Vb 2
\&    srand;
\&    rand($.) < 1 && ($line = $_) while <>;
.Ve
.PP
This has a significant advantage in space over reading the whole file
in. You can find a proof of this method in \fIThe Art of Computer
Programming\fR, Volume 2, Section 3.4.2, by Donald E. Knuth.
.PP
You can use the File::Random module which provides a function
for that algorithm:
.PP
.Vb 2
\&    use File::Random qw/random_line/;
\&    my $line = random_line($filename);
.Ve
.PP
Another way is to use the Tie::File module, which treats the entire
file as an array. Simply access a random array element.
.SS "Why do I get weird spaces when I print an array of lines?"
.IX Subsection "Why do I get weird spaces when I print an array of lines?"
(contributed by brian d foy)
.PP
If you are seeing spaces between the elements of your array when
you print the array, you are probably interpolating the array in
double quotes:
.PP
.Vb 2
\&    my @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: @animals\en";
.Ve
.PP
It's the double quotes, not the \f(CW\*(C`print\*(C'\fR, doing this. Whenever you
interpolate an array in a double quote context, Perl joins the
elements with spaces (or whatever is in \f(CW$"\fR, which is a space by
default):
.PP
.Vb 1
\&    animals are: camel llama alpaca vicuna
.Ve
.PP
This is different than printing the array without the interpolation:
.PP
.Vb 2
\&    my @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: ", @animals, "\en";
.Ve
.PP
Now the output doesn't have the spaces between the elements because
the elements of \f(CW@animals\fR simply become part of the list to
\&\f(CW\*(C`print\*(C'\fR:
.PP
.Vb 1
\&    animals are: camelllamaalpacavicuna
.Ve
.PP
You might notice this when each of the elements of \f(CW@array\fR end with
a newline. You expect to print one element per line, but notice that
every line after the first is indented:
.PP
.Vb 3
\&    this is a line
\&     this is another line
\&     this is the third line
.Ve
.PP
That extra space comes from the interpolation of the array. If you
don't want to put anything between your array elements, don't use the
array in double quotes. You can send it to print without them:
.PP
.Vb 1
\&    print @lines;
.Ve
.SS "How do I traverse a directory tree?"
.IX Subsection "How do I traverse a directory tree?"
(contributed by brian d foy)
.PP
The File::Find module, which comes with Perl, does all of the hard
work to traverse a directory structure. It comes with Perl. You simply
call the \f(CW\*(C`find\*(C'\fR subroutine with a callback subroutine and the
directories you want to traverse:
.PP
.Vb 1
\&    use File::Find;
\&
\&    find( \e&wanted, @directories );
\&
\&    sub wanted {
\&        # full path in $File::Find::name
\&        # just filename in $_
\&        ... do whatever you want to do ...
\&    }
.Ve
.PP
The File::Find::Closures, which you can download from \s-1CPAN\s0, provides
many ready-to-use subroutines that you can use with File::Find.
.PP
The File::Finder, which you can download from \s-1CPAN\s0, can help you
create the callback subroutine using something closer to the syntax of
the \f(CW\*(C`find\*(C'\fR command-line utility:
.PP
.Vb 2
\&    use File::Find;
\&    use File::Finder;
\&
\&    my $deep_dirs = File::Finder\->depth\->type(\*(Aqd\*(Aq)\->ls\->exec(\*(Aqrmdir\*(Aq,\*(Aq{}\*(Aq);
\&
\&    find( $deep_dirs\->as_options, @places );
.Ve
.PP
The File::Find::Rule module, which you can download from \s-1CPAN\s0, has
a similar interface, but does the traversal for you too:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    my @files = File::Find::Rule\->file()
\&                             \->name( \*(Aq*.pm\*(Aq )
\&                             \->in( @INC );
.Ve
.SS "How do I delete a directory tree?"
.IX Subsection "How do I delete a directory tree?"
(contributed by brian d foy)
.PP
If you have an empty directory, you can use Perl's built-in \f(CW\*(C`rmdir\*(C'\fR.
If the directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot of work) or use a module to
help you.
.PP
The File::Path module, which comes with Perl, has a \f(CW\*(C`remove_tree\*(C'\fR
which can take care of all of the hard work for you:
.PP
.Vb 1
\&    use File::Path qw(remove_tree);
\&
\&    remove_tree( @directories );
.Ve
.PP
The File::Path module also has a legacy interface to the older
\&\f(CW\*(C`rmtree\*(C'\fR subroutine.
.SS "How do I copy an entire directory?"
.IX Subsection "How do I copy an entire directory?"
(contributed by Shlomi Fish)
.PP
To do the equivalent of \f(CW\*(C`cp \-R\*(C'\fR (i.e. copy an entire directory tree
recursively) in portable Perl, you'll either need to write something yourself
or find a good \s-1CPAN\s0 module such as  File::Copy::Recursive.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq55.18.1                               0100644 0001750 0001750 00000206666 12566207437 023017  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ5 1"
.TH PERLFAQ5 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq5 \- Files and Formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with I/O and the \*(L"f\*(R" issues: filehandles, flushing,
formats, and footers.
.SS "How do I flush/unbuffer an output filehandle? Why must I do this?"
.IX Xref "flush buffer unbuffer autoflush"
.IX Subsection "How do I flush/unbuffer an output filehandle? Why must I do this?"
(contributed by brian d foy)
.PP
You might like to read Mark Jason Dominus's \*(L"Suffering From Buffering\*(R"
at <http://perl.plover.com/FAQs/Buffering.html> .
.PP
Perl normally buffers output so it doesn't make a system call for every
bit of output. By saving up output, it makes fewer expensive system calls.
For instance, in this little bit of code, you want to print a dot to the
screen for every line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the output and you
have a long wait before you see a row of 50 dots all at once:
.PP
.Vb 4
\&    # long wait, then row of dots all at once
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... expensive line processing operations
\&    }
.Ve
.PP
To get around this, you have to unbuffer the output filehandle, in this
case, \f(CW\*(C`STDOUT\*(C'\fR. You can set the special variable \f(CW$|\fR to a true value
(mnemonic: making your filehandles \*(L"piping hot\*(R"):
.PP
.Vb 1
\&    $|++;
\&
\&    # dot shown immediately
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... expensive line processing operations
\&    }
.Ve
.PP
The \f(CW$|\fR is one of the per-filehandle special variables, so each
filehandle has its own copy of its value. If you want to merge
standard output and standard error for instance, you have to unbuffer
each (although \s-1STDERR\s0 might be unbuffered by default):
.PP
.Vb 7
\&    {
\&        my $previous_default = select(STDOUT);  # save previous default
\&        $|++;                                   # autoflush STDOUT
\&        select(STDERR);
\&        $|++;                                   # autoflush STDERR, to be sure
\&        select($previous_default);              # restore previous default
\&    }
\&
\&    # now should alternate . and +
\&    while( 1 ) {
\&        sleep 1;
\&        print STDOUT ".";
\&        print STDERR "+";
\&        print STDOUT "\en" unless ++$count % 25;
\&    }
.Ve
.PP
Besides the \f(CW$|\fR special variable, you can use \f(CW\*(C`binmode\*(C'\fR to give
your filehandle a \f(CW\*(C`:unix\*(C'\fR layer, which is unbuffered:
.PP
.Vb 1
\&    binmode( STDOUT, ":unix" );
\&
\&    while( 1 ) {
\&        sleep 1;
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&    }
.Ve
.PP
For more information on output layers, see the entries for \f(CW\*(C`binmode\*(C'\fR
and open in perlfunc, and the PerlIO module documentation.
.PP
If you are using IO::Handle or one of its subclasses, you can
call the \f(CW\*(C`autoflush\*(C'\fR method to change the settings of the
filehandle:
.PP
.Vb 3
\&    use IO::Handle;
\&    open my( $io_fh ), ">", "output.txt";
\&    $io_fh\->autoflush(1);
.Ve
.PP
The IO::Handle objects also have a \f(CW\*(C`flush\*(C'\fR method. You can flush
the buffer any time you want without auto-buffering
.PP
.Vb 1
\&    $io_fh\->flush;
.Ve
.SS "How do I change, delete, or insert a line in a file, or append to the beginning of a file?"
.IX Xref "file, editing"
.IX Subsection "How do I change, delete, or insert a line in a file, or append to the beginning of a file?"
(contributed by brian d foy)
.PP
The basic idea of inserting, changing, or deleting a line from a text
file involves reading and printing the file to the point you want to
make the change, making the change, then reading and printing the rest
of the file. Perl doesn't provide random access to lines (especially
since the record input separator, \f(CW$/\fR, is mutable), although modules
such as Tie::File can fake it.
.PP
A Perl program to do these tasks takes the basic form of opening a
file, printing its lines, then closing the file:
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
Within that basic form, add the parts that you need to insert, change,
or delete lines.
.PP
To prepend lines to the beginning, print those lines before you enter
the loop that prints the existing lines.
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    print $out "# Add this line to the top\en"; # <\-\-\- HERE\*(AqS THE MAGIC
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To change existing lines, insert the code to modify the lines inside
the \f(CW\*(C`while\*(C'\fR loop. In this case, the code finds all lowercased
versions of \*(L"perl\*(R" and uppercases them. The happens for every line, so
be sure that you're supposed to do that on every line!
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!";
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    print $out "# Add this line to the top\en";
\&
\&    while( <$in> ) {
\&        s/\eb(perl)\eb/Perl/g;
\&        print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To change only a particular line, the input line number, \f(CW$.\fR, is
useful. First read and print the lines up to the one you  want to
change. Next, read the single line you want to change, change it, and
print it. After that, read the rest of the lines and print those:
.PP
.Vb 4
\&    while( <$in> ) { # print the lines before the change
\&        print $out $_;
\&        last if $. == 4; # line number before change
\&    }
\&
\&    my $line = <$in>;
\&    $line =~ s/\eb(perl)\eb/Perl/g;
\&    print $out $line;
\&
\&    while( <$in> ) { # print the rest of the lines
\&        print $out $_;
\&    }
.Ve
.PP
To skip lines, use the looping controls. The \f(CW\*(C`next\*(C'\fR in this example
skips comment lines, and the \f(CW\*(C`last\*(C'\fR stops all processing once it
encounters either \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.PP
.Vb 5
\&    while( <$in> ) {
\&        next if /^\es+#/;             # skip comment lines
\&        last if /^_\|_(END|DATA)_\|_$/;  # stop at end of code marker
\&        print $out $_;
\&    }
.Ve
.PP
Do the same sort of thing to delete a particular line by using \f(CW\*(C`next\*(C'\fR
to skip the lines you don't want to show up in the output. This
example skips every fifth line:
.PP
.Vb 4
\&    while( <$in> ) {
\&        next unless $. % 5;
\&        print $out $_;
\&    }
.Ve
.PP
If, for some odd reason, you really want to see the whole file at once
rather than processing line-by-line, you can slurp it in (as long as
you can fit the whole thing in memory!):
.PP
.Vb 2
\&    open my $in,  \*(Aq<\*(Aq,  $file      or die "Can\*(Aqt read old file: $!"
\&    open my $out, \*(Aq>\*(Aq, "$file.new" or die "Can\*(Aqt write new file: $!";
\&
\&    my $content = do { local $/; <$in> }; # slurp!
\&
\&        # do your magic here
\&
\&    print $out $content;
.Ve
.PP
Modules such as File::Slurp and Tie::File can help with that
too. If you can, however, avoid reading the entire file at once. Perl
won't give that memory back to the operating system until the process
finishes.
.PP
You can also use Perl one-liners to modify a file in-place. The
following changes all 'Fred' to 'Barney' in \fIinFile.txt\fR, overwriting
the file with the new contents. With the \f(CW\*(C`\-p\*(C'\fR switch, Perl wraps a
\&\f(CW\*(C`while\*(C'\fR loop around the code you specify with \f(CW\*(C`\-e\*(C'\fR, and \f(CW\*(C`\-i\*(C'\fR turns
on in-place editing. The current line is in \f(CW$_\fR. With \f(CW\*(C`\-p\*(C'\fR, Perl
automatically prints the value of \f(CW$_\fR at the end of the loop. See
perlrun for more details.
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To make a backup of \f(CW\*(C`inFile.txt\*(C'\fR, give \f(CW\*(C`\-i\*(C'\fR a file extension to add:
.PP
.Vb 1
\&    perl \-pi.bak \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To change only the fifth line, you can add a test checking \f(CW$.\fR, the
input line number, then only perform the operation when the test
passes:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/ if $. == 5\*(Aq inFile.txt
.Ve
.PP
To add lines before a certain line, you can add a line (or lines!)
before Perl prints \f(CW$_\fR:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before third line\en" if $. == 3\*(Aq inFile.txt
.Ve
.PP
You can even add a line to the beginning of a file, since the current
line prints at the end of the loop:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before first line\en" if $. == 1\*(Aq inFile.txt
.Ve
.PP
To insert a line after one already in the file, use the \f(CW\*(C`\-n\*(C'\fR switch.
It's just like \f(CW\*(C`\-p\*(C'\fR except that it doesn't print \f(CW$_\fR at the end of
the loop, so you have to do that yourself. In this case, print \f(CW$_\fR
first, then print the line that you want to add.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint; print "Put after fifth line\en" if $. == 5\*(Aq inFile.txt
.Ve
.PP
To delete lines, only print the ones that you want.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint if /d/\*(Aq inFile.txt
.Ve
.SS "How do I count the number of lines in a file?"
.IX Xref "file, counting lines lines line"
.IX Subsection "How do I count the number of lines in a file?"
(contributed by brian d foy)
.PP
Conceptually, the easiest way to count the lines in a file is to
simply read them and count them:
.PP
.Vb 2
\&    my $count = 0;
\&    while( <$fh> ) { $count++; }
.Ve
.PP
You don't really have to count them yourself, though, since Perl
already does that with the \f(CW$.\fR variable, which is the current line
number from the last filehandle read:
.PP
.Vb 2
\&    1 while( <$fh> );
\&    my $count = $.;
.Ve
.PP
If you want to use \f(CW$.\fR, you can reduce it to a simple one-liner,
like one of these:
.PP
.Vb 1
\&    % perl \-lne \*(Aq} print $.; {\*(Aq    file
\&
\&    % perl \-lne \*(AqEND { print $. }\*(Aq file
.Ve
.PP
Those can be rather inefficient though. If they aren't fast enough for
you, you might just read chunks of data and count the number of
newlines:
.PP
.Vb 6
\&    my $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or die "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ tr/\en// );
\&    }
\&    close FILE;
.Ve
.PP
However, that doesn't work if the line ending isn't a newline. You
might change that \f(CW\*(C`tr///\*(C'\fR to a \f(CW\*(C`s///\*(C'\fR so you can count the number of
times the input record separator, \f(CW$/\fR, shows up:
.PP
.Vb 6
\&    my $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or die "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ s|$/||g; );
\&    }
\&    close FILE;
.Ve
.PP
If you don't mind shelling out, the \f(CW\*(C`wc\*(C'\fR command is usually the
fastest, even with the extra interprocess overhead. Ensure that you
have an untainted filename though:
.PP
.Vb 1
\&    #!perl \-T
\&
\&    $ENV{PATH} = undef;
\&
\&    my $lines;
\&    if( $filename =~ /^([0\-9a\-z_.]+)\ez/ ) {
\&        $lines = \`/usr/bin/wc \-l $1\`
\&        chomp $lines;
\&    }
.Ve
.SS "How do I delete the last N lines from a file?"
.IX Xref "lines file"
.IX Subsection "How do I delete the last N lines from a file?"
(contributed by brian d foy)
.PP
The easiest conceptual solution is to count the lines in the
file then start at the beginning and print the number of lines
(minus the last N) to a new file.
.PP
Most often, the real question is how you can delete the last N lines
without making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard reality when
you might have millions of lines in your file.
.PP
One trick is to use File::ReadBackwards, which starts at the end of
the file. That module provides an object that wraps the real filehandle
to make it easy for you to move around the file. Once you get to the
spot you need, you can get the actual filehandle and work with it as
normal. In this case, you get the file position at the end of the last
line you want to keep and truncate the file to that point:
.PP
.Vb 1
\&    use File::ReadBackwards;
\&
\&    my $filename = \*(Aqtest.txt\*(Aq;
\&    my $Lines_to_truncate = 2;
\&
\&    my $bw = File::ReadBackwards\->new( $filename )
\&        or die "Could not read backwards in [$filename]: $!";
\&
\&    my $lines_from_end = 0;
\&    until( $bw\->eof or $lines_from_end == $Lines_to_truncate ) {
\&        print "Got: ", $bw\->readline;
\&        $lines_from_end++;
\&    }
\&
\&    truncate( $filename, $bw\->tell );
.Ve
.PP
The File::ReadBackwards module also has the advantage of setting
the input record separator to a regular expression.
.PP
You can also use the Tie::File module which lets you access
the lines through a tied array. You can use normal array operations
to modify your file, including setting the last index and using
\&\f(CW\*(C`splice\*(C'\fR.
.ie n .SS "How can I use Perl's ""\-i"" option from within a program?"
.el .SS "How can I use Perl's \f(CW\-i\fP option from within a program?"
.IX Xref "-i in-place"
.IX Subsection "How can I use Perl's -i option from within a program?"
\&\f(CW\*(C`\-i\*(C'\fR sets the value of Perl's \f(CW$^I\fR variable, which in turn affects
the behavior of \f(CW\*(C`<>\*(C'\fR; see perlrun for more details. By
modifying the appropriate variables directly, you can get the same
behavior within a larger program. For example:
.PP
.Vb 10
\&    # ...
\&    {
\&        local($^I, @ARGV) = (\*(Aq.orig\*(Aq, glob("*.c"));
\&        while (<>) {
\&            if ($. == 1) {
\&                print "This line should appear at the top of each file\en";
\&            }
\&            s/\eb(p)earl\eb/${1}erl/i;        # Correct typos, preserving case
\&            print;
\&            close ARGV if eof;              # Reset $.
\&        }
\&    }
\&    # $^I and @ARGV return to their old values here
.Ve
.PP
This block modifies all the \f(CW\*(C`.c\*(C'\fR files in the current directory,
leaving a backup of the original data from each file in a new
\&\f(CW\*(C`.c.orig\*(C'\fR file.
.SS "How can I copy a file?"
.IX Xref "copy file, copy File::Copy"
.IX Subsection "How can I copy a file?"
(contributed by brian d foy)
.PP
Use the File::Copy module. It comes with Perl and can do a
true copy across file systems, and it does its magic in
a portable fashion.
.PP
.Vb 1
\&    use File::Copy;
\&
\&    copy( $original, $new_copy ) or die "Copy failed: $!";
.Ve
.PP
If you can't use File::Copy, you'll have to do the work yourself:
open the original file, open the destination file, then print
to the destination file as you read the original. You also have to
remember to copy the permissions, owner, and group to the new file.
.SS "How do I make a temporary file name?"
.IX Xref "file, temporary"
.IX Subsection "How do I make a temporary file name?"
If you don't need to know the name of the file, you can use \f(CW\*(C`open()\*(C'\fR
with \f(CW\*(C`undef\*(C'\fR in place of the file name. In Perl 5.8 or later, the
\&\f(CW\*(C`open()\*(C'\fR function creates an anonymous temporary file:
.PP
.Vb 1
\&    open my $tmp, \*(Aq+>\*(Aq, undef or die $!;
.Ve
.PP
Otherwise, you can use the File::Temp module.
.PP
.Vb 1
\&    use File::Temp qw/ tempfile tempdir /;
\&
\&    my $dir = tempdir( CLEANUP => 1 );
\&    ($fh, $filename) = tempfile( DIR => $dir );
\&
\&    # or if you don\*(Aqt need to know the filename
\&
\&    my $fh = tempfile( DIR => $dir );
.Ve
.PP
The File::Temp has been a standard module since Perl 5.6.1. If you
don't have a modern enough Perl installed, use the \f(CW\*(C`new_tmpfile\*(C'\fR
class method from the IO::File module to get a filehandle opened for
reading and writing. Use it if you don't need to know the file's name:
.PP
.Vb 3
\&    use IO::File;
\&    my $fh = IO::File\->new_tmpfile()
\&        or die "Unable to make new temporary file: $!";
.Ve
.PP
If you're committed to creating a temporary file by hand, use the
process \s-1ID\s0 and/or the current time-value. If you need to have many
temporary files in one process, use a counter:
.PP
.Vb 4
\&    BEGIN {
\&        use Fcntl;
\&        my $temp_dir = \-d \*(Aq/tmp\*(Aq ? \*(Aq/tmp\*(Aq : $ENV{TMPDIR} || $ENV{TEMP};
\&        my $base_name = sprintf "%s/%d\-%d\-0000", $temp_dir, $$, time;
\&
\&        sub temp_file {
\&            my $fh;
\&            my $count = 0;
\&            until( defined(fileno($fh)) || $count++ > 100 ) {
\&                $base_name =~ s/\-(\ed+)$/"\-" . (1 + $1)/e;
\&                # O_EXCL is required for security reasons.
\&                sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT;
\&            }
\&
\&            if( defined fileno($fh) ) {
\&                return ($fh, $base_name);
\&            }
\&            else {
\&                return ();
\&            }
\&        }
\&    }
.Ve
.SS "How can I manipulate fixed-record-length files?"
.IX Xref "fixed-length file, fixed-length records"
.IX Subsection "How can I manipulate fixed-record-length files?"
The most efficient way is using \fIpack()\fR and
\&\fIunpack()\fR. This is faster than using
\&\fIsubstr()\fR when taking many, many strings. It is
slower for just a few.
.PP
Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:
.PP
.Vb 10
\&    # sample input line:
\&    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now\-what
\&    my $PS_T = \*(AqA6 A4 A7 A5 A*\*(Aq;
\&    open my $ps, \*(Aq\-|\*(Aq, \*(Aqps\*(Aq;
\&    print scalar <$ps>;
\&    my @fields = qw( pid tt stat time command );
\&    while (<$ps>) {
\&        my %process;
\&        @process{@fields} = unpack($PS_T, $_);
\&        for my $field ( @fields ) {
\&            print "$field: <$process{$field}>\en";
\&        }
\&        print \*(Aqline=\*(Aq, pack($PS_T, @process{@fields} ), "\en";
\&    }
.Ve
.PP
We've used a hash slice in order to easily handle the fields of each row.
Storing the keys in an array makes it easy to operate on them as a
group or loop over them with \f(CW\*(C`for\*(C'\fR. It also avoids polluting the program
with global variables and using symbolic references.
.SS "How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?"
.IX Xref "filehandle, local filehandle, passing filehandle, reference"
.IX Subsection "How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?"
As of perl5.6, \fIopen()\fR autovivifies file and directory handles
as references if you pass it an uninitialized scalar variable.
You can then pass these references just like any other scalar,
and use them in the place of named handles.
.PP
.Vb 1
\&    open my    $fh, $file_name;
\&
\&    open local $fh, $file_name;
\&
\&    print $fh "Hello World!\en";
\&
\&    process_file( $fh );
.Ve
.PP
If you like, you can store these filehandles in an array or a hash.
If you access them directly, they aren't simple scalars and you
need to give \f(CW\*(C`print\*(C'\fR a little help by placing the filehandle
reference in braces. Perl can only figure it out on its own when
the filehandle reference is a simple scalar.
.PP
.Vb 1
\&    my @fhs = ( $fh1, $fh2, $fh3 );
\&
\&    for( $i = 0; $i <= $#fhs; $i++ ) {
\&        print {$fhs[$i]} "just another Perl answer, \en";
\&    }
.Ve
.PP
Before perl5.6, you had to deal with various typeglob idioms
which you may see in older code.
.PP
.Vb 3
\&    open FILE, "> $filename";
\&    process_typeglob(   *FILE );
\&    process_reference( \e*FILE );
\&
\&    sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
\&    sub process_reference { local $fh = shift; print $fh "Reference!" }
.Ve
.PP
If you want to create many anonymous handles, you should
check out the Symbol or IO::Handle modules.
.SS "How can I use a filehandle indirectly?"
.IX Xref "filehandle, indirect"
.IX Subsection "How can I use a filehandle indirectly?"
An indirect filehandle is the use of something other than a symbol
in a place that a filehandle is expected. Here are ways
to get indirect filehandles:
.PP
.Vb 5
\&    $fh =   SOME_FH;       # bareword is strict\-subs hostile
\&    $fh =  "SOME_FH";      # strict\-refs hostile; same package only
\&    $fh =  *SOME_FH;       # typeglob
\&    $fh = \e*SOME_FH;       # ref to typeglob (bless\-able)
\&    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
.Ve
.PP
Or, you can use the \f(CW\*(C`new\*(C'\fR method from one of the IO::* modules to
create an anonymous filehandle and store that in a scalar variable.
.PP
.Vb 2
\&    use IO::Handle;                     # 5.004 or higher
\&    my $fh = IO::Handle\->new();
.Ve
.PP
Then use any of those as you would a normal filehandle. Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains
a filehandle. Functions like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, or
the \f(CW\*(C`<FH>\*(C'\fR diamond operator will accept either a named filehandle
or a scalar variable containing one:
.PP
.Vb 4
\&    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
\&    print $ofh "Type it: ";
\&    my $got = <$ifh>
\&    print $efh "What was that: $got";
.Ve
.PP
If you're passing a filehandle to a function, you can write
the function in two ways:
.PP
.Vb 4
\&    sub accept_fh {
\&        my $fh = shift;
\&        print $fh "Sending to indirect filehandle\en";
\&    }
.Ve
.PP
Or it can localize a typeglob and use the filehandle directly:
.PP
.Vb 4
\&    sub accept_fh {
\&        local *FH = shift;
\&        print  FH "Sending to localized filehandle\en";
\&    }
.Ve
.PP
Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this
is risky.)
.PP
.Vb 2
\&    accept_fh(*STDOUT);
\&    accept_fh($handle);
.Ve
.PP
In the examples above, we assigned the filehandle to a scalar variable
before using it. That is because only simple scalar variables, not
expressions or subscripts of hashes or arrays, can be used with
built-ins like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, or the diamond operator. Using
something other than a simple scalar variable as a filehandle is
illegal and won't even compile:
.PP
.Vb 4
\&    my @fd = (*STDIN, *STDOUT, *STDERR);
\&    print $fd[1] "Type it: ";                           # WRONG
\&    my $got = <$fd[0]>                                  # WRONG
\&    print $fd[2] "What was that: $got";                 # WRONG
.Ve
.PP
With \f(CW\*(C`print\*(C'\fR and \f(CW\*(C`printf\*(C'\fR, you get around this by using a block and
an expression where you would place the filehandle:
.PP
.Vb 3
\&    print  { $fd[1] } "funny stuff\en";
\&    printf { $fd[1] } "Pity the poor %x.\en", 3_735_928_559;
\&    # Pity the poor deadbeef.
.Ve
.PP
That block is a proper block like any other, so you can put more
complicated code there. This sends the message out to one of two places:
.PP
.Vb 3
\&    my $ok = \-x "/bin/cat";
\&    print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\en";
\&    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\en";
.Ve
.PP
This approach of treating \f(CW\*(C`print\*(C'\fR and \f(CW\*(C`printf\*(C'\fR like object methods
calls doesn't work for the diamond operator. That's because it's a
real operator, not just a function with a comma-less argument. Assuming
you've been storing typeglobs in your structure as we did above, you
can use the built-in function named \f(CW\*(C`readline\*(C'\fR to read a record just
as \f(CW\*(C`<>\*(C'\fR does. Given the initialization shown above for \f(CW@fd\fR, this
would work, but only because \fIreadline()\fR requires a typeglob. It doesn't
work with objects or strings, which might be a bug we haven't fixed yet.
.PP
.Vb 1
\&    $got = readline($fd[0]);
.Ve
.PP
Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators. Playing the object
game doesn't help you at all here.
.SS "How can I set up a footer format to be used with \fIwrite()\fP?"
.IX Xref "footer"
.IX Subsection "How can I set up a footer format to be used with write()?"
There's no builtin way to do this, but perlform has a couple of
techniques to make it possible for the intrepid hacker.
.SS "How can I \fIwrite()\fP into a string?"
.IX Xref "write, into a string"
.IX Subsection "How can I write() into a string?"
(contributed by brian d foy)
.PP
If you want to \f(CW\*(C`write\*(C'\fR into a string, you just have to <open> a
filehandle to a string, which Perl has been able to do since Perl 5.6:
.PP
.Vb 2
\&    open FH, \*(Aq>\*(Aq, \emy $string;
\&    write( FH );
.Ve
.PP
Since you want to be a good programmer, you probably want to use a lexical
filehandle, even though formats are designed to work with bareword filehandles
since the default format names take the filehandle name. However, you can
control this with some Perl special per-filehandle variables: \f(CW$^\fR, which
names the top-of-page format, and \f(CW$~\fR which shows the line format. You have
to change the default filehandle to set these variables:
.PP
.Vb 1
\&    open my($fh), \*(Aq>\*(Aq, \emy $string;
\&
\&    { # set per\-filehandle variables
\&        my $old_fh = select( $fh );
\&        $~ = \*(AqANIMAL\*(Aq;
\&        $^ = \*(AqANIMAL_TOP\*(Aq;
\&        select( $old_fh );
\&    }
\&
\&    format ANIMAL_TOP =
\&     ID  Type    Name
\&    .
\&
\&    format ANIMAL =
\&    @##   @<<<    @<<<<<<<<<<<<<<
\&    $id,  $type,  $name
\&    .
.Ve
.PP
Although write can work with lexical or package variables, whatever variables
you use have to scope in the format. That most likely means you'll want to
localize some package variables:
.PP
.Vb 4
\&    {
\&        local( $id, $type, $name ) = qw( 12 cat Buster );
\&        write( $fh );
\&    }
\&
\&    print $string;
.Ve
.PP
There are also some tricks that you can play with \f(CW\*(C`formline\*(C'\fR and the
accumulator variable \f(CW$^A\fR, but you lose a lot of the value of formats
since \f(CW\*(C`formline\*(C'\fR won't handle paging and so on. You end up reimplementing
formats when you use them.
.SS "How can I open a filehandle to a string?"
.IX Xref "string open IO::String filehandle"
.IX Subsection "How can I open a filehandle to a string?"
(contributed by Peter J. Holzer, hjp\-usenet2@hjp.at)
.PP
Since Perl 5.8.0 a file handle referring to a string can be created by
calling open with a reference to that string instead of the filename.
This file handle can then be used to read from or write to the string:
.PP
.Vb 3
\&    open(my $fh, \*(Aq>\*(Aq, \e$string) or die "Could not open string for writing";
\&    print $fh "foo\en";
\&    print $fh "bar\en";    # $string now contains "foo\enbar\en"
\&
\&    open(my $fh, \*(Aq<\*(Aq, \e$string) or die "Could not open string for reading";
\&    my $x = <$fh>;    # $x now contains "foo\en"
.Ve
.PP
With older versions of Perl, the IO::String module provides similar
functionality.
.SS "How can I output my numbers with commas added?"
.IX Xref "number, commify"
.IX Subsection "How can I output my numbers with commas added?"
(contributed by brian d foy and Benjamin Goldberg)
.PP
You can use Number::Format to separate places in a number.
It handles locale information for those of you who want to insert
full stops instead (or anything else that they want to use,
really).
.PP
This subroutine will add commas to your number:
.PP
.Vb 5
\&    sub commify {
\&        local $_  = shift;
\&        1 while s/^([\-+]?\ed+)(\ed{3})/$1,$2/;
\&        return $_;
\&    }
.Ve
.PP
This regex from Benjamin Goldberg will add commas to numbers:
.PP
.Vb 1
\&    s/(^[\-+]?\ed+?(?=(?>(?:\ed{3})+)(?!\ed))|\eG\ed{3}(?=\ed))/$1,/g;
.Ve
.PP
It is easier to see with comments:
.PP
.Vb 11
\&    s/(
\&        ^[\-+]?             # beginning of number.
\&        \ed+?               # first digits before first comma
\&        (?=                # followed by, (but not included in the match) :
\&            (?>(?:\ed{3})+) # some positive multiple of three digits.
\&            (?!\ed)         # an *exact* multiple, not x * 3 + 1 or whatever.
\&        )
\&        |                  # or:
\&        \eG\ed{3}            # after the last group, get three digits
\&        (?=\ed)             # but they have to have more digits after them.
\&    )/$1,/xg;
.Ve
.SS "How can I translate tildes (~) in a filename?"
.IX Xref "tilde tilde expansion"
.IX Subsection "How can I translate tildes (~) in a filename?"
Use the <> (\f(CW\*(C`glob()\*(C'\fR) operator, documented in perlfunc.
Versions of Perl older than 5.6 require that you have a shell
installed that groks tildes. Later versions of Perl have this feature
built in. The File::KGlob module (available from \s-1CPAN\s0) gives more
portable glob functionality.
.PP
Within Perl, you may use this directly:
.PP
.Vb 11
\&    $filename =~ s{
\&      ^ ~             # find a leading tilde
\&      (               # save this in $1
\&          [^/]        # a non\-slash character
\&                *     # repeated 0 or more times (0 means me)
\&      )
\&    }{
\&      $1
\&          ? (getpwnam($1))[7]
\&          : ( $ENV{HOME} || $ENV{LOGDIR} )
\&    }ex;
.Ve
.SS "How come when I open a file read-write it wipes it out?"
.IX Xref "clobber read-write clobbering truncate truncating"
.IX Subsection "How come when I open a file read-write it wipes it out?"
Because you're using something like this, which truncates the file
\&\fIthen\fR gives you read-write access:
.PP
.Vb 1
\&    open my $fh, \*(Aq+>\*(Aq, \*(Aq/path/name\*(Aq; # WRONG (almost always)
.Ve
.PP
Whoops. You should instead use this, which will fail if the file
doesn't exist:
.PP
.Vb 1
\&    open my $fh, \*(Aq+<\*(Aq, \*(Aq/path/name\*(Aq; # open for update
.Ve
.PP
Using \*(L">\*(R" always clobbers or creates. Using \*(L"<\*(R" never does
either. The \*(L"+\*(R" doesn't change this.
.PP
Here are examples of many kinds of file opens. Those using \f(CW\*(C`sysopen\*(C'\fR
all assume that you've pulled in the constants from Fcntl:
.PP
.Vb 1
\&    use Fcntl;
.Ve
.PP
To open file for reading:
.PP
.Vb 2
\&    open my $fh, \*(Aq<\*(Aq, $path                               or die $!;
\&    sysopen my $fh, $path, O_RDONLY                       or die $!;
.Ve
.PP
To open file for writing, create new file if needed or else truncate old file:
.PP
.Vb 3
\&    open my $fh, \*(Aq>\*(Aq, $path                               or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT       or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die $!;
.Ve
.PP
To open file for writing, create new file, file must not exist:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT        or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666  or die $!;
.Ve
.PP
To open file for appending, create if necessary:
.PP
.Vb 3
\&    open my $fh, \*(Aq>>\*(Aq $path                               or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT      or die $!;
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or die $!;
.Ve
.PP
To open file for appending, file must exist:
.PP
.Vb 1
\&    sysopen my $fh, $path, O_WRONLY|O_APPEND              or die $!;
.Ve
.PP
To open file for update, file must exist:
.PP
.Vb 2
\&    open my $fh, \*(Aq+<\*(Aq, $path                              or die $!;
\&    sysopen my $fh, $path, O_RDWR                         or die $!;
.Ve
.PP
To open file for update, create file if necessary:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_RDWR|O_CREAT                 or die $!;
\&    sysopen my $fh, $path, O_RDWR|O_CREAT, 0666           or die $!;
.Ve
.PP
To open file for update, file must not exist:
.PP
.Vb 2
\&    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT          or die $!;
\&    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666    or die $!;
.Ve
.PP
To open a file without blocking, creating if necessary:
.PP
.Vb 2
\&    sysopen my $fh, \*(Aq/foo/somefile\*(Aq, O_WRONLY|O_NDELAY|O_CREAT
\&        or die "can\*(Aqt open /foo/somefile: $!":
.Ve
.PP
Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over \s-1NFS.\s0 That is, two processes might both
successfully create or unlink the same file! Therefore O_EXCL
isn't as exclusive as you might wish.
.PP
See also perlopentut.
.ie n .SS "Why do I sometimes get an ""Argument list too long"" when I use <*>?"
.el .SS "Why do I sometimes get an ``Argument list too long'' when I use <*>?"
.IX Xref "argument list too long"
.IX Subsection "Why do I sometimes get an Argument list too long when I use <*>?"
The \f(CW\*(C`<>\*(C'\fR operator performs a globbing operation (see above).
In Perl versions earlier than v5.6.0, the internal \fIglob()\fR operator forks
\&\fIcsh\fR\|(1) to do the actual glob expansion, but
csh can't handle more than 127 items and so gives the error message
\&\f(CW\*(C`Argument list too long\*(C'\fR. People who installed tcsh as csh won't
have this problem, but their users may be surprised by it.
.PP
To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with \fIreaddir()\fR and patterns, or use a module like File::Glob,
one that doesn't use the shell to do globbing.
.ie n .SS "How can I open a file with a leading "">"" or trailing blanks?"
.el .SS "How can I open a file with a leading ``>'' or trailing blanks?"
.IX Xref "filename, special characters"
.IX Subsection "How can I open a file with a leading > or trailing blanks?"
(contributed by Brian McCauley)
.PP
The special two-argument form of Perl's \fIopen()\fR function ignores
trailing blanks in filenames and infers the mode from certain leading
characters (or a trailing \*(L"|\*(R"). In older versions of Perl this was the
only version of \fIopen()\fR and so it is prevalent in old code and books.
.PP
Unless you have a particular reason to use the two-argument form you
should use the three-argument form of \fIopen()\fR which does not treat any
characters in the filename as special.
.PP
.Vb 2
\&    open my $fh, "<", "  file  ";  # filename is "   file   "
\&    open my $fh, ">", ">file";     # filename is ">file"
.Ve
.SS "How can I reliably rename a file?"
.IX Xref "rename mv move file, rename"
.IX Subsection "How can I reliably rename a file?"
If your operating system supports a proper \fImv\fR\|(1) utility or its
functional equivalent, this works:
.PP
.Vb 1
\&    rename($old, $new) or system("mv", $old, $new);
.Ve
.PP
It may be more portable to use the File::Copy module instead.
You just copy to the new file to the new name (checking return
values), then delete the old one. This isn't really the same
semantically as a \f(CW\*(C`rename()\*(C'\fR, which preserves meta-information like
permissions, timestamps, inode info, etc.
.SS "How can I lock a file?"
.IX Xref "lock file, lock flock"
.IX Subsection "How can I lock a file?"
Perl's builtin \fIflock()\fR function (see perlfunc for details) will call
\&\fIflock\fR\|(2) if that exists, \fIfcntl\fR\|(2) if it doesn't (on perl version 5.004 and
later), and \fIlockf\fR\|(3) if neither of the two previous system calls exists.
On some systems, it may even use a different form of native locking.
Here are some gotchas with Perl's \fIflock()\fR:
.IP "1." 4
Produces a fatal error if none of the three system calls (or their
close equivalent) exists.
.IP "2." 4
\&\fIlockf\fR\|(3) does not provide shared locking, and requires that the
filehandle be open for writing (or appending, or read/writing).
.IP "3." 4
Some versions of \fIflock()\fR can't lock files over a network (e.g. on \s-1NFS\s0 file
systems), so you'd need to force the use of \fIfcntl\fR\|(2) when you build Perl.
But even this is dubious at best. See the flock entry of perlfunc
and the \fI\s-1INSTALL\s0\fR file in the source distribution for information on
building Perl to do this.
.Sp
Two potentially non-obvious but traditional flock semantics are that
it waits indefinitely until the lock is granted, and that its locks are
\&\fImerely advisory\fR. Such discretionary locks are more flexible, but
offer fewer guarantees. This means that files locked with \fIflock()\fR may
be modified by programs that do not also use \fIflock()\fR. Cars that stop
for red lights get on well with each other, but not with cars that don't
stop for red lights. See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details. It's
best to assume traditional behavior if you're writing portable programs.
(If you're not, you should as always feel perfectly free to write
for your own system's idiosyncrasies (sometimes called \*(L"features\*(R").
Slavish adherence to portability concerns shouldn't get in the way of
your getting your job done.)
.Sp
For more information on file locking, see also
\&\*(L"File Locking\*(R" in perlopentut if you have it (new for 5.6).
.ie n .SS "Why can't I just open(\s-1FH, ""\s0>file.lock"")?"
.el .SS "Why can't I just open(\s-1FH, ``\s0>file.lock'')?"
.IX Xref "lock, lockfile race condition"
.IX Subsection "Why can't I just open(FH, >file.lock)?"
A common bit of code \fB\s-1NOT TO USE\s0\fR is this:
.PP
.Vb 2
\&    sleep(3) while \-e \*(Aqfile.lock\*(Aq;    # PLEASE DO NOT USE
\&    open my $lock, \*(Aq>\*(Aq, \*(Aqfile.lock\*(Aq; # THIS BROKEN CODE
.Ve
.PP
This is a classic race condition: you take two steps to do something
which must be done in one. That's why computer hardware provides an
atomic test-and-set instruction. In theory, this \*(L"ought\*(R" to work:
.PP
.Vb 2
\&    sysopen my $fh, "file.lock", O_WRONLY|O_EXCL|O_CREAT
\&        or die "can\*(Aqt open  file.lock: $!";
.Ve
.PP
except that lamentably, file creation (and deletion) is not atomic
over \s-1NFS,\s0 so this won't work (at least, not every time) over the net.
Various schemes involving \fIlink()\fR have been suggested, but
these tend to involve busy-wait, which is also less than desirable.
.SS "I still don't get locking. I just want to increment the number in the file. How can I do this?"
.IX Xref "counter file, counter"
.IX Subsection "I still don't get locking. I just want to increment the number in the file. How can I do this?"
Didn't anyone ever tell you web-page hit counters were useless?
They don't count number of hits, they're a waste of time, and they serve
only to stroke the writer's vanity. It's better to pick a random number;
they're more realistic.
.PP
Anyway, this is what you can do if you can't help yourself.
.PP
.Vb 8
\&    use Fcntl qw(:DEFAULT :flock);
\&    sysopen my $fh, "numfile", O_RDWR|O_CREAT or die "can\*(Aqt open numfile: $!";
\&    flock $fh, LOCK_EX                        or die "can\*(Aqt flock numfile: $!";
\&    my $num = <$fh> || 0;
\&    seek $fh, 0, 0                            or die "can\*(Aqt rewind numfile: $!";
\&    truncate $fh, 0                           or die "can\*(Aqt truncate numfile: $!";
\&    (print $fh $num+1, "\en")                  or die "can\*(Aqt write numfile: $!";
\&    close $fh                                 or die "can\*(Aqt close numfile: $!";
.Ve
.PP
Here's a much better web-page hit counter:
.PP
.Vb 1
\&    $hits = int( (time() \- 850_000_000) / rand(1_000) );
.Ve
.PP
If the count doesn't impress your friends, then the code might. :\-)
.SS "All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?"
.IX Xref "append file, append"
.IX Subsection "All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?"
If you are on a system that correctly implements \f(CW\*(C`flock\*(C'\fR and you use
the example appending code from \*(L"perldoc \-f flock\*(R" everything will be
\&\s-1OK\s0 even if the \s-1OS\s0 you are on doesn't implement append mode correctly
(if such a system exists). So if you are happy to restrict yourself to
OSs that implement \f(CW\*(C`flock\*(C'\fR (and that's not really much of a
restriction) then that is what you should do.
.PP
If you know you are only going to use a system that does correctly
implement appending (i.e. not Win32) then you can omit the \f(CW\*(C`seek\*(C'\fR
from the code in the previous answer.
.PP
If you know you are only writing code to run on an \s-1OS\s0 and filesystem
that does implement append mode correctly (a local filesystem on a
modern Unix for example), and you keep the file in block-buffered mode
and you write less than one buffer-full of output between each manual
flushing of the buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else's output. You can also use the
\&\f(CW\*(C`syswrite\*(C'\fR function which is simply a wrapper around your system's
\&\f(CWwrite(2)\fR system call.
.PP
There is still a small theoretical chance that a signal will interrupt
the system-level \f(CW\*(C`write()\*(C'\fR operation before completion. There is also
a possibility that some \s-1STDIO\s0 implementations may call multiple system
level \f(CW\*(C`write()\*(C'\fRs even if the buffer was empty to start. There may be
some systems where this probability is reduced to zero, and this is
not a concern when using \f(CW\*(C`:perlio\*(C'\fR instead of your system's \s-1STDIO.\s0
.SS "How do I randomly update a binary file?"
.IX Xref "file, binary patch"
.IX Subsection "How do I randomly update a binary file?"
If you're just trying to patch a binary, in many cases something as
simple as this works:
.PP
.Vb 1
\&    perl \-i \-pe \*(Aqs{window manager}{window mangler}g\*(Aq /usr/bin/emacs
.Ve
.PP
However, if you have fixed sized records, then you might do something more
like this:
.PP
.Vb 9
\&    my $RECSIZE = 220; # size of record, in bytes
\&    my $recno   = 37;  # which record to update
\&    open my $fh, \*(Aq+<\*(Aq, \*(Aqsomewhere\*(Aq or die "can\*(Aqt update somewhere: $!";
\&    seek $fh, $recno * $RECSIZE, 0;
\&    read $fh, $record, $RECSIZE == $RECSIZE or die "can\*(Aqt read record $recno: $!";
\&    # munge the record
\&    seek $fh, \-$RECSIZE, 1;
\&    print $fh $record;
\&    close $fh;
.Ve
.PP
Locking and error checking are left as an exercise for the reader.
Don't forget them or you'll be quite sorry.
.SS "How do I get a file's timestamp in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How do I get a file's timestamp in perl?"
If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the \fB\-A\fR,
\&\fB\-M\fR, or \fB\-C\fR file test operations as documented in perlfunc.
These retrieve the age of the file (measured against the start-time of
your program) in days as a floating point number. Some platforms may
not have all of these times. See perlport for details. To retrieve
the \*(L"raw\*(R" time in seconds since the epoch, you would call the stat
function, then use \f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`gmtime()\*(C'\fR, or
\&\f(CW\*(C`POSIX::strftime()\*(C'\fR to convert this into human-readable form.
.PP
Here's an example:
.PP
.Vb 3
\&    my $write_secs = (stat($file))[9];
\&    printf "file %s updated at %s\en", $file,
\&        scalar localtime($write_secs);
.Ve
.PP
If you prefer something more legible, use the File::stat module
(part of the standard distribution in version 5.004 and later):
.PP
.Vb 5
\&    # error checking left as an exercise for reader.
\&    use File::stat;
\&    use Time::localtime;
\&    my $date_string = ctime(stat($file)\->mtime);
\&    print "file $file updated at $date_string\en";
.Ve
.PP
The \fIPOSIX::strftime()\fR approach has the benefit of being,
in theory, independent of the current locale. See perllocale
for details.
.SS "How do I set a file's timestamp in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How do I set a file's timestamp in perl?"
You use the \fIutime()\fR function documented in \*(L"utime\*(R" in perlfunc.
By way of example, here's a little program that copies the
read and write times from its first argument to all the rest
of them.
.PP
.Vb 6
\&    if (@ARGV < 2) {
\&        die "usage: cptimes timestamp_file other_files ...\en";
\&    }
\&    my $timestamp = shift;
\&    my($atime, $mtime) = (stat($timestamp))[8,9];
\&    utime $atime, $mtime, @ARGV;
.Ve
.PP
Error checking is, as usual, left as an exercise for the reader.
.PP
The perldoc for utime also has an example that has the same
effect as \fItouch\fR\|(1) on files that \fIalready exist\fR.
.PP
Certain file systems have a limited ability to store the times
on a file at the expected level of precision. For example, the
\&\s-1FAT\s0 and \s-1HPFS\s0 filesystem are unable to create dates on files with
a finer granularity than two seconds. This is a limitation of
the filesystems, not of \fIutime()\fR.
.SS "How do I print to more than one file at once?"
.IX Xref "print, to multiple files"
.IX Subsection "How do I print to more than one file at once?"
To connect one filehandle to several output filehandles,
you can use the IO::Tee or Tie::FileHandle::Multiplex modules.
.PP
If you only have to do this once, you can print individually
to each filehandle.
.PP
.Vb 1
\&    for my $fh ($fh1, $fh2, $fh3) { print $fh "whatever\en" }
.Ve
.SS "How can I read in an entire file all at once?"
.IX Xref "slurp file, slurping"
.IX Subsection "How can I read in an entire file all at once?"
The customary Perl approach for processing all the lines in a file is to
do so one line at a time:
.PP
.Vb 6
\&    open my $input, \*(Aq<\*(Aq, $file or die "can\*(Aqt open $file: $!";
\&    while (<$input>) {
\&        chomp;
\&        # do something with $_
\&    }
\&    close $input or die "can\*(Aqt close $file: $!";
.Ve
.PP
This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often\*(--if not almost always\*(--the wrong approach. Whenever
you see someone do this:
.PP
.Vb 1
\&    my @lines = <INPUT>;
.Ve
.PP
You should think long and hard about why you need everything loaded at
once. It's just not a scalable solution.
.PP
If you \*(L"mmap\*(R" the file with the File::Map module from
\&\s-1CPAN,\s0 you can virtually load the entire file into a
string without actually storing it in memory:
.PP
.Vb 1
\&    use File::Map qw(map_file);
\&
\&    map_file my $string, $filename;
.Ve
.PP
Once mapped, you can treat \f(CW$string\fR as you would any other string.
Since you don't necessarily have to load the data, mmap-ing can be
very fast and may not increase your memory footprint.
.PP
You might also find it more
fun to use the standard Tie::File module, or the DB_File module's
\&\f(CW$DB_RECNO\fR bindings, which allow you to tie an array to a file so that
accessing an element of the array actually accesses the corresponding
line in the file.
.PP
If you want to load the entire file, you can use the File::Slurp
module to do it in one one simple and efficient step:
.PP
.Vb 1
\&    use File::Slurp;
\&
\&    my $all_of_it = read_file($filename); # entire file in scalar
\&    my @all_lines = read_file($filename); # one line per element
.Ve
.PP
Or you can read the entire file contents into a scalar like this:
.PP
.Vb 6
\&    my $var;
\&    {
\&        local $/;
\&        open my $fh, \*(Aq<\*(Aq, $file or die "can\*(Aqt open $file: $!";
\&        $var = <$fh>;
\&    }
.Ve
.PP
That temporarily undefs your record separator, and will automatically
close the file at block exit. If the file is already open, just use this:
.PP
.Vb 1
\&    my $var = do { local $/; <$fh> };
.Ve
.PP
You can also use a localized \f(CW@ARGV\fR to eliminate the \f(CW\*(C`open\*(C'\fR:
.PP
.Vb 1
\&    my $var = do { local( @ARGV, $/ ) = $file; <> };
.Ve
.PP
For ordinary files you can also use the \f(CW\*(C`read\*(C'\fR function.
.PP
.Vb 1
\&    read( $fh, $var, \-s $fh );
.Ve
.PP
That third argument tests the byte size of the data on the \f(CW$fh\fR filehandle
and reads that many bytes into the buffer \f(CW$var\fR.
.SS "How can I read in a file by paragraphs?"
.IX Xref "file, reading by paragraphs"
.IX Subsection "How can I read in a file by paragraphs?"
Use the \f(CW$/\fR variable (see perlvar for details). You can either
set it to \f(CW""\fR to eliminate empty paragraphs (\f(CW"abc\en\en\en\endef"\fR,
for instance, gets treated as two paragraphs and not three), or
\&\f(CW"\en\en"\fR to accept empty paragraphs.
.PP
Note that a blank line must have no blanks in it. Thus
\&\f(CW"fred\en\ \enstuff\en\en"\fR is one paragraph, but \f(CW"fred\en\enstuff\en\en"\fR is two.
.SS "How can I read a single character from a file? From the keyboard?"
.IX Xref "getc file, reading one character at a time"
.IX Subsection "How can I read a single character from a file? From the keyboard?"
You can use the builtin \f(CW\*(C`getc()\*(C'\fR function for most filehandles, but
it won't (easily) work on a terminal device. For \s-1STDIN,\s0 either use
the Term::ReadKey module from \s-1CPAN\s0 or use the sample code in
\&\*(L"getc\*(R" in perlfunc.
.PP
If your system supports the portable operating system programming
interface (\s-1POSIX\s0), you can use the following code, which you'll note
turns off echo processing as well.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    $| = 1;
\&    for (1..4) {
\&        print "gimme: ";
\&        my $got = getone();
\&        print "\-\-> $got\en";
\&    }
\&    exit;
\&
\&    BEGIN {
\&        use POSIX qw(:termios_h);
\&
\&        my ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&        my $fd_stdin = fileno(STDIN);
\&
\&        $term     = POSIX::Termios\->new();
\&        $term\->getattr($fd_stdin);
\&        $oterm     = $term\->getlflag();
\&
\&        $echo     = ECHO | ECHOK | ICANON;
\&        $noecho   = $oterm & ~$echo;
\&
\&        sub cbreak {
\&            $term\->setlflag($noecho);
\&            $term\->setcc(VTIME, 1);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub cooked {
\&            $term\->setlflag($oterm);
\&            $term\->setcc(VTIME, 0);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub getone {
\&            my $key = \*(Aq\*(Aq;
\&            cbreak();
\&            sysread(STDIN, $key, 1);
\&            cooked();
\&            return $key;
\&        }
\&    }
\&
\&    END { cooked() }
.Ve
.PP
The Term::ReadKey module from \s-1CPAN\s0 may be easier to use. Recent versions
include also support for non-portable systems as well.
.PP
.Vb 8
\&    use Term::ReadKey;
\&    open my $tty, \*(Aq<\*(Aq, \*(Aq/dev/tty\*(Aq;
\&    print "Gimme a char: ";
\&    ReadMode "raw";
\&    my $key = ReadKey 0, $tty;
\&    ReadMode "normal";
\&    printf "\enYou said %s, char number %03d\en",
\&        $key, ord $key;
.Ve
.SS "How can I tell whether there's a character waiting on a filehandle?"
.IX Subsection "How can I tell whether there's a character waiting on a filehandle?"
The very first thing you should do is look into getting the Term::ReadKey
extension from \s-1CPAN.\s0 As we mentioned earlier, it now even has limited
support for non-portable (read: not open systems, closed, proprietary,
not \s-1POSIX,\s0 not Unix, etc.) systems.
.PP
You should also check out the Frequently Asked Questions list in
comp.unix.* for things like this: the answer is essentially the same.
It's very system-dependent. Here's one solution that works on \s-1BSD\s0
systems:
.PP
.Vb 5
\&    sub key_ready {
\&        my($rin, $nfd);
\&        vec($rin, fileno(STDIN), 1) = 1;
\&        return $nfd = select($rin,undef,undef,0);
\&    }
.Ve
.PP
If you want to find out how many characters are waiting, there's
also the \s-1FIONREAD\s0 ioctl call to be looked at. The \fIh2ph\fR tool that
comes with Perl tries to convert C include files to Perl code, which
can be \f(CW\*(C`require\*(C'\fRd. \s-1FIONREAD\s0 ends up defined as a function in the
\&\fIsys/ioctl.ph\fR file:
.PP
.Vb 1
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, FIONREAD(), $size)    or die "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
If \fIh2ph\fR wasn't installed or doesn't work for you, you can
\&\fIgrep\fR the include files by hand:
.PP
.Vb 2
\&    % grep FIONREAD /usr/include/*/*
\&    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
.Ve
.PP
Or write a small C program using the editor of champions:
.PP
.Vb 9
\&    % cat > fionread.c
\&    #include <sys/ioctl.h>
\&    main() {
\&        printf("%#08x\en", FIONREAD);
\&    }
\&    ^D
\&    % cc \-o fionread fionread.c
\&    % ./fionread
\&    0x4004667f
.Ve
.PP
And then hard-code it, leaving porting as an exercise to your successor.
.PP
.Vb 1
\&    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, $FIONREAD, $size)     or die "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
\&\s-1FIONREAD\s0 requires a filehandle connected to a stream, meaning that sockets,
pipes, and tty devices work, but \fInot\fR files.
.ie n .SS "How do I do a ""tail \-f"" in perl?"
.el .SS "How do I do a \f(CWtail \-f\fP in perl?"
.IX Xref "tail IO::Handle File::Tail clearerr"
.IX Subsection "How do I do a tail -f in perl?"
First try
.PP
.Vb 1
\&    seek($gw_fh, 0, 1);
.Ve
.PP
The statement \f(CW\*(C`seek($gw_fh, 0, 1)\*(C'\fR doesn't change the current position,
but it does clear the end-of-file condition on the handle, so that the
next \f(CW\*(C`<$gw_fh>\*(C'\fR makes Perl try again to read something.
.PP
If that doesn't work (it relies on features of your stdio implementation),
then you need something more like this:
.PP
.Vb 7
\&    for (;;) {
\&      for ($curpos = tell($gw_fh); <$gw_fh>; $curpos =tell($gw_fh)) {
\&        # search for some stuff and put it into files
\&      }
\&      # sleep for a while
\&      seek($gw_fh, $curpos, 0);  # seek to where we had been
\&    }
.Ve
.PP
If this still doesn't work, look into the \f(CW\*(C`clearerr\*(C'\fR method
from IO::Handle, which resets the error and end-of-file states
on the handle.
.PP
There's also a File::Tail module from \s-1CPAN.\s0
.SS "How do I \fIdup()\fP a filehandle in Perl?"
.IX Xref "dup"
.IX Subsection "How do I dup() a filehandle in Perl?"
If you check \*(L"open\*(R" in perlfunc, you'll see that several of the ways
to call \fIopen()\fR should do the trick. For example:
.PP
.Vb 2
\&    open my $log, \*(Aq>>\*(Aq, \*(Aq/foo/logfile\*(Aq;
\&    open STDERR, \*(Aq>&\*(Aq, $log;
.Ve
.PP
Or even with a literal numeric descriptor:
.PP
.Vb 2
\&    my $fd = $ENV{MHCONTEXTFD};
\&    open $mhcontext, "<&=$fd";  # like fdopen(3S)
.Ve
.PP
Note that \*(L"<&STDIN\*(R" makes a copy, but \*(L"<&=STDIN\*(R" makes
an alias. That means if you close an aliased handle, all
aliases become inaccessible. This is not true with
a copied one.
.PP
Error checking, as always, has been left as an exercise for the reader.
.SS "How do I close a file descriptor by number?"
.IX Xref "file, closing file descriptors POSIX close"
.IX Subsection "How do I close a file descriptor by number?"
If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used \f(CW\*(C`POSIX::open\*(C'\fR), you can use the
\&\f(CW\*(C`close()\*(C'\fR function from the \s-1POSIX\s0 module:
.PP
.Vb 1
\&    use POSIX ();
\&
\&    POSIX::close( $fd );
.Ve
.PP
This should rarely be necessary, as the Perl \f(CW\*(C`close()\*(C'\fR function is to be
used for things that Perl opened itself, even if it was a dup of a
numeric descriptor as with \f(CW\*(C`MHCONTEXT\*(C'\fR above. But if you really have
to, you may be able to do this:
.PP
.Vb 3
\&    require \*(Aqsys/syscall.ph\*(Aq;
\&    my $rc = syscall(SYS_close(), $fd + 0);  # must force numeric
\&    die "can\*(Aqt sysclose $fd: $!" unless $rc == \-1;
.Ve
.PP
Or, just use the fdopen(3S) feature of \f(CW\*(C`open()\*(C'\fR:
.PP
.Vb 4
\&    {
\&        open my $fh, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
\&        close $fh;
\&    }
.Ve
.ie n .SS "Why can't I use ""C:\etemp\efoo"" in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?"
.el .SS "Why can't I use ``C:\etemp\efoo'' in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?"
.IX Xref "filename, DOS issues"
.IX Subsection "Why can't I use C:tempfoo in DOS paths? Why doesn't `C:tempfoo.exe` work?"
Whoops!  You just put a tab and a formfeed into that filename!
Remember that within double quoted strings (\*(L"like\ethis\*(R"), the
backslash is an escape character. The full list of these is in
\&\*(L"Quote and Quote-like Operators\*(R" in perlop. Unsurprisingly, you don't
have a file called \*(L"c:(tab)emp(formfeed)oo\*(R" or
\&\*(L"c:(tab)emp(formfeed)oo.exe\*(R" on your legacy \s-1DOS\s0 filesystem.
.PP
Either single-quote your strings, or (preferably) use forward slashes.
Since all \s-1DOS\s0 and Windows versions since something like MS-DOS 2.0 or so
have treated \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`\e\*(C'\fR the same in a path, you might as well use the
one that doesn't clash with Perl\*(--or the \s-1POSIX\s0 shell, \s-1ANSI C\s0 and \*(C+,
awk, Tcl, Java, or Python, just to mention a few. \s-1POSIX\s0 paths
are more portable, too.
.ie n .SS "Why doesn't glob(""*.*"") get all the files?"
.el .SS "Why doesn't glob(``*.*'') get all the files?"
.IX Xref "glob"
.IX Subsection "Why doesn't glob(*.*) get all the files?"
Because even on non-Unix ports, Perl's glob function follows standard
Unix globbing semantics. You'll need \f(CW\*(C`glob("*")\*(C'\fR to get all (non-hidden)
files. This makes \fIglob()\fR portable even to legacy systems. Your
port may include proprietary globbing functions as well. Check its
documentation for details.
.ie n .SS "Why does Perl let me delete read-only files? Why does ""\-i"" clobber protected files? Isn't this a bug in Perl?"
.el .SS "Why does Perl let me delete read-only files? Why does \f(CW\-i\fP clobber protected files? Isn't this a bug in Perl?"
.IX Subsection "Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?"
This is elaborately and painstakingly described in the
\&\fIfile-dir-perms\fR article in the \*(L"Far More Than You Ever Wanted To
Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> .
.PP
The executive summary: learn how your filesystem works. The
permissions on a file say what can happen to the data in that file.
The permissions on a directory say what can happen to the list of
files in that directory. If you delete a file, you're removing its
name from the directory (so the operation depends on the permissions
of the directory, not of the file). If you try to write to the file,
the permissions of the file govern whether you're allowed to.
.SS "How do I select a random line from a file?"
.IX Xref "file, selecting a random line"
.IX Subsection "How do I select a random line from a file?"
Short of loading the file into a database or pre-indexing the lines in
the file, there are a couple of things that you can do.
.PP
Here's a reservoir-sampling algorithm from the Camel Book:
.PP
.Vb 2
\&    srand;
\&    rand($.) < 1 && ($line = $_) while <>;
.Ve
.PP
This has a significant advantage in space over reading the whole file
in. You can find a proof of this method in \fIThe Art of Computer
Programming\fR, Volume 2, Section 3.4.2, by Donald E. Knuth.
.PP
You can use the File::Random module which provides a function
for that algorithm:
.PP
.Vb 2
\&    use File::Random qw/random_line/;
\&    my $line = random_line($filename);
.Ve
.PP
Another way is to use the Tie::File module, which treats the entire
file as an array. Simply access a random array element.
.SS "Why do I get weird spaces when I print an array of lines?"
.IX Subsection "Why do I get weird spaces when I print an array of lines?"
(contributed by brian d foy)
.PP
If you are seeing spaces between the elements of your array when
you print the array, you are probably interpolating the array in
double quotes:
.PP
.Vb 2
\&    my @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: @animals\en";
.Ve
.PP
It's the double quotes, not the \f(CW\*(C`print\*(C'\fR, doing this. Whenever you
interpolate an array in a double quote context, Perl joins the
elements with spaces (or whatever is in \f(CW$"\fR, which is a space by
default):
.PP
.Vb 1
\&    animals are: camel llama alpaca vicuna
.Ve
.PP
This is different than printing the array without the interpolation:
.PP
.Vb 2
\&    my @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: ", @animals, "\en";
.Ve
.PP
Now the output doesn't have the spaces between the elements because
the elements of \f(CW@animals\fR simply become part of the list to
\&\f(CW\*(C`print\*(C'\fR:
.PP
.Vb 1
\&    animals are: camelllamaalpacavicuna
.Ve
.PP
You might notice this when each of the elements of \f(CW@array\fR end with
a newline. You expect to print one element per line, but notice that
every line after the first is indented:
.PP
.Vb 3
\&    this is a line
\&     this is another line
\&     this is the third line
.Ve
.PP
That extra space comes from the interpolation of the array. If you
don't want to put anything between your array elements, don't use the
array in double quotes. You can send it to print without them:
.PP
.Vb 1
\&    print @lines;
.Ve
.SS "How do I traverse a directory tree?"
.IX Subsection "How do I traverse a directory tree?"
(contributed by brian d foy)
.PP
The File::Find module, which comes with Perl, does all of the hard
work to traverse a directory structure. It comes with Perl. You simply
call the \f(CW\*(C`find\*(C'\fR subroutine with a callback subroutine and the
directories you want to traverse:
.PP
.Vb 1
\&    use File::Find;
\&
\&    find( \e&wanted, @directories );
\&
\&    sub wanted {
\&        # full path in $File::Find::name
\&        # just filename in $_
\&        ... do whatever you want to do ...
\&    }
.Ve
.PP
The File::Find::Closures, which you can download from \s-1CPAN,\s0 provides
many ready-to-use subroutines that you can use with File::Find.
.PP
The File::Finder, which you can download from \s-1CPAN,\s0 can help you
create the callback subroutine using something closer to the syntax of
the \f(CW\*(C`find\*(C'\fR command-line utility:
.PP
.Vb 2
\&    use File::Find;
\&    use File::Finder;
\&
\&    my $deep_dirs = File::Finder\->depth\->type(\*(Aqd\*(Aq)\->ls\->exec(\*(Aqrmdir\*(Aq,\*(Aq{}\*(Aq);
\&
\&    find( $deep_dirs\->as_options, @places );
.Ve
.PP
The File::Find::Rule module, which you can download from \s-1CPAN,\s0 has
a similar interface, but does the traversal for you too:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    my @files = File::Find::Rule\->file()
\&                             \->name( \*(Aq*.pm\*(Aq )
\&                             \->in( @INC );
.Ve
.SS "How do I delete a directory tree?"
.IX Subsection "How do I delete a directory tree?"
(contributed by brian d foy)
.PP
If you have an empty directory, you can use Perl's built-in \f(CW\*(C`rmdir\*(C'\fR.
If the directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot of work) or use a module to
help you.
.PP
The File::Path module, which comes with Perl, has a \f(CW\*(C`remove_tree\*(C'\fR
which can take care of all of the hard work for you:
.PP
.Vb 1
\&    use File::Path qw(remove_tree);
\&
\&    remove_tree( @directories );
.Ve
.PP
The File::Path module also has a legacy interface to the older
\&\f(CW\*(C`rmtree\*(C'\fR subroutine.
.SS "How do I copy an entire directory?"
.IX Subsection "How do I copy an entire directory?"
(contributed by Shlomi Fish)
.PP
To do the equivalent of \f(CW\*(C`cp \-R\*(C'\fR (i.e. copy an entire directory tree
recursively) in portable Perl, you'll either need to write something yourself
or find a good \s-1CPAN\s0 module such as  File::Copy::Recursive.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq6.1                                   0100644 0001750 0001750 00000142115 12566207437 022470  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ6 1"
.TH PERLFAQ6 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq6 \- Regular Expressions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section is surprisingly small because the rest of the \s-1FAQ\s0 is
littered with answers involving regular expressions. For example,
decoding a \s-1URL\s0 and checking whether something is a number can be handled
with regular expressions, but those answers are found elsewhere in
this document (in perlfaq9: \*(L"How do I decode or create those %\-encodings
on the web\*(R" and perlfaq4: \*(L"How do I determine whether a scalar is
a number/whole/integer/float\*(R", to be precise).
.SS "How can I hope to use regular expressions without creating illegible and unmaintainable code?"
.IX Xref "regex, legibility regexp, legibility regular expression, legibility x"
.IX Subsection "How can I hope to use regular expressions without creating illegible and unmaintainable code?"
Three techniques can make regular expressions maintainable and
understandable.
.IP "Comments Outside the Regex" 4
.IX Item "Comments Outside the Regex"
Describe what you're doing and how you're doing it, using normal Perl
comments.
.Sp
.Vb 3
\&    # turn the line into the first word, a colon, and the
\&    # number of characters on the rest of the line
\&    s/^(\ew+)(.*)/ lc($1) . ":" . length($2) /meg;
.Ve
.IP "Comments Inside the Regex" 4
.IX Item "Comments Inside the Regex"
The \f(CW\*(C`/x\*(C'\fR modifier causes whitespace to be ignored in a regex pattern
(except in a character class and a few other places), and also allows you to
use normal comments there, too. As you can imagine, whitespace and comments
help a lot.
.Sp
\&\f(CW\*(C`/x\*(C'\fR lets you turn this:
.Sp
.Vb 1
\&    s{<(?:[^>\*(Aq"]*|".*?"|\*(Aq.*?\*(Aq)+>}{}gs;
.Ve
.Sp
into this:
.Sp
.Vb 10
\&    s{ <                    # opening angle bracket
\&        (?:                 # Non\-backreffing grouping paren
\&            [^>\*(Aq"] *        # 0 or more things that are neither > nor \*(Aq nor "
\&                |           #    or else
\&            ".*?"           # a section between double quotes (stingy match)
\&                |           #    or else
\&            \*(Aq.*?\*(Aq           # a section between single quotes (stingy match)
\&        ) +                 #   all occurring one or more times
\&        >                   # closing angle bracket
\&    }{}gsx;                 # replace with nothing, i.e. delete
.Ve
.Sp
It's still not quite so clear as prose, but it is very useful for
describing the meaning of each part of the pattern.
.IP "Different Delimiters" 4
.IX Item "Different Delimiters"
While we normally think of patterns as being delimited with \f(CW\*(C`/\*(C'\fR
characters, they can be delimited by almost any character. perlre
describes this. For example, the \f(CW\*(C`s///\*(C'\fR above uses braces as
delimiters. Selecting another delimiter can avoid quoting the
delimiter within the pattern:
.Sp
.Vb 2
\&    s/\e/usr\e/local/\e/usr\e/share/g;    # bad delimiter choice
\&    s#/usr/local#/usr/share#g;        # better
.Ve
.Sp
Using logically paired delimiters can be even more readable:
.Sp
.Vb 1
\&    s{/usr/local/}{/usr/share}g;      # better still
.Ve
.SS "I'm having trouble matching over more than one line. What's wrong?"
.IX Xref "regex, multiline regexp, multiline regular expression, multiline"
.IX Subsection "I'm having trouble matching over more than one line. What's wrong?"
Either you don't have more than one line in the string you're looking
at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).
.PP
There are many ways to get multiline data into a string. If you want
it to happen automatically while reading input, you'll want to set $/
(probably to '' for paragraphs or \f(CW\*(C`undef\*(C'\fR for the whole file) to
allow you to read more than one line at a time.
.PP
Read perlre to help you decide which of \f(CW\*(C`/s\*(C'\fR and \f(CW\*(C`/m\*(C'\fR (or both)
you might want to use: \f(CW\*(C`/s\*(C'\fR allows dot to include newline, and \f(CW\*(C`/m\*(C'\fR
allows caret and dollar to match next to a newline, not just at the
end of the string. You do need to make sure that you've actually
got a multiline string in there.
.PP
For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones). For this example, we don't need
\&\f(CW\*(C`/s\*(C'\fR because we aren't using dot in a regular expression that we want
to cross line boundaries. Neither do we need \f(CW\*(C`/m\*(C'\fR because we don't
want caret or dollar to match at any point inside the record next
to newlines. But it's imperative that $/ be set to something other
than the default, or else we won't actually ever have a multiline
record read in.
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /\eb([\ew\*(Aq\-]+)(\es+\eg1)+\eb/gi ) {     # word starts alpha
\&            print "Duplicate $1 at paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Here's some code that finds sentences that begin with \*(L"From \*(R" (which would
be mangled by many mailers):
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /^From /gm ) { # /m makes ^ match next to \en
\&        print "leading from in paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Here's code that finds everything between \s-1START\s0 and \s-1END\s0 in a paragraph:
.PP
.Vb 6
\&    undef $/;          # read in whole file, not just one line or paragraph
\&    while ( <> ) {
\&        while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
\&            print "$1\en";
\&        }
\&    }
.Ve
.SS "How can I pull out lines between two patterns that are themselves on different lines?"
.IX Xref ".."
.IX Subsection "How can I pull out lines between two patterns that are themselves on different lines?"
You can use Perl's somewhat exotic \f(CW\*(C`..\*(C'\fR operator (documented in
perlop):
.PP
.Vb 1
\&    perl \-ne \*(Aqprint if /START/ .. /END/\*(Aq file1 file2 ...
.Ve
.PP
If you wanted text and not lines, you would use
.PP
.Vb 1
\&    perl \-0777 \-ne \*(Aqprint "$1\en" while /START(.*?)END/gs\*(Aq file1 file2 ...
.Ve
.PP
But if you want nested occurrences of \f(CW\*(C`START\*(C'\fR through \f(CW\*(C`END\*(C'\fR, you'll
run up against the problem described in the question in this section
on matching balanced text.
.PP
Here's another example of using \f(CW\*(C`..\*(C'\fR:
.PP
.Vb 7
\&    while (<>) {
\&        my $in_header =   1  .. /^$/;
\&        my $in_body   = /^$/ .. eof;
\&    # now choose between them
\&    } continue {
\&        $. = 0 if eof;    # fix $.
\&    }
.Ve
.SS "How do I match \s-1XML, HTML,\s0 or other nasty, ugly things with a regex?"
.IX Xref "regex, XML regex, HTML XML HTML pain frustration sucking out, will to live"
.IX Subsection "How do I match XML, HTML, or other nasty, ugly things with a regex?"
Do not use regexes. Use a module and forget about the
regular expressions. The XML::LibXML, HTML::TokeParser and
HTML::TreeBuilder modules are good starts, although each namespace
has other parsing modules specialized for certain tasks and different
ways of doing it. Start at \s-1CPAN\s0 Search ( <http://metacpan.org/> )
and wonder at all the work people have done for you already! :)
.SS "I put a regular expression into $/ but it didn't work. What's wrong?"
.IX Xref "$ , regexes in $INPUT_RECORD_SEPARATOR, regexes in $RS, regexes in"
.IX Subsection "I put a regular expression into $/ but it didn't work. What's wrong?"
$/ has to be a string. You can use these examples if you really need to
do this.
.PP
If you have File::Stream, this is easy.
.PP
.Vb 1
\&    use File::Stream;
\&
\&    my $stream = File::Stream\->new(
\&        $filehandle,
\&        separator => qr/\es*,\es*/,
\&        );
\&
\&    print "$_\en" while <$stream>;
.Ve
.PP
If you don't have File::Stream, you have to do a little more work.
.PP
You can use the four-argument form of sysread to continually add to
a buffer. After you add to the buffer, you check if you have a
complete line (using your regular expression).
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        while( s/^((?s).*?)your_pattern// ) {
\&            my $record = $1;
\&            # do stuff here.
\&        }
\&    }
.Ve
.PP
You can do the same thing with foreach and a match using the
c flag and the \eG anchor, if you do not mind your entire file
being in memory at the end.
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        foreach my $record ( m/\eG((?s).*?)your_pattern/gc ) {
\&            # do stuff here.
\&        }
\&        substr( $_, 0, pos ) = "" if pos;
\&    }
.Ve
.SS "How do I substitute case-insensitively on the \s-1LHS\s0 while preserving case on the \s-1RHS\s0?"
.IX Xref "replace, case preserving substitute, case preserving substitution, case preserving s, case preserving"
.IX Subsection "How do I substitute case-insensitively on the LHS while preserving case on the RHS?"
Here's a lovely Perlish solution by Larry Rosler. It exploits
properties of bitwise xor on \s-1ASCII\s0 strings.
.PP
.Vb 1
\&    $_= "this is a TEsT case";
\&
\&    $old = \*(Aqtest\*(Aq;
\&    $new = \*(Aqsuccess\*(Aq;
\&
\&    s{(\eQ$old\eE)}
\&    { uc $new | (uc $1 ^ $1) .
\&        (uc(substr $1, \-1) ^ substr $1, \-1) x
\&        (length($new) \- length $1)
\&    }egi;
\&
\&    print;
.Ve
.PP
And here it is as a subroutine, modeled after the above:
.PP
.Vb 3
\&    sub preserve_case {
\&        my ($old, $new) = @_;
\&        my $mask = uc $old ^ $old;
\&
\&        uc $new | $mask .
\&            substr($mask, \-1) x (length($new) \- length($old))
\&    }
\&
\&    $string = "this is a TEsT case";
\&    $string =~ s/(test)/preserve_case($1, "success")/egi;
\&    print "$string\en";
.Ve
.PP
This prints:
.PP
.Vb 1
\&    this is a SUcCESS case
.Ve
.PP
As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:
.PP
.Vb 3
\&    sub preserve_case {
\&        my ($from, $to) = @_;
\&        my ($lf, $lt) = map length, @_;
\&
\&        if ($lt < $lf) { $from = substr $from, 0, $lt }
\&        else { $from .= substr $to, $lf }
\&
\&        return uc $to | ($from ^ uc $from);
\&    }
.Ve
.PP
This changes the sentence to \*(L"this is a SUcCess case.\*(R"
.PP
Just to show that C programmers can write C in any programming language,
if you prefer a more C\-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.
.PP
.Vb 8
\&    # Original by Nathan Torkington, massaged by Jeffrey Friedl
\&    #
\&    sub preserve_case
\&    {
\&        my ($old, $new) = @_;
\&        my $state = 0; # 0 = no change; 1 = lc; 2 = uc
\&        my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
\&        my $len = $oldlen < $newlen ? $oldlen : $newlen;
\&
\&        for ($i = 0; $i < $len; $i++) {
\&            if ($c = substr($old, $i, 1), $c =~ /[\eW\ed_]/) {
\&                $state = 0;
\&            } elsif (lc $c eq $c) {
\&                substr($new, $i, 1) = lc(substr($new, $i, 1));
\&                $state = 1;
\&            } else {
\&                substr($new, $i, 1) = uc(substr($new, $i, 1));
\&                $state = 2;
\&            }
\&        }
\&        # finish up with any remaining new (for when new is longer than old)
\&        if ($newlen > $oldlen) {
\&            if ($state == 1) {
\&                substr($new, $oldlen) = lc(substr($new, $oldlen));
\&            } elsif ($state == 2) {
\&                substr($new, $oldlen) = uc(substr($new, $oldlen));
\&            }
\&        }
\&        return $new;
\&    }
.Ve
.ie n .SS "How can I make ""\ew"" match national character sets?"
.el .SS "How can I make \f(CW\ew\fP match national character sets?"
.IX Xref "\\w"
.IX Subsection "How can I make w match national character sets?"
Put \f(CW\*(C`use locale;\*(C'\fR in your script. The \ew character class is taken
from the current locale.
.PP
See perllocale for details.
.ie n .SS "How can I match a locale-smart version of ""/[a\-zA\-Z]/""?"
.el .SS "How can I match a locale-smart version of \f(CW/[a\-zA\-Z]/\fP?"
.IX Xref "alpha"
.IX Subsection "How can I match a locale-smart version of /[a-zA-Z]/?"
You can use the \s-1POSIX\s0 character class syntax \f(CW\*(C`/[[:alpha:]]/\*(C'\fR
documented in perlre.
.PP
No matter which locale you are in, the alphabetic characters are
the characters in \ew without the digits and the underscore.
As a regex, that looks like \f(CW\*(C`/[^\eW\ed_]/\*(C'\fR. Its complement,
the non-alphabetics, is then everything in \eW along with
the digits and the underscore, or \f(CW\*(C`/[\eW\ed_]/\*(C'\fR.
.SS "How can I quote a variable to use in a regex?"
.IX Xref "regex, escaping regexp, escaping regular expression, escaping"
.IX Subsection "How can I quote a variable to use in a regex?"
The Perl parser will expand \f(CW$variable\fR and \f(CW@variable\fR references in
regular expressions unless the delimiter is a single quote. Remember,
too, that the right-hand side of a \f(CW\*(C`s///\*(C'\fR substitution is considered
a double-quoted string (see perlop for more details). Remember
also that any regex special characters will be acted on unless you
precede the substitution with \eQ. Here's an example:
.PP
.Vb 2
\&    $string = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $string =~ s/$regex/Polyp/;
\&    # $string is now "Polypacido P. Octopus"
.Ve
.PP
Because \f(CW\*(C`.\*(C'\fR is special in regular expressions, and can match any
single character, the regex \f(CW\*(C`P.\*(C'\fR here has matched the <Pl> in the
original string.
.PP
To escape the special meaning of \f(CW\*(C`.\*(C'\fR, we use \f(CW\*(C`\eQ\*(C'\fR:
.PP
.Vb 2
\&    $string = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $string =~ s/\eQ$regex/Polyp/;
\&    # $string is now "Placido Polyp Octopus"
.Ve
.PP
The use of \f(CW\*(C`\eQ\*(C'\fR causes the <.> in the regex to be treated as a
regular character, so that \f(CW\*(C`P.\*(C'\fR matches a \f(CW\*(C`P\*(C'\fR followed by a dot.
.ie n .SS "What is ""/o"" really for?"
.el .SS "What is \f(CW/o\fP really for?"
.IX Xref " o, regular expressions compile, regular expressions"
.IX Subsection "What is /o really for?"
(contributed by brian d foy)
.PP
The \f(CW\*(C`/o\*(C'\fR option for regular expressions (documented in perlop and
perlreref) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.
.PP
Since the match operator \f(CW\*(C`m//\*(C'\fR, the substitution operator \f(CW\*(C`s///\*(C'\fR,
and the regular expression quoting operator \f(CW\*(C`qr//\*(C'\fR are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to \*(L"How can I quote a variable to use in a regex?\*(R" for more
details.
.PP
This example takes a regular expression from the argument list and
prints the lines of input that match it:
.PP
.Vb 1
\&    my $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/;
\&    }
.Ve
.PP
Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if \f(CW$pattern\fR had not changed. The \f(CW\*(C`/o\*(C'\fR
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:
.PP
.Vb 1
\&    my $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/o; # useful for Perl < 5.6
\&    }
.Ve
.PP
In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the \f(CW\*(C`/o\*(C'\fR
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the \f(CW\*(C`/o\*(C'\fR.
.PP
You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The \f(CW\*(C`use re
\&\*(Aqdebug\*(Aq\*(C'\fR pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see \f(CW\*(C`re\*(C'\fR reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see \f(CW\*(C`re\*(C'\fR report that for the first iteration.
.PP
.Vb 1
\&    use re \*(Aqdebug\*(Aq;
\&
\&    my $regex = \*(AqPerl\*(Aq;
\&    foreach ( qw(Perl Java Ruby Python) ) {
\&        print STDERR "\-" x 73, "\en";
\&        print STDERR "Trying $_...\en";
\&        print STDERR "\et$_ is good!\en" if m/$regex/;
\&    }
.Ve
.SS "How do I use a regular expression to strip C\-style comments from a file?"
.IX Subsection "How do I use a regular expression to strip C-style comments from a file?"
While this actually can be done, it's much harder than you'd think.
For example, this one-liner
.PP
.Vb 1
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
.Ve
.PP
will work in many but not all cases. You see, it's too simple-minded for
certain kinds of C programs, in particular, those with what appear to be
comments in quoted strings. For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.
.PP
.Vb 4
\&    $/ = undef;
\&    $_ = <>;
\&    s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $2 ? $2 : ""#gse;
\&    print;
.Ve
.PP
This could, of course, be more legibly written with the \f(CW\*(C`/x\*(C'\fR modifier, adding
whitespace and comments. Here it is expanded, courtesy of Fred Curtis.
.PP
.Vb 8
\&    s{
\&       /\e*         ##  Start of /* ... */ comment
\&       [^*]*\e*+    ##  Non\-* followed by 1\-or\-more *\*(Aqs
\&       (
\&         [^/*][^*]*\e*+
\&       )*          ##  0\-or\-more things which don\*(Aqt start with /
\&                   ##    but do end with \*(Aq*\*(Aq
\&       /           ##  End of /* ... */ comment
\&
\&     |         ##     OR  various things which aren\*(Aqt comments:
\&
\&       (
\&         "           ##  Start of " ... " string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^"\e\e]        ##  Non "\e
\&         )*
\&         "           ##  End of " ... " string
\&
\&       |         ##     OR
\&
\&         \*(Aq           ##  Start of \*(Aq ... \*(Aq string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^\*(Aq\e\e]        ##  Non \*(Aq\e
\&         )*
\&         \*(Aq           ##  End of \*(Aq ... \*(Aq string
\&
\&       |         ##     OR
\&
\&         .           ##  Anything other char
\&         [^/"\*(Aq\e\e]*   ##  Chars which doesn\*(Aqt start a comment, string or escape
\&       )
\&     }{defined $2 ? $2 : ""}gxse;
.Ve
.PP
A slight modification also removes \*(C+ comments, possibly spanning multiple lines
using a continuation character:
.PP
.Vb 1
\& s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|//([^\e\e]|[^\en][\en]?)*?\en|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $3 ? $3 : ""#gse;
.Ve
.SS "Can I use Perl regular expressions to match balanced text?"
.IX Xref "regex, matching balanced test regexp, matching balanced test regular expression, matching balanced test possessive PARNO Text::Balanced Regexp::Common backtracking recursion"
.IX Subsection "Can I use Perl regular expressions to match balanced text?"
(contributed by brian d foy)
.PP
Your first try should probably be the Text::Balanced module, which
is in the Perl standard library since Perl 5.8. It has a variety of
functions to deal with tricky text. The Regexp::Common module can
also help by providing canned patterns you can use.
.PP
As of Perl 5.10, you can match balanced text with regular expressions
using recursive patterns. Before Perl 5.10, you had to resort to
various tricks such as using Perl code in \f(CW\*(C`(??{})\*(C'\fR sequences.
.PP
Here's an example using a recursive regular expression. The goal is to
capture all of the text within angle brackets, including the text in
nested angle brackets. This sample text has two \*(L"major\*(R" groups: a
group with one level of nesting and a group with two levels of
nesting. There are five total groups in angle brackets:
.PP
.Vb 3
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
.Ve
.PP
The regular expression to match the balanced text uses two new (to
Perl 5.10) regular expression features. These are covered in perlre
and this example is a modified version of one in that documentation.
.PP
First, adding the new possessive \f(CW\*(C`+\*(C'\fR to any quantifier finds the
longest match and does not backtrack. That's important since you want
to handle any angle brackets through the recursion, not backtracking.
The group \f(CW\*(C`[^<>]++\*(C'\fR finds one or more non-angle brackets without
backtracking.
.PP
Second, the new \f(CW\*(C`(?PARNO)\*(C'\fR refers to the sub-pattern in the
particular capture group given by \f(CW\*(C`PARNO\*(C'\fR. In the following regex,
the first capture group finds (and remembers) the balanced text, and
you need that same pattern within the first buffer to get past the
nested text. That's the recursive part. The \f(CW\*(C`(?1)\*(C'\fR uses the pattern
in the outer capture group as an independent part of the regex.
.PP
Putting it all together, you have:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    my $string =<<"HERE";
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
\&    HERE
\&
\&    my @groups = $string =~ m/
\&            (                   # start of capture group 1
\&            <                   # match an opening angle bracket
\&                (?:
\&                    [^<>]++     # one or more non angle brackets, non backtracking
\&                      |
\&                    (?1)        # found < or >, so recurse to capture group 1
\&                )*
\&            >                   # match a closing angle bracket
\&            )                   # end of capture group 1
\&            /xg;
\&
\&    $" = "\en\et";
\&    print "Found:\en\et@groups\en";
.Ve
.PP
The output shows that Perl found the two major groups:
.PP
.Vb 3
\&    Found:
\&        <brackets in <nested brackets> >
\&        <another group <nested once <nested twice> > >
.Ve
.PP
With a little extra work, you can get the all of the groups in angle
brackets even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter (that's the one you
just matched so don't match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    my @queue =<<"HERE";
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
\&    HERE
\&
\&    my $regex = qr/
\&            (                   # start of bracket 1
\&            <                   # match an opening angle bracket
\&                (?:
\&                    [^<>]++     # one or more non angle brackets, non backtracking
\&                      |
\&                    (?1)        # recurse to bracket 1
\&                )*
\&            >                   # match a closing angle bracket
\&            )                   # end of bracket 1
\&            /x;
\&
\&    $" = "\en\et";
\&
\&    while( @queue ) {
\&        my $string = shift @queue;
\&
\&        my @groups = $string =~ m/$regex/g;
\&        print "Found:\en\et@groups\en\en" if @groups;
\&
\&        unshift @queue, map { s/^<//; s/>$//; $_ } @groups;
\&    }
.Ve
.PP
The output shows all of the groups. The outermost matches show up
first and the nested matches so up later:
.PP
.Vb 3
\&    Found:
\&        <brackets in <nested brackets> >
\&        <another group <nested once <nested twice> > >
\&
\&    Found:
\&        <nested brackets>
\&
\&    Found:
\&        <nested once <nested twice> >
\&
\&    Found:
\&        <nested twice>
.Ve
.SS "What does it mean that regexes are greedy? How can I get around it?"
.IX Xref "greedy greediness"
.IX Subsection "What does it mean that regexes are greedy? How can I get around it?"
Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (\f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`{}\*(C'\fR) that are greedy rather than the whole pattern; Perl prefers local
greed and immediate gratification to overall greed. To get non-greedy
versions of the same quantifiers, use (\f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{}?\*(C'\fR).
.PP
An example:
.PP
.Vb 3
\&    my $s1 = my $s2 = "I am very very cold";
\&    $s1 =~ s/ve.*y //;      # I am cold
\&    $s2 =~ s/ve.*?y //;     # I am very cold
.Ve
.PP
Notice how the second substitution stopped matching as soon as it
encountered \*(L"y \*(R". The \f(CW\*(C`*?\*(C'\fR quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass
control on to whatever is next in line, as you would if you were
playing hot potato.
.SS "How do I process each word on each line?"
.IX Xref "word"
.IX Subsection "How do I process each word on each line?"
Use the split function:
.PP
.Vb 5
\&    while (<>) {
\&        foreach my $word ( split ) {
\&            # do something with $word here
\&        }
\&    }
.Ve
.PP
Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.
.PP
To work with only alphanumeric sequences (including underscores), you
might consider
.PP
.Vb 5
\&    while (<>) {
\&        foreach $word (m/(\ew+)/g) {
\&            # do something with $word here
\&        }
\&    }
.Ve
.SS "How can I print out a word-frequency or line-frequency summary?"
.IX Subsection "How can I print out a word-frequency or line-frequency summary?"
To do this, you have to parse out each word in the input stream. We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given
in the previous question:
.PP
.Vb 6
\&    my (%seen);
\&    while (<>) {
\&        while ( /(\eb[^\eW_\ed][\ew\*(Aq\-]+\eb)/g ) {   # misses "\`sheep\*(Aq"
\&            $seen{$1}++;
\&        }
\&    }
\&
\&    while ( my ($word, $count) = each %seen ) {
\&        print "$count $word\en";
\&    }
.Ve
.PP
If you wanted to do the same thing for lines, you wouldn't need a
regular expression:
.PP
.Vb 1
\&    my (%seen);
\&
\&    while (<>) {
\&        $seen{$_}++;
\&    }
\&
\&    while ( my ($line, $count) = each %seen ) {
\&        print "$count $line";
\&    }
.Ve
.PP
If you want these output in a sorted order, see perlfaq4: \*(L"How do I
sort a hash (optionally by value instead of key)?\*(R".
.SS "How can I do approximate matching?"
.IX Xref "match, approximate matching, approximate"
.IX Subsection "How can I do approximate matching?"
See the module String::Approx available from \s-1CPAN.\s0
.SS "How do I efficiently match many regular expressions at once?"
.IX Xref "regex, efficiency regexp, efficiency regular expression, efficiency"
.IX Subsection "How do I efficiently match many regular expressions at once?"
(contributed by brian d foy)
.PP
If you have Perl 5.10 or later, this is almost trivial. You just smart
match against an array of regular expression objects:
.PP
.Vb 1
\&    my @patterns = ( qr/Fr.d/, qr/B.rn.y/, qr/W.lm./ );
\&
\&    if( $string ~~ @patterns ) {
\&        ...
\&    };
.Ve
.PP
The smart match stops when it finds a match, so it doesn't have to try
every expression.
.PP
Earlier than Perl 5.10, you have a bit of work to do. You want to
avoid compiling a regular expression every time you want to match it.
In this example, perl must recompile the regular expression for every
iteration of the \f(CW\*(C`foreach\*(C'\fR loop since it has no way to know what
\&\f(CW$pattern\fR will be:
.PP
.Vb 1
\&    my @patterns = qw( foo bar baz );
\&
\&    LINE: while( <DATA> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /\eb$pattern\eb/i ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`qr//\*(C'\fR operator showed up in perl 5.005. It compiles a regular
expression, but doesn't apply it. When you use the pre-compiled
version of the regex, perl does less work. In this example, I inserted
a \f(CW\*(C`map\*(C'\fR to turn each pattern into its pre-compiled form. The rest of
the script is the same, but faster:
.PP
.Vb 1
\&    my @patterns = map { qr/\eb$_\eb/i } qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /$pattern/ ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
In some cases, you may be able to make several patterns into a single
regular expression. Beware of situations that require backtracking
though.
.PP
.Vb 1
\&    my $regex = join \*(Aq|\*(Aq, qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        print if /\eb(?:$regex)\eb/i;
\&    }
.Ve
.PP
For more details on regular expression efficiency, see \fIMastering
Regular Expressions\fR by Jeffrey Friedl. He explains how the regular
expressions engine works and why some patterns are surprisingly
inefficient. Once you understand how perl applies regular expressions,
you can tune them for individual situations.
.ie n .SS "Why don't word-boundary searches with ""\eb"" work for me?"
.el .SS "Why don't word-boundary searches with \f(CW\eb\fP work for me?"
.IX Xref "\\b"
.IX Subsection "Why don't word-boundary searches with b work for me?"
(contributed by brian d foy)
.PP
Ensure that you know what \eb really does: it's the boundary between a
word character, \ew, and something that isn't a word character. That
thing that isn't a word character might be \eW, but it can also be the
start or end of the string.
.PP
It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.
.PP
In regex speak, a word boundary (\eb) is a \*(L"zero width assertion\*(R",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.
.PP
For the regular expression, /\ebPerl\eb/, there has to be a word
boundary before the \*(L"P\*(R" and after the \*(L"l\*(R". As long as something other
than a word character precedes the \*(L"P\*(R" and succeeds the \*(L"l\*(R", the
pattern will match. These strings match /\ebPerl\eb/.
.PP
.Vb 4
\&    "Perl"    # no word char before P or after l
\&    "Perl "   # same as previous (space is not a word char)
\&    "\*(AqPerl\*(Aq"  # the \*(Aq char is not a word char
\&    "Perl\*(Aqs"  # no word char before P, non\-word char after "l"
.Ve
.PP
These strings do not match /\ebPerl\eb/.
.PP
.Vb 2
\&    "Perl_"   # _ is a word char!
\&    "Perler"  # no word char before P, but one after l
.Ve
.PP
You don't have to use \eb to match words though. You can look for
non-word characters surrounded by word characters. These strings
match the pattern /\eb'\eb/.
.PP
.Vb 2
\&    "don\*(Aqt"   # the \*(Aq char is surrounded by "n" and "t"
\&    "qep\*(Aqa\*(Aq"  # the \*(Aq char is surrounded by "p" and "a"
.Ve
.PP
These strings do not match /\eb'\eb/.
.PP
.Vb 1
\&    "foo\*(Aq"    # there is no word char after non\-word \*(Aq
.Ve
.PP
You can also use the complement of \eb, \eB, to specify that there
should not be a word boundary.
.PP
In the pattern /\eBam\eB/, there must be a word character before the \*(L"a\*(R"
and after the \*(L"m\*(R". These patterns match /\eBam\eB/:
.PP
.Vb 2
\&    "llama"   # "am" surrounded by word chars
\&    "Samuel"  # same
.Ve
.PP
These strings do not match /\eBam\eB/
.PP
.Vb 2
\&    "Sam"      # no word boundary before "a", but one after "m"
\&    "I am Sam" # "am" surrounded by non\-word chars
.Ve
.SS "Why does using $&, $`, or $' slow my program down?"
.IX Xref "$MATCH $& $POSTMATCH $' $PREMATCH $`"
.IX Subsection "Why does using $&, $`, or $' slow my program down?"
(contributed by Anno Siegel)
.PP
Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer \*(L"expensive\*(R" the way the other two are.
.PP
Since Perl 5.6.1 the special variables @\- and @+ can functionally replace
$`, $& and $'. These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.
.PP
Perl 5.10 added three specials, \f(CW\*(C`${^MATCH}\*(C'\fR, \f(CW\*(C`${^PREMATCH}\*(C'\fR, and
\&\f(CW\*(C`${^POSTMATCH}\*(C'\fR to do the same job but without the global performance
penalty. Perl 5.10 only sets these variables if you compile or execute the
regular expression with the \f(CW\*(C`/p\*(C'\fR modifier.
.ie n .SS "What good is ""\eG"" in a regular expression?"
.el .SS "What good is \f(CW\eG\fP in a regular expression?"
.IX Xref "\\G"
.IX Subsection "What good is G in a regular expression?"
You use the \f(CW\*(C`\eG\*(C'\fR anchor to start the next match on the same
string where the last match left off. The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so \f(CW\*(C`\eG\*(C'\fR is similar to the
beginning of string anchor, \f(CW\*(C`^\*(C'\fR. The \f(CW\*(C`\eG\*(C'\fR anchor is typically
used with the \f(CW\*(C`g\*(C'\fR flag. It uses the value of \f(CW\*(C`pos()\*(C'\fR
as the position to start the next match. As the match
operator makes successive matches, it updates \f(CW\*(C`pos()\*(C'\fR with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own \f(CW\*(C`pos()\*(C'\fR value.
.PP
Suppose you want to match all of consecutive pairs of digits
in a string like \*(L"1122a44\*(R" and stop matching when you
encounter non-digits. You want to match \f(CW11\fR and \f(CW22\fR but
the letter <a> shows up between \f(CW22\fR and \f(CW44\fR and you want
to stop at \f(CW\*(C`a\*(C'\fR. Simply matching pairs of digits skips over
the \f(CW\*(C`a\*(C'\fR and still matches \f(CW44\fR.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    my @pairs = m/(\ed\ed)/g;   # qw( 11 22 44 )
.Ve
.PP
If you use the \f(CW\*(C`\eG\*(C'\fR anchor, you force the match after \f(CW22\fR to
start with the \f(CW\*(C`a\*(C'\fR. The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    my @pairs = m/\eG(\ed\ed)/g; # qw( 11 22 )
.Ve
.PP
You can also use the \f(CW\*(C`\eG\*(C'\fR anchor in scalar context. You
still need the \f(CW\*(C`g\*(C'\fR flag.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
.Ve
.PP
After the match fails at the letter \f(CW\*(C`a\*(C'\fR, perl resets \f(CW\*(C`pos()\*(C'\fR
and the next match on the same string starts at the beginning.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 after while" if m/(\ed\ed)/g; # finds "11"
.Ve
.PP
You can disable \f(CW\*(C`pos()\*(C'\fR resets on fail with the \f(CW\*(C`c\*(C'\fR flag, documented
in perlop and perlreref. Subsequent matches start where the last
successful match ended (the value of \f(CW\*(C`pos()\*(C'\fR) even if a match on the
same string has failed in the meantime. In this case, the match after
the \f(CW\*(C`while()\*(C'\fR loop starts at the \f(CW\*(C`a\*(C'\fR (where the last match stopped),
and since it does not use any anchor it can skip over the \f(CW\*(C`a\*(C'\fR to find
\&\f(CW44\fR.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/gc ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 after while" if m/(\ed\ed)/g; # finds "44"
.Ve
.PP
Typically you use the \f(CW\*(C`\eG\*(C'\fR anchor with the \f(CW\*(C`c\*(C'\fR flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.
.PP
.Vb 9
\&    while (<>) {
\&        chomp;
\&        PARSER: {
\&            m/ \eG( \ed+\eb    )/gcx   && do { print "number: $1\en";  redo; };
\&            m/ \eG( \ew+      )/gcx   && do { print "word:   $1\en";  redo; };
\&            m/ \eG( \es+      )/gcx   && do { print "space:  $1\en";  redo; };
\&            m/ \eG( [^\ew\ed]+ )/gcx   && do { print "other:  $1\en";  redo; };
\&        }
\&    }
.Ve
.PP
For each line, the \f(CW\*(C`PARSER\*(C'\fR loop first tries to match a series
of digits followed by a word boundary. This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since \f(CW\*(C`m/ \eG( \ed+\eb
)/gcx\*(C'\fR uses the \f(CW\*(C`c\*(C'\fR flag, if the string does not match that
regular expression, perl does not reset \fIpos()\fR and the next
match starts at the same position to try a different
pattern.
.SS "Are Perl regexes DFAs or NFAs? Are they \s-1POSIX\s0 compliant?"
.IX Xref "DFA NFA POSIX"
.IX Subsection "Are Perl regexes DFAs or NFAs? Are they POSIX compliant?"
While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the \fIegrep\fR\|(1) program, they are in
fact implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing. And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases. (It seems
that some people prefer guarantees of consistency, even when what's
guaranteed is slowness.) See the book \*(L"Mastering Regular Expressions\*(R"
(from O'Reilly) by Jeffrey Friedl for all the details you could ever
hope to know on these matters (a full citation appears in
perlfaq2).
.SS "What's wrong with using grep in a void context?"
.IX Xref "grep"
.IX Subsection "What's wrong with using grep in a void context?"
The problem is that grep builds a return list, regardless of the context.
This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
purpose.
.PP
In perls older than 5.8.1, map suffers from this problem as well.
But since 5.8.1, this has been fixed, and map is context aware \- in void
context, no lists are constructed.
.SS "How can I match strings with multibyte characters?"
.IX Xref "regex, and multibyte characters regexp, and multibyte characters regular expression, and multibyte characters martian encoding, Martian"
.IX Subsection "How can I match strings with multibyte characters?"
Starting from Perl 5.6 Perl has had some level of multibyte character
support. Perl 5.8 or later is recommended. Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module. See perluniintro, perlunicode,
and Encode.
.PP
If you are stuck with older Perls, you can do Unicode with the
Unicode::String module, and character conversions using the
Unicode::Map8 and Unicode::Map modules. If you are using
Japanese encodings, you might try using the jperl 5.005_03.
.PP
Finally, the following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.
.PP
Let's suppose you have some weird Martian encoding where pairs of
\&\s-1ASCII\s0 uppercase letters encode single Martian letters (i.e. the two
bytes \*(L"\s-1CV\*(R"\s0 make a single Martian letter, as do the two bytes \*(L"\s-1SG\*(R",
\&\*(L"VS\*(R", \*(L"XX\*(R",\s0 etc.). Other bytes represent single characters, just like
\&\s-1ASCII.\s0
.PP
So, the string of Martian \*(L"I am \s-1CVSGXX\s0!\*(R" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', '\s-1CV\s0', '\s-1SG\s0', '\s-1XX\s0', '!'.
.PP
Now, say you want to search for the single character \f(CW\*(C`/GX/\*(C'\fR. Perl
doesn't know about Martian, so it'll find the two bytes \*(L"\s-1GX\*(R"\s0 in the \*(L"I
am \s-1CVSGXX\s0!\*(R" string, even though that character isn't there: it just
looks like it is because \*(L"\s-1SG\*(R"\s0 is next to \*(L"\s-1XX\*(R",\s0 but there's no real
\&\*(L"\s-1GX\*(R".\s0 This is a big problem.
.PP
Here are a few ways, all painful, to deal with it:
.PP
.Vb 2
\&    # Make sure adjacent "martian" bytes are no longer adjacent.
\&    $martian =~ s/([A\-Z][A\-Z])/ $1 /g;
\&
\&    print "found GX!\en" if $martian =~ /GX/;
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    my @chars = $martian =~ m/([A\-Z][A\-Z]|[^A\-Z])/g;
\&    # above is conceptually similar to:     my @chars = $text =~ m/(.)/g;
\&    #
\&    foreach my $char (@chars) {
\&        print "found GX!\en", last if $char eq \*(AqGX\*(Aq;
\&    }
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    while ($martian =~ m/\eG([A\-Z][A\-Z]|.)/gs) {  # \eG probably unneeded
\&        if ($1 eq \*(AqGX\*(Aq) {
\&            print "found GX!\en";
\&            last;
\&        }
\&    }
.Ve
.PP
Here's another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind assertion.
.PP
.Vb 5
\&    print "found GX!\en" if    $martian =~ m/
\&        (?<![A\-Z])
\&        (?:[A\-Z][A\-Z])*?
\&        GX
\&        /x;
.Ve
.PP
This succeeds if the \*(L"martian\*(R" character \s-1GX\s0 is in the string, and fails
otherwise. If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A\-Z]) with (?:^|[^A\-Z]).
.PP
It does have the drawback of putting the wrong thing in $\-[0] and $+[0],
but this usually can be worked around.
.SS "How do I match a regular expression that's in a variable?"
.IX Xref "regex, in variable eval regex quotemeta \\Q, regex \\E, regex qr"
.IX Subsection "How do I match a regular expression that's in a variable?"
(contributed by brian d foy)
.PP
We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.
.PP
The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in \f(CW$regex\fR.
Once you have the pattern in \f(CW$regex\fR, you use that variable in the
match operator.
.PP
.Vb 1
\&    chomp( my $regex = <STDIN> );
\&
\&    if( $string =~ m/$regex/ ) { ... }
.Ve
.PP
Any regular expression special characters in \f(CW$regex\fR are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.
.PP
.Vb 1
\&    my $regex = "Unmatched ( paren";
\&
\&    "Two parens to bind them all" =~ m/$regex/;
.Ve
.PP
When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:
.PP
.Vb 1
\&    Unmatched ( in regex; marked by <\-\- HERE in m/Unmatched ( <\-\- HERE  paren/ at script line 3.
.Ve
.PP
You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with \f(CW\*(C`quotemeta\*(C'\fR before you use the string.
.PP
.Vb 2
\&    chomp( my $regex = <STDIN> );
\&    $regex = quotemeta( $regex );
\&
\&    if( $string =~ m/$regex/ ) { ... }
.Ve
.PP
You can also do this directly in the match operator using the \f(CW\*(C`\eQ\*(C'\fR
and \f(CW\*(C`\eE\*(C'\fR sequences. The \f(CW\*(C`\eQ\*(C'\fR tells Perl where to start escaping
special characters, and the \f(CW\*(C`\eE\*(C'\fR tells it where to stop (see perlop
for more details).
.PP
.Vb 1
\&    chomp( my $regex = <STDIN> );
\&
\&    if( $string =~ m/\eQ$regex\eE/ ) { ... }
.Ve
.PP
Alternately, you can use \f(CW\*(C`qr//\*(C'\fR, the regular expression quote operator (see
perlop for more details). It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.
.PP
.Vb 1
\&    chomp( my $input = <STDIN> );
\&
\&    my $regex = qr/$input/is;
\&
\&    $string =~ m/$regex/  # same as m/$input/is;
.Ve
.PP
You might also want to trap any errors by wrapping an \f(CW\*(C`eval\*(C'\fR block
around the whole thing.
.PP
.Vb 1
\&    chomp( my $input = <STDIN> );
\&
\&    eval {
\&        if( $string =~ m/\eQ$input\eE/ ) { ... }
\&    };
\&    warn $@ if $@;
.Ve
.PP
Or...
.PP
.Vb 7
\&    my $regex = eval { qr/$input/is };
\&    if( defined $regex ) {
\&        $string =~ m/$regex/;
\&    }
\&    else {
\&        warn $@;
\&    }
.Ve
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq65.16.1                               0100644 0001750 0001750 00000141632 12566207417 023003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ6 1"
.TH PERLFAQ6 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq6 \- Regular Expressions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section is surprisingly small because the rest of the \s-1FAQ\s0 is
littered with answers involving regular expressions. For example,
decoding a \s-1URL\s0 and checking whether something is a number can be handled
with regular expressions, but those answers are found elsewhere in
this document (in perlfaq9: \*(L"How do I decode or create those %\-encodings
on the web\*(R" and perlfaq4: \*(L"How do I determine whether a scalar is
a number/whole/integer/float\*(R", to be precise).
.SS "How can I hope to use regular expressions without creating illegible and unmaintainable code?"
.IX Xref "regex, legibility regexp, legibility regular expression, legibility  x"
.IX Subsection "How can I hope to use regular expressions without creating illegible and unmaintainable code?"
Three techniques can make regular expressions maintainable and
understandable.
.IP "Comments Outside the Regex" 4
.IX Item "Comments Outside the Regex"
Describe what you're doing and how you're doing it, using normal Perl
comments.
.Sp
.Vb 3
\&    # turn the line into the first word, a colon, and the
\&    # number of characters on the rest of the line
\&    s/^(\ew+)(.*)/ lc($1) . ":" . length($2) /meg;
.Ve
.IP "Comments Inside the Regex" 4
.IX Item "Comments Inside the Regex"
The \f(CW\*(C`/x\*(C'\fR modifier causes whitespace to be ignored in a regex pattern
(except in a character class and a few other places), and also allows you to
use normal comments there, too. As you can imagine, whitespace and comments
help a lot.
.Sp
\&\f(CW\*(C`/x\*(C'\fR lets you turn this:
.Sp
.Vb 1
\&    s{<(?:[^>\*(Aq"]*|".*?"|\*(Aq.*?\*(Aq)+>}{}gs;
.Ve
.Sp
into this:
.Sp
.Vb 10
\&    s{ <                    # opening angle bracket
\&        (?:                 # Non\-backreffing grouping paren
\&            [^>\*(Aq"] *        # 0 or more things that are neither > nor \*(Aq nor "
\&                |           #    or else
\&            ".*?"           # a section between double quotes (stingy match)
\&                |           #    or else
\&            \*(Aq.*?\*(Aq           # a section between single quotes (stingy match)
\&        ) +                 #   all occurring one or more times
\&        >                   # closing angle bracket
\&    }{}gsx;                 # replace with nothing, i.e. delete
.Ve
.Sp
It's still not quite so clear as prose, but it is very useful for
describing the meaning of each part of the pattern.
.IP "Different Delimiters" 4
.IX Item "Different Delimiters"
While we normally think of patterns as being delimited with \f(CW\*(C`/\*(C'\fR
characters, they can be delimited by almost any character. perlre
describes this. For example, the \f(CW\*(C`s///\*(C'\fR above uses braces as
delimiters. Selecting another delimiter can avoid quoting the
delimiter within the pattern:
.Sp
.Vb 2
\&    s/\e/usr\e/local/\e/usr\e/share/g;    # bad delimiter choice
\&    s#/usr/local#/usr/share#g;        # better
.Ve
.Sp
Using logically paired delimiters can be even more readable:
.Sp
.Vb 1
\&    s{/usr/local/}{/usr/share}g;      # better still
.Ve
.SS "I'm having trouble matching over more than one line. What's wrong?"
.IX Xref "regex, multiline regexp, multiline regular expression, multiline"
.IX Subsection "I'm having trouble matching over more than one line. What's wrong?"
Either you don't have more than one line in the string you're looking
at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).
.PP
There are many ways to get multiline data into a string. If you want
it to happen automatically while reading input, you'll want to set $/
(probably to '' for paragraphs or \f(CW\*(C`undef\*(C'\fR for the whole file) to
allow you to read more than one line at a time.
.PP
Read perlre to help you decide which of \f(CW\*(C`/s\*(C'\fR and \f(CW\*(C`/m\*(C'\fR (or both)
you might want to use: \f(CW\*(C`/s\*(C'\fR allows dot to include newline, and \f(CW\*(C`/m\*(C'\fR
allows caret and dollar to match next to a newline, not just at the
end of the string. You do need to make sure that you've actually
got a multiline string in there.
.PP
For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones). For this example, we don't need
\&\f(CW\*(C`/s\*(C'\fR because we aren't using dot in a regular expression that we want
to cross line boundaries. Neither do we need \f(CW\*(C`/m\*(C'\fR because we don't
want caret or dollar to match at any point inside the record next
to newlines. But it's imperative that $/ be set to something other
than the default, or else we won't actually ever have a multiline
record read in.
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /\eb([\ew\*(Aq\-]+)(\es+\eg1)+\eb/gi ) {     # word starts alpha
\&            print "Duplicate $1 at paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Here's some code that finds sentences that begin with \*(L"From \*(R" (which would
be mangled by many mailers):
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /^From /gm ) { # /m makes ^ match next to \en
\&        print "leading from in paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Here's code that finds everything between \s-1START\s0 and \s-1END\s0 in a paragraph:
.PP
.Vb 6
\&    undef $/;          # read in whole file, not just one line or paragraph
\&    while ( <> ) {
\&        while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
\&            print "$1\en";
\&        }
\&    }
.Ve
.SS "How can I pull out lines between two patterns that are themselves on different lines?"
.IX Xref ".."
.IX Subsection "How can I pull out lines between two patterns that are themselves on different lines?"
You can use Perl's somewhat exotic \f(CW\*(C`..\*(C'\fR operator (documented in
perlop):
.PP
.Vb 1
\&    perl \-ne \*(Aqprint if /START/ .. /END/\*(Aq file1 file2 ...
.Ve
.PP
If you wanted text and not lines, you would use
.PP
.Vb 1
\&    perl \-0777 \-ne \*(Aqprint "$1\en" while /START(.*?)END/gs\*(Aq file1 file2 ...
.Ve
.PP
But if you want nested occurrences of \f(CW\*(C`START\*(C'\fR through \f(CW\*(C`END\*(C'\fR, you'll
run up against the problem described in the question in this section
on matching balanced text.
.PP
Here's another example of using \f(CW\*(C`..\*(C'\fR:
.PP
.Vb 7
\&    while (<>) {
\&        my $in_header =   1  .. /^$/;
\&        my $in_body   = /^$/ .. eof;
\&    # now choose between them
\&    } continue {
\&        $. = 0 if eof;    # fix $.
\&    }
.Ve
.SS "How do I match \s-1XML\s0, \s-1HTML\s0, or other nasty, ugly things with a regex?"
.IX Xref "regex, XML regex, HTML XML HTML pain frustration sucking out, will to live"
.IX Subsection "How do I match XML, HTML, or other nasty, ugly things with a regex?"
Do not use regexes. Use a module and forget about the
regular expressions. The XML::LibXML, HTML::TokeParser and
HTML::TreeBuilder modules are good starts, although each namespace
has other parsing modules specialized for certain tasks and different
ways of doing it. Start at \s-1CPAN\s0 Search ( <http://metacpan.org/> )
and wonder at all the work people have done for you already! :)
.SS "I put a regular expression into $/ but it didn't work. What's wrong?"
.IX Xref "$ , regexes in $INPUT_RECORD_SEPARATOR, regexes in $RS, regexes in"
.IX Subsection "I put a regular expression into $/ but it didn't work. What's wrong?"
$/ has to be a string. You can use these examples if you really need to
do this.
.PP
If you have File::Stream, this is easy.
.PP
.Vb 1
\&    use File::Stream;
\&
\&    my $stream = File::Stream\->new(
\&        $filehandle,
\&        separator => qr/\es*,\es*/,
\&        );
\&
\&    print "$_\en" while <$stream>;
.Ve
.PP
If you don't have File::Stream, you have to do a little more work.
.PP
You can use the four-argument form of sysread to continually add to
a buffer. After you add to the buffer, you check if you have a
complete line (using your regular expression).
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        while( s/^((?s).*?)your_pattern// ) {
\&            my $record = $1;
\&            # do stuff here.
\&        }
\&    }
.Ve
.PP
You can do the same thing with foreach and a match using the
c flag and the \eG anchor, if you do not mind your entire file
being in memory at the end.
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        foreach my $record ( m/\eG((?s).*?)your_pattern/gc ) {
\&            # do stuff here.
\&        }
\&        substr( $_, 0, pos ) = "" if pos;
\&    }
.Ve
.SS "How do I substitute case-insensitively on the \s-1LHS\s0 while preserving case on the \s-1RHS\s0?"
.IX Xref "replace, case preserving substitute, case preserving substitution, case preserving s, case preserving"
.IX Subsection "How do I substitute case-insensitively on the LHS while preserving case on the RHS?"
Here's a lovely Perlish solution by Larry Rosler. It exploits
properties of bitwise xor on \s-1ASCII\s0 strings.
.PP
.Vb 1
\&    $_= "this is a TEsT case";
\&
\&    $old = \*(Aqtest\*(Aq;
\&    $new = \*(Aqsuccess\*(Aq;
\&
\&    s{(\eQ$old\eE)}
\&    { uc $new | (uc $1 ^ $1) .
\&        (uc(substr $1, \-1) ^ substr $1, \-1) x
\&        (length($new) \- length $1)
\&    }egi;
\&
\&    print;
.Ve
.PP
And here it is as a subroutine, modeled after the above:
.PP
.Vb 3
\&    sub preserve_case($$) {
\&        my ($old, $new) = @_;
\&        my $mask = uc $old ^ $old;
\&
\&        uc $new | $mask .
\&            substr($mask, \-1) x (length($new) \- length($old))
\&    }
\&
\&    $string = "this is a TEsT case";
\&    $string =~ s/(test)/preserve_case($1, "success")/egi;
\&    print "$string\en";
.Ve
.PP
This prints:
.PP
.Vb 1
\&    this is a SUcCESS case
.Ve
.PP
As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:
.PP
.Vb 3
\&    sub preserve_case {
\&        my ($from, $to) = @_;
\&        my ($lf, $lt) = map length, @_;
\&
\&        if ($lt < $lf) { $from = substr $from, 0, $lt }
\&        else { $from .= substr $to, $lf }
\&
\&        return uc $to | ($from ^ uc $from);
\&    }
.Ve
.PP
This changes the sentence to \*(L"this is a SUcCess case.\*(R"
.PP
Just to show that C programmers can write C in any programming language,
if you prefer a more C\-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.
.PP
.Vb 8
\&    # Original by Nathan Torkington, massaged by Jeffrey Friedl
\&    #
\&    sub preserve_case($$)
\&    {
\&        my ($old, $new) = @_;
\&        my $state = 0; # 0 = no change; 1 = lc; 2 = uc
\&        my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
\&        my $len = $oldlen < $newlen ? $oldlen : $newlen;
\&
\&        for ($i = 0; $i < $len; $i++) {
\&            if ($c = substr($old, $i, 1), $c =~ /[\eW\ed_]/) {
\&                $state = 0;
\&            } elsif (lc $c eq $c) {
\&                substr($new, $i, 1) = lc(substr($new, $i, 1));
\&                $state = 1;
\&            } else {
\&                substr($new, $i, 1) = uc(substr($new, $i, 1));
\&                $state = 2;
\&            }
\&        }
\&        # finish up with any remaining new (for when new is longer than old)
\&        if ($newlen > $oldlen) {
\&            if ($state == 1) {
\&                substr($new, $oldlen) = lc(substr($new, $oldlen));
\&            } elsif ($state == 2) {
\&                substr($new, $oldlen) = uc(substr($new, $oldlen));
\&            }
\&        }
\&        return $new;
\&    }
.Ve
.ie n .SS "How can I make ""\ew"" match national character sets?"
.el .SS "How can I make \f(CW\ew\fP match national character sets?"
.IX Xref "\\w"
.IX Subsection "How can I make w match national character sets?"
Put \f(CW\*(C`use locale;\*(C'\fR in your script. The \ew character class is taken
from the current locale.
.PP
See perllocale for details.
.ie n .SS "How can I match a locale-smart version of ""/[a\-zA\-Z]/""?"
.el .SS "How can I match a locale-smart version of \f(CW/[a\-zA\-Z]/\fP?"
.IX Xref "alpha"
.IX Subsection "How can I match a locale-smart version of /[a-zA-Z]/?"
You can use the \s-1POSIX\s0 character class syntax \f(CW\*(C`/[[:alpha:]]/\*(C'\fR
documented in perlre.
.PP
No matter which locale you are in, the alphabetic characters are
the characters in \ew without the digits and the underscore.
As a regex, that looks like \f(CW\*(C`/[^\eW\ed_]/\*(C'\fR. Its complement,
the non-alphabetics, is then everything in \eW along with
the digits and the underscore, or \f(CW\*(C`/[\eW\ed_]/\*(C'\fR.
.SS "How can I quote a variable to use in a regex?"
.IX Xref "regex, escaping regexp, escaping regular expression, escaping"
.IX Subsection "How can I quote a variable to use in a regex?"
The Perl parser will expand \f(CW$variable\fR and \f(CW@variable\fR references in
regular expressions unless the delimiter is a single quote. Remember,
too, that the right-hand side of a \f(CW\*(C`s///\*(C'\fR substitution is considered
a double-quoted string (see perlop for more details). Remember
also that any regex special characters will be acted on unless you
precede the substitution with \eQ. Here's an example:
.PP
.Vb 2
\&    $string = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $string =~ s/$regex/Polyp/;
\&    # $string is now "Polypacido P. Octopus"
.Ve
.PP
Because \f(CW\*(C`.\*(C'\fR is special in regular expressions, and can match any
single character, the regex \f(CW\*(C`P.\*(C'\fR here has matched the <Pl> in the
original string.
.PP
To escape the special meaning of \f(CW\*(C`.\*(C'\fR, we use \f(CW\*(C`\eQ\*(C'\fR:
.PP
.Vb 2
\&    $string = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $string =~ s/\eQ$regex/Polyp/;
\&    # $string is now "Placido Polyp Octopus"
.Ve
.PP
The use of \f(CW\*(C`\eQ\*(C'\fR causes the <.> in the regex to be treated as a
regular character, so that \f(CW\*(C`P.\*(C'\fR matches a \f(CW\*(C`P\*(C'\fR followed by a dot.
.ie n .SS "What is ""/o"" really for?"
.el .SS "What is \f(CW/o\fP really for?"
.IX Xref " o, regular expressions compile, regular expressions"
.IX Subsection "What is /o really for?"
(contributed by brian d foy)
.PP
The \f(CW\*(C`/o\*(C'\fR option for regular expressions (documented in perlop and
perlreref) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.
.PP
Since the match operator \f(CW\*(C`m//\*(C'\fR, the substitution operator \f(CW\*(C`s///\*(C'\fR,
and the regular expression quoting operator \f(CW\*(C`qr//\*(C'\fR are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to \*(L"How can I quote a variable to use in a regex?\*(R" for more
details.
.PP
This example takes a regular expression from the argument list and
prints the lines of input that match it:
.PP
.Vb 1
\&    my $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/;
\&    }
.Ve
.PP
Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if \f(CW$pattern\fR had not changed. The \f(CW\*(C`/o\*(C'\fR
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:
.PP
.Vb 1
\&    my $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/o; # useful for Perl < 5.6
\&    }
.Ve
.PP
In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the \f(CW\*(C`/o\*(C'\fR
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the \f(CW\*(C`/o\*(C'\fR.
.PP
You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The \f(CW\*(C`use re
\&\*(Aqdebug\*(Aq\*(C'\fR pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see \f(CW\*(C`re\*(C'\fR reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see \f(CW\*(C`re\*(C'\fR report that for the first iteration.
.PP
.Vb 1
\&    use re \*(Aqdebug\*(Aq;
\&
\&    my $regex = \*(AqPerl\*(Aq;
\&    foreach ( qw(Perl Java Ruby Python) ) {
\&        print STDERR "\-" x 73, "\en";
\&        print STDERR "Trying $_...\en";
\&        print STDERR "\et$_ is good!\en" if m/$regex/;
\&    }
.Ve
.SS "How do I use a regular expression to strip C\-style comments from a file?"
.IX Subsection "How do I use a regular expression to strip C-style comments from a file?"
While this actually can be done, it's much harder than you'd think.
For example, this one-liner
.PP
.Vb 1
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
.Ve
.PP
will work in many but not all cases. You see, it's too simple-minded for
certain kinds of C programs, in particular, those with what appear to be
comments in quoted strings. For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.
.PP
.Vb 4
\&    $/ = undef;
\&    $_ = <>;
\&    s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $2 ? $2 : ""#gse;
\&    print;
.Ve
.PP
This could, of course, be more legibly written with the \f(CW\*(C`/x\*(C'\fR modifier, adding
whitespace and comments. Here it is expanded, courtesy of Fred Curtis.
.PP
.Vb 8
\&    s{
\&       /\e*         ##  Start of /* ... */ comment
\&       [^*]*\e*+    ##  Non\-* followed by 1\-or\-more *\*(Aqs
\&       (
\&         [^/*][^*]*\e*+
\&       )*          ##  0\-or\-more things which don\*(Aqt start with /
\&                   ##    but do end with \*(Aq*\*(Aq
\&       /           ##  End of /* ... */ comment
\&
\&     |         ##     OR  various things which aren\*(Aqt comments:
\&
\&       (
\&         "           ##  Start of " ... " string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^"\e\e]        ##  Non "\e
\&         )*
\&         "           ##  End of " ... " string
\&
\&       |         ##     OR
\&
\&         \*(Aq           ##  Start of \*(Aq ... \*(Aq string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^\*(Aq\e\e]        ##  Non \*(Aq\e
\&         )*
\&         \*(Aq           ##  End of \*(Aq ... \*(Aq string
\&
\&       |         ##     OR
\&
\&         .           ##  Anything other char
\&         [^/"\*(Aq\e\e]*   ##  Chars which doesn\*(Aqt start a comment, string or escape
\&       )
\&     }{defined $2 ? $2 : ""}gxse;
.Ve
.PP
A slight modification also removes \*(C+ comments, possibly spanning multiple lines
using a continuation character:
.PP
.Vb 1
\& s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|//([^\e\e]|[^\en][\en]?)*?\en|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $3 ? $3 : ""#gse;
.Ve
.SS "Can I use Perl regular expressions to match balanced text?"
.IX Xref "regex, matching balanced test regexp, matching balanced test regular expression, matching balanced test possessive PARNO Text::Balanced Regexp::Common backtracking recursion"
.IX Subsection "Can I use Perl regular expressions to match balanced text?"
(contributed by brian d foy)
.PP
Your first try should probably be the Text::Balanced module, which
is in the Perl standard library since Perl 5.8. It has a variety of
functions to deal with tricky text. The Regexp::Common module can
also help by providing canned patterns you can use.
.PP
As of Perl 5.10, you can match balanced text with regular expressions
using recursive patterns. Before Perl 5.10, you had to resort to
various tricks such as using Perl code in \f(CW\*(C`(??{})\*(C'\fR sequences.
.PP
Here's an example using a recursive regular expression. The goal is to
capture all of the text within angle brackets, including the text in
nested angle brackets. This sample text has two \*(L"major\*(R" groups: a
group with one level of nesting and a group with two levels of
nesting. There are five total groups in angle brackets:
.PP
.Vb 3
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
.Ve
.PP
The regular expression to match the balanced text uses two new (to
Perl 5.10) regular expression features. These are covered in perlre
and this example is a modified version of one in that documentation.
.PP
First, adding the new possessive \f(CW\*(C`+\*(C'\fR to any quantifier finds the
longest match and does not backtrack. That's important since you want
to handle any angle brackets through the recursion, not backtracking.
The group \f(CW\*(C`[^<>]++\*(C'\fR finds one or more non-angle brackets without
backtracking.
.PP
Second, the new \f(CW\*(C`(?PARNO)\*(C'\fR refers to the sub-pattern in the
particular capture group given by \f(CW\*(C`PARNO\*(C'\fR. In the following regex,
the first capture group finds (and remembers) the balanced text, and
you need that same pattern within the first buffer to get past the
nested text. That's the recursive part. The \f(CW\*(C`(?1)\*(C'\fR uses the pattern
in the outer capture group as an independent part of the regex.
.PP
Putting it all together, you have:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    my $string =<<"HERE";
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
\&    HERE
\&
\&    my @groups = $string =~ m/
\&            (                   # start of capture group 1
\&            <                   # match an opening angle bracket
\&                (?:
\&                    [^<>]++     # one or more non angle brackets, non backtracking
\&                      |
\&                    (?1)        # found < or >, so recurse to capture group 1
\&                )*
\&            >                   # match a closing angle bracket
\&            )                   # end of capture group 1
\&            /xg;
\&
\&    $" = "\en\et";
\&    print "Found:\en\et@groups\en";
.Ve
.PP
The output shows that Perl found the two major groups:
.PP
.Vb 3
\&    Found:
\&        <brackets in <nested brackets> >
\&        <another group <nested once <nested twice> > >
.Ve
.PP
With a little extra work, you can get the all of the groups in angle
brackets even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter (that's the one you
just matched so don't match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    my @queue =<<"HERE";
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
\&    HERE
\&
\&    my $regex = qr/
\&            (                   # start of bracket 1
\&            <                   # match an opening angle bracket
\&                (?:
\&                    [^<>]++     # one or more non angle brackets, non backtracking
\&                      |
\&                    (?1)        # recurse to bracket 1
\&                )*
\&            >                   # match a closing angle bracket
\&            )                   # end of bracket 1
\&            /x;
\&
\&    $" = "\en\et";
\&
\&    while( @queue ) {
\&        my $string = shift @queue;
\&
\&        my @groups = $string =~ m/$regex/g;
\&        print "Found:\en\et@groups\en\en" if @groups;
\&
\&        unshift @queue, map { s/^<//; s/>$//; $_ } @groups;
\&    }
.Ve
.PP
The output shows all of the groups. The outermost matches show up
first and the nested matches so up later:
.PP
.Vb 3
\&    Found:
\&        <brackets in <nested brackets> >
\&        <another group <nested once <nested twice> > >
\&
\&    Found:
\&        <nested brackets>
\&
\&    Found:
\&        <nested once <nested twice> >
\&
\&    Found:
\&        <nested twice>
.Ve
.SS "What does it mean that regexes are greedy? How can I get around it?"
.IX Xref "greedy greediness"
.IX Subsection "What does it mean that regexes are greedy? How can I get around it?"
Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (\f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`{}\*(C'\fR) that are greedy rather than the whole pattern; Perl prefers local
greed and immediate gratification to overall greed. To get non-greedy
versions of the same quantifiers, use (\f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{}?\*(C'\fR).
.PP
An example:
.PP
.Vb 3
\&    my $s1 = my $s2 = "I am very very cold";
\&    $s1 =~ s/ve.*y //;      # I am cold
\&    $s2 =~ s/ve.*?y //;     # I am very cold
.Ve
.PP
Notice how the second substitution stopped matching as soon as it
encountered \*(L"y \*(R". The \f(CW\*(C`*?\*(C'\fR quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass
control on to whatever is next in line, as you would if you were
playing hot potato.
.SS "How do I process each word on each line?"
.IX Xref "word"
.IX Subsection "How do I process each word on each line?"
Use the split function:
.PP
.Vb 5
\&    while (<>) {
\&        foreach my $word ( split ) {
\&            # do something with $word here
\&        }
\&    }
.Ve
.PP
Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.
.PP
To work with only alphanumeric sequences (including underscores), you
might consider
.PP
.Vb 5
\&    while (<>) {
\&        foreach $word (m/(\ew+)/g) {
\&            # do something with $word here
\&        }
\&    }
.Ve
.SS "How can I print out a word-frequency or line-frequency summary?"
.IX Subsection "How can I print out a word-frequency or line-frequency summary?"
To do this, you have to parse out each word in the input stream. We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given
in the previous question:
.PP
.Vb 6
\&    my (%seen);
\&    while (<>) {
\&        while ( /(\eb[^\eW_\ed][\ew\*(Aq\-]+\eb)/g ) {   # misses "\`sheep\*(Aq"
\&            $seen{$1}++;
\&        }
\&    }
\&
\&    while ( my ($word, $count) = each %seen ) {
\&        print "$count $word\en";
\&    }
.Ve
.PP
If you wanted to do the same thing for lines, you wouldn't need a
regular expression:
.PP
.Vb 1
\&    my (%seen);
\&
\&    while (<>) {
\&        $seen{$_}++;
\&    }
\&
\&    while ( my ($line, $count) = each %seen ) {
\&        print "$count $line";
\&    }
.Ve
.PP
If you want these output in a sorted order, see perlfaq4: \*(L"How do I
sort a hash (optionally by value instead of key)?\*(R".
.SS "How can I do approximate matching?"
.IX Xref "match, approximate matching, approximate"
.IX Subsection "How can I do approximate matching?"
See the module String::Approx available from \s-1CPAN\s0.
.SS "How do I efficiently match many regular expressions at once?"
.IX Xref "regex, efficiency regexp, efficiency regular expression, efficiency"
.IX Subsection "How do I efficiently match many regular expressions at once?"
(contributed by brian d foy)
.PP
If you have Perl 5.10 or later, this is almost trivial. You just smart
match against an array of regular expression objects:
.PP
.Vb 1
\&    my @patterns = ( qr/Fr.d/, qr/B.rn.y/, qr/W.lm./ );
\&
\&    if( $string ~~ @patterns ) {
\&        ...
\&    };
.Ve
.PP
The smart match stops when it finds a match, so it doesn't have to try
every expression.
.PP
Earlier than Perl 5.10, you have a bit of work to do. You want to
avoid compiling a regular expression every time you want to match it.
In this example, perl must recompile the regular expression for every
iteration of the \f(CW\*(C`foreach\*(C'\fR loop since it has no way to know what
\&\f(CW$pattern\fR will be:
.PP
.Vb 1
\&    my @patterns = qw( foo bar baz );
\&
\&    LINE: while( <DATA> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /\eb$pattern\eb/i ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`qr//\*(C'\fR operator showed up in perl 5.005. It compiles a regular
expression, but doesn't apply it. When you use the pre-compiled
version of the regex, perl does less work. In this example, I inserted
a \f(CW\*(C`map\*(C'\fR to turn each pattern into its pre-compiled form. The rest of
the script is the same, but faster:
.PP
.Vb 1
\&    my @patterns = map { qr/\eb$_\eb/i } qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /$pattern/ ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
In some cases, you may be able to make several patterns into a single
regular expression. Beware of situations that require backtracking
though.
.PP
.Vb 1
\&    my $regex = join \*(Aq|\*(Aq, qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        print if /\eb(?:$regex)\eb/i;
\&    }
.Ve
.PP
For more details on regular expression efficiency, see \fIMastering
Regular Expressions\fR by Jeffrey Friedl. He explains how the regular
expressions engine works and why some patterns are surprisingly
inefficient. Once you understand how perl applies regular expressions,
you can tune them for individual situations.
.ie n .SS "Why don't word-boundary searches with ""\eb"" work for me?"
.el .SS "Why don't word-boundary searches with \f(CW\eb\fP work for me?"
.IX Xref "\\b"
.IX Subsection "Why don't word-boundary searches with b work for me?"
(contributed by brian d foy)
.PP
Ensure that you know what \eb really does: it's the boundary between a
word character, \ew, and something that isn't a word character. That
thing that isn't a word character might be \eW, but it can also be the
start or end of the string.
.PP
It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.
.PP
In regex speak, a word boundary (\eb) is a \*(L"zero width assertion\*(R",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.
.PP
For the regular expression, /\ebPerl\eb/, there has to be a word
boundary before the \*(L"P\*(R" and after the \*(L"l\*(R". As long as something other
than a word character precedes the \*(L"P\*(R" and succeeds the \*(L"l\*(R", the
pattern will match. These strings match /\ebPerl\eb/.
.PP
.Vb 4
\&    "Perl"    # no word char before P or after l
\&    "Perl "   # same as previous (space is not a word char)
\&    "\*(AqPerl\*(Aq"  # the \*(Aq char is not a word char
\&    "Perl\*(Aqs"  # no word char before P, non\-word char after "l"
.Ve
.PP
These strings do not match /\ebPerl\eb/.
.PP
.Vb 2
\&    "Perl_"   # _ is a word char!
\&    "Perler"  # no word char before P, but one after l
.Ve
.PP
You don't have to use \eb to match words though. You can look for
non-word characters surrounded by word characters. These strings
match the pattern /\eb'\eb/.
.PP
.Vb 2
\&    "don\*(Aqt"   # the \*(Aq char is surrounded by "n" and "t"
\&    "qep\*(Aqa\*(Aq"  # the \*(Aq char is surrounded by "p" and "a"
.Ve
.PP
These strings do not match /\eb'\eb/.
.PP
.Vb 1
\&    "foo\*(Aq"    # there is no word char after non\-word \*(Aq
.Ve
.PP
You can also use the complement of \eb, \eB, to specify that there
should not be a word boundary.
.PP
In the pattern /\eBam\eB/, there must be a word character before the \*(L"a\*(R"
and after the \*(L"m\*(R". These patterns match /\eBam\eB/:
.PP
.Vb 2
\&    "llama"   # "am" surrounded by word chars
\&    "Samuel"  # same
.Ve
.PP
These strings do not match /\eBam\eB/
.PP
.Vb 2
\&    "Sam"      # no word boundary before "a", but one after "m"
\&    "I am Sam" # "am" surrounded by non\-word chars
.Ve
.SS "Why does using $&, $`, or $' slow my program down?"
.IX Xref "$MATCH $& $POSTMATCH $' $PREMATCH $`"
.IX Subsection "Why does using $&, $`, or $' slow my program down?"
(contributed by Anno Siegel)
.PP
Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer \*(L"expensive\*(R" the way the other two are.
.PP
Since Perl 5.6.1 the special variables @\- and @+ can functionally replace
$`, $& and $'. These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.
.PP
Perl 5.10 added three specials, \f(CW\*(C`${^MATCH}\*(C'\fR, \f(CW\*(C`${^PREMATCH}\*(C'\fR, and
\&\f(CW\*(C`${^POSTMATCH}\*(C'\fR to do the same job but without the global performance
penalty. Perl 5.10 only sets these variables if you compile or execute the
regular expression with the \f(CW\*(C`/p\*(C'\fR modifier.
.ie n .SS "What good is ""\eG"" in a regular expression?"
.el .SS "What good is \f(CW\eG\fP in a regular expression?"
.IX Xref "\\G"
.IX Subsection "What good is G in a regular expression?"
You use the \f(CW\*(C`\eG\*(C'\fR anchor to start the next match on the same
string where the last match left off. The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so \f(CW\*(C`\eG\*(C'\fR is similar to the
beginning of string anchor, \f(CW\*(C`^\*(C'\fR. The \f(CW\*(C`\eG\*(C'\fR anchor is typically
used with the \f(CW\*(C`g\*(C'\fR flag. It uses the value of \f(CW\*(C`pos()\*(C'\fR
as the position to start the next match. As the match
operator makes successive matches, it updates \f(CW\*(C`pos()\*(C'\fR with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own \f(CW\*(C`pos()\*(C'\fR value.
.PP
Suppose you want to match all of consecutive pairs of digits
in a string like \*(L"1122a44\*(R" and stop matching when you
encounter non-digits. You want to match \f(CW11\fR and \f(CW22\fR but
the letter <a> shows up between \f(CW22\fR and \f(CW44\fR and you want
to stop at \f(CW\*(C`a\*(C'\fR. Simply matching pairs of digits skips over
the \f(CW\*(C`a\*(C'\fR and still matches \f(CW44\fR.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    my @pairs = m/(\ed\ed)/g;   # qw( 11 22 44 )
.Ve
.PP
If you use the \f(CW\*(C`\eG\*(C'\fR anchor, you force the match after \f(CW22\fR to
start with the \f(CW\*(C`a\*(C'\fR. The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    my @pairs = m/\eG(\ed\ed)/g; # qw( 11 22 )
.Ve
.PP
You can also use the \f(CW\*(C`\eG\*(C'\fR anchor in scalar context. You
still need the \f(CW\*(C`g\*(C'\fR flag.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
.Ve
.PP
After the match fails at the letter \f(CW\*(C`a\*(C'\fR, perl resets \f(CW\*(C`pos()\*(C'\fR
and the next match on the same string starts at the beginning.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 after while" if m/(\ed\ed)/g; # finds "11"
.Ve
.PP
You can disable \f(CW\*(C`pos()\*(C'\fR resets on fail with the \f(CW\*(C`c\*(C'\fR flag, documented
in perlop and perlreref. Subsequent matches start where the last
successful match ended (the value of \f(CW\*(C`pos()\*(C'\fR) even if a match on the
same string has failed in the meantime. In this case, the match after
the \f(CW\*(C`while()\*(C'\fR loop starts at the \f(CW\*(C`a\*(C'\fR (where the last match stopped),
and since it does not use any anchor it can skip over the \f(CW\*(C`a\*(C'\fR to find
\&\f(CW44\fR.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/gc ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 after while" if m/(\ed\ed)/g; # finds "44"
.Ve
.PP
Typically you use the \f(CW\*(C`\eG\*(C'\fR anchor with the \f(CW\*(C`c\*(C'\fR flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.
.PP
.Vb 9
\&    while (<>) {
\&        chomp;
\&        PARSER: {
\&            m/ \eG( \ed+\eb    )/gcx   && do { print "number: $1\en";  redo; };
\&            m/ \eG( \ew+      )/gcx   && do { print "word:   $1\en";  redo; };
\&            m/ \eG( \es+      )/gcx   && do { print "space:  $1\en";  redo; };
\&            m/ \eG( [^\ew\ed]+ )/gcx   && do { print "other:  $1\en";  redo; };
\&        }
\&    }
.Ve
.PP
For each line, the \f(CW\*(C`PARSER\*(C'\fR loop first tries to match a series
of digits followed by a word boundary. This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since \f(CW\*(C`m/ \eG( \ed+\eb
)/gcx\*(C'\fR uses the \f(CW\*(C`c\*(C'\fR flag, if the string does not match that
regular expression, perl does not reset \fIpos()\fR and the next
match starts at the same position to try a different
pattern.
.SS "Are Perl regexes DFAs or NFAs? Are they \s-1POSIX\s0 compliant?"
.IX Xref "DFA NFA POSIX"
.IX Subsection "Are Perl regexes DFAs or NFAs? Are they POSIX compliant?"
While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the \fIegrep\fR\|(1) program, they are in
fact implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing. And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases. (It seems
that some people prefer guarantees of consistency, even when what's
guaranteed is slowness.) See the book \*(L"Mastering Regular Expressions\*(R"
(from O'Reilly) by Jeffrey Friedl for all the details you could ever
hope to know on these matters (a full citation appears in
perlfaq2).
.SS "What's wrong with using grep in a void context?"
.IX Xref "grep"
.IX Subsection "What's wrong with using grep in a void context?"
The problem is that grep builds a return list, regardless of the context.
This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
purpose.
.PP
In perls older than 5.8.1, map suffers from this problem as well.
But since 5.8.1, this has been fixed, and map is context aware \- in void
context, no lists are constructed.
.SS "How can I match strings with multibyte characters?"
.IX Xref "regex, and multibyte characters regexp, and multibyte characters regular expression, and multibyte characters martian encoding, Martian"
.IX Subsection "How can I match strings with multibyte characters?"
Starting from Perl 5.6 Perl has had some level of multibyte character
support. Perl 5.8 or later is recommended. Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module. See perluniintro, perlunicode,
and Encode.
.PP
If you are stuck with older Perls, you can do Unicode with the
Unicode::String module, and character conversions using the
Unicode::Map8 and Unicode::Map modules. If you are using
Japanese encodings, you might try using the jperl 5.005_03.
.PP
Finally, the following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.
.PP
Let's suppose you have some weird Martian encoding where pairs of
\&\s-1ASCII\s0 uppercase letters encode single Martian letters (i.e. the two
bytes \*(L"\s-1CV\s0\*(R" make a single Martian letter, as do the two bytes \*(L"\s-1SG\s0\*(R",
\&\*(L"\s-1VS\s0\*(R", \*(L"\s-1XX\s0\*(R", etc.). Other bytes represent single characters, just like
\&\s-1ASCII\s0.
.PP
So, the string of Martian \*(L"I am \s-1CVSGXX\s0!\*(R" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', '\s-1CV\s0', '\s-1SG\s0', '\s-1XX\s0', '!'.
.PP
Now, say you want to search for the single character \f(CW\*(C`/GX/\*(C'\fR. Perl
doesn't know about Martian, so it'll find the two bytes \*(L"\s-1GX\s0\*(R" in the \*(L"I
am \s-1CVSGXX\s0!\*(R" string, even though that character isn't there: it just
looks like it is because \*(L"\s-1SG\s0\*(R" is next to \*(L"\s-1XX\s0\*(R", but there's no real
\&\*(L"\s-1GX\s0\*(R". This is a big problem.
.PP
Here are a few ways, all painful, to deal with it:
.PP
.Vb 2
\&    # Make sure adjacent "martian" bytes are no longer adjacent.
\&    $martian =~ s/([A\-Z][A\-Z])/ $1 /g;
\&
\&    print "found GX!\en" if $martian =~ /GX/;
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    my @chars = $martian =~ m/([A\-Z][A\-Z]|[^A\-Z])/g;
\&    # above is conceptually similar to:     my @chars = $text =~ m/(.)/g;
\&    #
\&    foreach my $char (@chars) {
\&        print "found GX!\en", last if $char eq \*(AqGX\*(Aq;
\&    }
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    while ($martian =~ m/\eG([A\-Z][A\-Z]|.)/gs) {  # \eG probably unneeded
\&        if ($1 eq \*(AqGX\*(Aq) {
\&            print "found GX!\en";
\&            last;
\&        }
\&    }
.Ve
.PP
Here's another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind assertion.
.PP
.Vb 5
\&    print "found GX!\en" if    $martian =~ m/
\&        (?<![A\-Z])
\&        (?:[A\-Z][A\-Z])*?
\&        GX
\&        /x;
.Ve
.PP
This succeeds if the \*(L"martian\*(R" character \s-1GX\s0 is in the string, and fails
otherwise. If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A\-Z]) with (?:^|[^A\-Z]).
.PP
It does have the drawback of putting the wrong thing in $\-[0] and $+[0],
but this usually can be worked around.
.SS "How do I match a regular expression that's in a variable?"
.IX Xref "regex, in variable eval regex quotemeta \\Q, regex \\E, regex qr"
.IX Subsection "How do I match a regular expression that's in a variable?"
(contributed by brian d foy)
.PP
We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.
.PP
The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in \f(CW$regex\fR.
Once you have the pattern in \f(CW$regex\fR, you use that variable in the
match operator.
.PP
.Vb 1
\&    chomp( my $regex = <STDIN> );
\&
\&    if( $string =~ m/$regex/ ) { ... }
.Ve
.PP
Any regular expression special characters in \f(CW$regex\fR are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.
.PP
.Vb 1
\&    my $regex = "Unmatched ( paren";
\&
\&    "Two parens to bind them all" =~ m/$regex/;
.Ve
.PP
When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:
.PP
.Vb 1
\&    Unmatched ( in regex; marked by <\-\- HERE in m/Unmatched ( <\-\- HERE  paren/ at script line 3.
.Ve
.PP
You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with \f(CW\*(C`quotemeta\*(C'\fR before you use the string.
.PP
.Vb 2
\&    chomp( my $regex = <STDIN> );
\&    $regex = quotemeta( $regex );
\&
\&    if( $string =~ m/$regex/ ) { ... }
.Ve
.PP
You can also do this directly in the match operator using the \f(CW\*(C`\eQ\*(C'\fR
and \f(CW\*(C`\eE\*(C'\fR sequences. The \f(CW\*(C`\eQ\*(C'\fR tells Perl where to start escaping
special characters, and the \f(CW\*(C`\eE\*(C'\fR tells it where to stop (see perlop
for more details).
.PP
.Vb 1
\&    chomp( my $regex = <STDIN> );
\&
\&    if( $string =~ m/\eQ$regex\eE/ ) { ... }
.Ve
.PP
Alternately, you can use \f(CW\*(C`qr//\*(C'\fR, the regular expression quote operator (see
perlop for more details). It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.
.PP
.Vb 1
\&    chomp( my $input = <STDIN> );
\&
\&    my $regex = qr/$input/is;
\&
\&    $string =~ m/$regex/  # same as m/$input/is;
.Ve
.PP
You might also want to trap any errors by wrapping an \f(CW\*(C`eval\*(C'\fR block
around the whole thing.
.PP
.Vb 1
\&    chomp( my $input = <STDIN> );
\&
\&    eval {
\&        if( $string =~ m/\eQ$input\eE/ ) { ... }
\&    };
\&    warn $@ if $@;
.Ve
.PP
Or...
.PP
.Vb 7
\&    my $regex = eval { qr/$input/is };
\&    if( defined $regex ) {
\&        $string =~ m/$regex/;
\&    }
\&    else {
\&        warn $@;
\&    }
.Ve
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq65.18.1                               0100644 0001750 0001750 00000142115 12566207437 023004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ6 1"
.TH PERLFAQ6 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq6 \- Regular Expressions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section is surprisingly small because the rest of the \s-1FAQ\s0 is
littered with answers involving regular expressions. For example,
decoding a \s-1URL\s0 and checking whether something is a number can be handled
with regular expressions, but those answers are found elsewhere in
this document (in perlfaq9: \*(L"How do I decode or create those %\-encodings
on the web\*(R" and perlfaq4: \*(L"How do I determine whether a scalar is
a number/whole/integer/float\*(R", to be precise).
.SS "How can I hope to use regular expressions without creating illegible and unmaintainable code?"
.IX Xref "regex, legibility regexp, legibility regular expression, legibility x"
.IX Subsection "How can I hope to use regular expressions without creating illegible and unmaintainable code?"
Three techniques can make regular expressions maintainable and
understandable.
.IP "Comments Outside the Regex" 4
.IX Item "Comments Outside the Regex"
Describe what you're doing and how you're doing it, using normal Perl
comments.
.Sp
.Vb 3
\&    # turn the line into the first word, a colon, and the
\&    # number of characters on the rest of the line
\&    s/^(\ew+)(.*)/ lc($1) . ":" . length($2) /meg;
.Ve
.IP "Comments Inside the Regex" 4
.IX Item "Comments Inside the Regex"
The \f(CW\*(C`/x\*(C'\fR modifier causes whitespace to be ignored in a regex pattern
(except in a character class and a few other places), and also allows you to
use normal comments there, too. As you can imagine, whitespace and comments
help a lot.
.Sp
\&\f(CW\*(C`/x\*(C'\fR lets you turn this:
.Sp
.Vb 1
\&    s{<(?:[^>\*(Aq"]*|".*?"|\*(Aq.*?\*(Aq)+>}{}gs;
.Ve
.Sp
into this:
.Sp
.Vb 10
\&    s{ <                    # opening angle bracket
\&        (?:                 # Non\-backreffing grouping paren
\&            [^>\*(Aq"] *        # 0 or more things that are neither > nor \*(Aq nor "
\&                |           #    or else
\&            ".*?"           # a section between double quotes (stingy match)
\&                |           #    or else
\&            \*(Aq.*?\*(Aq           # a section between single quotes (stingy match)
\&        ) +                 #   all occurring one or more times
\&        >                   # closing angle bracket
\&    }{}gsx;                 # replace with nothing, i.e. delete
.Ve
.Sp
It's still not quite so clear as prose, but it is very useful for
describing the meaning of each part of the pattern.
.IP "Different Delimiters" 4
.IX Item "Different Delimiters"
While we normally think of patterns as being delimited with \f(CW\*(C`/\*(C'\fR
characters, they can be delimited by almost any character. perlre
describes this. For example, the \f(CW\*(C`s///\*(C'\fR above uses braces as
delimiters. Selecting another delimiter can avoid quoting the
delimiter within the pattern:
.Sp
.Vb 2
\&    s/\e/usr\e/local/\e/usr\e/share/g;    # bad delimiter choice
\&    s#/usr/local#/usr/share#g;        # better
.Ve
.Sp
Using logically paired delimiters can be even more readable:
.Sp
.Vb 1
\&    s{/usr/local/}{/usr/share}g;      # better still
.Ve
.SS "I'm having trouble matching over more than one line. What's wrong?"
.IX Xref "regex, multiline regexp, multiline regular expression, multiline"
.IX Subsection "I'm having trouble matching over more than one line. What's wrong?"
Either you don't have more than one line in the string you're looking
at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).
.PP
There are many ways to get multiline data into a string. If you want
it to happen automatically while reading input, you'll want to set $/
(probably to '' for paragraphs or \f(CW\*(C`undef\*(C'\fR for the whole file) to
allow you to read more than one line at a time.
.PP
Read perlre to help you decide which of \f(CW\*(C`/s\*(C'\fR and \f(CW\*(C`/m\*(C'\fR (or both)
you might want to use: \f(CW\*(C`/s\*(C'\fR allows dot to include newline, and \f(CW\*(C`/m\*(C'\fR
allows caret and dollar to match next to a newline, not just at the
end of the string. You do need to make sure that you've actually
got a multiline string in there.
.PP
For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones). For this example, we don't need
\&\f(CW\*(C`/s\*(C'\fR because we aren't using dot in a regular expression that we want
to cross line boundaries. Neither do we need \f(CW\*(C`/m\*(C'\fR because we don't
want caret or dollar to match at any point inside the record next
to newlines. But it's imperative that $/ be set to something other
than the default, or else we won't actually ever have a multiline
record read in.
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /\eb([\ew\*(Aq\-]+)(\es+\eg1)+\eb/gi ) {     # word starts alpha
\&            print "Duplicate $1 at paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Here's some code that finds sentences that begin with \*(L"From \*(R" (which would
be mangled by many mailers):
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /^From /gm ) { # /m makes ^ match next to \en
\&        print "leading from in paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Here's code that finds everything between \s-1START\s0 and \s-1END\s0 in a paragraph:
.PP
.Vb 6
\&    undef $/;          # read in whole file, not just one line or paragraph
\&    while ( <> ) {
\&        while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
\&            print "$1\en";
\&        }
\&    }
.Ve
.SS "How can I pull out lines between two patterns that are themselves on different lines?"
.IX Xref ".."
.IX Subsection "How can I pull out lines between two patterns that are themselves on different lines?"
You can use Perl's somewhat exotic \f(CW\*(C`..\*(C'\fR operator (documented in
perlop):
.PP
.Vb 1
\&    perl \-ne \*(Aqprint if /START/ .. /END/\*(Aq file1 file2 ...
.Ve
.PP
If you wanted text and not lines, you would use
.PP
.Vb 1
\&    perl \-0777 \-ne \*(Aqprint "$1\en" while /START(.*?)END/gs\*(Aq file1 file2 ...
.Ve
.PP
But if you want nested occurrences of \f(CW\*(C`START\*(C'\fR through \f(CW\*(C`END\*(C'\fR, you'll
run up against the problem described in the question in this section
on matching balanced text.
.PP
Here's another example of using \f(CW\*(C`..\*(C'\fR:
.PP
.Vb 7
\&    while (<>) {
\&        my $in_header =   1  .. /^$/;
\&        my $in_body   = /^$/ .. eof;
\&    # now choose between them
\&    } continue {
\&        $. = 0 if eof;    # fix $.
\&    }
.Ve
.SS "How do I match \s-1XML, HTML,\s0 or other nasty, ugly things with a regex?"
.IX Xref "regex, XML regex, HTML XML HTML pain frustration sucking out, will to live"
.IX Subsection "How do I match XML, HTML, or other nasty, ugly things with a regex?"
Do not use regexes. Use a module and forget about the
regular expressions. The XML::LibXML, HTML::TokeParser and
HTML::TreeBuilder modules are good starts, although each namespace
has other parsing modules specialized for certain tasks and different
ways of doing it. Start at \s-1CPAN\s0 Search ( <http://metacpan.org/> )
and wonder at all the work people have done for you already! :)
.SS "I put a regular expression into $/ but it didn't work. What's wrong?"
.IX Xref "$ , regexes in $INPUT_RECORD_SEPARATOR, regexes in $RS, regexes in"
.IX Subsection "I put a regular expression into $/ but it didn't work. What's wrong?"
$/ has to be a string. You can use these examples if you really need to
do this.
.PP
If you have File::Stream, this is easy.
.PP
.Vb 1
\&    use File::Stream;
\&
\&    my $stream = File::Stream\->new(
\&        $filehandle,
\&        separator => qr/\es*,\es*/,
\&        );
\&
\&    print "$_\en" while <$stream>;
.Ve
.PP
If you don't have File::Stream, you have to do a little more work.
.PP
You can use the four-argument form of sysread to continually add to
a buffer. After you add to the buffer, you check if you have a
complete line (using your regular expression).
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        while( s/^((?s).*?)your_pattern// ) {
\&            my $record = $1;
\&            # do stuff here.
\&        }
\&    }
.Ve
.PP
You can do the same thing with foreach and a match using the
c flag and the \eG anchor, if you do not mind your entire file
being in memory at the end.
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        foreach my $record ( m/\eG((?s).*?)your_pattern/gc ) {
\&            # do stuff here.
\&        }
\&        substr( $_, 0, pos ) = "" if pos;
\&    }
.Ve
.SS "How do I substitute case-insensitively on the \s-1LHS\s0 while preserving case on the \s-1RHS\s0?"
.IX Xref "replace, case preserving substitute, case preserving substitution, case preserving s, case preserving"
.IX Subsection "How do I substitute case-insensitively on the LHS while preserving case on the RHS?"
Here's a lovely Perlish solution by Larry Rosler. It exploits
properties of bitwise xor on \s-1ASCII\s0 strings.
.PP
.Vb 1
\&    $_= "this is a TEsT case";
\&
\&    $old = \*(Aqtest\*(Aq;
\&    $new = \*(Aqsuccess\*(Aq;
\&
\&    s{(\eQ$old\eE)}
\&    { uc $new | (uc $1 ^ $1) .
\&        (uc(substr $1, \-1) ^ substr $1, \-1) x
\&        (length($new) \- length $1)
\&    }egi;
\&
\&    print;
.Ve
.PP
And here it is as a subroutine, modeled after the above:
.PP
.Vb 3
\&    sub preserve_case {
\&        my ($old, $new) = @_;
\&        my $mask = uc $old ^ $old;
\&
\&        uc $new | $mask .
\&            substr($mask, \-1) x (length($new) \- length($old))
\&    }
\&
\&    $string = "this is a TEsT case";
\&    $string =~ s/(test)/preserve_case($1, "success")/egi;
\&    print "$string\en";
.Ve
.PP
This prints:
.PP
.Vb 1
\&    this is a SUcCESS case
.Ve
.PP
As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:
.PP
.Vb 3
\&    sub preserve_case {
\&        my ($from, $to) = @_;
\&        my ($lf, $lt) = map length, @_;
\&
\&        if ($lt < $lf) { $from = substr $from, 0, $lt }
\&        else { $from .= substr $to, $lf }
\&
\&        return uc $to | ($from ^ uc $from);
\&    }
.Ve
.PP
This changes the sentence to \*(L"this is a SUcCess case.\*(R"
.PP
Just to show that C programmers can write C in any programming language,
if you prefer a more C\-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.
.PP
.Vb 8
\&    # Original by Nathan Torkington, massaged by Jeffrey Friedl
\&    #
\&    sub preserve_case
\&    {
\&        my ($old, $new) = @_;
\&        my $state = 0; # 0 = no change; 1 = lc; 2 = uc
\&        my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
\&        my $len = $oldlen < $newlen ? $oldlen : $newlen;
\&
\&        for ($i = 0; $i < $len; $i++) {
\&            if ($c = substr($old, $i, 1), $c =~ /[\eW\ed_]/) {
\&                $state = 0;
\&            } elsif (lc $c eq $c) {
\&                substr($new, $i, 1) = lc(substr($new, $i, 1));
\&                $state = 1;
\&            } else {
\&                substr($new, $i, 1) = uc(substr($new, $i, 1));
\&                $state = 2;
\&            }
\&        }
\&        # finish up with any remaining new (for when new is longer than old)
\&        if ($newlen > $oldlen) {
\&            if ($state == 1) {
\&                substr($new, $oldlen) = lc(substr($new, $oldlen));
\&            } elsif ($state == 2) {
\&                substr($new, $oldlen) = uc(substr($new, $oldlen));
\&            }
\&        }
\&        return $new;
\&    }
.Ve
.ie n .SS "How can I make ""\ew"" match national character sets?"
.el .SS "How can I make \f(CW\ew\fP match national character sets?"
.IX Xref "\\w"
.IX Subsection "How can I make w match national character sets?"
Put \f(CW\*(C`use locale;\*(C'\fR in your script. The \ew character class is taken
from the current locale.
.PP
See perllocale for details.
.ie n .SS "How can I match a locale-smart version of ""/[a\-zA\-Z]/""?"
.el .SS "How can I match a locale-smart version of \f(CW/[a\-zA\-Z]/\fP?"
.IX Xref "alpha"
.IX Subsection "How can I match a locale-smart version of /[a-zA-Z]/?"
You can use the \s-1POSIX\s0 character class syntax \f(CW\*(C`/[[:alpha:]]/\*(C'\fR
documented in perlre.
.PP
No matter which locale you are in, the alphabetic characters are
the characters in \ew without the digits and the underscore.
As a regex, that looks like \f(CW\*(C`/[^\eW\ed_]/\*(C'\fR. Its complement,
the non-alphabetics, is then everything in \eW along with
the digits and the underscore, or \f(CW\*(C`/[\eW\ed_]/\*(C'\fR.
.SS "How can I quote a variable to use in a regex?"
.IX Xref "regex, escaping regexp, escaping regular expression, escaping"
.IX Subsection "How can I quote a variable to use in a regex?"
The Perl parser will expand \f(CW$variable\fR and \f(CW@variable\fR references in
regular expressions unless the delimiter is a single quote. Remember,
too, that the right-hand side of a \f(CW\*(C`s///\*(C'\fR substitution is considered
a double-quoted string (see perlop for more details). Remember
also that any regex special characters will be acted on unless you
precede the substitution with \eQ. Here's an example:
.PP
.Vb 2
\&    $string = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $string =~ s/$regex/Polyp/;
\&    # $string is now "Polypacido P. Octopus"
.Ve
.PP
Because \f(CW\*(C`.\*(C'\fR is special in regular expressions, and can match any
single character, the regex \f(CW\*(C`P.\*(C'\fR here has matched the <Pl> in the
original string.
.PP
To escape the special meaning of \f(CW\*(C`.\*(C'\fR, we use \f(CW\*(C`\eQ\*(C'\fR:
.PP
.Vb 2
\&    $string = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $string =~ s/\eQ$regex/Polyp/;
\&    # $string is now "Placido Polyp Octopus"
.Ve
.PP
The use of \f(CW\*(C`\eQ\*(C'\fR causes the <.> in the regex to be treated as a
regular character, so that \f(CW\*(C`P.\*(C'\fR matches a \f(CW\*(C`P\*(C'\fR followed by a dot.
.ie n .SS "What is ""/o"" really for?"
.el .SS "What is \f(CW/o\fP really for?"
.IX Xref " o, regular expressions compile, regular expressions"
.IX Subsection "What is /o really for?"
(contributed by brian d foy)
.PP
The \f(CW\*(C`/o\*(C'\fR option for regular expressions (documented in perlop and
perlreref) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.
.PP
Since the match operator \f(CW\*(C`m//\*(C'\fR, the substitution operator \f(CW\*(C`s///\*(C'\fR,
and the regular expression quoting operator \f(CW\*(C`qr//\*(C'\fR are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to \*(L"How can I quote a variable to use in a regex?\*(R" for more
details.
.PP
This example takes a regular expression from the argument list and
prints the lines of input that match it:
.PP
.Vb 1
\&    my $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/;
\&    }
.Ve
.PP
Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if \f(CW$pattern\fR had not changed. The \f(CW\*(C`/o\*(C'\fR
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:
.PP
.Vb 1
\&    my $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/o; # useful for Perl < 5.6
\&    }
.Ve
.PP
In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the \f(CW\*(C`/o\*(C'\fR
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the \f(CW\*(C`/o\*(C'\fR.
.PP
You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The \f(CW\*(C`use re
\&\*(Aqdebug\*(Aq\*(C'\fR pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see \f(CW\*(C`re\*(C'\fR reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see \f(CW\*(C`re\*(C'\fR report that for the first iteration.
.PP
.Vb 1
\&    use re \*(Aqdebug\*(Aq;
\&
\&    my $regex = \*(AqPerl\*(Aq;
\&    foreach ( qw(Perl Java Ruby Python) ) {
\&        print STDERR "\-" x 73, "\en";
\&        print STDERR "Trying $_...\en";
\&        print STDERR "\et$_ is good!\en" if m/$regex/;
\&    }
.Ve
.SS "How do I use a regular expression to strip C\-style comments from a file?"
.IX Subsection "How do I use a regular expression to strip C-style comments from a file?"
While this actually can be done, it's much harder than you'd think.
For example, this one-liner
.PP
.Vb 1
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
.Ve
.PP
will work in many but not all cases. You see, it's too simple-minded for
certain kinds of C programs, in particular, those with what appear to be
comments in quoted strings. For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.
.PP
.Vb 4
\&    $/ = undef;
\&    $_ = <>;
\&    s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $2 ? $2 : ""#gse;
\&    print;
.Ve
.PP
This could, of course, be more legibly written with the \f(CW\*(C`/x\*(C'\fR modifier, adding
whitespace and comments. Here it is expanded, courtesy of Fred Curtis.
.PP
.Vb 8
\&    s{
\&       /\e*         ##  Start of /* ... */ comment
\&       [^*]*\e*+    ##  Non\-* followed by 1\-or\-more *\*(Aqs
\&       (
\&         [^/*][^*]*\e*+
\&       )*          ##  0\-or\-more things which don\*(Aqt start with /
\&                   ##    but do end with \*(Aq*\*(Aq
\&       /           ##  End of /* ... */ comment
\&
\&     |         ##     OR  various things which aren\*(Aqt comments:
\&
\&       (
\&         "           ##  Start of " ... " string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^"\e\e]        ##  Non "\e
\&         )*
\&         "           ##  End of " ... " string
\&
\&       |         ##     OR
\&
\&         \*(Aq           ##  Start of \*(Aq ... \*(Aq string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^\*(Aq\e\e]        ##  Non \*(Aq\e
\&         )*
\&         \*(Aq           ##  End of \*(Aq ... \*(Aq string
\&
\&       |         ##     OR
\&
\&         .           ##  Anything other char
\&         [^/"\*(Aq\e\e]*   ##  Chars which doesn\*(Aqt start a comment, string or escape
\&       )
\&     }{defined $2 ? $2 : ""}gxse;
.Ve
.PP
A slight modification also removes \*(C+ comments, possibly spanning multiple lines
using a continuation character:
.PP
.Vb 1
\& s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|//([^\e\e]|[^\en][\en]?)*?\en|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $3 ? $3 : ""#gse;
.Ve
.SS "Can I use Perl regular expressions to match balanced text?"
.IX Xref "regex, matching balanced test regexp, matching balanced test regular expression, matching balanced test possessive PARNO Text::Balanced Regexp::Common backtracking recursion"
.IX Subsection "Can I use Perl regular expressions to match balanced text?"
(contributed by brian d foy)
.PP
Your first try should probably be the Text::Balanced module, which
is in the Perl standard library since Perl 5.8. It has a variety of
functions to deal with tricky text. The Regexp::Common module can
also help by providing canned patterns you can use.
.PP
As of Perl 5.10, you can match balanced text with regular expressions
using recursive patterns. Before Perl 5.10, you had to resort to
various tricks such as using Perl code in \f(CW\*(C`(??{})\*(C'\fR sequences.
.PP
Here's an example using a recursive regular expression. The goal is to
capture all of the text within angle brackets, including the text in
nested angle brackets. This sample text has two \*(L"major\*(R" groups: a
group with one level of nesting and a group with two levels of
nesting. There are five total groups in angle brackets:
.PP
.Vb 3
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
.Ve
.PP
The regular expression to match the balanced text uses two new (to
Perl 5.10) regular expression features. These are covered in perlre
and this example is a modified version of one in that documentation.
.PP
First, adding the new possessive \f(CW\*(C`+\*(C'\fR to any quantifier finds the
longest match and does not backtrack. That's important since you want
to handle any angle brackets through the recursion, not backtracking.
The group \f(CW\*(C`[^<>]++\*(C'\fR finds one or more non-angle brackets without
backtracking.
.PP
Second, the new \f(CW\*(C`(?PARNO)\*(C'\fR refers to the sub-pattern in the
particular capture group given by \f(CW\*(C`PARNO\*(C'\fR. In the following regex,
the first capture group finds (and remembers) the balanced text, and
you need that same pattern within the first buffer to get past the
nested text. That's the recursive part. The \f(CW\*(C`(?1)\*(C'\fR uses the pattern
in the outer capture group as an independent part of the regex.
.PP
Putting it all together, you have:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    my $string =<<"HERE";
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
\&    HERE
\&
\&    my @groups = $string =~ m/
\&            (                   # start of capture group 1
\&            <                   # match an opening angle bracket
\&                (?:
\&                    [^<>]++     # one or more non angle brackets, non backtracking
\&                      |
\&                    (?1)        # found < or >, so recurse to capture group 1
\&                )*
\&            >                   # match a closing angle bracket
\&            )                   # end of capture group 1
\&            /xg;
\&
\&    $" = "\en\et";
\&    print "Found:\en\et@groups\en";
.Ve
.PP
The output shows that Perl found the two major groups:
.PP
.Vb 3
\&    Found:
\&        <brackets in <nested brackets> >
\&        <another group <nested once <nested twice> > >
.Ve
.PP
With a little extra work, you can get the all of the groups in angle
brackets even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter (that's the one you
just matched so don't match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    my @queue =<<"HERE";
\&    I have some <brackets in <nested brackets> > and
\&    <another group <nested once <nested twice> > >
\&    and that\*(Aqs it.
\&    HERE
\&
\&    my $regex = qr/
\&            (                   # start of bracket 1
\&            <                   # match an opening angle bracket
\&                (?:
\&                    [^<>]++     # one or more non angle brackets, non backtracking
\&                      |
\&                    (?1)        # recurse to bracket 1
\&                )*
\&            >                   # match a closing angle bracket
\&            )                   # end of bracket 1
\&            /x;
\&
\&    $" = "\en\et";
\&
\&    while( @queue ) {
\&        my $string = shift @queue;
\&
\&        my @groups = $string =~ m/$regex/g;
\&        print "Found:\en\et@groups\en\en" if @groups;
\&
\&        unshift @queue, map { s/^<//; s/>$//; $_ } @groups;
\&    }
.Ve
.PP
The output shows all of the groups. The outermost matches show up
first and the nested matches so up later:
.PP
.Vb 3
\&    Found:
\&        <brackets in <nested brackets> >
\&        <another group <nested once <nested twice> > >
\&
\&    Found:
\&        <nested brackets>
\&
\&    Found:
\&        <nested once <nested twice> >
\&
\&    Found:
\&        <nested twice>
.Ve
.SS "What does it mean that regexes are greedy? How can I get around it?"
.IX Xref "greedy greediness"
.IX Subsection "What does it mean that regexes are greedy? How can I get around it?"
Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (\f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`{}\*(C'\fR) that are greedy rather than the whole pattern; Perl prefers local
greed and immediate gratification to overall greed. To get non-greedy
versions of the same quantifiers, use (\f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{}?\*(C'\fR).
.PP
An example:
.PP
.Vb 3
\&    my $s1 = my $s2 = "I am very very cold";
\&    $s1 =~ s/ve.*y //;      # I am cold
\&    $s2 =~ s/ve.*?y //;     # I am very cold
.Ve
.PP
Notice how the second substitution stopped matching as soon as it
encountered \*(L"y \*(R". The \f(CW\*(C`*?\*(C'\fR quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass
control on to whatever is next in line, as you would if you were
playing hot potato.
.SS "How do I process each word on each line?"
.IX Xref "word"
.IX Subsection "How do I process each word on each line?"
Use the split function:
.PP
.Vb 5
\&    while (<>) {
\&        foreach my $word ( split ) {
\&            # do something with $word here
\&        }
\&    }
.Ve
.PP
Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.
.PP
To work with only alphanumeric sequences (including underscores), you
might consider
.PP
.Vb 5
\&    while (<>) {
\&        foreach $word (m/(\ew+)/g) {
\&            # do something with $word here
\&        }
\&    }
.Ve
.SS "How can I print out a word-frequency or line-frequency summary?"
.IX Subsection "How can I print out a word-frequency or line-frequency summary?"
To do this, you have to parse out each word in the input stream. We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given
in the previous question:
.PP
.Vb 6
\&    my (%seen);
\&    while (<>) {
\&        while ( /(\eb[^\eW_\ed][\ew\*(Aq\-]+\eb)/g ) {   # misses "\`sheep\*(Aq"
\&            $seen{$1}++;
\&        }
\&    }
\&
\&    while ( my ($word, $count) = each %seen ) {
\&        print "$count $word\en";
\&    }
.Ve
.PP
If you wanted to do the same thing for lines, you wouldn't need a
regular expression:
.PP
.Vb 1
\&    my (%seen);
\&
\&    while (<>) {
\&        $seen{$_}++;
\&    }
\&
\&    while ( my ($line, $count) = each %seen ) {
\&        print "$count $line";
\&    }
.Ve
.PP
If you want these output in a sorted order, see perlfaq4: \*(L"How do I
sort a hash (optionally by value instead of key)?\*(R".
.SS "How can I do approximate matching?"
.IX Xref "match, approximate matching, approximate"
.IX Subsection "How can I do approximate matching?"
See the module String::Approx available from \s-1CPAN.\s0
.SS "How do I efficiently match many regular expressions at once?"
.IX Xref "regex, efficiency regexp, efficiency regular expression, efficiency"
.IX Subsection "How do I efficiently match many regular expressions at once?"
(contributed by brian d foy)
.PP
If you have Perl 5.10 or later, this is almost trivial. You just smart
match against an array of regular expression objects:
.PP
.Vb 1
\&    my @patterns = ( qr/Fr.d/, qr/B.rn.y/, qr/W.lm./ );
\&
\&    if( $string ~~ @patterns ) {
\&        ...
\&    };
.Ve
.PP
The smart match stops when it finds a match, so it doesn't have to try
every expression.
.PP
Earlier than Perl 5.10, you have a bit of work to do. You want to
avoid compiling a regular expression every time you want to match it.
In this example, perl must recompile the regular expression for every
iteration of the \f(CW\*(C`foreach\*(C'\fR loop since it has no way to know what
\&\f(CW$pattern\fR will be:
.PP
.Vb 1
\&    my @patterns = qw( foo bar baz );
\&
\&    LINE: while( <DATA> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /\eb$pattern\eb/i ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`qr//\*(C'\fR operator showed up in perl 5.005. It compiles a regular
expression, but doesn't apply it. When you use the pre-compiled
version of the regex, perl does less work. In this example, I inserted
a \f(CW\*(C`map\*(C'\fR to turn each pattern into its pre-compiled form. The rest of
the script is the same, but faster:
.PP
.Vb 1
\&    my @patterns = map { qr/\eb$_\eb/i } qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /$pattern/ ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
In some cases, you may be able to make several patterns into a single
regular expression. Beware of situations that require backtracking
though.
.PP
.Vb 1
\&    my $regex = join \*(Aq|\*(Aq, qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        print if /\eb(?:$regex)\eb/i;
\&    }
.Ve
.PP
For more details on regular expression efficiency, see \fIMastering
Regular Expressions\fR by Jeffrey Friedl. He explains how the regular
expressions engine works and why some patterns are surprisingly
inefficient. Once you understand how perl applies regular expressions,
you can tune them for individual situations.
.ie n .SS "Why don't word-boundary searches with ""\eb"" work for me?"
.el .SS "Why don't word-boundary searches with \f(CW\eb\fP work for me?"
.IX Xref "\\b"
.IX Subsection "Why don't word-boundary searches with b work for me?"
(contributed by brian d foy)
.PP
Ensure that you know what \eb really does: it's the boundary between a
word character, \ew, and something that isn't a word character. That
thing that isn't a word character might be \eW, but it can also be the
start or end of the string.
.PP
It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.
.PP
In regex speak, a word boundary (\eb) is a \*(L"zero width assertion\*(R",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.
.PP
For the regular expression, /\ebPerl\eb/, there has to be a word
boundary before the \*(L"P\*(R" and after the \*(L"l\*(R". As long as something other
than a word character precedes the \*(L"P\*(R" and succeeds the \*(L"l\*(R", the
pattern will match. These strings match /\ebPerl\eb/.
.PP
.Vb 4
\&    "Perl"    # no word char before P or after l
\&    "Perl "   # same as previous (space is not a word char)
\&    "\*(AqPerl\*(Aq"  # the \*(Aq char is not a word char
\&    "Perl\*(Aqs"  # no word char before P, non\-word char after "l"
.Ve
.PP
These strings do not match /\ebPerl\eb/.
.PP
.Vb 2
\&    "Perl_"   # _ is a word char!
\&    "Perler"  # no word char before P, but one after l
.Ve
.PP
You don't have to use \eb to match words though. You can look for
non-word characters surrounded by word characters. These strings
match the pattern /\eb'\eb/.
.PP
.Vb 2
\&    "don\*(Aqt"   # the \*(Aq char is surrounded by "n" and "t"
\&    "qep\*(Aqa\*(Aq"  # the \*(Aq char is surrounded by "p" and "a"
.Ve
.PP
These strings do not match /\eb'\eb/.
.PP
.Vb 1
\&    "foo\*(Aq"    # there is no word char after non\-word \*(Aq
.Ve
.PP
You can also use the complement of \eb, \eB, to specify that there
should not be a word boundary.
.PP
In the pattern /\eBam\eB/, there must be a word character before the \*(L"a\*(R"
and after the \*(L"m\*(R". These patterns match /\eBam\eB/:
.PP
.Vb 2
\&    "llama"   # "am" surrounded by word chars
\&    "Samuel"  # same
.Ve
.PP
These strings do not match /\eBam\eB/
.PP
.Vb 2
\&    "Sam"      # no word boundary before "a", but one after "m"
\&    "I am Sam" # "am" surrounded by non\-word chars
.Ve
.SS "Why does using $&, $`, or $' slow my program down?"
.IX Xref "$MATCH $& $POSTMATCH $' $PREMATCH $`"
.IX Subsection "Why does using $&, $`, or $' slow my program down?"
(contributed by Anno Siegel)
.PP
Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer \*(L"expensive\*(R" the way the other two are.
.PP
Since Perl 5.6.1 the special variables @\- and @+ can functionally replace
$`, $& and $'. These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.
.PP
Perl 5.10 added three specials, \f(CW\*(C`${^MATCH}\*(C'\fR, \f(CW\*(C`${^PREMATCH}\*(C'\fR, and
\&\f(CW\*(C`${^POSTMATCH}\*(C'\fR to do the same job but without the global performance
penalty. Perl 5.10 only sets these variables if you compile or execute the
regular expression with the \f(CW\*(C`/p\*(C'\fR modifier.
.ie n .SS "What good is ""\eG"" in a regular expression?"
.el .SS "What good is \f(CW\eG\fP in a regular expression?"
.IX Xref "\\G"
.IX Subsection "What good is G in a regular expression?"
You use the \f(CW\*(C`\eG\*(C'\fR anchor to start the next match on the same
string where the last match left off. The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so \f(CW\*(C`\eG\*(C'\fR is similar to the
beginning of string anchor, \f(CW\*(C`^\*(C'\fR. The \f(CW\*(C`\eG\*(C'\fR anchor is typically
used with the \f(CW\*(C`g\*(C'\fR flag. It uses the value of \f(CW\*(C`pos()\*(C'\fR
as the position to start the next match. As the match
operator makes successive matches, it updates \f(CW\*(C`pos()\*(C'\fR with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own \f(CW\*(C`pos()\*(C'\fR value.
.PP
Suppose you want to match all of consecutive pairs of digits
in a string like \*(L"1122a44\*(R" and stop matching when you
encounter non-digits. You want to match \f(CW11\fR and \f(CW22\fR but
the letter <a> shows up between \f(CW22\fR and \f(CW44\fR and you want
to stop at \f(CW\*(C`a\*(C'\fR. Simply matching pairs of digits skips over
the \f(CW\*(C`a\*(C'\fR and still matches \f(CW44\fR.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    my @pairs = m/(\ed\ed)/g;   # qw( 11 22 44 )
.Ve
.PP
If you use the \f(CW\*(C`\eG\*(C'\fR anchor, you force the match after \f(CW22\fR to
start with the \f(CW\*(C`a\*(C'\fR. The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    my @pairs = m/\eG(\ed\ed)/g; # qw( 11 22 )
.Ve
.PP
You can also use the \f(CW\*(C`\eG\*(C'\fR anchor in scalar context. You
still need the \f(CW\*(C`g\*(C'\fR flag.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
.Ve
.PP
After the match fails at the letter \f(CW\*(C`a\*(C'\fR, perl resets \f(CW\*(C`pos()\*(C'\fR
and the next match on the same string starts at the beginning.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 after while" if m/(\ed\ed)/g; # finds "11"
.Ve
.PP
You can disable \f(CW\*(C`pos()\*(C'\fR resets on fail with the \f(CW\*(C`c\*(C'\fR flag, documented
in perlop and perlreref. Subsequent matches start where the last
successful match ended (the value of \f(CW\*(C`pos()\*(C'\fR) even if a match on the
same string has failed in the meantime. In this case, the match after
the \f(CW\*(C`while()\*(C'\fR loop starts at the \f(CW\*(C`a\*(C'\fR (where the last match stopped),
and since it does not use any anchor it can skip over the \f(CW\*(C`a\*(C'\fR to find
\&\f(CW44\fR.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/gc ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 after while" if m/(\ed\ed)/g; # finds "44"
.Ve
.PP
Typically you use the \f(CW\*(C`\eG\*(C'\fR anchor with the \f(CW\*(C`c\*(C'\fR flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.
.PP
.Vb 9
\&    while (<>) {
\&        chomp;
\&        PARSER: {
\&            m/ \eG( \ed+\eb    )/gcx   && do { print "number: $1\en";  redo; };
\&            m/ \eG( \ew+      )/gcx   && do { print "word:   $1\en";  redo; };
\&            m/ \eG( \es+      )/gcx   && do { print "space:  $1\en";  redo; };
\&            m/ \eG( [^\ew\ed]+ )/gcx   && do { print "other:  $1\en";  redo; };
\&        }
\&    }
.Ve
.PP
For each line, the \f(CW\*(C`PARSER\*(C'\fR loop first tries to match a series
of digits followed by a word boundary. This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since \f(CW\*(C`m/ \eG( \ed+\eb
)/gcx\*(C'\fR uses the \f(CW\*(C`c\*(C'\fR flag, if the string does not match that
regular expression, perl does not reset \fIpos()\fR and the next
match starts at the same position to try a different
pattern.
.SS "Are Perl regexes DFAs or NFAs? Are they \s-1POSIX\s0 compliant?"
.IX Xref "DFA NFA POSIX"
.IX Subsection "Are Perl regexes DFAs or NFAs? Are they POSIX compliant?"
While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the \fIegrep\fR\|(1) program, they are in
fact implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing. And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases. (It seems
that some people prefer guarantees of consistency, even when what's
guaranteed is slowness.) See the book \*(L"Mastering Regular Expressions\*(R"
(from O'Reilly) by Jeffrey Friedl for all the details you could ever
hope to know on these matters (a full citation appears in
perlfaq2).
.SS "What's wrong with using grep in a void context?"
.IX Xref "grep"
.IX Subsection "What's wrong with using grep in a void context?"
The problem is that grep builds a return list, regardless of the context.
This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
purpose.
.PP
In perls older than 5.8.1, map suffers from this problem as well.
But since 5.8.1, this has been fixed, and map is context aware \- in void
context, no lists are constructed.
.SS "How can I match strings with multibyte characters?"
.IX Xref "regex, and multibyte characters regexp, and multibyte characters regular expression, and multibyte characters martian encoding, Martian"
.IX Subsection "How can I match strings with multibyte characters?"
Starting from Perl 5.6 Perl has had some level of multibyte character
support. Perl 5.8 or later is recommended. Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module. See perluniintro, perlunicode,
and Encode.
.PP
If you are stuck with older Perls, you can do Unicode with the
Unicode::String module, and character conversions using the
Unicode::Map8 and Unicode::Map modules. If you are using
Japanese encodings, you might try using the jperl 5.005_03.
.PP
Finally, the following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.
.PP
Let's suppose you have some weird Martian encoding where pairs of
\&\s-1ASCII\s0 uppercase letters encode single Martian letters (i.e. the two
bytes \*(L"\s-1CV\*(R"\s0 make a single Martian letter, as do the two bytes \*(L"\s-1SG\*(R",
\&\*(L"VS\*(R", \*(L"XX\*(R",\s0 etc.). Other bytes represent single characters, just like
\&\s-1ASCII.\s0
.PP
So, the string of Martian \*(L"I am \s-1CVSGXX\s0!\*(R" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', '\s-1CV\s0', '\s-1SG\s0', '\s-1XX\s0', '!'.
.PP
Now, say you want to search for the single character \f(CW\*(C`/GX/\*(C'\fR. Perl
doesn't know about Martian, so it'll find the two bytes \*(L"\s-1GX\*(R"\s0 in the \*(L"I
am \s-1CVSGXX\s0!\*(R" string, even though that character isn't there: it just
looks like it is because \*(L"\s-1SG\*(R"\s0 is next to \*(L"\s-1XX\*(R",\s0 but there's no real
\&\*(L"\s-1GX\*(R".\s0 This is a big problem.
.PP
Here are a few ways, all painful, to deal with it:
.PP
.Vb 2
\&    # Make sure adjacent "martian" bytes are no longer adjacent.
\&    $martian =~ s/([A\-Z][A\-Z])/ $1 /g;
\&
\&    print "found GX!\en" if $martian =~ /GX/;
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    my @chars = $martian =~ m/([A\-Z][A\-Z]|[^A\-Z])/g;
\&    # above is conceptually similar to:     my @chars = $text =~ m/(.)/g;
\&    #
\&    foreach my $char (@chars) {
\&        print "found GX!\en", last if $char eq \*(AqGX\*(Aq;
\&    }
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    while ($martian =~ m/\eG([A\-Z][A\-Z]|.)/gs) {  # \eG probably unneeded
\&        if ($1 eq \*(AqGX\*(Aq) {
\&            print "found GX!\en";
\&            last;
\&        }
\&    }
.Ve
.PP
Here's another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind assertion.
.PP
.Vb 5
\&    print "found GX!\en" if    $martian =~ m/
\&        (?<![A\-Z])
\&        (?:[A\-Z][A\-Z])*?
\&        GX
\&        /x;
.Ve
.PP
This succeeds if the \*(L"martian\*(R" character \s-1GX\s0 is in the string, and fails
otherwise. If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A\-Z]) with (?:^|[^A\-Z]).
.PP
It does have the drawback of putting the wrong thing in $\-[0] and $+[0],
but this usually can be worked around.
.SS "How do I match a regular expression that's in a variable?"
.IX Xref "regex, in variable eval regex quotemeta \\Q, regex \\E, regex qr"
.IX Subsection "How do I match a regular expression that's in a variable?"
(contributed by brian d foy)
.PP
We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.
.PP
The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in \f(CW$regex\fR.
Once you have the pattern in \f(CW$regex\fR, you use that variable in the
match operator.
.PP
.Vb 1
\&    chomp( my $regex = <STDIN> );
\&
\&    if( $string =~ m/$regex/ ) { ... }
.Ve
.PP
Any regular expression special characters in \f(CW$regex\fR are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.
.PP
.Vb 1
\&    my $regex = "Unmatched ( paren";
\&
\&    "Two parens to bind them all" =~ m/$regex/;
.Ve
.PP
When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:
.PP
.Vb 1
\&    Unmatched ( in regex; marked by <\-\- HERE in m/Unmatched ( <\-\- HERE  paren/ at script line 3.
.Ve
.PP
You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with \f(CW\*(C`quotemeta\*(C'\fR before you use the string.
.PP
.Vb 2
\&    chomp( my $regex = <STDIN> );
\&    $regex = quotemeta( $regex );
\&
\&    if( $string =~ m/$regex/ ) { ... }
.Ve
.PP
You can also do this directly in the match operator using the \f(CW\*(C`\eQ\*(C'\fR
and \f(CW\*(C`\eE\*(C'\fR sequences. The \f(CW\*(C`\eQ\*(C'\fR tells Perl where to start escaping
special characters, and the \f(CW\*(C`\eE\*(C'\fR tells it where to stop (see perlop
for more details).
.PP
.Vb 1
\&    chomp( my $regex = <STDIN> );
\&
\&    if( $string =~ m/\eQ$regex\eE/ ) { ... }
.Ve
.PP
Alternately, you can use \f(CW\*(C`qr//\*(C'\fR, the regular expression quote operator (see
perlop for more details). It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.
.PP
.Vb 1
\&    chomp( my $input = <STDIN> );
\&
\&    my $regex = qr/$input/is;
\&
\&    $string =~ m/$regex/  # same as m/$input/is;
.Ve
.PP
You might also want to trap any errors by wrapping an \f(CW\*(C`eval\*(C'\fR block
around the whole thing.
.PP
.Vb 1
\&    chomp( my $input = <STDIN> );
\&
\&    eval {
\&        if( $string =~ m/\eQ$input\eE/ ) { ... }
\&    };
\&    warn $@ if $@;
.Ve
.PP
Or...
.PP
.Vb 7
\&    my $regex = eval { qr/$input/is };
\&    if( defined $regex ) {
\&        $string =~ m/$regex/;
\&    }
\&    else {
\&        warn $@;
\&    }
.Ve
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq7.1                                   0100644 0001750 0001750 00000134275 12566207437 022501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ7 1"
.TH PERLFAQ7 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq7 \- General Perl Language Issues
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with general Perl language issues that don't
clearly fit into any of the other sections.
.SS "Can I get a BNF/yacc/RE for the Perl language?"
.IX Subsection "Can I get a BNF/yacc/RE for the Perl language?"
There is no \s-1BNF,\s0 but you can paw your way through the yacc grammar in
perly.y in the source distribution if you're particularly brave. The
grammar relies on very smart tokenizing code, so be prepared to
venture into toke.c as well.
.PP
In the words of Chaim Frenkel: \*(L"Perl's grammar can not be reduced to \s-1BNF.\s0
The work of parsing perl is distributed between yacc, the lexer, smoke
and mirrors.\*(R"
.SS "What are all these $@%&* punctuation signs, and how do I know when to use them?"
.IX Subsection "What are all these $@%&* punctuation signs, and how do I know when to use them?"
They are type specifiers, as detailed in perldata:
.PP
.Vb 6
\&    $ for scalar values (number, string or reference)
\&    @ for arrays
\&    % for hashes (associative arrays)
\&    & for subroutines (aka functions, procedures, methods)
\&    * for all types of that symbol name. In version 4 you used them like
\&      pointers, but in modern perls you can just use references.
.Ve
.PP
There are a couple of other symbols that
you're likely to encounter that aren't
really type specifiers:
.PP
.Vb 2
\&    <> are used for inputting a record from a filehandle.
\&    \e  takes a reference to something.
.Ve
.PP
Note that <\s-1FILE\s0> is \fIneither\fR the type specifier for files
nor the name of the handle. It is the \f(CW\*(C`<>\*(C'\fR operator applied
to the handle \s-1FILE.\s0 It reads one line (well, record\*(--see
\&\*(L"$/\*(R" in perlvar) from the handle \s-1FILE\s0 in scalar context, or \fIall\fR lines
in list context. When performing open, close, or any other operation
besides \f(CW\*(C`<>\*(C'\fR on files, or even when talking about the handle, do
\&\fInot\fR use the brackets. These are correct: \f(CW\*(C`eof(FH)\*(C'\fR, \f(CW\*(C`seek(FH, 0,
2)\*(C'\fR and \*(L"copying from \s-1STDIN\s0 to \s-1FILE\*(R".\s0
.SS "Do I always/never have to quote my strings or use semicolons and commas?"
.IX Subsection "Do I always/never have to quote my strings or use semicolons and commas?"
Normally, a bareword doesn't need to be quoted, but in most cases
probably should be (and must be under \f(CW\*(C`use strict\*(C'\fR). But a hash key
consisting of a simple word and the left-hand
operand to the \f(CW\*(C`=>\*(C'\fR operator both
count as though they were quoted:
.PP
.Vb 4
\&    This                    is like this
\&    \-\-\-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    $foo{line}              $foo{\*(Aqline\*(Aq}
\&    bar => stuff            \*(Aqbar\*(Aq => stuff
.Ve
.PP
The final semicolon in a block is optional, as is the final comma in a
list. Good style (see perlstyle) says to put them in except for
one-liners:
.PP
.Vb 2
\&    if ($whoops) { exit 1 }
\&    my @nums = (1, 2, 3);
\&
\&    if ($whoops) {
\&        exit 1;
\&    }
\&
\&    my @lines = (
\&        "There Beren came from mountains cold",
\&        "And lost he wandered under leaves",
\&    );
.Ve
.SS "How do I skip some return values?"
.IX Subsection "How do I skip some return values?"
One way is to treat the return values as a list and index into it:
.PP
.Vb 1
\&    $dir = (getpwnam($user))[7];
.Ve
.PP
Another way is to use undef as an element on the left-hand-side:
.PP
.Vb 1
\&    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
.Ve
.PP
You can also use a list slice to select only the elements that
you need:
.PP
.Vb 1
\&    ($dev, $ino, $uid, $gid) = ( stat($file) )[0,1,4,5];
.Ve
.SS "How do I temporarily block warnings?"
.IX Subsection "How do I temporarily block warnings?"
If you are running Perl 5.6.0 or better, the \f(CW\*(C`use warnings\*(C'\fR pragma
allows fine control of what warnings are produced.
See perllexwarn for more details.
.PP
.Vb 4
\&    {
\&        no warnings;          # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Additionally, you can enable and disable categories of warnings.
You turn off the categories you want to ignore and you can still
get other categories of warnings. See perllexwarn for the
complete details, including the category names and hierarchy.
.PP
.Vb 4
\&    {
\&        no warnings \*(Aquninitialized\*(Aq;
\&        $x = $y + $z;
\&    }
.Ve
.PP
If you have an older version of Perl, the \f(CW$^W\fR variable (documented
in perlvar) controls runtime warnings for a block:
.PP
.Vb 4
\&    {
\&        local $^W = 0;        # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Note that like all the punctuation variables, you cannot currently
use \fImy()\fR on \f(CW$^W\fR, only \fIlocal()\fR.
.SS "What's an extension?"
.IX Subsection "What's an extension?"
An extension is a way of calling compiled C code from Perl. Reading
perlxstut is a good place to learn more about extensions.
.SS "Why do Perl operators have different precedence than C operators?"
.IX Subsection "Why do Perl operators have different precedence than C operators?"
Actually, they don't. All C operators that Perl copies have the same
precedence in Perl as they do in C. The problem is with operators that C
doesn't have, especially functions that give a list context to everything
on their right, eg. print, chmod, exec, and so on. Such functions are
called \*(L"list operators\*(R" and appear as such in the precedence table in
perlop.
.PP
A common mistake is to write:
.PP
.Vb 1
\&    unlink $file || die "snafu";
.Ve
.PP
This gets interpreted as:
.PP
.Vb 1
\&    unlink ($file || die "snafu");
.Ve
.PP
To avoid this problem, either put in extra parentheses or use the
super low precedence \f(CW\*(C`or\*(C'\fR operator:
.PP
.Vb 2
\&    (unlink $file) || die "snafu";
\&    unlink $file or die "snafu";
.Ve
.PP
The \*(L"English\*(R" operators (\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`xor\*(C'\fR, and \f(CW\*(C`not\*(C'\fR)
deliberately have precedence lower than that of list operators for
just such situations as the one above.
.PP
Another operator with surprising precedence is exponentiation. It
binds more tightly even than unary minus, making \f(CW\*(C`\-2**2\*(C'\fR produce a
negative four and not a positive one. It is also right-associating, meaning
that \f(CW\*(C`2**3**2\*(C'\fR is two raised to the ninth power, not eight squared.
.PP
Although it has the same precedence as in C, Perl's \f(CW\*(C`?:\*(C'\fR operator
produces an lvalue. This assigns \f(CW$x\fR to either \f(CW$if_true\fR or \f(CW$if_false\fR, depending
on the trueness of \f(CW$maybe:\fR
.PP
.Vb 1
\&    ($maybe ? $if_true : $if_false) = $x;
.Ve
.SS "How do I declare/create a structure?"
.IX Subsection "How do I declare/create a structure?"
In general, you don't \*(L"declare\*(R" a structure. Just use a (probably
anonymous) hash reference. See perlref and perldsc for details.
Here's an example:
.PP
.Vb 3
\&    $person = {};                   # new anonymous hash
\&    $person\->{AGE}  = 24;           # set field AGE to 24
\&    $person\->{NAME} = "Nat";        # set field NAME to "Nat"
.Ve
.PP
If you're looking for something a bit more rigorous, try perltoot.
.SS "How do I create a module?"
.IX Subsection "How do I create a module?"
perlnewmod is a good place to start, ignore the bits
about uploading to \s-1CPAN\s0 if you don't want to make your
module publicly available.
.PP
ExtUtils::ModuleMaker and Module::Starter are also
good places to start. Many \s-1CPAN\s0 authors now use Dist::Zilla
to automate as much as possible.
.PP
Detailed documentation about modules can be found at:
perlmod, perlmodlib, perlmodstyle.
.PP
If you need to include C code or C library interfaces 
use h2xs. h2xs will create the module distribution structure 
and the initial interface files.
perlxs and perlxstut explain the details.
.SS "How do I adopt or take over a module already on \s-1CPAN\s0?"
.IX Subsection "How do I adopt or take over a module already on CPAN?"
Ask the current maintainer to make you a co-maintainer or
transfer the module to you.
.PP
If you can not reach the author for some reason contact
the \s-1PAUSE\s0 admins at modules@perl.org who may be able to help,
but each case it treated seperatly.
.IP "\(bu" 4
Get a login for the Perl Authors Upload Server (\s-1PAUSE\s0) if you don't
already have one: <http://pause.perl.org>
.IP "\(bu" 4
Write to modules@perl.org explaining what you did to contact the
current maintainer. The \s-1PAUSE\s0 admins will also try to reach the
maintainer.
.IP "\(bu" 4
Post a public message in a heavily trafficked site announcing your
intention to take over the module.
.IP "\(bu" 4
Wait a bit. The \s-1PAUSE\s0 admins don't want to act too quickly in case
the current maintainer is on holiday. If there's no response to
private communication or the public post, a \s-1PAUSE\s0 admin can transfer
it to you.
.SS "How do I create a class?"
.IX Xref "class, creation package"
.IX Subsection "How do I create a class?"
(contributed by brian d foy)
.PP
In Perl, a class is just a package, and methods are just subroutines.
Perl doesn't get more formal than that and lets you set up the package
just the way that you like it (that is, it doesn't set up anything for
you).
.PP
The Perl documentation has several tutorials that cover class
creation, including perlboot (Barnyard Object Oriented Tutorial),
perltoot (Tom's Object Oriented Tutorial), perlbot (Bag o'
Object Tricks), and perlobj.
.SS "How can I tell if a variable is tainted?"
.IX Subsection "How can I tell if a variable is tainted?"
You can use the \fItainted()\fR function of the Scalar::Util module, available
from \s-1CPAN \s0(or included with Perl since release 5.8.0).
See also \*(L"Laundering and Detecting Tainted Data\*(R" in perlsec.
.SS "What's a closure?"
.IX Subsection "What's a closure?"
Closures are documented in perlref.
.PP
\&\fIClosure\fR is a computer science term with a precise but
hard-to-explain meaning. Usually, closures are implemented in Perl as
anonymous subroutines with lasting references to lexical variables
outside their own scopes. These lexicals magically refer to the
variables that were around when the subroutine was defined (deep
binding).
.PP
Closures are most often used in programming languages where you can
have the return value of a function be itself a function, as you can
in Perl. Note that some languages provide anonymous functions but are
not capable of providing proper closures: the Python language, for
example. For more information on closures, check out any textbook on
functional programming. Scheme is a language that not only supports
but encourages closures.
.PP
Here's a classic non-closure function-generating function:
.PP
.Vb 3
\&    sub add_function_generator {
\&        return sub { shift() + shift() };
\&    }
\&
\&    my $add_sub = add_function_generator();
\&    my $sum = $add_sub\->(4,5);                # $sum is 9 now.
.Ve
.PP
The anonymous subroutine returned by \fIadd_function_generator()\fR isn't
technically a closure because it refers to no lexicals outside its own
scope. Using a closure gives you a \fIfunction template\fR with some
customization slots left out to be filled later.
.PP
Contrast this with the following \fImake_adder()\fR function, in which the
returned anonymous function contains a reference to a lexical variable
outside the scope of that function itself. Such a reference requires
that Perl return a proper closure, thus locking in for all time the
value that the lexical had when the function was created.
.PP
.Vb 4
\&    sub make_adder {
\&        my $addpiece = shift;
\&        return sub { shift() + $addpiece };
\&    }
\&
\&    my $f1 = make_adder(20);
\&    my $f2 = make_adder(555);
.Ve
.PP
Now \f(CW\*(C`$f1\->($n)\*(C'\fR is always 20 plus whatever \f(CW$n\fR you pass in, whereas
\&\f(CW\*(C`$f2\->($n)\*(C'\fR is always 555 plus whatever \f(CW$n\fR you pass in. The \f(CW$addpiece\fR
in the closure sticks around.
.PP
Closures are often used for less esoteric purposes. For example, when
you want to pass in a bit of code into a function:
.PP
.Vb 2
\&    my $line;
\&    timeout( 30, sub { $line = <STDIN> } );
.Ve
.PP
If the code to execute had been passed in as a string,
\&\f(CW\*(Aq$line = <STDIN>\*(Aq\fR, there would have been no way for the
hypothetical \fItimeout()\fR function to access the lexical variable
\&\f(CW$line\fR back in its caller's scope.
.PP
Another use for a closure is to make a variable \fIprivate\fR to a
named subroutine, e.g. a counter that gets initialized at creation
time of the sub and can only be modified from within the sub.
This is sometimes used with a \s-1BEGIN\s0 block in package files to make
sure a variable doesn't get meddled with during the lifetime of the
package:
.PP
.Vb 4
\&    BEGIN {
\&        my $id = 0;
\&        sub next_id { ++$id }
\&    }
.Ve
.PP
This is discussed in more detail in perlsub; see the entry on
\&\fIPersistent Private Variables\fR.
.SS "What is variable suicide and how can I prevent it?"
.IX Subsection "What is variable suicide and how can I prevent it?"
This problem was fixed in perl 5.004_05, so preventing it means upgrading
your version of perl. ;)
.PP
Variable suicide is when you (temporarily or permanently) lose the value
of a variable. It is caused by scoping through \fImy()\fR and \fIlocal()\fR
interacting with either closures or aliased \fIforeach()\fR iterator variables
and subroutine arguments. It used to be easy to inadvertently lose a
variable's value this way, but now it's much harder. Take this code:
.PP
.Vb 4
\&    my $f = \*(Aqfoo\*(Aq;
\&    sub T {
\&        while ($i++ < 3) { my $f = $f; $f .= "bar"; print $f, "\en" }
\&    }
\&
\&    T;
\&    print "Finally $f\en";
.Ve
.PP
If you are experiencing variable suicide, that \f(CW\*(C`my $f\*(C'\fR in the subroutine
doesn't pick up a fresh copy of the \f(CW$f\fR whose value is \f(CW\*(Aqfoo\*(Aq\fR. The
output shows that inside the subroutine the value of \f(CW$f\fR leaks through
when it shouldn't, as in this output:
.PP
.Vb 4
\&    foobar
\&    foobarbar
\&    foobarbarbar
\&    Finally foo
.Ve
.PP
The \f(CW$f\fR that has \*(L"bar\*(R" added to it three times should be a new \f(CW$f\fR
\&\f(CW\*(C`my $f\*(C'\fR should create a new lexical variable each time through the loop.
The expected output is:
.PP
.Vb 4
\&    foobar
\&    foobar
\&    foobar
\&    Finally foo
.Ve
.SS "How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
.IX Subsection "How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
You need to pass references to these objects. See \*(L"Pass by
Reference\*(R" in perlsub for this particular question, and perlref for
information on references.
.IP "Passing Variables and Functions" 4
.IX Item "Passing Variables and Functions"
Regular variables and functions are quite easy to pass: just pass in a
reference to an existing or anonymous variable or function:
.Sp
.Vb 1
\&    func( \e$some_scalar );
\&
\&    func( \e@some_array  );
\&    func( [ 1 .. 10 ]   );
\&
\&    func( \e%some_hash   );
\&    func( { this => 10, that => 20 }   );
\&
\&    func( \e&some_func   );
\&    func( sub { $_[0] ** $_[1] }   );
.Ve
.IP "Passing Filehandles" 4
.IX Item "Passing Filehandles"
As of Perl 5.6, you can represent filehandles with scalar variables
which you treat as any other scalar.
.Sp
.Vb 2
\&    open my $fh, $filename or die "Cannot open $filename! $!";
\&    func( $fh );
\&
\&    sub func {
\&        my $passed_fh = shift;
\&
\&        my $line = <$passed_fh>;
\&    }
.Ve
.Sp
Before Perl 5.6, you had to use the \f(CW*FH\fR or \f(CW\*(C`\e*FH\*(C'\fR notations.
These are \*(L"typeglobs\*(R"\-\-see \*(L"Typeglobs and Filehandles\*(R" in perldata
and especially \*(L"Pass by Reference\*(R" in perlsub for more information.
.IP "Passing Regexes" 4
.IX Item "Passing Regexes"
Here's an example of how to pass in a string and a regular expression
for it to match against. You construct the pattern with the \f(CW\*(C`qr//\*(C'\fR
operator:
.Sp
.Vb 6
\&    sub compare {
\&        my ($val1, $regex) = @_;
\&        my $retval = $val1 =~ /$regex/;
\&        return $retval;
\&    }
\&    $match = compare("old McDonald", qr/d.*D/i);
.Ve
.IP "Passing Methods" 4
.IX Item "Passing Methods"
To pass an object method into a subroutine, you can do this:
.Sp
.Vb 7
\&    call_a_lot(10, $some_obj, "methname")
\&    sub call_a_lot {
\&        my ($count, $widget, $trick) = @_;
\&        for (my $i = 0; $i < $count; $i++) {
\&            $widget\->$trick();
\&        }
\&    }
.Ve
.Sp
Or, you can use a closure to bundle up the object, its
method call, and arguments:
.Sp
.Vb 6
\&    my $whatnot = sub { $some_obj\->obfuscate(@args) };
\&    func($whatnot);
\&    sub func {
\&        my $code = shift;
\&        &$code();
\&    }
.Ve
.Sp
You could also investigate the \fIcan()\fR method in the \s-1UNIVERSAL\s0 class
(part of the standard perl distribution).
.SS "How do I create a static variable?"
.IX Subsection "How do I create a static variable?"
(contributed by brian d foy)
.PP
In Perl 5.10, declare the variable with \f(CW\*(C`state\*(C'\fR. The \f(CW\*(C`state\*(C'\fR
declaration creates the lexical variable that persists between calls
to the subroutine:
.PP
.Vb 1
\&    sub counter { state $count = 1; $count++ }
.Ve
.PP
You can fake a static variable by using a lexical variable which goes
out of scope. In this example, you define the subroutine \f(CW\*(C`counter\*(C'\fR, and
it uses the lexical variable \f(CW$count\fR. Since you wrap this in a \s-1BEGIN\s0
block, \f(CW$count\fR is defined at compile-time, but also goes out of
scope at the end of the \s-1BEGIN\s0 block. The \s-1BEGIN\s0 block also ensures that
the subroutine and the value it uses is defined at compile-time so the
subroutine is ready to use just like any other subroutine, and you can
put this code in the same place as other subroutines in the program
text (i.e. at the end of the code, typically). The subroutine
\&\f(CW\*(C`counter\*(C'\fR still has a reference to the data, and is the only way you
can access the value (and each time you do, you increment the value).
The data in chunk of memory defined by \f(CW$count\fR is private to
\&\f(CW\*(C`counter\*(C'\fR.
.PP
.Vb 4
\&    BEGIN {
\&        my $count = 1;
\&        sub counter { $count++ }
\&    }
\&
\&    my $start = counter();
\&
\&    .... # code that calls counter();
\&
\&    my $end = counter();
.Ve
.PP
In the previous example, you created a function-private variable
because only one function remembered its reference. You could define
multiple functions while the variable is in scope, and each function
can share the \*(L"private\*(R" variable. It's not really \*(L"static\*(R" because you
can access it outside the function while the lexical variable is in
scope, and even create references to it. In this example,
\&\f(CW\*(C`increment_count\*(C'\fR and \f(CW\*(C`return_count\*(C'\fR share the variable. One
function adds to the value and the other simply returns the value.
They can both access \f(CW$count\fR, and since it has gone out of scope,
there is no other way to access it.
.PP
.Vb 5
\&    BEGIN {
\&        my $count = 1;
\&        sub increment_count { $count++ }
\&        sub return_count    { $count }
\&    }
.Ve
.PP
To declare a file-private variable, you still use a lexical variable.
A file is also a scope, so a lexical variable defined in the file
cannot be seen from any other file.
.PP
See \*(L"Persistent Private Variables\*(R" in perlsub for more information.
The discussion of closures in perlref may help you even though we
did not use anonymous subroutines in this answer. See
\&\*(L"Persistent Private Variables\*(R" in perlsub for details.
.SS "What's the difference between dynamic and lexical (static) scoping? Between \fIlocal()\fP and \fImy()\fP?"
.IX Subsection "What's the difference between dynamic and lexical (static) scoping? Between local() and my()?"
\&\f(CW\*(C`local($x)\*(C'\fR saves away the old value of the global variable \f(CW$x\fR
and assigns a new value for the duration of the subroutine \fIwhich is
visible in other functions called from that subroutine\fR. This is done
at run-time, so is called dynamic scoping. \fIlocal()\fR always affects global
variables, also called package variables or dynamic variables.
.PP
\&\f(CW\*(C`my($x)\*(C'\fR creates a new variable that is only visible in the current
subroutine. This is done at compile-time, so it is called lexical or
static scoping. \fImy()\fR always affects private variables, also called
lexical variables or (improperly) static(ly scoped) variables.
.PP
For instance:
.PP
.Vb 3
\&    sub visible {
\&        print "var has value $var\en";
\&    }
\&
\&    sub dynamic {
\&        local $var = \*(Aqlocal\*(Aq;    # new temporary value for the still\-global
\&        visible();              #   variable called $var
\&    }
\&
\&    sub lexical {
\&        my $var = \*(Aqprivate\*(Aq;    # new private variable, $var
\&        visible();              # (invisible outside of sub scope)
\&    }
\&
\&    $var = \*(Aqglobal\*(Aq;
\&
\&    visible();              # prints global
\&    dynamic();              # prints local
\&    lexical();              # prints global
.Ve
.PP
Notice how at no point does the value \*(L"private\*(R" get printed. That's
because \f(CW$var\fR only has that value within the block of the \fIlexical()\fR
function, and it is hidden from the called subroutine.
.PP
In summary, \fIlocal()\fR doesn't make what you think of as private, local
variables. It gives a global variable a temporary value. \fImy()\fR is
what you're looking for if you want private variables.
.PP
See \*(L"Private Variables via \fImy()\fR\*(R" in perlsub and
\&\*(L"Temporary Values via \fIlocal()\fR\*(R" in perlsub for excruciating details.
.SS "How can I access a dynamic variable while a similarly named lexical is in scope?"
.IX Subsection "How can I access a dynamic variable while a similarly named lexical is in scope?"
If you know your package, you can just mention it explicitly, as in
\&\f(CW$Some_Pack::var\fR. Note that the notation \f(CW$::var\fR is \fBnot\fR the dynamic \f(CW$var\fR
in the current package, but rather the one in the \*(L"main\*(R" package, as
though you had written \f(CW$main::var\fR.
.PP
.Vb 3
\&    use vars \*(Aq$var\*(Aq;
\&    local $var = "global";
\&    my    $var = "lexical";
\&
\&    print "lexical is $var\en";
\&    print "global  is $main::var\en";
.Ve
.PP
Alternatively you can use the compiler directive \fIour()\fR to bring a
dynamic variable into the current lexical scope.
.PP
.Vb 2
\&    require 5.006; # our() did not exist before 5.6
\&    use vars \*(Aq$var\*(Aq;
\&
\&    local $var = "global";
\&    my $var    = "lexical";
\&
\&    print "lexical is $var\en";
\&
\&    {
\&        our $var;
\&        print "global  is $var\en";
\&    }
.Ve
.SS "What's the difference between deep and shallow binding?"
.IX Subsection "What's the difference between deep and shallow binding?"
In deep binding, lexical variables mentioned in anonymous subroutines
are the same ones that were in scope when the subroutine was created.
In shallow binding, they are whichever variables with the same names
happen to be in scope when the subroutine is called. Perl always uses
deep binding of lexical variables (i.e., those created with \fImy()\fR).
However, dynamic variables (aka global, local, or package variables)
are effectively shallowly bound. Consider this just one more reason
not to use them. See the answer to \*(L"What's a closure?\*(R".
.ie n .SS "Why doesn't ""my($foo) = <$fh>;"" work right?"
.el .SS "Why doesn't ``my($foo) = <$fh>;'' work right?"
.IX Subsection "Why doesn't my($foo) = <$fh>; work right?"
\&\f(CW\*(C`my()\*(C'\fR and \f(CW\*(C`local()\*(C'\fR give list context to the right hand side
of \f(CW\*(C`=\*(C'\fR. The <$fh> read operation, like so many of Perl's
functions and operators, can tell which context it was called in and
behaves appropriately. In general, the \fIscalar()\fR function can help.
This function does nothing to the data itself (contrary to popular myth)
but rather tells its argument to behave in whatever its scalar fashion is.
If that function doesn't have a defined scalar behavior, this of course
doesn't help you (such as with \fIsort()\fR).
.PP
To enforce scalar context in this particular case, however, you need
merely omit the parentheses:
.PP
.Vb 3
\&    local($foo) = <$fh>;        # WRONG
\&    local($foo) = scalar(<$fh>);   # ok
\&    local $foo  = <$fh>;        # right
.Ve
.PP
You should probably be using lexical variables anyway, although the
issue is the same here:
.PP
.Vb 2
\&    my($foo) = <$fh>;    # WRONG
\&    my $foo  = <$fh>;    # right
.Ve
.SS "How do I redefine a builtin function, operator, or method?"
.IX Subsection "How do I redefine a builtin function, operator, or method?"
Why do you want to do that? :\-)
.PP
If you want to override a predefined function, such as \fIopen()\fR,
then you'll have to import the new definition from a different
module. See \*(L"Overriding Built-in Functions\*(R" in perlsub.
.PP
If you want to overload a Perl operator, such as \f(CW\*(C`+\*(C'\fR or \f(CW\*(C`**\*(C'\fR,
then you'll want to use the \f(CW\*(C`use overload\*(C'\fR pragma, documented
in overload.
.PP
If you're talking about obscuring method calls in parent classes,
see \*(L"Overridden Methods\*(R" in perltoot.
.SS "What's the difference between calling a function as &foo and \fIfoo()\fP?"
.IX Subsection "What's the difference between calling a function as &foo and foo()?"
(contributed by brian d foy)
.PP
Calling a subroutine as \f(CW&foo\fR with no trailing parentheses ignores
the prototype of \f(CW\*(C`foo\*(C'\fR and passes it the current value of the argument
list, \f(CW@_\fR. Here's an example; the \f(CW\*(C`bar\*(C'\fR subroutine calls \f(CW&foo\fR,
which prints its arguments list:
.PP
.Vb 1
\&    sub bar { &foo }
\&
\&    sub foo { print "Args in foo are: @_\en" }
\&
\&    bar( qw( a b c ) );
.Ve
.PP
When you call \f(CW\*(C`bar\*(C'\fR with arguments, you see that \f(CW\*(C`foo\*(C'\fR got the same \f(CW@_\fR:
.PP
.Vb 1
\&    Args in foo are: a b c
.Ve
.PP
Calling the subroutine with trailing parentheses, with or without arguments,
does not use the current \f(CW@_\fR and respects the subroutine prototype. Changing
the example to put parentheses after the call to \f(CW\*(C`foo\*(C'\fR changes the program:
.PP
.Vb 1
\&    sub bar { &foo() }
\&
\&    sub foo { print "Args in foo are: @_\en" }
\&
\&    bar( qw( a b c ) );
.Ve
.PP
Now the output shows that \f(CW\*(C`foo\*(C'\fR doesn't get the \f(CW@_\fR from its caller.
.PP
.Vb 1
\&    Args in foo are:
.Ve
.PP
The main use of the \f(CW@_\fR pass-through feature is to write subroutines
whose main job it is to call other subroutines for you. For further
details, see perlsub.
.SS "How do I create a switch or case statement?"
.IX Subsection "How do I create a switch or case statement?"
In Perl 5.10, use the \f(CW\*(C`given\-when\*(C'\fR construct described in perlsyn:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given ( $string ) {
\&        when( \*(AqFred\*(Aq )        { say "I found Fred!" }
\&        when( \*(AqBarney\*(Aq )      { say "I found Barney!" }
\&        when( /Bamm\-?Bamm/ )  { say "I found Bamm\-Bamm!" }
\&        default               { say "I don\*(Aqt recognize the name!" }
\&    };
.Ve
.PP
If one wants to use pure Perl and to be compatible with Perl versions
prior to 5.10, the general answer is to use \f(CW\*(C`if\-elsif\-else\*(C'\fR:
.PP
.Vb 6
\&    for ($variable_to_test) {
\&        if    (/pat1/)  { }     # do something
\&        elsif (/pat2/)  { }     # do something else
\&        elsif (/pat3/)  { }     # do something else
\&        else            { }     # default
\&    }
.Ve
.PP
Here's a simple example of a switch based on pattern matching,
lined up in a way to make it look more like a switch statement.
We'll do a multiway conditional based on the type of reference stored
in \f(CW$whatchamacallit:\fR
.PP
.Vb 1
\&    SWITCH: for (ref $whatchamacallit) {
\&
\&        /^$/           && die "not a reference";
\&
\&        /SCALAR/       && do {
\&                        print_scalar($$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /ARRAY/        && do {
\&                        print_array(@$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /HASH/        && do {
\&                        print_hash(%$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /CODE/        && do {
\&                        warn "can\*(Aqt print function ref";
\&                        last SWITCH;
\&                      };
\&
\&        # DEFAULT
\&
\&        warn "User defined type skipped";
\&
\&    }
.Ve
.PP
See perlsyn for other examples in this style.
.PP
Sometimes you should change the positions of the constant and the variable.
For example, let's say you wanted to test which of many answers you were
given, but in a case-insensitive way that also allows abbreviations.
You can use the following technique if the strings all start with
different characters or if you want to arrange the matches so that
one takes precedence over another, as \f(CW"SEND"\fR has precedence over
\&\f(CW"STOP"\fR here:
.PP
.Vb 6
\&    chomp($answer = <>);
\&    if    ("SEND"  =~ /^\eQ$answer/i) { print "Action is send\en"  }
\&    elsif ("STOP"  =~ /^\eQ$answer/i) { print "Action is stop\en"  }
\&    elsif ("ABORT" =~ /^\eQ$answer/i) { print "Action is abort\en" }
\&    elsif ("LIST"  =~ /^\eQ$answer/i) { print "Action is list\en"  }
\&    elsif ("EDIT"  =~ /^\eQ$answer/i) { print "Action is edit\en"  }
.Ve
.PP
A totally different approach is to create a hash of function references.
.PP
.Vb 6
\&    my %commands = (
\&        "happy" => \e&joy,
\&        "sad",  => \e&sullen,
\&        "done"  => sub { die "See ya!" },
\&        "mad"   => \e&angry,
\&    );
\&
\&    print "How are you? ";
\&    chomp($string = <STDIN>);
\&    if ($commands{$string}) {
\&        $commands{$string}\->();
\&    } else {
\&        print "No such command: $string\en";
\&    }
.Ve
.PP
Starting from Perl 5.8, a source filter module, \f(CW\*(C`Switch\*(C'\fR, can also be
used to get switch and case. Its use is now discouraged, because it's
not fully compatible with the native switch of Perl 5.10, and because,
as it's implemented as a source filter, it doesn't always work as intended
when complex syntax is involved.
.SS "How can I catch accesses to undefined variables, functions, or methods?"
.IX Subsection "How can I catch accesses to undefined variables, functions, or methods?"
The \s-1AUTOLOAD\s0 method, discussed in \*(L"Autoloading\*(R" in perlsub and
\&\*(L"\s-1AUTOLOAD:\s0 Proxy Methods\*(R" in perltoot, lets you capture calls to
undefined functions and methods.
.PP
When it comes to undefined variables that would trigger a warning
under \f(CW\*(C`use warnings\*(C'\fR, you can promote the warning to an error.
.PP
.Vb 1
\&    use warnings FATAL => qw(uninitialized);
.Ve
.SS "Why can't a method included in this same file be found?"
.IX Subsection "Why can't a method included in this same file be found?"
Some possible reasons: your inheritance is getting confused, you've
misspelled the method name, or the object is of the wrong type. Check
out perltoot for details about any of the above cases. You may
also use \f(CW\*(C`print ref($object)\*(C'\fR to find out the class \f(CW$object\fR was
blessed into.
.PP
Another possible reason for problems is that you've used the
indirect object syntax (eg, \f(CW\*(C`find Guru "Samy"\*(C'\fR) on a class name
before Perl has seen that such a package exists. It's wisest to make
sure your packages are all defined before you start using them, which
will be taken care of if you use the \f(CW\*(C`use\*(C'\fR statement instead of
\&\f(CW\*(C`require\*(C'\fR. If not, make sure to use arrow notation (eg.,
\&\f(CW\*(C`Guru\->find("Samy")\*(C'\fR) instead. Object notation is explained in
perlobj.
.PP
Make sure to read about creating modules in perlmod and
the perils of indirect objects in \*(L"Method Invocation\*(R" in perlobj.
.SS "How can I find out my current or calling package?"
.IX Subsection "How can I find out my current or calling package?"
(contributed by brian d foy)
.PP
To find the package you are currently in, use the special literal
\&\f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR, as documented in perldata. You can only use the
special literals as separate tokens, so you can't interpolate them
into strings like you can with variables:
.PP
.Vb 2
\&    my $current_package = _\|_PACKAGE_\|_;
\&    print "I am in package $current_package\en";
.Ve
.PP
If you want to find the package calling your code, perhaps to give better
diagnostics as Carp does, use the \f(CW\*(C`caller\*(C'\fR built-in:
.PP
.Vb 3
\&    sub foo {
\&        my @args = ...;
\&        my( $package, $filename, $line ) = caller;
\&
\&        print "I was called from package $package\en";
\&        );
.Ve
.PP
By default, your program starts in package \f(CW\*(C`main\*(C'\fR, so you will
always be in some package.
.PP
This is different from finding out the package an object is blessed
into, which might not be the current package. For that, use \f(CW\*(C`blessed\*(C'\fR
from Scalar::Util, part of the Standard Library since Perl 5.8:
.PP
.Vb 2
\&    use Scalar::Util qw(blessed);
\&    my $object_package = blessed( $object );
.Ve
.PP
Most of the time, you shouldn't care what package an object is blessed
into, however, as long as it claims to inherit from that class:
.PP
.Vb 1
\&    my $is_right_class = eval { $object\->isa( $package ) }; # true or false
.Ve
.PP
And, with Perl 5.10 and later, you don't have to check for an
inheritance to see if the object can handle a role. For that, you can
use \f(CW\*(C`DOES\*(C'\fR, which comes from \f(CW\*(C`UNIVERSAL\*(C'\fR:
.PP
.Vb 1
\&    my $class_does_it = eval { $object\->DOES( $role ) }; # true or false
.Ve
.PP
You can safely replace \f(CW\*(C`isa\*(C'\fR with \f(CW\*(C`DOES\*(C'\fR (although the converse is not true).
.SS "How can I comment out a large block of Perl code?"
.IX Subsection "How can I comment out a large block of Perl code?"
(contributed by brian d foy)
.PP
The quick-and-dirty way to comment out more than one line of Perl is
to surround those lines with Pod directives. You have to put these
directives at the beginning of the line and somewhere where Perl
expects a new statement (so not in the middle of statements like the \f(CW\*(C`#\*(C'\fR
comments). You end the comment with \f(CW\*(C`=cut\*(C'\fR, ending the Pod section:
.PP
.Vb 1
\&    =pod
\&
\&    my $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =cut
.Ve
.PP
The quick-and-dirty method only works well when you don't plan to
leave the commented code in the source. If a Pod parser comes along,
your multiline comment is going to show up in the Pod translation.
A better way hides it from Pod parsers as well.
.PP
The \f(CW\*(C`=begin\*(C'\fR directive can mark a section for a particular purpose.
If the Pod parser doesn't want to handle it, it just ignores it. Label
the comments with \f(CW\*(C`comment\*(C'\fR. End the comment using \f(CW\*(C`=end\*(C'\fR with the
same label. You still need the \f(CW\*(C`=cut\*(C'\fR to go back to Perl code from
the Pod comment:
.PP
.Vb 1
\&    =begin comment
\&
\&    my $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =end comment
\&
\&    =cut
.Ve
.PP
For more information on Pod, check out perlpod and perlpodspec.
.SS "How do I clear a package?"
.IX Subsection "How do I clear a package?"
Use this code, provided by Mark-Jason Dominus:
.PP
.Vb 10
\&    sub scrub_package {
\&        no strict \*(Aqrefs\*(Aq;
\&        my $pack = shift;
\&        die "Shouldn\*(Aqt delete main package"
\&            if $pack eq "" || $pack eq "main";
\&        my $stash = *{$pack . \*(Aq::\*(Aq}{HASH};
\&        my $name;
\&        foreach $name (keys %$stash) {
\&            my $fullname = $pack . \*(Aq::\*(Aq . $name;
\&            # Get rid of everything with that name.
\&            undef $$fullname;
\&            undef @$fullname;
\&            undef %$fullname;
\&            undef &$fullname;
\&            undef *$fullname;
\&        }
\&    }
.Ve
.PP
Or, if you're using a recent release of Perl, you can
just use the \fISymbol::delete_package()\fR function instead.
.SS "How can I use a variable as a variable name?"
.IX Subsection "How can I use a variable as a variable name?"
Beginners often think they want to have a variable contain the name
of a variable.
.PP
.Vb 3
\&    $fred    = 23;
\&    $varname = "fred";
\&    ++$$varname;         # $fred now 24
.Ve
.PP
This works \fIsometimes\fR, but it is a very bad idea for two reasons.
.PP
The first reason is that this technique \fIonly works on global
variables\fR. That means that if \f(CW$fred\fR is a lexical variable created
with \fImy()\fR in the above example, the code wouldn't work at all: you'd
accidentally access the global and skip right over the private lexical
altogether. Global variables are bad because they can easily collide
accidentally and in general make for non-scalable and confusing code.
.PP
Symbolic references are forbidden under the \f(CW\*(C`use strict\*(C'\fR pragma.
They are not true references and consequently are not reference-counted
or garbage-collected.
.PP
The other reason why using a variable to hold the name of another
variable is a bad idea is that the question often stems from a lack of
understanding of Perl data structures, particularly hashes. By using
symbolic references, you are just using the package's symbol-table hash
(like \f(CW%main::\fR) instead of a user-defined hash. The solution is to
use your own hash or a real reference instead.
.PP
.Vb 3
\&    $USER_VARS{"fred"} = 23;
\&    my $varname = "fred";
\&    $USER_VARS{$varname}++;  # not $$varname++
.Ve
.PP
There we're using the \f(CW%USER_VARS\fR hash instead of symbolic references.
Sometimes this comes up in reading strings from the user with variable
references and wanting to expand them to the values of your perl
program's variables. This is also a bad idea because it conflates the
program-addressable namespace and the user-addressable one. Instead of
reading a string and expanding it to the actual contents of your program's
own variables:
.PP
.Vb 2
\&    $str = \*(Aqthis has a $fred and $barney in it\*(Aq;
\&    $str =~ s/(\e$\ew+)/$1/eeg;          # need double eval
.Ve
.PP
it would be better to keep a hash around like \f(CW%USER_VARS\fR and have
variable references actually refer to entries in that hash:
.PP
.Vb 1
\&    $str =~ s/\e$(\ew+)/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
That's faster, cleaner, and safer than the previous approach. Of course,
you don't need to use a dollar sign. You could use your own scheme to
make it less confusing, like bracketed percent symbols, etc.
.PP
.Vb 2
\&    $str = \*(Aqthis has a %fred% and %barney% in it\*(Aq;
\&    $str =~ s/%(\ew+)%/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
Another reason that folks sometimes think they want a variable to
contain the name of a variable is that they don't know how to build
proper data structures using hashes. For example, let's say they
wanted two hashes in their program: \f(CW%fred\fR and \f(CW%barney\fR, and that they
wanted to use another scalar variable to refer to those by name.
.PP
.Vb 2
\&    $name = "fred";
\&    $$name{WIFE} = "wilma";     # set %fred
\&
\&    $name = "barney";
\&    $$name{WIFE} = "betty";    # set %barney
.Ve
.PP
This is still a symbolic reference, and is still saddled with the
problems enumerated above. It would be far better to write:
.PP
.Vb 2
\&    $folks{"fred"}{WIFE}   = "wilma";
\&    $folks{"barney"}{WIFE} = "betty";
.Ve
.PP
And just use a multilevel hash to start with.
.PP
The only times that you absolutely \fImust\fR use symbolic references are
when you really must refer to the symbol table. This may be because it's
something that one can't take a real reference to, such as a format name.
Doing so may also be important for method calls, since these always go
through the symbol table for resolution.
.PP
In those cases, you would turn off \f(CW\*(C`strict \*(Aqrefs\*(Aq\*(C'\fR temporarily so you
can play around with the symbol table. For example:
.PP
.Vb 5
\&    @colors = qw(red blue green yellow orange purple violet);
\&    for my $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;  # renege for the block
\&        *$name = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
All those functions (\fIred()\fR, \fIblue()\fR, \fIgreen()\fR, etc.) appear to be separate,
but the real code in the closure actually was compiled only once.
.PP
So, sometimes you might want to use symbolic references to manipulate
the symbol table directly. This doesn't matter for formats, handles, and
subroutines, because they are always global\*(--you can't use \fImy()\fR on them.
For scalars, arrays, and hashes, though\*(--and usually for subroutines\*(--
you probably only want to use hard references.
.ie n .SS "What does ""bad interpreter"" mean?"
.el .SS "What does ``bad interpreter'' mean?"
.IX Subsection "What does bad interpreter mean?"
(contributed by brian d foy)
.PP
The \*(L"bad interpreter\*(R" message comes from the shell, not perl. The
actual message may vary depending on your platform, shell, and locale
settings.
.PP
If you see \*(L"bad interpreter \- no such file or directory\*(R", the first
line in your perl script (the \*(L"shebang\*(R" line) does not contain the
right path to perl (or any other program capable of running scripts).
Sometimes this happens when you move the script from one machine to
another and each machine has a different path to perl\-\-/usr/bin/perl
versus /usr/local/bin/perl for instance. It may also indicate
that the source machine has \s-1CRLF\s0 line terminators and the
destination machine has \s-1LF\s0 only: the shell tries to find
/usr/bin/perl<\s-1CR\s0>, but can't.
.PP
If you see \*(L"bad interpreter: Permission denied\*(R", you need to make your
script executable.
.PP
In either case, you should still be able to run the scripts with perl
explicitly:
.PP
.Vb 1
\&    % perl script.pl
.Ve
.PP
If you get a message like \*(L"perl: command not found\*(R", perl is not in
your \s-1PATH,\s0 which might also mean that the location of perl is not
where you expect it so you need to adjust your shebang line.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq75.16.1                               0100644 0001750 0001750 00000133762 12566207417 023011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ7 1"
.TH PERLFAQ7 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq7 \- General Perl Language Issues
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with general Perl language issues that don't
clearly fit into any of the other sections.
.SS "Can I get a BNF/yacc/RE for the Perl language?"
.IX Subsection "Can I get a BNF/yacc/RE for the Perl language?"
There is no \s-1BNF\s0, but you can paw your way through the yacc grammar in
perly.y in the source distribution if you're particularly brave. The
grammar relies on very smart tokenizing code, so be prepared to
venture into toke.c as well.
.PP
In the words of Chaim Frenkel: \*(L"Perl's grammar can not be reduced to \s-1BNF\s0.
The work of parsing perl is distributed between yacc, the lexer, smoke
and mirrors.\*(R"
.SS "What are all these $@%&* punctuation signs, and how do I know when to use them?"
.IX Subsection "What are all these $@%&* punctuation signs, and how do I know when to use them?"
They are type specifiers, as detailed in perldata:
.PP
.Vb 6
\&    $ for scalar values (number, string or reference)
\&    @ for arrays
\&    % for hashes (associative arrays)
\&    & for subroutines (aka functions, procedures, methods)
\&    * for all types of that symbol name. In version 4 you used them like
\&      pointers, but in modern perls you can just use references.
.Ve
.PP
There are a couple of other symbols that
you're likely to encounter that aren't
really type specifiers:
.PP
.Vb 2
\&    <> are used for inputting a record from a filehandle.
\&    \e  takes a reference to something.
.Ve
.PP
Note that <\s-1FILE\s0> is \fIneither\fR the type specifier for files
nor the name of the handle. It is the \f(CW\*(C`<>\*(C'\fR operator applied
to the handle \s-1FILE\s0. It reads one line (well, record\*(--see
\&\*(L"$/\*(R" in perlvar) from the handle \s-1FILE\s0 in scalar context, or \fIall\fR lines
in list context. When performing open, close, or any other operation
besides \f(CW\*(C`<>\*(C'\fR on files, or even when talking about the handle, do
\&\fInot\fR use the brackets. These are correct: \f(CW\*(C`eof(FH)\*(C'\fR, \f(CW\*(C`seek(FH, 0,
2)\*(C'\fR and \*(L"copying from \s-1STDIN\s0 to \s-1FILE\s0\*(R".
.SS "Do I always/never have to quote my strings or use semicolons and commas?"
.IX Subsection "Do I always/never have to quote my strings or use semicolons and commas?"
Normally, a bareword doesn't need to be quoted, but in most cases
probably should be (and must be under \f(CW\*(C`use strict\*(C'\fR). But a hash key
consisting of a simple word and the left-hand
operand to the \f(CW\*(C`=>\*(C'\fR operator both
count as though they were quoted:
.PP
.Vb 4
\&    This                    is like this
\&    \-\-\-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    $foo{line}              $foo{\*(Aqline\*(Aq}
\&    bar => stuff            \*(Aqbar\*(Aq => stuff
.Ve
.PP
The final semicolon in a block is optional, as is the final comma in a
list. Good style (see perlstyle) says to put them in except for
one-liners:
.PP
.Vb 2
\&    if ($whoops) { exit 1 }
\&    my @nums = (1, 2, 3);
\&
\&    if ($whoops) {
\&        exit 1;
\&    }
\&
\&    my @lines = (
\&        "There Beren came from mountains cold",
\&        "And lost he wandered under leaves",
\&    );
.Ve
.SS "How do I skip some return values?"
.IX Subsection "How do I skip some return values?"
One way is to treat the return values as a list and index into it:
.PP
.Vb 1
\&    $dir = (getpwnam($user))[7];
.Ve
.PP
Another way is to use undef as an element on the left-hand-side:
.PP
.Vb 1
\&    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
.Ve
.PP
You can also use a list slice to select only the elements that
you need:
.PP
.Vb 1
\&    ($dev, $ino, $uid, $gid) = ( stat($file) )[0,1,4,5];
.Ve
.SS "How do I temporarily block warnings?"
.IX Subsection "How do I temporarily block warnings?"
If you are running Perl 5.6.0 or better, the \f(CW\*(C`use warnings\*(C'\fR pragma
allows fine control of what warnings are produced.
See perllexwarn for more details.
.PP
.Vb 4
\&    {
\&        no warnings;          # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Additionally, you can enable and disable categories of warnings.
You turn off the categories you want to ignore and you can still
get other categories of warnings. See perllexwarn for the
complete details, including the category names and hierarchy.
.PP
.Vb 4
\&    {
\&        no warnings \*(Aquninitialized\*(Aq;
\&        $x = $y + $z;
\&    }
.Ve
.PP
If you have an older version of Perl, the \f(CW$^W\fR variable (documented
in perlvar) controls runtime warnings for a block:
.PP
.Vb 4
\&    {
\&        local $^W = 0;        # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Note that like all the punctuation variables, you cannot currently
use \fImy()\fR on \f(CW$^W\fR, only \fIlocal()\fR.
.SS "What's an extension?"
.IX Subsection "What's an extension?"
An extension is a way of calling compiled C code from Perl. Reading
perlxstut is a good place to learn more about extensions.
.SS "Why do Perl operators have different precedence than C operators?"
.IX Subsection "Why do Perl operators have different precedence than C operators?"
Actually, they don't. All C operators that Perl copies have the same
precedence in Perl as they do in C. The problem is with operators that C
doesn't have, especially functions that give a list context to everything
on their right, eg. print, chmod, exec, and so on. Such functions are
called \*(L"list operators\*(R" and appear as such in the precedence table in
perlop.
.PP
A common mistake is to write:
.PP
.Vb 1
\&    unlink $file || die "snafu";
.Ve
.PP
This gets interpreted as:
.PP
.Vb 1
\&    unlink ($file || die "snafu");
.Ve
.PP
To avoid this problem, either put in extra parentheses or use the
super low precedence \f(CW\*(C`or\*(C'\fR operator:
.PP
.Vb 2
\&    (unlink $file) || die "snafu";
\&    unlink $file or die "snafu";
.Ve
.PP
The \*(L"English\*(R" operators (\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`xor\*(C'\fR, and \f(CW\*(C`not\*(C'\fR)
deliberately have precedence lower than that of list operators for
just such situations as the one above.
.PP
Another operator with surprising precedence is exponentiation. It
binds more tightly even than unary minus, making \f(CW\*(C`\-2**2\*(C'\fR produce a
negative four and not a positive one. It is also right-associating, meaning
that \f(CW\*(C`2**3**2\*(C'\fR is two raised to the ninth power, not eight squared.
.PP
Although it has the same precedence as in C, Perl's \f(CW\*(C`?:\*(C'\fR operator
produces an lvalue. This assigns \f(CW$x\fR to either \f(CW$if_true\fR or \f(CW$if_false\fR, depending
on the trueness of \f(CW$maybe:\fR
.PP
.Vb 1
\&    ($maybe ? $if_true : $if_false) = $x;
.Ve
.SS "How do I declare/create a structure?"
.IX Subsection "How do I declare/create a structure?"
In general, you don't \*(L"declare\*(R" a structure. Just use a (probably
anonymous) hash reference. See perlref and perldsc for details.
Here's an example:
.PP
.Vb 3
\&    $person = {};                   # new anonymous hash
\&    $person\->{AGE}  = 24;           # set field AGE to 24
\&    $person\->{NAME} = "Nat";        # set field NAME to "Nat"
.Ve
.PP
If you're looking for something a bit more rigorous, try perltoot.
.SS "How do I create a module?"
.IX Subsection "How do I create a module?"
perlnewmod is a good place to start, ignore the bits
about uploading to \s-1CPAN\s0 if you don't want to make your
module publicly available.
.PP
ExtUtils::ModuleMaker and Module::Starter are also
good places to start. Many \s-1CPAN\s0 authors now use Dist::Zilla
to automate as much as possible.
.PP
Detailed documentation about modules can be found at:
perlmod, perlmodlib, perlmodstyle.
.PP
If you need to include C code or C library interfaces 
use h2xs. h2xs will create the module distribution structure 
and the initial interface files.
perlxs and perlxstut explain the details.
.SS "How do I adopt or take over a module already on \s-1CPAN\s0?"
.IX Subsection "How do I adopt or take over a module already on CPAN?"
Ask the current maintainer to make you a co-maintainer or
transfer the module to you.
.PP
If you can not reach the author for some reason contact
the \s-1PAUSE\s0 admins at modules@perl.org who may be able to help,
but each case it treated seperatly.
.IP "\(bu" 4
Get a login for the Perl Authors Upload Server (\s-1PAUSE\s0) if you don't
already have one: <http://pause.perl.org>
.IP "\(bu" 4
Write to modules@perl.org explaining what you did to contact the
current maintainer. The \s-1PAUSE\s0 admins will also try to reach the
maintainer.
.IP "\(bu" 4
Post a public message in a heavily trafficked site announcing your
intention to take over the module.
.IP "\(bu" 4
Wait a bit. The \s-1PAUSE\s0 admins don't want to act too quickly in case
the current maintainer is on holiday. If there's no response to
private communication or the public post, a \s-1PAUSE\s0 admin can transfer
it to you.
.SS "How do I create a class?"
.IX Xref "class, creation package"
.IX Subsection "How do I create a class?"
(contributed by brian d foy)
.PP
In Perl, a class is just a package, and methods are just subroutines.
Perl doesn't get more formal than that and lets you set up the package
just the way that you like it (that is, it doesn't set up anything for
you).
.PP
The Perl documentation has several tutorials that cover class
creation, including perlboot (Barnyard Object Oriented Tutorial),
perltoot (Tom's Object Oriented Tutorial), perlbot (Bag o'
Object Tricks), and perlobj.
.SS "How can I tell if a variable is tainted?"
.IX Subsection "How can I tell if a variable is tainted?"
You can use the \fItainted()\fR function of the Scalar::Util module, available
from \s-1CPAN\s0 (or included with Perl since release 5.8.0).
See also \*(L"Laundering and Detecting Tainted Data\*(R" in perlsec.
.SS "What's a closure?"
.IX Subsection "What's a closure?"
Closures are documented in perlref.
.PP
\&\fIClosure\fR is a computer science term with a precise but
hard-to-explain meaning. Usually, closures are implemented in Perl as
anonymous subroutines with lasting references to lexical variables
outside their own scopes. These lexicals magically refer to the
variables that were around when the subroutine was defined (deep
binding).
.PP
Closures are most often used in programming languages where you can
have the return value of a function be itself a function, as you can
in Perl. Note that some languages provide anonymous functions but are
not capable of providing proper closures: the Python language, for
example. For more information on closures, check out any textbook on
functional programming. Scheme is a language that not only supports
but encourages closures.
.PP
Here's a classic non-closure function-generating function:
.PP
.Vb 3
\&    sub add_function_generator {
\&        return sub { shift() + shift() };
\&    }
\&
\&    my $add_sub = add_function_generator();
\&    my $sum = $add_sub\->(4,5);                # $sum is 9 now.
.Ve
.PP
The anonymous subroutine returned by \fIadd_function_generator()\fR isn't
technically a closure because it refers to no lexicals outside its own
scope. Using a closure gives you a \fIfunction template\fR with some
customization slots left out to be filled later.
.PP
Contrast this with the following \fImake_adder()\fR function, in which the
returned anonymous function contains a reference to a lexical variable
outside the scope of that function itself. Such a reference requires
that Perl return a proper closure, thus locking in for all time the
value that the lexical had when the function was created.
.PP
.Vb 4
\&    sub make_adder {
\&        my $addpiece = shift;
\&        return sub { shift() + $addpiece };
\&    }
\&
\&    my $f1 = make_adder(20);
\&    my $f2 = make_adder(555);
.Ve
.PP
Now \f(CW\*(C`$f1\->($n)\*(C'\fR is always 20 plus whatever \f(CW$n\fR you pass in, whereas
\&\f(CW\*(C`$f2\->($n)\*(C'\fR is always 555 plus whatever \f(CW$n\fR you pass in. The \f(CW$addpiece\fR
in the closure sticks around.
.PP
Closures are often used for less esoteric purposes. For example, when
you want to pass in a bit of code into a function:
.PP
.Vb 2
\&    my $line;
\&    timeout( 30, sub { $line = <STDIN> } );
.Ve
.PP
If the code to execute had been passed in as a string,
\&\f(CW\*(Aq$line = <STDIN>\*(Aq\fR, there would have been no way for the
hypothetical \fItimeout()\fR function to access the lexical variable
\&\f(CW$line\fR back in its caller's scope.
.PP
Another use for a closure is to make a variable \fIprivate\fR to a
named subroutine, e.g. a counter that gets initialized at creation
time of the sub and can only be modified from within the sub.
This is sometimes used with a \s-1BEGIN\s0 block in package files to make
sure a variable doesn't get meddled with during the lifetime of the
package:
.PP
.Vb 4
\&    BEGIN {
\&        my $id = 0;
\&        sub next_id { ++$id }
\&    }
.Ve
.PP
This is discussed in more detail in perlsub; see the entry on
\&\fIPersistent Private Variables\fR.
.SS "What is variable suicide and how can I prevent it?"
.IX Subsection "What is variable suicide and how can I prevent it?"
This problem was fixed in perl 5.004_05, so preventing it means upgrading
your version of perl. ;)
.PP
Variable suicide is when you (temporarily or permanently) lose the value
of a variable. It is caused by scoping through \fImy()\fR and \fIlocal()\fR
interacting with either closures or aliased \fIforeach()\fR iterator variables
and subroutine arguments. It used to be easy to inadvertently lose a
variable's value this way, but now it's much harder. Take this code:
.PP
.Vb 4
\&    my $f = \*(Aqfoo\*(Aq;
\&    sub T {
\&        while ($i++ < 3) { my $f = $f; $f .= "bar"; print $f, "\en" }
\&    }
\&
\&    T;
\&    print "Finally $f\en";
.Ve
.PP
If you are experiencing variable suicide, that \f(CW\*(C`my $f\*(C'\fR in the subroutine
doesn't pick up a fresh copy of the \f(CW$f\fR whose value is \f(CW\*(Aqfoo\*(Aq\fR. The
output shows that inside the subroutine the value of \f(CW$f\fR leaks through
when it shouldn't, as in this output:
.PP
.Vb 4
\&    foobar
\&    foobarbar
\&    foobarbarbar
\&    Finally foo
.Ve
.PP
The \f(CW$f\fR that has \*(L"bar\*(R" added to it three times should be a new \f(CW$f\fR
\&\f(CW\*(C`my $f\*(C'\fR should create a new lexical variable each time through the loop.
The expected output is:
.PP
.Vb 4
\&    foobar
\&    foobar
\&    foobar
\&    Finally foo
.Ve
.SS "How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
.IX Subsection "How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
You need to pass references to these objects. See \*(L"Pass by
Reference\*(R" in perlsub for this particular question, and perlref for
information on references.
.IP "Passing Variables and Functions" 4
.IX Item "Passing Variables and Functions"
Regular variables and functions are quite easy to pass: just pass in a
reference to an existing or anonymous variable or function:
.Sp
.Vb 1
\&    func( \e$some_scalar );
\&
\&    func( \e@some_array  );
\&    func( [ 1 .. 10 ]   );
\&
\&    func( \e%some_hash   );
\&    func( { this => 10, that => 20 }   );
\&
\&    func( \e&some_func   );
\&    func( sub { $_[0] ** $_[1] }   );
.Ve
.IP "Passing Filehandles" 4
.IX Item "Passing Filehandles"
As of Perl 5.6, you can represent filehandles with scalar variables
which you treat as any other scalar.
.Sp
.Vb 2
\&    open my $fh, $filename or die "Cannot open $filename! $!";
\&    func( $fh );
\&
\&    sub func {
\&        my $passed_fh = shift;
\&
\&        my $line = <$passed_fh>;
\&    }
.Ve
.Sp
Before Perl 5.6, you had to use the \f(CW*FH\fR or \f(CW\*(C`\e*FH\*(C'\fR notations.
These are \*(L"typeglobs\*(R"\-\-see \*(L"Typeglobs and Filehandles\*(R" in perldata
and especially \*(L"Pass by Reference\*(R" in perlsub for more information.
.IP "Passing Regexes" 4
.IX Item "Passing Regexes"
Here's an example of how to pass in a string and a regular expression
for it to match against. You construct the pattern with the \f(CW\*(C`qr//\*(C'\fR
operator:
.Sp
.Vb 6
\&    sub compare($$) {
\&        my ($val1, $regex) = @_;
\&        my $retval = $val1 =~ /$regex/;
\&        return $retval;
\&    }
\&    $match = compare("old McDonald", qr/d.*D/i);
.Ve
.IP "Passing Methods" 4
.IX Item "Passing Methods"
To pass an object method into a subroutine, you can do this:
.Sp
.Vb 7
\&    call_a_lot(10, $some_obj, "methname")
\&    sub call_a_lot {
\&        my ($count, $widget, $trick) = @_;
\&        for (my $i = 0; $i < $count; $i++) {
\&            $widget\->$trick();
\&        }
\&    }
.Ve
.Sp
Or, you can use a closure to bundle up the object, its
method call, and arguments:
.Sp
.Vb 6
\&    my $whatnot = sub { $some_obj\->obfuscate(@args) };
\&    func($whatnot);
\&    sub func {
\&        my $code = shift;
\&        &$code();
\&    }
.Ve
.Sp
You could also investigate the \fIcan()\fR method in the \s-1UNIVERSAL\s0 class
(part of the standard perl distribution).
.SS "How do I create a static variable?"
.IX Subsection "How do I create a static variable?"
(contributed by brian d foy)
.PP
In Perl 5.10, declare the variable with \f(CW\*(C`state\*(C'\fR. The \f(CW\*(C`state\*(C'\fR
declaration creates the lexical variable that persists between calls
to the subroutine:
.PP
.Vb 1
\&    sub counter { state $count = 1; $count++ }
.Ve
.PP
You can fake a static variable by using a lexical variable which goes
out of scope. In this example, you define the subroutine \f(CW\*(C`counter\*(C'\fR, and
it uses the lexical variable \f(CW$count\fR. Since you wrap this in a \s-1BEGIN\s0
block, \f(CW$count\fR is defined at compile-time, but also goes out of
scope at the end of the \s-1BEGIN\s0 block. The \s-1BEGIN\s0 block also ensures that
the subroutine and the value it uses is defined at compile-time so the
subroutine is ready to use just like any other subroutine, and you can
put this code in the same place as other subroutines in the program
text (i.e. at the end of the code, typically). The subroutine
\&\f(CW\*(C`counter\*(C'\fR still has a reference to the data, and is the only way you
can access the value (and each time you do, you increment the value).
The data in chunk of memory defined by \f(CW$count\fR is private to
\&\f(CW\*(C`counter\*(C'\fR.
.PP
.Vb 4
\&    BEGIN {
\&        my $count = 1;
\&        sub counter { $count++ }
\&    }
\&
\&    my $start = counter();
\&
\&    .... # code that calls counter();
\&
\&    my $end = counter();
.Ve
.PP
In the previous example, you created a function-private variable
because only one function remembered its reference. You could define
multiple functions while the variable is in scope, and each function
can share the \*(L"private\*(R" variable. It's not really \*(L"static\*(R" because you
can access it outside the function while the lexical variable is in
scope, and even create references to it. In this example,
\&\f(CW\*(C`increment_count\*(C'\fR and \f(CW\*(C`return_count\*(C'\fR share the variable. One
function adds to the value and the other simply returns the value.
They can both access \f(CW$count\fR, and since it has gone out of scope,
there is no other way to access it.
.PP
.Vb 5
\&    BEGIN {
\&        my $count = 1;
\&        sub increment_count { $count++ }
\&        sub return_count    { $count }
\&    }
.Ve
.PP
To declare a file-private variable, you still use a lexical variable.
A file is also a scope, so a lexical variable defined in the file
cannot be seen from any other file.
.PP
See \*(L"Persistent Private Variables\*(R" in perlsub for more information.
The discussion of closures in perlref may help you even though we
did not use anonymous subroutines in this answer. See
\&\*(L"Persistent Private Variables\*(R" in perlsub for details.
.SS "What's the difference between dynamic and lexical (static) scoping? Between \fIlocal()\fP and \fImy()\fP?"
.IX Subsection "What's the difference between dynamic and lexical (static) scoping? Between local() and my()?"
\&\f(CW\*(C`local($x)\*(C'\fR saves away the old value of the global variable \f(CW$x\fR
and assigns a new value for the duration of the subroutine \fIwhich is
visible in other functions called from that subroutine\fR. This is done
at run-time, so is called dynamic scoping. \fIlocal()\fR always affects global
variables, also called package variables or dynamic variables.
.PP
\&\f(CW\*(C`my($x)\*(C'\fR creates a new variable that is only visible in the current
subroutine. This is done at compile-time, so it is called lexical or
static scoping. \fImy()\fR always affects private variables, also called
lexical variables or (improperly) static(ly scoped) variables.
.PP
For instance:
.PP
.Vb 3
\&    sub visible {
\&        print "var has value $var\en";
\&    }
\&
\&    sub dynamic {
\&        local $var = \*(Aqlocal\*(Aq;    # new temporary value for the still\-global
\&        visible();              #   variable called $var
\&    }
\&
\&    sub lexical {
\&        my $var = \*(Aqprivate\*(Aq;    # new private variable, $var
\&        visible();              # (invisible outside of sub scope)
\&    }
\&
\&    $var = \*(Aqglobal\*(Aq;
\&
\&    visible();              # prints global
\&    dynamic();              # prints local
\&    lexical();              # prints global
.Ve
.PP
Notice how at no point does the value \*(L"private\*(R" get printed. That's
because \f(CW$var\fR only has that value within the block of the \fIlexical()\fR
function, and it is hidden from the called subroutine.
.PP
In summary, \fIlocal()\fR doesn't make what you think of as private, local
variables. It gives a global variable a temporary value. \fImy()\fR is
what you're looking for if you want private variables.
.PP
See \*(L"Private Variables via \fImy()\fR\*(R" in perlsub and
\&\*(L"Temporary Values via \fIlocal()\fR\*(R" in perlsub for excruciating details.
.SS "How can I access a dynamic variable while a similarly named lexical is in scope?"
.IX Subsection "How can I access a dynamic variable while a similarly named lexical is in scope?"
If you know your package, you can just mention it explicitly, as in
\&\f(CW$Some_Pack::var\fR. Note that the notation \f(CW$::var\fR is \fBnot\fR the dynamic \f(CW$var\fR
in the current package, but rather the one in the \*(L"main\*(R" package, as
though you had written \f(CW$main::var\fR.
.PP
.Vb 3
\&    use vars \*(Aq$var\*(Aq;
\&    local $var = "global";
\&    my    $var = "lexical";
\&
\&    print "lexical is $var\en";
\&    print "global  is $main::var\en";
.Ve
.PP
Alternatively you can use the compiler directive \fIour()\fR to bring a
dynamic variable into the current lexical scope.
.PP
.Vb 2
\&    require 5.006; # our() did not exist before 5.6
\&    use vars \*(Aq$var\*(Aq;
\&
\&    local $var = "global";
\&    my $var    = "lexical";
\&
\&    print "lexical is $var\en";
\&
\&    {
\&        our $var;
\&        print "global  is $var\en";
\&    }
.Ve
.SS "What's the difference between deep and shallow binding?"
.IX Subsection "What's the difference between deep and shallow binding?"
In deep binding, lexical variables mentioned in anonymous subroutines
are the same ones that were in scope when the subroutine was created.
In shallow binding, they are whichever variables with the same names
happen to be in scope when the subroutine is called. Perl always uses
deep binding of lexical variables (i.e., those created with \fImy()\fR).
However, dynamic variables (aka global, local, or package variables)
are effectively shallowly bound. Consider this just one more reason
not to use them. See the answer to \*(L"What's a closure?\*(R".
.ie n .SS "Why doesn't ""my($foo) = <$fh>;"" work right?"
.el .SS "Why doesn't ``my($foo) = <$fh>;'' work right?"
.IX Subsection "Why doesn't my($foo) = <$fh>; work right?"
\&\f(CW\*(C`my()\*(C'\fR and \f(CW\*(C`local()\*(C'\fR give list context to the right hand side
of \f(CW\*(C`=\*(C'\fR. The <$fh> read operation, like so many of Perl's
functions and operators, can tell which context it was called in and
behaves appropriately. In general, the \fIscalar()\fR function can help.
This function does nothing to the data itself (contrary to popular myth)
but rather tells its argument to behave in whatever its scalar fashion is.
If that function doesn't have a defined scalar behavior, this of course
doesn't help you (such as with \fIsort()\fR).
.PP
To enforce scalar context in this particular case, however, you need
merely omit the parentheses:
.PP
.Vb 3
\&    local($foo) = <$fh>;        # WRONG
\&    local($foo) = scalar(<$fh>);   # ok
\&    local $foo  = <$fh>;        # right
.Ve
.PP
You should probably be using lexical variables anyway, although the
issue is the same here:
.PP
.Vb 2
\&    my($foo) = <$fh>;    # WRONG
\&    my $foo  = <$fh>;    # right
.Ve
.SS "How do I redefine a builtin function, operator, or method?"
.IX Subsection "How do I redefine a builtin function, operator, or method?"
Why do you want to do that? :\-)
.PP
If you want to override a predefined function, such as \fIopen()\fR,
then you'll have to import the new definition from a different
module. See \*(L"Overriding Built-in Functions\*(R" in perlsub.
.PP
If you want to overload a Perl operator, such as \f(CW\*(C`+\*(C'\fR or \f(CW\*(C`**\*(C'\fR,
then you'll want to use the \f(CW\*(C`use overload\*(C'\fR pragma, documented
in overload.
.PP
If you're talking about obscuring method calls in parent classes,
see \*(L"Overridden Methods\*(R" in perltoot.
.SS "What's the difference between calling a function as &foo and \fIfoo()\fP?"
.IX Subsection "What's the difference between calling a function as &foo and foo()?"
(contributed by brian d foy)
.PP
Calling a subroutine as \f(CW&foo\fR with no trailing parentheses ignores
the prototype of \f(CW\*(C`foo\*(C'\fR and passes it the current value of the argument
list, \f(CW@_\fR. Here's an example; the \f(CW\*(C`bar\*(C'\fR subroutine calls \f(CW&foo\fR,
which prints its arguments list:
.PP
.Vb 1
\&    sub bar { &foo }
\&
\&    sub foo { print "Args in foo are: @_\en" }
\&
\&    bar( qw( a b c ) );
.Ve
.PP
When you call \f(CW\*(C`bar\*(C'\fR with arguments, you see that \f(CW\*(C`foo\*(C'\fR got the same \f(CW@_\fR:
.PP
.Vb 1
\&    Args in foo are: a b c
.Ve
.PP
Calling the subroutine with trailing parentheses, with or without arguments,
does not use the current \f(CW@_\fR and respects the subroutine prototype. Changing
the example to put parentheses after the call to \f(CW\*(C`foo\*(C'\fR changes the program:
.PP
.Vb 1
\&    sub bar { &foo() }
\&
\&    sub foo { print "Args in foo are: @_\en" }
\&
\&    bar( qw( a b c ) );
.Ve
.PP
Now the output shows that \f(CW\*(C`foo\*(C'\fR doesn't get the \f(CW@_\fR from its caller.
.PP
.Vb 1
\&    Args in foo are:
.Ve
.PP
The main use of the \f(CW@_\fR pass-through feature is to write subroutines
whose main job it is to call other subroutines for you. For further
details, see perlsub.
.SS "How do I create a switch or case statement?"
.IX Subsection "How do I create a switch or case statement?"
In Perl 5.10, use the \f(CW\*(C`given\-when\*(C'\fR construct described in perlsyn:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given ( $string ) {
\&        when( \*(AqFred\*(Aq )        { say "I found Fred!" }
\&        when( \*(AqBarney\*(Aq )      { say "I found Barney!" }
\&        when( /Bamm\-?Bamm/ )  { say "I found Bamm\-Bamm!" }
\&        default               { say "I don\*(Aqt recognize the name!" }
\&    };
.Ve
.PP
If one wants to use pure Perl and to be compatible with Perl versions
prior to 5.10, the general answer is to use \f(CW\*(C`if\-elsif\-else\*(C'\fR:
.PP
.Vb 6
\&    for ($variable_to_test) {
\&        if    (/pat1/)  { }     # do something
\&        elsif (/pat2/)  { }     # do something else
\&        elsif (/pat3/)  { }     # do something else
\&        else            { }     # default
\&    }
.Ve
.PP
Here's a simple example of a switch based on pattern matching,
lined up in a way to make it look more like a switch statement.
We'll do a multiway conditional based on the type of reference stored
in \f(CW$whatchamacallit:\fR
.PP
.Vb 1
\&    SWITCH: for (ref $whatchamacallit) {
\&
\&        /^$/           && die "not a reference";
\&
\&        /SCALAR/       && do {
\&                        print_scalar($$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /ARRAY/        && do {
\&                        print_array(@$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /HASH/        && do {
\&                        print_hash(%$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /CODE/        && do {
\&                        warn "can\*(Aqt print function ref";
\&                        last SWITCH;
\&                      };
\&
\&        # DEFAULT
\&
\&        warn "User defined type skipped";
\&
\&    }
.Ve
.PP
See perlsyn for other examples in this style.
.PP
Sometimes you should change the positions of the constant and the variable.
For example, let's say you wanted to test which of many answers you were
given, but in a case-insensitive way that also allows abbreviations.
You can use the following technique if the strings all start with
different characters or if you want to arrange the matches so that
one takes precedence over another, as \f(CW"SEND"\fR has precedence over
\&\f(CW"STOP"\fR here:
.PP
.Vb 6
\&    chomp($answer = <>);
\&    if    ("SEND"  =~ /^\eQ$answer/i) { print "Action is send\en"  }
\&    elsif ("STOP"  =~ /^\eQ$answer/i) { print "Action is stop\en"  }
\&    elsif ("ABORT" =~ /^\eQ$answer/i) { print "Action is abort\en" }
\&    elsif ("LIST"  =~ /^\eQ$answer/i) { print "Action is list\en"  }
\&    elsif ("EDIT"  =~ /^\eQ$answer/i) { print "Action is edit\en"  }
.Ve
.PP
A totally different approach is to create a hash of function references.
.PP
.Vb 6
\&    my %commands = (
\&        "happy" => \e&joy,
\&        "sad",  => \e&sullen,
\&        "done"  => sub { die "See ya!" },
\&        "mad"   => \e&angry,
\&    );
\&
\&    print "How are you? ";
\&    chomp($string = <STDIN>);
\&    if ($commands{$string}) {
\&        $commands{$string}\->();
\&    } else {
\&        print "No such command: $string\en";
\&    }
.Ve
.PP
Starting from Perl 5.8, a source filter module, \f(CW\*(C`Switch\*(C'\fR, can also be
used to get switch and case. Its use is now discouraged, because it's
not fully compatible with the native switch of Perl 5.10, and because,
as it's implemented as a source filter, it doesn't always work as intended
when complex syntax is involved.
.SS "How can I catch accesses to undefined variables, functions, or methods?"
.IX Subsection "How can I catch accesses to undefined variables, functions, or methods?"
The \s-1AUTOLOAD\s0 method, discussed in \*(L"Autoloading\*(R" in perlsub and
\&\*(L"\s-1AUTOLOAD:\s0 Proxy Methods\*(R" in perltoot, lets you capture calls to
undefined functions and methods.
.PP
When it comes to undefined variables that would trigger a warning
under \f(CW\*(C`use warnings\*(C'\fR, you can promote the warning to an error.
.PP
.Vb 1
\&    use warnings FATAL => qw(uninitialized);
.Ve
.SS "Why can't a method included in this same file be found?"
.IX Subsection "Why can't a method included in this same file be found?"
Some possible reasons: your inheritance is getting confused, you've
misspelled the method name, or the object is of the wrong type. Check
out perltoot for details about any of the above cases. You may
also use \f(CW\*(C`print ref($object)\*(C'\fR to find out the class \f(CW$object\fR was
blessed into.
.PP
Another possible reason for problems is that you've used the
indirect object syntax (eg, \f(CW\*(C`find Guru "Samy"\*(C'\fR) on a class name
before Perl has seen that such a package exists. It's wisest to make
sure your packages are all defined before you start using them, which
will be taken care of if you use the \f(CW\*(C`use\*(C'\fR statement instead of
\&\f(CW\*(C`require\*(C'\fR. If not, make sure to use arrow notation (eg.,
\&\f(CW\*(C`Guru\->find("Samy")\*(C'\fR) instead. Object notation is explained in
perlobj.
.PP
Make sure to read about creating modules in perlmod and
the perils of indirect objects in \*(L"Method Invocation\*(R" in perlobj.
.SS "How can I find out my current or calling package?"
.IX Subsection "How can I find out my current or calling package?"
(contributed by brian d foy)
.PP
To find the package you are currently in, use the special literal
\&\f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR, as documented in perldata. You can only use the
special literals as separate tokens, so you can't interpolate them
into strings like you can with variables:
.PP
.Vb 2
\&    my $current_package = _\|_PACKAGE_\|_;
\&    print "I am in package $current_package\en";
.Ve
.PP
If you want to find the package calling your code, perhaps to give better
diagnostics as Carp does, use the \f(CW\*(C`caller\*(C'\fR built-in:
.PP
.Vb 3
\&    sub foo {
\&        my @args = ...;
\&        my( $package, $filename, $line ) = caller;
\&
\&        print "I was called from package $package\en";
\&        );
.Ve
.PP
By default, your program starts in package \f(CW\*(C`main\*(C'\fR, so you will
always be in some package.
.PP
This is different from finding out the package an object is blessed
into, which might not be the current package. For that, use \f(CW\*(C`blessed\*(C'\fR
from Scalar::Util, part of the Standard Library since Perl 5.8:
.PP
.Vb 2
\&    use Scalar::Util qw(blessed);
\&    my $object_package = blessed( $object );
.Ve
.PP
Most of the time, you shouldn't care what package an object is blessed
into, however, as long as it claims to inherit from that class:
.PP
.Vb 1
\&    my $is_right_class = eval { $object\->isa( $package ) }; # true or false
.Ve
.PP
And, with Perl 5.10 and later, you don't have to check for an
inheritance to see if the object can handle a role. For that, you can
use \f(CW\*(C`DOES\*(C'\fR, which comes from \f(CW\*(C`UNIVERSAL\*(C'\fR:
.PP
.Vb 1
\&    my $class_does_it = eval { $object\->DOES( $role ) }; # true or false
.Ve
.PP
You can safely replace \f(CW\*(C`isa\*(C'\fR with \f(CW\*(C`DOES\*(C'\fR (although the converse is not true).
.SS "How can I comment out a large block of Perl code?"
.IX Subsection "How can I comment out a large block of Perl code?"
(contributed by brian d foy)
.PP
The quick-and-dirty way to comment out more than one line of Perl is
to surround those lines with Pod directives. You have to put these
directives at the beginning of the line and somewhere where Perl
expects a new statement (so not in the middle of statements like the \f(CW\*(C`#\*(C'\fR
comments). You end the comment with \f(CW\*(C`=cut\*(C'\fR, ending the Pod section:
.PP
.Vb 1
\&    =pod
\&
\&    my $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =cut
.Ve
.PP
The quick-and-dirty method only works well when you don't plan to
leave the commented code in the source. If a Pod parser comes along,
you're multiline comment is going to show up in the Pod translation.
A better way hides it from Pod parsers as well.
.PP
The \f(CW\*(C`=begin\*(C'\fR directive can mark a section for a particular purpose.
If the Pod parser doesn't want to handle it, it just ignores it. Label
the comments with \f(CW\*(C`comment\*(C'\fR. End the comment using \f(CW\*(C`=end\*(C'\fR with the
same label. You still need the \f(CW\*(C`=cut\*(C'\fR to go back to Perl code from
the Pod comment:
.PP
.Vb 1
\&    =begin comment
\&
\&    my $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =end comment
\&
\&    =cut
.Ve
.PP
For more information on Pod, check out perlpod and perlpodspec.
.SS "How do I clear a package?"
.IX Subsection "How do I clear a package?"
Use this code, provided by Mark-Jason Dominus:
.PP
.Vb 10
\&    sub scrub_package {
\&        no strict \*(Aqrefs\*(Aq;
\&        my $pack = shift;
\&        die "Shouldn\*(Aqt delete main package"
\&            if $pack eq "" || $pack eq "main";
\&        my $stash = *{$pack . \*(Aq::\*(Aq}{HASH};
\&        my $name;
\&        foreach $name (keys %$stash) {
\&            my $fullname = $pack . \*(Aq::\*(Aq . $name;
\&            # Get rid of everything with that name.
\&            undef $$fullname;
\&            undef @$fullname;
\&            undef %$fullname;
\&            undef &$fullname;
\&            undef *$fullname;
\&        }
\&    }
.Ve
.PP
Or, if you're using a recent release of Perl, you can
just use the \fISymbol::delete_package()\fR function instead.
.SS "How can I use a variable as a variable name?"
.IX Subsection "How can I use a variable as a variable name?"
Beginners often think they want to have a variable contain the name
of a variable.
.PP
.Vb 3
\&    $fred    = 23;
\&    $varname = "fred";
\&    ++$$varname;         # $fred now 24
.Ve
.PP
This works \fIsometimes\fR, but it is a very bad idea for two reasons.
.PP
The first reason is that this technique \fIonly works on global
variables\fR. That means that if \f(CW$fred\fR is a lexical variable created
with \fImy()\fR in the above example, the code wouldn't work at all: you'd
accidentally access the global and skip right over the private lexical
altogether. Global variables are bad because they can easily collide
accidentally and in general make for non-scalable and confusing code.
.PP
Symbolic references are forbidden under the \f(CW\*(C`use strict\*(C'\fR pragma.
They are not true references and consequently are not reference-counted
or garbage-collected.
.PP
The other reason why using a variable to hold the name of another
variable is a bad idea is that the question often stems from a lack of
understanding of Perl data structures, particularly hashes. By using
symbolic references, you are just using the package's symbol-table hash
(like \f(CW%main::\fR) instead of a user-defined hash. The solution is to
use your own hash or a real reference instead.
.PP
.Vb 3
\&    $USER_VARS{"fred"} = 23;
\&    my $varname = "fred";
\&    $USER_VARS{$varname}++;  # not $$varname++
.Ve
.PP
There we're using the \f(CW%USER_VARS\fR hash instead of symbolic references.
Sometimes this comes up in reading strings from the user with variable
references and wanting to expand them to the values of your perl
program's variables. This is also a bad idea because it conflates the
program-addressable namespace and the user-addressable one. Instead of
reading a string and expanding it to the actual contents of your program's
own variables:
.PP
.Vb 2
\&    $str = \*(Aqthis has a $fred and $barney in it\*(Aq;
\&    $str =~ s/(\e$\ew+)/$1/eeg;          # need double eval
.Ve
.PP
it would be better to keep a hash around like \f(CW%USER_VARS\fR and have
variable references actually refer to entries in that hash:
.PP
.Vb 1
\&    $str =~ s/\e$(\ew+)/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
That's faster, cleaner, and safer than the previous approach. Of course,
you don't need to use a dollar sign. You could use your own scheme to
make it less confusing, like bracketed percent symbols, etc.
.PP
.Vb 2
\&    $str = \*(Aqthis has a %fred% and %barney% in it\*(Aq;
\&    $str =~ s/%(\ew+)%/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
Another reason that folks sometimes think they want a variable to
contain the name of a variable is that they don't know how to build
proper data structures using hashes. For example, let's say they
wanted two hashes in their program: \f(CW%fred\fR and \f(CW%barney\fR, and that they
wanted to use another scalar variable to refer to those by name.
.PP
.Vb 2
\&    $name = "fred";
\&    $$name{WIFE} = "wilma";     # set %fred
\&
\&    $name = "barney";
\&    $$name{WIFE} = "betty";    # set %barney
.Ve
.PP
This is still a symbolic reference, and is still saddled with the
problems enumerated above. It would be far better to write:
.PP
.Vb 2
\&    $folks{"fred"}{WIFE}   = "wilma";
\&    $folks{"barney"}{WIFE} = "betty";
.Ve
.PP
And just use a multilevel hash to start with.
.PP
The only times that you absolutely \fImust\fR use symbolic references are
when you really must refer to the symbol table. This may be because it's
something that one can't take a real reference to, such as a format name.
Doing so may also be important for method calls, since these always go
through the symbol table for resolution.
.PP
In those cases, you would turn off \f(CW\*(C`strict \*(Aqrefs\*(Aq\*(C'\fR temporarily so you
can play around with the symbol table. For example:
.PP
.Vb 5
\&    @colors = qw(red blue green yellow orange purple violet);
\&    for my $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;  # renege for the block
\&        *$name = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
All those functions (\fIred()\fR, \fIblue()\fR, \fIgreen()\fR, etc.) appear to be separate,
but the real code in the closure actually was compiled only once.
.PP
So, sometimes you might want to use symbolic references to manipulate
the symbol table directly. This doesn't matter for formats, handles, and
subroutines, because they are always global\*(--you can't use \fImy()\fR on them.
For scalars, arrays, and hashes, though\*(--and usually for subroutines\*(--
you probably only want to use hard references.
.ie n .SS "What does ""bad interpreter"" mean?"
.el .SS "What does ``bad interpreter'' mean?"
.IX Subsection "What does bad interpreter mean?"
(contributed by brian d foy)
.PP
The \*(L"bad interpreter\*(R" message comes from the shell, not perl. The
actual message may vary depending on your platform, shell, and locale
settings.
.PP
If you see \*(L"bad interpreter \- no such file or directory\*(R", the first
line in your perl script (the \*(L"shebang\*(R" line) does not contain the
right path to perl (or any other program capable of running scripts).
Sometimes this happens when you move the script from one machine to
another and each machine has a different path to perl\-\-/usr/bin/perl
versus /usr/local/bin/perl for instance. It may also indicate
that the source machine has \s-1CRLF\s0 line terminators and the
destination machine has \s-1LF\s0 only: the shell tries to find
/usr/bin/perl<\s-1CR\s0>, but can't.
.PP
If you see \*(L"bad interpreter: Permission denied\*(R", you need to make your
script executable.
.PP
In either case, you should still be able to run the scripts with perl
explicitly:
.PP
.Vb 1
\&    % perl script.pl
.Ve
.PP
If you get a message like \*(L"perl: command not found\*(R", perl is not in
your \s-1PATH\s0, which might also mean that the location of perl is not
where you expect it so you need to adjust your shebang line.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq75.18.1                               0100644 0001750 0001750 00000134275 12566207437 023015  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ7 1"
.TH PERLFAQ7 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq7 \- General Perl Language Issues
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with general Perl language issues that don't
clearly fit into any of the other sections.
.SS "Can I get a BNF/yacc/RE for the Perl language?"
.IX Subsection "Can I get a BNF/yacc/RE for the Perl language?"
There is no \s-1BNF,\s0 but you can paw your way through the yacc grammar in
perly.y in the source distribution if you're particularly brave. The
grammar relies on very smart tokenizing code, so be prepared to
venture into toke.c as well.
.PP
In the words of Chaim Frenkel: \*(L"Perl's grammar can not be reduced to \s-1BNF.\s0
The work of parsing perl is distributed between yacc, the lexer, smoke
and mirrors.\*(R"
.SS "What are all these $@%&* punctuation signs, and how do I know when to use them?"
.IX Subsection "What are all these $@%&* punctuation signs, and how do I know when to use them?"
They are type specifiers, as detailed in perldata:
.PP
.Vb 6
\&    $ for scalar values (number, string or reference)
\&    @ for arrays
\&    % for hashes (associative arrays)
\&    & for subroutines (aka functions, procedures, methods)
\&    * for all types of that symbol name. In version 4 you used them like
\&      pointers, but in modern perls you can just use references.
.Ve
.PP
There are a couple of other symbols that
you're likely to encounter that aren't
really type specifiers:
.PP
.Vb 2
\&    <> are used for inputting a record from a filehandle.
\&    \e  takes a reference to something.
.Ve
.PP
Note that <\s-1FILE\s0> is \fIneither\fR the type specifier for files
nor the name of the handle. It is the \f(CW\*(C`<>\*(C'\fR operator applied
to the handle \s-1FILE.\s0 It reads one line (well, record\*(--see
\&\*(L"$/\*(R" in perlvar) from the handle \s-1FILE\s0 in scalar context, or \fIall\fR lines
in list context. When performing open, close, or any other operation
besides \f(CW\*(C`<>\*(C'\fR on files, or even when talking about the handle, do
\&\fInot\fR use the brackets. These are correct: \f(CW\*(C`eof(FH)\*(C'\fR, \f(CW\*(C`seek(FH, 0,
2)\*(C'\fR and \*(L"copying from \s-1STDIN\s0 to \s-1FILE\*(R".\s0
.SS "Do I always/never have to quote my strings or use semicolons and commas?"
.IX Subsection "Do I always/never have to quote my strings or use semicolons and commas?"
Normally, a bareword doesn't need to be quoted, but in most cases
probably should be (and must be under \f(CW\*(C`use strict\*(C'\fR). But a hash key
consisting of a simple word and the left-hand
operand to the \f(CW\*(C`=>\*(C'\fR operator both
count as though they were quoted:
.PP
.Vb 4
\&    This                    is like this
\&    \-\-\-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    $foo{line}              $foo{\*(Aqline\*(Aq}
\&    bar => stuff            \*(Aqbar\*(Aq => stuff
.Ve
.PP
The final semicolon in a block is optional, as is the final comma in a
list. Good style (see perlstyle) says to put them in except for
one-liners:
.PP
.Vb 2
\&    if ($whoops) { exit 1 }
\&    my @nums = (1, 2, 3);
\&
\&    if ($whoops) {
\&        exit 1;
\&    }
\&
\&    my @lines = (
\&        "There Beren came from mountains cold",
\&        "And lost he wandered under leaves",
\&    );
.Ve
.SS "How do I skip some return values?"
.IX Subsection "How do I skip some return values?"
One way is to treat the return values as a list and index into it:
.PP
.Vb 1
\&    $dir = (getpwnam($user))[7];
.Ve
.PP
Another way is to use undef as an element on the left-hand-side:
.PP
.Vb 1
\&    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
.Ve
.PP
You can also use a list slice to select only the elements that
you need:
.PP
.Vb 1
\&    ($dev, $ino, $uid, $gid) = ( stat($file) )[0,1,4,5];
.Ve
.SS "How do I temporarily block warnings?"
.IX Subsection "How do I temporarily block warnings?"
If you are running Perl 5.6.0 or better, the \f(CW\*(C`use warnings\*(C'\fR pragma
allows fine control of what warnings are produced.
See perllexwarn for more details.
.PP
.Vb 4
\&    {
\&        no warnings;          # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Additionally, you can enable and disable categories of warnings.
You turn off the categories you want to ignore and you can still
get other categories of warnings. See perllexwarn for the
complete details, including the category names and hierarchy.
.PP
.Vb 4
\&    {
\&        no warnings \*(Aquninitialized\*(Aq;
\&        $x = $y + $z;
\&    }
.Ve
.PP
If you have an older version of Perl, the \f(CW$^W\fR variable (documented
in perlvar) controls runtime warnings for a block:
.PP
.Vb 4
\&    {
\&        local $^W = 0;        # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Note that like all the punctuation variables, you cannot currently
use \fImy()\fR on \f(CW$^W\fR, only \fIlocal()\fR.
.SS "What's an extension?"
.IX Subsection "What's an extension?"
An extension is a way of calling compiled C code from Perl. Reading
perlxstut is a good place to learn more about extensions.
.SS "Why do Perl operators have different precedence than C operators?"
.IX Subsection "Why do Perl operators have different precedence than C operators?"
Actually, they don't. All C operators that Perl copies have the same
precedence in Perl as they do in C. The problem is with operators that C
doesn't have, especially functions that give a list context to everything
on their right, eg. print, chmod, exec, and so on. Such functions are
called \*(L"list operators\*(R" and appear as such in the precedence table in
perlop.
.PP
A common mistake is to write:
.PP
.Vb 1
\&    unlink $file || die "snafu";
.Ve
.PP
This gets interpreted as:
.PP
.Vb 1
\&    unlink ($file || die "snafu");
.Ve
.PP
To avoid this problem, either put in extra parentheses or use the
super low precedence \f(CW\*(C`or\*(C'\fR operator:
.PP
.Vb 2
\&    (unlink $file) || die "snafu";
\&    unlink $file or die "snafu";
.Ve
.PP
The \*(L"English\*(R" operators (\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`xor\*(C'\fR, and \f(CW\*(C`not\*(C'\fR)
deliberately have precedence lower than that of list operators for
just such situations as the one above.
.PP
Another operator with surprising precedence is exponentiation. It
binds more tightly even than unary minus, making \f(CW\*(C`\-2**2\*(C'\fR produce a
negative four and not a positive one. It is also right-associating, meaning
that \f(CW\*(C`2**3**2\*(C'\fR is two raised to the ninth power, not eight squared.
.PP
Although it has the same precedence as in C, Perl's \f(CW\*(C`?:\*(C'\fR operator
produces an lvalue. This assigns \f(CW$x\fR to either \f(CW$if_true\fR or \f(CW$if_false\fR, depending
on the trueness of \f(CW$maybe:\fR
.PP
.Vb 1
\&    ($maybe ? $if_true : $if_false) = $x;
.Ve
.SS "How do I declare/create a structure?"
.IX Subsection "How do I declare/create a structure?"
In general, you don't \*(L"declare\*(R" a structure. Just use a (probably
anonymous) hash reference. See perlref and perldsc for details.
Here's an example:
.PP
.Vb 3
\&    $person = {};                   # new anonymous hash
\&    $person\->{AGE}  = 24;           # set field AGE to 24
\&    $person\->{NAME} = "Nat";        # set field NAME to "Nat"
.Ve
.PP
If you're looking for something a bit more rigorous, try perltoot.
.SS "How do I create a module?"
.IX Subsection "How do I create a module?"
perlnewmod is a good place to start, ignore the bits
about uploading to \s-1CPAN\s0 if you don't want to make your
module publicly available.
.PP
ExtUtils::ModuleMaker and Module::Starter are also
good places to start. Many \s-1CPAN\s0 authors now use Dist::Zilla
to automate as much as possible.
.PP
Detailed documentation about modules can be found at:
perlmod, perlmodlib, perlmodstyle.
.PP
If you need to include C code or C library interfaces 
use h2xs. h2xs will create the module distribution structure 
and the initial interface files.
perlxs and perlxstut explain the details.
.SS "How do I adopt or take over a module already on \s-1CPAN\s0?"
.IX Subsection "How do I adopt or take over a module already on CPAN?"
Ask the current maintainer to make you a co-maintainer or
transfer the module to you.
.PP
If you can not reach the author for some reason contact
the \s-1PAUSE\s0 admins at modules@perl.org who may be able to help,
but each case it treated seperatly.
.IP "\(bu" 4
Get a login for the Perl Authors Upload Server (\s-1PAUSE\s0) if you don't
already have one: <http://pause.perl.org>
.IP "\(bu" 4
Write to modules@perl.org explaining what you did to contact the
current maintainer. The \s-1PAUSE\s0 admins will also try to reach the
maintainer.
.IP "\(bu" 4
Post a public message in a heavily trafficked site announcing your
intention to take over the module.
.IP "\(bu" 4
Wait a bit. The \s-1PAUSE\s0 admins don't want to act too quickly in case
the current maintainer is on holiday. If there's no response to
private communication or the public post, a \s-1PAUSE\s0 admin can transfer
it to you.
.SS "How do I create a class?"
.IX Xref "class, creation package"
.IX Subsection "How do I create a class?"
(contributed by brian d foy)
.PP
In Perl, a class is just a package, and methods are just subroutines.
Perl doesn't get more formal than that and lets you set up the package
just the way that you like it (that is, it doesn't set up anything for
you).
.PP
The Perl documentation has several tutorials that cover class
creation, including perlboot (Barnyard Object Oriented Tutorial),
perltoot (Tom's Object Oriented Tutorial), perlbot (Bag o'
Object Tricks), and perlobj.
.SS "How can I tell if a variable is tainted?"
.IX Subsection "How can I tell if a variable is tainted?"
You can use the \fItainted()\fR function of the Scalar::Util module, available
from \s-1CPAN \s0(or included with Perl since release 5.8.0).
See also \*(L"Laundering and Detecting Tainted Data\*(R" in perlsec.
.SS "What's a closure?"
.IX Subsection "What's a closure?"
Closures are documented in perlref.
.PP
\&\fIClosure\fR is a computer science term with a precise but
hard-to-explain meaning. Usually, closures are implemented in Perl as
anonymous subroutines with lasting references to lexical variables
outside their own scopes. These lexicals magically refer to the
variables that were around when the subroutine was defined (deep
binding).
.PP
Closures are most often used in programming languages where you can
have the return value of a function be itself a function, as you can
in Perl. Note that some languages provide anonymous functions but are
not capable of providing proper closures: the Python language, for
example. For more information on closures, check out any textbook on
functional programming. Scheme is a language that not only supports
but encourages closures.
.PP
Here's a classic non-closure function-generating function:
.PP
.Vb 3
\&    sub add_function_generator {
\&        return sub { shift() + shift() };
\&    }
\&
\&    my $add_sub = add_function_generator();
\&    my $sum = $add_sub\->(4,5);                # $sum is 9 now.
.Ve
.PP
The anonymous subroutine returned by \fIadd_function_generator()\fR isn't
technically a closure because it refers to no lexicals outside its own
scope. Using a closure gives you a \fIfunction template\fR with some
customization slots left out to be filled later.
.PP
Contrast this with the following \fImake_adder()\fR function, in which the
returned anonymous function contains a reference to a lexical variable
outside the scope of that function itself. Such a reference requires
that Perl return a proper closure, thus locking in for all time the
value that the lexical had when the function was created.
.PP
.Vb 4
\&    sub make_adder {
\&        my $addpiece = shift;
\&        return sub { shift() + $addpiece };
\&    }
\&
\&    my $f1 = make_adder(20);
\&    my $f2 = make_adder(555);
.Ve
.PP
Now \f(CW\*(C`$f1\->($n)\*(C'\fR is always 20 plus whatever \f(CW$n\fR you pass in, whereas
\&\f(CW\*(C`$f2\->($n)\*(C'\fR is always 555 plus whatever \f(CW$n\fR you pass in. The \f(CW$addpiece\fR
in the closure sticks around.
.PP
Closures are often used for less esoteric purposes. For example, when
you want to pass in a bit of code into a function:
.PP
.Vb 2
\&    my $line;
\&    timeout( 30, sub { $line = <STDIN> } );
.Ve
.PP
If the code to execute had been passed in as a string,
\&\f(CW\*(Aq$line = <STDIN>\*(Aq\fR, there would have been no way for the
hypothetical \fItimeout()\fR function to access the lexical variable
\&\f(CW$line\fR back in its caller's scope.
.PP
Another use for a closure is to make a variable \fIprivate\fR to a
named subroutine, e.g. a counter that gets initialized at creation
time of the sub and can only be modified from within the sub.
This is sometimes used with a \s-1BEGIN\s0 block in package files to make
sure a variable doesn't get meddled with during the lifetime of the
package:
.PP
.Vb 4
\&    BEGIN {
\&        my $id = 0;
\&        sub next_id { ++$id }
\&    }
.Ve
.PP
This is discussed in more detail in perlsub; see the entry on
\&\fIPersistent Private Variables\fR.
.SS "What is variable suicide and how can I prevent it?"
.IX Subsection "What is variable suicide and how can I prevent it?"
This problem was fixed in perl 5.004_05, so preventing it means upgrading
your version of perl. ;)
.PP
Variable suicide is when you (temporarily or permanently) lose the value
of a variable. It is caused by scoping through \fImy()\fR and \fIlocal()\fR
interacting with either closures or aliased \fIforeach()\fR iterator variables
and subroutine arguments. It used to be easy to inadvertently lose a
variable's value this way, but now it's much harder. Take this code:
.PP
.Vb 4
\&    my $f = \*(Aqfoo\*(Aq;
\&    sub T {
\&        while ($i++ < 3) { my $f = $f; $f .= "bar"; print $f, "\en" }
\&    }
\&
\&    T;
\&    print "Finally $f\en";
.Ve
.PP
If you are experiencing variable suicide, that \f(CW\*(C`my $f\*(C'\fR in the subroutine
doesn't pick up a fresh copy of the \f(CW$f\fR whose value is \f(CW\*(Aqfoo\*(Aq\fR. The
output shows that inside the subroutine the value of \f(CW$f\fR leaks through
when it shouldn't, as in this output:
.PP
.Vb 4
\&    foobar
\&    foobarbar
\&    foobarbarbar
\&    Finally foo
.Ve
.PP
The \f(CW$f\fR that has \*(L"bar\*(R" added to it three times should be a new \f(CW$f\fR
\&\f(CW\*(C`my $f\*(C'\fR should create a new lexical variable each time through the loop.
The expected output is:
.PP
.Vb 4
\&    foobar
\&    foobar
\&    foobar
\&    Finally foo
.Ve
.SS "How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
.IX Subsection "How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
You need to pass references to these objects. See \*(L"Pass by
Reference\*(R" in perlsub for this particular question, and perlref for
information on references.
.IP "Passing Variables and Functions" 4
.IX Item "Passing Variables and Functions"
Regular variables and functions are quite easy to pass: just pass in a
reference to an existing or anonymous variable or function:
.Sp
.Vb 1
\&    func( \e$some_scalar );
\&
\&    func( \e@some_array  );
\&    func( [ 1 .. 10 ]   );
\&
\&    func( \e%some_hash   );
\&    func( { this => 10, that => 20 }   );
\&
\&    func( \e&some_func   );
\&    func( sub { $_[0] ** $_[1] }   );
.Ve
.IP "Passing Filehandles" 4
.IX Item "Passing Filehandles"
As of Perl 5.6, you can represent filehandles with scalar variables
which you treat as any other scalar.
.Sp
.Vb 2
\&    open my $fh, $filename or die "Cannot open $filename! $!";
\&    func( $fh );
\&
\&    sub func {
\&        my $passed_fh = shift;
\&
\&        my $line = <$passed_fh>;
\&    }
.Ve
.Sp
Before Perl 5.6, you had to use the \f(CW*FH\fR or \f(CW\*(C`\e*FH\*(C'\fR notations.
These are \*(L"typeglobs\*(R"\-\-see \*(L"Typeglobs and Filehandles\*(R" in perldata
and especially \*(L"Pass by Reference\*(R" in perlsub for more information.
.IP "Passing Regexes" 4
.IX Item "Passing Regexes"
Here's an example of how to pass in a string and a regular expression
for it to match against. You construct the pattern with the \f(CW\*(C`qr//\*(C'\fR
operator:
.Sp
.Vb 6
\&    sub compare {
\&        my ($val1, $regex) = @_;
\&        my $retval = $val1 =~ /$regex/;
\&        return $retval;
\&    }
\&    $match = compare("old McDonald", qr/d.*D/i);
.Ve
.IP "Passing Methods" 4
.IX Item "Passing Methods"
To pass an object method into a subroutine, you can do this:
.Sp
.Vb 7
\&    call_a_lot(10, $some_obj, "methname")
\&    sub call_a_lot {
\&        my ($count, $widget, $trick) = @_;
\&        for (my $i = 0; $i < $count; $i++) {
\&            $widget\->$trick();
\&        }
\&    }
.Ve
.Sp
Or, you can use a closure to bundle up the object, its
method call, and arguments:
.Sp
.Vb 6
\&    my $whatnot = sub { $some_obj\->obfuscate(@args) };
\&    func($whatnot);
\&    sub func {
\&        my $code = shift;
\&        &$code();
\&    }
.Ve
.Sp
You could also investigate the \fIcan()\fR method in the \s-1UNIVERSAL\s0 class
(part of the standard perl distribution).
.SS "How do I create a static variable?"
.IX Subsection "How do I create a static variable?"
(contributed by brian d foy)
.PP
In Perl 5.10, declare the variable with \f(CW\*(C`state\*(C'\fR. The \f(CW\*(C`state\*(C'\fR
declaration creates the lexical variable that persists between calls
to the subroutine:
.PP
.Vb 1
\&    sub counter { state $count = 1; $count++ }
.Ve
.PP
You can fake a static variable by using a lexical variable which goes
out of scope. In this example, you define the subroutine \f(CW\*(C`counter\*(C'\fR, and
it uses the lexical variable \f(CW$count\fR. Since you wrap this in a \s-1BEGIN\s0
block, \f(CW$count\fR is defined at compile-time, but also goes out of
scope at the end of the \s-1BEGIN\s0 block. The \s-1BEGIN\s0 block also ensures that
the subroutine and the value it uses is defined at compile-time so the
subroutine is ready to use just like any other subroutine, and you can
put this code in the same place as other subroutines in the program
text (i.e. at the end of the code, typically). The subroutine
\&\f(CW\*(C`counter\*(C'\fR still has a reference to the data, and is the only way you
can access the value (and each time you do, you increment the value).
The data in chunk of memory defined by \f(CW$count\fR is private to
\&\f(CW\*(C`counter\*(C'\fR.
.PP
.Vb 4
\&    BEGIN {
\&        my $count = 1;
\&        sub counter { $count++ }
\&    }
\&
\&    my $start = counter();
\&
\&    .... # code that calls counter();
\&
\&    my $end = counter();
.Ve
.PP
In the previous example, you created a function-private variable
because only one function remembered its reference. You could define
multiple functions while the variable is in scope, and each function
can share the \*(L"private\*(R" variable. It's not really \*(L"static\*(R" because you
can access it outside the function while the lexical variable is in
scope, and even create references to it. In this example,
\&\f(CW\*(C`increment_count\*(C'\fR and \f(CW\*(C`return_count\*(C'\fR share the variable. One
function adds to the value and the other simply returns the value.
They can both access \f(CW$count\fR, and since it has gone out of scope,
there is no other way to access it.
.PP
.Vb 5
\&    BEGIN {
\&        my $count = 1;
\&        sub increment_count { $count++ }
\&        sub return_count    { $count }
\&    }
.Ve
.PP
To declare a file-private variable, you still use a lexical variable.
A file is also a scope, so a lexical variable defined in the file
cannot be seen from any other file.
.PP
See \*(L"Persistent Private Variables\*(R" in perlsub for more information.
The discussion of closures in perlref may help you even though we
did not use anonymous subroutines in this answer. See
\&\*(L"Persistent Private Variables\*(R" in perlsub for details.
.SS "What's the difference between dynamic and lexical (static) scoping? Between \fIlocal()\fP and \fImy()\fP?"
.IX Subsection "What's the difference between dynamic and lexical (static) scoping? Between local() and my()?"
\&\f(CW\*(C`local($x)\*(C'\fR saves away the old value of the global variable \f(CW$x\fR
and assigns a new value for the duration of the subroutine \fIwhich is
visible in other functions called from that subroutine\fR. This is done
at run-time, so is called dynamic scoping. \fIlocal()\fR always affects global
variables, also called package variables or dynamic variables.
.PP
\&\f(CW\*(C`my($x)\*(C'\fR creates a new variable that is only visible in the current
subroutine. This is done at compile-time, so it is called lexical or
static scoping. \fImy()\fR always affects private variables, also called
lexical variables or (improperly) static(ly scoped) variables.
.PP
For instance:
.PP
.Vb 3
\&    sub visible {
\&        print "var has value $var\en";
\&    }
\&
\&    sub dynamic {
\&        local $var = \*(Aqlocal\*(Aq;    # new temporary value for the still\-global
\&        visible();              #   variable called $var
\&    }
\&
\&    sub lexical {
\&        my $var = \*(Aqprivate\*(Aq;    # new private variable, $var
\&        visible();              # (invisible outside of sub scope)
\&    }
\&
\&    $var = \*(Aqglobal\*(Aq;
\&
\&    visible();              # prints global
\&    dynamic();              # prints local
\&    lexical();              # prints global
.Ve
.PP
Notice how at no point does the value \*(L"private\*(R" get printed. That's
because \f(CW$var\fR only has that value within the block of the \fIlexical()\fR
function, and it is hidden from the called subroutine.
.PP
In summary, \fIlocal()\fR doesn't make what you think of as private, local
variables. It gives a global variable a temporary value. \fImy()\fR is
what you're looking for if you want private variables.
.PP
See \*(L"Private Variables via \fImy()\fR\*(R" in perlsub and
\&\*(L"Temporary Values via \fIlocal()\fR\*(R" in perlsub for excruciating details.
.SS "How can I access a dynamic variable while a similarly named lexical is in scope?"
.IX Subsection "How can I access a dynamic variable while a similarly named lexical is in scope?"
If you know your package, you can just mention it explicitly, as in
\&\f(CW$Some_Pack::var\fR. Note that the notation \f(CW$::var\fR is \fBnot\fR the dynamic \f(CW$var\fR
in the current package, but rather the one in the \*(L"main\*(R" package, as
though you had written \f(CW$main::var\fR.
.PP
.Vb 3
\&    use vars \*(Aq$var\*(Aq;
\&    local $var = "global";
\&    my    $var = "lexical";
\&
\&    print "lexical is $var\en";
\&    print "global  is $main::var\en";
.Ve
.PP
Alternatively you can use the compiler directive \fIour()\fR to bring a
dynamic variable into the current lexical scope.
.PP
.Vb 2
\&    require 5.006; # our() did not exist before 5.6
\&    use vars \*(Aq$var\*(Aq;
\&
\&    local $var = "global";
\&    my $var    = "lexical";
\&
\&    print "lexical is $var\en";
\&
\&    {
\&        our $var;
\&        print "global  is $var\en";
\&    }
.Ve
.SS "What's the difference between deep and shallow binding?"
.IX Subsection "What's the difference between deep and shallow binding?"
In deep binding, lexical variables mentioned in anonymous subroutines
are the same ones that were in scope when the subroutine was created.
In shallow binding, they are whichever variables with the same names
happen to be in scope when the subroutine is called. Perl always uses
deep binding of lexical variables (i.e., those created with \fImy()\fR).
However, dynamic variables (aka global, local, or package variables)
are effectively shallowly bound. Consider this just one more reason
not to use them. See the answer to \*(L"What's a closure?\*(R".
.ie n .SS "Why doesn't ""my($foo) = <$fh>;"" work right?"
.el .SS "Why doesn't ``my($foo) = <$fh>;'' work right?"
.IX Subsection "Why doesn't my($foo) = <$fh>; work right?"
\&\f(CW\*(C`my()\*(C'\fR and \f(CW\*(C`local()\*(C'\fR give list context to the right hand side
of \f(CW\*(C`=\*(C'\fR. The <$fh> read operation, like so many of Perl's
functions and operators, can tell which context it was called in and
behaves appropriately. In general, the \fIscalar()\fR function can help.
This function does nothing to the data itself (contrary to popular myth)
but rather tells its argument to behave in whatever its scalar fashion is.
If that function doesn't have a defined scalar behavior, this of course
doesn't help you (such as with \fIsort()\fR).
.PP
To enforce scalar context in this particular case, however, you need
merely omit the parentheses:
.PP
.Vb 3
\&    local($foo) = <$fh>;        # WRONG
\&    local($foo) = scalar(<$fh>);   # ok
\&    local $foo  = <$fh>;        # right
.Ve
.PP
You should probably be using lexical variables anyway, although the
issue is the same here:
.PP
.Vb 2
\&    my($foo) = <$fh>;    # WRONG
\&    my $foo  = <$fh>;    # right
.Ve
.SS "How do I redefine a builtin function, operator, or method?"
.IX Subsection "How do I redefine a builtin function, operator, or method?"
Why do you want to do that? :\-)
.PP
If you want to override a predefined function, such as \fIopen()\fR,
then you'll have to import the new definition from a different
module. See \*(L"Overriding Built-in Functions\*(R" in perlsub.
.PP
If you want to overload a Perl operator, such as \f(CW\*(C`+\*(C'\fR or \f(CW\*(C`**\*(C'\fR,
then you'll want to use the \f(CW\*(C`use overload\*(C'\fR pragma, documented
in overload.
.PP
If you're talking about obscuring method calls in parent classes,
see \*(L"Overridden Methods\*(R" in perltoot.
.SS "What's the difference between calling a function as &foo and \fIfoo()\fP?"
.IX Subsection "What's the difference between calling a function as &foo and foo()?"
(contributed by brian d foy)
.PP
Calling a subroutine as \f(CW&foo\fR with no trailing parentheses ignores
the prototype of \f(CW\*(C`foo\*(C'\fR and passes it the current value of the argument
list, \f(CW@_\fR. Here's an example; the \f(CW\*(C`bar\*(C'\fR subroutine calls \f(CW&foo\fR,
which prints its arguments list:
.PP
.Vb 1
\&    sub bar { &foo }
\&
\&    sub foo { print "Args in foo are: @_\en" }
\&
\&    bar( qw( a b c ) );
.Ve
.PP
When you call \f(CW\*(C`bar\*(C'\fR with arguments, you see that \f(CW\*(C`foo\*(C'\fR got the same \f(CW@_\fR:
.PP
.Vb 1
\&    Args in foo are: a b c
.Ve
.PP
Calling the subroutine with trailing parentheses, with or without arguments,
does not use the current \f(CW@_\fR and respects the subroutine prototype. Changing
the example to put parentheses after the call to \f(CW\*(C`foo\*(C'\fR changes the program:
.PP
.Vb 1
\&    sub bar { &foo() }
\&
\&    sub foo { print "Args in foo are: @_\en" }
\&
\&    bar( qw( a b c ) );
.Ve
.PP
Now the output shows that \f(CW\*(C`foo\*(C'\fR doesn't get the \f(CW@_\fR from its caller.
.PP
.Vb 1
\&    Args in foo are:
.Ve
.PP
The main use of the \f(CW@_\fR pass-through feature is to write subroutines
whose main job it is to call other subroutines for you. For further
details, see perlsub.
.SS "How do I create a switch or case statement?"
.IX Subsection "How do I create a switch or case statement?"
In Perl 5.10, use the \f(CW\*(C`given\-when\*(C'\fR construct described in perlsyn:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given ( $string ) {
\&        when( \*(AqFred\*(Aq )        { say "I found Fred!" }
\&        when( \*(AqBarney\*(Aq )      { say "I found Barney!" }
\&        when( /Bamm\-?Bamm/ )  { say "I found Bamm\-Bamm!" }
\&        default               { say "I don\*(Aqt recognize the name!" }
\&    };
.Ve
.PP
If one wants to use pure Perl and to be compatible with Perl versions
prior to 5.10, the general answer is to use \f(CW\*(C`if\-elsif\-else\*(C'\fR:
.PP
.Vb 6
\&    for ($variable_to_test) {
\&        if    (/pat1/)  { }     # do something
\&        elsif (/pat2/)  { }     # do something else
\&        elsif (/pat3/)  { }     # do something else
\&        else            { }     # default
\&    }
.Ve
.PP
Here's a simple example of a switch based on pattern matching,
lined up in a way to make it look more like a switch statement.
We'll do a multiway conditional based on the type of reference stored
in \f(CW$whatchamacallit:\fR
.PP
.Vb 1
\&    SWITCH: for (ref $whatchamacallit) {
\&
\&        /^$/           && die "not a reference";
\&
\&        /SCALAR/       && do {
\&                        print_scalar($$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /ARRAY/        && do {
\&                        print_array(@$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /HASH/        && do {
\&                        print_hash(%$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /CODE/        && do {
\&                        warn "can\*(Aqt print function ref";
\&                        last SWITCH;
\&                      };
\&
\&        # DEFAULT
\&
\&        warn "User defined type skipped";
\&
\&    }
.Ve
.PP
See perlsyn for other examples in this style.
.PP
Sometimes you should change the positions of the constant and the variable.
For example, let's say you wanted to test which of many answers you were
given, but in a case-insensitive way that also allows abbreviations.
You can use the following technique if the strings all start with
different characters or if you want to arrange the matches so that
one takes precedence over another, as \f(CW"SEND"\fR has precedence over
\&\f(CW"STOP"\fR here:
.PP
.Vb 6
\&    chomp($answer = <>);
\&    if    ("SEND"  =~ /^\eQ$answer/i) { print "Action is send\en"  }
\&    elsif ("STOP"  =~ /^\eQ$answer/i) { print "Action is stop\en"  }
\&    elsif ("ABORT" =~ /^\eQ$answer/i) { print "Action is abort\en" }
\&    elsif ("LIST"  =~ /^\eQ$answer/i) { print "Action is list\en"  }
\&    elsif ("EDIT"  =~ /^\eQ$answer/i) { print "Action is edit\en"  }
.Ve
.PP
A totally different approach is to create a hash of function references.
.PP
.Vb 6
\&    my %commands = (
\&        "happy" => \e&joy,
\&        "sad",  => \e&sullen,
\&        "done"  => sub { die "See ya!" },
\&        "mad"   => \e&angry,
\&    );
\&
\&    print "How are you? ";
\&    chomp($string = <STDIN>);
\&    if ($commands{$string}) {
\&        $commands{$string}\->();
\&    } else {
\&        print "No such command: $string\en";
\&    }
.Ve
.PP
Starting from Perl 5.8, a source filter module, \f(CW\*(C`Switch\*(C'\fR, can also be
used to get switch and case. Its use is now discouraged, because it's
not fully compatible with the native switch of Perl 5.10, and because,
as it's implemented as a source filter, it doesn't always work as intended
when complex syntax is involved.
.SS "How can I catch accesses to undefined variables, functions, or methods?"
.IX Subsection "How can I catch accesses to undefined variables, functions, or methods?"
The \s-1AUTOLOAD\s0 method, discussed in \*(L"Autoloading\*(R" in perlsub and
\&\*(L"\s-1AUTOLOAD:\s0 Proxy Methods\*(R" in perltoot, lets you capture calls to
undefined functions and methods.
.PP
When it comes to undefined variables that would trigger a warning
under \f(CW\*(C`use warnings\*(C'\fR, you can promote the warning to an error.
.PP
.Vb 1
\&    use warnings FATAL => qw(uninitialized);
.Ve
.SS "Why can't a method included in this same file be found?"
.IX Subsection "Why can't a method included in this same file be found?"
Some possible reasons: your inheritance is getting confused, you've
misspelled the method name, or the object is of the wrong type. Check
out perltoot for details about any of the above cases. You may
also use \f(CW\*(C`print ref($object)\*(C'\fR to find out the class \f(CW$object\fR was
blessed into.
.PP
Another possible reason for problems is that you've used the
indirect object syntax (eg, \f(CW\*(C`find Guru "Samy"\*(C'\fR) on a class name
before Perl has seen that such a package exists. It's wisest to make
sure your packages are all defined before you start using them, which
will be taken care of if you use the \f(CW\*(C`use\*(C'\fR statement instead of
\&\f(CW\*(C`require\*(C'\fR. If not, make sure to use arrow notation (eg.,
\&\f(CW\*(C`Guru\->find("Samy")\*(C'\fR) instead. Object notation is explained in
perlobj.
.PP
Make sure to read about creating modules in perlmod and
the perils of indirect objects in \*(L"Method Invocation\*(R" in perlobj.
.SS "How can I find out my current or calling package?"
.IX Subsection "How can I find out my current or calling package?"
(contributed by brian d foy)
.PP
To find the package you are currently in, use the special literal
\&\f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR, as documented in perldata. You can only use the
special literals as separate tokens, so you can't interpolate them
into strings like you can with variables:
.PP
.Vb 2
\&    my $current_package = _\|_PACKAGE_\|_;
\&    print "I am in package $current_package\en";
.Ve
.PP
If you want to find the package calling your code, perhaps to give better
diagnostics as Carp does, use the \f(CW\*(C`caller\*(C'\fR built-in:
.PP
.Vb 3
\&    sub foo {
\&        my @args = ...;
\&        my( $package, $filename, $line ) = caller;
\&
\&        print "I was called from package $package\en";
\&        );
.Ve
.PP
By default, your program starts in package \f(CW\*(C`main\*(C'\fR, so you will
always be in some package.
.PP
This is different from finding out the package an object is blessed
into, which might not be the current package. For that, use \f(CW\*(C`blessed\*(C'\fR
from Scalar::Util, part of the Standard Library since Perl 5.8:
.PP
.Vb 2
\&    use Scalar::Util qw(blessed);
\&    my $object_package = blessed( $object );
.Ve
.PP
Most of the time, you shouldn't care what package an object is blessed
into, however, as long as it claims to inherit from that class:
.PP
.Vb 1
\&    my $is_right_class = eval { $object\->isa( $package ) }; # true or false
.Ve
.PP
And, with Perl 5.10 and later, you don't have to check for an
inheritance to see if the object can handle a role. For that, you can
use \f(CW\*(C`DOES\*(C'\fR, which comes from \f(CW\*(C`UNIVERSAL\*(C'\fR:
.PP
.Vb 1
\&    my $class_does_it = eval { $object\->DOES( $role ) }; # true or false
.Ve
.PP
You can safely replace \f(CW\*(C`isa\*(C'\fR with \f(CW\*(C`DOES\*(C'\fR (although the converse is not true).
.SS "How can I comment out a large block of Perl code?"
.IX Subsection "How can I comment out a large block of Perl code?"
(contributed by brian d foy)
.PP
The quick-and-dirty way to comment out more than one line of Perl is
to surround those lines with Pod directives. You have to put these
directives at the beginning of the line and somewhere where Perl
expects a new statement (so not in the middle of statements like the \f(CW\*(C`#\*(C'\fR
comments). You end the comment with \f(CW\*(C`=cut\*(C'\fR, ending the Pod section:
.PP
.Vb 1
\&    =pod
\&
\&    my $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =cut
.Ve
.PP
The quick-and-dirty method only works well when you don't plan to
leave the commented code in the source. If a Pod parser comes along,
your multiline comment is going to show up in the Pod translation.
A better way hides it from Pod parsers as well.
.PP
The \f(CW\*(C`=begin\*(C'\fR directive can mark a section for a particular purpose.
If the Pod parser doesn't want to handle it, it just ignores it. Label
the comments with \f(CW\*(C`comment\*(C'\fR. End the comment using \f(CW\*(C`=end\*(C'\fR with the
same label. You still need the \f(CW\*(C`=cut\*(C'\fR to go back to Perl code from
the Pod comment:
.PP
.Vb 1
\&    =begin comment
\&
\&    my $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =end comment
\&
\&    =cut
.Ve
.PP
For more information on Pod, check out perlpod and perlpodspec.
.SS "How do I clear a package?"
.IX Subsection "How do I clear a package?"
Use this code, provided by Mark-Jason Dominus:
.PP
.Vb 10
\&    sub scrub_package {
\&        no strict \*(Aqrefs\*(Aq;
\&        my $pack = shift;
\&        die "Shouldn\*(Aqt delete main package"
\&            if $pack eq "" || $pack eq "main";
\&        my $stash = *{$pack . \*(Aq::\*(Aq}{HASH};
\&        my $name;
\&        foreach $name (keys %$stash) {
\&            my $fullname = $pack . \*(Aq::\*(Aq . $name;
\&            # Get rid of everything with that name.
\&            undef $$fullname;
\&            undef @$fullname;
\&            undef %$fullname;
\&            undef &$fullname;
\&            undef *$fullname;
\&        }
\&    }
.Ve
.PP
Or, if you're using a recent release of Perl, you can
just use the \fISymbol::delete_package()\fR function instead.
.SS "How can I use a variable as a variable name?"
.IX Subsection "How can I use a variable as a variable name?"
Beginners often think they want to have a variable contain the name
of a variable.
.PP
.Vb 3
\&    $fred    = 23;
\&    $varname = "fred";
\&    ++$$varname;         # $fred now 24
.Ve
.PP
This works \fIsometimes\fR, but it is a very bad idea for two reasons.
.PP
The first reason is that this technique \fIonly works on global
variables\fR. That means that if \f(CW$fred\fR is a lexical variable created
with \fImy()\fR in the above example, the code wouldn't work at all: you'd
accidentally access the global and skip right over the private lexical
altogether. Global variables are bad because they can easily collide
accidentally and in general make for non-scalable and confusing code.
.PP
Symbolic references are forbidden under the \f(CW\*(C`use strict\*(C'\fR pragma.
They are not true references and consequently are not reference-counted
or garbage-collected.
.PP
The other reason why using a variable to hold the name of another
variable is a bad idea is that the question often stems from a lack of
understanding of Perl data structures, particularly hashes. By using
symbolic references, you are just using the package's symbol-table hash
(like \f(CW%main::\fR) instead of a user-defined hash. The solution is to
use your own hash or a real reference instead.
.PP
.Vb 3
\&    $USER_VARS{"fred"} = 23;
\&    my $varname = "fred";
\&    $USER_VARS{$varname}++;  # not $$varname++
.Ve
.PP
There we're using the \f(CW%USER_VARS\fR hash instead of symbolic references.
Sometimes this comes up in reading strings from the user with variable
references and wanting to expand them to the values of your perl
program's variables. This is also a bad idea because it conflates the
program-addressable namespace and the user-addressable one. Instead of
reading a string and expanding it to the actual contents of your program's
own variables:
.PP
.Vb 2
\&    $str = \*(Aqthis has a $fred and $barney in it\*(Aq;
\&    $str =~ s/(\e$\ew+)/$1/eeg;          # need double eval
.Ve
.PP
it would be better to keep a hash around like \f(CW%USER_VARS\fR and have
variable references actually refer to entries in that hash:
.PP
.Vb 1
\&    $str =~ s/\e$(\ew+)/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
That's faster, cleaner, and safer than the previous approach. Of course,
you don't need to use a dollar sign. You could use your own scheme to
make it less confusing, like bracketed percent symbols, etc.
.PP
.Vb 2
\&    $str = \*(Aqthis has a %fred% and %barney% in it\*(Aq;
\&    $str =~ s/%(\ew+)%/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
Another reason that folks sometimes think they want a variable to
contain the name of a variable is that they don't know how to build
proper data structures using hashes. For example, let's say they
wanted two hashes in their program: \f(CW%fred\fR and \f(CW%barney\fR, and that they
wanted to use another scalar variable to refer to those by name.
.PP
.Vb 2
\&    $name = "fred";
\&    $$name{WIFE} = "wilma";     # set %fred
\&
\&    $name = "barney";
\&    $$name{WIFE} = "betty";    # set %barney
.Ve
.PP
This is still a symbolic reference, and is still saddled with the
problems enumerated above. It would be far better to write:
.PP
.Vb 2
\&    $folks{"fred"}{WIFE}   = "wilma";
\&    $folks{"barney"}{WIFE} = "betty";
.Ve
.PP
And just use a multilevel hash to start with.
.PP
The only times that you absolutely \fImust\fR use symbolic references are
when you really must refer to the symbol table. This may be because it's
something that one can't take a real reference to, such as a format name.
Doing so may also be important for method calls, since these always go
through the symbol table for resolution.
.PP
In those cases, you would turn off \f(CW\*(C`strict \*(Aqrefs\*(Aq\*(C'\fR temporarily so you
can play around with the symbol table. For example:
.PP
.Vb 5
\&    @colors = qw(red blue green yellow orange purple violet);
\&    for my $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;  # renege for the block
\&        *$name = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
All those functions (\fIred()\fR, \fIblue()\fR, \fIgreen()\fR, etc.) appear to be separate,
but the real code in the closure actually was compiled only once.
.PP
So, sometimes you might want to use symbolic references to manipulate
the symbol table directly. This doesn't matter for formats, handles, and
subroutines, because they are always global\*(--you can't use \fImy()\fR on them.
For scalars, arrays, and hashes, though\*(--and usually for subroutines\*(--
you probably only want to use hard references.
.ie n .SS "What does ""bad interpreter"" mean?"
.el .SS "What does ``bad interpreter'' mean?"
.IX Subsection "What does bad interpreter mean?"
(contributed by brian d foy)
.PP
The \*(L"bad interpreter\*(R" message comes from the shell, not perl. The
actual message may vary depending on your platform, shell, and locale
settings.
.PP
If you see \*(L"bad interpreter \- no such file or directory\*(R", the first
line in your perl script (the \*(L"shebang\*(R" line) does not contain the
right path to perl (or any other program capable of running scripts).
Sometimes this happens when you move the script from one machine to
another and each machine has a different path to perl\-\-/usr/bin/perl
versus /usr/local/bin/perl for instance. It may also indicate
that the source machine has \s-1CRLF\s0 line terminators and the
destination machine has \s-1LF\s0 only: the shell tries to find
/usr/bin/perl<\s-1CR\s0>, but can't.
.PP
If you see \*(L"bad interpreter: Permission denied\*(R", you need to make your
script executable.
.PP
In either case, you should still be able to run the scripts with perl
explicitly:
.PP
.Vb 1
\&    % perl script.pl
.Ve
.PP
If you get a message like \*(L"perl: command not found\*(R", perl is not in
your \s-1PATH,\s0 which might also mean that the location of perl is not
where you expect it so you need to adjust your shebang line.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq8.1                                   0100644 0001750 0001750 00000173606 12566207437 022503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ8 1"
.TH PERLFAQ8 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq8 \- System Interaction
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the Perl \s-1FAQ\s0 covers questions involving operating
system interaction. Topics include interprocess communication (\s-1IPC\s0),
control over the user-interface (keyboard, screen and pointing
devices), and most anything else not related to data manipulation.
.PP
Read the FAQs and documentation specific to the port of perl to your
operating system (eg, perlvms, perlplan9, ...). These should
contain more detailed information on the vagaries of your perl.
.SS "How do I find out which operating system I'm running under?"
.IX Subsection "How do I find out which operating system I'm running under?"
The \f(CW$^O\fR variable (\f(CW$OSNAME\fR if you use \f(CW\*(C`English\*(C'\fR) contains an
indication of the name of the operating system (not its release
number) that your perl binary was built for.
.SS "How come \fIexec()\fP doesn't return?"
.IX Xref "exec system fork open pipe"
.IX Subsection "How come exec() doesn't return?"
(contributed by brian d foy)
.PP
The \f(CW\*(C`exec\*(C'\fR function's job is to turn your process into another
command and never to return. If that's not what you want to do, don't
use \f(CW\*(C`exec\*(C'\fR. :)
.PP
If you want to run an external command and still keep your Perl process
going, look at a piped \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, or \f(CW\*(C`system\*(C'\fR.
.SS "How do I do fancy stuff with the keyboard/screen/mouse?"
.IX Subsection "How do I do fancy stuff with the keyboard/screen/mouse?"
How you access/control keyboards, screens, and pointing devices
(\*(L"mice\*(R") is system-dependent. Try the following modules:
.IP "Keyboard" 4
.IX Item "Keyboard"
.Vb 5
\&    Term::Cap               Standard perl distribution
\&    Term::ReadKey           CPAN
\&    Term::ReadLine::Gnu     CPAN
\&    Term::ReadLine::Perl    CPAN
\&    Term::Screen            CPAN
.Ve
.IP "Screen" 4
.IX Item "Screen"
.Vb 3
\&    Term::Cap               Standard perl distribution
\&    Curses                  CPAN
\&    Term::ANSIColor         CPAN
.Ve
.IP "Mouse" 4
.IX Item "Mouse"
.Vb 4
\&    Tk                      CPAN
\&    Wx                      CPAN
\&    Gtk2                    CPAN
\&    Qt4                     kdebindings4 package
.Ve
.PP
Some of these specific cases are shown as examples in other answers
in this section of the perlfaq.
.SS "How do I print something out in color?"
.IX Subsection "How do I print something out in color?"
In general, you don't, because you don't know whether
the recipient has a color-aware display device. If you
know that they have an \s-1ANSI\s0 terminal that understands
color, you can use the Term::ANSIColor module from \s-1CPAN:\s0
.PP
.Vb 3
\&    use Term::ANSIColor;
\&    print color("red"), "Stop!\en", color("reset");
\&    print color("green"), "Go!\en", color("reset");
.Ve
.PP
Or like this:
.PP
.Vb 3
\&    use Term::ANSIColor qw(:constants);
\&    print RED, "Stop!\en", RESET;
\&    print GREEN, "Go!\en", RESET;
.Ve
.SS "How do I read just one key without waiting for a return key?"
.IX Subsection "How do I read just one key without waiting for a return key?"
Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the \fBstty\fR command as shown in
\&\*(L"getc\*(R" in perlfunc, but as you see, that's already getting you into
portability snags.
.PP
.Vb 6
\&    open(TTY, "+</dev/tty") or die "no tty: $!";
\&    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
\&    $key = getc(TTY);        # perhaps this works
\&    # OR ELSE
\&    sysread(TTY, $key, 1);    # probably this does
\&    system "stty \-cbreak </dev/tty >/dev/tty 2>&1";
.Ve
.PP
The Term::ReadKey module from \s-1CPAN\s0 offers an easy-to-use interface that
should be more efficient than shelling out to \fBstty\fR for each key.
It even includes limited support for Windows.
.PP
.Vb 4
\&    use Term::ReadKey;
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&    $key = ReadKey(0);
\&    ReadMode(\*(Aqnormal\*(Aq);
.Ve
.PP
However, using the code requires that you have a working C compiler
and can use it to build and install a \s-1CPAN\s0 module. Here's a solution
using the standard \s-1POSIX\s0 module, which is already on your system
(assuming your system supports \s-1POSIX\s0).
.PP
.Vb 2
\&    use HotKey;
\&    $key = readkey();
.Ve
.PP
And here's the \f(CW\*(C`HotKey\*(C'\fR module, which hides the somewhat mystifying calls
to manipulate the \s-1POSIX\s0 termios structures.
.PP
.Vb 2
\&    # HotKey.pm
\&    package HotKey;
\&
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqExporter\*(Aq;
\&    our @EXPORT = qw(cbreak cooked readkey);
\&
\&    use POSIX qw(:termios_h);
\&    my ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&    $fd_stdin = fileno(STDIN);
\&    $term     = POSIX::Termios\->new();
\&    $term\->getattr($fd_stdin);
\&    $oterm     = $term\->getlflag();
\&
\&    $echo     = ECHO | ECHOK | ICANON;
\&    $noecho   = $oterm & ~$echo;
\&
\&    sub cbreak {
\&        $term\->setlflag($noecho);  # ok, so i don\*(Aqt want echo either
\&        $term\->setcc(VTIME, 1);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub cooked {
\&        $term\->setlflag($oterm);
\&        $term\->setcc(VTIME, 0);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub readkey {
\&        my $key = \*(Aq\*(Aq;
\&        cbreak();
\&        sysread(STDIN, $key, 1);
\&        cooked();
\&        return $key;
\&    }
\&
\&    END { cooked() }
\&
\&    1;
.Ve
.SS "How do I check whether input is ready on the keyboard?"
.IX Subsection "How do I check whether input is ready on the keyboard?"
The easiest way to do this is to read a key in nonblocking mode with the
Term::ReadKey module from \s-1CPAN,\s0 passing it an argument of \-1 to indicate
not to block:
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&
\&    if (defined (my $char = ReadKey(\-1)) ) {
\&        # input was waiting and it was $char
\&    } else {
\&        # no input was waiting
\&    }
\&
\&    ReadMode(\*(Aqnormal\*(Aq);                  # restore normal tty settings
.Ve
.SS "How do I clear the screen?"
.IX Subsection "How do I clear the screen?"
(contributed by brian d foy)
.PP
To clear the screen, you just have to print the special sequence
that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.
.PP
You can use the Term::ANSIScreen module to get the special
sequence. Import the \f(CW\*(C`cls\*(C'\fR function (or the \f(CW\*(C`:screen\*(C'\fR tag):
.PP
.Vb 2
\&    use Term::ANSIScreen qw(cls);
\&    my $clear_screen = cls();
\&
\&    print $clear_screen;
.Ve
.PP
The Term::Cap module can also get the special sequence if you want
to deal with the low-level details of terminal control. The \f(CW\*(C`Tputs\*(C'\fR
method returns the string for the given capability:
.PP
.Vb 1
\&    use Term::Cap;
\&
\&    my $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 } );
\&    my $clear_string = $terminal\->Tputs(\*(Aqcl\*(Aq);
\&
\&    print $clear_screen;
.Ve
.PP
On Windows, you can use the Win32::Console module. After creating
an object for the output filehandle you want to affect, call the
\&\f(CW\*(C`Cls\*(C'\fR method:
.PP
.Vb 1
\&    Win32::Console;
\&
\&    my $OUT = Win32::Console\->new(STD_OUTPUT_HANDLE);
\&    my $clear_string = $OUT\->Cls;
\&
\&    print $clear_screen;
.Ve
.PP
If you have a command-line program that does the job, you can call
it in backticks to capture whatever it outputs so you can use it
later:
.PP
.Vb 1
\&    my $clear_string = \`clear\`;
\&
\&    print $clear_string;
.Ve
.SS "How do I get the screen size?"
.IX Subsection "How do I get the screen size?"
If you have Term::ReadKey module installed from \s-1CPAN,\s0
you can use it to fetch the width and height in characters
and in pixels:
.PP
.Vb 2
\&    use Term::ReadKey;
\&    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
.Ve
.PP
This is more portable than the raw \f(CW\*(C`ioctl\*(C'\fR, but not as
illustrative:
.PP
.Vb 10
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&    die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
\&    open(my $tty_fh, "+</dev/tty")                     or die "No tty: $!";
\&    unless (ioctl($tty_fh, &TIOCGWINSZ, $winsize=\*(Aq\*(Aq)) {
\&        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\en", &TIOCGWINSZ;
\&    }
\&    my ($row, $col, $xpixel, $ypixel) = unpack(\*(AqS4\*(Aq, $winsize);
\&    print "(row,col) = ($row,$col)";
\&    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
\&    print "\en";
.Ve
.SS "How do I ask the user for a password?"
.IX Subsection "How do I ask the user for a password?"
(This question has nothing to do with the web. See a different
\&\s-1FAQ\s0 for that.)
.PP
There's an example of this in \*(L"crypt\*(R" in perlfunc). First, you put the
terminal into \*(L"no echo\*(R" mode, then just read the password normally.
You may do this with an old-style \f(CW\*(C`ioctl()\*(C'\fR function, \s-1POSIX\s0 terminal
control (see \s-1POSIX\s0 or its documentation the Camel Book), or a call
to the \fBstty\fR program, with varying degrees of portability.
.PP
You can also do this for most systems using the Term::ReadKey module
from \s-1CPAN,\s0 which is easier to use and in theory more portable.
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqnoecho\*(Aq);
\&    my $password = ReadLine(0);
.Ve
.SS "How do I read and write the serial port?"
.IX Subsection "How do I read and write the serial port?"
This depends on which operating system your program is running on. In
the case of Unix, the serial ports will be accessible through files in
\&\f(CW\*(C`/dev\*(C'\fR; on other systems, device names will doubtless differ.
Several problem areas common to all device interaction are the
following:
.IP "lockfiles" 4
.IX Item "lockfiles"
Your system may use lockfiles to control multiple access. Make sure
you follow the correct protocol. Unpredictable behavior can result
from multiple processes reading from one device.
.IP "open mode" 4
.IX Item "open mode"
If you expect to use both read and write operations on the device,
you'll have to open it for update (see \*(L"open\*(R" in perlfunc for
details). You may wish to open it without running the risk of
blocking by using \f(CW\*(C`sysopen()\*(C'\fR and \f(CW\*(C`O_RDWR|O_NDELAY|O_NOCTTY\*(C'\fR from the
Fcntl module (part of the standard perl distribution). See
\&\*(L"sysopen\*(R" in perlfunc for more on this approach.
.IP "end of line" 4
.IX Item "end of line"
Some devices will be expecting a \*(L"\er\*(R" at the end of each line rather
than a \*(L"\en\*(R". In some ports of perl, \*(L"\er\*(R" and \*(L"\en\*(R" are different from
their usual (Unix) \s-1ASCII\s0 values of \*(L"\e015\*(R" and \*(L"\e012\*(R". You may have to
give the numeric values you want directly, using octal (\*(L"\e015\*(R"), hex
(\*(L"0x0D\*(R"), or as a control-character specification (\*(L"\ecM\*(R").
.Sp
.Vb 2
\&    print DEV "atv1\e012";    # wrong, for some devices
\&    print DEV "atv1\e015";    # right, for some devices
.Ve
.Sp
Even though with normal text files a \*(L"\en\*(R" will do the trick, there is
still no unified scheme for terminating a line that is portable
between Unix, DOS/Win, and Macintosh, except to terminate \fI\s-1ALL\s0\fR line
ends with \*(L"\e015\e012\*(R", and strip what you don't need from the output.
This applies especially to socket I/O and autoflushing, discussed
next.
.IP "flushing output" 4
.IX Item "flushing output"
If you expect characters to get to your device when you \f(CW\*(C`print()\*(C'\fR them,
you'll want to autoflush that filehandle. You can use \f(CW\*(C`select()\*(C'\fR
and the \f(CW$|\fR variable to control autoflushing (see \*(L"$|\*(R" in perlvar
and \*(L"select\*(R" in perlfunc, or perlfaq5, \*(L"How do I flush/unbuffer an
output filehandle? Why must I do this?\*(R"):
.Sp
.Vb 3
\&    my $old_handle = select($dev_fh);
\&    $| = 1;
\&    select($old_handle);
.Ve
.Sp
You'll also see code that does this without a temporary variable, as in
.Sp
.Vb 1
\&    select((select($deb_handle), $| = 1)[0]);
.Ve
.Sp
Or if you don't mind pulling in a few thousand lines
of code just because you're afraid of a little \f(CW$|\fR variable:
.Sp
.Vb 2
\&    use IO::Handle;
\&    $dev_fh\->autoflush(1);
.Ve
.Sp
As mentioned in the previous item, this still doesn't work when using
socket I/O between Unix and Macintosh. You'll need to hard code your
line terminators, in that case.
.IP "non-blocking input" 4
.IX Item "non-blocking input"
If you are doing a blocking \f(CW\*(C`read()\*(C'\fR or \f(CW\*(C`sysread()\*(C'\fR, you'll have to
arrange for an alarm handler to provide a timeout (see
\&\*(L"alarm\*(R" in perlfunc). If you have a non-blocking open, you'll likely
have a non-blocking read, which means you may have to use a 4\-arg
\&\f(CW\*(C`select()\*(C'\fR to determine whether I/O is ready on that device (see
\&\*(L"select\*(R" in perlfunc.
.PP
While trying to read from his caller-id box, the notorious Jamie
Zawinski \f(CW\*(C`<jwz@netscape.com>\*(C'\fR, after much gnashing of teeth and
fighting with \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \s-1POSIX\s0's \f(CW\*(C`tcgetattr\*(C'\fR business,
and various other functions that go bump in the night, finally came up
with this:
.PP
.Vb 10
\&    sub open_modem {
\&        use IPC::Open2;
\&        my $stty = \`/bin/stty \-g\`;
\&        open2( \e*MODEM_IN, \e*MODEM_OUT, "cu \-l$modem_device \-s2400 2>&1");
\&        # starting cu hoses /dev/tty\*(Aqs stty settings, even when it has
\&        # been opened on a pipe...
\&        system("/bin/stty $stty");
\&        $_ = <MODEM_IN>;
\&        chomp;
\&        if ( !m/^Connected/ ) {
\&            print STDERR "$0: cu printed \`$_\*(Aq instead of \`Connected\*(Aq\en";
\&        }
\&    }
.Ve
.SS "How do I decode encrypted password files?"
.IX Subsection "How do I decode encrypted password files?"
You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.
.PP
Seriously, you can't if they are Unix password files\*(--the Unix
password system employs one-way encryption. It's more like hashing
than encryption. The best you can do is check whether something else
hashes to the same string. You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.
.PP
If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
\&\fIpasswd\fR\|(1), for example).
.SS "How do I start a process in the background?"
.IX Subsection "How do I start a process in the background?"
(contributed by brian d foy)
.PP
There's not a single way to run code in the background so you don't
have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are covered in perlipc.
.PP
Several \s-1CPAN\s0 modules may be able to help, including IPC::Open2 or
IPC::Open3, IPC::Run, Parallel::Jobs,
Parallel::ForkManager, \s-1POE\s0, Proc::Background, and
Win32::Process. There are many other modules you might use, so
check those namespaces for other options too.
.PP
If you are on a Unix-like system, you might be able to get away with a
system call where you put an \f(CW\*(C`&\*(C'\fR on the end of the command:
.PP
.Vb 1
\&    system("cmd &")
.Ve
.PP
You can also try using \f(CW\*(C`fork\*(C'\fR, as described in perlfunc (although
this is the same thing that many of the modules will do for you).
.IP "\s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 are shared" 4
.IX Item "STDIN, STDOUT, and STDERR are shared"
Both the main process and the backgrounded one (the \*(L"child\*(R" process)
share the same \s-1STDIN, STDOUT\s0 and \s-1STDERR\s0 filehandles. If both try to
access them at once, strange things can happen. You may want to close
or reopen these for the child. You can get around this with
\&\f(CW\*(C`open\*(C'\fRing a pipe (see \*(L"open\*(R" in perlfunc) but on some systems this
means that the child process cannot outlive the parent.
.IP "Signals" 4
.IX Item "Signals"
You'll have to catch the \s-1SIGCHLD\s0 signal, and possibly \s-1SIGPIPE\s0 too.
\&\s-1SIGCHLD\s0 is sent when the backgrounded process finishes. \s-1SIGPIPE\s0 is
sent when you write to a filehandle whose child process has closed (an
untrapped \s-1SIGPIPE\s0 can cause your program to silently die). This is
not an issue with \f(CW\*(C`system("cmd&")\*(C'\fR.
.IP "Zombies" 4
.IX Item "Zombies"
You have to be prepared to \*(L"reap\*(R" the child process when it finishes.
.Sp
.Vb 1
\&    $SIG{CHLD} = sub { wait };
\&
\&    $SIG{CHLD} = \*(AqIGNORE\*(Aq;
.Ve
.Sp
You can also use a double fork. You immediately \f(CW\*(C`wait()\*(C'\fR for your
first child, and the init daemon will \f(CW\*(C`wait()\*(C'\fR for your grandchild once
it exits.
.Sp
.Vb 8
\&    unless ($pid = fork) {
\&        unless (fork) {
\&            exec "what you really wanna do";
\&            die "exec failed!";
\&        }
\&        exit 0;
\&    }
\&    waitpid($pid, 0);
.Ve
.Sp
See \*(L"Signals\*(R" in perlipc for other examples of code to do this.
Zombies are not an issue with \f(CW\*(C`system("prog &")\*(C'\fR.
.SS "How do I trap control characters/signals?"
.IX Subsection "How do I trap control characters/signals?"
You don't actually \*(L"trap\*(R" a control character. Instead, that character
generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in \*(L"Signals\*(R" in perlipc and the
section on \*(L"Signals\*(R" in the Camel.
.PP
You can set the values of the \f(CW%SIG\fR hash to be the functions you want
to handle the signal. After perl catches the signal, it looks in \f(CW%SIG\fR
for a key with the same name as the signal, then calls the subroutine
value for that key.
.PP
.Vb 1
\&    # as an anonymous subroutine
\&
\&    $SIG{INT} = sub { syswrite(STDERR, "ouch\en", 5 ) };
\&
\&    # or a reference to a function
\&
\&    $SIG{INT} = \e&ouch;
\&
\&    # or the name of the function as a string
\&
\&    $SIG{INT} = "ouch";
.Ve
.PP
Perl versions before 5.8 had in its C source code signal handlers which
would catch the signal and possibly run a Perl function that you had set
in \f(CW%SIG\fR. This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at \f(CW%SIG\fR
\&\fBafter\fR the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.
.SS "How do I modify the shadow password file on a Unix system?"
.IX Subsection "How do I modify the shadow password file on a Unix system?"
If perl was installed correctly and your shadow library was written
properly, the \f(CW\*(C`getpw*()\*(C'\fR functions described in perlfunc should in
theory provide (read-only) access to entries in the shadow password
file. To change the file, make a new shadow password file (the format
varies from system to system\*(--see \fIpasswd\fR\|(1) for specifics) and use
\&\f(CWpwd_mkdb(8)\fR to install it (see \fIpwd_mkdb\fR\|(8) for more details).
.SS "How do I set the time and date?"
.IX Subsection "How do I set the time and date?"
Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the \f(CWdate(1)\fR
program. (There is no way to set the time and date on a per-process
basis.)  This mechanism will work for Unix, MS-DOS, Windows, and \s-1NT\s0;
the \s-1VMS\s0 equivalent is \f(CW\*(C`set time\*(C'\fR.
.PP
However, if all you want to do is change your time zone, you can
probably get away with setting an environment variable:
.PP
.Vb 3
\&    $ENV{TZ} = "MST7MDT";           # Unixish
\&    $ENV{\*(AqSYS$TIMEZONE_DIFFERENTIAL\*(Aq}="\-5" # vms
\&    system(\*(Aqtrn\*(Aq, \*(Aqcomp.lang.perl.misc\*(Aq);
.Ve
.SS "How can I \fIsleep()\fP or \fIalarm()\fP for under a second?"
.IX Xref "Time::HiRes BSD::Itimer sleep select"
.IX Subsection "How can I sleep() or alarm() for under a second?"
If you want finer granularity than the 1 second that the \f(CW\*(C`sleep()\*(C'\fR
function provides, the easiest way is to use the \f(CW\*(C`select()\*(C'\fR function as
documented in \*(L"select\*(R" in perlfunc. Try the Time::HiRes and
the BSD::Itimer modules (available from \s-1CPAN,\s0 and starting from
Perl 5.8 Time::HiRes is part of the standard distribution).
.SS "How can I measure time under a second?"
.IX Xref "Time::HiRes BSD::Itimer sleep select"
.IX Subsection "How can I measure time under a second?"
(contributed by brian d foy)
.PP
The Time::HiRes module (part of the standard distribution as of
Perl 5.8) measures time with the \f(CW\*(C`gettimeofday()\*(C'\fR system call, which
returns the time in microseconds since the epoch. If you can't install
Time::HiRes for older Perls and you are on a Unixish system, you
may be able to call \f(CWgettimeofday(2)\fR directly. See
\&\*(L"syscall\*(R" in perlfunc.
.SS "How can I do an \fIatexit()\fP or \fIsetjmp()\fP/\fIlongjmp()\fP? (Exception handling)"
.IX Subsection "How can I do an atexit() or setjmp()/longjmp()? (Exception handling)"
You can use the \f(CW\*(C`END\*(C'\fR block to simulate \f(CW\*(C`atexit()\*(C'\fR. Each package's
\&\f(CW\*(C`END\*(C'\fR block is called when the program or thread ends. See the perlmod
manpage for more details about \f(CW\*(C`END\*(C'\fR blocks.
.PP
For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:
.PP
.Vb 3
\&    END {
\&        close(STDOUT) || die "stdout close failed: $!";
\&    }
.Ve
.PP
The \f(CW\*(C`END\*(C'\fR block isn't called when untrapped signals kill the program,
though, so if you use \f(CW\*(C`END\*(C'\fR blocks you should also use
.PP
.Vb 1
\&    use sigtrap qw(die normal\-signals);
.Ve
.PP
Perl's exception-handling mechanism is its \f(CW\*(C`eval()\*(C'\fR operator. You
can use \f(CW\*(C`eval()\*(C'\fR as \f(CW\*(C`setjmp\*(C'\fR and \f(CW\*(C`die()\*(C'\fR as \f(CW\*(C`longjmp\*(C'\fR. For
details of this, see the section on signals, especially the time-out
handler for a blocking \f(CW\*(C`flock()\*(C'\fR in \*(L"Signals\*(R" in perlipc or the
section on \*(L"Signals\*(R" in \fIProgramming Perl\fR.
.PP
If exception handling is all you're interested in, use one of the
many \s-1CPAN\s0 modules that handle exceptions, such as Try::Tiny.
.PP
If you want the \f(CW\*(C`atexit()\*(C'\fR syntax (and an \f(CW\*(C`rmexit()\*(C'\fR as well), try the
\&\f(CW\*(C`AtExit\*(C'\fR module available from \s-1CPAN.\s0
.ie n .SS "Why doesn't my sockets program work under System V (Solaris)? What does the error message ""Protocol not supported"" mean?"
.el .SS "Why doesn't my sockets program work under System V (Solaris)? What does the error message ``Protocol not supported'' mean?"
.IX Subsection "Why doesn't my sockets program work under System V (Solaris)? What does the error message Protocol not supported mean?"
Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants. Since these were constant across all
architectures, they were often hardwired into perl code. The proper
way to deal with this is to \*(L"use Socket\*(R" to get the correct values.
.PP
Note that even though SunOS and Solaris are binary compatible, these
values are different. Go figure.
.SS "How can I call my system's unique C functions from Perl?"
.IX Subsection "How can I call my system's unique C functions from Perl?"
In most cases, you write an external module to do it\*(--see the answer
to \*(L"Where can I learn about linking C with Perl? [h2xs, xsubpp]\*(R".
However, if the function is a system call, and your system supports
\&\f(CW\*(C`syscall()\*(C'\fR, you can use the \f(CW\*(C`syscall\*(C'\fR function (documented in
perlfunc).
.PP
Remember to check the modules that came with your distribution, and
\&\s-1CPAN\s0 as well\*(--someone may already have written a module to do it. On
Windows, try Win32::API. On Macs, try Mac::Carbon. If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with Inline::C.
.SS "Where do I get the include files to do \fIioctl()\fP or \fIsyscall()\fP?"
.IX Subsection "Where do I get the include files to do ioctl() or syscall()?"
Historically, these would be generated by the h2ph tool, part of the
standard perl distribution. This program converts \f(CWcpp(1)\fR directives
in C header files to files containing subroutine definitions, like
\&\f(CW\*(C`SYS_getitimer()\*(C'\fR, which you can use as arguments to your functions.
It doesn't work perfectly, but it usually gets most of the job done.
Simple files like \fIerrno.h\fR, \fIsyscall.h\fR, and \fIsocket.h\fR were fine,
but the hard ones like \fIioctl.h\fR nearly always need to be hand-edited.
Here's how to install the *.ph files:
.PP
.Vb 3
\&    1. Become the super\-user
\&    2. cd /usr/include
\&    3. h2ph *.h */*.h
.Ve
.PP
If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use h2xs (also part of the standard perl
distribution). This tool converts C header files to Perl extensions.
See perlxstut for how to get started with h2xs.
.PP
If your system doesn't support dynamic loading, you still probably
ought to use h2xs. See perlxstut and ExtUtils::MakeMaker for
more information (in brief, just use \fBmake perl\fR instead of a plain
\&\fBmake\fR to rebuild perl with a new static extension).
.SS "Why do setuid perl scripts complain about kernel problems?"
.IX Subsection "Why do setuid perl scripts complain about kernel problems?"
Some operating systems have bugs in the kernel that make setuid
scripts inherently insecure. Perl gives you a number of options
(described in perlsec) to work around such systems.
.SS "How can I open a pipe both to and from a command?"
.IX Subsection "How can I open a pipe both to and from a command?"
The IPC::Open2 module (part of the standard perl distribution) is
an easy-to-use approach that internally uses \f(CW\*(C`pipe()\*(C'\fR, \f(CW\*(C`fork()\*(C'\fR, and
\&\f(CW\*(C`exec()\*(C'\fR to do the job. Make sure you read the deadlock warnings in
its documentation, though (see IPC::Open2). See
\&\*(L"Bidirectional Communication with Another Process\*(R" in perlipc and
\&\*(L"Bidirectional Communication with Yourself\*(R" in perlipc
.PP
You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from IPC::Open2 (see IPC::Open3).
.SS "Why can't I get the output of a command with \fIsystem()\fP?"
.IX Subsection "Why can't I get the output of a command with system()?"
You're confusing the purpose of \f(CW\*(C`system()\*(C'\fR and backticks (``). \f(CW\*(C`system()\*(C'\fR
runs a command and returns exit status information (as a 16 bit value:
the low 7 bits are the signal the process died from, if any, and
the high 8 bits are the actual exit value). Backticks (``) run a
command and return what it sent to \s-1STDOUT.\s0
.PP
.Vb 2
\&    my $exit_status   = system("mail\-users");
\&    my $output_string = \`ls\`;
.Ve
.SS "How can I capture \s-1STDERR\s0 from an external command?"
.IX Subsection "How can I capture STDERR from an external command?"
There are three basic ways of running external commands:
.PP
.Vb 3
\&    system $cmd;        # using system()
\&    my $output = \`$cmd\`;        # using backticks (\`\`)
\&    open (my $pipe_fh, "$cmd |");    # using open()
.Ve
.PP
With \f(CW\*(C`system()\*(C'\fR, both \s-1STDOUT\s0 and \s-1STDERR\s0 will go the same place as the
script's \s-1STDOUT\s0 and \s-1STDERR,\s0 unless the \f(CW\*(C`system()\*(C'\fR command redirects them.
Backticks and \f(CW\*(C`open()\*(C'\fR read \fBonly\fR the \s-1STDOUT\s0 of your command.
.PP
You can also use the \f(CW\*(C`open3()\*(C'\fR function from IPC::Open3. Benjamin
Goldberg provides some sample code:
.PP
To capture a program's \s-1STDOUT,\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    my $pid = open3(gensym, \e*PH, ">&NULL", "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a program's \s-1STDERR,\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    my $pid = open3(gensym, ">&NULL", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a program's \s-1STDERR,\s0 and let its \s-1STDOUT\s0 go to our own \s-1STDERR:\s0
.PP
.Vb 5
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    my $pid = open3(gensym, ">&STDERR", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To read both a command's \s-1STDOUT\s0 and its \s-1STDERR\s0 separately, you can
redirect them to temp files, let the command run, then read the temp
files:
.PP
.Vb 10
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHOUT = IO::File\->new_tmpfile;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
\&    waitpid($pid, 0);
\&    seek $_, 0, 0 for \e*CATCHOUT, \e*CATCHERR;
\&    while( <CATCHOUT> ) {}
\&    while( <CATCHERR> ) {}
.Ve
.PP
But there's no real need for \fBboth\fR to be tempfiles... the following
should work just as well, without deadlocking:
.PP
.Vb 9
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    my $pid = open3(gensym, \e*CATCHOUT, ">&CATCHERR", "cmd");
\&    while( <CATCHOUT> ) {}
\&    waitpid($pid, 0);
\&    seek CATCHERR, 0, 0;
\&    while( <CATCHERR> ) {}
.Ve
.PP
And it'll be faster, too, since we can begin processing the program's
stdout immediately, rather than waiting for the program to finish.
.PP
With any of these, you can change file descriptors before the call:
.PP
.Vb 2
\&    open(STDOUT, ">logfile");
\&    system("ls");
.Ve
.PP
or you can use Bourne shell file-descriptor redirection:
.PP
.Vb 2
\&    $output = \`$cmd 2>some_file\`;
\&    open (PIPE, "cmd 2>some_file |");
.Ve
.PP
You can also use file-descriptor redirection to make \s-1STDERR\s0 a
duplicate of \s-1STDOUT:\s0
.PP
.Vb 2
\&    $output = \`$cmd 2>&1\`;
\&    open (PIPE, "cmd 2>&1 |");
.Ve
.PP
Note that you \fIcannot\fR simply open \s-1STDERR\s0 to be a dup of \s-1STDOUT\s0
in your Perl program and avoid calling the shell to do the redirection.
This doesn't work:
.PP
.Vb 2
\&    open(STDERR, ">&STDOUT");
\&    $alloutput = \`cmd args\`;  # stderr still escapes
.Ve
.PP
This fails because the \f(CW\*(C`open()\*(C'\fR makes \s-1STDERR\s0 go to where \s-1STDOUT\s0 was
going at the time of the \f(CW\*(C`open()\*(C'\fR. The backticks then make \s-1STDOUT\s0 go to
a string, but don't change \s-1STDERR \s0(which still goes to the old
\&\s-1STDOUT\s0).
.PP
Note that you \fImust\fR use Bourne shell (\f(CWsh(1)\fR) redirection syntax in
backticks, not \f(CWcsh(1)\fR!  Details on why Perl's \f(CW\*(C`system()\*(C'\fR and backtick
and pipe opens all use the Bourne shell are in the
\&\fIversus/csh.whynot\fR article in the \*(L"Far More Than You Ever Wanted To
Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> . To
capture a command's \s-1STDERR\s0 and \s-1STDOUT\s0 together:
.PP
.Vb 3
\&    $output = \`cmd 2>&1\`;                       # either with backticks
\&    $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a command's \s-1STDOUT\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>/dev/null\`;                # either with backticks
\&    $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a command's \s-1STDERR\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>&1 1>/dev/null\`;           # either with backticks
\&    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To exchange a command's \s-1STDOUT\s0 and \s-1STDERR\s0 in order to capture the \s-1STDERR\s0
but leave its \s-1STDOUT\s0 to come out our old \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 3>&1 1>&2 2>&3 3>&\-\`;        # either with backticks
\&    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&\-|");# or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To read both a command's \s-1STDOUT\s0 and its \s-1STDERR\s0 separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:
.PP
.Vb 1
\&    system("program args 1>program.stdout 2>program.stderr");
.Ve
.PP
Ordering is important in all these examples. That's because the shell
processes file descriptor redirections in strictly left to right order.
.PP
.Vb 2
\&    system("prog args 1>tmpfile 2>&1");
\&    system("prog args 2>&1 1>tmpfile");
.Ve
.PP
The first command sends both standard out and standard error to the
temporary file. The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.
.SS "Why doesn't \fIopen()\fP return an error when a pipe open fails?"
.IX Subsection "Why doesn't open() return an error when a pipe open fails?"
If the second argument to a piped \f(CW\*(C`open()\*(C'\fR contains shell
metacharacters, perl \f(CW\*(C`fork()\*(C'\fRs, then \f(CW\*(C`exec()\*(C'\fRs a shell to decode the
metacharacters and eventually run the desired program. If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started. You can still capture the shell's \s-1STDERR\s0 and
check it for error messages. See \*(L"How can I capture \s-1STDERR\s0 from an
external command?\*(R" elsewhere in this document, or use the
IPC::Open3 module.
.PP
If there are no shell metacharacters in the argument of \f(CW\*(C`open()\*(C'\fR, Perl
runs the command directly, without using the shell, and can correctly
report whether the command started.
.SS "What's wrong with using backticks in a void context?"
.IX Subsection "What's wrong with using backticks in a void context?"
Strictly speaking, nothing. Stylistically speaking, it's not a good
way to write maintainable code. Perl has several operators for
running external commands. Backticks are one; they collect the output
from the command for use in your program. The \f(CW\*(C`system\*(C'\fR function is
another; it doesn't do this.
.PP
Writing backticks in your program sends a clear message to the readers
of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?
.PP
Consider this line:
.PP
.Vb 1
\&    \`cat /etc/termcap\`;
.Ve
.PP
You forgot to check \f(CW$?\fR to see whether the program even ran
correctly. Even if you wrote
.PP
.Vb 1
\&    print \`cat /etc/termcap\`;
.Ve
.PP
this code could and probably should be written as
.PP
.Vb 2
\&    system("cat /etc/termcap") == 0
\&    or die "cat program failed!";
.Ve
.PP
which will echo the cat command's output as it is generated, instead
of waiting until the program has completed to print it out. It also
checks the return value.
.PP
\&\f(CW\*(C`system\*(C'\fR also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.
.SS "How can I call backticks without shell processing?"
.IX Subsection "How can I call backticks without shell processing?"
This is a bit tricky. You can't simply write the command
like this:
.PP
.Vb 1
\&    @ok = \`grep @opts \*(Aq$search_string\*(Aq @filenames\`;
.Ve
.PP
As of Perl 5.8.0, you can use \f(CW\*(C`open()\*(C'\fR with multiple arguments.
Just like the list forms of \f(CW\*(C`system()\*(C'\fR and \f(CW\*(C`exec()\*(C'\fR, no shell
escapes happen.
.PP
.Vb 3
\&    open( GREP, "\-|", \*(Aqgrep\*(Aq, @opts, $search_string, @filenames );
\&    chomp(@ok = <GREP>);
\&    close GREP;
.Ve
.PP
You can also:
.PP
.Vb 10
\&    my @ok = ();
\&    if (open(GREP, "\-|")) {
\&        while (<GREP>) {
\&            chomp;
\&            push(@ok, $_);
\&        }
\&        close GREP;
\&    } else {
\&        exec \*(Aqgrep\*(Aq, @opts, $search_string, @filenames;
\&    }
.Ve
.PP
Just as with \f(CW\*(C`system()\*(C'\fR, no shell escapes happen when you \f(CW\*(C`exec()\*(C'\fR a
list. Further examples of this can be found in \*(L"Safe Pipe
Opens\*(R" in perlipc.
.PP
Note that if you're using Windows, no solution to this vexing issue is
even possible. Even though Perl emulates \f(CW\*(C`fork()\*(C'\fR, you'll still be
stuck, because Windows does not have an argc/argv\-style \s-1API.\s0
.SS "Why can't my script read from \s-1STDIN\s0 after I gave it \s-1EOF \s0(^D on Unix, ^Z on MS-DOS)?"
.IX Subsection "Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?"
This happens only if your perl is compiled to use stdio instead of
perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The \s-1POSIX\s0 module defines
\&\f(CW\*(C`clearerr()\*(C'\fR that you can use. That is the technically correct way to
do it. Here are some less reliable workarounds:
.IP "1." 4
Try keeping around the seekpointer and go there, like this:
.Sp
.Vb 2
\&    my $where = tell($log_fh);
\&    seek($log_fh, $where, 0);
.Ve
.IP "2." 4
If that doesn't work, try seeking to a different part of the file and
then back.
.IP "3." 4
If that doesn't work, try seeking to a different part of
the file, reading something, and then seeking back.
.IP "4." 4
If that doesn't work, give up on your stdio package and use sysread.
.SS "How can I convert my shell script to perl?"
.IX Subsection "How can I convert my shell script to perl?"
Learn Perl and rewrite it. Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell\->perl converter
nigh-on impossible to write. By rewriting it, you'll think about what
you're really trying to do, and hopefully will escape the shell's
pipeline datastream paradigm, which while convenient for some matters,
causes many inefficiencies.
.SS "Can I use perl to run a telnet or ftp session?"
.IX Subsection "Can I use perl to run a telnet or ftp session?"
Try the Net::FTP, TCP::Client, and Net::Telnet modules
(available from \s-1CPAN\s0).
<http://www.cpan.org/scripts/netstuff/telnet.emul.shar> will also help
for emulating the telnet protocol, but Net::Telnet is quite
probably easier to use.
.PP
If all you want to do is pretend to be telnet but don't need
the initial telnet handshaking, then the standard dual-process
approach will suffice:
.PP
.Vb 12
\&    use IO::Socket;             # new in 5.004
\&    my $handle = IO::Socket::INET\->new(\*(Aqwww.perl.com:80\*(Aq)
\&        or die "can\*(Aqt connect to port 80 on www.perl.com $!";
\&    $handle\->autoflush(1);
\&    if (fork()) {               # XXX: undef means failure
\&        select($handle);
\&        print while <STDIN>;    # everything from stdin to socket
\&    } else {
\&        print while <$handle>;  # everything from socket to stdout
\&    }
\&    close $handle;
\&    exit;
.Ve
.SS "How can I write expect in Perl?"
.IX Subsection "How can I write expect in Perl?"
Once upon a time, there was a library called \fIchat2.pl\fR (part of the
standard perl distribution), which never really got finished. If you
find it somewhere, \fIdon't use it\fR. These days, your best bet is to
look at the Expect module available from \s-1CPAN,\s0 which also requires two
other modules from \s-1CPAN, \s0IO::Pty and IO::Stty.
.ie n .SS "Is there a way to hide perl's command line from programs such as ""ps""?"
.el .SS "Is there a way to hide perl's command line from programs such as ``ps''?"
.IX Subsection "Is there a way to hide perl's command line from programs such as ps?"
First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite
your program so that critical information is never given as an
argument. Hiding the arguments won't make your program completely
secure.
.PP
To actually alter the visible command line, you can assign to the
variable \f(CW$0\fR as documented in perlvar. This won't work on all
operating systems, though. Daemon programs like sendmail place their
state there, as in:
.PP
.Vb 1
\&    $0 = "orcus [accepting connections]";
.Ve
.SS "I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?"
.IX Subsection "I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?"
.IP "Unix" 4
.IX Item "Unix"
In the strictest sense, it can't be done\*(--the script executes as a
different process from the shell it was started from. Changes to a
process are not reflected in its parent\*(--only in any children
created after the change. There is shell magic that may allow you to
fake it by \f(CW\*(C`eval()\*(C'\fRing the script's output in your shell; check out the
comp.unix.questions \s-1FAQ\s0 for details.
.SS "How do I close a process's filehandle without waiting for it to complete?"
.IX Subsection "How do I close a process's filehandle without waiting for it to complete?"
Assuming your system supports such things, just send an appropriate signal
to the process (see \*(L"kill\*(R" in perlfunc). It's common to first send a \s-1TERM\s0
signal, wait a little bit, and then send a \s-1KILL\s0 signal to finish it off.
.SS "How do I fork a daemon process?"
.IX Subsection "How do I fork a daemon process?"
If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most
Unixish systems. Non-Unix users should check their Your_OS::Process
module for other solutions.
.IP "\(bu" 4
Open /dev/tty and use the \s-1TIOCNOTTY\s0 ioctl on it. See \fItty\fR\|(1)
for details. Or better yet, you can just use the \f(CW\*(C`POSIX::setsid()\*(C'\fR
function, so you don't have to worry about process groups.
.IP "\(bu" 4
Change directory to /
.IP "\(bu" 4
Reopen \s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 so they're not connected to the old
tty.
.IP "\(bu" 4
Background yourself like this:
.Sp
.Vb 1
\&    fork && exit;
.Ve
.PP
The Proc::Daemon module, available from \s-1CPAN,\s0 provides a function to
perform these actions for you.
.SS "How do I find out if I'm running interactively or not?"
.IX Subsection "How do I find out if I'm running interactively or not?"
(contributed by brian d foy)
.PP
This is a difficult question to answer, and the best answer is
only a guess.
.PP
What do you really want to know? If you merely want to know if one of
your filehandles is connected to a terminal, you can try the \f(CW\*(C`\-t\*(C'\fR
file test:
.PP
.Vb 3
\&    if( \-t STDOUT ) {
\&        print "I\*(Aqm connected to a terminal!\en";
\&    }
.Ve
.PP
However, you might be out of luck if you expect that means there is a
real person on the other side. With the Expect module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.
.PP
The IO::Interactive module does the best it can to give you an
answer. Its \f(CW\*(C`is_interactive\*(C'\fR function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:
.PP
.Vb 1
\&    use IO::Interactive;
\&
\&    print { is_interactive } "I might go to standard output!\en";
.Ve
.PP
This still doesn't guarantee that a real person is answering your
prompts or reading your output.
.PP
If you want to know how to handle automated testing for your
distribution, you can check the environment. The \s-1CPAN\s0
Testers, for instance, set the value of \f(CW\*(C`AUTOMATED_TESTING\*(C'\fR:
.PP
.Vb 3
\&    unless( $ENV{AUTOMATED_TESTING} ) {
\&        print "Hello interactive tester!\en";
\&    }
.Ve
.SS "How do I timeout a slow event?"
.IX Subsection "How do I timeout a slow event?"
Use the \f(CW\*(C`alarm()\*(C'\fR function, probably in conjunction with a signal
handler, as documented in \*(L"Signals\*(R" in perlipc and the section on
\&\*(L"Signals\*(R" in the Camel. You may instead use the more flexible
Sys::AlarmCall module available from \s-1CPAN.\s0
.PP
The \f(CW\*(C`alarm()\*(C'\fR function is not implemented on all versions of Windows.
Check the documentation for your specific version of Perl.
.SS "How do I set \s-1CPU\s0 limits?"
.IX Xref "BSD::Resource limit CPU"
.IX Subsection "How do I set CPU limits?"
(contributed by Xho)
.PP
Use the BSD::Resource module from \s-1CPAN.\s0 As an example:
.PP
.Vb 2
\&    use BSD::Resource;
\&    setrlimit(RLIMIT_CPU,10,20) or die $!;
.Ve
.PP
This sets the soft and hard limits to 10 and 20 seconds, respectively.
After 10 seconds of time spent running on the \s-1CPU \s0(not \*(L"wall\*(R" time),
the process will be sent a signal (\s-1XCPU\s0 on some systems) which, if not
trapped, will cause the process to terminate. If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.
.PP
See the BSD::Resource and your systems documentation for the gory
details.
.SS "How do I avoid zombies on a Unix system?"
.IX Subsection "How do I avoid zombies on a Unix system?"
Use the reaper code from \*(L"Signals\*(R" in perlipc to call \f(CW\*(C`wait()\*(C'\fR when a
\&\s-1SIGCHLD\s0 is received, or else use the double-fork technique described
in \*(L"How do I start a process in the background?\*(R" in perlfaq8.
.SS "How do I use an \s-1SQL\s0 database?"
.IX Subsection "How do I use an SQL database?"
The \s-1DBI\s0 module provides an abstract interface to most database
servers and types, including Oracle, \s-1DB2,\s0 Sybase, mysql, Postgresql,
\&\s-1ODBC,\s0 and flat files. The \s-1DBI\s0 module accesses each database type
through a database driver, or \s-1DBD.\s0 You can see a complete list of
available drivers on \s-1CPAN: \s0<http://www.cpan.org/modules/by\-module/DBD/> .
You can read more about \s-1DBI\s0 on <http://dbi.perl.org/> .
.PP
Other modules provide more specific access: Win32::ODBC, Alzabo,
\&\f(CW\*(C`iodbc\*(C'\fR, and others found on \s-1CPAN\s0 Search: <http://search.cpan.org/> .
.SS "How do I make a \fIsystem()\fP exit on control-C?"
.IX Subsection "How do I make a system() exit on control-C?"
You can't. You need to imitate the \f(CW\*(C`system()\*(C'\fR call (see perlipc for
sample code) and then have a signal handler for the \s-1INT\s0 signal that
passes the signal on to the subprocess. Or you can check for it:
.PP
.Vb 2
\&    $rc = system($cmd);
\&    if ($rc & 127) { die "signal death" }
.Ve
.SS "How do I open a file without blocking?"
.IX Subsection "How do I open a file without blocking?"
If you're lucky enough to be using a system that supports
non-blocking reads (most Unixish systems do), you need only to use the
\&\f(CW\*(C`O_NDELAY\*(C'\fR or \f(CW\*(C`O_NONBLOCK\*(C'\fR flag from the \f(CW\*(C`Fcntl\*(C'\fR module in conjunction with
\&\f(CW\*(C`sysopen()\*(C'\fR:
.PP
.Vb 3
\&    use Fcntl;
\&    sysopen(my $fh, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
\&        or die "can\*(Aqt open /foo/somefile: $!":
.Ve
.SS "How do I tell the difference between errors from the shell and perl?"
.IX Subsection "How do I tell the difference between errors from the shell and perl?"
(answer contributed by brian d foy)
.PP
When you run a Perl script, something else is running the script for you,
and that something else may output error messages. The script might
emit its own warnings and error messages. Most of the time you cannot
tell who said what.
.PP
You probably cannot fix the thing that runs perl, but you can change how
perl outputs its warnings by defining a custom warning and die functions.
.PP
Consider this script, which has an error you may not notice immediately.
.PP
.Vb 1
\&    #!/usr/locl/bin/perl
\&
\&    print "Hello World\en";
.Ve
.PP
I get an error when I run this from my shell (which happens to be
bash). That may look like perl forgot it has a \f(CW\*(C`print()\*(C'\fR function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.
.PP
.Vb 2
\&    $ ./test
\&    ./test: line 3: print: command not found
.Ve
.PP
A quick and dirty fix involves a little bit of code, but this may be all
you need to figure out the problem.
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    BEGIN {
\&        $SIG{_\|_WARN_\|_} = sub{ print STDERR "Perl: ", @_; };
\&        $SIG{_\|_DIE_\|_}  = sub{ print STDERR "Perl: ", @_; exit 1};
\&    }
\&
\&    $a = 1 + undef;
\&    $x / 0;
\&    _\|_END_\|_
.Ve
.PP
The perl message comes out with \*(L"Perl\*(R" in front. The \f(CW\*(C`BEGIN\*(C'\fR block
works at compile time so all of the compilation errors and warnings
get the \*(L"Perl:\*(R" prefix too.
.PP
.Vb 7
\&    Perl: Useless use of division (/) in void context at ./test line 9.
\&    Perl: Name "main::a" used only once: possible typo at ./test line 8.
\&    Perl: Name "main::x" used only once: possible typo at ./test line 9.
\&    Perl: Use of uninitialized value in addition (+) at ./test line 8.
\&    Perl: Use of uninitialized value in division (/) at ./test line 9.
\&    Perl: Illegal division by zero at ./test line 9.
\&    Perl: Illegal division by zero at \-e line 3.
.Ve
.PP
If I don't see that \*(L"Perl:\*(R", it's not from perl.
.PP
You could also just know all the perl errors, and although there are
some people who may know all of them, you probably don't. However, they
all should be in the perldiag manpage. If you don't find the error in
there, it probably isn't a perl error.
.PP
Looking up every message is not the easiest way, so let perl to do it
for you. Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
If you don't get a paragraph or two of expanded discussion, it
might not be perl's message.
.SS "How do I install a module from \s-1CPAN\s0?"
.IX Subsection "How do I install a module from CPAN?"
(contributed by brian d foy)
.PP
The easiest way is to have a module also named \s-1CPAN\s0 do it for you by using
the \f(CW\*(C`cpan\*(C'\fR command that comes with Perl. You can give it a list of modules
to install:
.PP
.Vb 1
\&    $ cpan IO::Interactive Getopt::Whatever
.Ve
.PP
If you prefer \f(CW\*(C`CPANPLUS\*(C'\fR, it's just as easy:
.PP
.Vb 1
\&    $ cpanp i IO::Interactive Getopt::Whatever
.Ve
.PP
If you want to install a distribution from the current directory, you can
tell \f(CW\*(C`CPAN.pm\*(C'\fR to install \f(CW\*(C`.\*(C'\fR (the full stop):
.PP
.Vb 1
\&    $ cpan .
.Ve
.PP
See the documentation for either of those commands to see what else
you can do.
.PP
If you want to try to install a distribution by yourself, resolving
all dependencies on your own, you follow one of two possible build
paths.
.PP
For distributions that use \fIMakefile.PL\fR:
.PP
.Vb 2
\&    $ perl Makefile.PL
\&    $ make test install
.Ve
.PP
For distributions that use \fIBuild.PL\fR:
.PP
.Vb 3
\&    $ perl Build.PL
\&    $ ./Build test
\&    $ ./Build install
.Ve
.PP
Some distributions may need to link to libraries or other third-party
code and their build and installation sequences may be more complicated.
Check any \fI\s-1README\s0\fR or \fI\s-1INSTALL\s0\fR files that you may find.
.SS "What's the difference between require and use?"
.IX Subsection "What's the difference between require and use?"
(contributed by brian d foy)
.PP
Perl runs \f(CW\*(C`require\*(C'\fR statement at run-time. Once Perl loads, compiles,
and runs the file, it doesn't do anything else. The \f(CW\*(C`use\*(C'\fR statement
is the same as a \f(CW\*(C`require\*(C'\fR run at compile-time, but Perl also calls the
\&\f(CW\*(C`import\*(C'\fR method for the loaded package. These two are the same:
.PP
.Vb 1
\&    use MODULE qw(import list);
\&
\&    BEGIN {
\&        require MODULE;
\&        MODULE\->import(import list);
\&    }
.Ve
.PP
However, you can suppress the \f(CW\*(C`import\*(C'\fR by using an explicit, empty
import list. Both of these still happen at compile-time:
.PP
.Vb 1
\&    use MODULE ();
\&
\&    BEGIN {
\&        require MODULE;
\&    }
.Ve
.PP
Since \f(CW\*(C`use\*(C'\fR will also call the \f(CW\*(C`import\*(C'\fR method, the actual value
for \f(CW\*(C`MODULE\*(C'\fR must be a bareword. That is, \f(CW\*(C`use\*(C'\fR cannot load files
by name, although \f(CW\*(C`require\*(C'\fR can:
.PP
.Vb 1
\&    require "$ENV{HOME}/lib/Foo.pm"; # no @INC searching!
.Ve
.PP
See the entry for \f(CW\*(C`use\*(C'\fR in perlfunc for more details.
.SS "How do I keep my own module/library directory?"
.IX Subsection "How do I keep my own module/library directory?"
When you build modules, tell Perl where to install the modules.
.PP
If you want to install modules for your own use, the easiest way might
be local::lib, which you can download from \s-1CPAN.\s0 It sets various
installation settings for you, and uses those same settings within
your programs.
.PP
If you want more flexibility, you need to configure your \s-1CPAN\s0 client
for your particular situation.
.PP
For \f(CW\*(C`Makefile.PL\*(C'\fR\-based distributions, use the \s-1INSTALL_BASE\s0 option
when generating Makefiles:
.PP
.Vb 1
\&    perl Makefile.PL INSTALL_BASE=/mydir/perl
.Ve
.PP
You can set this in your \f(CW\*(C`CPAN.pm\*(C'\fR configuration so modules
automatically install in your private library directory when you use
the \s-1CPAN\s0.pm shell:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
\&    cpan> o conf commit
.Ve
.PP
For \f(CW\*(C`Build.PL\*(C'\fR\-based distributions, use the \-\-install_base option:
.PP
.Vb 1
\&    perl Build.PL \-\-install_base /mydir/perl
.Ve
.PP
You can configure \f(CW\*(C`CPAN.pm\*(C'\fR to automatically use this option too:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf mbuild_arg "\-\-install_base /mydir/perl"
\&    cpan> o conf commit
.Ve
.PP
\&\s-1INSTALL_BASE\s0 tells these tools to put your modules into
\&\fI/mydir/perl/lib/perl5\fR. See \*(L"How do I add a directory to my
include path (@INC) at runtime?\*(R" for details on how to run your newly
installed modules.
.PP
There is one caveat with \s-1INSTALL_BASE,\s0 though, since it acts
differently from the \s-1PREFIX\s0 and \s-1LIB\s0 settings that older versions of
ExtUtils::MakeMaker advocated. \s-1INSTALL_BASE\s0 does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider whether you
really want that and, if you do, use the older \s-1PREFIX\s0 and \s-1LIB\s0
settings. See the ExtUtils::Makemaker documentation for more details.
.SS "How do I add the directory my program lives in to the module/library search path?"
.IX Subsection "How do I add the directory my program lives in to the module/library search path?"
(contributed by brian d foy)
.PP
If you know the directory already, you can add it to \f(CW@INC\fR as you would
for any other directory. You might <use lib> if you know the directory
at compile time:
.PP
.Vb 1
\&    use lib $directory;
.Ve
.PP
The trick in this task is to find the directory. Before your script does
anything else (such as a \f(CW\*(C`chdir\*(C'\fR), you can get the current working
directory with the \f(CW\*(C`Cwd\*(C'\fR module, which comes with Perl:
.PP
.Vb 4
\&    BEGIN {
\&        use Cwd;
\&        our $directory = cwd;
\&    }
\&
\&    use lib $directory;
.Ve
.PP
You can do a similar thing with the value of \f(CW$0\fR, which holds the
script name. That might hold a relative path, but \f(CW\*(C`rel2abs\*(C'\fR can turn
it into an absolute path. Once you have the
.PP
.Vb 3
\&    BEGIN {
\&        use File::Spec::Functions qw(rel2abs);
\&        use File::Basename qw(dirname);
\&
\&        my $path   = rel2abs( $0 );
\&        our $directory = dirname( $path );
\&    }
\&
\&    use lib $directory;
.Ve
.PP
The FindBin module, which comes with Perl, might work. It finds the
directory of the currently running script and puts it in \f(CW$Bin\fR, which
you can then use to construct the right library path:
.PP
.Vb 1
\&    use FindBin qw($Bin);
.Ve
.PP
You can also use local::lib to do much of the same thing. Install
modules using local::lib's settings then use the module in your
program:
.PP
.Vb 1
\&     use local::lib; # sets up a local lib at ~/perl5
.Ve
.PP
See the local::lib documentation for more details.
.SS "How do I add a directory to my include path (@INC) at runtime?"
.IX Subsection "How do I add a directory to my include path (@INC) at runtime?"
Here are the suggested ways of modifying your include path, including
environment variables, run-time switches, and in-code statements:
.ie n .IP "the ""PERLLIB"" environment variable" 4
.el .IP "the \f(CWPERLLIB\fR environment variable" 4
.IX Item "the PERLLIB environment variable"
.Vb 2
\&    $ export PERLLIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""PERL5LIB"" environment variable" 4
.el .IP "the \f(CWPERL5LIB\fR environment variable" 4
.IX Item "the PERL5LIB environment variable"
.Vb 2
\&    $ export PERL5LIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""perl \-Idir"" command line flag" 4
.el .IP "the \f(CWperl \-Idir\fR command line flag" 4
.IX Item "the perl -Idir command line flag"
.Vb 1
\&    $ perl \-I/path/to/my/dir program.pl
.Ve
.ie n .IP "the ""lib"" pragma:" 4
.el .IP "the \f(CWlib\fR pragma:" 4
.IX Item "the lib pragma:"
.Vb 1
\&    use lib "$ENV{HOME}/myown_perllib";
.Ve
.IP "the local::lib module:" 4
.IX Item "the local::lib module:"
.Vb 1
\&    use local::lib;
\&
\&    use local::lib "~/myown_perllib";
.Ve
.PP
The last is particularly useful because it knows about machine-dependent
architectures. The \f(CW\*(C`lib.pm\*(C'\fR pragmatic module was first
included with the 5.002 release of Perl.
.SS "What is socket.ph and where do I get it?"
.IX Subsection "What is socket.ph and where do I get it?"
It's a Perl 4 style file defining values for system networking
constants. Sometimes it is built using h2ph when Perl is installed,
but other times it is not. Modern programs should use \f(CW\*(C`use Socket;\*(C'\fR
instead.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq85.16.1                               0100644 0001750 0001750 00000173352 12566207417 023011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ8 1"
.TH PERLFAQ8 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq8 \- System Interaction
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the Perl \s-1FAQ\s0 covers questions involving operating
system interaction. Topics include interprocess communication (\s-1IPC\s0),
control over the user-interface (keyboard, screen and pointing
devices), and most anything else not related to data manipulation.
.PP
Read the FAQs and documentation specific to the port of perl to your
operating system (eg, perlvms, perlplan9, ...). These should
contain more detailed information on the vagaries of your perl.
.SS "How do I find out which operating system I'm running under?"
.IX Subsection "How do I find out which operating system I'm running under?"
The \f(CW$^O\fR variable (\f(CW$OSNAME\fR if you use \f(CW\*(C`English\*(C'\fR) contains an
indication of the name of the operating system (not its release
number) that your perl binary was built for.
.SS "How come \fIexec()\fP doesn't return?"
.IX Xref "exec system fork open pipe"
.IX Subsection "How come exec() doesn't return?"
(contributed by brian d foy)
.PP
The \f(CW\*(C`exec\*(C'\fR function's job is to turn your process into another
command and never to return. If that's not what you want to do, don't
use \f(CW\*(C`exec\*(C'\fR. :)
.PP
If you want to run an external command and still keep your Perl process
going, look at a piped \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, or \f(CW\*(C`system\*(C'\fR.
.SS "How do I do fancy stuff with the keyboard/screen/mouse?"
.IX Subsection "How do I do fancy stuff with the keyboard/screen/mouse?"
How you access/control keyboards, screens, and pointing devices
(\*(L"mice\*(R") is system-dependent. Try the following modules:
.IP "Keyboard" 4
.IX Item "Keyboard"
.Vb 5
\&    Term::Cap               Standard perl distribution
\&    Term::ReadKey           CPAN
\&    Term::ReadLine::Gnu     CPAN
\&    Term::ReadLine::Perl    CPAN
\&    Term::Screen            CPAN
.Ve
.IP "Screen" 4
.IX Item "Screen"
.Vb 3
\&    Term::Cap               Standard perl distribution
\&    Curses                  CPAN
\&    Term::ANSIColor         CPAN
.Ve
.IP "Mouse" 4
.IX Item "Mouse"
.Vb 4
\&    Tk                      CPAN
\&    Wx                      CPAN
\&    Gtk2                    CPAN
\&    Qt4                     kdebindings4 package
.Ve
.PP
Some of these specific cases are shown as examples in other answers
in this section of the perlfaq.
.SS "How do I print something out in color?"
.IX Subsection "How do I print something out in color?"
In general, you don't, because you don't know whether
the recipient has a color-aware display device. If you
know that they have an \s-1ANSI\s0 terminal that understands
color, you can use the Term::ANSIColor module from \s-1CPAN:\s0
.PP
.Vb 3
\&    use Term::ANSIColor;
\&    print color("red"), "Stop!\en", color("reset");
\&    print color("green"), "Go!\en", color("reset");
.Ve
.PP
Or like this:
.PP
.Vb 3
\&    use Term::ANSIColor qw(:constants);
\&    print RED, "Stop!\en", RESET;
\&    print GREEN, "Go!\en", RESET;
.Ve
.SS "How do I read just one key without waiting for a return key?"
.IX Subsection "How do I read just one key without waiting for a return key?"
Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the \fBstty\fR command as shown in
\&\*(L"getc\*(R" in perlfunc, but as you see, that's already getting you into
portability snags.
.PP
.Vb 6
\&    open(TTY, "+</dev/tty") or die "no tty: $!";
\&    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
\&    $key = getc(TTY);        # perhaps this works
\&    # OR ELSE
\&    sysread(TTY, $key, 1);    # probably this does
\&    system "stty \-cbreak </dev/tty >/dev/tty 2>&1";
.Ve
.PP
The Term::ReadKey module from \s-1CPAN\s0 offers an easy-to-use interface that
should be more efficient than shelling out to \fBstty\fR for each key.
It even includes limited support for Windows.
.PP
.Vb 4
\&    use Term::ReadKey;
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&    $key = ReadKey(0);
\&    ReadMode(\*(Aqnormal\*(Aq);
.Ve
.PP
However, using the code requires that you have a working C compiler
and can use it to build and install a \s-1CPAN\s0 module. Here's a solution
using the standard \s-1POSIX\s0 module, which is already on your system
(assuming your system supports \s-1POSIX\s0).
.PP
.Vb 2
\&    use HotKey;
\&    $key = readkey();
.Ve
.PP
And here's the \f(CW\*(C`HotKey\*(C'\fR module, which hides the somewhat mystifying calls
to manipulate the \s-1POSIX\s0 termios structures.
.PP
.Vb 2
\&    # HotKey.pm
\&    package HotKey;
\&
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqExporter\*(Aq;
\&    our @EXPORT = qw(cbreak cooked readkey);
\&
\&    use POSIX qw(:termios_h);
\&    my ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&    $fd_stdin = fileno(STDIN);
\&    $term     = POSIX::Termios\->new();
\&    $term\->getattr($fd_stdin);
\&    $oterm     = $term\->getlflag();
\&
\&    $echo     = ECHO | ECHOK | ICANON;
\&    $noecho   = $oterm & ~$echo;
\&
\&    sub cbreak {
\&        $term\->setlflag($noecho);  # ok, so i don\*(Aqt want echo either
\&        $term\->setcc(VTIME, 1);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub cooked {
\&        $term\->setlflag($oterm);
\&        $term\->setcc(VTIME, 0);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub readkey {
\&        my $key = \*(Aq\*(Aq;
\&        cbreak();
\&        sysread(STDIN, $key, 1);
\&        cooked();
\&        return $key;
\&    }
\&
\&    END { cooked() }
\&
\&    1;
.Ve
.SS "How do I check whether input is ready on the keyboard?"
.IX Subsection "How do I check whether input is ready on the keyboard?"
The easiest way to do this is to read a key in nonblocking mode with the
Term::ReadKey module from \s-1CPAN\s0, passing it an argument of \-1 to indicate
not to block:
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&
\&    if (defined (my $char = ReadKey(\-1)) ) {
\&        # input was waiting and it was $char
\&    } else {
\&        # no input was waiting
\&    }
\&
\&    ReadMode(\*(Aqnormal\*(Aq);                  # restore normal tty settings
.Ve
.SS "How do I clear the screen?"
.IX Subsection "How do I clear the screen?"
(contributed by brian d foy)
.PP
To clear the screen, you just have to print the special sequence
that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.
.PP
You can use the Term::ANSIScreen module to get the special
sequence. Import the \f(CW\*(C`cls\*(C'\fR function (or the \f(CW\*(C`:screen\*(C'\fR tag):
.PP
.Vb 2
\&    use Term::ANSIScreen qw(cls);
\&    my $clear_screen = cls();
\&
\&    print $clear_screen;
.Ve
.PP
The Term::Cap module can also get the special sequence if you want
to deal with the low-level details of terminal control. The \f(CW\*(C`Tputs\*(C'\fR
method returns the string for the given capability:
.PP
.Vb 1
\&    use Term::Cap;
\&
\&    my $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 } );
\&    my $clear_string = $terminal\->Tputs(\*(Aqcl\*(Aq);
\&
\&    print $clear_screen;
.Ve
.PP
On Windows, you can use the Win32::Console module. After creating
an object for the output filehandle you want to affect, call the
\&\f(CW\*(C`Cls\*(C'\fR method:
.PP
.Vb 1
\&    Win32::Console;
\&
\&    my $OUT = Win32::Console\->new(STD_OUTPUT_HANDLE);
\&    my $clear_string = $OUT\->Cls;
\&
\&    print $clear_screen;
.Ve
.PP
If you have a command-line program that does the job, you can call
it in backticks to capture whatever it outputs so you can use it
later:
.PP
.Vb 1
\&    my $clear_string = \`clear\`;
\&
\&    print $clear_string;
.Ve
.SS "How do I get the screen size?"
.IX Subsection "How do I get the screen size?"
If you have Term::ReadKey module installed from \s-1CPAN\s0,
you can use it to fetch the width and height in characters
and in pixels:
.PP
.Vb 2
\&    use Term::ReadKey;
\&    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
.Ve
.PP
This is more portable than the raw \f(CW\*(C`ioctl\*(C'\fR, but not as
illustrative:
.PP
.Vb 10
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&    die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
\&    open(my $tty_fh, "+</dev/tty")                     or die "No tty: $!";
\&    unless (ioctl($tty_fh, &TIOCGWINSZ, $winsize=\*(Aq\*(Aq)) {
\&        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\en", &TIOCGWINSZ;
\&    }
\&    my ($row, $col, $xpixel, $ypixel) = unpack(\*(AqS4\*(Aq, $winsize);
\&    print "(row,col) = ($row,$col)";
\&    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
\&    print "\en";
.Ve
.SS "How do I ask the user for a password?"
.IX Subsection "How do I ask the user for a password?"
(This question has nothing to do with the web. See a different
\&\s-1FAQ\s0 for that.)
.PP
There's an example of this in \*(L"crypt\*(R" in perlfunc). First, you put the
terminal into \*(L"no echo\*(R" mode, then just read the password normally.
You may do this with an old-style \f(CW\*(C`ioctl()\*(C'\fR function, \s-1POSIX\s0 terminal
control (see \s-1POSIX\s0 or its documentation the Camel Book), or a call
to the \fBstty\fR program, with varying degrees of portability.
.PP
You can also do this for most systems using the Term::ReadKey module
from \s-1CPAN\s0, which is easier to use and in theory more portable.
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqnoecho\*(Aq);
\&    my $password = ReadLine(0);
.Ve
.SS "How do I read and write the serial port?"
.IX Subsection "How do I read and write the serial port?"
This depends on which operating system your program is running on. In
the case of Unix, the serial ports will be accessible through files in
\&\f(CW\*(C`/dev\*(C'\fR; on other systems, device names will doubtless differ.
Several problem areas common to all device interaction are the
following:
.IP "lockfiles" 4
.IX Item "lockfiles"
Your system may use lockfiles to control multiple access. Make sure
you follow the correct protocol. Unpredictable behavior can result
from multiple processes reading from one device.
.IP "open mode" 4
.IX Item "open mode"
If you expect to use both read and write operations on the device,
you'll have to open it for update (see \*(L"open\*(R" in perlfunc for
details). You may wish to open it without running the risk of
blocking by using \f(CW\*(C`sysopen()\*(C'\fR and \f(CW\*(C`O_RDWR|O_NDELAY|O_NOCTTY\*(C'\fR from the
Fcntl module (part of the standard perl distribution). See
\&\*(L"sysopen\*(R" in perlfunc for more on this approach.
.IP "end of line" 4
.IX Item "end of line"
Some devices will be expecting a \*(L"\er\*(R" at the end of each line rather
than a \*(L"\en\*(R". In some ports of perl, \*(L"\er\*(R" and \*(L"\en\*(R" are different from
their usual (Unix) \s-1ASCII\s0 values of \*(L"\e015\*(R" and \*(L"\e012\*(R". You may have to
give the numeric values you want directly, using octal (\*(L"\e015\*(R"), hex
(\*(L"0x0D\*(R"), or as a control-character specification (\*(L"\ecM\*(R").
.Sp
.Vb 2
\&    print DEV "atv1\e012";    # wrong, for some devices
\&    print DEV "atv1\e015";    # right, for some devices
.Ve
.Sp
Even though with normal text files a \*(L"\en\*(R" will do the trick, there is
still no unified scheme for terminating a line that is portable
between Unix, DOS/Win, and Macintosh, except to terminate \fI\s-1ALL\s0\fR line
ends with \*(L"\e015\e012\*(R", and strip what you don't need from the output.
This applies especially to socket I/O and autoflushing, discussed
next.
.IP "flushing output" 4
.IX Item "flushing output"
If you expect characters to get to your device when you \f(CW\*(C`print()\*(C'\fR them,
you'll want to autoflush that filehandle. You can use \f(CW\*(C`select()\*(C'\fR
and the \f(CW$|\fR variable to control autoflushing (see \*(L"$|\*(R" in perlvar
and \*(L"select\*(R" in perlfunc, or perlfaq5, \*(L"How do I flush/unbuffer an
output filehandle? Why must I do this?\*(R"):
.Sp
.Vb 3
\&    my $old_handle = select($dev_fh);
\&    $| = 1;
\&    select($old_handle);
.Ve
.Sp
You'll also see code that does this without a temporary variable, as in
.Sp
.Vb 1
\&    select((select($deb_handle), $| = 1)[0]);
.Ve
.Sp
Or if you don't mind pulling in a few thousand lines
of code just because you're afraid of a little \f(CW$|\fR variable:
.Sp
.Vb 2
\&    use IO::Handle;
\&    $dev_fh\->autoflush(1);
.Ve
.Sp
As mentioned in the previous item, this still doesn't work when using
socket I/O between Unix and Macintosh. You'll need to hard code your
line terminators, in that case.
.IP "non-blocking input" 4
.IX Item "non-blocking input"
If you are doing a blocking \f(CW\*(C`read()\*(C'\fR or \f(CW\*(C`sysread()\*(C'\fR, you'll have to
arrange for an alarm handler to provide a timeout (see
\&\*(L"alarm\*(R" in perlfunc). If you have a non-blocking open, you'll likely
have a non-blocking read, which means you may have to use a 4\-arg
\&\f(CW\*(C`select()\*(C'\fR to determine whether I/O is ready on that device (see
\&\*(L"select\*(R" in perlfunc.
.PP
While trying to read from his caller-id box, the notorious Jamie
Zawinski \f(CW\*(C`<jwz@netscape.com>\*(C'\fR, after much gnashing of teeth and
fighting with \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \s-1POSIX\s0's \f(CW\*(C`tcgetattr\*(C'\fR business,
and various other functions that go bump in the night, finally came up
with this:
.PP
.Vb 10
\&    sub open_modem {
\&        use IPC::Open2;
\&        my $stty = \`/bin/stty \-g\`;
\&        open2( \e*MODEM_IN, \e*MODEM_OUT, "cu \-l$modem_device \-s2400 2>&1");
\&        # starting cu hoses /dev/tty\*(Aqs stty settings, even when it has
\&        # been opened on a pipe...
\&        system("/bin/stty $stty");
\&        $_ = <MODEM_IN>;
\&        chomp;
\&        if ( !m/^Connected/ ) {
\&            print STDERR "$0: cu printed \`$_\*(Aq instead of \`Connected\*(Aq\en";
\&        }
\&    }
.Ve
.SS "How do I decode encrypted password files?"
.IX Subsection "How do I decode encrypted password files?"
You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.
.PP
Seriously, you can't if they are Unix password files\*(--the Unix
password system employs one-way encryption. It's more like hashing
than encryption. The best you can do is check whether something else
hashes to the same string. You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.
.PP
If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
\&\fIpasswd\fR\|(1), for example).
.SS "How do I start a process in the background?"
.IX Subsection "How do I start a process in the background?"
(contributed by brian d foy)
.PP
There's not a single way to run code in the background so you don't
have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are covered in perlipc.
.PP
Several \s-1CPAN\s0 modules may be able to help, including IPC::Open2 or
IPC::Open3, IPC::Run, Parallel::Jobs,
Parallel::ForkManager, \s-1POE\s0, Proc::Background, and
Win32::Process. There are many other modules you might use, so
check those namespaces for other options too.
.PP
If you are on a Unix-like system, you might be able to get away with a
system call where you put an \f(CW\*(C`&\*(C'\fR on the end of the command:
.PP
.Vb 1
\&    system("cmd &")
.Ve
.PP
You can also try using \f(CW\*(C`fork\*(C'\fR, as described in perlfunc (although
this is the same thing that many of the modules will do for you).
.IP "\s-1STDIN\s0, \s-1STDOUT\s0, and \s-1STDERR\s0 are shared" 4
.IX Item "STDIN, STDOUT, and STDERR are shared"
Both the main process and the backgrounded one (the \*(L"child\*(R" process)
share the same \s-1STDIN\s0, \s-1STDOUT\s0 and \s-1STDERR\s0 filehandles. If both try to
access them at once, strange things can happen. You may want to close
or reopen these for the child. You can get around this with
\&\f(CW\*(C`open\*(C'\fRing a pipe (see \*(L"open\*(R" in perlfunc) but on some systems this
means that the child process cannot outlive the parent.
.IP "Signals" 4
.IX Item "Signals"
You'll have to catch the \s-1SIGCHLD\s0 signal, and possibly \s-1SIGPIPE\s0 too.
\&\s-1SIGCHLD\s0 is sent when the backgrounded process finishes. \s-1SIGPIPE\s0 is
sent when you write to a filehandle whose child process has closed (an
untrapped \s-1SIGPIPE\s0 can cause your program to silently die). This is
not an issue with \f(CW\*(C`system("cmd&")\*(C'\fR.
.IP "Zombies" 4
.IX Item "Zombies"
You have to be prepared to \*(L"reap\*(R" the child process when it finishes.
.Sp
.Vb 1
\&    $SIG{CHLD} = sub { wait };
\&
\&    $SIG{CHLD} = \*(AqIGNORE\*(Aq;
.Ve
.Sp
You can also use a double fork. You immediately \f(CW\*(C`wait()\*(C'\fR for your
first child, and the init daemon will \f(CW\*(C`wait()\*(C'\fR for your grandchild once
it exits.
.Sp
.Vb 8
\&    unless ($pid = fork) {
\&        unless (fork) {
\&            exec "what you really wanna do";
\&            die "exec failed!";
\&        }
\&        exit 0;
\&    }
\&    waitpid($pid, 0);
.Ve
.Sp
See \*(L"Signals\*(R" in perlipc for other examples of code to do this.
Zombies are not an issue with \f(CW\*(C`system("prog &")\*(C'\fR.
.SS "How do I trap control characters/signals?"
.IX Subsection "How do I trap control characters/signals?"
You don't actually \*(L"trap\*(R" a control character. Instead, that character
generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in \*(L"Signals\*(R" in perlipc and the
section on \*(L"Signals\*(R" in the Camel.
.PP
You can set the values of the \f(CW%SIG\fR hash to be the functions you want
to handle the signal. After perl catches the signal, it looks in \f(CW%SIG\fR
for a key with the same name as the signal, then calls the subroutine
value for that key.
.PP
.Vb 1
\&    # as an anonymous subroutine
\&
\&    $SIG{INT} = sub { syswrite(STDERR, "ouch\en", 5 ) };
\&
\&    # or a reference to a function
\&
\&    $SIG{INT} = \e&ouch;
\&
\&    # or the name of the function as a string
\&
\&    $SIG{INT} = "ouch";
.Ve
.PP
Perl versions before 5.8 had in its C source code signal handlers which
would catch the signal and possibly run a Perl function that you had set
in \f(CW%SIG\fR. This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at \f(CW%SIG\fR
\&\fBafter\fR the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.
.SS "How do I modify the shadow password file on a Unix system?"
.IX Subsection "How do I modify the shadow password file on a Unix system?"
If perl was installed correctly and your shadow library was written
properly, the \f(CW\*(C`getpw*()\*(C'\fR functions described in perlfunc should in
theory provide (read-only) access to entries in the shadow password
file. To change the file, make a new shadow password file (the format
varies from system to system\*(--see \fIpasswd\fR\|(1) for specifics) and use
\&\f(CWpwd_mkdb(8)\fR to install it (see \fIpwd_mkdb\fR\|(8) for more details).
.SS "How do I set the time and date?"
.IX Subsection "How do I set the time and date?"
Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the \f(CWdate(1)\fR
program. (There is no way to set the time and date on a per-process
basis.)  This mechanism will work for Unix, MS-DOS, Windows, and \s-1NT\s0;
the \s-1VMS\s0 equivalent is \f(CW\*(C`set time\*(C'\fR.
.PP
However, if all you want to do is change your time zone, you can
probably get away with setting an environment variable:
.PP
.Vb 3
\&    $ENV{TZ} = "MST7MDT";           # Unixish
\&    $ENV{\*(AqSYS$TIMEZONE_DIFFERENTIAL\*(Aq}="\-5" # vms
\&    system(\*(Aqtrn\*(Aq, \*(Aqcomp.lang.perl.misc\*(Aq);
.Ve
.SS "How can I \fIsleep()\fP or \fIalarm()\fP for under a second?"
.IX Xref "Time::HiRes BSD::Itimer sleep select"
.IX Subsection "How can I sleep() or alarm() for under a second?"
If you want finer granularity than the 1 second that the \f(CW\*(C`sleep()\*(C'\fR
function provides, the easiest way is to use the \f(CW\*(C`select()\*(C'\fR function as
documented in \*(L"select\*(R" in perlfunc. Try the Time::HiRes and
the BSD::Itimer modules (available from \s-1CPAN\s0, and starting from
Perl 5.8 Time::HiRes is part of the standard distribution).
.SS "How can I measure time under a second?"
.IX Xref "Time::HiRes BSD::Itimer sleep select"
.IX Subsection "How can I measure time under a second?"
(contributed by brian d foy)
.PP
The Time::HiRes module (part of the standard distribution as of
Perl 5.8) measures time with the \f(CW\*(C`gettimeofday()\*(C'\fR system call, which
returns the time in microseconds since the epoch. If you can't install
Time::HiRes for older Perls and you are on a Unixish system, you
may be able to call \f(CWgettimeofday(2)\fR directly. See
\&\*(L"syscall\*(R" in perlfunc.
.SS "How can I do an \fIatexit()\fP or \fIsetjmp()\fP/\fIlongjmp()\fP? (Exception handling)"
.IX Subsection "How can I do an atexit() or setjmp()/longjmp()? (Exception handling)"
You can use the \f(CW\*(C`END\*(C'\fR block to simulate \f(CW\*(C`atexit()\*(C'\fR. Each package's
\&\f(CW\*(C`END\*(C'\fR block is called when the program or thread ends. See the perlmod
manpage for more details about \f(CW\*(C`END\*(C'\fR blocks.
.PP
For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:
.PP
.Vb 3
\&    END {
\&        close(STDOUT) || die "stdout close failed: $!";
\&    }
.Ve
.PP
The \f(CW\*(C`END\*(C'\fR block isn't called when untrapped signals kill the program,
though, so if you use \f(CW\*(C`END\*(C'\fR blocks you should also use
.PP
.Vb 1
\&    use sigtrap qw(die normal\-signals);
.Ve
.PP
Perl's exception-handling mechanism is its \f(CW\*(C`eval()\*(C'\fR operator. You
can use \f(CW\*(C`eval()\*(C'\fR as \f(CW\*(C`setjmp\*(C'\fR and \f(CW\*(C`die()\*(C'\fR as \f(CW\*(C`longjmp\*(C'\fR. For
details of this, see the section on signals, especially the time-out
handler for a blocking \f(CW\*(C`flock()\*(C'\fR in \*(L"Signals\*(R" in perlipc or the
section on \*(L"Signals\*(R" in \fIProgramming Perl\fR.
.PP
If exception handling is all you're interested in, use one of the
many \s-1CPAN\s0 modules that handle exceptions, such as Try::Tiny.
.PP
If you want the \f(CW\*(C`atexit()\*(C'\fR syntax (and an \f(CW\*(C`rmexit()\*(C'\fR as well), try the
\&\f(CW\*(C`AtExit\*(C'\fR module available from \s-1CPAN\s0.
.ie n .SS "Why doesn't my sockets program work under System V (Solaris)? What does the error message ""Protocol not supported"" mean?"
.el .SS "Why doesn't my sockets program work under System V (Solaris)? What does the error message ``Protocol not supported'' mean?"
.IX Subsection "Why doesn't my sockets program work under System V (Solaris)? What does the error message Protocol not supported mean?"
Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants. Since these were constant across all
architectures, they were often hardwired into perl code. The proper
way to deal with this is to \*(L"use Socket\*(R" to get the correct values.
.PP
Note that even though SunOS and Solaris are binary compatible, these
values are different. Go figure.
.SS "How can I call my system's unique C functions from Perl?"
.IX Subsection "How can I call my system's unique C functions from Perl?"
In most cases, you write an external module to do it\*(--see the answer
to \*(L"Where can I learn about linking C with Perl? [h2xs, xsubpp]\*(R".
However, if the function is a system call, and your system supports
\&\f(CW\*(C`syscall()\*(C'\fR, you can use the \f(CW\*(C`syscall\*(C'\fR function (documented in
perlfunc).
.PP
Remember to check the modules that came with your distribution, and
\&\s-1CPAN\s0 as well\*(--someone may already have written a module to do it. On
Windows, try Win32::API. On Macs, try Mac::Carbon. If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with Inline::C.
.SS "Where do I get the include files to do \fIioctl()\fP or \fIsyscall()\fP?"
.IX Subsection "Where do I get the include files to do ioctl() or syscall()?"
Historically, these would be generated by the h2ph tool, part of the
standard perl distribution. This program converts \f(CWcpp(1)\fR directives
in C header files to files containing subroutine definitions, like
\&\f(CW&SYS_getitimer\fR, which you can use as arguments to your functions.
It doesn't work perfectly, but it usually gets most of the job done.
Simple files like \fIerrno.h\fR, \fIsyscall.h\fR, and \fIsocket.h\fR were fine,
but the hard ones like \fIioctl.h\fR nearly always need to be hand-edited.
Here's how to install the *.ph files:
.PP
.Vb 3
\&    1. Become the super\-user
\&    2. cd /usr/include
\&    3. h2ph *.h */*.h
.Ve
.PP
If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use h2xs (also part of the standard perl
distribution). This tool converts C header files to Perl extensions.
See perlxstut for how to get started with h2xs.
.PP
If your system doesn't support dynamic loading, you still probably
ought to use h2xs. See perlxstut and ExtUtils::MakeMaker for
more information (in brief, just use \fBmake perl\fR instead of a plain
\&\fBmake\fR to rebuild perl with a new static extension).
.SS "Why do setuid perl scripts complain about kernel problems?"
.IX Subsection "Why do setuid perl scripts complain about kernel problems?"
Some operating systems have bugs in the kernel that make setuid
scripts inherently insecure. Perl gives you a number of options
(described in perlsec) to work around such systems.
.SS "How can I open a pipe both to and from a command?"
.IX Subsection "How can I open a pipe both to and from a command?"
The IPC::Open2 module (part of the standard perl distribution) is
an easy-to-use approach that internally uses \f(CW\*(C`pipe()\*(C'\fR, \f(CW\*(C`fork()\*(C'\fR, and
\&\f(CW\*(C`exec()\*(C'\fR to do the job. Make sure you read the deadlock warnings in
its documentation, though (see IPC::Open2). See
\&\*(L"Bidirectional Communication with Another Process\*(R" in perlipc and
\&\*(L"Bidirectional Communication with Yourself\*(R" in perlipc
.PP
You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from IPC::Open2 (see IPC::Open3).
.SS "Why can't I get the output of a command with \fIsystem()\fP?"
.IX Subsection "Why can't I get the output of a command with system()?"
You're confusing the purpose of \f(CW\*(C`system()\*(C'\fR and backticks (``). \f(CW\*(C`system()\*(C'\fR
runs a command and returns exit status information (as a 16 bit value:
the low 7 bits are the signal the process died from, if any, and
the high 8 bits are the actual exit value). Backticks (``) run a
command and return what it sent to \s-1STDOUT\s0.
.PP
.Vb 2
\&    my $exit_status   = system("mail\-users");
\&    my $output_string = \`ls\`;
.Ve
.SS "How can I capture \s-1STDERR\s0 from an external command?"
.IX Subsection "How can I capture STDERR from an external command?"
There are three basic ways of running external commands:
.PP
.Vb 3
\&    system $cmd;        # using system()
\&    my $output = \`$cmd\`;        # using backticks (\`\`)
\&    open (my $pipe_fh, "$cmd |");    # using open()
.Ve
.PP
With \f(CW\*(C`system()\*(C'\fR, both \s-1STDOUT\s0 and \s-1STDERR\s0 will go the same place as the
script's \s-1STDOUT\s0 and \s-1STDERR\s0, unless the \f(CW\*(C`system()\*(C'\fR command redirects them.
Backticks and \f(CW\*(C`open()\*(C'\fR read \fBonly\fR the \s-1STDOUT\s0 of your command.
.PP
You can also use the \f(CW\*(C`open3()\*(C'\fR function from IPC::Open3. Benjamin
Goldberg provides some sample code:
.PP
To capture a program's \s-1STDOUT\s0, but discard its \s-1STDERR:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    my $pid = open3(gensym, \e*PH, ">&NULL", "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a program's \s-1STDERR\s0, but discard its \s-1STDOUT:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    my $pid = open3(gensym, ">&NULL", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a program's \s-1STDERR\s0, and let its \s-1STDOUT\s0 go to our own \s-1STDERR:\s0
.PP
.Vb 5
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    my $pid = open3(gensym, ">&STDERR", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To read both a command's \s-1STDOUT\s0 and its \s-1STDERR\s0 separately, you can
redirect them to temp files, let the command run, then read the temp
files:
.PP
.Vb 10
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHOUT = IO::File\->new_tmpfile;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
\&    waitpid($pid, 0);
\&    seek $_, 0, 0 for \e*CATCHOUT, \e*CATCHERR;
\&    while( <CATCHOUT> ) {}
\&    while( <CATCHERR> ) {}
.Ve
.PP
But there's no real need for \fBboth\fR to be tempfiles... the following
should work just as well, without deadlocking:
.PP
.Vb 9
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    my $pid = open3(gensym, \e*CATCHOUT, ">&CATCHERR", "cmd");
\&    while( <CATCHOUT> ) {}
\&    waitpid($pid, 0);
\&    seek CATCHERR, 0, 0;
\&    while( <CATCHERR> ) {}
.Ve
.PP
And it'll be faster, too, since we can begin processing the program's
stdout immediately, rather than waiting for the program to finish.
.PP
With any of these, you can change file descriptors before the call:
.PP
.Vb 2
\&    open(STDOUT, ">logfile");
\&    system("ls");
.Ve
.PP
or you can use Bourne shell file-descriptor redirection:
.PP
.Vb 2
\&    $output = \`$cmd 2>some_file\`;
\&    open (PIPE, "cmd 2>some_file |");
.Ve
.PP
You can also use file-descriptor redirection to make \s-1STDERR\s0 a
duplicate of \s-1STDOUT:\s0
.PP
.Vb 2
\&    $output = \`$cmd 2>&1\`;
\&    open (PIPE, "cmd 2>&1 |");
.Ve
.PP
Note that you \fIcannot\fR simply open \s-1STDERR\s0 to be a dup of \s-1STDOUT\s0
in your Perl program and avoid calling the shell to do the redirection.
This doesn't work:
.PP
.Vb 2
\&    open(STDERR, ">&STDOUT");
\&    $alloutput = \`cmd args\`;  # stderr still escapes
.Ve
.PP
This fails because the \f(CW\*(C`open()\*(C'\fR makes \s-1STDERR\s0 go to where \s-1STDOUT\s0 was
going at the time of the \f(CW\*(C`open()\*(C'\fR. The backticks then make \s-1STDOUT\s0 go to
a string, but don't change \s-1STDERR\s0 (which still goes to the old
\&\s-1STDOUT\s0).
.PP
Note that you \fImust\fR use Bourne shell (\f(CWsh(1)\fR) redirection syntax in
backticks, not \f(CWcsh(1)\fR!  Details on why Perl's \f(CW\*(C`system()\*(C'\fR and backtick
and pipe opens all use the Bourne shell are in the
\&\fIversus/csh.whynot\fR article in the \*(L"Far More Than You Ever Wanted To
Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> . To
capture a command's \s-1STDERR\s0 and \s-1STDOUT\s0 together:
.PP
.Vb 3
\&    $output = \`cmd 2>&1\`;                       # either with backticks
\&    $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a command's \s-1STDOUT\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>/dev/null\`;                # either with backticks
\&    $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a command's \s-1STDERR\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>&1 1>/dev/null\`;           # either with backticks
\&    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To exchange a command's \s-1STDOUT\s0 and \s-1STDERR\s0 in order to capture the \s-1STDERR\s0
but leave its \s-1STDOUT\s0 to come out our old \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 3>&1 1>&2 2>&3 3>&\-\`;        # either with backticks
\&    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&\-|");# or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To read both a command's \s-1STDOUT\s0 and its \s-1STDERR\s0 separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:
.PP
.Vb 1
\&    system("program args 1>program.stdout 2>program.stderr");
.Ve
.PP
Ordering is important in all these examples. That's because the shell
processes file descriptor redirections in strictly left to right order.
.PP
.Vb 2
\&    system("prog args 1>tmpfile 2>&1");
\&    system("prog args 2>&1 1>tmpfile");
.Ve
.PP
The first command sends both standard out and standard error to the
temporary file. The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.
.SS "Why doesn't \fIopen()\fP return an error when a pipe open fails?"
.IX Subsection "Why doesn't open() return an error when a pipe open fails?"
If the second argument to a piped \f(CW\*(C`open()\*(C'\fR contains shell
metacharacters, perl \f(CW\*(C`fork()\*(C'\fRs, then \f(CW\*(C`exec()\*(C'\fRs a shell to decode the
metacharacters and eventually run the desired program. If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started. You can still capture the shell's \s-1STDERR\s0 and
check it for error messages. See \*(L"How can I capture \s-1STDERR\s0 from an
external command?\*(R" elsewhere in this document, or use the
IPC::Open3 module.
.PP
If there are no shell metacharacters in the argument of \f(CW\*(C`open()\*(C'\fR, Perl
runs the command directly, without using the shell, and can correctly
report whether the command started.
.SS "What's wrong with using backticks in a void context?"
.IX Subsection "What's wrong with using backticks in a void context?"
Strictly speaking, nothing. Stylistically speaking, it's not a good
way to write maintainable code. Perl has several operators for
running external commands. Backticks are one; they collect the output
from the command for use in your program. The \f(CW\*(C`system\*(C'\fR function is
another; it doesn't do this.
.PP
Writing backticks in your program sends a clear message to the readers
of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?
.PP
Consider this line:
.PP
.Vb 1
\&    \`cat /etc/termcap\`;
.Ve
.PP
You forgot to check \f(CW$?\fR to see whether the program even ran
correctly. Even if you wrote
.PP
.Vb 1
\&    print \`cat /etc/termcap\`;
.Ve
.PP
this code could and probably should be written as
.PP
.Vb 2
\&    system("cat /etc/termcap") == 0
\&    or die "cat program failed!";
.Ve
.PP
which will echo the cat command's output as it is generated, instead
of waiting until the program has completed to print it out. It also
checks the return value.
.PP
\&\f(CW\*(C`system\*(C'\fR also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.
.SS "How can I call backticks without shell processing?"
.IX Subsection "How can I call backticks without shell processing?"
This is a bit tricky. You can't simply write the command
like this:
.PP
.Vb 1
\&    @ok = \`grep @opts \*(Aq$search_string\*(Aq @filenames\`;
.Ve
.PP
As of Perl 5.8.0, you can use \f(CW\*(C`open()\*(C'\fR with multiple arguments.
Just like the list forms of \f(CW\*(C`system()\*(C'\fR and \f(CW\*(C`exec()\*(C'\fR, no shell
escapes happen.
.PP
.Vb 3
\&    open( GREP, "\-|", \*(Aqgrep\*(Aq, @opts, $search_string, @filenames );
\&    chomp(@ok = <GREP>);
\&    close GREP;
.Ve
.PP
You can also:
.PP
.Vb 10
\&    my @ok = ();
\&    if (open(GREP, "\-|")) {
\&        while (<GREP>) {
\&            chomp;
\&            push(@ok, $_);
\&        }
\&        close GREP;
\&    } else {
\&        exec \*(Aqgrep\*(Aq, @opts, $search_string, @filenames;
\&    }
.Ve
.PP
Just as with \f(CW\*(C`system()\*(C'\fR, no shell escapes happen when you \f(CW\*(C`exec()\*(C'\fR a
list. Further examples of this can be found in \*(L"Safe Pipe
Opens\*(R" in perlipc.
.PP
Note that if you're using Windows, no solution to this vexing issue is
even possible. Even though Perl emulates \f(CW\*(C`fork()\*(C'\fR, you'll still be
stuck, because Windows does not have an argc/argv\-style \s-1API\s0.
.SS "Why can't my script read from \s-1STDIN\s0 after I gave it \s-1EOF\s0 (^D on Unix, ^Z on MS-DOS)?"
.IX Subsection "Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?"
This happens only if your perl is compiled to use stdio instead of
perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The \s-1POSIX\s0 module defines
\&\f(CW\*(C`clearerr()\*(C'\fR that you can use. That is the technically correct way to
do it. Here are some less reliable workarounds:
.IP "1." 4
Try keeping around the seekpointer and go there, like this:
.Sp
.Vb 2
\&    my $where = tell($log_fh);
\&    seek($log_fh, $where, 0);
.Ve
.IP "2." 4
If that doesn't work, try seeking to a different part of the file and
then back.
.IP "3." 4
If that doesn't work, try seeking to a different part of
the file, reading something, and then seeking back.
.IP "4." 4
If that doesn't work, give up on your stdio package and use sysread.
.SS "How can I convert my shell script to perl?"
.IX Subsection "How can I convert my shell script to perl?"
Learn Perl and rewrite it. Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell\->perl converter
nigh-on impossible to write. By rewriting it, you'll think about what
you're really trying to do, and hopefully will escape the shell's
pipeline datastream paradigm, which while convenient for some matters,
causes many inefficiencies.
.SS "Can I use perl to run a telnet or ftp session?"
.IX Subsection "Can I use perl to run a telnet or ftp session?"
Try the Net::FTP, TCP::Client, and Net::Telnet modules
(available from \s-1CPAN\s0).
<http://www.cpan.org/scripts/netstuff/telnet.emul.shar> will also help
for emulating the telnet protocol, but Net::Telnet is quite
probably easier to use.
.PP
If all you want to do is pretend to be telnet but don't need
the initial telnet handshaking, then the standard dual-process
approach will suffice:
.PP
.Vb 12
\&    use IO::Socket;             # new in 5.004
\&    my $handle = IO::Socket::INET\->new(\*(Aqwww.perl.com:80\*(Aq)
\&        or die "can\*(Aqt connect to port 80 on www.perl.com $!";
\&    $handle\->autoflush(1);
\&    if (fork()) {               # XXX: undef means failure
\&        select($handle);
\&        print while <STDIN>;    # everything from stdin to socket
\&    } else {
\&        print while <$handle>;  # everything from socket to stdout
\&    }
\&    close $handle;
\&    exit;
.Ve
.SS "How can I write expect in Perl?"
.IX Subsection "How can I write expect in Perl?"
Once upon a time, there was a library called \fIchat2.pl\fR (part of the
standard perl distribution), which never really got finished. If you
find it somewhere, \fIdon't use it\fR. These days, your best bet is to
look at the Expect module available from \s-1CPAN\s0, which also requires two
other modules from \s-1CPAN\s0, IO::Pty and IO::Stty.
.ie n .SS "Is there a way to hide perl's command line from programs such as ""ps""?"
.el .SS "Is there a way to hide perl's command line from programs such as ``ps''?"
.IX Subsection "Is there a way to hide perl's command line from programs such as ps?"
First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite
your program so that critical information is never given as an
argument. Hiding the arguments won't make your program completely
secure.
.PP
To actually alter the visible command line, you can assign to the
variable \f(CW$0\fR as documented in perlvar. This won't work on all
operating systems, though. Daemon programs like sendmail place their
state there, as in:
.PP
.Vb 1
\&    $0 = "orcus [accepting connections]";
.Ve
.SS "I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?"
.IX Subsection "I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?"
.IP "Unix" 4
.IX Item "Unix"
In the strictest sense, it can't be done\*(--the script executes as a
different process from the shell it was started from. Changes to a
process are not reflected in its parent\*(--only in any children
created after the change. There is shell magic that may allow you to
fake it by \f(CW\*(C`eval()\*(C'\fRing the script's output in your shell; check out the
comp.unix.questions \s-1FAQ\s0 for details.
.SS "How do I close a process's filehandle without waiting for it to complete?"
.IX Subsection "How do I close a process's filehandle without waiting for it to complete?"
Assuming your system supports such things, just send an appropriate signal
to the process (see \*(L"kill\*(R" in perlfunc). It's common to first send a \s-1TERM\s0
signal, wait a little bit, and then send a \s-1KILL\s0 signal to finish it off.
.SS "How do I fork a daemon process?"
.IX Subsection "How do I fork a daemon process?"
If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most
Unixish systems. Non-Unix users should check their Your_OS::Process
module for other solutions.
.IP "\(bu" 4
Open /dev/tty and use the \s-1TIOCNOTTY\s0 ioctl on it. See \fItty\fR\|(1)
for details. Or better yet, you can just use the \f(CW\*(C`POSIX::setsid()\*(C'\fR
function, so you don't have to worry about process groups.
.IP "\(bu" 4
Change directory to /
.IP "\(bu" 4
Reopen \s-1STDIN\s0, \s-1STDOUT\s0, and \s-1STDERR\s0 so they're not connected to the old
tty.
.IP "\(bu" 4
Background yourself like this:
.Sp
.Vb 1
\&    fork && exit;
.Ve
.PP
The Proc::Daemon module, available from \s-1CPAN\s0, provides a function to
perform these actions for you.
.SS "How do I find out if I'm running interactively or not?"
.IX Subsection "How do I find out if I'm running interactively or not?"
(contributed by brian d foy)
.PP
This is a difficult question to answer, and the best answer is
only a guess.
.PP
What do you really want to know? If you merely want to know if one of
your filehandles is connected to a terminal, you can try the \f(CW\*(C`\-t\*(C'\fR
file test:
.PP
.Vb 3
\&    if( \-t STDOUT ) {
\&        print "I\*(Aqm connected to a terminal!\en";
\&    }
.Ve
.PP
However, you might be out of luck if you expect that means there is a
real person on the other side. With the Expect module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.
.PP
The IO::Interactive module does the best it can to give you an
answer. Its \f(CW\*(C`is_interactive\*(C'\fR function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:
.PP
.Vb 1
\&    use IO::Interactive;
\&
\&    print { is_interactive } "I might go to standard output!\en";
.Ve
.PP
This still doesn't guarantee that a real person is answering your
prompts or reading your output.
.PP
If you want to know how to handle automated testing for your
distribution, you can check the environment. The \s-1CPAN\s0
Testers, for instance, set the value of \f(CW\*(C`AUTOMATED_TESTING\*(C'\fR:
.PP
.Vb 3
\&    unless( $ENV{AUTOMATED_TESTING} ) {
\&        print "Hello interactive tester!\en";
\&    }
.Ve
.SS "How do I timeout a slow event?"
.IX Subsection "How do I timeout a slow event?"
Use the \f(CW\*(C`alarm()\*(C'\fR function, probably in conjunction with a signal
handler, as documented in \*(L"Signals\*(R" in perlipc and the section on
\&\*(L"Signals\*(R" in the Camel. You may instead use the more flexible
Sys::AlarmCall module available from \s-1CPAN\s0.
.PP
The \f(CW\*(C`alarm()\*(C'\fR function is not implemented on all versions of Windows.
Check the documentation for your specific version of Perl.
.SS "How do I set \s-1CPU\s0 limits?"
.IX Xref "BSD::Resource limit CPU"
.IX Subsection "How do I set CPU limits?"
(contributed by Xho)
.PP
Use the BSD::Resource module from \s-1CPAN\s0. As an example:
.PP
.Vb 2
\&    use BSD::Resource;
\&    setrlimit(RLIMIT_CPU,10,20) or die $!;
.Ve
.PP
This sets the soft and hard limits to 10 and 20 seconds, respectively.
After 10 seconds of time spent running on the \s-1CPU\s0 (not \*(L"wall\*(R" time),
the process will be sent a signal (\s-1XCPU\s0 on some systems) which, if not
trapped, will cause the process to terminate. If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.
.PP
See the BSD::Resource and your systems documentation for the gory
details.
.SS "How do I avoid zombies on a Unix system?"
.IX Subsection "How do I avoid zombies on a Unix system?"
Use the reaper code from \*(L"Signals\*(R" in perlipc to call \f(CW\*(C`wait()\*(C'\fR when a
\&\s-1SIGCHLD\s0 is received, or else use the double-fork technique described
in \*(L"How do I start a process in the background?\*(R" in perlfaq8.
.SS "How do I use an \s-1SQL\s0 database?"
.IX Subsection "How do I use an SQL database?"
The \s-1DBI\s0 module provides an abstract interface to most database
servers and types, including Oracle, \s-1DB2\s0, Sybase, mysql, Postgresql,
\&\s-1ODBC\s0, and flat files. The \s-1DBI\s0 module accesses each database type
through a database driver, or \s-1DBD\s0. You can see a complete list of
available drivers on \s-1CPAN:\s0 http://www.cpan.org/modules/by\-module/DBD/ <http://www.cpan.org/modules/by-module/DBD/> .
You can read more about \s-1DBI\s0 on <http://dbi.perl.org/> .
.PP
Other modules provide more specific access: Win32::ODBC, Alzabo,
\&\f(CW\*(C`iodbc\*(C'\fR, and others found on \s-1CPAN\s0 Search: <http://search.cpan.org/> .
.SS "How do I make a \fIsystem()\fP exit on control-C?"
.IX Subsection "How do I make a system() exit on control-C?"
You can't. You need to imitate the \f(CW\*(C`system()\*(C'\fR call (see perlipc for
sample code) and then have a signal handler for the \s-1INT\s0 signal that
passes the signal on to the subprocess. Or you can check for it:
.PP
.Vb 2
\&    $rc = system($cmd);
\&    if ($rc & 127) { die "signal death" }
.Ve
.SS "How do I open a file without blocking?"
.IX Subsection "How do I open a file without blocking?"
If you're lucky enough to be using a system that supports
non-blocking reads (most Unixish systems do), you need only to use the
\&\f(CW\*(C`O_NDELAY\*(C'\fR or \f(CW\*(C`O_NONBLOCK\*(C'\fR flag from the \f(CW\*(C`Fcntl\*(C'\fR module in conjunction with
\&\f(CW\*(C`sysopen()\*(C'\fR:
.PP
.Vb 3
\&    use Fcntl;
\&    sysopen(my $fh, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
\&        or die "can\*(Aqt open /foo/somefile: $!":
.Ve
.SS "How do I tell the difference between errors from the shell and perl?"
.IX Subsection "How do I tell the difference between errors from the shell and perl?"
(answer contributed by brian d foy)
.PP
When you run a Perl script, something else is running the script for you,
and that something else may output error messages. The script might
emit its own warnings and error messages. Most of the time you cannot
tell who said what.
.PP
You probably cannot fix the thing that runs perl, but you can change how
perl outputs its warnings by defining a custom warning and die functions.
.PP
Consider this script, which has an error you may not notice immediately.
.PP
.Vb 1
\&    #!/usr/locl/bin/perl
\&
\&    print "Hello World\en";
.Ve
.PP
I get an error when I run this from my shell (which happens to be
bash). That may look like perl forgot it has a \f(CW\*(C`print()\*(C'\fR function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.
.PP
.Vb 2
\&    $ ./test
\&    ./test: line 3: print: command not found
.Ve
.PP
A quick and dirty fix involves a little bit of code, but this may be all
you need to figure out the problem.
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    BEGIN {
\&        $SIG{_\|_WARN_\|_} = sub{ print STDERR "Perl: ", @_; };
\&        $SIG{_\|_DIE_\|_}  = sub{ print STDERR "Perl: ", @_; exit 1};
\&    }
\&
\&    $a = 1 + undef;
\&    $x / 0;
\&    _\|_END_\|_
.Ve
.PP
The perl message comes out with \*(L"Perl\*(R" in front. The \f(CW\*(C`BEGIN\*(C'\fR block
works at compile time so all of the compilation errors and warnings
get the \*(L"Perl:\*(R" prefix too.
.PP
.Vb 7
\&    Perl: Useless use of division (/) in void context at ./test line 9.
\&    Perl: Name "main::a" used only once: possible typo at ./test line 8.
\&    Perl: Name "main::x" used only once: possible typo at ./test line 9.
\&    Perl: Use of uninitialized value in addition (+) at ./test line 8.
\&    Perl: Use of uninitialized value in division (/) at ./test line 9.
\&    Perl: Illegal division by zero at ./test line 9.
\&    Perl: Illegal division by zero at \-e line 3.
.Ve
.PP
If I don't see that \*(L"Perl:\*(R", it's not from perl.
.PP
You could also just know all the perl errors, and although there are
some people who may know all of them, you probably don't. However, they
all should be in the perldiag manpage. If you don't find the error in
there, it probably isn't a perl error.
.PP
Looking up every message is not the easiest way, so let perl to do it
for you. Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
If you don't get a paragraph or two of expanded discussion, it
might not be perl's message.
.SS "How do I install a module from \s-1CPAN\s0?"
.IX Subsection "How do I install a module from CPAN?"
(contributed by brian d foy)
.PP
The easiest way is to have a module also named \s-1CPAN\s0 do it for you by using
the \f(CW\*(C`cpan\*(C'\fR command that comes with Perl. You can give it a list of modules
to install:
.PP
.Vb 1
\&    $ cpan IO::Interactive Getopt::Whatever
.Ve
.PP
If you prefer \f(CW\*(C`CPANPLUS\*(C'\fR, it's just as easy:
.PP
.Vb 1
\&    $ cpanp i IO::Interactive Getopt::Whatever
.Ve
.PP
If you want to install a distribution from the current directory, you can
tell \f(CW\*(C`CPAN.pm\*(C'\fR to install \f(CW\*(C`.\*(C'\fR (the full stop):
.PP
.Vb 1
\&    $ cpan .
.Ve
.PP
See the documentation for either of those commands to see what else
you can do.
.PP
If you want to try to install a distribution by yourself, resolving
all dependencies on your own, you follow one of two possible build
paths.
.PP
For distributions that use \fIMakefile.PL\fR:
.PP
.Vb 2
\&    $ perl Makefile.PL
\&    $ make test install
.Ve
.PP
For distributions that use \fIBuild.PL\fR:
.PP
.Vb 3
\&    $ perl Build.PL
\&    $ ./Build test
\&    $ ./Build install
.Ve
.PP
Some distributions may need to link to libraries or other third-party
code and their build and installation sequences may be more complicated.
Check any \fI\s-1README\s0\fR or \fI\s-1INSTALL\s0\fR files that you may find.
.SS "What's the difference between require and use?"
.IX Subsection "What's the difference between require and use?"
(contributed by brian d foy)
.PP
Perl runs \f(CW\*(C`require\*(C'\fR statement at run-time. Once Perl loads, compiles,
and runs the file, it doesn't do anything else. The \f(CW\*(C`use\*(C'\fR statement
is the same as a \f(CW\*(C`require\*(C'\fR run at compile-time, but Perl also calls the
\&\f(CW\*(C`import\*(C'\fR method for the loaded package. These two are the same:
.PP
.Vb 1
\&    use MODULE qw(import list);
\&
\&    BEGIN {
\&        require MODULE;
\&        MODULE\->import(import list);
\&    }
.Ve
.PP
However, you can suppress the \f(CW\*(C`import\*(C'\fR by using an explicit, empty
import list. Both of these still happen at compile-time:
.PP
.Vb 1
\&    use MODULE ();
\&
\&    BEGIN {
\&        require MODULE;
\&    }
.Ve
.PP
Since \f(CW\*(C`use\*(C'\fR will also call the \f(CW\*(C`import\*(C'\fR method, the actual value
for \f(CW\*(C`MODULE\*(C'\fR must be a bareword. That is, \f(CW\*(C`use\*(C'\fR cannot load files
by name, although \f(CW\*(C`require\*(C'\fR can:
.PP
.Vb 1
\&    require "$ENV{HOME}/lib/Foo.pm"; # no @INC searching!
.Ve
.PP
See the entry for \f(CW\*(C`use\*(C'\fR in perlfunc for more details.
.SS "How do I keep my own module/library directory?"
.IX Subsection "How do I keep my own module/library directory?"
When you build modules, tell Perl where to install the modules.
.PP
If you want to install modules for your own use, the easiest way might
be local::lib, which you can download from \s-1CPAN\s0. It sets various
installation settings for you, and uses those same settings within
your programs.
.PP
If you want more flexibility, you need to configure your \s-1CPAN\s0 client
for your particular situation.
.PP
For \f(CW\*(C`Makefile.PL\*(C'\fR\-based distributions, use the \s-1INSTALL_BASE\s0 option
when generating Makefiles:
.PP
.Vb 1
\&    perl Makefile.PL INSTALL_BASE=/mydir/perl
.Ve
.PP
You can set this in your \f(CW\*(C`CPAN.pm\*(C'\fR configuration so modules
automatically install in your private library directory when you use
the \s-1CPAN\s0.pm shell:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
\&    cpan> o conf commit
.Ve
.PP
For \f(CW\*(C`Build.PL\*(C'\fR\-based distributions, use the \-\-install_base option:
.PP
.Vb 1
\&    perl Build.PL \-\-install_base /mydir/perl
.Ve
.PP
You can configure \f(CW\*(C`CPAN.pm\*(C'\fR to automatically use this option too:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf mbuild_arg "\-\-install_base /mydir/perl"
\&    cpan> o conf commit
.Ve
.PP
\&\s-1INSTALL_BASE\s0 tells these tools to put your modules into
\&\fI/mydir/perl/lib/perl5\fR. See \*(L"How do I add a directory to my
include path (@INC) at runtime?\*(R" for details on how to run your newly
installed modules.
.PP
There is one caveat with \s-1INSTALL_BASE\s0, though, since it acts
differently from the \s-1PREFIX\s0 and \s-1LIB\s0 settings that older versions of
ExtUtils::MakeMaker advocated. \s-1INSTALL_BASE\s0 does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider whether you
really want that and, if you do, use the older \s-1PREFIX\s0 and \s-1LIB\s0
settings. See the ExtUtils::Makemaker documentation for more details.
.SS "How do I add the directory my program lives in to the module/library search path?"
.IX Subsection "How do I add the directory my program lives in to the module/library search path?"
(contributed by brian d foy)
.PP
If you know the directory already, you can add it to \f(CW@INC\fR as you would
for any other directory. You might <use lib> if you know the directory
at compile time:
.PP
.Vb 1
\&    use lib $directory;
.Ve
.PP
The trick in this task is to find the directory. Before your script does
anything else (such as a \f(CW\*(C`chdir\*(C'\fR), you can get the current working
directory with the \f(CW\*(C`Cwd\*(C'\fR module, which comes with Perl:
.PP
.Vb 4
\&    BEGIN {
\&        use Cwd;
\&        our $directory = cwd;
\&    }
\&
\&    use lib $directory;
.Ve
.PP
You can do a similar thing with the value of \f(CW$0\fR, which holds the
script name. That might hold a relative path, but \f(CW\*(C`rel2abs\*(C'\fR can turn
it into an absolute path. Once you have the
.PP
.Vb 3
\&    BEGIN {
\&        use File::Spec::Functions qw(rel2abs);
\&        use File::Basename qw(dirname);
\&
\&        my $path   = rel2abs( $0 );
\&        our $directory = dirname( $path );
\&    }
\&
\&    use lib $directory;
.Ve
.PP
The FindBin module, which comes with Perl, might work. It finds the
directory of the currently running script and puts it in \f(CW$Bin\fR, which
you can then use to construct the right library path:
.PP
.Vb 1
\&    use FindBin qw($Bin);
.Ve
.PP
You can also use local::lib to do much of the same thing. Install
modules using local::lib's settings then use the module in your
program:
.PP
.Vb 1
\&     use local::lib; # sets up a local lib at ~/perl5
.Ve
.PP
See the local::lib documentation for more details.
.SS "How do I add a directory to my include path (@INC) at runtime?"
.IX Subsection "How do I add a directory to my include path (@INC) at runtime?"
Here are the suggested ways of modifying your include path, including
environment variables, run-time switches, and in-code statements:
.ie n .IP "the ""PERLLIB"" environment variable" 4
.el .IP "the \f(CWPERLLIB\fR environment variable" 4
.IX Item "the PERLLIB environment variable"
.Vb 2
\&    $ export PERLLIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""PERL5LIB"" environment variable" 4
.el .IP "the \f(CWPERL5LIB\fR environment variable" 4
.IX Item "the PERL5LIB environment variable"
.Vb 2
\&    $ export PERL5LIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""perl \-Idir"" command line flag" 4
.el .IP "the \f(CWperl \-Idir\fR command line flag" 4
.IX Item "the perl -Idir command line flag"
.Vb 1
\&    $ perl \-I/path/to/my/dir program.pl
.Ve
.ie n .IP "the ""lib"" pragma:" 4
.el .IP "the \f(CWlib\fR pragma:" 4
.IX Item "the lib pragma:"
.Vb 1
\&    use lib "$ENV{HOME}/myown_perllib";
.Ve
.IP "the local::lib module:" 4
.IX Item "the local::lib module:"
.Vb 1
\&    use local::lib;
\&
\&    use local::lib "~/myown_perllib";
.Ve
.PP
The last is particularly useful because it knows about machine-dependent
architectures. The \f(CW\*(C`lib.pm\*(C'\fR pragmatic module was first
included with the 5.002 release of Perl.
.SS "What is socket.ph and where do I get it?"
.IX Subsection "What is socket.ph and where do I get it?"
It's a Perl 4 style file defining values for system networking
constants. Sometimes it is built using h2ph when Perl is installed,
but other times it is not. Modern programs should use \f(CW\*(C`use Socket;\*(C'\fR
instead.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq85.18.1                               0100644 0001750 0001750 00000173606 12566207437 023017  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ8 1"
.TH PERLFAQ8 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq8 \- System Interaction
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the Perl \s-1FAQ\s0 covers questions involving operating
system interaction. Topics include interprocess communication (\s-1IPC\s0),
control over the user-interface (keyboard, screen and pointing
devices), and most anything else not related to data manipulation.
.PP
Read the FAQs and documentation specific to the port of perl to your
operating system (eg, perlvms, perlplan9, ...). These should
contain more detailed information on the vagaries of your perl.
.SS "How do I find out which operating system I'm running under?"
.IX Subsection "How do I find out which operating system I'm running under?"
The \f(CW$^O\fR variable (\f(CW$OSNAME\fR if you use \f(CW\*(C`English\*(C'\fR) contains an
indication of the name of the operating system (not its release
number) that your perl binary was built for.
.SS "How come \fIexec()\fP doesn't return?"
.IX Xref "exec system fork open pipe"
.IX Subsection "How come exec() doesn't return?"
(contributed by brian d foy)
.PP
The \f(CW\*(C`exec\*(C'\fR function's job is to turn your process into another
command and never to return. If that's not what you want to do, don't
use \f(CW\*(C`exec\*(C'\fR. :)
.PP
If you want to run an external command and still keep your Perl process
going, look at a piped \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, or \f(CW\*(C`system\*(C'\fR.
.SS "How do I do fancy stuff with the keyboard/screen/mouse?"
.IX Subsection "How do I do fancy stuff with the keyboard/screen/mouse?"
How you access/control keyboards, screens, and pointing devices
(\*(L"mice\*(R") is system-dependent. Try the following modules:
.IP "Keyboard" 4
.IX Item "Keyboard"
.Vb 5
\&    Term::Cap               Standard perl distribution
\&    Term::ReadKey           CPAN
\&    Term::ReadLine::Gnu     CPAN
\&    Term::ReadLine::Perl    CPAN
\&    Term::Screen            CPAN
.Ve
.IP "Screen" 4
.IX Item "Screen"
.Vb 3
\&    Term::Cap               Standard perl distribution
\&    Curses                  CPAN
\&    Term::ANSIColor         CPAN
.Ve
.IP "Mouse" 4
.IX Item "Mouse"
.Vb 4
\&    Tk                      CPAN
\&    Wx                      CPAN
\&    Gtk2                    CPAN
\&    Qt4                     kdebindings4 package
.Ve
.PP
Some of these specific cases are shown as examples in other answers
in this section of the perlfaq.
.SS "How do I print something out in color?"
.IX Subsection "How do I print something out in color?"
In general, you don't, because you don't know whether
the recipient has a color-aware display device. If you
know that they have an \s-1ANSI\s0 terminal that understands
color, you can use the Term::ANSIColor module from \s-1CPAN:\s0
.PP
.Vb 3
\&    use Term::ANSIColor;
\&    print color("red"), "Stop!\en", color("reset");
\&    print color("green"), "Go!\en", color("reset");
.Ve
.PP
Or like this:
.PP
.Vb 3
\&    use Term::ANSIColor qw(:constants);
\&    print RED, "Stop!\en", RESET;
\&    print GREEN, "Go!\en", RESET;
.Ve
.SS "How do I read just one key without waiting for a return key?"
.IX Subsection "How do I read just one key without waiting for a return key?"
Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the \fBstty\fR command as shown in
\&\*(L"getc\*(R" in perlfunc, but as you see, that's already getting you into
portability snags.
.PP
.Vb 6
\&    open(TTY, "+</dev/tty") or die "no tty: $!";
\&    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
\&    $key = getc(TTY);        # perhaps this works
\&    # OR ELSE
\&    sysread(TTY, $key, 1);    # probably this does
\&    system "stty \-cbreak </dev/tty >/dev/tty 2>&1";
.Ve
.PP
The Term::ReadKey module from \s-1CPAN\s0 offers an easy-to-use interface that
should be more efficient than shelling out to \fBstty\fR for each key.
It even includes limited support for Windows.
.PP
.Vb 4
\&    use Term::ReadKey;
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&    $key = ReadKey(0);
\&    ReadMode(\*(Aqnormal\*(Aq);
.Ve
.PP
However, using the code requires that you have a working C compiler
and can use it to build and install a \s-1CPAN\s0 module. Here's a solution
using the standard \s-1POSIX\s0 module, which is already on your system
(assuming your system supports \s-1POSIX\s0).
.PP
.Vb 2
\&    use HotKey;
\&    $key = readkey();
.Ve
.PP
And here's the \f(CW\*(C`HotKey\*(C'\fR module, which hides the somewhat mystifying calls
to manipulate the \s-1POSIX\s0 termios structures.
.PP
.Vb 2
\&    # HotKey.pm
\&    package HotKey;
\&
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqExporter\*(Aq;
\&    our @EXPORT = qw(cbreak cooked readkey);
\&
\&    use POSIX qw(:termios_h);
\&    my ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&    $fd_stdin = fileno(STDIN);
\&    $term     = POSIX::Termios\->new();
\&    $term\->getattr($fd_stdin);
\&    $oterm     = $term\->getlflag();
\&
\&    $echo     = ECHO | ECHOK | ICANON;
\&    $noecho   = $oterm & ~$echo;
\&
\&    sub cbreak {
\&        $term\->setlflag($noecho);  # ok, so i don\*(Aqt want echo either
\&        $term\->setcc(VTIME, 1);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub cooked {
\&        $term\->setlflag($oterm);
\&        $term\->setcc(VTIME, 0);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub readkey {
\&        my $key = \*(Aq\*(Aq;
\&        cbreak();
\&        sysread(STDIN, $key, 1);
\&        cooked();
\&        return $key;
\&    }
\&
\&    END { cooked() }
\&
\&    1;
.Ve
.SS "How do I check whether input is ready on the keyboard?"
.IX Subsection "How do I check whether input is ready on the keyboard?"
The easiest way to do this is to read a key in nonblocking mode with the
Term::ReadKey module from \s-1CPAN,\s0 passing it an argument of \-1 to indicate
not to block:
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&
\&    if (defined (my $char = ReadKey(\-1)) ) {
\&        # input was waiting and it was $char
\&    } else {
\&        # no input was waiting
\&    }
\&
\&    ReadMode(\*(Aqnormal\*(Aq);                  # restore normal tty settings
.Ve
.SS "How do I clear the screen?"
.IX Subsection "How do I clear the screen?"
(contributed by brian d foy)
.PP
To clear the screen, you just have to print the special sequence
that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.
.PP
You can use the Term::ANSIScreen module to get the special
sequence. Import the \f(CW\*(C`cls\*(C'\fR function (or the \f(CW\*(C`:screen\*(C'\fR tag):
.PP
.Vb 2
\&    use Term::ANSIScreen qw(cls);
\&    my $clear_screen = cls();
\&
\&    print $clear_screen;
.Ve
.PP
The Term::Cap module can also get the special sequence if you want
to deal with the low-level details of terminal control. The \f(CW\*(C`Tputs\*(C'\fR
method returns the string for the given capability:
.PP
.Vb 1
\&    use Term::Cap;
\&
\&    my $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 } );
\&    my $clear_string = $terminal\->Tputs(\*(Aqcl\*(Aq);
\&
\&    print $clear_screen;
.Ve
.PP
On Windows, you can use the Win32::Console module. After creating
an object for the output filehandle you want to affect, call the
\&\f(CW\*(C`Cls\*(C'\fR method:
.PP
.Vb 1
\&    Win32::Console;
\&
\&    my $OUT = Win32::Console\->new(STD_OUTPUT_HANDLE);
\&    my $clear_string = $OUT\->Cls;
\&
\&    print $clear_screen;
.Ve
.PP
If you have a command-line program that does the job, you can call
it in backticks to capture whatever it outputs so you can use it
later:
.PP
.Vb 1
\&    my $clear_string = \`clear\`;
\&
\&    print $clear_string;
.Ve
.SS "How do I get the screen size?"
.IX Subsection "How do I get the screen size?"
If you have Term::ReadKey module installed from \s-1CPAN,\s0
you can use it to fetch the width and height in characters
and in pixels:
.PP
.Vb 2
\&    use Term::ReadKey;
\&    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
.Ve
.PP
This is more portable than the raw \f(CW\*(C`ioctl\*(C'\fR, but not as
illustrative:
.PP
.Vb 10
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&    die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
\&    open(my $tty_fh, "+</dev/tty")                     or die "No tty: $!";
\&    unless (ioctl($tty_fh, &TIOCGWINSZ, $winsize=\*(Aq\*(Aq)) {
\&        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\en", &TIOCGWINSZ;
\&    }
\&    my ($row, $col, $xpixel, $ypixel) = unpack(\*(AqS4\*(Aq, $winsize);
\&    print "(row,col) = ($row,$col)";
\&    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
\&    print "\en";
.Ve
.SS "How do I ask the user for a password?"
.IX Subsection "How do I ask the user for a password?"
(This question has nothing to do with the web. See a different
\&\s-1FAQ\s0 for that.)
.PP
There's an example of this in \*(L"crypt\*(R" in perlfunc). First, you put the
terminal into \*(L"no echo\*(R" mode, then just read the password normally.
You may do this with an old-style \f(CW\*(C`ioctl()\*(C'\fR function, \s-1POSIX\s0 terminal
control (see \s-1POSIX\s0 or its documentation the Camel Book), or a call
to the \fBstty\fR program, with varying degrees of portability.
.PP
You can also do this for most systems using the Term::ReadKey module
from \s-1CPAN,\s0 which is easier to use and in theory more portable.
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqnoecho\*(Aq);
\&    my $password = ReadLine(0);
.Ve
.SS "How do I read and write the serial port?"
.IX Subsection "How do I read and write the serial port?"
This depends on which operating system your program is running on. In
the case of Unix, the serial ports will be accessible through files in
\&\f(CW\*(C`/dev\*(C'\fR; on other systems, device names will doubtless differ.
Several problem areas common to all device interaction are the
following:
.IP "lockfiles" 4
.IX Item "lockfiles"
Your system may use lockfiles to control multiple access. Make sure
you follow the correct protocol. Unpredictable behavior can result
from multiple processes reading from one device.
.IP "open mode" 4
.IX Item "open mode"
If you expect to use both read and write operations on the device,
you'll have to open it for update (see \*(L"open\*(R" in perlfunc for
details). You may wish to open it without running the risk of
blocking by using \f(CW\*(C`sysopen()\*(C'\fR and \f(CW\*(C`O_RDWR|O_NDELAY|O_NOCTTY\*(C'\fR from the
Fcntl module (part of the standard perl distribution). See
\&\*(L"sysopen\*(R" in perlfunc for more on this approach.
.IP "end of line" 4
.IX Item "end of line"
Some devices will be expecting a \*(L"\er\*(R" at the end of each line rather
than a \*(L"\en\*(R". In some ports of perl, \*(L"\er\*(R" and \*(L"\en\*(R" are different from
their usual (Unix) \s-1ASCII\s0 values of \*(L"\e015\*(R" and \*(L"\e012\*(R". You may have to
give the numeric values you want directly, using octal (\*(L"\e015\*(R"), hex
(\*(L"0x0D\*(R"), or as a control-character specification (\*(L"\ecM\*(R").
.Sp
.Vb 2
\&    print DEV "atv1\e012";    # wrong, for some devices
\&    print DEV "atv1\e015";    # right, for some devices
.Ve
.Sp
Even though with normal text files a \*(L"\en\*(R" will do the trick, there is
still no unified scheme for terminating a line that is portable
between Unix, DOS/Win, and Macintosh, except to terminate \fI\s-1ALL\s0\fR line
ends with \*(L"\e015\e012\*(R", and strip what you don't need from the output.
This applies especially to socket I/O and autoflushing, discussed
next.
.IP "flushing output" 4
.IX Item "flushing output"
If you expect characters to get to your device when you \f(CW\*(C`print()\*(C'\fR them,
you'll want to autoflush that filehandle. You can use \f(CW\*(C`select()\*(C'\fR
and the \f(CW$|\fR variable to control autoflushing (see \*(L"$|\*(R" in perlvar
and \*(L"select\*(R" in perlfunc, or perlfaq5, \*(L"How do I flush/unbuffer an
output filehandle? Why must I do this?\*(R"):
.Sp
.Vb 3
\&    my $old_handle = select($dev_fh);
\&    $| = 1;
\&    select($old_handle);
.Ve
.Sp
You'll also see code that does this without a temporary variable, as in
.Sp
.Vb 1
\&    select((select($deb_handle), $| = 1)[0]);
.Ve
.Sp
Or if you don't mind pulling in a few thousand lines
of code just because you're afraid of a little \f(CW$|\fR variable:
.Sp
.Vb 2
\&    use IO::Handle;
\&    $dev_fh\->autoflush(1);
.Ve
.Sp
As mentioned in the previous item, this still doesn't work when using
socket I/O between Unix and Macintosh. You'll need to hard code your
line terminators, in that case.
.IP "non-blocking input" 4
.IX Item "non-blocking input"
If you are doing a blocking \f(CW\*(C`read()\*(C'\fR or \f(CW\*(C`sysread()\*(C'\fR, you'll have to
arrange for an alarm handler to provide a timeout (see
\&\*(L"alarm\*(R" in perlfunc). If you have a non-blocking open, you'll likely
have a non-blocking read, which means you may have to use a 4\-arg
\&\f(CW\*(C`select()\*(C'\fR to determine whether I/O is ready on that device (see
\&\*(L"select\*(R" in perlfunc.
.PP
While trying to read from his caller-id box, the notorious Jamie
Zawinski \f(CW\*(C`<jwz@netscape.com>\*(C'\fR, after much gnashing of teeth and
fighting with \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \s-1POSIX\s0's \f(CW\*(C`tcgetattr\*(C'\fR business,
and various other functions that go bump in the night, finally came up
with this:
.PP
.Vb 10
\&    sub open_modem {
\&        use IPC::Open2;
\&        my $stty = \`/bin/stty \-g\`;
\&        open2( \e*MODEM_IN, \e*MODEM_OUT, "cu \-l$modem_device \-s2400 2>&1");
\&        # starting cu hoses /dev/tty\*(Aqs stty settings, even when it has
\&        # been opened on a pipe...
\&        system("/bin/stty $stty");
\&        $_ = <MODEM_IN>;
\&        chomp;
\&        if ( !m/^Connected/ ) {
\&            print STDERR "$0: cu printed \`$_\*(Aq instead of \`Connected\*(Aq\en";
\&        }
\&    }
.Ve
.SS "How do I decode encrypted password files?"
.IX Subsection "How do I decode encrypted password files?"
You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.
.PP
Seriously, you can't if they are Unix password files\*(--the Unix
password system employs one-way encryption. It's more like hashing
than encryption. The best you can do is check whether something else
hashes to the same string. You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.
.PP
If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
\&\fIpasswd\fR\|(1), for example).
.SS "How do I start a process in the background?"
.IX Subsection "How do I start a process in the background?"
(contributed by brian d foy)
.PP
There's not a single way to run code in the background so you don't
have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are covered in perlipc.
.PP
Several \s-1CPAN\s0 modules may be able to help, including IPC::Open2 or
IPC::Open3, IPC::Run, Parallel::Jobs,
Parallel::ForkManager, \s-1POE\s0, Proc::Background, and
Win32::Process. There are many other modules you might use, so
check those namespaces for other options too.
.PP
If you are on a Unix-like system, you might be able to get away with a
system call where you put an \f(CW\*(C`&\*(C'\fR on the end of the command:
.PP
.Vb 1
\&    system("cmd &")
.Ve
.PP
You can also try using \f(CW\*(C`fork\*(C'\fR, as described in perlfunc (although
this is the same thing that many of the modules will do for you).
.IP "\s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 are shared" 4
.IX Item "STDIN, STDOUT, and STDERR are shared"
Both the main process and the backgrounded one (the \*(L"child\*(R" process)
share the same \s-1STDIN, STDOUT\s0 and \s-1STDERR\s0 filehandles. If both try to
access them at once, strange things can happen. You may want to close
or reopen these for the child. You can get around this with
\&\f(CW\*(C`open\*(C'\fRing a pipe (see \*(L"open\*(R" in perlfunc) but on some systems this
means that the child process cannot outlive the parent.
.IP "Signals" 4
.IX Item "Signals"
You'll have to catch the \s-1SIGCHLD\s0 signal, and possibly \s-1SIGPIPE\s0 too.
\&\s-1SIGCHLD\s0 is sent when the backgrounded process finishes. \s-1SIGPIPE\s0 is
sent when you write to a filehandle whose child process has closed (an
untrapped \s-1SIGPIPE\s0 can cause your program to silently die). This is
not an issue with \f(CW\*(C`system("cmd&")\*(C'\fR.
.IP "Zombies" 4
.IX Item "Zombies"
You have to be prepared to \*(L"reap\*(R" the child process when it finishes.
.Sp
.Vb 1
\&    $SIG{CHLD} = sub { wait };
\&
\&    $SIG{CHLD} = \*(AqIGNORE\*(Aq;
.Ve
.Sp
You can also use a double fork. You immediately \f(CW\*(C`wait()\*(C'\fR for your
first child, and the init daemon will \f(CW\*(C`wait()\*(C'\fR for your grandchild once
it exits.
.Sp
.Vb 8
\&    unless ($pid = fork) {
\&        unless (fork) {
\&            exec "what you really wanna do";
\&            die "exec failed!";
\&        }
\&        exit 0;
\&    }
\&    waitpid($pid, 0);
.Ve
.Sp
See \*(L"Signals\*(R" in perlipc for other examples of code to do this.
Zombies are not an issue with \f(CW\*(C`system("prog &")\*(C'\fR.
.SS "How do I trap control characters/signals?"
.IX Subsection "How do I trap control characters/signals?"
You don't actually \*(L"trap\*(R" a control character. Instead, that character
generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in \*(L"Signals\*(R" in perlipc and the
section on \*(L"Signals\*(R" in the Camel.
.PP
You can set the values of the \f(CW%SIG\fR hash to be the functions you want
to handle the signal. After perl catches the signal, it looks in \f(CW%SIG\fR
for a key with the same name as the signal, then calls the subroutine
value for that key.
.PP
.Vb 1
\&    # as an anonymous subroutine
\&
\&    $SIG{INT} = sub { syswrite(STDERR, "ouch\en", 5 ) };
\&
\&    # or a reference to a function
\&
\&    $SIG{INT} = \e&ouch;
\&
\&    # or the name of the function as a string
\&
\&    $SIG{INT} = "ouch";
.Ve
.PP
Perl versions before 5.8 had in its C source code signal handlers which
would catch the signal and possibly run a Perl function that you had set
in \f(CW%SIG\fR. This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at \f(CW%SIG\fR
\&\fBafter\fR the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.
.SS "How do I modify the shadow password file on a Unix system?"
.IX Subsection "How do I modify the shadow password file on a Unix system?"
If perl was installed correctly and your shadow library was written
properly, the \f(CW\*(C`getpw*()\*(C'\fR functions described in perlfunc should in
theory provide (read-only) access to entries in the shadow password
file. To change the file, make a new shadow password file (the format
varies from system to system\*(--see \fIpasswd\fR\|(1) for specifics) and use
\&\f(CWpwd_mkdb(8)\fR to install it (see \fIpwd_mkdb\fR\|(8) for more details).
.SS "How do I set the time and date?"
.IX Subsection "How do I set the time and date?"
Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the \f(CWdate(1)\fR
program. (There is no way to set the time and date on a per-process
basis.)  This mechanism will work for Unix, MS-DOS, Windows, and \s-1NT\s0;
the \s-1VMS\s0 equivalent is \f(CW\*(C`set time\*(C'\fR.
.PP
However, if all you want to do is change your time zone, you can
probably get away with setting an environment variable:
.PP
.Vb 3
\&    $ENV{TZ} = "MST7MDT";           # Unixish
\&    $ENV{\*(AqSYS$TIMEZONE_DIFFERENTIAL\*(Aq}="\-5" # vms
\&    system(\*(Aqtrn\*(Aq, \*(Aqcomp.lang.perl.misc\*(Aq);
.Ve
.SS "How can I \fIsleep()\fP or \fIalarm()\fP for under a second?"
.IX Xref "Time::HiRes BSD::Itimer sleep select"
.IX Subsection "How can I sleep() or alarm() for under a second?"
If you want finer granularity than the 1 second that the \f(CW\*(C`sleep()\*(C'\fR
function provides, the easiest way is to use the \f(CW\*(C`select()\*(C'\fR function as
documented in \*(L"select\*(R" in perlfunc. Try the Time::HiRes and
the BSD::Itimer modules (available from \s-1CPAN,\s0 and starting from
Perl 5.8 Time::HiRes is part of the standard distribution).
.SS "How can I measure time under a second?"
.IX Xref "Time::HiRes BSD::Itimer sleep select"
.IX Subsection "How can I measure time under a second?"
(contributed by brian d foy)
.PP
The Time::HiRes module (part of the standard distribution as of
Perl 5.8) measures time with the \f(CW\*(C`gettimeofday()\*(C'\fR system call, which
returns the time in microseconds since the epoch. If you can't install
Time::HiRes for older Perls and you are on a Unixish system, you
may be able to call \f(CWgettimeofday(2)\fR directly. See
\&\*(L"syscall\*(R" in perlfunc.
.SS "How can I do an \fIatexit()\fP or \fIsetjmp()\fP/\fIlongjmp()\fP? (Exception handling)"
.IX Subsection "How can I do an atexit() or setjmp()/longjmp()? (Exception handling)"
You can use the \f(CW\*(C`END\*(C'\fR block to simulate \f(CW\*(C`atexit()\*(C'\fR. Each package's
\&\f(CW\*(C`END\*(C'\fR block is called when the program or thread ends. See the perlmod
manpage for more details about \f(CW\*(C`END\*(C'\fR blocks.
.PP
For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:
.PP
.Vb 3
\&    END {
\&        close(STDOUT) || die "stdout close failed: $!";
\&    }
.Ve
.PP
The \f(CW\*(C`END\*(C'\fR block isn't called when untrapped signals kill the program,
though, so if you use \f(CW\*(C`END\*(C'\fR blocks you should also use
.PP
.Vb 1
\&    use sigtrap qw(die normal\-signals);
.Ve
.PP
Perl's exception-handling mechanism is its \f(CW\*(C`eval()\*(C'\fR operator. You
can use \f(CW\*(C`eval()\*(C'\fR as \f(CW\*(C`setjmp\*(C'\fR and \f(CW\*(C`die()\*(C'\fR as \f(CW\*(C`longjmp\*(C'\fR. For
details of this, see the section on signals, especially the time-out
handler for a blocking \f(CW\*(C`flock()\*(C'\fR in \*(L"Signals\*(R" in perlipc or the
section on \*(L"Signals\*(R" in \fIProgramming Perl\fR.
.PP
If exception handling is all you're interested in, use one of the
many \s-1CPAN\s0 modules that handle exceptions, such as Try::Tiny.
.PP
If you want the \f(CW\*(C`atexit()\*(C'\fR syntax (and an \f(CW\*(C`rmexit()\*(C'\fR as well), try the
\&\f(CW\*(C`AtExit\*(C'\fR module available from \s-1CPAN.\s0
.ie n .SS "Why doesn't my sockets program work under System V (Solaris)? What does the error message ""Protocol not supported"" mean?"
.el .SS "Why doesn't my sockets program work under System V (Solaris)? What does the error message ``Protocol not supported'' mean?"
.IX Subsection "Why doesn't my sockets program work under System V (Solaris)? What does the error message Protocol not supported mean?"
Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants. Since these were constant across all
architectures, they were often hardwired into perl code. The proper
way to deal with this is to \*(L"use Socket\*(R" to get the correct values.
.PP
Note that even though SunOS and Solaris are binary compatible, these
values are different. Go figure.
.SS "How can I call my system's unique C functions from Perl?"
.IX Subsection "How can I call my system's unique C functions from Perl?"
In most cases, you write an external module to do it\*(--see the answer
to \*(L"Where can I learn about linking C with Perl? [h2xs, xsubpp]\*(R".
However, if the function is a system call, and your system supports
\&\f(CW\*(C`syscall()\*(C'\fR, you can use the \f(CW\*(C`syscall\*(C'\fR function (documented in
perlfunc).
.PP
Remember to check the modules that came with your distribution, and
\&\s-1CPAN\s0 as well\*(--someone may already have written a module to do it. On
Windows, try Win32::API. On Macs, try Mac::Carbon. If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with Inline::C.
.SS "Where do I get the include files to do \fIioctl()\fP or \fIsyscall()\fP?"
.IX Subsection "Where do I get the include files to do ioctl() or syscall()?"
Historically, these would be generated by the h2ph tool, part of the
standard perl distribution. This program converts \f(CWcpp(1)\fR directives
in C header files to files containing subroutine definitions, like
\&\f(CW\*(C`SYS_getitimer()\*(C'\fR, which you can use as arguments to your functions.
It doesn't work perfectly, but it usually gets most of the job done.
Simple files like \fIerrno.h\fR, \fIsyscall.h\fR, and \fIsocket.h\fR were fine,
but the hard ones like \fIioctl.h\fR nearly always need to be hand-edited.
Here's how to install the *.ph files:
.PP
.Vb 3
\&    1. Become the super\-user
\&    2. cd /usr/include
\&    3. h2ph *.h */*.h
.Ve
.PP
If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use h2xs (also part of the standard perl
distribution). This tool converts C header files to Perl extensions.
See perlxstut for how to get started with h2xs.
.PP
If your system doesn't support dynamic loading, you still probably
ought to use h2xs. See perlxstut and ExtUtils::MakeMaker for
more information (in brief, just use \fBmake perl\fR instead of a plain
\&\fBmake\fR to rebuild perl with a new static extension).
.SS "Why do setuid perl scripts complain about kernel problems?"
.IX Subsection "Why do setuid perl scripts complain about kernel problems?"
Some operating systems have bugs in the kernel that make setuid
scripts inherently insecure. Perl gives you a number of options
(described in perlsec) to work around such systems.
.SS "How can I open a pipe both to and from a command?"
.IX Subsection "How can I open a pipe both to and from a command?"
The IPC::Open2 module (part of the standard perl distribution) is
an easy-to-use approach that internally uses \f(CW\*(C`pipe()\*(C'\fR, \f(CW\*(C`fork()\*(C'\fR, and
\&\f(CW\*(C`exec()\*(C'\fR to do the job. Make sure you read the deadlock warnings in
its documentation, though (see IPC::Open2). See
\&\*(L"Bidirectional Communication with Another Process\*(R" in perlipc and
\&\*(L"Bidirectional Communication with Yourself\*(R" in perlipc
.PP
You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from IPC::Open2 (see IPC::Open3).
.SS "Why can't I get the output of a command with \fIsystem()\fP?"
.IX Subsection "Why can't I get the output of a command with system()?"
You're confusing the purpose of \f(CW\*(C`system()\*(C'\fR and backticks (``). \f(CW\*(C`system()\*(C'\fR
runs a command and returns exit status information (as a 16 bit value:
the low 7 bits are the signal the process died from, if any, and
the high 8 bits are the actual exit value). Backticks (``) run a
command and return what it sent to \s-1STDOUT.\s0
.PP
.Vb 2
\&    my $exit_status   = system("mail\-users");
\&    my $output_string = \`ls\`;
.Ve
.SS "How can I capture \s-1STDERR\s0 from an external command?"
.IX Subsection "How can I capture STDERR from an external command?"
There are three basic ways of running external commands:
.PP
.Vb 3
\&    system $cmd;        # using system()
\&    my $output = \`$cmd\`;        # using backticks (\`\`)
\&    open (my $pipe_fh, "$cmd |");    # using open()
.Ve
.PP
With \f(CW\*(C`system()\*(C'\fR, both \s-1STDOUT\s0 and \s-1STDERR\s0 will go the same place as the
script's \s-1STDOUT\s0 and \s-1STDERR,\s0 unless the \f(CW\*(C`system()\*(C'\fR command redirects them.
Backticks and \f(CW\*(C`open()\*(C'\fR read \fBonly\fR the \s-1STDOUT\s0 of your command.
.PP
You can also use the \f(CW\*(C`open3()\*(C'\fR function from IPC::Open3. Benjamin
Goldberg provides some sample code:
.PP
To capture a program's \s-1STDOUT,\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    my $pid = open3(gensym, \e*PH, ">&NULL", "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a program's \s-1STDERR,\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    my $pid = open3(gensym, ">&NULL", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a program's \s-1STDERR,\s0 and let its \s-1STDOUT\s0 go to our own \s-1STDERR:\s0
.PP
.Vb 5
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    my $pid = open3(gensym, ">&STDERR", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To read both a command's \s-1STDOUT\s0 and its \s-1STDERR\s0 separately, you can
redirect them to temp files, let the command run, then read the temp
files:
.PP
.Vb 10
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHOUT = IO::File\->new_tmpfile;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
\&    waitpid($pid, 0);
\&    seek $_, 0, 0 for \e*CATCHOUT, \e*CATCHERR;
\&    while( <CATCHOUT> ) {}
\&    while( <CATCHERR> ) {}
.Ve
.PP
But there's no real need for \fBboth\fR to be tempfiles... the following
should work just as well, without deadlocking:
.PP
.Vb 9
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    my $pid = open3(gensym, \e*CATCHOUT, ">&CATCHERR", "cmd");
\&    while( <CATCHOUT> ) {}
\&    waitpid($pid, 0);
\&    seek CATCHERR, 0, 0;
\&    while( <CATCHERR> ) {}
.Ve
.PP
And it'll be faster, too, since we can begin processing the program's
stdout immediately, rather than waiting for the program to finish.
.PP
With any of these, you can change file descriptors before the call:
.PP
.Vb 2
\&    open(STDOUT, ">logfile");
\&    system("ls");
.Ve
.PP
or you can use Bourne shell file-descriptor redirection:
.PP
.Vb 2
\&    $output = \`$cmd 2>some_file\`;
\&    open (PIPE, "cmd 2>some_file |");
.Ve
.PP
You can also use file-descriptor redirection to make \s-1STDERR\s0 a
duplicate of \s-1STDOUT:\s0
.PP
.Vb 2
\&    $output = \`$cmd 2>&1\`;
\&    open (PIPE, "cmd 2>&1 |");
.Ve
.PP
Note that you \fIcannot\fR simply open \s-1STDERR\s0 to be a dup of \s-1STDOUT\s0
in your Perl program and avoid calling the shell to do the redirection.
This doesn't work:
.PP
.Vb 2
\&    open(STDERR, ">&STDOUT");
\&    $alloutput = \`cmd args\`;  # stderr still escapes
.Ve
.PP
This fails because the \f(CW\*(C`open()\*(C'\fR makes \s-1STDERR\s0 go to where \s-1STDOUT\s0 was
going at the time of the \f(CW\*(C`open()\*(C'\fR. The backticks then make \s-1STDOUT\s0 go to
a string, but don't change \s-1STDERR \s0(which still goes to the old
\&\s-1STDOUT\s0).
.PP
Note that you \fImust\fR use Bourne shell (\f(CWsh(1)\fR) redirection syntax in
backticks, not \f(CWcsh(1)\fR!  Details on why Perl's \f(CW\*(C`system()\*(C'\fR and backtick
and pipe opens all use the Bourne shell are in the
\&\fIversus/csh.whynot\fR article in the \*(L"Far More Than You Ever Wanted To
Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> . To
capture a command's \s-1STDERR\s0 and \s-1STDOUT\s0 together:
.PP
.Vb 3
\&    $output = \`cmd 2>&1\`;                       # either with backticks
\&    $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a command's \s-1STDOUT\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>/dev/null\`;                # either with backticks
\&    $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a command's \s-1STDERR\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>&1 1>/dev/null\`;           # either with backticks
\&    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To exchange a command's \s-1STDOUT\s0 and \s-1STDERR\s0 in order to capture the \s-1STDERR\s0
but leave its \s-1STDOUT\s0 to come out our old \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 3>&1 1>&2 2>&3 3>&\-\`;        # either with backticks
\&    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&\-|");# or with an open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To read both a command's \s-1STDOUT\s0 and its \s-1STDERR\s0 separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:
.PP
.Vb 1
\&    system("program args 1>program.stdout 2>program.stderr");
.Ve
.PP
Ordering is important in all these examples. That's because the shell
processes file descriptor redirections in strictly left to right order.
.PP
.Vb 2
\&    system("prog args 1>tmpfile 2>&1");
\&    system("prog args 2>&1 1>tmpfile");
.Ve
.PP
The first command sends both standard out and standard error to the
temporary file. The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.
.SS "Why doesn't \fIopen()\fP return an error when a pipe open fails?"
.IX Subsection "Why doesn't open() return an error when a pipe open fails?"
If the second argument to a piped \f(CW\*(C`open()\*(C'\fR contains shell
metacharacters, perl \f(CW\*(C`fork()\*(C'\fRs, then \f(CW\*(C`exec()\*(C'\fRs a shell to decode the
metacharacters and eventually run the desired program. If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started. You can still capture the shell's \s-1STDERR\s0 and
check it for error messages. See \*(L"How can I capture \s-1STDERR\s0 from an
external command?\*(R" elsewhere in this document, or use the
IPC::Open3 module.
.PP
If there are no shell metacharacters in the argument of \f(CW\*(C`open()\*(C'\fR, Perl
runs the command directly, without using the shell, and can correctly
report whether the command started.
.SS "What's wrong with using backticks in a void context?"
.IX Subsection "What's wrong with using backticks in a void context?"
Strictly speaking, nothing. Stylistically speaking, it's not a good
way to write maintainable code. Perl has several operators for
running external commands. Backticks are one; they collect the output
from the command for use in your program. The \f(CW\*(C`system\*(C'\fR function is
another; it doesn't do this.
.PP
Writing backticks in your program sends a clear message to the readers
of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?
.PP
Consider this line:
.PP
.Vb 1
\&    \`cat /etc/termcap\`;
.Ve
.PP
You forgot to check \f(CW$?\fR to see whether the program even ran
correctly. Even if you wrote
.PP
.Vb 1
\&    print \`cat /etc/termcap\`;
.Ve
.PP
this code could and probably should be written as
.PP
.Vb 2
\&    system("cat /etc/termcap") == 0
\&    or die "cat program failed!";
.Ve
.PP
which will echo the cat command's output as it is generated, instead
of waiting until the program has completed to print it out. It also
checks the return value.
.PP
\&\f(CW\*(C`system\*(C'\fR also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.
.SS "How can I call backticks without shell processing?"
.IX Subsection "How can I call backticks without shell processing?"
This is a bit tricky. You can't simply write the command
like this:
.PP
.Vb 1
\&    @ok = \`grep @opts \*(Aq$search_string\*(Aq @filenames\`;
.Ve
.PP
As of Perl 5.8.0, you can use \f(CW\*(C`open()\*(C'\fR with multiple arguments.
Just like the list forms of \f(CW\*(C`system()\*(C'\fR and \f(CW\*(C`exec()\*(C'\fR, no shell
escapes happen.
.PP
.Vb 3
\&    open( GREP, "\-|", \*(Aqgrep\*(Aq, @opts, $search_string, @filenames );
\&    chomp(@ok = <GREP>);
\&    close GREP;
.Ve
.PP
You can also:
.PP
.Vb 10
\&    my @ok = ();
\&    if (open(GREP, "\-|")) {
\&        while (<GREP>) {
\&            chomp;
\&            push(@ok, $_);
\&        }
\&        close GREP;
\&    } else {
\&        exec \*(Aqgrep\*(Aq, @opts, $search_string, @filenames;
\&    }
.Ve
.PP
Just as with \f(CW\*(C`system()\*(C'\fR, no shell escapes happen when you \f(CW\*(C`exec()\*(C'\fR a
list. Further examples of this can be found in \*(L"Safe Pipe
Opens\*(R" in perlipc.
.PP
Note that if you're using Windows, no solution to this vexing issue is
even possible. Even though Perl emulates \f(CW\*(C`fork()\*(C'\fR, you'll still be
stuck, because Windows does not have an argc/argv\-style \s-1API.\s0
.SS "Why can't my script read from \s-1STDIN\s0 after I gave it \s-1EOF \s0(^D on Unix, ^Z on MS-DOS)?"
.IX Subsection "Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?"
This happens only if your perl is compiled to use stdio instead of
perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The \s-1POSIX\s0 module defines
\&\f(CW\*(C`clearerr()\*(C'\fR that you can use. That is the technically correct way to
do it. Here are some less reliable workarounds:
.IP "1." 4
Try keeping around the seekpointer and go there, like this:
.Sp
.Vb 2
\&    my $where = tell($log_fh);
\&    seek($log_fh, $where, 0);
.Ve
.IP "2." 4
If that doesn't work, try seeking to a different part of the file and
then back.
.IP "3." 4
If that doesn't work, try seeking to a different part of
the file, reading something, and then seeking back.
.IP "4." 4
If that doesn't work, give up on your stdio package and use sysread.
.SS "How can I convert my shell script to perl?"
.IX Subsection "How can I convert my shell script to perl?"
Learn Perl and rewrite it. Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell\->perl converter
nigh-on impossible to write. By rewriting it, you'll think about what
you're really trying to do, and hopefully will escape the shell's
pipeline datastream paradigm, which while convenient for some matters,
causes many inefficiencies.
.SS "Can I use perl to run a telnet or ftp session?"
.IX Subsection "Can I use perl to run a telnet or ftp session?"
Try the Net::FTP, TCP::Client, and Net::Telnet modules
(available from \s-1CPAN\s0).
<http://www.cpan.org/scripts/netstuff/telnet.emul.shar> will also help
for emulating the telnet protocol, but Net::Telnet is quite
probably easier to use.
.PP
If all you want to do is pretend to be telnet but don't need
the initial telnet handshaking, then the standard dual-process
approach will suffice:
.PP
.Vb 12
\&    use IO::Socket;             # new in 5.004
\&    my $handle = IO::Socket::INET\->new(\*(Aqwww.perl.com:80\*(Aq)
\&        or die "can\*(Aqt connect to port 80 on www.perl.com $!";
\&    $handle\->autoflush(1);
\&    if (fork()) {               # XXX: undef means failure
\&        select($handle);
\&        print while <STDIN>;    # everything from stdin to socket
\&    } else {
\&        print while <$handle>;  # everything from socket to stdout
\&    }
\&    close $handle;
\&    exit;
.Ve
.SS "How can I write expect in Perl?"
.IX Subsection "How can I write expect in Perl?"
Once upon a time, there was a library called \fIchat2.pl\fR (part of the
standard perl distribution), which never really got finished. If you
find it somewhere, \fIdon't use it\fR. These days, your best bet is to
look at the Expect module available from \s-1CPAN,\s0 which also requires two
other modules from \s-1CPAN, \s0IO::Pty and IO::Stty.
.ie n .SS "Is there a way to hide perl's command line from programs such as ""ps""?"
.el .SS "Is there a way to hide perl's command line from programs such as ``ps''?"
.IX Subsection "Is there a way to hide perl's command line from programs such as ps?"
First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite
your program so that critical information is never given as an
argument. Hiding the arguments won't make your program completely
secure.
.PP
To actually alter the visible command line, you can assign to the
variable \f(CW$0\fR as documented in perlvar. This won't work on all
operating systems, though. Daemon programs like sendmail place their
state there, as in:
.PP
.Vb 1
\&    $0 = "orcus [accepting connections]";
.Ve
.SS "I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?"
.IX Subsection "I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?"
.IP "Unix" 4
.IX Item "Unix"
In the strictest sense, it can't be done\*(--the script executes as a
different process from the shell it was started from. Changes to a
process are not reflected in its parent\*(--only in any children
created after the change. There is shell magic that may allow you to
fake it by \f(CW\*(C`eval()\*(C'\fRing the script's output in your shell; check out the
comp.unix.questions \s-1FAQ\s0 for details.
.SS "How do I close a process's filehandle without waiting for it to complete?"
.IX Subsection "How do I close a process's filehandle without waiting for it to complete?"
Assuming your system supports such things, just send an appropriate signal
to the process (see \*(L"kill\*(R" in perlfunc). It's common to first send a \s-1TERM\s0
signal, wait a little bit, and then send a \s-1KILL\s0 signal to finish it off.
.SS "How do I fork a daemon process?"
.IX Subsection "How do I fork a daemon process?"
If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most
Unixish systems. Non-Unix users should check their Your_OS::Process
module for other solutions.
.IP "\(bu" 4
Open /dev/tty and use the \s-1TIOCNOTTY\s0 ioctl on it. See \fItty\fR\|(1)
for details. Or better yet, you can just use the \f(CW\*(C`POSIX::setsid()\*(C'\fR
function, so you don't have to worry about process groups.
.IP "\(bu" 4
Change directory to /
.IP "\(bu" 4
Reopen \s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 so they're not connected to the old
tty.
.IP "\(bu" 4
Background yourself like this:
.Sp
.Vb 1
\&    fork && exit;
.Ve
.PP
The Proc::Daemon module, available from \s-1CPAN,\s0 provides a function to
perform these actions for you.
.SS "How do I find out if I'm running interactively or not?"
.IX Subsection "How do I find out if I'm running interactively or not?"
(contributed by brian d foy)
.PP
This is a difficult question to answer, and the best answer is
only a guess.
.PP
What do you really want to know? If you merely want to know if one of
your filehandles is connected to a terminal, you can try the \f(CW\*(C`\-t\*(C'\fR
file test:
.PP
.Vb 3
\&    if( \-t STDOUT ) {
\&        print "I\*(Aqm connected to a terminal!\en";
\&    }
.Ve
.PP
However, you might be out of luck if you expect that means there is a
real person on the other side. With the Expect module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.
.PP
The IO::Interactive module does the best it can to give you an
answer. Its \f(CW\*(C`is_interactive\*(C'\fR function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:
.PP
.Vb 1
\&    use IO::Interactive;
\&
\&    print { is_interactive } "I might go to standard output!\en";
.Ve
.PP
This still doesn't guarantee that a real person is answering your
prompts or reading your output.
.PP
If you want to know how to handle automated testing for your
distribution, you can check the environment. The \s-1CPAN\s0
Testers, for instance, set the value of \f(CW\*(C`AUTOMATED_TESTING\*(C'\fR:
.PP
.Vb 3
\&    unless( $ENV{AUTOMATED_TESTING} ) {
\&        print "Hello interactive tester!\en";
\&    }
.Ve
.SS "How do I timeout a slow event?"
.IX Subsection "How do I timeout a slow event?"
Use the \f(CW\*(C`alarm()\*(C'\fR function, probably in conjunction with a signal
handler, as documented in \*(L"Signals\*(R" in perlipc and the section on
\&\*(L"Signals\*(R" in the Camel. You may instead use the more flexible
Sys::AlarmCall module available from \s-1CPAN.\s0
.PP
The \f(CW\*(C`alarm()\*(C'\fR function is not implemented on all versions of Windows.
Check the documentation for your specific version of Perl.
.SS "How do I set \s-1CPU\s0 limits?"
.IX Xref "BSD::Resource limit CPU"
.IX Subsection "How do I set CPU limits?"
(contributed by Xho)
.PP
Use the BSD::Resource module from \s-1CPAN.\s0 As an example:
.PP
.Vb 2
\&    use BSD::Resource;
\&    setrlimit(RLIMIT_CPU,10,20) or die $!;
.Ve
.PP
This sets the soft and hard limits to 10 and 20 seconds, respectively.
After 10 seconds of time spent running on the \s-1CPU \s0(not \*(L"wall\*(R" time),
the process will be sent a signal (\s-1XCPU\s0 on some systems) which, if not
trapped, will cause the process to terminate. If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.
.PP
See the BSD::Resource and your systems documentation for the gory
details.
.SS "How do I avoid zombies on a Unix system?"
.IX Subsection "How do I avoid zombies on a Unix system?"
Use the reaper code from \*(L"Signals\*(R" in perlipc to call \f(CW\*(C`wait()\*(C'\fR when a
\&\s-1SIGCHLD\s0 is received, or else use the double-fork technique described
in \*(L"How do I start a process in the background?\*(R" in perlfaq8.
.SS "How do I use an \s-1SQL\s0 database?"
.IX Subsection "How do I use an SQL database?"
The \s-1DBI\s0 module provides an abstract interface to most database
servers and types, including Oracle, \s-1DB2,\s0 Sybase, mysql, Postgresql,
\&\s-1ODBC,\s0 and flat files. The \s-1DBI\s0 module accesses each database type
through a database driver, or \s-1DBD.\s0 You can see a complete list of
available drivers on \s-1CPAN: \s0<http://www.cpan.org/modules/by\-module/DBD/> .
You can read more about \s-1DBI\s0 on <http://dbi.perl.org/> .
.PP
Other modules provide more specific access: Win32::ODBC, Alzabo,
\&\f(CW\*(C`iodbc\*(C'\fR, and others found on \s-1CPAN\s0 Search: <http://search.cpan.org/> .
.SS "How do I make a \fIsystem()\fP exit on control-C?"
.IX Subsection "How do I make a system() exit on control-C?"
You can't. You need to imitate the \f(CW\*(C`system()\*(C'\fR call (see perlipc for
sample code) and then have a signal handler for the \s-1INT\s0 signal that
passes the signal on to the subprocess. Or you can check for it:
.PP
.Vb 2
\&    $rc = system($cmd);
\&    if ($rc & 127) { die "signal death" }
.Ve
.SS "How do I open a file without blocking?"
.IX Subsection "How do I open a file without blocking?"
If you're lucky enough to be using a system that supports
non-blocking reads (most Unixish systems do), you need only to use the
\&\f(CW\*(C`O_NDELAY\*(C'\fR or \f(CW\*(C`O_NONBLOCK\*(C'\fR flag from the \f(CW\*(C`Fcntl\*(C'\fR module in conjunction with
\&\f(CW\*(C`sysopen()\*(C'\fR:
.PP
.Vb 3
\&    use Fcntl;
\&    sysopen(my $fh, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
\&        or die "can\*(Aqt open /foo/somefile: $!":
.Ve
.SS "How do I tell the difference between errors from the shell and perl?"
.IX Subsection "How do I tell the difference between errors from the shell and perl?"
(answer contributed by brian d foy)
.PP
When you run a Perl script, something else is running the script for you,
and that something else may output error messages. The script might
emit its own warnings and error messages. Most of the time you cannot
tell who said what.
.PP
You probably cannot fix the thing that runs perl, but you can change how
perl outputs its warnings by defining a custom warning and die functions.
.PP
Consider this script, which has an error you may not notice immediately.
.PP
.Vb 1
\&    #!/usr/locl/bin/perl
\&
\&    print "Hello World\en";
.Ve
.PP
I get an error when I run this from my shell (which happens to be
bash). That may look like perl forgot it has a \f(CW\*(C`print()\*(C'\fR function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.
.PP
.Vb 2
\&    $ ./test
\&    ./test: line 3: print: command not found
.Ve
.PP
A quick and dirty fix involves a little bit of code, but this may be all
you need to figure out the problem.
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    BEGIN {
\&        $SIG{_\|_WARN_\|_} = sub{ print STDERR "Perl: ", @_; };
\&        $SIG{_\|_DIE_\|_}  = sub{ print STDERR "Perl: ", @_; exit 1};
\&    }
\&
\&    $a = 1 + undef;
\&    $x / 0;
\&    _\|_END_\|_
.Ve
.PP
The perl message comes out with \*(L"Perl\*(R" in front. The \f(CW\*(C`BEGIN\*(C'\fR block
works at compile time so all of the compilation errors and warnings
get the \*(L"Perl:\*(R" prefix too.
.PP
.Vb 7
\&    Perl: Useless use of division (/) in void context at ./test line 9.
\&    Perl: Name "main::a" used only once: possible typo at ./test line 8.
\&    Perl: Name "main::x" used only once: possible typo at ./test line 9.
\&    Perl: Use of uninitialized value in addition (+) at ./test line 8.
\&    Perl: Use of uninitialized value in division (/) at ./test line 9.
\&    Perl: Illegal division by zero at ./test line 9.
\&    Perl: Illegal division by zero at \-e line 3.
.Ve
.PP
If I don't see that \*(L"Perl:\*(R", it's not from perl.
.PP
You could also just know all the perl errors, and although there are
some people who may know all of them, you probably don't. However, they
all should be in the perldiag manpage. If you don't find the error in
there, it probably isn't a perl error.
.PP
Looking up every message is not the easiest way, so let perl to do it
for you. Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
If you don't get a paragraph or two of expanded discussion, it
might not be perl's message.
.SS "How do I install a module from \s-1CPAN\s0?"
.IX Subsection "How do I install a module from CPAN?"
(contributed by brian d foy)
.PP
The easiest way is to have a module also named \s-1CPAN\s0 do it for you by using
the \f(CW\*(C`cpan\*(C'\fR command that comes with Perl. You can give it a list of modules
to install:
.PP
.Vb 1
\&    $ cpan IO::Interactive Getopt::Whatever
.Ve
.PP
If you prefer \f(CW\*(C`CPANPLUS\*(C'\fR, it's just as easy:
.PP
.Vb 1
\&    $ cpanp i IO::Interactive Getopt::Whatever
.Ve
.PP
If you want to install a distribution from the current directory, you can
tell \f(CW\*(C`CPAN.pm\*(C'\fR to install \f(CW\*(C`.\*(C'\fR (the full stop):
.PP
.Vb 1
\&    $ cpan .
.Ve
.PP
See the documentation for either of those commands to see what else
you can do.
.PP
If you want to try to install a distribution by yourself, resolving
all dependencies on your own, you follow one of two possible build
paths.
.PP
For distributions that use \fIMakefile.PL\fR:
.PP
.Vb 2
\&    $ perl Makefile.PL
\&    $ make test install
.Ve
.PP
For distributions that use \fIBuild.PL\fR:
.PP
.Vb 3
\&    $ perl Build.PL
\&    $ ./Build test
\&    $ ./Build install
.Ve
.PP
Some distributions may need to link to libraries or other third-party
code and their build and installation sequences may be more complicated.
Check any \fI\s-1README\s0\fR or \fI\s-1INSTALL\s0\fR files that you may find.
.SS "What's the difference between require and use?"
.IX Subsection "What's the difference between require and use?"
(contributed by brian d foy)
.PP
Perl runs \f(CW\*(C`require\*(C'\fR statement at run-time. Once Perl loads, compiles,
and runs the file, it doesn't do anything else. The \f(CW\*(C`use\*(C'\fR statement
is the same as a \f(CW\*(C`require\*(C'\fR run at compile-time, but Perl also calls the
\&\f(CW\*(C`import\*(C'\fR method for the loaded package. These two are the same:
.PP
.Vb 1
\&    use MODULE qw(import list);
\&
\&    BEGIN {
\&        require MODULE;
\&        MODULE\->import(import list);
\&    }
.Ve
.PP
However, you can suppress the \f(CW\*(C`import\*(C'\fR by using an explicit, empty
import list. Both of these still happen at compile-time:
.PP
.Vb 1
\&    use MODULE ();
\&
\&    BEGIN {
\&        require MODULE;
\&    }
.Ve
.PP
Since \f(CW\*(C`use\*(C'\fR will also call the \f(CW\*(C`import\*(C'\fR method, the actual value
for \f(CW\*(C`MODULE\*(C'\fR must be a bareword. That is, \f(CW\*(C`use\*(C'\fR cannot load files
by name, although \f(CW\*(C`require\*(C'\fR can:
.PP
.Vb 1
\&    require "$ENV{HOME}/lib/Foo.pm"; # no @INC searching!
.Ve
.PP
See the entry for \f(CW\*(C`use\*(C'\fR in perlfunc for more details.
.SS "How do I keep my own module/library directory?"
.IX Subsection "How do I keep my own module/library directory?"
When you build modules, tell Perl where to install the modules.
.PP
If you want to install modules for your own use, the easiest way might
be local::lib, which you can download from \s-1CPAN.\s0 It sets various
installation settings for you, and uses those same settings within
your programs.
.PP
If you want more flexibility, you need to configure your \s-1CPAN\s0 client
for your particular situation.
.PP
For \f(CW\*(C`Makefile.PL\*(C'\fR\-based distributions, use the \s-1INSTALL_BASE\s0 option
when generating Makefiles:
.PP
.Vb 1
\&    perl Makefile.PL INSTALL_BASE=/mydir/perl
.Ve
.PP
You can set this in your \f(CW\*(C`CPAN.pm\*(C'\fR configuration so modules
automatically install in your private library directory when you use
the \s-1CPAN\s0.pm shell:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
\&    cpan> o conf commit
.Ve
.PP
For \f(CW\*(C`Build.PL\*(C'\fR\-based distributions, use the \-\-install_base option:
.PP
.Vb 1
\&    perl Build.PL \-\-install_base /mydir/perl
.Ve
.PP
You can configure \f(CW\*(C`CPAN.pm\*(C'\fR to automatically use this option too:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf mbuild_arg "\-\-install_base /mydir/perl"
\&    cpan> o conf commit
.Ve
.PP
\&\s-1INSTALL_BASE\s0 tells these tools to put your modules into
\&\fI/mydir/perl/lib/perl5\fR. See \*(L"How do I add a directory to my
include path (@INC) at runtime?\*(R" for details on how to run your newly
installed modules.
.PP
There is one caveat with \s-1INSTALL_BASE,\s0 though, since it acts
differently from the \s-1PREFIX\s0 and \s-1LIB\s0 settings that older versions of
ExtUtils::MakeMaker advocated. \s-1INSTALL_BASE\s0 does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider whether you
really want that and, if you do, use the older \s-1PREFIX\s0 and \s-1LIB\s0
settings. See the ExtUtils::Makemaker documentation for more details.
.SS "How do I add the directory my program lives in to the module/library search path?"
.IX Subsection "How do I add the directory my program lives in to the module/library search path?"
(contributed by brian d foy)
.PP
If you know the directory already, you can add it to \f(CW@INC\fR as you would
for any other directory. You might <use lib> if you know the directory
at compile time:
.PP
.Vb 1
\&    use lib $directory;
.Ve
.PP
The trick in this task is to find the directory. Before your script does
anything else (such as a \f(CW\*(C`chdir\*(C'\fR), you can get the current working
directory with the \f(CW\*(C`Cwd\*(C'\fR module, which comes with Perl:
.PP
.Vb 4
\&    BEGIN {
\&        use Cwd;
\&        our $directory = cwd;
\&    }
\&
\&    use lib $directory;
.Ve
.PP
You can do a similar thing with the value of \f(CW$0\fR, which holds the
script name. That might hold a relative path, but \f(CW\*(C`rel2abs\*(C'\fR can turn
it into an absolute path. Once you have the
.PP
.Vb 3
\&    BEGIN {
\&        use File::Spec::Functions qw(rel2abs);
\&        use File::Basename qw(dirname);
\&
\&        my $path   = rel2abs( $0 );
\&        our $directory = dirname( $path );
\&    }
\&
\&    use lib $directory;
.Ve
.PP
The FindBin module, which comes with Perl, might work. It finds the
directory of the currently running script and puts it in \f(CW$Bin\fR, which
you can then use to construct the right library path:
.PP
.Vb 1
\&    use FindBin qw($Bin);
.Ve
.PP
You can also use local::lib to do much of the same thing. Install
modules using local::lib's settings then use the module in your
program:
.PP
.Vb 1
\&     use local::lib; # sets up a local lib at ~/perl5
.Ve
.PP
See the local::lib documentation for more details.
.SS "How do I add a directory to my include path (@INC) at runtime?"
.IX Subsection "How do I add a directory to my include path (@INC) at runtime?"
Here are the suggested ways of modifying your include path, including
environment variables, run-time switches, and in-code statements:
.ie n .IP "the ""PERLLIB"" environment variable" 4
.el .IP "the \f(CWPERLLIB\fR environment variable" 4
.IX Item "the PERLLIB environment variable"
.Vb 2
\&    $ export PERLLIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""PERL5LIB"" environment variable" 4
.el .IP "the \f(CWPERL5LIB\fR environment variable" 4
.IX Item "the PERL5LIB environment variable"
.Vb 2
\&    $ export PERL5LIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""perl \-Idir"" command line flag" 4
.el .IP "the \f(CWperl \-Idir\fR command line flag" 4
.IX Item "the perl -Idir command line flag"
.Vb 1
\&    $ perl \-I/path/to/my/dir program.pl
.Ve
.ie n .IP "the ""lib"" pragma:" 4
.el .IP "the \f(CWlib\fR pragma:" 4
.IX Item "the lib pragma:"
.Vb 1
\&    use lib "$ENV{HOME}/myown_perllib";
.Ve
.IP "the local::lib module:" 4
.IX Item "the local::lib module:"
.Vb 1
\&    use local::lib;
\&
\&    use local::lib "~/myown_perllib";
.Ve
.PP
The last is particularly useful because it knows about machine-dependent
architectures. The \f(CW\*(C`lib.pm\*(C'\fR pragmatic module was first
included with the 5.002 release of Perl.
.SS "What is socket.ph and where do I get it?"
.IX Subsection "What is socket.ph and where do I get it?"
It's a Perl 4 style file defining values for system networking
constants. Sometimes it is built using h2ph when Perl is installed,
but other times it is not. Modern programs should use \f(CW\*(C`use Socket;\*(C'\fR
instead.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq9.1                                   0100644 0001750 0001750 00000051641 12566207437 022476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ9 1"
.TH PERLFAQ9 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq9 \- Web, Email and Networking
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with questions related to running web sites,
sending and receiving email as well as general networking.
.SS "Should I use a web framework?"
.IX Subsection "Should I use a web framework?"
Yes. If you are building a web site with any level of interactivity
(forms / users / databases), you
will want to use a framework to make handling requests
and responses easier.
.PP
If there is no interactivity then you may still want
to look at using something like Template Toolkit <https://metacpan.org/module/Template>
or Plack::Middleware::TemplateToolkit
so maintenance of your \s-1HTML\s0 files (and other assets) is easier.
.SS "Which web framework should I use?"
.IX Xref "framework CGI.pm CGI Catalyst Dancer"
.IX Subsection "Which web framework should I use?"
There is no simple answer to this question. Perl frameworks can run everything
from basic file servers and small scale intranets to massive multinational
multilingual websites that are the core to international businesses.
.PP
Below is a list of a few frameworks with comments which might help you in 
making a decision, depending on your specific requirements. Start by reading
the docs, then ask questions on the relevant mailing list or \s-1IRC\s0 channel.
.IP "Catalyst" 4
.IX Item "Catalyst"
Strongly object-oriented and fully-featured with a long development history and
a large community and addon ecosystem. It is excellent for large and complex
applications, where you have full control over the server.
.IP "Dancer" 4
.IX Item "Dancer"
Young and free of legacy weight, providing a lightweight and easy to learn \s-1API.\s0
Has a growing addon ecosystem. It is best used for smaller projects and
very easy to learn for beginners.
.IP "Mojolicious" 4
.IX Item "Mojolicious"
Fairly young with a focus on \s-1HTML5\s0 and real-time web technologies such as
WebSockets.
.IP "Web::Simple" 4
.IX Item "Web::Simple"
Currently experimental, strongly object-oriented, built for speed and intended
as a toolkit for building micro web apps, custom frameworks or for tieing
together existing Plack-compatible web applications with one central dispatcher.
.PP
All of these interact with or use Plack which is worth understanding
the basics of when building a website in Perl (there is a lot of useful
Plack::Middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>).
.SS "What is Plack and \s-1PSGI\s0?"
.IX Subsection "What is Plack and PSGI?"
\&\s-1PSGI\s0 is the Perl Web Server Gateway Interface Specification, it is
a standard that many Perl web frameworks use, you should not need to
understand it to build a web site, the part you might want to use is Plack.
.PP
Plack is a set of tools for using the \s-1PSGI\s0 stack. It contains
middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>
components, a reference server and utilities for Web application frameworks.
Plack is like Ruby's Rack or Python's Paste for \s-1WSGI.\s0
.PP
You could build a web site using Plack and your own code,
but for anything other than a very basic web site, using a web framework
(that uses Plack) is a better option.
.SS "How do I remove \s-1HTML\s0 from a string?"
.IX Subsection "How do I remove HTML from a string?"
Use HTML::Strip, or HTML::FormatText which not only removes \s-1HTML\s0
but also attempts to do a little simple formatting of the resulting
plain text.
.SS "How do I extract URLs?"
.IX Subsection "How do I extract URLs?"
HTML::SimpleLinkExtor will extract URLs from \s-1HTML,\s0 it handles anchors,
images, objects, frames, and many other tags that can contain a \s-1URL.\s0
If you need anything more complex, you can create your own subclass of
HTML::LinkExtor or HTML::Parser. You might even use
HTML::SimpleLinkExtor as an example for something specifically
suited to your needs.
.PP
You can use URI::Find to extract URLs from an arbitrary text document.
.SS "How do I fetch an \s-1HTML\s0 file?"
.IX Subsection "How do I fetch an HTML file?"
(contributed by brian d foy)
.PP
Use the libwww-perl distribution. The LWP::Simple module can fetch web
resources and give their content back to you as a string:
.PP
.Vb 1
\&    use LWP::Simple qw(get);
\&
\&    my $html = get( "http://www.example.com/index.html" );
.Ve
.PP
It can also store the resource directly in a file:
.PP
.Vb 1
\&    use LWP::Simple qw(getstore);
\&
\&    getstore( "http://www.example.com/index.html", "foo.html" );
.Ve
.PP
If you need to do something more complicated, you can use
LWP::UserAgent module to create your own user-agent (e.g. browser)
to get the job done. If you want to simulate an interactive web
browser, you can use the WWW::Mechanize module.
.SS "How do I automate an \s-1HTML\s0 form submission?"
.IX Subsection "How do I automate an HTML form submission?"
If you are doing something complex, such as moving through many pages
and forms or a web site, you can use WWW::Mechanize. See its
documentation for all the details.
.PP
If you're submitting values using the \s-1GET\s0 method, create a \s-1URL\s0 and encode
the form using the \f(CW\*(C`query_form\*(C'\fR method:
.PP
.Vb 2
\&    use LWP::Simple;
\&    use URI::URL;
\&
\&    my $url = url(\*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq)>;
\&    $url\->query_form(module => \*(AqDB_File\*(Aq, readme => 1);
\&    $content = get($url);
.Ve
.PP
If you're using the \s-1POST\s0 method, create your own user agent and encode
the content appropriately.
.PP
.Vb 2
\&    use HTTP::Request::Common qw(POST);
\&    use LWP::UserAgent;
\&
\&    my $ua = LWP::UserAgent\->new();
\&    my $req = POST \*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq>,
\&                   [ module => \*(AqDB_File\*(Aq, readme => 1 ];
\&    my $content = $ua\->request($req)\->as_string;
.Ve
.SS "How do I decode or create those %\-encodings on the web?"
.IX Xref "URI URI::Escape RFC 2396"
.IX Subsection "How do I decode or create those %-encodings on the web?"
Most of the time you should not need to do this as
your web framework, or if you are making a request,
the \s-1LWP\s0 or other module would handle it for you.
.PP
To encode a string yourself, use the URI::Escape module. The \f(CW\*(C`uri_escape\*(C'\fR
function returns the escaped string:
.PP
.Vb 1
\&    my $original = "Colon : Hash # Percent %";
\&
\&    my $escaped = uri_escape( $original );
\&
\&    print "$escaped\en"; # \*(AqColon%20%3A%20Hash%20%23%20Percent%20%25\*(Aq
.Ve
.PP
To decode the string, use the \f(CW\*(C`uri_unescape\*(C'\fR function:
.PP
.Vb 1
\&    my $unescaped = uri_unescape( $escaped );
\&
\&    print $unescaped; # back to original
.Ve
.PP
Remember not to encode a full \s-1URI,\s0 you need to escape each
component separately and then join them together.
.SS "How do I redirect to another page?"
.IX Subsection "How do I redirect to another page?"
Most Perl Web Frameworks will have a mechanism for doing this,
using the Catalyst framework it would be:
.PP
.Vb 2
\&    $c\->res\->redirect($url);
\&    $c\->detach();
.Ve
.PP
If you are using Plack (which most frameworks do), then
Plack::Middleware::Rewrite is worth looking at if you
are migrating from Apache or have \s-1URL\s0's you want to always
redirect.
.SS "How do I put a password on my web pages?"
.IX Subsection "How do I put a password on my web pages?"
See if the web framework you are using has an
authentication system and if that fits your needs.
.PP
Alternativly look at Plack::Middleware::Auth::Basic,
or one of the other Plack authentication <https://metacpan.org/search?q=plack+auth>
options.
.SS "How do I make sure users can't enter values into a form that causes my \s-1CGI\s0 script to do bad things?"
.IX Subsection "How do I make sure users can't enter values into a form that causes my CGI script to do bad things?"
(contributed by brian d foy)
.PP
You can't prevent people from sending your script bad data. Even if
you add some client-side checks, people may disable them or bypass
them completely. For instance, someone might use a module such as
\&\s-1LWP\s0 to submit to your web site. If you want to prevent data that
try to use \s-1SQL\s0 injection or other sorts of attacks (and you should
want to), you have to not trust any data that enter your program.
.PP
The perlsec documentation has general advice about data security.
If you are using the \s-1DBI\s0 module, use placeholder to fill in data.
If you are running external programs with \f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR, use
the list forms. There are many other precautions that you should take,
too many to list here, and most of them fall under the category of not
using any data that you don't intend to use. Trust no one.
.SS "How do I parse a mail header?"
.IX Subsection "How do I parse a mail header?"
Use the Email::MIME module. It's well-tested and supports all the
craziness that you'll see in the real world (comment-folding whitespace,
encodings, comments, etc.).
.PP
.Vb 1
\&  use Email::MIME;
\&
\&  my $message = Email::MIME\->new($rfc2822);
\&  my $subject = $message\->header(\*(AqSubject\*(Aq);
\&  my $from    = $message\->header(\*(AqFrom\*(Aq);
.Ve
.PP
If you've already got some other kind of email object, consider passing
it to Email::Abstract and then using its cast method to get an
Email::MIME object:
.PP
.Vb 3
\&  my $mail_message_object = read_message();
\&  my $abstract = Email::Abstract\->new($mail_message_object);
\&  my $email_mime_object = $abstract\->cast(\*(AqEmail::MIME\*(Aq);
.Ve
.SS "How do I check a valid mail address?"
.IX Subsection "How do I check a valid mail address?"
(partly contributed by Aaron Sherman)
.PP
This isn't as simple a question as it sounds. There are two parts:
.PP
a) How do I verify that an email address is correctly formatted?
.PP
b) How do I verify that an email address targets a valid recipient?
.PP
Without sending mail to the address and seeing whether there's a human
on the other end to answer you, you cannot fully answer part \fIb\fR, but
the Email::Valid module will do both part \fIa\fR and part \fIb\fR as far
as you can in real-time.
.PP
Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.
.PP
A related strategy that's less open to forgery is to give them a \s-1PIN
\&\s0(personal \s-1ID\s0 number). Record the address and \s-1PIN \s0(best that it be a
random one) for later processing. In the mail you send, include a link to
your site with the \s-1PIN\s0 included. If the mail bounces, you know it's not
valid. If they don't click on the link, either they forged the address or
(assuming they got the message) following through wasn't important so you
don't need to worry about it.
.SS "How do I decode a \s-1MIME/BASE64\s0 string?"
.IX Subsection "How do I decode a MIME/BASE64 string?"
The MIME::Base64 package handles this as well as the \s-1MIME/QP\s0 encoding.
Decoding base 64 becomes as simple as:
.PP
.Vb 2
\&    use MIME::Base64;
\&    my $decoded = decode_base64($encoded);
.Ve
.PP
The Email::MIME module can decode base 64\-encoded email message parts
transparently so the developer doesn't need to worry about it.
.SS "How do I find the user's mail address?"
.IX Subsection "How do I find the user's mail address?"
Ask them for it. There are so many email providers available that it's
unlikely the local system has any idea how to determine a user's email address.
.PP
The exception is for organization-specific email (e.g. foo@yourcompany.com)
where policy can be codified in your program. In that case, you could look at
\&\f(CW$ENV\fR{\s-1USER\s0}, \f(CW$ENV\fR{\s-1LOGNAME\s0}, and getpwuid($<) in scalar context, like so:
.PP
.Vb 1
\&  my $user_name = getpwuid($<)
.Ve
.PP
But you still cannot make assumptions about whether this is correct, unless
your policy says it is. You really are best off asking the user.
.SS "How do I send email?"
.IX Subsection "How do I send email?"
Use the Email::MIME and Email::Sender::Simple modules, like so:
.PP
.Vb 10
\&  # first, create your message
\&  my $message = Email::MIME\->create(
\&    header_str => [
\&      From    => \*(Aqyou@example.com\*(Aq,
\&      To      => \*(Aqfriend@example.com\*(Aq,
\&      Subject => \*(AqHappy birthday!\*(Aq,
\&    ],
\&    attributes => {
\&      encoding => \*(Aqquoted\-printable\*(Aq,
\&      charset  => \*(Aqutf\-8\*(Aq,
\&    },
\&    body_str => "Happy birthday to you!\en",
\&  );
\&
\&  use Email::Sender::Simple qw(sendmail);
\&  sendmail($message);
.Ve
.PP
By default, Email::Sender::Simple will try `sendmail` first, if it exists
in your \f(CW$PATH\fR. This generally isn't the case. If there's a remote mail
server you use to send mail, consider investigating one of the Transport
classes. At time of writing, the available transports include:
.IP "Email::Sender::Transport::Sendmail" 4
.IX Item "Email::Sender::Transport::Sendmail"
This is the default. If you can use the \fImail\fR\|(1) or \fImailx\fR\|(1)
program to send mail from the machine where your code runs, you should
be able to use this.
.IP "Email::Sender::Transport::SMTP" 4
.IX Item "Email::Sender::Transport::SMTP"
This transport contacts a remote \s-1SMTP\s0 server over \s-1TCP.\s0 It optionally
uses \s-1SSL\s0 and can authenticate to the server via \s-1SASL.\s0
.IP "Email::Sender::Transport::SMTP::TLS" 4
.IX Item "Email::Sender::Transport::SMTP::TLS"
This is like the \s-1SMTP\s0 transport, but uses \s-1TLS\s0 security. You can
authenticate with this module as well, using any mechanisms your server
supports after \s-1STARTTLS.\s0
.PP
Telling Email::Sender::Simple to use your transport is straightforward.
.PP
.Vb 6
\&  sendmail(
\&    $message,
\&    {
\&      transport => $email_sender_transport_object,
\&    }
\&  );
.Ve
.SS "How do I use \s-1MIME\s0 to make an attachment to a mail message?"
.IX Subsection "How do I use MIME to make an attachment to a mail message?"
Email::MIME directly supports multipart messages. Email::MIME
objects themselves are parts and can be attached to other Email::MIME
objects. Consult the Email::MIME documentation for more information,
including all of the supported methods and examples of their use.
.SS "How do I read email?"
.IX Subsection "How do I read email?"
Use the Email::Folder module, like so:
.PP
.Vb 1
\&  use Email::Folder;
\&
\&  my $folder = Email::Folder\->new(\*(Aq/path/to/email/folder\*(Aq);
\&  while(my $message = $folder\->next_message) {
\&    # next_message returns Email::Simple objects, but we want
\&    # Email::MIME objects as they\*(Aqre more robust
\&    my $mime = Email::MIME\->new($message\->as_string);
\&  }
.Ve
.PP
There are different classes in the Email::Folder namespace for
supporting various mailbox types. Note that these modules are generally
rather limited and only support \fBreading\fR rather than writing.
.SS "How do I find out my hostname, domainname, or \s-1IP\s0 address?"
.IX Xref "hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa, gethostbyname, Socket, Net::Domain, Sys::Hostname"
.IX Subsection "How do I find out my hostname, domainname, or IP address?"
(contributed by brian d foy)
.PP
The Net::Domain module, which is part of the Standard Library starting
in Perl 5.7.3, can get you the fully qualified domain name (\s-1FQDN\s0), the host
name, or the domain name.
.PP
.Vb 1
\&    use Net::Domain qw(hostname hostfqdn hostdomain);
\&
\&    my $host = hostfqdn();
.Ve
.PP
The Sys::Hostname module, part of the Standard Library, can also get the
hostname:
.PP
.Vb 1
\&    use Sys::Hostname;
\&
\&    $host = hostname();
.Ve
.PP
The Sys::Hostname::Long module takes a different approach and tries
harder to return the fully qualified hostname:
.PP
.Vb 1
\&  use Sys::Hostname::Long \*(Aqhostname_long\*(Aq;
\&
\&  my $hostname = hostname_long();
.Ve
.PP
To get the \s-1IP\s0 address, you can use the \f(CW\*(C`gethostbyname\*(C'\fR built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the \f(CW\*(C`inet_ntoa\*(C'\fR function
from the Socket module, which also comes with perl.
.PP
.Vb 1
\&    use Socket;
\&
\&    my $address = inet_ntoa(
\&        scalar gethostbyname( $host || \*(Aqlocalhost\*(Aq )
\&    );
.Ve
.SS "How do I fetch/put an (S)FTP file?"
.IX Subsection "How do I fetch/put an (S)FTP file?"
Net::FTP, and Net::SFTP allow you to interact with \s-1FTP\s0 and \s-1SFTP \s0(Secure
\&\s-1FTP\s0) servers.
.SS "How can I do \s-1RPC\s0 in Perl?"
.IX Subsection "How can I do RPC in Perl?"
Use one of the \s-1RPC\s0 modules( <https://metacpan.org/search?q=RPC> ).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq95.16.1                               0100644 0001750 0001750 00000051324 12566207417 023004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ9 1"
.TH PERLFAQ9 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq9 \- Web, Email and Networking
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with questions related to running web sites,
sending and receiving email as well as general networking.
.SS "Should I use a web framework?"
.IX Subsection "Should I use a web framework?"
Yes. If you are building a web site with any level of interactivity
(forms / users / databases), you
will want to use a framework to make handling requests
and responses easier.
.PP
If there is no interactivity then you may still want
to look at using something like Template Toolkit <https://metacpan.org/module/Template>
or Plack::Middleware::TemplateToolkit
so maintenance of your \s-1HTML\s0 files (and other assets) is easier.
.SS "Which web framework should I use?"
.IX Xref "framework CGI.pm CGI Catalyst Dancer"
.IX Subsection "Which web framework should I use?"
There is no simple answer to this question. Perl frameworks can run everything
from basic file servers and small scale intranets to massive multinational
multilingual websites that are the core to international businesses.
.PP
Below is a list of a few frameworks with comments which might help you in 
making a decision, depending on your specific requirements. Start by reading
the docs, then ask questions on the relevant mailing list or \s-1IRC\s0 channel.
.IP "Catalyst" 4
.IX Item "Catalyst"
Strongly object-oriented and fully-featured with a long development history and
a large community and addon ecosystem. It is excellent for large and complex
applications, where you have full control over the server.
.IP "Dancer" 4
.IX Item "Dancer"
Young and free of legacy weight, providing a lightweight and easy to learn \s-1API\s0.
Has a growing addon ecosystem. It is best used for smaller projects and
very easy to learn for beginners.
.IP "Mojolicious" 4
.IX Item "Mojolicious"
Fairly young with a focus on \s-1HTML5\s0 and real-time web technologies such as
WebSockets.
.IP "Web::Simple" 4
.IX Item "Web::Simple"
Currently experimental, strongly object-oriented, built for speed and intended
as a toolkit for building micro web apps, custom frameworks or for tieing
together existing Plack-compatible web applications with one central dispatcher.
.PP
All of these interact with or use Plack which is worth understanding
the basics of when building a website in Perl (there is a lot of useful
Plack::Middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>).
.SS "What is Plack and \s-1PSGI\s0?"
.IX Subsection "What is Plack and PSGI?"
\&\s-1PSGI\s0 is the Perl Web Server Gateway Interface Specification, it is
a standard that many Perl web frameworks use, you should not need to
understand it to build a web site, the part you might want to use is Plack.
.PP
Plack is a set of tools for using the \s-1PSGI\s0 stack. It contains
middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>
components, a reference server and utilities for Web application frameworks.
Plack is like Ruby's Rack or Python's Paste for \s-1WSGI\s0.
.PP
You could build a web site using Plack and your own code,
but for anything other than a very basic web site, using a web framework
(that uses Plack) is a better option.
.SS "How do I remove \s-1HTML\s0 from a string?"
.IX Subsection "How do I remove HTML from a string?"
Use HTML::Strip, or HTML::FormatText which not only removes \s-1HTML\s0
but also attempts to do a little simple formatting of the resulting
plain text.
.SS "How do I extract URLs?"
.IX Subsection "How do I extract URLs?"
HTML::SimpleLinkExtor will extract URLs from \s-1HTML\s0, it handles anchors,
images, objects, frames, and many other tags that can contain a \s-1URL\s0.
If you need anything more complex, you can create your own subclass of
HTML::LinkExtor or HTML::Parser. You might even use
HTML::SimpleLinkExtor as an example for something specifically
suited to your needs.
.PP
You can use URI::Find to extract URLs from an arbitrary text document.
.SS "How do I fetch an \s-1HTML\s0 file?"
.IX Subsection "How do I fetch an HTML file?"
(contributed by brian d foy)
.PP
Use the libwww-perl distribution. The LWP::Simple module can fetch web
resources and give their content back to you as a string:
.PP
.Vb 1
\&    use LWP::Simple qw(get);
\&
\&    my $html = get( "http://www.example.com/index.html" );
.Ve
.PP
It can also store the resource directly in a file:
.PP
.Vb 1
\&    use LWP::Simple qw(getstore);
\&
\&    getstore( "http://www.example.com/index.html", "foo.html" );
.Ve
.PP
If you need to do something more complicated, you can use
LWP::UserAgent module to create your own user-agent (e.g. browser)
to get the job done. If you want to simulate an interactive web
browser, you can use the WWW::Mechanize module.
.SS "How do I automate an \s-1HTML\s0 form submission?"
.IX Subsection "How do I automate an HTML form submission?"
If you are doing something complex, such as moving through many pages
and forms or a web site, you can use WWW::Mechanize. See its
documentation for all the details.
.PP
If you're submitting values using the \s-1GET\s0 method, create a \s-1URL\s0 and encode
the form using the \f(CW\*(C`query_form\*(C'\fR method:
.PP
.Vb 2
\&    use LWP::Simple;
\&    use URI::URL;
\&
\&    my $url = url(\*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq)>;
\&    $url\->query_form(module => \*(AqDB_File\*(Aq, readme => 1);
\&    $content = get($url);
.Ve
.PP
If you're using the \s-1POST\s0 method, create your own user agent and encode
the content appropriately.
.PP
.Vb 2
\&    use HTTP::Request::Common qw(POST);
\&    use LWP::UserAgent;
\&
\&    my $ua = LWP::UserAgent\->new();
\&    my $req = POST \*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq>,
\&                   [ module => \*(AqDB_File\*(Aq, readme => 1 ];
\&    my $content = $ua\->request($req)\->as_string;
.Ve
.SS "How do I decode or create those %\-encodings on the web?"
.IX Xref "URI URI::Escape RFC 2396"
.IX Subsection "How do I decode or create those %-encodings on the web?"
Most of the time you should not need to do this as
your web framework, or if you are making a request,
the \s-1LWP\s0 or other module would handle it for you.
.PP
To encode a string yourself, use the URI::Escape module. The \f(CW\*(C`uri_escape\*(C'\fR
function returns the escaped string:
.PP
.Vb 1
\&    my $original = "Colon : Hash # Percent %";
\&
\&    my $escaped = uri_escape( $original );
\&
\&    print "$escaped\en"; # \*(AqColon%20%3A%20Hash%20%23%20Percent%20%25\*(Aq
.Ve
.PP
To decode the string, use the \f(CW\*(C`uri_unescape\*(C'\fR function:
.PP
.Vb 1
\&    my $unescaped = uri_unescape( $escaped );
\&
\&    print $unescaped; # back to original
.Ve
.PP
Remember not to encode a full \s-1URI\s0, you need to escape each
component separately and then join them together.
.SS "How do I redirect to another page?"
.IX Subsection "How do I redirect to another page?"
Most Perl Web Frameworks will have a mechanism for doing this,
using the Catalyst framework it would be:
.PP
.Vb 2
\&    $c\->res\->redirect($url);
\&    $c\->detach();
.Ve
.PP
If you are using Plack (which most frameworks do), then
Plack::Middleware::Rewrite is worth looking at if you
are migrating from Apache or have \s-1URL\s0's you want to always
redirect.
.SS "How do I put a password on my web pages?"
.IX Subsection "How do I put a password on my web pages?"
See if the web framework you are using has an
authentication system and if that fits your needs.
.PP
Alternativly look at Plack::Middleware::Auth::Basic,
or one of the other Plack authentication <https://metacpan.org/search?q=plack+auth>
options.
.SS "How do I make sure users can't enter values into a form that causes my \s-1CGI\s0 script to do bad things?"
.IX Subsection "How do I make sure users can't enter values into a form that causes my CGI script to do bad things?"
(contributed by brian d foy)
.PP
You can't prevent people from sending your script bad data. Even if
you add some client-side checks, people may disable them or bypass
them completely. For instance, someone might use a module such as
\&\s-1LWP\s0 to submit to your web site. If you want to prevent data that
try to use \s-1SQL\s0 injection or other sorts of attacks (and you should
want to), you have to not trust any data that enter your program.
.PP
The perlsec documentation has general advice about data security.
If you are using the \s-1DBI\s0 module, use placeholder to fill in data.
If you are running external programs with \f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR, use
the list forms. There are many other precautions that you should take,
too many to list here, and most of them fall under the category of not
using any data that you don't intend to use. Trust no one.
.SS "How do I parse a mail header?"
.IX Subsection "How do I parse a mail header?"
Use the Email::MIME module. It's well-tested and supports all the
craziness that you'll see in the real world (comment-folding whitespace,
encodings, comments, etc.).
.PP
.Vb 1
\&  use Email::MIME;
\&
\&  my $message = Email::MIME\->new($rfc2822);
\&  my $subject = $message\->header(\*(AqSubject\*(Aq);
\&  my $from    = $message\->header(\*(AqFrom\*(Aq);
.Ve
.PP
If you've already got some other kind of email object, consider passing
it to Email::Abstract and then using its cast method to get an
Email::MIME object:
.PP
.Vb 3
\&  my $mail_message_object = read_message();
\&  my $abstract = Email::Abstract\->new($mail_message_object);
\&  my $email_mime_object = $abstract\->cast(\*(AqEmail::MIME\*(Aq);
.Ve
.SS "How do I check a valid mail address?"
.IX Subsection "How do I check a valid mail address?"
(partly contributed by Aaron Sherman)
.PP
This isn't as simple a question as it sounds. There are two parts:
.PP
a) How do I verify that an email address is correctly formatted?
.PP
b) How do I verify that an email address targets a valid recipient?
.PP
Without sending mail to the address and seeing whether there's a human
on the other end to answer you, you cannot fully answer part \fIb\fR, but
the Email::Valid module will do both part \fIa\fR and part \fIb\fR as far
as you can in real-time.
.PP
Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.
.PP
A related strategy that's less open to forgery is to give them a \s-1PIN\s0
(personal \s-1ID\s0 number). Record the address and \s-1PIN\s0 (best that it be a
random one) for later processing. In the mail you send, include a link to
your site with the \s-1PIN\s0 included. If the mail bounces, you know it's not
valid. If they don't click on the link, either they forged the address or
(assuming they got the message) following through wasn't important so you
don't need to worry about it.
.SS "How do I decode a \s-1MIME/BASE64\s0 string?"
.IX Subsection "How do I decode a MIME/BASE64 string?"
The MIME::Base64 package handles this as well as the \s-1MIME/QP\s0 encoding.
Decoding base 64 becomes as simple as:
.PP
.Vb 2
\&    use MIME::Base64;
\&    my $decoded = decode_base64($encoded);
.Ve
.PP
The Email::MIME module can decode base 64\-encoded email message parts
transparently so the developer doesn't need to worry about it.
.SS "How do I find the user's mail address?"
.IX Subsection "How do I find the user's mail address?"
Ask them for it. There are so many email providers available that it's
unlikely the local system has any idea how to determine a user's email address.
.PP
The exception is for organization-specific email (e.g. foo@yourcompany.com)
where policy can be codified in your program. In that case, you could look at
\&\f(CW$ENV\fR{\s-1USER\s0}, \f(CW$ENV\fR{\s-1LOGNAME\s0}, and getpwuid($<) in scalar context, like so:
.PP
.Vb 1
\&  my $user_name = getpwuid($<)
.Ve
.PP
But you still cannot make assumptions about whether this is correct, unless
your policy says it is. You really are best off asking the user.
.SS "How do I send email?"
.IX Subsection "How do I send email?"
Use the Email::MIME and Email::Sender::Simple modules, like so:
.PP
.Vb 10
\&  # first, create your message
\&  my $message = Email::MIME\->create(
\&    header_str => [
\&      From    => \*(Aqyou@example.com\*(Aq,
\&      To      => \*(Aqfriend@example.com\*(Aq,
\&      Subject => \*(AqHappy birthday!\*(Aq,
\&    ],
\&    attributes => {
\&      encoding => \*(Aqquoted\-printable\*(Aq,
\&      charset  => \*(AqISO\-8859\-1\*(Aq,
\&    },
\&    body_str => "Happy birthday to you!\en",
\&  );
\&
\&  use Email::Sender::Simple qw(sendmail);
\&  sendmail($message);
.Ve
.PP
By default, Email::Sender::Simple will try `sendmail` first, if it exists
in your \f(CW$PATH\fR. This generally isn't the case. If there's a remote mail
server you use to send mail, consider investigating one of the Transport
classes. At time of writing, the available transports include:
.IP "Email::Sender::Transport::Sendmail" 4
.IX Item "Email::Sender::Transport::Sendmail"
This is the default. If you can use the \fImail\fR\|(1) or \fImailx\fR\|(1)
program to send mail from the machine where your code runs, you should
be able to use this.
.IP "Email::Sender::Transport::SMTP" 4
.IX Item "Email::Sender::Transport::SMTP"
This transport contacts a remote \s-1SMTP\s0 server over \s-1TCP\s0. It optionally
uses \s-1SSL\s0 and can authenticate to the server via \s-1SASL\s0.
.IP "Email::Sender::Transport::SMTP::TLS" 4
.IX Item "Email::Sender::Transport::SMTP::TLS"
This is like the \s-1SMTP\s0 transport, but uses \s-1TLS\s0 security. You can
authenticate with this module as well, using any mechanisms your server
supports after \s-1STARTTLS\s0.
.PP
Telling Email::Sender::Simple to use your transport is straightforward.
.PP
.Vb 6
\&  sendmail(
\&    $message,
\&    {
\&      transport => $email_sender_transport_object,
\&    }
\&  );
.Ve
.SS "How do I use \s-1MIME\s0 to make an attachment to a mail message?"
.IX Subsection "How do I use MIME to make an attachment to a mail message?"
Email::MIME directly supports multipart messages. Email::MIME
objects themselves are parts and can be attached to other Email::MIME
objects. Consult the Email::MIME documentation for more information,
including all of the supported methods and examples of their use.
.SS "How do I read email?"
.IX Subsection "How do I read email?"
Use the Email::Folder module, like so:
.PP
.Vb 1
\&  use Email::Folder;
\&
\&  my $folder = Email::Folder\->new(\*(Aq/path/to/email/folder\*(Aq);
\&  while(my $message = $folder\->next_message) {
\&    # next_message returns Email::Simple objects, but we want
\&    # Email::MIME objects as they\*(Aqre more robust
\&    my $mime = Email::MIME\->new($message\->as_string);
\&  }
.Ve
.PP
There are different classes in the Email::Folder namespace for
supporting various mailbox types. Note that these modules are generally
rather limited and only support \fBreading\fR rather than writing.
.SS "How do I find out my hostname, domainname, or \s-1IP\s0 address?"
.IX Xref "hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa,
gethostbyname, Socket, Net::Domain, Sys::Hostname"
.IX Subsection "How do I find out my hostname, domainname, or IP address?"
(contributed by brian d foy)
.PP
The Net::Domain module, which is part of the Standard Library starting
in Perl 5.7.3, can get you the fully qualified domain name (\s-1FQDN\s0), the host
name, or the domain name.
.PP
.Vb 1
\&    use Net::Domain qw(hostname hostfqdn hostdomain);
\&
\&    my $host = hostfqdn();
.Ve
.PP
The Sys::Hostname module, part of the Standard Library, can also get the
hostname:
.PP
.Vb 1
\&    use Sys::Hostname;
\&
\&    $host = hostname();
.Ve
.PP
The Sys::Hostname::Long module takes a different approach and tries
harder to return the fully qualified hostname:
.PP
.Vb 1
\&  use Sys::Hostname::Long \*(Aqhostname_long\*(Aq;
\&
\&  my $hostname = hostname_long();
.Ve
.PP
To get the \s-1IP\s0 address, you can use the \f(CW\*(C`gethostbyname\*(C'\fR built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the \f(CW\*(C`inet_ntoa\*(C'\fR function
from the Socket module, which also comes with perl.
.PP
.Vb 1
\&    use Socket;
\&
\&    my $address = inet_ntoa(
\&        scalar gethostbyname( $host || \*(Aqlocalhost\*(Aq )
\&    );
.Ve
.SS "How do I fetch/put an (S)FTP file?"
.IX Subsection "How do I fetch/put an (S)FTP file?"
Net::FTP, and Net::SFTP allow you to interact with \s-1FTP\s0 and \s-1SFTP\s0 (Secure
\&\s-1FTP\s0) servers.
.SS "How can I do \s-1RPC\s0 in Perl?"
.IX Subsection "How can I do RPC in Perl?"
Use one of the \s-1RPC\s0 modules( <https://metacpan.org/search?q=RPC> ).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq95.18.1                               0100644 0001750 0001750 00000051641 12566207437 023012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ9 1"
.TH PERLFAQ9 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq9 \- Web, Email and Networking
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals with questions related to running web sites,
sending and receiving email as well as general networking.
.SS "Should I use a web framework?"
.IX Subsection "Should I use a web framework?"
Yes. If you are building a web site with any level of interactivity
(forms / users / databases), you
will want to use a framework to make handling requests
and responses easier.
.PP
If there is no interactivity then you may still want
to look at using something like Template Toolkit <https://metacpan.org/module/Template>
or Plack::Middleware::TemplateToolkit
so maintenance of your \s-1HTML\s0 files (and other assets) is easier.
.SS "Which web framework should I use?"
.IX Xref "framework CGI.pm CGI Catalyst Dancer"
.IX Subsection "Which web framework should I use?"
There is no simple answer to this question. Perl frameworks can run everything
from basic file servers and small scale intranets to massive multinational
multilingual websites that are the core to international businesses.
.PP
Below is a list of a few frameworks with comments which might help you in 
making a decision, depending on your specific requirements. Start by reading
the docs, then ask questions on the relevant mailing list or \s-1IRC\s0 channel.
.IP "Catalyst" 4
.IX Item "Catalyst"
Strongly object-oriented and fully-featured with a long development history and
a large community and addon ecosystem. It is excellent for large and complex
applications, where you have full control over the server.
.IP "Dancer" 4
.IX Item "Dancer"
Young and free of legacy weight, providing a lightweight and easy to learn \s-1API.\s0
Has a growing addon ecosystem. It is best used for smaller projects and
very easy to learn for beginners.
.IP "Mojolicious" 4
.IX Item "Mojolicious"
Fairly young with a focus on \s-1HTML5\s0 and real-time web technologies such as
WebSockets.
.IP "Web::Simple" 4
.IX Item "Web::Simple"
Currently experimental, strongly object-oriented, built for speed and intended
as a toolkit for building micro web apps, custom frameworks or for tieing
together existing Plack-compatible web applications with one central dispatcher.
.PP
All of these interact with or use Plack which is worth understanding
the basics of when building a website in Perl (there is a lot of useful
Plack::Middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>).
.SS "What is Plack and \s-1PSGI\s0?"
.IX Subsection "What is Plack and PSGI?"
\&\s-1PSGI\s0 is the Perl Web Server Gateway Interface Specification, it is
a standard that many Perl web frameworks use, you should not need to
understand it to build a web site, the part you might want to use is Plack.
.PP
Plack is a set of tools for using the \s-1PSGI\s0 stack. It contains
middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>
components, a reference server and utilities for Web application frameworks.
Plack is like Ruby's Rack or Python's Paste for \s-1WSGI.\s0
.PP
You could build a web site using Plack and your own code,
but for anything other than a very basic web site, using a web framework
(that uses Plack) is a better option.
.SS "How do I remove \s-1HTML\s0 from a string?"
.IX Subsection "How do I remove HTML from a string?"
Use HTML::Strip, or HTML::FormatText which not only removes \s-1HTML\s0
but also attempts to do a little simple formatting of the resulting
plain text.
.SS "How do I extract URLs?"
.IX Subsection "How do I extract URLs?"
HTML::SimpleLinkExtor will extract URLs from \s-1HTML,\s0 it handles anchors,
images, objects, frames, and many other tags that can contain a \s-1URL.\s0
If you need anything more complex, you can create your own subclass of
HTML::LinkExtor or HTML::Parser. You might even use
HTML::SimpleLinkExtor as an example for something specifically
suited to your needs.
.PP
You can use URI::Find to extract URLs from an arbitrary text document.
.SS "How do I fetch an \s-1HTML\s0 file?"
.IX Subsection "How do I fetch an HTML file?"
(contributed by brian d foy)
.PP
Use the libwww-perl distribution. The LWP::Simple module can fetch web
resources and give their content back to you as a string:
.PP
.Vb 1
\&    use LWP::Simple qw(get);
\&
\&    my $html = get( "http://www.example.com/index.html" );
.Ve
.PP
It can also store the resource directly in a file:
.PP
.Vb 1
\&    use LWP::Simple qw(getstore);
\&
\&    getstore( "http://www.example.com/index.html", "foo.html" );
.Ve
.PP
If you need to do something more complicated, you can use
LWP::UserAgent module to create your own user-agent (e.g. browser)
to get the job done. If you want to simulate an interactive web
browser, you can use the WWW::Mechanize module.
.SS "How do I automate an \s-1HTML\s0 form submission?"
.IX Subsection "How do I automate an HTML form submission?"
If you are doing something complex, such as moving through many pages
and forms or a web site, you can use WWW::Mechanize. See its
documentation for all the details.
.PP
If you're submitting values using the \s-1GET\s0 method, create a \s-1URL\s0 and encode
the form using the \f(CW\*(C`query_form\*(C'\fR method:
.PP
.Vb 2
\&    use LWP::Simple;
\&    use URI::URL;
\&
\&    my $url = url(\*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq)>;
\&    $url\->query_form(module => \*(AqDB_File\*(Aq, readme => 1);
\&    $content = get($url);
.Ve
.PP
If you're using the \s-1POST\s0 method, create your own user agent and encode
the content appropriately.
.PP
.Vb 2
\&    use HTTP::Request::Common qw(POST);
\&    use LWP::UserAgent;
\&
\&    my $ua = LWP::UserAgent\->new();
\&    my $req = POST \*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq>,
\&                   [ module => \*(AqDB_File\*(Aq, readme => 1 ];
\&    my $content = $ua\->request($req)\->as_string;
.Ve
.SS "How do I decode or create those %\-encodings on the web?"
.IX Xref "URI URI::Escape RFC 2396"
.IX Subsection "How do I decode or create those %-encodings on the web?"
Most of the time you should not need to do this as
your web framework, or if you are making a request,
the \s-1LWP\s0 or other module would handle it for you.
.PP
To encode a string yourself, use the URI::Escape module. The \f(CW\*(C`uri_escape\*(C'\fR
function returns the escaped string:
.PP
.Vb 1
\&    my $original = "Colon : Hash # Percent %";
\&
\&    my $escaped = uri_escape( $original );
\&
\&    print "$escaped\en"; # \*(AqColon%20%3A%20Hash%20%23%20Percent%20%25\*(Aq
.Ve
.PP
To decode the string, use the \f(CW\*(C`uri_unescape\*(C'\fR function:
.PP
.Vb 1
\&    my $unescaped = uri_unescape( $escaped );
\&
\&    print $unescaped; # back to original
.Ve
.PP
Remember not to encode a full \s-1URI,\s0 you need to escape each
component separately and then join them together.
.SS "How do I redirect to another page?"
.IX Subsection "How do I redirect to another page?"
Most Perl Web Frameworks will have a mechanism for doing this,
using the Catalyst framework it would be:
.PP
.Vb 2
\&    $c\->res\->redirect($url);
\&    $c\->detach();
.Ve
.PP
If you are using Plack (which most frameworks do), then
Plack::Middleware::Rewrite is worth looking at if you
are migrating from Apache or have \s-1URL\s0's you want to always
redirect.
.SS "How do I put a password on my web pages?"
.IX Subsection "How do I put a password on my web pages?"
See if the web framework you are using has an
authentication system and if that fits your needs.
.PP
Alternativly look at Plack::Middleware::Auth::Basic,
or one of the other Plack authentication <https://metacpan.org/search?q=plack+auth>
options.
.SS "How do I make sure users can't enter values into a form that causes my \s-1CGI\s0 script to do bad things?"
.IX Subsection "How do I make sure users can't enter values into a form that causes my CGI script to do bad things?"
(contributed by brian d foy)
.PP
You can't prevent people from sending your script bad data. Even if
you add some client-side checks, people may disable them or bypass
them completely. For instance, someone might use a module such as
\&\s-1LWP\s0 to submit to your web site. If you want to prevent data that
try to use \s-1SQL\s0 injection or other sorts of attacks (and you should
want to), you have to not trust any data that enter your program.
.PP
The perlsec documentation has general advice about data security.
If you are using the \s-1DBI\s0 module, use placeholder to fill in data.
If you are running external programs with \f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR, use
the list forms. There are many other precautions that you should take,
too many to list here, and most of them fall under the category of not
using any data that you don't intend to use. Trust no one.
.SS "How do I parse a mail header?"
.IX Subsection "How do I parse a mail header?"
Use the Email::MIME module. It's well-tested and supports all the
craziness that you'll see in the real world (comment-folding whitespace,
encodings, comments, etc.).
.PP
.Vb 1
\&  use Email::MIME;
\&
\&  my $message = Email::MIME\->new($rfc2822);
\&  my $subject = $message\->header(\*(AqSubject\*(Aq);
\&  my $from    = $message\->header(\*(AqFrom\*(Aq);
.Ve
.PP
If you've already got some other kind of email object, consider passing
it to Email::Abstract and then using its cast method to get an
Email::MIME object:
.PP
.Vb 3
\&  my $mail_message_object = read_message();
\&  my $abstract = Email::Abstract\->new($mail_message_object);
\&  my $email_mime_object = $abstract\->cast(\*(AqEmail::MIME\*(Aq);
.Ve
.SS "How do I check a valid mail address?"
.IX Subsection "How do I check a valid mail address?"
(partly contributed by Aaron Sherman)
.PP
This isn't as simple a question as it sounds. There are two parts:
.PP
a) How do I verify that an email address is correctly formatted?
.PP
b) How do I verify that an email address targets a valid recipient?
.PP
Without sending mail to the address and seeing whether there's a human
on the other end to answer you, you cannot fully answer part \fIb\fR, but
the Email::Valid module will do both part \fIa\fR and part \fIb\fR as far
as you can in real-time.
.PP
Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.
.PP
A related strategy that's less open to forgery is to give them a \s-1PIN
\&\s0(personal \s-1ID\s0 number). Record the address and \s-1PIN \s0(best that it be a
random one) for later processing. In the mail you send, include a link to
your site with the \s-1PIN\s0 included. If the mail bounces, you know it's not
valid. If they don't click on the link, either they forged the address or
(assuming they got the message) following through wasn't important so you
don't need to worry about it.
.SS "How do I decode a \s-1MIME/BASE64\s0 string?"
.IX Subsection "How do I decode a MIME/BASE64 string?"
The MIME::Base64 package handles this as well as the \s-1MIME/QP\s0 encoding.
Decoding base 64 becomes as simple as:
.PP
.Vb 2
\&    use MIME::Base64;
\&    my $decoded = decode_base64($encoded);
.Ve
.PP
The Email::MIME module can decode base 64\-encoded email message parts
transparently so the developer doesn't need to worry about it.
.SS "How do I find the user's mail address?"
.IX Subsection "How do I find the user's mail address?"
Ask them for it. There are so many email providers available that it's
unlikely the local system has any idea how to determine a user's email address.
.PP
The exception is for organization-specific email (e.g. foo@yourcompany.com)
where policy can be codified in your program. In that case, you could look at
\&\f(CW$ENV\fR{\s-1USER\s0}, \f(CW$ENV\fR{\s-1LOGNAME\s0}, and getpwuid($<) in scalar context, like so:
.PP
.Vb 1
\&  my $user_name = getpwuid($<)
.Ve
.PP
But you still cannot make assumptions about whether this is correct, unless
your policy says it is. You really are best off asking the user.
.SS "How do I send email?"
.IX Subsection "How do I send email?"
Use the Email::MIME and Email::Sender::Simple modules, like so:
.PP
.Vb 10
\&  # first, create your message
\&  my $message = Email::MIME\->create(
\&    header_str => [
\&      From    => \*(Aqyou@example.com\*(Aq,
\&      To      => \*(Aqfriend@example.com\*(Aq,
\&      Subject => \*(AqHappy birthday!\*(Aq,
\&    ],
\&    attributes => {
\&      encoding => \*(Aqquoted\-printable\*(Aq,
\&      charset  => \*(Aqutf\-8\*(Aq,
\&    },
\&    body_str => "Happy birthday to you!\en",
\&  );
\&
\&  use Email::Sender::Simple qw(sendmail);
\&  sendmail($message);
.Ve
.PP
By default, Email::Sender::Simple will try `sendmail` first, if it exists
in your \f(CW$PATH\fR. This generally isn't the case. If there's a remote mail
server you use to send mail, consider investigating one of the Transport
classes. At time of writing, the available transports include:
.IP "Email::Sender::Transport::Sendmail" 4
.IX Item "Email::Sender::Transport::Sendmail"
This is the default. If you can use the \fImail\fR\|(1) or \fImailx\fR\|(1)
program to send mail from the machine where your code runs, you should
be able to use this.
.IP "Email::Sender::Transport::SMTP" 4
.IX Item "Email::Sender::Transport::SMTP"
This transport contacts a remote \s-1SMTP\s0 server over \s-1TCP.\s0 It optionally
uses \s-1SSL\s0 and can authenticate to the server via \s-1SASL.\s0
.IP "Email::Sender::Transport::SMTP::TLS" 4
.IX Item "Email::Sender::Transport::SMTP::TLS"
This is like the \s-1SMTP\s0 transport, but uses \s-1TLS\s0 security. You can
authenticate with this module as well, using any mechanisms your server
supports after \s-1STARTTLS.\s0
.PP
Telling Email::Sender::Simple to use your transport is straightforward.
.PP
.Vb 6
\&  sendmail(
\&    $message,
\&    {
\&      transport => $email_sender_transport_object,
\&    }
\&  );
.Ve
.SS "How do I use \s-1MIME\s0 to make an attachment to a mail message?"
.IX Subsection "How do I use MIME to make an attachment to a mail message?"
Email::MIME directly supports multipart messages. Email::MIME
objects themselves are parts and can be attached to other Email::MIME
objects. Consult the Email::MIME documentation for more information,
including all of the supported methods and examples of their use.
.SS "How do I read email?"
.IX Subsection "How do I read email?"
Use the Email::Folder module, like so:
.PP
.Vb 1
\&  use Email::Folder;
\&
\&  my $folder = Email::Folder\->new(\*(Aq/path/to/email/folder\*(Aq);
\&  while(my $message = $folder\->next_message) {
\&    # next_message returns Email::Simple objects, but we want
\&    # Email::MIME objects as they\*(Aqre more robust
\&    my $mime = Email::MIME\->new($message\->as_string);
\&  }
.Ve
.PP
There are different classes in the Email::Folder namespace for
supporting various mailbox types. Note that these modules are generally
rather limited and only support \fBreading\fR rather than writing.
.SS "How do I find out my hostname, domainname, or \s-1IP\s0 address?"
.IX Xref "hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa, gethostbyname, Socket, Net::Domain, Sys::Hostname"
.IX Subsection "How do I find out my hostname, domainname, or IP address?"
(contributed by brian d foy)
.PP
The Net::Domain module, which is part of the Standard Library starting
in Perl 5.7.3, can get you the fully qualified domain name (\s-1FQDN\s0), the host
name, or the domain name.
.PP
.Vb 1
\&    use Net::Domain qw(hostname hostfqdn hostdomain);
\&
\&    my $host = hostfqdn();
.Ve
.PP
The Sys::Hostname module, part of the Standard Library, can also get the
hostname:
.PP
.Vb 1
\&    use Sys::Hostname;
\&
\&    $host = hostname();
.Ve
.PP
The Sys::Hostname::Long module takes a different approach and tries
harder to return the fully qualified hostname:
.PP
.Vb 1
\&  use Sys::Hostname::Long \*(Aqhostname_long\*(Aq;
\&
\&  my $hostname = hostname_long();
.Ve
.PP
To get the \s-1IP\s0 address, you can use the \f(CW\*(C`gethostbyname\*(C'\fR built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the \f(CW\*(C`inet_ntoa\*(C'\fR function
from the Socket module, which also comes with perl.
.PP
.Vb 1
\&    use Socket;
\&
\&    my $address = inet_ntoa(
\&        scalar gethostbyname( $host || \*(Aqlocalhost\*(Aq )
\&    );
.Ve
.SS "How do I fetch/put an (S)FTP file?"
.IX Subsection "How do I fetch/put an (S)FTP file?"
Net::FTP, and Net::SFTP allow you to interact with \s-1FTP\s0 and \s-1SFTP \s0(Secure
\&\s-1FTP\s0) servers.
.SS "How can I do \s-1RPC\s0 in Perl?"
.IX Subsection "How can I do RPC in Perl?"
Use one of the \s-1RPC\s0 modules( <https://metacpan.org/search?q=RPC> ).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfilter.1                                 0100644 0001750 0001750 00000065470 12566207437 023130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFILTER 1"
.TH PERLFILTER 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfilter \- Source Filters
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This article is about a little-known feature of Perl called
\&\fIsource filters\fR. Source filters alter the program text of a module
before Perl sees it, much as a C preprocessor alters the source text of
a C program before the compiler sees it. This article tells you more
about what source filters are, how they work, and how to write your
own.
.PP
The original purpose of source filters was to let you encrypt your
program source to prevent casual piracy. This isn't all they can do, as
you'll soon learn. But first, the basics.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Before the Perl interpreter can execute a Perl script, it must first
read it from a file into memory for parsing and compilation. If that
script itself includes other scripts with a \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR
statement, then each of those scripts will have to be read from their
respective files as well.
.PP
Now think of each logical connection between the Perl parser and an
individual file as a \fIsource stream\fR. A source stream is created when
the Perl parser opens a file, it continues to exist as the source code
is read into memory, and it is destroyed when Perl is finished parsing
the file. If the parser encounters a \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR statement in
a source stream, a new and distinct stream is created just for that
file.
.PP
The diagram below represents a single source stream, with the flow of
source from a Perl script file on the left into the Perl parser on the
right. This is how Perl normally operates.
.PP
.Vb 1
\&    file \-\-\-\-\-\-\-> parser
.Ve
.PP
There are two important points to remember:
.IP "1." 5
Although there can be any number of source streams in existence at any
given time, only one will be active.
.IP "2." 5
Every source stream is associated with only one file.
.PP
A source filter is a special kind of Perl module that intercepts and
modifies a source stream before it reaches the parser. A source filter
changes our diagram like this:
.PP
.Vb 1
\&    file \-\-\-\-> filter \-\-\-\-> parser
.Ve
.PP
If that doesn't make much sense, consider the analogy of a command
pipeline. Say you have a shell script stored in the compressed file
\&\fItrial.gz\fR. The simple pipeline command below runs the script without
needing to create a temporary file to hold the uncompressed file.
.PP
.Vb 1
\&    gunzip \-c trial.gz | sh
.Ve
.PP
In this case, the data flow from the pipeline can be represented as follows:
.PP
.Vb 1
\&    trial.gz \-\-\-\-> gunzip \-\-\-\-> sh
.Ve
.PP
With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:
.PP
.Vb 2
\&     compressed           gunzip
\&    Perl program \-\-\-> source filter \-\-\-> parser
.Ve
.SH "USING FILTERS"
.IX Header "USING FILTERS"
So how do you use a source filter in a Perl script? Above, I said that
a source filter is just a special kind of module. Like all Perl
modules, a source filter is invoked with a use statement.
.PP
Say you want to pass your Perl source through the C preprocessor before
execution. As it happens, the source filters distribution comes with a C
preprocessor filter module called Filter::cpp.
.PP
Below is an example program, \f(CW\*(C`cpp_test\*(C'\fR, which makes use of this filter.
Line numbers have been added to allow specific lines to be referenced
easily.
.PP
.Vb 4
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: $a = TRUE;
\&    4: print "a = $a\en";
.Ve
.PP
When you execute this script, Perl creates a source stream for the
file. Before the parser processes any of the lines from the file, the
source stream looks like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-\-\-\-\-\-> parser
.Ve
.PP
Line 1, \f(CW\*(C`use Filter::cpp\*(C'\fR, includes and installs the \f(CW\*(C`cpp\*(C'\fR filter
module. All source filters work this way. The use statement is compiled
and executed at compile time, before any more of the file is read, and
it attaches the cpp filter to the source stream behind the scenes. Now
the data flow looks like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-> cpp filter \-\-\-\-> parser
.Ve
.PP
As the parser reads the second and subsequent lines from the source
stream, it feeds those lines through the \f(CW\*(C`cpp\*(C'\fR source filter before
processing them. The \f(CW\*(C`cpp\*(C'\fR filter simply passes each line through the
real C preprocessor. The output from the C preprocessor is then
inserted back into the source stream by the filter.
.PP
.Vb 5
\&                  .\-> cpp \-\-.
\&                  |         |
\&                  |         |
\&                  |       <\-\*(Aq
\&   cpp_test \-\-\-\-> cpp filter \-\-\-\-> parser
.Ve
.PP
The parser then sees the following code:
.PP
.Vb 3
\&    use Filter::cpp;
\&    $a = 1;
\&    print "a = $a\en";
.Ve
.PP
Let's consider what happens when the filtered code includes another
module with use:
.PP
.Vb 5
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: use Fred;
\&    4: $a = TRUE;
\&    5: print "a = $a\en";
.Ve
.PP
The \f(CW\*(C`cpp\*(C'\fR filter does not apply to the text of the Fred module, only
to the text of the file that used it (\f(CW\*(C`cpp_test\*(C'\fR). Although the use
statement on line 3 will pass through the cpp filter, the module that
gets included (\f(CW\*(C`Fred\*(C'\fR) will not. The source streams look like this
after line 3 has been parsed and before line 4 is parsed:
.PP
.Vb 1
\&    cpp_test \-\-\-> cpp filter \-\-\-> parser (INACTIVE)
\&
\&    Fred.pm \-\-\-\-> parser
.Ve
.PP
As you can see, a new stream has been created for reading the source
from \f(CW\*(C`Fred.pm\*(C'\fR. This stream will remain active until all of \f(CW\*(C`Fred.pm\*(C'\fR
has been parsed. The source stream for \f(CW\*(C`cpp_test\*(C'\fR will still exist,
but is inactive. Once the parser has finished reading Fred.pm, the
source stream associated with it will be destroyed. The source stream
for \f(CW\*(C`cpp_test\*(C'\fR then becomes active again and the parser reads line 4
and subsequent lines from \f(CW\*(C`cpp_test\*(C'\fR.
.PP
You can use more than one source filter on a single file. Similarly,
you can reuse the same filter in as many files as you like.
.PP
For example, if you have a uuencoded and compressed source file, it is
possible to stack a uudecode filter and an uncompression filter like
this:
.PP
.Vb 4
\&    use Filter::uudecode; use Filter::uncompress;
\&    M\*(AqXL(".H<US4\*(Aq\*(AqV9I;F%L\*(Aq)Q;>7/;1I;_>_I3=&E=%:F*I"T?22Q/
\&    M6]9*<IQCO*XFT"0[PL%%\*(AqY+IG?WN^ZYN\-$\*(AqJ.[.JE$,20/?K=_[>
\&    ...
.Ve
.PP
Once the first line has been processed, the flow will look like this:
.PP
.Vb 2
\&    file \-\-\-> uudecode \-\-\-> uncompress \-\-\-> parser
\&               filter         filter
.Ve
.PP
Data flows through filters in the same order they appear in the source
file. The uudecode filter appeared before the uncompress filter, so the
source file will be uudecoded before it's uncompressed.
.SH "WRITING A SOURCE FILTER"
.IX Header "WRITING A SOURCE FILTER"
There are three ways to write your own source filter. You can write it
in C, use an external program as a filter, or write the filter in Perl.
I won't cover the first two in any great detail, so I'll get them out
of the way first. Writing the filter in Perl is most convenient, so
I'll devote the most space to it.
.SH "WRITING A SOURCE FILTER IN C"
.IX Header "WRITING A SOURCE FILTER IN C"
The first of the three available techniques is to write the filter
completely in C. The external module you create interfaces directly
with the source filter hooks provided by Perl.
.PP
The advantage of this technique is that you have complete control over
the implementation of your filter. The big disadvantage is the
increased complexity required to write the filter \- not only do you
need to understand the source filter hooks, but you also need a
reasonable knowledge of Perl guts. One of the few times it is worth
going to this trouble is when writing a source scrambler. The
\&\f(CW\*(C`decrypt\*(C'\fR filter (which unscrambles the source before Perl parses it)
included with the source filter distribution is an example of a C
source filter (see Decryption Filters, below).
.IP "\fBDecryption Filters\fR" 5
.IX Item "Decryption Filters"
All decryption filters work on the principle of \*(L"security through
obscurity.\*(R" Regardless of how well you write a decryption filter and
how strong your encryption algorithm is, anyone determined enough can
retrieve the original source code. The reason is quite simple \- once
the decryption filter has decrypted the source back to its original
form, fragments of it will be stored in the computer's memory as Perl
parses it. The source might only be in memory for a short period of
time, but anyone possessing a debugger, skill, and lots of patience can
eventually reconstruct your program.
.Sp
That said, there are a number of steps that can be taken to make life
difficult for the potential cracker. The most important: Write your
decryption filter in C and statically link the decryption module into
the Perl binary. For further tips to make life difficult for the
potential cracker, see the file \fIdecrypt.pm\fR in the source filters
distribution.
.SH "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
.IX Header "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
An alternative to writing the filter in C is to create a separate
executable in the language of your choice. The separate executable
reads from standard input, does whatever processing is necessary, and
writes the filtered data to standard output. \f(CW\*(C`Filter::cpp\*(C'\fR is an
example of a source filter implemented as a separate executable \- the
executable is the C preprocessor bundled with your C compiler.
.PP
The source filter distribution includes two modules that simplify this
task: \f(CW\*(C`Filter::exec\*(C'\fR and \f(CW\*(C`Filter::sh\*(C'\fR. Both allow you to run any
external executable. Both use a coprocess to control the flow of data
into and out of the external executable. (For details on coprocesses,
see Stephens, W.R., \*(L"Advanced Programming in the \s-1UNIX\s0 Environment.\*(R"
Addison-Wesley, \s-1ISBN 0\-210\-56317\-7,\s0 pages 441\-445.) The difference
between them is that \f(CW\*(C`Filter::exec\*(C'\fR spawns the external command
directly, while \f(CW\*(C`Filter::sh\*(C'\fR spawns a shell to execute the external
command. (Unix uses the Bourne shell; \s-1NT\s0 uses the cmd shell.) Spawning
a shell allows you to make use of the shell metacharacters and
redirection facilities.
.PP
Here is an example script that uses \f(CW\*(C`Filter::sh\*(C'\fR:
.PP
.Vb 3
\&    use Filter::sh \*(Aqtr XYZ PQR\*(Aq;
\&    $a = 1;
\&    print "XYZ a = $a\en";
.Ve
.PP
The output you'll get when the script is executed:
.PP
.Vb 1
\&    PQR a = 1
.Ve
.PP
Writing a source filter as a separate executable works fine, but a
small performance penalty is incurred. For example, if you execute the
small example above, a separate subprocess will be created to run the
Unix \f(CW\*(C`tr\*(C'\fR command. Each use of the filter requires its own subprocess.
If creating subprocesses is expensive on your system, you might want to
consider one of the other options for creating source filters.
.SH "WRITING A SOURCE FILTER IN PERL"
.IX Header "WRITING A SOURCE FILTER IN PERL"
The easiest and most portable option available for creating your own
source filter is to write it completely in Perl. To distinguish this
from the previous two techniques, I'll call it a Perl source filter.
.PP
To help understand how to write a Perl source filter we need an example
to study. Here is a complete source filter that performs rot13
decoding. (Rot13 is a very simple encryption scheme used in Usenet
postings to hide the contents of offensive posts. It moves every letter
forward thirteen places, so that A becomes N, B becomes O, and Z
becomes M.)
.PP
.Vb 1
\&   package Rot13;
\&
\&   use Filter::Util::Call;
\&
\&   sub import {
\&      my ($type) = @_;
\&      my ($ref) = [];
\&      filter_add(bless $ref);
\&   }
\&
\&   sub filter {
\&      my ($self) = @_;
\&      my ($status);
\&
\&      tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/
\&         if ($status = filter_read()) > 0;
\&      $status;
\&   }
\&
\&   1;
.Ve
.PP
All Perl source filters are implemented as Perl classes and have the
same basic structure as the example above.
.PP
First, we include the \f(CW\*(C`Filter::Util::Call\*(C'\fR module, which exports a
number of functions into your filter's namespace. The filter shown
above uses two of these functions, \f(CW\*(C`filter_add()\*(C'\fR and
\&\f(CW\*(C`filter_read()\*(C'\fR.
.PP
Next, we create the filter object and associate it with the source
stream by defining the \f(CW\*(C`import\*(C'\fR function. If you know Perl well
enough, you know that \f(CW\*(C`import\*(C'\fR is called automatically every time a
module is included with a use statement. This makes \f(CW\*(C`import\*(C'\fR the ideal
place to both create and install a filter object.
.PP
In the example filter, the object (\f(CW$ref\fR) is blessed just like any
other Perl object. Our example uses an anonymous array, but this isn't
a requirement. Because this example doesn't need to store any context
information, we could have used a scalar or hash reference just as
well. The next section demonstrates context data.
.PP
The association between the filter object and the source stream is made
with the \f(CW\*(C`filter_add()\*(C'\fR function. This takes a filter object as a
parameter (\f(CW$ref\fR in this case) and installs it in the source stream.
.PP
Finally, there is the code that actually does the filtering. For this
type of Perl source filter, all the filtering is done in a method
called \f(CW\*(C`filter()\*(C'\fR. (It is also possible to write a Perl source filter
using a closure. See the \f(CW\*(C`Filter::Util::Call\*(C'\fR manual page for more
details.) It's called every time the Perl parser needs another line of
source to process. The \f(CW\*(C`filter()\*(C'\fR method, in turn, reads lines from
the source stream using the \f(CW\*(C`filter_read()\*(C'\fR function.
.PP
If a line was available from the source stream, \f(CW\*(C`filter_read()\*(C'\fR
returns a status value greater than zero and appends the line to \f(CW$_\fR.
A status value of zero indicates end-of-file, less than zero means an
error. The filter function itself is expected to return its status in
the same way, and put the filtered line it wants written to the source
stream in \f(CW$_\fR. The use of \f(CW$_\fR accounts for the brevity of most Perl
source filters.
.PP
In order to make use of the rot13 filter we need some way of encoding
the source file in rot13 format. The script below, \f(CW\*(C`mkrot13\*(C'\fR, does
just that.
.PP
.Vb 5
\&    die "usage mkrot13 filename\en" unless @ARGV;
\&    my $in = $ARGV[0];
\&    my $out = "$in.tmp";
\&    open(IN, "<$in") or die "Cannot open file $in: $!\en";
\&    open(OUT, ">$out") or die "Cannot open file $out: $!\en";
\&
\&    print OUT "use Rot13;\en";
\&    while (<IN>) {
\&       tr/a\-zA\-Z/n\-za\-mN\-ZA\-M/;
\&       print OUT;
\&    }
\&
\&    close IN;
\&    close OUT;
\&    unlink $in;
\&    rename $out, $in;
.Ve
.PP
If we encrypt this with \f(CW\*(C`mkrot13\*(C'\fR:
.PP
.Vb 1
\&    print " hello fred \en";
.Ve
.PP
the result will be this:
.PP
.Vb 2
\&    use Rot13;
\&    cevag "uryyb serq\ea";
.Ve
.PP
Running it produces this output:
.PP
.Vb 1
\&    hello fred
.Ve
.SH "USING CONTEXT: THE DEBUG FILTER"
.IX Header "USING CONTEXT: THE DEBUG FILTER"
The rot13 example was a trivial example. Here's another demonstration
that shows off a few more features.
.PP
Say you wanted to include a lot of debugging code in your Perl script
during development, but you didn't want it available in the released
product. Source filters offer a solution. In order to keep the example
simple, let's say you wanted the debugging output to be controlled by
an environment variable, \f(CW\*(C`DEBUG\*(C'\fR. Debugging code is enabled if the
variable exists, otherwise it is disabled.
.PP
Two special marker lines will bracket debugging code, like this:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    if ($year > 1999) {
\&       warn "Debug: millennium bug in year $year\en";
\&    }
\&    ## DEBUG_END
.Ve
.PP
The filter ensures that Perl parses the code between the <\s-1DEBUG_BEGIN\s0>
and \f(CW\*(C`DEBUG_END\*(C'\fR markers only when the \f(CW\*(C`DEBUG\*(C'\fR environment variable
exists. That means that when \f(CW\*(C`DEBUG\*(C'\fR does exist, the code above
should be passed through the filter unchanged. The marker lines can
also be passed through as-is, because the Perl parser will see them as
comment lines. When \f(CW\*(C`DEBUG\*(C'\fR isn't set, we need a way to disable the
debug code. A simple way to achieve that is to convert the lines
between the two markers into comments:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    #if ($year > 1999) {
\&    #     warn "Debug: millennium bug in year $year\en";
\&    #}
\&    ## DEBUG_END
.Ve
.PP
Here is the complete Debug filter:
.PP
.Vb 1
\&    package Debug;
\&
\&    use strict;
\&    use warnings;
\&    use Filter::Util::Call;
\&
\&    use constant TRUE => 1;
\&    use constant FALSE => 0;
\&
\&    sub import {
\&       my ($type) = @_;
\&       my (%context) = (
\&         Enabled => defined $ENV{DEBUG},
\&         InTraceBlock => FALSE,
\&         Filename => (caller)[1],
\&         LineNo => 0,
\&         LastBegin => 0,
\&       );
\&       filter_add(bless \e%context);
\&    }
\&
\&    sub Die {
\&       my ($self) = shift;
\&       my ($message) = shift;
\&       my ($line_no) = shift || $self\->{LastBegin};
\&       die "$message at $self\->{Filename} line $line_no.\en"
\&    }
\&
\&    sub filter {
\&       my ($self) = @_;
\&       my ($status);
\&       $status = filter_read();
\&       ++ $self\->{LineNo};
\&
\&       # deal with EOF/error first
\&       if ($status <= 0) {
\&           $self\->Die("DEBUG_BEGIN has no DEBUG_END")
\&               if $self\->{InTraceBlock};
\&           return $status;
\&       }
\&
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_BEGIN/ ) {
\&              $self\->Die("Nested DEBUG_BEGIN", $self\->{LineNo})
\&          } elsif (/^\es*##\es*DEBUG_END/) {
\&              $self\->{InTraceBlock} = FALSE;
\&          }
\&
\&          # comment out the debug lines when the filter is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&          $self\->{LastBegin} = $self\->{LineNo};
\&       } elsif ( /^\es*##\es*DEBUG_END/ ) {
\&          $self\->Die("DEBUG_END has no DEBUG_BEGIN", $self\->{LineNo});
\&       }
\&       return $status;
\&    }
\&
\&    1;
.Ve
.PP
The big difference between this filter and the previous example is the
use of context data in the filter object. The filter object is based on
a hash reference, and is used to keep various pieces of context
information between calls to the filter function. All but two of the
hash fields are used for error reporting. The first of those two,
Enabled, is used by the filter to determine whether the debugging code
should be given to the Perl parser. The second, InTraceBlock, is true
when the filter has encountered a \f(CW\*(C`DEBUG_BEGIN\*(C'\fR line, but has not yet
encountered the following \f(CW\*(C`DEBUG_END\*(C'\fR line.
.PP
If you ignore all the error checking that most of the code does, the
essence of the filter is as follows:
.PP
.Vb 4
\&    sub filter {
\&       my ($self) = @_;
\&       my ($status);
\&       $status = filter_read();
\&
\&       # deal with EOF/error first
\&       return $status if $status <= 0;
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_END/) {
\&             $self\->{InTraceBlock} = FALSE
\&          }
\&
\&          # comment out debug lines when the filter is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&       }
\&       return $status;
\&    }
.Ve
.PP
Be warned: just as the C\-preprocessor doesn't know C, the Debug filter
doesn't know Perl. It can be fooled quite easily:
.PP
.Vb 3
\&    print <<EOM;
\&    ##DEBUG_BEGIN
\&    EOM
.Ve
.PP
Such things aside, you can see that a lot can be achieved with a modest
amount of code.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
You now have better understanding of what a source filter is, and you
might even have a possible use for them. If you feel like playing with
source filters but need a bit of inspiration, here are some extra
features you could add to the Debug filter.
.PP
First, an easy one. Rather than having debugging code that is
all-or-nothing, it would be much more useful to be able to control
which specific blocks of debugging code get included. Try extending the
syntax for debug blocks to allow each to be identified. The contents of
the \f(CW\*(C`DEBUG\*(C'\fR environment variable can then be used to control which
blocks get included.
.PP
Once you can identify individual blocks, try allowing them to be
nested. That isn't difficult either.
.PP
Here is an interesting idea that doesn't involve the Debug filter.
Currently Perl subroutines have fairly limited support for formal
parameter lists. You can specify the number of parameters and their
type, but you still have to manually take them out of the \f(CW@_\fR array
yourself. Write a source filter that allows you to have a named
parameter list. Such a filter would turn this:
.PP
.Vb 1
\&    sub MySub ($first, $second, @rest) { ... }
.Ve
.PP
into this:
.PP
.Vb 6
\&    sub MySub($$@) {
\&       my ($first) = shift;
\&       my ($second) = shift;
\&       my (@rest) = @_;
\&       ...
\&    }
.Ve
.PP
Finally, if you feel like a real challenge, have a go at writing a
full-blown Perl macro preprocessor as a source filter. Borrow the
useful features from the C preprocessor and any other macro processors
you know. The tricky bit will be choosing how much knowledge of Perl's
syntax you want your filter to have.
.SH "THINGS TO LOOK OUT FOR"
.IX Header "THINGS TO LOOK OUT FOR"
.ie n .IP "Some Filters Clobber the ""DATA"" Handle" 5
.el .IP "Some Filters Clobber the \f(CWDATA\fR Handle" 5
.IX Item "Some Filters Clobber the DATA Handle"
Some source filters use the \f(CW\*(C`DATA\*(C'\fR handle to read the calling program.
When using these source filters you cannot rely on this handle, nor expect
any particular kind of behavior when operating on it.  Filters based on
Filter::Util::Call (and therefore Filter::Simple) do not alter the \f(CW\*(C`DATA\*(C'\fR
filehandle.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
The Source Filters distribution is available on \s-1CPAN,\s0 in
.PP
.Vb 1
\&    CPAN/modules/by\-module/Filter
.Ve
.PP
Starting from Perl 5.8 Filter::Util::Call (the core part of the
Source Filters distribution) is part of the standard Perl distribution.
Also included is a friendlier interface called Filter::Simple, by
Damian Conway.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess <Paul.Marquess@btinternet.com>
.SH "Copyrights"
.IX Header "Copyrights"
This article originally appeared in The Perl Journal #11, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and
The Perl Journal.  This document may be distributed under the same terms
as Perl itself.
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfilter5.16.1                             0100644 0001750 0001750 00000065147 12566207417 023441  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFILTER 1"
.TH PERLFILTER 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfilter \- Source Filters
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This article is about a little-known feature of Perl called
\&\fIsource filters\fR. Source filters alter the program text of a module
before Perl sees it, much as a C preprocessor alters the source text of
a C program before the compiler sees it. This article tells you more
about what source filters are, how they work, and how to write your
own.
.PP
The original purpose of source filters was to let you encrypt your
program source to prevent casual piracy. This isn't all they can do, as
you'll soon learn. But first, the basics.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Before the Perl interpreter can execute a Perl script, it must first
read it from a file into memory for parsing and compilation. If that
script itself includes other scripts with a \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR
statement, then each of those scripts will have to be read from their
respective files as well.
.PP
Now think of each logical connection between the Perl parser and an
individual file as a \fIsource stream\fR. A source stream is created when
the Perl parser opens a file, it continues to exist as the source code
is read into memory, and it is destroyed when Perl is finished parsing
the file. If the parser encounters a \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR statement in
a source stream, a new and distinct stream is created just for that
file.
.PP
The diagram below represents a single source stream, with the flow of
source from a Perl script file on the left into the Perl parser on the
right. This is how Perl normally operates.
.PP
.Vb 1
\&    file \-\-\-\-\-\-\-> parser
.Ve
.PP
There are two important points to remember:
.IP "1." 5
Although there can be any number of source streams in existence at any
given time, only one will be active.
.IP "2." 5
Every source stream is associated with only one file.
.PP
A source filter is a special kind of Perl module that intercepts and
modifies a source stream before it reaches the parser. A source filter
changes our diagram like this:
.PP
.Vb 1
\&    file \-\-\-\-> filter \-\-\-\-> parser
.Ve
.PP
If that doesn't make much sense, consider the analogy of a command
pipeline. Say you have a shell script stored in the compressed file
\&\fItrial.gz\fR. The simple pipeline command below runs the script without
needing to create a temporary file to hold the uncompressed file.
.PP
.Vb 1
\&    gunzip \-c trial.gz | sh
.Ve
.PP
In this case, the data flow from the pipeline can be represented as follows:
.PP
.Vb 1
\&    trial.gz \-\-\-\-> gunzip \-\-\-\-> sh
.Ve
.PP
With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:
.PP
.Vb 2
\&     compressed           gunzip
\&    Perl program \-\-\-> source filter \-\-\-> parser
.Ve
.SH "USING FILTERS"
.IX Header "USING FILTERS"
So how do you use a source filter in a Perl script? Above, I said that
a source filter is just a special kind of module. Like all Perl
modules, a source filter is invoked with a use statement.
.PP
Say you want to pass your Perl source through the C preprocessor before
execution. As it happens, the source filters distribution comes with a C
preprocessor filter module called Filter::cpp.
.PP
Below is an example program, \f(CW\*(C`cpp_test\*(C'\fR, which makes use of this filter.
Line numbers have been added to allow specific lines to be referenced
easily.
.PP
.Vb 4
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: $a = TRUE;
\&    4: print "a = $a\en";
.Ve
.PP
When you execute this script, Perl creates a source stream for the
file. Before the parser processes any of the lines from the file, the
source stream looks like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-\-\-\-\-\-> parser
.Ve
.PP
Line 1, \f(CW\*(C`use Filter::cpp\*(C'\fR, includes and installs the \f(CW\*(C`cpp\*(C'\fR filter
module. All source filters work this way. The use statement is compiled
and executed at compile time, before any more of the file is read, and
it attaches the cpp filter to the source stream behind the scenes. Now
the data flow looks like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-> cpp filter \-\-\-\-> parser
.Ve
.PP
As the parser reads the second and subsequent lines from the source
stream, it feeds those lines through the \f(CW\*(C`cpp\*(C'\fR source filter before
processing them. The \f(CW\*(C`cpp\*(C'\fR filter simply passes each line through the
real C preprocessor. The output from the C preprocessor is then
inserted back into the source stream by the filter.
.PP
.Vb 5
\&                  .\-> cpp \-\-.
\&                  |         |
\&                  |         |
\&                  |       <\-\*(Aq
\&   cpp_test \-\-\-\-> cpp filter \-\-\-\-> parser
.Ve
.PP
The parser then sees the following code:
.PP
.Vb 3
\&    use Filter::cpp;
\&    $a = 1;
\&    print "a = $a\en";
.Ve
.PP
Let's consider what happens when the filtered code includes another
module with use:
.PP
.Vb 5
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: use Fred;
\&    4: $a = TRUE;
\&    5: print "a = $a\en";
.Ve
.PP
The \f(CW\*(C`cpp\*(C'\fR filter does not apply to the text of the Fred module, only
to the text of the file that used it (\f(CW\*(C`cpp_test\*(C'\fR). Although the use
statement on line 3 will pass through the cpp filter, the module that
gets included (\f(CW\*(C`Fred\*(C'\fR) will not. The source streams look like this
after line 3 has been parsed and before line 4 is parsed:
.PP
.Vb 1
\&    cpp_test \-\-\-> cpp filter \-\-\-> parser (INACTIVE)
\&
\&    Fred.pm \-\-\-\-> parser
.Ve
.PP
As you can see, a new stream has been created for reading the source
from \f(CW\*(C`Fred.pm\*(C'\fR. This stream will remain active until all of \f(CW\*(C`Fred.pm\*(C'\fR
has been parsed. The source stream for \f(CW\*(C`cpp_test\*(C'\fR will still exist,
but is inactive. Once the parser has finished reading Fred.pm, the
source stream associated with it will be destroyed. The source stream
for \f(CW\*(C`cpp_test\*(C'\fR then becomes active again and the parser reads line 4
and subsequent lines from \f(CW\*(C`cpp_test\*(C'\fR.
.PP
You can use more than one source filter on a single file. Similarly,
you can reuse the same filter in as many files as you like.
.PP
For example, if you have a uuencoded and compressed source file, it is
possible to stack a uudecode filter and an uncompression filter like
this:
.PP
.Vb 4
\&    use Filter::uudecode; use Filter::uncompress;
\&    M\*(AqXL(".H<US4\*(Aq\*(AqV9I;F%L\*(Aq)Q;>7/;1I;_>_I3=&E=%:F*I"T?22Q/
\&    M6]9*<IQCO*XFT"0[PL%%\*(AqY+IG?WN^ZYN\-$\*(AqJ.[.JE$,20/?K=_[>
\&    ...
.Ve
.PP
Once the first line has been processed, the flow will look like this:
.PP
.Vb 2
\&    file \-\-\-> uudecode \-\-\-> uncompress \-\-\-> parser
\&               filter         filter
.Ve
.PP
Data flows through filters in the same order they appear in the source
file. The uudecode filter appeared before the uncompress filter, so the
source file will be uudecoded before it's uncompressed.
.SH "WRITING A SOURCE FILTER"
.IX Header "WRITING A SOURCE FILTER"
There are three ways to write your own source filter. You can write it
in C, use an external program as a filter, or write the filter in Perl.
I won't cover the first two in any great detail, so I'll get them out
of the way first. Writing the filter in Perl is most convenient, so
I'll devote the most space to it.
.SH "WRITING A SOURCE FILTER IN C"
.IX Header "WRITING A SOURCE FILTER IN C"
The first of the three available techniques is to write the filter
completely in C. The external module you create interfaces directly
with the source filter hooks provided by Perl.
.PP
The advantage of this technique is that you have complete control over
the implementation of your filter. The big disadvantage is the
increased complexity required to write the filter \- not only do you
need to understand the source filter hooks, but you also need a
reasonable knowledge of Perl guts. One of the few times it is worth
going to this trouble is when writing a source scrambler. The
\&\f(CW\*(C`decrypt\*(C'\fR filter (which unscrambles the source before Perl parses it)
included with the source filter distribution is an example of a C
source filter (see Decryption Filters, below).
.IP "\fBDecryption Filters\fR" 5
.IX Item "Decryption Filters"
All decryption filters work on the principle of \*(L"security through
obscurity.\*(R" Regardless of how well you write a decryption filter and
how strong your encryption algorithm is, anyone determined enough can
retrieve the original source code. The reason is quite simple \- once
the decryption filter has decrypted the source back to its original
form, fragments of it will be stored in the computer's memory as Perl
parses it. The source might only be in memory for a short period of
time, but anyone possessing a debugger, skill, and lots of patience can
eventually reconstruct your program.
.Sp
That said, there are a number of steps that can be taken to make life
difficult for the potential cracker. The most important: Write your
decryption filter in C and statically link the decryption module into
the Perl binary. For further tips to make life difficult for the
potential cracker, see the file \fIdecrypt.pm\fR in the source filters
distribution.
.SH "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
.IX Header "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
An alternative to writing the filter in C is to create a separate
executable in the language of your choice. The separate executable
reads from standard input, does whatever processing is necessary, and
writes the filtered data to standard output. \f(CW\*(C`Filter::cpp\*(C'\fR is an
example of a source filter implemented as a separate executable \- the
executable is the C preprocessor bundled with your C compiler.
.PP
The source filter distribution includes two modules that simplify this
task: \f(CW\*(C`Filter::exec\*(C'\fR and \f(CW\*(C`Filter::sh\*(C'\fR. Both allow you to run any
external executable. Both use a coprocess to control the flow of data
into and out of the external executable. (For details on coprocesses,
see Stephens, W.R., \*(L"Advanced Programming in the \s-1UNIX\s0 Environment.\*(R"
Addison-Wesley, \s-1ISBN\s0 0\-210\-56317\-7, pages 441\-445.) The difference
between them is that \f(CW\*(C`Filter::exec\*(C'\fR spawns the external command
directly, while \f(CW\*(C`Filter::sh\*(C'\fR spawns a shell to execute the external
command. (Unix uses the Bourne shell; \s-1NT\s0 uses the cmd shell.) Spawning
a shell allows you to make use of the shell metacharacters and
redirection facilities.
.PP
Here is an example script that uses \f(CW\*(C`Filter::sh\*(C'\fR:
.PP
.Vb 3
\&    use Filter::sh \*(Aqtr XYZ PQR\*(Aq;
\&    $a = 1;
\&    print "XYZ a = $a\en";
.Ve
.PP
The output you'll get when the script is executed:
.PP
.Vb 1
\&    PQR a = 1
.Ve
.PP
Writing a source filter as a separate executable works fine, but a
small performance penalty is incurred. For example, if you execute the
small example above, a separate subprocess will be created to run the
Unix \f(CW\*(C`tr\*(C'\fR command. Each use of the filter requires its own subprocess.
If creating subprocesses is expensive on your system, you might want to
consider one of the other options for creating source filters.
.SH "WRITING A SOURCE FILTER IN PERL"
.IX Header "WRITING A SOURCE FILTER IN PERL"
The easiest and most portable option available for creating your own
source filter is to write it completely in Perl. To distinguish this
from the previous two techniques, I'll call it a Perl source filter.
.PP
To help understand how to write a Perl source filter we need an example
to study. Here is a complete source filter that performs rot13
decoding. (Rot13 is a very simple encryption scheme used in Usenet
postings to hide the contents of offensive posts. It moves every letter
forward thirteen places, so that A becomes N, B becomes O, and Z
becomes M.)
.PP
.Vb 1
\&   package Rot13;
\&
\&   use Filter::Util::Call;
\&
\&   sub import {
\&      my ($type) = @_;
\&      my ($ref) = [];
\&      filter_add(bless $ref);
\&   }
\&
\&   sub filter {
\&      my ($self) = @_;
\&      my ($status);
\&
\&      tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/
\&         if ($status = filter_read()) > 0;
\&      $status;
\&   }
\&
\&   1;
.Ve
.PP
All Perl source filters are implemented as Perl classes and have the
same basic structure as the example above.
.PP
First, we include the \f(CW\*(C`Filter::Util::Call\*(C'\fR module, which exports a
number of functions into your filter's namespace. The filter shown
above uses two of these functions, \f(CW\*(C`filter_add()\*(C'\fR and
\&\f(CW\*(C`filter_read()\*(C'\fR.
.PP
Next, we create the filter object and associate it with the source
stream by defining the \f(CW\*(C`import\*(C'\fR function. If you know Perl well
enough, you know that \f(CW\*(C`import\*(C'\fR is called automatically every time a
module is included with a use statement. This makes \f(CW\*(C`import\*(C'\fR the ideal
place to both create and install a filter object.
.PP
In the example filter, the object (\f(CW$ref\fR) is blessed just like any
other Perl object. Our example uses an anonymous array, but this isn't
a requirement. Because this example doesn't need to store any context
information, we could have used a scalar or hash reference just as
well. The next section demonstrates context data.
.PP
The association between the filter object and the source stream is made
with the \f(CW\*(C`filter_add()\*(C'\fR function. This takes a filter object as a
parameter (\f(CW$ref\fR in this case) and installs it in the source stream.
.PP
Finally, there is the code that actually does the filtering. For this
type of Perl source filter, all the filtering is done in a method
called \f(CW\*(C`filter()\*(C'\fR. (It is also possible to write a Perl source filter
using a closure. See the \f(CW\*(C`Filter::Util::Call\*(C'\fR manual page for more
details.) It's called every time the Perl parser needs another line of
source to process. The \f(CW\*(C`filter()\*(C'\fR method, in turn, reads lines from
the source stream using the \f(CW\*(C`filter_read()\*(C'\fR function.
.PP
If a line was available from the source stream, \f(CW\*(C`filter_read()\*(C'\fR
returns a status value greater than zero and appends the line to \f(CW$_\fR.
A status value of zero indicates end-of-file, less than zero means an
error. The filter function itself is expected to return its status in
the same way, and put the filtered line it wants written to the source
stream in \f(CW$_\fR. The use of \f(CW$_\fR accounts for the brevity of most Perl
source filters.
.PP
In order to make use of the rot13 filter we need some way of encoding
the source file in rot13 format. The script below, \f(CW\*(C`mkrot13\*(C'\fR, does
just that.
.PP
.Vb 5
\&    die "usage mkrot13 filename\en" unless @ARGV;
\&    my $in = $ARGV[0];
\&    my $out = "$in.tmp";
\&    open(IN, "<$in") or die "Cannot open file $in: $!\en";
\&    open(OUT, ">$out") or die "Cannot open file $out: $!\en";
\&
\&    print OUT "use Rot13;\en";
\&    while (<IN>) {
\&       tr/a\-zA\-Z/n\-za\-mN\-ZA\-M/;
\&       print OUT;
\&    }
\&
\&    close IN;
\&    close OUT;
\&    unlink $in;
\&    rename $out, $in;
.Ve
.PP
If we encrypt this with \f(CW\*(C`mkrot13\*(C'\fR:
.PP
.Vb 1
\&    print " hello fred \en";
.Ve
.PP
the result will be this:
.PP
.Vb 2
\&    use Rot13;
\&    cevag "uryyb serq\ea";
.Ve
.PP
Running it produces this output:
.PP
.Vb 1
\&    hello fred
.Ve
.SH "USING CONTEXT: THE DEBUG FILTER"
.IX Header "USING CONTEXT: THE DEBUG FILTER"
The rot13 example was a trivial example. Here's another demonstration
that shows off a few more features.
.PP
Say you wanted to include a lot of debugging code in your Perl script
during development, but you didn't want it available in the released
product. Source filters offer a solution. In order to keep the example
simple, let's say you wanted the debugging output to be controlled by
an environment variable, \f(CW\*(C`DEBUG\*(C'\fR. Debugging code is enabled if the
variable exists, otherwise it is disabled.
.PP
Two special marker lines will bracket debugging code, like this:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    if ($year > 1999) {
\&       warn "Debug: millennium bug in year $year\en";
\&    }
\&    ## DEBUG_END
.Ve
.PP
The filter ensures that Perl parses the code between the <\s-1DEBUG_BEGIN\s0>
and \f(CW\*(C`DEBUG_END\*(C'\fR markers only when the \f(CW\*(C`DEBUG\*(C'\fR environment variable
exists. That means that when \f(CW\*(C`DEBUG\*(C'\fR does exist, the code above
should be passed through the filter unchanged. The marker lines can
also be passed through as-is, because the Perl parser will see them as
comment lines. When \f(CW\*(C`DEBUG\*(C'\fR isn't set, we need a way to disable the
debug code. A simple way to achieve that is to convert the lines
between the two markers into comments:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    #if ($year > 1999) {
\&    #     warn "Debug: millennium bug in year $year\en";
\&    #}
\&    ## DEBUG_END
.Ve
.PP
Here is the complete Debug filter:
.PP
.Vb 1
\&    package Debug;
\&
\&    use strict;
\&    use warnings;
\&    use Filter::Util::Call;
\&
\&    use constant TRUE => 1;
\&    use constant FALSE => 0;
\&
\&    sub import {
\&       my ($type) = @_;
\&       my (%context) = (
\&         Enabled => defined $ENV{DEBUG},
\&         InTraceBlock => FALSE,
\&         Filename => (caller)[1],
\&         LineNo => 0,
\&         LastBegin => 0,
\&       );
\&       filter_add(bless \e%context);
\&    }
\&
\&    sub Die {
\&       my ($self) = shift;
\&       my ($message) = shift;
\&       my ($line_no) = shift || $self\->{LastBegin};
\&       die "$message at $self\->{Filename} line $line_no.\en"
\&    }
\&
\&    sub filter {
\&       my ($self) = @_;
\&       my ($status);
\&       $status = filter_read();
\&       ++ $self\->{LineNo};
\&
\&       # deal with EOF/error first
\&       if ($status <= 0) {
\&           $self\->Die("DEBUG_BEGIN has no DEBUG_END")
\&               if $self\->{InTraceBlock};
\&           return $status;
\&       }
\&
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_BEGIN/ ) {
\&              $self\->Die("Nested DEBUG_BEGIN", $self\->{LineNo})
\&          } elsif (/^\es*##\es*DEBUG_END/) {
\&              $self\->{InTraceBlock} = FALSE;
\&          }
\&
\&          # comment out the debug lines when the filter is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&          $self\->{LastBegin} = $self\->{LineNo};
\&       } elsif ( /^\es*##\es*DEBUG_END/ ) {
\&          $self\->Die("DEBUG_END has no DEBUG_BEGIN", $self\->{LineNo});
\&       }
\&       return $status;
\&    }
\&
\&    1;
.Ve
.PP
The big difference between this filter and the previous example is the
use of context data in the filter object. The filter object is based on
a hash reference, and is used to keep various pieces of context
information between calls to the filter function. All but two of the
hash fields are used for error reporting. The first of those two,
Enabled, is used by the filter to determine whether the debugging code
should be given to the Perl parser. The second, InTraceBlock, is true
when the filter has encountered a \f(CW\*(C`DEBUG_BEGIN\*(C'\fR line, but has not yet
encountered the following \f(CW\*(C`DEBUG_END\*(C'\fR line.
.PP
If you ignore all the error checking that most of the code does, the
essence of the filter is as follows:
.PP
.Vb 4
\&    sub filter {
\&       my ($self) = @_;
\&       my ($status);
\&       $status = filter_read();
\&
\&       # deal with EOF/error first
\&       return $status if $status <= 0;
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_END/) {
\&             $self\->{InTraceBlock} = FALSE
\&          }
\&
\&          # comment out debug lines when the filter is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&       }
\&       return $status;
\&    }
.Ve
.PP
Be warned: just as the C\-preprocessor doesn't know C, the Debug filter
doesn't know Perl. It can be fooled quite easily:
.PP
.Vb 3
\&    print <<EOM;
\&    ##DEBUG_BEGIN
\&    EOM
.Ve
.PP
Such things aside, you can see that a lot can be achieved with a modest
amount of code.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
You now have better understanding of what a source filter is, and you
might even have a possible use for them. If you feel like playing with
source filters but need a bit of inspiration, here are some extra
features you could add to the Debug filter.
.PP
First, an easy one. Rather than having debugging code that is
all-or-nothing, it would be much more useful to be able to control
which specific blocks of debugging code get included. Try extending the
syntax for debug blocks to allow each to be identified. The contents of
the \f(CW\*(C`DEBUG\*(C'\fR environment variable can then be used to control which
blocks get included.
.PP
Once you can identify individual blocks, try allowing them to be
nested. That isn't difficult either.
.PP
Here is an interesting idea that doesn't involve the Debug filter.
Currently Perl subroutines have fairly limited support for formal
parameter lists. You can specify the number of parameters and their
type, but you still have to manually take them out of the \f(CW@_\fR array
yourself. Write a source filter that allows you to have a named
parameter list. Such a filter would turn this:
.PP
.Vb 1
\&    sub MySub ($first, $second, @rest) { ... }
.Ve
.PP
into this:
.PP
.Vb 6
\&    sub MySub($$@) {
\&       my ($first) = shift;
\&       my ($second) = shift;
\&       my (@rest) = @_;
\&       ...
\&    }
.Ve
.PP
Finally, if you feel like a real challenge, have a go at writing a
full-blown Perl macro preprocessor as a source filter. Borrow the
useful features from the C preprocessor and any other macro processors
you know. The tricky bit will be choosing how much knowledge of Perl's
syntax you want your filter to have.
.SH "THINGS TO LOOK OUT FOR"
.IX Header "THINGS TO LOOK OUT FOR"
.ie n .IP "Some Filters Clobber the ""DATA"" Handle" 5
.el .IP "Some Filters Clobber the \f(CWDATA\fR Handle" 5
.IX Item "Some Filters Clobber the DATA Handle"
Some source filters use the \f(CW\*(C`DATA\*(C'\fR handle to read the calling program.
When using these source filters you cannot rely on this handle, nor expect
any particular kind of behavior when operating on it.  Filters based on
Filter::Util::Call (and therefore Filter::Simple) do not alter the \f(CW\*(C`DATA\*(C'\fR
filehandle.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
The Source Filters distribution is available on \s-1CPAN\s0, in
.PP
.Vb 1
\&    CPAN/modules/by\-module/Filter
.Ve
.PP
Starting from Perl 5.8 Filter::Util::Call (the core part of the
Source Filters distribution) is part of the standard Perl distribution.
Also included is a friendlier interface called Filter::Simple, by
Damian Conway.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess <Paul.Marquess@btinternet.com>
.SH "Copyrights"
.IX Header "Copyrights"
This article originally appeared in The Perl Journal #11, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and
The Perl Journal.  This document may be distributed under the same terms
as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfilter5.18.1                             0100644 0001750 0001750 00000065470 12566207437 023444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFILTER 1"
.TH PERLFILTER 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfilter \- Source Filters
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This article is about a little-known feature of Perl called
\&\fIsource filters\fR. Source filters alter the program text of a module
before Perl sees it, much as a C preprocessor alters the source text of
a C program before the compiler sees it. This article tells you more
about what source filters are, how they work, and how to write your
own.
.PP
The original purpose of source filters was to let you encrypt your
program source to prevent casual piracy. This isn't all they can do, as
you'll soon learn. But first, the basics.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Before the Perl interpreter can execute a Perl script, it must first
read it from a file into memory for parsing and compilation. If that
script itself includes other scripts with a \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR
statement, then each of those scripts will have to be read from their
respective files as well.
.PP
Now think of each logical connection between the Perl parser and an
individual file as a \fIsource stream\fR. A source stream is created when
the Perl parser opens a file, it continues to exist as the source code
is read into memory, and it is destroyed when Perl is finished parsing
the file. If the parser encounters a \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR statement in
a source stream, a new and distinct stream is created just for that
file.
.PP
The diagram below represents a single source stream, with the flow of
source from a Perl script file on the left into the Perl parser on the
right. This is how Perl normally operates.
.PP
.Vb 1
\&    file \-\-\-\-\-\-\-> parser
.Ve
.PP
There are two important points to remember:
.IP "1." 5
Although there can be any number of source streams in existence at any
given time, only one will be active.
.IP "2." 5
Every source stream is associated with only one file.
.PP
A source filter is a special kind of Perl module that intercepts and
modifies a source stream before it reaches the parser. A source filter
changes our diagram like this:
.PP
.Vb 1
\&    file \-\-\-\-> filter \-\-\-\-> parser
.Ve
.PP
If that doesn't make much sense, consider the analogy of a command
pipeline. Say you have a shell script stored in the compressed file
\&\fItrial.gz\fR. The simple pipeline command below runs the script without
needing to create a temporary file to hold the uncompressed file.
.PP
.Vb 1
\&    gunzip \-c trial.gz | sh
.Ve
.PP
In this case, the data flow from the pipeline can be represented as follows:
.PP
.Vb 1
\&    trial.gz \-\-\-\-> gunzip \-\-\-\-> sh
.Ve
.PP
With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:
.PP
.Vb 2
\&     compressed           gunzip
\&    Perl program \-\-\-> source filter \-\-\-> parser
.Ve
.SH "USING FILTERS"
.IX Header "USING FILTERS"
So how do you use a source filter in a Perl script? Above, I said that
a source filter is just a special kind of module. Like all Perl
modules, a source filter is invoked with a use statement.
.PP
Say you want to pass your Perl source through the C preprocessor before
execution. As it happens, the source filters distribution comes with a C
preprocessor filter module called Filter::cpp.
.PP
Below is an example program, \f(CW\*(C`cpp_test\*(C'\fR, which makes use of this filter.
Line numbers have been added to allow specific lines to be referenced
easily.
.PP
.Vb 4
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: $a = TRUE;
\&    4: print "a = $a\en";
.Ve
.PP
When you execute this script, Perl creates a source stream for the
file. Before the parser processes any of the lines from the file, the
source stream looks like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-\-\-\-\-\-> parser
.Ve
.PP
Line 1, \f(CW\*(C`use Filter::cpp\*(C'\fR, includes and installs the \f(CW\*(C`cpp\*(C'\fR filter
module. All source filters work this way. The use statement is compiled
and executed at compile time, before any more of the file is read, and
it attaches the cpp filter to the source stream behind the scenes. Now
the data flow looks like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-> cpp filter \-\-\-\-> parser
.Ve
.PP
As the parser reads the second and subsequent lines from the source
stream, it feeds those lines through the \f(CW\*(C`cpp\*(C'\fR source filter before
processing them. The \f(CW\*(C`cpp\*(C'\fR filter simply passes each line through the
real C preprocessor. The output from the C preprocessor is then
inserted back into the source stream by the filter.
.PP
.Vb 5
\&                  .\-> cpp \-\-.
\&                  |         |
\&                  |         |
\&                  |       <\-\*(Aq
\&   cpp_test \-\-\-\-> cpp filter \-\-\-\-> parser
.Ve
.PP
The parser then sees the following code:
.PP
.Vb 3
\&    use Filter::cpp;
\&    $a = 1;
\&    print "a = $a\en";
.Ve
.PP
Let's consider what happens when the filtered code includes another
module with use:
.PP
.Vb 5
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: use Fred;
\&    4: $a = TRUE;
\&    5: print "a = $a\en";
.Ve
.PP
The \f(CW\*(C`cpp\*(C'\fR filter does not apply to the text of the Fred module, only
to the text of the file that used it (\f(CW\*(C`cpp_test\*(C'\fR). Although the use
statement on line 3 will pass through the cpp filter, the module that
gets included (\f(CW\*(C`Fred\*(C'\fR) will not. The source streams look like this
after line 3 has been parsed and before line 4 is parsed:
.PP
.Vb 1
\&    cpp_test \-\-\-> cpp filter \-\-\-> parser (INACTIVE)
\&
\&    Fred.pm \-\-\-\-> parser
.Ve
.PP
As you can see, a new stream has been created for reading the source
from \f(CW\*(C`Fred.pm\*(C'\fR. This stream will remain active until all of \f(CW\*(C`Fred.pm\*(C'\fR
has been parsed. The source stream for \f(CW\*(C`cpp_test\*(C'\fR will still exist,
but is inactive. Once the parser has finished reading Fred.pm, the
source stream associated with it will be destroyed. The source stream
for \f(CW\*(C`cpp_test\*(C'\fR then becomes active again and the parser reads line 4
and subsequent lines from \f(CW\*(C`cpp_test\*(C'\fR.
.PP
You can use more than one source filter on a single file. Similarly,
you can reuse the same filter in as many files as you like.
.PP
For example, if you have a uuencoded and compressed source file, it is
possible to stack a uudecode filter and an uncompression filter like
this:
.PP
.Vb 4
\&    use Filter::uudecode; use Filter::uncompress;
\&    M\*(AqXL(".H<US4\*(Aq\*(AqV9I;F%L\*(Aq)Q;>7/;1I;_>_I3=&E=%:F*I"T?22Q/
\&    M6]9*<IQCO*XFT"0[PL%%\*(AqY+IG?WN^ZYN\-$\*(AqJ.[.JE$,20/?K=_[>
\&    ...
.Ve
.PP
Once the first line has been processed, the flow will look like this:
.PP
.Vb 2
\&    file \-\-\-> uudecode \-\-\-> uncompress \-\-\-> parser
\&               filter         filter
.Ve
.PP
Data flows through filters in the same order they appear in the source
file. The uudecode filter appeared before the uncompress filter, so the
source file will be uudecoded before it's uncompressed.
.SH "WRITING A SOURCE FILTER"
.IX Header "WRITING A SOURCE FILTER"
There are three ways to write your own source filter. You can write it
in C, use an external program as a filter, or write the filter in Perl.
I won't cover the first two in any great detail, so I'll get them out
of the way first. Writing the filter in Perl is most convenient, so
I'll devote the most space to it.
.SH "WRITING A SOURCE FILTER IN C"
.IX Header "WRITING A SOURCE FILTER IN C"
The first of the three available techniques is to write the filter
completely in C. The external module you create interfaces directly
with the source filter hooks provided by Perl.
.PP
The advantage of this technique is that you have complete control over
the implementation of your filter. The big disadvantage is the
increased complexity required to write the filter \- not only do you
need to understand the source filter hooks, but you also need a
reasonable knowledge of Perl guts. One of the few times it is worth
going to this trouble is when writing a source scrambler. The
\&\f(CW\*(C`decrypt\*(C'\fR filter (which unscrambles the source before Perl parses it)
included with the source filter distribution is an example of a C
source filter (see Decryption Filters, below).
.IP "\fBDecryption Filters\fR" 5
.IX Item "Decryption Filters"
All decryption filters work on the principle of \*(L"security through
obscurity.\*(R" Regardless of how well you write a decryption filter and
how strong your encryption algorithm is, anyone determined enough can
retrieve the original source code. The reason is quite simple \- once
the decryption filter has decrypted the source back to its original
form, fragments of it will be stored in the computer's memory as Perl
parses it. The source might only be in memory for a short period of
time, but anyone possessing a debugger, skill, and lots of patience can
eventually reconstruct your program.
.Sp
That said, there are a number of steps that can be taken to make life
difficult for the potential cracker. The most important: Write your
decryption filter in C and statically link the decryption module into
the Perl binary. For further tips to make life difficult for the
potential cracker, see the file \fIdecrypt.pm\fR in the source filters
distribution.
.SH "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
.IX Header "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
An alternative to writing the filter in C is to create a separate
executable in the language of your choice. The separate executable
reads from standard input, does whatever processing is necessary, and
writes the filtered data to standard output. \f(CW\*(C`Filter::cpp\*(C'\fR is an
example of a source filter implemented as a separate executable \- the
executable is the C preprocessor bundled with your C compiler.
.PP
The source filter distribution includes two modules that simplify this
task: \f(CW\*(C`Filter::exec\*(C'\fR and \f(CW\*(C`Filter::sh\*(C'\fR. Both allow you to run any
external executable. Both use a coprocess to control the flow of data
into and out of the external executable. (For details on coprocesses,
see Stephens, W.R., \*(L"Advanced Programming in the \s-1UNIX\s0 Environment.\*(R"
Addison-Wesley, \s-1ISBN 0\-210\-56317\-7,\s0 pages 441\-445.) The difference
between them is that \f(CW\*(C`Filter::exec\*(C'\fR spawns the external command
directly, while \f(CW\*(C`Filter::sh\*(C'\fR spawns a shell to execute the external
command. (Unix uses the Bourne shell; \s-1NT\s0 uses the cmd shell.) Spawning
a shell allows you to make use of the shell metacharacters and
redirection facilities.
.PP
Here is an example script that uses \f(CW\*(C`Filter::sh\*(C'\fR:
.PP
.Vb 3
\&    use Filter::sh \*(Aqtr XYZ PQR\*(Aq;
\&    $a = 1;
\&    print "XYZ a = $a\en";
.Ve
.PP
The output you'll get when the script is executed:
.PP
.Vb 1
\&    PQR a = 1
.Ve
.PP
Writing a source filter as a separate executable works fine, but a
small performance penalty is incurred. For example, if you execute the
small example above, a separate subprocess will be created to run the
Unix \f(CW\*(C`tr\*(C'\fR command. Each use of the filter requires its own subprocess.
If creating subprocesses is expensive on your system, you might want to
consider one of the other options for creating source filters.
.SH "WRITING A SOURCE FILTER IN PERL"
.IX Header "WRITING A SOURCE FILTER IN PERL"
The easiest and most portable option available for creating your own
source filter is to write it completely in Perl. To distinguish this
from the previous two techniques, I'll call it a Perl source filter.
.PP
To help understand how to write a Perl source filter we need an example
to study. Here is a complete source filter that performs rot13
decoding. (Rot13 is a very simple encryption scheme used in Usenet
postings to hide the contents of offensive posts. It moves every letter
forward thirteen places, so that A becomes N, B becomes O, and Z
becomes M.)
.PP
.Vb 1
\&   package Rot13;
\&
\&   use Filter::Util::Call;
\&
\&   sub import {
\&      my ($type) = @_;
\&      my ($ref) = [];
\&      filter_add(bless $ref);
\&   }
\&
\&   sub filter {
\&      my ($self) = @_;
\&      my ($status);
\&
\&      tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/
\&         if ($status = filter_read()) > 0;
\&      $status;
\&   }
\&
\&   1;
.Ve
.PP
All Perl source filters are implemented as Perl classes and have the
same basic structure as the example above.
.PP
First, we include the \f(CW\*(C`Filter::Util::Call\*(C'\fR module, which exports a
number of functions into your filter's namespace. The filter shown
above uses two of these functions, \f(CW\*(C`filter_add()\*(C'\fR and
\&\f(CW\*(C`filter_read()\*(C'\fR.
.PP
Next, we create the filter object and associate it with the source
stream by defining the \f(CW\*(C`import\*(C'\fR function. If you know Perl well
enough, you know that \f(CW\*(C`import\*(C'\fR is called automatically every time a
module is included with a use statement. This makes \f(CW\*(C`import\*(C'\fR the ideal
place to both create and install a filter object.
.PP
In the example filter, the object (\f(CW$ref\fR) is blessed just like any
other Perl object. Our example uses an anonymous array, but this isn't
a requirement. Because this example doesn't need to store any context
information, we could have used a scalar or hash reference just as
well. The next section demonstrates context data.
.PP
The association between the filter object and the source stream is made
with the \f(CW\*(C`filter_add()\*(C'\fR function. This takes a filter object as a
parameter (\f(CW$ref\fR in this case) and installs it in the source stream.
.PP
Finally, there is the code that actually does the filtering. For this
type of Perl source filter, all the filtering is done in a method
called \f(CW\*(C`filter()\*(C'\fR. (It is also possible to write a Perl source filter
using a closure. See the \f(CW\*(C`Filter::Util::Call\*(C'\fR manual page for more
details.) It's called every time the Perl parser needs another line of
source to process. The \f(CW\*(C`filter()\*(C'\fR method, in turn, reads lines from
the source stream using the \f(CW\*(C`filter_read()\*(C'\fR function.
.PP
If a line was available from the source stream, \f(CW\*(C`filter_read()\*(C'\fR
returns a status value greater than zero and appends the line to \f(CW$_\fR.
A status value of zero indicates end-of-file, less than zero means an
error. The filter function itself is expected to return its status in
the same way, and put the filtered line it wants written to the source
stream in \f(CW$_\fR. The use of \f(CW$_\fR accounts for the brevity of most Perl
source filters.
.PP
In order to make use of the rot13 filter we need some way of encoding
the source file in rot13 format. The script below, \f(CW\*(C`mkrot13\*(C'\fR, does
just that.
.PP
.Vb 5
\&    die "usage mkrot13 filename\en" unless @ARGV;
\&    my $in = $ARGV[0];
\&    my $out = "$in.tmp";
\&    open(IN, "<$in") or die "Cannot open file $in: $!\en";
\&    open(OUT, ">$out") or die "Cannot open file $out: $!\en";
\&
\&    print OUT "use Rot13;\en";
\&    while (<IN>) {
\&       tr/a\-zA\-Z/n\-za\-mN\-ZA\-M/;
\&       print OUT;
\&    }
\&
\&    close IN;
\&    close OUT;
\&    unlink $in;
\&    rename $out, $in;
.Ve
.PP
If we encrypt this with \f(CW\*(C`mkrot13\*(C'\fR:
.PP
.Vb 1
\&    print " hello fred \en";
.Ve
.PP
the result will be this:
.PP
.Vb 2
\&    use Rot13;
\&    cevag "uryyb serq\ea";
.Ve
.PP
Running it produces this output:
.PP
.Vb 1
\&    hello fred
.Ve
.SH "USING CONTEXT: THE DEBUG FILTER"
.IX Header "USING CONTEXT: THE DEBUG FILTER"
The rot13 example was a trivial example. Here's another demonstration
that shows off a few more features.
.PP
Say you wanted to include a lot of debugging code in your Perl script
during development, but you didn't want it available in the released
product. Source filters offer a solution. In order to keep the example
simple, let's say you wanted the debugging output to be controlled by
an environment variable, \f(CW\*(C`DEBUG\*(C'\fR. Debugging code is enabled if the
variable exists, otherwise it is disabled.
.PP
Two special marker lines will bracket debugging code, like this:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    if ($year > 1999) {
\&       warn "Debug: millennium bug in year $year\en";
\&    }
\&    ## DEBUG_END
.Ve
.PP
The filter ensures that Perl parses the code between the <\s-1DEBUG_BEGIN\s0>
and \f(CW\*(C`DEBUG_END\*(C'\fR markers only when the \f(CW\*(C`DEBUG\*(C'\fR environment variable
exists. That means that when \f(CW\*(C`DEBUG\*(C'\fR does exist, the code above
should be passed through the filter unchanged. The marker lines can
also be passed through as-is, because the Perl parser will see them as
comment lines. When \f(CW\*(C`DEBUG\*(C'\fR isn't set, we need a way to disable the
debug code. A simple way to achieve that is to convert the lines
between the two markers into comments:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    #if ($year > 1999) {
\&    #     warn "Debug: millennium bug in year $year\en";
\&    #}
\&    ## DEBUG_END
.Ve
.PP
Here is the complete Debug filter:
.PP
.Vb 1
\&    package Debug;
\&
\&    use strict;
\&    use warnings;
\&    use Filter::Util::Call;
\&
\&    use constant TRUE => 1;
\&    use constant FALSE => 0;
\&
\&    sub import {
\&       my ($type) = @_;
\&       my (%context) = (
\&         Enabled => defined $ENV{DEBUG},
\&         InTraceBlock => FALSE,
\&         Filename => (caller)[1],
\&         LineNo => 0,
\&         LastBegin => 0,
\&       );
\&       filter_add(bless \e%context);
\&    }
\&
\&    sub Die {
\&       my ($self) = shift;
\&       my ($message) = shift;
\&       my ($line_no) = shift || $self\->{LastBegin};
\&       die "$message at $self\->{Filename} line $line_no.\en"
\&    }
\&
\&    sub filter {
\&       my ($self) = @_;
\&       my ($status);
\&       $status = filter_read();
\&       ++ $self\->{LineNo};
\&
\&       # deal with EOF/error first
\&       if ($status <= 0) {
\&           $self\->Die("DEBUG_BEGIN has no DEBUG_END")
\&               if $self\->{InTraceBlock};
\&           return $status;
\&       }
\&
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_BEGIN/ ) {
\&              $self\->Die("Nested DEBUG_BEGIN", $self\->{LineNo})
\&          } elsif (/^\es*##\es*DEBUG_END/) {
\&              $self\->{InTraceBlock} = FALSE;
\&          }
\&
\&          # comment out the debug lines when the filter is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&          $self\->{LastBegin} = $self\->{LineNo};
\&       } elsif ( /^\es*##\es*DEBUG_END/ ) {
\&          $self\->Die("DEBUG_END has no DEBUG_BEGIN", $self\->{LineNo});
\&       }
\&       return $status;
\&    }
\&
\&    1;
.Ve
.PP
The big difference between this filter and the previous example is the
use of context data in the filter object. The filter object is based on
a hash reference, and is used to keep various pieces of context
information between calls to the filter function. All but two of the
hash fields are used for error reporting. The first of those two,
Enabled, is used by the filter to determine whether the debugging code
should be given to the Perl parser. The second, InTraceBlock, is true
when the filter has encountered a \f(CW\*(C`DEBUG_BEGIN\*(C'\fR line, but has not yet
encountered the following \f(CW\*(C`DEBUG_END\*(C'\fR line.
.PP
If you ignore all the error checking that most of the code does, the
essence of the filter is as follows:
.PP
.Vb 4
\&    sub filter {
\&       my ($self) = @_;
\&       my ($status);
\&       $status = filter_read();
\&
\&       # deal with EOF/error first
\&       return $status if $status <= 0;
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_END/) {
\&             $self\->{InTraceBlock} = FALSE
\&          }
\&
\&          # comment out debug lines when the filter is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&       }
\&       return $status;
\&    }
.Ve
.PP
Be warned: just as the C\-preprocessor doesn't know C, the Debug filter
doesn't know Perl. It can be fooled quite easily:
.PP
.Vb 3
\&    print <<EOM;
\&    ##DEBUG_BEGIN
\&    EOM
.Ve
.PP
Such things aside, you can see that a lot can be achieved with a modest
amount of code.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
You now have better understanding of what a source filter is, and you
might even have a possible use for them. If you feel like playing with
source filters but need a bit of inspiration, here are some extra
features you could add to the Debug filter.
.PP
First, an easy one. Rather than having debugging code that is
all-or-nothing, it would be much more useful to be able to control
which specific blocks of debugging code get included. Try extending the
syntax for debug blocks to allow each to be identified. The contents of
the \f(CW\*(C`DEBUG\*(C'\fR environment variable can then be used to control which
blocks get included.
.PP
Once you can identify individual blocks, try allowing them to be
nested. That isn't difficult either.
.PP
Here is an interesting idea that doesn't involve the Debug filter.
Currently Perl subroutines have fairly limited support for formal
parameter lists. You can specify the number of parameters and their
type, but you still have to manually take them out of the \f(CW@_\fR array
yourself. Write a source filter that allows you to have a named
parameter list. Such a filter would turn this:
.PP
.Vb 1
\&    sub MySub ($first, $second, @rest) { ... }
.Ve
.PP
into this:
.PP
.Vb 6
\&    sub MySub($$@) {
\&       my ($first) = shift;
\&       my ($second) = shift;
\&       my (@rest) = @_;
\&       ...
\&    }
.Ve
.PP
Finally, if you feel like a real challenge, have a go at writing a
full-blown Perl macro preprocessor as a source filter. Borrow the
useful features from the C preprocessor and any other macro processors
you know. The tricky bit will be choosing how much knowledge of Perl's
syntax you want your filter to have.
.SH "THINGS TO LOOK OUT FOR"
.IX Header "THINGS TO LOOK OUT FOR"
.ie n .IP "Some Filters Clobber the ""DATA"" Handle" 5
.el .IP "Some Filters Clobber the \f(CWDATA\fR Handle" 5
.IX Item "Some Filters Clobber the DATA Handle"
Some source filters use the \f(CW\*(C`DATA\*(C'\fR handle to read the calling program.
When using these source filters you cannot rely on this handle, nor expect
any particular kind of behavior when operating on it.  Filters based on
Filter::Util::Call (and therefore Filter::Simple) do not alter the \f(CW\*(C`DATA\*(C'\fR
filehandle.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
The Source Filters distribution is available on \s-1CPAN,\s0 in
.PP
.Vb 1
\&    CPAN/modules/by\-module/Filter
.Ve
.PP
Starting from Perl 5.8 Filter::Util::Call (the core part of the
Source Filters distribution) is part of the standard Perl distribution.
Also included is a friendlier interface called Filter::Simple, by
Damian Conway.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess <Paul.Marquess@btinternet.com>
.SH "Copyrights"
.IX Header "Copyrights"
This article originally appeared in The Perl Journal #11, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and
The Perl Journal.  This document may be distributed under the same terms
as Perl itself.
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfork.1                                   0100644 0001750 0001750 00000045616 12566207437 022604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFORK 1"
.TH PERLFORK 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfork \- Perl's fork() emulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    NOTE:  As of the 5.8.0 release, fork() emulation has considerably
\&    matured.  However, there are still a few known bugs and differences
\&    from real fork() that might affect you.  See the "BUGS" and
\&    "CAVEATS AND LIMITATIONS" sections below.
.Ve
.PP
Perl provides a \fIfork()\fR keyword that corresponds to the Unix system call
of the same name.  On most Unix-like platforms where the \fIfork()\fR system
call is available, Perl's \fIfork()\fR simply calls it.
.PP
On some platforms such as Windows where the \fIfork()\fR system call is not
available, Perl can be built to emulate \fIfork()\fR at the interpreter level.
While the emulation is designed to be as compatible as possible with the
real \fIfork()\fR at the level of the Perl program, there are certain
important differences that stem from the fact that all the pseudo child
\&\*(L"processes\*(R" created this way live in the same real process as far as the
operating system is concerned.
.PP
This document provides a general overview of the capabilities and
limitations of the \fIfork()\fR emulation.  Note that the issues discussed here
are not applicable to platforms where a real \fIfork()\fR is available and Perl
has been configured to use it.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fIfork()\fR emulation is implemented at the level of the Perl interpreter.
What this means in general is that running \fIfork()\fR will actually clone the
running interpreter and all its state, and run the cloned interpreter in
a separate thread, beginning execution in the new thread just after the
point where the \fIfork()\fR was called in the parent.  We will refer to the
thread that implements this child \*(L"process\*(R" as the pseudo-process.
.PP
To the Perl program that called \fIfork()\fR, all this is designed to be
transparent.  The parent returns from the \fIfork()\fR with a pseudo-process
\&\s-1ID\s0 that can be subsequently used in any process-manipulation functions;
the child returns from the \fIfork()\fR with a value of \f(CW0\fR to signify that
it is the child pseudo-process.
.SS "Behavior of other Perl features in forked pseudo-processes"
.IX Subsection "Behavior of other Perl features in forked pseudo-processes"
Most Perl features behave in a natural way within pseudo-processes.
.ie n .IP "$$ or $PROCESS_ID" 8
.el .IP "$$ or \f(CW$PROCESS_ID\fR" 8
.IX Item "$$ or $PROCESS_ID"
This special variable is correctly set to the pseudo-process \s-1ID.\s0
It can be used to identify pseudo-processes within a particular
session.  Note that this value is subject to recycling if any
pseudo-processes are launched after others have been \fIwait()\fR\-ed on.
.ie n .IP "%ENV" 8
.el .IP "\f(CW%ENV\fR" 8
.IX Item "%ENV"
Each pseudo-process maintains its own virtual environment.  Modifications
to \f(CW%ENV\fR affect the virtual environment, and are only visible within that
pseudo-process, and in any processes (or pseudo-processes) launched from
it.
.IP "\fIchdir()\fR and all other builtins that accept filenames" 8
.IX Item "chdir() and all other builtins that accept filenames"
Each pseudo-process maintains its own virtual idea of the current directory.
Modifications to the current directory using \fIchdir()\fR are only visible within
that pseudo-process, and in any processes (or pseudo-processes) launched from
it.  All file and directory accesses from the pseudo-process will correctly
map the virtual working directory to the real working directory appropriately.
.IP "\fIwait()\fR and \fIwaitpid()\fR" 8
.IX Item "wait() and waitpid()"
\&\fIwait()\fR and \fIwaitpid()\fR can be passed a pseudo-process \s-1ID\s0 returned by \fIfork()\fR.
These calls will properly wait for the termination of the pseudo-process
and return its status.
.IP "\fIkill()\fR" 8
.IX Item "kill()"
\&\f(CW\*(C`kill(\*(AqKILL\*(Aq, ...)\*(C'\fR can be used to terminate a pseudo-process by
passing it the \s-1ID\s0 returned by \fIfork()\fR. The outcome of kill on a pseudo-process
is unpredictable and it should not be used except
under dire circumstances, because the operating system may not
guarantee integrity of the process resources when a running thread is
terminated.  The process which implements the pseudo-processes can be blocked
and the Perl interpreter hangs. Note that using \f(CW\*(C`kill(\*(AqKILL\*(Aq, ...)\*(C'\fR on a
pseudo\-\fIprocess()\fR may typically cause memory leaks, because the thread
that implements the pseudo-process does not get a chance to clean up
its resources.
.Sp
\&\f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR can also be used on pseudo-processes, but the
signal will not be delivered while the pseudo-process is blocked by a
system call, e.g. waiting for a socket to connect, or trying to read
from a socket with no data available.  Starting in Perl 5.14 the
parent process will not wait for children to exit once they have been
signalled with \f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR to avoid deadlock during process
exit.  You will have to explicitly call \fIwaitpid()\fR to make sure the
child has time to clean-up itself, but you are then also responsible
that the child is not blocking on I/O either.
.IP "\fIexec()\fR" 8
.IX Item "exec()"
Calling \fIexec()\fR within a pseudo-process actually spawns the requested
executable in a separate process and waits for it to complete before
exiting with the same exit status as that process.  This means that the
process \s-1ID\s0 reported within the running executable will be different from
what the earlier Perl \fIfork()\fR might have returned.  Similarly, any process
manipulation functions applied to the \s-1ID\s0 returned by \fIfork()\fR will affect the
waiting pseudo-process that called \fIexec()\fR, not the real process it is
waiting for after the \fIexec()\fR.
.Sp
When \fIexec()\fR is called inside a pseudo-process then \s-1DESTROY\s0 methods and
\&\s-1END\s0 blocks will still be called after the external process returns.
.IP "\fIexit()\fR" 8
.IX Item "exit()"
\&\fIexit()\fR always exits just the executing pseudo-process, after automatically
\&\fIwait()\fR\-ing for any outstanding child pseudo-processes.  Note that this means
that the process as a whole will not exit unless all running pseudo-processes
have exited.  See below for some limitations with open filehandles.
.IP "Open handles to files, directories and network sockets" 8
.IX Item "Open handles to files, directories and network sockets"
All open handles are \fIdup()\fR\-ed in pseudo-processes, so that closing
any handles in one process does not affect the others.  See below for
some limitations.
.SS "Resource limits"
.IX Subsection "Resource limits"
In the eyes of the operating system, pseudo-processes created via the \fIfork()\fR
emulation are simply threads in the same process.  This means that any
process-level limits imposed by the operating system apply to all
pseudo-processes taken together.  This includes any limits imposed by the
operating system on the number of open file, directory and socket handles,
limits on disk space usage, limits on memory size, limits on \s-1CPU\s0 utilization
etc.
.SS "Killing the parent process"
.IX Subsection "Killing the parent process"
If the parent process is killed (either using Perl's \fIkill()\fR builtin, or
using some external means) all the pseudo-processes are killed as well,
and the whole process exits.
.SS "Lifetime of the parent process and pseudo-processes"
.IX Subsection "Lifetime of the parent process and pseudo-processes"
During the normal course of events, the parent process and every
pseudo-process started by it will wait for their respective pseudo-children
to complete before they exit.  This means that the parent and every
pseudo-child created by it that is also a pseudo-parent will only exit
after their pseudo-children have exited.
.PP
Starting with Perl 5.14 a parent will not \fIwait()\fR automatically
for any child that has been signalled with \f(CW\*(C`sig(\*(AqTERM\*(Aq, ...)\*(C'\fR
to avoid a deadlock in case the child is blocking on I/O and
never receives the signal.
.SH "CAVEATS AND LIMITATIONS"
.IX Header "CAVEATS AND LIMITATIONS"
.IP "\s-1BEGIN\s0 blocks" 8
.IX Item "BEGIN blocks"
The \fIfork()\fR emulation will not work entirely correctly when called from
within a \s-1BEGIN\s0 block.  The forked copy will run the contents of the
\&\s-1BEGIN\s0 block, but will not continue parsing the source stream after the
\&\s-1BEGIN\s0 block.  For example, consider the following code:
.Sp
.Vb 5
\&    BEGIN {
\&        fork and exit;          # fork child and exit the parent
\&        print "inner\en";
\&    }
\&    print "outer\en";
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&    inner
.Ve
.Sp
rather than the expected:
.Sp
.Vb 2
\&    inner
\&    outer
.Ve
.Sp
This limitation arises from fundamental technical difficulties in
cloning and restarting the stacks used by the Perl parser in the
middle of a parse.
.IP "Open filehandles" 8
.IX Item "Open filehandles"
Any filehandles open at the time of the \fIfork()\fR will be \fIdup()\fR\-ed.  Thus,
the files can be closed independently in the parent and child, but beware
that the \fIdup()\fR\-ed handles will still share the same seek pointer.  Changing
the seek position in the parent will change it in the child and vice-versa.
One can avoid this by opening files that need distinct seek pointers
separately in the child.
.Sp
On some operating systems, notably Solaris and Unixware, calling \f(CW\*(C`exit()\*(C'\fR
from a child process will flush and close open filehandles in the parent,
thereby corrupting the filehandles.  On these systems, calling \f(CW\*(C`_exit()\*(C'\fR
is suggested instead.  \f(CW\*(C`_exit()\*(C'\fR is available in Perl through the 
\&\f(CW\*(C`POSIX\*(C'\fR module.  Please consult your system's manpages for more information
on this.
.IP "Open directory handles" 8
.IX Item "Open directory handles"
Perl will completely read from all open directory handles until they
reach the end of the stream.  It will then \fIseekdir()\fR back to the
original location and all future \fIreaddir()\fR requests will be fulfilled
from the cache buffer.  That means that neither the directory handle held
by the parent process nor the one held by the child process will see
any changes made to the directory after the \fIfork()\fR call.
.Sp
Note that \fIrewinddir()\fR has a similar limitation on Windows and will not
force \fIreaddir()\fR to read the directory again either.  Only a newly
opened directory handle will reflect changes to the directory.
.IP "Forking pipe \fIopen()\fR not yet implemented" 8
.IX Item "Forking pipe open() not yet implemented"
The \f(CW\*(C`open(FOO, "|\-")\*(C'\fR and \f(CW\*(C`open(BAR, "\-|")\*(C'\fR constructs are not yet
implemented.  This limitation can be easily worked around in new code
by creating a pipe explicitly.  The following example shows how to
write to a forked child:
.Sp
.Vb 10
\&    # simulate open(FOO, "|\-")
\&    sub pipe_to_fork ($) {
\&        my $parent = shift;
\&        pipe my $child, $parent or die;
\&        my $pid = fork();
\&        die "fork() failed: $!" unless defined $pid;
\&        if ($pid) {
\&            close $child;
\&        }
\&        else {
\&            close $parent;
\&            open(STDIN, "<&=" . fileno($child)) or die;
\&        }
\&        $pid;
\&    }
\&
\&    if (pipe_to_fork(\*(AqFOO\*(Aq)) {
\&        # parent
\&        print FOO "pipe_to_fork\en";
\&        close FOO;
\&    }
\&    else {
\&        # child
\&        while (<STDIN>) { print; }
\&        exit(0);
\&    }
.Ve
.Sp
And this one reads from the child:
.Sp
.Vb 10
\&    # simulate open(FOO, "\-|")
\&    sub pipe_from_fork ($) {
\&        my $parent = shift;
\&        pipe $parent, my $child or die;
\&        my $pid = fork();
\&        die "fork() failed: $!" unless defined $pid;
\&        if ($pid) {
\&            close $child;
\&        }
\&        else {
\&            close $parent;
\&            open(STDOUT, ">&=" . fileno($child)) or die;
\&        }
\&        $pid;
\&    }
\&
\&    if (pipe_from_fork(\*(AqBAR\*(Aq)) {
\&        # parent
\&        while (<BAR>) { print; }
\&        close BAR;
\&    }
\&    else {
\&        # child
\&        print "pipe_from_fork\en";
\&        exit(0);
\&    }
.Ve
.Sp
Forking pipe \fIopen()\fR constructs will be supported in future.
.IP "Global state maintained by XSUBs" 8
.IX Item "Global state maintained by XSUBs"
External subroutines (XSUBs) that maintain their own global state may
not work correctly.  Such XSUBs will either need to maintain locks to
protect simultaneous access to global data from different pseudo-processes,
or maintain all their state on the Perl symbol table, which is copied
naturally when \fIfork()\fR is called.  A callback mechanism that provides
extensions an opportunity to clone their state will be provided in the
near future.
.IP "Interpreter embedded in larger application" 8
.IX Item "Interpreter embedded in larger application"
The \fIfork()\fR emulation may not behave as expected when it is executed in an
application which embeds a Perl interpreter and calls Perl APIs that can
evaluate bits of Perl code.  This stems from the fact that the emulation
only has knowledge about the Perl interpreter's own data structures and
knows nothing about the containing application's state.  For example, any
state carried on the application's own call stack is out of reach.
.IP "Thread-safety of extensions" 8
.IX Item "Thread-safety of extensions"
Since the \fIfork()\fR emulation runs code in multiple threads, extensions
calling into non-thread-safe libraries may not work reliably when
calling \fIfork()\fR.  As Perl's threading support gradually becomes more
widely adopted even on platforms with a native \fIfork()\fR, such extensions
are expected to be fixed for thread-safety.
.SH "PORTABILITY CAVEATS"
.IX Header "PORTABILITY CAVEATS"
In portable Perl code, \f(CW\*(C`kill(9, $child)\*(C'\fR must not be used on forked processes.
Killing a forked process is unsafe and has unpredictable results.
See \*(L"\fIkill()\fR\*(R", above.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 8
Having pseudo-process IDs be negative integers breaks down for the integer
\&\f(CW\*(C`\-1\*(C'\fR because the \fIwait()\fR and \fIwaitpid()\fR functions treat this number as
being special.  The tacit assumption in the current implementation is that
the system never allocates a thread \s-1ID\s0 of \f(CW1\fR for user threads.  A better
representation for pseudo-process IDs will be implemented in future.
.IP "\(bu" 8
In certain cases, the OS-level handles created by the \fIpipe()\fR, \fIsocket()\fR,
and \fIaccept()\fR operators are apparently not duplicated accurately in
pseudo-processes.  This only happens in some situations, but where it
does happen, it may result in deadlocks between the read and write ends
of pipe handles, or inability to send or receive data across socket
handles.
.IP "\(bu" 8
This document may be incomplete in some respects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Support for concurrent interpreters and the \fIfork()\fR emulation was implemented
by ActiveState, with funding from Microsoft Corporation.
.PP
This document is authored and maintained by Gurusamy Sarathy
<gsar@activestate.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"fork\*(R" in perlfunc, perlipc
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfork5.16.1                               0100644 0001750 0001750 00000045275 12566207417 023115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFORK 1"
.TH PERLFORK 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfork \- Perl's fork() emulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    NOTE:  As of the 5.8.0 release, fork() emulation has considerably
\&    matured.  However, there are still a few known bugs and differences
\&    from real fork() that might affect you.  See the "BUGS" and
\&    "CAVEATS AND LIMITATIONS" sections below.
.Ve
.PP
Perl provides a \fIfork()\fR keyword that corresponds to the Unix system call
of the same name.  On most Unix-like platforms where the \fIfork()\fR system
call is available, Perl's \fIfork()\fR simply calls it.
.PP
On some platforms such as Windows where the \fIfork()\fR system call is not
available, Perl can be built to emulate \fIfork()\fR at the interpreter level.
While the emulation is designed to be as compatible as possible with the
real \fIfork()\fR at the level of the Perl program, there are certain
important differences that stem from the fact that all the pseudo child
\&\*(L"processes\*(R" created this way live in the same real process as far as the
operating system is concerned.
.PP
This document provides a general overview of the capabilities and
limitations of the \fIfork()\fR emulation.  Note that the issues discussed here
are not applicable to platforms where a real \fIfork()\fR is available and Perl
has been configured to use it.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fIfork()\fR emulation is implemented at the level of the Perl interpreter.
What this means in general is that running \fIfork()\fR will actually clone the
running interpreter and all its state, and run the cloned interpreter in
a separate thread, beginning execution in the new thread just after the
point where the \fIfork()\fR was called in the parent.  We will refer to the
thread that implements this child \*(L"process\*(R" as the pseudo-process.
.PP
To the Perl program that called \fIfork()\fR, all this is designed to be
transparent.  The parent returns from the \fIfork()\fR with a pseudo-process
\&\s-1ID\s0 that can be subsequently used in any process-manipulation functions;
the child returns from the \fIfork()\fR with a value of \f(CW0\fR to signify that
it is the child pseudo-process.
.SS "Behavior of other Perl features in forked pseudo-processes"
.IX Subsection "Behavior of other Perl features in forked pseudo-processes"
Most Perl features behave in a natural way within pseudo-processes.
.ie n .IP "$$ or $PROCESS_ID" 8
.el .IP "$$ or \f(CW$PROCESS_ID\fR" 8
.IX Item "$$ or $PROCESS_ID"
This special variable is correctly set to the pseudo-process \s-1ID\s0.
It can be used to identify pseudo-processes within a particular
session.  Note that this value is subject to recycling if any
pseudo-processes are launched after others have been \fIwait()\fR\-ed on.
.ie n .IP "%ENV" 8
.el .IP "\f(CW%ENV\fR" 8
.IX Item "%ENV"
Each pseudo-process maintains its own virtual environment.  Modifications
to \f(CW%ENV\fR affect the virtual environment, and are only visible within that
pseudo-process, and in any processes (or pseudo-processes) launched from
it.
.IP "\fIchdir()\fR and all other builtins that accept filenames" 8
.IX Item "chdir() and all other builtins that accept filenames"
Each pseudo-process maintains its own virtual idea of the current directory.
Modifications to the current directory using \fIchdir()\fR are only visible within
that pseudo-process, and in any processes (or pseudo-processes) launched from
it.  All file and directory accesses from the pseudo-process will correctly
map the virtual working directory to the real working directory appropriately.
.IP "\fIwait()\fR and \fIwaitpid()\fR" 8
.IX Item "wait() and waitpid()"
\&\fIwait()\fR and \fIwaitpid()\fR can be passed a pseudo-process \s-1ID\s0 returned by \fIfork()\fR.
These calls will properly wait for the termination of the pseudo-process
and return its status.
.IP "\fIkill()\fR" 8
.IX Item "kill()"
\&\f(CW\*(C`kill(\*(AqKILL\*(Aq, ...)\*(C'\fR can be used to terminate a pseudo-process by
passing it the \s-1ID\s0 returned by \fIfork()\fR. The outcome of kill on a pseudo-process
is unpredictable and it should not be used except
under dire circumstances, because the operating system may not
guarantee integrity of the process resources when a running thread is
terminated.  The process which implements the pseudo-processes can be blocked
and the Perl interpreter hangs. Note that using \f(CW\*(C`kill(\*(AqKILL\*(Aq, ...)\*(C'\fR on a
pseudo\-\fIprocess()\fR may typically cause memory leaks, because the thread
that implements the pseudo-process does not get a chance to clean up
its resources.
.Sp
\&\f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR can also be used on pseudo-processes, but the
signal will not be delivered while the pseudo-process is blocked by a
system call, e.g. waiting for a socket to connect, or trying to read
from a socket with no data available.  Starting in Perl 5.14 the
parent process will not wait for children to exit once they have been
signalled with \f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR to avoid deadlock during process
exit.  You will have to explicitly call \fIwaitpid()\fR to make sure the
child has time to clean-up itself, but you are then also responsible
that the child is not blocking on I/O either.
.IP "\fIexec()\fR" 8
.IX Item "exec()"
Calling \fIexec()\fR within a pseudo-process actually spawns the requested
executable in a separate process and waits for it to complete before
exiting with the same exit status as that process.  This means that the
process \s-1ID\s0 reported within the running executable will be different from
what the earlier Perl \fIfork()\fR might have returned.  Similarly, any process
manipulation functions applied to the \s-1ID\s0 returned by \fIfork()\fR will affect the
waiting pseudo-process that called \fIexec()\fR, not the real process it is
waiting for after the \fIexec()\fR.
.Sp
When \fIexec()\fR is called inside a pseudo-process then \s-1DESTROY\s0 methods and
\&\s-1END\s0 blocks will still be called after the external process returns.
.IP "\fIexit()\fR" 8
.IX Item "exit()"
\&\fIexit()\fR always exits just the executing pseudo-process, after automatically
\&\fIwait()\fR\-ing for any outstanding child pseudo-processes.  Note that this means
that the process as a whole will not exit unless all running pseudo-processes
have exited.  See below for some limitations with open filehandles.
.IP "Open handles to files, directories and network sockets" 8
.IX Item "Open handles to files, directories and network sockets"
All open handles are \fIdup()\fR\-ed in pseudo-processes, so that closing
any handles in one process does not affect the others.  See below for
some limitations.
.SS "Resource limits"
.IX Subsection "Resource limits"
In the eyes of the operating system, pseudo-processes created via the \fIfork()\fR
emulation are simply threads in the same process.  This means that any
process-level limits imposed by the operating system apply to all
pseudo-processes taken together.  This includes any limits imposed by the
operating system on the number of open file, directory and socket handles,
limits on disk space usage, limits on memory size, limits on \s-1CPU\s0 utilization
etc.
.SS "Killing the parent process"
.IX Subsection "Killing the parent process"
If the parent process is killed (either using Perl's \fIkill()\fR builtin, or
using some external means) all the pseudo-processes are killed as well,
and the whole process exits.
.SS "Lifetime of the parent process and pseudo-processes"
.IX Subsection "Lifetime of the parent process and pseudo-processes"
During the normal course of events, the parent process and every
pseudo-process started by it will wait for their respective pseudo-children
to complete before they exit.  This means that the parent and every
pseudo-child created by it that is also a pseudo-parent will only exit
after their pseudo-children have exited.
.PP
Starting with Perl 5.14 a parent will not \fIwait()\fR automatically
for any child that has been signalled with \f(CW\*(C`sig(\*(AqTERM\*(Aq, ...)\*(C'\fR
to avoid a deadlock in case the child is blocking on I/O and
never receives the signal.
.SH "CAVEATS AND LIMITATIONS"
.IX Header "CAVEATS AND LIMITATIONS"
.IP "\s-1BEGIN\s0 blocks" 8
.IX Item "BEGIN blocks"
The \fIfork()\fR emulation will not work entirely correctly when called from
within a \s-1BEGIN\s0 block.  The forked copy will run the contents of the
\&\s-1BEGIN\s0 block, but will not continue parsing the source stream after the
\&\s-1BEGIN\s0 block.  For example, consider the following code:
.Sp
.Vb 5
\&    BEGIN {
\&        fork and exit;          # fork child and exit the parent
\&        print "inner\en";
\&    }
\&    print "outer\en";
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&    inner
.Ve
.Sp
rather than the expected:
.Sp
.Vb 2
\&    inner
\&    outer
.Ve
.Sp
This limitation arises from fundamental technical difficulties in
cloning and restarting the stacks used by the Perl parser in the
middle of a parse.
.IP "Open filehandles" 8
.IX Item "Open filehandles"
Any filehandles open at the time of the \fIfork()\fR will be \fIdup()\fR\-ed.  Thus,
the files can be closed independently in the parent and child, but beware
that the \fIdup()\fR\-ed handles will still share the same seek pointer.  Changing
the seek position in the parent will change it in the child and vice-versa.
One can avoid this by opening files that need distinct seek pointers
separately in the child.
.Sp
On some operating systems, notably Solaris and Unixware, calling \f(CW\*(C`exit()\*(C'\fR
from a child process will flush and close open filehandles in the parent,
thereby corrupting the filehandles.  On these systems, calling \f(CW\*(C`_exit()\*(C'\fR
is suggested instead.  \f(CW\*(C`_exit()\*(C'\fR is available in Perl through the 
\&\f(CW\*(C`POSIX\*(C'\fR module.  Please consult your system's manpages for more information
on this.
.IP "Open directory handles" 8
.IX Item "Open directory handles"
Perl will completely read from all open directory handles until they
reach the end of the stream.  It will then \fIseekdir()\fR back to the
original location and all future \fIreaddir()\fR requests will be fulfilled
from the cache buffer.  That means that neither the directory handle held
by the parent process nor the one held by the child process will see
any changes made to the directory after the \fIfork()\fR call.
.Sp
Note that \fIrewinddir()\fR has a similar limitation on Windows and will not
force \fIreaddir()\fR to read the directory again either.  Only a newly
opened directory handle will reflect changes to the directory.
.IP "Forking pipe \fIopen()\fR not yet implemented" 8
.IX Item "Forking pipe open() not yet implemented"
The \f(CW\*(C`open(FOO, "|\-")\*(C'\fR and \f(CW\*(C`open(BAR, "\-|")\*(C'\fR constructs are not yet
implemented.  This limitation can be easily worked around in new code
by creating a pipe explicitly.  The following example shows how to
write to a forked child:
.Sp
.Vb 10
\&    # simulate open(FOO, "|\-")
\&    sub pipe_to_fork ($) {
\&        my $parent = shift;
\&        pipe my $child, $parent or die;
\&        my $pid = fork();
\&        die "fork() failed: $!" unless defined $pid;
\&        if ($pid) {
\&            close $child;
\&        }
\&        else {
\&            close $parent;
\&            open(STDIN, "<&=" . fileno($child)) or die;
\&        }
\&        $pid;
\&    }
\&
\&    if (pipe_to_fork(\*(AqFOO\*(Aq)) {
\&        # parent
\&        print FOO "pipe_to_fork\en";
\&        close FOO;
\&    }
\&    else {
\&        # child
\&        while (<STDIN>) { print; }
\&        exit(0);
\&    }
.Ve
.Sp
And this one reads from the child:
.Sp
.Vb 10
\&    # simulate open(FOO, "\-|")
\&    sub pipe_from_fork ($) {
\&        my $parent = shift;
\&        pipe $parent, my $child or die;
\&        my $pid = fork();
\&        die "fork() failed: $!" unless defined $pid;
\&        if ($pid) {
\&            close $child;
\&        }
\&        else {
\&            close $parent;
\&            open(STDOUT, ">&=" . fileno($child)) or die;
\&        }
\&        $pid;
\&    }
\&
\&    if (pipe_from_fork(\*(AqBAR\*(Aq)) {
\&        # parent
\&        while (<BAR>) { print; }
\&        close BAR;
\&    }
\&    else {
\&        # child
\&        print "pipe_from_fork\en";
\&        exit(0);
\&    }
.Ve
.Sp
Forking pipe \fIopen()\fR constructs will be supported in future.
.IP "Global state maintained by XSUBs" 8
.IX Item "Global state maintained by XSUBs"
External subroutines (XSUBs) that maintain their own global state may
not work correctly.  Such XSUBs will either need to maintain locks to
protect simultaneous access to global data from different pseudo-processes,
or maintain all their state on the Perl symbol table, which is copied
naturally when \fIfork()\fR is called.  A callback mechanism that provides
extensions an opportunity to clone their state will be provided in the
near future.
.IP "Interpreter embedded in larger application" 8
.IX Item "Interpreter embedded in larger application"
The \fIfork()\fR emulation may not behave as expected when it is executed in an
application which embeds a Perl interpreter and calls Perl APIs that can
evaluate bits of Perl code.  This stems from the fact that the emulation
only has knowledge about the Perl interpreter's own data structures and
knows nothing about the containing application's state.  For example, any
state carried on the application's own call stack is out of reach.
.IP "Thread-safety of extensions" 8
.IX Item "Thread-safety of extensions"
Since the \fIfork()\fR emulation runs code in multiple threads, extensions
calling into non-thread-safe libraries may not work reliably when
calling \fIfork()\fR.  As Perl's threading support gradually becomes more
widely adopted even on platforms with a native \fIfork()\fR, such extensions
are expected to be fixed for thread-safety.
.SH "PORTABILITY CAVEATS"
.IX Header "PORTABILITY CAVEATS"
In portable Perl code, \f(CW\*(C`kill(9, $child)\*(C'\fR must not be used on forked processes.
Killing a forked process is unsafe and has unpredictable results.
See \*(L"\fIkill()\fR\*(R", above.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 8
Having pseudo-process IDs be negative integers breaks down for the integer
\&\f(CW\*(C`\-1\*(C'\fR because the \fIwait()\fR and \fIwaitpid()\fR functions treat this number as
being special.  The tacit assumption in the current implementation is that
the system never allocates a thread \s-1ID\s0 of \f(CW1\fR for user threads.  A better
representation for pseudo-process IDs will be implemented in future.
.IP "\(bu" 8
In certain cases, the OS-level handles created by the \fIpipe()\fR, \fIsocket()\fR,
and \fIaccept()\fR operators are apparently not duplicated accurately in
pseudo-processes.  This only happens in some situations, but where it
does happen, it may result in deadlocks between the read and write ends
of pipe handles, or inability to send or receive data across socket
handles.
.IP "\(bu" 8
This document may be incomplete in some respects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Support for concurrent interpreters and the \fIfork()\fR emulation was implemented
by ActiveState, with funding from Microsoft Corporation.
.PP
This document is authored and maintained by Gurusamy Sarathy
<gsar@activestate.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"fork\*(R" in perlfunc, perlipc
                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfork5.18.1                               0100644 0001750 0001750 00000045616 12566207437 023120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFORK 1"
.TH PERLFORK 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfork \- Perl's fork() emulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    NOTE:  As of the 5.8.0 release, fork() emulation has considerably
\&    matured.  However, there are still a few known bugs and differences
\&    from real fork() that might affect you.  See the "BUGS" and
\&    "CAVEATS AND LIMITATIONS" sections below.
.Ve
.PP
Perl provides a \fIfork()\fR keyword that corresponds to the Unix system call
of the same name.  On most Unix-like platforms where the \fIfork()\fR system
call is available, Perl's \fIfork()\fR simply calls it.
.PP
On some platforms such as Windows where the \fIfork()\fR system call is not
available, Perl can be built to emulate \fIfork()\fR at the interpreter level.
While the emulation is designed to be as compatible as possible with the
real \fIfork()\fR at the level of the Perl program, there are certain
important differences that stem from the fact that all the pseudo child
\&\*(L"processes\*(R" created this way live in the same real process as far as the
operating system is concerned.
.PP
This document provides a general overview of the capabiliti