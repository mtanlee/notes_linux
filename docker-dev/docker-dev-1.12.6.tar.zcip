DUsage_GD_Z    = 0x32,    /* Dynamic Value */
    kHIDUsage_GD_Rx    = 0x33,    /* Dynamic Value */
    kHIDUsage_GD_Ry    = 0x34,    /* Dynamic Value */
    kHIDUsage_GD_Rz    = 0x35,    /* Dynamic Value */
    kHIDUsage_GD_Slider    = 0x36,    /* Dynamic Value */
    kHIDUsage_GD_Dial    = 0x37,    /* Dynamic Value */
    kHIDUsage_GD_Wheel    = 0x38,    /* Dynamic Value */
    kHIDUsage_GD_Hatswitch    = 0x39,    /* Dynamic Value */
    kHIDUsage_GD_CountedBuffer    = 0x3A,    /* Logical Collection */
    kHIDUsage_GD_ByteCount    = 0x3B,    /* Dynamic Value */
    kHIDUsage_GD_MotionWakeup    = 0x3C,    /* One-Shot Control */
    kHIDUsage_GD_Start    = 0x3D,    /* On/Off Control */
    kHIDUsage_GD_Select    = 0x3E,    /* On/Off Control */
    /* 0x3F Reserved */
    kHIDUsage_GD_Vx    = 0x40,    /* Dynamic Value */
    kHIDUsage_GD_Vy    = 0x41,    /* Dynamic Value */
    kHIDUsage_GD_Vz    = 0x42,    /* Dynamic Value */
    kHIDUsage_GD_Vbrx    = 0x43,    /* Dynamic Value */
    kHIDUsage_GD_Vbry    = 0x44,    /* Dynamic Value */
    kHIDUsage_GD_Vbrz    = 0x45,    /* Dynamic Value */
    kHIDUsage_GD_Vno    = 0x46,    /* Dynamic Value */
    /* 0x47 - 0x7F Reserved */
    kHIDUsage_GD_SystemControl    = 0x80,    /* Application Collection */
    kHIDUsage_GD_SystemPowerDown    = 0x81,    /* One-Shot Control */
    kHIDUsage_GD_SystemSleep    = 0x82,    /* One-Shot Control */
    kHIDUsage_GD_SystemWakeUp    = 0x83,    /* One-Shot Control */
    kHIDUsage_GD_SystemContextMenu    = 0x84,    /* One-Shot Control */
    kHIDUsage_GD_SystemMainMenu    = 0x85,    /* One-Shot Control */
    kHIDUsage_GD_SystemAppMenu    = 0x86,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuHelp    = 0x87,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuExit    = 0x88,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuSelect    = 0x89,    /* Selector */
    kHIDUsage_GD_SystemMenu    = kHIDUsage_GD_SystemMenuSelect,    /* Selector */
    kHIDUsage_GD_SystemMenuRight    = 0x8A,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuLeft    = 0x8B,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuUp    = 0x8C,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuDown    = 0x8D,    /* Re-Trigger Control */
    /* 0x8E - 0x8F Reserved */
    kHIDUsage_GD_DPadUp    = 0x90,    /* On/Off Control */
    kHIDUsage_GD_DPadDown    = 0x91,    /* On/Off Control */
    kHIDUsage_GD_DPadRight    = 0x92,    /* On/Off Control */
    kHIDUsage_GD_DPadLeft    = 0x93,    /* On/Off Control */
    /* 0x94 - 0xFFFF Reserved */
    kHIDUsage_GD_Reserved = 0xFFFF
};

/* Simulation Page (0x02) */
/* This section provides detailed descriptions of the usages employed by simulation devices. */
enum
{
    kHIDUsage_Sim_FlightSimulationDevice    = 0x01,    /* Application Collection */
    kHIDUsage_Sim_AutomobileSimulationDevice    = 0x02,    /* Application Collection */
    kHIDUsage_Sim_TankSimulationDevice    = 0x03,    /* Application Collection */
    kHIDUsage_Sim_SpaceshipSimulationDevice    = 0x04,    /* Application Collection */
    kHIDUsage_Sim_SubmarineSimulationDevice    = 0x05,    /* Application Collection */
    kHIDUsage_Sim_SailingSimulationDevice    = 0x06,    /* Application Collection */
    kHIDUsage_Sim_MotorcycleSimulationDevice    = 0x07,    /* Application Collection */
    kHIDUsage_Sim_SportsSimulationDevice    = 0x08,    /* Application Collection */
    kHIDUsage_Sim_AirplaneSimulationDevice    = 0x09,    /* Application Collection */
    kHIDUsage_Sim_HelicopterSimulationDevice    = 0x0A,    /* Application Collection */
    kHIDUsage_Sim_MagicCarpetSimulationDevice    = 0x0B,    /* Application Collection */
    kHIDUsage_Sim_BicycleSimulationDevice    = 0x0C,    /* Application Collection */
    /* 0x0D - 0x1F Reserved */
    kHIDUsage_Sim_FlightControlStick    = 0x20,    /* Application Collection */
    kHIDUsage_Sim_FlightStick    = 0x21,    /* Application Collection */
    kHIDUsage_Sim_CyclicControl    = 0x22,    /* Physical Collection */
    kHIDUsage_Sim_CyclicTrim    = 0x23,    /* Physical Collection */
    kHIDUsage_Sim_FlightYoke    = 0x24,    /* Application Collection */
    kHIDUsage_Sim_TrackControl    = 0x25,    /* Physical Collection */
    /* 0x26 - 0xAF Reserved */
    kHIDUsage_Sim_Aileron    = 0xB0,    /* Dynamic Value */
    kHIDUsage_Sim_AileronTrim    = 0xB1,    /* Dynamic Value */
    kHIDUsage_Sim_AntiTorqueControl    = 0xB2,    /* Dynamic Value */
    kHIDUsage_Sim_AutopilotEnable    = 0xB3,    /* On/Off Control */
    kHIDUsage_Sim_ChaffRelease    = 0xB4,    /* One-Shot Control */
    kHIDUsage_Sim_CollectiveControl    = 0xB5,    /* Dynamic Value */
    kHIDUsage_Sim_DiveBrake    = 0xB6,    /* Dynamic Value */
    kHIDUsage_Sim_ElectronicCountermeasures    = 0xB7,    /* On/Off Control */
    kHIDUsage_Sim_Elevator    = 0xB8,    /* Dynamic Value */
    kHIDUsage_Sim_ElevatorTrim    = 0xB9,    /* Dynamic Value */
    kHIDUsage_Sim_Rudder    = 0xBA,    /* Dynamic Value */
    kHIDUsage_Sim_Throttle    = 0xBB,    /* Dynamic Value */
    kHIDUsage_Sim_FlightCommunications    = 0xBC,    /* On/Off Control */
    kHIDUsage_Sim_FlareRelease    = 0xBD,    /* One-Shot Control */
    kHIDUsage_Sim_LandingGear    = 0xBE,    /* On/Off Control */
    kHIDUsage_Sim_ToeBrake    = 0xBF,    /* Dynamic Value */
    kHIDUsage_Sim_Trigger    = 0xC0,    /* Momentary Control */
    kHIDUsage_Sim_WeaponsArm    = 0xC1,    /* On/Off Control */
    kHIDUsage_Sim_Weapons    = 0xC2,    /* Selector */
    kHIDUsage_Sim_WingFlaps    = 0xC3,    /* Dynamic Value */
    kHIDUsage_Sim_Accelerator    = 0xC4,    /* Dynamic Value */
    kHIDUsage_Sim_Brake    = 0xC5,    /* Dynamic Value */
    kHIDUsage_Sim_Clutch    = 0xC6,    /* Dynamic Value */
    kHIDUsage_Sim_Shifter    = 0xC7,    /* Dynamic Value */
    kHIDUsage_Sim_Steering    = 0xC8,    /* Dynamic Value */
    kHIDUsage_Sim_TurretDirection    = 0xC9,    /* Dynamic Value */
    kHIDUsage_Sim_BarrelElevation    = 0xCA,    /* Dynamic Value */
    kHIDUsage_Sim_DivePlane    = 0xCB,    /* Dynamic Value */
    kHIDUsage_Sim_Ballast    = 0xCC,    /* Dynamic Value */
    kHIDUsage_Sim_BicycleCrank    = 0xCD,    /* Dynamic Value */
    kHIDUsage_Sim_HandleBars    = 0xCE,    /* Dynamic Value */
    kHIDUsage_Sim_FrontBrake    = 0xCF,    /* Dynamic Value */
    kHIDUsage_Sim_RearBrake    = 0xD0,    /* Dynamic Value */
    /* 0xD1 - 0xFFFF Reserved */
    kHIDUsage_Sim_Reserved = 0xFFFF
};

/* VR Page (0x03) */
/* Virtual Reality controls depend on designators to identify the individual controls. Most of the following are */
/* usages are applied to the collections of entities that comprise the actual device. */
enum
{
    kHIDUsage_VR_Belt    = 0x01,    /* Application Collection */
    kHIDUsage_VR_BodySuit    = 0x02,    /* Application Collection */
    kHIDUsage_VR_Flexor    = 0x03,    /* Physical Collection */
    kHIDUsage_VR_Glove    = 0x04,    /* Application Collection */
    kHIDUsage_VR_HeadTracker    = 0x05,    /* Physical Collection */
    kHIDUsage_VR_HeadMountedDisplay    = 0x06,    /* Application Collection */
    kHIDUsage_VR_HandTracker    = 0x07,    /* Application Collection */
    kHIDUsage_VR_Oculometer    = 0x08,    /* Application Collection */
    kHIDUsage_VR_Vest    = 0x09,    /* Application Collection */
    kHIDUsage_VR_AnimatronicDevice    = 0x0A,    /* Application Collection */
    /* 0x0B - 0x1F Reserved */
    kHIDUsage_VR_StereoEnable    = 0x20,    /* On/Off Control */
    kHIDUsage_VR_DisplayEnable    = 0x21,    /* On/Off Control */
    /* 0x22 - 0xFFFF Reserved */
    kHIDUsage_VR_Reserved = 0xFFFF
};

/* Sport Page (0x04) */
enum
{
    kHIDUsage_Sprt_BaseballBat    = 0x01,    /* Application Collection */
    kHIDUsage_Sprt_GolfClub    = 0x02,    /* Application Collection */
    kHIDUsage_Sprt_RowingMachine    = 0x03,    /* Application Collection */
    kHIDUsage_Sprt_Treadmill    = 0x04,    /* Application Collection */
    /* 0x05 - 0x2F Reserved */
    kHIDUsage_Sprt_Oar    = 0x30,    /* Dynamic Value */
    kHIDUsage_Sprt_Slope    = 0x31,    /* Dynamic Value */
    kHIDUsage_Sprt_Rate    = 0x32,    /* Dynamic Value */
    kHIDUsage_Sprt_StickSpeed    = 0x33,    /* Dynamic Value */
    kHIDUsage_Sprt_StickFaceAngle    = 0x34,    /* Dynamic Value */
    kHIDUsage_Sprt_StickHeelOrToe    = 0x35,    /* Dynamic Value */
    kHIDUsage_Sprt_StickFollowThrough    = 0x36,    /* Dynamic Value */
    kHIDUsage_Sprt_StickTempo    = 0x37,    /* Dynamic Value */
    kHIDUsage_Sprt_StickType    = 0x38,    /* Named Array */
    kHIDUsage_Sprt_StickHeight    = 0x39,    /* Dynamic Value */
    /* 0x3A - 0x4F Reserved */
    kHIDUsage_Sprt_Putter    = 0x50,    /* Selector */
    kHIDUsage_Sprt_1Iron    = 0x51,    /* Selector */
    kHIDUsage_Sprt_2Iron    = 0x52,    /* Selector */
    kHIDUsage_Sprt_3Iron    = 0x53,    /* Selector */
    kHIDUsage_Sprt_4Iron    = 0x54,    /* Selector */
    kHIDUsage_Sprt_5Iron    = 0x55,    /* Selector */
    kHIDUsage_Sprt_6Iron    = 0x56,    /* Selector */
    kHIDUsage_Sprt_7Iron    = 0x57,    /* Selector */
    kHIDUsage_Sprt_8Iron    = 0x58,    /* Selector */
    kHIDUsage_Sprt_9Iron    = 0x59,    /* Selector */
    kHIDUsage_Sprt_10Iron    = 0x5A,    /* Selector */
    kHIDUsage_Sprt_11Iron    = 0x5B,    /* Selector */
    kHIDUsage_Sprt_SandWedge    = 0x5C,    /* Selector */
    kHIDUsage_Sprt_LoftWedge    = 0x5D,    /* Selector */
    kHIDUsage_Sprt_PowerWedge    = 0x5E,    /* Selector */
    kHIDUsage_Sprt_1Wood    = 0x5F,    /* Selector */
    kHIDUsage_Sprt_3Wood    = 0x60,    /* Selector */
    kHIDUsage_Sprt_5Wood    = 0x61,    /* Selector */
    kHIDUsage_Sprt_7Wood    = 0x62,    /* Selector */
    kHIDUsage_Sprt_9Wood    = 0x63,    /* Selector */
    /* 0x64 - 0xFFFF Reserved */
    kHIDUsage_Sprt_Reserved = 0xFFFF
};

/* Game Page (0x05) */
enum
{
    kHIDUsage_Game_3DGameController    = 0x01,    /* Application Collection */
    kHIDUsage_Game_PinballDevice    = 0x02,    /* Application Collection */
    kHIDUsage_Game_GunDevice    = 0x03,    /* Application Collection */
    /* 0x04 - 0x1F Reserved */
    kHIDUsage_Game_PointofView    = 0x20,    /* Physical Collection */
    kHIDUsage_Game_TurnRightOrLeft    = 0x21,    /* Dynamic Value */
    kHIDUsage_Game_PitchUpOrDown    = 0x22,    /* Dynamic Value */
    kHIDUsage_Game_RollRightOrLeft    = 0x23,    /* Dynamic Value */
    kHIDUsage_Game_MoveRightOrLeft    = 0x24,    /* Dynamic Value */
    kHIDUsage_Game_MoveForwardOrBackward    = 0x25,    /* Dynamic Value */
    kHIDUsage_Game_MoveUpOrDown    = 0x26,    /* Dynamic Value */
    kHIDUsage_Game_LeanRightOrLeft    = 0x27,    /* Dynamic Value */
    kHIDUsage_Game_LeanForwardOrBackward    = 0x28,    /* Dynamic Value */
    kHIDUsage_Game_HeightOfPOV    = 0x29,    /* Dynamic Value */
    kHIDUsage_Game_Flipper    = 0x2A,    /* Momentary Control */
    kHIDUsage_Game_SecondaryFlipper    = 0x2B,    /* Momentary Control */
    kHIDUsage_Game_Bump    = 0x2C,    /* Momentary Control */
    kHIDUsage_Game_NewGame    = 0x2D,    /* One-Shot Control */
    kHIDUsage_Game_ShootBall    = 0x2E,    /* One-Shot Control */
    kHIDUsage_Game_Player    = 0x2F,    /* One-Shot Control */
    kHIDUsage_Game_GunBolt    = 0x30,    /* On/Off Control */
    kHIDUsage_Game_GunClip    = 0x31,    /* On/Off Control */
    kHIDUsage_Game_Gun    = 0x32,    /* Selector */
    kHIDUsage_Game_GunSingleShot    = 0x33,    /* Selector */
    kHIDUsage_Game_GunBurst    = 0x34,    /* Selector */
    kHIDUsage_Game_GunAutomatic    = 0x35,    /* Selector */
    kHIDUsage_Game_GunSafety    = 0x36,    /* On/Off Control */
    kHIDUsage_Game_GamepadFireOrJump    = 0x37,    /* Logical Collection */
    kHIDUsage_Game_GamepadTrigger    = 0x39,    /* Logical Collection */
    /* 0x3A - 0xFFFF Reserved */
    kHIDUsage_Game_Reserved = 0xFFFF
};

/* Generic Device Controls (0x0g) */
enum
{
    kHIDUsage_GenDevControls_BackgroundControls     = 0x01, /* Application Collection */
};

/* KeyboardOrKeypad Page (0x07) */
/* This section is the Usage Page for key codes to be used in implementing a USB keyboard. A Boot Keyboard (84-, 101- or 104-key) should at a minimum support all associated usage codes as indicated in the “Boot” */
/* column below. */
/* The usage type of all key codes is Selectors (Sel), except for the modifier keys Keyboard Left Control (0x224) to Keyboard Right GUI (0x231) which are Dynamic Flags (DV). */
/* Note: A general note on Usages and languages: Due to the variation of keyboards from language to language, it is not feasible to specify exact key mappings for every language. Where this list is not specific for a key function in a language, the closest equivalent key position should be used, so that a keyboard may be modified for a different language by simply printing different keycaps. One example is the Y key on a North American keyboard. In Germany this is typically Z. Rather than changing the keyboard firmware to put the Z Usage into that place in the descriptor list, the vendor should use the Y Usage on both the North American and German keyboards. This continues to be the existing practice in the industry, in order to minimize the number of changes to the electronics to accommodate otherlanguages. */
enum
{
    kHIDUsage_KeyboardErrorRollOver    = 0x01,    /* ErrorRollOver */
    kHIDUsage_KeyboardPOSTFail    = 0x02,    /* POSTFail */
    kHIDUsage_KeyboardErrorUndefined    = 0x03,    /* ErrorUndefined */
    kHIDUsage_KeyboardA    = 0x04,    /* a or A */
    kHIDUsage_KeyboardB    = 0x05,    /* b or B */
    kHIDUsage_KeyboardC    = 0x06,    /* c or C */
    kHIDUsage_KeyboardD    = 0x07,    /* d or D */
    kHIDUsage_KeyboardE    = 0x08,    /* e or E */
    kHIDUsage_KeyboardF    = 0x09,    /* f or F */
    kHIDUsage_KeyboardG    = 0x0A,    /* g or G */
    kHIDUsage_KeyboardH    = 0x0B,    /* h or H */
    kHIDUsage_KeyboardI    = 0x0C,    /* i or I */
    kHIDUsage_KeyboardJ    = 0x0D,    /* j or J */
    kHIDUsage_KeyboardK    = 0x0E,    /* k or K */
    kHIDUsage_KeyboardL    = 0x0F,    /* l or L */
    kHIDUsage_KeyboardM    = 0x10,    /* m or M */
    kHIDUsage_KeyboardN    = 0x11,    /* n or N */
    kHIDUsage_KeyboardO    = 0x12,    /* o or O */
    kHIDUsage_KeyboardP    = 0x13,    /* p or P */
    kHIDUsage_KeyboardQ    = 0x14,    /* q or Q */
    kHIDUsage_KeyboardR    = 0x15,    /* r or R */
    kHIDUsage_KeyboardS    = 0x16,    /* s or S */
    kHIDUsage_KeyboardT    = 0x17,    /* t or T */
    kHIDUsage_KeyboardU    = 0x18,    /* u or U */
    kHIDUsage_KeyboardV    = 0x19,    /* v or V */
    kHIDUsage_KeyboardW    = 0x1A,    /* w or W */
    kHIDUsage_KeyboardX    = 0x1B,    /* x or X */
    kHIDUsage_KeyboardY    = 0x1C,    /* y or Y */
    kHIDUsage_KeyboardZ    = 0x1D,    /* z or Z */
    kHIDUsage_Keyboard1    = 0x1E,    /* 1 or ! */
    kHIDUsage_Keyboard2    = 0x1F,    /* 2 or @ */
    kHIDUsage_Keyboard3    = 0x20,    /* 3 or # */
    kHIDUsage_Keyboard4    = 0x21,    /* 4 or $ */
    kHIDUsage_Keyboard5    = 0x22,    /* 5 or % */
    kHIDUsage_Keyboard6    = 0x23,    /* 6 or ^ */
    kHIDUsage_Keyboard7    = 0x24,    /* 7 or & */
    kHIDUsage_Keyboard8    = 0x25,    /* 8 or * */
    kHIDUsage_Keyboard9    = 0x26,    /* 9 or ( */
    kHIDUsage_Keyboard0    = 0x27,    /* 0 or ) */
    kHIDUsage_KeyboardReturnOrEnter    = 0x28,    /* Return (Enter) */
    kHIDUsage_KeyboardEscape    = 0x29,    /* Escape */
    kHIDUsage_KeyboardDeleteOrBackspace    = 0x2A,    /* Delete (Backspace) */
    kHIDUsage_KeyboardTab    = 0x2B,    /* Tab */
    kHIDUsage_KeyboardSpacebar    = 0x2C,    /* Spacebar */
    kHIDUsage_KeyboardHyphen    = 0x2D,    /* - or _ */
    kHIDUsage_KeyboardEqualSign    = 0x2E,    /* = or + */
    kHIDUsage_KeyboardOpenBracket    = 0x2F,    /* [ or { */
    kHIDUsage_KeyboardCloseBracket    = 0x30,    /* ] or } */
    kHIDUsage_KeyboardBackslash    = 0x31,    /* \ or | */
    kHIDUsage_KeyboardNonUSPound    = 0x32,    /* Non-US # or _ */
    kHIDUsage_KeyboardSemicolon    = 0x33,    /* ; or : */
    kHIDUsage_KeyboardQuote    = 0x34,    /* ' or " */
    kHIDUsage_KeyboardGraveAccentAndTilde    = 0x35,    /* Grave Accent and Tilde */
    kHIDUsage_KeyboardComma    = 0x36,    /* , or < */
    kHIDUsage_KeyboardPeriod    = 0x37,    /* . or > */
    kHIDUsage_KeyboardSlash    = 0x38,    /* / or ? */
    kHIDUsage_KeyboardCapsLock    = 0x39,    /* Caps Lock */
    kHIDUsage_KeyboardF1    = 0x3A,    /* F1 */
    kHIDUsage_KeyboardF2    = 0x3B,    /* F2 */
    kHIDUsage_KeyboardF3    = 0x3C,    /* F3 */
    kHIDUsage_KeyboardF4    = 0x3D,    /* F4 */
    kHIDUsage_KeyboardF5    = 0x3E,    /* F5 */
    kHIDUsage_KeyboardF6    = 0x3F,    /* F6 */
    kHIDUsage_KeyboardF7    = 0x40,    /* F7 */
    kHIDUsage_KeyboardF8    = 0x41,    /* F8 */
    kHIDUsage_KeyboardF9    = 0x42,    /* F9 */
    kHIDUsage_KeyboardF10    = 0x43,    /* F10 */
    kHIDUsage_KeyboardF11    = 0x44,    /* F11 */
    kHIDUsage_KeyboardF12    = 0x45,    /* F12 */
    kHIDUsage_KeyboardPrintScreen    = 0x46,    /* Print Screen */
    kHIDUsage_KeyboardScrollLock    = 0x47,    /* Scroll Lock */
    kHIDUsage_KeyboardPause    = 0x48,    /* Pause */
    kHIDUsage_KeyboardInsert    = 0x49,    /* Insert */
    kHIDUsage_KeyboardHome    = 0x4A,    /* Home */
    kHIDUsage_KeyboardPageUp    = 0x4B,    /* Page Up */
    kHIDUsage_KeyboardDeleteForward    = 0x4C,    /* Delete Forward */
    kHIDUsage_KeyboardEnd    = 0x4D,    /* End */
    kHIDUsage_KeyboardPageDown    = 0x4E,    /* Page Down */
    kHIDUsage_KeyboardRightArrow    = 0x4F,    /* Right Arrow */
    kHIDUsage_KeyboardLeftArrow    = 0x50,    /* Left Arrow */
    kHIDUsage_KeyboardDownArrow    = 0x51,    /* Down Arrow */
    kHIDUsage_KeyboardUpArrow    = 0x52,    /* Up Arrow */
    kHIDUsage_KeypadNumLock    = 0x53,    /* Keypad NumLock or Clear */
    kHIDUsage_KeypadSlash    = 0x54,    /* Keypad / */
    kHIDUsage_KeypadAsterisk    = 0x55,    /* Keypad * */
    kHIDUsage_KeypadHyphen    = 0x56,    /* Keypad - */
    kHIDUsage_KeypadPlus    = 0x57,    /* Keypad + */
    kHIDUsage_KeypadEnter    = 0x58,    /* Keypad Enter */
    kHIDUsage_Keypad1    = 0x59,    /* Keypad 1 or End */
    kHIDUsage_Keypad2    = 0x5A,    /* Keypad 2 or Down Arrow */
    kHIDUsage_Keypad3    = 0x5B,    /* Keypad 3 or Page Down */
    kHIDUsage_Keypad4    = 0x5C,    /* Keypad 4 or Left Arrow */
    kHIDUsage_Keypad5    = 0x5D,    /* Keypad 5 */
    kHIDUsage_Keypad6    = 0x5E,    /* Keypad 6 or Right Arrow */
    kHIDUsage_Keypad7    = 0x5F,    /* Keypad 7 or Home */
    kHIDUsage_Keypad8    = 0x60,    /* Keypad 8 or Up Arrow */
    kHIDUsage_Keypad9    = 0x61,    /* Keypad 9 or Page Up */
    kHIDUsage_Keypad0    = 0x62,    /* Keypad 0 or Insert */
    kHIDUsage_KeypadPeriod    = 0x63,    /* Keypad . or Delete */
    kHIDUsage_KeyboardNonUSBackslash    = 0x64,    /* Non-US \ or | */
    kHIDUsage_KeyboardApplication    = 0x65,    /* Application */
    kHIDUsage_KeyboardPower    = 0x66,    /* Power */
    kHIDUsage_KeypadEqualSign    = 0x67,    /* Keypad = */
    kHIDUsage_KeyboardF13    = 0x68,    /* F13 */
    kHIDUsage_KeyboardF14    = 0x69,    /* F14 */
    kHIDUsage_KeyboardF15    = 0x6A,    /* F15 */
    kHIDUsage_KeyboardF16    = 0x6B,    /* F16 */
    kHIDUsage_KeyboardF17    = 0x6C,    /* F17 */
    kHIDUsage_KeyboardF18    = 0x6D,    /* F18 */
    kHIDUsage_KeyboardF19    = 0x6E,    /* F19 */
    kHIDUsage_KeyboardF20    = 0x6F,    /* F20 */
    kHIDUsage_KeyboardF21    = 0x70,    /* F21 */
    kHIDUsage_KeyboardF22    = 0x71,    /* F22 */
    kHIDUsage_KeyboardF23    = 0x72,    /* F23 */
    kHIDUsage_KeyboardF24    = 0x73,    /* F24 */
    kHIDUsage_KeyboardExecute    = 0x74,    /* Execute */
    kHIDUsage_KeyboardHelp    = 0x75,    /* Help */
    kHIDUsage_KeyboardMenu    = 0x76,    /* Menu */
    kHIDUsage_KeyboardSelect    = 0x77,    /* Select */
    kHIDUsage_KeyboardStop    = 0x78,    /* Stop */
    kHIDUsage_KeyboardAgain    = 0x79,    /* Again */
    kHIDUsage_KeyboardUndo    = 0x7A,    /* Undo */
    kHIDUsage_KeyboardCut    = 0x7B,    /* Cut */
    kHIDUsage_KeyboardCopy    = 0x7C,    /* Copy */
    kHIDUsage_KeyboardPaste    = 0x7D,    /* Paste */
    kHIDUsage_KeyboardFind    = 0x7E,    /* Find */
    kHIDUsage_KeyboardMute    = 0x7F,    /* Mute */
    kHIDUsage_KeyboardVolumeUp    = 0x80,    /* Volume Up */
    kHIDUsage_KeyboardVolumeDown    = 0x81,    /* Volume Down */
    kHIDUsage_KeyboardLockingCapsLock    = 0x82,    /* Locking Caps Lock */
    kHIDUsage_KeyboardLockingNumLock    = 0x83,    /* Locking Num Lock */
    kHIDUsage_KeyboardLockingScrollLock    = 0x84,    /* Locking Scroll Lock */
    kHIDUsage_KeypadComma    = 0x85,    /* Keypad Comma */
    kHIDUsage_KeypadEqualSignAS400    = 0x86,    /* Keypad Equal Sign for AS/400 */
    kHIDUsage_KeyboardInternational1    = 0x87,    /* International1 */
    kHIDUsage_KeyboardInternational2    = 0x88,    /* International2 */
    kHIDUsage_KeyboardInternational3    = 0x89,    /* International3 */
    kHIDUsage_KeyboardInternational4    = 0x8A,    /* International4 */
    kHIDUsage_KeyboardInternational5    = 0x8B,    /* International5 */
    kHIDUsage_KeyboardInternational6    = 0x8C,    /* International6 */
    kHIDUsage_KeyboardInternational7    = 0x8D,    /* International7 */
    kHIDUsage_KeyboardInternational8    = 0x8E,    /* International8 */
    kHIDUsage_KeyboardInternational9    = 0x8F,    /* International9 */
    kHIDUsage_KeyboardLANG1    = 0x90,    /* LANG1 */
    kHIDUsage_KeyboardLANG2    = 0x91,    /* LANG2 */
    kHIDUsage_KeyboardLANG3    = 0x92,    /* LANG3 */
    kHIDUsage_KeyboardLANG4    = 0x93,    /* LANG4 */
    kHIDUsage_KeyboardLANG5    = 0x94,    /* LANG5 */
    kHIDUsage_KeyboardLANG6    = 0x95,    /* LANG6 */
    kHIDUsage_KeyboardLANG7    = 0x96,    /* LANG7 */
    kHIDUsage_KeyboardLANG8    = 0x97,    /* LANG8 */
    kHIDUsage_KeyboardLANG9    = 0x98,    /* LANG9 */
    kHIDUsage_KeyboardAlternateErase    = 0x99,    /* AlternateErase */
    kHIDUsage_KeyboardSysReqOrAttention    = 0x9A,    /* SysReq/Attention */
    kHIDUsage_KeyboardCancel    = 0x9B,    /* Cancel */
    kHIDUsage_KeyboardClear    = 0x9C,    /* Clear */
    kHIDUsage_KeyboardPrior    = 0x9D,    /* Prior */
    kHIDUsage_KeyboardReturn    = 0x9E,    /* Return */
    kHIDUsage_KeyboardSeparator    = 0x9F,    /* Separator */
    kHIDUsage_KeyboardOut    = 0xA0,    /* Out */
    kHIDUsage_KeyboardOper    = 0xA1,    /* Oper */
    kHIDUsage_KeyboardClearOrAgain    = 0xA2,    /* Clear/Again */
    kHIDUsage_KeyboardCrSelOrProps    = 0xA3,    /* CrSel/Props */
    kHIDUsage_KeyboardExSel    = 0xA4,    /* ExSel */
    /* 0xA5-0xDF Reserved */
    kHIDUsage_KeyboardLeftControl    = 0xE0,    /* Left Control */
    kHIDUsage_KeyboardLeftShift    = 0xE1,    /* Left Shift */
    kHIDUsage_KeyboardLeftAlt    = 0xE2,    /* Left Alt */
    kHIDUsage_KeyboardLeftGUI    = 0xE3,    /* Left GUI */
    kHIDUsage_KeyboardRightControl    = 0xE4,    /* Right Control */
    kHIDUsage_KeyboardRightShift    = 0xE5,    /* Right Shift */
    kHIDUsage_KeyboardRightAlt    = 0xE6,    /* Right Alt */
    kHIDUsage_KeyboardRightGUI    = 0xE7,    /* Right GUI */
    /* 0xE8-0xFFFF Reserved */
    kHIDUsage_Keyboard_Reserved = 0xFFFF
};

/* LEDs Page (0x08) */
/* An LED or indicator is implemented as an On/Off Control (OOF) using the “Single button toggle” mode, where a value of 1 will turn on the indicator, and a value of 0 will turn it off. The exceptions are described below. */
enum
{
    kHIDUsage_LED_NumLock    = 0x01,    /* On/Off Control */
    kHIDUsage_LED_CapsLock    = 0x02,    /* On/Off Control */
    kHIDUsage_LED_ScrollLock    = 0x03,    /* On/Off Control */
    kHIDUsage_LED_Compose    = 0x04,    /* On/Off Control */
    kHIDUsage_LED_Kana    = 0x05,    /* On/Off Control */
    kHIDUsage_LED_Power    = 0x06,    /* On/Off Control */
    kHIDUsage_LED_Shift    = 0x07,    /* On/Off Control */
    kHIDUsage_LED_DoNotDisturb    = 0x08,    /* On/Off Control */
    kHIDUsage_LED_Mute    = 0x09,    /* On/Off Control */
    kHIDUsage_LED_ToneEnable    = 0x0A,    /* On/Off Control */
    kHIDUsage_LED_HighCutFilter    = 0x0B,    /* On/Off Control */
    kHIDUsage_LED_LowCutFilter    = 0x0C,    /* On/Off Control */
    kHIDUsage_LED_EqualizerEnable    = 0x0D,    /* On/Off Control */
    kHIDUsage_LED_SoundFieldOn    = 0x0E,    /* On/Off Control */
    kHIDUsage_LED_SurroundOn    = 0x0F,    /* On/Off Control */
    kHIDUsage_LED_Repeat    = 0x10,    /* On/Off Control */
    kHIDUsage_LED_Stereo    = 0x11,    /* On/Off Control */
    kHIDUsage_LED_SamplingRateDetect    = 0x12,    /* On/Off Control */
    kHIDUsage_LED_Spinning    = 0x13,    /* On/Off Control */
    kHIDUsage_LED_CAV    = 0x14,    /* On/Off Control */
    kHIDUsage_LED_CLV    = 0x15,    /* On/Off Control */
    kHIDUsage_LED_RecordingFormatDetect    = 0x16,    /* On/Off Control */
    kHIDUsage_LED_OffHook    = 0x17,    /* On/Off Control */
    kHIDUsage_LED_Ring    = 0x18,    /* On/Off Control */
    kHIDUsage_LED_MessageWaiting    = 0x19,    /* On/Off Control */
    kHIDUsage_LED_DataMode    = 0x1A,    /* On/Off Control */
    kHIDUsage_LED_BatteryOperation    = 0x1B,    /* On/Off Control */
    kHIDUsage_LED_BatteryOK    = 0x1C,    /* On/Off Control */
    kHIDUsage_LED_BatteryLow    = 0x1D,    /* On/Off Control */
    kHIDUsage_LED_Speaker    = 0x1E,    /* On/Off Control */
    kHIDUsage_LED_HeadSet    = 0x1F,    /* On/Off Control */
    kHIDUsage_LED_Hold    = 0x20,    /* On/Off Control */
    kHIDUsage_LED_Microphone    = 0x21,    /* On/Off Control */
    kHIDUsage_LED_Coverage    = 0x22,    /* On/Off Control */
    kHIDUsage_LED_NightMode    = 0x23,    /* On/Off Control */
    kHIDUsage_LED_SendCalls    = 0x24,    /* On/Off Control */
    kHIDUsage_LED_CallPickup    = 0x25,    /* On/Off Control */
    kHIDUsage_LED_Conference    = 0x26,    /* On/Off Control */
    kHIDUsage_LED_StandBy    = 0x27,    /* On/Off Control */
    kHIDUsage_LED_CameraOn    = 0x28,    /* On/Off Control */
    kHIDUsage_LED_CameraOff    = 0x29,    /* On/Off Control */
    kHIDUsage_LED_OnLine    = 0x2A,    /* On/Off Control */
    kHIDUsage_LED_OffLine    = 0x2B,    /* On/Off Control */
    kHIDUsage_LED_Busy    = 0x2C,    /* On/Off Control */
    kHIDUsage_LED_Ready    = 0x2D,    /* On/Off Control */
    kHIDUsage_LED_PaperOut    = 0x2E,    /* On/Off Control */
    kHIDUsage_LED_PaperJam    = 0x2F,    /* On/Off Control */
    kHIDUsage_LED_Remote    = 0x30,    /* On/Off Control */
    kHIDUsage_LED_Forward    = 0x31,    /* On/Off Control */
    kHIDUsage_LED_Reverse    = 0x32,    /* On/Off Control */
    kHIDUsage_LED_Stop    = 0x33,    /* On/Off Control */
    kHIDUsage_LED_Rewind    = 0x34,    /* On/Off Control */
    kHIDUsage_LED_FastForward    = 0x35,    /* On/Off Control */
    kHIDUsage_LED_Play    = 0x36,    /* On/Off Control */
    kHIDUsage_LED_Pause    = 0x37,    /* On/Off Control */
    kHIDUsage_LED_Record    = 0x38,    /* On/Off Control */
    kHIDUsage_LED_Error    = 0x39,    /* On/Off Control */
    kHIDUsage_LED_Usage    = 0x3A,    /* Selector */
    kHIDUsage_LED_UsageInUseIndicator    = 0x3B,    /* Usage Switch */
    kHIDUsage_LED_UsageMultiModeIndicator    = 0x3C,    /* Usage Modifier */
    kHIDUsage_LED_IndicatorOn    = 0x3D,    /* Selector */
    kHIDUsage_LED_IndicatorFlash    = 0x3E,    /* Selector */
    kHIDUsage_LED_IndicatorSlowBlink    = 0x3F,    /* Selector */
    kHIDUsage_LED_IndicatorFastBlink    = 0x40,    /* Selector */
    kHIDUsage_LED_IndicatorOff    = 0x41,    /* Selector */
    kHIDUsage_LED_FlashOnTime    = 0x42,    /* Dynamic Value */
    kHIDUsage_LED_SlowBlinkOnTime    = 0x43,    /* Dynamic Value */
    kHIDUsage_LED_SlowBlinkOffTime    = 0x44,    /* Dynamic Value */
    kHIDUsage_LED_FastBlinkOnTime    = 0x45,    /* Dynamic Value */
    kHIDUsage_LED_FastBlinkOffTime    = 0x46,    /* Dynamic Value */
    kHIDUsage_LED_UsageIndicatorColor    = 0x47,    /* Usage Modifier */
    kHIDUsage_LED_IndicatorRed    = 0x48,    /* Selector */
    kHIDUsage_LED_IndicatorGreen    = 0x49,    /* Selector */
    kHIDUsage_LED_IndicatorAmber    = 0x4A,    /* Selector */
    kHIDUsage_LED_GenericIndicator    = 0x4B,    /* On/Off Control */
    kHIDUsage_LED_SystemSuspend    = 0x4C,    /* On/Off Control */
    kHIDUsage_LED_ExternalPowerConnected    = 0x4D,    /* On/Off Control */
    /* 0x4E - 0xFFFF Reserved */
    kHIDUsage_LED_Reserved = 0xFFFF
};

/* Button Page (0x09) */
/* The Button page is the first place an application should look for user selection controls. System graphical user interfaces typically employ a pointer and a set of hierarchical selectors to select, move and otherwise manipulate their environment. For these purposes the following assignment of significance can be applied to the Button usages: */
/* • Button 1, Primary Button. Used for object selecting, dragging, and double click activation. On MacOS, this is the only button. Microsoft operating systems call this a logical left button, because it */
/* is not necessarily physically located on the left of the pointing device. */
/* • Button 2, Secondary Button. Used by newer graphical user interfaces to browse object properties. Exposed by systems to applications that typically assign application-specific functionality. */
/* • Button 3, Tertiary Button. Optional control. Exposed to applications, but seldom assigned functionality due to prevalence of two- and one-button devices. */
/* • Buttons 4 -55. As the button number increases, its significance as a selector decreases. */
/* In many ways the assignment of button numbers is similar to the assignment of Effort in Physical descriptors. Button 1 would be used to define the button a finger rests on when the hand is in the “at rest” position, that is, virtually no effort is required by the user to activate the button. Button values increment as the finger has to stretch to reach a control. See Section 6.2.3, “Physical Descriptors,” in the HID Specification for methods of further qualifying buttons. */
enum
{
    kHIDUsage_Button_1    = 0x01,    /* (primary/trigger) */
    kHIDUsage_Button_2    = 0x02,    /* (secondary) */
    kHIDUsage_Button_3    = 0x03,    /* (tertiary) */
    kHIDUsage_Button_4    = 0x04, /* 4th button */
    /* ... */
    kHIDUsage_Button_65535    = 0xFFFF
};

/* Ordinal Page (0x0A) */
/* The Ordinal page allows multiple instances of a control or sets of controls to be declared without requiring individual enumeration in the native usage page. For example, it is not necessary to declare usages of Pointer 1, Pointer 2, and so forth on the Generic Desktop page. When parsed, the ordinal instance number is, in essence, concatenated to the usages attached to the encompassing collection to create Pointer 1, Pointer 2, and so forth. */
/* For an example, see Section A.5, “Multiple Instances of a Control,” in Appendix A, “Usage Examples.” By convention, an Ordinal collection is placed inside the collection for which it is declaring multiple instances. */
/* Instances do not have to be identical. */
enum
{
    /* 0x00 Reserved */
    kHIDUsage_Ord_Instance1    = 0x01,    /* Usage Modifier */
    kHIDUsage_Ord_Instance2    = 0x02,    /* Usage Modifier */
    kHIDUsage_Ord_Instance3    = 0x03,    /* Usage Modifier */
    kHIDUsage_Ord_Instance4    = 0x04,    /* Usage Modifier */
    kHIDUsage_Ord_Instance65535    = 0xFFFF    /* Usage Modifier */
};

/* Telephony Page (0x0B) */
/* This usage page defines the keytop and control usages for telephony devices. */
/* Indicators on a phone are handled by wrapping them in LED: Usage In Use Indicator and LED: Usage Selected Indicator usages. For example, a message-indicator LED would be identified by a Telephony: Message usage declared as a Feature or Output in a LED: Usage In Use Indicator collection. */
/* See Section 14, “Consumer Page (0x0C),” for audio volume and tone controls. */
enum
{
    kHIDUsage_Tfon_Phone    = 0x01,    /* Application Collection */
    kHIDUsage_Tfon_AnsweringMachine    = 0x02,    /* Application Collection */
    kHIDUsage_Tfon_MessageControls    = 0x03,    /* Logical Collection */
    kHIDUsage_Tfon_Handset    = 0x04,    /* Logical Collection */
    kHIDUsage_Tfon_Headset    = 0x05,    /* Logical Collection */
    kHIDUsage_Tfon_TelephonyKeyPad    = 0x06,    /* Named Array */
    kHIDUsage_Tfon_ProgrammableButton    = 0x07,    /* Named Array */
    /* 0x08 - 0x1F Reserved */
    kHIDUsage_Tfon_HookSwitch    = 0x20,    /* On/Off Control */
    kHIDUsage_Tfon_Flash    = 0x21,    /* Momentary Control */
    kHIDUsage_Tfon_Feature    = 0x22,    /* One-Shot Control */
    kHIDUsage_Tfon_Hold    = 0x23,    /* On/Off Control */
    kHIDUsage_Tfon_Redial    = 0x24,    /* One-Shot Control */
    kHIDUsage_Tfon_Transfer    = 0x25,    /* One-Shot Control */
    kHIDUsage_Tfon_Drop    = 0x26,    /* One-Shot Control */
    kHIDUsage_Tfon_Park    = 0x27,    /* On/Off Control */
    kHIDUsage_Tfon_ForwardCalls    = 0x28,    /* On/Off Control */
    kHIDUsage_Tfon_AlternateFunction    = 0x29,    /* Momentary Control */
    kHIDUsage_Tfon_Line    = 0x2A,    /* One-Shot Control */
    kHIDUsage_Tfon_SpeakerPhone    = 0x2B,    /* On/Off Control */
    kHIDUsage_Tfon_Conference    = 0x2C,    /* On/Off Control */
    kHIDUsage_Tfon_RingEnable    = 0x2D,    /* On/Off Control */
    kHIDUsage_Tfon_Ring    = 0x2E,    /* Selector */
    kHIDUsage_Tfon_PhoneMute    = 0x2F,    /* On/Off Control */
    kHIDUsage_Tfon_CallerID    = 0x30,    /* Momentary Control */
    /* 0x31 - 0x4F Reserved */
    kHIDUsage_Tfon_SpeedDial    = 0x50,    /* One-Shot Control */
    kHIDUsage_Tfon_StoreNumber    = 0x51,    /* One-Shot Control */
    kHIDUsage_Tfon_RecallNumber    = 0x52,    /* One-Shot Control */
    kHIDUsage_Tfon_PhoneDirectory    = 0x53,    /* On/Off Control */
    /* 0x54 - 0x6F Reserved */
    kHIDUsage_Tfon_VoiceMail    = 0x70,    /* On/Off Control */
    kHIDUsage_Tfon_ScreenCalls    = 0x71,    /* On/Off Control */
    kHIDUsage_Tfon_DoNotDisturb    = 0x72,    /* On/Off Control */
    kHIDUsage_Tfon_Message    = 0x73,    /* One-Shot Control */
    kHIDUsage_Tfon_AnswerOnOrOff    = 0x74,    /* On/Off Control */
    /* 0x75 - 0x8F Reserved */
    kHIDUsage_Tfon_InsideDialTone    = 0x90,    /* Momentary Control */
    kHIDUsage_Tfon_OutsideDialTone    = 0x91,    /* Momentary Control */
    kHIDUsage_Tfon_InsideRingTone    = 0x92,    /* Momentary Control */
    kHIDUsage_Tfon_OutsideRingTone    = 0x93,    /* Momentary Control */
    kHIDUsage_Tfon_PriorityRingTone    = 0x94,    /* Momentary Control */
    kHIDUsage_Tfon_InsideRingback    = 0x95,    /* Momentary Control */
    kHIDUsage_Tfon_PriorityRingback    = 0x96,    /* Momentary Control */
    kHIDUsage_Tfon_LineBusyTone    = 0x97,    /* Momentary Control */
    kHIDUsage_Tfon_ReorderTone    = 0x98,    /* Momentary Control */
    kHIDUsage_Tfon_CallWaitingTone    = 0x99,    /* Momentary Control */
    kHIDUsage_Tfon_ConfirmationTone1    = 0x9A,    /* Momentary Control */
    kHIDUsage_Tfon_ConfirmationTone2    = 0x9B,    /* Momentary Control */
    kHIDUsage_Tfon_TonesOff    = 0x9C,    /* On/Off Control */
    kHIDUsage_Tfon_OutsideRingback    = 0x9D,    /* Momentary Control */
    /* 0x9E - 0xAF Reserved */
    kHIDUsage_Tfon_PhoneKey0    = 0xB0,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey1    = 0xB1,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey2    = 0xB2,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey3    = 0xB3,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey4    = 0xB4,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey5    = 0xB5,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey6    = 0xB6,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey7    = 0xB7,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey8    = 0xB8,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey9    = 0xB9,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyStar    = 0xBA,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyPound    = 0xBB,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyA    = 0xBC,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyB    = 0xBD,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyC    = 0xBE,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyD    = 0xBF,    /* Selector/One-Shot Control */
    /* 0xC0 - 0xFFFF Reserved */
    kHIDUsage_TFon_Reserved = 0xFFFF
};

/* Consumer Page (0x0C) */
/* All controls on the Consumer page are application-specific. That is, they affect a specific device, not the system as a whole. */
enum
{
    kHIDUsage_Csmr_ConsumerControl    = 0x01,    /* Application Collection */
    kHIDUsage_Csmr_NumericKeyPad    = 0x02,    /* Named Array */
    kHIDUsage_Csmr_ProgrammableButtons    = 0x03,    /* Named Array */
    kHIDUsage_Csmr_Microphone   = 0x04,    /* Application Collection */
    kHIDUsage_Csmr_Headphone   = 0x05,    /* Application Collection */
    kHIDUsage_Csmr_GraphicEqualizer   = 0x06,    /* Application Collection */
    /* 0x07 - 0x1F Reserved */
    kHIDUsage_Csmr_Plus10    = 0x20,    /* One-Shot Control */
    kHIDUsage_Csmr_Plus100    = 0x21,    /* One-Shot Control */
    kHIDUsage_Csmr_AMOrPM    = 0x22,    /* One-Shot Control */
    /* 0x23 - 0x3F Reserved */
    kHIDUsage_Csmr_Power    = 0x30,    /* On/Off Control */
    kHIDUsage_Csmr_Reset    = 0x31,    /* One-Shot Control */
    kHIDUsage_Csmr_Sleep    = 0x32,    /* One-Shot Control */
    kHIDUsage_Csmr_SleepAfter    = 0x33,    /* One-Shot Control */
    kHIDUsage_Csmr_SleepMode    = 0x34,    /* Re-Trigger Control */
    kHIDUsage_Csmr_Illumination    = 0x35,    /* On/Off Control */
    kHIDUsage_Csmr_FunctionButtons    = 0x36,    /* Named Array */
    /* 0x37 - 0x3F Reserved */
    kHIDUsage_Csmr_Menu    = 0x40,    /* On/Off Control */
    kHIDUsage_Csmr_MenuPick    = 0x41,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuUp    = 0x42,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuDown    = 0x43,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuLeft    = 0x44,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuRight    = 0x45,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuEscape    = 0x46,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuValueIncrease    = 0x47,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuValueDecrease    = 0x48,    /* One-Shot Control */
    /* 0x49 - 0x5F Reserved */
    kHIDUsage_Csmr_DataOnScreen    = 0x60,    /* On/Off Control */
    kHIDUsage_Csmr_ClosedCaption    = 0x61,    /* On/Off Control */
    kHIDUsage_Csmr_ClosedCaptionSelect    = 0x62,    /* Selector */
    kHIDUsage_Csmr_VCROrTV    = 0x63,    /* On/Off Control */
    kHIDUsage_Csmr_BroadcastMode    = 0x64,    /* One-Shot Control */
    kHIDUsage_Csmr_Snapshot    = 0x65,    /* One-Shot Control */
    kHIDUsage_Csmr_Still    = 0x66,    /* One-Shot Control */
    kHIDUsage_Csmr_PictureInPictureToggle = 0x67, /* One-Shot Control */
    kHIDUsage_Csmr_PictureInPictureSwap = 0x68, /* One-Shot Control */
    kHIDUsage_Csmr_RedMenuButton = 0x69, /* Momentary Control */
    kHIDUsage_Csmr_GreenMenuButton = 0x6A, /* Momentary Control */
    kHIDUsage_Csmr_BlueMenuButton = 0x6B, /* Momentary Control */
    kHIDUsage_Csmr_YellowMenuButton = 0x6C, /* Momentary Control */
    kHIDUsage_Csmr_Aspect = 0x6D, /* One-shot Control */
    kHIDUsage_Csmr_3DModeSelect = 0x6E, /* One-shot Control */
    kHIDUsage_Csmr_DisplayBrightnessIncrement = 0x6F, /* Re-Trigger Control */
    kHIDUsage_Csmr_DisplayBrightnessDecrement = 0x70, /* Re-Trigger Control */
    kHIDUsage_Csmr_DisplayBrightness = 0x71, /* Logical Collection */
    kHIDUsage_Csmr_DisplayBacklightToggle = 0x72, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessMinimum = 0x73, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessMaximum = 0x74, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessSetAutoBrightness = 0x75, /* On Off Control */
    /* 0x76 - 0x7F Reserved */
    kHIDUsage_Csmr_Selection    = 0x80,    /* Named Array */
    kHIDUsage_Csmr_Assign    = 0x81,    /* Selector */
    kHIDUsage_Csmr_ModeStep    = 0x82,    /* One-Shot Control */
    kHIDUsage_Csmr_RecallLast    = 0x83,    /* One-Shot Control */
    kHIDUsage_Csmr_EnterChannel    = 0x84,    /* One-Shot Control */
    kHIDUsage_Csmr_OrderMovie    = 0x85,    /* One-Shot Control */
    kHIDUsage_Csmr_Channel    = 0x86,    /* Linear Control */
    kHIDUsage_Csmr_MediaSelection    = 0x87,    /* Selector */
    kHIDUsage_Csmr_MediaSelectComputer    = 0x88,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTV    = 0x89,    /* Selector */
    kHIDUsage_Csmr_MediaSelectWWW    = 0x8A,    /* Selector */
    kHIDUsage_Csmr_MediaSelectDVD    = 0x8B,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTelephone    = 0x8C,    /* Selector */
    kHIDUsage_Csmr_MediaSelectProgramGuide    = 0x8D,    /* Selector */
    kHIDUsage_Csmr_MediaSelectVideoPhone    = 0x8E,    /* Selector */
    kHIDUsage_Csmr_MediaSelectGames    = 0x8F,    /* Selector */
    kHIDUsage_Csmr_MediaSelectMessages    = 0x90,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCD    = 0x91,    /* Selector */
    kHIDUsage_Csmr_MediaSelectVCR    = 0x92,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTuner    = 0x93,    /* Selector */
    kHIDUsage_Csmr_Quit    = 0x94,    /* One-Shot Control */
    kHIDUsage_Csmr_Help    = 0x95,    /* On/Off Control */
    kHIDUsage_Csmr_MediaSelectTape    = 0x96,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCable    = 0x97,    /* Selector */
    kHIDUsage_Csmr_MediaSelectSatellite    = 0x98,    /* Selector */
    kHIDUsage_Csmr_MediaSelectSecurity    = 0x99,    /* Selector */
    kHIDUsage_Csmr_MediaSelectHome    = 0x9A,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCall    = 0x9B,    /* Selector */
    kHIDUsage_Csmr_ChannelIncrement    = 0x9C,    /* One-Shot Control */
    kHIDUsage_Csmr_ChannelDecrement    = 0x9D,    /* One-Shot Control */
    kHIDUsage_Csmr_Media    = 0x9E,    /* Selector */
    /* 0x9F Reserved */
    kHIDUsage_Csmr_VCRPlus    = 0xA0,    /* One-Shot Control */
    kHIDUsage_Csmr_Once    = 0xA1,    /* One-Shot Control */
    kHIDUsage_Csmr_Daily    = 0xA2,    /* One-Shot Control */
    kHIDUsage_Csmr_Weekly    = 0xA3,    /* One-Shot Control */
    kHIDUsage_Csmr_Monthly    = 0xA4,    /* One-Shot Control */
    /* 0xA5 - 0xAF Reserved */
    kHIDUsage_Csmr_Play    = 0xB0,    /* On/Off Control */
    kHIDUsage_Csmr_Pause    = 0xB1,    /* On/Off Control */
    kHIDUsage_Csmr_Record    = 0xB2,    /* On/Off Control */
    kHIDUsage_Csmr_FastForward    = 0xB3,    /* On/Off Control */
    kHIDUsage_Csmr_Rewind    = 0xB4,    /* On/Off Control */
    kHIDUsage_Csmr_ScanNextTrack    = 0xB5,    /* One-Shot Control */
    kHIDUsage_Csmr_ScanPreviousTrack    = 0xB6,    /* One-Shot Control */
    kHIDUsage_Csmr_Stop    = 0xB7,    /* One-Shot Control */
    kHIDUsage_Csmr_Eject    = 0xB8,    /* One-Shot Control */
    kHIDUsage_Csmr_RandomPlay    = 0xB9,    /* On/Off Control */
    kHIDUsage_Csmr_SelectDisc    = 0xBA,    /* Named Array */
    kHIDUsage_Csmr_EnterDisc    = 0xBB,    /* Momentary Control */
    kHIDUsage_Csmr_Repeat    = 0xBC,    /* One-Shot Control */
    kHIDUsage_Csmr_Tracking    = 0xBD,    /* Linear Control */
    kHIDUsage_Csmr_TrackNormal    = 0xBE,    /* One-Shot Control */
    kHIDUsage_Csmr_SlowTracking    = 0xBF,    /* Linear Control */
    kHIDUsage_Csmr_FrameForward    = 0xC0,    /* Re-Trigger Control */
    kHIDUsage_Csmr_FrameBack    = 0xC1,    /* Re-Trigger Control */
    kHIDUsage_Csmr_Mark    = 0xC2,    /* One-Shot Control */
    kHIDUsage_Csmr_ClearMark    = 0xC3,    /* One-Shot Control */
    kHIDUsage_Csmr_RepeatFromMark    = 0xC4,    /* On/Off Control */
    kHIDUsage_Csmr_ReturnToMark    = 0xC5,    /* One-Shot Control */
    kHIDUsage_Csmr_SearchMarkForward    = 0xC6,    /* One-Shot Control */
    kHIDUsage_Csmr_SearchMarkBackwards    = 0xC7,    /* One-Shot Control */
    kHIDUsage_Csmr_CounterReset    = 0xC8,    /* One-Shot Control */
    kHIDUsage_Csmr_ShowCounter    = 0xC9,    /* One-Shot Control */
    kHIDUsage_Csmr_TrackingIncrement    = 0xCA,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrackingDecrement    = 0xCB,    /* Re-Trigger Control */
    kHIDUsage_Csmr_StopOrEject    = 0xCC,    /* One-Shot Control */
    kHIDUsage_Csmr_PlayOrPause    = 0xCD,    /* One-Shot Control */
    kHIDUsage_Csmr_PlayOrSkip    = 0xCE,    /* One-Shot Control */
    kHIDUsage_Csmr_VoiceCommand    = 0xCF, /* One-Shot Control */
    /* 0xCF - 0xDF Reserved */
    kHIDUsage_Csmr_Volume    = 0xE0,    /* Linear Control */
    kHIDUsage_Csmr_Balance    = 0xE1,    /* Linear Control */
    kHIDUsage_Csmr_Mute    = 0xE2,    /* On/Off Control */
    kHIDUsage_Csmr_Bass    = 0xE3,    /* Linear Control */
    kHIDUsage_Csmr_Treble    = 0xE4,    /* Linear Control */
    kHIDUsage_Csmr_BassBoost    = 0xE5,    /* On/Off Control */
    kHIDUsage_Csmr_SurroundMode    = 0xE6,    /* One-Shot Control */
    kHIDUsage_Csmr_Loudness    = 0xE7,    /* On/Off Control */
    kHIDUsage_Csmr_MPX    = 0xE8,    /* On/Off Control */
    kHIDUsage_Csmr_VolumeIncrement    = 0xE9,    /* Re-Trigger Control */
    kHIDUsage_Csmr_VolumeDecrement    = 0xEA,    /* Re-Trigger Control */
    /* 0xEB - 0xEF Reserved */
    kHIDUsage_Csmr_Speed    = 0xF0,    /* Selector */
    kHIDUsage_Csmr_PlaybackSpeed    = 0xF1,    /* Named Array */
    kHIDUsage_Csmr_StandardPlay    = 0xF2,    /* Selector */
    kHIDUsage_Csmr_LongPlay    = 0xF3,    /* Selector */
    kHIDUsage_Csmr_ExtendedPlay    = 0xF4,    /* Selector */
    kHIDUsage_Csmr_Slow    = 0xF5,    /* One-Shot Control */
    /* 0xF6 - 0xFF Reserved */
    kHIDUsage_Csmr_FanEnable    = 0x100,    /* On/Off Control */
    kHIDUsage_Csmr_FanSpeed    = 0x101,    /* Linear Control */
    kHIDUsage_Csmr_LightEnable    = 0x102,    /* On/Off Control */
    kHIDUsage_Csmr_LightIlluminationLevel    = 0x103,    /* Linear Control */
    kHIDUsage_Csmr_ClimateControlEnable    = 0x104,    /* On/Off Control */
    kHIDUsage_Csmr_RoomTemperature    = 0x105,    /* Linear Control */
    kHIDUsage_Csmr_SecurityEnable    = 0x106,    /* On/Off Control */
    kHIDUsage_Csmr_FireAlarm    = 0x107,    /* One-Shot Control */
    kHIDUsage_Csmr_PoliceAlarm    = 0x108,    /* One-Shot Control */
    kHIDUsage_Csmr_Proximity    = 0x109,    /* Linear Control */
    kHIDUsage_Csmr_Motion    = 0x10A,    /* One-Shot Control */
    kHIDUsage_Csmr_DuressAlarm    = 0x10B,    /* One-Shot Control */
    kHIDUsage_Csmr_HoldupAlarm    = 0x10C,    /* One-Shot Control */
    kHIDUsage_Csmr_MedicalAlarm    = 0x10D,    /* One-Shot Control */
    /* 0x10E - 0x14F Reserved */
    kHIDUsage_Csmr_BalanceRight    = 0x150,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BalanceLeft    = 0x151,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BassIncrement    = 0x152,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BassDecrement    = 0x153,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrebleIncrement    = 0x154,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrebleDecrement    = 0x155,    /* Re-Trigger Control */
    /* 0x156 - 0x15F Reserved */
    kHIDUsage_Csmr_SpeakerSystem    = 0x160,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelLeft    = 0x161,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelRight    = 0x162,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelCenter    = 0x163,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelFront    = 0x164,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelCenterFront    = 0x165,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelSide    = 0x166,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelSurround    = 0x167,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelLowFrequencyEnhancement    = 0x168,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelTop    = 0x169,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelUnknown    = 0x16A,    /* Logical Collection */
    /* 0x16B - 0x16F Reserved */
    kHIDUsage_Csmr_SubChannel    = 0x170,    /* Linear Control */
    kHIDUsage_Csmr_SubChannelIncrement    = 0x171,    /* One-Shot Control */
    kHIDUsage_Csmr_SubChannelDecrement    = 0x172,    /* One-Shot Control */
    kHIDUsage_Csmr_AlternateAudioIncrement    = 0x173,    /* One-Shot Control */
    kHIDUsage_Csmr_AlternateAudioDecrement    = 0x174,    /* One-Shot Control */
    /* 0x175 - 0x17F Reserved */
    kHIDUsage_Csmr_ApplicationLaunchButtons    = 0x180,    /* Named Array */
    kHIDUsage_Csmr_ALLaunchButtonConfigurationTool    = 0x181,    /* Selector */
    kHIDUsage_Csmr_ALProgrammableButtonConfiguration    = 0x182,    /* Selector */
    kHIDUsage_Csmr_ALConsumerControlConfiguration    = 0x183,    /* Selector */
    kHIDUsage_Csmr_ALWordProcessor    = 0x184,    /* Selector */
    kHIDUsage_Csmr_ALTextEditor    = 0x185,    /* Selector */
    kHIDUsage_Csmr_ALSpreadsheet    = 0x186,    /* Selector */
    kHIDUsage_Csmr_ALGraphicsEditor    = 0x187,    /* Selector */
    kHIDUsage_Csmr_ALPresentationApp    = 0x188,    /* Selector */
    kHIDUsage_Csmr_ALDatabaseApp    = 0x189,    /* Selector */
    kHIDUsage_Csmr_ALEmailReader    = 0x18A,    /* Selector */
    kHIDUsage_Csmr_ALNewsreader    = 0x18B,    /* Selector */
    kHIDUsage_Csmr_ALVoicemail    = 0x18C,    /* Selector */
    kHIDUsage_Csmr_ALContactsOrAddressBook    = 0x18D,    /* Selector */
    kHIDUsage_Csmr_ALCalendarOrSchedule    = 0x18E,    /* Selector */
    kHIDUsage_Csmr_ALTaskOrProjectManager    = 0x18F,    /* Selector */
    kHIDUsage_Csmr_ALLogOrJournalOrTimecard    = 0x190,    /* Selector */
    kHIDUsage_Csmr_ALCheckbookOrFinance    = 0x191,    /* Selector */
    kHIDUsage_Csmr_ALCalculator    = 0x192,    /* Selector */
    kHIDUsage_Csmr_ALAOrVCaptureOrPlayback    = 0x193,    /* Selector */
    kHIDUsage_Csmr_ALLocalMachineBrowser    = 0x194,    /* Selector */
    kHIDUsage_Csmr_ALLANOrWANBrowser    = 0x195,    /* Selector */
    kHIDUsage_Csmr_ALInternetBrowser    = 0x196,    /* Selector */
    kHIDUsage_Csmr_ALRemoteNetworkingOrISPConnect    = 0x197,    /* Selector */
    kHIDUsage_Csmr_ALNetworkConference    = 0x198,    /* Selector */
    kHIDUsage_Csmr_ALNetworkChat    = 0x199,    /* Selector */
    kHIDUsage_Csmr_ALTelephonyOrDialer    = 0x19A,    /* Selector */
    kHIDUsage_Csmr_ALLogon    = 0x19B,    /* Selector */
    kHIDUsage_Csmr_ALLogoff    = 0x19C,    /* Selector */
    kHIDUsage_Csmr_ALLogonOrLogoff    = 0x19D,    /* Selector */
    kHIDUsage_Csmr_ALTerminalLockOrScreensaver    = 0x19E,    /* Selector */
    kHIDUsage_Csmr_ALControlPanel    = 0x19F,    /* Selector */
    kHIDUsage_Csmr_ALCommandLineProcessorOrRun    = 0x1A0,    /* Selector */
    kHIDUsage_Csmr_ALProcessOrTaskManager    = 0x1A1,    /* Selector */
    kHIDUsage_Csmr_AL    = 0x1A2,    /* Selector */
    kHIDUsage_Csmr_ALNextTaskOrApplication    = 0x1A3,    /* Selector */
    kHIDUsage_Csmr_ALPreviousTaskOrApplication    = 0x1A4,    /* Selector */
    kHIDUsage_Csmr_ALPreemptiveHaltTaskOrApplication    = 0x1A5,    /* Selector */
    kHIDUsage_Csmr_ALIntegratedHelpCenter   = 0x1A6, /* Selector */
    kHIDUsage_Csmr_ALDocuments   = 0x1A7, /* Selector */
    kHIDUsage_Csmr_ALThesaurus   = 0x1A8, /* Selector */
    kHIDUsage_Csmr_ALDictionary   = 0x1A9, /* Selector */
    kHIDUsage_Csmr_ALDesktop   = 0x1AA, /* Selector */
    kHIDUsage_Csmr_ALSpellCheck   = 0x1AB, /* Selector */
    kHIDUsage_Csmr_ALGrammerCheck   = 0x1AC, /* Selector */
    kHIDUsage_Csmr_ALWirelessStatus   = 0x1AD, /* Selector */
    kHIDUsage_Csmr_ALKeyboardLayout   = 0x1AE, /* Selector */
    kHIDUsage_Csmr_ALVirusProtection   = 0x1AF, /* Selector */
    kHIDUsage_Csmr_ALEncryption   = 0x1B0, /* Selector */
    kHIDUsage_Csmr_ALScreenSaver   = 0x1B1, /* Selector */
    kHIDUsage_Csmr_ALAlarms   = 0x1B2, /* Selector */
    kHIDUsage_Csmr_ALClock   = 0x1B3, /* Selector */
    kHIDUsage_Csmr_ALFileBrowser   = 0x1B4, /* Selector */
    kHIDUsage_Csmr_ALPowerStatus   = 0x1B5, /* Selector */
    kHIDUsage_Csmr_ALImageBrowser   = 0x1B6, /* Selector */
    kHIDUsage_Csmr_ALAudioBrowser   = 0x1B7, /* Selector */
    kHIDUsage_Csmr_ALMovieBrowser   = 0x1B8, /* Selector */
    kHIDUsage_Csmr_ALDigitalRightsManager   = 0x1B9, /* Selector */
    kHIDUsage_Csmr_ALDigitalWallet   = 0x1BA, /* Selector */
    /* 0x1BB Reserved */
    kHIDUsage_Csmr_ALInstantMessaging   = 0x1BC, /* Selector */
    kHIDUsage_Csmr_ALOEMFeatureBrowser  = 0x1BD, /* Selector */
    kHIDUsage_Csmr_ALOEMHelp    = 0x1BE, /* Selector */
    kHIDUsage_Csmr_ALOnlineCommunity    = 0x1BF, /* Selector */
    kHIDUsage_Csmr_ALEntertainmentContentBrowser    = 0x1C0, /* Selector */
    kHIDUsage_Csmr_ALOnlineShoppingBrowswer = 0x1C1, /* Selector */
    kHIDUsage_Csmr_ALSmartCardInformationOrHelp = 0x1C2, /* Selector */
    kHIDUsage_Csmr_ALMarketMonitorOrFinanceBrowser  = 0x1C3, /* Selector */
    kHIDUsage_Csmr_ALCustomizedCorporateNewsBrowser = 0x1C4, /* Selector */
    kHIDUsage_Csmr_ALOnlineActivityBrowswer= 0x1C5, /* Selector */
    kHIDUsage_Csmr_ALResearchOrSearchBrowswer   = 0x1C6, /* Selector */
    kHIDUsage_Csmr_ALAudioPlayer= 0x1C7, /* Selector */
    /* 0x1C8 - 0x1FF Reserved */
    kHIDUsage_Csmr_GenericGUIApplicationControls    = 0x200,    /* Named Array */
    kHIDUsage_Csmr_ACNew    = 0x201,    /* Selector */
    kHIDUsage_Csmr_ACOpen    = 0x202,    /* Selector */
    kHIDUsage_Csmr_ACClose    = 0x203,    /* Selector */
    kHIDUsage_Csmr_ACExit    = 0x204,    /* Selector */
    kHIDUsage_Csmr_ACMaximize    = 0x205,    /* Selector */
    kHIDUsage_Csmr_ACMinimize    = 0x206,    /* Selector */
    kHIDUsage_Csmr_ACSave    = 0x207,    /* Selector */
    kHIDUsage_Csmr_ACPrint    = 0x208,    /* Selector */
    kHIDUsage_Csmr_ACProperties    = 0x209,    /* Selector */
    kHIDUsage_Csmr_ACUndo    = 0x21A,    /* Selector */
    kHIDUsage_Csmr_ACCopy    = 0x21B,    /* Selector */
    kHIDUsage_Csmr_ACCut    = 0x21C,    /* Selector */
    kHIDUsage_Csmr_ACPaste    = 0x21D,    /* Selector */
    kHIDUsage_Csmr_AC    = 0x21E,    /* Selector */
    kHIDUsage_Csmr_ACFind    = 0x21F,    /* Selector */
    kHIDUsage_Csmr_ACFindandReplace    = 0x220,    /* Selector */
    kHIDUsage_Csmr_ACSearch    = 0x221,    /* Selector */
    kHIDUsage_Csmr_ACGoTo    = 0x222,    /* Selector */
    kHIDUsage_Csmr_ACHome    = 0x223,    /* Selector */
    kHIDUsage_Csmr_ACBack    = 0x224,    /* Selector */
    kHIDUsage_Csmr_ACForward    = 0x225,    /* Selector */
    kHIDUsage_Csmr_ACStop    = 0x226,    /* Selector */
    kHIDUsage_Csmr_ACRefresh    = 0x227,    /* Selector */
    kHIDUsage_Csmr_ACPreviousLink    = 0x228,    /* Selector */
    kHIDUsage_Csmr_ACNextLink    = 0x229,    /* Selector */
    kHIDUsage_Csmr_ACBookmarks    = 0x22A,    /* Selector */
    kHIDUsage_Csmr_ACHistory    = 0x22B,    /* Selector */
    kHIDUsage_Csmr_ACSubscriptions    = 0x22C,    /* Selector */
    kHIDUsage_Csmr_ACZoomIn    = 0x22D,    /* Selector */
    kHIDUsage_Csmr_ACZoomOut    = 0x22E,    /* Selector */
    kHIDUsage_Csmr_ACZoom    = 0x22F,    /* Selector */
    kHIDUsage_Csmr_ACFullScreenView    = 0x230,    /* Selector */
    kHIDUsage_Csmr_ACNormalView    = 0x231,    /* Selector */
    kHIDUsage_Csmr_ACViewToggle    = 0x232,    /* Selector */
    kHIDUsage_Csmr_ACScrollUp    = 0x233,    /* Selector */
    kHIDUsage_Csmr_ACScrollDown    = 0x234,    /* Selector */
    kHIDUsage_Csmr_ACScroll    = 0x235,    /* Selector */
    kHIDUsage_Csmr_ACPanLeft    = 0x236,    /* Selector */
    kHIDUsage_Csmr_ACPanRight    = 0x237,    /* Selector */
    kHIDUsage_Csmr_ACPan    = 0x238,    /* Selector */
    kHIDUsage_Csmr_ACNewWindow    = 0x239,    /* Selector */
    kHIDUsage_Csmr_ACTileHorizontally    = 0x23A,    /* Selector */
    kHIDUsage_Csmr_ACTileVertically    = 0x23B,    /* Selector */
    kHIDUsage_Csmr_ACFormat    = 0x23C,    /* Selector */
    kHIDUsage_Csmr_ACEdit   = 0x23D,    /* Selector */
    kHIDUsage_Csmr_ACBold   = 0x23E,    /* Selector */
    kHIDUsage_Csmr_ACItalics    = 0x23F,    /* Selector */
    kHIDUsage_Csmr_ACUnderline  = 0x240,    /* Selector */
    kHIDUsage_Csmr_ACStrikethrough  = 0x241,    /* Selector */
    kHIDUsage_Csmr_ACSubscript  = 0x242,    /* Selector */
    kHIDUsage_Csmr_ACSuperscript    = 0x243,    /* Selector */
    kHIDUsage_Csmr_ACAllCaps    = 0x244,    /* Selector */
    kHIDUsage_Csmr_ACRotate = 0x245,    /* Selector */
    kHIDUsage_Csmr_ACResize = 0x246,    /* Selector */
    kHIDUsage_Csmr_ACFlipHorizontal = 0x247,    /* Selector */
    kHIDUsage_Csmr_ACFlipVertical   = 0x248,    /* Selector */
    kHIDUsage_Csmr_ACMirrorHorizontal   = 0x249,    /* Selector */
    kHIDUsage_Csmr_ACMirrorVertical = 0x24A,    /* Selector */
    kHIDUsage_Csmr_ACFontSelect = 0x24B,    /* Selector */
    kHIDUsage_Csmr_ACFontColor  = 0x24C,    /* Selector */
    kHIDUsage_Csmr_ACFontSize   = 0x24D,    /* Selector */
    kHIDUsage_Csmr_ACJustifyLeft    = 0x24E,    /* Selector */
    kHIDUsage_Csmr_ACJustifyCenterH = 0x24F,    /* Selector */
    kHIDUsage_Csmr_ACJustifyRight   = 0x250,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBlockH  = 0x251,    /* Selector */
    kHIDUsage_Csmr_ACJustifyTop     = 0x252,    /* Selector */
    kHIDUsage_Csmr_ACJustifyCenterV = 0x253,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBottom  = 0x254,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBlockV  = 0x255,    /* Selector */
    kHIDUsage_Csmr_ACIndentyDecrease    = 0x256,    /* Selector */
    kHIDUsage_Csmr_ACIndentyIncrease    = 0x257,    /* Selector */
    kHIDUsage_Csmr_ACNumberedList   = 0x258,    /* Selector */
    kHIDUsage_Csmr_ACRestartNumbering   = 0x259,    /* Selector */
    kHIDUsage_Csmr_ACBulletedList   = 0x25A,    /* Selector */
    kHIDUsage_Csmr_ACPromote    = 0x25B,    /* Selector */
    kHIDUsage_Csmr_ACDemote = 0x25C,    /* Selector */
    kHIDUsage_Csmr_ACYes    = 0x25D,    /* Selector */
    kHIDUsage_Csmr_ACNo = 0x25E,    /* Selector */
    kHIDUsage_Csmr_ACCancel = 0x25F,    /* Selector */
    kHIDUsage_Csmr_ACCatalog    = 0x260,    /* Selector */
    kHIDUsage_Csmr_ACBuyOrCheckout  = 0x261,    /* Selector */
    kHIDUsage_Csmr_ACAddToCart  = 0x262,    /* Selector */
    kHIDUsage_Csmr_ACExpand = 0x263,    /* Selector */
    kHIDUsage_Csmr_ACExpandAll  = 0x264,    /* Selector */
    kHIDUsage_Csmr_ACCollapse   = 0x265,    /* Selector */
    kHIDUsage_Csmr_ACCollapseAll    = 0x266,    /* Selector */
    kHIDUsage_Csmr_ACPrintPreview   = 0x267,    /* Selector */
    kHIDUsage_Csmr_ACPasteSpecial   = 0x268,    /* Selector */
    kHIDUsage_Csmr_ACInsertMode = 0x269,    /* Selector */
    kHIDUsage_Csmr_ACDelete = 0x26A,    /* Selector */
    kHIDUsage_Csmr_ACLock   = 0x26B,    /* Selector */
    kHIDUsage_Csmr_ACUnlock = 0x26C,    /* Selector */
    kHIDUsage_Csmr_ACProtect    = 0x26D,    /* Selector */
    kHIDUsage_Csmr_ACUnprotect  = 0x26E,    /* Selector */
    kHIDUsage_Csmr_ACAttachComment  = 0x26F,    /* Selector */
    kHIDUsage_Csmr_ACDetachComment  = 0x270,    /* Selector */
    kHIDUsage_Csmr_ACViewComment    = 0x271,    /* Selector */
    kHIDUsage_Csmr_ACSelectWord = 0x272,    /* Selector */
    kHIDUsage_Csmr_ACSelectSentence = 0x273,    /* Selector */
    kHIDUsage_Csmr_ACSelectParagraph    = 0x274,    /* Selector */
    kHIDUsage_Csmr_ACSelectColumn   = 0x275,    /* Selector */
    kHIDUsage_Csmr_ACSelectRow  = 0x276,    /* Selector */
    kHIDUsage_Csmr_ACSelectTable    = 0x277,    /* Selector */
    kHIDUsage_Csmr_ACSelectObject   = 0x278,    /* Selector */
    kHIDUsage_Csmr_ACRedoOrRepeat   = 0x279,    /* Selector */
    kHIDUsage_Csmr_ACSort   = 0x27A,    /* Selector */
    kHIDUsage_Csmr_ACSortAscending  = 0x27B,    /* Selector */
    kHIDUsage_Csmr_ACSortDescending = 0x27C,    /* Selector */
    kHIDUsage_Csmr_ACFilter = 0x27D,    /* Selector */
    kHIDUsage_Csmr_ACSetClock   = 0x27E,    /* Selector */
    kHIDUsage_Csmr_ACViewClock  = 0x27F,    /* Selector */
    kHIDUsage_Csmr_ACSelectTimeZone = 0x280,    /* Selector */
    kHIDUsage_Csmr_ACEditTimeZones  = 0x281,    /* Selector */
    kHIDUsage_Csmr_ACSetAlarm   = 0x282,    /* Selector */
    kHIDUsage_Csmr_ACClearAlarm = 0x283,    /* Selector */
    kHIDUsage_Csmr_ACSnoozeAlarm    = 0x284,    /* Selector */
    kHIDUsage_Csmr_ACResetAlarm = 0x285,    /* Selector */
    kHIDUsage_Csmr_ACSynchronize    = 0x286,    /* Selector */
    kHIDUsage_Csmr_ACSendOrReceive  = 0x287,    /* Selector */
    kHIDUsage_Csmr_ACSendTo = 0x288,    /* Selector */
    kHIDUsage_Csmr_ACReply  = 0x289,    /* Selector */
    kHIDUsage_Csmr_ACReplyAll   = 0x28A,    /* Selector */
    kHIDUsage_Csmr_ACForwardMessage = 0x28B,    /* Selector */
    kHIDUsage_Csmr_ACSend   = 0x28C,    /* Selector */
    kHIDUsage_Csmr_ACAttachFile = 0x28D,    /* Selector */
    kHIDUsage_Csmr_ACUpload = 0x28E,    /* Selector */
    kHIDUsage_Csmr_ACDownload   = 0x28F,    /* Selector */
    kHIDUsage_Csmr_ACSetBorders = 0x290,    /* Selector */
    kHIDUsage_Csmr_ACInsertRow  = 0x291,    /* Selector */
    kHIDUsage_Csmr_ACInsertColumn   = 0x292,    /* Selector */
    kHIDUsage_Csmr_ACInsertFile = 0x293,    /* Selector */
    kHIDUsage_Csmr_ACInsertPicture  = 0x294,    /* Selector */
    kHIDUsage_Csmr_ACInsertObject   = 0x295,    /* Selector */
    kHIDUsage_Csmr_ACInsertSymbol   = 0x296,    /* Selector */
    kHIDUsage_Csmr_ACSaveAndClose   = 0x297,    /* Selector */
    kHIDUsage_Csmr_ACRename = 0x298,    /* Selector */
    kHIDUsage_Csmr_ACMerge  = 0x299,    /* Selector */
    kHIDUsage_Csmr_ACSplit  = 0x29A,    /* Selector */
    kHIDUsage_Csmr_ACDistributeH    = 0x29B,    /* Selector */
    kHIDUsage_Csmr_ACDistributeV    = 0x29C,    /* Selector */
    /* 0x29D - 0xFFFF Reserved */
    kHIDUsage_Csmr_Reserved = 0xFFFF
};

/* Digitizer Page (0x0D) */
/* This section provides detailed descriptions of the usages employed by Digitizer Devices. */
enum
{
    kHIDUsage_Dig_Digitizer                         = 0x01,     /* Application Collection */
    kHIDUsage_Dig_Pen                               = 0x02,     /* Application Collection */
    kHIDUsage_Dig_LightPen                          = 0x03,     /* Application Collection */
    kHIDUsage_Dig_TouchScreen                       = 0x04,     /* Application Collection */
    kHIDUsage_Dig_TouchPad                          = 0x05,     /* Application Collection */
    kHIDUsage_Dig_WhiteBoard                        = 0x06,     /* Application Collection */
    kHIDUsage_Dig_CoordinateMeasuringMachine        = 0x07,     /* Application Collection */
    kHIDUsage_Dig_3DDigitizer                       = 0x08,     /* Application Collection */
    kHIDUsage_Dig_StereoPlotter                     = 0x09,     /* Application Collection */
    kHIDUsage_Dig_ArticulatedArm                    = 0x0A,     /* Application Collection */
    kHIDUsage_Dig_Armature                          = 0x0B,     /* Application Collection */
    kHIDUsage_Dig_MultiplePointDigitizer            = 0x0C,     /* Application Collection */
    kHIDUsage_Dig_FreeSpaceWand                     = 0x0D,     /* Application Collection */
    kHIDUsage_Dig_DeviceConfiguration               = 0x0E,     /* Application Collection */
    /* 0x0F - 0x1F Reserved */
    kHIDUsage_Dig_Stylus                            = 0x20,     /* Logical Collection */
    kHIDUsage_Dig_Puck                              = 0x21,     /* Logical Collection */
    kHIDUsage_Dig_Finger                            = 0x22,     /* Logical Collection */
    kHIDUsage_Dig_DeviceSettings                    = 0x23,     /* Logical Collection */
    kHIDUsage_Dig_GestureCharacter                  = 0x24,     /* Logical Collection */
    /* 0x25 - 0x2F Reserved */
    kHIDUsage_Dig_TipPressure                       = 0x30,     /* Dynamic Value */
    kHIDUsage_Dig_BarrelPressure                    = 0x31,     /* Dynamic Value */
    kHIDUsage_Dig_InRange                           = 0x32,     /* Momentary Control */
    kHIDUsage_Dig_Touch                             = 0x33,     /* Momentary Control */
    kHIDUsage_Dig_Untouch                           = 0x34,     /* One-Shot Control */
    kHIDUsage_Dig_Tap                               = 0x35,     /* One-Shot Control */
    kHIDUsage_Dig_Quality                           = 0x36,     /* Dynamic Value */
    kHIDUsage_Dig_DataValid                         = 0x37,     /* Momentary Control */
    kHIDUsage_Dig_TransducerIndex                   = 0x38,     /* Dynamic Value */
    kHIDUsage_Dig_TabletFunctionKeys                = 0x39,     /* Logical Collection */
    kHIDUsage_Dig_ProgramChangeKeys                 = 0x3A,     /* Logical Collection */
    kHIDUsage_Dig_BatteryStrength                   = 0x3B,     /* Dynamic Value */
    kHIDUsage_Dig_Invert                            = 0x3C,     /* Momentary Control */
    kHIDUsage_Dig_XTilt                             = 0x3D,     /* Dynamic Value */
    kHIDUsage_Dig_YTilt                             = 0x3E,     /* Dynamic Value */
    kHIDUsage_Dig_Azimuth                           = 0x3F,     /* Dynamic Value */
    kHIDUsage_Dig_Altitude                          = 0x40,     /* Dynamic Value */
    kHIDUsage_Dig_Twist                             = 0x41,     /* Dynamic Value */
    kHIDUsage_Dig_TipSwitch                         = 0x42,     /* Momentary Control */
    kHIDUsage_Dig_SecondaryTipSwitch                = 0x43,     /* Momentary Control */
    kHIDUsage_Dig_BarrelSwitch                      = 0x44,     /* Momentary Control */
    kHIDUsage_Dig_Eraser                            = 0x45,     /* Momentary Control */
    kHIDUsage_Dig_TabletPick                        = 0x46,     /* Momentary Control */
    kHIDUsage_Dig_TouchValid                        = 0x47,     /* Momentary Control */
    kHIDUsage_Dig_Width                             = 0x48,     /* Dynamic Value */
    kHIDUsage_Dig_Height                            = 0x49,     /* Dynamic Value */
    /* 0x4A - 0x50 Reserved */
    kHIDUsage_Dig_ContactIdentifier                 = 0x51,     /* Dynamic Value */
    kHIDUsage_Dig_DeviceMode                        = 0x52,     /* Dynamic Value */
    kHIDUsage_Dig_DeviceIdentifier                  = 0x53,     /* Dynamic Value */
    kHIDUsage_Dig_ContactCount                      = 0x54,     /* Dynamic Value */
    kHIDUsage_Dig_ContactCountMaximum               = 0x55,     /* Static Value */
    
    /* 0x56 - 0x5F Reserved */
    kHIDUsage_Dig_GestureCharacterEnable            = 0x60,     /* Dynamic Flag */
    kHIDUsage_Dig_GestureCharacterQuality           = 0x61,     /* Dynamic Value */
    kHIDUsage_Dig_GestureCharacterDataLength        = 0x62,     /* Dynamic Value */
    kHIDUsage_Dig_GestureCharacterData              = 0x63,     /* Buffered Bytes */
    kHIDUsage_Dig_GestureCharacterEncoding          = 0x64,     /* Named Array */
    kHIDUsage_Dig_GestureCharacterEncodingUTF8      = 0x65,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF16LE   = 0x66,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF16BE   = 0x67,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF32LE   = 0x68,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF32BE   = 0x69,     /* Selector */
    
    /* 0x70 - 0xFFFF Reserved */
    kHIDUsage_Dig_Reserved                          = 0xFFFF
};

/* Physical Interface Device Page (0x0F) */
/* This section provides detailed descriptions of the usages employed by Power Devices. */
enum
{
    kHIDUsage_PID_PhysicalInterfaceDevice = 0x01,        /* CA - A collection of PID usages */
    /* 0x02 - 0x1F Reserved */
    kHIDUsage_PID_Normal = 0x20,                        /* DV - A force applied perpendicular to the surface of an object */
    kHIDUsage_PID_SetEffectReport = 0x21,                /* XXX */
    kHIDUsage_PID_EffectBlockIndex = 0x22,                /* XXX */
    kHIDUsage_PID_ParamBlockOffset = 0x23,                /* XXX */
    kHIDUsage_PID_ROM_Flag = 0x24,                        /* XXX */
    kHIDUsage_PID_EffectType = 0x25,                    /* XXX */
    kHIDUsage_PID_ET_ConstantForce = 0x26,                /* XXX */
    kHIDUsage_PID_ET_Ramp = 0x27,                        /* XXX */
    kHIDUsage_PID_ET_CustomForceData = 0x28,            /* XXX */
    /* 0x29 - 0x2F Reserved */
    kHIDUsage_PID_ET_Square = 0x30,                        /* XXX */
    kHIDUsage_PID_ET_Sine = 0x31,                        /* XXX */
    kHIDUsage_PID_ET_Triangle = 0x32,                    /* XXX */
    kHIDUsage_PID_ET_SawtoothUp = 0x33,                    /* XXX */
    kHIDUsage_PID_ET_SawtoothDown = 0x34,                /* XXX */
    /* 0x35 - 0x3F Reserved */
    kHIDUsage_PID_ET_Spring = 0x40,                        /* XXX */
    kHIDUsage_PID_ET_Damper = 0x41,                        /* XXX */
    kHIDUsage_PID_ET_Inertia = 0x42,                    /* XXX */
    kHIDUsage_PID_ET_Friction = 0x43,                    /* XXX */
    /* 0x44 - 0x4F Reserved */
    kHIDUsage_PID_Duration = 0x50,                        /* XXX */
    kHIDUsage_PID_SamplePeriod = 0x51,                    /* XXX */
    kHIDUsage_PID_Gain = 0x52,                            /* XXX */
    kHIDUsage_PID_TriggerButton = 0x53,                    /* XXX */
    kHIDUsage_PID_TriggerRepeatInterval = 0x54,            /* XXX */
    kHIDUsage_PID_AxesEnable = 0x55,                    /* XXX */
    kHIDUsage_PID_DirectionEnable = 0x56,                /* XXX */
    kHIDUsage_PID_Direction = 0x57,                        /* XXX */
    kHIDUsage_PID_TypeSpecificBlockOffset = 0x58,        /* XXX */
    kHIDUsage_PID_BlockType = 0x59,                        /* XXX */
    kHIDUsage_PID_SetEnvelopeReport = 0x5A,                /* XXX */
    kHIDUsage_PID_AttackLevel = 0x5B,                    /* XXX */
    kHIDUsage_PID_AttackTime = 0x5C,                    /* XXX */
    kHIDUsage_PID_FadeLevel = 0x5D,                        /* XXX */
    kHIDUsage_PID_FadeTime = 0x5E,                        /* XXX */
    kHIDUsage_PID_SetConditionReport = 0x5F,            /* XXX */
    
    kHIDUsage_PID_CP_Offset = 0x60,                        /* XXX */
    kHIDUsage_PID_PositiveCoefficient = 0x61,            /* XXX */
    kHIDUsage_PID_NegativeCoefficient = 0x62,            /* XXX */
    kHIDUsage_PID_PositiveSaturation = 0x63,            /* XXX */
    kHIDUsage_PID_NegativeSaturation = 0x64,            /* XXX */
    kHIDUsage_PID_DeadBand = 0x65,                        /* XXX */
    kHIDUsage_PID_DownloadForceSample = 0x66,            /* XXX */
    kHIDUsage_PID_IsochCustomForceEnable = 0x67,        /* XXX */
    kHIDUsage_PID_CustomForceDataReport = 0x68,            /* XXX */
    kHIDUsage_PID_CustomForceData = 0x69,                /* XXX */
    kHIDUsage_PID_CustomForceVendorDefinedData = 0x6A,    /* XXX */
    kHIDUsage_PID_SetCustomForceReport = 0x6B,            /* XXX */
    kHIDUsage_PID_CustomForceDataOffset = 0x6C,            /* XXX */
    kHIDUsage_PID_SampleCount = 0x6D,                    /* XXX */
    kHIDUsage_PID_SetPeriodicReport = 0x6E,                /* XXX */
    kHIDUsage_PID_Offset = 0x6F,                        /* XXX */
    
    kHIDUsage_PID_Magnitude = 0x70,                        /* XXX */
    kHIDUsage_PID_Phase = 0x71,                            /* XXX */
    kHIDUsage_PID_Period = 0x72,                        /* XXX */
    kHIDUsage_PID_SetConstantForceReport = 0x73,        /* XXX */
    kHIDUsage_PID_SetRampForceReport = 0x74,            /* XXX */
    kHIDUsage_PID_RampStart = 0x75,                        /* XXX */
    kHIDUsage_PID_RampEnd = 0x76,                        /* XXX */
    kHIDUsage_PID_EffectOperationReport = 0x77,            /* XXX */
    kHIDUsage_PID_EffectOperation = 0x78,                /* XXX */
    kHIDUsage_PID_OpEffectStart = 0x79,                    /* XXX */
    kHIDUsage_PID_OpEffectStartSolo = 0x7A,                /* XXX */
    kHIDUsage_PID_OpEffectStop = 0x7B,                    /* XXX */
    kHIDUsage_PID_LoopCount = 0x7C,                        /* XXX */
    kHIDUsage_PID_DeviceGainReport = 0x7D,                /* XXX */
    kHIDUsage_PID_DeviceGain = 0x7E,                    /* XXX */
    kHIDUsage_PID_PoolReport = 0x7F,                    /* XXX */
    
    kHIDUsage_PID_RAM_PoolSize = 0x80,                    /* XXX */
    kHIDUsage_PID_ROM_PoolSize = 0x81,                    /* XXX */
    kHIDUsage_PID_ROM_EffectBlockCount = 0x82,            /* XXX */
    kHIDUsage_PID_SimultaneousEffectsMax = 0x83,        /* XXX */
    kHIDUsage_PID_PoolAlignment = 0x84,                    /* XXX */
    kHIDUsage_PID_PoolMoveReport = 0x85,                /* XXX */
    kHIDUsage_PID_MoveSource = 0x86,                    /* XXX */
    kHIDUsage_PID_MoveDestination = 0x87,                /* XXX */
    kHIDUsage_PID_MoveLength = 0x88,                    /* XXX */
    kHIDUsage_PID_BlockLoadReport = 0x89,                /* XXX */
    /* 0x8A Reserved */
    kHIDUsage_PID_BlockLoadStatus = 0x8B,                /* XXX */
    kHIDUsage_PID_BlockLoadSuccess = 0x8C,                /* XXX */
    kHIDUsage_PID_BlockLoadFull = 0x8D,                    /* XXX */
    kHIDUsage_PID_BlockLoadError = 0x8E,                /* XXX */
    kHIDUsage_PID_BlockHandle = 0x8F,                    /* XXX */
    
    kHIDUsage_PID_BlockFreeReport = 0x90,                /* XXX */
    kHIDUsage_PID_TypeSpecificBlockHandle = 0x91,        /* XXX */
    kHIDUsage_PID_StateReport = 0x92,                    /* XXX */
    /* 0x93 Reserved */
    kHIDUsage_PID_EffectPlaying = 0x94,                    /* XXX */
    kHIDUsage_PID_DeviceControlReport = 0x95,            /* XXX */
    kHIDUsage_PID_DeviceControl = 0x96,                    /* XXX */
    kHIDUsage_PID_DC_EnableActuators = 0x97,            /* XXX */
    kHIDUsage_PID_DC_DisableActuators = 0x98,            /* XXX */
    kHIDUsage_PID_DC_StopAllEffects = 0x99,                /* XXX */
    kHIDUsage_PID_DC_DeviceReset = 0x9A,                /* XXX */
    kHIDUsage_PID_DC_DevicePause = 0x9B,                /* XXX */
    kHIDUsage_PID_DC_DeviceContinue = 0x9C,                /* XXX */
    /* 0x9d - 0x9E Reserved */
    kHIDUsage_PID_DevicePaused = 0x9F,                    /* XXX */
    
    kHIDUsage_PID_ActuatorsEnabled = 0xA0,                /* XXX */
    /* 0xA1 - 0xA3 Reserved */
    kHIDUsage_PID_SafetySwitch = 0xA4,                    /* XXX */
    kHIDUsage_PID_ActuatorOverrideSwitch = 0xA5,        /* XXX */
    kHIDUsage_PID_ActuatorPower = 0xA6,                    /* XXX */
    kHIDUsage_PID_StartDelay = 0xA7,                    /* XXX */
    kHIDUsage_PID_ParameterBlockSize = 0xA8,            /* XXX */
    kHIDUsage_PID_DeviceManagedPool = 0xA9,                /* XXX */
    kHIDUsage_PID_SharedParameterBlocks = 0xAA,            /* XXX */
    kHIDUsage_PID_CreateNewEffectReport = 0xAB,            /* XXX */
    kHIDUsage_PID_RAM_PoolAvailable = 0xAC,                /* XXX */
    /* 0xAD - 0xFFFF Reserved */
    kHIDUsage_PID_Reserved = 0xFFFF
};

/* AlphanumericDisplay Page (0x14) */
/* The Alphanumeric Display page is intended for use by simple alphanumeric displays that are used on consumer devices. */
enum
{
    kHIDUsage_AD_AlphanumericDisplay    = 0x01,    /* Application Collection */
    /* 0x02 - 0x1F Reserved */
    kHIDUsage_AD_DisplayAttributesReport    = 0x20,    /* Logical Collection */
    kHIDUsage_AD_ASCIICharacterSet    = 0x21,    /* Static Flag */
    kHIDUsage_AD_DataReadBack    = 0x22,    /* Static Flag */
    kHIDUsage_AD_FontReadBack    = 0x23,    /* Static Flag */
    kHIDUsage_AD_DisplayControlReport    = 0x24,    /* Logical Collection */
    kHIDUsage_AD_ClearDisplay    = 0x25,    /* Dynamic Flag */
    kHIDUsage_AD_DisplayEnable    = 0x26,    /* Dynamic Flag */
    kHIDUsage_AD_ScreenSaverDelay    = 0x27,    /* Static Value */
    kHIDUsage_AD_ScreenSaverEnable    = 0x28,    /* Dynamic Flag */
    kHIDUsage_AD_VerticalScroll    = 0x29,    /* Static Flag */
    kHIDUsage_AD_HorizontalScroll    = 0x2A,    /* Static Flag */
    kHIDUsage_AD_CharacterReport    = 0x2B,    /* Logical Collection */
    kHIDUsage_AD_DisplayData    = 0x2C,    /* Dynamic Value */
    kHIDUsage_AD_DisplayStatus    = 0x2D,    /* Logical Collection */
    kHIDUsage_AD_StatNotReady    = 0x2E,    /* Selector */
    kHIDUsage_AD_StatReady    = 0x2F,    /* Selector */
    kHIDUsage_AD_ErrNotaloadablecharacter    = 0x30,    /* Selector */
    kHIDUsage_AD_ErrFontdatacannotberead    = 0x31,    /* Selector */
    kHIDUsage_AD_CursorPositionReport    = 0x32,    /* Logical Collection */
    kHIDUsage_AD_Row    = 0x33,    /* Dynamic Value */
    kHIDUsage_AD_Column    = 0x34,    /* Dynamic Value */
    kHIDUsage_AD_Rows    = 0x35,    /* Static Value */
    kHIDUsage_AD_Columns    = 0x36,    /* Static Value */
    kHIDUsage_AD_CursorPixelPositioning    = 0x37,    /* Static Flag */
    kHIDUsage_AD_CursorMode    = 0x38,    /* Dynamic Flag */
    kHIDUsage_AD_CursorEnable    = 0x39,    /* Dynamic Flag */
    kHIDUsage_AD_CursorBlink    = 0x3A,    /* Dynamic Flag */
    kHIDUsage_AD_FontReport    = 0x3B,    /* Logical Collection */
    kHIDUsage_AD_FontData    = 0x3C,    /* Buffered Byte */
    kHIDUsage_AD_CharacterWidth    = 0x3D,    /* Static Value */
    kHIDUsage_AD_CharacterHeight    = 0x3E,    /* Static Value */
    kHIDUsage_AD_CharacterSpacingHorizontal    = 0x3F,    /* Static Value */
    kHIDUsage_AD_CharacterSpacingVertical    = 0x40,    /* Static Value */
    kHIDUsage_AD_UnicodeCharacterSet    = 0x41,    /* Static Flag */
    /* 0x42 - 0xFFFF Reserved */
    kHIDUsage_AD_Reserved = 0xFFFF
};

/* Sensor Page (0x14) */
/* The Sensor page is intended for use by devices that capture biometric, electrical, environmental, light, location, mechanical, motion, orientation, scanner, etc events. */
enum
{
    kHIDUsage_Snsr_Undefined                            = 0x00,
    kHIDUsage_Snsr_Sensor                               = 0x01,     /* Application/Physical Collection */
    /* 0x02 - 0x0F Reserved */
    kHIDUsage_Snsr_Biometric                            = 0x10,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanPresence              = 0x11,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanProximity             = 0x12,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanTouch                 = 0x13,     /* Application/Physical Collection */
    /* 0x14 - 0x1F Reserved */
    kHIDUsage_Snsr_Electrical                           = 0x20,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Capacitance               = 0x21,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Current                   = 0x22,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Power                     = 0x23,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Inductance                = 0x24,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Resistance                = 0x25,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Voltage                   = 0x26,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Potentiometer             = 0x27,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Frequency                 = 0x28,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Period                    = 0x29,     /* Application/Physical Collection */
    /* 0x2A - 0x2F Reserved */
    kHIDUsage_Snsr_Environmental                        = 0x30,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_AtmosphericPressure    = 0x31,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_Humidity               = 0x32,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_Temperature            = 0x33,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_WindDirection          = 0x34,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_WindSpeed              = 0x35,     /* Application/Physical Collection */
    /* 0x36 - 0x3F Reserved */
    kHIDUsage_Snsr_Light                                = 0x40,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Light_AmbientLight                   = 0x41,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Light_ConsumerInfrared               = 0x42,     /* Application/Physical Collection */
    /* 0x43 - 0x4F Reserved */
    kHIDUsage_Snsr_Location                             = 0x50,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Broadcast                   = 0x51,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_DeadReckoning               = 0x52,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_GPS                         = 0x53,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Lookup                      = 0x54,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Other                       = 0x55,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Static                      = 0x56,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Triangulation               = 0x57,     /* Application/Physical Collection */
    /* 0x58 - 0x5F Reserved */
    kHIDUsage_Snsr_Mechanical                           = 0x60,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_BooleanSwitch             = 0x61,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_BooleanSwitchArray        = 0x62,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_MultivalueSwitch          = 0x63,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Force                     = 0x64,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Pressure                  = 0x65,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Strain                    = 0x66,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Weight                    = 0x67,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_HapticVibrator            = 0x68,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_HallEffectSwitch          = 0x69,     /* Application/Physical Collection */
    /* 0x6A - 0x6F Reserved */
    kHIDUsage_Snsr_Motion                               = 0x70,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer1D               = 0x71,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer2D               = 0x72,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer3D               = 0x73,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer1D                   = 0x74,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer2D                   = 0x75,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer3D                   = 0x76,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_MotionDetector                = 0x77,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Speedometer                   = 0x78,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer                 = 0x79,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer                     = 0x7A,     /* Application/Physical Collection */
    /* 0x7B - 0x7F Reserved */
    kHIDUsage_Snsr_Orientation                          = 0x80,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass1D                = 0x81,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass2D                = 0x82,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass3D                = 0x83,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer1D           = 0x84,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer2D           = 0x85,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer3D           = 0x86,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance1D               = 0x87,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance2D               = 0x88,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance3D               = 0x89,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_DeviceOrientation        = 0x8A,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_CompassD                 = 0x8B,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_InclinometerD            = 0x8C,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_DistanceD                = 0x8D,     /* Application/Physical Collection */
    /* 0x8E - 0x8F Reserved */
    kHIDUsage_Snsr_Scanner                              = 0x90,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_Barcode                      = 0x91,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_RFID                         = 0x92,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_NFC                          = 0x93,     /* Application/Physical Collection */
    /* 0x94 - 0x9F Reserved */
    kHIDUsage_Snsr_Time                                 = 0xA0,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Time_AlarmTimer                      = 0xA1,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Time_RealTimeClock                   = 0xA2,     /* Application/Physical Collection */
    /* 0xA3 - 0xDF Reserved */
    kHIDUsage_Snsr_Other                                = 0xE0,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_Custom                         = 0xE1,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_Generic                        = 0xE2,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_GenericEnumerator              = 0xE3,     /* Application/Physical Collection */
    /* 0xE4 - 0xEF Reserved */
    /* 0xF0 - 0xFF Vendor Reserved */
    
    /* Common Sensor Type Data Fields */

    /* Usage Switches used in conjunction with other Data Usages. The value of the modifier is OR-ed in to the upper nibble of the 16bit Data Usage. */
    kHIDUsage_Snsr_Modifier_None                                = 0x0,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityAbsolute           = 0x1,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Max                                 = 0x2,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Min                                 = 0x3,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Accuracy                            = 0x4,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Resolution                          = 0x5,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ThresholdHigh                       = 0x6,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ThresholdLow                        = 0x7,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_CalibrationOffset                   = 0x8,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_CalibrationMultiplier               = 0x9,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ReportInterval                      = 0xA,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_FrequencyMax                        = 0xB,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_PeriodMax                           = 0xC,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRange       = 0xD,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRelative    = 0xE,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_VendorDefined                       = 0xF,      /* Data Field Usage Switch */

    /* Event Usages */
    kHIDUsage_Snsr_Event                                        = 0x0200,
    kHIDUsage_Snsr_Event_SensorState                            = 0x0201,
    kHIDUsage_Snsr_Event_SensorEvent                            = 0x0202,
    /* 0x0203 - 0x02FF Event Reserved */
    
    kHIDUsage_Snsr_Event_SensorState_Undefined                  = 0x0800,
    kHIDUsage_Snsr_Event_SensorState_Ready                      = 0x0801,
    kHIDUsage_Snsr_Event_SensorState_NotAvailable               = 0x0802,
    kHIDUsage_Snsr_Event_SensorState_NoData                     = 0x0803,
    kHIDUsage_Snsr_Event_SensorState_Initializing               = 0x0804,
    kHIDUsage_Snsr_Event_SensorState_AccessDenied               = 0x0805,
    kHIDUsage_Snsr_Event_SensorState_Error                      = 0x0806,
    /* 0x0807 - 0x080F Reserved */
    
    kHIDUsage_Snsr_Event_SensorEvent_Unknown                    = 0x0810,
    kHIDUsage_Snsr_Event_SensorEvent_StateChanged               = 0x0811,
    kHIDUsage_Snsr_Event_SensorEvent_PropertyChanged            = 0x0812,
    kHIDUsage_Snsr_Event_SensorEvent_DataUpdated                = 0x0813,
    kHIDUsage_Snsr_Event_SensorEvent_PollResponse               = 0x0814,
    kHIDUsage_Snsr_Event_SensorEvent_ChangeSensitivity          = 0x0815,
    kHIDUsage_Snsr_Event_SensorEvent_RangeMaxReached            = 0x0816,
    kHIDUsage_Snsr_Event_SensorEvent_RangeMinReached            = 0x0817,
    kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossUp       = 0x0818,
    kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossDown     = 0x0819,
    kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossUp        = 0x081A,
    kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossDown      = 0x081B,
    kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossUp       = 0x081C,
    kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossDown     = 0x081D,
    kHIDUsage_Snsr_Event_SensorEvent_PeriodExceeded             = 0x081E,
    kHIDUsage_Snsr_Event_SensorEvent_FrequencyExceeded          = 0x081F,
    kHIDUsage_Snsr_Event_SensorEvent_ComplexTrigger             = 0x0820,
    /* 0x0821 - 0x082F Reserved */

    /* Property Usages */
    kHIDUsage_Snsr_Property                                     = 0x0300,
    kHIDUsage_Snsr_Property_FriendlyName                        = 0x0301,
    kHIDUsage_Snsr_Property_PersistentUniqueID                  = 0x0302,
    kHIDUsage_Snsr_Property_SensorStatus                        = 0x0303,
    kHIDUsage_Snsr_Property_MinimumReportInterval               = 0x0304,
    kHIDUsage_Snsr_Property_Manufacturer                        = 0x0305,
    kHIDUsage_Snsr_Property_Model                               = 0x0306,
    kHIDUsage_Snsr_Property_SerialNumber                        = 0x0307,
    kHIDUsage_Snsr_Property_Description                         = 0x0308,
    kHIDUsage_Snsr_Property_ConnectionType                      = 0x0309,
    kHIDUsage_Snsr_Property_DevicePath                          = 0x030A,
    kHIDUsage_Snsr_Property_HardwareRevision                    = 0x030B,
    kHIDUsage_Snsr_Property_FirmwareVersion                     = 0x030C,
    kHIDUsage_Snsr_Property_ReleaseData                         = 0x030D,
    kHIDUsage_Snsr_Property_ReportInterval                      = 0x030E,
    kHIDUsage_Snsr_Property_ChangeSensitivityAbsolute           = 0x030F,
    kHIDUsage_Snsr_Property_ChangeSensitivityPercentRange       = 0x0310,
    kHIDUsage_Snsr_Property_ChangeSensitivityPercentRelative    = 0x0311,
    kHIDUsage_Snsr_Property_Accuracy                            = 0x0312,
    kHIDUsage_Snsr_Property_Resolution                          = 0x0313,
    kHIDUsage_Snsr_Property_Maximum                             = 0x0314,
    kHIDUsage_Snsr_Property_Minimum                             = 0x0315,
    kHIDUsage_Snsr_Property_ReportingState                      = 0x0316,
    kHIDUsage_Snsr_Property_SamplingRate                        = 0x0317,
    kHIDUsage_Snsr_Property_ResponseCurve                       = 0x0318,
    kHIDUsage_Snsr_Property_PowerState                          = 0x0319,
    /* 0x031A - 0x03FF Reserved */
    
    kHIDUsage_Snsr_Property_ConnectionType_Integrated           = 0x0830,
    kHIDUsage_Snsr_Property_ConnectionType_Attached             = 0x0831,
    kHIDUsage_Snsr_Property_ConnectionType_External             = 0x0832,
    /* 0x0833 - 0x083F Reserved */
    kHIDUsage_Snsr_Property_ReportingState_NoEvents             = 0x0840,
    kHIDUsage_Snsr_Property_ReportingState_AllEvents            = 0x0841,
    kHIDUsage_Snsr_Property_ReportingState_ThresholdEvents      = 0x0842,
    kHIDUsage_Snsr_Property_ReportingState_WakeNoEvents         = 0x0843,
    kHIDUsage_Snsr_Property_ReportingState_WakeAllEvents        = 0x0844,
    kHIDUsage_Snsr_Property_ReportingState_WakeThresholdEvents  = 0x0845,
    /* 0x0846 - 0x084F Reserved */
    kHIDUsage_Snsr_Property_PowerState_Undefined                = 0x0850,
    kHIDUsage_Snsr_Property_PowerState_D0_FullPower             = 0x0851,
    kHIDUsage_Snsr_Property_PowerState_D1_LowPower              = 0x0852,
    kHIDUsage_Snsr_Property_PowerState_D2_Standby               = 0x0853,
    kHIDUsage_Snsr_Property_PowerState_D3_Sleep                 = 0x0854,
    kHIDUsage_Snsr_Property_PowerState_D4_PowerOff              = 0x0855,
    /* 0x0855 - 0x085F Reserved */
    
    /* Specific Sensor Type Data Fields */
    /*** TODO ***/
};

/* Power Device Page (0x84) */
/* This section provides detailed descriptions of the usages employed by Power Devices. */
enum
{
    
    kHIDUsage_PD_Undefined = 0x00,                /* Power Device Undefined Usage */
    kHIDUsage_PD_iName = 0x01,                    /* CL- Power Device Name Index */
    kHIDUsage_PD_PresentStatus = 0x02,            /* CL- Power Device Present Status */
    kHIDUsage_PD_ChangedStatus = 0x03,            /* CA- Power Device Changed Status */
    kHIDUsage_PD_UPS = 0x04,                    /* CA- Uninterruptible Power Supply */
    kHIDUsage_PD_PowerSupply = 0x05,            /* CA- Power Supply */
    /* Reserved 0x06 - 0x0F */
    kHIDUsage_PD_BatterySystem = 0x10,            /* CP- Battery System power module */
    kHIDUsage_PD_BatterySystemID = 0x11,        /* SV IF- Battery System ID */
    kHIDUsage_PD_Battery = 0x12,                /* CP- Battery */
    kHIDUsage_PD_BatteryID = 0x13,                /* SV IF- Battery ID */
    kHIDUsage_PD_Charger = 0x14,                /* CP- Charger */
    kHIDUsage_PD_ChargerID = 0x15,                /* SV IF- Charger ID */
    kHIDUsage_PD_PowerConverter = 0x16,            /* CP- Power Converter power module */
    kHIDUsage_PD_PowerConverterID = 0x17,        /* SV IF- Power Converter ID */
    kHIDUsage_PD_OutletSystem = 0x18,            /* CP- Outlet System power module */
    kHIDUsage_PD_OutletSystemID = 0x19,            /* SV IF-Outlet System ID */
    kHIDUsage_PD_Input = 0x1A,                    /* CP- Power Device Input */
    kHIDUsage_PD_InputID = 0x1B,                /* SV IF- Power Device Input ID */
    kHIDUsage_PD_Output = 0x1C,                    /* CP- Power Device Output */
    kHIDUsage_PD_OutputID = 0x1D,                /* SV IF- Power Device Output ID */
    kHIDUsage_PD_Flow = 0x1E,                    /* CP- Power Device Flow */
    kHIDUsage_PD_FlowID = 0x1F,                    /* Item IF- Power Device Flow ID */
    kHIDUsage_PD_Outlet = 0x20,                    /* CP- Power Device Outlet */
    kHIDUsage_PD_OutletID = 0x21,                /* SV IF- Power Device Outlet ID */
    kHIDUsage_PD_Gang = 0x22,                    /* CL/CP- Power Device Gang */
    kHIDUsage_PD_GangID = 0x23,                    /* SV IF- Power Device Gang ID */
    kHIDUsage_PD_PowerSummary = 0x24,            /* CL/CP- Power Device Power Summary */
    kHIDUsage_PD_PowerSummaryID = 0x25,            /* SV IF- Power Device Power Summary ID */
    /* Reserved 0x26 - 0x2F */
    kHIDUsage_PD_Voltage = 0x30,                /* DV IF- Power Device Voltage */
    kHIDUsage_PD_Current = 0x31,                /* DV IF- Power Device Current */
    kHIDUsage_PD_Frequency = 0x32,                /* DV IF- Power Device Frequency */
    kHIDUsage_PD_ApparentPower = 0x33,            /* DV IF- Power Device Apparent Power */
    kHIDUsage_PD_ActivePower = 0x34,            /* DV IF- Power Device RMS Power */
    kHIDUsage_PD_PercentLoad = 0x35,            /* DV IF- Power Device Percent Load */
    kHIDUsage_PD_Temperature = 0x36,            /* DV IF- Power Device Temperature */
    kHIDUsage_PD_Humidity = 0x37,                /* DV IF- Power Device Humidity */
    kHIDUsage_PD_BadCount = 0x38,                /* DV IF- Power Device Bad Condition Count */
    /* Reserved 0x39 - 0x3F */
    kHIDUsage_PD_ConfigVoltage = 0x40,            /* SV/DV F- Power Device Nominal Voltage */
    kHIDUsage_PD_ConfigCurrent = 0x41,            /* SV/DV F- Power Device Nominal Current */
    kHIDUsage_PD_ConfigFrequency = 0x42,        /* SV/DV F- Power Device Nominal Frequency */
    kHIDUsage_PD_ConfigApparentPower = 0x43,    /* SV/DV F- Power Device Nominal Apparent Power */
    kHIDUsage_PD_ConfigActivePower = 0x44,        /* SV/DV F- Power Device Nominal RMS Power */
    kHIDUsage_PD_ConfigPercentLoad = 0x45,        /* SV/DV F- Power Device Nominal Percent Load */
    kHIDUsage_PD_ConfigTemperature = 0x46,        /* SV/DV F- Power Device Nominal Temperature */
    kHIDUsage_PD_ConfigHumidity = 0x47,            /* SV/DV F- Power Device Nominal Humidity */
    /* Reserved 0x48 - 0x4F */
    kHIDUsage_PD_SwitchOnControl = 0x50,        /* DV F- Power Device Switch On Control */
    kHIDUsage_PD_SwitchOffControl = 0x51,        /* DV F- Power Device Switch Off Control */
    kHIDUsage_PD_ToggleControl = 0x52,            /* DV F- Power Device Toogle Sequence Control */
    kHIDUsage_PD_LowVoltageTransfer = 0x53,        /* DV F- Power Device Min Transfer Voltage */
    kHIDUsage_PD_HighVoltageTransfer = 0x54,    /* DV F- Power Device Max Transfer Voltage */
    kHIDUsage_PD_DelayBeforeReboot = 0x55,        /* DV F- Power Device Delay Before Reboot */
    kHIDUsage_PD_DelayBeforeStartup = 0x56,        /* DV F- Power Device Delay Before Startup */
    kHIDUsage_PD_DelayBeforeShutdown = 0x57,    /* DV F- Power Device Delay Before Shutdown */
    kHIDUsage_PD_Test = 0x58,                    /* DV F- Power Device Test Request/Result */
    kHIDUsage_PD_ModuleReset = 0x59,            /* DV F- Power Device Reset Request/Result */
    kHIDUsage_PD_AudibleAlarmControl = 0x5A,    /* DV F- Power Device Audible Alarm Control */
    /* Reserved 0x5B - 0x5F */
    kHIDUsage_PD_Present = 0x60,                /* DV IOF- Power Device Present */
    kHIDUsage_PD_Good = 0x61,                    /* DV IOF- Power Device Good */
    kHIDUsage_PD_InternalFailure = 0x62,        /* DV IOF- Power Device Internal Failure */
    kHIDUsage_PD_VoltageOutOfRange = 0x63,        /* DV IOF- Power Device Voltage Out Of Range */
    kHIDUsage_PD_FrequencyOutOfRange = 0x64,    /* DV IOF- Power Device Frequency Out Of Range */
    kHIDUsage_PD_Overload = 0x65,                /* DV IOF- Power Device Overload */
    kHIDUsage_PD_OverCharged = 0x66,            /* DV IOF- Power Device Over Charged */
    kHIDUsage_PD_OverTemperature = 0x67,        /* DV IOF- Power Device Over Temperature */
    kHIDUsage_PD_ShutdownRequested = 0x68,        /* DV IOF- Power Device Shutdown Requested */
    kHIDUsage_PD_ShutdownImminent = 0x69,        /* DV IOF- Power Device Shutdown Imminent */
    /* Reserved 0x6A */
    kHIDUsage_PD_SwitchOnOff = 0x6B,            /* DV IOF- Power Device On/Off Switch Status */
    kHIDUsage_PD_Switchable = 0x6C,                /* DV IOF- Power Device Switchable */
    kHIDUsage_PD_Used = 0x6D,                    /* DV IOF- Power Device Used */
    kHIDUsage_PD_Boost = 0x6E,                    /* DV IOF- Power Device Boosted */
    kHIDUsage_PD_Buck = 0x6F,                    /* DV IOF- Power Device Bucked */
    kHIDUsage_PD_Initialized = 0x70,            /* DV IOF- Power Device Initialized */
    kHIDUsage_PD_Tested = 0x71,                    /* DV IOF- Power Device Tested */
    kHIDUsage_PD_AwaitingPower = 0x72,            /* DV IOF- Power Device Awaiting Power */
    kHIDUsage_PD_CommunicationLost = 0x73,        /* DV IOF- Power Device Communication Lost */
    /* Reserved 0x74 - 0xFC */
    kHIDUsage_PD_iManufacturer = 0xFD,            /* SV F- Power Device Manufacturer String Index */
    kHIDUsage_PD_iProduct = 0xFE,                /* SV F- Power Device Product String Index */
    kHIDUsage_PD_iserialNumber = 0xFF            /* SV F- Power Device Serial Number String Index */
};

/* Battery System Page (x85) */
/* This section provides detailed descriptions of the usages employed by Battery Systems. */    
enum
{
    kHIDUsage_BS_Undefined = 0x00,                /* Battery System Undefined */
    kHIDUsage_BS_SMBBatteryMode = 0x01,            /* CL - SMB Mode */
    kHIDUsage_BS_SMBBatteryStatus = 0x02,        /* CL - SMB Status */
    kHIDUsage_BS_SMBAlarmWarning = 0x03,        /* CL - SMB Alarm Warning */
    kHIDUsage_BS_SMBChargerMode = 0x04,            /* CL - SMB Charger Mode */
    kHIDUsage_BS_SMBChargerStatus = 0x05,        /* CL - SMB Charger Status */
    kHIDUsage_BS_SMBChargerSpecInfo = 0x06,        /* CL - SMB Charger Extended Status */
    kHIDUsage_BS_SMBSelectorState = 0x07,        /* CL - SMB Selector State */
    kHIDUsage_BS_SMBSelectorPresets = 0x08,        /* CL - SMB Selector Presets */
    kHIDUsage_BS_SMBSelectorInfo = 0x09,        /* CL - SMB Selector Info */
    /* Reserved 0x0A - 0x0F */
    kHIDUsage_BS_OptionalMfgFunction1 = 0x10,    /* DV F - Battery System Optional SMB Mfg Function 1 */
    kHIDUsage_BS_OptionalMfgFunction2 = 0x11,    /* DV F - Battery System Optional SMB Mfg Function 2 */
    kHIDUsage_BS_OptionalMfgFunction3 = 0x12,    /* DV F - Battery System Optional SMB Mfg Function 3 */
    kHIDUsage_BS_OptionalMfgFunction4 = 0x13,    /* DV F - Battery System Optional SMB Mfg Function 4 */
    kHIDUsage_BS_OptionalMfgFunction5 = 0x14,    /* DV F - Battery System Optional SMB Mfg Function 5 */
    kHIDUsage_BS_ConnectionToSMBus = 0x15,        /* DF F - Battery System Connection To System Management Bus */
    kHIDUsage_BS_OutputConnection = 0x16,        /* DF F - Battery System Output Connection Status */
    kHIDUsage_BS_ChargerConnection = 0x17,        /* DF F - Battery System Charger Connection */
    kHIDUsage_BS_BatteryInsertion = 0x18,        /* DF F - Battery System Battery Insertion */
    kHIDUsage_BS_Usenext = 0x19,                /* DF F - Battery System Use Next */
    kHIDUsage_BS_OKToUse = 0x1A,                /* DF F - Battery System OK To Use */
    kHIDUsage_BS_BatterySupported = 0x1B,        /* DF F - Battery System Battery Supported */
    kHIDUsage_BS_SelectorRevision = 0x1C,        /* DF F - Battery System Selector Revision */
    kHIDUsage_BS_ChargingIndicator = 0x1D,        /* DF F - Battery System Charging Indicator */
    /* Reserved 0x1E - 0x27 */
    kHIDUsage_BS_ManufacturerAccess = 0x28,        /* DV F - Battery System Manufacturer Access */
    kHIDUsage_BS_RemainingCapacityLimit = 0x29,    /* DV F - Battery System Remaining Capacity Limit */
    kHIDUsage_BS_RemainingTimeLimit = 0x2A,        /* DV F - Battery System Remaining Time Limit */
    kHIDUsage_BS_AtRate = 0x2B,                    /* DV F - Battery System At Rate... */
    kHIDUsage_BS_CapacityMode = 0x2C,            /* DV F - Battery System Capacity Mode */
    kHIDUsage_BS_BroadcastToCharger = 0x2D,        /* DV F - Battery System Broadcast To Charger */
    kHIDUsage_BS_PrimaryBattery = 0x2E,            /* DV F - Battery System Primary Battery */
    kHIDUsage_BS_ChargeController = 0x2F,        /* DV F - Battery System Charge Controller */
    /* Reserved 0x30 - 0x3F */
    kHIDUsage_BS_TerminateCharge = 0x40,        /* DF IOF - Battery System Terminate Charge */
    kHIDUsage_BS_TerminateDischarge = 0x41,        /* DF IOF - Battery System Terminate Discharge */
    kHIDUsage_BS_BelowRemainingCapacityLimit = 0x42, /* DF IOF - Battery System Below Remaining Capacity Limit */
    kHIDUsage_BS_RemainingTimeLimitExpired = 0x43, /* DF IOF - Battery System Remaining Time Limit Expired */
    kHIDUsage_BS_Charging = 0x44,                /* DF IOF - Battery System Charging */
    kHIDUsage_BS_Discharging = 0x45,            /* DV IOF - Battery System Discharging */
    kHIDUsage_BS_FullyCharged = 0x46,            /* DF IOF - Battery System Fully Charged */
    kHIDUsage_BS_FullyDischarged = 0x47,        /* DV IOF - Battery System Fully Discharged */
    kHIDUsage_BS_ConditioningFlag = 0x48,        /* DV IOF - Battery System Conditioning Flag */
    kHIDUsage_BS_AtRateOK = 0x49,                /* DV IOF - Battery System At Rate OK */
    kHIDUsage_BS_SMBErrorCode = 0x4A,            /* DF IOF - Battery System SMB Error Code */
    kHIDUsage_BS_NeedReplacement = 0x4B,        /* DF IOF - Battery System Need Replacement */
    /* Reserved 0x4C - 0x5F */
    kHIDUsage_BS_AtRateTimeToFull = 0x60,        /* DV IF - Battery System At Rate Time To Full */
    kHIDUsage_BS_AtRateTimeToEmpty = 0x61,        /* DV IF - Battery System At Rate Time To Empty */
    kHIDUsage_BS_AverageCurrent = 0x62,            /* DV IF - Battery System Average Current */
    kHIDUsage_BS_Maxerror = 0x63,                /* DV IF - Battery System Max Error */
    kHIDUsage_BS_RelativeStateOfCharge = 0x64,    /* DV IF - Battery System Relative State Of Charge */
    kHIDUsage_BS_AbsoluteStateOfCharge = 0x65,    /* DV IF - Battery System Absolute State Of Charge */
    kHIDUsage_BS_RemainingCapacity = 0x66,        /* DV IF - Battery System Remaining Capacity */
    kHIDUsage_BS_FullChargeCapacity = 0x67,        /* DV IF - Battery System Full Charge Capacity */
    kHIDUsage_BS_RunTimeToEmpty = 0x68,            /* DV IF - Battery System Run Time To Empty */
    kHIDUsage_BS_AverageTimeToEmpty = 0x69,        /* DV IF - Battery System Average Time To Empty */
    kHIDUsage_BS_AverageTimeToFull = 0x6A,        /* DV IF - Battery System Average Time To Full */
    kHIDUsage_BS_CycleCount = 0x6B,                /* DV IF - Battery System Cycle Count */
    /* Reserved 0x6C - 0x7F */
    kHIDUsage_BS_BattPackModelLevel = 0x80,        /* SV F - Battery System Batt Pack Model Level */
    kHIDUsage_BS_InternalChargeController = 0x81, /* SF F - Battery System Internal Charge Controller */
    kHIDUsage_BS_PrimaryBatterySupport = 0x82,    /* SF F - Battery System Primary Battery Support */
    kHIDUsage_BS_DesignCapacity = 0x83,            /* SV F - Battery System Design Capacity */
    kHIDUsage_BS_SpecificationInfo = 0x84,        /* SV F - Battery System Specification Info */
    kHIDUsage_BS_ManufacturerDate = 0x85,        /* SV F - Battery System Manufacturer Date */
    kHIDUsage_BS_SerialNumber = 0x86,            /* SV F - Battery System Serial Number */
    kHIDUsage_BS_iManufacturerName = 0x87,        /* SV F - Battery System Manufacturer Name Index */
    kHIDUsage_BS_iDevicename = 0x88,            /* SV F - Battery System Device Name Index */
    kHIDUsage_BS_iDeviceChemistry = 0x89,        /* SV F - Battery System Device Chemistry Index */
    kHIDUsage_BS_ManufacturerData = 0x8A,        /* SV F - Battery System Manufacturer Data */
    kHIDUsage_BS_Rechargable = 0x8B,            /* SV F - Battery System Rechargable */
    kHIDUsage_BS_WarningCapacityLimit = 0x8C,    /* SV F - Battery System Warning Capacity Limit */
    kHIDUsage_BS_CapacityGranularity1 = 0x8D,    /* SV F - Battery System Capacity Granularity 1 */
    kHIDUsage_BS_CapacityGranularity2 = 0x8E,    /* SV F - Battery System Capacity Granularity 2 */
    kHIDUsage_BS_iOEMInformation = 0x8F,        /* SV F - Battery System OEM Information Index */
    /* Reserved 0x90 - 0xBF */
    kHIDUsage_BS_InhibitCharge = 0xC0,            /* DF IOF - Battery System Inhibit Charge */
    kHIDUsage_BS_EnablePolling = 0xC1,            /* DF IOF - Battery System Enable Polling */
    kHIDUsage_BS_ResetToZero = 0xC2,            /* DF IOF - Battery System Reset To Zero */
    /* Reserved 0xC3 - 0xCF */
    kHIDUsage_BS_ACPresent = 0xD0,                /* DF IOF - Battery System AC Present */
    kHIDUsage_BS_BatteryPresent = 0xD1,            /* DF IOF - Battery System Battery Present */
    kHIDUsage_BS_PowerFail = 0xD2,                /* DF IOF - Battery System Power Fail */
    kHIDUsage_BS_AlarmInhibited = 0xD3,            /* DF IOF - Battery System Alarm Inhibited */
    kHIDUsage_BS_ThermistorUnderRange = 0xD4,    /* DF IOF - Battery System Thermistor Under Range */
    kHIDUsage_BS_ThermistorHot = 0xD5,            /* DF IOF - Battery System Thermistor Hot */
    kHIDUsage_BS_ThermistorCold = 0xD6,            /* DF IOF - Battery System Thermistor Cold */
    kHIDUsage_BS_ThermistorOverRange = 0xD7,    /* DF IOF - Battery System Thermistor Over Range */
    kHIDUsage_BS_VoltageOutOfRange = 0xD8,        /* DF IOF - Battery System Voltage Out Of Range */
    kHIDUsage_BS_CurrentOutOfRange = 0xD9,        /* DF IOF - Battery System Current Out Of Range */
    kHIDUsage_BS_CurrentNotRegulated = 0xDA,    /* DF IOF - Battery System Current Not Regulated */
    kHIDUsage_BS_VoltageNotRegulated = 0xDB,    /* DF IOF - Battery System Voltage Not Regulated */
    kHIDUsage_BS_MasterMode = 0xDC,                /* DF IOF - Battery System Master Mode */
    /* Reserved 0xDD - 0xEF */
    kHIDUsage_BS_ChargerSelectorSupport = 0xF0,    /* SF F- Battery System Charger Support Selector */
    kHIDUsage_BS_ChargerSpec = 0xF1,            /* SF F- Battery System Charger Specification */
    kHIDUsage_BS_Level2 = 0xF2,                    /* SF F- Battery System Charger Level 2 */
    kHIDUsage_BS_Level3 = 0xF3                    /* SF F- Battery System Charger Level 3 */
    /* Reserved 0xF2 - 0xFF */
};

/* Bar Code Scanner Page (0x8C) */
/* This section provides detailed descriptions of the usages employed by Bar Code Scanner Devices. */
enum
{
    kHIDUsage_BCS_Undefined = 0x00,                     /* Bar Code Scanner Undefined Usage */
    kHIDUsage_BCS_BadgeReader = 0x01,                   /* CA - Bar Code Badge Reader */
    kHIDUsage_BCS_BarCodeScanner = 0x02,                /* CA -Bar Code Scanner */
    kHIDUsage_BCS_DumbBarCodeScanner = 0x03,            /* CA -Dumb Bar Code Scanner  Usage */
    kHIDUsage_BCS_CordlessScannerBase = 0x04,           /* CA -Cordless Base Usage */
    kHIDUsage_BCS_BarCodeScannerCradle = 0x05,          /* CA -Bar Code Scanner Cradle Usage */
    /* Reserved 0x06 - 0x0F */
    kHIDUsage_BCS_AttributeReport = 0x10,               /* CL - Attribute Report */
    kHIDUsage_BCS_SettingsReport = 0x11,                /* CL - Settings Report */
    kHIDUsage_BCS_ScannedDataReport = 0x12,             /* CL - Scanned Data Report */
    kHIDUsage_BCS_RawScannedDataReport = 0x13,          /* CL - Raw Scanned Data Report */
    kHIDUsage_BCS_TriggerReport = 0x14,                 /* CL - Trigger Report */
    kHIDUsage_BCS_StatusReport = 0x15,                  /* CL - Status Report */
    kHIDUsage_BCS_UPC_EANControlReport = 0x16,          /* CL - UPC/EAN Control Report */
    kHIDUsage_BCS_EAN2_3LabelControlReport = 0x17,      /* CL - EAN 2/3 Label Control Report */
    kHIDUsage_BCS_Code39ControlReport = 0x18,           /* CL - Code 39 Control Report */
    kHIDUsage_BCS_Interleaved2of5ControlReport = 0x19,  /* CL - Interleaved 2 of 5 Control Report */
    kHIDUsage_BCS_Standard2of5ControlReport = 0x1A,     /* CL - Standard 2 of 5 Control Report */
    kHIDUsage_BCS_MSIPlesseyControlReport = 0x1B,       /* CL - MSI Plessey Control Report */
    kHIDUsage_BCS_CodabarControlReport = 0x1C,          /* CL - Codabar Control Report */
    kHIDUsage_BCS_Code128ControlReport = 0x1D,          /* CL - Code 128 Control Report */
    kHIDUsage_BCS_Misc1DControlReport = 0x1E,           /* CL - Misc 1D Control Report */
    kHIDUsage_BCS_2DControlReport = 0x1F,               /* CL - 2D Control Report */
    /* Reserved 0x20 - 0x2F */
    kHIDUsage_BCS_Aiming_PointerMide = 0x30,            /* SF - Aiming Pointer Mode */
    kHIDUsage_BCS_BarCodePresentSensor = 0x31,          /* SF - Bar Code Present Sensor */
    kHIDUsage_BCS_Class1ALaser = 0x32,                  /* SF - Class 1A Laser */
    kHIDUsage_BCS_Class2Laser = 0x33,                   /* SF - Class 2 Laser */
    kHIDUsage_BCS_HeaterPresent = 0x34,                 /* SF - Heater Present */
    kHIDUsage_BCS_ContactScanner = 0x35,                /* SF - Contact Scanner */
    kHIDUsage_BCS_ElectronicArticleSurveillanceNotification = 0x36, /* SF - Electronic Article Surveillance Notification */
    kHIDUsage_BCS_ConstantElectronicArticleSurveillance = 0x37, /* SF - Constant Electronic Article Surveillance */
    kHIDUsage_BCS_ErrorIndication = 0x38,               /* SF - Error Indication */
    kHIDUsage_BCS_FixedBeeper = 0x39,                   /* SF - Fixed Beeper */
    kHIDUsage_BCS_GoodDecodeIndication = 0x3A,          /* SF - Good Decode Indication */
    kHIDUsage_BCS_HandsFreeScanning = 0x3B,             /* SF - Hands Free Scanning */
    kHIDUsage_BCS_IntrinsicallySafe = 0x3C,             /* SF - Intrinsically Safe */
    kHIDUsage_BCS_KlasseEinsLaser = 0x3D,               /* SF - Klasse Eins Laser */
    kHIDUsage_BCS_LongRangeScanner = 0x3E,              /* SF - Long Range Scanner */
    kHIDUsage_BCS_MirrorSpeedControl = 0x3F,            /* SF - Mirror Speed Control */
    kHIDUsage_BCS_NotOnFileIndication = 0x40,           /* SF - Not On File Indication */
    kHIDUsage_BCS_ProgrammableBeeper = 0x41,            /* SF - Programmable Beeper */
    kHIDUsage_BCS_Triggerless = 0x42,                   /* SF - Triggerless */
    kHIDUsage_BCS_Wand = 0x43,                          /* SF - Wand */
    kHIDUsage_BCS_WaterResistant = 0x44,                /* SF - Water Resistant */
    kHIDUsage_BCS_MultiRangeScanner = 0x45,             /* SF - Multi-Range Scanner */
    kHIDUsage_BCS_ProximitySensor = 0x46,               /* SF - Proximity Sensor */
    /* Reserved 0x47 - 0x4C */
    kHIDUsage_BCS_FragmentDecoding = 0x4D,              /* DF - Fragment Decoding */
    kHIDUsage_BCS_ScannerReadConfidence = 0x4E,         /* DV - Scanner Read Confidence */
    kHIDUsage_BCS_DataPrefix = 0x4F,                    /* NAry - Data Prefix  */
    kHIDUsage_BCS_PrefixAIMI = 0x50,                    /* SEL - Prefix AIMI */
    kHIDUsage_BCS_PrefixNone = 0x51,                    /* SEL - Prefix None */
    kHIDUsage_BCS_PrefixProprietary = 0x52,             /* SEL - Prefix Proprietary */
    /* Reserved 0x53 - 0x54 */
    kHIDUsage_BCS_ActiveTime = 0x55,                    /* DV - Active Time */
    kHIDUsage_BCS_AimingLaserPattern = 0x56,            /* DF - Aiming Laser Pattern */
    kHIDUsage_BCS_BarCodePresent = 0x57,                /* OOC - Bar Code Present */
    kHIDUsage_BCS_BeeperState = 0x58,                   /* OOC - Beeper State */
    kHIDUsage_BCS_LaserOnTime = 0x59,                   /* DV - Laser On Time */
    kHIDUsage_BCS_LaserState = 0x5A,                    /* OOC - Laser State */
    kHIDUsage_BCS_LockoutTime = 0x5B,                   /* DV - Lockout Time */
    kHIDUsage_BCS_MotorState = 0x5C,                    /* OOC - Motor State */
    kHIDUsage_BCS_MotorTimeout = 0x5D,                  /* DV - Motor Timeout */
    kHIDUsage_BCS_PowerOnResetScanner = 0x5E,           /* DF - Power On Reset Scanner */
    kHIDUsage_BCS_PreventReadOfBarcodes = 0x5F,         /* DF - Prevent Read of Barcodes */
    kHIDUsage_BCS_InitiateBarcodeRead = 0x60,           /* DF - Initiate Barcode Read */
    kHIDUsage_BCS_TriggerState = 0x61,                  /* DF - Trigger State */
    kHIDUsage_BCS_TriggerMode = 0x62,                   /* NAry - Trigger Mode */
    kHIDUsage_BCS_TriggerModeBlinkingLaserOn = 0x63,    /* SEL - Trigger Mode Blinking Laser On */
    kHIDUsage_BCS_TriggerModeContinuousLaserOn = 0x64,  /* SEL - Trigger Mode Continuous Laser On */
    kHIDUsage_BCS_TriggerModeLaserOnWhilePulled = 0x65, /* SEL - Trigger Mode Laser on while Pulled */
    kHIDUsage_BCS_TriggerModeLaserStaysOnAfterTriggerRelease = 0x66, /* SEL - Trigger Mode Laser stays on after Trigger Release */
    /* Reserved 0x67 - 0x6C */
    kHIDUsage_BCS_CommitParametersToNVM = 0x6D,         /* DF - Commit Parameters to NVM */
    kHIDUsage_BCS_ParameterScanning = 0x6E,             /* DF - Parameter Scanning */
    kHIDUsage_BCS_ParametersChanged = 0x6F,             /* OOC - Parameters Changed */
    kHIDUsage_BCS_SetParameterDefaultValues = 0x70,     /* DF - Set parameter default values */
    /* Reserved 0x71 - 0x74 */
    kHIDUsage_BCS_ScannerInCradle = 0x75,               /* OOC - Scanner In Cradle */
    kHIDUsage_BCS_ScannerInRange = 0x76,                /* OOC - Scanner In Range */
    /* Reserved 0x77 - 0x79 */
    kHIDUsage_BCS_AimDuration = 0x7A,                   /* DV - Aim Duration */
    kHIDUsage_BCS_GoodReadLampDuration = 0x7B,          /* DV - Good Read Lamp Duration */
    kHIDUsage_BCS_GoodReadLampIntensity = 0x7C,         /* DV - Good Read Lamp Intensity */
    kHIDUsage_BCS_GoodReadLED = 0x7D,                   /* DF - Good Read LED */
    kHIDUsage_BCS_GoodReadToneFrequency = 0x7E,         /* DV - Good Read Tone Frequency*/
    kHIDUsage_BCS_GoodReadToneLength = 0x7F,            /* DV - Good Read Tone Length */
    kHIDUsage_BCS_GoodReadToneVolume = 0x80,            /* DV - Good Read Tone Volume */
    /* Reserved 0x81 */
    kHIDUsage_BCS_NoReadMessage = 0x82,                 /* DF - No Read Message */
    kHIDUsage_BCS_NotOnFileVolume = 0x83,               /* DV - Not on File Volume */
    kHIDUsage_BCS_PowerupBeep = 0x84,                   /* DF - Powerup Beep */
    kHIDUsage_BCS_SoundErrorBeep = 0x85,               /* DF - Sound Error Beep */
    kHIDUsage_BCS_SoundGoodReadBeep = 0x86,             /* DF - Sound Good Read Beep */
    kHIDUsage_BCS_SoundNotOnFileBeep = 0x87,            /* DF - Sound Not On File Beep */
    kHIDUsage_BCS_GoodReadWhenToWrite = 0x88,           /* NArry - Good Read When to Write */
    kHIDUsage_BCS_GRWTIAfterDecode = 0x89,              /* SEL - GRWTI After Decode */
    kHIDUsage_BCS_GRWTIBeep_LampAfterTransmit = 0x8A,   /* SEL - GRWTI Beep/Lamp after transmit */
    kHIDUsage_BCS_GRWTINoBeep_LampUseAtAll = 0x8B,      /* SEL - GRWTI No Beep/Lamp at all */
    /* Reserved 0x8C - 0x90 */
    kHIDUsage_BCS_BooklandEAN = 0x91,                   /* DF - Bookland EAN */
    kHIDUsage_BCS_ConvertEAN8To13Type = 0x92,           /* DF - Convert EAN 8 to 13 Type */
    kHIDUsage_BCS_ConvertUPCAToEAN_13 = 0x93,           /* DF - Convert UPC A to EAN-13 */
    kHIDUsage_BCS_ConvertUPC_EToA = 0x94,               /* DF - Convert UPC-E to A */
    kHIDUsage_BCS_EAN_13 = 0x95,                        /* DF - EAN-13 */
    kHIDUsage_BCS_EAN_8 = 0x96,                         /* DF - EAN_8 */
    kHIDUsage_BCS_EAN_99_128_Mandatory  = 0x97,         /* DF - EAN-99 128_Mandatory  */
    kHIDUsage_BCS_EAN_99_P5_128_Optional = 0x98,        /* DF - EAN-99 P5/128_Optional */
    /* Reserved 0x99 */
    kHIDUsage_BCS_UPC_EAN = 0x9A,                       /* DF - UPC/EAN */
    kHIDUsage_BCS_UPC_EANCouponCode = 0x9B,             /* DF - UPC/EAN Coupon Code */
    kHIDUsage_BCS_UPC_EANPeriodicals = 0x9C,            /* DV - UPC/EAN Periodicals */
    kHIDUsage_BCS_UPC_A = 0x9D,                         /* DF - UPC-A */
    kHIDUsage_BCS_UPC_AWith128Mandatory = 0x9E,         /* DF - UPC-A with 128 Mandatory */
    kHIDUsage_BCS_UPC_AWith128Optical = 0x9F,           /* DF - UPC-A with 128 Optical */
    kHIDUsage_BCS_UPC_AWithP5Optional = 0xA0,           /* DF - UPC-A with P5 Optional */
    kHIDUsage_BCS_UPC_E = 0xA1,                         /* DF - UPC-E */
    kHIDUsage_BCS_UPC_E1 = 0xA2,                        /* DF - UPC-E1 */
    /* Reserved 0xA3 - 0xA8 */
    kHIDUsage_BCS_Periodical = 0xA9,                    /* NArry - Periodical */
    kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus2 = 0xAA,/* SEL - Periodical Auto-Discriminate + 2 */
    kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus2 = 0xAB, /* SEL - Periodical Only Decode with + 2 */
    kHIDUsage_BCS_PeriodicalIgnorePlus2 = 0xAC,         /* SEL - Periodical Ignore + 2 */
    kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus5 = 0xAD,/* SEL - Periodical Auto-Discriminate + 5 */
    kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus5 = 0xAE, /* SEL - Periodical Only Decode with + 5 */
    kHIDUsage_BCS_PeriodicalIgnorePlus5 = 0xAF,         /* SEL - Periodical Ignore + 5 */
    kHIDUsage_BCS_Check = 0xB0,                         /* NArry - Check */
    kHIDUsage_BCS_CheckDisablePrice = 0xB1,             /* SEL - Check Disable Price */
    kHIDUsage_BCS_CheckEnable4DigitPrice = 0xB2,        /* SEL - Check Enable 4 digit Price */
    kHIDUsage_BCS_CheckEnable5DigitPrice = 0xB3,        /* SEL - Check Enable 5 digit Price */
    kHIDUsage_BCS_CheckEnableEuropean4DigitPrice = 0xB4,/* SEL - Check Enable European 4 digit Price */
    kHIDUsage_BCS_CheckEnableEuropean5DigitPrice = 0xB5,/* SEL - Check Enable European 5 digit Price */
    /* Reserved 0xB6 */
    kHIDUsage_BCS_EANTwoLabel = 0xB7,                   /* DF - EAN Two Label  */
    kHIDUsage_BCS_EANThreeLabel  = 0xB8,                /* DF - EAN Thread Label */
    kHIDUsage_BCS_EAN8FlagDigit1 = 0xB9,                /* DV - EAN 8 Flag Digit 1 */
    kHIDUsage_BCS_EAN8FlagDigit2 = 0xBA,                /* DV - EAN 8 Flag Digit 2 */
    kHIDUsage_BCS_EAN8FlagDigit3 = 0xBB,                /* DV - EAN 8 Flag Digit 3 */
    kHIDUsage_BCS_EAN13FlagDigit1 = 0xBC,               /* DV - EAN 13 Flag Digit 1 */
    kHIDUsage_BCS_EAN13FlagDigit2 = 0xBD,               /* DV - EAN 13 Flag Digit 2 */
    kHIDUsage_BCS_EAN13FlagDigit3 = 0xBE,               /* DV - EAN 13 Flag Digit 3 */
    kHIDUsage_BCS_AddEAN2_3LabelDefinition = 0xBF,      /* DF - Add EAN 2/3 Label Definition */
    kHIDUsage_BCS_ClearAllEAN2_3LabelDefinitions = 0xC0,/* DF - Clear all EAN 2/3 Label Definitions */
    /* Reserved 0xC1 - 0xC2 */
    kHIDUsage_BCS_Codabar = 0xC3,                       /* DF - Codabar */
    kHIDUsage_BCS_Code128 = 0xC4,                       /* DF - Code 128 */
    /* Reserved 0xC5 - 0xC6 */
    kHIDUsage_BCS_Code39 = 0xC7,                        /* DF - Code 39 */
    kHIDUsage_BCS_Code93 = 0xC8,                        /* DF - Code 93 */
    kHIDUsage_BCS_FullASCIIConversion = 0xC9,           /* DF - Full ASCII Conversion */
    kHIDUsage_BCS_Interleaved2of5 = 0xCA,               /* DF - Interleaved 2 of 5 */
    kHIDUsage_BCS_ItalianPharmacyCode = 0xCB,           /* DF - Italian Pharmacy Code */
    kHIDUsage_BCS_MSI_Plessey = 0xCC,                   /* DF - MSI/Plessey */
    kHIDUsage_BCS_Standard2of5IATA = 0xCD,              /* DF - Standard 2 of 5 IATA */
    kHIDUsage_BCS_Standard2of5 = 0xCE,                  /* DF - Standard 2 of 5 */
    /* Reserved 0xCF - 0xD2 */
    kHIDUsage_BCS_TransmitStart_Stop = 0xD3,            /* DF - Transmit Start/Stop */
    kHIDUsage_BCS_TriOptic = 0xD4,                      /* DF - Tri-Optic  */
    kHIDUsage_BCS_UCC_EAN_128 = 0xD5,                   /* DF - UCC/EAN-128  */
    kHIDUsage_BCS_CheckDigit = 0xD6,                    /* NArry - Check Digit */
    kHIDUsage_BCS_CheckDigitDisable = 0xD7,             /* SEL - Check Digit Disable */
    kHIDUsage_BCS_CheckDigitEnableInterleaved2of5OPCC = 0xD8, /* SEL - Check Digit Enable Interleaved 2 of 5 OPCC */
    kHIDUsage_BCS_CheckDigitEnableInterleaved2of5USS = 0xD9, /* SEL - Check Digit Enable Interleaved 2 of 5 USS */
    kHIDUsage_BCS_CheckDigitEnableStandard2of5OPCC = 0xD8, /* SEL - Check Digit Enable Standard 2 of 5 OPCC */
    kHIDUsage_BCS_CheckDigitEnableStandard2of5USS = 0xD9, /* SEL - Check Digit Enable Standard 2 of 5 USS */
    kHIDUsage_BCS_CheckDigitEnableOneMSIPlessey = 0xDC, /* SEL - Check Digit Enable One MSI Plessey */
    kHIDUsage_BCS_CheckDigitEnableTwoMSIPlessey = 0xDD, /* SEL - Check Digit Enable Two MSI Plessey */
    kHIDUsage_BCS_CheckDigitCodabarEnable = 0xDE,       /* SEL - Check Digit Codabar Enable */
    kHIDUsage_BCS_CheckDigitCode99Enable = 0xDF,        /* SEL - Check Digit Code 99 Enable */
    /* Reserved 0xE0 - 0xEF */
    kHIDUsage_BCS_TransmitCheckDigit = 0xF0,            /* NArry - Transmit Check Digit */
    kHIDUsage_BCS_DisableCheckDigitTransmit = 0xF1,     /* SEL - Disable Check Digit Transmit */
    kHIDUsage_BCS_EnableCheckDigitTransmit = 0xF2,      /* SEL - Enable Check Digit Transmit */
    /* Reserved 0xF3 - 0xFA */
    kHIDUsage_BCS_SymbologyIdentifier1 = 0xFB,          /* DV - Symbology Identifier 1 */
    kHIDUsage_BCS_SymbologyIdentifier2 = 0xFC,          /* DV - Symbology Identifier 2 */
    kHIDUsage_BCS_SymbologyIdentifier3 = 0xFD,          /* DV - Symbology Identifier 3 */
    kHIDUsage_BCS_DecodedData = 0xFE,                   /* DV - Decoded Data */
    kHIDUsage_BCS_DecodeDataContinued = 0xFF,           /* DF - Decode Data Continued */
    kHIDUsage_BCS_BarSpaceData = 0x100,                 /* DV - Bar Space Data */
    kHIDUsage_BCS_ScannerDataAccuracy = 0x101,          /* DV - Scanner Data Accuracy */
    kHIDUsage_BCS_RawDataPolarity = 0x102,              /* NArry - Raw Data Polarity */
    kHIDUsage_BCS_PolarityInvertedBarCode = 0x103,      /* SEL - Polarity Inverted Bar Code */
    kHIDUsage_BCS_PolarityNormalBarCode = 0x103,        /* SEL - Polarity Normal Bar Code */
    /* Reserved 0x105 */
    kHIDUsage_BCS_MinimumLengthToDecode = 0x106,        /* DV - Minimum Length to Decode */
    kHIDUsage_BCS_MaximumLengthToDecode = 0x107,        /* DV - Maximum Length to Decode */
    kHIDUsage_BCS_FirstDiscreteLengthToDecode = 0x108,  /* DV - First Discrete Length to Decode */
    kHIDUsage_BCS_SecondDiscreteLengthToDecode = 0x109, /* DV - Second Discrete Length to Decode */
    kHIDUsage_BCS_DataLengthMethod = 0x10A,             /* NArry - Data Length Method */
    kHIDUsage_BCS_DLMethodReadAny = 0x10B,              /* DF - DL Method Read any */
    kHIDUsage_BCS_DLMethodCheckInRange = 0x10C,         /* DF - DL Method Check in Range */
    kHIDUsage_BCS_DLMethodCheckForDiscrete = 0x10D,     /* DF - DL Method Check for Discrete */
    /* Reserved 0x10E - 0x10F */
    kHIDUsage_BCS_AztecCode = 0x110,                    /* DF - Aztec Code */
    kHIDUsage_BCS_BC412 = 0x111,                        /* DF - BC412 */
    kHIDUsage_BCS_ChannelCode = 0x112,                  /* DF - Channel Code */
    kHIDUsage_BCS_Code16 = 0x113,                       /* DF - Code 16 */
    kHIDUsage_BCS_Code32 = 0x114,                       /* DF - Code 32 */
    kHIDUsage_BCS_Code49 = 0x115,                       /* DF - Code 49 */
    kHIDUsage_BCS_CodeOne = 0x116,                      /* DF - Code One */
    kHIDUsage_BCS_Colorcode = 0x117,                    /* DF - Colorcode */
    kHIDUsage_BCS_DataMatrix = 0x118,                   /* DF - Data Matrix */
    kHIDUsage_BCS_MaxiCode = 0x119,                     /* DF - MaxiCode */
    kHIDUsage_BCS_MicroPDF = 0x11A,                     /* DF - MicroPDF */
    kHIDUsage_BCS_PDF_417 = 0x11B,                      /* DF - PDF-417 */
    kHIDUsage_BCS_PosiCode = 0x11C,                     /* DF - PosiCode */
    kHIDUsage_BCS_QRCode = 0x11D,                       /* DF - QR Code */
    kHIDUsage_BCS_SuperCode = 0x11E,                    /* DF - SuperCode */
    kHIDUsage_BCS_UltraCode = 0x11F,                    /* DF - UltraCode */
    kHIDUsage_BCS_USB_5_SlugCode = 0x120,               /* DF - USD-5 (Slug Code) */
    kHIDUsage_BCS_VeriCode = 0x121                      /* DF - VeriCode */
    /* Reserved 0x122 - 0xFFFF */
};

/* Weighing Devices Page (0x8D) */
/* This section provides detailed descriptions of the usages employed by Weighing Devices. */
enum
{
    kHIDUsage_WD_Undefined = 0x00,                      /* Weighing Device Undefined Usage */
    kHIDUsage_WD_WeighingDevice = 0x01,                 /* CA - Weighing Device */
    /* Reserved 0x02 - 0x1F */
    kHIDUsage_WD_ScaleScaleDevice = 0x20,               /* CL - Scale Device */
    kHIDUsage_WD_ScaleScaleClassIMetricCL = 0x21,       /* CL - Scale Class I Metric */
    kHIDUsage_WD_ScaleScaleClassIMetric = 0x22,         /* SEL - Scale Class I Metric */
    kHIDUsage_WD_ScaleScaleClassIIMetric = 0x23,        /* SEL - Scale Class II Metric */
    kHIDUsage_WD_ScaleScaleClassIIIMetric = 0x24,       /* SEL - Scale Class III Metric */
    kHIDUsage_WD_ScaleScaleClassIIILMetric = 0x25,      /* SEL - Scale Class IIIL Metric */
    kHIDUsage_WD_ScaleScaleClassIVMetric = 0x26,        /* SEL - Scale Class IV Metric */
    kHIDUsage_WD_ScaleScaleClassIIIEnglish = 0x27,      /* SEL - Scale Class III English */
    kHIDUsage_WD_ScaleScaleClassIIILEnglish = 0x28,     /* SEL - Scale Class IIIL English */
    kHIDUsage_WD_ScaleScaleClassIVEnglish = 0x29,       /* SEL - Scale Class IV English */
    kHIDUsage_WD_ScaleScaleClassGeneric = 0x2A,         /* SEL - Scale Class Generic */
    /* Reserved 0x2B - 0x2F */
    kHIDUsage_WD_ScaleAtrributeReport = 0x30,           /* CL - Scale Attribute Report */
    kHIDUsage_WD_ScaleControlReport = 0x31,             /* CL - Scale Control Report */
    kHIDUsage_WD_ScaleDataReport = 0x32,                /* CL - Scale Data Report */
    kHIDUsage_WD_ScaleStatusReport = 0x33,              /* CL - Scale Status Report */
    kHIDUsage_WD_ScaleWeightLimitReport = 0x34,         /* CL - Scale Weight Limit Report */
    kHIDUsage_WD_ScaleStatisticsReport = 0x35,          /* CL - Scale Statistics Report */
    /* Reserved 0x36 - 0x3F */
    kHIDUsage_WD_DataWeight = 0x40,                     /* DV - Data Weight */
    kHIDUsage_WD_DataScaling = 0x41,                    /* DV - Data Scaling */
    /* Reserved 0x42 - 0x4F */
    kHIDUsage_WD_WeightUnit = 0x50,                     /* CL - Weight Unit */
    kHIDUsage_WD_WeightUnitMilligram = 0x51,            /* SEL - Weight Unit Milligram */
    kHIDUsage_WD_WeightUnitGram = 0x52,                 /* SEL - Weight Unit Gram */
    kHIDUsage_WD_WeightUnitKilogram = 0x53,             /* SEL - Weight Unit Kilogram */
    kHIDUsage_WD_WeightUnitCarats = 0x54,               /* SEL - Weight Unit Carats */
    kHIDUsage_WD_WeightUnitTaels = 0x55,                /* SEL - Weight Unit Taels */
    kHIDUsage_WD_WeightUnitGrains = 0x56,               /* SEL - Weight Unit Grains */
    kHIDUsage_WD_WeightUnitPennyweights = 0x57,         /* SEL - Weight Unit Pennyweights */
    kHIDUsage_WD_WeightUnitMetricTon = 0x58,            /* SEL - Weight Unit Metric Ton */
    kHIDUsage_WD_WeightUnitAvoirTon = 0x59,             /* SEL - Weight Unit Avoir Ton */
    kHIDUsage_WD_WeightUnitTroyOunce = 0x5A,            /* SEL - Weight Unit Troy Ounce */
    kHIDUsage_WD_WeightUnitOunce = 0x5B,                /* SEL - Weight Unit Ounce */
    kHIDUsage_WD_WeightUnitPound = 0x5C,                /* SEL - Weight Unit Pound */
    /* Reserved 0x5D - 0x5F */
    kHIDUsage_WD_CalibrationCount = 0x60,               /* DV - Calibration Count */
    kHIDUsage_WD_RezeroCount = 0x61,                    /* DV - Re-Zero Count*/
    /* Reserved 0x62 - 0x6F */
    kHIDUsage_WD_ScaleStatus = 0x70,                    /* CL - Scale Status */
    kHIDUsage_WD_ScaleStatusFault = 0x71,               /* SEL - Scale Status Fault */
    kHIDUsage_WD_ScaleStatusStableAtZero = 0x72,        /* SEL - Scale Status Stable at Center of  Zero */
    kHIDUsage_WD_ScaleStatusInMotion = 0x73,            /* SEL - Scale Status In Motion */
    kHIDUsage_WD_ScaleStatusWeightStable = 0x74,        /* SEL - Scale Status Weight Stable */
    kHIDUsage_WD_ScaleStatusUnderZero = 0x75,           /* SEL - Scale Status Under Zero */
    kHIDUsage_WD_ScaleStatusOverWeightLimit = 0x76,     /* SEL - Scale Status Over Weight Limit */
    kHIDUsage_WD_ScaleStatusRequiresCalibration = 0x77, /* SEL - Scale Status Requires Calibration */
    kHIDUsage_WD_ScaleStatusRequiresRezeroing = 0x78,   /* SEL - Scale Status Requires Re-zeroing */
    /* Reserved 0x79 - 0x7F */
    kHIDUsage_WD_ZeroScale = 0x80,                      /* OOC - Zero Scale */
    kHIDUsage_WD_EnforcedZeroReturn = 0x81              /* OOC - Enforced Zero Return */
    /* Reserved 0x82 - 0xFFFF */
    
};

/* Magnetic Stripe Reader Page (0x8E) */
/* This section provides detailed descriptions of the usages employed by Magnetic Stripe Reader Devices. */
enum 
{
    kHIDUsage_MSR_Undefined = 0x00,                     /* MagStripe Undefined Usage */
    kHIDUsage_MSR_DeviceReadOnly = 0x01,                /* CA - MSR Device Read-Only */
    /* Reserved 0x02 - 0x10 */
    kHIDUsage_MSR_Track1Length = 0x11,                     /* SF, DF, SEL - Track 1 Length */
    kHIDUsage_MSR_Track2Length = 0x12,                     /* SF, DF, SEL - Track 2 Length */
    kHIDUsage_MSR_Track3Length = 0x13,                     /* SF, DF, SEL - Track 3 Length */
    kHIDUsage_MSR_TrackJISLength = 0x14,                   /* SF, DF, SEL - Track JIS Length */
    /* Reserved 0x15 - 0x1F */
    kHIDUsage_MSR_TrackData = 0x20,                        /* SF, DF, SEL - Track Data */
    kHIDUsage_MSR_Track1Data = 0x21,                       /* SF, DF, SEL - Track 1 Data */
    kHIDUsage_MSR_Track2Data = 0x22,                       /* SF, DF, SEL - Track 2 Data */
    kHIDUsage_MSR_Track3Data = 0x23,                       /* SF, DF, SEL - Track 3 Data */
    kHIDUsage_MSR_TrackJISData = 0x24                      /* SF, DF, SEL - Track JIS Data */
    /* Reserved 0x25 - 0xFFFF */
};

#endif /* _IOHIDUSAGETABLES_H */
                                                                                                                                                                                                                       hidevent/                                                                                           0040755 0001750 0001750 00000000000 12612224742 033626  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOHIDEventDriver.h                                                                                  0100644 0001750 0001750 00000026250 12567452123 037020  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidevent                                                       /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDEVENTDRIVER_H
#define _IOKIT_HID_IOHIDEVENTDRIVER_H

#include <IOKit/IOService.h>
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hid/IOHIDInterface.h>
#include <IOKit/hidevent/IOHIDEventService.h>


class DigitizerTransducer;
class EventElementCollection;
class IOHIDEvent;

/*! @class IOHIDEventDriver : public IOHIDEventService
    @abstract
    @discussion
*/
class IOHIDEventDriver: public IOHIDEventService
{
    OSDeclareDefaultStructors( IOHIDEventDriver )

private:
    IOHIDInterface *            _interface;
    void *                      _reservedVoid[3] __unused;
    
    OSArray *                   _supportedElements;
        
    UInt32                      _bootSupport;
    bool                        _multipleReports;
    bool                        _reservedBool   __unused;
    UInt32                      _reservedUInt32 __unused;
    bool                        _reservedBool1  __unused;
    
    
    struct ExpansionData {
        SInt32  absoluteAxisRemovalPercentage;
        SInt32  preferredAxisRemovalPercentage;
        
        struct {
            OSArray *           elements;
        } led;
        
        struct {
            OSArray *           elements;
        } scroll;
        
        struct {
            OSArray *           elements;
            bool                disabled;
        } relative;
        
        struct {
            OSArray *           elements;
            UInt8               bootMouseData[4];
        } keyboard;
        
        struct {
            IOHIDElement *      deviceModeElement;
            OSArray *           transducers;
            bool                native;
        } digitizer;
        
        struct {
            OSArray *           elements;

            UInt32              capable;
            UInt32              sendingReportID;
            IOFixed             axis[6];
            UInt32              buttonState;
            IOOptionBits        options;            
            bool                disabled;
        } multiAxis;
        
        struct {
            IOHIDElement *      gestureStateElement;
            OSArray *           legacyElements;
            OSArray *           gesturesCandidates;
        } unicode;
        
        struct {
            bool                extended;
            OSArray *           elements;
            UInt32              capable;
            UInt32              sendingReportID;
            
            struct {
                IOFixed up;
                IOFixed down;
                IOFixed left;
                IOFixed right;
            } dpad;
            
            struct {
                IOFixed x;
                IOFixed y;
                IOFixed a;
                IOFixed b;
            }face;
            
            struct {
                IOFixed x;
                IOFixed y;
                IOFixed z;
                IOFixed rz;
            } joystick;
            
            struct {
                IOFixed l1;
                IOFixed l2;
                IOFixed r1;
                IOFixed r2;
            } shoulder;

        } gameController;
        
    };
    ExpansionData *             _reserved;
    
    bool                    parseElements(OSArray * elementArray, UInt32 bootProtocol);
    bool                    parseRelativeElement(IOHIDElement * element);
    bool                    parseMultiAxisElement(IOHIDElement * element);
    bool                    parseGameControllerElement(IOHIDElement * element);
    bool                    parseDigitizerElement(IOHIDElement * element);
    bool                    parseDigitizerTransducerElement(IOHIDElement * element, IOHIDElement * parent=NULL);
    bool                    parseScrollElement(IOHIDElement * element);
    bool                    parseLEDElement(IOHIDElement * element);
    bool                    parseKeyboardElement(IOHIDElement * element);
    bool                    parseUnicodeElement(IOHIDElement * element);
    bool                    parseLegacyUnicodeElement(IOHIDElement * element);
    bool                    parseGestureUnicodeElement(IOHIDElement * element);
    
    void                    processDigitizerElements();
    void                    processMultiAxisElements();
    void                    processGameControllerElements();
    void                    processUnicodeElements();
    
    void                    setRelativeProperties();
    void                    setDigitizerProperties();
    void                    setGameControllerProperties();
    void                    setMultiAxisProperties();
    void                    setScrollProperties();
    void                    setLEDProperties();
    void                    setKeyboardProperties();
    void                    setUnicodeProperties();

    UInt32                  checkGameControllerElement(IOHIDElement * element);
    UInt32                  checkMultiAxisElement(IOHIDElement * element);
    
    static void             calibrateJustifiedPreferredStateElement(IOHIDElement * element, SInt32 removalPercentage);
    static void             calibrateCenteredPreferredStateElement(IOHIDElement * element, SInt32 removalPercentage);

    void                    handleBootPointingReport(AbsoluteTime timeStamp, IOMemoryDescriptor * report, UInt32 reportID);
    void                    handleRelativeReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleGameControllerReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleMultiAxisPointerReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleDigitizerReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleDigitizerTransducerReport(DigitizerTransducer * transducer, AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleScrollReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleKeboardReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleUnicodeReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleUnicodeLegacyReport(AbsoluteTime timeStamp, UInt32 reportID);
    void                    handleUnicodeGestureReport(AbsoluteTime timeStamp, UInt32 reportID);
    IOHIDEvent *            handleUnicodeGestureCandidateReport(EventElementCollection * candidate, AbsoluteTime timeStamp, UInt32 reportID);
    
    bool                    serializeCharacterGestureState(void * ref, OSSerialize * serializer);

protected:

    virtual void            free();
    
    virtual OSArray *       getReportElements();
    
    virtual bool            handleStart( IOService * provider );

    virtual void            handleStop(  IOService * provider );
    
    virtual void            handleInterruptReport (
                                AbsoluteTime                timeStamp,
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             reportType,
                                UInt32                      reportID);

    virtual OSString *      getTransport ();

    virtual UInt32          getLocationID ();

    virtual UInt32          getVendorID ();

    virtual UInt32          getVendorIDSource ();

    virtual UInt32          getProductID ();

    virtual UInt32          getVersion ();

    virtual UInt32          getCountryCode ();

    virtual OSString *      getManufacturer ();

    virtual OSString *      getProduct ();

    virtual OSString *      getSerialNumber ();

    virtual void            setElementValue (
                                UInt32                      usagePage,
                                UInt32                      usage,
                                UInt32                      value );
    
    virtual UInt32          getElementValue ( 
                                UInt32                      usagePage,
                                UInt32                      usage );

public:


    virtual bool            init( OSDictionary * dictionary = 0 );

    virtual bool            didTerminate(
                                IOService *                 provider,
                                IOOptionBits                options,
                                bool *                      defer );

    virtual IOReturn        setProperties( OSObject * properties );
    
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  0);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  1);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  2);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  3);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  4);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  5);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  6);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  7);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  8);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver,  9);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 10);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 11);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 12);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 13);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 14);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 15);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 16);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 17);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 18);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 19);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 20);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 21);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 22);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 23);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 24);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 25);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 26);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 27);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 28);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 29);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 30);
    OSMetaClassDeclareReservedUnused(IOHIDEventDriver, 31);

};

#endif /* !_IOKIT_HID_IOHIDEVENTDRIVER_H */
                                                                                                                                                                                                                                                                                                                                                        IOHIDEventService.h                                                                                 0100644 0001750 0001750 00000120345 12567452123 037165  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidevent                                                       /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2009 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDEVENTSERVICE_H
#define _IOKIT_HID_IOHIDEVENTSERVICE_H

#include <TargetConditionals.h>

#include <IOKit/IOService.h>
#include <IOKit/IOWorkLoop.h>
#include <IOKit/IOTimerEventSource.h>
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hid/IOHIDInterface.h>
#include <IOKit/hid/IOHIDElement.h>
#include <IOKit/hid/IOHIDKeys.h>

#if TARGET_OS_EMBEDDED
    #include <IOKit/hid/IOHIDEvent.h>
#endif

enum 
{
    kHIDDispatchOptionPointerNoAcceleration         = 0x01,
    kHIDDispatchOptionPointerDisplayIntegrated      = 0x02,
    kHIDDispatchOptionPointerAffixToScreen          = kHIDDispatchOptionPointerDisplayIntegrated,
    kHIDDispatchOptionPointerAbsolutToRelative      = 0x04
};

enum
{
    kHIDDispatchOptionScrollNoAcceleration              = (1<<0),

    kHIDDispatchOptionScrollMomentumAny                 = 0x00e,
    kHIDDispatchOptionScrollMomentumContinue            = (1<<1),
    kHIDDispatchOptionScrollMomentumStart               = (1<<2),
    kHIDDispatchOptionScrollMomentumEnd                 = (1<<3),
    
    kHIDDispatchOptionPhaseAny                          = 0xff0,
    kHIDDispatchOptionPhaseBegan                        = (1<<4),
    kHIDDispatchOptionPhaseChanged                      = (1<<5),
    kHIDDispatchOptionPhaseEnded                        = (1<<6),
    kHIDDispatchOptionPhaseCanceled                     = (1<<7),
    kHIDDispatchOptionPhaseMayBegin                     = (1<<11),
    
    kHIDDispatchOptionDeliveryNotificationForce         = (1<<30),
    kHIDDispatchOptionDeliveryNotificationSuppress      = (1<<31)
};

enum 
{
    kHIDDispatchOptionKeyboardNoRepeat                  = (1<<0)
};

class   IOHIDPointing;
class   IOHIDKeyboard;
class   IOHIDConsumer;
struct  TransducerData;

/*! @class IOHIDEventService : public IOService
 @abstract
 @discussion
 */
class IOHIDEventService: public IOService
{
    OSDeclareAbstractStructors( IOHIDEventService )
    
    friend class IOHIDPointing;
    friend class IOHIDKeyboard;
    friend class IOHIDConsumer;
    friend class AppleEmbeddedKeyboard;
    friend class IOHIDEventServiceUserClient;

private:
    IOHIDKeyboard *         _keyboardNub;
    IOHIDPointing *         _pointingNub;
    IOHIDConsumer *         _consumerNub;

    IONotifier *            _publishNotify;
    IORecursiveLock *       _nubLock;
    
    void *                  _reserved0;
    
    bool                    _readyForInputReports;
    
    struct ExpansionData {
        IOService *             provider;
        IOWorkLoop *            workLoop;
        OSArray *               deviceUsagePairs;
        IOCommandGate *         commandGate;
        
#if TARGET_OS_EMBEDDED
        OSDictionary *          clientDict;
#endif

        struct {
            UInt32                  deviceID;
            bool                    range;
            bool                    touch;
            SInt32                  x;
            SInt32                  y;
            SInt32                  z;
        } digitizer;

        struct {
            struct {
                UInt32                  delayMS;
                IOTimerEventSource *    timer;
                UInt32                  state;
                IOOptionBits            options;
            } eject;
            struct {
                UInt32                  delayMS;
                IOTimerEventSource *    timer;
                UInt32                  state;
                IOOptionBits            options;
            } caps;
            
#if TARGET_OS_EMBEDDED
            struct {
                UInt32                  startMask;
                UInt32                  mask;
                UInt32                  nmiMask;
                UInt32                  nmiDelay;
                IOTimerEventSource *    nmiTimer;
            } debug;

            bool                    swapISO;
#endif
            bool                    appleVendorSupported;
        } keyboard;
        
        struct {
            IOFixed                 x;
            IOFixed                 y;
            IOFixed                 z;
            IOFixed                 rX;
            IOFixed                 rY;
            IOFixed                 rZ;
            UInt32                  buttonState;
            IOOptionBits            options;
            IOTimerEventSource *    timer;
        } multiAxis;
        
        struct {
            UInt32                  buttonState;
        } relativePointer;


    };
    ExpansionData *         _reserved;
    
    IOHIDPointing *         newPointingShim (
                                UInt32          buttonCount         = 1,
                                IOFixed         pointerResolution   = (400 << 16),
                                IOFixed         scrollResolution    = 0,
                                IOOptionBits    options             = 0 );
                                
    IOHIDKeyboard *         newKeyboardShim (
                                UInt32          supportedModifiers  = 0,
                                IOOptionBits    options             = 0 );

    IOHIDConsumer *         newConsumerShim ( IOOptionBits options = 0 );
    
    void                    parseSupportedElements ( 
                                OSArray *                   elementArray, 
                                UInt32                      bootProtocol );
                                
    void                    processTabletElement ( IOHIDElement * element );

    IOFixed                 determineResolution ( IOHIDElement * element );
                                    
    static bool             _publishMatchingNotificationHandler(void * target, void * ref, IOService * newService, IONotifier * notifier);

    void                    ejectTimerCallback(IOTimerEventSource *sender);

    void                    capsTimerCallback(IOTimerEventSource *sender);
    
#if TARGET_OS_EMBEDDED
    void                    debuggerTimerCallback(IOTimerEventSource *sender);

    void                    stackshotTimerCallback(IOTimerEventSource *sender);
#endif
    
    void                    multiAxisTimerCallback(IOTimerEventSource *sender);

    void                    calculateCapsLockDelay();
    
    void                    calculateStandardType();

protected:

    virtual void            free();
        
/*! @function handleOpen
    @abstract Handle a client open on the interface.
    @discussion This method is called by IOService::open() with the
    arbitration lock held, and must return true to accept the client open.
    This method will in turn call handleClientOpen() to qualify the client
    requesting the open.
    @param client The client object that requested the open.
    @param options Options passed to IOService::open().
    @param argument Argument passed to IOService::open().
    @result true to accept the client open, false otherwise. */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       argument);

/*! @function handleClose
    @abstract Handle a client close on the interface.
    @discussion This method is called by IOService::close() with the
    arbitration lock held. This method will in turn call handleClientClose()
    to notify interested subclasses about the client close. If this represents
    the last close, then the interface will also close the controller before
    this method returns. The controllerWillClose() method will be called before
    closing the controller. Subclasses should not override this method.
    @param client The client object that requested the close.
    @param options Options passed to IOService::close(). */

    virtual void handleClose(IOService * client, IOOptionBits options);

/*! @function handleIsOpen
    @abstract Query whether a client has an open on the interface.
    @discussion This method is always called by IOService with the
    arbitration lock held. Subclasses should not override this method.
    @result true if the specified client, or any client if none (0) is
    specified, presently has an open on this object. */

    virtual bool handleIsOpen(const IOService * client) const;

/*! @function handleStart
    @abstract Prepare the hardware and driver to support I/O operations.
    @discussion IOHIDEventService will call this method from start() before
    any I/O operations are issued to the concrete subclass. Methods
    such as getReportElements() are only called after handleStart()
    has returned true. A subclass that overrides this method should
    begin its implementation by calling the version in super, and
    then check the return value.
    @param provider The provider argument passed to start().
    @result True on success, or false otherwise. Returning false will
    cause start() to fail and return false. */

    virtual bool            handleStart( IOService * provider );

/*! @function handleStop
    @abstract Quiesce the hardware and stop the driver.
    @discussion IOHIDEventService will call this method from stop() to
    signal that the hardware should be quiesced and the driver stopped.
    A subclass that overrides this method should end its implementation
    by calling the version in super.
    @param provider The provider argument passed to stop(). */

    virtual void            handleStop(  IOService * provider );
    
    virtual OSString *      getTransport ();
    virtual UInt32          getLocationID ();
    virtual UInt32          getVendorID ();
    virtual UInt32          getVendorIDSource ();
    virtual UInt32          getProductID ();
    virtual UInt32          getVersion ();
    virtual UInt32          getCountryCode ();
    virtual OSString *      getManufacturer ();
    virtual OSString *      getProduct ();
    virtual OSString *      getSerialNumber ();
    
    virtual OSArray *       getReportElements();

    virtual void            setElementValue (
                                UInt32                      usagePage,
                                UInt32                      usage,
                                UInt32                      value );
    
    virtual UInt32          getElementValue ( 
                                UInt32                      usagePage,
                                UInt32                      usage );
                                
    virtual void            dispatchKeyboardEvent(
                                AbsoluteTime                timeStamp,
                                UInt32                      usagePage,
                                UInt32                      usage,
                                UInt32                      value,
                                IOOptionBits                options = 0 );

    virtual void            dispatchRelativePointerEvent(
                                AbsoluteTime                timeStamp,
                                SInt32                      dx,
                                SInt32                      dy,
                                UInt32                      buttonState,
                                IOOptionBits                options = 0 );
    
    virtual void            dispatchAbsolutePointerEvent(
                                AbsoluteTime                timeStamp,
                                SInt32                      x,
                                SInt32                      y,
                                IOGBounds *                 bounds,
                                UInt32                      buttonState,
                                bool                        inRange,
                                SInt32                      tipPressure,
                                SInt32                      tipPressureMin,
                                SInt32                      tipPressureMax,
                                IOOptionBits                options = 0 );

    virtual void            dispatchScrollWheelEvent(
                                AbsoluteTime                timeStamp,
                                SInt32                      deltaAxis1,
                                SInt32                      deltaAxis2,
                                SInt32                      deltaAxis3,
                                IOOptionBits                options = 0 );

    virtual void            dispatchTabletPointerEvent(
                                AbsoluteTime                timeStamp,
                                UInt32                      transducerID,
                                SInt32                      x,
                                SInt32                      y,
                                SInt32                      z,
                                IOGBounds *                 bounds,
                                UInt32                      buttonState,
                                SInt32                      tipPressure,
                                SInt32                      tipPressureMin,
                                SInt32                      tipPressureMax,
                                SInt32                      barrelPressure,
                                SInt32                      barrelPressureMin,
                                SInt32                      barrelPressureMax,
                                SInt32                      tiltX,
                                SInt32                      tiltY,
                                UInt32                      twist,
                                IOOptionBits                options = 0 );

    virtual void            dispatchTabletProximityEvent(
                                AbsoluteTime                timeStamp,
                                UInt32                      transducerID,
                                bool                        inRange,
                                bool                        invert,
                                UInt32                      vendorTransducerUniqueID        = 0,
                                UInt32                      vendorTransducerSerialNumber    = 0,
                                IOOptionBits                options                         = 0 );

public:
    bool                    readyForReports();

    virtual bool            init(OSDictionary * properties = 0);

    virtual bool            start( IOService * provider );
    
    virtual void            stop( IOService * provider );

    virtual bool            matchPropertyTable(OSDictionary * table, SInt32 * score);    
    
    virtual IOReturn        setSystemProperties( OSDictionary * properties );
    
    virtual IOReturn        setProperties( OSObject * properties );
    
protected:
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  0);
    virtual OSArray *       getDeviceUsagePairs();
    
        
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  1);
    virtual UInt32          getReportInterval();

    OSMetaClassDeclareReservedUsed(IOHIDEventService,  2);
    enum {
        kMultiAxisOptionRotationForTranslation  = (1<<0),
        kMultiAxisOptionZForScroll              = (1<<1)
    };
/*!
    @function dispatchMultiAxisPointerEvent
    @abstract Dispatch multi-axis pointer event
    @discussion This is meant to be used with joysticks or multi-axis pointer devices such as those with
                with 6 degrees of freedom.  This function will generate related relative pointer and scroll
                event associated with movement.
    @param timeStamp    AbsoluteTime representing origination of event
    @param buttonState  Button mask where bit0 is the primary button, bit1 secondary and so forth
    @param x            Absolute location of pointer along the x-axis from -1.0 to 1.0 in 16:16 fixed point.
    @param y            Absolute location of pointer along the y-axis from -1.0 to 1.0 in 16:16 fixed point.
    @param z            Absolute location of pointer along the z-axis from -1.0 to 1.0 in 16:16 fixed point.
    @param rX           Absolute rotation of pointer around the x-axis from -1.0 to 1.0 in 16:16 fixed point.
    @param rY           Absolute rotation of pointer around the y-axis from -1.0 to 1.0 in 16:16 fixed point.
    @param rZ           Absolute rotation of pointer around the z-axis from -1.0 to 1.0 in 16:16 fixed point.
    @param options      Additional options to be used when dispatching event such as leveraging rotational
                        axis for translation or using the z axis for vertical scrolling.
*/
    virtual void            dispatchMultiAxisPointerEvent(
                                AbsoluteTime                timeStamp,
                                UInt32                      buttonState,
                                IOFixed                     x,
                                IOFixed                     y,
                                IOFixed                     z,
                                IOFixed                     rX      = 0,
                                IOFixed                     rY      = 0,
                                IOFixed                     rZ      = 0,
                                IOOptionBits                options = 0 );

    enum {
        kDigitizerInvert = (1<<0),
        
        kDigitizerCapabilityButtons             = (1<<16),
        kDigitizerCapabilityPressure            = (1<<16),
        kDigitizerCapabilityTangentialPressure  = (1<<16),
        kDigitizerCapabilityZ                   = (1<<16),
        kDigitizerCapabilityTiltX               = (1<<16),
        kDigitizerCapabilityTiltY               = (1<<16),
        kDigitizerCapabilityTwist               = (1<<16),
    };
    
    enum {
        kDigitizerTransducerTypeStylus = 0,
        kDigitizerTransducerTypePuck,
        kDigitizerTransducerTypeFinger,
        kDigitizerTransducerTypeHand
    };
    typedef UInt32 DigitizerTransducerType;
    
/*!
    @function dispatchDigitizerEvent
    @abstract Dispatch tablet events without orientation
    @discussion This is meant to be used with transducers without any orientation.
    @param timeStamp    AbsoluteTime representing origination of event
    @param ID           ID of the transducer generating the event
    @param type         Type of the transducer generating the event
    @param inRange      Details whether the transducer is in promitity to digitizer surface
    @param buttonState  Button mask where bit0 is the primary button, bit1 secondary and so forth
    @param x            Absolute location of transducer along the x-axis from 0.0 to 1.0 in
                        16:16 fixed point.
    @param y            Absolute location of transducer along the y-axis from 0.0 to 1.0 in
                        16:16 fixed point.
    @param z            Absolute location of transducer along the z-axis from 0.0 to 1.0 in
                        16:16 fixed point. This is typically used to determine the distance
                        between the transducer and surface
    @param tipPressure  Absolute pressure exerted on surface by tip from 0.0 to 1.0 in 16:16
                        fixed point.
    @param auxPressure  Absolute pressure exerted on transducer from 0.0 to 1.0 in 16:16 fixed point.
    @param options      Additional options to be used when dispatching event.
*/
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  3);
    virtual void            dispatchDigitizerEvent(
                                AbsoluteTime                    timeStamp,
                                UInt32                          transducerID,
                                DigitizerTransducerType         type,
                                bool                            inRange,
                                UInt32                          buttonState,
                                IOFixed                         x,
                                IOFixed                         y,
                                IOFixed                         z               = 0,
                                IOFixed                         tipPressure     = 0,
                                IOFixed                         auxPressure     = 0,
                                IOFixed                         twist           = 0,
                                IOOptionBits                    options         = 0 );

/*! 
    @function dispatchDigitizerEventWithTiltOrientation
    @abstract Dispatch tablet events with tilt orientation
    @discussion This is meant to be used with transducers that leverage tilt orientation
    @param timeStamp    AbsoluteTime representing origination of event
    @param ID           ID of the transducer generating the event 
    @param type         Type of the transducer generating the event
    @param inRange      Details whether the transducer is in promitity to digitizer surface
    @param buttonState  Button mask where bit0 is the primary button, bit1 secondary and so forth
    @param x            Absolute location of transducer along the x-axis from 0.0 to 1.0 in 
                        16:16 fixed point.
    @param y            Absolute location of transducer along the y-axis from 0.0 to 1.0 in
                        16:16 fixed point.
    @param z            Absolute location of transducer along the z-axis from 0.0 to 1.0 in
                        16:16 fixed point. This is typically used to determine the distance 
                        between the transducer and surface
    @param tipPressure  Absolute pressure exerted on surface by tip from 0.0 to 1.0 in 16:16 
                        fixed point.
    @param auxPressure  Absolute pressure exerted on transducer from 0.0 to 1.0 in 16:16 fixed point.
    @param twist        Absolute clockwise rotation along the transducer's major axis from 0.0 to 
                        360.0 degrees in 16:16 fixed point.
    @param tiltX        Absolute plane angle between the Y-Z plane and the plane containing the
                        transducer axis and the Y axis.  A positive X tilt is to the right.  Value is
                        represented in degrees from -90.0 to 90.0 in 16:16 fixed point.
    @param tiltY        Absolute plane angle between the X-Z plane and the plane containing the
                        transducer axis and the X axis.  A positive Y tilt is towards the user.  Value
                        is represented in degrees from -90.0 to 90.0 in 16:16 fixed point.
    @param options      Additional options to be used when dispatching event. 
*/
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  4);
    virtual void            dispatchDigitizerEventWithTiltOrientation(
                                AbsoluteTime                    timeStamp,
                                UInt32                          ID,
                                DigitizerTransducerType         type,
                                bool                            inRange,
                                UInt32                          buttonState,
                                IOFixed                         x,
                                IOFixed                         y,
                                IOFixed                         z               = 0,
                                IOFixed                         tipPressure     = 0, // 0.0-1.0 in 16:16 fixed
                                IOFixed                         auxPressure     = 0, // 0.0-1.0 in 16:16 fixed
                                IOFixed                         twist           = 0,
                                IOFixed                         tiltX           = 0,
                                IOFixed                         tiltY           = 0,
                                IOOptionBits                    options         = 0 );

/*!
    @function dispatchDigitizerEventWithPolarOrientation
    @abstract Dispatch tablet events with polar orientation
    @discussion This is meant to be used with transducers that leverage polar orientation
    @param timeStamp    AbsoluteTime representing origination of event
    @param ID           ID of the transducer generating the event
    @param type         Type of the transducer generating the event
    @param inRange      Details whether the transducer is in promitity to digitizer surface
    @param buttonState  Button mask where bit0 is the primary button, bit1 secondary and so forth
    @param x            Absolute location of transducer along the x-axis from 0.0 to 1.0 in
                        16:16 fixed point.
    @param y            Absolute location of transducer along the y-axis from 0.0 to 1.0 in
                        16:16 fixed point.
    @param z            Absolute location of transducer along the z-axis from 0.0 to 1.0 in
                        16:16 fixed point. This is typically used to determine the distance
                        between the transducer and surface
    @param tipPressure  Absolute pressure exerted on surface by tip from 0.0 to 1.0 in 16:16
                        fixed point.
    @param auxPressure  Absolute pressure exerted on transducer from 0.0 to 1.0 in 16:16 fixed point.
    @param twist        Absolute clockwise rotation along the transducer's major axis from 0.0 to
                        360.0 degrees in 16:16 fixed point.
    @param altitude     Specifies angle with the X-Y plane thorugh a signed, semicircular range.
                        Positive values specify an angle downward and toward the positive Z axis.
                        Value is represented in degrees from -180.0 to 180.0 in 16:16 fixed point.
    @param azimuth      Counter clockwise rotation of the cursor around the Z-axis through a full
                        circular range.  Value is represented in degrees from 0.0 to 360.0 in 16:16 
                        fixed point.
    @param options      Additional options to be used when dispatching event.
*/
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  5);
    virtual void            dispatchDigitizerEventWithPolarOrientation(
                                AbsoluteTime                    timeStamp,
                                UInt32                          transducerID,
                                DigitizerTransducerType         type,
                                bool                            inRange,
                                UInt32                          buttonState,
                                IOFixed                         x,
                                IOFixed                         y,
                                IOFixed                         z               = 0,
                                IOFixed                         tipPressure     = 0, // 0.0-1.0 in 16:16 fixed
                                IOFixed                         tanPressure     = 0, // 0.0-1.0 in 16:16 fixed
                                IOFixed                         twist           = 0,
                                IOFixed                         altitude        = 0,
                                IOFixed                         azimuth         = 0,
                                IOOptionBits                    options         = 0 );
    
    /*!
     @function dispatchUnicodeEvent
     @abstract Dispatch unicode events
     @discussion The HID specificiation provides a means to dispatch unicode characters from HID
     compliant devices.  The original method was to leverage the unicode page to deliver UTF-16 LE
     characters by way of a usage page selector.
     @param timeStamp   AbsoluteTime representing origination of event
     @param length      Length of unicode payload
     @param payload     character payload
     @param quality     A fixed point value from 0.0 to 1.0 that represents that quality/confidence of the event.
     @param options     Additional options to be used when dispatching event.
     */
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  6);
    enum {
        kUnicodeEncodingTypeUTF8    = 0,
        kUnicodeEncodingTypeUTF16LE,
        kUnicodeEncodingTypeUTF16BE,
        kUnicodeEncodingTypeUTF32LE,
        kUnicodeEncodingTypeUTF32BE,
    };
    typedef UInt32 UnicodeEncodingType;

    virtual void            dispatchUnicodeEvent(
                                                 AbsoluteTime               timeStamp,
                                                 UInt8 *                    payload,
                                                 UInt32                     length,
                                                 UnicodeEncodingType        encoding    = kUnicodeEncodingTypeUTF16LE,
                                                 IOFixed                    quality     = (1<<16),
                                                 IOOptionBits               options     = 0);

    
private:
    enum {
        kDigitizerOrientationTypeTilt = 0,
        kDigitizerOrientationTypePolar,
        kDigitizerOrientationTypeQuality
    };
    typedef UInt32 DigitizerOrientationType;
    
    void            dispatchDigitizerEventWithOrientation(
                                AbsoluteTime                    timeStamp,
                                UInt32                          transducerID,
                                DigitizerTransducerType         type,
                                bool                            inRange,
                                UInt32                          buttonState,
                                IOFixed                         x,
                                IOFixed                         y,
                                IOFixed                         z                       = 0,
                                IOFixed                         tipPressure             = 0,
                                IOFixed                         auxPressure             = 0,
                                IOFixed                         twist                   = 0,
                                DigitizerOrientationType        orientationType         = kDigitizerOrientationTypeTilt,
                                IOFixed *                       orientationParams       = NULL,
                                UInt32                          orientationParamCount   = 0,
                                IOOptionBits                    options                 = 0 );
    



#if TARGET_OS_EMBEDDED
public:
    typedef void (*Action)(OSObject *target, OSObject * sender, void *context, OSObject *event, IOOptionBits options);

    OSMetaClassDeclareReservedUsed(IOHIDEventService,  7);
    virtual bool            open(
                                IOService *                 client,
                                IOOptionBits                options,
                                void *                      context,
                                Action                      action);
                                
protected:    
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  8);
    virtual void            dispatchEvent(IOHIDEvent * event, IOOptionBits options=0);

    OSMetaClassDeclareReservedUsed(IOHIDEventService,  9);
    virtual UInt32          getPrimaryUsagePage();
    
    OSMetaClassDeclareReservedUsed(IOHIDEventService, 10);
    virtual UInt32          getPrimaryUsage();
    
public:
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  11);
    virtual IOHIDEvent *    copyEvent(
                                IOHIDEventType              type, 
                                IOHIDEvent *                matching = 0,
                                IOOptionBits                options = 0);
    
protected:
    /*!
     @function dispatchStandardGameControllerEvent
     @abstract Dispatch standard game controller event
     @discussion This is meant to dispatch a conforming standard game controller event that includes the
     following: Direction Pad, Face Buttons, and Left and Right Shoulder Buttons.
     @param timeStamp   AbsoluteTime representing origination of event
     @param dpadUp      Direction pad up with a fixed value between 0.0 and 1.0
     @param dpadDown    Direction pad down with a fixed value between 0.0 and 1.0
     @param dpadLeft    Direction pad left with a fixed value between 0.0 and 1.0
     @param dpadRight   Direction pad right with a fixed value between 0.0 and 1.0
     @param faceX       Face button X with a fixed value between 0.0 and 1.0
     @param faceY       Face button Y with a fixed value between 0.0 and 1.0
     @param faceA       Face button A with a fixed value between 0.0 and 1.0
     @param faceB       Face button B with a fixed value between 0.0 and 1.0
     @param shoulderL   Left shoulder button with a fixed value between 0.0 and 1.0
     @param shoulderR   Right shoulder button with a fixed value between 0.0 and 1.0
     @param options     Additional options to be defined.
     */
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  12);
    virtual void            dispatchStandardGameControllerEvent(
                                                                AbsoluteTime                    timeStamp,
                                                                IOFixed                         dpadUp,
                                                                IOFixed                         dpadDown,
                                                                IOFixed                         dpadLeft,
                                                                IOFixed                         dpadRight,
                                                                IOFixed                         faceX,
                                                                IOFixed                         faceY,
                                                                IOFixed                         faceA,
                                                                IOFixed                         faceB,
                                                                IOFixed                         shoulderL,
                                                                IOFixed                         shoulderR,
                                                                IOOptionBits                    options         = 0 );
    
    /*!
     @function dispatchExtendedGameControllerEvent
     @abstract Dispatch extended game controller event
     @discussion This is meant to dispatch a conforming extended game controller event that includes the
     following: Direction Pad, Face Buttons, Left and Right Joysticks and 2 Left and 2 Right Shoulder Buttons.
     @param timeStamp   AbsoluteTime representing origination of event
     @param dpadUp      Direction pad up with a fixed value between 0.0 and 1.0
     @param dpadDown    Direction pad down with a fixed value between 0.0 and 1.0
     @param dpadLeft    Direction pad left with a fixed value between 0.0 and 1.0
     @param dpadRight   Direction pad right with a fixed value between 0.0 and 1.0
     @param faceX       Face button X with a fixed value between 0.0 and 1.0
     @param faceY       Face button Y with a fixed value between 0.0 and 1.0
     @param faceA       Face button A with a fixed value between 0.0 and 1.0
     @param faceB       Face button B with a fixed value between 0.0 and 1.0
     @param shoulderL1  Top left shoulder button with a fixed value between 0.0 and 1.0
     @param shoulderR1  Top right shoulder button with a fixed value between 0.0 and 1.0
     @param shoulderL2  Bottom left shoulder button with a fixed value between 0.0 and 1.0
     @param shoulderR2  Bottom right shoulder button with a fixed value between 0.0 and 1.0
     @param joystickX   Joystick X axis with a fixed value between -1.0 and 1.0
     @param joystickY   Joystick Y axis with a fixed value between -1.0 and 1.0
     @param joystickZ   Joystick Z axis with a fixed value between -1.0 and 1.0
     @param joystickRz  Joystick Rz axis with a fixed value between -1.0 and 1.0
     @param options     Additional options to be defined.
     */
    OSMetaClassDeclareReservedUsed(IOHIDEventService,  13);
    virtual void            dispatchExtendedGameControllerEvent(
                                                                AbsoluteTime                    timeStamp,
                                                                IOFixed                         dpadUp,
                                                                IOFixed                         dpadDown,
                                                                IOFixed                         dpadLeft,
                                                                IOFixed                         dpadRight,
                                                                IOFixed                         faceX,
                                                                IOFixed                         faceY,
                                                                IOFixed                         faceA,
                                                                IOFixed                         faceB,
                                                                IOFixed                         shoulderL1,
                                                                IOFixed                         shoulderR1,
                                                                IOFixed                         shoulderL2,
                                                                IOFixed                         shoulderR2,
                                                                IOFixed                         joystickX,
                                                                IOFixed                         joystickY,
                                                                IOFixed                         joystickZ,
                                                                IOFixed                         joystickRz,
                                                                IOOptionBits                    options         = 0 );
    

#else
    OSMetaClassDeclareReservedUnused(IOHIDEventService,  7);
    OSMetaClassDeclareReservedUnused(IOHIDEventService,  8);
    OSMetaClassDeclareReservedUnused(IOHIDEventService,  9);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 10);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 11);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 12);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 13);
#endif
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 14);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 15);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 16);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 17);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 18);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 19);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 20);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 21);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 22);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 23);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 24);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 25);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 26);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 27);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 28);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 29);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 30);
    OSMetaClassDeclareReservedUnused(IOHIDEventService, 31);
    
#if TARGET_OS_EMBEDDED
public:
    virtual void            close( IOService * forClient, IOOptionBits options = 0 );
    
private:
    bool                    openGated( IOService *client, IOOptionBits *pOptions, void *context, Action action);
    void                    closeGated( IOService * forClient, IOOptionBits *pOptions);
#endif

};

#endif /* !_IOKIT_HID_IOHIDEVENTSERVICE_H */
                                                                                                                                                                                                                                                                                           hidsystem/                                                                                          0040755 0001750 0001750 00000000000 12612224742 034031  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOHIDDescriptorParser.h                                                                             0100644 0001750 0001750 00000146716 12567452123 040273  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2012 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __IOHIDDescriptorParser__
#define __IOHIDDescriptorParser__

#include <TargetConditionals.h>
#include <IOKit/IOTypes.h>
#include <IOKit/hidsystem/IOHIDUsageTables.h>

#ifdef __cplusplus
extern "C" {
#endif

#if TARGET_OS_EMBEDDED
/* Types and enums required by these functions but not in IOTypes.h */

typedef UInt8		Byte;
typedef SInt8		SignedByte;
typedef unsigned long	FourCharCode;
typedef FourCharCode	OSType;

enum {
	noErr	= 0
};
#endif

/* End missing types and enums */

enum
{
	kHIDSuccess						= 0,
	
/* HID assigned error numbers are -13949 .. -13900 */
	kHIDBaseError					= -13950,

	kHIDNullStateErr,
	kHIDBufferTooSmallErr,
	kHIDValueOutOfRangeErr,
	kHIDUsageNotFoundErr,
	kHIDNotValueArrayErr,
	kHIDInvalidPreparsedDataErr,
	kHIDIncompatibleReportErr,
	kHIDBadLogPhysValuesErr,
	kHIDInvalidReportTypeErr,
	kHIDInvalidReportLengthErr,
	kHIDNullPointerErr,
	kHIDBadParameterErr,
	kHIDNotEnoughMemoryErr,
	kHIDEndOfDescriptorErr,
	kHIDUsagePageZeroErr,
	kHIDBadLogicalMinimumErr,
	kHIDBadLogicalMaximumErr,
	kHIDInvertedLogicalRangeErr,
	kHIDInvertedPhysicalRangeErr,
	kHIDUnmatchedUsageRangeErr,
	kHIDInvertedUsageRangeErr,
	kHIDUnmatchedStringRangeErr,
	kHIDUnmatchedDesignatorRangeErr,
	kHIDReportSizeZeroErr,
	kHIDReportCountZeroErr,
	kHIDReportIDZeroErr,
	kHIDInvalidRangePageErr,

	// 
	// HID device driver errors 
	//
	
	kHIDDeviceNotReady 		= -13910, 		// The device is still initializing, try again later
	kHIDVersionIncompatibleErr,
};

// types of HID reports (input, output, feature)
enum
{
	kHIDInputReport			= 	1,
	kHIDOutputReport,
	kHIDFeatureReport,
	kHIDUnknownReport		=	255
};

// flags passed to HIDOpenReportDescriptor
enum
{
	kHIDFlag_StrictErrorChecking = 0x00000001
};

typedef UInt32	HIDReportType;
typedef UInt32	HIDUsage;

typedef void *HIDPreparsedDataRef;

/*!
  @typedef HIDUsageAndPage
  @abstract The HIDUsageAndPage data structure is used by HID clients when obtaining status of buttons to hold the usage page and usage of a button that is down.
  @discussion Clients use the HIDUSageAndPage structure with the HIDGetButtonsEx function to obtain both the usage page and usage identifiers of each button that is down.
  @field usage Specifies the usage identifier within the usage page specified by usagePage of a button that is down.
  @field usagePage Specifies the usage page identifier of a button that is down.
 */
struct HIDUsageAndPage
{
	HIDUsage	usage;
	HIDUsage	usagePage;
};
typedef struct HIDUsageAndPage HIDUsageAndPage, *HIDUsageAndPagePtr;

/*!
  @typedef HIDCaps
  @abstract The HIDCaps data structure is used by HID clients to hold the capabilities of a HID device.
  @discussion This structure holds the parsed capabilities and data maximums returned for a device by the HIDGetCaps function.
  @field usage Specifies the specific class of functionality that this device provides.  This value is dependent and specific to the value provided in the usagePage field.  For example, a keyboard could have a usagePage of kHIDUsagePage_Generic and a usage of kHIDUsage_Generic_Keyboard.
  @field usagePage Specifies the usage page identifier for this top level collection.
  @field inputReportByteLength Specifies the maximum length, in bytes, of an input report for this device, including the report ID which is unilaterally prepended to the device data.
  @field outputReportByteLength Specifies the maximum length, in bytes, of an output report for this device, including the report ID which is unilaterally prepended to the device data.
  @field featureReportByteLength Specifies the maximum length, in bytes, of a feature report for this device, including the report ID which is unilaterally prepended to the device data.
  @field numberCollectionNodes Specifies the number of HIDCollectionNode structures that are returned for this top level collection by the HIDGetConnectionNodes function.
  @field numberInputButtonCaps Specifies the number of input buttons.
  @field numberInputValueCaps Specifies the number of input values.
  @field numberOutputButtonCaps Specifies the number of output buttons.
  @field numberOutputValueCaps Specifies the number of output values
  @field numberFeatureButtonCaps Specifies the number of feature buttons.
  @field numberFeatureValueCaps Specifies the number of feature values.
 */
struct HIDCaps
{
	HIDUsage		usage;
	HIDUsage		usagePage;
	IOByteCount		inputReportByteLength;
	IOByteCount		outputReportByteLength;
	IOByteCount		featureReportByteLength;
	UInt32			numberCollectionNodes;
	UInt32			numberInputButtonCaps;
	UInt32			numberInputValueCaps;
	UInt32			numberOutputButtonCaps;
	UInt32			numberOutputValueCaps;
	UInt32			numberFeatureButtonCaps;
	UInt32			numberFeatureValueCaps;
};
typedef struct HIDCaps HIDCaps, * HIDCapsPtr;

struct HIDCapabilities {
    HIDUsage                        usage;
    HIDUsage                        usagePage;
    IOByteCount						inputReportByteLength;
    IOByteCount						outputReportByteLength;
    IOByteCount						featureReportByteLength;
    UInt32                          numberCollectionNodes;
    UInt32                          numberInputButtonCaps;
    UInt32                          numberInputValueCaps;
    UInt32                          numberOutputButtonCaps;
    UInt32                          numberOutputValueCaps;
    UInt32                          numberFeatureButtonCaps;
    UInt32                          numberFeatureValueCaps;
};
typedef struct HIDCapabilities HIDCapabilities, * HIDCapabilitiesPtr;


struct HIDCollectionNode
{
	HIDUsage	collectionUsage;
	HIDUsage	collectionUsagePage;
	UInt32		parent;
	UInt32		numberOfChildren;
	UInt32		nextSibling;
	UInt32		firstChild;
};
typedef struct HIDCollectionNode HIDCollectionNode, * HIDCollectionNodePtr;

struct HIDButtonCaps
{
	HIDUsage	usagePage;
	UInt32		reportID;
	UInt32		bitField;
	UInt32		collection;
	HIDUsage	collectionUsage;
	HIDUsage	collectionUsagePage;
	Boolean		isRange;
	Boolean		isStringRange;
	Boolean		isDesignatorRange;
	Boolean		isAbsolute;
        SInt32 startBit;	// Added esb 9-29-99

	union
	{
		struct
		{
			HIDUsage		usageMin;
			HIDUsage		usageMax;
			UInt32			stringMin;
			UInt32			stringMax;
			UInt32			designatorMin;
			UInt32			designatorMax;
		} range;
		struct
		{
			HIDUsage		usage;
			HIDUsage		reserved1;
			UInt32			stringIndex;
			UInt32			reserved2;
			UInt32			designatorIndex;
			UInt32			reserved3;
		} notRange;
	} u;
};
typedef struct HIDButtonCaps HIDButtonCaps, * HIDButtonCapsPtr;

struct HIDButtonCapabilities
{
	HIDUsage	usagePage;
	UInt32		reportID;
	UInt32		bitField;
	UInt32		collection;
	HIDUsage	collectionUsage;
	HIDUsage	collectionUsagePage;
	Boolean		isRange;
	Boolean		isStringRange;
	Boolean		isDesignatorRange;
	Boolean		isAbsolute;

    SInt32                          unitExponent;	// Added KH 1/25/01
    SInt32                          units;			// Added KH 1/25/01
//    UInt32                          reserved;		// Not added KH 1/25/01
        SInt32 startBit;	// Added esb 9-29-99
    UInt32                          pbVersion;		// Added KH 1/25/01

	union
	{
		struct
		{
			HIDUsage		usageMin;
			HIDUsage		usageMax;
			UInt32			stringMin;
			UInt32			stringMax;
			UInt32			designatorMin;
			UInt32			designatorMax;
		} range;
		struct
		{
			HIDUsage		usage;
			HIDUsage		reserved1;
			UInt32			stringIndex;
			UInt32			reserved2;
			UInt32			designatorIndex;
			UInt32			reserved3;
		} notRange;
	} u;
};
typedef struct HIDButtonCapabilities HIDButtonCapabilities, * HIDButtonCapabilitiesPtr;

struct HIDValueCaps
{
	HIDUsage	usagePage;
	UInt32		reportID;
	UInt32		bitField;
	UInt32		collection;
	HIDUsage	collectionUsage;
	HIDUsage	collectionUsagePage;

	Boolean		isRange;
	Boolean		isStringRange;
	Boolean		isDesignatorRange;
	Boolean		isAbsolute;

        UInt32		startBit;	// Added by esb 9-28-99
	UInt32		bitSize;
	UInt32		reportCount;

	SInt32		logicalMin;
	SInt32		logicalMax;
	SInt32		physicalMin;
	SInt32		physicalMax;
	
	union
	{
		struct
		{
			HIDUsage		usageMin;
			HIDUsage		usageMax;
			UInt32			stringMin;
			UInt32			stringMax;
			UInt32			designatorMin;
			UInt32			designatorMax;
		} range;
		struct
		{
			HIDUsage		usage;
			HIDUsage		reserved1;
			UInt32			stringIndex;
			UInt32			reserved2;
			UInt32			designatorIndex;
			UInt32			reserved3;
		} notRange;
	} u;
};
typedef struct HIDValueCaps HIDValueCaps, * HIDValueCapsPtr;

struct HIDValueCapabilities
{
	HIDUsage	usagePage;
	UInt32		reportID;
	UInt32		bitField;
	UInt32		collection;
	HIDUsage	collectionUsage;
	HIDUsage	collectionUsagePage;

	Boolean		isRange;
	Boolean		isStringRange;
	Boolean		isDesignatorRange;
	Boolean		isAbsolute;

	UInt32		bitSize;
	UInt32		reportCount;

	SInt32		logicalMin;
	SInt32		logicalMax;
	SInt32		physicalMin;
	SInt32		physicalMax;
	
    SInt32                          unitExponent;	// Added KH 1/25/01
    SInt32                          units;			// Added KH 1/25/01
//    UInt32                          reserved;		// Not added KH 1/25/01
        SInt32 startBit;	// Added esb 9-29-99	// Moved here KH 1/25/01
    UInt32                          pbVersion;		// Added KH 1/25/01

	union
	{
		struct
		{
			HIDUsage		usageMin;
			HIDUsage		usageMax;
			UInt32			stringMin;
			UInt32			stringMax;
			UInt32			designatorMin;
			UInt32			designatorMax;
		} range;
		struct
		{
			HIDUsage		usage;
			HIDUsage		reserved1;
			UInt32			stringIndex;
			UInt32			reserved2;
			UInt32			designatorIndex;
			UInt32			reserved3;
		} notRange;
	} u;
};
typedef struct HIDValueCapabilities HIDValueCapabilities, * HIDValueCapabilitiesPtr;

/*!
  @function HIDOpenReportDescriptor
  @abstract The HIDOpenReportDescriptor function allocates the memory the parser needs to handle the given report descriptor, and then parses the report descriptor.
  @discussion When the parsed information is no longer needed, clients should call the HIDCloseReportDescriptor function.
  @param hidReportDescriptor Contains a pointer to the actual HID report descriptor from the USB device's firmware
  @param descriptorLength The length of the HID report descriptor
  @param preparsedDataRef Preparsed data reference to be used for subsequent function calls
  @param flags Flags for this runction are kHIDFlag_StrictErrorChecking = 0x00000001
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDOpenReportDescriptor	   (void *					hidReportDescriptor,
							IOByteCount				descriptorLength,
							HIDPreparsedDataRef *	preparsedDataRef,
							UInt32					flags);

/*!
  @function HIDCloseReportDescriptor
  @abstract Disposes of the memory the parser allocated for the HIDOpenReportDescriptor function.
  @param hidReportDescriptor Contains a pointer to the actual HID report descriptor from the USB device's firmware
  @param preparsedDataRef Preparsed data reference for the report that is returned by the HIDOpenReportDescriptor function.  After making a call to the HIDCloseReportDescriptor function, the preparsedDataRef is invalid and should not be used.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDCloseReportDescriptor   (HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetButtonCaps
  @abstract Returns the button capabilities structures for a HID device based on the given preparsed data.
 @param reportType Specifies the type of report for which to retrieve the scaled value.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport
  @param buttonCaps Points to a caller-allocated buffer that will contain, on return, an array of HIDButtonCaps structures.  The structures contain information for all buttons that meet the search criteria
  @param buttonCapsSize Contains the size of the buttonCaps array passed in to the function and is set to the number of elements actually placed in the array after the call completes.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetButtonCaps		   (HIDReportType			reportType,
							HIDButtonCapsPtr		buttonCaps,
							UInt32	*				buttonCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetButtonCapabilities
  @abstract Returns the button capabilities structures for a HID device based on the given preparsed data.
 @param reportType Specifies the type of report for which to retrieve the scaled value.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport
  @param buttonCaps Points to a caller-allocated buffer that will contain, on return, an array of HIDButtonCapabilities structures.  The structures contain information for all buttons that meet the search criteria
  @param buttonCapsSize Contains the size of the buttonCaps array passed in to the function and is set to the number of elements actually placed in the array after the call completes.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetButtonCapabilities   (HIDReportType			reportType,
							HIDButtonCapabilitiesPtr	buttonCaps,
							UInt32	*				buttonCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetCaps
  @abstract Returns the capabilities of a HID device based on the given preparsed data.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param capabilities Points to a caller allocated buffer, that upon return contains the parsed capability information for this HID device.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetCaps				   (HIDPreparsedDataRef		preparsedDataRef,
							HIDCapsPtr				capabilities);

/*!
  @function HIDGetCapabilities
  @abstract Returns the capabilities of a HID device based on the given preparsed data.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param capabilities Points to a caller allocated buffer, that upon return contains the parsed capability information for this HID device.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetCapabilities		   (HIDPreparsedDataRef		preparsedDataRef,
							HIDCapabilitiesPtr		capabilities);

/*!
  @function HIDGetCollectionNodes
  @abstract Returns an array of HIDCollectionNode structures that describe the relationships and layout of the link collections within this top level collection.
  @discussion The length of the buffer required, in array elements, for an entire collection node array is found in the HIDCaps structure member numberCollectionNodes.  You obtain the HIDCaps information by calling the HIDGetCaps function.  For information on the relationships of link collections described by the data returned from this routine, see the descripton of the HIDCollectionNode structure.
  @param collectionNodes Points to a caller-allocated array of HIDCollectionNode structures in which this routine returns an entry for each collection within the top level collection.  A collection is a group of corresponding HID descriptors containing input, output, and feature items that have some common relationship to one another.  For example, a pointer collection contains items for x and y position data, and button data.
  @param collectionNodesSize On input, specifies the length in array elements of the buffer provided at collectionNodes.  On output, this parameter is set to the number of entries in the collectionNodes array that were initialized.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetCollectionNodes	   (HIDCollectionNodePtr	collectionNodes,
							UInt32 *				collectionNodesSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetScaledUsageValue
  @abstract The HIDGetScaledUsageValue function returns the capabilities for all buttons for a given top level collection.
  @discussion Clients who which to obtain all capabilities for a usage that contains multiple data items for a single usage that corresponds to a HID byte array, must call the HIDGetUsageValueArray function.
  @param reportType Specifies the type of report for which to retrieve the scaled value.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page of the value to be retrieved.
  @param collection Optionally specifies the link collection identifier of the value to be retrieved.
  @param usage Specifies the usage of the scaled value to be retrieved.
  @param usageValue Points to a variable, that on return from this routine holds the scaled value retrieved from the device report.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data
  @param reportLength Specifies the length, in bytes, of the report data provided at report
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetScaledUsageValue	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							SInt32 *				usageValue,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDGetSpecificButtonCaps
  @abstract Retrieves the capabilities for all buttons in a specific type of report that meet the search criteria.
  @discussion The HIDGetSpecificButtonCaps function retrieves capability data for buttons that meet a given search criteria, as opposed to the HIDGetButtonCaps function which returns the capability data for all buttons on the device.  Calling this routine specifying zero for usagePage, usage and collection is equivalent to calling the HIDGetButtonCaps function.
  @param reportType Specifies the type of report for which to retrieve the button capabilities.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies a usage page identifier to use as a search criteria.  If this parameter is non-zero, then only buttons that specify this usage page will be retrieved.
  @param collection Specifies a link collection identifier to use as a search criteria.  If this parameter is non-zero, then only buttons that are part of the specified link collection are retrieved.
  @param usage Specifies a usage identifier to use as a search criteria.  If this parameter is non-zero, then only buttons that match the value specified are retrieved.
  @param buttonCaps Points to a caller-allocated buffer that will contain, on return, an array of HIDButtonCaps structures.  The structures contain information for all buttons that meet the search criteria.
  @param buttonCapsLength On input, specifies the length, in array elements, of the buffer provided in the buttonCaps parameter.  On output, this parameter is set to the actual number of elements that were returned by the function call, in the buffer provided in the buttonCaps parameter, if the routine completed without error.  The correct length necessary to retrieve the button capabilities can be found in the capability data returned for the device by the HIDGetCaps function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetSpecificButtonCaps   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							HIDButtonCapsPtr		buttonCaps,
							UInt32 *				buttonCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetSpecificButtonCapabilities
  @abstract Retrieves the capabilities for all buttons in a specific type of report that meet the search criteria.
  @discussion The HIDGetSpecificButtonCapabilities function retrieves capability data for buttons that meet a given search criteria, as opposed to the HIDGetButtonCapabilities function which returns the capability data for all buttons on the device.  Calling this routine specifying zero for usagePage, usage and collection is equivalent to calling the HIDGetButtonCapabilities function.
  @param reportType Specifies the type of report for which to retrieve the button capabilities.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies a usage page identifier to use as a search criteria.  If this parameter is non-zero, then only buttons that specify this usage page will be retrieved.
  @param collection Specifies a link collection identifier to use as a search criteria.  If this parameter is non-zero, then only buttons that are part of the specified link collection are retrieved.
  @param usage Specifies a usage identifier to use as a search criteria.  If this parameter is non-zero, then only buttons that match the value specified are retrieved.
  @param buttonCaps Points to a caller-allocated buffer that will contain, on return, an array of HIDButtonCapabilities structures.  The structures contain information for all buttons that meet the search criteria.
  @param buttonCapsLength On input, specifies the length, in array elements, of the buffer provided in the buttonCaps parameter.  On output, this parameter is set to the actual number of elements that were returned by the function call, in the buffer provided in the buttonCaps parameter, if the routine completed without error.  The correct length necessary to retrieve the button capabilities can be found in the capability data returned for the device by the HIDGetCaps function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetSpecificButtonCapabilities   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							HIDButtonCapabilitiesPtr	buttonCaps,
							UInt32 *				buttonCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetSpecificValueCaps
  @abstract Retrieves the capabilities for all values in a specific type of report that meet the search criteria.
  @discussion The HIDGetSpecificValueCaps function retrieves capability data for values that meet given search criteria, as opposed to the HIDGetValueCaps function, which returns the capability data for all values on the device.  Calling this routine with a value of zero for usagePage, usage and collection parameters is equivalent to calling the HIDGetValueCaps function.
  @param reportType Specifies the type of report for which to retrieve the value capabilities.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport or kHIDFeatureReport.
  @param usagePage Specifies a usage page identifier to use as a search criteria.  If this parameter is non-zero, then only values that specify this usage page will be retrieved.
  @param collection Specifies a link collection identifier to use as a search criteria.  If this parameter is non-zero, then only values that are part of this link collection will be retrieved.
  @param usage Specifies a usage identifier to use as a search criteria.  If this parameter is non-zero, then only values that specify this usage will be retrieved.
  @param valueCaps Points to a caller-allocated buffer that will contain, on return, an array of HIDValueCaps structures that contain information for all values that meet the search criteria.
  @param valueCapsSize Specifies the length on input, in array elements, of the buffer provided in the valueCaps parameter.  On output, this parameter is set to the actual number of elements that were returned by this function call, in the buffer provided in the valueCaps parameter, if the routine completed without error.  The correct length necessary to retrieve the value capabilities can be found in the capability data returned for the device from the HIDGetCaps function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetSpecificValueCaps	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							HIDValueCapsPtr			valueCaps,
							UInt32 *				valueCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetSpecificValueCapabilities
  @abstract Retrieves the capabilities for all values in a specific type of report that meet the search criteria.
  @discussion The HIDGetSpecificValueCapabilities function retrieves capability data for values that meet given search criteria, as opposed to the HIDGetValueCapabilities function, which returns the capability data for all values on the device.  Calling this routine with a value of zero for usagePage, usage and collection parameters is equivalent to calling the HIDGetValueCapabilities function.
  @param reportType Specifies the type of report for which to retrieve the value capabilities.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport or kHIDFeatureReport.
  @param usagePage Specifies a usage page identifier to use as a search criteria.  If this parameter is non-zero, then only values that specify this usage page will be retrieved.
  @param collection Specifies a link collection identifier to use as a search criteria.  If this parameter is non-zero, then only values that are part of this link collection will be retrieved.
  @param usage Specifies a usage identifier to use as a search criteria.  If this parameter is non-zero, then only values that specify this usage will be retrieved.
  @param valueCaps Points to a caller-allocated buffer that will contain, on return, an array of HIDValueCapabilities structures that contain information for all values that meet the search criteria.
  @param valueCapsSize Specifies the length on input, in array elements, of the buffer provided in the valueCaps parameter.  On output, this parameter is set to the actual number of elements that were returned by this function call, in the buffer provided in the valueCaps parameter, if the routine completed without error.  The correct length necessary to retrieve the value capabilities can be found in the capability data returned for the device from the HIDGetCaps function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetSpecificValueCapabilities	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							HIDValueCapabilitiesPtr	valueCaps,
							UInt32 *				valueCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetButtonsOnPage
  @abstract Retrieves the button stat information for buttons on a specified usage page.
  @param reportType Specifies the type of report, provided in the report parameter, from which to retrieve the buttons.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport or kHIDFeatureReport.
  @param usagePage Specifies the usage page of the buttons for which to retrieve the current state.
  @param collection Optionally specifies the link collection identifier used to retrieve only specific button states.  If this value is non-zero, only the buttons that are part of the given collection are returned.
  @param usageList On return, points to a caller-allocated buffer that contains the usages of all the buttons that are perssed and belong to the usage page specified in the usagePage parameter.
  @param usageListSize Is the size, in array elements, of the buffer provided in the usageList parameter.  On return, this parameter contains the number of button states that were set by this routine.  If the error kHIDBufferTooSmallErr was returned, this parameter contains the number of array elements required to hold all button data requested.  The maximum number of buttons that can ever be returned for a given type of report can be obtained by calling the HIDMaxUsageListLength function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data
  @param reportLength Specifies the size, in bytes, of the report data provided in the report parameter
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetButtonsOnPage		   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage *				usageList,
							UInt32 *				usageListSize,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDGetButtons
  @abstract The HIDGetButtons function takes a report from a HID device and gets the current state of the buttons in that report.
  @param reportType Specifies the type of report, provided in the report parameter, from which to retrieve the buttons.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport or kHIDFeatureReport
  @param collection Optionally specifies the link collection identifier used to retrieve only specific button states.  If this value is non-zero, only the buttons that are part of the given collection are returned.
  @param usageList On return, points to a caller-allocated buffer that contains the usages of all the buttons that are pressed.
  @param usageListSize Is the size, in array elements, of the buffer provided in the usageList parameter.  On return, this parameter contains the number of button states that were set by this routine.  If the error kHIDBufferToSmallErr was returned, this parameter contains the number of array elements required to hold all button data requested.  The maximum number of buttons that can ever be returned for a given type of report can be obtained by calling the HIDMaxUsageListLength function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the length, in bytes, of the report data provided in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetButtons			   (HIDReportType			reportType,
							UInt32					collection,
							HIDUsageAndPagePtr		usageList,
							UInt32 *				usageListSize,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

extern 
OSStatus
HIDGetNextButtonInfo       (HIDReportType          reportType,
                            HIDUsage               usagePage,
                            HIDUsage               usage,
                            UInt32 *               collection,
                            UInt8 *                reportID,
                            HIDPreparsedDataRef    preparsedDataRef);

extern 
OSStatus
HIDGetNextUsageValueInfo   (HIDReportType          reportType,
                            HIDUsage               usagePage,
                            HIDUsage               usage,
                            UInt32 *               collection,
                            UInt8 *                reportID,
                            HIDPreparsedDataRef    preparsedDataRef);

extern 
OSStatus
HIDGetReportLength         (HIDReportType          	reportType,
                            UInt8                  	reportID,
                            IOByteCount		   		*reportLength,
                            HIDPreparsedDataRef    	preparsedDataRef);

/*!
  @function HIDGetUsageValue
  @abstract The HIDGetUsageValue function returns a value from a device data report given a selected search criteria.
  @discussion The HIDGetUsageValue function does not sign the value.  To have the sign bit automatically applied, use the HIDGetScaledUsageValue function instead.  For manually assigning the sign bit, the position of the sign bit can be found in the HIDValueCaps structure for this value.  Clients who wish to obtain all data for a usage that contains multiple data items for a single usage, corresponding to a HID byte array, must call the HIDGetUsageValueArray function instead.
  @param reportType Specifies the type of report, provided in report, from which to retrieve the value.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page of the value to retrieve.
  @param collection Optionally specifies the link collection identifier of the value to be retrieved.
  @param usage Specifies the usage of the value to be retrieved.
  @param usageValue Points to a variable, that on return from this routine holds the value retrieved from the device report.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the size, in bytes, of the report data provided in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetUsageValue		   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							SInt32 *				usageValue,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDGetUsageValueArray
  @abstract The HIDGetUsageValueArray function returns a value from a device data report given a selected search criteria.
  @discussion When the HIDGetUsageValueArray function retrieves the data, it fills in the buffer in little-endian order beginning with the least significant bit of the data for this usage.  The data is filled in without regard to byte alignment and is shifted such that the least significant bit is placed as the 1st bit of the given buffer.
  @param reportType Specifies the type of report, provided in report, from which to retrieve the value.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page of the data to be retrieved.
  @param collection Optionally specifies the link collection identifier of the data to be retrieved.
  @param usage Specifies the usage identifier of the value to be retrieved.
  @param usageValueBuffer Points to a caller-allocated buffer that contains, on output, the data from the device.  The correct length for this buffer can be found by multiplying the reportCount and bitSize fields of the HIDValueCaps structure for the value and rounding the resulting value up to the nearest byte.
  @param usageValueBufferSize Specifies the size, in bytes, of the buffer in the usageValueBuffer parameter.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the size, in bytes, of the report data provided in report.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetUsageValueArray	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							UInt8 *					usageValueBuffer,
							IOByteCount				usageValueBufferSize,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDGetValueCaps
  @abstract The HIDGetValueCaps function retrieves the capabilities for all values for a specified top level collection.
  @discussion The HIDGetValueCaps function retrieves the capability data for all values in a top level collection without regard for the usage, usage page or collection of the value.  To retrieve value capabilities for a specific usage, usage page or collection, use the HIDGetSpecificValueCaps function.
  @param reportType Specifies the type of report for which to retrieve the value capabilities.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param valueCaps On return, points to a caller-allocated buffer that contains an array of HIDValueCaps structures containing information for all values in the top level collection.
  @param valueCapsSize On input, specifies the size in array elements of the buffer provided in the valueCaps parameter.  On output, this parameter is set to the actual number of elements that were returned in the buffer provided in the valueCaps parameter, if the function completed without error.  The correct length necessary to retrieve the value capabilities can be found in the capability data returned for the device by the HIDGetCaps function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetValueCaps			   (HIDReportType			reportType,
							HIDValueCapsPtr			valueCaps,
							UInt32 *				valueCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDGetValueCapabilities
  @abstract The HIDGetValueCapabilities function retrieves the capabilities for all values for a specified top level collection.
  @discussion The HIDGetValueCapabilities function retrieves the capability data for all values in a top level collection without regard for the usage, usage page or collection of the value.  To retrieve value capabilities for a specific usage, usage page or collection, use the HIDGetSpecificValueCapabilities function.
  @param reportType Specifies the type of report for which to retrieve the value capabilities.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param valueCaps On return, points to a caller-allocated buffer that contains an array of HIDValueCapabilities structures containing information for all values in the top level collection.
  @param valueCapsSize On input, specifies the size in array elements of the buffer provided in the valueCaps parameter.  On output, this parameter is set to the actual number of elements that were returned in the buffer provided in the valueCaps parameter, if the function completed without error.  The correct length necessary to retrieve the value capabilities can be found in the capability data returned for the device by the HIDGetCapabilities function.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDGetValueCapabilities	   (HIDReportType			reportType,
							HIDValueCapabilitiesPtr	valueCaps,
							UInt32 *				valueCapsSize,
							HIDPreparsedDataRef		preparsedDataRef);

extern 
OSStatus
HIDInitReport              (HIDReportType          reportType,
                            UInt8                  reportID,
                            HIDPreparsedDataRef    preparsedDataRef,
                            void *                 report,
                            IOByteCount      	   reportLength);

/*!
  @function HIDMaxUsageListLength
  @abstract The HIDMaxUsageListLength function returns the maximum number of buttons that can be returned from a given report type for the top level collection.
  @param reportType Specifies the type of report for which to get a maximum usage count.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Optionally specifies the usage page identifier to use as a search criteria.  If this parameter is zero, the function returns the number of buttons for the entire top-level collection regardless of the actual value of the usage page.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern  
UInt32
HIDMaxUsageListLength	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							HIDPreparsedDataRef		preparsedDataRef);

/*!
  @function HIDSetScaledUsageValue
  @abstract The HIDSetScaledUsageValue function takes a signed physical (scaled) number and converts it to the logical, or device representation and inserts it in a given report.
  @discussion The HIDSetScaledUsageValue function automatically handles the setting of the signed bit in the data to be sent to the device.
  @param reportType Specifies the type of report.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page identifier of the value to be set in the report.
  @param collection Optionally specifies the link collection identifier to distinguish between values that have the same usage page and usage identifiers.  If this parameter is zero, it will be ignored.
  @param usage Specifies the usage identifier of the value to be set in the report.
  @param usageValue Specifies the physical, or scaled, value to be set in the value for the given report.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param Specifies the length, in bytes of the report data specified in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDSetScaledUsageValue	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							SInt32					usageValue,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDSetButtons
  @abstract The HIDSetButtons function takes a report from a HID device and returns the current state of the buttons in that report.
  @param reportType Specifies the type of repor.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page identifier of the value to be set in the report.
  @param collection Optionally specifies the link collection identifier to distinguish between buttons.  If this parameter is zero, it is ignored.
  @param usageList Points to a caller-allocated buffer that contains an array of button data to be set in the report in the report parameter.
  @param usageListSize Specifies the size, in array elements, of the buffer provided in the usageList parameter.  If an error is returned by a call to this function, the usageListLength parameter contains the location in the array provided in the usageList parameter where the error was encountered.  All array entries encountered prior to the error location were successfully set in the report provided in the report parameter.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the size, in bytes, of the report data provided in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDSetButtons			   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage *				usageList,
							UInt32 *				usageListSize,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDSetUsageValue
  @abstract The HIDSetUsageValue function sets a value in a give report.
  @discussion The HIDSetUsageVlaue function does not automatically handle the sign bit.  Clients must either manually set the sign bit, at the position provided in the HIDValueCaps structure for this value, or call the HIDSetScaledUsageValue function.
  @param reportType Specifies the type of report.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page identifier of the value to be set in the report.
  @param collection Optionally specifies the link collection identifier to distinguish between values that have the same usage page and usage identifiers.  If this parameter is zero, it is ignored.
  @param usage Specifies the usage identifier of the value to be set in the report.
  @param usageValue Specifies the data that is to be set in the value for the given report.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the size, in bytes, of the report data provided in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDSetUsageValue		   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							SInt32					usageValue,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDSetUsageValueArray
  @abstract The HIDSetUsageValueArray function sets an array of values in a given report.
  @discussion The HIDSetUsageValue function does not automatically handle the sign bit.  Clients must either manually set the sign bit, at the position provided in the HIDValueCaps structure for this value, or call the HIDSetScaledUsageValue function.
  @param reportType Specifies the type of report.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page identifier of the value to be set in the report.
  @param collection Optionally specifies the link collection identifier to distinguish between values that have the same usage page and usage identifiers.  If this parameter is zero, it is ignored.
  @param usage Specifies the usage identifier of the value to be set in the report.
  @param usageValueBuffer Points to a caller-allocated buffer that contains, on output, the data from the device.  The correct length for this buffer can be found by multiplying the reportCount and bitSize fields of the HIDValueCaps structure for this value and rounding the resulting value up to the nearest byte.
  @param usageValueBufferLength Specifies the size, in bytes, of the buffer in the usageValueBuffer parameter.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the size, in bytes, of the report data provided in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDSetUsageValueArray	   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							UInt8 *					usageValueBuffer,
							IOByteCount				usageValueBufferLength,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);

/*!
  @function HIDUsageListDifference
  @abstract The HIDUsageListDifference function compares and provides the differences between two lists of buttons.
  @param previousUsageList Points to the older button list to be used for comparison.
  @param currentUsageList Points to the newer button list to be used for comparison.
  @param breakUsageList On return, points to a caller-allocated buffer that contains the buttons set in the older list, specified in the previousUsageList parameter, but not set in the new list, specified in the currentUsageList parameter.
  @param makeUsageList On return, points to a caller-allocated buffer that contains the buttons set in the new list, specified in the currentUsageList parameter, but not set in the old list, specified in the previousUsageList parameter.
  @param usageListsLength Specifies the length, in array elements, of the buffers provided in the currentUsageList and previousUssageList parameters.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDUsageListDifference	   (HIDUsage *				previousUsageList,
							HIDUsage *				currentUsageList,
							HIDUsage *				breakUsageList,
							HIDUsage *				makeUsageList,
							UInt32					usageListsSize);

/*!
  @function HIDSetButton
  @abstract The HIDSetButton function takes a report from a HID device and sets the current state of the specified button in that report.
  @param reportType Specifies the type of report.  This parameter must be one of the following: kHIDInputReport, kHIDOutputReport, or kHIDFeatureReport.
  @param usagePage Specifies the usage page identifier of the value to be set in the report.
  @param collection Optionally specifies the link collection identifier to distinguish between buttons.  If this parameter is zero, it is ignored.
  @param usage Points to a caller-allocated buffer that contains the button data to be set in the report in the report parameter.
  @param preparsedDataRef Preparsed data reference for the report that is retuned by the HIDOpenReportDescriptor function
  @param report Points to the caller-allocated buffer that contains the device report data.
  @param reportLength Specifies the size, in bytes, of the report data provided in the report parameter.
  @result OSStatus Returns an error code if an error was encountered or noErr on success.
 */

extern 
OSStatus
HIDSetButton			   (HIDReportType			reportType,
							HIDUsage				usagePage,
							UInt32					collection,
							HIDUsage				usage,
							HIDPreparsedDataRef		preparsedDataRef,
							void *					report,
							IOByteCount				reportLength);


#ifdef __cplusplus
}
#endif


#endif
                                                  IOHIDParameter.h                                                                                    0100644 0001750 0001750 00000030307 12567452123 036704  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved. 
 *
 * evsio.h - Get/Set parameter calls for Event Status Driver.
 *
 *	CAUTION: Developers should stick to the API exported in
 *		<drivers/event_status_driver.h> to guarantee
 *		binary compatability of their applications in future
 *		releases.
 *
 * HISTORY
 * 22 May 1992    Mike Paquette at NeXT
 *      Created. 
 */
#ifndef _DEV_EVSIO_H
#define _DEV_EVSIO_H

/* Public type definitions. */
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hidsystem/IOLLEvent.h>

/*
 * Identify this driver as one that uses the new driverkit and messaging API
 */
#ifndef _NeXT_MACH_EVENT_DRIVER_
#define _NeXT_MACH_EVENT_DRIVER_	(1)
#endif /* !_NeXT_MACH_EVENT_DRIVER_ */

/* * */

#define kIOHIDKindKey					"HIDKind"
#define kIOHIDInterfaceIDKey			"HIDInterfaceID"
#define kIOHIDSubinterfaceIDKey			"HIDSubinterfaceID"
#define kIOHIDOriginalSubinterfaceIDKey "HIDOriginalSubinterfaceID"

#define kIOHIDParametersKey				"HIDParameters"

#define kIOHIDVirtualHIDevice                   "HIDVirtualDevice"

#define kIOHIDKeyRepeatKey				"HIDKeyRepeat"
#define kIOHIDInitialKeyRepeatKey		"HIDInitialKeyRepeat"
#define kIOHIDKeyMappingKey				"HIDKeyMapping"
#define kIOHIDResetKeyboardKey			"HIDResetKeyboard"

#define kIOHIDKeyboardModifierMappingPairsKey   "HIDKeyboardModifierMappingPairs"
#define kIOHIDKeyboardModifierMappingSrcKey     "HIDKeyboardModifierMappingSrc"
#define kIOHIDKeyboardModifierMappingDstKey     "HIDKeyboardModifierMappingDst"

#define kIOHIDKeyboardCapsLockDoesLockKey       "HIDKeyboardCapsLockDoesLock"
#define kIOHIDKeyboardSupportsF12EjectKey       "HIDKeyboardSupportsF12Eject"
#define kIOHIDKeyboardSupportedModifiersKey     "HIDKeyboardSupportedModifiers"

#define kIOHIDPointerResolutionKey		"HIDPointerResolution"
#define kIOHIDResetPointerKey			"HIDResetPointer"
#define kIOHIDPointerConvertAbsoluteKey	"HIDPointerConvertAbsolute"
#define kIOHIDPointerContactToMoveKey	"HIDPointerContactToMove"
#define kIOHIDPointerPressureToClickKey	"HIDPointerPressureToClick"
#define kIOHIDPointerButtonMode			"HIDPointerButtonMode"
#define kIOHIDPointerButtonCountKey	"HIDPointerButtonCount"

#define kIOHIDPointerAccelerationKey	"HIDPointerAcceleration"
#define kIOHIDPointerAccelerationSettingsKey	"HIDPointerAccelerationSettings"
#define kIOHIDPointerAccelerationTypeKey	"HIDPointerAccelerationType"
#define kIOHIDPointerAccelerationTableKey  "HIDPointerAccelerationTable"

#define kIOHIDScrollResetKey			"HIDScrollReset"
#define kIOHIDScrollResolutionKey		"HIDScrollResolution"
#define kIOHIDScrollReportRateKey       "HIDScrollReportRate"
#define kIOHIDScrollAccelerationKey		"HIDScrollAcceleration"
#define kIOHIDScrollAccelerationTypeKey     "HIDScrollAccelerationType"
#define kIOHIDScrollAccelerationTableKey	"HIDScrollAccelerationTable"

#define kIOHIDScrollResolutionXKey		"HIDScrollResolutionX"
#define kIOHIDScrollResolutionYKey		"HIDScrollResolutionY"
#define kIOHIDScrollResolutionZKey		"HIDScrollResolutionZ"

#define kIOHIDScrollAccelerationTableXKey	"HIDScrollAccelerationTableX"
#define kIOHIDScrollAccelerationTableYKey	"HIDScrollAccelerationTableY"
#define kIOHIDScrollAccelerationTableZKey	"HIDScrollAccelerationTableZ"

#define kIOHIDScrollMouseButtonKey      "HIDScrollMouseButton"

#define kIOHIDScrollZoomModifierMaskKey "HIDScrollZoomModifierMask"

#define kIOHIDTrackpadScrollAccelerationKey "HIDTrackpadScrollAcceleration"
#define kIOHIDMouseScrollAccelerationKey   "HIDMouseScrollAcceleration"

#define kIOHIDTrackpadAccelerationType	"HIDTrackpadAcceleration"
#define kIOHIDMouseAccelerationType		"HIDMouseAcceleration"

#define kIOHIDClickTimeKey				"HIDClickTime"
#define kIOHIDClickSpaceKey				"HIDClickSpace"

#define kIOHIDWaitCursorFrameIntervalKey	"HIDWaitCursorFrameInterval"

#define kIOHIDAutoDimThresholdKey		"HIDAutoDimThreshold"
#define kIOHIDAutoDimStateKey			"HIDAutoDimState"
#define kIOHIDAutoDimTimeKey			"HIDAutoDimTime"
#define kIOHIDIdleTimeKey				"HIDIdleTime"

#define kIOHIDBrightnessKey				"HIDBrightness"
#define kIOHIDAutoDimBrightnessKey		"HIDAutoDimBrightness"

#define kIOHIDFKeyModeKey			"HIDFKeyMode"

// if kIOHIDStickyKeysDisabledKey is 1, then all sticky keys functionality
// is completely turned off. Multiple shifts will have no effect.
#define kIOHIDStickyKeysDisabledKey		"HIDStickyKeysDisabled"

// if kIOHIDStickyKeysOnKey is 1 then a depressed modifier will stay down
// until a non-modifer key is pressed (or sticky keys is turned off)
#define kIOHIDStickyKeysOnKey			"HIDStickyKeysOn"

// if kIOHIDStickyKeysShiftTogglesKey is 1, then a sequence of five
// shift keys in sequence will toggle sticky keys on or off
#define kIOHIDStickyKeysShiftTogglesKey	"HIDStickyKeysShiftToggles"

// if kIOHIDMouseKeysOptionTogglesKey is 1, then a sequence of five
// option keys in sequence will toggle mouse keys on or off
#define kIOHIDMouseKeysOptionTogglesKey	"HIDMouseKeysOptionToggles"

// kIOHIDSlowKeysDelayKey represents the delay used for slow keys.
// if kIOHIDSlowKeysDelayKey is 0, then slow keys off
#define kIOHIDSlowKeysDelayKey			"HIDSlowKeysDelay"

#define kIOHIDF12EjectDelayKey			"HIDF12EjectDelay"

#define kIOHIDMouseKeysOnKey			"HIDMouseKeysOn"

#define kIOHIDUseKeyswitchKey           "HIDUseKeyswitch"

#define kIOHIDDisallowRemappingOfPrimaryClickKey	"HIDDisallowRemappingOfPrimaryClick"
#define kIOHIDMouseKeysEnablesVirtualNumPadKey	"HIDMouseKeysEnablesVirtualNumPad"

#define kIOHIDResetLEDsKey          "HIDResetLEDs"

// Parametric Acceleration Keys
#define kHIDAccelParametricCurvesKey            "HIDAccelCurves"
#define kHIDTrackingAccelParametricCurvesKey    "HIDTrackingAccelCurves"
#define kHIDScrollAccelParametricCurvesKey      "HIDScrollAccelCurves"
#define kHIDAccelParametricCurvesDebugKey       "HIDAccelCurvesDebug"
#define kHIDScrollAccelParametricCurvesDebugKey "HIDScrollAccelCurvesDebug"
#define kHIDAccelGainLinearKey                  "HIDAccelGainLinear"
#define kHIDAccelGainParabolicKey               "HIDAccelGainParabolic"
#define kHIDAccelGainCubicKey                   "HIDAccelGainCubic"
#define kHIDAccelGainQuarticKey              "HIDAccelGainQuartic"
#define kHIDAccelTangentSpeedLinearKey          "HIDAccelTangentSpeedLinear"
#define kHIDAccelTangentSpeedParabolicRootKey   "HIDAccelTangentSpeedParabolicRoot"
#define kHIDAccelTangentSpeedCubicRootKey       "HIDAccelTangentSpeedCubicRoot"
#define kHIDAccelTangentSpeedQuarticRootKey  "HIDAccelTangentSpeedQuarticRoot"
#define kHIDAccelIndexKey                       "HIDAccelIndex"

// Scroll Count Keys
#define kIOHIDScrollCountMaxTimeDeltaBetweenKey         "HIDScrollCountMaxTimeDeltaBetween"
#define kIOHIDScrollCountMaxTimeDeltaToSustainKey       "HIDScrollCountMaxTimeDeltaToSustain"
#define kIOHIDScrollCountMinDeltaToStartKey             "HIDScrollCountMinDeltaToStart"
#define kIOHIDScrollCountMinDeltaToSustainKey           "HIDScrollCountMinDeltaToSustain"
#define kIOHIDScrollCountIgnoreMomentumScrollsKey       "HIDScrollCountIgnoreMomentumScrolls"
#define kIOHIDScrollCountMouseCanResetKey               "HIDScrollCountMouseCanReset"
#define kIOHIDScrollCountMaxKey                         "HIDScrollCountMax"
#define kIOHIDScrollCountAccelerationFactorKey          "HIDScrollCountAccelerationFactor"
#define kIOHIDScrollCountZeroKey                        "HIDScrollCountZero"
#define kIOHIDScrollCountBootDefaultKey                 "HIDScrollCountBootDefault"
#define kIOHIDScrollCountResetKey                       "HIDScrollCountReset"

// the following values are used in kIOHIDPointerButtonMode
typedef enum {
	kIOHIDButtonMode_BothLeftClicks = 0,
	kIOHIDButtonMode_ReverseLeftRightClicks = 1,
	kIOHIDButtonMode_EnableRightClick = 2
} IOHIDButtonModes;

#ifdef _undef
#define EVS_PREFIX	"Evs_"	/* All EVS calls start with this string */

/* WaitCursor-related ioctls */

#define EVSIOSWT "Evs_SetWaitThreshold"
#define EVSIOSWT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSWS "Evs_SetWaitSustain"
#define EVSIOSWS_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSWFI "Evs_SetWaitFrameInterval"
#define EVSIOSWFI_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOCWINFO	"Evs_CurrentWaitCursorInfo"
#define EVSIOCWINFO_THRESH	0
#define EVSIOCWINFO_SUSTAIN	(EVSIOCWINFO_THRESH + EVS_PACKED_TIME_SIZE)
#define EVSIOCWINFO_FINTERVAL	(EVSIOCWINFO_SUSTAIN + EVS_PACKED_TIME_SIZE)
#define EVSIOCWINFO_SIZE	(EVSIOCWINFO_FINTERVAL + EVS_PACKED_TIME_SIZE)
#endif

#define EVS_PACKED_TIME_SIZE (sizeof(UInt64) / sizeof( unsigned int))

/* Device control ioctls. Levels specified may be in the range 0 - 64. */

#define EVSIOSB	  	kIOHIDBrightnessKey
#define EVSIOSB_SIZE	1

#define EVSIOSADB 	kIOHIDAutoDimBrightnessKey
#define EVSIOSADB_SIZE	1

#ifdef _undef
#define EVSIOSA	  "Evs_SetAttenuation"
#define EVIOSA_SIZE	1

#define EVSIO_DCTLINFO	"Evs_DeviceControlInfo"
typedef enum {
	EVSIO_DCTLINFO_BRIGHT,
	EVSIO_DCTLINFO_ATTEN,
	EVSIO_DCTLINFO_AUTODIMBRIGHT
} evsio_DCTLINFOIndices;
#define EVSIO_DCTLINFO_SIZE	(EVSIO_DCTLINFO_AUTODIMBRIGHT + 1)
#endif

/*
 * Device status request
 */
#define	EVSIOINFO  NX_EVS_DEVICE_INFO


/* Keyboard-related ioctls - implemented within Event Sources */

#define EVSIOSKR  	kIOHIDKeyRepeatKey
#define EVSIOSKR_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSIKR 	kIOHIDInitialKeyRepeatKey
#define EVSIOSIKR_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIORKBD 	kIOHIDResetKeyboardKey
#define EVSIORKBD_SIZE	1

#define EVSIOCKR_SIZE	EVS_PACKED_TIME_SIZE

#define	EVSIOCKML 	kIOHIDKeyMappingKey
#define EVSIOCKML_SIZE	1

/* The following two tokens are for use with the get/set character routines. */
#define EVSIOSKM  	kIOHIDKeyMappingKey
#define EVSIOSKM_SIZE	4096

#define	EVSIOCKM  	kIOHIDKeyMappingKey
#define EVSIOCKM_SIZE	4096

/* Mouse-related ioctls - implemented within Event Sources */

#define	EVSIOSMS  	kIOHIDPointerAccelerationKey
#define	EVSIOSMS_SIZE		(1)

#define	EVSIOCMS  	kIOHIDPointerAccelerationKey
#define	EVSIOCMS_SIZE		(1)

#ifdef _undef
#define EVSIOSMH  "Evs_SetMouseHandedness"
#define EVSIOSMH_SIZE	1		// value from NXMouseButton enum

#define EVSIOCMH  "Evs_CurrentMouseHandedness"
#define EVSIOCMH_SIZE	1
#endif

/* Generic pointer device controls, implemented by the Event Driver. */
#define	EVSIOSCT  	kIOHIDClickTimeKey
#define EVSIOSCT_SIZE	EVS_PACKED_TIME_SIZE

#define	EVSIOSCS  	kIOHIDClickSpaceKey
typedef enum {
	EVSIOSCS_X,
	EVSIOSCS_Y
} evsioEVSIOSCSIndices;
#define EVSIOSCS_SIZE	(EVSIOSCS_Y + 1)

#define EVSIOSADT	 kIOHIDAutoDimThresholdKey
#define EVSIOSADT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSADS 	kIOHIDAutoDimStateKey
#define EVSIOSADS_SIZE	1

#define EVSIORMS  	kIOHIDResetPointerKey
#define EVSIORMS_SIZE	1

#define	EVSIOCCT  	kIOHIDClickTimeKey
#define EVSIOCCT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOCADT 	kIOHIDAutoDimThresholdKey
#define EVSIOCADT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOGDADT 	kIOHIDAutoDimTimeKey
#define EVSIOGDADT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOIDLE 	kIOHIDIdleTimeKey
#define EVSIOIDLE_SIZE	EVS_PACKED_TIME_SIZE

#define	EVSIOCCS  	kIOHIDClickSpaceKey
typedef enum {
	EVSIOCCS_X,
	EVSIOCCS_Y
} evsioEVSIOCCSIndices;
#define EVSIOCCS_SIZE	(EVSIOCCS_Y + 1)

#define EVSIOCADS 	kIOHIDAutoDimStateKey
#define EVSIOCADS_SIZE	1

enum {
    // Selectors for IOHIDGetModifierLockState and IOHIDSetModifierLockState
    kIOHIDCapsLockState             = 0x00000001,
    kIOHIDNumLockState              = 0x00000002,
    kIOHIDActivityUserIdle          = 0x00000003,
    kIOHIDActivityDisplayOn         = 0x00000004,
};

#endif /* !_DEV_EVSIO_H */
                                                                                                                                                                                                                                                                                                                         IOHIDShared.h                                                                                       0100644 0001750 0001750 00000024441 12567452123 036174  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2011 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _DEV_EVIO_H
#define _DEV_EVIO_H

#include <sys/cdefs.h>

__BEGIN_DECLS

#if KERNEL
#include <IOKit/system.h>
#else /* !KERNEL */
#include <mach/message.h>
#include <IOKit/IOKitLib.h>
#endif /* KERNEL */

#include <IOKit/IOReturn.h>
#include <IOKit/graphics/IOGraphicsTypes.h>
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hidsystem/IOLLEvent.h>

/*
 * Identify this driver as one that uses the new driverkit and messaging API
 */
#ifndef _NeXT_MACH_EVENT_DRIVER_
#define _NeXT_MACH_EVENT_DRIVER_	(1)
#endif /* _NeXT_MACH_EVENT_DRIVER_ */


/* Pressure Constants */
#define MINPRESSURE EV_MINPRESSURE
#define MAXPRESSURE EV_MAXPRESSURE

#define	LLEQSIZE 240	/* Entries in low-level event queue */

typedef struct _NXEQElStruct {
    int	next;		/* Slot of lleq for next event */
    OSSpinLock sema; /* Is high-level code reading this event now? */
    NXEvent event;	/* The event itself */
} NXEQElement;

/******************************************************************************
    SHARED MEMORY OVERVIEW
    
    PERSPECTIVE
    The ev driver and PostScript share at least one page of wired memory.
    This memory contains the low-level event queue which ev deposits events
    into and PostScript reads events from. Also, this memory contains other
    important data such as wait cursor state and some general cursor state.
    This memory is critical for speed.  That is, we avoid having to make
    system calls for common operations.
    
    SHARED MEMORY REGIONS
    There are currently three "regions" or "zones" delineated within this
    shared memory.  The first zone is the EvOffsets structure. This structure
    contains two offsets from the beginning of shared memory. The first offset
    is to the second zone, EvGlobals. The second offset is to the third
    zone, private shmem for drivers.
    
    INITIALIZATION OF SHARED MEMORY
    When the WindowServer starts up, it finds all screens that will be active.
    It then opens the ev driver and calls the EVIOSSCR ioctl repeatedly for
    each screen in use. This lets the ev driver set up the evScreen array
    and fill in each element. This ioctl also returns to PostScript a running
    total shared memory size with which to allocate. PostScript then allocates
    a region of memory this size and calls evmmap to "map in" this shared
    region.  Evmmap initializes and fills in the EvOffsets and EvGlobals.
    Next the WindowServer calls each screen in turn to register itself with
    the ev driver in the same sequence as presented to EVIOSSCR.  Each screen
    driver calls ev_register_screen() which among other things allocates a
    part of the private shmem (of the third shared memory zone) for the driver.
    
    DEBUGGING NOTES
    You can easily display and set this shared memory from kgdb, but usually
    cannot do so from within PostScript.  Gdb (or some weird interaction
    between gdb and the os) chokes on this shmem.  So if you read or write
    this area of memory, copy-on-write will occur and you'll get a completely
    new page for PostScript.  This will render the shared memory scheme
    useless and you will have to restart PostScript.  It was my understanding
    that before, we were able to "read" this area from PS, but not write to
    it (the idea behind copy-on-WRITE).  However, this seems to be broken
    in 2.0.  We think this is a kernel bug.
******************************************************************************/

typedef volatile struct _evOffsets {
    int	evGlobalsOffset;	/* Offset to EvGlobals structure */
    int evShmemOffset;		/* Offset to private shmem regions */
} EvOffsets;

/******************************************************************************
    EvGlobals
    This structures defines the portion of the events driver data structure
    that is exported to the PostScript server. It contains the event queue
    which is in memory shared between the driver and the PostScript server.
    All the variables necessary to read and process events from the queue are
    contained here.
******************************************************************************/

typedef volatile struct _evGlobals {
    OSSpinLock cursorSema; 	/* set to disable periodic code */
    int eNum;                       /* Unique id for mouse events */
    int buttons;                    /* State of the mouse buttons 1==down, 0==up */
    int eventFlags;                 /* The current value of event.flags */
    int VertRetraceClock;           /* The current value of event.time */
    IOGPoint cursorLoc;             /* The current location of the cursor, in desktop coordinates */
    int frame;                      /* current cursor frame */
    IOGBounds workBounds;           /* bounding box of all screens */
    IOGBounds mouseRect;            /* Rect for mouse-exited events */
    int version;                    /* for run time checks */
    int	structSize;                 /* for run time checks */
    int lastFrame;
                                    /* The current location of the cursor, 24.8 bit fixed point format */
    IOFixedPoint32 screenCursorFixed; /* in Screen coordinates  */
    IOFixedPoint32 desktopCursorFixed;/* in Desktop coordinates  */
    unsigned int reservedA[27];

    unsigned reserved:25;
    unsigned updateCursorPositionFromFixed:1; /* if this is set, IOHIDSystem will take any cursor position updates from desktopCursorFixed instead of cursorLoc */
    unsigned logCursorUpdates:1;    /* log cursor updates */
    unsigned wantPressure:1;        /* pressure in current mouseRect? */
    unsigned wantPrecision:1;       /* precise coordinates in current mouseRect? */
    unsigned dontWantCoalesce:1;    /* coalesce within the current mouseRect? */
    unsigned dontCoalesce:1;        /* actual flag which determines coalescing */
    unsigned mouseRectValid:1;      /* If nonzero, post a mouse-exited whenever mouse outside mouseRect. */
    int movedMask;                  /* This contains an event mask for the three events MOUSEMOVED,
                                        LMOUSEDRAGGED,  and RMOUSEDRAGGED. It says whether driver should
                                        generate those events. */
    OSSpinLock waitCursorSema; /* protects wait cursor fields */
    int AALastEventSent;            /* timestamp for wait cursor */
    int AALastEventConsumed;        /* timestamp for wait cursor */	
    int waitCursorUp;               /* Is wait cursor up? */
    char ctxtTimedOut;              /* Has wait cursor timer expired? */
    char waitCursorEnabled;         /* Play wait cursor game (per ctxt)? */
    char globalWaitCursorEnabled;   /* Play wait cursor game (global)? */
    int waitThreshold;              /* time before wait cursor appears */

    int LLEHead;                    /* The next event to be read */
    int LLETail;                    /* Where the next event will go */
    int LLELast;                    /* The last event entered */
    NXEQElement lleq[LLEQSIZE];     /* The event queue itself */
} EvGlobals;

/* These evio structs are used in various calls supported by the ev driver. */

struct evioLLEvent {
    int setCursor;
    int type;
    IOGPoint location;
    NXEventData data;
    int setFlags;
    int flags;
};

typedef struct evioLLEvent _NXLLEvent;

#ifdef mach3xxx

/*
 * On a keypress of a VOL UP or VOL DOWN key, we send a message to the 
 * sound server to notify it of the volume change.  The message includes
 * a flag to indicate which key was pressed, and the machine independant
 * flag bits to indicate which modifier keys were pressed.
 */

struct evioSpecialKeyMsg
{
	msg_header_t Head;
	msg_type_t keyType;
	int key;		// special key number, from bsd/dev/ev_keymap.h
	msg_type_t directionType;
	int direction;		// NX_KEYDOWN, NX_KEYUP from event.h
	msg_type_t flagsType;
	int flags;		// device independant flags from event.h
	msg_type_t levelType;
	int level;		// EV_AUDIO_MIN_VOLUME to EV_AUDIO_MAX_VOLUME
};
#else
struct evioSpecialKeyMsg
{
	mach_msg_header_t Head;
	int key;		// special key number, from bsd/dev/ev_keymap.h
	int direction;		// NX_KEYDOWN, NX_KEYUP from event.h
	int flags;		// device independant flags from event.h
	int level;		// EV_AUDIO_MIN_VOLUME to EV_AUDIO_MAX_VOLUME
};
#endif

#define EV_SPECIAL_KEY_MSG_ID	(('S'<<24) | ('k'<<16) | ('e'<<8) | ('y'))
typedef struct evioSpecialKeyMsg *evioSpecialKeyMsg_t;

/*
 * Volume ranges
 */
#define EV_AUDIO_MIN_VOLUME	0
#define EV_AUDIO_MAX_VOLUME	64

#define kIOHIDSystemClass	"IOHIDSystem"
#define kIOHIKeyboardClass	"IOHIKeyboard"
#define kIOHIPointingClass	"IOHIPointing"

#define IOHIDSYSTEM_CONFORMSTO	kIOHIDSystemClass

enum {
    kIOHIDEventNotification     = 0,
};
#define kIOHIDCurrentShmemVersion           4
#define kIOHIDLastCompatibleShmemVersion    3

enum {
    kIOHIDServerConnectType	= 0,
    kIOHIDParamConnectType	= 1,
    kIOHIDEventSystemConnectType = 3,
};

enum {
    kIOHIDGlobalMemory          = 0
};

enum {
    kIOHIDEventQueueTypeKernel  = 0,
    kIOHIDEventQueueTypeUser    = 1
};

#ifdef KERNEL
typedef UInt16 (*MasterVolumeUpdate)(void);
typedef bool (*MasterMuteUpdate)(void);

typedef struct {
    MasterVolumeUpdate incrementMasterVolume;
    MasterVolumeUpdate decrementMasterVolume;
    MasterMuteUpdate toggleMasterMute;
} MasterAudioFunctions;

extern MasterAudioFunctions *masterAudioFunctions;
#endif

#ifndef KERNEL
#ifndef _IOKIT_IOHIDLIB_H
#include <IOKit/hidsystem/IOHIDLib.h>
#endif
#endif /* !KERNEL */

__END_DECLS


#endif /* !_DEV_EVIO_H */
                                                                                                                                                                                                                               IOHIDSystem.h                                                                                       0100644 0001750 0001750 00000103602 12567452123 036247  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 *
 * Copyright (c) 1999-2009 Apple Computer, Inc.  All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved.
 *
 * EventDriver.h - Exported Interface Event Driver object.
 *
 *		The EventDriver is a pseudo-device driver.
 *
 * HISTORY
 * 19 Mar 1992    Mike Paquette at NeXT
 *      Created.
 * 4  Aug 1993	  Erik Kay at NeXT
 *	API cleanup
 */

#ifndef	_IOHIDSYSTEM_H
#define _IOHIDSYSTEM_H

#include <TargetConditionals.h>
#include <IOKit/IOTimerEventSource.h>
#include <IOKit/IOInterruptEventSource.h>
#include <IOKit/IOService.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOUserClient.h>
#include <IOKit/IOCommandGate.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/pwr_mgt/IOPM.h>
#include "IOHIDWorkLoop.h"
#if TARGET_OS_EMBEDDED
class IOGraphicsDevice;
#else
#include <IOKit/graphics/IOGraphicsDevice.h>
#endif
#include <IOKit/hidsystem/IOHIDevice.h>
#include <IOKit/hidsystem/IOHIDShared.h>
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hidsystem/IOLLEvent.h>
#include <IOKit/IODataQueue.h>
#include <IOKit/hidsystem/ev_keymap.h>		/* For NX_NUM_SCANNED_SPECIALKEYS */


// The following messages should be unique across the entire system
#ifndef sub_iokit_hidsystem
#define sub_iokit_hidsystem                     err_sub(14)
#endif

#define kIOHIDSystem508MouseClickMessage        iokit_family_msg(sub_iokit_hidsystem, 1)
#define kIOHIDSystemDeviceSeizeRequestMessage	iokit_family_msg(sub_iokit_hidsystem, 2)
#define kIOHIDSystem508SpecialKeyDownMessage    iokit_family_msg(sub_iokit_hidsystem, 3)
// 4 is used by IOHIDSecurePrompt
#define kIOHIDSystemActivityTickle              iokit_family_msg(sub_iokit_hidsystem, 5)
#define kIOHIDSystemUserHidActivity             iokit_family_msg(sub_iokit_hidsystem, 6)


class IOHIDKeyboardDevice;
class IOHIDPointingDevice;
class IOHIDEvent;
class IOFixedPoint64;

class IOHIDSystem : public IOService
{
	OSDeclareDefaultStructors(IOHIDSystem);

	friend class IOHIDUserClient;
	friend class IOHIDParamUserClient;
	friend class IOHIDEventSystemUserClient;

private:
	IOHIDWorkLoop *		workLoop;
	IOTimerEventSource          *periodicES;
        IOInterruptEventSource * eventConsumerES;
        IOInterruptEventSource * keyboardEQES;
        IOCommandGate *		cmdGate;
	IOUserClient *		serverConnect;
	IOUserClient *		paramConnect;
        IONotifier *		eventPublishNotify;
        IONotifier *		eventTerminateNotify;
        IONotifier *		publishNotify;
        IONotifier *		terminateNotify;

        OSArray *		ioHIDevices;
    OSSet             * touchEventPosters;

	// Ports on which we hold send rights
	mach_port_t	eventPort;	// Send msg here when event queue
					// goes non-empty
    mach_port_t stackShotPort;
	mach_port_t	_specialKeyPort[NX_NUM_SCANNED_SPECIALKEYS]; // Special key msgs
	void		*eventMsg;	// Msg to be sent to Window Server.
	void		*stackShotMsg;	// Msg to be sent to Stack Shot.

	// Shared memory area information
    IOBufferMemoryDescriptor * globalMemory;
	uintptr_t	shmem_addr;	// kernel address of shared memory
	vm_size_t	shmem_size;	// size of shared memory

	// Pointers to structures which occupy the shared memory area.
	volatile void	*evs;		// Pointer to private driver shmem
	volatile EvGlobals *evg;	// Pointer to EvGlobals (shmem)
	// Internal variables related to the shared memory area
	int		lleqSize;	// # of entries in low-level queue
                        // FIXME: why is this ivar lleqSize an ivar? {Dan]

	// Screens list
	vm_size_t	evScreenSize;	// Byte size of evScreen array
	void		*evScreen;	// array of screens known to driver
	volatile void	*lastShmemPtr;	// Pointer used to index thru shmem
					// while assigning shared areas to
					// drivers.
	int		screens;	// running total of allocated screens
	UInt32		cursorScreens;	// bit mask of screens with cursor present
        UInt32		cursorPinScreen;// a screen to pin against
	IOGBounds		cursorPin;	// Range to which cursor is pinned
					// while on this screen.
	IOGBounds		workSpace;	// IOGBounds of full workspace.
	// Event Status state - This includes things like event timestamps,
	// time til screen dim, and related things manipulated through the
	// Event Status API.
	//
    struct ExpansionData;
    ExpansionData   *_privateData;

    IOGPoint	clickLoc;       // location of last mouse click
    IOGPoint    clickSpaceThresh;// max mouse delta to be a doubleclick

	int	clickState;	// Current click state

	bool evOpenCalled;	// Has the driver been opened?
	bool evInitialized;	// Has the first-open-only initialization run?
    bool evStateChanging;   // Is the event system state changing.
	bool eventsOpen;	// Boolean: has evmmap been called yet?
	bool cursorStarted;	// periodic events running?
	bool cursorEnabled;	// cursor positioning ok?
	bool cursorCoupled;	// cursor positioning on pointer moves ok?
	bool cursorPinned;	// cursor positioning on pointer moves ok?

	short leftENum;		// Unique ID for last left down event
	short rightENum;	// Unique ID for last right down event

	// The periodic event mechanism timestamps and state
	// are recorded here.
    uint64_t clickTime;		// Timestamps used to determine doubleclicks
    uint64_t clickTimeThresh;

    uint64_t lastEventTime;
    uint64_t lastUndimEvent;

	// Flag used in scheduling periodic event callbacks
	bool		needToKickEventConsumer;

        IOService *	displayManager;	// points to display manager
        IOPMPowerFlags	displayState;


        IOService *	rootDomain;
        AbsoluteTime	rootDomainStateChangeDeadline;
        AbsoluteTime    displayStateChangeDeadline;
        AbsoluteTime    displaySleepWakeupDeadline;
        bool  displaySleepDrivenByPM;

        OSDictionary *  savedParameters;	// keep user settings

        const char *    registryName;		// cache our name
        UInt32		maxWaitCursorFrame;	// animation frames
	UInt32		firstWaitCursorFrame;	//

        int		cachedEventFlags;
        OSArray *  cachedButtonStates;

        OSArray * systemInfo;

        IOHIDPointingDevice * _hidPointingDevice;
        IOHIDKeyboardDevice * _hidKeyboardDevice;

        /* The consumed keys array stores key codes for which a key down event
         * has been consumed and a corresponding key up event must be consumed
         * when it arrives.
         */
        OSArray * consumedKeys;

    OSObject * lastSender;

        UInt32 scrollZoomMask;

    bool setParamPropertiesInProgress;

    OSSet * dataQueueSet;

private:
    UInt8 getSubtypeForSender(OSObject * sender);
    void updateMouseEventForSender(OSObject * sender, NXEventData * evData);
    void updateMouseMoveEventForSender(OSObject * sender, NXEventData * evData);
    void updateScrollEventForSender(OSObject * sender, NXEventData * evData);

  inline short getUniqueEventNum();

  virtual IOReturn powerStateDidChangeTo( IOPMPowerFlags, unsigned long, IOService * );
  static IOReturn powerStateHandler( void *target, void *refCon,
               UInt32 messageType, IOService *service, void *messageArgument, vm_size_t argSize );
 /* Resets */
  void _resetMouseParameters();
    void    _setScrollCountParameters(OSDictionary *newSettings = NULL);

  /* Initialize the shared memory area */
  void     initShmem(bool clean);
  /* Dispatch low level events through shared memory to the WindowServer */
  void postEvent(       int        what,
          /* at */      IOFixedPoint64 *       location,
          /* atTime */  AbsoluteTime  ts,
          /* withData */NXEventData * myData,
          /* sender */  OSObject *    sender   = 0,
          /* pid */     UInt32        extPID   = 0,
          /* processKEQ*/bool          processKEQ = true);
  /* Dispatch mechanisms for screen state changes */
  void evDispatch(
            /* command */ EvCmd evcmd);
  /* Dispatch mechanism for special key press */
  void evSpecialKeyMsg(unsigned key,
               /* direction */ unsigned dir,
               /* flags */     unsigned f,
               /* level */     unsigned l);
  /* Message the event consumer to process posted events */
  void kickEventConsumer();
  void sendStackShotMessage(UInt32 flavor);

  OSDictionary * createFilteredParamPropertiesForService(IOService * service, OSDictionary * dict);

  static void _periodicEvents(IOHIDSystem * self,
                              IOTimerEventSource *timer);

  static void doSpecialKeyMsg(IOHIDSystem * self,
					struct evioSpecialKeyMsg *msg);
  static void doKickEventConsumer(IOHIDSystem * self);

  static void doProcessKeyboardEQ(IOHIDSystem * self);
  static void processKeyboardEQ(IOHIDSystem * self, AbsoluteTime * deadline = 0);

  void doProcessNotifications();
  
  bool genericNotificationHandler(void * ref, IOService * newService, IONotifier * notifier );

  static bool handlePublishNotification( void * target, IOService * newService );
  static bool handlePublishNotificationGated( void * target, IOService * newService );

  static bool handleTerminateNotification( void * target, IOService * service );
  static bool handleTerminateNotificationGated( void * target, IOService * newService );

  static void makeNumberParamProperty( OSDictionary * dict, const char * key,
                            unsigned long long number, unsigned int bits );

  static void makeInt32ArrayParamProperty( OSDictionary * dict, const char * key,
                            UInt32 * array, unsigned int count );

/*
 * HISTORICAL NOTE:
 *   The following methods were part of the IOHIDSystem(Input) category;
 *   the declarations have now been merged directly into this class.
 *
 * Exported Interface Event Driver object input services.
 */

private:
  // Schedule next periodic run based on current event system state.
  void scheduleNextPeriodicEvent();
  // Message invoked to run periodic events.  This method runs in the workloop.
  void periodicEvents(IOTimerEventSource *timer);
  // Start the cursor running.
  bool startCursor();
  // Repin cursor location.
  bool resetCursor();
  // Wait Cursor machinery.
  void showWaitCursor();
  void hideWaitCursor();
  void animateWaitCursor();
  void changeCursor(int frame);
  // Return screen number a point lies on.
  int  pointToScreen(IOGPoint * p);

  inline void showCursor();
  inline void hideCursor();
  inline void moveCursor();
  void enableContinuousCursor();
  void disableContinuousCursor();
  void _onScreenCursorPin();
  // Claim ownership of event sources.
  void attachDefaultEventSources();
  // Give up ownership of event sources.
  void detachEventSources();
  bool registerEventSource(IOService * source);

  // Set abs cursor position.
  void setCursorPosition(IOGPoint * newLoc, bool external, OSObject * sender=0);
  void _setButtonState(int buttons,
                       /* atTime */ AbsoluteTime ts,
                       OSObject * sender);
  void _setCursorPosition(bool external = false, bool proximityChange = false, OSObject * sender=0);

    static bool _idleTimeSerializerCallback(void * target, void * ref, OSSerialize *s);
    static bool _displaySerializerCallback(void * target, void * ref, OSSerialize *s);

  void _postMouseMoveEvent(int		what,
                           AbsoluteTime	theClock,
                           OSObject *	sender);
  void createParameters( void );

/* END HISTORICAL NOTE */

public:
  static IOHIDSystem * instance();     /* Return the current instance of the */
				       /* EventDriver, or 0 if none. */
  static void scaleLocationToCurrentScreen(IOGPoint *location, IOGBounds *bounds);

  virtual bool init(OSDictionary * properties = 0);
  virtual IOHIDSystem * probe(IOService *    provider,
                              SInt32 * score);
  virtual bool start(IOService * provider);
  virtual IOReturn message(UInt32 type, IOService * provider,
				void * argument);
  virtual void free();
  virtual bool attach( IOService * provider );
  virtual void detach( IOService * provider );

  virtual IOWorkLoop *getWorkLoop() const;

  virtual IOReturn evOpen(void);
  virtual IOReturn evClose(void);

  virtual IOReturn  setProperties( OSObject * properties );
  virtual IOReturn  setParamProperties(OSDictionary * dict);

  /* Create the shared memory area */
  virtual IOReturn createShmem(void*,void*,void*,void*,void*,void*);

  /* register the IODataQueue for the new user events */
  virtual IOReturn registerEventQueue(IODataQueue * queue);

  /* Unregister the IODataQueue for the new user events */
  virtual IOReturn unregisterEventQueue(IODataQueue * queue);

  /* Set the port for event available notify msg */
  virtual void     setEventPort(mach_port_t port);

  /* Set if display sleep is driven by IOPMrootDomain */
  void setDisplaySleepDrivenByPM(bool val);
private:
    static IOReturn doSetEventPort(IOHIDSystem *self, void *port_void, void *arg1, void *arg2, void *arg3);
    void            setEventPortGated(mach_port_t port);
public:

  /* Set the port for the special key keypress msg */
  virtual IOReturn setSpecialKeyPort(
                     /* keyFlavor */ int         special_key,
                     /* keyPort */   mach_port_t key_port);
  virtual mach_port_t specialKeyPort(int special_key);


  virtual IOReturn newUserClient(task_t         owningTask,
                 /* withToken */ void *         security_id,
                 /* ofType */    UInt32         type,
                 /* withProps*/  OSDictionary *  properties,
                 /* client */    IOUserClient ** handler);

/*
 * HISTORICAL NOTE:
 *   The following methods were part of the IOHIPointingEvents protocol;
 *   the declarations have now been merged directly into this class.
 */

public:
  /* Mouse event reporting */
  virtual void relativePointerEvent(int        buttons,
                       /* deltaX */ int        dx,
                       /* deltaY */ int        dy,
                       /* atTime */ AbsoluteTime ts);

  /* Tablet event reporting */
  virtual void absolutePointerEvent(int        buttons,
                 /* at */           IOGPoint *    newLoc,
                 /* withBounds */   IOGBounds *bounds,
                 /* inProximity */  bool       proximity,
                 /* withPressure */ int        pressure,
                 /* withAngle */    int        stylusAngle,
                 /* atTime */       AbsoluteTime ts);

  /* Mouse scroll wheel event reporting */
  virtual void scrollWheelEvent(short deltaAxis1,
                                short deltaAxis2,
                                short deltaAxis3,
                                AbsoluteTime ts);


  virtual void tabletEvent(NXEventData *tabletData,
                           AbsoluteTime ts);

  virtual void proximityEvent(NXEventData *proximityData,
                              AbsoluteTime ts);

/*
 * HISTORICAL NOTE:
 *   The following methods were part of the IOHIKeyboardEvents protocol;
 *   the declarations have now been merged directly into this class.
 */

public:
  virtual void keyboardEvent(unsigned   eventType,
      /* flags */            unsigned   flags,
      /* keyCode */          unsigned   key,
      /* charCode */         unsigned   charCode,
      /* charSet */          unsigned   charSet,
      /* originalCharCode */ unsigned   origCharCode,
      /* originalCharSet */  unsigned   origCharSet,
      /* keyboardType */     unsigned   keyboardType,
      /* repeat */           bool       repeat,
      /* atTime */           AbsoluteTime ts);

  virtual void keyboardSpecialEvent(   unsigned   eventType,
                    /* flags */        unsigned   flags,
                    /* keyCode  */     unsigned   key,
                    /* specialty */    unsigned   flavor,
                    /* guid */ 	       UInt64     guid,
                    /* repeat */       bool       repeat,
                    /* atTime */       AbsoluteTime ts);

  virtual void updateEventFlags(unsigned flags);  /* Does not generate events */




private:

  /*
   * statics for upstream callouts
   */

  void _scaleLocationToCurrentScreen(IOFixedPoint64 &location, IOGBounds *bounds);

  static void _relativePointerEvent(IOHIDSystem * self,
				    int        buttons,
                       /* deltaX */ int        dx,
                       /* deltaY */ int        dy,
                       /* atTime */ AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  /* Tablet event reporting */
  static void _absolutePointerEvent(IOHIDSystem * self,
				    int        buttons,
                 /* at */           IOGPoint *    newLoc,
                 /* withBounds */   IOGBounds *bounds,
                 /* inProximity */  bool       proximity,
                 /* withPressure */ int        pressure,
                 /* withAngle */    int        stylusAngle,
                 /* atTime */       AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  /* Mouse scroll wheel event reporting */
  static void _scrollWheelEvent(    IOHIDSystem *self,
                                    short      deltaAxis1,
                                    short      deltaAxis2,
                                    short      deltaAxis3,
                                    IOFixed    fixedDelta1,
                                    IOFixed    fixedDelta2,
                                    IOFixed    fixedDelta3,
                                    SInt32  pointDeltaAxis1,
                                    SInt32  pointDeltaAxis2,
                                    SInt32  pointDeltaAxis3,
                                    UInt32  options,
                                    AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  static void _tabletEvent(         IOHIDSystem *self,
                                    NXEventData *tabletData,
                                    AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  static void _proximityEvent(      IOHIDSystem *self,
                                    NXEventData *proximityData,
                                    AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  static void _keyboardEvent(       IOHIDSystem * self,
                                    unsigned   eventType,
            /* flags */             unsigned   flags,
            /* keyCode */           unsigned   key,
            /* charCode */          unsigned   charCode,
            /* charSet */           unsigned   charSet,
            /* originalCharCode */  unsigned   origCharCode,
            /* originalCharSet */   unsigned   origCharSet,
            /* keyboardType */      unsigned   keyboardType,
            /* repeat */            bool       repeat,
            /* atTime */            AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  static void _keyboardSpecialEvent(IOHIDSystem * self,
                                    unsigned   eventType,
                /* flags */         unsigned   flags,
                /* keyCode  */      unsigned   key,
                /* specialty */     unsigned   flavor,
                /* guid */          UInt64     guid,
                /* repeat */        bool       repeat,
                /* atTime */        AbsoluteTime ts,
                                    OSObject * sender,
                                    void *     refcon);

  static void _updateEventFlags(    IOHIDSystem * self,
                                    unsigned   flags,
                                    OSObject * sender,
                                    void *     refcon);  /* Does not generate events */


/*
 * HISTORICAL NOTE:
 *   The following methods were part of the IOUserClient protocol;
 *   the declarations have now been merged directly into this class.
 */

public:

  virtual IOReturn setEventsEnable(void*,void*,void*,void*,void*,void*);
  virtual IOReturn setCursorEnable(void*,void*,void*,void*,void*,void*);
  virtual IOReturn extPostEvent(void*,void*,void*,void*,void*,void*);
  virtual IOReturn extSetMouseLocation(void*,void*,void*,void*,void*,void*);
  virtual IOReturn extGetButtonEventNum(void*,void*,void*,void*,void*,void*);
    
    IOReturn extSetBounds(void*,void*,void*,void*,void*,void*);
    IOReturn extSetOnScreenBounds(void*,void*,void*,void*,void*,void*);
    IOReturn setBounds(IOGBounds * bounds, IOGPoint * screenPoint, bool onScreen);

    IOReturn extGetStateForSelector(void*,void*,void*,void*,void*,void*);
    IOReturn extSetStateForSelector(void*,void*,void*,void*,void*,void*);
    IOReturn extRegisterVirtualDisplay(void*,void*,void*,void*,void*,void*);
    IOReturn extUnregisterVirtualDisplay(void*,void*,void*,void*,void*,void*);
    IOReturn extSetVirtualDisplayBounds(void*,void*,void*,void*,void*,void*);
    IOReturn extGetUserHidActivityState(void*,void*,void*,void*,void*,void*);
    IOReturn setContinuousCursorEnable(void*,void*,void*,void*,void*,void*);
/*
 * HISTORICAL NOTE:
 *   The following methods were part of the IOScreenRegistration protocol;
 *   the declarations have now been merged directly into this class.
 *
 * Methods exported by the EventDriver for display systems.
 *
 *	The screenRegister protocol is used by frame buffer drivers to register
 *	themselves with the Event Driver.  These methods are called in response
 *	to an _IOGetParameterInIntArray() call with "IO_Framebuffer_Register" or
 *	"IO_Framebuffer_Unregister".
 */

public:
  virtual int registerScreen(IOGraphicsDevice * instance,
        /* bounds */         IOGBounds * bp,
        /* virtual bounds */ IOGBounds * vbp);
private:
    static IOReturn doRegisterScreen(IOHIDSystem *self, IOGraphicsDevice *io_gd, IOGBounds *bp, IOGBounds * vbp, void *arg3);
    IOReturn        registerScreenGated(IOGraphicsDevice *io_gd, IOGBounds *bp, IOGBounds * vbp, SInt32 *index);
public:


  virtual void unregisterScreen(int index);

/*
 * HISTORICAL NOTE:
 *   The following methods were part of the IOWorkspaceBounds protocol;
 *   the declarations have now been merged directly into this class.
 *
 * Absolute position input devices and some specialized output devices
 * may need to know the bounding rectangle for all attached displays.
 * The following method returns a IOGBounds* for the workspace.  Please note
 * that the bounds are kept as signed values, and that on a multi-display
 * system the minx and miny values may very well be negative.
 */

public:
  virtual IOGBounds * workspaceBounds();

/* END HISTORICAL NOTES */

private:
void relativePointerEvent(          int        buttons,
                 /* deltaX */       int        dx,
                 /* deltaY */       int        dy,
                 /* atTime */       AbsoluteTime ts,
                 /* senderID */     OSObject * sender);

  /* Tablet event reporting */
void absolutePointerEvent(          int        buttons,
                 /* at */           IOGPoint *    newLoc,
                 /* withBounds */   IOGBounds *bounds,
                 /* inProximity */  bool       proximity,
                 /* withPressure */ int        pressure,
                 /* withAngle */    int        stylusAngle,
                 /* atTime */       AbsoluteTime ts,
                 /* senderID */     OSObject * sender);

  /* Mouse scroll wheel event reporting */
void scrollWheelEvent(	        short 	       deltaAxis1,
                                short          deltaAxis2,
                                short          deltaAxis3,
                                IOFixed        fixedDelta1,
                                IOFixed        fixedDelta2,
                                IOFixed        fixedDelta3,
                                SInt32         pointDeltaAxis1,
                                SInt32         pointDeltaAxis2,
                                SInt32         pointDeltaAxis3,
                                UInt32         options,
                                AbsoluteTime   ts,
                                OSObject *     sender);

void tabletEvent(	NXEventData * tabletData,
                                AbsoluteTime ts,
                                OSObject * sender);

void proximityEvent(	NXEventData * proximityData,
                                AbsoluteTime ts,
                                OSObject * sender);

void keyboardEvent(unsigned   eventType,
      /* flags */            unsigned   flags,
      /* keyCode */          unsigned   key,
      /* charCode */         unsigned   charCode,
      /* charSet */          unsigned   charSet,
      /* originalCharCode */ unsigned   origCharCode,
      /* originalCharSet */  unsigned   origCharSet,
      /* keyboardType */     unsigned   keyboardType,
      /* repeat */           bool       repeat,
      /* atTime */           AbsoluteTime ts,
      /* sender */           OSObject * sender);

void keyboardSpecialEvent(   unsigned   eventType,
      /* flags */        unsigned   flags,
      /* keyCode  */     unsigned   key,
      /* specialty */    unsigned   flavor,
      /* guid */         UInt64     guid,
      /* repeat */       bool       repeat,
      /* atTime */       AbsoluteTime ts,
      /* sender */       OSObject * sender);

void updateEventFlags(unsigned flags, OSObject * sender);

bool addConsumedKey(unsigned key);
bool removeConsumedKey(unsigned key);

/*
 * COMMAND GATE COMPATIBILITY:
 *   The following method is part of the work needed to make IOHIDSystem
 *   compatible with IOCommandGate.  The use of IOCommandQueue has been
 *   deprecated, thus requiring this move.  This should allow for less
 *   context switching as all actions formerly run on the I/O Workloop
 *   thread, will now be run on the caller thread.  The static methods
 *   will be called from cmdGate->runAction and returns the appropriate
 *   non-static helper method.  Arguments are stored in the void* array,
 *   args, and are passed through.   Since we are returning in the static
 *   function, gcc3 should translate that to one instruction, thus
 *   minimizing cost.
 */

static	IOReturn	doEvClose (IOHIDSystem *self);
        IOReturn	evCloseGated (void);

static	IOReturn	doSetEventsEnablePre (IOHIDSystem *self, void *p1);
        IOReturn	setEventsEnablePreGated (void *p1);

static	IOReturn	doSetEventsEnablePost (IOHIDSystem *self, void *p1);
        IOReturn	setEventsEnablePostGated (void *p1);

static	IOReturn	doUnregisterScreen (IOHIDSystem *self, void * arg0, void *arg1);
        IOReturn	unregisterScreenGated (int index, bool internal);

static	IOReturn	doSetDisplayBounds (IOHIDSystem *self, void * arg0, void * arg1);
        IOReturn	setDisplayBoundsGated (UInt32 index, IOGBounds *bounds);

static	IOReturn	doCreateShmem (IOHIDSystem *self, void * arg0);
        IOReturn	createShmemGated (void * p1);

static	IOReturn	doRegisterEventQueue (IOHIDSystem *self, void * arg0);
        IOReturn	registerEventQueueGated (void * p1);

static	IOReturn	doUnregisterEventQueue (IOHIDSystem *self, void * arg0);
        IOReturn	unregisterEventQueueGated (void * p1);

static	IOReturn	doRelativePointerEvent (IOHIDSystem *self, void * args);
        void		relativePointerEventGated(int buttons,
                                                    int dx,
                                                    int dy,
                                                    SInt64 ts,
                                                    OSObject * sender);

static	IOReturn	doAbsolutePointerEvent (IOHIDSystem *self, void * args);
        void 		absolutePointerEventGated (int buttons,
                                                    IOGPoint *    newLoc,
                                                    IOGBounds *bounds,
                                                    bool       proximity,
                                                    int        pressure,
                                                    int        stylusAngle,
                                                    AbsoluteTime ts,
                                                    OSObject * sender);

static	IOReturn	doScrollWheelEvent(IOHIDSystem *self, void * args);
        void		scrollWheelEventGated (short deltaAxis1,
                                                short deltaAxis2,
                                                short deltaAxis3,
                                               IOFixed  fixedDelta1,
                                               IOFixed  fixedDelta2,
                                               IOFixed  fixedDelta3,
                                               SInt32   pointDeltaAxis1,
                                               SInt32   pointDeltaAxis2,
                                               SInt32   pointDeltaAxis3,
                                               UInt32   options,
                                                AbsoluteTime ts,
                                                OSObject * sender);

static	IOReturn	doTabletEvent (IOHIDSystem *self, void * arg0, void * arg1, void * arg2);
        void		tabletEventGated (	NXEventData *tabletData,
                                                AbsoluteTime ts,
                                                OSObject * sender);

static	IOReturn	doProximityEvent (IOHIDSystem *self, void * arg0, void * arg1, void * arg2);
        void		proximityEventGated (	NXEventData *proximityData,
                                                AbsoluteTime ts,
                                                OSObject * sender);

static	IOReturn	doKeyboardEvent (IOHIDSystem *self, void * args);
        void		keyboardEventGated (unsigned   eventType,
                                            unsigned   flags,
                                            unsigned   key,
                                            unsigned   charCode,
                                            unsigned   charSet,
                                            unsigned   origCharCode,
                                            unsigned   origCharSet,
                                            unsigned   keyboardType,
                                            bool       repeat,
                                            AbsoluteTime ts,
                                            OSObject * sender);

static	IOReturn	doKeyboardSpecialEvent (IOHIDSystem *self, void * args);
        void		keyboardSpecialEventGated (
                                            unsigned   eventType,
                                            unsigned   flags,
                                            unsigned   key,
                                            unsigned   flavor,
                                            UInt64     guid,
                                            bool       repeat,
                                            AbsoluteTime ts,
                                            OSObject * sender);

static	IOReturn	doUpdateEventFlags (IOHIDSystem *self, void * args);
        void		updateEventFlagsGated (unsigned flags, OSObject * sender);

static	IOReturn	doNewUserClient (IOHIDSystem *self, void * args);
        IOReturn 	newUserClientGated (task_t owningTask,
                                            void * security_id,
                                            UInt32 type,
                                            OSDictionary *  properties,
                                            IOUserClient ** handler);

static	IOReturn	doSetCursorEnable (IOHIDSystem *self, void * arg0);
        IOReturn	setCursorEnableGated (void * p1);

static	IOReturn	doSetContinuousCursorEnable (IOHIDSystem *self, void * arg0);
        IOReturn	setContinuousCursorEnableGated (void * p1);

static	IOReturn	doExtPostEvent(IOHIDSystem *self, void * arg0, void * arg1, void * arg2, void * arg3);
        IOReturn	extPostEventGated (void * p1, void * p2, void * p3);

static	IOReturn	doExtSetMouseLocation (IOHIDSystem *self, void * args);
        IOReturn	extSetMouseLocationGated (void * args);

static	IOReturn	doExtGetButtonEventNum (IOHIDSystem *self, void * arg0, void * arg1);
        IOReturn	extGetButtonEventNumGated (void * p1, void * p2);

static	IOReturn	doSetParamPropertiesPre (IOHIDSystem *self, void * arg0, void * arg1);
        IOReturn	setParamPropertiesPreGated (OSDictionary * dict, OSIterator ** pOpenIter);

static	IOReturn	doSetParamPropertiesPost (IOHIDSystem *self, void * arg0);
        IOReturn	setParamPropertiesPostGated (OSDictionary * dict);

        IOReturn  updateParamPropertiesGated(IOService * source);

static	IOReturn	doExtGetStateForSelector (IOHIDSystem *self, void *p1, void *p2);
static	IOReturn	doExtSetStateForSelector (IOHIDSystem *self, void *p1, void *p2);
        IOReturn    getCapsLockState(unsigned int *state_O);
        IOReturn    setCapsLockState(unsigned int state_I);
        IOReturn    getNumLockState(unsigned int *state_O);
        IOReturn    setNumLockState(unsigned int state_I);

/* END COMMAND GATE COMPATIBILITY */

public:
    virtual void setStackShotPort(mach_port_t port);

    virtual UInt32 eventFlags();

    virtual void dispatchEvent(IOHIDEvent *event, IOOptionBits options=0);

    void updateHidActivity();
    void hidActivityChecker();
    static void reportUserHidActivity(IOHIDSystem *self, void *args );
    void reportUserHidActivityGated(void *args );

    static IOReturn getUserHidActivityState(IOHIDSystem *self, void *arg0);
    IOReturn getUserHidActivityStateGated(void *state);
};

#endif /* !_IOHIDSYSTEM_H */
                                                                                                                              IOHIDTypes.h                                                                                        0100644 0001750 0001750 00000013660 12567452123 036073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/******************************************************************************
	ev_types.h
	Data types for the events status driver.
	This file contains public API.
	mpaque 11Oct91
	
	Copyright 1991 NeXT Computer, Inc.
	Copyright 1997-2011 Apple, Inc.
	
	Modified:
	
******************************************************************************/

#ifndef _DEV_EV_TYPES_H
#define _DEV_EV_TYPES_H

#include <mach/boolean.h>
#include <libkern/OSAtomic.h>
#include <IOKit/graphics/IOGraphicsTypes.h>

// This should be removed, but is being used by others
// <rdar://problem/8917741> IOHIDFamily-355 causes projects to fail to build with 'ev_lock_data_t' does not name a type
#include <IOKit/IOSharedLock.h>

/* Shared memory versions */
#define EVENT_SYSTEM_VERSION   2

/* Maximum length of SetMouseScaling arrays */
#define NX_MAXMOUSESCALINGS 20

typedef struct evsioKeymapping		/* Match old struct names in kernel */
{
    int size;
    char *mapping;
} NXKeyMapping;

typedef struct evsioMouseScaling	/* Match old struct names in kernel */
{
    int numScaleLevels;
    short scaleThresholds[NX_MAXMOUSESCALINGS];
    short scaleFactors[NX_MAXMOUSESCALINGS];
} NXMouseScaling;

typedef enum {
    NX_OneButton,
    NX_LeftButton,
    NX_RightButton
} NXMouseButton;

// IOFixedPoint32 is a 24.8 format
typedef struct __IOFixedPoint32 {
    int32_t     x;
    int32_t     y;
} IOFixedPoint32;

/*
 * NXEventSystemInfo() information structures.  These are designed to
 * allow for expansion.
 *
 * The current implementation of NXEventSystemInfo() uses an ioctl call.
 * THIS WILL CHANGE.
 */
 
/*
 * Generic query max size and typedefs.
 *
 *	The maximum size is selected to support anticipated future extensions
 *	of request flavors.  Certain flavors planned for future releases may 
 *	require roughtly 800 ints to represent.  We allow a little extra, in
 *	case further growth is needed.
 */
typedef int *NXEventSystemInfoType;
#define NX_EVS_INFO_MAX		(1024)	/* Max array size */
typedef int NXEventSystemInfoData[NX_EVS_INFO_MAX];

/* Event System Devices query */
#define NX_EVS_DEVICE_MAX	16

	/* Interface types */
#define NX_EVS_DEVICE_INTERFACE_OTHER		0
#define NX_EVS_DEVICE_INTERFACE_NeXT		1 // NeXT custom, in older sys
#define NX_EVS_DEVICE_INTERFACE_ADB		2 // NeXT/fruit keybds/mice
#define NX_EVS_DEVICE_INTERFACE_ACE		3 // For x86 PC keyboards
#define NX_EVS_DEVICE_INTERFACE_SERIAL_ACE	4 // For PC serial mice 
#define NX_EVS_DEVICE_INTERFACE_BUS_ACE		5 // For PC bus mice 
#define NX_EVS_DEVICE_INTERFACE_HIL		6 // For HIL hp keyboard 
#define NX_EVS_DEVICE_INTERFACE_TYPE5		7 // For Sun Type5 keyboard

/*
 * Note! if any new interface types are added above, the following
 * definition of the number of interfaces supported must reflect this.
 * This is used in the libkeymap project (storemap.c module) which needs
 * to be cognizant of the number of new devices coming online
 * via support for heterogeneous architecture platforms.
 * e.g., PCs, HP's HIL, Sun's Type5 keyboard,...
 */
#define NUM_SUPPORTED_INTERFACES	(NX_EVS_DEVICE_INTERFACE_TYPE5 + 1)
					// Other, NeXT, ADB, ACE,...

	/* Device types */
#define NX_EVS_DEVICE_TYPE_OTHER	0
#define NX_EVS_DEVICE_TYPE_KEYBOARD	1
#define NX_EVS_DEVICE_TYPE_MOUSE	2	// Relative position devices
#define NX_EVS_DEVICE_TYPE_TABLET	3	// Absolute position devices

typedef struct {
	int	interface;	/* NeXT, ADB, other */
	int	interface_addr;	/* Device address on the interface */
	int	dev_type;	/* Keyboard, mouse, tablet, other */
	int	id;		/* manufacturer's device handler ID */
} NXEventSystemDevice;

typedef struct {
	NXEventSystemDevice	dev[NX_EVS_DEVICE_MAX];
} NXEventSystemDeviceList;

#define __OLD_NX_EVS_DEVICE_INFO		1
#define NX_EVS_DEVICE_INFO			"Evs_EventDeviceInfo"
#define NX_EVS_DEVICE_INFO_COUNT \
	(sizeof (NXEventSystemDeviceList) / sizeof (int))

/*
 * Types used in evScreen protocol compliant operations.
 */

typedef enum {EVNOP, EVHIDE, EVSHOW, EVMOVE, EVLEVEL} EvCmd; /* Cursor state */

#define EV_SCREEN_MIN_BRIGHTNESS	0
#define EV_SCREEN_MAX_BRIGHTNESS	64
/* Scale should lie between MIN_BRIGHTNESS and MAX_BRIGHTNESS */
#define EV_SCALE_BRIGHTNESS( scale, datum ) \
	((((UInt32)(datum))*((UInt32)scale)) >> 6)

/*
 * Definition of a tick, as a time in milliseconds. This controls how
 * often the event system periodic jobs are run.  All actual tick times
 * are derived from the nanosecond timer.  These values are typically used
 * as part of computing mouse velocity for acceleration purposes.
 */
#define EV_TICK_TIME		16			/* 16 milliseconds */
#define EV_TICKS_PER_SEC	(1000/EV_TICK_TIME)	/* ~ 62 Hz */

/* Mouse Button bits, as passed from an EventSrc to the Event Driver */
#define EV_RB			(0x01)
#define EV_LB			(0x04)
#define EV_MOUSEBUTTONMASK	(EV_LB | EV_RB)

/* Tablet Pressure Constants, as passed from an EventSrc to the Event Driver */
#define EV_MINPRESSURE 0
#define EV_MAXPRESSURE 255

/* Cursor size in pixels */
#define EV_CURSOR_WIDTH		16
#define EV_CURSOR_HEIGHT	16


#define kAppleOnboardGUID 	0x0610000000000000ULL

#endif /* !_DEV_EV_TYPES_H */

                                                                                IOHIDUsageTables.h                                                                                  0100644 0001750 0001750 00000416451 12567452123 037173  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOHIDUSAGETABLES_H
#define _IOHIDUSAGETABLES_H

/* ******************************************************************************************
 * HID Usage Tables
 *
 * The following constants are from the USB 'HID Usage Tables' specification, revision 1.1rc3
 * ****************************************************************************************** */


/* Usage Pages */
enum
{
    kHIDPage_Undefined              = 0x00,
    kHIDPage_GenericDesktop         = 0x01,
    kHIDPage_Simulation             = 0x02,
    kHIDPage_VR                     = 0x03,
    kHIDPage_Sport                  = 0x04,
    kHIDPage_Game                   = 0x05,
    kHIDPage_GenericDeviceControls  = 0x06,
    kHIDPage_KeyboardOrKeypad       = 0x07,    /* USB Device Class Definition for Human Interface Devices (HID). Note: the usage type for all key codes is Selector (Sel). */
    kHIDPage_LEDs                   = 0x08,
    kHIDPage_Button                 = 0x09,
    kHIDPage_Ordinal                = 0x0A,
    kHIDPage_Telephony              = 0x0B,
    kHIDPage_Consumer               = 0x0C,
    kHIDPage_Digitizer              = 0x0D,
    /* Reserved 0x0E */
    kHIDPage_PID                    = 0x0F,    /* USB Physical Interface Device definitions for force feedback and related devices. */
    kHIDPage_Unicode                = 0x10,
    /* Reserved 0x11 - 0x13 */
    kHIDPage_AlphanumericDisplay    = 0x14,
    /* Reserved 0x15 - 0x1F */
    kHIDPage_Sensor                 = 0x20,
    /* Reserved 0x21 - 0x7f */
    kHIDPage_Monitor                = 0x80,
    kHIDPage_MonitorEnumerated      = 0x81,
    kHIDPage_MonitorVirtual         = 0x82,
    kHIDPage_MonitorReserved        = 0x83,
    /* Power 0x84 - 0x87     USB Device Class Definition for Power Devices */
    kHIDPage_PowerDevice            = 0x84,                 /* Power Device Page */
    kHIDPage_BatterySystem          = 0x85,                 /* Battery System Page */
    kHIDPage_PowerReserved          = 0x86,
    kHIDPage_PowerReserved2         = 0x87,
    /* Reserved 0x88 - 0x8B */
    kHIDPage_BarCodeScanner         = 0x8C,    /* (Point of Sale) USB Device Class Definition for Bar Code Scanner Devices */
    kHIDPage_WeighingDevice         = 0x8D,    /* (Point of Sale) USB Device Class Definition for Weighing Devices */
    kHIDPage_Scale                  = 0x8D,    /* (Point of Sale) USB Device Class Definition for Scale Devices */
    kHIDPage_MagneticStripeReader   = 0x8E,
    /* ReservedPointofSalepages 0x8F */
    kHIDPage_CameraControl          = 0x90,    /* USB Device Class Definition for Image Class Devices */
    kHIDPage_Arcade                 = 0x91,    /* OAAF Definitions for arcade and coinop related Devices */
    /* Reserved 0x92 - 0xFEFF */
    /* VendorDefined 0xFF00 - 0xFFFF */
    kHIDPage_VendorDefinedStart     = 0xFF00
};

/* Undefined Usage for all usage pages */
enum
{
    kHIDUsage_Undefined    = 0x00
};

/* GenericDesktop Page (0x01) */
enum
{
    kHIDUsage_GD_Pointer    = 0x01,    /* Physical Collection */
    kHIDUsage_GD_Mouse    = 0x02,    /* Application Collection */
    /* 0x03 Reserved */
    kHIDUsage_GD_Joystick    = 0x04,    /* Application Collection */
    kHIDUsage_GD_GamePad    = 0x05,    /* Application Collection */
    kHIDUsage_GD_Keyboard    = 0x06,    /* Application Collection */
    kHIDUsage_GD_Keypad    = 0x07,    /* Application Collection */
    kHIDUsage_GD_MultiAxisController    = 0x08,    /* Application Collection */
    /* 0x09 - 0x2F Reserved */
    kHIDUsage_GD_X    = 0x30,    /* Dynamic Value */
    kHIDUsage_GD_Y    = 0x31,    /* Dynamic Value */
    kHIDUsage_GD_Z    = 0x32,    /* Dynamic Value */
    kHIDUsage_GD_Rx    = 0x33,    /* Dynamic Value */
    kHIDUsage_GD_Ry    = 0x34,    /* Dynamic Value */
    kHIDUsage_GD_Rz    = 0x35,    /* Dynamic Value */
    kHIDUsage_GD_Slider    = 0x36,    /* Dynamic Value */
    kHIDUsage_GD_Dial    = 0x37,    /* Dynamic Value */
    kHIDUsage_GD_Wheel    = 0x38,    /* Dynamic Value */
    kHIDUsage_GD_Hatswitch    = 0x39,    /* Dynamic Value */
    kHIDUsage_GD_CountedBuffer    = 0x3A,    /* Logical Collection */
    kHIDUsage_GD_ByteCount    = 0x3B,    /* Dynamic Value */
    kHIDUsage_GD_MotionWakeup    = 0x3C,    /* One-Shot Control */
    kHIDUsage_GD_Start    = 0x3D,    /* On/Off Control */
    kHIDUsage_GD_Select    = 0x3E,    /* On/Off Control */
    /* 0x3F Reserved */
    kHIDUsage_GD_Vx    = 0x40,    /* Dynamic Value */
    kHIDUsage_GD_Vy    = 0x41,    /* Dynamic Value */
    kHIDUsage_GD_Vz    = 0x42,    /* Dynamic Value */
    kHIDUsage_GD_Vbrx    = 0x43,    /* Dynamic Value */
    kHIDUsage_GD_Vbry    = 0x44,    /* Dynamic Value */
    kHIDUsage_GD_Vbrz    = 0x45,    /* Dynamic Value */
    kHIDUsage_GD_Vno    = 0x46,    /* Dynamic Value */
    /* 0x47 - 0x7F Reserved */
    kHIDUsage_GD_SystemControl    = 0x80,    /* Application Collection */
    kHIDUsage_GD_SystemPowerDown    = 0x81,    /* One-Shot Control */
    kHIDUsage_GD_SystemSleep    = 0x82,    /* One-Shot Control */
    kHIDUsage_GD_SystemWakeUp    = 0x83,    /* One-Shot Control */
    kHIDUsage_GD_SystemContextMenu    = 0x84,    /* One-Shot Control */
    kHIDUsage_GD_SystemMainMenu    = 0x85,    /* One-Shot Control */
    kHIDUsage_GD_SystemAppMenu    = 0x86,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuHelp    = 0x87,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuExit    = 0x88,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuSelect    = 0x89,    /* Selector */
    kHIDUsage_GD_SystemMenu    = kHIDUsage_GD_SystemMenuSelect,    /* Selector */
    kHIDUsage_GD_SystemMenuRight    = 0x8A,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuLeft    = 0x8B,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuUp    = 0x8C,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuDown    = 0x8D,    /* Re-Trigger Control */
    /* 0x8E - 0x8F Reserved */
    kHIDUsage_GD_DPadUp    = 0x90,    /* On/Off Control */
    kHIDUsage_GD_DPadDown    = 0x91,    /* On/Off Control */
    kHIDUsage_GD_DPadRight    = 0x92,    /* On/Off Control */
    kHIDUsage_GD_DPadLeft    = 0x93,    /* On/Off Control */
    /* 0x94 - 0xFFFF Reserved */
    kHIDUsage_GD_Reserved = 0xFFFF
};

/* Simulation Page (0x02) */
/* This section provides detailed descriptions of the usages employed by simulation devices. */
enum
{
    kHIDUsage_Sim_FlightSimulationDevice    = 0x01,    /* Application Collection */
    kHIDUsage_Sim_AutomobileSimulationDevice    = 0x02,    /* Application Collection */
    kHIDUsage_Sim_TankSimulationDevice    = 0x03,    /* Application Collection */
    kHIDUsage_Sim_SpaceshipSimulationDevice    = 0x04,    /* Application Collection */
    kHIDUsage_Sim_SubmarineSimulationDevice    = 0x05,    /* Application Collection */
    kHIDUsage_Sim_SailingSimulationDevice    = 0x06,    /* Application Collection */
    kHIDUsage_Sim_MotorcycleSimulationDevice    = 0x07,    /* Application Collection */
    kHIDUsage_Sim_SportsSimulationDevice    = 0x08,    /* Application Collection */
    kHIDUsage_Sim_AirplaneSimulationDevice    = 0x09,    /* Application Collection */
    kHIDUsage_Sim_HelicopterSimulationDevice    = 0x0A,    /* Application Collection */
    kHIDUsage_Sim_MagicCarpetSimulationDevice    = 0x0B,    /* Application Collection */
    kHIDUsage_Sim_BicycleSimulationDevice    = 0x0C,    /* Application Collection */
    /* 0x0D - 0x1F Reserved */
    kHIDUsage_Sim_FlightControlStick    = 0x20,    /* Application Collection */
    kHIDUsage_Sim_FlightStick    = 0x21,    /* Application Collection */
    kHIDUsage_Sim_CyclicControl    = 0x22,    /* Physical Collection */
    kHIDUsage_Sim_CyclicTrim    = 0x23,    /* Physical Collection */
    kHIDUsage_Sim_FlightYoke    = 0x24,    /* Application Collection */
    kHIDUsage_Sim_TrackControl    = 0x25,    /* Physical Collection */
    /* 0x26 - 0xAF Reserved */
    kHIDUsage_Sim_Aileron    = 0xB0,    /* Dynamic Value */
    kHIDUsage_Sim_AileronTrim    = 0xB1,    /* Dynamic Value */
    kHIDUsage_Sim_AntiTorqueControl    = 0xB2,    /* Dynamic Value */
    kHIDUsage_Sim_AutopilotEnable    = 0xB3,    /* On/Off Control */
    kHIDUsage_Sim_ChaffRelease    = 0xB4,    /* One-Shot Control */
    kHIDUsage_Sim_CollectiveControl    = 0xB5,    /* Dynamic Value */
    kHIDUsage_Sim_DiveBrake    = 0xB6,    /* Dynamic Value */
    kHIDUsage_Sim_ElectronicCountermeasures    = 0xB7,    /* On/Off Control */
    kHIDUsage_Sim_Elevator    = 0xB8,    /* Dynamic Value */
    kHIDUsage_Sim_ElevatorTrim    = 0xB9,    /* Dynamic Value */
    kHIDUsage_Sim_Rudder    = 0xBA,    /* Dynamic Value */
    kHIDUsage_Sim_Throttle    = 0xBB,    /* Dynamic Value */
    kHIDUsage_Sim_FlightCommunications    = 0xBC,    /* On/Off Control */
    kHIDUsage_Sim_FlareRelease    = 0xBD,    /* One-Shot Control */
    kHIDUsage_Sim_LandingGear    = 0xBE,    /* On/Off Control */
    kHIDUsage_Sim_ToeBrake    = 0xBF,    /* Dynamic Value */
    kHIDUsage_Sim_Trigger    = 0xC0,    /* Momentary Control */
    kHIDUsage_Sim_WeaponsArm    = 0xC1,    /* On/Off Control */
    kHIDUsage_Sim_Weapons    = 0xC2,    /* Selector */
    kHIDUsage_Sim_WingFlaps    = 0xC3,    /* Dynamic Value */
    kHIDUsage_Sim_Accelerator    = 0xC4,    /* Dynamic Value */
    kHIDUsage_Sim_Brake    = 0xC5,    /* Dynamic Value */
    kHIDUsage_Sim_Clutch    = 0xC6,    /* Dynamic Value */
    kHIDUsage_Sim_Shifter    = 0xC7,    /* Dynamic Value */
    kHIDUsage_Sim_Steering    = 0xC8,    /* Dynamic Value */
    kHIDUsage_Sim_TurretDirection    = 0xC9,    /* Dynamic Value */
    kHIDUsage_Sim_BarrelElevation    = 0xCA,    /* Dynamic Value */
    kHIDUsage_Sim_DivePlane    = 0xCB,    /* Dynamic Value */
    kHIDUsage_Sim_Ballast    = 0xCC,    /* Dynamic Value */
    kHIDUsage_Sim_BicycleCrank    = 0xCD,    /* Dynamic Value */
    kHIDUsage_Sim_HandleBars    = 0xCE,    /* Dynamic Value */
    kHIDUsage_Sim_FrontBrake    = 0xCF,    /* Dynamic Value */
    kHIDUsage_Sim_RearBrake    = 0xD0,    /* Dynamic Value */
    /* 0xD1 - 0xFFFF Reserved */
    kHIDUsage_Sim_Reserved = 0xFFFF
};

/* VR Page (0x03) */
/* Virtual Reality controls depend on designators to identify the individual controls. Most of the following are */
/* usages are applied to the collections of entities that comprise the actual device. */
enum
{
    kHIDUsage_VR_Belt    = 0x01,    /* Application Collection */
    kHIDUsage_VR_BodySuit    = 0x02,    /* Application Collection */
    kHIDUsage_VR_Flexor    = 0x03,    /* Physical Collection */
    kHIDUsage_VR_Glove    = 0x04,    /* Application Collection */
    kHIDUsage_VR_HeadTracker    = 0x05,    /* Physical Collection */
    kHIDUsage_VR_HeadMountedDisplay    = 0x06,    /* Application Collection */
    kHIDUsage_VR_HandTracker    = 0x07,    /* Application Collection */
    kHIDUsage_VR_Oculometer    = 0x08,    /* Application Collection */
    kHIDUsage_VR_Vest    = 0x09,    /* Application Collection */
    kHIDUsage_VR_AnimatronicDevice    = 0x0A,    /* Application Collection */
    /* 0x0B - 0x1F Reserved */
    kHIDUsage_VR_StereoEnable    = 0x20,    /* On/Off Control */
    kHIDUsage_VR_DisplayEnable    = 0x21,    /* On/Off Control */
    /* 0x22 - 0xFFFF Reserved */
    kHIDUsage_VR_Reserved = 0xFFFF
};

/* Sport Page (0x04) */
enum
{
    kHIDUsage_Sprt_BaseballBat    = 0x01,    /* Application Collection */
    kHIDUsage_Sprt_GolfClub    = 0x02,    /* Application Collection */
    kHIDUsage_Sprt_RowingMachine    = 0x03,    /* Application Collection */
    kHIDUsage_Sprt_Treadmill    = 0x04,    /* Application Collection */
    /* 0x05 - 0x2F Reserved */
    kHIDUsage_Sprt_Oar    = 0x30,    /* Dynamic Value */
    kHIDUsage_Sprt_Slope    = 0x31,    /* Dynamic Value */
    kHIDUsage_Sprt_Rate    = 0x32,    /* Dynamic Value */
    kHIDUsage_Sprt_StickSpeed    = 0x33,    /* Dynamic Value */
    kHIDUsage_Sprt_StickFaceAngle    = 0x34,    /* Dynamic Value */
    kHIDUsage_Sprt_StickHeelOrToe    = 0x35,    /* Dynamic Value */
    kHIDUsage_Sprt_StickFollowThrough    = 0x36,    /* Dynamic Value */
    kHIDUsage_Sprt_StickTempo    = 0x37,    /* Dynamic Value */
    kHIDUsage_Sprt_StickType    = 0x38,    /* Named Array */
    kHIDUsage_Sprt_StickHeight    = 0x39,    /* Dynamic Value */
    /* 0x3A - 0x4F Reserved */
    kHIDUsage_Sprt_Putter    = 0x50,    /* Selector */
    kHIDUsage_Sprt_1Iron    = 0x51,    /* Selector */
    kHIDUsage_Sprt_2Iron    = 0x52,    /* Selector */
    kHIDUsage_Sprt_3Iron    = 0x53,    /* Selector */
    kHIDUsage_Sprt_4Iron    = 0x54,    /* Selector */
    kHIDUsage_Sprt_5Iron    = 0x55,    /* Selector */
    kHIDUsage_Sprt_6Iron    = 0x56,    /* Selector */
    kHIDUsage_Sprt_7Iron    = 0x57,    /* Selector */
    kHIDUsage_Sprt_8Iron    = 0x58,    /* Selector */
    kHIDUsage_Sprt_9Iron    = 0x59,    /* Selector */
    kHIDUsage_Sprt_10Iron    = 0x5A,    /* Selector */
    kHIDUsage_Sprt_11Iron    = 0x5B,    /* Selector */
    kHIDUsage_Sprt_SandWedge    = 0x5C,    /* Selector */
    kHIDUsage_Sprt_LoftWedge    = 0x5D,    /* Selector */
    kHIDUsage_Sprt_PowerWedge    = 0x5E,    /* Selector */
    kHIDUsage_Sprt_1Wood    = 0x5F,    /* Selector */
    kHIDUsage_Sprt_3Wood    = 0x60,    /* Selector */
    kHIDUsage_Sprt_5Wood    = 0x61,    /* Selector */
    kHIDUsage_Sprt_7Wood    = 0x62,    /* Selector */
    kHIDUsage_Sprt_9Wood    = 0x63,    /* Selector */
    /* 0x64 - 0xFFFF Reserved */
    kHIDUsage_Sprt_Reserved = 0xFFFF
};

/* Game Page (0x05) */
enum
{
    kHIDUsage_Game_3DGameController    = 0x01,    /* Application Collection */
    kHIDUsage_Game_PinballDevice    = 0x02,    /* Application Collection */
    kHIDUsage_Game_GunDevice    = 0x03,    /* Application Collection */
    /* 0x04 - 0x1F Reserved */
    kHIDUsage_Game_PointofView    = 0x20,    /* Physical Collection */
    kHIDUsage_Game_TurnRightOrLeft    = 0x21,    /* Dynamic Value */
    kHIDUsage_Game_PitchUpOrDown    = 0x22,    /* Dynamic Value */
    kHIDUsage_Game_RollRightOrLeft    = 0x23,    /* Dynamic Value */
    kHIDUsage_Game_MoveRightOrLeft    = 0x24,    /* Dynamic Value */
    kHIDUsage_Game_MoveForwardOrBackward    = 0x25,    /* Dynamic Value */
    kHIDUsage_Game_MoveUpOrDown    = 0x26,    /* Dynamic Value */
    kHIDUsage_Game_LeanRightOrLeft    = 0x27,    /* Dynamic Value */
    kHIDUsage_Game_LeanForwardOrBackward    = 0x28,    /* Dynamic Value */
    kHIDUsage_Game_HeightOfPOV    = 0x29,    /* Dynamic Value */
    kHIDUsage_Game_Flipper    = 0x2A,    /* Momentary Control */
    kHIDUsage_Game_SecondaryFlipper    = 0x2B,    /* Momentary Control */
    kHIDUsage_Game_Bump    = 0x2C,    /* Momentary Control */
    kHIDUsage_Game_NewGame    = 0x2D,    /* One-Shot Control */
    kHIDUsage_Game_ShootBall    = 0x2E,    /* One-Shot Control */
    kHIDUsage_Game_Player    = 0x2F,    /* One-Shot Control */
    kHIDUsage_Game_GunBolt    = 0x30,    /* On/Off Control */
    kHIDUsage_Game_GunClip    = 0x31,    /* On/Off Control */
    kHIDUsage_Game_Gun    = 0x32,    /* Selector */
    kHIDUsage_Game_GunSingleShot    = 0x33,    /* Selector */
    kHIDUsage_Game_GunBurst    = 0x34,    /* Selector */
    kHIDUsage_Game_GunAutomatic    = 0x35,    /* Selector */
    kHIDUsage_Game_GunSafety    = 0x36,    /* On/Off Control */
    kHIDUsage_Game_GamepadFireOrJump    = 0x37,    /* Logical Collection */
    kHIDUsage_Game_GamepadTrigger    = 0x39,    /* Logical Collection */
    /* 0x3A - 0xFFFF Reserved */
    kHIDUsage_Game_Reserved = 0xFFFF
};

/* Generic Device Controls (0x0g) */
enum
{
    kHIDUsage_GenDevControls_BackgroundControls     = 0x01, /* Application Collection */
};

/* KeyboardOrKeypad Page (0x07) */
/* This section is the Usage Page for key codes to be used in implementing a USB keyboard. A Boot Keyboard (84-, 101- or 104-key) should at a minimum support all associated usage codes as indicated in the “Boot” */
/* column below. */
/* The usage type of all key codes is Selectors (Sel), except for the modifier keys Keyboard Left Control (0x224) to Keyboard Right GUI (0x231) which are Dynamic Flags (DV). */
/* Note: A general note on Usages and languages: Due to the variation of keyboards from language to language, it is not feasible to specify exact key mappings for every language. Where this list is not specific for a key function in a language, the closest equivalent key position should be used, so that a keyboard may be modified for a different language by simply printing different keycaps. One example is the Y key on a North American keyboard. In Germany this is typically Z. Rather than changing the keyboard firmware to put the Z Usage into that place in the descriptor list, the vendor should use the Y Usage on both the North American and German keyboards. This continues to be the existing practice in the industry, in order to minimize the number of changes to the electronics to accommodate otherlanguages. */
enum
{
    kHIDUsage_KeyboardErrorRollOver    = 0x01,    /* ErrorRollOver */
    kHIDUsage_KeyboardPOSTFail    = 0x02,    /* POSTFail */
    kHIDUsage_KeyboardErrorUndefined    = 0x03,    /* ErrorUndefined */
    kHIDUsage_KeyboardA    = 0x04,    /* a or A */
    kHIDUsage_KeyboardB    = 0x05,    /* b or B */
    kHIDUsage_KeyboardC    = 0x06,    /* c or C */
    kHIDUsage_KeyboardD    = 0x07,    /* d or D */
    kHIDUsage_KeyboardE    = 0x08,    /* e or E */
    kHIDUsage_KeyboardF    = 0x09,    /* f or F */
    kHIDUsage_KeyboardG    = 0x0A,    /* g or G */
    kHIDUsage_KeyboardH    = 0x0B,    /* h or H */
    kHIDUsage_KeyboardI    = 0x0C,    /* i or I */
    kHIDUsage_KeyboardJ    = 0x0D,    /* j or J */
    kHIDUsage_KeyboardK    = 0x0E,    /* k or K */
    kHIDUsage_KeyboardL    = 0x0F,    /* l or L */
    kHIDUsage_KeyboardM    = 0x10,    /* m or M */
    kHIDUsage_KeyboardN    = 0x11,    /* n or N */
    kHIDUsage_KeyboardO    = 0x12,    /* o or O */
    kHIDUsage_KeyboardP    = 0x13,    /* p or P */
    kHIDUsage_KeyboardQ    = 0x14,    /* q or Q */
    kHIDUsage_KeyboardR    = 0x15,    /* r or R */
    kHIDUsage_KeyboardS    = 0x16,    /* s or S */
    kHIDUsage_KeyboardT    = 0x17,    /* t or T */
    kHIDUsage_KeyboardU    = 0x18,    /* u or U */
    kHIDUsage_KeyboardV    = 0x19,    /* v or V */
    kHIDUsage_KeyboardW    = 0x1A,    /* w or W */
    kHIDUsage_KeyboardX    = 0x1B,    /* x or X */
    kHIDUsage_KeyboardY    = 0x1C,    /* y or Y */
    kHIDUsage_KeyboardZ    = 0x1D,    /* z or Z */
    kHIDUsage_Keyboard1    = 0x1E,    /* 1 or ! */
    kHIDUsage_Keyboard2    = 0x1F,    /* 2 or @ */
    kHIDUsage_Keyboard3    = 0x20,    /* 3 or # */
    kHIDUsage_Keyboard4    = 0x21,    /* 4 or $ */
    kHIDUsage_Keyboard5    = 0x22,    /* 5 or % */
    kHIDUsage_Keyboard6    = 0x23,    /* 6 or ^ */
    kHIDUsage_Keyboard7    = 0x24,    /* 7 or & */
    kHIDUsage_Keyboard8    = 0x25,    /* 8 or * */
    kHIDUsage_Keyboard9    = 0x26,    /* 9 or ( */
    kHIDUsage_Keyboard0    = 0x27,    /* 0 or ) */
    kHIDUsage_KeyboardReturnOrEnter    = 0x28,    /* Return (Enter) */
    kHIDUsage_KeyboardEscape    = 0x29,    /* Escape */
    kHIDUsage_KeyboardDeleteOrBackspace    = 0x2A,    /* Delete (Backspace) */
    kHIDUsage_KeyboardTab    = 0x2B,    /* Tab */
    kHIDUsage_KeyboardSpacebar    = 0x2C,    /* Spacebar */
    kHIDUsage_KeyboardHyphen    = 0x2D,    /* - or _ */
    kHIDUsage_KeyboardEqualSign    = 0x2E,    /* = or + */
    kHIDUsage_KeyboardOpenBracket    = 0x2F,    /* [ or { */
    kHIDUsage_KeyboardCloseBracket    = 0x30,    /* ] or } */
    kHIDUsage_KeyboardBackslash    = 0x31,    /* \ or | */
    kHIDUsage_KeyboardNonUSPound    = 0x32,    /* Non-US # or _ */
    kHIDUsage_KeyboardSemicolon    = 0x33,    /* ; or : */
    kHIDUsage_KeyboardQuote    = 0x34,    /* ' or " */
    kHIDUsage_KeyboardGraveAccentAndTilde    = 0x35,    /* Grave Accent and Tilde */
    kHIDUsage_KeyboardComma    = 0x36,    /* , or < */
    kHIDUsage_KeyboardPeriod    = 0x37,    /* . or > */
    kHIDUsage_KeyboardSlash    = 0x38,    /* / or ? */
    kHIDUsage_KeyboardCapsLock    = 0x39,    /* Caps Lock */
    kHIDUsage_KeyboardF1    = 0x3A,    /* F1 */
    kHIDUsage_KeyboardF2    = 0x3B,    /* F2 */
    kHIDUsage_KeyboardF3    = 0x3C,    /* F3 */
    kHIDUsage_KeyboardF4    = 0x3D,    /* F4 */
    kHIDUsage_KeyboardF5    = 0x3E,    /* F5 */
    kHIDUsage_KeyboardF6    = 0x3F,    /* F6 */
    kHIDUsage_KeyboardF7    = 0x40,    /* F7 */
    kHIDUsage_KeyboardF8    = 0x41,    /* F8 */
    kHIDUsage_KeyboardF9    = 0x42,    /* F9 */
    kHIDUsage_KeyboardF10    = 0x43,    /* F10 */
    kHIDUsage_KeyboardF11    = 0x44,    /* F11 */
    kHIDUsage_KeyboardF12    = 0x45,    /* F12 */
    kHIDUsage_KeyboardPrintScreen    = 0x46,    /* Print Screen */
    kHIDUsage_KeyboardScrollLock    = 0x47,    /* Scroll Lock */
    kHIDUsage_KeyboardPause    = 0x48,    /* Pause */
    kHIDUsage_KeyboardInsert    = 0x49,    /* Insert */
    kHIDUsage_KeyboardHome    = 0x4A,    /* Home */
    kHIDUsage_KeyboardPageUp    = 0x4B,    /* Page Up */
    kHIDUsage_KeyboardDeleteForward    = 0x4C,    /* Delete Forward */
    kHIDUsage_KeyboardEnd    = 0x4D,    /* End */
    kHIDUsage_KeyboardPageDown    = 0x4E,    /* Page Down */
    kHIDUsage_KeyboardRightArrow    = 0x4F,    /* Right Arrow */
    kHIDUsage_KeyboardLeftArrow    = 0x50,    /* Left Arrow */
    kHIDUsage_KeyboardDownArrow    = 0x51,    /* Down Arrow */
    kHIDUsage_KeyboardUpArrow    = 0x52,    /* Up Arrow */
    kHIDUsage_KeypadNumLock    = 0x53,    /* Keypad NumLock or Clear */
    kHIDUsage_KeypadSlash    = 0x54,    /* Keypad / */
    kHIDUsage_KeypadAsterisk    = 0x55,    /* Keypad * */
    kHIDUsage_KeypadHyphen    = 0x56,    /* Keypad - */
    kHIDUsage_KeypadPlus    = 0x57,    /* Keypad + */
    kHIDUsage_KeypadEnter    = 0x58,    /* Keypad Enter */
    kHIDUsage_Keypad1    = 0x59,    /* Keypad 1 or End */
    kHIDUsage_Keypad2    = 0x5A,    /* Keypad 2 or Down Arrow */
    kHIDUsage_Keypad3    = 0x5B,    /* Keypad 3 or Page Down */
    kHIDUsage_Keypad4    = 0x5C,    /* Keypad 4 or Left Arrow */
    kHIDUsage_Keypad5    = 0x5D,    /* Keypad 5 */
    kHIDUsage_Keypad6    = 0x5E,    /* Keypad 6 or Right Arrow */
    kHIDUsage_Keypad7    = 0x5F,    /* Keypad 7 or Home */
    kHIDUsage_Keypad8    = 0x60,    /* Keypad 8 or Up Arrow */
    kHIDUsage_Keypad9    = 0x61,    /* Keypad 9 or Page Up */
    kHIDUsage_Keypad0    = 0x62,    /* Keypad 0 or Insert */
    kHIDUsage_KeypadPeriod    = 0x63,    /* Keypad . or Delete */
    kHIDUsage_KeyboardNonUSBackslash    = 0x64,    /* Non-US \ or | */
    kHIDUsage_KeyboardApplication    = 0x65,    /* Application */
    kHIDUsage_KeyboardPower    = 0x66,    /* Power */
    kHIDUsage_KeypadEqualSign    = 0x67,    /* Keypad = */
    kHIDUsage_KeyboardF13    = 0x68,    /* F13 */
    kHIDUsage_KeyboardF14    = 0x69,    /* F14 */
    kHIDUsage_KeyboardF15    = 0x6A,    /* F15 */
    kHIDUsage_KeyboardF16    = 0x6B,    /* F16 */
    kHIDUsage_KeyboardF17    = 0x6C,    /* F17 */
    kHIDUsage_KeyboardF18    = 0x6D,    /* F18 */
    kHIDUsage_KeyboardF19    = 0x6E,    /* F19 */
    kHIDUsage_KeyboardF20    = 0x6F,    /* F20 */
    kHIDUsage_KeyboardF21    = 0x70,    /* F21 */
    kHIDUsage_KeyboardF22    = 0x71,    /* F22 */
    kHIDUsage_KeyboardF23    = 0x72,    /* F23 */
    kHIDUsage_KeyboardF24    = 0x73,    /* F24 */
    kHIDUsage_KeyboardExecute    = 0x74,    /* Execute */
    kHIDUsage_KeyboardHelp    = 0x75,    /* Help */
    kHIDUsage_KeyboardMenu    = 0x76,    /* Menu */
    kHIDUsage_KeyboardSelect    = 0x77,    /* Select */
    kHIDUsage_KeyboardStop    = 0x78,    /* Stop */
    kHIDUsage_KeyboardAgain    = 0x79,    /* Again */
    kHIDUsage_KeyboardUndo    = 0x7A,    /* Undo */
    kHIDUsage_KeyboardCut    = 0x7B,    /* Cut */
    kHIDUsage_KeyboardCopy    = 0x7C,    /* Copy */
    kHIDUsage_KeyboardPaste    = 0x7D,    /* Paste */
    kHIDUsage_KeyboardFind    = 0x7E,    /* Find */
    kHIDUsage_KeyboardMute    = 0x7F,    /* Mute */
    kHIDUsage_KeyboardVolumeUp    = 0x80,    /* Volume Up */
    kHIDUsage_KeyboardVolumeDown    = 0x81,    /* Volume Down */
    kHIDUsage_KeyboardLockingCapsLock    = 0x82,    /* Locking Caps Lock */
    kHIDUsage_KeyboardLockingNumLock    = 0x83,    /* Locking Num Lock */
    kHIDUsage_KeyboardLockingScrollLock    = 0x84,    /* Locking Scroll Lock */
    kHIDUsage_KeypadComma    = 0x85,    /* Keypad Comma */
    kHIDUsage_KeypadEqualSignAS400    = 0x86,    /* Keypad Equal Sign for AS/400 */
    kHIDUsage_KeyboardInternational1    = 0x87,    /* International1 */
    kHIDUsage_KeyboardInternational2    = 0x88,    /* International2 */
    kHIDUsage_KeyboardInternational3    = 0x89,    /* International3 */
    kHIDUsage_KeyboardInternational4    = 0x8A,    /* International4 */
    kHIDUsage_KeyboardInternational5    = 0x8B,    /* International5 */
    kHIDUsage_KeyboardInternational6    = 0x8C,    /* International6 */
    kHIDUsage_KeyboardInternational7    = 0x8D,    /* International7 */
    kHIDUsage_KeyboardInternational8    = 0x8E,    /* International8 */
    kHIDUsage_KeyboardInternational9    = 0x8F,    /* International9 */
    kHIDUsage_KeyboardLANG1    = 0x90,    /* LANG1 */
    kHIDUsage_KeyboardLANG2    = 0x91,    /* LANG2 */
    kHIDUsage_KeyboardLANG3    = 0x92,    /* LANG3 */
    kHIDUsage_KeyboardLANG4    = 0x93,    /* LANG4 */
    kHIDUsage_KeyboardLANG5    = 0x94,    /* LANG5 */
    kHIDUsage_KeyboardLANG6    = 0x95,    /* LANG6 */
    kHIDUsage_KeyboardLANG7    = 0x96,    /* LANG7 */
    kHIDUsage_KeyboardLANG8    = 0x97,    /* LANG8 */
    kHIDUsage_KeyboardLANG9    = 0x98,    /* LANG9 */
    kHIDUsage_KeyboardAlternateErase    = 0x99,    /* AlternateErase */
    kHIDUsage_KeyboardSysReqOrAttention    = 0x9A,    /* SysReq/Attention */
    kHIDUsage_KeyboardCancel    = 0x9B,    /* Cancel */
    kHIDUsage_KeyboardClear    = 0x9C,    /* Clear */
    kHIDUsage_KeyboardPrior    = 0x9D,    /* Prior */
    kHIDUsage_KeyboardReturn    = 0x9E,    /* Return */
    kHIDUsage_KeyboardSeparator    = 0x9F,    /* Separator */
    kHIDUsage_KeyboardOut    = 0xA0,    /* Out */
    kHIDUsage_KeyboardOper    = 0xA1,    /* Oper */
    kHIDUsage_KeyboardClearOrAgain    = 0xA2,    /* Clear/Again */
    kHIDUsage_KeyboardCrSelOrProps    = 0xA3,    /* CrSel/Props */
    kHIDUsage_KeyboardExSel    = 0xA4,    /* ExSel */
    /* 0xA5-0xDF Reserved */
    kHIDUsage_KeyboardLeftControl    = 0xE0,    /* Left Control */
    kHIDUsage_KeyboardLeftShift    = 0xE1,    /* Left Shift */
    kHIDUsage_KeyboardLeftAlt    = 0xE2,    /* Left Alt */
    kHIDUsage_KeyboardLeftGUI    = 0xE3,    /* Left GUI */
    kHIDUsage_KeyboardRightControl    = 0xE4,    /* Right Control */
    kHIDUsage_KeyboardRightShift    = 0xE5,    /* Right Shift */
    kHIDUsage_KeyboardRightAlt    = 0xE6,    /* Right Alt */
    kHIDUsage_KeyboardRightGUI    = 0xE7,    /* Right GUI */
    /* 0xE8-0xFFFF Reserved */
    kHIDUsage_Keyboard_Reserved = 0xFFFF
};

/* LEDs Page (0x08) */
/* An LED or indicator is implemented as an On/Off Control (OOF) using the “Single button toggle” mode, where a value of 1 will turn on the indicator, and a value of 0 will turn it off. The exceptions are described below. */
enum
{
    kHIDUsage_LED_NumLock    = 0x01,    /* On/Off Control */
    kHIDUsage_LED_CapsLock    = 0x02,    /* On/Off Control */
    kHIDUsage_LED_ScrollLock    = 0x03,    /* On/Off Control */
    kHIDUsage_LED_Compose    = 0x04,    /* On/Off Control */
    kHIDUsage_LED_Kana    = 0x05,    /* On/Off Control */
    kHIDUsage_LED_Power    = 0x06,    /* On/Off Control */
    kHIDUsage_LED_Shift    = 0x07,    /* On/Off Control */
    kHIDUsage_LED_DoNotDisturb    = 0x08,    /* On/Off Control */
    kHIDUsage_LED_Mute    = 0x09,    /* On/Off Control */
    kHIDUsage_LED_ToneEnable    = 0x0A,    /* On/Off Control */
    kHIDUsage_LED_HighCutFilter    = 0x0B,    /* On/Off Control */
    kHIDUsage_LED_LowCutFilter    = 0x0C,    /* On/Off Control */
    kHIDUsage_LED_EqualizerEnable    = 0x0D,    /* On/Off Control */
    kHIDUsage_LED_SoundFieldOn    = 0x0E,    /* On/Off Control */
    kHIDUsage_LED_SurroundOn    = 0x0F,    /* On/Off Control */
    kHIDUsage_LED_Repeat    = 0x10,    /* On/Off Control */
    kHIDUsage_LED_Stereo    = 0x11,    /* On/Off Control */
    kHIDUsage_LED_SamplingRateDetect    = 0x12,    /* On/Off Control */
    kHIDUsage_LED_Spinning    = 0x13,    /* On/Off Control */
    kHIDUsage_LED_CAV    = 0x14,    /* On/Off Control */
    kHIDUsage_LED_CLV    = 0x15,    /* On/Off Control */
    kHIDUsage_LED_RecordingFormatDetect    = 0x16,    /* On/Off Control */
    kHIDUsage_LED_OffHook    = 0x17,    /* On/Off Control */
    kHIDUsage_LED_Ring    = 0x18,    /* On/Off Control */
    kHIDUsage_LED_MessageWaiting    = 0x19,    /* On/Off Control */
    kHIDUsage_LED_DataMode    = 0x1A,    /* On/Off Control */
    kHIDUsage_LED_BatteryOperation    = 0x1B,    /* On/Off Control */
    kHIDUsage_LED_BatteryOK    = 0x1C,    /* On/Off Control */
    kHIDUsage_LED_BatteryLow    = 0x1D,    /* On/Off Control */
    kHIDUsage_LED_Speaker    = 0x1E,    /* On/Off Control */
    kHIDUsage_LED_HeadSet    = 0x1F,    /* On/Off Control */
    kHIDUsage_LED_Hold    = 0x20,    /* On/Off Control */
    kHIDUsage_LED_Microphone    = 0x21,    /* On/Off Control */
    kHIDUsage_LED_Coverage    = 0x22,    /* On/Off Control */
    kHIDUsage_LED_NightMode    = 0x23,    /* On/Off Control */
    kHIDUsage_LED_SendCalls    = 0x24,    /* On/Off Control */
    kHIDUsage_LED_CallPickup    = 0x25,    /* On/Off Control */
    kHIDUsage_LED_Conference    = 0x26,    /* On/Off Control */
    kHIDUsage_LED_StandBy    = 0x27,    /* On/Off Control */
    kHIDUsage_LED_CameraOn    = 0x28,    /* On/Off Control */
    kHIDUsage_LED_CameraOff    = 0x29,    /* On/Off Control */
    kHIDUsage_LED_OnLine    = 0x2A,    /* On/Off Control */
    kHIDUsage_LED_OffLine    = 0x2B,    /* On/Off Control */
    kHIDUsage_LED_Busy    = 0x2C,    /* On/Off Control */
    kHIDUsage_LED_Ready    = 0x2D,    /* On/Off Control */
    kHIDUsage_LED_PaperOut    = 0x2E,    /* On/Off Control */
    kHIDUsage_LED_PaperJam    = 0x2F,    /* On/Off Control */
    kHIDUsage_LED_Remote    = 0x30,    /* On/Off Control */
    kHIDUsage_LED_Forward    = 0x31,    /* On/Off Control */
    kHIDUsage_LED_Reverse    = 0x32,    /* On/Off Control */
    kHIDUsage_LED_Stop    = 0x33,    /* On/Off Control */
    kHIDUsage_LED_Rewind    = 0x34,    /* On/Off Control */
    kHIDUsage_LED_FastForward    = 0x35,    /* On/Off Control */
    kHIDUsage_LED_Play    = 0x36,    /* On/Off Control */
    kHIDUsage_LED_Pause    = 0x37,    /* On/Off Control */
    kHIDUsage_LED_Record    = 0x38,    /* On/Off Control */
    kHIDUsage_LED_Error    = 0x39,    /* On/Off Control */
    kHIDUsage_LED_Usage    = 0x3A,    /* Selector */
    kHIDUsage_LED_UsageInUseIndicator    = 0x3B,    /* Usage Switch */
    kHIDUsage_LED_UsageMultiModeIndicator    = 0x3C,    /* Usage Modifier */
    kHIDUsage_LED_IndicatorOn    = 0x3D,    /* Selector */
    kHIDUsage_LED_IndicatorFlash    = 0x3E,    /* Selector */
    kHIDUsage_LED_IndicatorSlowBlink    = 0x3F,    /* Selector */
    kHIDUsage_LED_IndicatorFastBlink    = 0x40,    /* Selector */
    kHIDUsage_LED_IndicatorOff    = 0x41,    /* Selector */
    kHIDUsage_LED_FlashOnTime    = 0x42,    /* Dynamic Value */
    kHIDUsage_LED_SlowBlinkOnTime    = 0x43,    /* Dynamic Value */
    kHIDUsage_LED_SlowBlinkOffTime    = 0x44,    /* Dynamic Value */
    kHIDUsage_LED_FastBlinkOnTime    = 0x45,    /* Dynamic Value */
    kHIDUsage_LED_FastBlinkOffTime    = 0x46,    /* Dynamic Value */
    kHIDUsage_LED_UsageIndicatorColor    = 0x47,    /* Usage Modifier */
    kHIDUsage_LED_IndicatorRed    = 0x48,    /* Selector */
    kHIDUsage_LED_IndicatorGreen    = 0x49,    /* Selector */
    kHIDUsage_LED_IndicatorAmber    = 0x4A,    /* Selector */
    kHIDUsage_LED_GenericIndicator    = 0x4B,    /* On/Off Control */
    kHIDUsage_LED_SystemSuspend    = 0x4C,    /* On/Off Control */
    kHIDUsage_LED_ExternalPowerConnected    = 0x4D,    /* On/Off Control */
    /* 0x4E - 0xFFFF Reserved */
    kHIDUsage_LED_Reserved = 0xFFFF
};

/* Button Page (0x09) */
/* The Button page is the first place an application should look for user selection controls. System graphical user interfaces typically employ a pointer and a set of hierarchical selectors to select, move and otherwise manipulate their environment. For these purposes the following assignment of significance can be applied to the Button usages: */
/* • Button 1, Primary Button. Used for object selecting, dragging, and double click activation. On MacOS, this is the only button. Microsoft operating systems call this a logical left button, because it */
/* is not necessarily physically located on the left of the pointing device. */
/* • Button 2, Secondary Button. Used by newer graphical user interfaces to browse object properties. Exposed by systems to applications that typically assign application-specific functionality. */
/* • Button 3, Tertiary Button. Optional control. Exposed to applications, but seldom assigned functionality due to prevalence of two- and one-button devices. */
/* • Buttons 4 -55. As the button number increases, its significance as a selector decreases. */
/* In many ways the assignment of button numbers is similar to the assignment of Effort in Physical descriptors. Button 1 would be used to define the button a finger rests on when the hand is in the “at rest” position, that is, virtually no effort is required by the user to activate the button. Button values increment as the finger has to stretch to reach a control. See Section 6.2.3, “Physical Descriptors,” in the HID Specification for methods of further qualifying buttons. */
enum
{
    kHIDUsage_Button_1    = 0x01,    /* (primary/trigger) */
    kHIDUsage_Button_2    = 0x02,    /* (secondary) */
    kHIDUsage_Button_3    = 0x03,    /* (tertiary) */
    kHIDUsage_Button_4    = 0x04, /* 4th button */
    /* ... */
    kHIDUsage_Button_65535    = 0xFFFF
};

/* Ordinal Page (0x0A) */
/* The Ordinal page allows multiple instances of a control or sets of controls to be declared without requiring individual enumeration in the native usage page. For example, it is not necessary to declare usages of Pointer 1, Pointer 2, and so forth on the Generic Desktop page. When parsed, the ordinal instance number is, in essence, concatenated to the usages attached to the encompassing collection to create Pointer 1, Pointer 2, and so forth. */
/* For an example, see Section A.5, “Multiple Instances of a Control,” in Appendix A, “Usage Examples.” By convention, an Ordinal collection is placed inside the collection for which it is declaring multiple instances. */
/* Instances do not have to be identical. */
enum
{
    /* 0x00 Reserved */
    kHIDUsage_Ord_Instance1    = 0x01,    /* Usage Modifier */
    kHIDUsage_Ord_Instance2    = 0x02,    /* Usage Modifier */
    kHIDUsage_Ord_Instance3    = 0x03,    /* Usage Modifier */
    kHIDUsage_Ord_Instance4    = 0x04,    /* Usage Modifier */
    kHIDUsage_Ord_Instance65535    = 0xFFFF    /* Usage Modifier */
};

/* Telephony Page (0x0B) */
/* This usage page defines the keytop and control usages for telephony devices. */
/* Indicators on a phone are handled by wrapping them in LED: Usage In Use Indicator and LED: Usage Selected Indicator usages. For example, a message-indicator LED would be identified by a Telephony: Message usage declared as a Feature or Output in a LED: Usage In Use Indicator collection. */
/* See Section 14, “Consumer Page (0x0C),” for audio volume and tone controls. */
enum
{
    kHIDUsage_Tfon_Phone    = 0x01,    /* Application Collection */
    kHIDUsage_Tfon_AnsweringMachine    = 0x02,    /* Application Collection */
    kHIDUsage_Tfon_MessageControls    = 0x03,    /* Logical Collection */
    kHIDUsage_Tfon_Handset    = 0x04,    /* Logical Collection */
    kHIDUsage_Tfon_Headset    = 0x05,    /* Logical Collection */
    kHIDUsage_Tfon_TelephonyKeyPad    = 0x06,    /* Named Array */
    kHIDUsage_Tfon_ProgrammableButton    = 0x07,    /* Named Array */
    /* 0x08 - 0x1F Reserved */
    kHIDUsage_Tfon_HookSwitch    = 0x20,    /* On/Off Control */
    kHIDUsage_Tfon_Flash    = 0x21,    /* Momentary Control */
    kHIDUsage_Tfon_Feature    = 0x22,    /* One-Shot Control */
    kHIDUsage_Tfon_Hold    = 0x23,    /* On/Off Control */
    kHIDUsage_Tfon_Redial    = 0x24,    /* One-Shot Control */
    kHIDUsage_Tfon_Transfer    = 0x25,    /* One-Shot Control */
    kHIDUsage_Tfon_Drop    = 0x26,    /* One-Shot Control */
    kHIDUsage_Tfon_Park    = 0x27,    /* On/Off Control */
    kHIDUsage_Tfon_ForwardCalls    = 0x28,    /* On/Off Control */
    kHIDUsage_Tfon_AlternateFunction    = 0x29,    /* Momentary Control */
    kHIDUsage_Tfon_Line    = 0x2A,    /* One-Shot Control */
    kHIDUsage_Tfon_SpeakerPhone    = 0x2B,    /* On/Off Control */
    kHIDUsage_Tfon_Conference    = 0x2C,    /* On/Off Control */
    kHIDUsage_Tfon_RingEnable    = 0x2D,    /* On/Off Control */
    kHIDUsage_Tfon_Ring    = 0x2E,    /* Selector */
    kHIDUsage_Tfon_PhoneMute    = 0x2F,    /* On/Off Control */
    kHIDUsage_Tfon_CallerID    = 0x30,    /* Momentary Control */
    /* 0x31 - 0x4F Reserved */
    kHIDUsage_Tfon_SpeedDial    = 0x50,    /* One-Shot Control */
    kHIDUsage_Tfon_StoreNumber    = 0x51,    /* One-Shot Control */
    kHIDUsage_Tfon_RecallNumber    = 0x52,    /* One-Shot Control */
    kHIDUsage_Tfon_PhoneDirectory    = 0x53,    /* On/Off Control */
    /* 0x54 - 0x6F Reserved */
    kHIDUsage_Tfon_VoiceMail    = 0x70,    /* On/Off Control */
    kHIDUsage_Tfon_ScreenCalls    = 0x71,    /* On/Off Control */
    kHIDUsage_Tfon_DoNotDisturb    = 0x72,    /* On/Off Control */
    kHIDUsage_Tfon_Message    = 0x73,    /* One-Shot Control */
    kHIDUsage_Tfon_AnswerOnOrOff    = 0x74,    /* On/Off Control */
    /* 0x75 - 0x8F Reserved */
    kHIDUsage_Tfon_InsideDialTone    = 0x90,    /* Momentary Control */
    kHIDUsage_Tfon_OutsideDialTone    = 0x91,    /* Momentary Control */
    kHIDUsage_Tfon_InsideRingTone    = 0x92,    /* Momentary Control */
    kHIDUsage_Tfon_OutsideRingTone    = 0x93,    /* Momentary Control */
    kHIDUsage_Tfon_PriorityRingTone    = 0x94,    /* Momentary Control */
    kHIDUsage_Tfon_InsideRingback    = 0x95,    /* Momentary Control */
    kHIDUsage_Tfon_PriorityRingback    = 0x96,    /* Momentary Control */
    kHIDUsage_Tfon_LineBusyTone    = 0x97,    /* Momentary Control */
    kHIDUsage_Tfon_ReorderTone    = 0x98,    /* Momentary Control */
    kHIDUsage_Tfon_CallWaitingTone    = 0x99,    /* Momentary Control */
    kHIDUsage_Tfon_ConfirmationTone1    = 0x9A,    /* Momentary Control */
    kHIDUsage_Tfon_ConfirmationTone2    = 0x9B,    /* Momentary Control */
    kHIDUsage_Tfon_TonesOff    = 0x9C,    /* On/Off Control */
    kHIDUsage_Tfon_OutsideRingback    = 0x9D,    /* Momentary Control */
    /* 0x9E - 0xAF Reserved */
    kHIDUsage_Tfon_PhoneKey0    = 0xB0,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey1    = 0xB1,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey2    = 0xB2,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey3    = 0xB3,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey4    = 0xB4,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey5    = 0xB5,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey6    = 0xB6,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey7    = 0xB7,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey8    = 0xB8,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey9    = 0xB9,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyStar    = 0xBA,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyPound    = 0xBB,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyA    = 0xBC,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyB    = 0xBD,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyC    = 0xBE,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyD    = 0xBF,    /* Selector/One-Shot Control */
    /* 0xC0 - 0xFFFF Reserved */
    kHIDUsage_TFon_Reserved = 0xFFFF
};

/* Consumer Page (0x0C) */
/* All controls on the Consumer page are application-specific. That is, they affect a specific device, not the system as a whole. */
enum
{
    kHIDUsage_Csmr_ConsumerControl    = 0x01,    /* Application Collection */
    kHIDUsage_Csmr_NumericKeyPad    = 0x02,    /* Named Array */
    kHIDUsage_Csmr_ProgrammableButtons    = 0x03,    /* Named Array */
    kHIDUsage_Csmr_Microphone   = 0x04,    /* Application Collection */
    kHIDUsage_Csmr_Headphone   = 0x05,    /* Application Collection */
    kHIDUsage_Csmr_GraphicEqualizer   = 0x06,    /* Application Collection */
    /* 0x07 - 0x1F Reserved */
    kHIDUsage_Csmr_Plus10    = 0x20,    /* One-Shot Control */
    kHIDUsage_Csmr_Plus100    = 0x21,    /* One-Shot Control */
    kHIDUsage_Csmr_AMOrPM    = 0x22,    /* One-Shot Control */
    /* 0x23 - 0x3F Reserved */
    kHIDUsage_Csmr_Power    = 0x30,    /* On/Off Control */
    kHIDUsage_Csmr_Reset    = 0x31,    /* One-Shot Control */
    kHIDUsage_Csmr_Sleep    = 0x32,    /* One-Shot Control */
    kHIDUsage_Csmr_SleepAfter    = 0x33,    /* One-Shot Control */
    kHIDUsage_Csmr_SleepMode    = 0x34,    /* Re-Trigger Control */
    kHIDUsage_Csmr_Illumination    = 0x35,    /* On/Off Control */
    kHIDUsage_Csmr_FunctionButtons    = 0x36,    /* Named Array */
    /* 0x37 - 0x3F Reserved */
    kHIDUsage_Csmr_Menu    = 0x40,    /* On/Off Control */
    kHIDUsage_Csmr_MenuPick    = 0x41,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuUp    = 0x42,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuDown    = 0x43,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuLeft    = 0x44,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuRight    = 0x45,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuEscape    = 0x46,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuValueIncrease    = 0x47,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuValueDecrease    = 0x48,    /* One-Shot Control */
    /* 0x49 - 0x5F Reserved */
    kHIDUsage_Csmr_DataOnScreen    = 0x60,    /* On/Off Control */
    kHIDUsage_Csmr_ClosedCaption    = 0x61,    /* On/Off Control */
    kHIDUsage_Csmr_ClosedCaptionSelect    = 0x62,    /* Selector */
    kHIDUsage_Csmr_VCROrTV    = 0x63,    /* On/Off Control */
    kHIDUsage_Csmr_BroadcastMode    = 0x64,    /* One-Shot Control */
    kHIDUsage_Csmr_Snapshot    = 0x65,    /* One-Shot Control */
    kHIDUsage_Csmr_Still    = 0x66,    /* One-Shot Control */
    kHIDUsage_Csmr_PictureInPictureToggle = 0x67, /* One-Shot Control */
    kHIDUsage_Csmr_PictureInPictureSwap = 0x68, /* One-Shot Control */
    kHIDUsage_Csmr_RedMenuButton = 0x69, /* Momentary Control */
    kHIDUsage_Csmr_GreenMenuButton = 0x6A, /* Momentary Control */
    kHIDUsage_Csmr_BlueMenuButton = 0x6B, /* Momentary Control */
    kHIDUsage_Csmr_YellowMenuButton = 0x6C, /* Momentary Control */
    kHIDUsage_Csmr_Aspect = 0x6D, /* One-shot Control */
    kHIDUsage_Csmr_3DModeSelect = 0x6E, /* One-shot Control */
    kHIDUsage_Csmr_DisplayBrightnessIncrement = 0x6F, /* Re-Trigger Control */
    kHIDUsage_Csmr_DisplayBrightnessDecrement = 0x70, /* Re-Trigger Control */
    kHIDUsage_Csmr_DisplayBrightness = 0x71, /* Logical Collection */
    kHIDUsage_Csmr_DisplayBacklightToggle = 0x72, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessMinimum = 0x73, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessMaximum = 0x74, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessSetAutoBrightness = 0x75, /* On Off Control */
    /* 0x76 - 0x7F Reserved */
    kHIDUsage_Csmr_Selection    = 0x80,    /* Named Array */
    kHIDUsage_Csmr_Assign    = 0x81,    /* Selector */
    kHIDUsage_Csmr_ModeStep    = 0x82,    /* One-Shot Control */
    kHIDUsage_Csmr_RecallLast    = 0x83,    /* One-Shot Control */
    kHIDUsage_Csmr_EnterChannel    = 0x84,    /* One-Shot Control */
    kHIDUsage_Csmr_OrderMovie    = 0x85,    /* One-Shot Control */
    kHIDUsage_Csmr_Channel    = 0x86,    /* Linear Control */
    kHIDUsage_Csmr_MediaSelection    = 0x87,    /* Selector */
    kHIDUsage_Csmr_MediaSelectComputer    = 0x88,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTV    = 0x89,    /* Selector */
    kHIDUsage_Csmr_MediaSelectWWW    = 0x8A,    /* Selector */
    kHIDUsage_Csmr_MediaSelectDVD    = 0x8B,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTelephone    = 0x8C,    /* Selector */
    kHIDUsage_Csmr_MediaSelectProgramGuide    = 0x8D,    /* Selector */
    kHIDUsage_Csmr_MediaSelectVideoPhone    = 0x8E,    /* Selector */
    kHIDUsage_Csmr_MediaSelectGames    = 0x8F,    /* Selector */
    kHIDUsage_Csmr_MediaSelectMessages    = 0x90,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCD    = 0x91,    /* Selector */
    kHIDUsage_Csmr_MediaSelectVCR    = 0x92,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTuner    = 0x93,    /* Selector */
    kHIDUsage_Csmr_Quit    = 0x94,    /* One-Shot Control */
    kHIDUsage_Csmr_Help    = 0x95,    /* On/Off Control */
    kHIDUsage_Csmr_MediaSelectTape    = 0x96,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCable    = 0x97,    /* Selector */
    kHIDUsage_Csmr_MediaSelectSatellite    = 0x98,    /* Selector */
    kHIDUsage_Csmr_MediaSelectSecurity    = 0x99,    /* Selector */
    kHIDUsage_Csmr_MediaSelectHome    = 0x9A,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCall    = 0x9B,    /* Selector */
    kHIDUsage_Csmr_ChannelIncrement    = 0x9C,    /* One-Shot Control */
    kHIDUsage_Csmr_ChannelDecrement    = 0x9D,    /* One-Shot Control */
    kHIDUsage_Csmr_Media    = 0x9E,    /* Selector */
    /* 0x9F Reserved */
    kHIDUsage_Csmr_VCRPlus    = 0xA0,    /* One-Shot Control */
    kHIDUsage_Csmr_Once    = 0xA1,    /* One-Shot Control */
    kHIDUsage_Csmr_Daily    = 0xA2,    /* One-Shot Control */
    kHIDUsage_Csmr_Weekly    = 0xA3,    /* One-Shot Control */
    kHIDUsage_Csmr_Monthly    = 0xA4,    /* One-Shot Control */
    /* 0xA5 - 0xAF Reserved */
    kHIDUsage_Csmr_Play    = 0xB0,    /* On/Off Control */
    kHIDUsage_Csmr_Pause    = 0xB1,    /* On/Off Control */
    kHIDUsage_Csmr_Record    = 0xB2,    /* On/Off Control */
    kHIDUsage_Csmr_FastForward    = 0xB3,    /* On/Off Control */
    kHIDUsage_Csmr_Rewind    = 0xB4,    /* On/Off Control */
    kHIDUsage_Csmr_ScanNextTrack    = 0xB5,    /* One-Shot Control */
    kHIDUsage_Csmr_ScanPreviousTrack    = 0xB6,    /* One-Shot Control */
    kHIDUsage_Csmr_Stop    = 0xB7,    /* One-Shot Control */
    kHIDUsage_Csmr_Eject    = 0xB8,    /* One-Shot Control */
    kHIDUsage_Csmr_RandomPlay    = 0xB9,    /* On/Off Control */
    kHIDUsage_Csmr_SelectDisc    = 0xBA,    /* Named Array */
    kHIDUsage_Csmr_EnterDisc    = 0xBB,    /* Momentary Control */
    kHIDUsage_Csmr_Repeat    = 0xBC,    /* One-Shot Control */
    kHIDUsage_Csmr_Tracking    = 0xBD,    /* Linear Control */
    kHIDUsage_Csmr_TrackNormal    = 0xBE,    /* One-Shot Control */
    kHIDUsage_Csmr_SlowTracking    = 0xBF,    /* Linear Control */
    kHIDUsage_Csmr_FrameForward    = 0xC0,    /* Re-Trigger Control */
    kHIDUsage_Csmr_FrameBack    = 0xC1,    /* Re-Trigger Control */
    kHIDUsage_Csmr_Mark    = 0xC2,    /* One-Shot Control */
    kHIDUsage_Csmr_ClearMark    = 0xC3,    /* One-Shot Control */
    kHIDUsage_Csmr_RepeatFromMark    = 0xC4,    /* On/Off Control */
    kHIDUsage_Csmr_ReturnToMark    = 0xC5,    /* One-Shot Control */
    kHIDUsage_Csmr_SearchMarkForward    = 0xC6,    /* One-Shot Control */
    kHIDUsage_Csmr_SearchMarkBackwards    = 0xC7,    /* One-Shot Control */
    kHIDUsage_Csmr_CounterReset    = 0xC8,    /* One-Shot Control */
    kHIDUsage_Csmr_ShowCounter    = 0xC9,    /* One-Shot Control */
    kHIDUsage_Csmr_TrackingIncrement    = 0xCA,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrackingDecrement    = 0xCB,    /* Re-Trigger Control */
    kHIDUsage_Csmr_StopOrEject    = 0xCC,    /* One-Shot Control */
    kHIDUsage_Csmr_PlayOrPause    = 0xCD,    /* One-Shot Control */
    kHIDUsage_Csmr_PlayOrSkip    = 0xCE,    /* One-Shot Control */
    kHIDUsage_Csmr_VoiceCommand    = 0xCF, /* One-Shot Control */
    /* 0xCF - 0xDF Reserved */
    kHIDUsage_Csmr_Volume    = 0xE0,    /* Linear Control */
    kHIDUsage_Csmr_Balance    = 0xE1,    /* Linear Control */
    kHIDUsage_Csmr_Mute    = 0xE2,    /* On/Off Control */
    kHIDUsage_Csmr_Bass    = 0xE3,    /* Linear Control */
    kHIDUsage_Csmr_Treble    = 0xE4,    /* Linear Control */
    kHIDUsage_Csmr_BassBoost    = 0xE5,    /* On/Off Control */
    kHIDUsage_Csmr_SurroundMode    = 0xE6,    /* One-Shot Control */
    kHIDUsage_Csmr_Loudness    = 0xE7,    /* On/Off Control */
    kHIDUsage_Csmr_MPX    = 0xE8,    /* On/Off Control */
    kHIDUsage_Csmr_VolumeIncrement    = 0xE9,    /* Re-Trigger Control */
    kHIDUsage_Csmr_VolumeDecrement    = 0xEA,    /* Re-Trigger Control */
    /* 0xEB - 0xEF Reserved */
    kHIDUsage_Csmr_Speed    = 0xF0,    /* Selector */
    kHIDUsage_Csmr_PlaybackSpeed    = 0xF1,    /* Named Array */
    kHIDUsage_Csmr_StandardPlay    = 0xF2,    /* Selector */
    kHIDUsage_Csmr_LongPlay    = 0xF3,    /* Selector */
    kHIDUsage_Csmr_ExtendedPlay    = 0xF4,    /* Selector */
    kHIDUsage_Csmr_Slow    = 0xF5,    /* One-Shot Control */
    /* 0xF6 - 0xFF Reserved */
    kHIDUsage_Csmr_FanEnable    = 0x100,    /* On/Off Control */
    kHIDUsage_Csmr_FanSpeed    = 0x101,    /* Linear Control */
    kHIDUsage_Csmr_LightEnable    = 0x102,    /* On/Off Control */
    kHIDUsage_Csmr_LightIlluminationLevel    = 0x103,    /* Linear Control */
    kHIDUsage_Csmr_ClimateControlEnable    = 0x104,    /* On/Off Control */
    kHIDUsage_Csmr_RoomTemperature    = 0x105,    /* Linear Control */
    kHIDUsage_Csmr_SecurityEnable    = 0x106,    /* On/Off Control */
    kHIDUsage_Csmr_FireAlarm    = 0x107,    /* One-Shot Control */
    kHIDUsage_Csmr_PoliceAlarm    = 0x108,    /* One-Shot Control */
    kHIDUsage_Csmr_Proximity    = 0x109,    /* Linear Control */
    kHIDUsage_Csmr_Motion    = 0x10A,    /* One-Shot Control */
    kHIDUsage_Csmr_DuressAlarm    = 0x10B,    /* One-Shot Control */
    kHIDUsage_Csmr_HoldupAlarm    = 0x10C,    /* One-Shot Control */
    kHIDUsage_Csmr_MedicalAlarm    = 0x10D,    /* One-Shot Control */
    /* 0x10E - 0x14F Reserved */
    kHIDUsage_Csmr_BalanceRight    = 0x150,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BalanceLeft    = 0x151,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BassIncrement    = 0x152,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BassDecrement    = 0x153,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrebleIncrement    = 0x154,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrebleDecrement    = 0x155,    /* Re-Trigger Control */
    /* 0x156 - 0x15F Reserved */
    kHIDUsage_Csmr_SpeakerSystem    = 0x160,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelLeft    = 0x161,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelRight    = 0x162,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelCenter    = 0x163,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelFront    = 0x164,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelCenterFront    = 0x165,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelSide    = 0x166,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelSurround    = 0x167,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelLowFrequencyEnhancement    = 0x168,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelTop    = 0x169,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelUnknown    = 0x16A,    /* Logical Collection */
    /* 0x16B - 0x16F Reserved */
    kHIDUsage_Csmr_SubChannel    = 0x170,    /* Linear Control */
    kHIDUsage_Csmr_SubChannelIncrement    = 0x171,    /* One-Shot Control */
    kHIDUsage_Csmr_SubChannelDecrement    = 0x172,    /* One-Shot Control */
    kHIDUsage_Csmr_AlternateAudioIncrement    = 0x173,    /* One-Shot Control */
    kHIDUsage_Csmr_AlternateAudioDecrement    = 0x174,    /* One-Shot Control */
    /* 0x175 - 0x17F Reserved */
    kHIDUsage_Csmr_ApplicationLaunchButtons    = 0x180,    /* Named Array */
    kHIDUsage_Csmr_ALLaunchButtonConfigurationTool    = 0x181,    /* Selector */
    kHIDUsage_Csmr_ALProgrammableButtonConfiguration    = 0x182,    /* Selector */
    kHIDUsage_Csmr_ALConsumerControlConfiguration    = 0x183,    /* Selector */
    kHIDUsage_Csmr_ALWordProcessor    = 0x184,    /* Selector */
    kHIDUsage_Csmr_ALTextEditor    = 0x185,    /* Selector */
    kHIDUsage_Csmr_ALSpreadsheet    = 0x186,    /* Selector */
    kHIDUsage_Csmr_ALGraphicsEditor    = 0x187,    /* Selector */
    kHIDUsage_Csmr_ALPresentationApp    = 0x188,    /* Selector */
    kHIDUsage_Csmr_ALDatabaseApp    = 0x189,    /* Selector */
    kHIDUsage_Csmr_ALEmailReader    = 0x18A,    /* Selector */
    kHIDUsage_Csmr_ALNewsreader    = 0x18B,    /* Selector */
    kHIDUsage_Csmr_ALVoicemail    = 0x18C,    /* Selector */
    kHIDUsage_Csmr_ALContactsOrAddressBook    = 0x18D,    /* Selector */
    kHIDUsage_Csmr_ALCalendarOrSchedule    = 0x18E,    /* Selector */
    kHIDUsage_Csmr_ALTaskOrProjectManager    = 0x18F,    /* Selector */
    kHIDUsage_Csmr_ALLogOrJournalOrTimecard    = 0x190,    /* Selector */
    kHIDUsage_Csmr_ALCheckbookOrFinance    = 0x191,    /* Selector */
    kHIDUsage_Csmr_ALCalculator    = 0x192,    /* Selector */
    kHIDUsage_Csmr_ALAOrVCaptureOrPlayback    = 0x193,    /* Selector */
    kHIDUsage_Csmr_ALLocalMachineBrowser    = 0x194,    /* Selector */
    kHIDUsage_Csmr_ALLANOrWANBrowser    = 0x195,    /* Selector */
    kHIDUsage_Csmr_ALInternetBrowser    = 0x196,    /* Selector */
    kHIDUsage_Csmr_ALRemoteNetworkingOrISPConnect    = 0x197,    /* Selector */
    kHIDUsage_Csmr_ALNetworkConference    = 0x198,    /* Selector */
    kHIDUsage_Csmr_ALNetworkChat    = 0x199,    /* Selector */
    kHIDUsage_Csmr_ALTelephonyOrDialer    = 0x19A,    /* Selector */
    kHIDUsage_Csmr_ALLogon    = 0x19B,    /* Selector */
    kHIDUsage_Csmr_ALLogoff    = 0x19C,    /* Selector */
    kHIDUsage_Csmr_ALLogonOrLogoff    = 0x19D,    /* Selector */
    kHIDUsage_Csmr_ALTerminalLockOrScreensaver    = 0x19E,    /* Selector */
    kHIDUsage_Csmr_ALControlPanel    = 0x19F,    /* Selector */
    kHIDUsage_Csmr_ALCommandLineProcessorOrRun    = 0x1A0,    /* Selector */
    kHIDUsage_Csmr_ALProcessOrTaskManager    = 0x1A1,    /* Selector */
    kHIDUsage_Csmr_AL    = 0x1A2,    /* Selector */
    kHIDUsage_Csmr_ALNextTaskOrApplication    = 0x1A3,    /* Selector */
    kHIDUsage_Csmr_ALPreviousTaskOrApplication    = 0x1A4,    /* Selector */
    kHIDUsage_Csmr_ALPreemptiveHaltTaskOrApplication    = 0x1A5,    /* Selector */
    kHIDUsage_Csmr_ALIntegratedHelpCenter   = 0x1A6, /* Selector */
    kHIDUsage_Csmr_ALDocuments   = 0x1A7, /* Selector */
    kHIDUsage_Csmr_ALThesaurus   = 0x1A8, /* Selector */
    kHIDUsage_Csmr_ALDictionary   = 0x1A9, /* Selector */
    kHIDUsage_Csmr_ALDesktop   = 0x1AA, /* Selector */
    kHIDUsage_Csmr_ALSpellCheck   = 0x1AB, /* Selector */
    kHIDUsage_Csmr_ALGrammerCheck   = 0x1AC, /* Selector */
    kHIDUsage_Csmr_ALWirelessStatus   = 0x1AD, /* Selector */
    kHIDUsage_Csmr_ALKeyboardLayout   = 0x1AE, /* Selector */
    kHIDUsage_Csmr_ALVirusProtection   = 0x1AF, /* Selector */
    kHIDUsage_Csmr_ALEncryption   = 0x1B0, /* Selector */
    kHIDUsage_Csmr_ALScreenSaver   = 0x1B1, /* Selector */
    kHIDUsage_Csmr_ALAlarms   = 0x1B2, /* Selector */
    kHIDUsage_Csmr_ALClock   = 0x1B3, /* Selector */
    kHIDUsage_Csmr_ALFileBrowser   = 0x1B4, /* Selector */
    kHIDUsage_Csmr_ALPowerStatus   = 0x1B5, /* Selector */
    kHIDUsage_Csmr_ALImageBrowser   = 0x1B6, /* Selector */
    kHIDUsage_Csmr_ALAudioBrowser   = 0x1B7, /* Selector */
    kHIDUsage_Csmr_ALMovieBrowser   = 0x1B8, /* Selector */
    kHIDUsage_Csmr_ALDigitalRightsManager   = 0x1B9, /* Selector */
    kHIDUsage_Csmr_ALDigitalWallet   = 0x1BA, /* Selector */
    /* 0x1BB Reserved */
    kHIDUsage_Csmr_ALInstantMessaging   = 0x1BC, /* Selector */
    kHIDUsage_Csmr_ALOEMFeatureBrowser  = 0x1BD, /* Selector */
    kHIDUsage_Csmr_ALOEMHelp    = 0x1BE, /* Selector */
    kHIDUsage_Csmr_ALOnlineCommunity    = 0x1BF, /* Selector */
    kHIDUsage_Csmr_ALEntertainmentContentBrowser    = 0x1C0, /* Selector */
    kHIDUsage_Csmr_ALOnlineShoppingBrowswer = 0x1C1, /* Selector */
    kHIDUsage_Csmr_ALSmartCardInformationOrHelp = 0x1C2, /* Selector */
    kHIDUsage_Csmr_ALMarketMonitorOrFinanceBrowser  = 0x1C3, /* Selector */
    kHIDUsage_Csmr_ALCustomizedCorporateNewsBrowser = 0x1C4, /* Selector */
    kHIDUsage_Csmr_ALOnlineActivityBrowswer= 0x1C5, /* Selector */
    kHIDUsage_Csmr_ALResearchOrSearchBrowswer   = 0x1C6, /* Selector */
    kHIDUsage_Csmr_ALAudioPlayer= 0x1C7, /* Selector */
    /* 0x1C8 - 0x1FF Reserved */
    kHIDUsage_Csmr_GenericGUIApplicationControls    = 0x200,    /* Named Array */
    kHIDUsage_Csmr_ACNew    = 0x201,    /* Selector */
    kHIDUsage_Csmr_ACOpen    = 0x202,    /* Selector */
    kHIDUsage_Csmr_ACClose    = 0x203,    /* Selector */
    kHIDUsage_Csmr_ACExit    = 0x204,    /* Selector */
    kHIDUsage_Csmr_ACMaximize    = 0x205,    /* Selector */
    kHIDUsage_Csmr_ACMinimize    = 0x206,    /* Selector */
    kHIDUsage_Csmr_ACSave    = 0x207,    /* Selector */
    kHIDUsage_Csmr_ACPrint    = 0x208,    /* Selector */
    kHIDUsage_Csmr_ACProperties    = 0x209,    /* Selector */
    kHIDUsage_Csmr_ACUndo    = 0x21A,    /* Selector */
    kHIDUsage_Csmr_ACCopy    = 0x21B,    /* Selector */
    kHIDUsage_Csmr_ACCut    = 0x21C,    /* Selector */
    kHIDUsage_Csmr_ACPaste    = 0x21D,    /* Selector */
    kHIDUsage_Csmr_AC    = 0x21E,    /* Selector */
    kHIDUsage_Csmr_ACFind    = 0x21F,    /* Selector */
    kHIDUsage_Csmr_ACFindandReplace    = 0x220,    /* Selector */
    kHIDUsage_Csmr_ACSearch    = 0x221,    /* Selector */
    kHIDUsage_Csmr_ACGoTo    = 0x222,    /* Selector */
    kHIDUsage_Csmr_ACHome    = 0x223,    /* Selector */
    kHIDUsage_Csmr_ACBack    = 0x224,    /* Selector */
    kHIDUsage_Csmr_ACForward    = 0x225,    /* Selector */
    kHIDUsage_Csmr_ACStop    = 0x226,    /* Selector */
    kHIDUsage_Csmr_ACRefresh    = 0x227,    /* Selector */
    kHIDUsage_Csmr_ACPreviousLink    = 0x228,    /* Selector */
    kHIDUsage_Csmr_ACNextLink    = 0x229,    /* Selector */
    kHIDUsage_Csmr_ACBookmarks    = 0x22A,    /* Selector */
    kHIDUsage_Csmr_ACHistory    = 0x22B,    /* Selector */
    kHIDUsage_Csmr_ACSubscriptions    = 0x22C,    /* Selector */
    kHIDUsage_Csmr_ACZoomIn    = 0x22D,    /* Selector */
    kHIDUsage_Csmr_ACZoomOut    = 0x22E,    /* Selector */
    kHIDUsage_Csmr_ACZoom    = 0x22F,    /* Selector */
    kHIDUsage_Csmr_ACFullScreenView    = 0x230,    /* Selector */
    kHIDUsage_Csmr_ACNormalView    = 0x231,    /* Selector */
    kHIDUsage_Csmr_ACViewToggle    = 0x232,    /* Selector */
    kHIDUsage_Csmr_ACScrollUp    = 0x233,    /* Selector */
    kHIDUsage_Csmr_ACScrollDown    = 0x234,    /* Selector */
    kHIDUsage_Csmr_ACScroll    = 0x235,    /* Selector */
    kHIDUsage_Csmr_ACPanLeft    = 0x236,    /* Selector */
    kHIDUsage_Csmr_ACPanRight    = 0x237,    /* Selector */
    kHIDUsage_Csmr_ACPan    = 0x238,    /* Selector */
    kHIDUsage_Csmr_ACNewWindow    = 0x239,    /* Selector */
    kHIDUsage_Csmr_ACTileHorizontally    = 0x23A,    /* Selector */
    kHIDUsage_Csmr_ACTileVertically    = 0x23B,    /* Selector */
    kHIDUsage_Csmr_ACFormat    = 0x23C,    /* Selector */
    kHIDUsage_Csmr_ACEdit   = 0x23D,    /* Selector */
    kHIDUsage_Csmr_ACBold   = 0x23E,    /* Selector */
    kHIDUsage_Csmr_ACItalics    = 0x23F,    /* Selector */
    kHIDUsage_Csmr_ACUnderline  = 0x240,    /* Selector */
    kHIDUsage_Csmr_ACStrikethrough  = 0x241,    /* Selector */
    kHIDUsage_Csmr_ACSubscript  = 0x242,    /* Selector */
    kHIDUsage_Csmr_ACSuperscript    = 0x243,    /* Selector */
    kHIDUsage_Csmr_ACAllCaps    = 0x244,    /* Selector */
    kHIDUsage_Csmr_ACRotate = 0x245,    /* Selector */
    kHIDUsage_Csmr_ACResize = 0x246,    /* Selector */
    kHIDUsage_Csmr_ACFlipHorizontal = 0x247,    /* Selector */
    kHIDUsage_Csmr_ACFlipVertical   = 0x248,    /* Selector */
    kHIDUsage_Csmr_ACMirrorHorizontal   = 0x249,    /* Selector */
    kHIDUsage_Csmr_ACMirrorVertical = 0x24A,    /* Selector */
    kHIDUsage_Csmr_ACFontSelect = 0x24B,    /* Selector */
    kHIDUsage_Csmr_ACFontColor  = 0x24C,    /* Selector */
    kHIDUsage_Csmr_ACFontSize   = 0x24D,    /* Selector */
    kHIDUsage_Csmr_ACJustifyLeft    = 0x24E,    /* Selector */
    kHIDUsage_Csmr_ACJustifyCenterH = 0x24F,    /* Selector */
    kHIDUsage_Csmr_ACJustifyRight   = 0x250,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBlockH  = 0x251,    /* Selector */
    kHIDUsage_Csmr_ACJustifyTop     = 0x252,    /* Selector */
    kHIDUsage_Csmr_ACJustifyCenterV = 0x253,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBottom  = 0x254,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBlockV  = 0x255,    /* Selector */
    kHIDUsage_Csmr_ACIndentyDecrease    = 0x256,    /* Selector */
    kHIDUsage_Csmr_ACIndentyIncrease    = 0x257,    /* Selector */
    kHIDUsage_Csmr_ACNumberedList   = 0x258,    /* Selector */
    kHIDUsage_Csmr_ACRestartNumbering   = 0x259,    /* Selector */
    kHIDUsage_Csmr_ACBulletedList   = 0x25A,    /* Selector */
    kHIDUsage_Csmr_ACPromote    = 0x25B,    /* Selector */
    kHIDUsage_Csmr_ACDemote = 0x25C,    /* Selector */
    kHIDUsage_Csmr_ACYes    = 0x25D,    /* Selector */
    kHIDUsage_Csmr_ACNo = 0x25E,    /* Selector */
    kHIDUsage_Csmr_ACCancel = 0x25F,    /* Selector */
    kHIDUsage_Csmr_ACCatalog    = 0x260,    /* Selector */
    kHIDUsage_Csmr_ACBuyOrCheckout  = 0x261,    /* Selector */
    kHIDUsage_Csmr_ACAddToCart  = 0x262,    /* Selector */
    kHIDUsage_Csmr_ACExpand = 0x263,    /* Selector */
    kHIDUsage_Csmr_ACExpandAll  = 0x264,    /* Selector */
    kHIDUsage_Csmr_ACCollapse   = 0x265,    /* Selector */
    kHIDUsage_Csmr_ACCollapseAll    = 0x266,    /* Selector */
    kHIDUsage_Csmr_ACPrintPreview   = 0x267,    /* Selector */
    kHIDUsage_Csmr_ACPasteSpecial   = 0x268,    /* Selector */
    kHIDUsage_Csmr_ACInsertMode = 0x269,    /* Selector */
    kHIDUsage_Csmr_ACDelete = 0x26A,    /* Selector */
    kHIDUsage_Csmr_ACLock   = 0x26B,    /* Selector */
    kHIDUsage_Csmr_ACUnlock = 0x26C,    /* Selector */
    kHIDUsage_Csmr_ACProtect    = 0x26D,    /* Selector */
    kHIDUsage_Csmr_ACUnprotect  = 0x26E,    /* Selector */
    kHIDUsage_Csmr_ACAttachComment  = 0x26F,    /* Selector */
    kHIDUsage_Csmr_ACDetachComment  = 0x270,    /* Selector */
    kHIDUsage_Csmr_ACViewComment    = 0x271,    /* Selector */
    kHIDUsage_Csmr_ACSelectWord = 0x272,    /* Selector */
    kHIDUsage_Csmr_ACSelectSentence = 0x273,    /* Selector */
    kHIDUsage_Csmr_ACSelectParagraph    = 0x274,    /* Selector */
    kHIDUsage_Csmr_ACSelectColumn   = 0x275,    /* Selector */
    kHIDUsage_Csmr_ACSelectRow  = 0x276,    /* Selector */
    kHIDUsage_Csmr_ACSelectTable    = 0x277,    /* Selector */
    kHIDUsage_Csmr_ACSelectObject   = 0x278,    /* Selector */
    kHIDUsage_Csmr_ACRedoOrRepeat   = 0x279,    /* Selector */
    kHIDUsage_Csmr_ACSort   = 0x27A,    /* Selector */
    kHIDUsage_Csmr_ACSortAscending  = 0x27B,    /* Selector */
    kHIDUsage_Csmr_ACSortDescending = 0x27C,    /* Selector */
    kHIDUsage_Csmr_ACFilter = 0x27D,    /* Selector */
    kHIDUsage_Csmr_ACSetClock   = 0x27E,    /* Selector */
    kHIDUsage_Csmr_ACViewClock  = 0x27F,    /* Selector */
    kHIDUsage_Csmr_ACSelectTimeZone = 0x280,    /* Selector */
    kHIDUsage_Csmr_ACEditTimeZones  = 0x281,    /* Selector */
    kHIDUsage_Csmr_ACSetAlarm   = 0x282,    /* Selector */
    kHIDUsage_Csmr_ACClearAlarm = 0x283,    /* Selector */
    kHIDUsage_Csmr_ACSnoozeAlarm    = 0x284,    /* Selector */
    kHIDUsage_Csmr_ACResetAlarm = 0x285,    /* Selector */
    kHIDUsage_Csmr_ACSynchronize    = 0x286,    /* Selector */
    kHIDUsage_Csmr_ACSendOrReceive  = 0x287,    /* Selector */
    kHIDUsage_Csmr_ACSendTo = 0x288,    /* Selector */
    kHIDUsage_Csmr_ACReply  = 0x289,    /* Selector */
    kHIDUsage_Csmr_ACReplyAll   = 0x28A,    /* Selector */
    kHIDUsage_Csmr_ACForwardMessage = 0x28B,    /* Selector */
    kHIDUsage_Csmr_ACSend   = 0x28C,    /* Selector */
    kHIDUsage_Csmr_ACAttachFile = 0x28D,    /* Selector */
    kHIDUsage_Csmr_ACUpload = 0x28E,    /* Selector */
    kHIDUsage_Csmr_ACDownload   = 0x28F,    /* Selector */
    kHIDUsage_Csmr_ACSetBorders = 0x290,    /* Selector */
    kHIDUsage_Csmr_ACInsertRow  = 0x291,    /* Selector */
    kHIDUsage_Csmr_ACInsertColumn   = 0x292,    /* Selector */
    kHIDUsage_Csmr_ACInsertFile = 0x293,    /* Selector */
    kHIDUsage_Csmr_ACInsertPicture  = 0x294,    /* Selector */
    kHIDUsage_Csmr_ACInsertObject   = 0x295,    /* Selector */
    kHIDUsage_Csmr_ACInsertSymbol   = 0x296,    /* Selector */
    kHIDUsage_Csmr_ACSaveAndClose   = 0x297,    /* Selector */
    kHIDUsage_Csmr_ACRename = 0x298,    /* Selector */
    kHIDUsage_Csmr_ACMerge  = 0x299,    /* Selector */
    kHIDUsage_Csmr_ACSplit  = 0x29A,    /* Selector */
    kHIDUsage_Csmr_ACDistributeH    = 0x29B,    /* Selector */
    kHIDUsage_Csmr_ACDistributeV    = 0x29C,    /* Selector */
    /* 0x29D - 0xFFFF Reserved */
    kHIDUsage_Csmr_Reserved = 0xFFFF
};

/* Digitizer Page (0x0D) */
/* This section provides detailed descriptions of the usages employed by Digitizer Devices. */
enum
{
    kHIDUsage_Dig_Digitizer                         = 0x01,     /* Application Collection */
    kHIDUsage_Dig_Pen                               = 0x02,     /* Application Collection */
    kHIDUsage_Dig_LightPen                          = 0x03,     /* Application Collection */
    kHIDUsage_Dig_TouchScreen                       = 0x04,     /* Application Collection */
    kHIDUsage_Dig_TouchPad                          = 0x05,     /* Application Collection */
    kHIDUsage_Dig_WhiteBoard                        = 0x06,     /* Application Collection */
    kHIDUsage_Dig_CoordinateMeasuringMachine        = 0x07,     /* Application Collection */
    kHIDUsage_Dig_3DDigitizer                       = 0x08,     /* Application Collection */
    kHIDUsage_Dig_StereoPlotter                     = 0x09,     /* Application Collection */
    kHIDUsage_Dig_ArticulatedArm                    = 0x0A,     /* Application Collection */
    kHIDUsage_Dig_Armature                          = 0x0B,     /* Application Collection */
    kHIDUsage_Dig_MultiplePointDigitizer            = 0x0C,     /* Application Collection */
    kHIDUsage_Dig_FreeSpaceWand                     = 0x0D,     /* Application Collection */
    kHIDUsage_Dig_DeviceConfiguration               = 0x0E,     /* Application Collection */
    /* 0x0F - 0x1F Reserved */
    kHIDUsage_Dig_Stylus                            = 0x20,     /* Logical Collection */
    kHIDUsage_Dig_Puck                              = 0x21,     /* Logical Collection */
    kHIDUsage_Dig_Finger                            = 0x22,     /* Logical Collection */
    kHIDUsage_Dig_DeviceSettings                    = 0x23,     /* Logical Collection */
    kHIDUsage_Dig_GestureCharacter                  = 0x24,     /* Logical Collection */
    /* 0x25 - 0x2F Reserved */
    kHIDUsage_Dig_TipPressure                       = 0x30,     /* Dynamic Value */
    kHIDUsage_Dig_BarrelPressure                    = 0x31,     /* Dynamic Value */
    kHIDUsage_Dig_InRange                           = 0x32,     /* Momentary Control */
    kHIDUsage_Dig_Touch                             = 0x33,     /* Momentary Control */
    kHIDUsage_Dig_Untouch                           = 0x34,     /* One-Shot Control */
    kHIDUsage_Dig_Tap                               = 0x35,     /* One-Shot Control */
    kHIDUsage_Dig_Quality                           = 0x36,     /* Dynamic Value */
    kHIDUsage_Dig_DataValid                         = 0x37,     /* Momentary Control */
    kHIDUsage_Dig_TransducerIndex                   = 0x38,     /* Dynamic Value */
    kHIDUsage_Dig_TabletFunctionKeys                = 0x39,     /* Logical Collection */
    kHIDUsage_Dig_ProgramChangeKeys                 = 0x3A,     /* Logical Collection */
    kHIDUsage_Dig_BatteryStrength                   = 0x3B,     /* Dynamic Value */
    kHIDUsage_Dig_Invert                            = 0x3C,     /* Momentary Control */
    kHIDUsage_Dig_XTilt                             = 0x3D,     /* Dynamic Value */
    kHIDUsage_Dig_YTilt                             = 0x3E,     /* Dynamic Value */
    kHIDUsage_Dig_Azimuth                           = 0x3F,     /* Dynamic Value */
    kHIDUsage_Dig_Altitude                          = 0x40,     /* Dynamic Value */
    kHIDUsage_Dig_Twist                             = 0x41,     /* Dynamic Value */
    kHIDUsage_Dig_TipSwitch                         = 0x42,     /* Momentary Control */
    kHIDUsage_Dig_SecondaryTipSwitch                = 0x43,     /* Momentary Control */
    kHIDUsage_Dig_BarrelSwitch                      = 0x44,     /* Momentary Control */
    kHIDUsage_Dig_Eraser                            = 0x45,     /* Momentary Control */
    kHIDUsage_Dig_TabletPick                        = 0x46,     /* Momentary Control */
    kHIDUsage_Dig_TouchValid                        = 0x47,     /* Momentary Control */
    kHIDUsage_Dig_Width                             = 0x48,     /* Dynamic Value */
    kHIDUsage_Dig_Height                            = 0x49,     /* Dynamic Value */
    /* 0x4A - 0x50 Reserved */
    kHIDUsage_Dig_ContactIdentifier                 = 0x51,     /* Dynamic Value */
    kHIDUsage_Dig_DeviceMode                        = 0x52,     /* Dynamic Value */
    kHIDUsage_Dig_DeviceIdentifier                  = 0x53,     /* Dynamic Value */
    kHIDUsage_Dig_ContactCount                      = 0x54,     /* Dynamic Value */
    kHIDUsage_Dig_ContactCountMaximum               = 0x55,     /* Static Value */
    
    /* 0x56 - 0x5F Reserved */
    kHIDUsage_Dig_GestureCharacterEnable            = 0x60,     /* Dynamic Flag */
    kHIDUsage_Dig_GestureCharacterQuality           = 0x61,     /* Dynamic Value */
    kHIDUsage_Dig_GestureCharacterDataLength        = 0x62,     /* Dynamic Value */
    kHIDUsage_Dig_GestureCharacterData              = 0x63,     /* Buffered Bytes */
    kHIDUsage_Dig_GestureCharacterEncoding          = 0x64,     /* Named Array */
    kHIDUsage_Dig_GestureCharacterEncodingUTF8      = 0x65,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF16LE   = 0x66,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF16BE   = 0x67,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF32LE   = 0x68,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF32BE   = 0x69,     /* Selector */
    
    /* 0x70 - 0xFFFF Reserved */
    kHIDUsage_Dig_Reserved                          = 0xFFFF
};

/* Physical Interface Device Page (0x0F) */
/* This section provides detailed descriptions of the usages employed by Power Devices. */
enum
{
    kHIDUsage_PID_PhysicalInterfaceDevice = 0x01,        /* CA - A collection of PID usages */
    /* 0x02 - 0x1F Reserved */
    kHIDUsage_PID_Normal = 0x20,                        /* DV - A force applied perpendicular to the surface of an object */
    kHIDUsage_PID_SetEffectReport = 0x21,                /* XXX */
    kHIDUsage_PID_EffectBlockIndex = 0x22,                /* XXX */
    kHIDUsage_PID_ParamBlockOffset = 0x23,                /* XXX */
    kHIDUsage_PID_ROM_Flag = 0x24,                        /* XXX */
    kHIDUsage_PID_EffectType = 0x25,                    /* XXX */
    kHIDUsage_PID_ET_ConstantForce = 0x26,                /* XXX */
    kHIDUsage_PID_ET_Ramp = 0x27,                        /* XXX */
    kHIDUsage_PID_ET_CustomForceData = 0x28,            /* XXX */
    /* 0x29 - 0x2F Reserved */
    kHIDUsage_PID_ET_Square = 0x30,                        /* XXX */
    kHIDUsage_PID_ET_Sine = 0x31,                        /* XXX */
    kHIDUsage_PID_ET_Triangle = 0x32,                    /* XXX */
    kHIDUsage_PID_ET_SawtoothUp = 0x33,                    /* XXX */
    kHIDUsage_PID_ET_SawtoothDown = 0x34,                /* XXX */
    /* 0x35 - 0x3F Reserved */
    kHIDUsage_PID_ET_Spring = 0x40,                        /* XXX */
    kHIDUsage_PID_ET_Damper = 0x41,                        /* XXX */
    kHIDUsage_PID_ET_Inertia = 0x42,                    /* XXX */
    kHIDUsage_PID_ET_Friction = 0x43,                    /* XXX */
    /* 0x44 - 0x4F Reserved */
    kHIDUsage_PID_Duration = 0x50,                        /* XXX */
    kHIDUsage_PID_SamplePeriod = 0x51,                    /* XXX */
    kHIDUsage_PID_Gain = 0x52,                            /* XXX */
    kHIDUsage_PID_TriggerButton = 0x53,                    /* XXX */
    kHIDUsage_PID_TriggerRepeatInterval = 0x54,            /* XXX */
    kHIDUsage_PID_AxesEnable = 0x55,                    /* XXX */
    kHIDUsage_PID_DirectionEnable = 0x56,                /* XXX */
    kHIDUsage_PID_Direction = 0x57,                        /* XXX */
    kHIDUsage_PID_TypeSpecificBlockOffset = 0x58,        /* XXX */
    kHIDUsage_PID_BlockType = 0x59,                        /* XXX */
    kHIDUsage_PID_SetEnvelopeReport = 0x5A,                /* XXX */
    kHIDUsage_PID_AttackLevel = 0x5B,                    /* XXX */
    kHIDUsage_PID_AttackTime = 0x5C,                    /* XXX */
    kHIDUsage_PID_FadeLevel = 0x5D,                        /* XXX */
    kHIDUsage_PID_FadeTime = 0x5E,                        /* XXX */
    kHIDUsage_PID_SetConditionReport = 0x5F,            /* XXX */
    
    kHIDUsage_PID_CP_Offset = 0x60,                        /* XXX */
    kHIDUsage_PID_PositiveCoefficient = 0x61,            /* XXX */
    kHIDUsage_PID_NegativeCoefficient = 0x62,            /* XXX */
    kHIDUsage_PID_PositiveSaturation = 0x63,            /* XXX */
    kHIDUsage_PID_NegativeSaturation = 0x64,            /* XXX */
    kHIDUsage_PID_DeadBand = 0x65,                        /* XXX */
    kHIDUsage_PID_DownloadForceSample = 0x66,            /* XXX */
    kHIDUsage_PID_IsochCustomForceEnable = 0x67,        /* XXX */
    kHIDUsage_PID_CustomForceDataReport = 0x68,            /* XXX */
    kHIDUsage_PID_CustomForceData = 0x69,                /* XXX */
    kHIDUsage_PID_CustomForceVendorDefinedData = 0x6A,    /* XXX */
    kHIDUsage_PID_SetCustomForceReport = 0x6B,            /* XXX */
    kHIDUsage_PID_CustomForceDataOffset = 0x6C,            /* XXX */
    kHIDUsage_PID_SampleCount = 0x6D,                    /* XXX */
    kHIDUsage_PID_SetPeriodicReport = 0x6E,                /* XXX */
    kHIDUsage_PID_Offset = 0x6F,                        /* XXX */
    
    kHIDUsage_PID_Magnitude = 0x70,                        /* XXX */
    kHIDUsage_PID_Phase = 0x71,                            /* XXX */
    kHIDUsage_PID_Period = 0x72,                        /* XXX */
    kHIDUsage_PID_SetConstantForceReport = 0x73,        /* XXX */
    kHIDUsage_PID_SetRampForceReport = 0x74,            /* XXX */
    kHIDUsage_PID_RampStart = 0x75,                        /* XXX */
    kHIDUsage_PID_RampEnd = 0x76,                        /* XXX */
    kHIDUsage_PID_EffectOperationReport = 0x77,            /* XXX */
    kHIDUsage_PID_EffectOperation = 0x78,                /* XXX */
    kHIDUsage_PID_OpEffectStart = 0x79,                    /* XXX */
    kHIDUsage_PID_OpEffectStartSolo = 0x7A,                /* XXX */
    kHIDUsage_PID_OpEffectStop = 0x7B,                    /* XXX */
    kHIDUsage_PID_LoopCount = 0x7C,                        /* XXX */
    kHIDUsage_PID_DeviceGainReport = 0x7D,                /* XXX */
    kHIDUsage_PID_DeviceGain = 0x7E,                    /* XXX */
    kHIDUsage_PID_PoolReport = 0x7F,                    /* XXX */
    
    kHIDUsage_PID_RAM_PoolSize = 0x80,                    /* XXX */
    kHIDUsage_PID_ROM_PoolSize = 0x81,                    /* XXX */
    kHIDUsage_PID_ROM_EffectBlockCount = 0x82,            /* XXX */
    kHIDUsage_PID_SimultaneousEffectsMax = 0x83,        /* XXX */
    kHIDUsage_PID_PoolAlignment = 0x84,                    /* XXX */
    kHIDUsage_PID_PoolMoveReport = 0x85,                /* XXX */
    kHIDUsage_PID_MoveSource = 0x86,                    /* XXX */
    kHIDUsage_PID_MoveDestination = 0x87,                /* XXX */
    kHIDUsage_PID_MoveLength = 0x88,                    /* XXX */
    kHIDUsage_PID_BlockLoadReport = 0x89,                /* XXX */
    /* 0x8A Reserved */
    kHIDUsage_PID_BlockLoadStatus = 0x8B,                /* XXX */
    kHIDUsage_PID_BlockLoadSuccess = 0x8C,                /* XXX */
    kHIDUsage_PID_BlockLoadFull = 0x8D,                    /* XXX */
    kHIDUsage_PID_BlockLoadError = 0x8E,                /* XXX */
    kHIDUsage_PID_BlockHandle = 0x8F,                    /* XXX */
    
    kHIDUsage_PID_BlockFreeReport = 0x90,                /* XXX */
    kHIDUsage_PID_TypeSpecificBlockHandle = 0x91,        /* XXX */
    kHIDUsage_PID_StateReport = 0x92,                    /* XXX */
    /* 0x93 Reserved */
    kHIDUsage_PID_EffectPlaying = 0x94,                    /* XXX */
    kHIDUsage_PID_DeviceControlReport = 0x95,            /* XXX */
    kHIDUsage_PID_DeviceControl = 0x96,                    /* XXX */
    kHIDUsage_PID_DC_EnableActuators = 0x97,            /* XXX */
    kHIDUsage_PID_DC_DisableActuators = 0x98,            /* XXX */
    kHIDUsage_PID_DC_StopAllEffects = 0x99,                /* XXX */
    kHIDUsage_PID_DC_DeviceReset = 0x9A,                /* XXX */
    kHIDUsage_PID_DC_DevicePause = 0x9B,                /* XXX */
    kHIDUsage_PID_DC_DeviceContinue = 0x9C,                /* XXX */
    /* 0x9d - 0x9E Reserved */
    kHIDUsage_PID_DevicePaused = 0x9F,                    /* XXX */
    
    kHIDUsage_PID_ActuatorsEnabled = 0xA0,                /* XXX */
    /* 0xA1 - 0xA3 Reserved */
    kHIDUsage_PID_SafetySwitch = 0xA4,                    /* XXX */
    kHIDUsage_PID_ActuatorOverrideSwitch = 0xA5,        /* XXX */
    kHIDUsage_PID_ActuatorPower = 0xA6,                    /* XXX */
    kHIDUsage_PID_StartDelay = 0xA7,                    /* XXX */
    kHIDUsage_PID_ParameterBlockSize = 0xA8,            /* XXX */
    kHIDUsage_PID_DeviceManagedPool = 0xA9,                /* XXX */
    kHIDUsage_PID_SharedParameterBlocks = 0xAA,            /* XXX */
    kHIDUsage_PID_CreateNewEffectReport = 0xAB,            /* XXX */
    kHIDUsage_PID_RAM_PoolAvailable = 0xAC,                /* XXX */
    /* 0xAD - 0xFFFF Reserved */
    kHIDUsage_PID_Reserved = 0xFFFF
};

/* AlphanumericDisplay Page (0x14) */
/* The Alphanumeric Display page is intended for use by simple alphanumeric displays that are used on consumer devices. */
enum
{
    kHIDUsage_AD_AlphanumericDisplay    = 0x01,    /* Application Collection */
    /* 0x02 - 0x1F Reserved */
    kHIDUsage_AD_DisplayAttributesReport    = 0x20,    /* Logical Collection */
    kHIDUsage_AD_ASCIICharacterSet    = 0x21,    /* Static Flag */
    kHIDUsage_AD_DataReadBack    = 0x22,    /* Static Flag */
    kHIDUsage_AD_FontReadBack    = 0x23,    /* Static Flag */
    kHIDUsage_AD_DisplayControlReport    = 0x24,    /* Logical Collection */
    kHIDUsage_AD_ClearDisplay    = 0x25,    /* Dynamic Flag */
    kHIDUsage_AD_DisplayEnable    = 0x26,    /* Dynamic Flag */
    kHIDUsage_AD_ScreenSaverDelay    = 0x27,    /* Static Value */
    kHIDUsage_AD_ScreenSaverEnable    = 0x28,    /* Dynamic Flag */
    kHIDUsage_AD_VerticalScroll    = 0x29,    /* Static Flag */
    kHIDUsage_AD_HorizontalScroll    = 0x2A,    /* Static Flag */
    kHIDUsage_AD_CharacterReport    = 0x2B,    /* Logical Collection */
    kHIDUsage_AD_DisplayData    = 0x2C,    /* Dynamic Value */
    kHIDUsage_AD_DisplayStatus    = 0x2D,    /* Logical Collection */
    kHIDUsage_AD_StatNotReady    = 0x2E,    /* Selector */
    kHIDUsage_AD_StatReady    = 0x2F,    /* Selector */
    kHIDUsage_AD_ErrNotaloadablecharacter    = 0x30,    /* Selector */
    kHIDUsage_AD_ErrFontdatacannotberead    = 0x31,    /* Selector */
    kHIDUsage_AD_CursorPositionReport    = 0x32,    /* Logical Collection */
    kHIDUsage_AD_Row    = 0x33,    /* Dynamic Value */
    kHIDUsage_AD_Column    = 0x34,    /* Dynamic Value */
    kHIDUsage_AD_Rows    = 0x35,    /* Static Value */
    kHIDUsage_AD_Columns    = 0x36,    /* Static Value */
    kHIDUsage_AD_CursorPixelPositioning    = 0x37,    /* Static Flag */
    kHIDUsage_AD_CursorMode    = 0x38,    /* Dynamic Flag */
    kHIDUsage_AD_CursorEnable    = 0x39,    /* Dynamic Flag */
    kHIDUsage_AD_CursorBlink    = 0x3A,    /* Dynamic Flag */
    kHIDUsage_AD_FontReport    = 0x3B,    /* Logical Collection */
    kHIDUsage_AD_FontData    = 0x3C,    /* Buffered Byte */
    kHIDUsage_AD_CharacterWidth    = 0x3D,    /* Static Value */
    kHIDUsage_AD_CharacterHeight    = 0x3E,    /* Static Value */
    kHIDUsage_AD_CharacterSpacingHorizontal    = 0x3F,    /* Static Value */
    kHIDUsage_AD_CharacterSpacingVertical    = 0x40,    /* Static Value */
    kHIDUsage_AD_UnicodeCharacterSet    = 0x41,    /* Static Flag */
    /* 0x42 - 0xFFFF Reserved */
    kHIDUsage_AD_Reserved = 0xFFFF
};

/* Sensor Page (0x14) */
/* The Sensor page is intended for use by devices that capture biometric, electrical, environmental, light, location, mechanical, motion, orientation, scanner, etc events. */
enum
{
    kHIDUsage_Snsr_Undefined                            = 0x00,
    kHIDUsage_Snsr_Sensor                               = 0x01,     /* Application/Physical Collection */
    /* 0x02 - 0x0F Reserved */
    kHIDUsage_Snsr_Biometric                            = 0x10,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanPresence              = 0x11,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanProximity             = 0x12,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanTouch                 = 0x13,     /* Application/Physical Collection */
    /* 0x14 - 0x1F Reserved */
    kHIDUsage_Snsr_Electrical                           = 0x20,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Capacitance               = 0x21,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Current                   = 0x22,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Power                     = 0x23,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Inductance                = 0x24,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Resistance                = 0x25,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Voltage                   = 0x26,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Potentiometer             = 0x27,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Frequency                 = 0x28,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Period                    = 0x29,     /* Application/Physical Collection */
    /* 0x2A - 0x2F Reserved */
    kHIDUsage_Snsr_Environmental                        = 0x30,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_AtmosphericPressure    = 0x31,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_Humidity               = 0x32,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_Temperature            = 0x33,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_WindDirection          = 0x34,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_WindSpeed              = 0x35,     /* Application/Physical Collection */
    /* 0x36 - 0x3F Reserved */
    kHIDUsage_Snsr_Light                                = 0x40,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Light_AmbientLight                   = 0x41,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Light_ConsumerInfrared               = 0x42,     /* Application/Physical Collection */
    /* 0x43 - 0x4F Reserved */
    kHIDUsage_Snsr_Location                             = 0x50,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Broadcast                   = 0x51,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_DeadReckoning               = 0x52,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_GPS                         = 0x53,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Lookup                      = 0x54,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Other                       = 0x55,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Static                      = 0x56,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Triangulation               = 0x57,     /* Application/Physical Collection */
    /* 0x58 - 0x5F Reserved */
    kHIDUsage_Snsr_Mechanical                           = 0x60,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_BooleanSwitch             = 0x61,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_BooleanSwitchArray        = 0x62,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_MultivalueSwitch          = 0x63,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Force                     = 0x64,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Pressure                  = 0x65,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Strain                    = 0x66,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Weight                    = 0x67,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_HapticVibrator            = 0x68,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_HallEffectSwitch          = 0x69,     /* Application/Physical Collection */
    /* 0x6A - 0x6F Reserved */
    kHIDUsage_Snsr_Motion                               = 0x70,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer1D               = 0x71,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer2D               = 0x72,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer3D               = 0x73,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer1D                   = 0x74,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer2D                   = 0x75,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer3D                   = 0x76,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_MotionDetector                = 0x77,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Speedometer                   = 0x78,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer                 = 0x79,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer                     = 0x7A,     /* Application/Physical Collection */
    /* 0x7B - 0x7F Reserved */
    kHIDUsage_Snsr_Orientation                          = 0x80,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass1D                = 0x81,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass2D                = 0x82,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass3D                = 0x83,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer1D           = 0x84,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer2D           = 0x85,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer3D           = 0x86,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance1D               = 0x87,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance2D               = 0x88,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance3D               = 0x89,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_DeviceOrientation        = 0x8A,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_CompassD                 = 0x8B,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_InclinometerD            = 0x8C,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_DistanceD                = 0x8D,     /* Application/Physical Collection */
    /* 0x8E - 0x8F Reserved */
    kHIDUsage_Snsr_Scanner                              = 0x90,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_Barcode                      = 0x91,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_RFID                         = 0x92,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_NFC                          = 0x93,     /* Application/Physical Collection */
    /* 0x94 - 0x9F Reserved */
    kHIDUsage_Snsr_Time                                 = 0xA0,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Time_AlarmTimer                      = 0xA1,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Time_RealTimeClock                   = 0xA2,     /* Application/Physical Collection */
    /* 0xA3 - 0xDF Reserved */
    kHIDUsage_Snsr_Other                                = 0xE0,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_Custom                         = 0xE1,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_Generic                        = 0xE2,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_GenericEnumerator              = 0xE3,     /* Application/Physical Collection */
    /* 0xE4 - 0xEF Reserved */
    /* 0xF0 - 0xFF Vendor Reserved */
    
    /* Common Sensor Type Data Fields */

    /* Usage Switches used in conjunction with other Data Usages. The value of the modifier is OR-ed in to the upper nibble of the 16bit Data Usage. */
    kHIDUsage_Snsr_Modifier_None                                = 0x0,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityAbsolute           = 0x1,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Max                                 = 0x2,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Min                                 = 0x3,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Accuracy                            = 0x4,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Resolution                          = 0x5,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ThresholdHigh                       = 0x6,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ThresholdLow                        = 0x7,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_CalibrationOffset                   = 0x8,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_CalibrationMultiplier               = 0x9,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ReportInterval                      = 0xA,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_FrequencyMax                        = 0xB,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_PeriodMax                           = 0xC,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRange       = 0xD,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRelative    = 0xE,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_VendorDefined                       = 0xF,      /* Data Field Usage Switch */

    /* Event Usages */
    kHIDUsage_Snsr_Event                                        = 0x0200,
    kHIDUsage_Snsr_Event_SensorState                            = 0x0201,
    kHIDUsage_Snsr_Event_SensorEvent                            = 0x0202,
    /* 0x0203 - 0x02FF Event Reserved */
    
    kHIDUsage_Snsr_Event_SensorState_Undefined                  = 0x0800,
    kHIDUsage_Snsr_Event_SensorState_Ready                      = 0x0801,
    kHIDUsage_Snsr_Event_SensorState_NotAvailable               = 0x0802,
    kHIDUsage_Snsr_Event_SensorState_NoData                     = 0x0803,
    kHIDUsage_Snsr_Event_SensorState_Initializing               = 0x0804,
    kHIDUsage_Snsr_Event_SensorState_AccessDenied               = 0x0805,
    kHIDUsage_Snsr_Event_SensorState_Error                      = 0x0806,
    /* 0x0807 - 0x080F Reserved */
    
    kHIDUsage_Snsr_Event_SensorEvent_Unknown                    = 0x0810,
    kHIDUsage_Snsr_Event_SensorEvent_StateChanged               = 0x0811,
    kHIDUsage_Snsr_Event_SensorEvent_PropertyChanged            = 0x0812,
    kHIDUsage_Snsr_Event_SensorEvent_DataUpdated                = 0x0813,
    kHIDUsage_Snsr_Event_SensorEvent_PollResponse               = 0x0814,
    kHIDUsage_Snsr_Event_SensorEvent_ChangeSensitivity          = 0x0815,
    kHIDUsage_Snsr_Event_SensorEvent_RangeMaxReached            = 0x0816,
    kHIDUsage_Snsr_Event_SensorEvent_RangeMinReached            = 0x0817,
    kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossUp       = 0x0818,
    kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossDown     = 0x0819,
    kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossUp        = 0x081A,
    kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossDown      = 0x081B,
    kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossUp       = 0x081C,
    kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossDown     = 0x081D,
    kHIDUsage_Snsr_Event_SensorEvent_PeriodExceeded             = 0x081E,
    kHIDUsage_Snsr_Event_SensorEvent_FrequencyExceeded          = 0x081F,
    kHIDUsage_Snsr_Event_SensorEvent_ComplexTrigger             = 0x0820,
    /* 0x0821 - 0x082F Reserved */

    /* Property Usages */
    kHIDUsage_Snsr_Property                                     = 0x0300,
    kHIDUsage_Snsr_Property_FriendlyName                        = 0x0301,
    kHIDUsage_Snsr_Property_PersistentUniqueID                  = 0x0302,
    kHIDUsage_Snsr_Property_SensorStatus                        = 0x0303,
    kHIDUsage_Snsr_Property_MinimumReportInterval               = 0x0304,
    kHIDUsage_Snsr_Property_Manufacturer                        = 0x0305,
    kHIDUsage_Snsr_Property_Model                               = 0x0306,
    kHIDUsage_Snsr_Property_SerialNumber                        = 0x0307,
    kHIDUsage_Snsr_Property_Description                         = 0x0308,
    kHIDUsage_Snsr_Property_ConnectionType                      = 0x0309,
    kHIDUsage_Snsr_Property_DevicePath                          = 0x030A,
    kHIDUsage_Snsr_Property_HardwareRevision                    = 0x030B,
    kHIDUsage_Snsr_Property_FirmwareVersion                     = 0x030C,
    kHIDUsage_Snsr_Property_ReleaseData                         = 0x030D,
    kHIDUsage_Snsr_Property_ReportInterval                      = 0x030E,
    kHIDUsage_Snsr_Property_ChangeSensitivityAbsolute           = 0x030F,
    kHIDUsage_Snsr_Property_ChangeSensitivityPercentRange       = 0x0310,
    kHIDUsage_Snsr_Property_ChangeSensitivityPercentRelative    = 0x0311,
    kHIDUsage_Snsr_Property_Accuracy                            = 0x0312,
    kHIDUsage_Snsr_Property_Resolution                          = 0x0313,
    kHIDUsage_Snsr_Property_Maximum                             = 0x0314,
    kHIDUsage_Snsr_Property_Minimum                             = 0x0315,
    kHIDUsage_Snsr_Property_ReportingState                      = 0x0316,
    kHIDUsage_Snsr_Property_SamplingRate                        = 0x0317,
    kHIDUsage_Snsr_Property_ResponseCurve                       = 0x0318,
    kHIDUsage_Snsr_Property_PowerState                          = 0x0319,
    /* 0x031A - 0x03FF Reserved */
    
    kHIDUsage_Snsr_Property_ConnectionType_Integrated           = 0x0830,
    kHIDUsage_Snsr_Property_ConnectionType_Attached             = 0x0831,
    kHIDUsage_Snsr_Property_ConnectionType_External             = 0x0832,
    /* 0x0833 - 0x083F Reserved */
    kHIDUsage_Snsr_Property_ReportingState_NoEvents             = 0x0840,
    kHIDUsage_Snsr_Property_ReportingState_AllEvents            = 0x0841,
    kHIDUsage_Snsr_Property_ReportingState_ThresholdEvents      = 0x0842,
    kHIDUsage_Snsr_Property_ReportingState_WakeNoEvents         = 0x0843,
    kHIDUsage_Snsr_Property_ReportingState_WakeAllEvents        = 0x0844,
    kHIDUsage_Snsr_Property_ReportingState_WakeThresholdEvents  = 0x0845,
    /* 0x0846 - 0x084F Reserved */
    kHIDUsage_Snsr_Property_PowerState_Undefined                = 0x0850,
    kHIDUsage_Snsr_Property_PowerState_D0_FullPower             = 0x0851,
    kHIDUsage_Snsr_Property_PowerState_D1_LowPower              = 0x0852,
    kHIDUsage_Snsr_Property_PowerState_D2_Standby               = 0x0853,
    kHIDUsage_Snsr_Property_PowerState_D3_Sleep                 = 0x0854,
    kHIDUsage_Snsr_Property_PowerState_D4_PowerOff              = 0x0855,
    /* 0x0855 - 0x085F Reserved */
    
    /* Specific Sensor Type Data Fields */
    /*** TODO ***/
};

/* Power Device Page (0x84) */
/* This section provides detailed descriptions of the usages employed by Power Devices. */
enum
{
    
    kHIDUsage_PD_Undefined = 0x00,                /* Power Device Undefined Usage */
    kHIDUsage_PD_iName = 0x01,                    /* CL- Power Device Name Index */
    kHIDUsage_PD_PresentStatus = 0x02,            /* CL- Power Device Present Status */
    kHIDUsage_PD_ChangedStatus = 0x03,            /* CA- Power Device Changed Status */
    kHIDUsage_PD_UPS = 0x04,                    /* CA- Uninterruptible Power Supply */
    kHIDUsage_PD_PowerSupply = 0x05,            /* CA- Power Supply */
    /* Reserved 0x06 - 0x0F */
    kHIDUsage_PD_BatterySystem = 0x10,            /* CP- Battery System power module */
    kHIDUsage_PD_BatterySystemID = 0x11,        /* SV IF- Battery System ID */
    kHIDUsage_PD_Battery = 0x12,                /* CP- Battery */
    kHIDUsage_PD_BatteryID = 0x13,                /* SV IF- Battery ID */
    kHIDUsage_PD_Charger = 0x14,                /* CP- Charger */
    kHIDUsage_PD_ChargerID = 0x15,                /* SV IF- Charger ID */
    kHIDUsage_PD_PowerConverter = 0x16,            /* CP- Power Converter power module */
    kHIDUsage_PD_PowerConverterID = 0x17,        /* SV IF- Power Converter ID */
    kHIDUsage_PD_OutletSystem = 0x18,            /* CP- Outlet System power module */
    kHIDUsage_PD_OutletSystemID = 0x19,            /* SV IF-Outlet System ID */
    kHIDUsage_PD_Input = 0x1A,                    /* CP- Power Device Input */
    kHIDUsage_PD_InputID = 0x1B,                /* SV IF- Power Device Input ID */
    kHIDUsage_PD_Output = 0x1C,                    /* CP- Power Device Output */
    kHIDUsage_PD_OutputID = 0x1D,                /* SV IF- Power Device Output ID */
    kHIDUsage_PD_Flow = 0x1E,                    /* CP- Power Device Flow */
    kHIDUsage_PD_FlowID = 0x1F,                    /* Item IF- Power Device Flow ID */
    kHIDUsage_PD_Outlet = 0x20,                    /* CP- Power Device Outlet */
    kHIDUsage_PD_OutletID = 0x21,                /* SV IF- Power Device Outlet ID */
    kHIDUsage_PD_Gang = 0x22,                    /* CL/CP- Power Device Gang */
    kHIDUsage_PD_GangID = 0x23,                    /* SV IF- Power Device Gang ID */
    kHIDUsage_PD_PowerSummary = 0x24,            /* CL/CP- Power Device Power Summary */
    kHIDUsage_PD_PowerSummaryID = 0x25,            /* SV IF- Power Device Power Summary ID */
    /* Reserved 0x26 - 0x2F */
    kHIDUsage_PD_Voltage = 0x30,                /* DV IF- Power Device Voltage */
    kHIDUsage_PD_Current = 0x31,                /* DV IF- Power Device Current */
    kHIDUsage_PD_Frequency = 0x32,                /* DV IF- Power Device Frequency */
    kHIDUsage_PD_ApparentPower = 0x33,            /* DV IF- Power Device Apparent Power */
    kHIDUsage_PD_ActivePower = 0x34,            /* DV IF- Power Device RMS Power */
    kHIDUsage_PD_PercentLoad = 0x35,            /* DV IF- Power Device Percent Load */
    kHIDUsage_PD_Temperature = 0x36,            /* DV IF- Power Device Temperature */
    kHIDUsage_PD_Humidity = 0x37,                /* DV IF- Power Device Humidity */
    kHIDUsage_PD_BadCount = 0x38,                /* DV IF- Power Device Bad Condition Count */
    /* Reserved 0x39 - 0x3F */
    kHIDUsage_PD_ConfigVoltage = 0x40,            /* SV/DV F- Power Device Nominal Voltage */
    kHIDUsage_PD_ConfigCurrent = 0x41,            /* SV/DV F- Power Device Nominal Current */
    kHIDUsage_PD_ConfigFrequency = 0x42,        /* SV/DV F- Power Device Nominal Frequency */
    kHIDUsage_PD_ConfigApparentPower = 0x43,    /* SV/DV F- Power Device Nominal Apparent Power */
    kHIDUsage_PD_ConfigActivePower = 0x44,        /* SV/DV F- Power Device Nominal RMS Power */
    kHIDUsage_PD_ConfigPercentLoad = 0x45,        /* SV/DV F- Power Device Nominal Percent Load */
    kHIDUsage_PD_ConfigTemperature = 0x46,        /* SV/DV F- Power Device Nominal Temperature */
    kHIDUsage_PD_ConfigHumidity = 0x47,            /* SV/DV F- Power Device Nominal Humidity */
    /* Reserved 0x48 - 0x4F */
    kHIDUsage_PD_SwitchOnControl = 0x50,        /* DV F- Power Device Switch On Control */
    kHIDUsage_PD_SwitchOffControl = 0x51,        /* DV F- Power Device Switch Off Control */
    kHIDUsage_PD_ToggleControl = 0x52,            /* DV F- Power Device Toogle Sequence Control */
    kHIDUsage_PD_LowVoltageTransfer = 0x53,        /* DV F- Power Device Min Transfer Voltage */
    kHIDUsage_PD_HighVoltageTransfer = 0x54,    /* DV F- Power Device Max Transfer Voltage */
    kHIDUsage_PD_DelayBeforeReboot = 0x55,        /* DV F- Power Device Delay Before Reboot */
    kHIDUsage_PD_DelayBeforeStartup = 0x56,        /* DV F- Power Device Delay Before Startup */
    kHIDUsage_PD_DelayBeforeShutdown = 0x57,    /* DV F- Power Device Delay Before Shutdown */
    kHIDUsage_PD_Test = 0x58,                    /* DV F- Power Device Test Request/Result */
    kHIDUsage_PD_ModuleReset = 0x59,            /* DV F- Power Device Reset Request/Result */
    kHIDUsage_PD_AudibleAlarmControl = 0x5A,    /* DV F- Power Device Audible Alarm Control */
    /* Reserved 0x5B - 0x5F */
    kHIDUsage_PD_Present = 0x60,                /* DV IOF- Power Device Present */
    kHIDUsage_PD_Good = 0x61,                    /* DV IOF- Power Device Good */
    kHIDUsage_PD_InternalFailure = 0x62,        /* DV IOF- Power Device Internal Failure */
    kHIDUsage_PD_VoltageOutOfRange = 0x63,        /* DV IOF- Power Device Voltage Out Of Range */
    kHIDUsage_PD_FrequencyOutOfRange = 0x64,    /* DV IOF- Power Device Frequency Out Of Range */
    kHIDUsage_PD_Overload = 0x65,                /* DV IOF- Power Device Overload */
    kHIDUsage_PD_OverCharged = 0x66,            /* DV IOF- Power Device Over Charged */
    kHIDUsage_PD_OverTemperature = 0x67,        /* DV IOF- Power Device Over Temperature */
    kHIDUsage_PD_ShutdownRequested = 0x68,        /* DV IOF- Power Device Shutdown Requested */
    kHIDUsage_PD_ShutdownImminent = 0x69,        /* DV IOF- Power Device Shutdown Imminent */
    /* Reserved 0x6A */
    kHIDUsage_PD_SwitchOnOff = 0x6B,            /* DV IOF- Power Device On/Off Switch Status */
    kHIDUsage_PD_Switchable = 0x6C,                /* DV IOF- Power Device Switchable */
    kHIDUsage_PD_Used = 0x6D,                    /* DV IOF- Power Device Used */
    kHIDUsage_PD_Boost = 0x6E,                    /* DV IOF- Power Device Boosted */
    kHIDUsage_PD_Buck = 0x6F,                    /* DV IOF- Power Device Bucked */
    kHIDUsage_PD_Initialized = 0x70,            /* DV IOF- Power Device Initialized */
    kHIDUsage_PD_Tested = 0x71,                    /* DV IOF- Power Device Tested */
    kHIDUsage_PD_AwaitingPower = 0x72,            /* DV IOF- Power Device Awaiting Power */
    kHIDUsage_PD_CommunicationLost = 0x73,        /* DV IOF- Power Device Communication Lost */
    /* Reserved 0x74 - 0xFC */
    kHIDUsage_PD_iManufacturer = 0xFD,            /* SV F- Power Device Manufacturer String Index */
    kHIDUsage_PD_iProduct = 0xFE,                /* SV F- Power Device Product String Index */
    kHIDUsage_PD_iserialNumber = 0xFF            /* SV F- Power Device Serial Number String Index */
};

/* Battery System Page (x85) */
/* This section provides detailed descriptions of the usages employed by Battery Systems. */    
enum
{
    kHIDUsage_BS_Undefined = 0x00,                /* Battery System Undefined */
    kHIDUsage_BS_SMBBatteryMode = 0x01,            /* CL - SMB Mode */
    kHIDUsage_BS_SMBBatteryStatus = 0x02,        /* CL - SMB Status */
    kHIDUsage_BS_SMBAlarmWarning = 0x03,        /* CL - SMB Alarm Warning */
    kHIDUsage_BS_SMBChargerMode = 0x04,            /* CL - SMB Charger Mode */
    kHIDUsage_BS_SMBChargerStatus = 0x05,        /* CL - SMB Charger Status */
    kHIDUsage_BS_SMBChargerSpecInfo = 0x06,        /* CL - SMB Charger Extended Status */
    kHIDUsage_BS_SMBSelectorState = 0x07,        /* CL - SMB Selector State */
    kHIDUsage_BS_SMBSelectorPresets = 0x08,        /* CL - SMB Selector Presets */
    kHIDUsage_BS_SMBSelectorInfo = 0x09,        /* CL - SMB Selector Info */
    /* Reserved 0x0A - 0x0F */
    kHIDUsage_BS_OptionalMfgFunction1 = 0x10,    /* DV F - Battery System Optional SMB Mfg Function 1 */
    kHIDUsage_BS_OptionalMfgFunction2 = 0x11,    /* DV F - Battery System Optional SMB Mfg Function 2 */
    kHIDUsage_BS_OptionalMfgFunction3 = 0x12,    /* DV F - Battery System Optional SMB Mfg Function 3 */
    kHIDUsage_BS_OptionalMfgFunction4 = 0x13,    /* DV F - Battery System Optional SMB Mfg Function 4 */
    kHIDUsage_BS_OptionalMfgFunction5 = 0x14,    /* DV F - Battery System Optional SMB Mfg Function 5 */
    kHIDUsage_BS_ConnectionToSMBus = 0x15,        /* DF F - Battery System Connection To System Management Bus */
    kHIDUsage_BS_OutputConnection = 0x16,        /* DF F - Battery System Output Connection Status */
    kHIDUsage_BS_ChargerConnection = 0x17,        /* DF F - Battery System Charger Connection */
    kHIDUsage_BS_BatteryInsertion = 0x18,        /* DF F - Battery System Battery Insertion */
    kHIDUsage_BS_Usenext = 0x19,                /* DF F - Battery System Use Next */
    kHIDUsage_BS_OKToUse = 0x1A,                /* DF F - Battery System OK To Use */
    kHIDUsage_BS_BatterySupported = 0x1B,        /* DF F - Battery System Battery Supported */
    kHIDUsage_BS_SelectorRevision = 0x1C,        /* DF F - Battery System Selector Revision */
    kHIDUsage_BS_ChargingIndicator = 0x1D,        /* DF F - Battery System Charging Indicator */
    /* Reserved 0x1E - 0x27 */
    kHIDUsage_BS_ManufacturerAccess = 0x28,        /* DV F - Battery System Manufacturer Access */
    kHIDUsage_BS_RemainingCapacityLimit = 0x29,    /* DV F - Battery System Remaining Capacity Limit */
    kHIDUsage_BS_RemainingTimeLimit = 0x2A,        /* DV F - Battery System Remaining Time Limit */
    kHIDUsage_BS_AtRate = 0x2B,                    /* DV F - Battery System At Rate... */
    kHIDUsage_BS_CapacityMode = 0x2C,            /* DV F - Battery System Capacity Mode */
    kHIDUsage_BS_BroadcastToCharger = 0x2D,        /* DV F - Battery System Broadcast To Charger */
    kHIDUsage_BS_PrimaryBattery = 0x2E,            /* DV F - Battery System Primary Battery */
    kHIDUsage_BS_ChargeController = 0x2F,        /* DV F - Battery System Charge Controller */
    /* Reserved 0x30 - 0x3F */
    kHIDUsage_BS_TerminateCharge = 0x40,        /* DF IOF - Battery System Terminate Charge */
    kHIDUsage_BS_TerminateDischarge = 0x41,        /* DF IOF - Battery System Terminate Discharge */
    kHIDUsage_BS_BelowRemainingCapacityLimit = 0x42, /* DF IOF - Battery System Below Remaining Capacity Limit */
    kHIDUsage_BS_RemainingTimeLimitExpired = 0x43, /* DF IOF - Battery System Remaining Time Limit Expired */
    kHIDUsage_BS_Charging = 0x44,                /* DF IOF - Battery System Charging */
    kHIDUsage_BS_Discharging = 0x45,            /* DV IOF - Battery System Discharging */
    kHIDUsage_BS_FullyCharged = 0x46,            /* DF IOF - Battery System Fully Charged */
    kHIDUsage_BS_FullyDischarged = 0x47,        /* DV IOF - Battery System Fully Discharged */
    kHIDUsage_BS_ConditioningFlag = 0x48,        /* DV IOF - Battery System Conditioning Flag */
    kHIDUsage_BS_AtRateOK = 0x49,                /* DV IOF - Battery System At Rate OK */
    kHIDUsage_BS_SMBErrorCode = 0x4A,            /* DF IOF - Battery System SMB Error Code */
    kHIDUsage_BS_NeedReplacement = 0x4B,        /* DF IOF - Battery System Need Replacement */
    /* Reserved 0x4C - 0x5F */
    kHIDUsage_BS_AtRateTimeToFull = 0x60,        /* DV IF - Battery System At Rate Time To Full */
    kHIDUsage_BS_AtRateTimeToEmpty = 0x61,        /* DV IF - Battery System At Rate Time To Empty */
    kHIDUsage_BS_AverageCurrent = 0x62,            /* DV IF - Battery System Average Current */
    kHIDUsage_BS_Maxerror = 0x63,                /* DV IF - Battery System Max Error */
    kHIDUsage_BS_RelativeStateOfCharge = 0x64,    /* DV IF - Battery System Relative State Of Charge */
    kHIDUsage_BS_AbsoluteStateOfCharge = 0x65,    /* DV IF - Battery System Absolute State Of Charge */
    kHIDUsage_BS_RemainingCapacity = 0x66,        /* DV IF - Battery System Remaining Capacity */
    kHIDUsage_BS_FullChargeCapacity = 0x67,        /* DV IF - Battery System Full Charge Capacity */
    kHIDUsage_BS_RunTimeToEmpty = 0x68,            /* DV IF - Battery System Run Time To Empty */
    kHIDUsage_BS_AverageTimeToEmpty = 0x69,        /* DV IF - Battery System Average Time To Empty */
    kHIDUsage_BS_AverageTimeToFull = 0x6A,        /* DV IF - Battery System Average Time To Full */
    kHIDUsage_BS_CycleCount = 0x6B,                /* DV IF - Battery System Cycle Count */
    /* Reserved 0x6C - 0x7F */
    kHIDUsage_BS_BattPackModelLevel = 0x80,        /* SV F - Battery System Batt Pack Model Level */
    kHIDUsage_BS_InternalChargeController = 0x81, /* SF F - Battery System Internal Charge Controller */
    kHIDUsage_BS_PrimaryBatterySupport = 0x82,    /* SF F - Battery System Primary Battery Support */
    kHIDUsage_BS_DesignCapacity = 0x83,            /* SV F - Battery System Design Capacity */
    kHIDUsage_BS_SpecificationInfo = 0x84,        /* SV F - Battery System Specification Info */
    kHIDUsage_BS_ManufacturerDate = 0x85,        /* SV F - Battery System Manufacturer Date */
    kHIDUsage_BS_SerialNumber = 0x86,            /* SV F - Battery System Serial Number */
    kHIDUsage_BS_iManufacturerName = 0x87,        /* SV F - Battery System Manufacturer Name Index */
    kHIDUsage_BS_iDevicename = 0x88,            /* SV F - Battery System Device Name Index */
    kHIDUsage_BS_iDeviceChemistry = 0x89,        /* SV F - Battery System Device Chemistry Index */
    kHIDUsage_BS_ManufacturerData = 0x8A,        /* SV F - Battery System Manufacturer Data */
    kHIDUsage_BS_Rechargable = 0x8B,            /* SV F - Battery System Rechargable */
    kHIDUsage_BS_WarningCapacityLimit = 0x8C,    /* SV F - Battery System Warning Capacity Limit */
    kHIDUsage_BS_CapacityGranularity1 = 0x8D,    /* SV F - Battery System Capacity Granularity 1 */
    kHIDUsage_BS_CapacityGranularity2 = 0x8E,    /* SV F - Battery System Capacity Granularity 2 */
    kHIDUsage_BS_iOEMInformation = 0x8F,        /* SV F - Battery System OEM Information Index */
    /* Reserved 0x90 - 0xBF */
    kHIDUsage_BS_InhibitCharge = 0xC0,            /* DF IOF - Battery System Inhibit Charge */
    kHIDUsage_BS_EnablePolling = 0xC1,            /* DF IOF - Battery System Enable Polling */
    kHIDUsage_BS_ResetToZero = 0xC2,            /* DF IOF - Battery System Reset To Zero */
    /* Reserved 0xC3 - 0xCF */
    kHIDUsage_BS_ACPresent = 0xD0,                /* DF IOF - Battery System AC Present */
    kHIDUsage_BS_BatteryPresent = 0xD1,            /* DF IOF - Battery System Battery Present */
    kHIDUsage_BS_PowerFail = 0xD2,                /* DF IOF - Battery System Power Fail */
    kHIDUsage_BS_AlarmInhibited = 0xD3,            /* DF IOF - Battery System Alarm Inhibited */
    kHIDUsage_BS_ThermistorUnderRange = 0xD4,    /* DF IOF - Battery System Thermistor Under Range */
    kHIDUsage_BS_ThermistorHot = 0xD5,            /* DF IOF - Battery System Thermistor Hot */
    kHIDUsage_BS_ThermistorCold = 0xD6,            /* DF IOF - Battery System Thermistor Cold */
    kHIDUsage_BS_ThermistorOverRange = 0xD7,    /* DF IOF - Battery System Thermistor Over Range */
    kHIDUsage_BS_VoltageOutOfRange = 0xD8,        /* DF IOF - Battery System Voltage Out Of Range */
    kHIDUsage_BS_CurrentOutOfRange = 0xD9,        /* DF IOF - Battery System Current Out Of Range */
    kHIDUsage_BS_CurrentNotRegulated = 0xDA,    /* DF IOF - Battery System Current Not Regulated */
    kHIDUsage_BS_VoltageNotRegulated = 0xDB,    /* DF IOF - Battery System Voltage Not Regulated */
    kHIDUsage_BS_MasterMode = 0xDC,                /* DF IOF - Battery System Master Mode */
    /* Reserved 0xDD - 0xEF */
    kHIDUsage_BS_ChargerSelectorSupport = 0xF0,    /* SF F- Battery System Charger Support Selector */
    kHIDUsage_BS_ChargerSpec = 0xF1,            /* SF F- Battery System Charger Specification */
    kHIDUsage_BS_Level2 = 0xF2,                    /* SF F- Battery System Charger Level 2 */
    kHIDUsage_BS_Level3 = 0xF3                    /* SF F- Battery System Charger Level 3 */
    /* Reserved 0xF2 - 0xFF */
};

/* Bar Code Scanner Page (0x8C) */
/* This section provides detailed descriptions of the usages employed by Bar Code Scanner Devices. */
enum
{
    kHIDUsage_BCS_Undefined = 0x00,                     /* Bar Code Scanner Undefined Usage */
    kHIDUsage_BCS_BadgeReader = 0x01,                   /* CA - Bar Code Badge Reader */
    kHIDUsage_BCS_BarCodeScanner = 0x02,                /* CA -Bar Code Scanner */
    kHIDUsage_BCS_DumbBarCodeScanner = 0x03,            /* CA -Dumb Bar Code Scanner  Usage */
    kHIDUsage_BCS_CordlessScannerBase = 0x04,           /* CA -Cordless Base Usage */
    kHIDUsage_BCS_BarCodeScannerCradle = 0x05,          /* CA -Bar Code Scanner Cradle Usage */
    /* Reserved 0x06 - 0x0F */
    kHIDUsage_BCS_AttributeReport = 0x10,               /* CL - Attribute Report */
    kHIDUsage_BCS_SettingsReport = 0x11,                /* CL - Settings Report */
    kHIDUsage_BCS_ScannedDataReport = 0x12,             /* CL - Scanned Data Report */
    kHIDUsage_BCS_RawScannedDataReport = 0x13,          /* CL - Raw Scanned Data Report */
    kHIDUsage_BCS_TriggerReport = 0x14,                 /* CL - Trigger Report */
    kHIDUsage_BCS_StatusReport = 0x15,                  /* CL - Status Report */
    kHIDUsage_BCS_UPC_EANControlReport = 0x16,          /* CL - UPC/EAN Control Report */
    kHIDUsage_BCS_EAN2_3LabelControlReport = 0x17,      /* CL - EAN 2/3 Label Control Report */
    kHIDUsage_BCS_Code39ControlReport = 0x18,           /* CL - Code 39 Control Report */
    kHIDUsage_BCS_Interleaved2of5ControlReport = 0x19,  /* CL - Interleaved 2 of 5 Control Report */
    kHIDUsage_BCS_Standard2of5ControlReport = 0x1A,     /* CL - Standard 2 of 5 Control Report */
    kHIDUsage_BCS_MSIPlesseyControlReport = 0x1B,       /* CL - MSI Plessey Control Report */
    kHIDUsage_BCS_CodabarControlReport = 0x1C,          /* CL - Codabar Control Report */
    kHIDUsage_BCS_Code128ControlReport = 0x1D,          /* CL - Code 128 Control Report */
    kHIDUsage_BCS_Misc1DControlReport = 0x1E,           /* CL - Misc 1D Control Report */
    kHIDUsage_BCS_2DControlReport = 0x1F,               /* CL - 2D Control Report */
    /* Reserved 0x20 - 0x2F */
    kHIDUsage_BCS_Aiming_PointerMide = 0x30,            /* SF - Aiming Pointer Mode */
    kHIDUsage_BCS_BarCodePresentSensor = 0x31,          /* SF - Bar Code Present Sensor */
    kHIDUsage_BCS_Class1ALaser = 0x32,                  /* SF - Class 1A Laser */
    kHIDUsage_BCS_Class2Laser = 0x33,                   /* SF - Class 2 Laser */
    kHIDUsage_BCS_HeaterPresent = 0x34,                 /* SF - Heater Present */
    kHIDUsage_BCS_ContactScanner = 0x35,                /* SF - Contact Scanner */
    kHIDUsage_BCS_ElectronicArticleSurveillanceNotification = 0x36, /* SF - Electronic Article Surveillance Notification */
    kHIDUsage_BCS_ConstantElectronicArticleSurveillance = 0x37, /* SF - Constant Electronic Article Surveillance */
    kHIDUsage_BCS_ErrorIndication = 0x38,               /* SF - Error Indication */
    kHIDUsage_BCS_FixedBeeper = 0x39,                   /* SF - Fixed Beeper */
    kHIDUsage_BCS_GoodDecodeIndication = 0x3A,          /* SF - Good Decode Indication */
    kHIDUsage_BCS_HandsFreeScanning = 0x3B,             /* SF - Hands Free Scanning */
    kHIDUsage_BCS_IntrinsicallySafe = 0x3C,             /* SF - Intrinsically Safe */
    kHIDUsage_BCS_KlasseEinsLaser = 0x3D,               /* SF - Klasse Eins Laser */
    kHIDUsage_BCS_LongRangeScanner = 0x3E,              /* SF - Long Range Scanner */
    kHIDUsage_BCS_MirrorSpeedControl = 0x3F,            /* SF - Mirror Speed Control */
    kHIDUsage_BCS_NotOnFileIndication = 0x40,           /* SF - Not On File Indication */
    kHIDUsage_BCS_ProgrammableBeeper = 0x41,            /* SF - Programmable Beeper */
    kHIDUsage_BCS_Triggerless = 0x42,                   /* SF - Triggerless */
    kHIDUsage_BCS_Wand = 0x43,                          /* SF - Wand */
    kHIDUsage_BCS_WaterResistant = 0x44,                /* SF - Water Resistant */
    kHIDUsage_BCS_MultiRangeScanner = 0x45,             /* SF - Multi-Range Scanner */
    kHIDUsage_BCS_ProximitySensor = 0x46,               /* SF - Proximity Sensor */
    /* Reserved 0x47 - 0x4C */
    kHIDUsage_BCS_FragmentDecoding = 0x4D,              /* DF - Fragment Decoding */
    kHIDUsage_BCS_ScannerReadConfidence = 0x4E,         /* DV - Scanner Read Confidence */
    kHIDUsage_BCS_DataPrefix = 0x4F,                    /* NAry - Data Prefix  */
    kHIDUsage_BCS_PrefixAIMI = 0x50,                    /* SEL - Prefix AIMI */
    kHIDUsage_BCS_PrefixNone = 0x51,                    /* SEL - Prefix None */
    kHIDUsage_BCS_PrefixProprietary = 0x52,             /* SEL - Prefix Proprietary */
    /* Reserved 0x53 - 0x54 */
    kHIDUsage_BCS_ActiveTime = 0x55,                    /* DV - Active Time */
    kHIDUsage_BCS_AimingLaserPattern = 0x56,            /* DF - Aiming Laser Pattern */
    kHIDUsage_BCS_BarCodePresent = 0x57,                /* OOC - Bar Code Present */
    kHIDUsage_BCS_BeeperState = 0x58,                   /* OOC - Beeper State */
    kHIDUsage_BCS_LaserOnTime = 0x59,                   /* DV - Laser On Time */
    kHIDUsage_BCS_LaserState = 0x5A,                    /* OOC - Laser State */
    kHIDUsage_BCS_LockoutTime = 0x5B,                   /* DV - Lockout Time */
    kHIDUsage_BCS_MotorState = 0x5C,                    /* OOC - Motor State */
    kHIDUsage_BCS_MotorTimeout = 0x5D,                  /* DV - Motor Timeout */
    kHIDUsage_BCS_PowerOnResetScanner = 0x5E,           /* DF - Power On Reset Scanner */
    kHIDUsage_BCS_PreventReadOfBarcodes = 0x5F,         /* DF - Prevent Read of Barcodes */
    kHIDUsage_BCS_InitiateBarcodeRead = 0x60,           /* DF - Initiate Barcode Read */
    kHIDUsage_BCS_TriggerState = 0x61,                  /* DF - Trigger State */
    kHIDUsage_BCS_TriggerMode = 0x62,                   /* NAry - Trigger Mode */
    kHIDUsage_BCS_TriggerModeBlinkingLaserOn = 0x63,    /* SEL - Trigger Mode Blinking Laser On */
    kHIDUsage_BCS_TriggerModeContinuousLaserOn = 0x64,  /* SEL - Trigger Mode Continuous Laser On */
    kHIDUsage_BCS_TriggerModeLaserOnWhilePulled = 0x65, /* SEL - Trigger Mode Laser on while Pulled */
    kHIDUsage_BCS_TriggerModeLaserStaysOnAfterTriggerRelease = 0x66, /* SEL - Trigger Mode Laser stays on after Trigger Release */
    /* Reserved 0x67 - 0x6C */
    kHIDUsage_BCS_CommitParametersToNVM = 0x6D,         /* DF - Commit Parameters to NVM */
    kHIDUsage_BCS_ParameterScanning = 0x6E,             /* DF - Parameter Scanning */
    kHIDUsage_BCS_ParametersChanged = 0x6F,             /* OOC - Parameters Changed */
    kHIDUsage_BCS_SetParameterDefaultValues = 0x70,     /* DF - Set parameter default values */
    /* Reserved 0x71 - 0x74 */
    kHIDUsage_BCS_ScannerInCradle = 0x75,               /* OOC - Scanner In Cradle */
    kHIDUsage_BCS_ScannerInRange = 0x76,                /* OOC - Scanner In Range */
    /* Reserved 0x77 - 0x79 */
    kHIDUsage_BCS_AimDuration = 0x7A,                   /* DV - Aim Duration */
    kHIDUsage_BCS_GoodReadLampDuration = 0x7B,          /* DV - Good Read Lamp Duration */
    kHIDUsage_BCS_GoodReadLampIntensity = 0x7C,         /* DV - Good Read Lamp Intensity */
    kHIDUsage_BCS_GoodReadLED = 0x7D,                   /* DF - Good Read LED */
    kHIDUsage_BCS_GoodReadToneFrequency = 0x7E,         /* DV - Good Read Tone Frequency*/
    kHIDUsage_BCS_GoodReadToneLength = 0x7F,            /* DV - Good Read Tone Length */
    kHIDUsage_BCS_GoodReadToneVolume = 0x80,            /* DV - Good Read Tone Volume */
    /* Reserved 0x81 */
    kHIDUsage_BCS_NoReadMessage = 0x82,                 /* DF - No Read Message */
    kHIDUsage_BCS_NotOnFileVolume = 0x83,               /* DV - Not on File Volume */
    kHIDUsage_BCS_PowerupBeep = 0x84,                   /* DF - Powerup Beep */
    kHIDUsage_BCS_SoundErrorBeep = 0x85,               /* DF - Sound Error Beep */
    kHIDUsage_BCS_SoundGoodReadBeep = 0x86,             /* DF - Sound Good Read Beep */
    kHIDUsage_BCS_SoundNotOnFileBeep = 0x87,            /* DF - Sound Not On File Beep */
    kHIDUsage_BCS_GoodReadWhenToWrite = 0x88,           /* NArry - Good Read When to Write */
    kHIDUsage_BCS_GRWTIAfterDecode = 0x89,              /* SEL - GRWTI After Decode */
    kHIDUsage_BCS_GRWTIBeep_LampAfterTransmit = 0x8A,   /* SEL - GRWTI Beep/Lamp after transmit */
    kHIDUsage_BCS_GRWTINoBeep_LampUseAtAll = 0x8B,      /* SEL - GRWTI No Beep/Lamp at all */
    /* Reserved 0x8C - 0x90 */
    kHIDUsage_BCS_BooklandEAN = 0x91,                   /* DF - Bookland EAN */
    kHIDUsage_BCS_ConvertEAN8To13Type = 0x92,           /* DF - Convert EAN 8 to 13 Type */
    kHIDUsage_BCS_ConvertUPCAToEAN_13 = 0x93,           /* DF - Convert UPC A to EAN-13 */
    kHIDUsage_BCS_ConvertUPC_EToA = 0x94,               /* DF - Convert UPC-E to A */
    kHIDUsage_BCS_EAN_13 = 0x95,                        /* DF - EAN-13 */
    kHIDUsage_BCS_EAN_8 = 0x96,                         /* DF - EAN_8 */
    kHIDUsage_BCS_EAN_99_128_Mandatory  = 0x97,         /* DF - EAN-99 128_Mandatory  */
    kHIDUsage_BCS_EAN_99_P5_128_Optional = 0x98,        /* DF - EAN-99 P5/128_Optional */
    /* Reserved 0x99 */
    kHIDUsage_BCS_UPC_EAN = 0x9A,                       /* DF - UPC/EAN */
    kHIDUsage_BCS_UPC_EANCouponCode = 0x9B,             /* DF - UPC/EAN Coupon Code */
    kHIDUsage_BCS_UPC_EANPeriodicals = 0x9C,            /* DV - UPC/EAN Periodicals */
    kHIDUsage_BCS_UPC_A = 0x9D,                         /* DF - UPC-A */
    kHIDUsage_BCS_UPC_AWith128Mandatory = 0x9E,         /* DF - UPC-A with 128 Mandatory */
    kHIDUsage_BCS_UPC_AWith128Optical = 0x9F,           /* DF - UPC-A with 128 Optical */
    kHIDUsage_BCS_UPC_AWithP5Optional = 0xA0,           /* DF - UPC-A with P5 Optional */
    kHIDUsage_BCS_UPC_E = 0xA1,                         /* DF - UPC-E */
    kHIDUsage_BCS_UPC_E1 = 0xA2,                        /* DF - UPC-E1 */
    /* Reserved 0xA3 - 0xA8 */
    kHIDUsage_BCS_Periodical = 0xA9,                    /* NArry - Periodical */
    kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus2 = 0xAA,/* SEL - Periodical Auto-Discriminate + 2 */
    kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus2 = 0xAB, /* SEL - Periodical Only Decode with + 2 */
    kHIDUsage_BCS_PeriodicalIgnorePlus2 = 0xAC,         /* SEL - Periodical Ignore + 2 */
    kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus5 = 0xAD,/* SEL - Periodical Auto-Discriminate + 5 */
    kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus5 = 0xAE, /* SEL - Periodical Only Decode with + 5 */
    kHIDUsage_BCS_PeriodicalIgnorePlus5 = 0xAF,         /* SEL - Periodical Ignore + 5 */
    kHIDUsage_BCS_Check = 0xB0,                         /* NArry - Check */
    kHIDUsage_BCS_CheckDisablePrice = 0xB1,             /* SEL - Check Disable Price */
    kHIDUsage_BCS_CheckEnable4DigitPrice = 0xB2,        /* SEL - Check Enable 4 digit Price */
    kHIDUsage_BCS_CheckEnable5DigitPrice = 0xB3,        /* SEL - Check Enable 5 digit Price */
    kHIDUsage_BCS_CheckEnableEuropean4DigitPrice = 0xB4,/* SEL - Check Enable European 4 digit Price */
    kHIDUsage_BCS_CheckEnableEuropean5DigitPrice = 0xB5,/* SEL - Check Enable European 5 digit Price */
    /* Reserved 0xB6 */
    kHIDUsage_BCS_EANTwoLabel = 0xB7,                   /* DF - EAN Two Label  */
    kHIDUsage_BCS_EANThreeLabel  = 0xB8,                /* DF - EAN Thread Label */
    kHIDUsage_BCS_EAN8FlagDigit1 = 0xB9,                /* DV - EAN 8 Flag Digit 1 */
    kHIDUsage_BCS_EAN8FlagDigit2 = 0xBA,                /* DV - EAN 8 Flag Digit 2 */
    kHIDUsage_BCS_EAN8FlagDigit3 = 0xBB,                /* DV - EAN 8 Flag Digit 3 */
    kHIDUsage_BCS_EAN13FlagDigit1 = 0xBC,               /* DV - EAN 13 Flag Digit 1 */
    kHIDUsage_BCS_EAN13FlagDigit2 = 0xBD,               /* DV - EAN 13 Flag Digit 2 */
    kHIDUsage_BCS_EAN13FlagDigit3 = 0xBE,               /* DV - EAN 13 Flag Digit 3 */
    kHIDUsage_BCS_AddEAN2_3LabelDefinition = 0xBF,      /* DF - Add EAN 2/3 Label Definition */
    kHIDUsage_BCS_ClearAllEAN2_3LabelDefinitions = 0xC0,/* DF - Clear all EAN 2/3 Label Definitions */
    /* Reserved 0xC1 - 0xC2 */
    kHIDUsage_BCS_Codabar = 0xC3,                       /* DF - Codabar */
    kHIDUsage_BCS_Code128 = 0xC4,                       /* DF - Code 128 */
    /* Reserved 0xC5 - 0xC6 */
    kHIDUsage_BCS_Code39 = 0xC7,                        /* DF - Code 39 */
    kHIDUsage_BCS_Code93 = 0xC8,                        /* DF - Code 93 */
    kHIDUsage_BCS_FullASCIIConversion = 0xC9,           /* DF - Full ASCII Conversion */
    kHIDUsage_BCS_Interleaved2of5 = 0xCA,               /* DF - Interleaved 2 of 5 */
    kHIDUsage_BCS_ItalianPharmacyCode = 0xCB,           /* DF - Italian Pharmacy Code */
    kHIDUsage_BCS_MSI_Plessey = 0xCC,                   /* DF - MSI/Plessey */
    kHIDUsage_BCS_Standard2of5IATA = 0xCD,              /* DF - Standard 2 of 5 IATA */
    kHIDUsage_BCS_Standard2of5 = 0xCE,                  /* DF - Standard 2 of 5 */
    /* Reserved 0xCF - 0xD2 */
    kHIDUsage_BCS_TransmitStart_Stop = 0xD3,            /* DF - Transmit Start/Stop */
    kHIDUsage_BCS_TriOptic = 0xD4,                      /* DF - Tri-Optic  */
    kHIDUsage_BCS_UCC_EAN_128 = 0xD5,                   /* DF - UCC/EAN-128  */
    kHIDUsage_BCS_CheckDigit = 0xD6,                    /* NArry - Check Digit */
    kHIDUsage_BCS_CheckDigitDisable = 0xD7,             /* SEL - Check Digit Disable */
    kHIDUsage_BCS_CheckDigitEnableInterleaved2of5OPCC = 0xD8, /* SEL - Check Digit Enable Interleaved 2 of 5 OPCC */
    kHIDUsage_BCS_CheckDigitEnableInterleaved2of5USS = 0xD9, /* SEL - Check Digit Enable Interleaved 2 of 5 USS */
    kHIDUsage_BCS_CheckDigitEnableStandard2of5OPCC = 0xD8, /* SEL - Check Digit Enable Standard 2 of 5 OPCC */
    kHIDUsage_BCS_CheckDigitEnableStandard2of5USS = 0xD9, /* SEL - Check Digit Enable Standard 2 of 5 USS */
    kHIDUsage_BCS_CheckDigitEnableOneMSIPlessey = 0xDC, /* SEL - Check Digit Enable One MSI Plessey */
    kHIDUsage_BCS_CheckDigitEnableTwoMSIPlessey = 0xDD, /* SEL - Check Digit Enable Two MSI Plessey */
    kHIDUsage_BCS_CheckDigitCodabarEnable = 0xDE,       /* SEL - Check Digit Codabar Enable */
    kHIDUsage_BCS_CheckDigitCode99Enable = 0xDF,        /* SEL - Check Digit Code 99 Enable */
    /* Reserved 0xE0 - 0xEF */
    kHIDUsage_BCS_TransmitCheckDigit = 0xF0,            /* NArry - Transmit Check Digit */
    kHIDUsage_BCS_DisableCheckDigitTransmit = 0xF1,     /* SEL - Disable Check Digit Transmit */
    kHIDUsage_BCS_EnableCheckDigitTransmit = 0xF2,      /* SEL - Enable Check Digit Transmit */
    /* Reserved 0xF3 - 0xFA */
    kHIDUsage_BCS_SymbologyIdentifier1 = 0xFB,          /* DV - Symbology Identifier 1 */
    kHIDUsage_BCS_SymbologyIdentifier2 = 0xFC,          /* DV - Symbology Identifier 2 */
    kHIDUsage_BCS_SymbologyIdentifier3 = 0xFD,          /* DV - Symbology Identifier 3 */
    kHIDUsage_BCS_DecodedData = 0xFE,                   /* DV - Decoded Data */
    kHIDUsage_BCS_DecodeDataContinued = 0xFF,           /* DF - Decode Data Continued */
    kHIDUsage_BCS_BarSpaceData = 0x100,                 /* DV - Bar Space Data */
    kHIDUsage_BCS_ScannerDataAccuracy = 0x101,          /* DV - Scanner Data Accuracy */
    kHIDUsage_BCS_RawDataPolarity = 0x102,              /* NArry - Raw Data Polarity */
    kHIDUsage_BCS_PolarityInvertedBarCode = 0x103,      /* SEL - Polarity Inverted Bar Code */
    kHIDUsage_BCS_PolarityNormalBarCode = 0x103,        /* SEL - Polarity Normal Bar Code */
    /* Reserved 0x105 */
    kHIDUsage_BCS_MinimumLengthToDecode = 0x106,        /* DV - Minimum Length to Decode */
    kHIDUsage_BCS_MaximumLengthToDecode = 0x107,        /* DV - Maximum Length to Decode */
    kHIDUsage_BCS_FirstDiscreteLengthToDecode = 0x108,  /* DV - First Discrete Length to Decode */
    kHIDUsage_BCS_SecondDiscreteLengthToDecode = 0x109, /* DV - Second Discrete Length to Decode */
    kHIDUsage_BCS_DataLengthMethod = 0x10A,             /* NArry - Data Length Method */
    kHIDUsage_BCS_DLMethodReadAny = 0x10B,              /* DF - DL Method Read any */
    kHIDUsage_BCS_DLMethodCheckInRange = 0x10C,         /* DF - DL Method Check in Range */
    kHIDUsage_BCS_DLMethodCheckForDiscrete = 0x10D,     /* DF - DL Method Check for Discrete */
    /* Reserved 0x10E - 0x10F */
    kHIDUsage_BCS_AztecCode = 0x110,                    /* DF - Aztec Code */
    kHIDUsage_BCS_BC412 = 0x111,                        /* DF - BC412 */
    kHIDUsage_BCS_ChannelCode = 0x112,                  /* DF - Channel Code */
    kHIDUsage_BCS_Code16 = 0x113,                       /* DF - Code 16 */
    kHIDUsage_BCS_Code32 = 0x114,                       /* DF - Code 32 */
    kHIDUsage_BCS_Code49 = 0x115,                       /* DF - Code 49 */
    kHIDUsage_BCS_CodeOne = 0x116,                      /* DF - Code One */
    kHIDUsage_BCS_Colorcode = 0x117,                    /* DF - Colorcode */
    kHIDUsage_BCS_DataMatrix = 0x118,                   /* DF - Data Matrix */
    kHIDUsage_BCS_MaxiCode = 0x119,                     /* DF - MaxiCode */
    kHIDUsage_BCS_MicroPDF = 0x11A,                     /* DF - MicroPDF */
    kHIDUsage_BCS_PDF_417 = 0x11B,                      /* DF - PDF-417 */
    kHIDUsage_BCS_PosiCode = 0x11C,                     /* DF - PosiCode */
    kHIDUsage_BCS_QRCode = 0x11D,                       /* DF - QR Code */
    kHIDUsage_BCS_SuperCode = 0x11E,                    /* DF - SuperCode */
    kHIDUsage_BCS_UltraCode = 0x11F,                    /* DF - UltraCode */
    kHIDUsage_BCS_USB_5_SlugCode = 0x120,               /* DF - USD-5 (Slug Code) */
    kHIDUsage_BCS_VeriCode = 0x121                      /* DF - VeriCode */
    /* Reserved 0x122 - 0xFFFF */
};

/* Weighing Devices Page (0x8D) */
/* This section provides detailed descriptions of the usages employed by Weighing Devices. */
enum
{
    kHIDUsage_WD_Undefined = 0x00,                      /* Weighing Device Undefined Usage */
    kHIDUsage_WD_WeighingDevice = 0x01,                 /* CA - Weighing Device */
    /* Reserved 0x02 - 0x1F */
    kHIDUsage_WD_ScaleScaleDevice = 0x20,               /* CL - Scale Device */
    kHIDUsage_WD_ScaleScaleClassIMetricCL = 0x21,       /* CL - Scale Class I Metric */
    kHIDUsage_WD_ScaleScaleClassIMetric = 0x22,         /* SEL - Scale Class I Metric */
    kHIDUsage_WD_ScaleScaleClassIIMetric = 0x23,        /* SEL - Scale Class II Metric */
    kHIDUsage_WD_ScaleScaleClassIIIMetric = 0x24,       /* SEL - Scale Class III Metric */
    kHIDUsage_WD_ScaleScaleClassIIILMetric = 0x25,      /* SEL - Scale Class IIIL Metric */
    kHIDUsage_WD_ScaleScaleClassIVMetric = 0x26,        /* SEL - Scale Class IV Metric */
    kHIDUsage_WD_ScaleScaleClassIIIEnglish = 0x27,      /* SEL - Scale Class III English */
    kHIDUsage_WD_ScaleScaleClassIIILEnglish = 0x28,     /* SEL - Scale Class IIIL English */
    kHIDUsage_WD_ScaleScaleClassIVEnglish = 0x29,       /* SEL - Scale Class IV English */
    kHIDUsage_WD_ScaleScaleClassGeneric = 0x2A,         /* SEL - Scale Class Generic */
    /* Reserved 0x2B - 0x2F */
    kHIDUsage_WD_ScaleAtrributeReport = 0x30,           /* CL - Scale Attribute Report */
    kHIDUsage_WD_ScaleControlReport = 0x31,             /* CL - Scale Control Report */
    kHIDUsage_WD_ScaleDataReport = 0x32,                /* CL - Scale Data Report */
    kHIDUsage_WD_ScaleStatusReport = 0x33,              /* CL - Scale Status Report */
    kHIDUsage_WD_ScaleWeightLimitReport = 0x34,         /* CL - Scale Weight Limit Report */
    kHIDUsage_WD_ScaleStatisticsReport = 0x35,          /* CL - Scale Statistics Report */
    /* Reserved 0x36 - 0x3F */
    kHIDUsage_WD_DataWeight = 0x40,                     /* DV - Data Weight */
    kHIDUsage_WD_DataScaling = 0x41,                    /* DV - Data Scaling */
    /* Reserved 0x42 - 0x4F */
    kHIDUsage_WD_WeightUnit = 0x50,                     /* CL - Weight Unit */
    kHIDUsage_WD_WeightUnitMilligram = 0x51,            /* SEL - Weight Unit Milligram */
    kHIDUsage_WD_WeightUnitGram = 0x52,                 /* SEL - Weight Unit Gram */
    kHIDUsage_WD_WeightUnitKilogram = 0x53,             /* SEL - Weight Unit Kilogram */
    kHIDUsage_WD_WeightUnitCarats = 0x54,               /* SEL - Weight Unit Carats */
    kHIDUsage_WD_WeightUnitTaels = 0x55,                /* SEL - Weight Unit Taels */
    kHIDUsage_WD_WeightUnitGrains = 0x56,               /* SEL - Weight Unit Grains */
    kHIDUsage_WD_WeightUnitPennyweights = 0x57,         /* SEL - Weight Unit Pennyweights */
    kHIDUsage_WD_WeightUnitMetricTon = 0x58,            /* SEL - Weight Unit Metric Ton */
    kHIDUsage_WD_WeightUnitAvoirTon = 0x59,             /* SEL - Weight Unit Avoir Ton */
    kHIDUsage_WD_WeightUnitTroyOunce = 0x5A,            /* SEL - Weight Unit Troy Ounce */
    kHIDUsage_WD_WeightUnitOunce = 0x5B,                /* SEL - Weight Unit Ounce */
    kHIDUsage_WD_WeightUnitPound = 0x5C,                /* SEL - Weight Unit Pound */
    /* Reserved 0x5D - 0x5F */
    kHIDUsage_WD_CalibrationCount = 0x60,               /* DV - Calibration Count */
    kHIDUsage_WD_RezeroCount = 0x61,                    /* DV - Re-Zero Count*/
    /* Reserved 0x62 - 0x6F */
    kHIDUsage_WD_ScaleStatus = 0x70,                    /* CL - Scale Status */
    kHIDUsage_WD_ScaleStatusFault = 0x71,               /* SEL - Scale Status Fault */
    kHIDUsage_WD_ScaleStatusStableAtZero = 0x72,        /* SEL - Scale Status Stable at Center of  Zero */
    kHIDUsage_WD_ScaleStatusInMotion = 0x73,            /* SEL - Scale Status In Motion */
    kHIDUsage_WD_ScaleStatusWeightStable = 0x74,        /* SEL - Scale Status Weight Stable */
    kHIDUsage_WD_ScaleStatusUnderZero = 0x75,           /* SEL - Scale Status Under Zero */
    kHIDUsage_WD_ScaleStatusOverWeightLimit = 0x76,     /* SEL - Scale Status Over Weight Limit */
    kHIDUsage_WD_ScaleStatusRequiresCalibration = 0x77, /* SEL - Scale Status Requires Calibration */
    kHIDUsage_WD_ScaleStatusRequiresRezeroing = 0x78,   /* SEL - Scale Status Requires Re-zeroing */
    /* Reserved 0x79 - 0x7F */
    kHIDUsage_WD_ZeroScale = 0x80,                      /* OOC - Zero Scale */
    kHIDUsage_WD_EnforcedZeroReturn = 0x81              /* OOC - Enforced Zero Return */
    /* Reserved 0x82 - 0xFFFF */
    
};

/* Magnetic Stripe Reader Page (0x8E) */
/* This section provides detailed descriptions of the usages employed by Magnetic Stripe Reader Devices. */
enum 
{
    kHIDUsage_MSR_Undefined = 0x00,                     /* MagStripe Undefined Usage */
    kHIDUsage_MSR_DeviceReadOnly = 0x01,                /* CA - MSR Device Read-Only */
    /* Reserved 0x02 - 0x10 */
    kHIDUsage_MSR_Track1Length = 0x11,                     /* SF, DF, SEL - Track 1 Length */
    kHIDUsage_MSR_Track2Length = 0x12,                     /* SF, DF, SEL - Track 2 Length */
    kHIDUsage_MSR_Track3Length = 0x13,                     /* SF, DF, SEL - Track 3 Length */
    kHIDUsage_MSR_TrackJISLength = 0x14,                   /* SF, DF, SEL - Track JIS Length */
    /* Reserved 0x15 - 0x1F */
    kHIDUsage_MSR_TrackData = 0x20,                        /* SF, DF, SEL - Track Data */
    kHIDUsage_MSR_Track1Data = 0x21,                       /* SF, DF, SEL - Track 1 Data */
    kHIDUsage_MSR_Track2Data = 0x22,                       /* SF, DF, SEL - Track 2 Data */
    kHIDUsage_MSR_Track3Data = 0x23,                       /* SF, DF, SEL - Track 3 Data */
    kHIDUsage_MSR_TrackJISData = 0x24                      /* SF, DF, SEL - Track JIS Data */
    /* Reserved 0x25 - 0xFFFF */
};

#endif /* _IOHIDUSAGETABLES_H */
                                                                                                                                                                                                                       IOHIDevice.h                                                                                        0100644 0001750 0001750 00000004336 12567452123 036062  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2009 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved. 
 *
 * IOHIDevice.h - Common Event Source object class.
 *
 * HISTORY
 * 22 May 1992    Mike Paquette at NeXT
 *      Created. 
 * 4  Aug 1993	  Erik Kay at NeXT
 *	API cleanup
 * 5  Aug 1993	  Erik Kay at NeXT
 *	added ivar space for future expansion
 */

#ifndef _IOHIDEVICE_H
#define _IOHIDEVICE_H

#include <IOKit/IOService.h>
#include <IOKit/IOLocks.h>

typedef enum {
  kHIUnknownDevice          = 0,
  kHIKeyboardDevice         = 1,
  kHIRelativePointingDevice = 2
} IOHIDKind;

class IOHIDevice : public IOService
{
  OSDeclareDefaultStructors(IOHIDevice);

public:
  virtual bool init(OSDictionary * properties = 0);
  virtual void free();
  virtual bool start(IOService * provider);
  virtual bool open(  IOService *    forClient,
                      IOOptionBits   options = 0,
                      void *         arg = 0 );

  virtual UInt32    deviceType();
  virtual IOHIDKind hidKind();
  virtual UInt32    interfaceID();
  virtual bool 	    updateProperties(void);
  virtual IOReturn  setProperties( OSObject * properties );
  virtual IOReturn  setParamProperties(OSDictionary * dict);
  virtual UInt64    getGUID();
  
  static SInt32		GenerateKey(OSObject *object);
};

#endif /* !_IOHIDEVICE_H */
                                                                                                                                                                                                                                                                                                  IOHIKeyboard.h                                                                                      0100644 0001750 0001750 00000026162 12567452123 036424  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved. 
 *
 * EventSrcPCKeyboard.h - PC Keyboard EventSrc subclass definition
 *
 * HISTORY
 * 28 Aug 1992    Joe Pasqua
 *      Created. 
 */

#ifndef _IOHIKEYBOARD_H
#define _IOHIKEYBOARD_H

#include <IOKit/hidsystem/IOHIDevice.h>
#include <IOKit/hidsystem/IOHIKeyboardMapper.h>

/* Start Action Definitions */

/*
 * HISTORICAL NOTE:
 *   The following entry points were part of the IOHIKeyboardEvents
 *   protocol.
 */

typedef void (*KeyboardEventAction)(       OSObject * target,
                    /* eventFlags  */      unsigned   eventType,
                    /* flags */            unsigned   flags,
                    /* keyCode */          unsigned   key,
                    /* charCode */         unsigned   charCode,
                    /* charSet */          unsigned   charSet,
                    /* originalCharCode */ unsigned   origCharCode,
                    /* originalCharSet */  unsigned   origCharSet,
                    /* keyboardType */     unsigned   keyboardType,
                    /* repeat */           bool       repeat,
                    /* atTime */           AbsoluteTime ts);

typedef void (*KeyboardSpecialEventAction)(OSObject * target,
                    /* eventType */        unsigned   eventType,
                    /* flags */            unsigned   flags,
                    /* keyCode */          unsigned   key,
                    /* specialty */        unsigned   flavor,
                    /* source id */        UInt64     guid,
                    /* repeat */           bool       repeat,
                    /* atTime */           AbsoluteTime ts);

typedef void (*UpdateEventFlagsAction)(    OSObject * target,
                     /* flags */           unsigned   flags);

/* Event Callback Definitions */

typedef void (*KeyboardEventCallback)(
                    /* target */           OSObject * target,
                    /* eventFlags  */      unsigned   eventType,
                    /* flags */            unsigned   flags,
                    /* keyCode */          unsigned   key,
                    /* charCode */         unsigned   charCode,
                    /* charSet */          unsigned   charSet,
                    /* originalCharCode */ unsigned   origCharCode,
                    /* originalCharSet */  unsigned   origCharSet,
                    /* keyboardType */     unsigned   keyboardType,
                    /* repeat */           bool       repeat,
                    /* atTime */           AbsoluteTime ts,
                    /* sender */           OSObject * sender,
                    /* refcon */           void *     refcon);

typedef void (*KeyboardSpecialEventCallback)(
                    /* target */           OSObject * target,
                    /* eventType */        unsigned   eventType,
                    /* flags */            unsigned   flags,
                    /* keyCode */          unsigned   key,
                    /* specialty */        unsigned   flavor,
                    /* source id */        UInt64     guid,
                    /* repeat */           bool       repeat,
                    /* atTime */           AbsoluteTime ts,
                    /* sender */           OSObject * sender,
                    /* refcon */           void *     refcon);
                    
typedef void (*UpdateEventFlagsCallback)(
                    /* target */           OSObject * target,
                    /* flags */            unsigned   flags,
                    /* sender */           OSObject * sender,
                    /* refcon */           void *     refcon);

/* End Action Definitions */

/* Default key repeat parameters */
#define EV_DEFAULTINITIALREPEAT 500000000ULL    // 1/2 sec in nanoseconds
#define EV_DEFAULTKEYREPEAT     83333333ULL     // 1/12 sec in nanoseconds
#define EV_MINKEYREPEAT         16700000ULL     // 1/60 sec

class IOHIKeyboard : public IOHIDevice
{
    OSDeclareDefaultStructors(IOHIKeyboard);

    friend class IOHIDKeyboardDevice;
	friend class IOHIDKeyboard;
	friend class IOHIDConsumer;

protected:
    IOLock *	         _deviceLock;	// Lock for all device access
    IOHIKeyboardMapper * _keyMap;	// KeyMap instance

    // The following fields describe the kind of keyboard
    UInt32		_interfaceType;
    UInt32		_deviceType;

    // The following fields describe the state of the keyboard
    UInt32 *	_keyState;		// kbdBitVector
    IOByteCount _keyStateSize;		// kbdBitVector allocated size
    unsigned	_eventFlags;		// Current eventFlags
    bool	_alphaLock;		// true means alpha lock is on
    bool	_numLock;		// true means num lock is on
    bool	_charKeyActive;		// true means char gen. key active

    // The following fields are used in performing key repeats
    bool 	_isRepeat;		// true means we're generating repeat
    unsigned	_codeToRepeat;		// What we are repeating
    bool	_calloutPending;	// true means we've sched. a callout
    AbsoluteTime	_lastEventTime;		// Time last event was dispatched
    AbsoluteTime	_downRepeatTime;	// Time when we should next repeat
    AbsoluteTime	_keyRepeat;		// Delay between key repeats
    AbsoluteTime	_initialKeyRepeat;	// Delay before initial key repeat
    UInt64		_guid;

    OSObject *                 _keyboardEventTarget;
    KeyboardEventAction        _keyboardEventAction;
    OSObject *                 _keyboardSpecialEventTarget;
    KeyboardSpecialEventAction _keyboardSpecialEventAction;
    OSObject *                 _updateEventFlagsTarget;
    UpdateEventFlagsAction     _updateEventFlagsAction;
    
    UInt16      _lastUsagePage;
    UInt16      _lastUsage;

protected:
  virtual void dispatchKeyboardEvent(unsigned int keyCode,
		     /* direction */ bool         goingDown,
		     /* timeStamp */ AbsoluteTime time);
    void    setLastPageAndUsage(UInt16 usagePage, UInt16 usage);
    void    getLastPageAndUsage(UInt16 &usagePage, UInt16 &usage);
    void    clearLastPageAndUsage();

public:
  virtual bool init(OSDictionary * properties = 0);
  virtual bool start(IOService * provider);
  virtual void stop(IOService * provider);
  virtual void free();

  virtual bool open(IOService *                client,
		    IOOptionBits	       options,
                    KeyboardEventAction        keAction,
                    KeyboardSpecialEventAction kseAction,
                    UpdateEventFlagsAction     uefAction);
                    
  bool open(        IOService *                  client,
		    IOOptionBits	         options,
                    void *,
                    KeyboardEventCallback        keCallback,
                    KeyboardSpecialEventCallback kseCallback,
                    UpdateEventFlagsCallback     uefCallback);

  virtual void close(IOService * client, IOOptionBits );

  virtual IOReturn message( UInt32 type, IOService * provider,
                    void * argument = 0 );

  virtual IOHIDKind hidKind();
  virtual bool 	    updateProperties( void );
  virtual IOReturn  setParamProperties(OSDictionary * dict);
  virtual IOReturn  setProperties( OSObject * properties );
  
  inline  bool	    isRepeat() {return _isRepeat;}

protected: // for subclasses to implement
  virtual const unsigned char * defaultKeymapOfLength(UInt32 * length);
  virtual void setAlphaLockFeedback(bool val);
  virtual void setNumLockFeedback(bool val);
  virtual UInt32 maxKeyCodes();


private:
  virtual bool resetKeyboard();
  virtual void scheduleAutoRepeat();
  static void _autoRepeat(void * arg, void *);
  virtual void autoRepeat();
  virtual void setRepeat(unsigned eventType, unsigned keyCode);
  void setRepeatMode(bool repeat);
  static void _createKeyboardNub(thread_call_param_t param0, thread_call_param_t param1);

/*
 * HISTORICAL NOTE:
 *   The following methods were part of the KeyMapDelegate protocol;
 *   the declarations have now been merged directly into this class.
 */

public:
  virtual void keyboardEvent(unsigned eventType,
      /* flags */            unsigned flags,
      /* keyCode */          unsigned keyCode,
      /* charCode */         unsigned charCode,
      /* charSet */          unsigned charSet,
      /* originalCharCode */ unsigned origCharCode,
      /* originalCharSet */  unsigned origCharSet);

  virtual void keyboardSpecialEvent(unsigned eventType,
		    /* flags */     unsigned flags,
		    /* keyCode */   unsigned keyCode,
		    /* specialty */ unsigned flavor);

  virtual void updateEventFlags(unsigned flags); // Does not generate events

  virtual unsigned eventFlags();           // Global event flags
  virtual unsigned deviceFlags();          // per-device event flags
  virtual void setDeviceFlags(unsigned flags); // Set device event flags
  virtual bool alphaLock();                // current alpha-lock state
  virtual void setAlphaLock(bool val);     // Set current alpha-lock state
  virtual bool numLock();                
  virtual void setNumLock(bool val);     
  virtual bool charKeyActive();            // Is a character gen. key down?
  virtual void setCharKeyActive(bool val); // Note that a char gen key is down.
  virtual bool doesKeyLock(unsigned key);  //does key lock physically
  virtual unsigned getLEDStatus();  //check hardware for LED status

private:
  static void _keyboardEvent( IOHIKeyboard * self,
			     unsigned   eventType,
      /* flags */            unsigned   flags,
      /* keyCode */          unsigned   key,
      /* charCode */         unsigned   charCode,
      /* charSet */          unsigned   charSet,
      /* originalCharCode */ unsigned   origCharCode,
      /* originalCharSet */  unsigned   origCharSet,
      /* keyboardType */     unsigned   keyboardType,
      /* repeat */           bool       repeat,
      /* atTime */           AbsoluteTime ts);
  static void _keyboardSpecialEvent( 	
                             IOHIKeyboard * self,
                             unsigned   eventType,
        /* flags */          unsigned   flags,
        /* keyCode  */       unsigned   key,
        /* specialty */      unsigned   flavor,
        /* guid */           UInt64     guid,
        /* repeat */         bool       repeat,
        /* atTime */         AbsoluteTime ts);
        
  static void _updateEventFlags( IOHIKeyboard * self,
				unsigned flags);  /* Does not generate events */

};

#endif /* !_IOHIKEYBOARD_H */
                                                                                                                                                                                                                                                                                                                                                                                                              IOHIKeyboardMapper.h                                                                                0100644 0001750 0001750 00000030024 12567452123 037561  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOHIKEYBOARDMAPPER_H
#define _IOHIKEYBOARDMAPPER_H

#include <IOKit/hidsystem/ev_keymap.h>
#include <IOKit/hidsystem/IOLLEvent.h>
#include <IOKit/IOTimerEventSource.h>
#include <IOKit/IOInterruptEventSource.h>

class IOHIKeyboard;
class IOHIDSystem;

/*
 * Key ip/down state is tracked in a bit list.  Bits are set
 * for key-down, and cleared for key-up.  The bit vector and macros
 * for it's manipulation are defined here.
 */

typedef	UInt32 * kbdBitVector;

#define EVK_BITS_PER_UNIT	32
#define EVK_BITS_MASK		31
#define EVK_BITS_SHIFT		5	// 1<<5 == 32, for cheap divide

#define EVK_KEYDOWN(n, bits) \
	(bits)[((n)>>EVK_BITS_SHIFT)] |= (1 << ((n) & EVK_BITS_MASK))

#define EVK_KEYUP(n, bits) \
	(bits)[((n)>>EVK_BITS_SHIFT)] &= ~(1 << ((n) & EVK_BITS_MASK))

#define EVK_IS_KEYDOWN(n, bits) \
	(((bits)[((n)>>EVK_BITS_SHIFT)] & (1 << ((n) & EVK_BITS_MASK))) != 0)

/* the maximum number of modifier keys sticky keys can hold at once */
#define kMAX_MODIFIERS					5

/* the number of shift keys in a row that must be depressed to toggle state */
#define kNUM_SHIFTS_TO_ACTIVATE			5

/* the number of milliseconds all the shifts must be pressed in - 30 seconds (30000 mS)*/
#define kDEFAULT_SHIFTEXPIREINTERVAL	30000


// sticky keys state flags
enum
{
    kState_Disabled_Flag	= 0x0001,	// disabled and will do nothing until this is changed
    kState_ShiftActivates_Flag	= 0x0002,	// the 'on' gesture (5 shifts) will activate
    kState_On			= 0x0004,	// currently on, will hold down modifiers when pressed
    kState_On_ModifiersDown	= 0x0008,	// one or more modifiers being held down

    kState_Mask			= 0x00FF,	// mask for all states
};

typedef struct _stickyKeys_ToggleInfo
{
	// size of this allocation
	IOByteCount		size;

	// which modifier key we are tracking (using NX_WHICHMODMASK)
	unsigned		toggleModifier;

	// the number of times the modifier must be pressed to toggle
	unsigned		repetitionsToToggle;

	// how long the user has to press the modifier repetitionsToToggle times
	// the default is 30 seconds
	AbsoluteTime	expireInterval;

	// the number of times the modifier used within the alloted time
	unsigned		currentCount;

	// the times that the last shift must occer for this one to be used
	// this array will actually be of size repetitionsToToggle
	AbsoluteTime	deadlines[1];
} StickyKeys_ToggleInfo;

// Flags for each sticky key modifier
// This will allow for chording of keys
// and for key locking
enum
{
    kModifier_DidPerformModifiy	= 0x01,
    kModifier_DidKeyUp		= 0x02,
    kModifier_Locked		= 0x04,
};
typedef struct _stickyKeys_ModifierInfo
{
	UInt8		key;		// Key code of the sticky modifier
        UInt8		state;		// The state of the sticky modifier
        UInt8		leftModBit;	// System Mod bit of the sticky modifier
} StickyKeys_ModifierInfo;

class IOHIDKeyboardDevice;

class IOHIKeyboardMapper : public OSObject
{
  OSDeclareDefaultStructors(IOHIKeyboardMapper);

private:
	IOHIKeyboard *		_delegate;					// KeyMap delegate
	bool				_mappingShouldBeFreed;		// true if map can be IOFree'd
	NXParsedKeyMapping	_parsedMapping;				// current system-wide keymap
	IOHIDSystem	 *		_hidSystem;					// target of IOHIKeyboard (should be IOHIDSystem)
	
	// binary compatibility padding
    struct ExpansionData { 
    
        // This is for F12 eject
	UInt16 			f12Eject_State;
	UInt32 			eject_Delay_MS;
	IOTimerEventSource 	*ejectTimerEventSource;

        // This is for sticky keys
        kbdBitVector		cached_KeyBits;
        StickyKeys_ModifierInfo stickyKeys_StuckModifiers[kMAX_MODIFIERS];
        IOInterruptEventSource  *stickyKeysMouseClickEventSource;
        IOInterruptEventSource	*stickyKeysSetFnStateEventSource;
        // The following should really be statics, but placing here 
        // to match design by predecesor.
        OSDictionary		*offFnParamDict;
        OSDictionary		*onFnParamDict;

        // This is for SlowKeys
        UInt16			slowKeys_State;
        UInt32 			slowKeys_Delay_MS;
        IOTimerEventSource	*slowKeysTimerEventSource;
        
        // stored for slowKeysPostProcess
        UInt8		slowKeys_Aborted_Key;
        UInt8		slowKeys_Current_Key;        
        
        UInt32		specialKeyModifierFlags;
        
        bool		supportsF12Eject;
        
        SInt32      modifierSwap_Modifiers[NX_NUMMODIFIERS];
		
		unsigned char * cachedAlphaLockModDefs;
    };
    ExpansionData * _reserved;				    // Reserved for future use.  (Internal use only)
    
public:
	static IOHIKeyboardMapper * keyboardMapper(
										IOHIKeyboard * delegate,
										const UInt8 *  mapping,
										UInt32         mappingLength,
										bool           mappingShouldBeFreed );
	
	virtual bool init(IOHIKeyboard * delegate,
					const UInt8 *  mapping,
					  UInt32         mappingLength,
					  bool           mappingShouldBeFreed);
	virtual void free();
	
	virtual const UInt8 *   mapping();
	virtual UInt32          mappingLength();
	virtual bool 		  	serialize(OSSerialize *s) const;
	
	virtual void 		translateKeyCode(UInt8 key, bool keyDown, kbdBitVector keyBits);
	virtual UInt8  		getParsedSpecialKey(UInt8 logical);   //retrieve a key from _parsedMapping

	virtual	void		setKeyboardTarget (IOService * keyboardTarget);
	
	virtual bool 	    updateProperties (void);
	virtual IOReturn  	setParamProperties (OSDictionary * dict);
	
	// keyEventPostProcess is called while a lock is not held, so a recursive
	// call back into HIKeyboard is possible
	virtual void 	    keyEventPostProcess (void);

private:
	static void makeNumberParamProperty( OSDictionary * dict, const char * key,
                            unsigned long long number, unsigned int bits );


	virtual bool parseKeyMapping(const UInt8 *        mapping,
								 UInt32               mappingLength,
							     NXParsedKeyMapping * parsedMapping) const;
	
	virtual void calcModBit(int bit, kbdBitVector keyBits);
	virtual void doModCalc(int key, kbdBitVector keyBits);
	virtual void doCharGen(int keyCode, bool down);

	/* sticky keys functionality */
private:
	// original translateKeyCode
	void rawTranslateKeyCode (UInt8 key, bool keyDown, kbdBitVector keyBits);
    bool modifierSwapFilterKey(UInt8 * key);

	// the current state of stickyKeys
	UInt32            	_stickyKeys_State; 
	
	// the number of modifiers being held down by stickyKeys
	int		    		_stickyKeys_NumModifiersDown;
        
	// contains the info needed to keep track of shift repetitions
	StickyKeys_ToggleInfo * _stickyKeys_ShiftToggle;

	// contains the info needed to keep track of option repetitions
	StickyKeys_ToggleInfo * _stickyKeys_OptionToggle;

	// dictionaries with cached on and off states, used to set params when state changes
	bool				_stateDirty;
	OSDictionary *		_onParamDict;
	OSDictionary *		_offParamDict;

	// init/free vars
	bool stickyKeysinit (void);
	void stickyKeysfree (void);

	// allocate/free a StickyKeys_ToggleInfo struct
	static StickyKeys_ToggleInfo * stickyKeysAllocToggleInfo (unsigned maxCount);
	static void stickyKeysFreeToggleInfo (StickyKeys_ToggleInfo * toggleInfo);

	// create on/off dicts as part of init
	bool createParamDicts (void);
  
	// post special keyboard events thru the event system
	void postKeyboardSpecialEvent (unsigned subtype, unsigned eventType=NX_SYSDEFINED);

	// check any modifier to see if it is pressed 5 times
	// based on StickyKeys_ToggleInfo
	bool stickyKeysModifierToggleCheck(
							StickyKeys_ToggleInfo * toggleInfo,
							UInt8        key,
							bool         keyDown,
							kbdBitVector keyBits,
                                                        bool 	     mouseClick = false);

	// non-modifier key pressed
	void stickyKeysNonModifierKey (UInt8 key, bool keyDown, kbdBitVector keyBits, bool mouseClick = false);

	// modifier key pressed (shift, command, option, control)
	bool stickyKeysModifierKey (UInt8 key, bool keyDown, kbdBitVector keyBits);

	// main entry point, called for all keys (returns true if key handled)
	bool stickyKeysFilterKey (UInt8 key, bool keyDown, kbdBitVector keyBits, bool mouseClick = false);

        // called by interrupt event source to inform sticky keys of mouse down event
        static void stickyKeysMouseUp(IOHIKeyboardMapper *owner, IOEventSource *sender);

	void stickyKeysCleanup();

        // called by interrupt event source to restore prior fn state
	static void stickyKeysSetFnState(IOHIKeyboardMapper *owner, IOEventSource *sender);

        /* F12 Eject Functionality */ 
private:
        
        // Determining f12 eject key press
        // Returns true if f12 held down for a predetermined period of time.
        bool f12EjectFilterKey (UInt8 key, bool keyDown, kbdBitVector keyBits);
        
        // Timer function for eject
        static void performF12Eject(IOHIKeyboardMapper *owner, IOTimerEventSource *sender);
        
        /* SlowKeys Functionality */
private:
        // Slow keys methods
        bool slowKeysFilterKey (UInt8 key, bool keyDown, kbdBitVector keyBits);
        
        static void slowKeysPostProcess (IOHIKeyboardMapper *owner, IOTimerEventSource *sender);

	
public:	
    OSMetaClassDeclareReservedUsed(IOHIKeyboardMapper,  0);
    virtual IOReturn message( UInt32 type, IOService * provider, void * argument = 0 );

	// binary compatibility padding
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  1);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  2);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  3);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  4);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  5);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  6);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  7);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  8);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper,  9);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper, 10);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper, 11);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper, 12);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper, 13);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper, 14);
    OSMetaClassDeclareReservedUnused(IOHIKeyboardMapper, 15);
};

#endif // _IOHIKEYBOARDMAPPER_H

/*
 * HISTORICAL NOTE:
 *   The "delegate" object had to respond to the following protocol;
 *   this protocol has since been merged into the IOHIKeyboard class.
 *
 * @protocol KeyMapDelegate
 *
 * - keyboardEvent	:(unsigned)eventType
 * 	flags	:(unsigned)flags
 *	keyCode	:(unsigned)keyCode
 *	charCode:(unsigned)charCode
 *	charSet	:(unsigned)charSet
 *	originalCharCode:(unsigned)origCharCode
 *	originalCharSet:(unsigned)origCharSet;
 * 
 * - keyboardSpecialEvent:(unsigned)eventType
 *	flags	 :(unsigned)flags
 *	keyCode	:(unsigned)keyCode
 *	specialty:(unsigned)flavor;
 *
 * - updateEventFlags:(unsigned)flags;	// Does not generate events
 *
 * - (unsigned)eventFlags;		// Global event flags
 * - (unsigned)deviceFlags;		// per-device event flags
 * - setDeviceFlags:(unsigned)flags;	// Set device event flags
 * - (bool)alphaLock;			// current alpha-lock state
 * - setAlphaLock:(bool)val;		// Set current alpha-lock state
 * - (bool)charKeyActive;		// Is a character gen. key down?
 * - setCharKeyActive:(bool)val;	// Note that a char gen key is down.
 *
 * @end
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            IOHIPointing.h                                                                                      0100644 0001750 0001750 00000025261 12567452123 036452  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2009 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOHIPOINTING_H
#define _IOHIPOINTING_H

#include <IOKit/hidsystem/IOHIPointing.h>
#include <IOKit/hidsystem/IOHIDevice.h>
#include <IOKit/hidsystem/IOHIDTypes.h>

/* Start Action Definitions */

/*
 * HISTORICAL NOTE:
 *   The following entry points were part of the IOHIPointingEvents
 *   protocol.
 */
typedef void (*RelativePointerEventAction)(OSObject * target,
                        /* buttons */      int        buttons,
                        /* deltaX */       int        dx,
                        /* deltaY */       int        dy,
                        /* atTime */       AbsoluteTime ts);

typedef void (*AbsolutePointerEventAction)(OSObject * target,
                        /* buttons */      int        buttons,
                        /* at */           IOGPoint * newLoc,
                        /* withBounds */   IOGBounds *bounds,
                        /* inProximity */  bool       proximity,
                        /* withPressure */ int        pressure,
                        /* withAngle */    int        stylusAngle,
                        /* atTime */       AbsoluteTime ts);

typedef void (*ScrollWheelEventAction)(OSObject * target,
                                       short      deltaAxis1,
                                       short      deltaAxis2,
                                       short      deltaAxis3,
                                       AbsoluteTime ts);

/* Event Callback Definitions */

typedef void (*RelativePointerEventCallback)(
                        /* target */       OSObject * target,
                        /* buttons */      int        buttons,
                        /* deltaX */       int        dx,
                        /* deltaY */       int        dy,
                        /* atTime */       AbsoluteTime ts,
                        /* sender */       OSObject * sender,
                        /* refcon */       void *     refcon);

typedef void (*AbsolutePointerEventCallback)(
                        /* target */       OSObject * target,
                        /* buttons */      int        buttons,
                        /* at */           IOGPoint * newLoc,
                        /* withBounds */   IOGBounds *bounds,
                        /* inProximity */  bool       proximity,
                        /* withPressure */ int        pressure,
                        /* withAngle */    int        stylusAngle,
                        /* atTime */       AbsoluteTime ts,
                        /* sender */       OSObject * sender,
                        /* refcon */       void *     refcon);

typedef void (*ScrollWheelEventCallback)(
                        /* target */       OSObject * target,
                        /* delta1 */       short      deltaAxis1,
                        /* delta2 */       short      deltaAxis2,
                        /* delta3 */       short      deltaAxis3,
                        /* fixedDelta1 */  IOFixed    fixedDelta1,
                        /* fixedDelta2 */  IOFixed    fixedDelta2,
                        /* fixedDelta3 */  IOFixed    fixedDelta3,
                        /* pointDelta1 */  SInt32     pointDelta1,
                        /* pointDelta2 */  SInt32     pointDelta2,
                        /* pointDelta3 */  SInt32     pointDelta3,
                        /* reserved */     SInt32     options,
                        /* atTime */       AbsoluteTime ts,
                        /* sender */       OSObject * sender,
                        /* refcon */       void *     refcon);

/* End Action Definitions */

/* Default accel level parameters */
#define EV_DEFAULTPOINTERACCELLEVEL 0x0000b000
#define EV_DEFAULTSCROLLACCELLEVEL  0x00005000

class IOHIDPointingDevice;
struct ScrollAccelInfo;

class IOHIPointing : public IOHIDevice
{
    OSDeclareDefaultStructors(IOHIPointing);
    
    friend class IOHITablet;
    friend class IOHIDPointing;

private:
    IOLock *		_deviceLock;  // Lock for all device access
    int			_buttonMode;  // The "handedness" of the pointer
    IOFixed		_acceleration;
    bool		_convertAbsoluteToRelative;
    bool		_contactToMove;
    bool		_hadContact;
    IOGPoint    _previousLocation;
    UInt8		_pressureThresholdToClick;	// A scale factor of 0 to 255 to determine how much pressure is necessary to generate a primary mouse click - a value of 255 means no click will be generated
    void *		_scaleSegments;
    IOItemCount		_scaleSegCount;
    IOFixed		_fractX;
    IOFixed		_fractY;

    OSObject *                 _relativePointerEventTarget;
    RelativePointerEventAction _relativePointerEventAction;
    OSObject *                 _absolutePointerEventTarget;
    AbsolutePointerEventAction _absolutePointerEventAction;
    OSObject *                 _scrollWheelEventTarget;
    ScrollWheelEventAction     _scrollWheelEventAction;
    
    struct ExpansionData;

    ExpansionData *  _reserved;
    
    void    setPointingMode(UInt32 accelerateMode);
    UInt32  getPointingMode ();
    void    setScrollType(UInt32 scrollType);
    UInt32  getScrollType();

    void dispatchScrollWheelEventWithAccelInfo(
                                SInt32              deltaAxis1,
                                SInt32              deltaAxis2,
                                SInt32              deltaAxis3,
                                ScrollAccelInfo *   info,
                                AbsoluteTime        ts);
    
    
protected:
  virtual void dispatchRelativePointerEvent(int        dx,
                                            int        dy,
                                            UInt32     buttonState,
                                            AbsoluteTime ts);
    
  virtual void dispatchAbsolutePointerEvent(IOGPoint *	newLoc,
                                            IOGBounds *	bounds,
                                            UInt32	buttonState,
                                            bool	proximity,
                                            int		pressure,
                                            int		pressureMin,
                                            int		pressureMax,
                                            int		stylusAngle,
                                            AbsoluteTime	ts);

  virtual void dispatchScrollWheelEvent(short deltaAxis1,
                                        short deltaAxis2,
                                        short deltaAxis3,
                                        AbsoluteTime ts);

public:
  virtual bool init(OSDictionary * properties = 0);
  virtual bool start(IOService * provider);
  virtual void free();

  virtual bool open(IOService *                client,
		    IOOptionBits	       options,
                    RelativePointerEventAction rpeAction,
                    AbsolutePointerEventAction apeAction,
                    ScrollWheelEventAction     sweAction);
                    
  bool open(        IOService *				client,
                    IOOptionBits			options,
                    void *,
                    RelativePointerEventCallback	rpeCallback,
                    AbsolutePointerEventCallback	apeCallback,
                    ScrollWheelEventCallback		sweCallback);

  virtual void close(IOService * client, IOOptionBits );
  virtual IOReturn message( UInt32 type, IOService * provider,
                              void * argument = 0 );

  virtual IOHIDKind hidKind();
  virtual bool 	    updateProperties( void );
  virtual IOReturn  setParamProperties( OSDictionary * dict );
  virtual IOReturn  powerStateWillChangeTo( IOPMPowerFlags powerFlags,
                        unsigned long newState, IOService * device);
  virtual IOReturn  powerStateDidChangeTo( IOPMPowerFlags powerFlags,
                        unsigned long newState, IOService * device);

protected: // for subclasses to implement
  virtual OSData *    copyAccelerationTable();
  virtual IOItemCount buttonCount();
  virtual IOFixed     resolution();

  // RY: Adding method to copy scroll wheel accel table.
  // Unfortunately, we don't have any padding, so this
  // is going to be non-virtual.
  /*virtual*/ OSData * copyScrollAccelerationTable();

private:
  virtual bool resetPointer();
  virtual void scalePointer(int * dxp, int * dyp);
    virtual void setupForAcceleration(IOFixed accl);
  
  // RY: Adding methods to support scroll wheel accel.
  // Unfortunately, we don't have any padding, so these
  // are going to be non-virtual.
  /*virtual*/ bool 	resetScroll();
  /*virtual*/ void 	setupScrollForAcceleration(IOFixed accl);
  
  // RY: We have to make sure that subclasses that will 
  // take advantage of this have their defined resolution 
  // in their property table.
  /*virtual*/ IOFixed	scrollResolutionForType(SInt32 type=-1);
  /*virtual*/ IOFixed   scrollReportRate();
  /*virtual*/ OSData *  copyScrollAccelerationTableForType(SInt32 type=-1);
  
private:
  static void _relativePointerEvent( IOHIPointing * self,
				    int        buttons,
                       /* deltaX */ int        dx,
                       /* deltaY */ int        dy,
                       /* atTime */ AbsoluteTime ts);

  /* Tablet event reporting */
  static void _absolutePointerEvent(IOHIPointing * self,
				    int        buttons,
                 /* at */           IOGPoint * newLoc,
                 /* withBounds */   IOGBounds *bounds,
                 /* inProximity */  bool       proximity,
                 /* withPressure */ int        pressure,
                 /* withAngle */    int        stylusAngle,
                 /* atTime */       AbsoluteTime ts);

  /* Mouse scroll wheel event reporting */
  static void _scrollWheelEvent(IOHIPointing *self,
                                short deltaAxis1,
                                short deltaAxis2,
                                short deltaAxis3,
                                AbsoluteTime ts);

};

#endif /* !_IOHIPOINTING_H */
                                                                                                                                                                                                                                                                                                                                               IOLLEvent.h                                                                                         0100644 0001750 0001750 00000053745 12567452123 035763  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2009 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/******************************************************************************
	event.h (PostScript side version)
	
	CONFIDENTIAL
	Copyright (c) 1988 NeXT, Inc. as an unpublished work.
	All Rights Reserved.

	Created Leo 01Mar88

	Modified:
	04May88 Leo  Final event types and record
	22Aug88 Leo  Change short -> int for window, add reserved
	26May90 Ted  Added NX_UNDIMMASK to correct triggering of UndoAutoDim
	12Dec91 Mike Brought into sync with dpsclient/event.h, and fixed
		     the #ifndef interlock with dpsclient/event.h that was
		     broken during the Great Header Revision.

	The PostScript version of this file differs from the
	Window Kit version in that the coordinates here are
	ints instead of floats.
******************************************************************************/

#ifndef _DEV_EVENT_H
#define _DEV_EVENT_H

#include <libkern/OSTypes.h>
#include <IOKit/hidsystem/IOHIDTypes.h>

#ifdef EVENT_H		/* Interlock with dpsclient/event.h */
#if !defined(_NXSIZE_)	/* Work around patch for old event.h in Phase 3 projs*/
#define _NXSIZE_	1	/* NXCoord, NXPoint, NXSize decl seen */
#define _NXSize_	NXSize
#endif /* _NXSIZE_ */
#else  /* EVENT_H */		/* Haven't seen dpsclient/event.h, so define away */
#define EVENT_H

#ifdef	KERNEL
#else	/* KERNEL */

#if !defined(_NXSIZE_)	/* Work around patch for old event.h in Phase 3 projs*/
#define _NXSIZE_	1	/* NXCoord, NXPoint, NXSize decl seen */
typedef float   NXCoord;

typedef struct _NXPoint {	/* point */
    NXCoord         x, y;
} NXPoint;

typedef struct _NXSize {	/* size */
    NXCoord         width, height;
} NXSize;
#define _NXSize_	NXSize	/* Correct usage in event_status_driver.h */
#endif /* _NXSIZE_ */

#endif	/* KERNEL */

/* Event types */

#define NX_NULLEVENT		0	/* internal use */

/* mouse events */

#define NX_LMOUSEDOWN		1	/* left mouse-down event */
#define NX_LMOUSEUP		2	/* left mouse-up event */
#define NX_RMOUSEDOWN		3	/* right mouse-down event */
#define NX_RMOUSEUP		4	/* right mouse-up event */
#define NX_MOUSEMOVED		5	/* mouse-moved event */
#define NX_LMOUSEDRAGGED	6	/* left mouse-dragged event */
#define NX_RMOUSEDRAGGED	7	/* right mouse-dragged event */
#define NX_MOUSEENTERED		8	/* mouse-entered event */
#define NX_MOUSEEXITED		9	/* mouse-exited event */

/* other mouse events
 *
 * event.data.mouse.buttonNumber should contain the 
 * button number (2-31) changing state.
 */
#define NX_OMOUSEDOWN		25	/* other mouse-down event */
#define NX_OMOUSEUP		26	/* other mouse-up event */
#define NX_OMOUSEDRAGGED	27	/* other mouse-dragged event */

/* keyboard events */

#define NX_KEYDOWN		10	/* key-down event */
#define NX_KEYUP		11	/* key-up event */
#define NX_FLAGSCHANGED		12	/* flags-changed event */

/* composite events */

#define NX_KITDEFINED		13	/* application-kit-defined event */
#define NX_SYSDEFINED		14	/* system-defined event */
#define NX_APPDEFINED		15	/* application-defined event */
/* There are additional DPS client defined events past this point. */

/* Scroll wheel events */

#define NX_SCROLLWHEELMOVED	22

/* Zoom events */
#define NX_ZOOM             28

/* tablet events */

#define NX_TABLETPOINTER	23	/* for non-mousing transducers */
#define NX_TABLETPROXIMITY	24  /* for non-mousing transducers */

/* event range */

#define NX_FIRSTEVENT		0
#define NX_LASTEVENT		28
#define NX_NUMPROCS		(NX_LASTEVENT-NX_FIRSTEVENT+1)

/* Event masks */
#define NX_NULLEVENTMASK        (1 << NX_NULLEVENT)     /* NULL event */
#define NX_LMOUSEDOWNMASK       (1 << NX_LMOUSEDOWN)	/* left mouse-down */
#define NX_LMOUSEUPMASK         (1 << NX_LMOUSEUP)      /* left mouse-up */
#define NX_RMOUSEDOWNMASK       (1 << NX_RMOUSEDOWN)	/* right mouse-down */
#define NX_RMOUSEUPMASK         (1 << NX_RMOUSEUP)      /* right mouse-up */
#define NX_OMOUSEDOWNMASK       (1 << NX_OMOUSEDOWN)	/* other mouse-down */
#define NX_OMOUSEUPMASK         (1 << NX_OMOUSEUP)      /* other mouse-up  */
#define NX_MOUSEMOVEDMASK       (1 << NX_MOUSEMOVED)	/* mouse-moved */
#define NX_LMOUSEDRAGGEDMASK	(1 << NX_LMOUSEDRAGGED)	/* left-dragged */
#define NX_RMOUSEDRAGGEDMASK	(1 << NX_RMOUSEDRAGGED)	/* right-dragged */
#define NX_OMOUSEDRAGGEDMASK	(1 << NX_OMOUSEDRAGGED)	/* other-dragged */
#define NX_MOUSEENTEREDMASK     (1 << NX_MOUSEENTERED)	/* mouse-entered */
#define NX_MOUSEEXITEDMASK      (1 << NX_MOUSEEXITED)	/* mouse-exited */
#define NX_KEYDOWNMASK          (1 << NX_KEYDOWN)       /* key-down */
#define NX_KEYUPMASK            (1 << NX_KEYUP)         /* key-up */
#define NX_FLAGSCHANGEDMASK     (1 << NX_FLAGSCHANGED)	/* flags-changed */
#define NX_KITDEFINEDMASK       (1 << NX_KITDEFINED)	/* kit-defined */
#define NX_SYSDEFINEDMASK       (1 << NX_SYSDEFINED)	/* system-defined */
#define NX_APPDEFINEDMASK       (1 << NX_APPDEFINED)	/* app-defined */
#define NX_SCROLLWHEELMOVEDMASK	(1 << NX_SCROLLWHEELMOVED)	/* scroll wheel moved */
#define NX_ZOOMMASK             (1 << NX_ZOOM)          /* Zoom */
#define NX_TABLETPOINTERMASK	(1 << NX_TABLETPOINTER)	/* tablet pointer moved */
#define NX_TABLETPROXIMITYMASK	(1 << NX_TABLETPROXIMITY)	/* tablet pointer proximity */

#define EventCodeMask(type)	(1 << (type))
#define NX_ALLEVENTS		-1	/* Check for all events */

/* sub types for mouse and move events */

#define NX_SUBTYPE_DEFAULT					0
#define NX_SUBTYPE_TABLET_POINT				1
#define NX_SUBTYPE_TABLET_PROXIMITY			2
#define NX_SUBTYPE_MOUSE_TOUCH              3

/* sub types for system defined events */

#define NX_SUBTYPE_POWER_KEY				1
#define NX_SUBTYPE_AUX_MOUSE_BUTTONS		7

/* 
 * NX_SUBTYPE_AUX_CONTROL_BUTTONS usage
 *
 * The incoming NXEvent for other mouse button down/up has event.type 
 * NX_SYSDEFINED and event.data.compound.subtype NX_SUBTYPE_AUX_MOUSE_BUTTONS.
 * Within the event.data.compound.misc.L[0] contains bits for all the buttons 
 * that have changed state, and event.data.compound.misc.L[1] contains the 
 * current button state as a bitmask, with 1 representing down, and 0
 * representing up.  Bit 0 is the left button, bit one is the right button, 
 * bit 2 is the center button and so forth.
 */
#define NX_SUBTYPE_AUX_CONTROL_BUTTONS		8

#define NX_SUBTYPE_EJECT_KEY				10
#define NX_SUBTYPE_SLEEP_EVENT				11
#define NX_SUBTYPE_RESTART_EVENT			12
#define NX_SUBTYPE_SHUTDOWN_EVENT			13

#define NX_SUBTYPE_STICKYKEYS_ON			100
#define NX_SUBTYPE_STICKYKEYS_OFF			101
#define NX_SUBTYPE_STICKYKEYS_SHIFT			102
#define NX_SUBTYPE_STICKYKEYS_CONTROL			103
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE			104
#define NX_SUBTYPE_STICKYKEYS_COMMAND			105
#define NX_SUBTYPE_STICKYKEYS_RELEASE			106
#define NX_SUBTYPE_STICKYKEYS_TOGGLEMOUSEDRIVING	107

// New stickykeys key events
// These were created to send an event describing the 
// different state of the modifiers
#define NX_SUBTYPE_STICKYKEYS_SHIFT_DOWN		110
#define NX_SUBTYPE_STICKYKEYS_CONTROL_DOWN		111
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE_DOWN		112
#define NX_SUBTYPE_STICKYKEYS_COMMAND_DOWN		113
#define NX_SUBTYPE_STICKYKEYS_FN_DOWN			114

#define NX_SUBTYPE_STICKYKEYS_SHIFT_LOCK		120
#define NX_SUBTYPE_STICKYKEYS_CONTROL_LOCK		121
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE_LOCK		122
#define NX_SUBTYPE_STICKYKEYS_COMMAND_LOCK		123
#define NX_SUBTYPE_STICKYKEYS_FN_LOCK			124

#define NX_SUBTYPE_STICKYKEYS_SHIFT_UP			130
#define NX_SUBTYPE_STICKYKEYS_CONTROL_UP		131
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE_UP		132
#define NX_SUBTYPE_STICKYKEYS_COMMAND_UP		133
#define NX_SUBTYPE_STICKYKEYS_FN_UP			134



// SlowKeys 
#define NX_SUBTYPE_SLOWKEYS_START			200
#define NX_SUBTYPE_SLOWKEYS_ABORT			201
#define NX_SUBTYPE_SLOWKEYS_END				202

// HID Parameter Property Modified
#define NX_SUBTYPE_HIDPARAMETER_MODIFIED		210

/* Masks for the bits in event.flags */

/* device-independent */

#define	NX_ALPHASHIFTMASK	0x00010000
#define	NX_SHIFTMASK		0x00020000
#define	NX_CONTROLMASK		0x00040000
#define	NX_ALTERNATEMASK	0x00080000
#define	NX_COMMANDMASK		0x00100000
#define	NX_NUMERICPADMASK	0x00200000
#define	NX_HELPMASK		0x00400000
#define	NX_SECONDARYFNMASK	0x00800000
#define NX_ALPHASHIFT_STATELESS_MASK    0x01000000

/* device-dependent (really?) */

#define	NX_DEVICELCTLKEYMASK	0x00000001
#define	NX_DEVICELSHIFTKEYMASK	0x00000002
#define	NX_DEVICERSHIFTKEYMASK	0x00000004
#define	NX_DEVICELCMDKEYMASK	0x00000008
#define	NX_DEVICERCMDKEYMASK	0x00000010
#define	NX_DEVICELALTKEYMASK	0x00000020
#define	NX_DEVICERALTKEYMASK	0x00000040
#define NX_DEVICE_ALPHASHIFT_STATELESS_MASK 0x00000080
#define NX_DEVICERCTLKEYMASK	0x00002000

/* 
 * Additional reserved bits in event.flags
 */

#define NX_STYLUSPROXIMITYMASK	0x00000080	/* deprecated */
#define NX_NONCOALSESCEDMASK	0x00000100

/* click state values
 * If you have the following events in close succession, the click
 * field has the indicated value:
 *	
 *  Event	Click Value	Comments
 *  mouse-down	1		Not part of any click yet
 *  mouse-up	1		Aha! A click!
 *  mouse-down	2		Doing a double-click
 *  mouse-up	2		It's finished
 *  mouse-down	3		A triple
 *  mouse-up	3
 */

/* Values for the character set in event.data.key.charSet */

#define	NX_ASCIISET		0
#define NX_SYMBOLSET		1
#define	NX_DINGBATSSET		2

/* tablet button masks
 * Mask bits for the tablet barrel buttons placed in tablet.buttons.
 * The buttons field uses adopts the following convention:
 *
 * Bit      Comments
 * 0        Left Mouse Button ( kHIDUsage_Button_1 )
 * 1        Right Mouse Button ( kHIDUsage_Button_2 )
 * 2        Middle Mouse Button ( kHIDUsage_Button_3 )
 * 3        4th Mouse Button ( kHIDUsage_Button_4 )
 * ...
 * 15       15th Mouse Button
 *
 * For your convenience, the following mask bits have been defined
 * for tablet specific application:
 */
 
#define NX_TABLET_BUTTON_PENTIPMASK             0x0001
#define NX_TABLET_BUTTON_PENLOWERSIDEMASK       0x0002
#define NX_TABLET_BUTTON_PENUPPERSIDEMASK       0x0004


/* tablet capability masks
 * Mask bits for the tablet capabilities field.   Use these 
 * masks with the capabilities field of a proximity event to 
 * determine what fields in a Tablet Event are valid for this 
 * device.
 */
#define NX_TABLET_CAPABILITY_DEVICEIDMASK           0x0001
#define NX_TABLET_CAPABILITY_ABSXMASK               0x0002
#define NX_TABLET_CAPABILITY_ABSYMASK               0x0004
#define NX_TABLET_CAPABILITY_VENDOR1MASK            0x0008
#define NX_TABLET_CAPABILITY_VENDOR2MASK            0x0010
#define NX_TABLET_CAPABILITY_VENDOR3MASK            0x0020
#define NX_TABLET_CAPABILITY_BUTTONSMASK            0x0040
#define NX_TABLET_CAPABILITY_TILTXMASK              0x0080
#define NX_TABLET_CAPABILITY_TILTYMASK              0x0100
#define NX_TABLET_CAPABILITY_ABSZMASK               0x0200
#define NX_TABLET_CAPABILITY_PRESSUREMASK           0x0400
#define NX_TABLET_CAPABILITY_TANGENTIALPRESSUREMASK 0x0800
#define NX_TABLET_CAPABILITY_ORIENTINFOMASK         0x1000
#define NX_TABLET_CAPABILITY_ROTATIONMASK           0x2000

/* proximity pointer types
 * Value that describes the type of pointing device placed in
 * proximity.pointerType.
 */
 
#define NX_TABLET_POINTER_UNKNOWN               0
#define NX_TABLET_POINTER_PEN                   1
#define NX_TABLET_POINTER_CURSOR                2
#define NX_TABLET_POINTER_ERASER                3

/* TabletPointData type: defines the tablet data for points included
 * in mouse events created by a tablet driver.
 */

typedef struct _NXTabletPointData {
	SInt32  x;  /* absolute x coordinate in tablet space at full tablet resolution */
    SInt32  y;  /* absolute y coordinate in tablet space at full tablet resolution */
	SInt32  z;  /* absolute z coordinate in tablet space at full tablet resolution */
    UInt16  buttons;   /* one bit per button - bit 0 is first button - 1 = closed  */
    UInt16  pressure;  /* scaled pressure value; MAX=(2^16)-1, MIN=0 */
    struct {           /* tilt range is -((2^15)-1) to (2^15)-1 (-32767 to 32767)  */
        SInt16 x;      /* scaled tilt x value */
        SInt16 y;      /* scaled tilt y value */
	} tilt;
	UInt16  rotation;  /* Fixed-point representation of device rotation in a 10.6 format */
	SInt16  tangentialPressure; /* tangential pressure on the device; same range as tilt */
	UInt16  deviceID;  /* system-assigned unique device ID */
	SInt16  vendor1;   /* vendor-defined signed 16-bit integer */
	SInt16  vendor2;   /* vendor-defined signed 16-bit integer */
	SInt16  vendor3;   /* vendor-defined signed 16-bit integer */
} NXTabletPointData, *NXTabletPointDataPtr;

/* TabletProximityData type: defines the tablet data for proximity
 * events included in mouse events created by a tablet driver.
 */

typedef struct _NXTabletProximityData {
    UInt16  vendorID;             /* vendor-defined ID - typically the USB vendor ID */
	UInt16  tabletID;             /* vendor-defined tablet ID - typically the USB product ID */
	UInt16  pointerID;            /* vendor-defined ID of the specific pointing device */
	UInt16  deviceID;             /* system-assigned unique device ID */
	UInt16  systemTabletID;       /* system-assigned unique tablet ID */
	UInt16  vendorPointerType;    /* vendor-defined pointer type */
	UInt32  pointerSerialNumber;  /* vendor-defined serial number */
	UInt64  uniqueID __attribute__ ((packed));             /* vendor-defined unique ID */
	UInt32  capabilityMask;       /* capabilities mask of the device */
	UInt8   pointerType;          /* type of pointing device */
	UInt8   enterProximity;       /* non-zero = entering; zero = leaving */
	SInt16  reserved1;
} NXTabletProximityData, *NXTabletProximityDataPtr;

/* EventData type: defines the data field of an event */

typedef	union {
    struct {    /* For mouse-down and mouse-up events */
        UInt8   subx;       /* sub-pixel position for x */
        UInt8   suby;       /* sub-pixel position for y */
        SInt16  eventNum;   /* unique identifier for this button */
        SInt32  click;      /* click state of this event */
        UInt8   pressure;   /* pressure value: 0=none, 255=full */
        UInt8   buttonNumber;/* button generating other button event (0-31) */
        UInt8   subType;
        UInt8   reserved2;
        SInt32  reserved3;
        union {
            NXTabletPointData      point;     /* tablet point data */
            NXTabletProximityData  proximity; /* tablet proximity data */
        } tablet;
    } mouse;
    struct {
        SInt32  dx;
        SInt32  dy;
        UInt8   subx;
        UInt8   suby;
        UInt8   subType;
        UInt8   reserved1;
        SInt32  reserved2;
        union {
            NXTabletPointData      point;     /* tablet point data */
            NXTabletProximityData  proximity; /* tablet proximity data */
        } tablet;
    } mouseMove;
    struct {    /* For key-down and key-up events */
        UInt16  origCharSet;    /* unmodified character set code */
        SInt16  repeat;         /* for key-down: nonzero if really a repeat */
        UInt16  charSet;        /* character set code */
        UInt16  charCode;       /* character code in that set */
        UInt16  keyCode;        /* device-dependent key number */
        UInt16  origCharCode;   /* unmodified character code */
        SInt32  reserved1;
        UInt32  keyboardType;
        SInt32  reserved2;
        SInt32  reserved3;
        SInt32  reserved4;
        SInt32  reserved5[4];
    } key;
    struct {    /* For mouse-entered and mouse-exited events */
        SInt16  reserved;
        SInt16  eventNum;       /* unique identifier from mouse down event */
        SInt32  trackingNum;    /* unique identifier from settrackingrect */
        SInt32  userData;       /* uninterpreted integer from settrackingrect */
        SInt32  reserved1;
        SInt32  reserved2;
        SInt32  reserved3;
        SInt32  reserved4;
        SInt32  reserved5;
        SInt32  reserved6[4];
    } tracking;
    struct {
        SInt16  deltaAxis1;
        SInt16  deltaAxis2;
        SInt16  deltaAxis3;
        SInt16  reserved1;
        SInt32  fixedDeltaAxis1;
        SInt32  fixedDeltaAxis2;
        SInt32  fixedDeltaAxis3;
        SInt32  pointDeltaAxis1;
        SInt32  pointDeltaAxis2;
        SInt32  pointDeltaAxis3;
        SInt32  reserved8[4];
    } scrollWheel, zoom;
    struct {    /* For window-changed, sys-defined, and app-defined events */
        SInt16  reserved;
        SInt16  subType;    /* event subtype for compound events */
        union {
            float   F[11];  /* for use in compound events */
            SInt32  L[11];  /* for use in compound events */
            SInt16  S[22];  /* for use in compound events */
            char    C[44];  /* for use in compound events */
        } misc;
    } compound;
    struct {
        SInt32  x;  /* absolute x coordinate in tablet space at full tablet resolution */
        SInt32  y;  /* absolute y coordinate in tablet space at full tablet resolution */
        SInt32  z;  /* absolute z coordinate in tablet space at full tablet resolution */
        UInt16  buttons;   /* one bit per button - bit 0 is first button - 1 = closed  */
        UInt16  pressure;  /* scaled pressure value; MAX=(2^16)-1, MIN=0 */
        struct {           /* tilt range is -((2^15)-1) to (2^15)-1 (-32767 to 32767)  */
            SInt16 x;      /* scaled tilt x value */
            SInt16 y;      /* scaled tilt y value */
        } tilt;
        UInt16  rotation;  /* Fixed-point representation of device rotation in a 10.6 format */
        SInt16  tangentialPressure; /* tangential pressure on the device; same range as tilt */
        UInt16  deviceID;  /* system-assigned unique device ID */
        SInt16  vendor1;   /* vendor-defined signed 16-bit integer */
        SInt16  vendor2;   /* vendor-defined signed 16-bit integer */
        SInt16  vendor3;   /* vendor-defined signed 16-bit integer */
        SInt32  reserved[4];
    } tablet;
    struct {
        UInt16  vendorID;  /* vendor-defined ID - typically the USB vendor ID */
        UInt16  tabletID;  /* vendor-defined tablet ID - typically the USB product ID */
        UInt16  pointerID; /* vendor-defined ID of the specific pointing device */
        UInt16  deviceID;             /* system-assigned unique device ID */
        UInt16  systemTabletID;       /* system-assigned unique tablet ID */
        UInt16  vendorPointerType;    /* vendor-defined pointer type */
        UInt32  pointerSerialNumber;  /* vendor-defined serial number */
        UInt64  uniqueID __attribute__ ((packed));             /* vendor-defined unique ID */
        UInt32  capabilityMask;       /* capabilities mask of the device */
        UInt8   pointerType;          /* type of pointing device */
        UInt8   enterProximity;       /* non-zero = entering; zero = leaving */
        SInt16  reserved1;
        SInt32  reserved2[4];
    } proximity;
} NXEventData;

/* The current version number of the NXEventData structure. */

#define kNXEventDataVersion		2

/* Finally! The event record! */
#ifndef __ppc__
typedef struct _NXEvent {
	SInt32              type;		/* An event type from above */
    struct {
        SInt32	x, y;					/* Base coordinates in window, */
    } 					location;	/* from bottom left */
    UInt64              time __attribute__ ((packed));		/* time since launch */
    SInt32              flags;		/* key state flags */
    UInt32              window;		/* window number of assigned window */
    UInt64              service_id __attribute__ ((packed)); /* service id */
    SInt32              ext_pid;    /* external pid */
    NXEventData			data;		/* type-dependent data */
} NXEvent, *NXEventPtr;

#else

typedef struct _NXEvent {
	SInt32              type;		/* An event type from above */
    struct {
        SInt32	x, y;					/* Base coordinates in window, */
    } 					location;	/* from bottom left */
    UInt64              time __attribute__ ((packed));		/* time since launch */
    SInt32              flags;		/* key state flags */
    UInt32              window;		/* window number of assigned window */
    NXEventData			data;		/* type-dependent data */
    UInt64              service_id __attribute__ ((packed)); /* service id */
    SInt32              ext_pid;    /* external pid */
} NXEvent, *NXEventPtr;
#endif

/* The current version number of the NXEvent structure. */

#define kNXEventVersion		2

/* How to pick window(s) for event (for PostEvent) */
#define NX_NOWINDOW		-1
#define NX_BYTYPE		0
#define NX_BROADCAST		1
#define NX_TOPWINDOW		2
#define NX_FIRSTWINDOW		3
#define NX_MOUSEWINDOW		4
#define NX_NEXTWINDOW		5
#define NX_LASTLEFT		6
#define NX_LASTRIGHT		7
#define NX_LASTKEY		8
#define NX_EXPLICIT		9
#define NX_TRANSMIT		10
#define NX_BYPSCONTEXT		11

#endif /* EVENT_H */	/* End of defs common with dpsclient/event.h */

/* Mask of events that cause the screen to wake up */
#define NX_WAKEMASK     (   NX_KEYDOWNMASK | NX_FLAGSCHANGEDMASK | \
                            NX_LMOUSEDOWNMASK | NX_LMOUSEUPMASK | \
                            NX_RMOUSEDOWNMASK | NX_RMOUSEUPMASK | \
                            NX_OMOUSEDOWNMASK | NX_OMOUSEUPMASK   \
                        )

/* Mask of events that cause screen to undim */
#define NX_UNDIMMASK    (   NX_WAKEMASK | NX_KEYUPMASK | NX_SCROLLWHEELMOVEDMASK | \
                            NX_LMOUSEDRAGGEDMASK | NX_RMOUSEDRAGGEDMASK | NX_OMOUSEDRAGGEDMASK | \
                            NX_MOUSEMOVEDMASK | NX_MOUSEENTEREDMASK | NX_MOUSEEXITEDMASK | \
                            NX_TABLETPOINTERMASK | NX_TABLETPROXIMITYMASK \
                        )

#endif /* !_DEV_EVENT_H */

                           ev_keymap.h                                                                                         0100644 0001750 0001750 00000014105 12567452123 036165  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hidsystem                                                      /*
 * @APPLE_LICENSE_HEADER_START@
 *
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved.
 *
 *	ev_keymap.h
 *	Defines the structure used for parsing keymappings.  These structures
 *	and definitions are used by event sources in the kernel and by
 *	applications and utilities which manipulate keymaps.
 *
 * HISTORY
 * 02-Jun-1992    Mike Paquette at NeXT
 *      Created.
 */

#ifndef _DEV_EV_KEYMAP_H
#define _DEV_EV_KEYMAP_H

#define	NX_NUMKEYCODES	256	/* Highest key code is 0xff. ADB used to use 0x80 for keydown state, but who the heck uses adb anymore. */
#define NX_NUMSEQUENCES	128	/* Maximum possible number of sequences */
#define	NX_NUMMODIFIERS	16	/* Maximum number of modifier bits */
#define	NX_BYTE_CODES	0	/* If first short 0, all are bytes (else shorts) */

#define	NX_WHICHMODMASK	0x0f 	/* bits out of keyBits for bucky bits */
#define	NX_MODMASK	0x10	/* Bit out of keyBits indicates modifier bit */
#define	NX_CHARGENMASK	0x20	/* bit out of keyBits for char gen */
#define	NX_SPECIALKEYMASK 0x40	/* bit out of keyBits for specialty key */
#define	NX_KEYSTATEMASK	0x80	/* OBSOLETE - DO NOT USE IN NEW DESIGNS */

/*
 * Special keys currently known to and understood by the system.
 * If new specialty keys are invented, extend this list as appropriate.
 * The presence of these keys in a particular implementation is not
 * guaranteed.
 */
#define NX_NOSPECIALKEY			0xFFFF
#define NX_KEYTYPE_SOUND_UP		0
#define NX_KEYTYPE_SOUND_DOWN		1
#define NX_KEYTYPE_BRIGHTNESS_UP	2
#define NX_KEYTYPE_BRIGHTNESS_DOWN	3
#define NX_KEYTYPE_CAPS_LOCK		4
#define NX_KEYTYPE_HELP			5
#define NX_POWER_KEY			6
#define	NX_KEYTYPE_MUTE			7
#define NX_UP_ARROW_KEY			8
#define NX_DOWN_ARROW_KEY		9
#define NX_KEYTYPE_NUM_LOCK		10

#define NX_KEYTYPE_CONTRAST_UP		11
#define NX_KEYTYPE_CONTRAST_DOWN	12
#define NX_KEYTYPE_LAUNCH_PANEL		13
#define NX_KEYTYPE_EJECT		14
#define NX_KEYTYPE_VIDMIRROR		15

#define NX_KEYTYPE_PLAY			16
#define NX_KEYTYPE_NEXT			17
#define NX_KEYTYPE_PREVIOUS		18
#define NX_KEYTYPE_FAST			19
#define NX_KEYTYPE_REWIND		20

#define NX_KEYTYPE_ILLUMINATION_UP	21
#define NX_KEYTYPE_ILLUMINATION_DOWN	22
#define NX_KEYTYPE_ILLUMINATION_TOGGLE	23

#define	NX_NUMSPECIALKEYS		24 /* Maximum number of special keys */
#define NX_NUM_SCANNED_SPECIALKEYS	24 /* First 24 special keys are */
					  /* actively scanned in kernel */

/* Mask of special keys that are posted as events */

#define NX_SPECIALKEY_POST_MASK		\
                                ((1 << NX_KEYTYPE_SOUND_UP) | (1 << NX_KEYTYPE_SOUND_DOWN) | \
                                (1 << NX_POWER_KEY) | (1 << NX_KEYTYPE_MUTE) | \
                                (1 << NX_KEYTYPE_BRIGHTNESS_UP) | (1 << NX_KEYTYPE_BRIGHTNESS_DOWN) | \
                                (1 << NX_KEYTYPE_CONTRAST_UP) | (1 << NX_KEYTYPE_CONTRAST_UP) | \
                                (1 << NX_KEYTYPE_LAUNCH_PANEL) | (1 << NX_KEYTYPE_EJECT) | \
                                (1 << NX_KEYTYPE_VIDMIRROR) | (1 << NX_KEYTYPE_PLAY) | \
                                (1 << NX_KEYTYPE_NEXT) | (1 << NX_KEYTYPE_PREVIOUS) | \
                                (1 << NX_KEYTYPE_FAST) | (1 << NX_KEYTYPE_REWIND) | \
                                (1 << NX_KEYTYPE_ILLUMINATION_UP) | \
                                (1 << NX_KEYTYPE_ILLUMINATION_DOWN) | \
                                (1 << NX_KEYTYPE_ILLUMINATION_TOGGLE) | 0)

/* Modifier key indices into modDefs[] */
#define NX_MODIFIERKEY_ALPHALOCK	0
#define NX_MODIFIERKEY_SHIFT		1
#define NX_MODIFIERKEY_CONTROL		2
#define NX_MODIFIERKEY_ALTERNATE	3
#define NX_MODIFIERKEY_COMMAND		4
#define NX_MODIFIERKEY_NUMERICPAD	5
#define NX_MODIFIERKEY_HELP		6
#define NX_MODIFIERKEY_SECONDARYFN     	7
#define NX_MODIFIERKEY_NUMLOCK		8

/* support for right hand modifier */
#define NX_MODIFIERKEY_RSHIFT		9
#define NX_MODIFIERKEY_RCONTROL		10
#define NX_MODIFIERKEY_RALTERNATE	11
#define NX_MODIFIERKEY_RCOMMAND		12

#define NX_MODIFIERKEY_ALPHALOCK_STATELESS  13
#define NX_MODIFIERKEY_LAST_KEY     13


typedef struct _NXParsedKeyMapping_ {
 	/* If nonzero, all numbers are shorts; if zero, all numbers are bytes*/
	short	shorts;

	/*
	 *  For each keycode, low order bit says if the key
	 *  generates characters.
	 *  High order bit says if the key is assigned to a modifier bit.
	 *  The second to low order bit gives the current state of the key.
	 */
	char	keyBits[NX_NUMKEYCODES];

	/* Bit number of highest numbered modifier bit */
	int			maxMod;

	/* Pointers to where the list of keys for each modifiers bit begins,
	 * or NULL.
	 */
	unsigned char *modDefs[NX_NUMMODIFIERS];

	/* Key code of highest key deinfed to generate characters */
	int			numDefs;

	/* Pointer into the keyMapping where this key's definitions begin */
	unsigned char *keyDefs[NX_NUMKEYCODES];

	/* number of sequence definitions */
	int			numSeqs;

	/* pointers to sequences */
	unsigned char *seqDefs[NX_NUMSEQUENCES];

	/* Special key definitions */
	int			numSpecialKeys;

	/* Special key values, or 0xFFFF if none */
	unsigned short specialKeys[NX_NUMSPECIALKEYS];

	/* Pointer to the original keymapping string */
	const unsigned char *mapping;

	/* Length of the original string */
	int	mappingLen;
} NXParsedKeyMapping;

#endif /* !_DEV_EV_KEYMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                           i2c/                                                                                                0040755 0001750 0001750 00000000000 12612224742 032475  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOI2CInterface.h                                                                                    0100644 0001750 0001750 00000027114 12567452457 035315  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/i2c                                                            /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOI2CINTERFACE_H
#define _IOKIT_IOI2CINTERFACE_H

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

typedef struct IOI2CRequest IOI2CRequest;
typedef struct IOI2CBuffer IOI2CBuffer;

typedef void (*IOI2CRequestCompletion) (IOI2CRequest * request);

// IOI2CRequest.sendTransactionType, IOI2CRequest.replyTransactionType
enum {
    kIOI2CNoTransactionType         = 0,
    kIOI2CSimpleTransactionType     = 1,
    kIOI2CDDCciReplyTransactionType = 2,
    kIOI2CCombinedTransactionType   = 3,
    kIOI2CDisplayPortNativeTransactionType = 4
};

// IOI2CRequest.commFlags
enum {
    kIOI2CUseSubAddressCommFlag     = 0x00000002
};

/*!
 * @struct IOI2CRequest
 * @abstract A structure defining an I2C bus transaction.
 * @discussion This structure is used to request an I2C transaction consisting of a send (write) to and reply (read) from a device, either of which is optional, to be carried out atomically on an I2C bus.
 * @field __reservedA Set to zero.
 * @field result The result of the transaction. Common errors are kIOReturnNoDevice if there is no device responding at the given address, kIOReturnUnsupportedMode if the type of transaction is unsupported on the requested bus.
 * @field completion A completion routine to be executed when the request completes. If NULL is passed, the request is synchronous, otherwise it may execute asynchronously.
 * @field commFlags Flags that modify the I2C transaction type. The following flags are defined:<br>
 *      kIOI2CUseSubAddressCommFlag Transaction includes a subaddress.<br>
 * @field minReplyDelay Minimum delay as absolute time between send and reply transactions.
 * @field sendAddress I2C address to write.
 * @field sendSubAddress I2C subaddress to write.
 * @field __reservedB Set to zero.
 * @field sendTransactionType The following types of transaction are defined for the send part of the request:<br>
 *      kIOI2CNoTransactionType No send transaction to perform. <br>
 *      kIOI2CSimpleTransactionType Simple I2C message. <br>
 *      kIOI2CCombinedTransactionType Combined format I2C R/~W transaction. <br>
 * @field sendBuffer Pointer to the send buffer.
 * @field sendBytes Number of bytes to send. Set to actual bytes sent on completion of the request.
 * @field replyAddress I2C Address from which to read.
 * @field replySubAddress I2C Address from which to read.
 * @field __reservedC Set to zero.
 * @field replyTransactionType The following types of transaction are defined for the reply part of the request:<br>
 *      kIOI2CNoTransactionType No reply transaction to perform. <br>
 *      kIOI2CSimpleTransactionType Simple I2C message. <br>
 *      kIOI2CDDCciReplyTransactionType DDC/ci message (with embedded length). See VESA DDC/ci specification. <br>
 *      kIOI2CCombinedTransactionType Combined format I2C R/~W transaction. <br>
 * @field replyBuffer Pointer to the reply buffer.
 * @field replyBytes Max bytes to reply (size of replyBuffer). Set to actual bytes received on completion of the request.
 * @field __reservedD Set to zero.
 */

#pragma pack(push, 4)
struct IOI2CRequest
{
    IOOptionBits                sendTransactionType;
    IOOptionBits                replyTransactionType;
    uint32_t                    sendAddress;
    uint32_t                    replyAddress;
    uint8_t                     sendSubAddress;
    uint8_t                     replySubAddress;
    uint8_t                     __reservedA[2];

    uint64_t                    minReplyDelay;

    IOReturn                    result;
    IOOptionBits                commFlags;

#if defined(__LP64__)
    uint32_t                    __padA;
#else
    vm_address_t                sendBuffer;
#endif
    uint32_t                    sendBytes;

    uint32_t                    __reservedB[2];

#if defined(__LP64__)
    uint32_t                    __padB;
#else
    vm_address_t                replyBuffer;
#endif
    uint32_t                    replyBytes;

    IOI2CRequestCompletion      completion;
#if !defined(__LP64__)
    uint32_t                    __padC[5];
#else
    vm_address_t                sendBuffer;
    vm_address_t                replyBuffer;
#endif

    uint32_t                    __reservedC[10];
#ifdef __ppc__
    uint32_t                    __reservedD;
#endif
};
#pragma pack(pop)

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define kIOI2CInterfaceClassName        "IOI2CInterface"

#define kIOI2CInterfaceIDKey            "IOI2CInterfaceID"
#define kIOI2CBusTypeKey                "IOI2CBusType"
#define kIOI2CTransactionTypesKey       "IOI2CTransactionTypes"
#define kIOI2CSupportedCommFlagsKey     "IOI2CSupportedCommFlags"

#define kIOFBI2CInterfaceInfoKey        "IOFBI2CInterfaceInfo"
#define kIOFBI2CInterfaceIDsKey         "IOFBI2CInterfaceIDs"

// kIOI2CBusTypeKey values
enum {
    kIOI2CBusTypeI2C            = 1,
    kIOI2CBusTypeDisplayPort    = 2
};

/*!
 * @struct IOI2CBusTiming
 * @abstract A structure defining low level timing for an I2C bus.
 * @discussion This structure is used to specify timeouts and pulse widths for an I2C bus implementation.
 * @field bitTimeout Maximum time a slave can delay (by pulling the clock line low) a single bit response.
 * @field byteTimeout Maximum time a slave can delay (by pulling the clock line low) the first bit of a byte response.
 * @field acknowledgeTimeout Maximum time to wait for a slave to respond with an ACK after writing a byte.
 * @field startTimeout Maximum time to wait for a slave to respond after a start signal.
 * @field riseFallTime Time to wait after any change in output signal.
 * @field __reservedA Set to zero.
 */

struct IOI2CBusTiming
{
    AbsoluteTime                bitTimeout;
    AbsoluteTime                byteTimeout;
    AbsoluteTime                acknowledgeTimeout;
    AbsoluteTime                startTimeout;
    AbsoluteTime                holdTime;
    AbsoluteTime                riseFallTime;
    UInt32                      __reservedA[8];
};
typedef struct IOI2CBusTiming IOI2CBusTiming;

#ifndef KERNEL

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// options for IOFBCopyI2CInterfaceForBus()
enum {
    kIOI2CBusNumberMask                 = 0x000000ff
};


/*! @function IOFBGetI2CInterfaceCount
    @abstract Returns a count of I2C interfaces available associated with an IOFramebuffer instance.
    @discussion Returns a count of I2C interfaces available associated with an IOFramebuffer instance.
    @param framebuffer The io_service_t of an IOFramebuffer instance. CoreGraphics will provide this for a CGDisplay with the CGDisplayIOServicePort() call.
    @param count Interface count is returned.
    @result An IOReturn code. */

IOReturn IOFBGetI2CInterfaceCount( io_service_t framebuffer, IOItemCount * count );

/*! @function IOFBCopyI2CInterfaceForBus
    @abstract Returns an instance of an I2C bus interface, associated with an IOFramebuffer instance / bus index pair.
    @discussion Some graphics devices will allow access to an I2C bus routed through a display connector in order to control external devices on that bus. This function returns an instance of an I2C bus interface, associated with an IOFramebuffer instance / bus index pair. The number of I2C buses is available from the IOFBGetI2CInterfaceCount() call. The interface may be used with the IOI2CInterfaceOpen/Close/SendRequest() calls to carry out I2C transactions on that bus. Not all graphics devices support this functionality.
    @param bus The zero based index of the bus on the requested framebuffer.
    @param interface The interface instance is returned. The caller should release this instance with IOObjectRelease().
    @result An IOReturn code. */

IOReturn IOFBCopyI2CInterfaceForBus( io_service_t framebuffer, IOOptionBits bus, io_service_t * interface );

typedef struct IOI2CConnect * IOI2CConnectRef;  /* struct IOI2CConnect is opaque */

IOReturn IOI2CCopyInterfaceForID( CFTypeRef identifier, io_service_t * interface );

/*! @function IOI2CInterfaceOpen
    @abstract Opens an instance of an I2C bus interface, allowing I2C requests to be made.
    @discussion An instance of an I2C bus interface, obtained by IOFBCopyI2CInterfaceForBus, is opened with this function allowing I2C requests to be made.
    @param interface An I2C bus interface (see IOFBCopyI2CInterfaceForBus). The interface may be released after this call is made.
    @param options Pass kNilOptions.
    @param connect The opaque IOI2CConnectRef is returned, for use with IOI2CSendRequest() and IOI2CInterfaceClose().
    @result An IOReturn code. */

IOReturn IOI2CInterfaceOpen( io_service_t interface, IOOptionBits options,
                             IOI2CConnectRef * connect );

/*! @function IOI2CInterfaceClose
    @abstract Closes an IOI2CConnectRef.
    @discussion Frees the resources associated with an IOI2CConnectRef.
    @param connect The opaque IOI2CConnectRef returned by IOI2CInterfaceOpen().
    @param options Pass kNilOptions.
    @result An IOReturn code. */

IOReturn IOI2CInterfaceClose( IOI2CConnectRef connect, IOOptionBits options );

/*! @function IOI2CSendRequest
    @abstract Carries out the I2C transaction specified by an IOI2CRequest structure.
    @discussion Frees the resources associated with an IOI2CConnectRef.
    @param connect The opaque IOI2CConnectRef returned by IOI2CInterfaceOpen().
    @param options Pass kNilOptions.
    @param request Pass a pointer to a IOI2CRequest structure describing the request. If an asynchronous request (with a non-NULL completion routine) the request structure must be valid for the life of the request.
    @result An IOReturn code reflecting only the result of starting the transaction. If the result of IOI2CSendRequest() is kIOReturnSuccess, the I2C transaction result is returned in the result field of the request structure. */

IOReturn IOI2CSendRequest( IOI2CConnectRef connect, IOOptionBits options, 
                           IOI2CRequest * request );

#else

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @class IOI2CInterface
    @abstract The base class for an I2C bus interface.
    @discussion The IOI2CInterface base class defines an I2C bus interface. Not useful for developers. */

class IOI2CInterface : public IOService
{
    OSDeclareDefaultStructors(IOI2CInterface)
    
protected:
    UInt64      fID;

public:
    IOReturn newUserClient( task_t              owningTask,
                            void *              security_id,
                            UInt32              type,
                            IOUserClient **     handler );

    bool registerI2C( UInt64 id );

    virtual IOReturn startIO( IOI2CRequest * request ) = 0;
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif /* KERNEL */

#endif /* ! _IOKIT_IOI2CINTERFACE_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                    ndrvsupport/                                                                                        0040755 0001750 0001750 00000000000 12612224742 034426  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOMacOSTypes.h                                                                                      0100644 0001750 0001750 00000037063 12567452457 037043  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/ndrvsupport                                                    /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997 Apple Computer, Inc.
 *
 *
 * HISTORY
 *
 * sdouglas  22 Oct 97 - first checked in.
 * sdouglas  21 July 98 - start IOKit
 */

/*
    File:       Types.h
 
    Contains:   Basic Macintosh data types.
 
    Version:    Technology: PowerSurge 1.0.2.
                Package:    Universal Interfaces 2.1.2 on ETO #20
 
    Copyright:  ÔøΩ 1984-1995 by Apple Computer, Inc.
                All rights reserved.
 
    Bugs?:      If you find a problem with this file, use the Apple Bug Reporter
                stack.  Include the file and version information (from above)
                in the problem description and send to:
                    Internet:   apple.bugs@applelink.apple.com
                    AppleLink:  APPLE.BUGS
 
*/

#ifndef _IOKIT_IOMACOSTYPES_H
#define _IOKIT_IOMACOSTYPES_H
#ifndef __MACTYPES__

#include <IOKit/IOTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LP64__
#pragma options align=mac68k
#endif

#ifndef NULL
#if !defined(__cplusplus) && (defined(__SC__) || defined(THINK_C))
#define NULL ((void *) 0)
#else
#define NULL 0
#endif
#endif

enum {
    noErr                       = 0
};

typedef unsigned char Byte;

typedef signed char SignedByte;

typedef UInt16 UniChar;

typedef char *Ptr;

typedef Ptr *Handle;

typedef UInt32 Fixed;

typedef Fixed *FixedPtr;

typedef UInt32 Fract;

typedef Fract *FractPtr;

/*
enum {
    false,
    true
};
#if !__option(bool)
    #ifndef true
        #define true            1
    #endif
    #ifndef false
        #define false           0
    #endif
#endif

typedef unsigned char Boolean;
*/


typedef short OSErr;

typedef unsigned int FourCharCode;

typedef FourCharCode OSType;

typedef FourCharCode ResType;

typedef OSType *OSTypePtr;

typedef ResType *ResTypePtr;

struct Rect {
    short                           top;
    short                           left;
    short                           bottom;
    short                           right;
};
typedef struct Rect Rect;

typedef Rect *RectPtr;

// Quickdraw.i

/*
    kVariableLengthArray is used in array bounds to specify a variable length array.
    It is ususally used in variable length structs when the last field is an array
    of any size.  Before ANSI C, we used zero as the bounds of variable length 
    array, but that is illegal in ANSI C.  Example:
    
        struct FooList 
        {
            short   listLength;
            Foo     elements[kVariableLengthArray];
        };
*/

enum {
    kVariableLengthArray        = 1
};

/* Numeric version part of 'vers' resource */
struct NumVersion {
    UInt8                           majorRev;                   /*1st part of version number in BCD*/
    UInt8                           minorAndBugRev;             /*2nd & 3rd part of version number share a byte*/
    UInt8                           stage;                      /*stage code: dev, alpha, beta, final*/
    UInt8                           nonRelRev;                  /*revision level of non-released version*/
};
typedef struct NumVersion NumVersion;

typedef struct OpaqueRef *KernelID;

typedef UInt8 *BytePtr;

typedef IOByteCount ByteCount;

typedef IOItemCount ItemCount;

typedef void *LogicalAddress;

#if !defined(__LP64__)
typedef void *PhysicalAddress;
#endif

typedef UInt32 PBVersion;

typedef SInt32 Duration;

#define kInvalidID 0

enum {
    kNilOptions                 = 0
};


typedef unsigned char Str31[32];


/*
From:
        File:           DriverFamilyMatching.i <18>
        Copyright:      ÔøΩ 1995-1996 by Apple Computer, Inc., all rights reserved.
*/

//##############################################
// Well known properties in the Name Registry
//##############################################

#define kPropertyName                                   "name"
#define kPropertyCompatible                             "compatible"
#define kPropertyDriverPtr                              "driver-ptr"
#define kPropertyDriverDesc                             "driver-description"
#define kPropertyReg                                    "reg"
#define kPropertyAAPLAddress                            "AAPL,address"
#define kPropertyMatching                               "matching"


//#########################################################
// Descriptor for Drivers and NDRVs
//#########################################################
/* Driver Typing Information Used to Match Drivers With Devices */
struct DriverType {
        Str31                                                   nameInfoStr;                            /* Driver Name/Info String*/
        NumVersion                                              version;                                        /* Driver Version Number*/
};
typedef struct DriverType                       DriverType;
typedef DriverType *                            DriverTypePtr;

/* OS Runtime Information Used to Setup and Maintain a Driver's Runtime Environment */
typedef IOOptionBits RuntimeOptions;


enum {
        kDriverIsLoadedUponDiscovery = 0x00000001,                                      /* auto-load driver when discovered*/
        kDriverIsOpenedUponLoad         =  0x00000002,                                  /* auto-open driver when loaded*/
        kDriverIsUnderExpertControl     =  0x00000004,                                  /* I/O expert handles loads/opens*/
        kDriverIsConcurrent                     =  0x00000008,                                  /* supports concurrent requests*/
        kDriverQueuesIOPB                       =  0x00000010,                                  /* device manager doesn't queue IOPB*/
        kDriverIsLoadedAtBoot           =  0x00000020,                                  /* Driver is loaded at the boot time */
        kDriverIsForVirtualDevice       =  0x00000040,                                  /* Driver is for a virtual Device */ 
        kDriverSupportDMSuspendAndResume = 0x00000080                           /* Driver supports Device Manager Suspend and Resume command */
};

struct DriverOSRuntime {
        RuntimeOptions                                  driverRuntime;                          /* Options for OS Runtime*/
        Str31                                                   driverName;                                     /* Driver's name to the OS*/
        UInt32                                                  driverDescReserved[8];          /* Reserved area*/
};
typedef struct DriverOSRuntime          DriverOSRuntime;
typedef DriverOSRuntime *                       DriverOSRuntimePtr;

/* OS Service Information Used To Declare What APIs a Driver Supports */
typedef UInt32 ServiceCount;

struct DriverServiceInfo {
        OSType                                                  serviceCategory;                        /* Service Category Name*/
        OSType                                                  serviceType;                            /* Type within Category*/
        NumVersion                                              serviceVersion;                         /* Version of service*/
};
typedef struct DriverServiceInfo        DriverServiceInfo;
typedef DriverServiceInfo *                     DriverServiceInfoPtr;

struct DriverOSService {
        ServiceCount                                    nServices;                                      /* Number of Services Supported*/
        DriverServiceInfo                               service[1];                                     /* The List of Services (at least one)*/
};
typedef struct DriverOSService          DriverOSService;
typedef DriverOSService *                       DriverOSServicePtr;

/* Categories */

enum {
        kServiceCategoryDisplay                 = 'disp',                                               /* Display Manager*/
        kServiceCategoryOpenTransport   = 'otan',                                               /* Open Transport*/
        kServiceCategoryBlockStorage    = 'blok',                                               /* Block Storage*/
        kServiceCategoryNdrvDriver              = 'ndrv',                                               /* Generic Native Driver*/
        kServiceCategoryScsiSIM                 = 'scsi',                                               /* SCSI */
        kServiceCategoryFileManager             = 'file',                                               /* File Manager */
        kServiceCategoryIDE                             = 'ide-',                                               /* ide */
        kServiceCategoryADB                             = 'adb-',                                               /* adb */
        kServiceCategoryPCI                             = 'pci-',                                               /* pci bus */
                                                                                                                                        /* Nu Bus */
        kServiceCategoryDFM                             = 'dfm-',                                               /* DFM */
        kServiceCategoryMotherBoard             = 'mrbd',                                               /* mother Board */
        kServiceCategoryKeyboard                = 'kybd',                                               /* Keyboard */
        kServiceCategoryPointing                = 'poit',                                               /* Pointing */
        kServiceCategoryRTC                             = 'rtc-',                                               /* RTC */
        kServiceCategoryNVRAM                   = 'nram',                                               /* NVRAM */
        kServiceCategorySound                   = 'sond',                                               /* Sound (1/3/96 MCS) */
        kServiceCategoryPowerMgt                = 'pgmt',                                               /* Power Management */
        kServiceCategoryGeneric                 = 'genr'                                                /* Generic Service Category to receive general Events */
};

/* Ndrv ServiceCategory Types */
enum {
        kNdrvTypeIsGeneric                      = 'genr',                                               /* generic*/
        kNdrvTypeIsVideo                        = 'vido',                                               /* video*/
        kNdrvTypeIsBlockStorage         = 'blok',                                               /* block storage*/
        kNdrvTypeIsNetworking           = 'netw',                                               /* networking*/
        kNdrvTypeIsSerial                       = 'serl',                                               /* serial*/
        kNdrvTypeIsParallel                     = 'parl',                                               /* parallel */
        kNdrvTypeIsSound                        = 'sond',                                               /* sound*/
        kNdrvTypeIsBusBridge            = 'brdg'
};

typedef UInt32 DriverDescVersion;

/*      The Driver Description */
enum {
        kInitialDriverDescriptor        = 0,
        kVersionOneDriverDescriptor     = 1
};

enum {
        kTheDescriptionSignature        = 'mtej',
        kDriverDescriptionSignature     = 'pdes'                                                
};


struct DriverDescription {
        OSType                                                  driverDescSignature;            /* Signature field of this structure*/
        DriverDescVersion                               driverDescVersion;                      /* Version of this data structure*/
        DriverType                                              driverType;                                     /* Type of Driver*/
        DriverOSRuntime                                 driverOSRuntimeInfo;            /* OS Runtime Requirements of Driver*/
        DriverOSService                                 driverServices;                         /* Apple Service API Membership*/
};
typedef struct DriverDescription        DriverDescription;
typedef DriverDescription *                     DriverDescriptionPtr;


#ifndef __LP64__
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __MACTYPES__ */

#ifndef __QUICKDRAW__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LP64__
#pragma options align=mac68k
#endif

struct RGBColor {
 unsigned short red;                /*magnitude of red component*/
 unsigned short green;              /*magnitude of green component*/
 unsigned short blue;               /*magnitude of blue component*/
};
typedef struct RGBColor     RGBColor;
typedef RGBColor            *RGBColorPtr;
typedef RGBColorPtr         *RGBColorHdl;

struct ColorSpec {
 short value;                       /*index or other value*/
 RGBColor rgb;                      /*true color*/
};

typedef struct ColorSpec    ColorSpec;
typedef ColorSpec           *ColorSpecPtr;

struct GammaTbl {
 short gVersion;                    /*gamma version number*/
 short gType;                       /*gamma data type*/
 short gFormulaSize;                /*Formula data size*/
 short gChanCnt;                    /*number of channels of data*/
 short gDataCnt;                    /*number of values/channel*/
 short gDataWidth;                  /*bits/corrected value (data packed to next larger byte size)*/
 short gFormulaData[1];             /*data for formulas followed by gamma values*/
};
typedef struct GammaTbl     GammaTbl;
typedef GammaTbl            *GammaTblPtr;

struct RegEntryID
{
    void * opaque[4];
};
typedef struct RegEntryID RegEntryID;
typedef RegEntryID *                    RegEntryIDPtr;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

struct IONDRVControlParameters {
    UInt8       __reservedA[0x1a];
    UInt16      code;
    void *      params;
    UInt8       __reservedB[0x12];
};

enum {
    kIONDRVOpenCommand                = 128 + 0,
    kIONDRVCloseCommand               = 128 + 1,
    kIONDRVReadCommand                = 128 + 2,
    kIONDRVWriteCommand               = 128 + 3,
    kIONDRVControlCommand             = 128 + 4,
    kIONDRVStatusCommand              = 128 + 5,
    kIONDRVKillIOCommand              = 128 + 6,
    kIONDRVInitializeCommand          = 128 + 7,                /* init driver and device*/
    kIONDRVFinalizeCommand            = 128 + 8,                /* shutdown driver and device*/
    kIONDRVReplaceCommand             = 128 + 9,                /* replace an old driver*/
    kIONDRVSupersededCommand          = 128 + 10                /* prepare to be replaced by a new driver*/
};
enum {
    kIONDRVSynchronousIOCommandKind   = 0x00000001,
    kIONDRVAsynchronousIOCommandKind  = 0x00000002,
    kIONDRVImmediateIOCommandKind     = 0x00000004
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef __LP64__
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __QUICKDRAW__ */

#endif /* _IOKIT_IOMACOSTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             IOMacOSVideo.h                                                                                      0100644 0001750 0001750 00000241003 12567452457 036774  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/ndrvsupport                                                    /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
     File:       Video.h
 
     Contains:   Video Driver Interfaces.
 
     Copyright:  (c) 1986-2000 by Apple Computer, Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __IOMACOSVIDEO__
#define __IOMACOSVIDEO__

#define PRAGMA_STRUCT_ALIGN 1
#define FOUR_CHAR_CODE(x)           (x)
#include <IOKit/ndrvsupport/IOMacOSTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LP64__
#pragma options align=mac68k
#endif

enum {
    mBaseOffset                 = 1,                            /*Id of mBaseOffset.*/
    mRowBytes                   = 2,                            /*Video sResource parameter Id's */
    mBounds                     = 3,                            /*Video sResource parameter Id's */
    mVersion                    = 4,                            /*Video sResource parameter Id's */
    mHRes                       = 5,                            /*Video sResource parameter Id's */
    mVRes                       = 6,                            /*Video sResource parameter Id's */
    mPixelType                  = 7,                            /*Video sResource parameter Id's */
    mPixelSize                  = 8,                            /*Video sResource parameter Id's */
    mCmpCount                   = 9,                            /*Video sResource parameter Id's */
    mCmpSize                    = 10,                           /*Video sResource parameter Id's */
    mPlaneBytes                 = 11,                           /*Video sResource parameter Id's */
    mVertRefRate                = 14,                           /*Video sResource parameter Id's */
    mVidParams                  = 1,                            /*Video parameter block id.*/
    mTable                      = 2,                            /*Offset to the table.*/
    mPageCnt                    = 3,                            /*Number of pages*/
    mDevType                    = 4,                            /*Device Type*/
    oneBitMode                  = 128,                          /*Id of OneBitMode Parameter list.*/
    twoBitMode                  = 129,                          /*Id of TwoBitMode Parameter list.*/
    fourBitMode                 = 130,                          /*Id of FourBitMode Parameter list.*/
    eightBitMode                = 131                           /*Id of EightBitMode Parameter list.*/
};

enum {
    sixteenBitMode              = 132,                          /*Id of SixteenBitMode Parameter list.*/
    thirtyTwoBitMode            = 133,                          /*Id of ThirtyTwoBitMode Parameter list.*/
    firstVidMode                = 128,                          /*The new, better way to do the above. */
    secondVidMode               = 129,                          /* QuickDraw only supports six video */
    thirdVidMode                = 130,                          /* at this time.      */
    fourthVidMode               = 131,
    fifthVidMode                = 132,
    sixthVidMode                = 133,
    spGammaDir                  = 64,
    spVidNamesDir               = 65
};

typedef UInt32                          AVIDType;
typedef AVIDType                        DisplayIDType;
typedef IODisplayModeID                 DisplayModeID;
typedef UInt16                          DepthMode;
typedef UInt32                          VideoDeviceType;
typedef UInt32                          GammaTableID;

/* csTimingFormat values in VDTimingInfo */
/* look in the declaration rom for timing info */
enum {
    kDeclROMtables              = FOUR_CHAR_CODE('decl'),
    kDetailedTimingFormat       = FOUR_CHAR_CODE('arba')        /* Timing is a detailed timing*/
};

/* Size of a block of EDID (Extended Display Identification Data) */
enum {
    kDDCBlockSize               = 128
};

/* ddcBlockType constants*/
enum {
    kDDCBlockTypeEDID           = 0                             /* EDID block type. */
};

/* ddcFlags constants*/
enum {
    kDDCForceReadBit            = 0,                            /* Force a new read of the EDID. */
    kDDCForceReadMask           = (1 << kDDCForceReadBit)       /* Mask for kddcForceReadBit. */
};


/* Timing mode constants for Display Manager MultiMode support
    Corresponding   .h equates are in Video.h
                    .a equates are in Video.a
                    .r equates are in DepVideoEqu.r
    
    The second enum is the old names (for compatibility).
    The first enum is the new names.
*/
enum {
    timingInvalid               = 0,                            /*    Unknown timing... force user to confirm. */
    timingInvalid_SM_T24        = 8,                            /*    Work around bug in SM Thunder24 card.*/
    timingApple_FixedRateLCD    = 42,                           /*    Lump all fixed-rate LCDs into one category.*/
    timingApple_512x384_60hz    = 130,                          /*  512x384  (60 Hz) Rubik timing. */
    timingApple_560x384_60hz    = 135,                          /*  560x384  (60 Hz) Rubik-560 timing. */
    timingApple_640x480_67hz    = 140,                          /*  640x480  (67 Hz) HR timing. */
    timingApple_640x400_67hz    = 145,                          /*  640x400  (67 Hz) HR-400 timing. */
    timingVESA_640x480_60hz     = 150,                          /*  640x480  (60 Hz) VGA timing. */
    timingVESA_640x480_72hz     = 152,                          /*  640x480  (72 Hz) VGA timing. */
    timingVESA_640x480_75hz     = 154,                          /*  640x480  (75 Hz) VGA timing. */
    timingVESA_640x480_85hz     = 158,                          /*  640x480  (85 Hz) VGA timing. */
    timingGTF_640x480_120hz     = 159,                          /*  640x480  (120 Hz) VESA Generalized Timing Formula */
    timingApple_640x870_75hz    = 160,                          /*  640x870  (75 Hz) FPD timing.*/
    timingApple_640x818_75hz    = 165,                          /*  640x818  (75 Hz) FPD-818 timing.*/
    timingApple_832x624_75hz    = 170,                          /*  832x624  (75 Hz) GoldFish timing.*/
    timingVESA_800x600_56hz     = 180,                          /*  800x600  (56 Hz) SVGA timing. */
    timingVESA_800x600_60hz     = 182,                          /*  800x600  (60 Hz) SVGA timing. */
    timingVESA_800x600_72hz     = 184,                          /*  800x600  (72 Hz) SVGA timing. */
    timingVESA_800x600_75hz     = 186,                          /*  800x600  (75 Hz) SVGA timing. */
    timingVESA_800x600_85hz     = 188,                          /*  800x600  (85 Hz) SVGA timing. */
    timingVESA_1024x768_60hz    = 190,                          /* 1024x768  (60 Hz) VESA 1K-60Hz timing. */
    timingVESA_1024x768_70hz    = 200,                          /* 1024x768  (70 Hz) VESA 1K-70Hz timing. */
    timingVESA_1024x768_75hz    = 204,                          /* 1024x768  (75 Hz) VESA 1K-75Hz timing (very similar to timingApple_1024x768_75hz). */
    timingVESA_1024x768_85hz    = 208,                          /* 1024x768  (85 Hz) VESA timing. */
    timingApple_1024x768_75hz   = 210,                          /* 1024x768  (75 Hz) Apple 19" RGB. */
    timingApple_1152x870_75hz   = 220,                          /* 1152x870  (75 Hz) Apple 21" RGB. */
    timingAppleNTSC_ST          = 230,                          /*  512x384  (60 Hz, interlaced, non-convolved). */
    timingAppleNTSC_FF          = 232,                          /*  640x480  (60 Hz, interlaced, non-convolved). */
    timingAppleNTSC_STconv      = 234,                          /*  512x384  (60 Hz, interlaced, convolved). */
    timingAppleNTSC_FFconv      = 236,                          /*  640x480  (60 Hz, interlaced, convolved). */
    timingApplePAL_ST           = 238,                          /*  640x480  (50 Hz, interlaced, non-convolved). */
    timingApplePAL_FF           = 240,                          /*  768x576  (50 Hz, interlaced, non-convolved). */
    timingApplePAL_STconv       = 242,                          /*  640x480  (50 Hz, interlaced, convolved). */
    timingApplePAL_FFconv       = 244,                          /*  768x576  (50 Hz, interlaced, convolved). */
    timingVESA_1280x960_75hz    = 250,                          /* 1280x960  (75 Hz) */
    timingVESA_1280x960_60hz    = 252,                          /* 1280x960  (60 Hz) */
    timingVESA_1280x960_85hz    = 254,                          /* 1280x960  (85 Hz) */
    timingVESA_1280x1024_60hz   = 260,                          /* 1280x1024 (60 Hz) */
    timingVESA_1280x1024_75hz   = 262,                          /* 1280x1024 (75 Hz) */
    timingVESA_1280x1024_85hz   = 268,                          /* 1280x1024 (85 Hz) */
    timingVESA_1600x1200_60hz   = 280,                          /* 1600x1200 (60 Hz) VESA timing. */
    timingVESA_1600x1200_65hz   = 282,                          /* 1600x1200 (65 Hz) VESA timing. */
    timingVESA_1600x1200_70hz   = 284,                          /* 1600x1200 (70 Hz) VESA timing. */
    timingVESA_1600x1200_75hz   = 286,                          /* 1600x1200 (75 Hz) VESA timing (pixel clock is 189.2 Mhz dot clock). */
    timingVESA_1600x1200_80hz   = 288,                          /* 1600x1200 (80 Hz) VESA timing (pixel clock is 216>? Mhz dot clock) - proposed only. */
    timingVESA_1600x1200_85hz   = 289,                          /* 1600x1200 (85 Hz) VESA timing (pixel clock is 229.5 Mhz dot clock). */
    timingVESA_1792x1344_60hz   = 296,                          /* 1792x1344 (60 Hz) VESA timing (204.75 Mhz dot clock). */
    timingVESA_1792x1344_75hz   = 298,                          /* 1792x1344 (75 Hz) VESA timing (261.75 Mhz dot clock). */
    timingVESA_1856x1392_60hz   = 300,                          /* 1856x1392 (60 Hz) VESA timing (218.25 Mhz dot clock). */
    timingVESA_1856x1392_75hz   = 302,                          /* 1856x1392 (75 Hz) VESA timing (288 Mhz dot clock). */
    timingVESA_1920x1440_60hz   = 304,                          /* 1920x1440 (60 Hz) VESA timing (234 Mhz dot clock). */
    timingVESA_1920x1440_75hz   = 306,                          /* 1920x1440 (75 Hz) VESA timing (297 Mhz dot clock). */
    timingSMPTE240M_60hz        = 400,                          /* 60Hz V, 33.75KHz H, interlaced timing, 16:9 aspect, typical resolution of 1920x1035. */
    timingFilmRate_48hz         = 410,                          /* 48Hz V, 25.20KHz H, non-interlaced timing, typical resolution of 640x480. */
    timingSony_1600x1024_76hz   = 500,                          /* 1600x1024 (76 Hz) Sony timing (pixel clock is 170.447 Mhz dot clock). */
    timingSony_1920x1080_60hz   = 510,                          /* 1920x1080 (60 Hz) Sony timing (pixel clock is 159.84 Mhz dot clock). */
    timingSony_1920x1080_72hz   = 520,                          /* 1920x1080 (72 Hz) Sony timing (pixel clock is 216.023 Mhz dot clock). */
    timingSony_1920x1200_76hz   = 540,                          /* 1900x1200 (76 Hz) Sony timing (pixel clock is 243.20 Mhz dot clock). */
    timingApple_0x0_0hz_Offline = 550                           /* Indicates that this timing will take the display off-line and remove it from the system. */
};


/* Deprecated timing names.*/
enum {
    timingApple12               = timingApple_512x384_60hz,
    timingApple12x              = timingApple_560x384_60hz,
    timingApple13               = timingApple_640x480_67hz,
    timingApple13x              = timingApple_640x400_67hz,
    timingAppleVGA              = timingVESA_640x480_60hz,
    timingApple15               = timingApple_640x870_75hz,
    timingApple15x              = timingApple_640x818_75hz,
    timingApple16               = timingApple_832x624_75hz,
    timingAppleSVGA             = timingVESA_800x600_56hz,
    timingApple1Ka              = timingVESA_1024x768_60hz,
    timingApple1Kb              = timingVESA_1024x768_70hz,
    timingApple19               = timingApple_1024x768_75hz,
    timingApple21               = timingApple_1152x870_75hz,
    timingSony_1900x1200_74hz   = 530,                          /* 1900x1200 (74 Hz) Sony timing (pixel clock is 236.25 Mhz dot clock). */
    timingSony_1900x1200_76hz   = timingSony_1920x1200_76hz     /* 1900x1200 (76 Hz) Sony timing (pixel clock is 245.48 Mhz dot clock). */
};

/* csConnectFlags values in VDDisplayConnectInfo */
enum {
    kAllModesValid              = 0,                            /* All modes not trimmed by primary init are good close enough to try */
    kAllModesSafe               = 1,                            /* All modes not trimmed by primary init are know to be safe */
    kReportsTagging             = 2,                            /* Can detect tagged displays (to identify smart monitors) */
    kHasDirectConnection        = 3,                            /* True implies that driver can talk directly to device (e.g. serial data link via sense lines) */
    kIsMonoDev                  = 4,                            /* Says whether there's an RGB (0) or Monochrome (1) connection. */
    kUncertainConnection        = 5,                            /* There may not be a display (no sense lines?). */
    kTaggingInfoNonStandard     = 6,                            /* Set when csConnectTaggedType/csConnectTaggedData are non-standard (i.e., not the Apple CRT sense codes). */
    kReportsDDCConnection       = 7,                            /* Card can do ddc (set kHasDirectConnect && kHasDDCConnect if you actually found a ddc display). */
    kHasDDCConnection           = 8,                            /* Card has ddc connect now. */
    kConnectionInactive         = 9,                            /* Set when the connection is NOT currently active (generally used in a multiconnection environment). */
    kDependentConnection        = 10,                           /* Set when some ascpect of THIS connection depends on another (will generally be set in a kModeSimulscan environment). */
    kBuiltInConnection          = 11,                           /* Set when connection is KNOWN to be built-in (this is not the same as kHasDirectConnection). */
    kOverrideConnection         = 12,                           /* Set when the reported connection is not the true one, but is one that has been forced through a SetConnection call */
    kFastCheckForDDC            = 13,                           /* Set when all 3 are true: 1) sense codes indicate DDC display could be attached 2) attempted fast check 3) DDC failed */
    kReportsHotPlugging         = 14,                           /* Detects and reports hot pluggging on connector (via VSL also implies DDC will be up to date w/o force read) */
    kStereoSyncConnection       = 15                            /* Connection supports stereo sync signalling */
};


/* csDisplayType values in VDDisplayConnectInfo */
enum {
    kUnknownConnect             = 1,                            /* Not sure how we'll use this, but seems like a good idea. */
    kPanelConnect               = 2,                            /* For use with fixed-in-place LCD panels. */
    kPanelTFTConnect            = 2,                            /* Alias for kPanelConnect */
    kFixedModeCRTConnect        = 3,                            /*  For use with fixed-mode (i.e., very limited range) displays. */
    kMultiModeCRT1Connect       = 4,                            /* 320x200 maybe, 12" maybe, 13" (default), 16" certain, 19" maybe, 21" maybe */
    kMultiModeCRT2Connect       = 5,                            /* 320x200 maybe, 12" maybe, 13" certain, 16" (default), 19" certain, 21" maybe */
    kMultiModeCRT3Connect       = 6,                            /* 320x200 maybe, 12" maybe, 13" certain, 16" certain, 19" default, 21" certain */
    kMultiModeCRT4Connect       = 7,                            /* Expansion to large multi mode (not yet used) */
    kModelessConnect            = 8,                            /* Expansion to modeless model (not yet used) */
    kFullPageConnect            = 9,                            /* 640x818 (to get 8bpp in 512K case) and 640x870 (these two only) */
    kVGAConnect                 = 10,                           /* 640x480 VGA default -- question everything else */
    kNTSCConnect                = 11,                           /* NTSC ST (default), FF, STconv, FFconv */
    kPALConnect                 = 12,                           /* PAL ST (default), FF, STconv, FFconv */
    kHRConnect                  = 13,                           /* Straight-6 connect -- 640x480 and 640x400 (to get 8bpp in 256K case) (these two only) */
    kPanelFSTNConnect           = 14,                           /* For use with fixed-in-place LCD FSTN (aka "Supertwist") panels */
    kMonoTwoPageConnect         = 15,                           /* 1152x870 Apple color two-page display */
    kColorTwoPageConnect        = 16,                           /* 1152x870 Apple B&W two-page display */
    kColor16Connect             = 17,                           /* 832x624 Apple B&W two-page display */
    kColor19Connect             = 18,                           /* 1024x768 Apple B&W two-page display */
    kGenericCRT                 = 19,                           /* Indicates nothing except that connection is CRT in nature. */
    kGenericLCD                 = 20,                           /* Indicates nothing except that connection is LCD in nature. */
    kDDCConnect                 = 21,                           /* DDC connection, always set kHasDDCConnection */
    kNoConnect                  = 22                            /* No display is connected - load sensing or similar level of hardware detection is assumed (used by resident drivers that support hot plugging when nothing is currently connected) */
};

/* csTimingFlags values in VDTimingInfoRec */
enum {
    kModeValid                  = 0,                            /* Says that this mode should NOT be trimmed. */
    kModeSafe                   = 1,                            /* This mode does not need confirmation */
    kModeDefault                = 2,                            /* This is the default mode for this type of connection */
    kModeShowNow                = 3,                            /* This mode should always be shown (even though it may require a confirm) */
    kModeNotResize              = 4,                            /* This mode should not be used to resize the display (eg. mode selects a different connector on card) */
    kModeRequiresPan            = 5,                            /* This mode has more pixels than are actually displayed */
    kModeInterlaced             = 6,                            /* This mode is interlaced (single pixel lines look bad). */
    kModeShowNever              = 7,                            /* This mode should not be shown in the user interface. */
    kModeSimulscan              = 8,                            /* Indicates that more than one display connection can be driven from a single framebuffer controller. */
    kModeNotPreset              = 9,                            /* Indicates that the timing is not a factory preset for the current display (geometry may need correction) */
    kModeBuiltIn                = 10,                           /* Indicates that the display mode is for the built-in connect only (on multiconnect devices like the PB 3400) Only the driver is quieried */
    kModeStretched              = 11,                           /* Indicates that the display mode will be stretched/distorted to match the display aspect ratio */
    kModeNotGraphicsQuality     = 12,                           /* Indicates that the display mode is not the highest quality (eg. stretching artifacts).  Intended as a hint */
    kModeValidateAgainstDisplay = 13                            /* Indicates that this mode should be validated against the display EDID */
};

/* csDepthFlags in VDVideoParametersInfoRec */
enum {
    kDepthDependent             = 0,                            /* Says that this depth mode may cause dependent changes in other framebuffers (and . */
    kDepthDependentMask         = (1 << kDepthDependent)        /* mask for kDepthDependent */    
};

/* csResolutionFlags bit flags for VDResolutionInfoRec */
enum {
    kResolutionHasMultipleDepthSizes = 0                        /* Says that this mode has different csHorizontalPixels, csVerticalLines at different depths (usually slightly larger at lower depths) */
};


enum {
                                                                /*    Power Mode constants for VDPowerStateRec.powerState.  Note the numeric order does not match the power state order */
    kAVPowerOff                 = 0,                            /* Power fully off*/
    kAVPowerStandby             = 1,
    kAVPowerSuspend             = 2,
    kAVPowerOn                  = 3,
    kHardwareSleep              = 128,
    kHardwareWake               = 129,
    kHardwareWakeFromSuspend    = 130,
    kHardwareWakeToDoze         = 131,
    kHardwareWakeToDozeFromSuspend = 132,
    kHardwarePark               = 133,
    kHardwareDrive              = 134
};

/* Reduced perf level, for GetPowerState, SetPowerState*/
enum {
    kPowerStateReducedPowerMask   = 0x00000300,
    kPowerStateFullPower          = 0x00000000,
    kPowerStateReducedPower1      = 0x00000100,
    kPowerStateReducedPower2      = 0x00000200,
    kPowerStateReducedPower3      = 0x00000300
};

enum {
                                                                /*    Power Mode masks and bits for VDPowerStateRec.powerFlags.  */
    kPowerStateNeedsRefresh     = 0,                            /* When leaving this power mode, a display will need refreshing   */
    kPowerStateSleepAwareBit    = 1,                            /* if gestaltPCCardDockingSelectorFix, Docking mgr checks this bit before checking kPowerStateSleepAllowedBit */
    kPowerStateSleepForbiddenBit = 2,                           /* if kPowerStateSleepAwareBit, Docking mgr checks this bit before sleeping */
    kPowerStateSleepCanPowerOffBit = 3,                         /* supports power down sleep (ie PCI power off)*/
    kPowerStateSleepNoDPMSBit   = 4,                            /* Bug #2425210.  Do not use DPMS with this display.*/
    kPowerStateSleepWaketoDozeBit = 5,                          /* Supports Wake to Doze */
    kPowerStateSleepWakeNeedsProbeBit = 6,                      /* Does not sense connection changes on wake */

    kPowerStateNeedsRefreshMask = (1 << kPowerStateNeedsRefresh),
    kPowerStateSleepAwareMask   = (1 << kPowerStateSleepAwareBit),
    kPowerStateSleepForbiddenMask = (1 << kPowerStateSleepForbiddenBit),
    kPowerStateSleepCanPowerOffMask = (1 << kPowerStateSleepCanPowerOffBit),
    kPowerStateSleepNoDPMSMask  = (1 << kPowerStateSleepNoDPMSBit),
    kPowerStateSleepWaketoDozeMask = (1 << kPowerStateSleepWaketoDozeBit),
    kPowerStateSleepWakeNeedsProbeMask = (1 << kPowerStateSleepWakeNeedsProbeBit),

    kPowerStateSupportsReducedPower1Bit = 10,
    kPowerStateSupportsReducedPower2Bit = 11,
    kPowerStateSupportsReducedPower3Bit = 12,
    kPowerStateSupportsReducedPower1BitMask = (1 << 10),
    kPowerStateSupportsReducedPower2BitMask = (1 << 11),
    kPowerStateSupportsReducedPower3BitMask = (1 << 12)
};


enum {
                                                                /* Control Codes */
    cscReset                    = 0,
    cscKillIO                   = 1,
    cscSetMode                  = 2,
    cscSetEntries               = 3,
    cscSetGamma                 = 4,
    cscGrayPage                 = 5,
    cscGrayScreen               = 5,
    cscSetGray                  = 6,
    cscSetInterrupt             = 7,
    cscDirectSetEntries         = 8,
    cscSetDefaultMode           = 9,
    cscSwitchMode               = 10,                           /* Takes a VDSwitchInfoPtr */         
    cscSetSync                  = 11,                           /* Takes a VDSyncInfoPtr */           
    cscSavePreferredConfiguration = 16,                         /* Takes a VDSwitchInfoPtr */         
    cscSetHardwareCursor        = 22,                           /* Takes a VDSetHardwareCursorPtr */  
    cscDrawHardwareCursor       = 23,                           /* Takes a VDDrawHardwareCursorPtr */ 
    cscSetConvolution           = 24,                           /* Takes a VDConvolutionInfoPtr */    
    cscSetPowerState            = 25,                           /* Takes a VDPowerStatePtr */         
    cscPrivateControlCall       = 26,                           /* Takes a VDPrivateSelectorDataRec*/
    cscSetMultiConnect          = 28,                           /* From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.*/
    cscSetClutBehavior          = 29,                           /* Takes a VDClutBehavior */
    cscSetDetailedTiming        = 31,                           /* Takes a VDDetailedTimingPtr */
    cscDoCommunication          = 33,                           /* Takes a VDCommunicationPtr */
    cscProbeConnection          = 34,                           /* Takes nil pointer */
                                                                /* (may generate a kFBConnectInterruptServiceType service interrupt) */
    cscSetScaler                = 36,                           /* Takes a VDScalerPtr */
    cscSetMirror                = 37,                           /* Takes a VDMirrorPtr*/
    cscSetFeatureConfiguration  = 38,                           /* Takes a VDConfigurationPtr*/
    cscUnusedCall               = 127                           /* This call used to expand the scrn resource.  Its imbedded data contains more control info */
};

enum {
                                                                /* Status Codes */
    cscGetMode                  = 2,
    cscGetEntries               = 3,
    cscGetPageCnt               = 4,
    cscGetPages                 = 4,                            /* This is what C&D 2 calls it. */
    cscGetPageBase              = 5,
    cscGetBaseAddr              = 5,                            /* This is what C&D 2 calls it. */
    cscGetGray                  = 6,
    cscGetInterrupt             = 7,
    cscGetGamma                 = 8,
    cscGetDefaultMode           = 9,
    cscGetCurMode               = 10,                           /* Takes a VDSwitchInfoPtr */
    cscGetSync                  = 11,                           /* Takes a VDSyncInfoPtr */  
    cscGetConnection            = 12,                           /* Return information about the connection to the display */
    cscGetModeTiming            = 13,                           /* Return timing info for a mode */
    cscGetModeBaseAddress       = 14,                           /* Return base address information about a particular mode */
    cscGetScanProc              = 15,                           /* QuickTime scan chasing routine */
    cscGetPreferredConfiguration = 16,                          /* Takes a VDSwitchInfoPtr */               
    cscGetNextResolution        = 17,                           /* Takes a VDResolutionInfoPtr */           
    cscGetVideoParameters       = 18,                           /* Takes a VDVideoParametersInfoPtr */      
    cscGetGammaInfoList         = 20,                           /* Takes a VDGetGammaListPtr */             
    cscRetrieveGammaTable       = 21,                           /* Takes a VDRetrieveGammaPtr */            
    cscSupportsHardwareCursor   = 22,                           /* Takes a VDSupportsHardwareCursorPtr */   
    cscGetHardwareCursorDrawState = 23,                         /* Takes a VDHardwareCursorDrawStatePtr */  
    cscGetConvolution           = 24,                           /* Takes a VDConvolutionInfoPtr */          
    cscGetPowerState            = 25,                           /* Takes a VDPowerStatePtr */               
    cscPrivateStatusCall        = 26,                           /* Takes a VDPrivateSelectorDataRec*/
    cscGetDDCBlock              = 27,                           /* Takes a VDDDCBlockRec  */
    cscGetMultiConnect          = 28,                           /* From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.*/
    cscGetClutBehavior          = 29,                           /* Takes a VDClutBehavior */
    cscGetTimingRanges          = 30,                           /* Takes a VDDisplayTimingRangePtr */
    cscGetDetailedTiming        = 31,                           /* Takes a VDDetailedTimingPtr */
    cscGetCommunicationInfo     = 32,                           /* Takes a VDCommunicationInfoPtr */
    cscGetScalerInfo            = 35,                           /* Takes a VDScalerInfoPtr */
    cscGetScaler                = 36,                           /* Takes a VDScalerPtr */
    cscGetMirror                = 37,                           /* Takes a VDMirrorPtr*/
    cscGetFeatureConfiguration  = 38,                           /* Takes a VDConfigurationPtr*/
    cscGetFeatureList           = 39
};

/* Bit definitions for the Get/Set Sync call*/
enum {
    kDisableHorizontalSyncBit   = 0,
    kDisableVerticalSyncBit     = 1,
    kDisableCompositeSyncBit    = 2,
    kEnableSyncOnBlue           = 3,
    kEnableSyncOnGreen          = 4,
    kEnableSyncOnRed            = 5,
    kNoSeparateSyncControlBit   = 6,
    kTriStateSyncBit            = 7,
    kHorizontalSyncMask         = 0x01,
    kVerticalSyncMask           = 0x02,
    kCompositeSyncMask          = 0x04,
    kDPMSSyncMask               = 0x07,
    kTriStateSyncMask           = 0x80,
    kSyncOnBlueMask             = 0x08,
    kSyncOnGreenMask            = 0x10,
    kSyncOnRedMask              = 0x20,
    kSyncOnMask                 = 0x38
};

enum {
                                                                /*    Power Mode constants for translating DPMS modes to Get/SetSync calls.  */
    kDPMSSyncOn                 = 0,
    kDPMSSyncStandby            = 1,
    kDPMSSyncSuspend            = 2,
    kDPMSSyncOff                = 7
};

/* Bit definitions for the Get/Set Convolution call*/
enum {
    kConvolved                  = 0,
    kLiveVideoPassThru          = 1,
    kConvolvedMask              = 0x01,
    kLiveVideoPassThruMask      = 0x02
};



struct VPBlock {
    UInt32                           vpBaseOffset;               /*Offset to page zero of video RAM (From minorBaseOS).*/
#if __LP64__
    UInt32                           vpRowBytes;                 /*Width of each row of video memory.*/
#else
    SInt16                           vpRowBytes;                 /*Width of each row of video memory.*/
#endif
    Rect                            vpBounds;                   /*BoundsRect for the video display (gives dimensions).*/
    SInt16                           vpVersion;                  /*PixelMap version number.*/
    SInt16                           vpPackType;
    UInt32                           vpPackSize;
    UInt32                            vpHRes;                     /*Horizontal resolution of the device (pixels per inch).*/
    UInt32                            vpVRes;                     /*Vertical resolution of the device (pixels per inch).*/
    SInt16                           vpPixelType;                /*Defines the pixel type.*/
    SInt16                           vpPixelSize;                /*Number of bits in pixel.*/
    SInt16                           vpCmpCount;                 /*Number of components in pixel.*/
    SInt16                           vpCmpSize;                  /*Number of bits per component*/
    UInt32                            vpPlaneBytes;               /*Offset from one plane to the next.*/
};
typedef struct VPBlock                  VPBlock;
typedef VPBlock *                       VPBlockPtr;

struct VDEntryRecord {
    Ptr                             csTable;                    /* pointer to color table entry=value, r,g,b:INTEGER*/
};
typedef struct VDEntryRecord            VDEntryRecord;

typedef VDEntryRecord *                 VDEntRecPtr;
/* Parm block for SetGray control call */

struct VDGrayRecord {
    Boolean                         csMode;                     /*Same as GDDevType value (0=color, 1=mono)*/
    SInt8                           filler;
};
typedef struct VDGrayRecord             VDGrayRecord;

typedef VDGrayRecord *                  VDGrayPtr;
/* Parm block for SetInterrupt call */

struct VDFlagRecord {
    SInt8                           csMode;
    SInt8                           filler;
};
typedef struct VDFlagRecord             VDFlagRecord;

typedef VDFlagRecord *                  VDFlagRecPtr;
/* Parm block for SetEntries control call */

struct VDSetEntryRecord {
    ColorSpec *                     csTable;                    /*Pointer to an array of color specs*/
    SInt16                           csStart;                    /*Which spec in array to start with, or -1*/
    SInt16                           csCount;                    /*Number of color spec entries to set*/
};
typedef struct VDSetEntryRecord         VDSetEntryRecord;

typedef VDSetEntryRecord *              VDSetEntryPtr;
/* Parm block for SetGamma control call */

struct VDGammaRecord {
    Ptr                             csGTable;                   /*pointer to gamma table*/
};
typedef struct VDGammaRecord            VDGammaRecord;

typedef VDGammaRecord *                 VDGamRecPtr;

struct VDSwitchInfoRec {
    DepthMode                  csMode;                     /* mode depth*/
    DisplayModeID                   csData;                     /* functional sResource of mode*/
    UInt16                  csPage;                     /* page to switch in*/
    Ptr                             csBaseAddr;                 /* base address of page (return value)*/
    uintptr_t                   csReserved;                 /* Reserved (set to 0) */
};
typedef struct VDSwitchInfoRec          VDSwitchInfoRec;

typedef VDSwitchInfoRec *               VDSwitchInfoPtr;

struct VDTimingInfoRec {
    DisplayModeID                   csTimingMode;               /* timing mode (a la InitGDevice) */
    uintptr_t                   csTimingReserved;           /* reserved */
    UInt32                   csTimingFormat;             /* what format is the timing info */
    UInt32                   csTimingData;               /* data supplied by driver */
    UInt32                   csTimingFlags;              /* mode within device */
};
typedef struct VDTimingInfoRec          VDTimingInfoRec;

typedef VDTimingInfoRec *               VDTimingInfoPtr;

struct VDDisplayConnectInfoRec {
    UInt16                  csDisplayType;              /* Type of display connected */
    UInt8                   csConnectTaggedType;        /* type of tagging */
    UInt8                   csConnectTaggedData;        /* tagging data */
    UInt32                   csConnectFlags;             /* tell us about the connection */
    uintptr_t                   csDisplayComponent;         /* if the card has a direct connection to the display, it returns the display component here (FUTURE) */
    uintptr_t                   csConnectReserved;          /* reserved */
};
typedef struct VDDisplayConnectInfoRec  VDDisplayConnectInfoRec;

typedef VDDisplayConnectInfoRec *       VDDisplayConnectInfoPtr;

struct VDMultiConnectInfoRec {
    UInt32                   csDisplayCountOrNumber;     /* For GetMultiConnect, returns count n of 1..n connections; otherwise, indicates the ith connection.*/
    VDDisplayConnectInfoRec         csConnectInfo;              /* Standard VDDisplayConnectionInfo for connection i.*/
};
typedef struct VDMultiConnectInfoRec    VDMultiConnectInfoRec;

typedef VDMultiConnectInfoRec *         VDMultiConnectInfoPtr;
/* RawSenseCode
    This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
    for the possible raw sense code values when 'standard' sense code hardware is implemented.

    For 'standard' sense code hardware, the raw sense is obtained as follows:
        o Instruct the frame buffer controller NOT to actively drive any of the monitor sense lines
        o Read the state of the monitor sense lines 2, 1, and 0.  (2 is the MSB, 0 the LSB)

    IMPORTANT Note: 
    When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
    are valid 'csConnectTaggedType' values in 'VDDisplayConnectInfo' 

*/
typedef UInt8                   RawSenseCode;
enum {
    kRSCZero                    = 0,
    kRSCOne                     = 1,
    kRSCTwo                     = 2,
    kRSCThree                   = 3,
    kRSCFour                    = 4,
    kRSCFive                    = 5,
    kRSCSix                     = 6,
    kRSCSeven                   = 7
};


/* ExtendedSenseCode
    This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
    for the values which are possible when the extended sense algorithm is applied to hardware
    which implements 'standard' sense code hardware.

    For 'standard' sense code hardware, the extended sense code algorithm is as follows:
    (Note:  as described here, sense line 'A' corresponds to '2', 'B' to '1', and 'C' to '0')
        o Drive sense line 'A' low and read the values of 'B' and 'C'.  
        o Drive sense line 'B' low and read the values of 'A' and 'C'.
        o Drive sense line 'C' low and read the values of 'A' and 'B'.

    In this way, a six-bit number of the form BC/AC/AB is generated. 

    IMPORTANT Note: 
    When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
    are valid 'csConnectTaggedData' values in 'VDDisplayConnectInfo' 

*/
typedef UInt8                   ExtendedSenseCode;
enum {
    kESCZero21Inch              = 0x00,                         /* 21" RGB                     */
    kESCOnePortraitMono         = 0x14,                         /* Portrait Monochrome              */
    kESCTwo12Inch               = 0x21,                         /* 12" RGB                    */
    kESCThree21InchRadius       = 0x31,                         /* 21" RGB (Radius)               */
    kESCThree21InchMonoRadius   = 0x34,                         /* 21" Monochrome (Radius)           */
    kESCThree21InchMono         = 0x35,                         /* 21" Monochrome               */
    kESCFourNTSC                = 0x0A,                         /* NTSC                     */
    kESCFivePortrait            = 0x1E,                         /* Portrait RGB              */
    kESCSixMSB1                 = 0x03,                         /* MultiScan Band-1 (12" thru 1Six")  */
    kESCSixMSB2                 = 0x0B,                         /* MultiScan Band-2 (13" thru 19")       */
    kESCSixMSB3                 = 0x23,                         /* MultiScan Band-3 (13" thru 21")       */
    kESCSixStandard             = 0x2B,                         /* 13"/14" RGB or 12" Monochrome   */
    kESCSevenPAL                = 0x00,                         /* PAL                        */
    kESCSevenNTSC               = 0x14,                         /* NTSC                     */
    kESCSevenVGA                = 0x17,                         /* VGA                        */
    kESCSeven16Inch             = 0x2D,                         /* 16" RGB (GoldFish)               */
    kESCSevenPALAlternate       = 0x30,                         /* PAL (Alternate)                */
    kESCSeven19Inch             = 0x3A,                         /* Third-Party 19"                 */
    kESCSevenDDC                = 0x3E,                         /* DDC display                   */
    kESCSevenNoDisplay          = 0x3F                          /* No display connected           */
};

/* DepthMode
    This abstract data type is used to to reference RELATIVE pixel depths.
    Its definition is largely derived from its past usage, analogous to 'xxxVidMode'

    Bits per pixel DOES NOT directly map to 'DepthMode'  For example, on some
    graphics hardware, 'kDepthMode1' may represent 1 BPP, whereas on other
    hardware, 'kDepthMode1' may represent 8BPP.

    DepthMode IS considered to be ordinal, i.e., operations such as <, >, ==, etc.
    behave as expected.  The values of the constants which comprise the set are such
    that 'kDepthMode4 < kDepthMode6' behaves as expected.
*/
enum {
    kDepthMode1                 = 128,
    kDepthMode2                 = 129,
    kDepthMode3                 = 130,
    kDepthMode4                 = 131,
    kDepthMode5                 = 132,
    kDepthMode6                 = 133
};

enum {
    kFirstDepthMode             = 128,                          /* These constants are obsolete, and just included    */
    kSecondDepthMode            = 129,                          /* for clients that have converted to the above     */
    kThirdDepthMode             = 130,                          /* kDepthModeXXX constants.                */
    kFourthDepthMode            = 131,
    kFifthDepthMode             = 132,
    kSixthDepthMode             = 133
};



struct VDPageInfo {
    DepthMode                           csMode;                     /* mode within device*/
    DisplayModeID                            csData;                     /* data supplied by driver*/
    SInt16                           csPage;                     /* page to switch in*/
    Ptr                             csBaseAddr;                 /* base address of page*/
};
typedef struct VDPageInfo               VDPageInfo;

typedef VDPageInfo *                    VDPgInfoPtr;

struct VDSizeInfo {
    SInt16                           csHSize;                    /* desired/returned h size*/
    SInt16                           csHPos;                     /* desired/returned h position*/
    SInt16                           csVSize;                    /* desired/returned v size*/
    SInt16                           csVPos;                     /* desired/returned v position*/
};
typedef struct VDSizeInfo               VDSizeInfo;

typedef VDSizeInfo *                    VDSzInfoPtr;

struct VDSettings {
    SInt16                           csParamCnt;                 /* number of params*/
    SInt16                           csBrightMax;                /* max brightness*/
    SInt16                           csBrightDef;                /* default brightness*/
    SInt16                           csBrightVal;                /* current brightness*/
    SInt16                           csCntrstMax;                /* max contrast*/
    SInt16                           csCntrstDef;                /* default contrast*/
    SInt16                           csCntrstVal;                /* current contrast*/
    SInt16                           csTintMax;                  /* max tint*/
    SInt16                           csTintDef;                  /* default tint*/
    SInt16                           csTintVal;                  /* current tint*/
    SInt16                           csHueMax;                   /* max hue*/
    SInt16                           csHueDef;                   /* default hue*/
    SInt16                           csHueVal;                   /* current hue*/
    SInt16                           csHorizDef;                 /* default horizontal*/
    SInt16                           csHorizVal;                 /* current horizontal*/
    SInt16                           csHorizMax;                 /* max horizontal*/
    SInt16                           csVertDef;                  /* default vertical*/
    SInt16                           csVertVal;                  /* current vertical*/
    SInt16                           csVertMax;                  /* max vertical*/
};
typedef struct VDSettings               VDSettings;
typedef VDSettings *                    VDSettingsPtr;

struct VDDefMode {
    UInt8                           csID;
    SInt8                           filler;
};
typedef struct VDDefMode                VDDefMode;
typedef VDDefMode *                     VDDefModePtr;

struct VDSyncInfoRec {
    UInt8                           csMode;
    UInt8                           csFlags;
};
typedef struct VDSyncInfoRec            VDSyncInfoRec;

typedef VDSyncInfoRec *                 VDSyncInfoPtr;
/*
   All displayModeID values from 0x80000000 to 0xFFFFFFFF and 0x00
   are reserved for Apple Computer.
*/
/* Constants for the cscGetNextResolution call */
enum {
    kDisplayModeIDCurrent       = 0x00,                         /* Reference the Current DisplayModeID */
    kDisplayModeIDInvalid       = (IODisplayModeID)0xFFFFFFFF,             /* A bogus DisplayModeID in all cases */
    kDisplayModeIDFindFirstResolution = (IODisplayModeID)0xFFFFFFFE,       /* Used in cscGetNextResolution to reset iterator */
    kDisplayModeIDNoMoreResolutions = (IODisplayModeID)0xFFFFFFFD,         /* Used in cscGetNextResolution to indicate End Of List */
    kDisplayModeIDFindFirstProgrammable = (IODisplayModeID)0xFFFFFFFC,     /* Used in cscGetNextResolution to find unused programmable timing */
    kDisplayModeIDBootProgrammable = (IODisplayModeID)0xFFFFFFFB,          /* This is the ID given at boot time by the OF driver to a programmable timing */
    kDisplayModeIDReservedBase  = (IODisplayModeID)0x80000000              /* Lowest (unsigned) DisplayModeID reserved by Apple */
};

/* Constants for the GetGammaInfoList call */
enum {
    kGammaTableIDFindFirst      = (GammaTableID)0xFFFFFFFE,             /* Get the first gamma table ID */
    kGammaTableIDNoMoreTables   = (GammaTableID)0xFFFFFFFD,             /* Used to indicate end of list */
    kGammaTableIDSpecific       = 0x00                          /* Return the info for the given table id */
};

/* Constants for GetMultiConnect call*/
enum {
    kGetConnectionCount         = 0xFFFFFFFF,             /* Used to get the number of possible connections in a "multi-headed" framebuffer environment.*/
    kActivateConnection         = (0 << kConnectionInactive),   /* Used for activating a connection (csConnectFlags value).*/
    kDeactivateConnection       = (1 << kConnectionInactive)    /* Used for deactivating a connection (csConnectFlags value.)*/
};

/* VDCommunicationRec.csBusID values*/
enum {
    kVideoDefaultBus            = 0
};


/* VDCommunicationInfoRec.csBusType values*/
enum {
    kVideoBusTypeInvalid        = 0,
    kVideoBusTypeI2C            = 1,
    kVideoBusTypeDisplayPort    = 2
};


/* VDCommunicationRec.csSendType and VDCommunicationRec.csReplyType values*/
enum {
    kVideoNoTransactionType     = 0,    /* No transaction*/
    kVideoNoTransactionTypeMask = (1 << kVideoNoTransactionType),
    kVideoSimpleI2CType         = 1,    /* Simple I2C message*/
    kVideoSimpleI2CTypeMask     = (1 << kVideoSimpleI2CType),
    kVideoDDCciReplyType        = 2,    /* DDC/ci message (with imbedded length)*/
    kVideoDDCciReplyTypeMask    = (1 << kVideoDDCciReplyType),
    kVideoCombinedI2CType       = 3,    /* Combined format I2C R/~W transaction*/
    kVideoCombinedI2CTypeMask   = (1 << kVideoCombinedI2CType),
    kVideoDisplayPortNativeType       = 4,    /* DisplayPort Native */
    kVideoDisplayPortNativeTypeMask   = (1 << kVideoDisplayPortNativeType)
};

// VDCommunicationRec.csCommFlags and VDCommunicationInfoRec.csSupportedCommFlags
enum {
    kVideoReplyMicroSecDelayBit   = 0,    /* If bit set, the driver should delay csMinReplyDelay micro seconds between send and receive*/
    kVideoReplyMicroSecDelayMask  = (1 << kVideoReplyMicroSecDelayBit),
    kVideoUsageAddrSubAddrBit     = 1,    /* If bit set, the driver understands to use the lower 16 bits of the address field as two 8 bit values (address/subaddress) for the I2C transaction*/
    kVideoUsageAddrSubAddrMask    = (1 << kVideoUsageAddrSubAddrBit)
};


struct VDResolutionInfoRec {
    DisplayModeID                   csPreviousDisplayModeID;    /* ID of the previous resolution in a chain */
    DisplayModeID                   csDisplayModeID;            /* ID of the next resolution */
    UInt32                   csHorizontalPixels;         /* # of pixels in a horizontal line at the max depth */
    UInt32                   csVerticalLines;            /* # of lines in a screen at the max depth */
    Fixed                           csRefreshRate;              /* Vertical Refresh Rate in Hz */
    DepthMode                       csMaxDepthMode;             /* 0x80-based number representing max bit depth */
    UInt32                   csResolutionFlags;          /* Reserved - flag bits */
    uintptr_t                   csReserved;                 /* Reserved */
};
typedef struct VDResolutionInfoRec      VDResolutionInfoRec;

typedef VDResolutionInfoRec *           VDResolutionInfoPtr;

struct VDVideoParametersInfoRec {
    DisplayModeID                   csDisplayModeID;            /* the ID of the resolution we want info on */
    DepthMode                       csDepthMode;                /* The bit depth we want the info on (0x80 based) */
    VPBlockPtr                      csVPBlockPtr;               /* Pointer to a video parameter block */
    UInt32                   csPageCount;                /* Number of pages supported by the resolution */
    VideoDeviceType                 csDeviceType;               /* Device Type:  Direct, Fixed or CLUT; */
    UInt32                          csDepthFlags;               /* Flags */
};
typedef struct VDVideoParametersInfoRec VDVideoParametersInfoRec;

typedef VDVideoParametersInfoRec *      VDVideoParametersInfoPtr;

struct VDGammaInfoRec {
    GammaTableID                    csLastGammaID;              /* the ID of the previous gamma table */
    GammaTableID                    csNextGammaID;              /* the ID of the next gamma table */
    Ptr                             csGammaPtr;                 /* Ptr to a gamma table data */
    uintptr_t                   csReserved;                 /* Reserved */
};
typedef struct VDGammaInfoRec           VDGammaInfoRec;

typedef VDGammaInfoRec *                VDGammaInfoPtr;

struct VDGetGammaListRec {
    GammaTableID                    csPreviousGammaTableID;     /* ID of the previous gamma table */
    GammaTableID                    csGammaTableID;             /* ID of the gamma table following csPreviousDisplayModeID */
    UInt32                   csGammaTableSize;           /* Size of the gamma table in bytes */
    char *                          csGammaTableName;           /* Gamma table name (c-string) */
};
typedef struct VDGetGammaListRec        VDGetGammaListRec;

typedef VDGetGammaListRec *             VDGetGammaListPtr;

struct VDRetrieveGammaRec {
    GammaTableID                    csGammaTableID;             /* ID of gamma table to retrieve */
    GammaTbl *                      csGammaTablePtr;            /* Location to copy desired gamma to */
};
typedef struct VDRetrieveGammaRec       VDRetrieveGammaRec;

typedef VDRetrieveGammaRec *            VDRetrieveGammaPtr;

struct VDSetHardwareCursorRec {
    void *                          csCursorRef;                /* reference to cursor data */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* should be ignored */
};
typedef struct VDSetHardwareCursorRec   VDSetHardwareCursorRec;

typedef VDSetHardwareCursorRec *        VDSetHardwareCursorPtr;

struct VDDrawHardwareCursorRec {
    SInt32                          csCursorX;                  /* x coordinate */
    SInt32                          csCursorY;                  /* y coordinate */
    UInt32                          csCursorVisible;            /* true if cursor is must be visible */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* should be ignored */
};
typedef struct VDDrawHardwareCursorRec  VDDrawHardwareCursorRec;

typedef VDDrawHardwareCursorRec *       VDDrawHardwareCursorPtr;

struct VDSupportsHardwareCursorRec {
    UInt32                          csSupportsHardwareCursor;
                                                                /* true if hardware cursor is supported */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* must be zero */
};
typedef struct VDSupportsHardwareCursorRec VDSupportsHardwareCursorRec;

typedef VDSupportsHardwareCursorRec *   VDSupportsHardwareCursorPtr;

struct VDHardwareCursorDrawStateRec {
    SInt32                          csCursorX;                  /* x coordinate */
    SInt32                          csCursorY;                  /* y coordinate */
    UInt32                          csCursorVisible;            /* true if cursor is visible */
    UInt32                          csCursorSet;                /* true if cursor successfully set by last set control call */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* must be zero */
};
typedef struct VDHardwareCursorDrawStateRec VDHardwareCursorDrawStateRec;

typedef VDHardwareCursorDrawStateRec *  VDHardwareCursorDrawStatePtr;

struct VDConvolutionInfoRec {
    DisplayModeID                   csDisplayModeID;            /* the ID of the resolution we want info on */
    DepthMode                       csDepthMode;                /* The bit depth we want the info on (0x80 based) */
    UInt32                   csPage;
    UInt32                          csFlags;
    UInt32                          csReserved;
};
typedef struct VDConvolutionInfoRec     VDConvolutionInfoRec;

typedef VDConvolutionInfoRec *          VDConvolutionInfoPtr;

struct VDPowerStateRec {
    UInt32                   powerState;
    UInt32                   powerFlags;

    uintptr_t                powerReserved1;
    uintptr_t                powerReserved2;
};
typedef struct VDPowerStateRec          VDPowerStateRec;

typedef VDPowerStateRec *               VDPowerStatePtr;
/*
    Private Data to video drivers.
    
    In versions of MacOS with multiple address spaces (System 8), the OS 
    must know the extent of parameters in order to move them between the caller
    and driver.  The old private-selector model for video drivers does not have
    this information so:
    
    For post-7.x Systems private calls should be implemented using the cscPrivateCall
*/

struct VDPrivateSelectorDataRec {
    LogicalAddress                  privateParameters;          /* Caller's parameters*/
    ByteCount                       privateParametersSize;      /* Size of data sent from caller to driver*/
    LogicalAddress                  privateResults;             /* Caller's return area. Can be nil, or same as privateParameters.*/
    ByteCount                       privateResultsSize;         /* Size of data driver returns to caller. Can be nil, or same as privateParametersSize.*/
};
typedef struct VDPrivateSelectorDataRec VDPrivateSelectorDataRec;


struct VDPrivateSelectorRec {
    UInt32                          reserved;                   /* Reserved (set to 0). */
    VDPrivateSelectorDataRec        data[1];
};
typedef struct VDPrivateSelectorRec     VDPrivateSelectorRec;

struct VDDDCBlockRec {
    UInt32                          ddcBlockNumber;             /* Input -- DDC EDID (Extended Display Identification Data) number (1-based) */
    ResType                         ddcBlockType;               /* Input -- DDC block type (EDID/VDIF) */
    UInt32                          ddcFlags;                   /* Input -- DDC Flags*/
    UInt32                          ddcReserved;                /* Reserved */
    Byte                            ddcBlockData[128];          /* Output -- DDC EDID/VDIF data (kDDCBlockSize) */
};
typedef struct VDDDCBlockRec            VDDDCBlockRec;

typedef VDDDCBlockRec *                 VDDDCBlockPtr;

enum {
                                                                /* timingSyncConfiguration*/
    kSyncInterlaceMask          = (1 << 7),
    kSyncAnalogCompositeMask    = 0,
    kSyncAnalogCompositeSerrateMask = (1 << 2),
    kSyncAnalogCompositeRGBSyncMask = (1 << 1),
    kSyncAnalogBipolarMask      = (1 << 3),
    kSyncAnalogBipolarSerrateMask = (1 << 2),
    kSyncAnalogBipolarSRGBSyncMask = (1 << 1),
    kSyncDigitalCompositeMask   = (1 << 4),
    kSyncDigitalCompositeSerrateMask = (1 << 2),
    kSyncDigitalCompositeMatchHSyncMask = (1 << 2),
    kSyncDigitalSeperateMask    = (1 << 4) + (1 << 3),
    kSyncDigitalVSyncPositiveMask = (1 << 2),
    kSyncDigitalHSyncPositiveMask = (1 << 1)
};




struct VDDisplayTimingRangeRec {
    UInt32                          csRangeSize;                /* Init to sizeof(VDDisplayTimingRangeRec) */
    UInt32                          csRangeType;                /* Init to 0 */
    UInt32                          csRangeVersion;             /* Init to 0 */
    UInt32                          csRangeReserved;            /* Init to 0 */

    UInt32                          csRangeBlockIndex;          /* Requested block (first index is 0)*/
    UInt32                          csRangeGroup;               /* set to 0 */
    UInt32                          csRangeBlockCount;          /* # blocks */
    UInt32                          csRangeFlags;               /* dependent video */

    UInt64                          csMinPixelClock;            /* Min dot clock in Hz */
    UInt64                          csMaxPixelClock;            /* Max dot clock in Hz */

    UInt32                          csMaxPixelError;            /* Max dot clock error */
    UInt32                          csTimingRangeSyncFlags;
    UInt32                          csTimingRangeSignalLevels;
    UInt32                          csTimingRangeSupportedSignalConfigs;

    UInt32                          csMinFrameRate;             /* Hz */
    UInt32                          csMaxFrameRate;             /* Hz */
    UInt32                          csMinLineRate;              /* Hz */
    UInt32                          csMaxLineRate;              /* Hz */


    UInt32                          csMaxHorizontalTotal;       /* Clocks - Maximum total (active + blanking) */
    UInt32                          csMaxVerticalTotal;         /* Clocks - Maximum total (active + blanking) */
    UInt32                          csMaxTotalReserved1;        /* Reserved */
    UInt32                          csMaxTotalReserved2;        /* Reserved */



                                                                /* Some cards require that some timing elements*/
                                                                /* be multiples of a "character size" (often 8*/
                                                                /* clocks).  The "xxxxCharSize" fields document*/
                                                                /* those requirements.*/


    UInt8                           csCharSizeHorizontalActive; /* Character size */
    UInt8                           csCharSizeHorizontalBlanking; /* Character size */
    UInt8                           csCharSizeHorizontalSyncOffset; /* Character size */
    UInt8                           csCharSizeHorizontalSyncPulse; /* Character size */

    UInt8                           csCharSizeVerticalActive;   /* Character size */
    UInt8                           csCharSizeVerticalBlanking; /* Character size */
    UInt8                           csCharSizeVerticalSyncOffset; /* Character size */
    UInt8                           csCharSizeVerticalSyncPulse; /* Character size */

    UInt8                           csCharSizeHorizontalBorderLeft; /* Character size */
    UInt8                           csCharSizeHorizontalBorderRight; /* Character size */
    UInt8                           csCharSizeVerticalBorderTop; /* Character size */
    UInt8                           csCharSizeVerticalBorderBottom; /* Character size */

    UInt8                           csCharSizeHorizontalTotal;  /* Character size for active + blanking */
    UInt8                           csCharSizeVerticalTotal;    /* Character size for active + blanking */
    UInt16                          csCharSizeReserved1;        /* Reserved (Init to 0) */


    UInt32                          csMinHorizontalActiveClocks;
    UInt32                          csMaxHorizontalActiveClocks;
    UInt32                          csMinHorizontalBlankingClocks;
    UInt32                          csMaxHorizontalBlankingClocks;

    UInt32                          csMinHorizontalSyncOffsetClocks;
    UInt32                          csMaxHorizontalSyncOffsetClocks;
    UInt32                          csMinHorizontalPulseWidthClocks;
    UInt32                          csMaxHorizontalPulseWidthClocks;

    UInt32                          csMinVerticalActiveClocks;
    UInt32                          csMaxVerticalActiveClocks;
    UInt32                          csMinVerticalBlankingClocks;
    UInt32                          csMaxVerticalBlankingClocks;

    UInt32                          csMinVerticalSyncOffsetClocks;
    UInt32                          csMaxVerticalSyncOffsetClocks;
    UInt32                          csMinVerticalPulseWidthClocks;
    UInt32                          csMaxVerticalPulseWidthClocks;


    UInt32                          csMinHorizontalBorderLeft;
    UInt32                          csMaxHorizontalBorderLeft;
    UInt32                          csMinHorizontalBorderRight;
    UInt32                          csMaxHorizontalBorderRight;

    UInt32                          csMinVerticalBorderTop;
    UInt32                          csMaxVerticalBorderTop;
    UInt32                          csMinVerticalBorderBottom;
    UInt32                          csMaxVerticalBorderBottom;

    UInt32                          csMaxNumLinks;                /* number of links, if zero, assume link 1 */
    UInt32                          csMinLink0PixelClock;         /* min pixel clock for link 0 (kHz) */
    UInt32                          csMaxLink0PixelClock;         /* max pixel clock for link 0 (kHz) */
    UInt32                          csMinLink1PixelClock;         /* min pixel clock for link 1 (kHz) */
    UInt32                          csMaxLink1PixelClock;         /* max pixel clock for link 1 (kHz) */

    UInt32                          csReserved6;                /* Reserved (Init to 0)*/
    UInt32                          csReserved7;                /* Reserved (Init to 0)*/
    UInt32                          csReserved8;                /* Reserved (Init to 0)*/
};
typedef struct VDDisplayTimingRangeRec  VDDisplayTimingRangeRec;

typedef VDDisplayTimingRangeRec *       VDDisplayTimingRangePtr;

enum {
                                                                /* csDisplayModeState*/
    kDMSModeReady               = 0,                            /* Display Mode ID is configured and ready*/
    kDMSModeNotReady            = 1,                            /* Display Mode ID is is being programmed*/
    kDMSModeFree                = 2                             /* Display Mode ID is not associated with a timing*/
};


/* Video driver Errors -10930 to -10959 */
enum {
    kTimingChangeRestrictedErr  = -10930,
    kVideoI2CReplyPendingErr    = -10931,
    kVideoI2CTransactionErr     = -10932,
    kVideoI2CBusyErr            = -10933,
    kVideoI2CTransactionTypeErr = -10934,
    kVideoBufferSizeErr         = -10935,
    kVideoCannotMirrorErr       = -10936
};


enum {
                                                                /* csTimingRangeSignalLevels*/
    kRangeSupportsSignal_0700_0300_Bit = 0,
    kRangeSupportsSignal_0714_0286_Bit = 1,
    kRangeSupportsSignal_1000_0400_Bit = 2,
    kRangeSupportsSignal_0700_0000_Bit = 3,
    kRangeSupportsSignal_0700_0300_Mask = (1 << kRangeSupportsSignal_0700_0300_Bit),
    kRangeSupportsSignal_0714_0286_Mask = (1 << kRangeSupportsSignal_0714_0286_Bit),
    kRangeSupportsSignal_1000_0400_Mask = (1 << kRangeSupportsSignal_1000_0400_Bit),
    kRangeSupportsSignal_0700_0000_Mask = (1 << kRangeSupportsSignal_0700_0000_Bit)
};


enum {
                                                                /* csSignalConfig*/
    kDigitalSignalBit            = 0,                            /* Do not set.  Mac OS does not currently support arbitrary digital timings*/
    kAnalogSetupExpectedBit      = 1,                            /* Analog displays - display expects a blank-to-black setup or pedestal.  See VESA signal standards.*/
    kInterlacedCEA861SyncModeBit = 2,

    kDigitalSignalMask            = (1 << kDigitalSignalBit),
    kAnalogSetupExpectedMask      = (1 << kAnalogSetupExpectedBit),
    kInterlacedCEA861SyncModeMask = (1 << kInterlacedCEA861SyncModeBit)
};


enum {
                                                                /* csSignalLevels for analog*/
    kAnalogSignalLevel_0700_0300 = 0,
    kAnalogSignalLevel_0714_0286 = 1,
    kAnalogSignalLevel_1000_0400 = 2,
    kAnalogSignalLevel_0700_0000 = 3
};


enum {
                                                                /* csTimingRangeSyncFlags*/
    kRangeSupportsSeperateSyncsBit = 0,
    kRangeSupportsSyncOnGreenBit = 1,
    kRangeSupportsCompositeSyncBit = 2,
    kRangeSupportsVSyncSerrationBit = 3,
    kRangeSupportsSeperateSyncsMask = (1 << kRangeSupportsSeperateSyncsBit),
    kRangeSupportsSyncOnGreenMask = (1 << kRangeSupportsSyncOnGreenBit),
    kRangeSupportsCompositeSyncMask = (1 << kRangeSupportsCompositeSyncBit),
    kRangeSupportsVSyncSerrationMask = (1 << kRangeSupportsVSyncSerrationBit)
};



enum {
                                                                /* csHorizontalSyncConfig and csVerticalSyncConfig*/
    kSyncPositivePolarityBit    = 0,                            /* Digital separate sync polarity for analog interfaces (0 => negative polarity)*/
    kSyncPositivePolarityMask   = (1 << kSyncPositivePolarityBit)
};




/* For timings with kDetailedTimingFormat.*/

struct VDDetailedTimingRec {
    UInt32                          csTimingSize;               /* Init to sizeof(VDDetailedTimingRec)*/
    UInt32                          csTimingType;               /* Init to 0*/
    UInt32                          csTimingVersion;            /* Init to 0*/
    UInt32                          csTimingReserved;           /* Init to 0*/

    DisplayModeID                   csDisplayModeID;            /* Init to 0*/
    UInt32                          csDisplayModeSeed;          /* */
    UInt32                          csDisplayModeState;         /* Display Mode state*/
    UInt32                          csDisplayModeAlias;         /* Mode to use when programmed.*/

    UInt32                          csSignalConfig;
    UInt32                          csSignalLevels;

    UInt64                          csPixelClock;               /* Hz*/

    UInt64                          csMinPixelClock;            /* Hz - With error what is slowest actual clock */
    UInt64                          csMaxPixelClock;            /* Hz - With error what is fasted actual clock */


    UInt32                          csHorizontalActive;         /* Pixels*/
    UInt32                          csHorizontalBlanking;       /* Pixels*/
    UInt32                          csHorizontalSyncOffset;     /* Pixels*/
    UInt32                          csHorizontalSyncPulseWidth; /* Pixels*/

    UInt32                          csVerticalActive;           /* Lines*/
    UInt32                          csVerticalBlanking;         /* Lines*/
    UInt32                          csVerticalSyncOffset;       /* Lines*/
    UInt32                          csVerticalSyncPulseWidth;   /* Lines*/

    UInt32                          csHorizontalBorderLeft;     /* Pixels*/
    UInt32                          csHorizontalBorderRight;    /* Pixels*/
    UInt32                          csVerticalBorderTop;        /* Lines*/
    UInt32                          csVerticalBorderBottom;     /* Lines*/

    UInt32                          csHorizontalSyncConfig;
    UInt32                          csHorizontalSyncLevel;      /* Future use (init to 0)*/
    UInt32                          csVerticalSyncConfig;
    UInt32                          csVerticalSyncLevel;        /* Future use (init to 0)*/

    UInt32                          csNumLinks;                 /* number of links, if 0 = assume link - 0 */

    UInt32                          csReserved2;                /* Init to 0*/
    UInt32                          csReserved3;                /* Init to 0*/
    UInt32                          csReserved4;                /* Init to 0*/

    UInt32                          csReserved5;                /* Init to 0*/
    UInt32                          csReserved6;                /* Init to 0*/
    UInt32                          csReserved7;                /* Init to 0*/
    UInt32                          csReserved8;                /* Init to 0*/
};
typedef struct VDDetailedTimingRec      VDDetailedTimingRec;

typedef VDDetailedTimingRec *           VDDetailedTimingPtr;

/* csScalerFeatures */
enum {
    kScaleStretchOnlyMask         = (1<<0),                     /* True means the driver cannot add borders to avoid non-square pixels */
    kScaleCanUpSamplePixelsMask   = (1<<1),                     /* True means timings with more active clocks than pixels (ie 640x480 pixels on a 1600x1200 timing) */
    kScaleCanDownSamplePixelsMask = (1<<2),                     /* True means timings with fewer active clocks than pixels (ie 1600x1200  pixels on a 640x480 timing) */
    kScaleCanScaleInterlacedMask  = (1<<3),                     /* True means can scale an interlaced timing */
    kScaleCanSupportInsetMask     = (1<<4),                     /* True means can scale a timing with insets */
    kScaleCanRotateMask           = (1<<5),                     /* True means can rotate image */
    kScaleCanBorderInsetOnlyMask  = (1<<6)                      /* True means can scale a timing with insets */
};

/* csScalerFlags */
enum {
    kScaleStretchToFitMask      = 0x00000001,                   /* True means the driver should avoid borders and allow non-square pixels */

    kScaleRotateFlagsMask       = 0x000000f0,

    kScaleSwapAxesMask          = 0x00000010,
    kScaleInvertXMask           = 0x00000020,
    kScaleInvertYMask           = 0x00000040,

    kScaleRotate0Mask           = 0x00000000,
    kScaleRotate90Mask          = kScaleSwapAxesMask | kScaleInvertXMask,
    kScaleRotate180Mask         = kScaleInvertXMask  | kScaleInvertYMask,
    kScaleRotate270Mask         = kScaleSwapAxesMask | kScaleInvertYMask
};

typedef UInt32                  VDClutBehavior;
typedef VDClutBehavior *        VDClutBehaviorPtr;
enum {
    kSetClutAtSetEntries        = 0,                            /* SetEntries behavior is to update clut during SetEntries call*/
    kSetClutAtVBL               = 1                             /* SetEntries behavior is to upate clut at next vbl*/
};


struct VDCommunicationRec {
    SInt32                          csBusID;                    /* kVideoDefaultBus for single headed cards.*/
    UInt32                          csCommFlags;                /* Always zero*/
    UInt32                          csMinReplyDelay;            /* Minimum delay between send and reply transactions (units depend on csCommFlags)*/
    UInt32                          csReserved2;                /* Always zero*/

    UInt32                          csSendAddress;              /* Usually I2C address (eg 0x6E)*/
    UInt32                          csSendType;                 /* See kVideoSimpleI2CType etc.*/
    LogicalAddress                  csSendBuffer;               /* Pointer to the send buffer*/
    ByteCount                       csSendSize;                 /* Number of bytes to send*/

    UInt32                          csReplyAddress;             /* Address from which to read (eg 0x6F for kVideoDDCciReplyType I2C address)*/
    UInt32                          csReplyType;                /* See kVideoDDCciReplyType etc.*/
    LogicalAddress                  csReplyBuffer;              /* Pointer to the reply buffer*/
    ByteCount                       csReplySize;                /* Max bytes to reply (size of csReplyBuffer)*/

    UInt32                          csReserved3;
    UInt32                          csReserved4;
    UInt32                          csReserved5;                /* Always zero*/
    UInt32                          csReserved6;                /* Always zero*/
};
typedef struct VDCommunicationRec       VDCommunicationRec;

typedef VDCommunicationRec *            VDCommunicationPtr;

struct VDCommunicationInfoRec {
    SInt32                          csBusID;                    /* kVideoDefaultBus for single headed cards. */
    UInt32                          csBusType;                  /* See kVideoBusI2C etc.*/
    SInt32                          csMinBus;                   /* Minimum bus (usually kVideoDefaultBus).  Used to probe additional busses*/
    SInt32                          csMaxBus;                   /* Max bus (usually kVideoDefaultBus).  Used to probe additional busses*/

    UInt32                          csSupportedTypes;           /* Bit field for first 32 supported transaction types.  Eg. 0x07 => support for kVideoNoTransactionType, kVideoSimpleI2CType and kVideoDDCciReplyType.*/
    UInt32                          csSupportedCommFlags;       /* Return the flags csCommFlags understood by this driver. */
    UInt32                          csReserved2;                /* Always zero*/
    UInt32                          csReserved3;                /* Always zero*/

    UInt32                          csReserved4;                /* Always zero*/
    UInt32                          csReserved5;                /* Always zero*/
    UInt32                          csReserved6;                /* Always zero*/
    UInt32                          csReserved7;                /* Always zero*/
};
typedef struct VDCommunicationInfoRec   VDCommunicationInfoRec;

typedef VDCommunicationInfoRec *        VDCommunicationInfoPtr;


struct VDScalerRec {
    UInt32                          csScalerSize;               /* Init to sizeof(VDScalerRec) */
    UInt32                          csScalerVersion;            /* Init to 0 */
    UInt32                          csReserved1;                /* Init to 0 */
    UInt32                          csReserved2;                /* Init to 0 */
    
    DisplayModeID                   csDisplayModeID;            /* Display Mode ID modified by this call. */
    UInt32                          csDisplayModeSeed;          /*  */
    UInt32                          csDisplayModeState;         /* Display Mode state */
    UInt32                          csReserved3;                /* Init to 0 */
    
    UInt32                          csScalerFlags;              /* Init to 0 */
    UInt32                          csHorizontalPixels;         /* Graphics system addressable pixels */
    UInt32                          csVerticalPixels;           /* Graphics system addressable lines */
    UInt32                          csHorizontalInset;          /* Border pixels for underscan */
    UInt32                          csVerticalInset;            /* Border lines for underscan */
    UInt32                          csReserved6;                /* Init to 0 */
    UInt32                          csReserved7;                /* Init to 0 */
    UInt32                          csReserved8;                /* Init to 0 */
};
typedef struct VDScalerRec   VDScalerRec;
typedef VDScalerRec  *VDScalerPtr;

struct VDScalerInfoRec {
    UInt32                          csScalerInfoSize;           /* Init to sizeof(VDScalerInfoRec) */
    UInt32                          csScalerInfoVersion;        /* Init to 0 */
    UInt32                          csReserved1;                /* Init to 0 */
    UInt32                          csReserved2;                /* Init to 0 */
    
    UInt32                          csScalerFeatures;           /* Feature flags */
    UInt32                          csMaxHorizontalPixels;      /* limit to horizontal scaled pixels */
    UInt32                          csMaxVerticalPixels;        /* limit to vertical scaled pixels */
    UInt32                          csReserved3;                /* Init to 0 */

    UInt32                          csReserved4;                /* Init to 0 */
    UInt32                          csReserved5;                /* Init to 0 */
    UInt32                          csReserved6;                /* Init to 0 */
    UInt32                          csReserved7;                /* Init to 0 */
};
typedef struct VDScalerInfoRec   VDScalerInfoRec;
typedef VDScalerInfoRec *VDScalerInfoPtr;

enum {
    /* csMirrorFeatures*/
    kMirrorSameDepthOnlyMirrorMask = (1 << 0),                  /* Commonly true - Mirroring can only be done if the displays are the same bitdepth*/
    kMirrorSameSizeOnlyMirrorMask = (1 << 1),                   /* Commonly false - Mirroring can only be done if the displays are the same size*/
    kMirrorSameTimingOnlyMirrorMask = (1 << 2),                 /* Sometimes true - Mirroring can only be done if the displays are the same timing*/
    kMirrorCommonGammaMask        = (1 << 3)                    /* Sometimes true - Only one gamma correction LUT.*/
};

enum {
    /* csMirrorSupportedFlags and csMirrorFlags*/
    kMirrorCanMirrorMask          = (1 << 0),                   /* Set means we can HW mirrored right now (uses csMirrorEntryID)*/
    kMirrorAreMirroredMask        = (1 << 1),                   /* Set means we are HW mirrored right now (uses csMirrorEntryID)*/
    kMirrorUnclippedMirrorMask    = (1 << 2),                   /* Set means mirrored displays are not clipped to their intersection*/
    kMirrorHAlignCenterMirrorMask = (1 << 3),                   /* Set means mirrored displays can/should be centered horizontally*/
    kMirrorVAlignCenterMirrorMask = (1 << 4),                   /* Set means mirrored displays can/should be centered vertically*/
    kMirrorCanChangePixelFormatMask = (1 << 5),                 /* Set means mirrored the device should change the pixel format of mirrored displays to allow mirroring.*/
    kMirrorCanChangeTimingMask    = (1 << 6),                   /* Set means mirrored the device should change the timing of mirrored displays to allow mirroring.*/
    kMirrorClippedMirrorMask      = (1 << 7)                    /* Set means mirrored displays are clipped to their intersection (driver handles blacking and base address adjustment)*/
};

struct VDMirrorRec {
    UInt32              csMirrorSize;           /* Init to sizeof(VDMirrorRec)*/
    UInt32              csMirrorVersion;        /* Init to 0*/
    
    RegEntryID          csMirrorRequestID;   /* Input RegEntryID to check for mirroring support and state*/
    RegEntryID          csMirrorResultID;    /* Output RegEntryID of the next mirrored device*/
    
    UInt32              csMirrorFeatures;       /* Output summary features of the driver*/
    UInt32              csMirrorSupportedFlags; /* Output configuration options supported by the driver*/
    UInt32              csMirrorFlags;          /* Output configuration options active now*/
    UInt32              csReserved1;            /* Init to 0*/
    
    
    UInt32              csReserved2;            /* Init to 0*/
    UInt32              csReserved3;            /* Init to 0*/
    UInt32              csReserved4;            /* Init to 0*/
    UInt32              csReserved5;            /* Init to 0*/
};
typedef struct VDMirrorRec VDMirrorRec;
typedef VDMirrorRec * VDMirrorPtr;

struct VDConfigurationRec {
    UInt32              csConfigFeature;        /* input what feature to config - always input*/
    UInt32              csConfigSupport;        /* output support value - always output*/
    uintptr_t           csConfigValue;          /* input/output feature value - input on Control(), output on Status()*/
    uintptr_t           csReserved1;
    uintptr_t           csReserved2;
};
typedef struct VDConfigurationRec       VDConfigurationRec;
typedef VDConfigurationRec *            VDConfigurationPtr;

enum
{
    kDVIPowerSwitchFeature        = (1 << 0),   /* Used for csConfigFeature*/
    kDVIPowerSwitchSupportMask    = (1 << 0),   /* Read-only*/
    kDVIPowerSwitchActiveMask     = (1 << 0),   /* Read/write for csConfigValue*/
};

struct VDConfigurationFeatureListRec
{
    OSType *    csConfigFeatureList;
    ItemCount   csNumConfigFeatures;
    uintptr_t   csReserved1;
    uintptr_t   csReserved2;
};
typedef struct VDConfigurationFeatureListRec   VDConfigurationFeatureListRec;
typedef VDConfigurationFeatureListRec *        VDConfigurationFeatureListRecPtr;


#ifndef __LP64__
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __IOMACOSVIDEO__ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             IONDRVFramebuffer.h                                                                                 0100644 0001750 0001750 00000032744 12567452457 037773  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/ndrvsupport                                                    /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997-1998 Apple Computer, Inc.
 *
 *
 * HISTORY
 *
 * sdouglas  22 Oct 97 - first checked in.
 * sdouglas  24 Jul 98 - start IOKit.
 * sdouglas  15 Dec 98 - cpp.
 *
 */

#ifndef _IOKIT_IONDRVFRAMEBUFFER_H
#define _IOKIT_IONDRVFRAMEBUFFER_H

#include <IOKit/graphics/IOFramebuffer.h>
#include <IOKit/ndrvsupport/IOMacOSVideo.h>
#include <IOKit/ndrvsupport/IONDRVSupport.h>

#define kIONDRVDisableKey       "AAPL,disable-ndrv"

class IONDRVFramebuffer : public IOFramebuffer
{
    OSDeclareDefaultStructors(IONDRVFramebuffer)

protected:
/*    Reserved for future use.  (Internal use only)  */
    struct ExpansionData { };
    ExpansionData * reserved;

protected:

    IOService *                 nub;
    class IONDRV *              ndrv;

    // current configuration
    IODisplayModeID             currentDisplayMode;
    IOIndex                     currentDepth;
    IOIndex                     currentPage;
    UInt8                       __reservedE;

    IOPhysicalAddress           __resv_was_physicalFramebuffer;
    IOMemoryDescriptor *        vramRange;

    UInt8                       gammaWidth;
    UInt8                       __reservedD;
    UInt8                       lastGrayMode;
    VDClutBehavior              lastClutSetting;
    UInt8                       __reservedC;

    bool                        consoleDevice;
    UInt32                      powerState;
    UInt32                      ndrvState;
    SInt32                      ndrvEnter;
    OSArray *                   detailedTimings;
    UInt32                      detailedTimingsSeed;
    UInt32 *                    detailedTimingsCurrent;

    IODeviceMemory *            vramMemory;

    VDResolutionInfoRec         cachedVDResolution;

    struct _VSLService *        vslServices;

    UInt32                      accessFlags;
    unsigned int                shouldDoI2CPower:1;
    unsigned int                online:1;
    unsigned int                avJackState:1;
    unsigned int                grayMode:1;
    unsigned int                platformSleep:1;
    unsigned int                forceReadEDID:1;
    unsigned int                supportsProbe:1;
    unsigned int                __reservedB:25;

    IOService *                 device;

    UInt32                      __reservedA[29];

private:
    struct IONDRVFramebufferPrivate * __private;

public:
    virtual IOReturn doDriverIO( UInt32 commandID, void * contents,
                                 UInt32 commandCode, UInt32 commandKind );
private:
    OSMetaClassDeclareReservedUsed(IONDRVFramebuffer, 0);

    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 1);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 2);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 3);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 4);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 5);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 6);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 7);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 8);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 9);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 10);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 11);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 12);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 13);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 14);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 15);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 16);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 17);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 18);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 19);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 20);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 21);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 22);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 23);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 24);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 25);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 26);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 27);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 28);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 29);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 30);
    OSMetaClassDeclareReservedUnused(IONDRVFramebuffer, 31);

private:

    void initForPM ( void );

    virtual unsigned long maxCapabilityForDomainState( IOPMPowerFlags domainState );
    virtual unsigned long initialPowerStateForDomainState( IOPMPowerFlags domainState );
    virtual unsigned long powerStateForDomainState( IOPMPowerFlags domainState );

    virtual IOReturn checkDriver( void );
    virtual UInt32 iterateAllModes( IODisplayModeID * displayModeIDs );
    virtual IOReturn getResInfoForMode( IODisplayModeID modeID,
                                    IODisplayModeInformation * theInfo );
    virtual IOReturn getResInfoForArbMode( IODisplayModeID modeID,
                                    IODisplayModeInformation * theInfo );
    IOReturn getResInfoForDetailed( IODisplayModeID modeID,
                                    VDDetailedTimingRec * detailed,
                                    IODisplayModeInformation * info );
    IOIndex mapDepthIndex( IODisplayModeID modeID, IOIndex depth, bool fromDepthMode );
    virtual IOReturn validateDisplayMode(
            IODisplayModeID mode, IOOptionBits flags,
            VDDetailedTimingRec ** detailed );
    virtual IOReturn setDetailedTiming(
            IODisplayModeID mode, IOOptionBits options,
            void * description, IOByteCount descripSize );
    virtual void getCurrentConfiguration( void );
    static const IOTVector * _undefinedSymbolHandler( void * self, 
                            const char * libraryName, const char * symbolName );
    static bool _videoJackStateChangeHandler( void * target, void * ref,
                            IOService * newService, IONotifier * notifier );
    static void _avProbeAction( OSObject * p0, IOTimerEventSource * evtSrc );
    void displayI2CPower( bool enable );
    IOReturn ndrvSetPowerState( UInt32 newState );
    IOReturn ndrvUpdatePowerState( void );
    IOReturn ndrvSetDisplayPowerState( UInt32 newState );
    static IOReturn _probeAction( IONDRVFramebuffer * self, IOOptionBits options );
    bool searchOfflineMode( IODisplayModeID * offlineMode );
    IOReturn processConnectChange( uintptr_t * value );
    IOReturn setMirror( IONDRVFramebuffer * other );
    IOReturn setConnectionFlags( void );
    bool getOnlineState( void );
    IOReturn ndrvGetSetFeature( UInt32 feature, uintptr_t newValue, uintptr_t * currentValue );
    static IOReturn _doControl( IONDRVFramebuffer * self, UInt32 code, void * params );
    static IOReturn _doStatus( IONDRVFramebuffer * self, UInt32 code, void * params );
    static IOReturn extControl( OSObject * owner, void * code, void * params );
    static IOReturn extStatus( OSObject * owner, void * code, void * params );
    IOReturn createI2C( void );
    void setInfoProperties( void );

public:
    virtual IOReturn doControl( UInt32 code, void * params );
    virtual IOReturn doStatus( UInt32 code, void * params );

public:

    virtual IOService * probe(  IOService *     provider,
                                SInt32 *        score );

    virtual bool start( IOService * provider );

    virtual void stop( IOService * provider );

    virtual void free( void );

    virtual IOReturn setProperties( OSObject * properties );

    virtual IOReturn requestProbe( IOOptionBits options );

    virtual IOReturn enableController( void );

    virtual IODeviceMemory * makeSubRange( IOPhysicalAddress64 start,
                                           IOPhysicalLength64  length );
    virtual IODeviceMemory * getApertureRange( IOPixelAperture aperture );
    virtual IODeviceMemory * getVRAMRange( void );

    virtual IODeviceMemory * findVRAM( void );

    virtual bool isConsoleDevice( void );

    virtual const IOTVector * undefinedSymbolHandler( const char * libraryName,
                                                      const char * symbolName );

    virtual const char * getPixelFormats( void );

    // Array of supported display modes
    virtual IOItemCount getDisplayModeCount( void );
    virtual IOReturn getDisplayModes( IODisplayModeID * allDisplayModes );

    // Info about a display mode
    virtual IOReturn getInformationForDisplayMode( IODisplayModeID displayMode,
                    IODisplayModeInformation * info );

    // Mask of pixel formats available in mode and depth
    virtual UInt64  getPixelFormatsForDisplayMode( IODisplayModeID displayMode,
                    IOIndex depth );

    virtual IOReturn getPixelInformation(
        IODisplayModeID displayMode, IOIndex depth,
        IOPixelAperture aperture, IOPixelInformation * pixelInfo );

    // Framebuffer info

    virtual IOReturn setupForCurrentConfig( void );

    // Current display mode and depth
    virtual IOReturn getCurrentDisplayMode( IODisplayModeID * displayMode,
                            IOIndex * depth );

    // Set display mode and depth
    virtual IOReturn setDisplayMode( IODisplayModeID displayMode,
                            IOIndex depth );

    // For pages
    virtual IOReturn setApertureEnable( IOPixelAperture aperture,
                    IOOptionBits enable );

    virtual IOReturn setStartupDisplayMode( IODisplayModeID displayMode,
                            IOIndex depth );
    virtual IOReturn getStartupDisplayMode( IODisplayModeID * displayMode,
                            IOIndex * depth );

    //// CLUTs

    virtual IOReturn setCLUTWithEntries( IOColorEntry * colors, UInt32 index,
                UInt32 numEntries, IOOptionBits options );

    //// Gamma

    virtual IOReturn setGammaTable( UInt32 channelCount, UInt32 dataCount,
                    UInt32 dataWidth, void * data );

    //// Display mode timing information

    virtual IOReturn getTimingInfoForDisplayMode( IODisplayModeID displayMode,
                IOTimingInformation * info );

    //// Detailed timing information

    virtual IOReturn validateDetailedTiming(
                    void * description, IOByteCount descripSize );

    virtual IOReturn setDetailedTimings( OSArray * array );

    //// Controller attributes

    virtual IOReturn setAttribute( IOSelect attribute, uintptr_t value );
    virtual IOReturn getAttribute( IOSelect attribute, uintptr_t * value );

    //// Connections

    virtual IOItemCount getConnectionCount( void );

    virtual IOReturn getAttributeForConnection( IOIndex connectIndex,
                    IOSelect attribute, uintptr_t  * value );
    
    virtual IOReturn setAttributeForConnection( IOIndex connectIndex,
                    IOSelect attribute, uintptr_t  info );

    // Apple sensing

    virtual IOReturn getAppleSense( IOIndex connectIndex,
            UInt32 * senseType,
            UInt32 * primary,
            UInt32 * extended,
            UInt32 * displayType );

    virtual IOReturn connectFlags( IOIndex connectIndex,
                    IODisplayModeID displayMode, IOOptionBits * flags );

    //// IOHighLevelDDCSense

    virtual bool hasDDCConnect( IOIndex connectIndex );
    virtual IOReturn getDDCBlock( IOIndex connectIndex, UInt32 blockNumber,
                    IOSelect blockType, IOOptionBits options,
                    UInt8 * data, IOByteCount * length );

    //// Interrupts

    virtual IOReturn registerForInterruptType( IOSelect interruptType,
                        IOFBInterruptProc proc, OSObject * target, void * ref,
                        void ** interruptRef );
    virtual IOReturn unregisterInterrupt( void * interruptRef );
    virtual IOReturn setInterruptState( void * interruptRef, UInt32 state );

    //// HW Cursors

    virtual IOReturn setCursorImage( void * cursorImage );
    virtual IOReturn setCursorState( SInt32 x, SInt32 y, bool visible );

    //// I2C calls

    virtual IOReturn doI2CRequest( UInt32 bus, IOI2CBusTiming * timing, IOI2CRequest * request );

    //// VSL calls

    static OSStatus VSLNewInterruptService(
                            void * entryID,
                            UInt32 serviceType,
                            _VSLService ** serviceID );
    static OSStatus VSLDisposeInterruptService( _VSLService * serviceID );
    static OSStatus VSLDoInterruptService( _VSLService * serviceID );
    static Boolean  VSLPrepareCursorForHardwareCursor(
                            void * cursorRef,
                            IOHardwareCursorDescriptor * hwDesc,
                            IOHardwareCursorInfo * hwCursorInfo );
};

#endif /* ! _IOKIT_IONDRVFRAMEBUFFER_H */


                            IONDRVLibraries.h                                                                                   0100644 0001750 0001750 00000034232 12567452457 037455  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/ndrvsupport                                                    
#ifndef __IONDRVLIBRARIES__
#define __IONDRVLIBRARIES__

#include <libkern/OSByteOrder.h>
#include <libkern/OSAtomic.h>
#include <IOKit/ndrvsupport/IOMacOSTypes.h>
#include <IOKit/graphics/IOGraphicsTypes.h>


#ifdef __cplusplus
extern "C" {
#endif

/* NameRegistry error codes */
enum {
    nrLockedErr                         = -2536,
    nrNotEnoughMemoryErr                = -2537,
    nrInvalidNodeErr                    = -2538,
    nrNotFoundErr                       = -2539,
    nrNotCreatedErr                     = -2540,
    nrNameErr                           = -2541,
    nrNotSlotDeviceErr                  = -2542,
    nrDataTruncatedErr                  = -2543,
    nrPowerErr                          = -2544,
    nrPowerSwitchAbortErr               = -2545,
    nrTypeMismatchErr                   = -2546,
    nrNotModifiedErr                    = -2547,
    nrOverrunErr                        = -2548,
    nrResultCodeBase                    = -2549,
    nrPathNotFound                      = -2550,    /* a path component lookup failed */
    nrPathBufferTooSmall                = -2551,    /* buffer for path is too small */
    nrInvalidEntryIterationOp           = -2552,    /* invalid entry iteration operation */
    nrPropertyAlreadyExists             = -2553,    /* property already exists */
    nrIterationDone                     = -2554,    /* iteration operation is done */
    nrExitedIteratorScope               = -2555,    /* outer scope of iterator was exited */
    nrTransactionAborted                = -2556,        /* transaction was aborted */

    gestaltUndefSelectorErr             = -5551 /*undefined selector was passed to Gestalt*/
};

enum {
    kNVRAMProperty                      = 0x00000020,            // matches NR
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef _IOKIT_IOSERVICE_H
typedef struct IOService IOService;
#endif

IOReturn _IONDRVLibrariesInitialize( IOService * provider );
IOReturn _IONDRVLibrariesFinalize( IOService * provider );

#ifndef kAAPLRegEntryIDKey
#define kAAPLRegEntryIDKey      "AAPL,RegEntryID"
#endif

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*******************************************************************************
 * 
 * Foundation Types
 *
 */
/* Value of a property */
typedef void *                          RegPropertyValue;
/* Length of property value */
typedef UInt32                          RegPropertyValueSize;

/*******************************************************************************/

/*******************************************************************************
 *
 * Root Entry Name Definitions  (Applies to all Names in the RootNameSpace)
 *
 *  + Names are a colon-separated list of name components.  Name components
 *    may not themselves contain colons.  
 *  + Names are presented as null-terminated ASCII character strings.
 *  + Names follow similar parsing rules to Apple file system absolute
 *    and relative paths.  However the '::' parent directory syntax is
 *    not currently supported.
 */
/* Max length of Entry Name */
enum {
  kRegCStrMaxEntryNameLength    = 47
};

/* Entry Names are single byte ASCII */
typedef char                            RegCStrEntryName;
typedef char *                          RegCStrEntryNamePtr;
/* length of RegCStrEntryNameBuf =  kRegCStrMaxEntryNameLength+1*/
typedef char                            RegCStrEntryNameBuf[48];
typedef char                            RegCStrPathName;
typedef UInt32                          RegPathNameSize;
enum {
  kRegPathNameSeparator         = ':',  /* 0x3A */
  kRegEntryNameTerminator       = 0x00, /* '\0' */
  kRegPathNameTerminator        = 0x00  /* '\0' */
};

/*******************************************************************************
 *
 * Property Name and ID Definitions
 *  (Applies to all Properties Regardless of NameSpace)
 */
enum {
  kRegMaximumPropertyNameLength = 31,   /* Max length of Property Name */
  kRegPropertyNameTerminator    = 0x00  /* '\0' */
};

typedef char                            RegPropertyNameBuf[32];
typedef char                            RegPropertyName;
typedef char *                          RegPropertyNamePtr;
enum {
  kRegMaxPropertyNameLength     = kRegMaximumPropertyNameLength
};

/*******************************************************************************
 *
 * Iteration Operations
 *
 *  These specify direction when traversing the name relationships
 */
typedef UInt32                          RegIterationOp;
typedef RegIterationOp                  RegEntryIterationOp;
enum {
                                        /* Absolute locations*/
  kRegIterRoot                  = 0x00000002, /* "Upward" Relationships */
  kRegIterParents               = 0x00000003, /* include all  parent(s) of entry */
                                        /* "Downward" Relationships*/
  kRegIterChildren              = 0x00000004, /* include all children */
  kRegIterSubTrees              = 0x00000005, /* include all sub trees of entry */
  kRegIterDescendants           = 0x00000005, /* include all descendants of entry */
                                        /* "Horizontal" Relationships */
  kRegIterSibling               = 0x00000006, /* include all siblings */
                                        /* Keep doing the same thing*/
  kRegIterContinue              = 0x00000001
};

/*******************************************************************************
 *
 * Name Entry and Property Modifiers
 *
 *
 *
 * Modifiers describe special characteristics of names
 * and properties.  Modifiers might be supported for
 * some names and not others.
 * 
 * Device Drivers should not rely on functionality
 * specified as a modifier.
 */
typedef UInt32                          RegModifiers;
typedef RegModifiers                    RegEntryModifiers;
typedef RegModifiers                    RegPropertyModifiers;
enum {
  kRegNoModifiers               = 0x00000000, /* no entry modifiers in place */
  kRegUniversalModifierMask     = 0x0000FFFF, /* mods to all entries */
  kRegNameSpaceModifierMask     = 0x00FF0000, /* mods to all entries within namespace */
  kRegModifierMask              = (RegModifiers)0xFF000000 /* mods to just this entry */
};

/* Universal Property Modifiers */
enum {
  kRegPropertyValueIsSavedToNVRAM = 0x00000020, /* property is non-volatile (saved in NVRAM) */
  kRegPropertyValueIsSavedToDisk = 0x00000040 /* property is non-volatile (saved on disk) */
};

typedef size_t Size;

#ifndef _IOKIT_IOREGISTRYENTRY_H
typedef struct IORegistryIterator IORegistryIterator;
typedef struct OSIterator OSIterator;
#endif /* _IOKIT_IOREGISTRYENTRY_H */
typedef IORegistryIterator * RegEntryIter;
typedef OSIterator * RegPropertyIter;

OSStatus RegistryEntryIDCopy( const RegEntryID * entryID, RegEntryID * to );

OSStatus RegistryEntryIDInit( RegEntryID * entryID );

Boolean RegistryEntryIDCompare( const RegEntryID * id1, const RegEntryID * id2);

OSStatus RegistryPropertyGetSize(
  const RegEntryID *       entryID,
  const RegPropertyName *  propertyName,
  RegPropertyValueSize *   propertySize);

OSStatus RegistryPropertyGet(
  const RegEntryID *       entryID,
  const RegPropertyName *  propertyName,
  void *                   propertyValue,
  RegPropertyValueSize *   propertySize);

OSStatus RegistryPropertyCreate(
  const RegEntryID *       entryID,
  const RegPropertyName *  propertyName,
  const void *             propertyValue,
  RegPropertyValueSize     propertySize);

OSStatus RegistryPropertyDelete(
  const RegEntryID *       entryID,
  const RegPropertyName *  propertyName);

OSStatus RegistryPropertySet(
  const RegEntryID *       entryID,
  const RegPropertyName *  propertyName,
  const void *             propertyValue,
  RegPropertyValueSize     propertySize);

OSStatus RegistryPropertyGetMod(
  const RegEntryID *       entry,
  const RegPropertyName *  name,
  RegPropertyModifiers *   modifiers);

OSStatus RegistryPropertySetMod(
  const RegEntryID *       entry,
  const RegPropertyName *  name,
  RegPropertyModifiers     modifiers);

OSStatus RegistryPropertyIterateCreate(
  const RegEntryID *  entry,
  RegPropertyIter *   cookie);

OSStatus RegistryPropertyIterateDispose( RegPropertyIter * cookie);

OSStatus RegistryPropertyIterate(
  RegPropertyIter *  cookie,
  RegPropertyName *  foundProperty,
  Boolean *          done);

OSStatus RegistryEntryIterateCreate( RegEntryIter * cookie);

OSStatus RegistryEntryIterateDispose( RegEntryIter * cookie);

OSStatus RegistryEntryIterate( RegEntryIter *   cookie,
                        RegEntryIterationOp     relationship,
                        RegEntryID *    foundEntry,
                        Boolean *       done);

OSStatus RegistryCStrEntryToName( const RegEntryID *    entryID,
                            RegEntryID *                parentEntry,
                            RegCStrEntryName *          nameComponent,
                            Boolean *                   done );

OSStatus RegistryCStrEntryLookup(  const RegEntryID *   parentEntry,
                            const RegCStrPathName *     path,
                            RegEntryID *                newEntry);

OSStatus RegistryEntryIDDispose(RegEntryID * entryID);

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

enum {
  paramErr                      = -50,  /*error in user parameter list*/
  noHardwareErr                 = -200, /*Sound Manager Error Returns*/
  notEnoughHardwareErr          = -201, /*Sound Manager Error Returns*/
  userCanceledErr               = -128,
  qErr                          = -1,   /*queue element not found during deletion*/
  vTypErr                       = -2,   /*invalid queue element*/
  corErr                        = -3,   /*core routine number out of range*/
  unimpErr                      = -4,   /*unimplemented core routine*/
  SlpTypeErr                    = -5,   /*invalid queue element*/
  seNoDB                        = -8,   /*no debugger installed to handle debugger command*/
  controlErr                    = -17,  /*I/O System Errors*/
  statusErr                     = -18,  /*I/O System Errors*/
  readErr                       = -19,  /*I/O System Errors*/
  writErr                       = -20,  /*I/O System Errors*/
  badUnitErr                    = -21,  /*I/O System Errors*/
  unitEmptyErr                  = -22,  /*I/O System Errors*/
  openErr                       = -23,  /*I/O System Errors*/
  closErr                       = -24,  /*I/O System Errors*/
  dRemovErr                     = -25,  /*tried to remove an open driver*/
  dInstErr                      = -26,   /*DrvrInstall couldn't find driver in resources*/

  badCksmErr                    = -69,  /*addr mark checksum didn't check*/
};
enum {
  durationMicrosecond           = -1,  /* Microseconds are negative*/
  durationMillisecond           = 1,   /* Milliseconds are positive*/
  durationSecond                = 1000, /* 1000 * durationMillisecond*/
  durationMinute                = 60000, /* 60 * durationSecond,*/
  durationHour                  = 3600000, /* 60 * durationMinute,*/
  durationDay                   = 86400000, /* 24 * durationHour,*/
  durationNoWait                = 0,   /* don't block*/
  durationForever               = 0x7FFFFFFF /* no time limit*/
};
#ifndef NULL
    #if !defined(__cplusplus) && (defined(__SC__) || defined(THINK_C))
        /* Symantec C compilers (but not C++) want NULL and nil to be (void*)0  */
        #define NULL ((void *) 0)
    #else
        /* in case int is 16-bits, make sure NULL is 32-bits */
        #define NULL 0L
    #endif
#endif

#ifndef nil
    #define nil NULL
#endif

typedef ResType                         VSLGestaltType;

enum {
  clutType                      = 0,    /*0 if lookup table*/
  fixedType                     = 1,    /*1 if fixed table*/
  directType                    = 2,    /*2 if direct values*/
  RGBDirect                     = 16   /* 16 & 32 bits/pixel pixelType value */
};
typedef UInt32 *                        UInt32Ptr;

typedef struct IOHardwareCursorDescriptor HardwareCursorDescriptorRec;
typedef HardwareCursorDescriptorRec *     HardwareCursorDescriptorPtr;
typedef struct IOHardwareCursorInfo       HardwareCursorInfoRec;
typedef HardwareCursorInfoRec *           HardwareCursorInfoPtr;

typedef ResType                         InterruptServiceType;
typedef struct _VSLService *            InterruptServiceIDType;
typedef InterruptServiceIDType *        InterruptServiceIDPtr;

enum {
  kVBLInterruptServiceType      = 'vbl ',
  kHBLInterruptServiceType      = 'hbl ',
  kFrameInterruptServiceType    = 'fram',
  kConnectInterruptServiceType  = 'dci ', /* Renamed -- Use kFBCheckInterruptServiceType*/
  kFBConnectInterruptServiceType = kConnectInterruptServiceType, /* Demand to check configuration (Hardware unchanged)*/
  kFBChangedInterruptServiceType = 'chng', /* Demand to rebuild (Hardware has reinitialized on dependent change)*/
  kFBOfflineInterruptServiceType = 'remv', /* Demand to remove framebuffer (Hardware not available on dependent change -- but must not buserror)*/
  kFBOnlineInterruptServiceType = 'add ' /* Notice that hardware is available (after being removed)*/
};

enum {
    kVSLClamshellStateGestaltType = 'clam',
};

OSStatus
VSLGestalt( VSLGestaltType selector, UInt32 * response );

OSErr
VSLNewInterruptService(
  RegEntryID *            serviceDevice,
  InterruptServiceType    serviceType,
  InterruptServiceIDPtr   serviceID);

OSErr
VSLDisposeInterruptService(InterruptServiceIDType serviceID);

OSErr
VSLDoInterruptService(InterruptServiceIDType serviceID);

Boolean
VSLPrepareCursorForHardwareCursor(
  void *                        cursorRef,
  IOHardwareCursorDescriptor *  hardwareDescriptor,
  IOHardwareCursorInfo *        hwCursorInfo);


enum {
                                        /* Version Release Stage Codes */
  developStage                  = 0x20,
  alphaStage                    = 0x40,
  betaStage                     = 0x60,
  finalStage                    = 0x80
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

typedef struct OpaqueIOCommandID*       IOCommandID;

typedef UInt32 IOCommandKind;
typedef UInt32 IOCommandCode;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifdef __cplusplus
}
#endif

#endif /* __IONDRVLIBRARIES__ */

                                                                                                                                                                                                                                                                                                                                                                      IONDRVSupport.h                                                                                     0100644 0001750 0001750 00000002465 12567452457 037220  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/ndrvsupport                                                    /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __IONDRVSUPPORT__
#define __IONDRVSUPPORT__

#include <libkern/OSTypes.h>


#ifdef __cplusplus
extern "C" {
#endif

#define kIONDRVIgnoreKey        "AAPL,iokit-ignore-ndrv"
#define kIONDRVForXKey          "AAPL,iokit-ndrv"


struct IOTVector {
    void *      pc;
    UInt32      toc;
};
typedef struct IOTVector IOTVector;

#ifdef __cplusplus
}
#endif

#endif /* __IONDRVSUPPORT__ */
                                                                                                                                                                                                           network/                                                                                            0040755 0001750 0001750 00000000000 12612224742 033511  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOBasicOutputQueue.h                                                                                0100644 0001750 0001750 00000032460 12567452435 037376  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOBASICOUTPUTQUEUE_H
#define _IOBASICOUTPUTQUEUE_H

#include <IOKit/IOLocks.h>
#include <IOKit/network/IOOutputQueue.h>
#include <IOKit/network/IOPacketQueue.h>

struct IOMbufQueue;

/*! @class IOBasicOutputQueue
    @abstract A concrete implementation of an IOOutputQueue. 
    @discussion This object uses a mutex to protect the packet queue from
    multiple producers.
    A single producer is promoted to become a consumer when the queue is
    not active. Otherwise, the producer will simply queue the packet and
    return without blocking.

    The flow of packets from the queue to its target can be controlled
    by calling methods such as start(), stop(), or service(). The target
    is expected to call those methods from a single threaded context,
    i.e. the work loop context in a network driver. In addition, the
    target must also return a status for every packet delivered by the
    consumer thread. This return value is the only mechanism that the
    target can use to manage the queue when it is running on the
    consumer thread. 
*/

class IOBasicOutputQueue : public IOOutputQueue
{
    OSDeclareDefaultStructors( IOBasicOutputQueue )

private:
	static IOReturn dispatchNetworkDataNotification(void *          target,
                                                    void *          param,
                                                    IONetworkData * data,
                                                    UInt32          type);

    void dequeue();
    
protected:
    OSObject *            _target;
    IOOutputAction        _action;
    UInt32                _priorities;
    IOOutputQueueStats *  _stats;
    IONetworkData *       _statsData;
	IOLock *              _queueLock;
    IOMbufQueue *         _inQueues;
    IOMbufQueue *         _primaryQueues;
    IOMbufQueue *         _shadowQueues;
    volatile bool         _waitDequeueDone;
    volatile UInt32       _state;
    volatile UInt32       _serviceCount;
    
/*! @function serviceThread
    @abstract Provides an implementation for the serviceThread() method
    defined in IOOutputQueue.
    @discussion This method is called by the scheduled service thread when it
    starts to run. The service thread is scheduled by service()
    to restart a stalled queue when the kServiceAsync option is given.
    @param param A parameter that was given to scheduleServiceThread().
    This parameter is not used. 
*/

    virtual void serviceThread(void * param);

/*! @function output
    @abstract Transfers all packets in the mbuf queue to the target.
    @param queue A queue of output packets.
    @param state Returns a state bit defined by IOBasicOutputQueue that
    declares the new state of the queue following this method call.
    A kStateStalled is returned if the queue should stall, otherwise 0
    is returned. 
*/

    virtual void output(IOMbufQueue * queue, UInt32 * state);

/*! @function free
    @abstract Frees the IOBasicOutputQueue object.
    @discussion This function releases allocated resources, then call super::free(). 
*/

    virtual void free();

/*! @function handleNetworkDataAccess
    @abstract Handles an external access to the IONetworkData object
    returned by getStatisticsData().
    @param data The IONetworkData object being accessed.
    @param type Description of the type of access being performed.
    @param param An optional parameter for the handler.
    @result Returns kIOReturnSuccess on success, or an error code otherwise.
*/

    virtual IOReturn handleNetworkDataAccess(IONetworkData * data,
                                             UInt32          type,
                                             void *          param);

public:

/*! @function init
    @abstract Initializes an IOBasicOutputQueue object.
    @param target The object that will handle packets removed from the
    queue, which is usually a subclass of IONetworkController.
    @param action The function that will handle packets removed from the
    queue.
    @param capacity The initial capacity of the output queue.
    @result Returns true if initialized successfully, false otherwise. 
*/

    virtual bool init(OSObject *     target,
                      IOOutputAction action,
                      UInt32         capacity = 0,
                      UInt32         priorities = 1);

/*! @function withTarget
    @abstract Factory method that constructs and initializes an
    IOBasicOutputQueue object.
    @param target An IONetworkController object that will handle packets
    removed from the queue.
    @param capacity The initial capacity of the output queue.
    @result Returns an IOBasicOutputQueue object on success, or 0 otherwise. 
*/

    static IOBasicOutputQueue * withTarget(IONetworkController * target,
                                           UInt32                capacity = 0);

    /*! @function withTarget
     @abstract Factory method that constructs and initializes an
     IOBasicOutputQueue object.
     @param target An IONetworkController object that will handle packets
     removed from the queue.
     @param capacity The initial capacity of the output queue.
     @param priorities The number of traffic priorities supported
     @result Returns an IOBasicOutputQueue object on success, or 0 otherwise. 
     */
    
    static IOBasicOutputQueue * withTarget(IONetworkController * target,
                                           UInt32                capacity,
                                           UInt32                priorities);
    
/*! @function withTarget
    @abstract Factory method that constructs and initializes an
    IOBasicOutputQueue object.
    @param target The object that will handle packets removed from the
    queue.
    @param action The function that will handle packets removed from the
    queue.
    @param capacity The initial capacity of the output queue.
    @result Returns an IOBasicOutputQueue object on success, or 0 otherwise. 
*/

    static IOBasicOutputQueue * withTarget(OSObject *     target,
                                           IOOutputAction action,
                                           UInt32         capacity = 0);

    /*! @function withTarget
     @abstract Factory method that constructs and initializes an
     IOBasicOutputQueue object.
     @param target The object that will handle packets removed from the
     queue.
     @param action The function that will handle packets removed from the
     queue.
     @param capacity The initial capacity of the output queue.
     @param priorities The number of traffic priorities supported
     @result Returns an IOBasicOutputQueue object on success, or 0 otherwise. 
     */
    
    static IOBasicOutputQueue * withTarget(OSObject *     target,
                                           IOOutputAction action,
                                           UInt32         capacity,
                                           UInt32         priorities);
    
/*! @function enqueue
    @abstract Adds a packet, or a chain of packets,
    to the queue.
    @discussion This method is called by a client to add a packet, or a chain of packets,
    to the queue.  A packet is described by an mbuf chain, while a chain
    of packets is constructed by linking multiple mbuf chains via the
    m_nextpkt field. This method can be called by multiple client
    threads.
    @param m A single packet, or a chain of packets.
    @param param A parameter provided by the caller.
    @result Always returns 0. 
*/

    virtual UInt32 enqueue(mbuf_t m, void * param);

/*! @function start
    @abstract Starts up the packet flow between the queue and its target.
    @discussion Called by the target to start the queue. This will allow
    packets to be removed from the queue, and then delivered to the target.
    @result Returns true if the queue was started successfully, false otherwise. */

    virtual bool start();

/*! @function stop
    @abstract Stops the packet flow between the queue and its target.
    @discussion This method stops the queue and prevents it from sending packets to its
    target. This call is synchronous and it may block. After this method
    returns, the queue will no longer call the registered target/action,
    even as new packets are added to the queue. The queue will continue to
    absorb new packets until the size of the queue reaches its capacity.
    The registered action must never call stop(), or a deadlock will occur.
    @result Returns the previous running state of the queue,
    true if the queue was running, false if the queue was already stopped. 
*/

    virtual bool stop();

/*! @enum ServiceAsync
    @abstract The option bits recognized by service().
    @constant kServiceAsync Set this option to service the queue in
    an asynchronous manner. The service() call will not block, but a
    scheduling latency will be introduced before the queue is serviced. 
*/

    enum {
        kServiceAsync = 0x1
    };

/*! @function service
    @abstract Services a queue that was stalled by the target.
    @discussion A target that stalls the queue must call service() when
    it becomes ready to accept more packets. Calling this method when the
    queue is not stalled is harmless.
    @result Returns true if the queue was stalled and there were packets sitting in
    the queue awaiting delivery, false otherwise. 
*/

    virtual bool service(IOOptionBits options = 0);

/*! @function flush
    @abstract Drops and frees all packets currently held by the queue.
    @discussion To ensure that all packets are removed from the queue,
    stop() should be called prior to flush(), to make sure there are
    no packets in-flight and being delivered to the target.
    @result Returns the number of packets that were dropped and freed. 
*/

    virtual UInt32 flush();

/*! @function setCapacity
    @abstract Changes the number of packets that the queue can hold
    before it begins to drop excess packets.
    @param capacity The new desired capacity.
    @result Returns true if the new capacity was accepted, false otherwise. 
*/

    virtual bool setCapacity(UInt32 capacity);

/*! @function getCapacity
    @abstract Gets the number of packets that the queue can hold.
    @discussion The queue will begin to drop incoming packets when the
    size of the queue reaches its capacity.
    @result Returns the current queue capacity. 
*/

    virtual UInt32 getCapacity() const;

/*! @function getSize
    @abstract Gets the number of packets currently held in the queue.
    @result Returns the size of the queue. 
*/

    virtual UInt32 getSize() const;

/*! @function getDropCount
    @abstract Gets the number of packets dropped by the queue.
    @result Returns the number of packets dropped due to over-capacity, or by
    external calls to the flush() method. 
*/

    virtual UInt32 getDropCount();

/*! @function getOutputCount
    @abstract Gets the number of packets accepted by the target.
    @result Returns the number of times that kIOOutputStatusAccepted is returned by
    the target. 
*/

    virtual UInt32 getOutputCount();

/*! @function getRetryCount
    @abstract Gets the number of instances when the target has refused to
    accept the packet provided.
    @result Returns the number of times that kIOOutputStatusRetry is returned by the
    target. 
*/

    virtual UInt32 getRetryCount();

/*! @function getStallCount
    @abstract Gets the number of instances when the target has stalled the
    queue.
    @result Returns the number of times that kIOOutputCommandStall is returned by the
    target. 
*/

    virtual UInt32 getStallCount();

/*! @enum GetStateBits
    @abstract The bits in the value returned by getState().
    @constant kStateRunning Set when the queue is running. Calling start()
    and stop() will set or clear this bit.
    @constant kStateStalled Set when the queue is stalled by the target.
    @constant kStateActive  Set when a consumer thread is actively removing
    packets from the queue and passing them to the target. 
*/

    enum {
        kStateRunning            = 0x1,
        kStateOutputStalled      = 0x2,
        kStateOutputActive       = 0x4,
        kStateOutputServiceMask  = 0xff00
    };

/*! @function getState
    @abstract Gets the state of the queue object.
    @result Returns the current state of the queue object. 
*/ 

    virtual UInt32 getState() const;

/*! @function getStatisticsData
    @abstract Returns an IONetworkData object containing statistics counters
    updated by the queue.
    @result Returns an IONetworkData object. 
*/

	virtual IONetworkData * getStatisticsData() const;
};

#endif /* !_IOBASICOUTPUTQUEUE_H */
                                                                                                                                                                                                                IOEthernetController.h                                                                              0100644 0001750 0001750 00000055015 12567452435 037752  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOETHERNETCONTROLLER_H
#define _IOETHERNETCONTROLLER_H

#include <IOKit/network/IONetworkController.h>

/*! @defined kIOEthernetControllerClass
    @abstract kIOEthernetControllerClass is the name of the
        IOEthernetController class. */

#define kIOEthernetControllerClass        "IOEthernetController"

/*! @defined kIOEthernetAddressSize
    @abstract The number of bytes in an Ethernet hardware address. */

#define kIOEthernetAddressSize            6

/*! @defined kIOEthernetMaxPacketSize
    @abstract The maximum size of an Ethernet packet, including
        the FCS bytes. */

#define kIOEthernetMaxPacketSize          1518

/*! @defined kIOEthernetMinPacketSize
    @abstract The minimum size of an Ethernet packet, including
        the FCS bytes. */

#define kIOEthernetMinPacketSize          64

/*! @defined kIOEthernetCRCSize
    @abstract The size in bytes of the 32-bit CRC value appended
        to the end of each Ethernet frame. */

#define kIOEthernetCRCSize                4

/*! @defined kIOEthernetWakeOnLANFilterGroup
    @abstract kIOEthernetWakeOnLANFilterGroup describes the name assigned
        to the Ethernet Wake-On-LAN filter group. This group represents
        wake filters that are supported by the controller. */

#define kIOEthernetWakeOnLANFilterGroup   "IOEthernetWakeOnLANFilterGroup"

/*! @defined kIOEthernetDisabledWakeOnLANFilterGroup
    @abstract kIOEthernetDisabledWakeOnLANFilterGroup describes the name
        assigned to the disabled Ethernet Wake-On-LAN filter group. This
        group represents wake filters that are currently disabled.
        Membership in this group is dynamic. */

#define kIOEthernetDisabledWakeOnLANFilterGroup \
        "IOEthernetDisabledWakeOnLANFilterGroup"

/*! @enum Wake On LAN Filters
    @abstract All filters in the Wake-on-LAN filter group.
    @discussion Each filter listed will respond to a network event that
        will trigger a system wake-up.
    @constant kIOEthernetWakeOnMagicPacket Reception of a Magic Packet.
    @constant kIOEthernetWakeOnPacketAddressMatch Reception of a packet
    which passes through any of the address filtering mechanisms based
    on its destination Ethernet address. This may include unicast,
    broadcast, or multicast addresses depending on the current state
    and setting of the corresponding packet filters. */

enum {
    kIOEthernetWakeOnMagicPacket         = 0x00000001,
    kIOEthernetWakeOnPacketAddressMatch  = 0x00000002
};

#ifdef KERNEL
#ifdef __cplusplus

struct IOEthernetAddress {
	UInt8 bytes[kIOEthernetAddressSize];
};

/*! @const gIOEthernetWakeOnLANFilterGroup
    @discussion gIOEthernetWakeOnLANFilterGroup is an OSSymbol object
    that contains the name of the Ethernet Wake-on-LAN filter group
    defined by kIOEthernetWakeOnLANFilterGroup. */

extern const OSSymbol * gIOEthernetWakeOnLANFilterGroup;

/*! @const gIOEthernetDisabledWakeOnLANFilterGroup
    @discussion gIOEthernetDisabledWakeOnLANFilterGroup is an OSSymbol object
    that contains the name of the disabled Ethernet Wake-on-LAN filter group
    defined by kIOEthernetDisabledWakeOnLANFilterGroup. */

extern const OSSymbol * gIOEthernetDisabledWakeOnLANFilterGroup;

/*! @class IOEthernetController
    @abstract Abstract superclass for Ethernet controllers. 
    @discussion Ethernet controller drivers should subclass IOEthernetController, and implement
    or override the hardware specific methods to create an Ethernet driver.
    An interface object (an IOEthernetInterface instance) must be
    instantiated by the driver, through attachInterface(), to connect
    the controller driver to the data link layer. 
*/

class IOEthernetController : public IONetworkController
{
    OSDeclareAbstractStructors( IOEthernetController )

protected:
    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *  _reserved;


public:

/*! @function initialize
    @abstract IOEthernetController class initializer.
    @discussion Creates global OSSymbol objects that are used as keys. */

    static void initialize();

/*! @function init
    @abstract Initializes an IOEthernetController object.
    @param properties A dictionary object containing a property table
        associated with this instance.
    @result Returns true on success, false otherwise. 
*/ 

    virtual bool init(OSDictionary * properties);

/*! @function getPacketFilters
    @abstract Gets the set of packet filters supported by the Ethernet 
    controller in the given filter group.
    @discussion The default implementation of the abstract method inherited
    from IONetworkController. When the filter group specified is
    gIONetworkFilterGroup, then this method will return a value formed by
    a bitwise OR of kIOPacketFilterUnicast, kIOPacketFilterBroadcast,
    kIOPacketFilterMulticast, kIOPacketFilterPromiscuous. Otherwise, the 
    return value will be set to zero (0). Subclasses must override this
    method if their filtering capability differs from what is reported by
    this default implementation. This method is called from the workloop
    context, and the result is published to the I/O Kit Registry.
    @param group The name of the filter group.
    @param filters Pointer to the mask of supported filters returned by
    	this method.
    @result Returns kIOReturnSuccess. Drivers that override this
    method must return kIOReturnSuccess to indicate success, or an error 
    return code otherwise. 
*/

    virtual IOReturn getPacketFilters(const OSSymbol * group,
                                      UInt32 *         filters) const;

/*! @function enablePacketFilter
    @abstract Enables one of the supported packet filters from the
    given filter group.
    @discussion The default implementation of the abstract method inherited
    from IONetworkController. This method will call setMulticastMode() or
    setPromiscuousMode() when the multicast or the promiscuous filter is to be
    enabled. Requests to disable the Unicast or Broadcast filters are handled
    silently, without informing the subclass. Subclasses can override this
    method to change this default behavior, or to extend it to handle
    additional filter types or filter groups. This method call is synchronized
    by the workloop's gate.
    @param group The name of the filter group containing the filter to be
    enabled.
    @param aFilter The filter to enable.
    @param enabledFilters All filters currently enabled by the client.
    @param options Optional flags for the enable request.
    @result Returns the value returned by setMulticastMode() or setPromiscuousMode() if
    either of those two methods are called. Returns kIOReturnSuccess if the filter
    specified is kIOPacketFilterUnicast or kIOPacketFilterBroadcast.
    Returns kIOReturnUnsupported if the filter group specified is not
    gIONetworkFilterGroup. 
*/

    virtual IOReturn enablePacketFilter(const OSSymbol * group,
                                        UInt32           aFilter,
                                        UInt32           enabledFilters,
                                        IOOptionBits     options = 0);

/*! @function disablePacketFilter
    @abstract Disables a packet filter that is currently enabled from the
    given filter group.
    @discussion The default implementation of the abstract method inherited
    from IONetworkController. This method will call setMulticastMode() or
    setPromiscuousMode() when the multicast or the promiscuous filter is to be
    disabled. Requests to disable the Unicast or Broadcast filters are handled
    silently, without informing the subclass. Subclasses can override this
    method to change this default behavior, or to extend it to handle
    additional filter types or filter groups. This method call is synchronized
    by the workloop's gate.
    @param group The name of the filter group containing the filter to be
    disabled.
    @param aFilter The filter to disable.
    @param enabledFilters All filters currently enabled by the client.
    @param options Optional flags for the disable request.
    @result Returns the value returned by setMulticastMode() or setPromiscuousMode() if
    either of those two methods are called. Returns kIOReturnSuccess if the filter
    specified is kIOPacketFilterUnicast or kIOPacketFilterBroadcast.
    Returns kIOReturnUnsupported if the filter group specified is not
    gIONetworkFilterGroup. 
*/

    virtual IOReturn disablePacketFilter(const OSSymbol * group,
                                         UInt32           aFilter,
                                         UInt32           enabledFilters,
                                         IOOptionBits     options = 0);

/*! @function getHardwareAddress
    @abstract Gets the Ethernet controller's station address.
    @discussion The default implementation of the abstract method inherited
    from IONetworkController. This method will call the overloaded form
    IOEthernetController::getHardwareAddress() that subclasses are expected
    to override.
    @param addr The buffer where the controller's hardware address should
           be written.
    @param inOutAddrBytes The size of the address buffer provided by the
           client, and replaced by this method with the actual size of
           the hardware address in bytes.
    @result Returns kIOReturnSuccess on success, or an error otherwise. 
*/

    virtual IOReturn getHardwareAddress(void *   addr,
                                        UInt32 * inOutAddrBytes);

/*! @function setHardwareAddress
    @abstract Sets or changes the station address used by the Ethernet
    controller.
    @discussion The default implementation of the abstract method inherited
    from IONetworkController. This method will call the overloaded form
    IOEthernetController::setHardwareAddress() that subclasses are expected
    to override.
    @param addr The buffer containing the hardware address provided by
    the client.
    @param addrBytes The size of the address buffer provided by the
    client in bytes.
    @result Returns kIOReturnSuccess on success, or an error otherwise. 
*/

    virtual IOReturn setHardwareAddress(const void * addr,
                                        UInt32       addrBytes);

/*! @function getMaxPacketSize
    @abstract Gets the maximum packet size supported by the Ethernet
        controller, including the frame header and FCS.
    @param maxSize Pointer to the return value.
    @result Returns kIOReturnSuccess on success, or an error code otherwise. 
*/

    virtual IOReturn getMaxPacketSize(UInt32 * maxSize) const;

/*! @function getMinPacketSize
    @abstract Gets the minimum packet size supported by the Ethernet
        controller, including the frame header and FCS.
    @param minSize Pointer to the return value.
    @result Returns kIOReturnSuccess on success, or an error code otherwise. 
*/

    virtual IOReturn getMinPacketSize(UInt32 * minSize) const;

/*! @function getPacketFilters
    @abstract Gets the set of packet filters supported by the Ethernet 
    controller in the network filter group.
    @param filters Pointer to the return value containing a mask of
    supported filters.
    @result Returns kIOReturnSuccess. Drivers that override this
    method must return kIOReturnSuccess to indicate success, or an error 
    return code otherwise. 
*/

    virtual IOReturn getPacketFilters(UInt32 * filters) const;

/*! @function getHardwareAddress
    @abstract Gets the Ethernet controller's permanent station address.
    @discussion Ethernet drivers must implement this method, by reading the
    address from hardware and writing it to the buffer provided. This method
    is called from the workloop context.
    @param addrP Pointer to an IOEthernetAddress where the hardware address
    should be returned.
    @result Returns kIOReturnSuccess on success, or an error return code otherwise. 
*/

    virtual IOReturn getHardwareAddress(IOEthernetAddress * addrP) = 0;

/*! @function setHardwareAddress
    @abstract Sets or changes the station address used by the Ethernet
        controller.
    @discussion This method is called in response to a client command to
    change the station address used by the Ethernet controller. Implementation
    of this method is optional. This method is called from the workloop context.
    @param addrP Pointer to an IOEthernetAddress containing the new station
    address.
    @result The default implementation will always return kIOReturnUnsupported.
    If overridden, drivers must return kIOReturnSuccess on success, or an error
    return code otherwise. 
*/

    virtual IOReturn setHardwareAddress(const IOEthernetAddress * addrP);

/*! @function setMulticastMode
    @abstract Enables or disables multicast mode.
    @discussion Called by enablePacketFilter() or disablePacketFilter()
    when there is a change in the activation state of the multicast filter
    identified by kIOPacketFilterMulticast. This method is called from the
    workloop context.
    @param active True to enable multicast mode, false to disable it.
    @result Returns kIOReturnUnsupported. If overridden, drivers must return
    kIOReturnSuccess on success, or an error return code otherwise. 
*/

    virtual IOReturn setMulticastMode(bool active);

/*! @function setMulticastList
    @abstract Sets the list of multicast addresses a multicast filter
    should use to match against the destination address of an incoming frame.
    @discussion This method sets the list of multicast addresses that the multicast filter
    should use to match against the destination address of an incoming frame.
    The frame should be accepted when a match occurs.  Called when the multicast group membership of an interface
    object is changed. Drivers that support kIOPacketFilterMulticast should
    override this method and update the hardware multicast filter using the
    list of Ethernet addresses provided. Perfect multicast filtering is
    preferred if supported by the hardware, in order to reduce the number of
    unwanted packets received. If the number of multicast addresses in the
    list exceeds what the hardware is capable of supporting, or if perfect
    filtering is not supported, then ideally the hardware should be programmed
    to perform imperfect filtering, through some form of hash filtering
    mechanism. Only as a last resort should the driver enable reception of
    all multicast packets to satisfy this request. This method is called
    from the workloop context, and only if the driver reports
    kIOPacketFilterMulticast support in getPacketFilters().
    @param addrs An array of Ethernet addresses. This argument must be
        ignored if the count argument is 0.
    @param count The number of Ethernet addresses in the list. This value
        will be zero when the list becomes empty.
    @result Returns kIOReturnUnsupported. Drivers must return kIOReturnSuccess to
    indicate success, or an error return code otherwise. 
*/

    virtual IOReturn setMulticastList(IOEthernetAddress * addrs, 
                                      UInt32              count);

/*! @function setPromiscuousMode
    @abstract Enables or disables promiscuous mode.
    @discussion Called by enablePacketFilter() or disablePacketFilter()
    when there is a change in the activation state of the promiscuous
    filter identified by kIOPacketFilterPromiscuous. This method is 
    called from the workloop context.
    @param active True to enable promiscuous mode, false to disable it.
    @result Returns kIOReturnUnsupported. If overridden, drivers must return
    kIOReturnSuccess on success, or an error return code otherwise. 
*/

    virtual IOReturn setPromiscuousMode(bool active);

/*! @function setWakeOnMagicPacket
    @abstract Enables or disables the wake on Magic Packet support.
    @discussion Called by enablePacketFilter() or disablePacketFilter()
    when there is a change in the activation state of the Wake-on-LAN
    filter identified by kIOEthernetWakeOnMagicPacket. This method is
    called from the workloop context.
    @param active True to enable support for system wake on reception
    of a Magic Packet, false to disable it.
    @result Returns kIOReturnUnsupported. If overridden, drivers must return
    kIOReturnSuccess on success, or an error return code otherwise. 
*/

    virtual IOReturn setWakeOnMagicPacket(bool active);

protected:

/*! @function createInterface
    @abstract Creates an IOEthernetInterface object.
    @discussion This method allocates and returns a new IOEthernetInterface instance.
    A subclass of IONetworkController must implement this method and return
    a matching interface object. The implementation in IOEthernetController
    will return an IOEthernetInterface object. Subclasses of
    IOEthernetController, such as Ethernet controller drivers, will have
    little reason to override this implementation.
    @result Returns a newly allocated and initialized IOEthernetInterface object. 
*/

    virtual IONetworkInterface * createInterface();

/*! @function free
    @abstract Frees the IOEthernetController instance. 
    @discussion This method releases resources, and is
    then followed by a call to super::free(). */

    virtual void free();

/*! @function publishProperties
    @abstract Publishes Ethernet controller properties and capabilities.
    @discussion This method publishes Ethernet controller properties to the property
    table. For instance, getHardwareAddress() is called to fetch the
    hardware address, and the address is then published to the property
    table. This method call is synchronized by the workloop's gate,
    and must never be called directly by subclasses.
    @result Returns true if all properties and capabilities were discovered,
    and published successfully, false otherwise. Returning false will
    prevent client objects from attaching to the Ethernet controller
    since a property that a client relies upon may be missing. 
*/

    virtual bool publishProperties();

    OSMetaClassDeclareReservedUsed( IOEthernetController,  0);

	/*! @function getVlanTagDemand
		@abstract Fetch the demand for hardware vlan tag stuffing
		for the given packet before it is transmitted on the network.
		@discussion A network controller that can insert 802.1Q vlan tags for output
		packets must call this method to obtain vlan tag information that it must
		insert into the given output packet.
		@param m A mbuf containing a packet that may require vlan tag stuffing.
		@param vlanTag After calling, the low order 16 bits contain the 802.1Q priority and
		vlan ID tag in host order.  The hi-order 16 bits are currently unused and should be ignored.
		@result true if vlanTag has been set and should be used.
		false if no vlan tag stuffing is required for this packet. */

	virtual bool getVlanTagDemand(mbuf_t m, UInt32 *vlanTag);

	OSMetaClassDeclareReservedUsed( IOEthernetController,  1);

	/*! @function setVlanTag
		@abstract Encode a received packet with the vlan tag result reported
		by the hardware.
		@discussion A network controller that can strip 802.1Q vlan tag information for a
		received packet should call this method to encode the result on the
		packet, before passing it up towards the protocol stacks.
		@param m A mbuf containing a packet that has had its 802.1q vlan tag stripped by
		the hardware.
		@param vlanTag A value in host order that contains the 802.1q vlan tag and priority
		in the low order 16 bits.  The hi order word is currently unused and should be set to 0. */

	virtual void setVlanTag(mbuf_t m, UInt32 vlanTag);
	
    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IOEthernetController,  2);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  3);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  4);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  5);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  6);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  7);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  8);
    OSMetaClassDeclareReservedUnused( IOEthernetController,  9);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 10);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 11);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 12);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 13);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 14);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 15);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 16);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 17);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 18);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 19);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 20);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 21);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 22);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 23);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 24);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 25);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 26);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 27);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 28);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 29);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 30);
    OSMetaClassDeclareReservedUnused( IOEthernetController, 31);
};

/*
 * FIXME: remove this.
 */
enum {
    kIOEnetPromiscuousModeOff   = false,
    kIOEnetPromiscuousModeOn    = true,
    kIOEnetPromiscuousModeAll   = true,
    kIOEnetMulticastModeOff     = false,
    kIOEnetMulticastModeFilter  = true
};
typedef bool IOEnetPromiscuousMode;
typedef bool IOEnetMulticastMode;

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOETHERNETCONTROLLER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   IOEthernetInterface.h                                                                               0100644 0001750 0001750 00000032600 12567452435 037522  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOETHERNETINTERFACE_H
#define _IOETHERNETINTERFACE_H

/*! @defined kIOEthernetInterfaceClass
    @abstract The name of the
        IOEthernetInterface class. 
*/

#define kIOEthernetInterfaceClass     "IOEthernetInterface"

/*! @defined kIOActivePacketFilters
    @abstract A property of IOEthernetInterface objects.
    @discussion The kIOActivePacketFilters property has an OSDictionary value that describes the current
        set of packet filters that have been successfully activated. Each
        entry in the dictionary is a key/value pair consisting of the filter
        group name, and an OSNumber describing the set of active filters for
        that group. Entries in this dictionary will mirror those in
        kIORequiredPacketFilters if the controller has reported success for
        all filter change requests from the IOEthernetInterface object. 
*/

#define kIOActivePacketFilters        "IOActivePacketFilters"

/*! @defined kIORequiredPacketFilters
    @abstract A property of IOEthernetInterface objects.
    @discussion The kIORequiredPacketFilters property has an OSDictionary value that describes the current
        set of required packet filters. Each entry in the dictionary is a
        key/value pair consisting of the filter group name, and an OSNumber
        describing the set of required filters for that group. 
*/

#define kIORequiredPacketFilters      "IORequiredPacketFilters"

/*! @defined kIOMulticastAddressList
    @abstract A property of IOEthernetInterface objects.
    @discussion The kIOMulticastAddressList property is an OSData object that describes the
        list of multicast addresses that are being used by the
        controller to match against the destination address of an
        incoming frame. 
*/

#define kIOMulticastAddressList       "IOMulticastAddressList"
#define kIOMulticastFilterData        kIOMulticastAddressList    

#ifdef KERNEL
#ifdef __cplusplus

#include <IOKit/network/IONetworkInterface.h>
#include <IOKit/network/IOEthernetController.h>
#include <IOKit/network/IOEthernetStats.h>

/*! @class IOEthernetInterface
    @abstract The Ethernet interface object. 
    @discussion An Ethernet controller driver,
    that is a subclass of IOEthernetController, will instantiate an object
    of this class when the driver calls the attachInterface() method.
    This interface object will then vend an Ethernet interface to DLIL,
    and manage the connection between the controller driver and the upper
    networking layers. Drivers will seldom need to subclass
    IOEthernetInterface. 
*/

class IOEthernetInterface : public IONetworkInterface
{
    OSDeclareDefaultStructors( IOEthernetInterface )

private:
    thread_call_t    _inputEventThreadCall; // inputEvent() thread call
    UInt32           _mcAddrCount;          // # of multicast addresses
    bool             _ctrEnabled;           // Is controller enabled?
    OSDictionary *   _supportedFilters;     // Controller's supported filters
    OSDictionary *   _requiredFilters;      // The required filters
    OSDictionary *   _activeFilters;        // Currently active filters    
    bool             _controllerLostPower;  // true if controller is unusable

    struct ExpansionData { 
        UInt32      altMTU;                 // track the physical mtu of controller
        UInt32      publishedFeatureID;     // id for published wake packet
        uint32_t    supportedWakeFilters;   // bitmask of supported wake filters
        OSNumber *  disabledWakeFilters;    // OSNumber of disabled wake filters
        uint64_t    wompEnabledAssertionID;
	};
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *  _reserved;


    IOReturn enableController(IONetworkController * ctr);
    IOReturn setupMulticastFilter(IONetworkController * ctr);

    UInt32 getFilters(const OSDictionary * dict,
                      const OSSymbol *     group);

    bool setFilters(OSDictionary *   dict,
                    const OSSymbol * group,
                    UInt32           filters);
                                     
    IOReturn disableFilter(IONetworkController * ctr,
                           const OSSymbol *      group,
                           UInt32                filter,
                           IOOptionBits          options = 0);

    IOReturn enableFilter(IONetworkController * ctr,
                          const OSSymbol *      group,
                          UInt32                filter,
                          IOOptionBits          options = 0);

    int syncSIOCSIFFLAGS(IONetworkController * ctr);
    int syncSIOCSIFADDR(IONetworkController * ctr);
    int syncSIOCADDMULTI(IONetworkController * ctr);
    int syncSIOCDELMULTI(IONetworkController * ctr);
    int syncSIOCSIFMTU(IONetworkController * ctr, struct ifreq * ifr, bool);
    int syncSIOCGIFDEVMTU(IONetworkController * ctr, struct ifreq * ifr);
    int syncSIOCSIFLLADDR(IONetworkController * ctr, const char * lladdr, int len);
	void _fixupVlanPacket(mbuf_t, u_int16_t, int);
    void reportInterfaceWakeFlags(IONetworkController * ctr);

    static void handleEthernetInputEvent(thread_call_param_t param0, thread_call_param_t param1);
    static int performGatedCommand(void *, void *, void *, void *, void *);
	static IOReturn enableFilter_Wrapper(
        IOEthernetInterface *, IONetworkController *, const OSSymbol *, UInt32 , IOOptionBits);

public:

/*! @function init
    @abstract Initializes an IOEthernetInterface instance.
    @discussion Instance variables are initialized, and an arpcom
    structure is allocated.
    @param controller A network controller object that will service
    the interface object being initialized.
    @result Returns true on success, false otherwise. 
*/

    virtual bool init( IONetworkController * controller );

/*! @function getNamePrefix
    @abstract Returns a string containing the prefix to use when
    creating a BSD name for this interface.
    @discussion The BSD name for each interface object is created by
    concatenating a string returned by this method, with an unique
    unit number assigned by IONetworkStack.
    @result Returns a pointer to a constant C string "en". Therefore, Ethernet
    interfaces will be registered with BSD as en0, en1, etc. 
*/

    virtual const char * getNamePrefix() const;

protected:

/*! @function free
    @abstract Frees the IOEthernetInterface instance.
    @discussion The memory allocated for the arpcom structure is released,
    followed by a call to super::free(). 
*/

    virtual void free();

/*! @function performCommand
    @abstract Handles an ioctl command sent to the Ethernet interface.
    @discussion This method handles socket ioctl commands sent to the Ethernet
    interface from DLIL. Commands recognized and processed by this method are
    SIOCSIFADDR, SIOCSIFFLAGS, SIOCADDMULTI, and SIOCDELMULTI. Other commands
    are passed to the superclass.
    @param controller The controller object.
    @param cmd  The ioctl command code.
    @param arg0 Command argument 0. Generally a pointer to an ifnet structure
        associated with the interface.
    @param arg1 Command argument 1.
    @result Returns a BSD return value defined in bsd/sys/errno.h. 
*/

    virtual SInt32 performCommand(IONetworkController * controller,
                                  unsigned long         cmd,
                                  void *                arg0,
                                  void *                arg1);

/*! @function controllerDidOpen
    @abstract A notification that the interface has opened the network
    controller.
    @discussion This method will be called by IONetworkInterface after a
    network controller has accepted an open from this interface object.
    IOEthernetInterface will first call the implementation in its
    superclass, then inspect the controller through properties published
    in the registry. This method is called with the arbitration lock held.
    @param controller The controller object that was opened.
    @result Returns true on success, false otherwise. Returning false will
    cause the controller to be closed, and any pending client opens to be
    rejected. 
*/

    virtual bool controllerDidOpen(IONetworkController * controller);

/*! @function controllerWillClose
    @abstract A notification that the interface will close the network
    controller.
    @discussion This method will simply call super to propagate the method
    call. This method is called with the arbitration lock held.
    @param controller The controller that is about to be closed. 
*/

    virtual void controllerWillClose(IONetworkController * controller);


/*! @function controllerWillChangePowerState
    @abstract Handles a notification that the network controller 
    servicing this interface object is about to transition to a new power state.
    @discussion If the controller is about to transition to an unusable state,
    and it is currently enabled, then the disable() method on the controller is
    called.
    @param controller The network controller object.
    @param flags Flags that describe the capability of the controller in the new
    power state.
    @param stateNumber An index to a state in the network controller's
    power state array that the controller is switching to.
    @param policyMaker A reference to the network controller's policy-maker,
    and is also the originator of this notification.
    @result Always returns kIOReturnSuccess. 
*/

    virtual IOReturn controllerWillChangePowerState(
                               IONetworkController * controller,
                               IOPMPowerFlags        flags,
                               UInt32                stateNumber,
                               IOService *           policyMaker);

/*! @function controllerDidChangePowerState
    @abstract Handles a notification that the network controller servicing
    this interface object has transitioned to a new power state.
    @discussion If the controller did transition to a usable state, and it was
    previously disabled due to a previous power change, then it is re-enabled.
    @param controller The network controller object.
    @param flags Flags that describe the capability of the controller in the new
    power state.
    @param stateNumber An index to a state in the network controller's
    power state array that the controller has switched to.
    @param policyMaker A reference to the network controller's policy-maker,
    and is also the originator of this notification.
    @result Always returns kIOReturnSuccess. 
*/

    virtual IOReturn controllerDidChangePowerState( 
                               IONetworkController * controller,
                               IOPMPowerFlags        flags,
                               UInt32                stateNumber,
                               IOService *           policyMaker);

public:
    /* Override IONetworkInterface::willTerminate() */

    virtual bool willTerminate( IOService *  provider,
                                IOOptionBits options );

    /* Override IONetworkInterface::attachToDataLinkLayer() */

    virtual IOReturn attachToDataLinkLayer( IOOptionBits options,
                                            void *       parameter );

    /* Override IONetworkInterface::inputEvent() */

    virtual bool inputEvent( UInt32 type, void * data );

protected:
	virtual void feedPacketInputTap(mbuf_t);
	virtual void feedPacketOutputTap(mbuf_t);
	virtual bool initIfnetParams(struct ifnet_init_params *params);

public:
    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  0);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  1);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  2);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  3);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  4);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  5);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  6);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  7);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  8);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface,  9);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface, 10);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface, 11);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface, 12);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface, 13);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface, 14);
    OSMetaClassDeclareReservedUnused( IOEthernetInterface, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOETHERNETINTERFACE_H */
                                                                                                                                IOEthernetStats.h                                                                                   0100644 0001750 0001750 00000013317 12567452435 036724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * IOEthernetStats.h - Ethernet MIB statistics definitions.
 *
 * HISTORY
 */

#ifndef _IOETHERNETSTATS_H
#define _IOETHERNETSTATS_H

/*! @header IOEthernetStats.h
    @discussion Ethernet statistics. */

//---------------------------------------------------------------------------
// Ethernet-like statistics group.

/*! @typedef IODot3StatsEntry
    @discussion Ethernet MIB statistics structure.
    @field alignmentErrors            dot3StatsAlignmentErrors.
    @field fcsErrors                  dot3StatsFCSErrors.
    @field singleCollisionFrames      dot3StatsSingleCollisionFrames.
    @field multipleCollisionFrames    dot3StatsMultipleCollisionFrames.
    @field sqeTestErrors              dot3StatsSQETestErrors.
    @field deferredTransmissions      dot3StatsDeferredTransmissions.
    @field lateCollisions             dot3StatsLateCollisions.
    @field excessiveCollisions        dot3StatsExcessiveCollisions.
    @field internalMacTransmitErrors  dot3StatsInternalMacTransmitErrors.
    @field carrierSenseErrors         dot3StatsCarrierSenseErrors.
    @field frameTooLongs              dot3StatsFrameTooLongs.
    @field internalMacReceiveErrors   dot3StatsInternalMacReceiveErrors.
    @field etherChipSet               dot3StatsEtherChipSet.
    @field missedFrames               dot3StatsMissedFrames (not in RFC1650).
    */

typedef struct {
    UInt32 alignmentErrors;
    UInt32 fcsErrors;
    UInt32 singleCollisionFrames;
    UInt32 multipleCollisionFrames;
    UInt32 sqeTestErrors;
    UInt32 deferredTransmissions;
    UInt32 lateCollisions;
    UInt32 excessiveCollisions;
    UInt32 internalMacTransmitErrors;
    UInt32 carrierSenseErrors;
    UInt32 frameTooLongs;
    UInt32 internalMacReceiveErrors;
    UInt32 etherChipSet;
    UInt32 missedFrames;
} IODot3StatsEntry;

//---------------------------------------------------------------------------
// Ethernet-like collision statistics group (optional).

/*! @typedef IODot3CollEntry
    @discussion Collision statistics structure.
    @field collFrequencies            dot3StatsCollFrequencies. */

typedef struct {
    UInt32 collFrequencies[16];
} IODot3CollEntry;

//---------------------------------------------------------------------------
// Receiver extra statistics group (not defined by RFC 1650).

/*! @typedef IODot3RxExtraEntry
    @discussion Extra receiver statistics not defined by RFC1650.
    @field overruns            receiver overruns.
    @field watchdogTimeouts    watchdog timer expirations.
    @field frameTooShorts      runt frames.
    @field collisionErrors     frames damages by late collision.
    @field phyErrors           PHY receive errors.
    @field timeouts            receiver timeouts.
    @field interrupts          receiver interrupts.
    @field resets              receiver resets.
    @field resourceErrors      receiver resource shortages.
    */

typedef struct {
    UInt32 overruns;
    UInt32 watchdogTimeouts;
    UInt32 frameTooShorts;
    UInt32 collisionErrors;
    UInt32 phyErrors;
    UInt32 timeouts;
    UInt32 interrupts;
    UInt32 resets;
    UInt32 resourceErrors;
    UInt32 reserved[4];
} IODot3RxExtraEntry;

//---------------------------------------------------------------------------
// Transmitter extra statistics group (not defined by RFC 1650).

/*! @typedef IODot3TxExtraEntry
    @discussion Extra transmitter statistics not defined by RFC1650.
    @field underruns           transmit underruns.
    @field jabbers             jabber events.
    @field phyErrors           PHY transmit errors.
    @field timeouts            transmitter timeouts.
    @field interrupts          transmitter interrupts.
    @field resets              transmitter resets.
    @field resourceErrors      transmitter resource shortages.
    */

typedef struct {
    UInt32 underruns;
    UInt32 jabbers;
    UInt32 phyErrors;
    UInt32 timeouts;
    UInt32 interrupts;
    UInt32 resets;
    UInt32 resourceErrors;
    UInt32 reserved[4];
} IODot3TxExtraEntry;

//---------------------------------------------------------------------------
// Aggregate Ethernet statistics.

/*! @typedef IOEthernetStats
    @discussion Aggregate Ethernet statistics structure.
    @field dot3StatsEntry      IODot3StatsEntry statistics group.
    @field dot3CollEntry       IODot3CollEntry statistics group.
    @field dot3RxExtraEntry    IODot3RxExtraEntry statistics group.
    @field dot3TxExtraEntry    IODot3TxExtraEntry statistics group.
    */

typedef struct {
    IODot3StatsEntry    dot3StatsEntry;
    IODot3CollEntry     dot3CollEntry;
    IODot3RxExtraEntry  dot3RxExtraEntry;
    IODot3TxExtraEntry  dot3TxExtraEntry;   
} IOEthernetStats;

/*! @defined kIOEthernetStatsKey
    @discussion Defines the name of an IONetworkData that contains
    an IOEthernetStats. */

#define kIOEthernetStatsKey             "IOEthernetStatsKey"

#endif /* !_IOETHERNETSTATS_H */
                                                                                                                                                                                                                                                                                                                 IOGatedOutputQueue.h                                                                                0100644 0001750 0001750 00000016530 12567452435 037401  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOGATEDOUTPUTQUEUE_H
#define _IOGATEDOUTPUTQUEUE_H

#include <IOKit/IOWorkLoop.h>
#include <IOKit/IOCommandGate.h>
#include <IOKit/IOInterruptEventSource.h>
#include <IOKit/network/IOBasicOutputQueue.h>

/*! @class IOGatedOutputQueue
    @abstract An extension of an IOBasicOutputQueue. 
    @discussion An IOCommandGate
    object is created by this queue and added to a work loop as an
    event source. All calls to the target by the consumer thread must
    occur with the gate closed. Therefore, all calls to the target of
    this type of queue will be serialized with any other thread that
    runs on the same work loop context. This is useful for network
    drivers that have a tight hardware coupling between the transmit
    and receive engines, and a single-threaded hardware access model
    is desirable. 
*/

class IOGatedOutputQueue : public IOBasicOutputQueue
{
    OSDeclareDefaultStructors( IOGatedOutputQueue )

private:
    static void gatedOutput(OSObject *           owner,
                            IOGatedOutputQueue * self,
                            IOMbufQueue *        queue,
                            UInt32 *             state);

    static void restartDeferredOutput(OSObject *               owner,
                                      IOInterruptEventSource * sender,
                                      int                      count);

protected:
    IOCommandGate *           _gate;
    IOInterruptEventSource *  _interruptSrc;

/*! @function output
    @abstract Transfers all packets in the mbuf queue to the target.
    @param queue A queue of output packets.
    @param state Return a state bit defined by IOBasicOutputQueue that
    declares the new state of the queue following this method call.
    A kStateStalled is returned if the queue should stall, otherwise 0
    is returned. 
*/

    virtual void output(IOMbufQueue * queue, UInt32 * state);

/*! @function free
    @abstract Frees the IOGatedOutputQueue object.
    @discussion Release allocated resources, then call super::free(). */

    virtual void free();

/*! @function output
    @abstract Overrides the method inherited from IOOutputQueue.
    @result Returns true if a thread was successfully scheduled to service
    the queue. 
*/

    virtual bool scheduleServiceThread(void * param);

public:

/*! @function init
    @abstract Initializes an IOGatedOutputQueue object.
    @param target The object that will handle packets removed from the
    queue, and is usually a subclass of IONetworkController.
    @param action The function that will handle packets removed from the
    queue.
    @param workloop A workloop object. An IOCommandGate object is created
    and added to this workloop as an event source.
    @param capacity The initial capacity of the output queue.
    @result Returns true if initialized successfully, false otherwise. 
*/

    virtual bool init(OSObject *     target,
                      IOOutputAction action,
                      IOWorkLoop *   workloop,
                      UInt32         capacity = 0,
                      UInt32         priorities = 1);

/*! @function withTarget
    @abstract Factory method that constructs and initializes an
    IOGatedOutputQueue object.
    @param target An IONetworkController object that will handle packets
    removed from the queue.
    @param workloop A workloop object. An IOCommandGate object is created
    and added to this workloop as an event source.
    @param capacity The initial capacity of the output queue.
    @result Returns an IOGatedOutputQueue object on success, or 0 otherwise. 
*/

    static IOGatedOutputQueue * withTarget(IONetworkController * target,
                                           IOWorkLoop *          workloop,
                                           UInt32                capacity = 0);

    /*! @function withTarget
     @abstract Factory method that constructs and initializes an
     IOGatedOutputQueue object.
     @param target An IONetworkController object that will handle packets
     removed from the queue.
     @param workloop A workloop object. An IOCommandGate object is created
     and added to this workloop as an event source.
     @param capacity The initial capacity of the output queue.
     @param priorities The number of traffic priorities supported
     @result Returns an IOGatedOutputQueue object on success, or 0 otherwise. 
     */
    
    static IOGatedOutputQueue * withTarget(IONetworkController * target,
                                           IOWorkLoop *          workloop,
                                           UInt32                capacity,
                                           UInt32                priorities);
    
/*! @function withTarget
    @abstract Factory method that constructs and initializes an
    IOGatedOutputQueue object.
    @param target The object that will handle packets removed from the
    queue.
    @param action The function that will handle packets removed from the
    queue.
    @param workloop A workloop object. An IOCommandGate object is created
    and added to this workloop as an event source.
    @param capacity The initial capacity of the output queue.
    @result Returns an IOGatedOutputQueue object on success, or 0 otherwise. 
*/

    static IOGatedOutputQueue * withTarget(OSObject *     target,
                                           IOOutputAction action,
                                           IOWorkLoop *   workloop,
                                           UInt32         capacity = 0);
    
    /*! @function withTarget
     @abstract Factory method that constructs and initializes an
     IOGatedOutputQueue object.
     @param target The object that will handle packets removed from the
     queue.
     @param action The function that will handle packets removed from the
     queue.
     @param workloop A workloop object. An IOCommandGate object is created
     and added to this workloop as an event source.
     @param capacity The initial capacity of the output queue.
     @param priorities The number of traffic priorities supported
     @result Returns an IOGatedOutputQueue object on success, or 0 otherwise. 
     */
    
    static IOGatedOutputQueue * withTarget(OSObject *     target,
                                           IOOutputAction action,
                                           IOWorkLoop *   workloop,
                                           UInt32         capacity,
                                           UInt32         priorities);
};

#endif /* !_IOGATEDOUTPUTQUEUE_H */
                                                                                                                                                                        IOKernelDebugger.h                                                                                  0100644 0001750 0001750 00000042057 12567452435 037017  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKERNELDEBUGGER_H
#define _IOKERNELDEBUGGER_H

#include <IOKit/IOService.h>

/*! @typedef IODebuggerRxHandler
    @discussion Defines the receive handler that must be implemented
    by the target to service KDP receive requests. This handler is called
    by kdpReceiveDispatcher().
    @param target The target object.
    @param buffer KDP receive buffer. The buffer allocated has room for
           1518 bytes. The receive handler must not overflow this buffer.
    @param length The amount of data received and placed into the buffer.
           Set to 0 if no frame was received during the poll interval.
    @param timeout The amount of time to poll in milliseconds while waiting
           for a frame to arrive. */

typedef void (*IODebuggerRxHandler)( IOService * target,
                                     void *      buffer,
                                     UInt32 *    length,
                                     UInt32      timeout );

/*! @typedef IODebuggerTxHandler
    @discussion Defines the transmit handler that must be implemented
    by the target to service KDP transmit requests. This handler is called
    by kdpTransmitDispatcher().
    @param target The target object.
    @param buffer KDP transmit buffer. This buffer contains a KDP frame
           to be sent on the network.
    @param length The number of bytes in the transmit buffer. */

typedef void (*IODebuggerTxHandler)( IOService * target,
                                     void *      buffer,
                                     UInt32      length );

/*! @typedef IODebuggerLinkStatusHandler
    @discussion Defines the link up handler that must be implemented
    by the target to service KDP link status requests. This handler is called
    by kdpLinkStatusDispatcher().
    @param target The target object.
    @result Return link status.
*/

typedef UInt32 (*IODebuggerLinkStatusHandler)( IOService * target); 

/*! @typedef IODebuggerSetModeHandler
    @discussion Defines the mode handler that must be implemented
    by the target to service KDP link status requests. This handler is called
    by kdpSetModeDispatcher().
    @param target The target object.
    @param active True if entering KDP and false if exiting KDP.
    @result Return true on success and false on failure.
*/

typedef bool (*IODebuggerSetModeHandler)( IOService * target, bool active); 

/*! @typedef IODebuggerLockState
    @discussion Defines flags returned by IOKernelDebugger::lock().
    @constant kIODebuggerLockTaken Set if the debugger lock was taken. */

typedef enum {
    kIODebuggerLockTaken = 0x1
} IODebuggerLockState;

/*! @class IOKernelDebugger
    @abstract Kernel debugger nub.
    @discussion This object interfaces with the KDP
    (kernel debugger protocol) module and dispatches KDP requests to its
    target (provider). The target, designated as the debugger device, must 
    implement a pair of handler functions that are called to handle KDP 
    transmit and receive requests during a debugging session. Only a single
    IOKernelDebugger in the system can be active at a given time. The
    active IOKernelDebugger is the one that has an IOKDP object attached
    as a client.

    The debugger device is usually a subclass of IOEthernetController.
    However, any IOService can service an IOKernelDebugger client,
    implement the two polled mode handlers, and transport the KDP
    packets through a data channel. However, KDP assumes that the
    debugger device is an Ethernet interface and therefore it will
    always send, and expect to receive, an Ethernet frame. */

class IOKernelDebugger : public IOService
{
    OSDeclareDefaultStructors( IOKernelDebugger )

protected:
    IOService *             _target;      // target (provider)
    IODebuggerTxHandler     _txHandler;   // target's transmit handler.
    IODebuggerRxHandler     _rxHandler;   // target's receive handler.
    IOService *             _client;      // client that has opened us.
    bool                    _pmDisabled;  // true if disabled by PM.

    struct ExpansionData {
        thread_call_t  activationChangeThreadCall;
        UInt32         stateVars[2];
        IONotifier  *  interfaceNotifier;
        IODebuggerLinkStatusHandler linkStatusHandler; // target's link status handler.
        IODebuggerSetModeHandler setModeHandler; // target's KDP mode handler.
    };

    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *         _reserved;

/*! @function kdpReceiveDispatcher
    @abstract The KDP receive dispatch function.
    @discussion Field KDP receives requests, then dispatches the call to the
    registered receiver handler.
    @param buffer KDP receive buffer. The buffer allocated by KDP has room
           for 1518 bytes. The receive handler must not overflow this buffer.
    @param length The amount of data received and placed into the buffer.
           Set to 0 if a frame was not received during the poll interval.
    @param timeout The amount of time to poll in milliseconds while waiting
           for a frame to arrive. 
*/

    static void kdpReceiveDispatcher(void *   buffer,
                                     UInt32 * length,
                                     UInt32   timeout);

/*! @function kdpTransmitDispatcher
    @abstract The KDP transmit dispatch function.
    @discussion Field KDP transmit requests, then dispatches the call to the
    registered transmit handler.
    @param buffer KDP transmit buffer. This buffer contains a KDP frame to
           be sent on the network.
    @param length The number of bytes in the transmit buffer. 
*/

    static void kdpTransmitDispatcher(void * buffer, UInt32 length);

/*! @function kdpLinkStatusDispatcher
    @abstract The KDP link status dispatch function.
    @discussion Field KDP link status requests, then dispatches the call to the
    registered link up handler.
    @result Return link status.
*/

    static UInt32 kdpLinkStatusDispatcher(void);


/*! @function kdpSetModeDispatcher
    @abstract The KDP set mode dispatch function.
    @discussion Field KDP set mode requests, then dispatches the call to the
    registered set mode handler.
    @param active TRUE if entering KDP. FALSE if leaving KDP.
    @result Return TRUE if the link is up and data can be sent/received. Otherwise,
            return FALSE.
*/

    static boolean_t kdpSetModeDispatcher(boolean_t active);

/*! @function free
    @abstract Frees the IOKernelDebugger instance. */

    virtual void free();

/*! @function nullTxHandler
    @abstract Null transmit handler.
    @discussion This function is registered as the transmit handler when an
    IOKernelDebugger object surrenders its status as the active debugger nub.
    Until another IOKernelDebugger object gets promoted, this function will
    handle polled transmit requests from KDP. This function does nothing
    useful. 
*/

    static void nullTxHandler( IOService * target,
                               void *      buffer,
                               UInt32      length );

/*! @function nullRxHandler
    @abstract Null receive handler.
    @discussion This function is registered as the receive handler when an
    IOKernelDebugger object surrenders its status as the active debugger nub.
    Until another IOKernelDebugger object gets promoted, this function will
    handle polled receive requests from KDP. This function does nothing
    except to log a warning message. 
*/

    static void nullRxHandler( IOService * target,
                               void *      buffer,
                               UInt32 *    length,
                               UInt32      timeout );

/*! @function nullLinkStatusHandler
    @abstract Null link status handler.
    @discussion This function is registered as the link status handler when an
    IOKernelDebugger object surrenders its status as the active debugger nub.
    Until another IOKernelDebugger object gets promoted, this function will
    handle polled link status requests from KDP. 
    @result This function will always report link up.
*/

    static UInt32 nullLinkStatusHandler( IOService * target);

/*! @function nullSetModeHandler
    @abstract Null set mode handler.
    @discussion This function is registered as the set mode handler when an
    IOKernelDebugger object surrenders its status as the active debugger nub.
    Until another IOKernelDebugger object gets promoted, this function will
    handle set mode requests from KDP. 
    @result This function will always return true.
*/

    static bool nullSetModeHandler( IOService * target, bool active);

/*! @function registerHandler
    @abstract Registers the target and the handler functions.
    @discussion This method is called by handleOpen() and handleClose()
    to register or unregister the target and its handler functions.
    @param target The target object.
    @param txHandler The transmit handler function. The null handler is
    registered if the argument is zero.
    @param rxHandler The receive handler function. The null handler is
    @param linkUpHandler The linkup handler function. The null handler is
    registered if the argument is zero. 
*/

    static void registerHandler( IOService *                 target,
                                 IODebuggerTxHandler         txHandler = 0,
                                 IODebuggerRxHandler         rxHandler = 0,
                                 IODebuggerLinkStatusHandler linkUpHandler = 0,
                                 IODebuggerSetModeHandler    setModeHandler = 0);

/*! @function powerStateWillChangeTo
    @abstract Handles notification that the network controller will change
    power state.
    @discussion If the controller is about to become unusable, then the
    controller's handlers are unregistered, and the controller is disabled.
    @param flags Describe the capability of the controller in the new power 
           state.
    @param stateNumber The number of the state in the state array that the 
           controller is switching to.
    @param policyMaker The policy maker that manages the controller's
           power state.
    @result Returns the constant 3000000, to indicate a maximum of 3 seconds for the 
            preparation to complete, and an acknowledgement delivered to the
            policy maker. 
*/

    virtual IOReturn powerStateWillChangeTo( IOPMPowerFlags  flags,
                                             unsigned long   stateNumber,
                                             IOService *     policyMaker );

/*! @function powerStateDidChangeTo
    @abstract Handles notification that the network controller did change
    power state.
    @discussion If the controller became usable, then the controller is 
    re-enabled, and the controller's handlers are re-registered.
    @param flags Description of the capability of the controller in the new power 
           state.
    @param stateNumber The number of the state in the state array that the 
           controller is switching to.
    @param policyMaker The policy maker that manages the controller's
           power state.
    @result Returns the constant 3000000, to indicate a maximum of 3 seconds for the 
            preparation to complete, and an acknowledgement delivered to the
            policy maker. 
*/

    virtual IOReturn powerStateDidChangeTo( IOPMPowerFlags  flags,
                                            unsigned long   stateNumber,
                                            IOService *     policyMaker );

/*! @function handleOpen
    @abstract Handles a client open.
    @discussion This method is called by IOService::open() to handle an
    open from a client (IOKDP) with the arbitration lock held.
    @param forClient The client (IOKDP) requesting the open.
    @param options Options passed to the open() call. Not used.
    @param arg A family defined argument passed to the open() call. Not used.
    @result Returns true on success, false otherwise. 
*/

    virtual bool handleOpen( IOService *    forClient,
                             IOOptionBits   options,
                             void *         arg );

/*! @function handleClose
    @abstract Handles a client close.
    @discussion This method is called by IOService::close() to handle a
    close from a client with the arbitration lock held.
    @param forClient The client (IOKDP) requesting the close.
    @param options Options passed to the close() call. Not used. 
*/

    virtual void handleClose( IOService *   forClient,
                              IOOptionBits  options );

/*! @function handleIsOpen
    @abstract Queries whether a client has an open on this object.
    @discussion This method is called by IOService::isOpen() with the
    arbitration lock held.
    @result Returns true if the specified client, or any client if none (0) is
    specified, presently has an open on this object. 
*/

    virtual bool handleIsOpen( const IOService * forClient ) const;

	static bool interfacePublished(
        void *target, void *param, IOService *service, IONotifier *notifier );

public:

/*! @function lock
    @abstract Takes the debugger lock conditionally.
    @discussion This method takes the debugger lock if the object given matches the
    target registered by registerHandler().
    @param target The target or provider of an IOKernelDebugger object.
    @result Returns kIODebuggerLockTaken if the lock was taken, or 0 otherwise. 
*/

    static IODebuggerLockState lock( IOService * target );

/*! @function unlock
    @abstract Releases the debugger lock.
    @discussion This method releases the debugger lock if the kIODebuggerLockTaken flag is
    set in the argument. 
*/

    static void unlock( IODebuggerLockState state );

/*! @function init
    @abstract Initializes an IOKernelDebugger instance.
    @param target The target object that implements the debugger handlers.
    @param txHandler The target's transmit handler. A pointer to a 'C' function.
    @param rxHandler The target's receive handler. A pointer to a 'C' function.
    @param linkStatusHandler The target's link status handler. A pointer to a 'C' function.
    @param setModeHandler The target's set mode handler. A pointer to a 'C' function.
    @result Returns true if the instance initialized successfully, false otherwise. 
*/

    virtual bool init( IOService *                 target,
                       IODebuggerTxHandler         txHandler,
                       IODebuggerRxHandler         rxHandler,
                       IODebuggerLinkStatusHandler linkUpHandler,
                       IODebuggerSetModeHandler    setModeHandler);

/*! @function debugger
    @abstract Factory method that performs allocation and initialization
    of an IOKernelDebugger object.
    @param target The target object that implements the debugger handlers.
    @param txHandler The target's transmit handler. A pointer to a 'C' function.
    @param rxHandler The target's receive handler. A pointer to a 'C' function.
    @param linkStatusHandler The target's link status handler. A pointer to a 'C' function.
    @param setModeHandler The target's set mode handler. A pointer to a 'C' function.
    @result Returns an IOKernelDebugger instance on success, 0 otherwise. 
*/

    static IOKernelDebugger * debugger( IOService *                 target,
                                        IODebuggerTxHandler         txHandler,
                                        IODebuggerRxHandler         rxHandler,
                                        IODebuggerLinkStatusHandler linkStatusHandler,
                                        IODebuggerSetModeHandler    setModeHandler);

    /*
     * Entry point for generic messages delivered from the provider.
     */

    virtual IOReturn message( UInt32 type, IOService * provider, void * arg );

/*! @function signalDebugger
    @abstract Signal the kernel to enter the debugger when safe.
*/
    static void signalDebugger(void);

    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IOKernelDebugger,  0);
    OSMetaClassDeclareReservedUnused( IOKernelDebugger,  1);
    OSMetaClassDeclareReservedUnused( IOKernelDebugger,  2);
    OSMetaClassDeclareReservedUnused( IOKernelDebugger,  3);
};

// Concise form of the lock()/unlock() static member functions.
//
#define IODebuggerLock    IOKernelDebugger::lock
#define IODebuggerUnlock  IOKernelDebugger::unlock

#endif /* !_IOKERNELDEBUGGER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IOMbufMemoryCursor.h                                                                                0100644 0001750 0001750 00000037362 12567452435 037415  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_NETWORK_IOMBUFMEMORYCURSOR_H
#define _IOKIT_NETWORK_IOMBUFMEMORYCURSOR_H

#include <IOKit/IOMemoryCursor.h>


/*! @class IOMbufMemoryCursor
    @abstract A mechanism to convert mbuf chains to physical addresses.
    @discussion The IOMbufMemoryCursor defines the super class that all
    specific mbuf cursors must inherit from, but a mbuf cursor can be created   
    without a specific formal subclass by just providing a segment function to
    the initializers. This class performs the task of walking a given
    mbuf chain and creating a physical scatter/gather list appropriate for
    the target hardware. When necessary, this class may also coalesce
    mbuf chains when the generated scatter/gather list exceeds the specified 
    hardware limit. However, this should be avoided since it exacts a 
    performance cost.
    <br><br>
    A driver is expected to create a mbuf cursor and configure it to match the
    limitations of it's DMA hardware; for instance the mbuf cursor used by
    an Ethernet controller driver may have a maximum physical segment size
    of 1520, and allow for up to 6 physical segments. Thus it would create a 
    mbuf cursor with a maxSegmentSize of 1520 and a maxNumSegments of 6.
    The driver may choose to supply an OutputSegmentFunc function to
    format the output of each scatter/gather segment to match the
    hardware descriptor format, or it may use a subclass of 
    IOMbufMemoryCursor to generate IOPhysicalSegment segments with 
    various byte orders.
    <br><br>
    A driver may also create more than one mbuf cursor, perhaps one
    dedicated for the transmit thread, and the other for the receive thread.
    This becomes a requirement when the driver is multi-threaded, since the 
    mbuf cursor maintains state and does not support reentrancy. */

class IOMbufMemoryCursor : public IOMemoryCursor
{
    OSDeclareDefaultStructors(IOMbufMemoryCursor)

protected:
    UInt32 maxNumSegments;
    UInt32 coalesceCount;
    UInt32 packetTooBigErrors;

    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    virtual bool initWithSpecification(OutputSegmentFunc outSeg,
                                       UInt32 maxSegmentSize,
                                       UInt32 maxTransferSize,
                                       UInt32 align);

public:
/*! @function initWithSpecification
    @abstract Primary initializer for the IOMbufMemoryCursor class.
    @param outSeg Function to call to output one physical segment.
    @param maxSegmentSize Maximum allowable size for one segment.
    @param maxNumSegments Maximum number of segments.
    @result Returns true if the inherited classes and this instance initialized
    successfully.
*/

    virtual bool initWithSpecification(OutputSegmentFunc outSeg,
                                       UInt32 maxSegmentSize,
                                       UInt32 maxNumSegments);

/*! @function genPhysicalSegments
    @abstract Generates a physical scatter/gather list given a mbuf packet.
    @discussion Generates a list of physical segments from the given mbuf.
    @param packet The mbuf packet.
    @param vector Void pointer to base of output physical scatter/gather list.
    Always passed directly onto the OutputSegmentFunc without interpretation
    by the cursor. 
    @param maxSegs Maximum number of segments that can be written to segments
    array.
    @param doCoalesce Set to true to perform coalescing when the required 
    number of segments exceeds the specified limit, otherwise abort and
    return 0.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    virtual UInt32 genPhysicalSegments(mbuf_t packet, void * vector,
                                       UInt32 maxSegs, bool doCoalesce);

/*! @function getAndResetCoalesceCount
    @abstract Returns a count of the total number of mbuf chains coalesced
    by genPhysicalSegments().
    @discussion This method returns a count of the total number of mbuf chains coalesced
    by genPhysicalSegments(). The counter is then reset to 0.
    @result Returns the coalesce count. 
*/

    UInt32 getAndResetCoalesceCount();

    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IOMbufMemoryCursor,  0);
    OSMetaClassDeclareReservedUnused( IOMbufMemoryCursor,  1);
    OSMetaClassDeclareReservedUnused( IOMbufMemoryCursor,  2);
    OSMetaClassDeclareReservedUnused( IOMbufMemoryCursor,  3);
};


/*! @class IOMbufNaturalMemoryCursor
    @abstract An IOMbufMemoryCursor subclass that outputs a vector of
    IOPhysicalSegments in the natural byte orientation for the cpu.  
    @discussion The IOMbufNaturalMemoryCursor would be used when it is too
    difficult to implement an OutputSegmentFunc that is more appropriate for
    your hardware.  This cursor just outputs an array of IOPhysicalSegments. 
*/

class IOMbufNaturalMemoryCursor : public IOMbufMemoryCursor
{
    OSDeclareDefaultStructors(IOMbufNaturalMemoryCursor)

public:

/*! @function withSpecification
    @abstract Factory function that creates and initializes an 
    IOMbufNaturalMemoryCursor in one operation. 
    @discussion See also IOMbufMemoryCursor::initWithSpecification.
    @param maxSegmentSize Maximum allowable size for one segment.
    @param maxNumSegments Maximum number of segments.
    @result Returns a new mbuf cursor if successfully created and initialized,
    0 otherwise. 
*/

    static IOMbufNaturalMemoryCursor * withSpecification(UInt32 maxSegmentSize, 
                                                         UInt32 maxNumSegments);

/*! @function getPhysicalSegments
    @abstract Generates a cpu natural physical scatter/gather list from a given
    mbuf.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IOPhysicalSegments for the output 
    physical scatter/gather list.
    @param numVectorSegments Maximum number of IOPhysicalSegments accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegments(mbuf_t packet,
                               struct IOPhysicalSegment * vector,
                               UInt32 numVectorSegments = 0);

/*! @function getPhysicalSegmentsWithCoalesce
    @abstract Generates a cpu natural physical scatter/gather list from a given
    mbuf.
    @discussion Generate a cpu natural physical scatter/gather list from a 
    given mbuf. Coalesce mbuf chain when the number of segments in the 
    scatter/gather list exceeds numVectorSegments.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IOPhysicalSegments for the output 
    physical scatter/gather list.
    @param numVectorSegments Maximum number of IOPhysicalSegments accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegmentsWithCoalesce(mbuf_t packet,
                                           struct IOPhysicalSegment * vector,
                                           UInt32 numVectorSegments = 0);
};

//===========================================================================
//===========================================================================

/*! @class IOMbufBigMemoryCursor
    @abstract An IOMbufMemoryCursor subclass that outputs a vector of 
    IOPhysicalSegments in the big endian byte order.  
    @discussion The IOMbufBigMemoryCursor would be used when the DMA hardware 
    requires a big endian address and length pair.  This cursor outputs an 
    array of IOPhysicalSegments that are encoded in big-endian format. 
*/

class IOMbufBigMemoryCursor : public IOMbufMemoryCursor
{
    OSDeclareDefaultStructors(IOMbufBigMemoryCursor)

public:

/*! @function withSpecification
    @abstract Factory function that creates and initializes an 
    IOMbufBigMemoryCursor in one operation.
    @discussion See also IOMbufMemoryCursor::initWithSpecification.
    @param maxSegmentSize Maximum allowable size for one segment.
    @param maxNumSegments Maximum number of segments.
    @result Returns a new mbuf cursor if successfully created and initialized,
    0 otherwise. 
*/

    static IOMbufBigMemoryCursor * withSpecification(UInt32 maxSegmentSize,
                                                     UInt32 maxNumSegments);

/*! @function getPhysicalSegments
    @abstract Generates a big endian physical scatter/gather list from a given
    mbuf.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IOPhysicalSegments for the output 
    physical scatter/gather list.
    @param numVectorSegments Maximum number of IOPhysicalSegments accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegments(mbuf_t packet,
                               struct IOPhysicalSegment * vector,
                               UInt32 numVectorSegments = 0);

/*! @function getPhysicalSegmentsWithCoalesce
    @abstract Generates a big endian physical scatter/gather list from a given
    mbuf.
    @discussion Generate a big endian physical scatter/gather list from a 
    given mbuf. Coalesce mbuf chain when the number of segments in the 
    scatter/gather list exceeds numVectorSegments.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IOPhysicalSegments for the output 
    physical scatter/gather list.
    @param numVectorSegments Maximum number of IOPhysicalSegments accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegmentsWithCoalesce(mbuf_t packet,
                                           struct IOPhysicalSegment * vector,
                                           UInt32 numVectorSegments = 0);
};

//===========================================================================
//===========================================================================

/*! @class IOMbufLittleMemoryCursor
    @abstract An IOMbufMemoryCursor subclass that outputs a vector of 
    IOPhysicalSegments in the little endian byte order.  
    @discussion The IOMbufLittleMemoryCursor would be used when the DMA 
    hardware requires a little endian address and length pair.  This cursor 
    outputs an array of IOPhysicalSegments that are encoded in little endian 
    format. 
*/

class IOMbufLittleMemoryCursor : public IOMbufMemoryCursor
{
    OSDeclareDefaultStructors(IOMbufLittleMemoryCursor)

public:

/*! @function withSpecification
    @abstract Factory function that creates and initializes an 
    IOMbufLittleMemoryCursor in one operation.
    @discussion See also IOMbufMemoryCursor::initWithSpecification.
    @param maxSegmentSize Maximum allowable size for one segment.
    @param maxNumSegments Maximum number of segments.
    @result Returns a new mbuf cursor if successfully created and initialized,
    0 otherwise. 
*/

    static IOMbufLittleMemoryCursor * withSpecification(UInt32 maxSegmentSize, 
                                                        UInt32 maxNumSegments);

/*! @function getPhysicalSegments
    @abstract Generates a little endian physical scatter/gather list from a 
    given mbuf.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IOPhysicalSegments for the output 
    physical scatter/gather list.
    @param numVectorSegments Maximum number of IOPhysicalSegments accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegments(mbuf_t packet,
                               struct IOPhysicalSegment * vector,
                               UInt32 numVectorSegments = 0);

/*! @function getPhysicalSegmentsWithCoalesce
    @abstract Generates a little endian physical scatter/gather list from a 
    given mbuf.
    @discussion Generate a little endian physical scatter/gather list from a 
    given mbuf. Coalesce mbuf chain when the number of segments in the 
    scatter/gather list exceeds numVectorSegments.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IOPhysicalSegments for the output 
    physical scatter/gather list.
    @param numVectorSegments Maximum number of IOPhysicalSegments accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegmentsWithCoalesce(mbuf_t packet,
                                           struct IOPhysicalSegment * vector,
                                           UInt32 numVectorSegments = 0);
};

#ifdef __ppc__

struct IODBDMADescriptor;

//===========================================================================
//===========================================================================

/*! @class IOMbufDBDMAMemoryCursor
    @abstract An IOMbufMemoryCursor subclass that outputs a vector of 
    IODBDMADescriptors. 
*/

class IOMbufDBDMAMemoryCursor : public IOMbufMemoryCursor
{
    OSDeclareDefaultStructors(IOMbufDBDMAMemoryCursor)

public:

/*! @function withSpecification
    @abstract Factory function that creates and initializes an 
    IOMbufDBDMAMemoryCursor in one operation.
    @discussion See also IOMbufMemoryCursor::initWithSpecification.
    @param maxSegmentSize Maximum allowable size for one segment.
    @param maxNumSegments Maximum number of segments.
    @result Returns a new mbuf cursor if successfully created and initialized,
    0 otherwise. 
*/

    static IOMbufDBDMAMemoryCursor * withSpecification(UInt32 maxSegmentSize, 
                                                       UInt32 maxNumSegments);

/*! @function getPhysicalSegments
    @abstract Generates a DBDMA descriptor list from a given mbuf.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IODBDMADescriptor for the output list.
    @param numVectorSegments Maximum number of IODBDMADescriptors accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegments(mbuf_t packet,
                               struct IODBDMADescriptor *vector,
                               UInt32 numVectorSegments = 0);

/*! @function getPhysicalSegmentsWithCoalesce
    @abstract Generates a DBDMA descriptor list from a given mbuf.
    @discussion Generate a DBDMA descriptor list from a given mbuf.
    Coalesce mbuf chain when the number of elements in the list exceeds
    numVectorSegments.
    @param packet The mbuf packet.
    @param vector Pointer to an array of IODBDMADescriptor for the output list.
    @param numVectorSegments Maximum number of IODBDMADescriptors accepted.
    @result Returns the number of segments that were filled in, or
    0 if an error occurred. 
*/

    UInt32 getPhysicalSegmentsWithCoalesce(mbuf_t packet,
                                           struct IODBDMADescriptor * vector,
                                           UInt32 numVectorSegments = 0);
};

#endif /* __ppc__ */

#endif /* !_IOKIT_NETWORK_IOMBUFMEMORYCURSOR_H */

                                                                                                                                                                                                                                                                              IONetworkController.h                                                                               0100644 0001750 0001750 00000215641 12567452435 037630  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKCONTROLLER_H
#define _IONETWORKCONTROLLER_H

/*! @defined kIONetworkControllerClass
    @abstract The name of the IONetworkController class. */

#define kIONetworkControllerClass   "IONetworkController"

/*! @defined kIOVendor
    @abstract A property of IONetworkController objects.
    @discussion The kIOVendor property is a property of IONetworkController objects.  It has an OSString value 	that describes the vendor of the network controller. */

#define kIOVendor                "IOVendor"

/*! @defined kIOModel
    @abstract A property of IONetworkController objects.
    @discussion The kIOModel property is a property of IONetworkController objects.  It has an OSString value that 	describes the model of the network controller. */

#define kIOModel                 "IOModel"

/*! @defined kIORevision
    @abstract A property of IONetworkController objects.
    @discussion The kIORevision property is a property of IONetworkController objects.  It has an OSString value 	that describes the revision level of the network controller. */

#define kIORevision              "IORevision"

/*! @defined kIOFeatures
    @abstract A property of IONetworkController objects.
    @discussion The kIOFeatures property is a property of IONetworkController objects. It has an OSNumber value 	that describes generic features defined by IONetworkController that are supported by the
        network controller. */

#define kIOFeatures              "IOFeatures"

/*! @defined kIOMediumDictionary
    @abstract A property of IONetworkController objects.
    @discussion The kIOMediumDictionary property is a property of IONetworkController
        objects.  It has an OSDictionary value that is a container for the
        collection of IONetworkMedium objects that represent the media
        types supported by the network controller.
        Each entry in the dictionary is a key/value pair consisting of
        the medium name, and a dictionary value that contains the
        properties for that medium entry. */

#define kIOMediumDictionary      "IOMediumDictionary"

/*! @defined kIODefaultMedium
    @abstract A property of IONetworkController objects.
    @discussion The kIODefaultMedium property is a property of IONetworkController
        objects.  It has an OSString value that describes the name of the
        default medium. This definition may change or disappear in the
        future. */

#define kIODefaultMedium         "IODefaultMedium"

/*! @defined kIOSelectedMedium
    @abstract A property of IONetworkController objects.
    @discussion The kIOSelectedMedium property is a property of IONetworkController
        objects.  It has an OSSymbol value that describes the name of the
        current selected medium. This name can be used as a key into the
        medium dictionary to gather additional information about the
        selected medium. */

#define kIOSelectedMedium         "IOSelectedMedium"

/*! @defined kIOActiveMedium
    @abstract A property of IONetworkController objects.
    @discussion The kIOActiveMedium property is a property of IONetworkController
        objects.  It has an OSSymbol value that describes the name of the
        active medium. This is the name of the medium where an active
        link has been established. This name can be used as a key into
        the medium dictionary to gather additional information about the
        active medium. */

#define kIOActiveMedium          "IOActiveMedium"

/*! @defined kIOLinkSpeed
    @abstract A property of IONetworkController objects.
    @discussion The kIOLinkSpeed property is a property of IONetworkController
        objects. It has an OSNumber value that describes the speed of the
    	link established over the active medium in bits per second. */

#define kIOLinkSpeed             "IOLinkSpeed"

/*! @defined kIOLinkStatus
    @abstract A property of IONetworkController objects.
    @discussion The kIOLinkStatus property is a property of IONetworkController
        objects. It has an OSNumber value that describes the current network
        link status. See IONetworkMedium for the definition of the link
        status bits. */

#define kIOLinkStatus            "IOLinkStatus"

/*! @defined kIOLinkData
    @abstract A property of IONetworkController objects.
    @discussion The kIOLinkData property is a property of IONetworkController
        objects. It has an OSData value that contains additional information
        describing the active link that was established.
        Its interpretation is not defined. */

#define kIOLinkData              "IOLinkData"

/*! @defined kIOPacketFilters
    @abstract A property of IONetworkController objects.
    @discussion The kIOPacketFilters property is a property of IONetworkController
        objects. It has an OSDictionary value that describes the entire
        set of packet filters supported by the controller. Each entry
        in the dictionary is a key/value pair consisting of the filter
        group name, and an OSNumber describing the set of supported
        filters for that group. */

#define kIOPacketFilters         "IOPacketFilters"

/*! @defined kIOMACAddress
    @abstract A property of IONetworkController objects.
    @discussion The kIOMACAddress property is a property of IONetworkController
        objects. It has an OSData value that describes the hardware
        MAC (media access controller) address, or station address,
        of the network controller. */

#define kIOMACAddress            "IOMACAddress"

/*! @defined kIOMaxPacketSize
    @abstract A property of IONetworkController objects.
    @discussion The kIOMaxPacketSize property is a property of IONetworkController
        objects. It has an OSNumber value that describes the maximum
        packet size supported by the controller. */

#define kIOMaxPacketSize         "IOMaxPacketSize"

/*! @defined kIOMinPacketSize
    @abstract A property of IONetworkController objects.
    @discussion The kIOMinPacketSize property is a property of IONetworkController
        objects. It has an OSNumber value that describes the minimum
        packet size supported by the controller. */

#define kIOMinPacketSize         "IOMinPacketSize"

/*! @defined kIONetworkFilterGroup
    @abstract The name assigned to the standard network filter group. */

#define kIONetworkFilterGroup    "IONetworkFilterGroup"

/*! @enum StandardPacketFilters
    @abstract All standard packet filters. 
    @discussion Each filter will allow the reception of certain class of packets
        depending on its destination MAC address.
    @constant kIOPacketFilterUnicast Reception of unicast packets.
    @constant kIOPacketFilterBroadcast Reception of broadcast packets.
    @constant kIOPacketFilterMulticast Reception of multicast packets
        addressed to a set of multicast addresses.
    @constant kIOPacketFilterMulticastAll Reception of all multicast
        packets.
    @constant kIOPacketFilterPromiscuous Reception of all packets.
    @constant kIOPacketFilterPromiscuousAll Reception of all packets,
        including bad packets. */

enum {
    kIOPacketFilterUnicast         = 0x1,
    kIOPacketFilterBroadcast       = 0x2,
    kIOPacketFilterMulticast       = 0x10,
    kIOPacketFilterMulticastAll    = 0x20,
    kIOPacketFilterPromiscuous     = 0x100,
    kIOPacketFilterPromiscuousAll  = 0x200
};

/*! @enum Network Feature Flags
    @abstract Feature flags returned by the getFeatures() method.
    @constant kIONetworkFeatureNoBSDWait Set this bit in the value
        returned by getFeatures() to disable the automatic wait for
        "IOBSD" resource by the IONetworkController::start() method. 
    @constant kIONetworkFeatureHardwareVlan Set this bit in the value
        returned by getFeatures() to indicate the controller supports hardware
        stripping and stuffing of 802.1q vlan tags.  If the controller supports
        this feature it must enable it when initializing so that all received
        packets delivered to higher layers have the tag stripped.  The controller
        should use setVlanTag() to provide the tag information out of band.
    @constant kIONetworkFeatureSoftwareVlan Set this bit in the value
        returned by getFeatures() to indicate that the controller can support software
        based vlan by transmitting and receiving packets 4 bytes longer that normal. 
    @constant kIONetworkFeatureMultiPages Set this bit if the driver is
	capable of handling packets coming down from the network stack that
	reside in virtually, but not in physically contiguous span of the
	external mbuf clusters.  In this case, the data area of a packet in
	the external mbuf cluster might cross one or more physical pages that
	are disjoint, depending on the interface MTU and the packet size.
	Such a use of larger than system page size clusters by the network
	stack is done for better system efficiency.  Drivers that utilize the
	IOMbufNaturalMemoryCursor with the getPhysicalSegmentsWithCoalesce
	interfaces and enumerate the list of vectors should set this flag
	for possible gain in performance during bulk data transfer.
    @constant kIONetworkFeatureTSOIPv4 Set this bit to advertise support
        for TCP/IPv4 segmentation offload.
    @constant kIONetworkFeatureTSOIPv6 Set this bit to advertise support
        for TCP/IPv6 segmentation offload.
    @constant kIONetworkFeatureTransmitCompletionStatus Set this bit to
        advertise the capability to report per-packet transmit completion status.
        See <code>IONetworkInterface::reportTransmitCompletionStatus</code>.
*/

enum {
    kIONetworkFeatureNoBSDWait                  = 0x01,
    kIONetworkFeatureHardwareVlan               = 0x02,
    kIONetworkFeatureSoftwareVlan               = 0x04,
    kIONetworkFeatureMultiPages                 = 0x08,
    kIONetworkFeatureTSOIPv4                    = 0x10,
    kIONetworkFeatureTSOIPv6                    = 0x20,
    kIONetworkFeatureTransmitCompletionStatus   = 0x40
};

#ifdef KERNEL
#ifdef __cplusplus

#include <IOKit/IOService.h>
#include <IOKit/IOWorkLoop.h>
#include <IOKit/network/IONetworkInterface.h>
#include <IOKit/network/IOKernelDebugger.h>

class  IOCommandGate;
class  IOOutputQueue;
class  IONetworkMedium;

/*! @typedef IOPacketBufferConstraints
    @discussion Constraint parameters, specified by a driver,
    for the data buffer in a packet mbuf. This is observed by
    allocatePacket() to satisfy the stated requirements.
    @field alignStart Starting address byte alignment.
    @field alignLength Buffer length byte alignment. */

typedef struct {
    UInt32  alignStart;
    UInt32  alignLength;
    UInt32  reserved[6];
} IOPacketBufferConstraints;

// Some frequently used alignment constants.
//
enum {
    kIOPacketBufferAlign1   = 1,
    kIOPacketBufferAlign2   = 2,
    kIOPacketBufferAlign4   = 4,
    kIOPacketBufferAlign8   = 8,
    kIOPacketBufferAlign16  = 16,
    kIOPacketBufferAlign32  = 32
};

/*!	@const gIONetworkFilterGroup
    @discussion gIONetworkFilterGroup is an OSSymbol object that contains
        the name of the standard network filter group as defined by
        kIONetworkFilterGroup. */

extern const OSSymbol *  gIONetworkFilterGroup;

/*! @class IONetworkController
    @abstract Implements the framework for a generic 
    network controller.
    @discussion A subclass of IONetworkController must provide
    additional functionality specific for a particular networking type.
    In addition, the driver must implement (override) a basic set of 
    hardware dependent methods to create a working driver.

    IONetworkController attaches itself to the data link layer (DLIL) via
    an IONetworkInterface object. A controller object without a companion
    interface is not accessible to the networking system. The controller
    interacts with DLIL by calling methods defined by the interface object.
    And conversely, DLIL will issue commands and packets to the controller
    through the interface object.

    IONetworkController will create an IOCommandGate and attach this
    event source to an IOWorkLoop object. All commands sent from the
    interface object are handled through the IOCommandGate object,
    which will serialize access to the controller. Outbound packets sent
    from the interface to the controller have no implicit serialization. 
    Drivers must implement an output function that is thread safe, or use
    an IOOutputQueue object which will provide a serialization model.

	Note: IONetworkController internally uses some private messaging constants
	in the sys_iokit | sub_iokit_networking range defined in 
	"IONetworkControllerPrivate.h".	If you create a client for your controller
	(for example an IOUserClient), and it overrides the IOService::message 
	method, your client may receive these messages.  It should ignore these 
	messages and pass them to super::message() 	
    */

class IONetworkController : public IOService
{
    OSDeclareAbstractStructors( IONetworkController )

private:

    IOWorkLoop *             _workLoop;
    IOCommandGate *          _cmdGate;
    IOOutputQueue *          _outputQueue;
    OSSet *                  _clientSet;
    OSCollectionIterator *   _clientSetIter;
    OSObject *               _cmdClient;
    UInt32                   _alignStart;
    UInt32                   _alignLength;
    UInt32                   _alignPadding;
    bool                     _propertiesPublished;
    IOLock *                 _mediumLock;
    IODebuggerLockState      _debugLockState;
    SInt32                   _debugLockCount;
    OSNumber *               _linkStatus;
    OSNumber *               _linkSpeed;
    const OSData *           _lastLinkData;
    const OSSymbol *         _lastActiveMediumName;
    const OSSymbol *         _lastCurrentMediumName;
    mbuf_t                   _freeList;

    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *	    _reserved;


    bool _broadcastEvent(UInt32 type, void * data = 0);

    static void debugRxHandler(IOService * handler,
                               void *      buffer,
                               UInt32 *    length,
                               UInt32      timeout);

    static void debugTxHandler(IOService * handler,
                               void *      buffer,
                               UInt32      length);

    static UInt32 debugLinkStatusHandler(IOService * handler);
    static bool debugSetModeHandler(IOService * handler, bool active);

    static IOReturn executeCommandAction(OSObject * owner,
                                         void *     arg0,
                                         void *     arg1,
                                         void *     arg2,
                                         void *     arg3);

    static IOReturn handleCommand(void * target,
                                  void * param0,
                                  void * param1,
                                  void * param2,
                                  void * param3);

public:

/*! @function init
    @abstract Initializes the IONetworkController object.
    @discussion Instance variables are initialized, then super::init()
    is called.
    @param properties A dictionary object containing a property table
        associated with this instance.
    @result Returns true on success, false otherwise. 
*/ 

    virtual bool init(OSDictionary * properties);

/*! @function start
    @abstract Starts the network controller.
    @discussion After the controller driver has successfully matched
    to a provider, this method is called to start the network controller. 
    IONetworkController will allocate resources and gather controller
    properties in its implementation. No I/O will be performed until
    the subclass tries to attach a client object. A driver must override
    this method, and call super::start() at the beginning of its own
    implementation. Then check the return value to make sure that its
    superclass was started successfully before proceeding. Tasks that
    are usually performed by a driver's start method are: resource
    allocation, hardware initialization, allocation of IOEventSources
    and attaching them to a workloop, publishing a medium dictionary,
    and finally, attaching an interface object when it is ready to
    handle client requests.
    @param provider The provider that the controller was matched
    (and attached) to.
    @result Returns true on success, false otherwise. 
*/

    virtual bool start(IOService * provider);

/*! @function stop
    @abstract Stops the network controller.
    @discussion The counterpart of start(). The controller has been
    instructed to stop running. The stop() method should release
    resources and undo actions performed by the start() method.
    Subclasses must override this method and call super::stop()
    at the end of its implementation.
    @param provider The provider that the controller was matched
    (and attached) to. */

    virtual void stop(IOService * provider);

/*! @function message
    @abstract Receives messages delivered from an attached provider.
    @discussion Handles the <code>kIOMessageDeviceSignaledWakeup</code> message
    from a provider identifying the IONetworkController as the wakeup source.
    @param type A type defined in <code>IOMessage.h</code>.
    @param provider The provider from which the message originates.
    @param argument An argument defined by the message type.
    @result An IOReturn code defined by the message type.
*/

    virtual IOReturn message(
        UInt32 type, IOService * provider, void * argument );

/*! @typedef IONetworkController::Action
    @discussion Definition of a C function that can be called
    through executeCommand().
    @param target The first argument passed to action.
    @param param0 Action parameter 0.
    @param param1 Action parameter 1.
    @param param2 Action parameter 2.
    @param param3 Action parameter 3. */

    typedef IOReturn (*Action)(void * target, void * param0,
                                              void * param1,
                                              void * param2,
                                              void * param3);

/*! @function executeCommand
    @abstract Makes a C function call through the command gate.
    @discussion This method makes a call to a C function that will be synchronized 
    with the workloop thread, and any other threads that are called
    with the workloop's gate closed.
    @param client The client requesting the action. This parameter is not
    passed to the function.
    @param action Pointer to a C function to be executed.
    @param target The first parameter in the action callout.
    @param param0 Action parameter 0.
    @param param1 Action parameter 1.
    @param param2 Action parameter 2.
    @param param3 Action parameter 3.
    @result Returns the value returned by the action. 
*/

    virtual IOReturn executeCommand(OSObject * client,
                                    Action     action,
                                    void *     target,
                                    void *     param0 = 0,
                                    void *     param1 = 0,
                                    void *     param2 = 0,
                                    void *     param3 = 0);

/*! @function outputPacket
    @abstract Transmits an output packet.
    @discussion If an IOOutputQueue was created by createOutputQueue(),
    then this method will be called by the output queue object.
    Otherwise, an interface object will call this method directly when
    it receives an output packet from the data link layer.

    There is no upper limit on the number of mbufs, hence the number of
    memory fragments, in the mbuf chain provided. Drivers must be able to
    handle cases when the mbuf count might exceed the limit supported by their
    DMA engines, and perform coalescing to copy the various memory fragments
    into a lesser number of fragments. This complexity can be hidden from
    the driver when an IOMbufMemoryCursor is used, which is able to convert
    an mbuf chain into a physical address scatter-gather list that will not
    exceed a specified number of physically contiguous memory segments.
    See IOMbufMemoryCursor.

    The implementation in IONetworkController performs no useful action
    and will drop all packets. A driver must override this method and
    process the output packet provided. The implementation in the driver
    must not block, since this may cause the network stack to be reentered
    from an unsafe point.
    @param mbuf_t An mbuf chain containing the output packet to be sent on
    the network.
    @param param A parameter provided by the caller.
    @result Returns a return code defined by the caller. 
*/

    virtual UInt32 outputPacket(mbuf_t, void * param);

/*! @function getFeatures
    @abstract Reports generic features supported by the controller and/or
    the driver.
    @result This method will always return 0. Subclasses may override
    this method and return a bit mask of all supported features. */

    virtual UInt32 getFeatures() const;

/*! @function newVendorString
    @result Returns a string describing the vendor of the network controller.
    The caller is responsible for releasing the string object returned. */

    virtual const OSString * newVendorString() const;

/*! @function newModelString
    @result Returns a string describing the model of the network controller.
    The caller is responsible for releasing the string object returned. */

    virtual const OSString * newModelString() const;

/*! @function newRevisionString
    @result Returns a string describing the hardware revision of the
    network controller. The caller is responsible for releasing the
    string object returned. */

    virtual const OSString * newRevisionString() const;

/*! @function getSelectedMedium
    @abstract Gets the current selected medium.
    @discussion If the driver has previously called setSelectedMedium() 
    to indicate its current media selection, then this method will return
    that medium object. Otherwise, the driver's property table is
    consulted and a default medium property is examined, and the
    corresponding entry in the medium dictionary is returned.
    @result Returns the current selected medium, the default medium, or 0. 
*/

    virtual const IONetworkMedium * getSelectedMedium() const;
	const IONetworkMedium * getCurrentMedium() const;

/*! @function getMediumDictionary
    @abstract Returns the medium dictionary published by the driver.
    @discussion Returns the medium dictionary published by the driver
    through publishMediumDictionary(). Use copyMediumDictionary() to
    create and get a copy of the medium dictionary.
    @result Returns the published medium dictionary, or 0 if the driver has not
    yet published a medium dictionary through publishMediumDictionary(). 
*/

    virtual const OSDictionary * getMediumDictionary() const;

/*! @function copyMediumDictionary
    @abstract Returns a copy of the medium dictionary published by the
    driver.
    @discussion The caller is responsible for releasing the dictionary
    object returned. Use getMediumDictionary() to get a reference to the
    published medium dictionary instead of creating a copy.
    @result Returns a copy of the medium dictionary, or 0 if the driver has not
    published a medium dictionary through publishMediumDictionary().
*/

    virtual OSDictionary * copyMediumDictionary() const;

/*! @function getOutputHandler
    @abstract Gets the address of the method designated to handle output 
    packets for the network controller.
    @result Returns a pointer to the outputPacket() method. 
*/

    virtual IOOutputAction getOutputHandler() const;

/*! @function doEnable
    @abstract Makes a synchronized call to enable() through executeCommand().
    @discussion Do not use this method, it may be removed in the future.
    See enable(). 
*/

    virtual IOReturn doEnable(IOService * client);

/*! @function doDisable
    @abstract Makes a synchronized call to disable() through executeCommand().
    @discussion Do not use this method, it may be removed in the future.
    See disable(). 
*/

    virtual IOReturn doDisable(IOService * client);

/*! @function getCommandGate
    @abstract Gets the IOCommandGate object created by IONetworkController.
    @discussion When IONetworkController is started, an IOCommandGate object
    is instantiated and attached to the workloop returned by getWorkLoop().
    This IOCommandGate object is used internally to synchronize client
    commands handled through executeCommand(). Subclasses that need an
    IOCommandGate should try to reuse the object returned by this method,
    rather than creating a new instance. See IOCommandGate documentation.
    @result Returns the IOCommandGate object created by IONetworkController. 
*/

    virtual IOCommandGate * getCommandGate() const;

/*! @function getHardwareAddress
    @abstract Gets the network controller's permanent hardware/station
    address. 
    @discussion This method call is synchronized by the workloop's gate.
    @param addr The buffer where the controller's hardware address should
           be stored.
    @param inOutAddrBytes The size of the address buffer provided by the
           client, and replaced by this method with the actual size of
           the hardware address in bytes.
    @result Returns kIOReturnSuccess on success, or an error otherwise. 
*/

    virtual IOReturn getHardwareAddress(void *   addr,
                                        UInt32 * inOutAddrBytes) = 0;

/*! @function setHardwareAddress
    @abstract Sets or changes the station address used by the network
    controller. 
    @discussion This method call is synchronized by the workloop's gate.
    @param addr The buffer containing the hardware address provided by
    the client.
    @param addrBytes The size of the address buffer provided by the
    client in bytes.
    @result Returns kIOReturnSuccess on success, or an error otherwise. 
*/

    virtual IOReturn setHardwareAddress(const void * addr,
                                        UInt32       addrBytes) = 0;

/*! @function enable
    @abstract Handles an enable request from a client.
    @discussion This method handles an enable request from a client. A client will call
    enable after it has opened the controller, and before it starts to use
    the controller to send and to receive packets over the network. The
    client object provided is typecasted using OSDynamicCast, and depending
    on whether the client is an IOKernelDebugger or an IONetworkInterface,
    then an overloaded enable method that takes a more specific argument
    type is called. If the client matches neither type, then
    kIOReturnBadArgument is returned. A driver has the option of overriding
    this base enable method, or the overloaded form. This method call is
    synchronized by the workloop's gate.
    @param client The client object requesting the enable.
    @result Returns the return value from the overloaded enable() method, or
    kIOReturnBadArgument if the client type is unknown. 
*/

    virtual IOReturn enable(IOService * client);

/*! @function disable
    @abstract Handles a disable request from a client.
    @discussion This method handles a disable request from a client. A client will call
    disable if it has previously enabled the controller, and it no longer
    needs to transport packets or perform I/O using the controller.
    The client object is typecasted using OSDynamicCast, and depending on
    whether the client is an IOKernelDebugger or an IONetworkInterface,
    then an overloaded disable method that takes a more specific argument
    type is called. If the client matches neither type, then
    kIOReturnBadArgument is returned. A driver has the option of overriding
    this base disable method, or the overloaded form. This method call is
    synchronized by the workloop's gate.
    @param client The client object requesting the disable.
    @result Returns the return from the overloaded disable() method, or
    kIOReturnBadArgument if the client type is unknown.
*/
    
    virtual IOReturn disable(IOService * client);

/*! @function setMaxPacketSize
    @abstract A client request to change the maximum packet size.
    @discussion This method call is synchronized by the workloop's gate.
    @param maxSize The new maximum packet size.
    @result Returns kIOReturnUnsupported. Drivers may override this method
    and return either kIOReturnSuccess to indicate that the new size
    was accepted and is in effect, or an error code to indicate failure. 
*/

    virtual IOReturn setMaxPacketSize(UInt32 maxSize);

/*! @function getMaxPacketSize
    @abstract Gets the maximum packet size supported by the controller.
    @param maxSize Pointer to the return value.
    @result Returns kIOReturnSuccess on success, or an error code otherwise. 
*/

    virtual IOReturn getMaxPacketSize(UInt32 * maxSize) const = 0;

/*! @function getMinPacketSize
    @abstract Gets the minimum packet size supported by the controller.
    @param minSize Pointer to the return value.
    @result Returns kIOReturnSuccess on success, or an error code otherwise. 
*/

    virtual IOReturn getMinPacketSize(UInt32 * minSize) const = 0;

/*! @function selectMedium
    @abstract A client request to change the medium selection.
    @discussion This method is called when a client issues a command
    for the controller to change its current medium selection.
    The implementation must call setSelectedMedium() after the change
    has occurred. This method call is synchronized by the workloop's
    gate.
    @param medium An entry from the published medium dictionary that
    represents the selection chosen by the client.
    @result Returns kIOReturnUnsupported. Drivers may override this method and
    return kIOReturnSuccess if the selection was successful,
    or an error code otherwise. 
*/

    virtual IOReturn selectMedium(const IONetworkMedium * medium);

/*! @function selectMediumWithName
    @abstract A client request to change the medium selection.
    @discussion This method is called when a client issues a command
    for the controller to change its current medium selection.
    This implementation will look for an entry in the medium
    dictionary published by the driver that is associated with the
    key given. If a match is found, then selectMedium() is called to
    perform the selection, otherwise an error is reported back to the
    client. Subclasses should override selectMedium() and not this
    method. This method call is synchronized by the workloop's gate.
    @param mediumName An OSSymbol object that describes the name of the
    new medium selected by the client.
    @result Returns the return from selectMedium() if a matching entry was found
    from the medium dictionary. Returns kIOReturnUnsupported if a medium
    dictionary does not exist, or kIOReturnBadArgument if the name given
    does not match any entry in the medium dictionary. 
*/

    virtual IOReturn selectMediumWithName(const OSSymbol * mediumName);

/*! @function getPacketFilters
    @abstract Gets the set of packet filters supported by the network 
    controller for the given filter group.
    @discussion A subclass must implement this method and report the
    set of filters that are supported for the given filter group.
    This method call is synchronized by the workloop's gate.
    @param group The name of the filter group.
    @param filters Pointer to the mask of supported filters returned by
    	this method.
    @result Returns kIOReturnSuccess on success, or an error to indicate a
    failure to discover the set of supported filters. 
*/

    virtual IOReturn getPacketFilters(const OSSymbol * group,
                                      UInt32 *         filters) const = 0;

/*! @function enablePacketFilter
    @abstract Enables one of the supported packet filters from the
    given filter group.
    @discussion A client will call this method to enable a supported filter
    from the filter group specified. If the client wishes to enable more
    than one filter, it must call this method multiple times to enable the
    desired set of filters. This method call is synchronized by the
    workloop's gate.
    @param group The name of the filter group containing the filter to be
    enabled.
    @param aFilter The filter to enable.
    @param enabledFilters All filters currently enabled by the client.
    @param options Optional flags for the enable request.
    @result Returns kIOReturnSuccess on success, or an error otherwise. 
*/

    virtual IOReturn enablePacketFilter(const OSSymbol * group,
                                        UInt32           aFilter,
                                        UInt32           enabledFilters,
                                        IOOptionBits     options = 0) = 0;

/*! @function disablePacketFilter
    @abstract Disables a packet filter that is currently enabled from the
    given filter group.
    @discussion After a supported filter has been successfully enabled,
    a client can call this method to disable that filter. This method call
    is synchronized by the workloop's gate.
    @param group The name of the filter group containing the filter to be
    disabled.
    @param aFilter The filter to disable.
    @param enabledFilters All filters currently enabled by the client.
    @param options Optional flags for the disable request.
    @result Returns kIOReturnSuccess on success, or an error otherwise. 
*/

    virtual IOReturn disablePacketFilter(const OSSymbol * group,
                                         UInt32           aFilter,
                                         UInt32           enabledFilters,
                                         IOOptionBits     options = 0) = 0;

/*! @function getOutputQueue
    @abstract Gets the IOOutputQueue object created by createOutputQueue().
    @result Returns a reference to the output queue object created by
    createOutputQueue(). 
*/

    virtual IOOutputQueue * getOutputQueue() const;

/*! @function getPacketBufferConstraints
    @abstract Gets the controller's packet buffer constraints.
    @discussion Called by start() to obtain the constraints on the
    memory buffer for each mbuf packet allocated through allocatePacket().
    Drivers can override this method to specify the buffer constraints
    imposed by their bus master hardware. Note that outbound packets,
    those that originate from the network stack, are not currently
    subject to the constraints reported here.
    @param constraints A pointer to an IOPacketBufferConstraints
    structure that this method is expected to initialize.
    See IOPacketBufferConstraints structure definition. 
*/

    virtual void getPacketBufferConstraints(
                    IOPacketBufferConstraints * constraints) const;

/*! @function allocatePacket
    @abstract Allocates a packet with a data buffer that is larger than
    or equal to the size specified.
    @discussion This method will always return a single mbuf unless the
    size requested (plus the alignment padding) is greater than MCLBYTES.
    The data buffer for the mbuf (or an mbuf chain) returned is aligned
    according to the constraints reported by getPacketBufferConstraints().
    The length fields in each mbuf returned are set by this method, thus
    allowing the mbuf to be passed directly to an IOMbufMemoryCursor object
    in order to convert the mbuf to a physical address scatter-gather list.
    @param size The minimum size of the data buffer for the mbuf
    packet allocated.
    @result Returns an mbuf packet, or 0 if allocation failed. 
*/

    virtual mbuf_t allocatePacket(UInt32 size);

/*! @function copyPacket
    @abstract Allocates a new packet, containing data copied from an
    existing source packet.
    @discussion The source packet is not modified by this method.
    @param m The source packet.
    @param size The number of bytes to copy. If set to 0, then the
    entire data buffer from the source packet is copied.
    @result Returns a new packet containing the same data as the source packet. 
*/

    virtual mbuf_t copyPacket(const mbuf_t m, UInt32 size = 0);

/*! @function replacePacket
    @abstract Allocates a new packet to replace an existing packet, the
    existing packet is then returned.
    @param mp A handle to the existing packet.
    @param size If size is 0, then the new packet shall have the same buffer
    size as the original packet that is being replaced. Otherwise, the new
    packet shall have the buffer size specified by this value.
    @result If packet allocation was successful, then a replacement will
    take place and the original packet will be returned. Otherwise, 0
    is returned, and the original packet will be left untouched.
*/

    virtual mbuf_t replacePacket(mbuf_t * mp, UInt32 size = 0);

/*! @function replaceOrCopyPacket
    @abstract A helper method that combines the functionality of
    copyPacket() and replacePacket() to process a packet containing
    a received frame.
    @discussion This method will either make a copy or replace the existing
    packet, whichever is more time efficient. Packets containing small frames
    are copied, otherwise they are replaced. If replaced, then the existing
    packet is returned, and a new packet with the same buffer size is created
    to take its place. If copied, the existing packet is left intact, while a
    copy is returned that will hold a copy of the data from the source packet.
    @param mp A handle to the existing packet that may be replaced.
    @param length The number of bytes received held in the packet.
        Must be greater than zero.
    @param replaced Pointer to a return value that is set to true to indicate
        that the existing packet was replaced, or false to indicate that the
        existing packet was not replaced, and a copy was created.
    @result Returns a replacement or a copy of the existing packet, or 0 if packet
    allocation failed. 
*/

    virtual mbuf_t replaceOrCopyPacket(mbuf_t * mp,
                                       UInt32   length,
                                       bool *   replaced);

    enum {
        kDelayFree = 0x01
    };

/*! @function freePacket
    @abstract Releases the packet given back to the free pool.
    @param mbuf_t The packet to be freed.
    @param options When kDelayFree option is set, then the packet
    provided to this function will be queued on the free packet queue.
    A subsequent call to releaseFreePackets() will release all queued
    packets by making a single BSD function call. Without the kDelayFree
    option, the packet provided will be released immediately. 
*/

    virtual void freePacket(mbuf_t, IOOptionBits options = 0);

/*! @function releaseFreePackets
    @abstract Releases all packets held in the free packet queue.
    @discussion The free packet queue is not protected by a lock. This
    function must be called in a single-threaded manner with respect to
    all calls to freePacket() with the kDelayFree option set.
    @result Returns the number of packets queued and released. 
*/

    virtual UInt32 releaseFreePackets();

/*! @enum TCP/IP Checksums
    @abstract TCP/IP checksums that may be supported by the
    hardware.
    @constant kChecksumFamilyTCPIP A value that describes the collection
    of TCP/IP checksums.
    @constant kChecksumIP An IP header checksum.
    @constant kChecksumTCP A TCP checksum that covers the TCP header and TCP
    data.
    @constant kChecksumUDP A UDP checksum that covers the UDP header and UDP
    data.
    @constant kChecksumTCPIPv6 A TCP checksum that covers the IPv6 pseudo header,
    TCP header and TCP data.
    @constant kChecksumUDPIPv6 A UDP checksum that covers the IPv6 pseudo header,
    UDP header and UDP data.
    @constant kChecksumTCPNoPseudoHeader A TCP checksum that covers the TCP
    header and the TCP data, but the pseudo header is not included in the
    checksum computation. A partial 16-bit checksum value must be provided
    to allow the protocol stacks to calculate and verify the final checksum.
    This type of checksum is not currently supported on the output path.
    @constant kChecksumUDPNoPseudoHeader A UDP checksum that covers the UDP
    header and the UDP data, but the pseudo header is not included in the
    checksum computation. A partial 16-bit checksum value must be provided
    to allow the protocol stacks to calculate and verify the final checksum.
    This type of checksum is not currently supported on the output path.
    @constant kChecksumTCPSum16 The hardware has a simple checksum engine
    that can perform a TCP style ones complement sum of 16-bit words over 
    a certain range of bytes in a packet. The hardware does not have the
    ability to scan for IP or TCP headers, and the driver must pass/get
    additional parameter(s) to or from the protocol stack to coordinate
    the checksumming effort. 
*/

    enum {
        kChecksumFamilyTCPIP         = 0x00000001,
        kChecksumIP                  = 0x0001,
        kChecksumTCP                 = 0x0002,
        kChecksumUDP                 = 0x0004,
        kChecksumTCPIPv6             = 0x0020,
        kChecksumUDPIPv6             = 0x0040,
        kChecksumTCPNoPseudoHeader   = 0x0100,
        kChecksumUDPNoPseudoHeader   = 0x0200,
        kChecksumTCPSum16            = 0x1000
    };

/*! @function getChecksumSupport
    @abstract Gets checksums that are supported by the network controller for
    the given checksum family.
    @discussion A network controller that is capable of inserting and verifying
    checksums on output and input packets, should override this method and
    advertise its capability in order to assist or offload the software checksum
    calculations performed by the protocol stacks.
    @param checksumMask A pointer to the mask of supported checksums returned
    by this method.
    @param checksumFamily A value that specifies the checksum family.
    @param isOutput Set to true to query the support for checksum insertion on
    output packets, or false to query the support for checksum verification
    on input packets. Controllers that have symmetric hardware checksum support 
    can return a fixed checksum mask value, and ignore this argument.
    @result Default return is kIOReturnUnsupported. Controllers that override
    this method must return kIOReturnSuccess. Any other return value will be
    interpretated as a lack of checksum support, regardless of the value
    returned through the first argument. 
*/

    virtual IOReturn getChecksumSupport( UInt32 * checksumMask,
                                         UInt32   checksumFamily,
                                         bool     isOutput );

/*! @function setChecksumResult
    @abstract Encodes a received packet with the checksum result reported
    by the hardware.
    @discussion A network controller that can verify the checksum(s) for a
    received packet, should call this method to encode the result on the
    packet, before passing it up towards the protocol stacks.
    @param packet An mbuf containing a packet that has been checksummed by
    the hardware.
    @param checksumFamily A value that specifies the checksum family.
    @param resultMask A mask of all checksums that were checked or computed.
    Setting a bit implies that the driver is able to report the result of
    the checksum computation, by asserting the validity of the checksum,
    or by returning a partial checksum value.
    @param validMask A mask of all checksums are were computed and verified
    by the hardware as valid. Certain types of checksum performed by the
    hardware are inheritely incomplete, and therefore should never be marked
    as valid. A checksum cannot be marked valid unless it has also been
    checked.
    @param param0 Optional parameter 0, defaults to 0.
    @param param1 Optional parameter 1, defaults to 0.
    @result Returns true if the checksum family is valid and the packet has been
    encoded with the checksum result provided, false otherwise. 
*/

    virtual bool setChecksumResult( mbuf_t  packet,
                                    UInt32  checksumFamily,
                                    UInt32  resultMask,
                                    UInt32  validMask,
                                    UInt32  param0 = 0,
                                    UInt32  param1 = 0 );

/*! @function getChecksumDemand
    @abstract Fetches the demand for hardware checksum computation and insertion
    for the given packet before it is transmitted on the network.
    @discussion A network controller that can insert a checksum for output
    packets must call this method to obtain the set of checksums that it must
    compute, and insert into the appropriate fields in the given output packet.
    @param packet An mbuf containing a packet that may be missing one or more
    checksums in the specified checksum family.
    @param checksumFamily A value that specifies the checksum family.
    @param demandMask A mask of all checksums that the hardware must compute
    and insert into the appropriate checksum fields in the packet.
    @param param0 Optional parameter 0, defaults to 0.
    @param param1 Optional parameter 1, defaults to 0. 
*/

    virtual void getChecksumDemand( const mbuf_t packet,
                                    UInt32       checksumFamily,
                                    UInt32 *     demandMask,
                                    void *       param0 = 0,
                                    void *       param1 = 0 );

/*! @function publishMediumDictionary
    @abstract Publishes a dictionary of IONetworkMedium objects to
    advertise the media selection supported by the network controller.
    @discussion Called by drivers to publish their medium dictionary.
    Each entry in the dictionary is an IONetworkMedium object that
    represents a single medium that is supported by the controller.
    This method will make a copy of the dictionary provided, then add
    the copy to the driver's property table. The dictionary provided
    can be released by the caller upon returning from this method.
    It is permissible to call this method multiple times, which may be
    necessary if the hardware's media capability changes dynamically.
    However, if the capability is static, which is often the case,
    then a driver will typically call this method only once from
    its start() method.

    Several methods depend on the presence of a medium dictionary.
    They should be called after the medium dictionary has been
    published. Those methods are:
        setSelectedMedium()
        getSelectedMedium()
        getMediumDictionary()
        copyMediumDictionary()

    @param mediumDict A dictionary of IONetworkMedium objects.
    @result Returns true if the dictionary is valid, and was successfully
    exported to the property table, false otherwise. 
*/

    virtual bool publishMediumDictionary(const OSDictionary * mediumDict);

/*! @function setSelectedMedium
    @abstract Designates an entry in the published medium dictionary as
    the current selected medium.
    @discussion After the driver has configured the hardware to select
    one of its supported media types, it must call this method to inform
    its parent about the change that has occurred. IONetworkController
    will update a property in the registry to reflect the current selection.
    @param medium A medium object representing the current selection.
    @result Returns true if the property table update was successful,
    false if the update failed, or if the medium provided does not match
    any entry from the published medium dictionary. 
*/

    virtual bool setSelectedMedium(const IONetworkMedium * medium);
    bool setCurrentMedium(const IONetworkMedium * medium);

/*! @function setLinkStatus
    @abstract Reports the link status and the active medium.
    @discussion Drivers must call this method when a link change is
    detected. IONetworkController will update the link status properties
    in the registry, and generate an event to inform the upper layers
    about the change.
    @param status Link status bits.
           See IONetworkMedium for the definition of the link status bits.
    @param activeMedium An object in the published medium dictionary
    	   that represents the active medium. This may not be the same as
    	   the selected medium. Set this to 0 if the link is inactive.
    @param speed Link speed in units of bits per second. If zero, then
           the link speed is taken from the medium object provided.
    @param data An OSData containing any additional link parameter that
           the driver wishes to publish to the registry.
    @result Returns true if all link properties were successfully updated,
    false otherwise. 
*/

    virtual bool setLinkStatus(
                           UInt32                  status,
                           const IONetworkMedium * activeMedium = 0,
                           UInt64                  speed        = 0,
                           OSData *                data         = 0);

/*! @function systemWillShutdown
    @abstract Handles system shutdown and restart notifications.
    @discussion Overrides <code>IOService::systemWillShutdown</code> in order
    to notify network clients that the power-managed controller should be disabled.
    As a result, drivers can expect their <code>disable</code> method to be called
    before system shutdown or restart. This implementation is synchronous and can
    block before calling <code>IOService::systemWillShutdown</code> and return.
    @param specifier
	<code>kIOMessageSystemWillPowerOff</code> or <code>kIOMessageSystemWillRestart</code>.
    @see //apple_ref/cpp/instm/IOService/systemWillShutdown/void/(IOOptionBits) IOService::systemWillShutdown
*/

    virtual void systemWillShutdown( IOOptionBits specifier );

    /* Override IOService::setAggressiveness() */

    virtual IOReturn setAggressiveness(
            unsigned long type, unsigned long newLevel );

protected:

/*! @function free
    @abstract Frees the IONetworkController object.
    @discussion Frees the IONetworkController object by releasing all
    allocated resources, followed by a call to super::free(). 
*/

    virtual void free();

/*! @function registerWithPolicyMaker
    @abstract Implemented by controller drivers to register with
    the power management policy-maker.
    @discussion Drivers that are able to power manage their hardware
    should override this method and register with the policy-maker
    provided by calling IOService::registerPowerDriver().
    IONetworkController will call this method before the initial
    attempt is made to attach a client.
    @param policyMaker The policy-maker chosen to manage power for
    this network controller.
    @result Returns kIOReturnSuccess on success, kIOReturnUnsupported if the
    driver does not support power management, or an appropriate error
    return code. The default return is kIOReturnUnsupported. */

    virtual IOReturn registerWithPolicyMaker(IOService * policyMaker);

/*! @function createWorkLoop
    @abstract Method called by IONetworkController prior to the initial
    getWorkLoop() call.
    @discussion Before IONetworkController calls getWorkLoop() in its
    start() method, it will call createWorkLoop() to make sure that a
    subclass that wants to create a workloop, will do so before its
    first use.
    @result Returns true to indicate success, false otherwise. Returning false
    will fail IONetworkController::start(). 
*/

    virtual bool createWorkLoop();

/*! @function prepare
    @abstract Prepares the controller before an IOService is created and
    attached as a client.
    @discussion This method is called by attachInterface() or
    attachDebuggerClient() to prepare the controller before the new client
    object is attached. This method will call publishProperties() to publish
    controller capabilities and properties that may be used by client objects.
    However, publishProperties() will be called only once, even if prepare()
    is called multiple times. This method call is synchronized by the
    workloop's gate.
    @result Returns kIOReturnSuccess on success, or an error code otherwise.
        Returning an error will fail the client attach. 
*/

    virtual IOReturn prepare();

/*! @function publishProperties
    @abstract Publishes controller properties and capabilities.
    @discussion Called by IONetworkController to discover controller
    properties, and publish them to the property table in the I/O Kit
    Registry. This method is called once by prepare().
    @result Returns true if all properties were discovered and published
    successfully, false otherwise. Returning false will prevent client
    objects from attaching to the controller, since a property that
    a client relies upon may be missing. */

    virtual bool publishProperties();

/*! @function getCommandClient
    @abstract Gets the command client object.
    @discussion Methods called on the workloop context to service a
    client request can call this method to get the client object that
    initiated the command.
    @result Returns the command client. If the caller is not running on the
    workloop thread, or if the thread does not have the workloop's gate
    closed, then 0 is returned. 
*/

    virtual OSObject * getCommandClient() const;

/*! @function handleOpen
    @abstract Handles a client open.
    @discussion This method handles a client open on the controller object. IOService
    calls this method with the arbitration lock held. Subclasses
    should not override this method.
    @param client The client that is attempting to open the controller.
    @param options Not used. See IOService.
    @param argument Not used. See IOService.
    @result Returns true to accept the client open, false to refuse it. 
*/

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       argument);

/*! @function handleClose
    @abstract Handles a client close.
    @discussion This method handles a close from one of the client objects. IOService
    calls this method with the arbitration lock held. Subclasses
    should not override this method.
    @param client The client that is closing the controller.
    @param options Not used. See IOService. 
*/

    virtual void handleClose(IOService * client, IOOptionBits options);

/*! @function handleIsOpen
    @abstract Queries whether a client has an open on the controller.
    @discussion This method is always called by IOService with the
    arbitration lock held. Subclasses should not override this method.
    @result Returns true if the specified client, or any client if none (0) is
    specified, presently has an open on this object. 
*/

    virtual bool handleIsOpen(const IOService * client) const;

/*! @function enable
    @abstract A request from an interface client to enable the controller.
    @discussion This method is called by an interface client to enable the controller.
    Upon receiving this command, the controller driver must bring up the
    hardware and become ready to transmit and receive packets. A driver
    should also delay the allocation of most runtime resources until this
    method is called in order to conserve system resources. This method call
    is synchronized by the workloop's gate.
    @param interface The interface client object that requested the enable.
    @result Returns kIOReturnUnsupported. Drivers that override this method must
    return kIOReturnSuccess on success, or an error code otherwise. 
*/

    virtual IOReturn enable(IONetworkInterface * interface);

/*! @function disable
    @abstract A request from an interface client to disable the controller.
    @discussion This method is called by an interface client to disable the controller.
    This method should stop the hardware and disable hardware interrupt
    sources. Any resources allocated by enable() should also be deallocated.
    This method call is synchronized by the workloop's gate.
    @param interface The interface object that requested the disable.
    @result kIOReturnUnsupported. Drivers that override this method must
    return Returns kIOReturnSuccess on success, or an error code otherwise. 
*/

    virtual IOReturn disable(IONetworkInterface * interface);

/*! @function attachInterface
    @abstract Attaches a new network interface client object.
    @discussion This method creates a new network interface object and attaches
    it as a client of the controller. The <code>createInterface()</code> method
    is used to allocate and to initialize the interface, followed by a call to
    <code>configureInterface()</code> to configure the interface. Subclasses
    may override those two methods to customize the new interface object.
    Before this method returns, <code>registerService()</code> is called on the
    interface to start matching, which will ultimately attach the interface
    to the networking stack.
    Drivers will typically call this method from their <code>start()</code>
    method after they are ready to process interface requests. This has the
    desirable effect of preventing the <code>busyState</code> at the IOService
    root from becoming zero before the interface object has completed matching,
    which then holds off the user process that is waiting for I/O Kit to become
    quiet before assigning BSD names to all interfaces. Drivers that are unable
    to trigger interface matching synchronously from their <code>start()</code>
    method should instead call <code>adjustBusy</code> to manually increment
    the <code>busyState</code>, then followed by a <code>busyState</code> 
    decrement after attaching and registering the interface, or after a
    reasonable timeout.
    @param interface Upon success (return value is <code>true</code>), the
    pointer to the interface object will be written to the argument provided.
    @param doRegister If true, start interface matching before returning.
    Drivers can pass <code>false</code> to postpone interface matching, then
    register the interface when ready.
    @result Returns <code>true</code> on success, <code>false</code> otherwise. 
*/

    virtual bool attachInterface(IONetworkInterface ** interface,
                                 bool                  doRegister = true);

/*! @function detachInterface
    @abstract Detaches an interface client object.
    @discussion This method will verify that the object provided is indeed
    an IONetworkInterface instance, and then call its terminate() method.
    Note that an interface object will close and detach from its 
    controller after the data link layer has removed all references to 
    all data structures exposed by the interface. The interface object
    should be released following this call.
    @param interface An interface object to be detached and terminated.
    @param sync If true, the interface is terminated synchronously.
           This may cause this method to block for an indeterminate
           amount of time. */

    virtual void detachInterface(IONetworkInterface * interface,
                                 bool                 sync = false);

/*! @function createInterface
    @abstract Creates a new network interface object.
    @discussion This method is called by attachInterface() to perform
    allocation and initialization of a new interface object. A subclass of
    IONetworkController must implement this method and return a matching
    interface object. For example, IOEthernetController's implementation
    will return an IOEthernetInterface object when createInterface() is
    called.
    @result Returns a newly allocated and initialized interface object. 
*/

    virtual IONetworkInterface * createInterface() = 0;

/*! @function configureInterface
    @abstract Configures a newly created network interface object.
    @discussion This method configures an interface object that was created by
    createInterface(). Subclasses can override this method to customize
    and examine the interface object that will be attached to the
    controller as a client.
    @param interface The interface object to be configured.
    @result Returns true if the operation was successful, false otherwise
    (this will cause attachInterface() to fail and return 0). 
*/

    virtual bool configureInterface(IONetworkInterface * interface);

/*! @function createOutputQueue
    @abstract Creates an IOOutputQueue to handle output packet queueing,
    and also to resolve contention for the controller's transmitter from
    multiple client threads.
    @discussion This method is called by start() to create an IOOutputQueue object to
    handle output packet queueing. The default implementation will always
    return 0, hence no output queue will be created. A driver may override
    this method and return a subclass of IOOutputQueue. IONetworkController
    will keep a reference to the queue created, and will release this
    object when IONetworkController is freed. Also see getOutputQueue().
    @result Returns a newly allocated and initialized IOOutputQueue object. 
*/

    virtual IOOutputQueue * createOutputQueue();

/*! @function enable
    @abstract An enable request from an IOKernelDebugger client.
    @discussion Drivers that provide debugging support may either override
    this method and set up the hardware to support the polled-mode send and
    receive methods, receivePacket() and sendPacket(), or override the base
    enable() and disable() methods that take an IOService argument.
    @param debugger The IOKernelDebugger client requesting the enable.
    @result Returns kIOReturnSuccess. Drivers must return kIOReturnSuccess
    on success, or an error otherwise. 
*/

    virtual IOReturn enable(IOKernelDebugger * debugger);

/*! @function disable
    @abstract A disable request from an IOKernelDebugger client.
    @discussion Drivers that provide debugging support may either override
    this method to disable support for the polled-mode send and receive
    methods, or override the base enable() and disable() methods that
    take an IOService argument.
    @param debugger The IOKernelDebugger client requesting the disable.
    @result Returns kIOReturnSuccess. Drivers must return kIOReturnSuccess
    on success, or an error otherwise. 
*/

    virtual IOReturn disable(IOKernelDebugger * debugger);

/*! @function attachDebuggerClient
    @abstract Attaches a new IOKernelDebugger client object.
    @discussion This method allocates an IOKernelDebugger object and attaches it as
    a client. Having a debugger client implies that the controller
    supports kernel debugging, and therefore must implement the two
    polled-mode methods that are called by the debugger client. See
    sendPacket() and receivePacket(). Only a single debugger client
    should be attached to each controller.
    @param debuggerP A handle that will return the new
           IOKernelDebugger object created.
    @result Returns true on success, false otherwise. 
*/

    virtual bool attachDebuggerClient(IOKernelDebugger ** debuggerP);

/*! @function detachDebuggerClient
    @abstract Detaches an IOKernelDebugger client object.
    @discussion This method detaches and terminates the IOKernelDebugger client object
    provided. A synchronous termination is issued, and this method will
    return after the debugger client has been terminated. The debugger
    client should be released following this call.
    @param debugger The IOKernelDebugger object to be detached and
           terminated. If the argument provided is NULL or is not an
           IOKernelDebugger, this method will return immediately. 
*/

    virtual void detachDebuggerClient(IOKernelDebugger * debugger);

/*! @function reserveDebuggerLock
    @abstract Takes the global debugger lock.
    @discussion This method should not be used. Instead, call the
    lock() method provided by IOKernelDebugger. 
*/

    void reserveDebuggerLock();

/*! @function releaseDebuggerLock
    @abstract Releases the global debugger lock.
    @discussion This method should not be used. Instead, call the
    unlock() method provided by IOKernelDebugger. 
*/

    void releaseDebuggerLock();

/*! @function receivePacket
    @abstract Debugger polled-mode receive handler.
    @discussion This method must be implemented by a driver that supports
    kernel debugging. After a debugger client has been attached through
    attachDebuggerClient(), this method will be called by the debugger
    client to poll for an incoming packet when the kernel debugger is active.
    This method may be called from the primary interrupt context, and the
    implementation must avoid any memory allocation, and must never block.
    The receivePacket() method in IONetworkController is used as a placeholder,
    it performs no useful action, and should not be called. A driver that
    attaches a debugger client must override this method.
    @param pkt Address of a receive buffer where the received packet should
           be stored. This buffer has room for 1518 bytes.
    @param pktSize Address where the number of bytes received must be
           recorded. Set this to zero if no packets were received during
           the timeout interval.
    @param timeout The maximum amount of time in milliseconds to poll for
           a packet to arrive before this method must return. 
*/ 

    virtual void receivePacket(void * pkt, UInt32 * pktSize, UInt32 timeout);

/*! @function sendPacket
    @abstract Debugger polled-mode transmit handler.
    @discussion This method must be implemented by a driver that supports
    kernel debugging. After a debugger client has been attached through
    attachDebuggerClient(), this method will be called by the debugger
    to send an outbound packet only when the kernel debugger is active.
    This method may be called from the primary interrupt context, and the
    implementation must avoid any memory allocation, and must never block.
    The sendPacket() method in IONetworkController is used as a placeholder,
    it performs no useful action, and should not be called. A driver that
    attaches a debugger client must override this method.
    @param pkt Pointer to a transmit buffer containing the packet to be
        sent on the network.
    @param pktSize The size of the transmit buffer in bytes. 
*/

    virtual void sendPacket(void * pkt, UInt32 pktSize);

/*! @function getDebuggerLinkStatus
    @abstract Debugger polled-mode link status handler.
    @discussion This method should be implemented by a driver that wishes to support
    early availability kernel debugging. After a debugger client has been attached through
    attachDebuggerClient(), this method will be called by the debugger
    to poll for link status availability only when the kernel debugger is active.
    This method may be called from the primary interrupt context. As a result, the
    implementation must avoid any memory allocation, not use spinlocks, and
    never block.

    The getDebuggerLinkStatus() method in IONetworkController is used as a placeholder
    and always reports that the link is up. A driver that attaches a debugger client 
    should override this method. The driver should do any setup required to make 
    sure the link is available for use. Prior to sending or receiving data, KDP will call this 
    function repeatedly until it indicates that the link is both valid and active 
    (kIONetworkLinkValid | kIONetworkLinkActive). 

    @result Link status bits. See IONetworkMedium for the definition of the link status bits.
*/
    virtual UInt32 getDebuggerLinkStatus(void);

/*! @function setDebuggerMode
    @abstract Set debugger mode for network drivers.
    @discussion This method should be implemented by a driver that wishes to be notified when
    entering or leaving KDP. After a debugger client has been attached through
    attachDebuggerClient(), this method will be called by the debugger
    to inform the driver that the kernel debugger is going active or inactive.
    This method may be called from the primary interrupt context. As a result, the
    implementation must avoid any memory allocation, not use spinlocks, and
    never block.

    The setDebuggerMode() method in IONetworkController is used as a placeholder
    and doesn't do anything. If a driver wishes to perform specific actions based upon whether
    or not the debugger is active or not, it should override this method. For example, drivers
    may wish to alter power management settings or perform other chipset reconfigurations based 
    upon the active debugger state.

    @param active Set to true if entering KDP and false if leaving KDP. 
    @result Returns true on success and false otherwise.
*/
    virtual bool setDebuggerMode(bool active);

    // Virtual function padding
    OSMetaClassDeclareReservedUsed( IONetworkController,  0); // getDebuggerLinkStatus
    OSMetaClassDeclareReservedUsed( IONetworkController,  1); // setDebuggerMode

    OSMetaClassDeclareReservedUnused( IONetworkController,  2);
    OSMetaClassDeclareReservedUnused( IONetworkController,  3);
    OSMetaClassDeclareReservedUnused( IONetworkController,  4);
    OSMetaClassDeclareReservedUnused( IONetworkController,  5);
    OSMetaClassDeclareReservedUnused( IONetworkController,  6);
    OSMetaClassDeclareReservedUnused( IONetworkController,  7);
    OSMetaClassDeclareReservedUnused( IONetworkController,  8);
    OSMetaClassDeclareReservedUnused( IONetworkController,  9);
    OSMetaClassDeclareReservedUnused( IONetworkController, 10);
    OSMetaClassDeclareReservedUnused( IONetworkController, 11);
    OSMetaClassDeclareReservedUnused( IONetworkController, 12);
    OSMetaClassDeclareReservedUnused( IONetworkController, 13);
    OSMetaClassDeclareReservedUnused( IONetworkController, 14);
    OSMetaClassDeclareReservedUnused( IONetworkController, 15);
    OSMetaClassDeclareReservedUnused( IONetworkController, 16);
    OSMetaClassDeclareReservedUnused( IONetworkController, 17);
    OSMetaClassDeclareReservedUnused( IONetworkController, 18);
    OSMetaClassDeclareReservedUnused( IONetworkController, 19);
    OSMetaClassDeclareReservedUnused( IONetworkController, 20);
    OSMetaClassDeclareReservedUnused( IONetworkController, 21);
    OSMetaClassDeclareReservedUnused( IONetworkController, 22);
    OSMetaClassDeclareReservedUnused( IONetworkController, 23);
    OSMetaClassDeclareReservedUnused( IONetworkController, 24);
    OSMetaClassDeclareReservedUnused( IONetworkController, 25);
    OSMetaClassDeclareReservedUnused( IONetworkController, 26);
    OSMetaClassDeclareReservedUnused( IONetworkController, 27);
    OSMetaClassDeclareReservedUnused( IONetworkController, 28);
    OSMetaClassDeclareReservedUnused( IONetworkController, 29);
    OSMetaClassDeclareReservedUnused( IONetworkController, 30);
    OSMetaClassDeclareReservedUnused( IONetworkController, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IONETWORKCONTROLLER_H */
                                                                                               IONetworkData.h                                                                                     0100644 0001750 0001750 00000046661 12567452436 036363  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKDATA_H
#define _IONETWORKDATA_H

#define IONetworkParameter IONetworkData  // FIXME

/*! @enum NetworkDataAccessTypes
    @abstract Constants that describe access types.
    @constant kIONetworkDataAccessTypeRead  Read access.
    @constant kIONetworkDataAccessTypeWrite Write access.
    @constant kIONetworkDataAccessTypeReset Reset access.
    @constant kIONetworkDataAccessTypeSerialize Serialization access. 
*/

enum {
    kIONetworkDataAccessTypeRead        = 0x01,
    kIONetworkDataAccessTypeWrite       = 0x02,
    kIONetworkDataAccessTypeReset       = 0x04,
    kIONetworkDataAccessTypeSerialize   = 0x08,
    kIONetworkDataAccessTypeMask        = 0xff
};

/*! @define kIONetworkDataBasicAccessTypes
    @discussion The default access types supported by an IONetworkData
    object. Allow read() and serialize(). */

#define kIONetworkDataBasicAccessTypes \
       (kIONetworkDataAccessTypeRead | kIONetworkDataAccessTypeSerialize)

/*! @enum NetworkDataBufferTypes
    @abstract The types of data buffers that can be managed by an IONetworkData object.
    @constant kIONetworkDataBufferTypeInternal An internal data buffer
              allocated by the init() method.
    @constant kIONetworkDataBufferTypeExternal An external (persistent) data
              buffer.
    @constant kIONetworkDataBufferTypeNone No data buffer. The only useful 
              action perfomed by an IONetworkData object with this buffer type 
              is to call the access notification handler. 
*/

enum {
    kIONetworkDataBufferTypeInternal = 0,
    kIONetworkDataBufferTypeExternal,
    kIONetworkDataBufferTypeNone
};

/*! @defined kIONetworkDataBytes
    @abstract A property of IONetworkData objects.
    @discussion The kIONetworkDataBytes property is an OSData that describes
        the data buffer of an IONetworkData object. This property is present
        only if kIONetworkDataAccessTypeSerialize access is supported. 
*/

#define kIONetworkDataBytes             "Data"

/*! @defined kIONetworkDataAccessTypes
    @abstract A property of IONetworkData objects.
    @discussion The kIONetworkDataAccessTypes property is an OSNumber that
        describes the supported access types of an IONetworkData object. 
*/

#define kIONetworkDataAccessTypes       "Access Types"

/*! @defined kIONetworkDataSize
    @abstract A property of IONetworkData objects.
    @discussion The kIONetworkDataSize property is an OSNumber that
        describes the size of the data buffer of an IONetworkData object. 
*/

#define kIONetworkDataSize              "Size"

#ifdef KERNEL

#include <libkern/c++/OSSymbol.h>
#include <libkern/c++/OSSerialize.h>

/*! @class IONetworkData
    @abstract An object that manages a fixed-size named buffer.
    @discussion An IONetworkData object manages a fixed-size named buffer.
    This object provides external access methods that can be used to
    access the contents of the data buffer. In addition, serialization
    is supported, and therefore this object can be added to a property
    table to publish the data object. An unique name must be assigned to
    the object during initialization. An OSSymbol key will be created
    based on the assigned name, and this key can be used when the object
    is added to a dictionary.

    The level of access granted to the access methods can be restricted,
    by specifying a set of supported access types when the object is
    initialized, or modified later by calling setAccessTypes(). By default,
    each IONetworkData object created will support serialization, and will
    also allow its data buffer to be read through the read() access method.

    An access notification handler, in the form of a 'C' function, can
    be registered to receive a call each time the data buffer is accessed
    through an access method. Arguments provided to the handler will identify 
    the data object and the type of access that triggered the notification.
    The handler can therefore perform lazy update of the data buffer until
    an interested party tries to read or serialize the data. The notification
    handler can also take over the default action performed by the access
    methods when the buffer type is set to kIONetworkDataBufferTypeNone.
    This will prevent the access methods from accessing the data buffer,
    and allow the handler to override the access protocol.

    This object is primarily used by IONetworkInterface to export interface
    properties to user space. 
*/


class IONetworkData : public OSObject
{
    OSDeclareDefaultStructors( IONetworkData )

public:

/*! @typedef Action
    @abstract Defines a C function that may be called by an IONetworkData object
    when one of its access methods is called.
    @param target The target of the notification.
    @param param A parameter that was provided when the notification
           handler was registered.
    @param data The IONetworkData object being accessed, and the
           sender of the notification.
    @param accessType A bit will be set indicating the type of access
           which triggered the notification.
    @param buffer Pointer to the accessor's buffer. Only valid for
           read() and write() accesses.
    @param bufferSize Pointer to the size of the accessor's buffer.
    @param offset An offset from the start of the data buffer to begin
           reading or writing. 
*/

    typedef IOReturn (*Action)(void *           target,
                               void *           param,
                               IONetworkData *  data,
                               UInt32           accessType,
                               void *           buffer,
                               UInt32 *         bufferSize,
                               UInt32           offset);

protected:
    const OSSymbol *  _key;        // key associated with this object.
    UInt32            _access;     // supported access types.
    void *            _buffer;     // Data buffer.
    UInt32            _bufType;    // buffer type
    UInt32            _size;       // data buffer size.
    void *            _tapTarget;  // target for access notification.
    Action            _tapAction;  // the function to call.
    void *            _tapParam;   // arbitrary notification param.

    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *	_reserved;


/*! @function free
    @abstract Frees the IONetworkData object. 
*/

    virtual void free();

/*! @function writeBytes
    @abstract Writes to the data buffer with data from a source buffer
    provided by the caller.
    @param srcBuffer Pointer to a source buffer provided by the caller.
    @param srcBufferSize The size of the source buffer.
    @param writeOffset A byte offset from the start of the data buffer
           to begin writting.
    @result Returns true if the operation was successful, false otherwise. 
*/

    virtual bool writeBytes(const void * srcBuffer,
                            UInt32       srcBufferSize,
                            UInt32       writeOffset = 0);

/*! @function readBytes
    @abstract Reads from the data buffer and copies the data to a destination
    buffer provided by the caller.
    @param dstBuffer Pointer to the destination buffer.
    @param dstBufferSize Pointer to an integer containing the size of the
    destination buffer. And is overwritten by this method with the actual
    number of bytes copied to the destination buffer.
    @param readOffset A byte offset from the start of the data buffer
           to begin reading.
    @result Returns true if the operation was successful, false otherwise. 
*/

    virtual bool readBytes(void *   dstBuffer,
                           UInt32 * dstBufferSize,
                           UInt32   readOffset = 0) const;

/*! @function clearBuffer
    @abstract Clears the data buffer by filling it with zeroes.
    @result Returns true if the operation was successful, false otherwise. 
*/

    virtual bool clearBuffer();

public:

/*! @function withInternalBuffer
    @abstract Factory method that constructs and initializes an
    IONetworkData object with an internal data buffer.
    @param name A name to assign to this object.
    @param bufferSize The number of bytes to allocate for the internal data
           buffer.
    @param accessTypes The initial supported access types.
    @param target The notification target.
    @param action The notification action.
    @param param A parameter to pass to the notification action.
    @result Returns an IONetworkData object on success, or 0 otherwise. 
*/

    static IONetworkData *
           withInternalBuffer(const char * name,
                              UInt32       bufferSize,
                              UInt32       accessTypes = 
                                           kIONetworkDataBasicAccessTypes,
                              void *       target = 0,
                              Action       action = 0,
                              void *       param  = 0);

/*! @function withExternalBuffer
    @abstract Factory method that constructs and initializes an
    IONetworkData object with an external data buffer.
    @param name A name to assign to this object.
    @param bufferSize The size of the external data buffer.
    @param externalBuffer Pointer to the external data buffer.
    @param accessTypes The initial supported access types.
    @param target The notification target.
    @param action The notification action.
    @param param A parameter to pass to the notification action.
    @result Returns an IONetworkData object on success, or 0 otherwise. 
*/

    static IONetworkData *
           withExternalBuffer(const char * name,
                              UInt32       bufferSize,
                              void *       externalBuffer,
                              UInt32       accessTypes =
                                           kIONetworkDataBasicAccessTypes,
                              void *       target = 0,
                              Action       action = 0,
                              void *       param  = 0);

/*! @function withNoBuffer
    @abstract Factory method that constructs and initializes an
    IONetworkData object without a data buffer. 
    @discussion The notification handler
    must intervene when the IONetworkData is accessed.
    @param name A name to assign to this object.
    @param bufferSize The size of the phantom data buffer.
    @param accessTypes The initial supported access types.
    @param target The notification target.
    @param action The notification action.
    @param param A parameter to pass to the notification action.
    @result Returns an IONetworkData object on success, or 0 otherwise. 
*/

    static IONetworkData * withNoBuffer(const char * name,
                                        UInt32       bufferSize,
                                        UInt32       accessTypes,
                                        void *       target,
                                        Action       action,
                                        void *       param = 0);

/*! @function init
    @abstract Initializes an IONetworkData object.
    @param name A name to assign to this object.
    @param bufferType The type of buffer associated with this object.
    @param bufferSize The size of the data buffer.
    @param externalBuffer Pointer to an external data buffer.
    @param accessTypes The initial supported access types.
           Can be later modified by calling setAccessTypes().
    @param target The notification target.
    @param action The notification action.
    @param param A parameter to pass to the notification action.
    @result Returns true if initialized successfully, false otherwise. 
*/

    virtual bool init(const char * name,
                      UInt32       bufferType,
                      UInt32       bufferSize,
                      void *       externalBuffer = 0,
                      UInt32       accessTypes    =
                                   kIONetworkDataBasicAccessTypes,
                      void *       target         = 0,
                      Action       action         = 0,
                      void *       param          = 0);

/*! @function setAccessTypes
    @abstract Sets the types of access that are permitted on the data buffer.
    @param types A mask of access types indicating the supported access
                 types. 
*/

    virtual void setAccessTypes(UInt32 types);

/*! @function setNotificationTarget
    @abstract Registers a C function to handle access notifications sent
    from this object.
    @discussion A notification is sent by an IONetworkData object to the
    registered notification handler, when an access method is called to
    modify the contents of the data buffer.
    @param target The first parameter passed to the notification handler.
    @param action A pointer to a C function that will handle the notification.
           If 0, then notification is disabled.
    @param param An optional parameter passed to the notification handler. 
*/

    virtual void setNotificationTarget(void *  target,
                                       Action  action,
                                       void *  param = 0);

/*! @function getBuffer
    @abstract Gets a pointer to the data buffer.
    @result Returns a pointer to the data buffer. Returns 0 if the buffer type is
            kIONetworkDataBufferTypeNone. 
*/

    virtual const void *     getBuffer() const;

/*! @function getBufferType
    @abstract Gets the type of data buffer managed by this object.
    @result Returns a constant that describes the type of the data buffer. 
*/

    virtual UInt32           getBufferType() const;

/*! @function getAccessTypes
    @abstract Gets the types of data access supported by this object.
    @result Returns a mask of supported access types. 
*/

    virtual UInt32           getAccessTypes() const;

/*! @function getNotificationTarget
    @abstract Gets the first parameter that will be passed to the access
              notification handler.
    @result Returns the first parameter that will be passed to the access notification
            handler. 
*/

    virtual void *           getNotificationTarget() const;

/*! @function getNotificationAction
    @abstract Gets the C function that was registered to handle access
              notifications sent from this object.
    @result Returns a pointer to a C function, or 0 if notification is disabled. 
*/

    virtual Action           getNotificationAction() const;

/*! @function getNotificationParameter
    @abstract Gets the parameter that will be passed to the access
              notification handler.
    @result Returns the parameter that will be passed to the access notification
            handler. 
*/

    virtual void *           getNotificationParameter() const;

/*! @function getKey
    @abstract Gets a unique OSSymbol key associated with this object.
    @discussion During initialization, IONetworkData will create an
    OSSymbol key based on its assigned name.
    @result Returns an OSSymbol key that was generated from the name assigned to
    this object. 
*/

    virtual const OSSymbol * getKey() const;

/*! @function getSize
    @abstract Gets the size of the data buffer.
    @result Returns the size of the data buffer managed by this object in bytes. 
*/

    virtual UInt32           getSize() const;

/*! @function reset
    @abstract An access method that resets the data buffer.
    @discussion This method handles an external request to reset the data buffer.
    If notification is enabled, then the notification handler is called
    after the data buffer has been cleared.
    @result Returns kIOReturnSuccess on success,
            kIOReturnNotWritable if reset access is not permitted,
            or an error from the notification handler. 
*/

    virtual IOReturn reset();

/*! @function read
    @abstract An access method that reads from the data buffer.
    @discussion This method handles an external request to read from the data buffer
    and copy it to the destination buffer provided by the accessor.
    If notification is enabled, then the notification handler is called
    before the data buffer is copied to the destination buffer. The 
    notification handler may use this opportunity to intervene and
    to update the contents of the data buffer.
    @param dstBuffer Pointer to the destination buffer.
    @param dstBufferSize Pointer to an integer containing the size of the
    destination buffer. And is overwritten by this method to the actual number
    of bytes copied to the destination buffer.
    @param readOffset An offset from the start of the source data buffer to
    begin reading.
    @result Returns kIOReturnSuccess on success,
            kIOReturnBadArgument if any of the arguments provided is invalid,
            kIOReturnNotReadable if read access is not permitted,
            or an error from the notification handler. 
*/

    virtual IOReturn read(void *   dstBuffer,
                          UInt32 * dstBufferSize,
                          UInt32   readOffset = 0);

/*! @function write
    @abstract An access method that writes to the data buffer.
    @discussion This method handles an external request to write to the data buffer
    from a source buffer provided by the accessor. After checking that
    the data object supports write accesses, the data buffer is updated
    if it exists. Then the registered notification handler is called.
    @param srcBuffer Pointer to the source buffer.
    @param srcBufferSize The number of bytes to write to the data buffer.
    @param writeOffset An offset from the start of the destination data buffer
    to begin writing.
    @result Returns kIOReturnSuccess on success,
            kIOReturnBadArgument if any of the arguments provided is invalid,
            kIOReturnNotWritable if write access is not permitted,
            or an error from the notification handler. 
*/

    virtual IOReturn write(void *  srcBuffer,
                           UInt32  srcBufferSize,
                           UInt32  writeOffset = 0);

/*! @function serialize
    @abstract Serializes the IONetworkData object.
    @discussion If notification is enabled, then the notification
    handler is called just before the data buffer is serialized.
    @param s An OSSerialize object.
    @result Returns true on success, false otherwise. 
*/

    virtual bool serialize(OSSerialize * s) const;

    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IONetworkData,  0);
    OSMetaClassDeclareReservedUnused( IONetworkData,  1);
    OSMetaClassDeclareReservedUnused( IONetworkData,  2);
    OSMetaClassDeclareReservedUnused( IONetworkData,  3);
};

#endif /* KERNEL */

#endif /* !_IONETWORKDATA_H */
                                                                               IONetworkInterface.h                                                                                0100644 0001750 0001750 00000131450 12567452436 037401  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKINTERFACE_H
#define _IONETWORKINTERFACE_H

/*! @defined kIONetworkInterfaceClass
    @abstract The name of the IONetworkInterface class. 
*/

#define kIONetworkInterfaceClass  "IONetworkInterface"

/*! @defined kIONetworkData
    @abstract A property of IONetworkInterface objects. 
    @discussion The kIONetworkData property has an OSDictionary value and is a
        container for the set of IONetworkData objects managed by the interface.
        Each entry in the dictionary is a key/value pair consisting of
        the network data name, and an OSDictionary describing the
        contents of the network data. 
*/

#define kIONetworkData            "IONetworkData"

/*! @defined kIOInterfaceType
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceType property has an OSNumber value that
        specifies the type of network interface that this interface represents.
        The type constants are defined in bsd/net/if_types.h. 
*/

#define kIOInterfaceType          "IOInterfaceType"

/*! @defined kIOMaxTransferUnit
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOMaxTransferUnit property has an OSNumber value that
        specifies the maximum transfer unit for the interface in bytes.
*/

#define kIOMaxTransferUnit        "IOMaxTransferUnit"

/*! @defined kIOMediaAddressLength
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOMediaAddressLength property has an OSNumber value that
        specifies the size of the media address in bytes. 
*/

#define kIOMediaAddressLength     "IOMediaAddressLength"

/*! @defined kIOMediaHeaderLength
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOMediaHeaderLength property has an OSNumber value that
        specifies the size of the media header in bytes. 
*/

#define kIOMediaHeaderLength      "IOMediaHeaderLength"

/*! @defined kIOInterfaceFlags
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceFlags property has an OSNumber value that
        specifies the current value of the interface flags. The flag constants
        are defined in bsd/net/if.h. 
*/

#define kIOInterfaceFlags         "IOInterfaceFlags"

/*! @defined kIOInterfaceExtraFlags
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceExtraFlags property has an OSNumber value that
        specifies the current value of the interface eflags. The eflag constants
        are defined in bsd/net/if.h. 
*/

#define kIOInterfaceExtraFlags    "IOInterfaceExtraFlags"

/*! @defined kIOInterfaceUnit
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceUnit property has an OSNumber value that
        describes the unit number assigned to the interface object. 
*/

#define kIOInterfaceUnit          "IOInterfaceUnit"

/*! @defined kIOInterfaceState
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceState property has an OSNumber value that
        describes the current state of the interface object. This property is
        not exported to BSD via the ifnet structure. 
*/

#define kIOInterfaceState         "IOInterfaceState"

/*! @defined kIOInterfaceNamePrefix
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceNamePrefix property has an OSString value that
        describes the string prefix for the BSD name assigned to the interface. 
*/

#define kIOInterfaceNamePrefix    "IOInterfaceNamePrefix"

/*! @defined kIOPrimaryInterface
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceNamePrefix property has an OSBoolean value that
        describes whether the interface is the primary or the built-in network
        interface. 
*/

#define kIOPrimaryInterface       "IOPrimaryInterface"

/*! @defined kIOBuiltin
    @abstract kIOBuiltin is a property of IONetworkInterface
        objects. It has an OSBoolean value.
    @discussion The kIOBuiltin property describes whether the
        interface is built-in. 
*/

#define kIOBuiltin                "IOBuiltin"

/*! @defined kIOLocation
    @abstract kIOLocation is a property of IONetworkInterface
        objects. It has an OSString value.
    @discussion The kIOLocation property describes the physical 
        location of built-in interfaces. 
*/

#define kIOLocation               "IOLocation"

/*! @defined kIONetworkNoBSDAttachKey
    @abstract kIONetworkNoBSDAttachKey is a property of IONetworkInterface
        objects. It has an OSBoolean value.
    @discussion Adding a property with this key and the value kOSBooleanTrue
        before the interface is published will hold off the BSD attach.
        When the interface is ready to attach to BSD, remove the property
        and then re-publish the interface by calling registerService().
*/

#define kIONetworkNoBSDAttachKey  "IONetworkNoBSDAttach"

/*! @enum InterfaceObjectStates
    @discussion Constants used to encode the state of the interface object.
   @constant kIONetworkInterfaceRegisteredState The interface object has
        registered with the data link layer.
    @constant kIONetworkInterfaceOpenedState One or more clients have an
        open on the interface object.
    @constant kIONetworkInterfaceDisabledState The interface is temporarily
        unable to service its clients. This will occur when the network
        controller that is servicing the interface has entered a low power
        state that renders it unusable. 
*/

enum {
    kIONetworkInterfaceRegisteredState  = 0x1,
    kIONetworkInterfaceOpenedState      = 0x2,
    kIONetworkInterfaceDisabledState    = 0x4
};

#ifdef KERNEL
#ifdef __cplusplus

#include <IOKit/IOService.h>
#include <IOKit/network/IONetworkData.h>
#include <IOKit/network/IONetworkStats.h>
#include <IOKit/network/IONetworkMedium.h>
#include <net/kpi_interface.h>

class  IONetworkController;
class  IONetworkStack;
class  IOCommandGate;
struct IOMbufQueue;

/*! @typedef IOOutputAction
    @discussion Prototype for an output packet handler that will process
    all outbound packets sent to the interface from the data link layer.
    An output handler is registered with the interface by calling
    registerOutputHandler().
    @param mbuf_t A packet mbuf.
    @param param A parameter for the output request. */

typedef UInt32 (OSObject::*IOOutputAction)(mbuf_t, void * param);

/*! @typedef BPF_FUNC
    @discussion Prototype for the BPF tap handler. This will disappear
    when the correct DLIL header file is included. */

typedef int (*BPF_FUNC)(struct ifnet *, struct mbuf *);

// Network event types recognized by inputEvent().
//
enum {
    /* DLIL defined event, argument must be a pointer to a
       kern_event_msg structure. */
    kIONetworkEventTypeDLIL                 = 0xff000001,

    /* Link up event, no argument */
    kIONetworkEventTypeLinkUp               = 0xff000002,

    /* Link down event, no argument */
    kIONetworkEventTypeLinkDown             = 0xff000003,

    /* Wake on LAN support changed, no argument */
    kIONetworkEventWakeOnLANSupportChanged  = 0xff000004,
    
    /* Link speed changed */
    kIONetworkEventTypeLinkSpeedChange      = 0xff000005
};


/*! @class IONetworkInterface
    @abstract Abstract class that manages the connection between an
    IONetworkController and the data link interface layer.
    @discussion An IONetworkInterface object manages the connection between
    an IONetworkController and the data link interface layer (DLIL).
    All interactions between the controller and DLIL must go through an
    interface object. Any data structures that are required by DLIL for a
    particular interface type shall be allocated and mantained by the
    interface object. IONetworkInterface is an abstract class that must be
    extended by a concrete subclass to specialize for a particular network
    type.

    Although most drivers will allocate a single interface object,
    it is possible for multiple interfaces to be attached to a single
    controller. This controller driver will be responsible for arbitrating
    access among its multiple interface clients.
    
    IONetworkInterface also maintains a dictionary of IONetworkData
    objects containing statistics structures. Controller drivers can
    ask for a particular data object by name and update the
    statistics counters within directly. This dictionary is added to
    the interface's property table and is visible outside of the kernel. 
*/

class IONetworkInterface : public IOService
{
    OSDeclareAbstractStructors( IONetworkInterface )

    friend class IONetworkStack;


private:
    IONetworkController *   _driver;
    ifnet_t                 _backingIfnet;
    IOLock *                _privateLock;
    OSSet *                 _clientSet;
    OSNumber *              _stateBits;
    bpf_packet_func         _inputFilterFunc;
    bpf_packet_func         _outputFilterFunc;
    OSObject *              _outTarget;
    IOOutputAction          _outAction;
    UInt32                  _clientVar[4];
    OSDictionary *          _dataDict;
    IOMbufQueue *           _inputPushQueue;
    void *                  _unused1;
    UInt32                  _unused2;

    struct ExpansionData {
        int                         unit;
        int                         type;
        int                         mtu;
        int                         flags;
        int                         eflags;
        int                         addrlen;
        int                         hdrlen;
        int32_t                     loggingLevel;
        uint32_t                    outputQueueModel;
        IONetworkStats              driverStats;
        IONetworkStats              lastDriverStats;
        ifnet_stat_increment_param  inputDeltas;
        IORecursiveLock *           publicLock;
        char *                      remote_NMI_pattern;
        unsigned int                remote_NMI_len;
        IONetworkController *       controller;
        uint32_t                    configFlags;
        uint32_t                    txRingSize;
        uint32_t                    txPullOptions;
        uint32_t                    txQueueSize;
        uint32_t                    txSchedulingModel;
        uint32_t                    txTargetQdelay;
        uint32_t                    txThreadState;
        volatile UInt32             txThreadFlags;
        uint32_t                    txThreadSignal;
        uint32_t                    txThreadSignalLast;
        thread_t                    txStartThread;
        void *                      txStartAction;
        IOWorkLoop *                txWorkLoop;
        uint32_t                    rxRingSize;
        uint32_t                    rxPollOptions;
        uint32_t                    rxPollModel;
        void *                      rxPollAction;
        void *                      rxCtlAction;        
        uint64_t                    rxPollEmpty;
        uint64_t                    rxPollTotal;
        uint16_t                    txStartDelayQueueLength;	/* optional */
        uint16_t                    txStartDelayTimeout;        /* optional */
    };

    ExpansionData *         _reserved;

    bool            _syncNetworkDataDict();
    SInt32          syncSIOCSIFMEDIA(IONetworkController * ctr, struct ifreq * ifr);
    SInt32          syncSIOCGIFMEDIA(IONetworkController * ctr, struct ifreq * ifr,
                                unsigned long cmd);
    SInt32          syncSIOCSIFMTU(IONetworkController * ctr, struct ifreq * ifr);
    void            drainOutputQueue(ifnet_t ifp, IONetworkController * driver);
    IOReturn        haltOutputThread(uint32_t stateBit);
    void            pushInputQueue( IOMbufQueue * queue );
    void            pushInputPacket( mbuf_t packet, uint32_t length );
    int             if_start_precheck( ifnet_t ifp );
    static int      performGatedCommand(void *, void *, void *, void *, void *);
    static void     powerChangeHandler(void *, void *, void *);
    static errno_t  if_ioctl(ifnet_t ifp, unsigned long cmd, void * data);
    static int      if_output(ifnet_t ifp, mbuf_t);
    static errno_t  if_set_bpf_tap(ifnet_t ifp, bpf_tap_mode, bpf_packet_func);
	static void     if_detach(ifnet_t ifp);
    static void     if_start(ifnet_t ifp);
    static void     if_start_gated(ifnet_t ifp);
    static void     if_input_poll(ifnet_t ifp, uint32_t flags,
                                uint32_t max_count,
                                mbuf_t * first_packet, mbuf_t * last_packet,
                                uint32_t *  cnt, uint32_t * len);
    static void     if_input_poll_gated(ifnet_t ifp, uint32_t flags,
                                uint32_t max_count,
                                mbuf_t * first_packet, mbuf_t * last_packet,
                                uint32_t *  cnt, uint32_t * len);
    void            notifyDriver( uint32_t type, void * data );

public:

/*! @function isPrimaryInterface
    @abstract Queries whether the interface is the primary network interface
    on the system.
    @discussion The definition of a primary interface and its discovery is
    platform specific.
    @result Returns true if the interface is the primary interface,
    false otherwise.
*/
    virtual bool     isPrimaryInterface( void ) const;

/*! @function init
    @abstract Initializes the <code>IONetworkInterface</code> object.
    @discussion Resources are allocated, but an <code>ifnet_t</code> will not
    be allocated until the interface is assigned a BSD name and attached to the
    network stack.
    @param controller A network controller object that will service the
    the interface.
    @result Returns true on success, false otherwise.
*/
    virtual bool     init( IONetworkController * controller );

/*! @function isRegistered
    @abstract Queries if the interface has attached to the BSD network stack.
    @discussion Once attached a <code>kIOBSDNameKey</code> property is added
    to the interface object with the assigned BSD name.
    @result Returns true if interface is registered and attached to the network
    stack, false otherwise.
*/
    virtual bool     isRegistered( void ) const;

/*! @function getInterfaceState
    @abstract Reports the current state of the interface object.
    @result Returns the current interface state flags.
*/
    virtual UInt32   getInterfaceState( void ) const;

/*! @function getController
    @abstract Gets the <code>IONetworkController</code> object that created
    this interface.
    @discussion The controller object passed to init() will be retained until
    the interface closes the controller. Subclasses can safely call this method
    before the controller is closed.
    @result Returns the parent <code>IONetworkController</code> object.
*/
    virtual IONetworkController * getController( void ) const;

/*! @function inputPacket
    @abstract For drivers to submit a received packet to the network stack.
    @discussion The packet provided to this method may be added to an input
    queue managed by the interface object, which the driver can use to postpone
    the packet handoff to the network stack, until all received packets have been
    added to the input queue. A subsequent call to <code>flushInputQueue()</code>,
    will transfer the entire contents of the input queue to the network stack.
    This input queue is not protected by a lock. Drivers that leverage this
    input queue must either access the queue from a single thread, or enforce
    serialized access.
    @param mbuf_t The mbuf containing the received packet.
    @param length Specify the size of the received packet in the mbuf.
    The mbuf length fields are updated with this value. If zero, then the mbuf
    length fields are not updated.
    @param options Pass <code>kInputOptionQueuePacket</code> to enqueue the
    input packet. Pass zero to bypass the input queue, and immediately submit
    the packet to the network stack.
    @param param A parameter provided by the driver. Not used.
    @result Returns the number of packets that were submitted to the network
    stack, or zero if the packet was enqueued.
*/
    virtual UInt32   inputPacket(
                        mbuf_t          packet,
                        UInt32          length  = 0,
                        IOOptionBits    options = 0,
                        void *          param   = 0 );

/*! @enum InputOptionQueuePacket
    @discussion Options for <code>inputPacket()</code>.
    @constant kInputOptionQueuePacket Enqueue the input packet provided to the
    input packet queue. Calls to <code>inputPacket()</code> must be serialized.
*/
    enum {
        kInputOptionQueuePacket = 0x1
    };

/*! @function flushInputQueue
    @abstract Submit all packets held in the input queue to the network stack.
    @discussion Allow drivers to remove all packets from the input queue and
    submit them to the network stack. This method should be used in concert
    with the <code>inputPacket()</code> method, to flush the input queue after
    queueing a number of received packets.
    @result Returns the number of packets that were submitted to the network
    stack. Returns zero if the queue was empty.
*/
    virtual UInt32   flushInputQueue( void );

/*! @function clearInputQueue
    @abstract Discards all packets in the input queue.
    @discussion This method removes all packets from the input queue and
    releases them back to the free mbuf pool. It is unusual for a driver to
    call this method.
    @result Returns the number of packets freed.
*/
    virtual UInt32   clearInputQueue( void );

/*! @function inputEvent
    @abstract Sends an event to the network stack.
    @discussion This method can be used by the driver to send an event to the
    network stack.
    @param type A constant describing the event type.
    @param data An optional data associated with the event.
    @result Returns true if the event was delivered, false if the event type
    specified is invalid, or if the event delivery failed.
*/
    virtual bool     inputEvent( UInt32 type, void * data );

/*! @function registerOutputHandler
    @abstract Registers a target/action to handle outbound packets.
    @discussion The interface object will forward all output packets sent from
    the network stack to the target and action registered using this method.
    The registration must occur before the interface is registered and opened
    by <code>IONetworkStack</code>, otherwise the default handler will be used.
    The default target and action is set by <code>init()</code> as the
    controller, and the handler returned by the controller's
    <code>getOutputHandler()</code> method.
    @param target Object that implements the output handler.
    @param action The function that will handle output packets.
    @result Returns true if the target/action provided was accepted,
    false otherwise.
*/
    virtual bool     registerOutputHandler(
                            OSObject *      target,
                            IOOutputAction  action );

/*! @function getNamePrefix
    @abstract Returns the BSD name prefix as a C-string.
    @discussion The BSD name for each interface object is generated by
    concatenating the string returned by this method, along with an unit number
    assigned by <code>IONetworkStack</code>. A concrete interface subclass must
    implement this method and return a distinct name prefix for its instances.
    @result Returns a pointer to a constant C-string.
*/
    virtual const char * getNamePrefix() const = 0;

/*! @function getInterfaceType
    @abstract Gets the interface type.
    @discussion This method returns the interface type previously set by
    <code>setInterfaceType</code>.
    @result Returns a constant defined in <code>bsd/net/if_types.h</code>
    that describes the interface type.
*/
    virtual UInt8    getInterfaceType( void ) const;

/*! @function getMaxTransferUnit
    @abstract Gets the maximum transfer unit for this interface.
    @discussion This method calls <code>ifnet_mtu</code> and returns the
    maximum transfer unit.
    @result Returns the interface MTU size in bytes.
*/
    virtual UInt32   getMaxTransferUnit( void ) const;

/*! @function getFlags
    @abstract Gets the current interface flags.
    @discussion This method calls <code>ifnet_flags</code> and returns the
    current interface flags.
    @result Returns the interface flags.
*/
    virtual UInt16   getFlags( void ) const;

/*! @function getExtraFlags
    @abstract Gets the current interface eflags.
    @discussion This method calls <code>ifnet_eflags</code> and returns the
    current interface eflags.
    @result Returns the value of the interface eflags.
*/
    virtual UInt32   getExtraFlags( void ) const;

/*! @function getMediaAddressLength
    @abstract Gets the size of the media (MAC-layer) address.
    @discussion This method calls <code>ifnet_addrlen</code> and returns the
    media address length.
    @result Returns the size of the media address in bytes.
*/
    virtual UInt8    getMediaAddressLength( void ) const;

/*! @function getMediaHeaderLength
    @abstract Gets the size of the media header.
    @discussion This method calls <code>ifnet_hdrlen</code> and returns the
    media header length.
    @result Returns the size of the media header in bytes.
*/
    virtual UInt8    getMediaHeaderLength( void ) const;

/*! @function getUnitNumber
    @abstract Gets the unit number assigned to this interface object.
    @discussion This method calls <code>ifnet_unit</code> and returns the
    unit number assigned by <code>IONetworkStack</code>.
    @result Returns the assigned interface unit number.
*/
    virtual UInt16   getUnitNumber( void ) const;

/*! @function addNetworkData
    @abstract Adds an <code>IONetworkData</code> object to the interface.
    @discussion The <code>IONetworkData</code> object is added to a
    collection using the key from <code>IONetworkData::getKey()<code>.
    The object provided is retained.
    @param aData The <code>IONetworkData</code> object.
    @result Returns true if the object was added, false otherwise.
*/
    virtual bool     addNetworkData( IONetworkData * aData );

/*! @function removeNetworkData
    @abstract Removes an <code>IONetworkData</code> object from the interface.
    @discussion This method removes an <code>IONetworkData</code> object from
    the collection managed by the interface. The object removed is released.
    @param aKey An OSSymbol identifying the object to be removed.
    @result Returns true if the object was found and removed, false otherwise.
*/
    virtual bool     removeNetworkData( const OSSymbol * aKey );

/*! @function removeNetworkData
    @abstract Removes an <code>IONetworkData</code> object from the interface.
    @discussion This method removes an <code>IONetworkData</code> object from
    the collection managed by the interface. The object removed is released.
    @param aKey A C-string identifying the object to be removed.
    @result Returns true if the object was found and removed, false otherwise.
*/
    virtual bool     removeNetworkData( const char * aKey );

/*! @function getNetworkData
    @abstract Gets an <code>IONetworkData</code> object from the interface.
    @discussion Returns a reference to an <code>IONetworkData</code> object
    that was previously added to the interface, and is associated with the
    provided key.
    @param aKey A C-string identifying the object.
    @result Returns a reference to the matching <code>IONetworkData</code>
    object, or NULL if no match was found.
*/
    virtual IONetworkData * getNetworkData( const char * aKey ) const;

/*! @function getNetworkData
    @abstract Gets an <code>IONetworkData</code> object from the interface.
    @discussion Returns a reference to an <code>IONetworkData</code> object
    that was previously added to the interface, and is associated with the
    provided key.
    @param aKey An OSSymbol identifying the object.
    @result Returns a reference to the matching <code>IONetworkData</code>
    object, or NULL if no match was found.
*/
    virtual IONetworkData * getNetworkData(const OSSymbol * aKey) const;

    /* Compatibility methods */
    IONetworkData * getParameter(const char * aKey) const;
	bool setExtendedFlags(UInt32 flags, UInt32 clear = 0);

    /* Override IOService::message() */
    virtual IOReturn message( UInt32 type, IOService * provider, void * argument );

/*! @function debuggerRegistered
    @abstract Tells the <code>IONetworkData</code> that this interface will be
    used by the debugger.
*/
    void debuggerRegistered( void );

protected:
/*! @function setInterfaceType
    @abstract Sets the interface type.
    @discussion Sets the interface type before the interface is attached to
    the network stack. See <code>bsd/net/if_types.h</code> for defined types.
    The <code>kIOInterfaceType</code> is also updated using the provided type.
    @param type A constant defined in <code>bsd/net/if_types.h</code> that
    describes the interface type.
    @result Returns true to indicate success if the interface has not yet
    attached to the network stack, otherwise returns false.
*/
    virtual bool     setInterfaceType( UInt8 type );

/*! @function setMaxTransferUnit
    @abstract Sets the maximum transfer unit for this interface.
    @discussion Calls <code>ifnet_set_mtu</code> if the interface is attached
    to the network stack, and updates the <code>kIOMaxTransferUnit</code>
    property using the provided value.
    @param mtu The interface MTU size in bytes.
    @result Always returns true.
*/
    virtual bool     setMaxTransferUnit( UInt32 mtu );

/*! @function setFlags
    @abstract Performs a read-modify-write operation on the current
    interface flags value.
    @discussion Calls <code>ifnet_set_flags</code> if the interface is attached
    to the network stack, and updates the <code>kIOInterfaceFlags</code>
    property using the provided value. See <code>bsd/net/if.h</code> header
    file for the flag constants.
    @param flags The bits that should be set.
    @param clear The bits that should be cleared. If zero, then non
    of the flags are cleared and the result is formed by OR'ing the
    original flags value with the new flags.
    @result Always returns true.
*/
    virtual bool     setFlags( UInt16 flags, UInt16 clear = 0 );

    /* Deprecated. No replacement. */
    virtual bool     setExtraFlags( UInt32 flags, UInt32 clear = 0 );

/*! @function setMediaAddressLength
    @abstract Sets the size of the media (MAC-layer) address.
    @discussion Calls <code>ifnet_set_addrlen</code> if interface is attached
    to the network stack, and updates the <code>kIOMediaAddressLength</code>
    property using the provided value.
    @param length The size of the media address in bytes.
    @result Always returns true.
*/
    virtual bool     setMediaAddressLength( UInt8 length );

/*! @function setMediaHeaderLength
    @abstract Sets the size of the media header.
    @discussion Calls <code>ifnet_set_hdrlen</code> if interface is attached
    to the network stack, and updates the <code>kIOMediaHeaderLength</code>
    property using the provided value.
    @param length The size of the media header in bytes.
    @result Always returns true.
*/
    virtual bool     setMediaHeaderLength( UInt8 length );

/*! @function setUnitNumber
    @abstract Assigns an unique unit number to this interface.
    @discussion This method is called internally before the interface is
    attached to the network stack, to assign an unique unit number to the
    interface object. The <code>kIOInterfaceUnit</code> property is also
    updated using the provided value.
    @param unit The unit number assigned to this interface object.
    @result Returns true to indicate success if the interface has not yet
    attached to the network stack, otherwise returns false.
*/
    virtual bool     setUnitNumber( UInt16 unit );

/*! @function free
    @abstract Frees the <code>IONetworkInterface</code> object.
    @discussion Resource allocated by init() are released, and
    clearInputQueue() is called to ensure that the input queue is empty.
    The interface should have already detached from the network stack.
*/
    virtual void     free( void );

    /* Override IOService::handleOpen() */
    virtual bool     handleOpen( IOService *  client,
                                 IOOptionBits options,
                                 void *       argument );

    /* Override IOService::handleClose() */
    virtual void     handleClose( IOService * client, IOOptionBits options );

    /* Override IOService::handleIsOpen() */
    virtual bool     handleIsOpen( const IOService * client ) const;

/*! @function lock
    @abstract Acquires a recursive lock owned by the interface.
    @discussion A recursive lock is allocated and initialized in
    <code>init()</code>. This lock is otherwise not used by the
    <code>IONetworkInterface</code> class. This method call acquires
    the lock and must be balanced with an <code>unlock()</code>.
*/
    virtual void     lock( void );

/*! @function unlock
    @abstract Releases the recursive lock owned by the interface.
    @discussion A recursive lock is allocated and initialized in
    <code>init()</code>. This lock is otherwise not used by the
    <code>IONetworkInterface</code> class. This method call releases
    the lock to balance a prior <code>lock()</code>.
*/
    virtual void     unlock( void );

/*! @function controllerDidOpen
    @abstract Sends a notification that the interface has opened the network
    controller.
    @discussion This method is called by <code>handleOpen()</code> to notify
    subclasses that the controller was opened. The open on the controller
    occurs when the interface receives the initial open request from a client.
    Subclasses can override this method and inspect the controller before
    allowing the client open. This method is called with the arbitration lock
    held, hence issuing I/O to the controller must be avoided to eliminate the
    possibility of a deadlock.
    @param controller The controller that was opened.
    @result Must return true in order for handleOpen() to accept the client
    open. If the return is false, then the controller will be closed and the
    client open will fail.
*/
    virtual bool     controllerDidOpen( IONetworkController * controller );

/*! @function controllerWillClose
    @abstract Sends a notification that the interface will close the network
    controller.
    @discussion This method is called by <code>handleClose()</code> after
    receiving a close from the last interface client, and just before the
    controller is closed. Subclasses can override this method to perform any
    cleanup action before the controller is closed. This method is called with
    the arbitration lock held, hence issuing I/O to the controller should be
    avoided to eliminate the possibility of a deadlock.
    @param controller The controller that is about to be closed.
*/
    virtual void     controllerWillClose( IONetworkController * controller );

/*! @function performCommand
    @abstract Handles an ioctl command sent to the network interface.
    @discussion This method handles socket ioctl commands sent to the
    network interface from DLIL.
    IONetworkInterface handles commands that are common for all network
    interface types. A subclass of IONetworkInterface may override this
    method to override the command handling in IONetworkInterface, or
    to extend the command processing to handle additional commands.
    The ioctl commands handled by IONetworkInterface are
        <code>SIOCGIFMTU</code> (Get interface MTU size),
        <code>SIOCSIFMTU</code> (Set interface MTU size),
        <code>SIOCSIFMEDIA</code> (Set media), and
        <code>SIOCGIFMEDIA</code> (Get media and link status).
    @param controller The controller object.
    @param cmd The ioctl command code.
    @param arg0 Command argument 0. Generally a pointer to an ifnet structure
        associated with the interface.
    @param arg1 Command argument 1.
    @result Returns a BSD return value defined in <code>bsd/sys/errno.h</code>.
*/
    virtual SInt32   performCommand(
                                IONetworkController * controller,
                                unsigned long         cmd,
                                void *                arg0,
                                void *                arg1 );

public:

/*! @function getIfnet
    @abstract Returns the <code>ifnet_t</code> allocated by the interface object.
    @discussion Gets the interface's <code>ifnet_t</code>, which is managed
    primarily by <code>IONetworkInterface</code>, however subclasses or drivers
    can use this method to obtain a reference to the <code>ifnet_t</code> for
    interface KPI calls.
    @result Returns the <code>ifnet_t</code> after the interface has attached
    to the network stack and before the interface is detached, otherwise returns
    NULL.
*/
    virtual ifnet_t  getIfnet( void ) const;

protected:

    /* Deprecated. Use <code>initIfnetParams</code> instead. */
    virtual bool     initIfnet( struct ifnet * ifp );

/*! @function handleClientOpen
    @abstract Handles a client open on the interface.
    @discussion This method is called by <code>handleOpen()</code> to allow a
    subclass to handle a client close. The arbitration lock is held.
    @param client The client object requesting the open.
    @param options Options passed to <code>handleOpen()</code>.
    @param argument Argument passed to <code>handleOpen()</code>.
    @result Returns true to accept the client open, false to reject the open.
*/
    virtual bool     handleClientOpen( IOService *  client,
                                       IOOptionBits options,
                                       void *       argument );

/*! @function handleClientClose
    @abstract Handles a client close on the interface.
    @discussion This method is called by <code>handleClose()</code> to allow a
    subclass to handle a client close. The arbitration lock is held.
    @param client The client object requesting the close.
    @param options Options same options passed to <code>handleClose()</code>.
*/
    virtual void     handleClientClose( IOService *  client,
                                        IOOptionBits options );

    /* Override IOService::newUserClient() */
    virtual IOReturn newUserClient( task_t           owningTask,
                                    void *           security_id,
                                    UInt32           type,
                                    IOUserClient **  handler );

/*! @function setInterfaceState
    @abstract Updates the interface object state flags.
    @discussion The flags reflect the current state of the interface, and is
    also published through the <code>kIOInterfaceState</code> property.
    @param set The flags that should be set.
    @param clear The flags that should be cleared.
    @result Returns the new interface state flags.
*/
    virtual UInt32   setInterfaceState( UInt32 set, UInt32 clear = 0 );

/*! @function powerStateWillChangeTo
    @abstract Handles a pre-change power interest notification from the
    network controller.
    @discussion The <code>controllerWillChangePowerState()</code> method is
    called by this handler. Subclasses are not expected to override this method.
    @param flags Flags that describe the capability of the controller in the
    new power state.
    @param stateNumber An index to a state in the network controller's
    power state array that the controller is switching to.
    @param policyMaker A reference to the network controller's policy-maker,
    and is also the originator of this notification.
    @result Returns <code>IOPMAckImplied</code> to indicate synchronous completion.
*/
    virtual IOReturn powerStateWillChangeTo(
                                IOPMPowerFlags  flags,
                                unsigned long   stateNumber,
                                IOService *     policyMaker );

/*! @function powerStateDidChangeTo
    @abstract Handles a post-change power interest notification from the
    network controller.
    @discussion The <code>controllerDidChangePowerState()</code> method is
    called by this handler. Subclasses are not expected to override this method.
    @param flags Flags that describe the capability of the controller in the
    new power state.
    @param stateNumber An index to a state in the network controller's
    power state array that the controller has switched to.
    @param policyMaker A reference to the network controller's policy-maker,
    and is also the originator of this notification.
    @result Returns <code>IOPMAckImplied</code> to indicate synchronous completion.
*/
    virtual IOReturn powerStateDidChangeTo(
                                IOPMPowerFlags  flags,
                                unsigned long   stateNumber,
                                IOService *     policyMaker );

/*! @function controllerWillChangePowerState
    @abstract Handles a notification that the network controller servicing
    this interface object will transition to a new power state.
    @param controller The network controller object.
    @param flags Flags that describe the capability of the controller in the
    new power state.
    @param stateNumber An index to a state in the network controller's
    power state array that the controller is switching to.
    @param policyMaker A reference to the network controller's policy-maker,
    and is also the originator of this notification.
    @result The return value is always <code>kIOReturnSuccess</code>.
*/
    virtual IOReturn controllerWillChangePowerState(
                                IONetworkController * controller,
                                IOPMPowerFlags        flags,
                                UInt32                stateNumber,
                                IOService *           policyMaker );

/*! @function controllerDidChangePowerState
    @abstract Handles a notification that the network controller servicing
    this interface object has transitioned to a new power state.
    @param controller The network controller object.
    @param flags Flags that describe the capability of the controller in the
    new power state.
    @param stateNumber An index to a state in the network controller's
    power state array that the controller has switched to.
    @param policyMaker A reference to the network controller's policy-maker,
    and is also the originator of this notification.
    @result The return value is always <code>kIOReturnSuccess</code>.
*/
    virtual IOReturn controllerDidChangePowerState(
                                IONetworkController * controller,
                                IOPMPowerFlags        flags,
                                UInt32                stateNumber,
                                IOService *           policyMaker );

public:
    /* Override IOService::willTerminate() */
    virtual bool     willTerminate(
                                IOService *  provider,
                                IOOptionBits options );

    /* Override IOService::requestTerminate() */
    virtual bool     requestTerminate(
                                IOService * provider, IOOptionBits options );

    /* Override IOService::serializeProperties() */
    virtual bool     serializeProperties( OSSerialize * s ) const;

/*! @function attachToDataLinkLayer
    @abstract Attach the network interface to the BSD data link layer.
    @discussion This method is called internally to attach the network
    interface to the BSD data link layer, after an unit number has been
    assigned. The calling context is not synchronized against the driver's
    work loop. Subclasses may override this method to perform additional
    setup before the network stack attach. The <code>getIfnet()</code> method
    will return the BSD interface being attached.
    @param options Options for the attach call. None are currently defined.
    @param parameter Parameter for the attach call. Not currently used.
    @result Returns <code>kIOReturnSuccess</code> on success.
*/
    virtual IOReturn attachToDataLinkLayer( IOOptionBits options,
                                            void *       parameter );

    OSMetaClassDeclareReservedUsed(IONetworkInterface, 0);

/*! @function detachFromDataLinkLayer
    @abstract Detach the network interface from the BSD data link layer.
    @discussion This method is called internally to detach the network
    interface from the BSD data link layer, after the interface has been
    terminated and before the last client close. This method will block until
    the detach operation is complete. The calling context is not synchronized
    against the driver's work loop. Subclasses may override this method to
    perform additional cleanup before or after detaching from the network
    stack. The <code>getIfnet()</code> method will return NULL after detach.
    @param options Options for the detach call. None are currently defined.
    @param parameter Parameter for the detach call. Not currently used.
*/
    virtual void     detachFromDataLinkLayer( IOOptionBits options,
                                              void *       parameter );

    OSMetaClassDeclareReservedUsed(IONetworkInterface, 1);

protected:
/*! @function feedPacketInputTap
    @abstract Feed received packets to the BPF
    @discussion This function is called internally to send input packets to
    the BPF input tap when it is enabled. Subclasses are not expected to
    override this method.
    @param mbuf_t Pointer to the input packet.
*/
    virtual void     feedPacketInputTap( mbuf_t );

	OSMetaClassDeclareReservedUsed(IONetworkInterface, 2);

/*! @function feedPacketOutputTap
    @abstract Feed output packets to the BPF
    @discussion This function is called internally to send output packets to
    the BPF output tap when it is enabled. Subclasses are not expected to
    override this method.
    @param mbuf_t Pointer to the output packet.
*/
	virtual void     feedPacketOutputTap( mbuf_t );

	OSMetaClassDeclareReservedUsed(IONetworkInterface, 3);

/*! @function initIfnetParams
    @abstract Allows a subclass to provide ifnet initialization parameters
    specific to an interface type.
    @discussion This method initializes the parameters that are common to all
    network interfaces. An interface subclass is expected to override this
    method, call the superclass implementation first, then initialize the
    parameters specific to that interface type. This method is called after
    an unit number has been assigned to the interface, and just before the
    interface is attached to BSD.
    @param params Pointer to an <code>ifnet_init_params</code> allocated by
    the caller.
    @result Returns <code>true</code> on success, <code>false</code> otherwise.
*/
	virtual bool     initIfnetParams( struct ifnet_init_params * params );

    OSMetaClassDeclareReservedUsed(IONetworkInterface, 4);
    
/*! @function configureOutputStartDelay
    @abstract Configure the output start delay
    @discussion This optional routine, if used, needs to be called after 
    IONetworkInterface::init() and before IONetworkInterface::attachToDataLinkLayer().
    This allows for over-riding ifnet_init_eparams.start_delay_qlen and 
    ifnet_init_eparams.start_delay_timeout.
    @param outputStartDelayQueueLength, maps to ifnet_init_eparams.start_delay_qlen
    @param outputStartDelayTimeout, maps to ifnet_init_eparams.start_delay_timeout
    @result <code>kIOReturnSuccess</code> if interface was successfully
    configured.
 */
    IOReturn configureOutputStartDelay( uint16_t outputStartDelayQueueLength,
                                        uint16_t outputStartDelayTimeout );

public:
    OSMetaClassDeclareReservedUnused( IONetworkInterface,  5);
    OSMetaClassDeclareReservedUnused( IONetworkInterface,  6);
    OSMetaClassDeclareReservedUnused( IONetworkInterface,  7);
    OSMetaClassDeclareReservedUnused( IONetworkInterface,  8);
    OSMetaClassDeclareReservedUnused( IONetworkInterface,  9);
    OSMetaClassDeclareReservedUnused( IONetworkInterface, 10);
    OSMetaClassDeclareReservedUnused( IONetworkInterface, 11);
    OSMetaClassDeclareReservedUnused( IONetworkInterface, 12);
    OSMetaClassDeclareReservedUnused( IONetworkInterface, 13);
    OSMetaClassDeclareReservedUnused( IONetworkInterface, 14);
    OSMetaClassDeclareReservedUnused( IONetworkInterface, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IONETWORKINTERFACE_H */
                                                                                                                                                                                                                        IONetworkMedium.h                                                                                   0100644 0001750 0001750 00000040570 12567452436 036723  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKMEDIUM_H
#define _IONETWORKMEDIUM_H

__BEGIN_DECLS

#include <net/if_media.h>

/*! @typedef IOMediumType
    @discussion A 32-bit value divided into fields which describes
    a single medium type. */

typedef UInt32 IOMediumType;

/*! @defined kIOMediumType
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumType property is an OSNumber object that describes the type of
        medium that this object represents. 
*/

#define kIOMediumType           "Type"

/*! @defined kIOMediumFlags
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumFlags property is an OSNumber object that describes a set of
        attributes assigned to the medium. 
*/

#define kIOMediumFlags          "Flags"

/*! @defined kIOMediumSpeed
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumSpeed property is an OSNumber object that describes the maximum link
        speed supported by the medium in bits per second. 
*/

#define kIOMediumSpeed          "Speed"

/*! @defined kIOMediumIndex
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumIndex property is an OSNumber object that describes an index assigned
        by the owner of the medium object. Its interpretation is driver
        specific.
*/

#define kIOMediumIndex          "Index"

//===========================================================================
// Medium Type (IOMediumType).
//
// The medium type is encoded by a 32-bit value. The definitions of
// the fields and the encoding for each field is adapted from FreeBSD.
//
// Bits     Definition
// -------------------
//  4-0     medium subtype
//  7-5     network type
// 15-8     network specific options
// 19-16    reserved
// 27-20    common options
// 31-28    instance number

// Ethernet.
//
enum {
    kIOMediumEthernet             =  IFM_ETHER,
    kIOMediumEthernetAuto         =  ( IFM_AUTO    | IFM_ETHER ),
    kIOMediumEthernetManual       =  ( IFM_MANUAL  | IFM_ETHER ),
    kIOMediumEthernetNone         =  ( IFM_NONE    | IFM_ETHER ),
    kIOMediumEthernet10BaseT      =  ( IFM_10_T    | IFM_ETHER ),
    kIOMediumEthernet10Base2      =  ( IFM_10_2    | IFM_ETHER ),
    kIOMediumEthernet10Base5      =  ( IFM_10_5    | IFM_ETHER ),
    kIOMediumEthernet100BaseTX    =  ( IFM_100_TX  | IFM_ETHER ),
    kIOMediumEthernet100BaseFX    =  ( IFM_100_FX  | IFM_ETHER ),
    kIOMediumEthernet100BaseT4    =  ( IFM_100_T4  | IFM_ETHER ),
    kIOMediumEthernet100BaseVG    =  ( IFM_100_VG  | IFM_ETHER ),
    kIOMediumEthernet100BaseT2    =  ( IFM_100_T2  | IFM_ETHER ),
    kIOMediumEthernet1000BaseSX   =  ( IFM_1000_SX | IFM_ETHER ),
    kIOMediumEthernet10BaseSTP    =  ( IFM_10_STP  | IFM_ETHER ),
    kIOMediumEthernet10BaseFL     =  ( IFM_10_FL   | IFM_ETHER ),
    kIOMediumEthernet1000BaseLX   =  ( IFM_1000_LX | IFM_ETHER ),
    kIOMediumEthernet1000BaseCX   =  ( IFM_1000_CX | IFM_ETHER ),
    kIOMediumEthernet1000BaseTX   =  ( IFM_1000_T  | IFM_ETHER ), //deprecated- use kIOMediumEthernet1000BaseT instead
    kIOMediumEthernet1000BaseT    =  ( IFM_1000_T  | IFM_ETHER ),
    kIOMediumEthernetHomePNA1     =  ( IFM_HPNA_1  | IFM_ETHER ),
	kIOMediumEthernet10GBaseSR    =  ( IFM_10G_SR  | IFM_ETHER ),
	kIOMediumEthernet10GBaseLR    =  ( IFM_10G_LR  | IFM_ETHER ),
    kIOMediumEthernet10GBaseCX4   =  ( IFM_10G_CX4 | IFM_ETHER ),
    kIOMediumEthernet10GBaseT     =  ( IFM_10G_T   | IFM_ETHER ),
    kIOMediumEthernet2500BaseT    =  ( IFM_2500_T  | IFM_ETHER ),
    kIOMediumEthernet5000BaseT    =  ( IFM_5000_T  | IFM_ETHER )
};

// IEEE 802.11 Wireless.
//
enum {
    kIOMediumIEEE80211            =  IFM_IEEE80211,
    kIOMediumIEEE80211Auto        =  ( IFM_AUTO           | IFM_IEEE80211 ),
    kIOMediumIEEE80211Manual      =  ( IFM_MANUAL         | IFM_IEEE80211 ),
    kIOMediumIEEE80211None        =  ( IFM_NONE           | IFM_IEEE80211 ),
    kIOMediumIEEE80211FH1         =  ( IFM_IEEE80211_FH1  | IFM_IEEE80211 ),
    kIOMediumIEEE80211FH2         =  ( IFM_IEEE80211_FH2  | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS2         =  ( IFM_IEEE80211_DS2  | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS5         =  ( IFM_IEEE80211_DS5  | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS11        =  ( IFM_IEEE80211_DS11 | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS1         =  ( IFM_IEEE80211_DS1  | IFM_IEEE80211 ),
    kIOMediumIEEE80211OptionAdhoc =  IFM_IEEE80211_ADHOC
};

// Common options.
//
enum {
    kIOMediumOptionFullDuplex     = IFM_FDX,
    kIOMediumOptionHalfDuplex     = IFM_HDX,
    kIOMediumOptionFlowControl    = IFM_FLOW,
    kIOMediumOptionEEE            = IFM_EEE,
    kIOMediumOptionFlag0          = IFM_FLAG0,
    kIOMediumOptionFlag1          = IFM_FLAG1,
    kIOMediumOptionFlag2          = IFM_FLAG2,
    kIOMediumOptionLoopback       = IFM_LOOP
};

// Medium type masks.
//
#define kIOMediumSubTypeMask        IFM_TMASK
#define kIOMediumNetworkTypeMask    IFM_NMASK
#define kIOMediumOptionsMask        IFM_OMASK
#define kIOMediumCommonOptionsMask  IFM_GMASK
#define kIOMediumInstanceShift      IFM_ISHIFT
#define kIOMediumInstanceMask       IFM_IMASK

// Medium type field accessors.
//
#define IOMediumGetSubType(x)       ((x)  & kIOMediumSubTypeMask)
#define IOMediumGetNetworkType(x)   ((x)  & kIOMediumNetworkTypeMask)
#define IOMediumGetInstance(x)      (((x) & kIOMediumInstanceMask) >> \
                                            kIOMediumInstanceShift)

//===========================================================================
// Medium flags.


//===========================================================================
// Link status bits.
//
enum {
    kIONetworkLinkValid           = IFM_AVALID,     // link status is valid
    kIONetworkLinkActive          = IFM_ACTIVE,     // link is up/active.
    kIONetworkLinkNoNetworkChange = IFM_WAKESAMENET
};

__END_DECLS

#ifdef KERNEL
//===========================================================================
// IONetworkMedium class.

#include <libkern/c++/OSObject.h>
#include <libkern/c++/OSSymbol.h>

/*! @class IONetworkMedium
    @abstract An object that encapsulates information about a network
    medium (i.e. 10Base-T, or 100Base-T Full Duplex). 
    @discussion The main purpose of
    this object is for a network driver to advertise its media capability,
    through a collection of IONetworkMedium objects stored in a dictionary
    in its property table. IONetworkMedium supports serialization, and will
    encode its properties in the form of a dictionary to the serialization
    stream when instructed. This will allow a user-space application to
    browse the set of media types supported by the controller. 
*/

class IONetworkMedium : public OSObject
{
    OSDeclareDefaultStructors( IONetworkMedium )

protected:
    IOMediumType      _type;
    UInt32            _flags;
    UInt64            _speed;
    UInt32            _index;
    const OSSymbol *  _name;

    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *_reserved;


/*! @function free
    @abstract Frees the IONetworkMedium object. 
*/

    virtual void free();

public:

/*! @function nameForType
    @abstract Creates a name that describes a medium type.
    @discussion Given a medium type, creates an OSymbol object that
    describes the medium type. There is a 1-to-1 mapping between the
    medium type, and the medium name created by this method. The caller
    is responsible for releasing the OSSymbol object returned.
    @param type A medium type. See IONetworkMedium.h for type encoding.
    @result Returns an OSSymbol object is created based on the type provided. 
*/

    static const OSSymbol * nameForType(IOMediumType type);

/*! @function addMedium
    @abstract Adds an IONetworkMedium object to a dictionary.
    @discussion A helper function to add an IONetworkMedium object to a
    given dictionary. The name of the medium is used as the key for the
    new dictionary entry.
    @param dict An OSDictionary object where the medium object should be
    added as a new entry.
    @param medium The IONetworkMedium object to add to the dictionary.
    @result Returns true on success, false otherwise. 
*/

    static bool addMedium(OSDictionary *          dict,
                          const IONetworkMedium * medium);

/*! @function removeMedium
    @abstract Removes an IONetworkMedium object from a dictionary.
    @discussion A helper function to remove an entry in a dictionary.
    @param dict The OSDictionary object where the medium object should be
    removed from.
    @param medium The name of this medium object is used as the key. 
*/

    static void removeMedium(OSDictionary *          dict,
                             const IONetworkMedium * medium);

/*! @function getMediumWithType
    @abstract Finds a medium object from a dictionary with a given type.
    @discussion This method iterates through a dictionary and returns an IONetworkMedium
    entry with the given type. An optional mask supplies the don't care bits.
    @param dict The dictionary to look for a matching entry.
    @param type Search for an entry with this type.
    @param mask The don't care bits in IOMediumType. Defaults to 0, which
    implies that a perfect match is desired.
    @result Returns the first matching IONetworkMedium entry found,
    or 0 if no match was found. 
*/

    static IONetworkMedium * getMediumWithType(const OSDictionary * dict,
                                               IOMediumType         type,
                                               IOMediumType         mask = 0);

/*! @function getMediumWithIndex
    @abstract Finds a medium object from a dictionary with a given index.
    @discussion This method iterates through a dictionary and returns an IONetworkMedium
    entry with the given index. An optional mask supplies the don't care bits.
    @param dict The dictionary to look for a matching entry.
    @param index Search for an entry with the given index.
    @param mask The don't care bits in index. Defaults to 0, which
    implies that a perfect match is desired.
    @result Returns the first matching IONetworkMedium entry found,
    or 0 if no match was found. 
*/

    static IONetworkMedium * getMediumWithIndex(const OSDictionary * dict,
                                                UInt32               index,
                                                UInt32               mask = 0);

/*! @function init
    @abstract Initializes an IONetworkMedium object.
    @param type The medium type, this value is encoded with bits defined in
           IONetworkMedium.h.
    @param speed The maximum (or the only) link speed supported over this 
           medium in units of bits per second.
    @param flags An optional flag for the medium object.
           See IONetworkMedium.h for defined flags.
    @param index An optional index number assigned by the owner.
           Drivers can use this to store an index to a media table in
           the driver, or it may map to a driver-defined media type.
    @param name An optional name assigned to this medium object. If 0,
           then a name will be created based on the medium type by
           calling IONetworkMedium::nameForType(). Since the name of
           the medium is used as a key when inserted into a dictionary,
           the name chosen must be unique within the scope of the owner.
    @result Returns true on success, false otherwise. 
*/

    virtual bool init(IOMediumType  type,
                      UInt64        speed,
                      UInt32        flags = 0,
                      UInt32        index = 0,
                      const char *  name  = 0);

/*! @function medium
    @abstract Factory method that allocates and initializes an IONetworkMedium object.
    @param type The medium type, this value is encoded with bits defined in
           IONetworkMedium.h.
    @param speed The maximum (or the only) link speed supported over this 
           medium in units of bits per second.
    @param flags An optional flag for the medium object.
           See IONetworkMedium.h for defined flags.
    @param index An optional index number assigned by the owner.
           Drivers can use this to store an index to a media table in
           the driver, or it may map to a driver-defined media type.
    @param name An optional name assigned to this medium object. If 0,
           then a name will be created based on the medium type by
           calling IONetworkMedium::nameForType(). Since the name of
           the medium is used as a key when inserted into a dictionary,
           the name chosen must be unique within the scope of the owner.
    @result Returns an IONetworkMedium instance on success, or 0 otherwise. 
*/

    static IONetworkMedium * medium(IOMediumType  type,
                                    UInt64        speed,
                                    UInt32        flags = 0,
                                    UInt32        index = 0,
                                    const char *  name  = 0);

/*! @function getType
    @result Returns the medium type assigned to this medium object. 
*/

    virtual IOMediumType  getType() const;

/*! @function getSpeed
    @result Returns the maximum link speed supported by this medium. 
*/

    virtual UInt64        getSpeed() const;

/*! @function getFlags
    @result Returns the medium flags. 
*/

    virtual UInt32        getFlags() const;

/*! @function getIndex
    @result Returns the assigned medium index. 
*/

    virtual UInt32        getIndex() const;

/*! @function getName
    @result Returns the name assigned to this medium object. 
*/

    virtual const OSSymbol * getName() const;

/*! @function getKey
    @result Returns the key to use for this medium object. This key should be
    used when this object is added to a dictionary. Same as getName(). 
*/

    virtual const OSSymbol * getKey() const;

/*! @function isEqualTo
    @abstract Tests for equality between two IONetworkMedium objects.
    @discussion Two IONetworkMedium objects are considered equal if
    they have similar properties assigned to them during initialization.
    @param medium An IONetworkMedium to test against the IONetworkMedium
    object being called.
    @result Returns true if equal, false otherwise. 
*/

    virtual bool isEqualTo(const IONetworkMedium * medium) const;

/*! @function isEqualTo
    @abstract Tests for equality between a IONetworkMedium object and an
    OSObject.
    @discussion The OSObject is considered equal to the IONetworkMedium
    object if the OSObject is an IONetworkMedium, and they have
    similar properties assigned to them during initialization.
    @param obj An OSObject to test against an IONetworkMedium object.
    @result Returns true if equal, false otherwise. 
*/

    virtual bool isEqualTo(const OSMetaClassBase * obj) const;

/*! @function serialize
    @abstract Serializes the IONetworkMedium object.
    @discussion A dictionary is created containing the properties
    assigned to this medium object, and this dictionary is then
    serialized using the OSSerialize object provided.
    @param s An OSSerialize object.
    @result Returns true on success, false otherwise. 
*/

    virtual bool serialize(OSSerialize * s) const;

    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IONetworkMedium,  0);
    OSMetaClassDeclareReservedUnused( IONetworkMedium,  1);
    OSMetaClassDeclareReservedUnused( IONetworkMedium,  2);
    OSMetaClassDeclareReservedUnused( IONetworkMedium,  3);
};

// Translate getKey() to getName().
//
inline const OSSymbol * IONetworkMedium::getKey() const
{
    return getName();
}

#endif /* KERNEL */

#endif /* !_IONETWORKMEDIUM_H */
                                                                                                                                        IONetworkStats.h                                                                                    0100644 0001750 0001750 00000006026 12567452436 036577  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKSTATS_H
#define _IONETWORKSTATS_H

/*! @header IONetworkStats.h
    @discussion Generic network statistics. */

//------------------------------------------------------------------------
// Generic network statistics. Common to all network interfaces.
//
// WARNING: This structure must match the statistics field in
// ifnet->if_data. This structure will overlay a portion of ifnet.

/*! @typedef IONetworkStats
        @discussion Generic network statistics structure.
        @field inputPackets count input packets.
        @field inputErrors count input errors.
        @field outputPackets count output packets.
        @field outputErrors count output errors.
        @field collisions count collisions on CDMA networks. */

typedef struct {
        UInt32  inputPackets;
        UInt32  inputErrors;
        UInt32  outputPackets;
        UInt32  outputErrors;
        UInt32  collisions;
} IONetworkStats;

/*! @defined kIONetworkStatsKey
        @discussion Defines the name of an IONetworkData that contains
        an IONetworkStats. */

#define kIONetworkStatsKey              "IONetworkStatsKey"

//------------------------------------------------------------------------
// Output queue statistics.

/*! @typedef IOOutputQueueStats
        @discussion Statistics recorded by IOOutputQueue objects.
        @field capacity queue capacity.
        @field size current size of the queue.
        @field peakSize peak size of the queue.
        @field dropCount number of packets dropped.
        @field outputCount number of output packets.
        @field retryCount number of retries.
        @field stallCount number of queue stalls. */

typedef struct {
        UInt32  capacity;
        UInt32  size;
        UInt32  peakSize;
        UInt32  dropCount;
        UInt32  outputCount;
        UInt32  retryCount;
        UInt32  stallCount;
        UInt32  reserved[4];
} IOOutputQueueStats;

/*! @defined kIOOutputQueueStatsKey
        @discussion Defines the name of an IONetworkData that contains
        an IOOutputQueueStats. */

#define kIOOutputQueueStatsKey          "IOOutputQueueStatsKey"

#endif /* !_IONETWORKSTATS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          IOOutputQueue.h                                                                                     0100644 0001750 0001750 00000023446 12567452436 036441  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOOUTPUTQUEUE_H
#define _IOOUTPUTQUEUE_H

#include <IOKit/network/IONetworkInterface.h>

// Forward declarations.
//
struct mbuf;
class  IONetworkData;

// FIXME - We do not want the enqueue/dequeue macros defined in queue.h.
//
#undef enqueue
#undef dequeue

// FIXME - Belongs in IOBasicOutputQueue.h
//
/*! @enum OutputPacketStatus
    @abstract The status of the packet sent to the target.
    @constant kIOOutputStatusMask Define the status field in the return code.
    @constant kIOOutputStatusAccept Packet was accepted by the target.
    @constant kIOOutputStatusDropped Packet accepted, but was also dropped.
    @constant kIOOutputStatusRetry Target ran out of resources, and is unable
    to accept the packet. The ownership of the packet reverts back to the
    queue. 
*/

enum {
    kIOOutputStatusMask     = 0x00ff,
    kIOOutputStatusAccepted = 0x0000,
    kIOOutputStatusDropped  = 0x0001,
    kIOOutputStatusRetry    = 0x0002
};

/*! @enum OutputCommands
    @abstract A command requested by the target.
    @constant kIOOutputCommandMask Define the command field in the return code.
    @constant kIOOutputCommandNone No command.
    @constant kIOOutputCommandStall A command to stall the queue. 
*/

enum {
    kIOOutputCommandMask    = 0xff00,
    kIOOutputCommandNone    = 0x0000,
    kIOOutputCommandStall   = 0x0100
};

/*! @enum OutputHandlerReturnCodes
    @abstract Common return codes returned by the target's output handler.
    @constant kIOReturnOutputSuccess Packet was accepted.
    @constant kIOReturnOutputDropped Packet was dropped.
    @constant kIOReturnOutputStall   Stall the queue and retry the same packet
              when the queue is restarted. 
*/

enum {
    kIOReturnOutputSuccess = (kIOOutputStatusAccepted | kIOOutputCommandNone),
    kIOReturnOutputDropped = (kIOOutputStatusDropped  | kIOOutputCommandNone),
    kIOReturnOutputStall   = (kIOOutputStatusRetry    | kIOOutputCommandStall)
};

/*! @class IOOutputQueue
    @abstract A packet queue that supports multiple producers and a single
    consumer. 
    @discussion Each producer, or a client thread, will deliver a chain of packets
    to the queue. A single consumer will remove packets from the queue one at a
    time and forward it to the registered target/action. This object may be used
    by an IONetworkController on the output (transmit) side to handle the output
    packet flow downstream from an IONetworkInterface, and then call the driver's
    output function. IOOutputQueue is an abstract class that provides an interface
    for its subclasses. Concrete subclasses will complete the implementation, and
    specify the context that the target is called for packets removed from
    the queue. 
*/

class IOOutputQueue : public OSObject
{
    OSDeclareAbstractStructors( IOOutputQueue )

private:

    static void runServiceThread(thread_call_param_t, thread_call_param_t);

protected:

    thread_call_t  _callEntry;  // callout entry structure.

    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *_reserved;


/*! @function init
    @abstract Initializes an IOOutputQueue object.
    @result Returns true if initialized successfully, false otherwise. 
*/

    virtual bool init();

/*! @function free
    @abstract Frees the IOOutputQueue object.
    @discussion Release allocated resources, then call super::free(). 
*/

    virtual void free();

/*! @function scheduleServiceThread
    @abstract Schedules a service thread callout.
    @discussion This method can be called by service() to schedule
    a thread that will call serviceThread() when it starts running.
    @param param A parameter to pass to the serviceThread() method.
    @result Returns true if a thread callout was scheduled, false otherwise. 
*/

    virtual bool scheduleServiceThread(void * param = 0);

/*! @function cancelServiceThread
    @abstract Cancels any pending service thread callout.
    @result Returns true if a previously scheduled thread callout was canceled,
    false otherwise. 
*/

    virtual bool cancelServiceThread();

/*! @function serviceThread
    @abstract Method called by the scheduled service thread when it
    starts to run.
    @discussion Must be implemented by a subclass that calls
    scheduleServiceThread(). The default implementation does nothing.
    @param param A parameter that was given to scheduleServiceThread()
    when the service thread was scheduled. 
*/

    virtual void serviceThread(void * param);
                                             
public:

/*! @function start
    @abstract Starts up the queue.
    @discussion This method is called by the target to start the queue. This will allow
    packets to be removed from the queue, then delivered to the target.
    @result Returns true if the queue was started successfully, false otherwise. 
*/

    virtual bool start() = 0;

/*! @function stop
    @abstract Stops the queue.
    @discussion Stop the queue and prevent it from sending packets to its
    target.
    @result Returns the previous running state of the queue,
    true if the queue was running, false if the queue was already stopped. 
*/

    virtual bool stop() = 0;

/*! @function service
    @abstract Services the queue.
    @discussion Manage the queue after it has been started.
    @param options Options for the service request.
    @result Returns a return value to indicate the service result. 
*/

    virtual bool service(IOOptionBits options = 0) = 0;

/*! @function flush
    @abstract Drops and frees all packets currently held by the queue.
    @result Returns the number of packets that were dropped and freed. 
*/

    virtual UInt32 flush() = 0;

/*! @function setCapacity
    @abstract Changes the number of packets that the queue can hold
    before it begins to drop excess packets.
    @param capacity The new desired capacity.
    @result Returns true if the new capacity was accepted, false otherwise.
*/

    virtual bool setCapacity(UInt32 capacity) = 0;

/*! @function getCapacity
    @abstract Gets the number of packets that the queue can hold.
    @discussion The queue will begin to drop incoming packets when the
    size of queue reaches its capacity.
    @result Returns the current queue capacity. 
*/

    virtual UInt32 getCapacity() const = 0;

/*! @function getSize
    @abstract Gets the number of packets currently held in the queue.
    @result Returns the size of the queue. 
*/

    virtual UInt32 getSize() const = 0;

/*! @function enqueue
    @abstract Adds a packet, or a chain of packets, to the queue.
    @discussion This method is called by a client to add a packet, or a chain of packets,
    to the queue.  A packet is described by an mbuf chain, while a chain
    of packets is constructed by linking multiple mbuf chains via the
    m_nextpkt field.
    @param m A single packet, or a chain of packets.
    @param param A parameter provided by the caller.
    @result Returns a return code. 
*/

    virtual UInt32 enqueue(mbuf_t m, void * param) = 0;

/*! @function getOutputHandler
    @abstract Returns the address of a function that is designated to handle
    incoming packets sent to the queue object.
    @result Returns the address of the enqueue() method. 
*/

    virtual IOOutputAction getOutputHandler() const;

/*! @function getStatisticsData
    @abstract Returns an IONetworkData object containing statistics counters
    updated by the queue.
    @result Returns an IONetworkData object. This implementation will always return
    0. 
*/

    virtual IONetworkData * getStatisticsData() const;

    /*! @function getMbufPriority
     @abstract Determines an mbuf's traffic priority.  The highest priority is 0.
     @discussion A queue can prioritize certain classes of traffic. This method
     facilitates that by evaluating an mbuf and returning its priority.
     @param m An mbuf to analyze.
     @result Returns a UInt32 representing the priority of the packet.  0 is the highest priority.
     */
    
    OSMetaClassDeclareReservedUsed( IOOutputQueue,  0);
    virtual UInt32 getMbufPriority(mbuf_t m);

    // Virtual function padding
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  1);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  2);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  3);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  4);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  5);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  6);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  7);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  8);
    OSMetaClassDeclareReservedUnused( IOOutputQueue,  9);
    OSMetaClassDeclareReservedUnused( IOOutputQueue, 10);
    OSMetaClassDeclareReservedUnused( IOOutputQueue, 11);
    OSMetaClassDeclareReservedUnused( IOOutputQueue, 12);
    OSMetaClassDeclareReservedUnused( IOOutputQueue, 13);
    OSMetaClassDeclareReservedUnused( IOOutputQueue, 14);
    OSMetaClassDeclareReservedUnused( IOOutputQueue, 15);
};

#endif /* !_IOOUTPUTQUEUE_H */
                                                                                                                                                                                                                          IOPacketQueue.h                                                                                     0100644 0001750 0001750 00000024042 12567452436 036341  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/network                                                        /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOPACKETQUEUE_H
#define _IOPACKETQUEUE_H

#include <libkern/c++/OSObject.h>
#include <IOKit/IOLocks.h>
extern "C" {
#include <sys/kpi_mbuf.h>
}
// Forward declarations.
//
struct mbuf;
struct IOMbufQueue;

// We do not want the enqueue/dequeue macros defined in queue.h.
//
// #warning queue.h should not be included
#undef enqueue
#undef dequeue

/*! @class IOPacketQueue
    @abstract Implements a bounded FIFO queue of mbuf packets. 
    @discussion Packets are
    removed from the head of the queue (dequeue), and new packets are added
    to the tail of the queue (enqueue). A spinlock is used to synchronize
    access to the queue between methods that have a "lock" prefix. 
*/

class IOPacketQueue : public OSObject
{   
    OSDeclareDefaultStructors( IOPacketQueue )

protected:
    IOMbufQueue *   _queue;   // mbuf queue
    IOSimpleLock *  _lock;    // spinlock for synchronized methods

    struct ExpansionData { };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *_reserved;

/*! @function free
    @abstract Frees the IOPacketQueue object.
    @discussion All packets held by the queue are released back to the free
    pool, resource are deallocated, then super::free() is called. 
*/

    virtual void free();

/*! @var IOPacketQueueDefaultCapacity 
    @abstract Describes the default capacity of the 
    queue object. 
    @discussion The capacity is only observed by the enqueue() method.
    Therefore, it is possible for the size of the queue to exceed its
    capacity when other methods, such as prepend(), are used to add packets
    to the queue. 
*/

    static const UInt32 IOPacketQueueDefaultCapacity = 100;

public:

/*! @function withCapacity
    @abstract Factory method that constructs and initializes an
    IOPacketQueue object.
    @param capacity The initial capacity of the queue object. Can be
    later changed by calling the setCapacity() method.
    @result Returns an IOPacketQueue instance on success, or 0 otherwise. 
*/

    static IOPacketQueue * withCapacity(UInt32 capacity = 
                                        IOPacketQueueDefaultCapacity);

/*! @function initWithCapacity
    @abstract Initializes an IOPacketQueue object.
    @discussion This method initializes an IOPacketQueue object with the given capacity.
    @param capacity The initial capacity of the queue. Can be later changed
    by calling the setCapacity() method.
    @result Returns true if initialized successfully, false otherwise. 
*/

    virtual bool initWithCapacity(UInt32 capacity = 
                                  IOPacketQueueDefaultCapacity);

/*! @function getSize
    @abstract Gets the size of the queue.
    @result Returns the number of packets currently held by the queue. 
*/

    virtual UInt32 getSize() const;

/*! @function setCapacity
    @abstract Changes the capacity of the queue.
    @param capacity The new capacity.
    @result Returns true if the new capacity was accepted, false otherwise. 
*/

    virtual bool setCapacity(UInt32 capacity);

/*! @function getCapacity
    @abstract Gets the current capacity of the queue.
    @result Returns the current queue capacity. 
*/

    virtual UInt32 getCapacity() const;

/*! @function peek
    @abstract Examines the packet at the head of the queue without
    removing it from the queue.
    @discussion A following call to peek() or dequeue() will return
    the same packet. The caller must never modify the mbuf packet returned.
    @result Returns the packet at the head of the queue. 
*/

    virtual const mbuf_t peek() const;

/*! @function prepend
    @abstract Adds a chain of packets to the head of the queue.
    @param m A chain of packets to add to the head of the queue. 
*/

    virtual void prepend(mbuf_t m);

/*! @function prepend
    @abstract Removes all packets from the specified queue, and adds them
    to the head of this queue.
    @param queue The source IOPacketQueue object containing the packets to
    be transferred. 
*/

    virtual void prepend(IOPacketQueue * queue);

/*! @function lockPrepend
    @abstract Adds a chain of packets to the head of a synchronized queue.
    @discussion A spinlock is used to synchronize access to the queue.
    @param m A chain of packets to add to the head of the queue.
    @result Always returns true. 
*/

    virtual void lockPrepend(mbuf_t m);

/*! @function enqueue
    @abstract Adds a chain of packets to the tail of the queue.
    @discussion Packets are not added if the size of the queue has reached
    its capacity.
    @param m A chain of packets to add to the tail of the queue.
    @result Returns true on success, or false to indicate over-capacity and refusal
    to accept the packet chain provided. 
*/

    virtual bool enqueue(mbuf_t m);

/*! @function enqueue
    @abstract Removes all packets from the specified queue, and adds them
    to the tail of this queue.
    @param queue The source IOPacketQueue object containing the packets to
    be transferred.
    @result Always returns true. 
*/

    virtual bool enqueue(IOPacketQueue * queue);

/*! @function enqueueWithDrop
    @abstract Adds a chain of packets to the tail of the queue. 
    @discussion Packets are
    dropped if the size of the queue has reached its capacity.
    @param m A chain of packets to add to the tail of the queue.
    @result Returns the number of packets dropped and freed by the queue. 
*/

    virtual UInt32 enqueueWithDrop(mbuf_t m);

/*! @function lockEnqueue
    @abstract Adds a chain of packets to the tail of a synchronized queue.
    @discussion Packets are not added if the size of the queue has reached
    its capacity. A spinlock is used to synchronize access to the queue.
    @param m A chain of packets to add to the tail of the queue.
    @result Returns true on success, or false to indicate over-capacity and refusal
    to accept the packet chain provided.
*/

    virtual bool lockEnqueue(mbuf_t m);

/*! @function lockEnqueueWithDrop
    @abstract Adds a chain of packets to the tail of a synchronized queue.
    @discussion Packets are dropped if the size of the queue has reached its capacity.  A spinlock is used to synchronize access to the queue.
    @param m A chain of packets to add to the tail of the queue.
    @result Returns the number of packets dropped and freed by the queue. 
*/

    virtual UInt32 lockEnqueueWithDrop(mbuf_t m);

/*! @function dequeue
    @abstract Removes a single packet from the head of the queue.
    @result Returns a packet removed from the head of the queue, or NULL if the
    queue was empty. 
*/

    virtual mbuf_t dequeue();

/*! @function lockDequeue
    @abstract Removes a single packet from the head of a synchronized queue.
    @discussion A spinlock is used to synchronize access to the queue.
    @result Returns a packet removed from the head of the queue, or NULL if the
    queue was empty. 
*/

    virtual mbuf_t lockDequeue();

/*! @function dequeueAll
    @abstract Removes all packets from the queue and returns the head of the
    packet chain.
    @discussion The size of the queue is cleared to zero.
    @result Returns the head of a packet chain linking all packets that were held
    in the queue, or NULL if the queue was empty. 
*/

    virtual mbuf_t dequeueAll();

/*! @function lockDequeueAll
    @abstract Removes all packets from a synchronized queue and returns the
    head of the packet chain.
    @discussion The size of the queue is cleared to zero. A spinlock is used
    to synchronize access to the queue.
    @result Returns the head of a packet chain linking all packets that were held
    in the queue, or NULL if the queue was empty. 
*/

    virtual mbuf_t lockDequeueAll();

/*! @function flush
    @abstract Frees all packets currently held in the queue and releases them
    back to the free mbuf pool.
    @discussion The size of the queue is cleared to zero.
    @result Returns the number of packets freed. 
*/

    virtual UInt32 flush();

/*! @function lockFlush
    @abstract Frees all packets currently held in a synchronized queue and
    releases them back to the free mbuf pool.
    @discussion The size of the queue is cleared to zero. A spinlock is used
    to synchronize access to the queue.
    @result Returns the number of packets freed. 
*/

    virtual UInt32 lockFlush();

    // Virtual Pad functions
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  0);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  1);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  2);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  3);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  4);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  5);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  6);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  7);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  8);
    OSMetaClassDeclareReservedUnused( IOPacketQueue,  9);
    OSMetaClassDeclareReservedUnused( IOPacketQueue, 10);
    OSMetaClassDeclareReservedUnused( IOPacketQueue, 11);
    OSMetaClassDeclareReservedUnused( IOPacketQueue, 12);
    OSMetaClassDeclareReservedUnused( IOPacketQueue, 13);
    OSMetaClassDeclareReservedUnused( IOPacketQueue, 14);
    OSMetaClassDeclareReservedUnused( IOPacketQueue, 15);
};

#endif /* !_IOPACKETQUEUE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              nvram/                                                                                              0040755 0001750 0001750 00000000000 12612224742 033143  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IONVRAMController.h                                                                                 0100644 0001750 0001750 00000003525 12567450736 036512  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/nvram                                                          /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IONVRAMCONTROLLER_H
#define _IOKIT_IONVRAMCONTROLLER_H

#include <IOKit/IOService.h>

class IONVRAMController: public IOService
{
  OSDeclareAbstractStructors(IONVRAMController);
  
public:
  virtual void registerService(IOOptionBits options = 0) APPLE_KEXT_OVERRIDE;
  
  virtual void sync(void);
  
  virtual IOReturn read(IOByteCount offset, UInt8 *buffer,
			IOByteCount length) = 0;
  virtual IOReturn write(IOByteCount offset, UInt8 *buffer,
			 IOByteCount length) = 0;
};

#endif /* !_IOKIT_IONVRAMCONTROLLER_H */
                                                                                                                                                                           pci/                                                                                                0040755 0001750 0001750 00000000000 12612224742 032573  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOAGPDevice.h                                                                                       0100644 0001750 0001750 00000023015 12567452147 034734  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pci                                                            /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOAGPDEVICE_H
#define _IOKIT_IOAGPDEVICE_H

#include <IOKit/IORangeAllocator.h>
#include <IOKit/pci/IOPCIDevice.h>

/* Definitions of AGP config registers */
enum {
    kIOPCIConfigAGPStatusOffset  = 4,
    kIOPCIConfigAGPCommandOffset = 8
};

/* Definitions of AGP Command & Status registers */
enum {
    kIOAGPRequestQueueMask      = 0xff000000,
    kIOAGPSideBandAddresssing   = 0x00000200,
    kIOAGPEnable                = 0x00000100,
    kIOAGP4GbAddressing         = 0x00000020,
    kIOAGPFastWrite             = 0x00000010,
    kIOAGP4xDataRate            = 0x00000004,
    kIOAGP2xDataRate            = 0x00000002,
    kIOAGP1xDataRate            = 0x00000001
};

enum {
    kIOAGPGartInvalidate        = 0x00000001
};

// getAGPStatus() defines
enum {
    kIOAGPDefaultStatus         = 0
};
enum {
    kIOAGPIdle                  = 0x00000001,
    kIOAGPInvalidGARTEntry      = 0x00000002,
    kIOAGPAccessOutOfRange      = 0x00000004
};

#define kIOAGPBusFlagsKey       "IOAGPFlags"
enum {
    // the AGP target must be idle before invalidating its gart tlb
    kIOAGPGartIdleInvalidate    = 0x00000001,

    // the AGP target cannot handle operations that cross page boundaries
    kIOAGPDisablePageSpans      = 0x00000002,

    // the AGP target cannot handle master -> target AGP writes
    kIOAGPDisableAGPWrites      = 0x00000004,

    // the AGP target cannot handle target -> master PCI reads
    kIOAGPDisablePCIReads       = 0x00000008,

    // the AGP target cannot handle master -> target PCI writes
    kIOAGPDisablePCIWrites      = 0x00000010,

    // the AGP target cannot handle all unaligned transactions 
    kIOAGPDisableUnaligned      = 0x00000020,

    kIOAGPDisableFeature6       = 0x00000040,
    kIOAGPDisableFeature7       = 0x00000080,
    kIOAGPDisableFeature8       = 0x00000100,
    kIOAGPDisableFeature9       = 0x00000200
};

// masterState
enum {
    kIOAGPStateEnabled          = 0x00000001,
    kIOAGPStateEnablePending    = 0x00010000
};


/*! @class IOAGPDevice
    @abstract An IOService class representing an AGP master device.
    @discussion The discovery of an AGP master device by the PCI bus family results in an instance of the IOAGPDevice being created and published. It provides services specific to AGP, in addition to the PCI services supplied by its superclass IOPCIDevice.
*/

class IOAGPDevice : public IOPCIDevice
{
    OSDeclareDefaultStructors(IOAGPDevice)

protected:

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the IOWorkLoop in the future.
*/    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  
*/
    ExpansionData *reserved;

public:
    UInt32      masterState;
    UInt8       masterAGPRegisters;

/*! @function createAGPSpace
    @abstract Allocates the AGP space, and enables AGP transactions on the master and slave.
    @discussion This method should be called by the driver for the AGP master device to set the size of the space and enable AGP transactions. It will destroy any AGP space currently allocated.
    @param options No options are currently defined, pass zero.
    @param address The physical range allocated for the AGP space is passed back to the caller.
    @param length An in/out parameter - the caller sets the devices maximum AGP addressing and the actual size created is passed back.
    @result Returns an IOReturn code indicating success or failure. 
*/

    virtual IOReturn createAGPSpace( IOOptionBits options,
                                    IOPhysicalAddress * address, 
                                    IOPhysicalLength * length );

/*! @function destroyAGPSpace
    @abstract Destroys the AGP space, and disables AGP transactions on the master and slave.
    @discussion This method should be called by the driver to shutdown AGP transactions and release resources. 
*/

    virtual IOReturn destroyAGPSpace( void );

/*! @function getAGPRangeAllocator
    @abstract Accessor to obtain the AGP range allocator.
    @discussion To allocate ranges in AGP space, obtain a range allocator for the space with this method. It is retained while the space is created (until destroyAGPSpace is called) and should not be released by the caller.
    @result Returns a pointer to the range allocator for the AGP space. 
*/

    virtual IORangeAllocator * getAGPRangeAllocator( void );

/*! @function getAGPStatus
    @abstract Returns the current state of the AGP bus.
    @discussion Returns state bits for the AGP bus. Only one type of status is currently defined. 
    @param which Type of status - only kIOAGPDefaultStatus is currently valid.
    @result Returns mask of status bits for the AGP bus.
*/

    virtual IOOptionBits getAGPStatus( IOOptionBits which = kIOAGPDefaultStatus );

/*! @function commitAGPMemory
    @abstract Makes memory addressable by AGP transactions.
    @discussion Makes the memory described by the IOMemoryDescriptor object addressable by AGP by entering its pages into the GART array, given an offset into AGP space supplied by the caller (usually allocated by the AGP range allocator). It is the caller's responsibility to prepare non-kernel pageable memory before calling this method, with IOMemoryDescriptor::prepare.
    @param memory A IOMemoryDescriptor object describing the memory to add to the GART.
    @param agpOffset An offset into AGP space that the caller has allocated - usually allocated by the AGP range allocator.
    @param options Pass kIOAGPGartInvalidate if the AGP target should invalidate any GART TLB.
    @result Returns an IOReturn code indicating success or failure.
*/

    virtual IOReturn commitAGPMemory( IOMemoryDescriptor * memory,
                                        IOByteCount agpOffset,
                                        IOOptionBits options = 0 );

/*! @function releaseAGPMemory
    @abstract Releases memory addressable by AGP transactions.
    @discussion Makes the memory described by the IOMemoryDescriptor object unaddressable by AGP by removing its pages from the GART array, given an offset into AGP space supplied by the caller (usually allocated by the AGP range allocator). It is the caller's responsibility to complete non-kernel pageable memory before calling this method, with IOMemoryDescriptor::complete.
    @param memory A IOMemoryDescriptor object describing the memory to remove from the GART.
    @param agpOffset An offset into AGP space that the caller has allocated - usually allocated by the AGP range allocator.
    @param options Pass kIOAGPGartInvalidate if the AGP target should invalidate any GART TLB.
    @result Returns an IOReturn code indicating success or failure.
*/

    virtual IOReturn releaseAGPMemory( IOMemoryDescriptor * memory, 
                                        IOByteCount agpOffset,
                                        IOOptionBits options = 0 );

    virtual IOReturn resetAGP( IOOptionBits options = 0 );

/*! @function getAGPSpace
    @abstract Returns the allocated AGP space.
    @discussion This method can be called by the driver for the AGP master device to retrieve the physical address and size of the space created with createAGPSpace.
    @param address The physical range allocated for the AGP space is passed back to the caller. Zero may be passed if the address is not needed by the caller.
    @param length The size of the the AGP space created is passed back.  Zero may be passed if the length is not needed by the caller.
    @result Returns an IOReturn code indicating success or failure. 
*/

    virtual IOReturn getAGPSpace( IOPhysicalAddress * address, 
                                    IOPhysicalLength * length );

    // Unused Padding
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  0);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  1);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  2);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  3);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  4);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  5);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  6);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  7);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  8);
    OSMetaClassDeclareReservedUnused(IOAGPDevice,  9);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 10);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 11);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 12);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 13);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 14);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 15);
    OSMetaClassDeclareReservedUnused(IOAGPDevice, 16);
};

#endif /* ! _IOKIT_IOAGPDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   IOPCIBridge.h                                                                                       0100644 0001750 0001750 00000043153 12567452147 034742  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pci                                                            /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998-2000 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOPCIBRIDGE_H
#define _IOKIT_IOPCIBRIDGE_H

#include <IOKit/IOService.h>
#include <IOKit/IODeviceMemory.h>
#include <IOKit/IOFilterInterruptEventSource.h>
#include <IOKit/pwr_mgt/RootDomain.h>
#include <IOKit/pci/IOAGPDevice.h>

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
class IOPCIConfigurator;
class IOPCIDevice;
class IOPCIMessagedInterruptController;

enum {
    kIOPCIResourceTypeMemory         = 0,
    kIOPCIResourceTypePrefetchMemory = 1,
    kIOPCIResourceTypeIO             = 2,
    kIOPCIResourceTypeBusNumber      = 3,
    kIOPCIResourceTypeCount          = 4,
};

/*!
    @class IOPCIBridge
    @abstract   Base class for all PCI bridge drivers.
*/

class IOPCIBridge : public IOService
{
    friend class IOPCIDevice;
    friend class IOPCI2PCIBridge;
    friend class IOPCIConfigurator;

    OSDeclareAbstractStructors(IOPCIBridge)

private:
    static void initialize(void);
    IORegistryEntry * findMatching( OSIterator * in, IOPCIAddressSpace space );
    virtual bool isDTNub( IOPCIDevice * nub );
    bool checkProperties( IOPCIDevice * entry );

    void removeDevice( IOPCIDevice * device, IOOptionBits options = 0 );

	void restoreQEnter(IOPCIDevice * device);
    void restoreQRemove(IOPCIDevice * device);

	IOReturn restoreTunnelState(IOPCIDevice * root, IOOptionBits options);
    IOReturn restoreMachineState( IOOptionBits options, IOPCIDevice * device );
    void tunnelsWait(IOPCIDevice * device);
    static IOReturn finishMachineState(IOOptionBits options);
	static IOReturn systemPowerChange(void * target, void * refCon,
										UInt32 messageType, IOService * service,
										void * messageArgument, vm_size_t argSize);

    IOReturn _restoreDeviceState( IOPCIDevice * device, IOOptionBits options );
    IOReturn resolveLegacyInterrupts( IOService * provider, IOPCIDevice * nub );
    IOReturn resolveMSIInterrupts   ( IOService * provider, IOPCIDevice * nub );

    IOReturn relocate(IOPCIDevice * device, uint32_t options);
	void spaceFromProperties( IORegistryEntry * regEntry,
                              IOPCIAddressSpace * space );
	void updateWakeReason(IOPCIDevice * device);

protected:
    static void nvLocation( IORegistryEntry * entry,
                            UInt8 * busNum, UInt8 * deviceNum, UInt8 * functionNum );
#if !defined(__LP64__) || defined(__x86_64__)
    static SInt32 compareAddressCell( UInt32 cellCount, UInt32 cleft[], UInt32 cright[] );
#else
    static SInt64 compareAddressCell( UInt32 cellCount, UInt32 cleft[], UInt32 cright[] );
#endif
    IOReturn setDeviceASPMBits(IOPCIDevice * device, uint32_t bits);
    IOReturn setDeviceL1PMBits(IOPCIDevice * device, uint32_t bits);

    IOReturn setDevicePowerState(IOPCIDevice * device, IOOptionBits options,
								 unsigned long prevState, unsigned long newState);
    static IOReturn configOp(IOService * device, uintptr_t op, void * result, void * arg = 0);
    static void     deferredProbe(IOPCIDevice * device);

    void * __reserved1;
    void * __reserved2;

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the IOPCIBridge in the future.
*/    
    struct ExpansionData
    {
        struct IOPCIRange * rangeLists[kIOPCIResourceTypeCount];
        IOPCIMessagedInterruptController *messagedInterruptController;
    };

/*! @var reserved
    Reserved for future use.  (Internal use only)  
*/
private:
    ExpansionData *reserved;

protected:
	IOWorkLoop * getConfiguratorWorkLoop(void) const;

public:
	static IOPCIEventSource * createEventSource(
			         OSObject * owner, IOPCIEventSource::Action action, uint32_t options);

public:
    virtual void probeBus( IOService * provider, UInt8 busNum );

    virtual UInt8 firstBusNum( void );
    virtual UInt8 lastBusNum( void );

    virtual void spaceFromProperties( OSDictionary * propTable,
                                        IOPCIAddressSpace * space );
    virtual OSDictionary * constructProperties( IOPCIAddressSpace space );

    virtual IOPCIDevice * createNub( OSDictionary * from );

    virtual bool initializeNub( IOPCIDevice * nub, OSDictionary * from );

    virtual bool publishNub( IOPCIDevice * nub, UInt32 index );

    virtual bool addBridgeMemoryRange( IOPhysicalAddress start,
                                        IOPhysicalLength length, bool host );

    virtual bool addBridgeIORange( IOByteCount start, IOByteCount length );


private:
    virtual bool constructRange( IOPCIAddressSpace * flags,
                                 IOPhysicalAddress64 phys, IOPhysicalLength64 len,
                                 OSArray * array );

    virtual bool matchNubWithPropertyTable( IOService * nub,
                                            OSDictionary * propertyTable,
                                            SInt32 * score );

    virtual bool compareNubName( const IOService * nub, OSString * name,
                                 OSString ** matched = 0 ) const;

    virtual bool pciMatchNub( IOPCIDevice * nub,
                                OSDictionary * table, SInt32 * score);

    virtual bool matchKeys( IOPCIDevice * nub, const char * keys,
                                UInt32 defaultMask, UInt8 regNum );

    virtual IOReturn getNubResources( IOService * nub );

    virtual IOReturn getNubAddressing( IOPCIDevice * nub );

    virtual IOReturn getDTNubAddressing( IOPCIDevice * nub );

public:
    virtual void free( void );

    virtual bool start( IOService * provider );

    virtual void stop( IOService * provider );

    virtual bool configure( IOService * provider );

	virtual IOReturn setProperties(OSObject * properties);

    virtual IOReturn newUserClient(task_t owningTask, void * securityID,
                                   UInt32 type,  OSDictionary * properties,
                                   IOUserClient ** handler);

	virtual unsigned long maxCapabilityForDomainState ( IOPMPowerFlags domainState );
	virtual unsigned long initialPowerStateForDomainState ( IOPMPowerFlags domainState );
	virtual unsigned long powerStateForDomainState ( IOPMPowerFlags domainState );

    virtual IOReturn callPlatformFunction(const OSSymbol * functionName,
                                          bool waitForFunction,
                                          void * param1, void * param2,
                                          void * param3, void * param4);

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * */

    virtual IODeviceMemory * ioDeviceMemory( void ) = 0;

    virtual UInt32 configRead32( IOPCIAddressSpace space, UInt8 offset ) = 0;
    virtual void configWrite32( IOPCIAddressSpace space,
                                        UInt8 offset, UInt32 data ) = 0;
    virtual UInt16 configRead16( IOPCIAddressSpace space, UInt8 offset ) = 0;
    virtual void configWrite16( IOPCIAddressSpace space,
                                        UInt8 offset, UInt16 data ) = 0;
    virtual UInt8 configRead8( IOPCIAddressSpace space, UInt8 offset ) = 0;
    virtual void configWrite8( IOPCIAddressSpace space,
                                        UInt8 offset, UInt8 data ) = 0;

    virtual IOPCIAddressSpace getBridgeSpace( void ) = 0;

    virtual UInt32 findPCICapability( IOPCIAddressSpace space,
                                      UInt8 capabilityID, UInt8 * offset = 0 );

    virtual IOReturn setDevicePowerState( IOPCIDevice * device,
                                          unsigned long whatToDo );
    virtual IOReturn saveDeviceState( IOPCIDevice * device,
                                      IOOptionBits options = 0 );
    virtual IOReturn restoreDeviceState( IOPCIDevice * device,
                                         IOOptionBits options = 0 );

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * */

    virtual IOReturn createAGPSpace( IOAGPDevice * master,
                                     IOOptionBits options,
                                     IOPhysicalAddress * address, 
                                     IOPhysicalLength * length );

    virtual IOReturn destroyAGPSpace( IOAGPDevice * master );

    virtual IORangeAllocator * getAGPRangeAllocator( IOAGPDevice * master );

    virtual IOOptionBits getAGPStatus( IOAGPDevice * master,
                                       IOOptionBits options = 0 );
    virtual IOReturn resetAGPDevice( IOAGPDevice * master,
                                     IOOptionBits options = 0 );

    virtual IOReturn getAGPSpace( IOAGPDevice * master,
                                  IOPhysicalAddress * address, 
                                  IOPhysicalLength * length );

    virtual IOReturn commitAGPMemory( IOAGPDevice * master, 
                                      IOMemoryDescriptor * memory,
                                      IOByteCount agpOffset,
                                      IOOptionBits options );

    virtual IOReturn releaseAGPMemory(  IOAGPDevice * master, 
                                        IOMemoryDescriptor * memory, 
                                        IOByteCount agpOffset,
                                        IOOptionBits options );

protected:
    OSMetaClassDeclareReservedUsed(IOPCIBridge, 0);
private:
    virtual bool addBridgePrefetchableMemoryRange( IOPhysicalAddress start,
                                                   IOPhysicalLength length,
                                                   bool host );
protected:
    bool addBridgePrefetchableMemoryRange( addr64_t start, addr64_t length );
    IOReturn kernelRequestProbe(IOPCIDevice * device, uint32_t options);
    IOReturn protectDevice(IOPCIDevice * device, uint32_t space, uint32_t prot);

    OSMetaClassDeclareReservedUsed(IOPCIBridge, 1);
    virtual UInt32 extendedFindPCICapability( IOPCIAddressSpace space,
                                              UInt32 capabilityID, IOByteCount * offset = 0 );

    OSMetaClassDeclareReservedUsed(IOPCIBridge, 2);
    virtual IOReturn setDeviceASPMState(IOPCIDevice * device,
                                IOService * client, IOOptionBits state);

    OSMetaClassDeclareReservedUsed(IOPCIBridge, 3);
	virtual IOReturn checkLink(uint32_t options = 0);

    OSMetaClassDeclareReservedUsed(IOPCIBridge, 4);
	virtual IOReturn enableLTR(IOPCIDevice * device, bool enable);

    OSMetaClassDeclareReservedUsed(IOPCIBridge, 5);
    virtual IOPCIEventSource * createEventSource(IOPCIDevice * device,
			OSObject * owner, IOPCIEventSource::Action action, uint32_t options);

    // Unused Padding
    OSMetaClassDeclareReservedUnused(IOPCIBridge,  6);
    OSMetaClassDeclareReservedUnused(IOPCIBridge,  7);
    OSMetaClassDeclareReservedUnused(IOPCIBridge,  8);
    OSMetaClassDeclareReservedUnused(IOPCIBridge,  9);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 10);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 11);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 12);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 13);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 14);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 15);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 16);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 17);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 18);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 19);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 20);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 21);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 22);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 23);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 24);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 25);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 26);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 27);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 28);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 29);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 30);
    OSMetaClassDeclareReservedUnused(IOPCIBridge, 31);
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class IOPCI2PCIBridge : public IOPCIBridge
{
    friend class IOPCIEventSource;
    friend class IOPCIDevice;

    OSDeclareDefaultStructors(IOPCI2PCIBridge)

protected:
	IOFilterInterruptEventSource * fBridgeInterruptSource;

private:
    IOPCIDevice *                  fBridgeDevice;
	IOTimerEventSource *	       fTimerProbeES;
	IOWorkLoop *                   fWorkLoop;
	IOPMDriverAssertionID 		   fPMAssertion;
    IOSimpleLock *                 fISRLock;
    struct IOPCIAERRoot *          fAERRoot;
	uint32_t                       __resvA[6];
	int32_t                        fTunnelL1EnableCount;
	uint32_t                       fHotplugCount;

	uint8_t                        _resvA[3];
    uint8_t                        fHotPlugInts;
	uint8_t                        fIntsPending;
	uint8_t                        fIsAERRoot;

	uint8_t                        fPresence;
	uint8_t                        fWaitingLinkEnable;
	uint8_t                        fLinkChangeOnly;
	uint8_t                        fBridgeInterruptEnablePending;
	uint8_t                        fNeedProbe;
	uint8_t                        fPresenceInt;
	uint8_t						   fBridgeMSI;
	uint8_t						   fNoDevice;
	uint8_t						   fLinkControlWithPM;
	uint8_t						   fPowerState;
	char						   fLogName[32];
;

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData {};

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

public:

    virtual UInt8 firstBusNum( void );
    virtual UInt8 lastBusNum( void );

public:
    virtual void free();

    virtual bool serializeProperties( OSSerialize * serialize ) const;

    virtual IOService * probe(  IOService *     provider,
                                SInt32 *        score );

    virtual bool start( IOService * provider );

    virtual void stop( IOService * provider );

    virtual bool configure( IOService * provider );

    virtual void probeBus( IOService * provider, UInt8 busNum );

    virtual IOReturn requestProbe( IOOptionBits options );

    virtual void saveBridgeState( void );

    virtual void restoreBridgeState( void );

    IOReturn setPowerState( unsigned long powerState,
                            IOService * whatDevice );

	void adjustPowerState(unsigned long state);

    virtual IOReturn saveDeviceState( IOPCIDevice * device,
                                      IOOptionBits options = 0 );

    virtual bool publishNub( IOPCIDevice * nub, UInt32 index );

    virtual IODeviceMemory * ioDeviceMemory( void );

    virtual IOPCIAddressSpace getBridgeSpace( void );

    virtual UInt32 configRead32( IOPCIAddressSpace space, UInt8 offset );
    virtual void configWrite32( IOPCIAddressSpace space,
                                        UInt8 offset, UInt32 data );
    virtual UInt16 configRead16( IOPCIAddressSpace space, UInt8 offset );
    virtual void configWrite16( IOPCIAddressSpace space,
                                        UInt8 offset, UInt16 data );
    virtual UInt8 configRead8( IOPCIAddressSpace space, UInt8 offset );
    virtual void configWrite8( IOPCIAddressSpace space,
                                        UInt8 offset, UInt8 data );

    virtual IOReturn setDeviceASPMState(IOPCIDevice * device,
                                IOService * client, IOOptionBits state);

	virtual IOReturn checkLink(uint32_t options = 0);

	virtual IOReturn enableLTR(IOPCIDevice * device, bool enable);

    virtual IOPCIEventSource * createEventSource(IOPCIDevice * device,
			OSObject * owner, IOPCIEventSource::Action action, uint32_t options);

    // Unused Padding
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  0);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  1);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  2);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  3);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  4);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  5);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  6);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  7);
    OSMetaClassDeclareReservedUnused(IOPCI2PCIBridge,  8);

protected:
    void allocateBridgeInterrupts(IOService * provider);
	void startBridgeInterrupts(IOService * provider);
	void enableBridgeInterrupts(void);
	void disableBridgeInterrupts(void);

private:
    IOReturn setTunnelL1Enable(IOPCIDevice * device, IOService * client,
    									bool l1Enable);

public:
	void startBootDefer(IOService * provider);

    bool filterInterrupt( IOFilterInterruptEventSource * source);
                            
    void handleInterrupt( IOInterruptEventSource * source,
                             int                      count );
	void timerProbe(IOTimerEventSource * es);
};

#define kIOPCI2PCIBridgeName	"IOPP"

#endif /* ! _IOKIT_IOPCIBRIDGE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                     IOPCIDevice.h                                                                                       0100644 0001750 0001750 00000123415 12567452147 034745  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pci                                                            /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IOPCIDEVICE_H
#define _IOKIT_IOPCIDEVICE_H

#include <IOKit/IOTypes.h>

/* Definitions of PCI Config Registers */
enum {
    kIOPCIConfigVendorID                = 0x00,
    kIOPCIConfigDeviceID                = 0x02,
    kIOPCIConfigCommand                 = 0x04,
    kIOPCIConfigStatus                  = 0x06,
    kIOPCIConfigRevisionID              = 0x08,
    kIOPCIConfigClassCode               = 0x09,
    kIOPCIConfigCacheLineSize           = 0x0C,
    kIOPCIConfigLatencyTimer            = 0x0D,
    kIOPCIConfigHeaderType              = 0x0E,
    kIOPCIConfigBIST                    = 0x0F,
    kIOPCIConfigBaseAddress0            = 0x10,
    kIOPCIConfigBaseAddress1            = 0x14,
    kIOPCIConfigBaseAddress2            = 0x18,
    kIOPCIConfigBaseAddress3            = 0x1C,
    kIOPCIConfigBaseAddress4            = 0x20,
    kIOPCIConfigBaseAddress5            = 0x24,
    kIOPCIConfigCardBusCISPtr           = 0x28,
    kIOPCIConfigSubSystemVendorID       = 0x2C,
    kIOPCIConfigSubSystemID             = 0x2E,
    kIOPCIConfigExpansionROMBase        = 0x30,
    kIOPCIConfigCapabilitiesPtr         = 0x34,
    kIOPCIConfigInterruptLine           = 0x3C,
    kIOPCIConfigInterruptPin            = 0x3D,
    kIOPCIConfigMinimumGrant            = 0x3E,
    kIOPCIConfigMaximumLatency          = 0x3F
};

/* Definitions of Capabilities PCI Config Register */
enum {
    kIOPCICapabilityIDOffset            = 0x00,
    kIOPCINextCapabilityOffset          = 0x01,

    kIOPCIPowerManagementCapability     = 0x01,
    kIOPCIAGPCapability                 = 0x02,
    kIOPCIVitalProductDataCapability    = 0x03,
    kIOPCISlotIDCapability              = 0x04,
    kIOPCIMSICapability                 = 0x05,
    kIOPCICPCIHotswapCapability         = 0x06,
    kIOPCIPCIXCapability                = 0x07,
    kIOPCILDTCapability                 = 0x08,
    kIOPCIVendorSpecificCapability      = 0x09,
    kIOPCIDebugPortCapability           = 0x0a,
    kIOPCICPCIResourceControlCapability = 0x0b,
    kIOPCIHotplugCapability             = 0x0c,
    kIOPCIAGP8Capability                = 0x0e,
    kIOPCISecureCapability              = 0x0f,
    kIOPCIPCIExpressCapability          = 0x10,
    kIOPCIMSIXCapability                = 0x11,

    kIOPCIExpressErrorReportingCapability            = -0x01UL,
    kIOPCIExpressVirtualChannelCapability            = -0x02UL,
    kIOPCIExpressDeviceSerialNumberCapability        = -0x03UL,
    kIOPCIExpressPowerBudgetCapability               = -0x04UL,
    kIOPCIExpressLatencyTolerenceReportingCapability = -0x18UL,
    kIOPCIExpressL1PMSubstatesCapability             = -0x1EUL,
};

/* Space definitions */
enum {
    kIOPCIConfigSpace           = 0,
    kIOPCIIOSpace               = 1,
    kIOPCI32BitMemorySpace      = 2,
    kIOPCI64BitMemorySpace      = 3
};

/* Command register definitions */
enum {
    kIOPCICommandIOSpace                = 0x0001,
    kIOPCICommandMemorySpace            = 0x0002,
    kIOPCICommandBusMaster              = 0x0004,
    kIOPCICommandSpecialCycles          = 0x0008,
    kIOPCICommandMemWrInvalidate        = 0x0010,
    kIOPCICommandPaletteSnoop           = 0x0020,
    kIOPCICommandParityError            = 0x0040,
    kIOPCICommandAddressStepping        = 0x0080,
    kIOPCICommandSERR                   = 0x0100,
    kIOPCICommandFastBack2Back          = 0x0200,
    kIOPCICommandInterruptDisable       = 0x0400
};

/* Status register definitions */
enum {
	kIOPCIStatusInterrupt				= 0x0008,
    kIOPCIStatusCapabilities            = 0x0010,
    kIOPCIStatusPCI66                   = 0x0020,
    kIOPCIStatusUDF                     = 0x0040,
    kIOPCIStatusFastBack2Back           = 0x0080,
    kIOPCIStatusDevSel0                 = 0x0000,
    kIOPCIStatusDevSel1                 = 0x0200,
    kIOPCIStatusDevSel2                 = 0x0400,
    kIOPCIStatusDevSel3                 = 0x0600,
    kIOPCIStatusTargetAbortCapable      = 0x0800,
    kIOPCIStatusTargetAbortActive       = 0x1000,
    kIOPCIStatusMasterAbortActive       = 0x2000,
    kIOPCIStatusSERRActive              = 0x4000,
    kIOPCIStatusParityErrActive         = 0x8000
};

enum {
    kPCI2PCIPrimaryBus          = 0x18,
    kPCI2PCISecondaryBus        = 0x19,
    kPCI2PCISubordinateBus      = 0x1a,
    kPCI2PCISecondaryLT         = 0x1b,
    kPCI2PCIIORange             = 0x1c,
    kPCI2PCIMemoryRange         = 0x20,
    kPCI2PCIPrefetchMemoryRange = 0x24,
    kPCI2PCIPrefetchUpperBase   = 0x28,
    kPCI2PCIPrefetchUpperLimit  = 0x2c,
    kPCI2PCIUpperIORange        = 0x30,
    kPCI2PCIBridgeControl       = 0x3e
};

// constants which are part of the PCI Bus Power Management Spec.
enum
{
    // capabilities bits in the 16 bit capabilities register
    kPCIPMCPMESupportFromD3Cold = 0x8000,
    kPCIPMCPMESupportFromD3Hot  = 0x4000,
    kPCIPMCPMESupportFromD2             = 0x2000,
    kPCIPMCPMESupportFromD1             = 0x1000,
    kPCIPMCPMESupportFromD0             = 0x0800,
    kPCIPMCD2Support                    = 0x0400,
    kPCIPMCD1Support                    = 0x0200,
 
    kPCIPMCD3Support                    = 0x0001
};

enum
{
    // bits in the power management control/status register
    kPCIPMCSPMEStatus                   = 0x8000,
    kPCIPMCSPMEEnable                   = 0x0100,
    kPCIPMCSPowerStateMask              = 0x0003,
    kPCIPMCSPowerStateD3                = 0x0003,
    kPCIPMCSPowerStateD2                = 0x0002,
    kPCIPMCSPowerStateD1                = 0x0001,
    kPCIPMCSPowerStateD0                = 0x0000,
    
    kPCIPMCSDefaultEnableBits           = (~(IOOptionBits)0)
};

union IOPCIAddressSpace {
    UInt32              bits;
    struct {
#if __BIG_ENDIAN__
        unsigned int    reloc:1;
        unsigned int    prefetch:1;
        unsigned int    t:1;
        unsigned int    resv:3;
        unsigned int    space:2;
        unsigned int    busNum:8;
        unsigned int    deviceNum:5;
        unsigned int    functionNum:3;
        unsigned int    registerNum:8;
#elif __LITTLE_ENDIAN__
        unsigned int    registerNum:8;
        unsigned int    functionNum:3;
        unsigned int    deviceNum:5;
        unsigned int    busNum:8;
        unsigned int    space:2;
        unsigned int    resv:3;
        unsigned int    t:1;
        unsigned int    prefetch:1;
        unsigned int    reloc:1;
#endif
    } s;
    struct {
#if __BIG_ENDIAN__
        unsigned int    resv:4;
        unsigned int    registerNumExtended:4;
        unsigned int    busNum:8;
        unsigned int    deviceNum:5;
        unsigned int    functionNum:3;
        unsigned int    registerNum:8;
#elif __LITTLE_ENDIAN__
        unsigned int    registerNum:8;
        unsigned int    functionNum:3;
        unsigned int    deviceNum:5;
        unsigned int    busNum:8;
        unsigned int    registerNumExtended:4;
        unsigned int    resv:4;
#endif
    } es;
};
typedef union IOPCIAddressSpace IOPCIAddressSpace;

struct IOPCIPhysicalAddress {
    IOPCIAddressSpace   physHi;
#if defined(__i386__) || defined(__x86_64__)
    UInt32              physMid;
    UInt32              physLo;
    UInt32              lengthHi;
    UInt32              lengthLo;
#else
    UInt32              physLo;
    UInt32              physMid;
    UInt32              lengthLo;
    UInt32              lengthHi;
#endif
};

// IOPCIDevice matching property names
#define kIOPCIMatchKey                  "IOPCIMatch"
#define kIOPCIPrimaryMatchKey           "IOPCIPrimaryMatch"
#define kIOPCISecondaryMatchKey         "IOPCISecondaryMatch"
#define kIOPCIClassMatchKey             "IOPCIClassMatch"
#define kIOPCITunnelCompatibleKey       "IOPCITunnelCompatible"
#define kIOPCITunnelledKey 		  		"IOPCITunnelled"
#define kIOPCITunnelL1EnableKey	  		"IOPCITunnelL1Enable"

#define kIOPCIPauseCompatibleKey        "IOPCIPauseCompatible"

// property to control PCI default config space save on sleep
#define kIOPMPCIConfigSpaceVolatileKey  "IOPMPCIConfigSpaceVolatile"
// property to disable express link on sleep
#define kIOPMPCISleepLinkDisableKey     "IOPMPCISleepLinkDisable"
// property to reset secondary bus on sleep
#define kIOPMPCISleepResetKey           "IOPMPCISleepReset"

// pci express capabilities
#define kIOPCIExpressCapabilitiesKey       "IOPCIExpressCapabilities"
// pci express link status
#define kIOPCIExpressLinkStatusKey       "IOPCIExpressLinkStatus"
// pci express link capabilities
#define kIOPCIExpressLinkCapabilitiesKey "IOPCIExpressLinkCapabilities"
// pci express slot status
#define kIOPCIExpressSlotStatusKey       "IOPCIExpressSlotStatus"
// pci express slot capabilities
#define kIOPCIExpressSlotCapabilitiesKey "IOPCIExpressSlotCapabilities"

#ifndef kIOPlatformDeviceASPMEnableKey
#define kIOPlatformDeviceASPMEnableKey  "IOPlatformDeviceASPMEnable"
#endif

#ifndef kIOPCIDeviceASPMSupportedKey
#define kIOPCIDeviceASPMSupportedKey    "pci-aspm-supported"
#endif

#define kIOPCIPMEOptionsKey             "IOPCIPMEOptions"

#define kIOPCITunnelIDKey               "IOPCITunnelID"
#define kIOPCITunnelControllerIDKey     "IOPCITunnelControllerID"

#define kIOPCIBridgeInterruptESKey      "IOPCIBridgeInterruptES"

#define kIOPCIDeviceDeviceTreeEntryKey  "IOPCIDeviceDeviceTreeEntry"

enum {
    kIOPCIDevicePowerStateCount = 4,
    kIOPCIDeviceOffState        = 0,
    kIOPCIDeviceDozeState       = 1,
    kIOPCIDeviceOnState         = 2,
    kIOPCIDevicePausedState     = 3,
};

enum
{
    // bits getInterruptType result
    kIOInterruptTypePCIMessaged = 0x00010000
};

// setLatencyTolerance options
enum
{
    kIOPCILatencySnooped   = 0x00000001,
    kIOPCILatencyUnsnooped = 0x00000002,
};

enum
{
    kIOPCIProbeOptionDone      = 0x80000000,

    kIOPCIProbeOptionEject     = 0x00100000,
    kIOPCIProbeOptionNeedsScan = 0x00200000,
};


// saveDeviceState options
enum
{
	kIOPCIConfigShadowPermanent = 0x80000000,
};

#if defined(KERNEL)

#include <IOKit/IOService.h>
#include <IOKit/IOEventSource.h>

class IOPCIDevice;
class IOPCIBridge;
class IOPCI2PCIBridge;
class IOPCIMessagedInterruptController;
class IOPCIConfigurator;
class IOPCIEventSource;


// IOPCIEvent.event
enum 
{
    kIOPCIEventCorrectableError = 1,
    kIOPCIEventNonFatalError    = 2,
    kIOPCIEventFatalError       = 3,
    kIOPCIEventLinkEnableChange = 4,
};


// PCIe error bits
enum 
{
    kIOPCIUncorrectableErrorBitDataLinkProtocol      = 4,
    kIOPCIUncorrectableErrorBitSurpriseDown          = 5,
    kIOPCIUncorrectableErrorBitPoisonedTLP           = 12,
    kIOPCIUncorrectableErrorBitFlowControlProtocol   = 13,
    kIOPCIUncorrectableErrorBitCompletionTimeout     = 14,
    kIOPCIUncorrectableErrorBitCompleterAbort        = 15,
    kIOPCIUncorrectableErrorBitUnexpectedCompletion  = 16,
    kIOPCIUncorrectableErrorBitReceiverOverflow      = 17,
    kIOPCIUncorrectableErrorBitMalformedTLP          = 18,
    kIOPCIUncorrectableErrorBitECRC                  = 19,
    kIOPCIUncorrectableErrorBitUnsupportedRequest    = 20,

    kIOPCIUncorrectableErrorBitACSViolation          = 21,
    kIOPCIUncorrectableErrorBitInternal              = 22,
    kIOPCIUncorrectableErrorBitMCBlockedTLP          = 23,
    kIOPCIUncorrectableErrorBitAtomicOpEgressBlocked = 24,
    kIOPCIUncorrectableErrorBitTLPPrefixBlocked      = 25
};

enum 
{
    kIOPCICorrectableErrorBitReceiver           = 0,
    kIOPCICorrectableErrorBitBadTLP             = 6,
    kIOPCICorrectableErrorBitBadDLLP            = 7,
    kIOPCICorrectableErrorBitReplayNumRollover  = 8,
    kIOPCICorrectableErrorBitReplayTimerTimeout = 12,
    kIOPCICorrectableErrorBitAdvisoryNonFatal   = 13,
    kIOPCICorrectableErrorBitCorrectedInternal  = 14,
    kIOPCICorrectableErrorBitHeaderLogOverflow  = 15,
};


struct IOPCIEvent
{
    IOPCIDevice * reporter;
    uint32_t      event;
    uint32_t      data[5];
};

class IOPCIEventSource : public IOEventSource
{
    friend class IOPCIBridge;
    friend class IOPCI2PCIBridge;

    OSDeclareDefaultStructors(IOPCIEventSource);
public:
    typedef void (*Action)(OSObject * owner, IOPCIEventSource * es,
                           const IOPCIEvent * event );
#define IOPCIEventAction IOPCIEventSource::Action
 
private:
    queue_chain_t     fQ;
    IOPCI2PCIBridge * fRoot;
    IOPCIDevice *     fDevice;
    uint8_t           fReadIndex;
    uint8_t           fWriteIndex;
    IOPCIEvent *      fEvents;

public: 
    virtual void enable();
    virtual void disable();

protected:
    virtual void free(void);
    virtual bool checkForWork(void);
};


typedef IOReturn (*IOPCIDeviceConfigHandler)(void * ref,
                                                IOMessage message, IOPCIDevice * device, uint32_t state);

/*! @class IOPCIDevice : public IOService
    @abstract An IOService class representing a PCI device.
    @discussion The discovery of a PCI device by the PCI bus family results in an instance of the IOPCIDevice being created and published. It provides services for looking up and mapping memory mapped hardware, and access to the PCI configuration and I/O spaces. 

<br><br>Matching Supported by IOPCIDevice<br><br>

Two types of matching are available, OpenFirmware name matching and PCI register matching. Currently, only one of these two matching schemes can be used in the same property table.

<br><br>OpenFirmware Name Matching<br><br>

IOService performs matching based on the IONameMatch property (see IOService). IOPCIDevices created with OpenFirmware device tree entries will name match based on the standard OpenFirmware name matching properties.

<br><br>PCI Register Matching<br><br>

A PCI device driver can also match on the values of certain config space registers.

In each case, several matching values can be specified, and an optional mask for the value of the config space register may follow the value, preceded by an '&' character.
<br>
<br>
        kIOPCIMatchKey, "IOPCIMatch"
<br>
The kIOPCIMatchKey property matches the vendor and device ID (0x00) register, or the subsystem register (0x2c).
<br>
<br>
        kIOPCIPrimaryMatchKey, "IOPCIPrimaryMatch"
<br>
The kIOPCIPrimaryMatchKey property matches the vendor and device ID (0x00) register.
<br>
<br>
        kIOPCISecondaryMatchKey, "IOPCISecondaryMatch"
<br>
The kIOPCISecondaryMatchKey property matches the subsystem register (0x2c).
<br>
<br>
        kIOPCIClassMatchKey, "IOPCIClassMatch"
<br>
The kIOPCIClassMatchKey property matches the class code register (0x08). The default mask for this register is 0xffffff00.
<br>
<br>
Examples:
<br>
<br>
      &ltkey&gtIOPCIMatch&lt/key&gt             <br>
        &ltstring&gt0x00261011&lt/string&gt
<br>
Matches a device whose vendor ID is 0x1011, and device ID is 0x0026, including subsystem IDs.
<br>
<br>
      &ltkey&gtIOPCIMatch&lt/key&gt             <br>
        &ltstring&gt0x00789004&0x00ffffff 0x78009004&0x0xff00ffff&lt/string&gt
<br>
Matches with any device with a vendor ID of 0x9004, and a device ID of 0xzz78 or 0x78zz, where 'z' is don't care.
<br>
<br>
      &ltkey&gtIOPCIClassMatch&lt/key&gt        <br>
        &ltstring&gt0x02000000&0xffff0000&lt/string&gt
<br>
<br>
Matches a device whose class code is 0x0200zz, an ethernet device.

*/

class IOPCIDevice : public IOService
{
    OSDeclareDefaultStructors(IOPCIDevice)

    friend class IOPCIBridge;
    friend class IOPCI2PCIBridge;
    friend class IOPCIMessagedInterruptController;
    friend class IOPCIConfigurator;

protected:
    IOPCIBridge *       parent;
    IOMemoryMap *       ioMap;
    OSObject *          slotNameProperty;

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    struct IOPCIDeviceExpansionData * reserved;

public:
    IOPCIAddressSpace   space;
    UInt32      *       savedConfig;

public:
    /* IOService/IORegistryEntry methods */

    virtual bool init( OSDictionary *  propTable );
    virtual bool init( IORegistryEntry * from,
                                const IORegistryPlane * inPlane );
    virtual void free();
    virtual bool attach( IOService * provider );
    virtual void detach( IOService * provider );
	virtual void detachAbove(const IORegistryPlane *);

    virtual IOReturn newUserClient( task_t owningTask, void * securityID,
                                    UInt32 type,  OSDictionary * properties,
                                    IOUserClient ** handler );

    virtual IOReturn requestProbe( IOOptionBits options );

    virtual IOReturn powerStateWillChangeTo (IOPMPowerFlags  capabilities, 
                                             unsigned long   stateNumber, 
                                             IOService*      whatDevice);
    virtual IOReturn setPowerState( unsigned long, IOService * );

	virtual unsigned long maxCapabilityForDomainState ( IOPMPowerFlags domainState );
	virtual unsigned long initialPowerStateForDomainState ( IOPMPowerFlags domainState );
	virtual unsigned long powerStateForDomainState ( IOPMPowerFlags domainState );

    virtual bool compareName( OSString * name, OSString ** matched = 0 ) const;
    virtual bool matchPropertyTable( OSDictionary *     table,
                                     SInt32       *     score );
    virtual IOService * matchLocation( IOService * client );
    virtual IOReturn getResources( void );
    virtual IOReturn setProperties(OSObject * properties);
    virtual IOReturn callPlatformFunction(const OSSymbol * functionName,
                                          bool waitForFunction,
                                          void * p1, void * p2,
                                          void * p3, void * p4);
    virtual IOReturn callPlatformFunction(const char * functionName,
                                          bool waitForFunction,
                                          void * p1, void * p2,
                                          void * p3, void * p4);
    virtual IODeviceMemory * getDeviceMemoryWithIndex(unsigned int index);

private:
	bool configAccess(bool write);
	bool initReserved(void);
    IOReturn setPCIPowerState(uint8_t powerState, uint32_t options);
    void     updateWakeReason(uint16_t pmeState);
    IOReturn enableLTR(IOPCIDevice * device, bool enable);

public:

    /* Config space accessors */

    virtual UInt32 configRead32( IOPCIAddressSpace space, UInt8 offset );
    virtual void configWrite32( IOPCIAddressSpace space,
                                        UInt8 offset, UInt32 data );
    virtual UInt16 configRead16( IOPCIAddressSpace space, UInt8 offset );
    virtual void configWrite16( IOPCIAddressSpace space,
                                        UInt8 offset, UInt16 data );
    virtual UInt8 configRead8( IOPCIAddressSpace space, UInt8 offset );
    virtual void configWrite8( IOPCIAddressSpace space,
                                        UInt8 offset, UInt8 data );

#if __IOPCIDEVICE_INTERNAL__

#if APPLE_KEXT_VTABLE_PADDING
    virtual UInt32 configRead32( UInt8 offset );
    virtual UInt16 configRead16( UInt8 offset );
    virtual UInt8  configRead8( UInt8 offset );
    virtual void   configWrite32( UInt8 offset, UInt32 data );
    virtual void   configWrite16( UInt8 offset, UInt16 data );
    virtual void   configWrite8( UInt8 offset, UInt8 data );
#endif /* APPLE_KEXT_VTABLE_PADDING */

#else /* !__IOPCIDEVICE_INTERNAL__ */

/*! @function configRead32
    @abstract Reads a 32-bit value from the PCI device's configuration space.
    @discussion This method reads a 32-bit configuration space register on the device and returns its value.
    @param offset An offset into configuration space, of which bits 0-1 are ignored.
    @result An 32-bit value in host byte order (big endian on PPC). */

    UInt32 configRead32( IOByteCount offset ) { return (extendedConfigRead32(offset)); }

/*! @function configRead16
    @abstract Reads a 16-bit value from the PCI device's configuration space.
    @discussion This method reads a 16-bit configuration space register on the device and returns its value.
    @param offset An offset into configuration space, of which bit 0 is ignored.
    @result An 16-bit value in host byte order (big endian on PPC). */

    UInt16 configRead16( IOByteCount offset ) { return (extendedConfigRead16(offset)); }

/*! @function configRead8
    @abstract Reads a 8-bit value from the PCI device's configuration space.
    @discussion This method reads a 8-bit configuration space register on the device and returns its value.
    @param offset An offset into configuration space.
    @result An 8-bit value. */

    UInt8 configRead8( IOByteCount offset ) { return (extendedConfigRead8(offset)); }

/*! @function configWrite32
    @abstract Writes a 32-bit value to the PCI device's configuration space.
    @discussion This method write a 32-bit value to a configuration space register on the device.
    @param offset An offset into configuration space, of which bits 0-1 are ignored.
    @param data An 32-bit value to be written in host byte order (big endian on PPC). */

    void configWrite32( IOByteCount offset, UInt32 data ) { return (extendedConfigWrite32(offset, data)); }

/*! @function configWrite16
    @abstract Writes a 16-bit value to the PCI device's configuration space.
    @discussion This method write a 16-bit value to a configuration space register on the device.
    @param offset An offset into configuration space, of which bit 0 is ignored.
    @param data An 16-bit value to be written in host byte order (big endian on PPC). */

    void configWrite16( IOByteCount offset, UInt16 data ) { return (extendedConfigWrite16(offset, data)); }

/*! @function configWrite8
    @abstract Writes a 8-bit value to the PCI device's configuration space.
    @discussion This method write a 8-bit value to a configuration space register on the device.
    @param offset An offset into configuration space.
    @param data An 8-bit value to be written. */

    void configWrite8( IOByteCount offset, UInt8 data ) { return (extendedConfigWrite8(offset, data)); }

    OSMetaClassDeclareReservedUnused(IOPCIDevice,  16);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  17);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  18);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  19);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  20);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  21);
public:

#endif /* !__IOPCIDEVICE_INTERNAL__ */

    virtual IOReturn saveDeviceState( IOOptionBits options = 0 );
    virtual IOReturn restoreDeviceState( IOOptionBits options = 0 );

/*! @function setConfigBits
    @abstract Sets masked bits in a configuration space register.
    @discussion This method sets masked bits in a configuration space register on the device by reading and writing the register. The value of the masked bits before the write is returned.
    @param offset An 8-bit offset into configuration space, of which bits 0-1 are ignored.
    @param mask An 32-bit mask indicating which bits in the value parameter are valid.
    @param data An 32-bit value to be written in host byte order (big endian on PPC).
    @result The value of the register masked with the mask before the write. */
    
    virtual UInt32 setConfigBits( UInt8 offset, UInt32 mask, UInt32 value );

/*! @function setMemoryEnable
    @abstract Sets the device's memory space response.
    @discussion This method sets the memory space response bit in the device's command config space register to the passed value, and returns the previous state of the enable.
    @param enable True or false to enable or disable the memory space response.
    @result True if the memory space response was previously enabled, false otherwise. */

    virtual bool setMemoryEnable( bool enable );

/*! @function setIOEnable
    @abstract Sets the device's I/O space response.
    @discussion This method sets the I/O space response bit in the device's command config space register to the passed value, and returns the previous state of the enable. The exclusive option allows only one exclusive device on the bus to be enabled concurrently, this should be only for temporary access.
    @param enable True or false to enable or disable the I/O space response.
    @param exclusive If true, only one setIOEnable with the exclusive flag set will be allowed at a time on the bus, this should be only for temporary access.
    @result True if the I/O space response was previously enabled, false otherwise. */

    virtual bool setIOEnable( bool enable, bool exclusive = false );

/*! @function setBusMasterEnable
    @abstract Sets the device's bus master enable.
    @discussion This method sets the bus master enable bit in the device's command config space register to the passed value, and returns the previous state of the enable.
    @param enable True or false to enable or disable bus mastering.
    @result True if bus mastering was previously enabled, false otherwise. */

    virtual bool setBusMasterEnable( bool enable );

/*! @function findPCICapability
    @abstract Search configuration space for a PCI capability register.
    @discussion This method searches the device's config space for a PCI capability register matching the passed capability ID, if the device supports PCI capabilities. To search for PCI Express extended capabilities or for multiple capablities with the same ID, use the extendedFindPCICapability() method.
    @param capabilityID An 8-bit PCI capability ID.
    @param offset An optional pointer to return the offset into config space where the capability was found.
    @result The 32-bit value of the capability register if one was found, zero otherwise. */

    virtual UInt32 findPCICapability( UInt8 capabilityID, UInt8 * offset = 0 );

/*! @function getBusNumber
    @abstract Accessor to return the PCI device's assigned bus number.
    @discussion This method is an accessor to return the PCI device's assigned bus number.
    @result The 8-bit value of device's PCI bus number. */

    virtual UInt8 getBusNumber( void );

/*! @function getDeviceNumber
    @abstract Accessor to return the PCI device's device number.
    @discussion This method is an accessor to return the PCI device's device number.
    @result The 5-bit value of device's device number. */

    virtual UInt8 getDeviceNumber( void );

/*! @function getFunctionNumber
    @abstract Accessor to return the PCI device's function number.
    @discussion This method is an accessor to return the PCI device's function number.
    @result The 3-bit value of device's function number. */

    virtual UInt8 getFunctionNumber( void );

    /* Device memory accessors */

/*! @function getDeviceMemoryWithRegister
    @abstract Returns an instance of IODeviceMemory representing one of the device's memory mapped ranges.
    @discussion This method will return a pointer to an instance of IODeviceMemory for the physical memory range that was assigned to the configuration space base address register passed in. It is analogous to IOService::getDeviceMemoryWithIndex.
    @param reg The 8-bit configuration space register that is the base address register for the desired range.
    @result A pointer to an instance of IODeviceMemory, or zero no such range was found. The IODeviceMemory is retained by the provider, so is valid while attached, or while any mappings to it exist. It should not be released by the caller. */

    virtual IODeviceMemory * getDeviceMemoryWithRegister( UInt8 reg );

/*! @function mapDeviceMemoryWithRegister
    @abstract Maps a physical range of the device.
    @discussion This method will create a mapping for the IODeviceMemory for the physical memory range that was assigned to the configuration space base address register passed in, with IODeviceMemory::map(options). The mapping is represented by the returned instance of IOMemoryMap, which should not be released until the mapping is no longer required. This method is analogous to IOService::mapDeviceMemoryWithIndex.
    @param reg The 8-bit configuration space register that is the base address register for the desired range.
    @param options Options to be passed to the IOMemoryDescriptor::map() method.
    @result An instance of IOMemoryMap, or zero if the index is beyond the count available. The mapping should be released only when access to it is no longer required. */

    virtual IOMemoryMap * mapDeviceMemoryWithRegister( UInt8 reg,
                                                IOOptionBits options = 0 );

/*! @function ioDeviceMemory
    @abstract Accessor to the I/O space aperture for the bus.
    @discussion This method will return a reference to the IODeviceMemory for the I/O aperture of the bus the device is on.
    @result A pointer to an IODeviceMemory object for the I/O aperture. The IODeviceMemory is retained by the provider, so is valid while attached, or while any mappings to it exist. It should not be released by the caller. */

    virtual IODeviceMemory * ioDeviceMemory( void );

    /* I/O space accessors */

/*! @function ioWrite32
    @abstract Writes a 32-bit value to an I/O space aperture.
    @discussion This method will write a 32-bit value to a 4 byte aligned offset in an I/O space aperture. If a map object is passed in, the value is written relative to it, otherwise to the value is written relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
    @param offset An offset into a bus or device's I/O space aperture.
    @param value The value to be written in host byte order (big endian on PPC).
    @param map If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus' I/O space. */

    virtual void ioWrite32( UInt16 offset, UInt32 value,
                                IOMemoryMap * map = 0 );

/*! @function ioWrite16
    @abstract Writes a 16-bit value to an I/O space aperture.
    @discussion This method will write a 16-bit value to a 2 byte aligned offset in an I/O space aperture. If a map object is passed in, the value is written relative to it, otherwise to the value is written relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
    @param offset An offset into a bus or device's I/O space aperture.
    @param value The value to be written in host byte order (big endian on PPC).
    @param map If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus' I/O space. */

    virtual void ioWrite16( UInt16 offset, UInt16 value,
                                IOMemoryMap * map = 0 );

/*! @function ioWrite8
    @abstract Writes a 8-bit value to an I/O space aperture.
    @discussion This method will write a 8-bit value to an offset in an I/O space aperture. If a map object is passed in, the value is written relative to it, otherwise to the value is written relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
    @param offset An offset into a bus or device's I/O space aperture.
    @param value The value to be written in host byte order (big endian on PPC).
    @param map If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus' I/O space. */

    virtual void ioWrite8( UInt16 offset, UInt8 value,
                                IOMemoryMap * map = 0 );

/*! @function ioRead32
    @abstract Reads a 32-bit value from an I/O space aperture.
    @discussion This method will read a 32-bit value from a 4 byte aligned offset in an I/O space aperture. If a map object is passed in, the value is read relative to it, otherwise to the value is read relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
    @param offset An offset into a bus or device's I/O space aperture.
    @param map If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus' I/O space.
    @result The value read in host byte order (big endian on PPC). */

    virtual UInt32 ioRead32( UInt16 offset, IOMemoryMap * map = 0 );

/*! @function ioRead16
    @abstract Reads a 16-bit value from an I/O space aperture.
    @discussion This method will read a 16-bit value from a 2 byte aligned offset in an I/O space aperture. If a map object is passed in, the value is read relative to it, otherwise to the value is read relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
    @param offset An offset into a bus or device's I/O space aperture.
    @param map If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus' I/O space.
    @result The value read in host byte order (big endian on PPC). */

    virtual UInt16 ioRead16( UInt16 offset, IOMemoryMap * map = 0 );

/*! @function ioRead8
    @abstract Reads a 8-bit value from an I/O space aperture.
    @discussion This method will read a 8-bit value from an offset in an I/O space aperture. If a map object is passed in, the value is read relative to it, otherwise to the value is read relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
    @param offset An offset into a bus or device's I/O space aperture.
    @param map If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus' I/O space.
    @result The value read. */

    virtual UInt8 ioRead8( UInt16 offset, IOMemoryMap * map = 0 );

    OSMetaClassDeclareReservedUsed(IOPCIDevice,  0);
/*! @function hasPCIPowerManagement
    @abstract determine whether or not the device supports PCI Bus Power Management.
    @discussion This method will look at the device's capabilties registers and determine whether or not the device supports the PCI BUS Power Management Specification.
    @param state(optional) Check for support of a specific state (e.g. kPCIPMCPMESupportFromD3Cold). If state is not suuplied or is 0, then check for a property in the registry which tells which state the hardware expects the device to go to during sleep.
    @result true if the specified state is supported */
    virtual bool hasPCIPowerManagement(IOOptionBits state = 0);
    
    OSMetaClassDeclareReservedUsed(IOPCIDevice,  1);
/*! @function enablePCIPowerManagement
    @abstract enable PCI power management for sleep state
    @discussion This method will enable PCI Bus Powermanagement when going to sleep mode.
    @param state(optional) Enables PCI Power Management by placing the function in the given state (e.g. kPCIPMCSPowerStateD3). If state is not specified or is 0xffffffff, then the IOPCIDevice determines the desired state. If state is kPCIPMCSPowerStateD0 (0) then PCI Power Management is disabled.
    @result kIOReturnSuccess if there were no errors */
    virtual IOReturn enablePCIPowerManagement(IOOptionBits state = 0xffffffff);
    
    OSMetaClassDeclareReservedUsed(IOPCIDevice,  2);
/*! @function extendedFindPCICapability
    @abstract Search configuration space for a PCI capability register.
    @discussion This method searches the device's config space for a PCI capability register matching the passed capability ID, if the device supports PCI capabilities.
    @param capabilityID A PCI capability ID. PCI Express devices may support extended capabilities in config space starting at offset 0x100. To search this space, the ID passed should be the negated value of the PCI-SIG assigned ID for the extended capability.
    @param offset An optional in/out parameter to return the offset into config space where the capability was found, and to set the start point of the next search. Initialize the offset to zero before the first call to extendedFindPCICapability() and subsequent calls will find all capabilty blocks that may exist on the device with the same ID.
    @result The 32-bit value of the capability register if one was found, zero otherwise. */

    virtual UInt32 extendedFindPCICapability( UInt32 capabilityID, IOByteCount * offset = 0 );

    // Unused Padding
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  3);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  4);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  5);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  6);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  7);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  8);
    OSMetaClassDeclareReservedUnused(IOPCIDevice,  9);
    OSMetaClassDeclareReservedUnused(IOPCIDevice, 10);
    OSMetaClassDeclareReservedUnused(IOPCIDevice, 11);
    OSMetaClassDeclareReservedUnused(IOPCIDevice, 12);
    OSMetaClassDeclareReservedUnused(IOPCIDevice, 13);
    OSMetaClassDeclareReservedUnused(IOPCIDevice, 14);
    OSMetaClassDeclareReservedUnused(IOPCIDevice, 15);

public:

/*! @function extendedConfigRead32
    @abstract Reads a 32-bit value from the PCI device's configuration space.
    @discussion This method reads a 32-bit configuration space register on the device and returns its value.
    @param offset A byte offset into configuration space, of which bits 0-1 are ignored.
    @result An 32-bit value in host byte order (big endian on PPC). */

    UInt32 extendedConfigRead32( IOByteCount offset );

/*! @function extendedConfigRead16
    @abstract Reads a 16-bit value from the PCI device's configuration space.
    @discussion This method reads a 16-bit configuration space register on the device and returns its value.
    @param offset A byte offset into configuration space, of which bit 0 is ignored.
    @result An 16-bit value in host byte order (big endian on PPC). */

    UInt16 extendedConfigRead16( IOByteCount offset );

/*! @function extendedConfigRead8
    @abstract Reads a 8-bit value from the PCI device's configuration space.
    @discussion This method reads a 8-bit configuration space register on the device and returns its value.
    @param offset A byte offset into configuration space.
    @result An 8-bit value. */

    UInt8 extendedConfigRead8( IOByteCount offset );

/*! @function extendedConfigWrite32
    @abstract Writes a 32-bit value to the PCI device's configuration space.
    @discussion This method writes a 32-bit value to a configuration space register on the device.
    @param offset A byte offset into configuration space, of which bits 0-1 are ignored.
    @param data An 32-bit value to be written in host byte order (big endian on PPC). */

    void extendedConfigWrite32( IOByteCount offset, UInt32 data );

/*! @function extendedConfigWrite16
    @abstract Writes a 16-bit value to the PCI device's configuration space.
    @discussion This method writes a 16-bit value to a configuration space register on the device.
    @param offset A byte offset into configuration space, of which bit 0 is ignored.
    @param data An 16-bit value to be written in host byte order (big endian on PPC). */

    void extendedConfigWrite16( IOByteCount offset, UInt16 data );

/*! @function extendedConfigWrite8
    @abstract Writes a 8-bit value to the PCI device's configuration space.
    @discussion This method writes a 8-bit value to a configuration space register on the device.
    @param offset A byte offset into configuration space.
    @param data An 8-bit value to be written. */

    void extendedConfigWrite8( IOByteCount offset, UInt8 data );

    // pass NULL or currentHandler, currentRef to get current handler installed
    // pass NULL or handler, ref to set handler for device
    // messages: kIOMessageDeviceWillPowerOff, kIOMessageDeviceHasPoweredOff,
    //           kIOMessageDeviceWillPowerOn, kIOMessageDeviceHasPoweredOn
    // state: D3
    IOReturn setConfigHandler(IOPCIDeviceConfigHandler handler, void * ref,
                              IOPCIDeviceConfigHandler * currentHandler, void ** currentRef);

    // 
    IOReturn kernelRequestProbe(uint32_t options);

	// (kIOPCIConfigSpace, VM_PROT_READ/WRITE to disable that access)
	IOReturn protectDevice(uint32_t space, uint32_t prot);

	IOReturn checkLink(uint32_t options = 0);

	IOReturn relocate(uint32_t options = 0);

	IOReturn setLatencyTolerance(IOOptionBits type, uint64_t nanoseconds);

    IOPCIEventSource * createEventSource(OSObject * owner, IOPCIEventSource::Action action, uint32_t options);

    // allow tunnel controller to enter L1, client should be an attached driver calling
    // this method in its IOPCIDevice provider.
	IOReturn setTunnelL1Enable(IOService * client, bool l1Enable);

	IOReturn setASPMState(IOService * client, IOOptionBits state);

    enum { kIOPCIAERErrorDescriptionMaxLength = 256 };

    void copyAERErrorDescriptionForBit(bool correctable, uint32_t bit, char * string, size_t maxLength);
};

#endif /* defined(KERNEL) */

#endif /* ! _IOKIT_IOPCIDEVICE_H */

                                                                                                                                                                                                                                                   platform/                                                                                           0040755 0001750 0001750 00000000000 12612224742 033644  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                AppleMacIO.h                                                                                        0100644 0001750 0001750 00000005015 12567450736 035742  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/platform                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_APPLEMACIO_H
#define _IOKIT_APPLEMACIO_H

#include <IOKit/IOService.h>

#include <IOKit/platform/AppleMacIODevice.h>

class AppleMacIO : public IOService
{
    OSDeclareAbstractStructors(AppleMacIO);

    IOService *		fNub;
    IOMemoryMap *	fMemory;

    struct ExpansionData { };
    ExpansionData *fReserved;
    
protected:
    virtual bool selfTest( void );

public:
    virtual bool start(	IOService * provider ) APPLE_KEXT_OVERRIDE;

    virtual IOService * createNub( IORegistryEntry * from );

    virtual void processNub( IOService * nub );

    virtual void publishBelow( IORegistryEntry * root );

    virtual const char * deleteList( void );
    virtual const char * excludeList( void );

    virtual bool compareNubName( const IOService * nub, OSString * name,
				 OSString ** matched = 0 ) const;

    virtual IOReturn getNubResources( IOService * nub );

    OSMetaClassDeclareReservedUnused(AppleMacIO,  0);
    OSMetaClassDeclareReservedUnused(AppleMacIO,  1);
    OSMetaClassDeclareReservedUnused(AppleMacIO,  2);
    OSMetaClassDeclareReservedUnused(AppleMacIO,  3);
};

#endif /* ! _IOKIT_APPLEMACIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   AppleMacIODevice.h                                                                                  0100644 0001750 0001750 00000004245 12567450736 037066  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/platform                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_APPLEMACIODEVICE_H
#define _IOKIT_APPLEMACIODEVICE_H

#include <IOKit/IOService.h>

class AppleMacIODevice : public IOService
{
  OSDeclareDefaultStructors(AppleMacIODevice);

private:  
  struct ExpansionData { };
  ExpansionData *reserved;

public:
  virtual bool compareName( OSString * name, OSString ** matched = 0 ) const APPLE_KEXT_OVERRIDE;
  virtual IOService *matchLocation(IOService *client) APPLE_KEXT_OVERRIDE;
  virtual IOReturn getResources( void ) APPLE_KEXT_OVERRIDE;
    
  OSMetaClassDeclareReservedUnused(AppleMacIODevice,  0);
  OSMetaClassDeclareReservedUnused(AppleMacIODevice,  1);
  OSMetaClassDeclareReservedUnused(AppleMacIODevice,  2);
  OSMetaClassDeclareReservedUnused(AppleMacIODevice,  3);
};

#endif /* ! _IOKIT_APPLEMACIODEVICE_H */
                                                                                                                                                                                                                                                                                                                                                           AppleNMI.h                                                                                          0100644 0001750 0001750 00000005026 12567450736 035437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/platform                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998-9 Apple Computer, Inc.  All rights reserved.
 *
 *  DRI: Josh de Cesare
 *
 */

#ifndef _IOKIT_APPLENMI_H
#define _IOKIT_APPLENMI_H

#include <IOKit/IOService.h>
#include <IOKit/IOInterrupts.h>

// NMI Interrupt Constants
enum
{
    kExtInt9_NMIIntSource      = 0x800506E0,
    kNMIIntLevelMask           = 0x00004000,
    kNMIIntMask                = 0x00000080
};


class AppleNMI : public IOService
{
  OSDeclareDefaultStructors(AppleNMI);

private:
  bool enable_debugger;
  bool mask_NMI;

  struct ExpansionData { };
  ExpansionData * reserved;	// Reserved for future use

public:
  IOService *rootDomain;
  virtual bool start(IOService *provider) APPLE_KEXT_OVERRIDE;
  virtual IOReturn initNMI(IOInterruptController *parentController, OSData *parentSource);
  virtual IOReturn handleInterrupt(void *refCon, IOService *nub, int source);

  // Power handling methods:
  virtual IOReturn powerStateWillChangeTo(IOPMPowerFlags, unsigned long, IOService*) APPLE_KEXT_OVERRIDE;

  OSMetaClassDeclareReservedUnused(AppleNMI,  0);
  OSMetaClassDeclareReservedUnused(AppleNMI,  1);
  OSMetaClassDeclareReservedUnused(AppleNMI,  2);
  OSMetaClassDeclareReservedUnused(AppleNMI,  3);
};

#endif /* ! _IOKIT_APPLENMI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ApplePlatformExpert.h                                                                               0100644 0001750 0001750 00000005530 12567450736 037770  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/platform                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998-2000 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_APPLEPLATFORM_H
#define _IOKIT_APPLEPLATFORM_H

#include <IOKit/IOPlatformExpert.h>

enum {
  kBootROMTypeOldWorld = 0,
  kBootROMTypeNewWorld
};

enum {
  kChipSetTypePowerSurge = 0,
  kChipSetTypePowerStar,
  kChipSetTypeGossamer,
  kChipSetTypePowerExpress,
  kChipSetTypeCore99,
  kChipSetTypeCore2001
};

enum {
  kMachineTypeUnknown = 0
};

extern const OSSymbol *gGetDefaultBusSpeedsKey;

class ApplePlatformExpert : public IODTPlatformExpert
{
  OSDeclareAbstractStructors(ApplePlatformExpert);
  
private:    
  SInt32 _timeToGMT;

  struct ExpansionData { };
  ExpansionData *reserved;

public:
  virtual bool start( IOService * provider ) APPLE_KEXT_OVERRIDE;
  virtual bool configure( IOService * provider ) APPLE_KEXT_OVERRIDE;
  virtual const char * deleteList( void ) APPLE_KEXT_OVERRIDE;
  virtual const char * excludeList( void ) APPLE_KEXT_OVERRIDE;
  
  virtual void registerNVRAMController( IONVRAMController * nvram ) APPLE_KEXT_OVERRIDE;
  
  virtual long getGMTTimeOfDay(void) APPLE_KEXT_OVERRIDE;
  virtual void setGMTTimeOfDay(long secs) APPLE_KEXT_OVERRIDE;
  
  virtual bool getMachineName(char *name, int maxLength) APPLE_KEXT_OVERRIDE;

  OSMetaClassDeclareReservedUnused(ApplePlatformExpert,  0);
  OSMetaClassDeclareReservedUnused(ApplePlatformExpert,  1);
  OSMetaClassDeclareReservedUnused(ApplePlatformExpert,  2);
  OSMetaClassDeclareReservedUnused(ApplePlatformExpert,  3);
};


#endif /* ! _IOKIT_APPLEPLATFORM_H */
                                                                                                                                                                        power/                                                                                              0040755 0001750 0001750 00000000000 12612224742 033154  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOPwrController.h                                                                                   0100644 0001750 0001750 00000002751 12567450737 036411  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/power                                                          /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * 24 Nov  1998 suurballe  Created.
 */

#include <IOKit/IOService.h>

class IOPwrController: public IOService
{
OSDeclareAbstractStructors(IOPwrController)

public:

};

                       pwr_mgt/                                                                                            0040755 0001750 0001750 00000000000 12612224742 033477  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOPM.h                                                                                              0100644 0001750 0001750 00000112647 12567450737 034442  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOPM_H
#define _IOKIT_IOPM_H

#include <IOKit/IOTypes.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOReturn.h>

/*! @header IOPM.h
    @abstract Defines power management constants