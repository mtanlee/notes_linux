
  {ARM_EXT_V6, 0x0700f050, 0x0ff0f0d0, "smusd%5'x%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07000010, 0x0ff000d0, "smlad%5'x%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x07400010, 0x0ff000d0, "smlald%5'x%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07000050, 0x0ff000d0, "smlsd%5'x%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x07400050, 0x0ff000d0, "smlsld%5'x%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0750f010, 0x0ff0f0d0, "smmul%5'r%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07500010, 0x0ff000d0, "smmla%5'r%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x075000d0, 0x0ff000d0, "smmls%5'r%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0xf84d0500, 0xfe5fffe0, "srs%23?id%24?ba\t%16-19r%21'!, #%0-4d"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00ff0, "ssat%c\t%12-15r, #%16-20W, %0-3r"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06a00050, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, asr #%7-11d"},
  {ARM_EXT_V6, 0x06a00f30, 0x0ff00ff0, "ssat16%c\t%12-15r, #%16-19W, %0-3r"},
  {ARM_EXT_V6, 0x01800f90, 0x0ff00ff0, "strex%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6, 0x00400090, 0x0ff000f0, "umaal%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0780f010, 0x0ff0f0f0, "usad8%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07800010, 0x0ff000f0, "usada8%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00ff0, "usat%c\t%12-15r, #%16-20d, %0-3r"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06e00050, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, asr #%7-11d"},
  {ARM_EXT_V6, 0x06e00f30, 0x0ff00ff0, "usat16%c\t%12-15r, #%16-19d, %0-3r"},

  /* V5J instruction.  */
  {ARM_EXT_V5J, 0x012fff20, 0x0ffffff0, "bxj%c\t%0-3r"},

  /* V5 Instructions.  */
  {ARM_EXT_V5, 0xe1200070, 0xfff000f0, "bkpt\t0x%16-19X%12-15X%8-11X%0-3X"},
  {ARM_EXT_V5, 0xfa000000, 0xfe000000, "blx\t%B"},
  {ARM_EXT_V5, 0x012fff30, 0x0ffffff0, "blx%c\t%0-3r"},
  {ARM_EXT_V5, 0x016f0f10, 0x0fff0ff0, "clz%c\t%12-15r, %0-3r"},

  /* V5E "El Segundo" Instructions.  */    
  {ARM_EXT_V5E, 0x000000d0, 0x0e1000f0, "ldrd%c\t%12-15r, %s"},
  {ARM_EXT_V5E, 0x000000f0, 0x0e1000f0, "strd%c\t%12-15r, %s"},
  {ARM_EXT_V5E, 0xf450f000, 0xfc70f000, "pld\t%a"},
  {ARM_EXT_V5ExP, 0x01000080, 0x0ff000f0, "smlabb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000a0, 0x0ff000f0, "smlatb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000c0, 0x0ff000f0, "smlabt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000e0, 0x0ff000f0, "smlatt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},

  {ARM_EXT_V5ExP, 0x01200080, 0x0ff000f0, "smlawb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x012000c0, 0x0ff000f0, "smlawt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},

  {ARM_EXT_V5ExP, 0x01400080, 0x0ff000f0, "smlalbb%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000a0, 0x0ff000f0, "smlaltb%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000c0, 0x0ff000f0, "smlalbt%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000e0, 0x0ff000f0, "smlaltt%c\t%12-15r, %16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x01600080, 0x0ff0f0f0, "smulbb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000a0, 0x0ff0f0f0, "smultb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000c0, 0x0ff0f0f0, "smulbt%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000e0, 0x0ff0f0f0, "smultt%c\t%16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x012000a0, 0x0ff0f0f0, "smulwb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x012000e0, 0x0ff0f0f0, "smulwt%c\t%16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x01000050, 0x0ff00ff0,  "qadd%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01400050, 0x0ff00ff0, "qdadd%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01200050, 0x0ff00ff0,  "qsub%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01600050, 0x0ff00ff0, "qdsub%c\t%12-15r, %0-3r, %16-19r"},

  /* ARM Instructions.  */
  {ARM_EXT_V1, 0x00000090, 0x0e100090, "str%6's%5?hb%c\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00100090, 0x0e100090, "ldr%6's%5?hb%c\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00000000, 0x0de00000, "and%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00200000, 0x0de00000, "eor%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00400000, 0x0de00000, "sub%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00600000, 0x0de00000, "rsb%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00800000, 0x0de00000, "add%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00a00000, 0x0de00000, "adc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00c00000, 0x0de00000, "sbc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00e00000, 0x0de00000, "rsc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V3, 0x0120f000, 0x0db0f000, "msr%c\t%22?SCPSR%C, %o"},
  {ARM_EXT_V3, 0x010f0000, 0x0fbf0fff, "mrs%c\t%12-15r, %22?SCPSR"},
  {ARM_EXT_V1, 0x01000000, 0x0de00000, "tst%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01200000, 0x0de00000, "teq%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01400000, 0x0de00000, "cmp%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01600000, 0x0de00000, "cmn%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01800000, 0x0de00000, "orr%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x03a00000, 0x0fef0000, "mov%20's%c\t%12-15r, %o"},
  {ARM_EXT_V1, 0x01a00000, 0x0def0ff0, "mov%20's%c\t%12-15r, %0-3r"},
  {ARM_EXT_V1, 0x01a00000, 0x0def0060, "lsl%20's%c\t%12-15r, %q"},
  {ARM_EXT_V1, 0x01a00020, 0x0def0060, "lsr%20's%c\t%12-15r, %q"},
  {ARM_EXT_V1, 0x01a00040, 0x0def0060, "asr%20's%c\t%12-15r, %q"},
  {ARM_EXT_V1, 0x01a00060, 0x0def0ff0, "rrx%20's%c\t%12-15r, %0-3r"},
  {ARM_EXT_V1, 0x01a00060, 0x0def0060, "ror%20's%c\t%12-15r, %q"},
  {ARM_EXT_V1, 0x01c00000, 0x0de00000, "bic%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01e00000, 0x0de00000, "mvn%20's%c\t%12-15r, %o"},
  {ARM_EXT_V1, 0x052d0004, 0x0fff0fff, "push%c\t{%12-15r}\t\t@ (str%c %12-15r, %a)"},
  {ARM_EXT_V1, 0x04000000, 0x0e100000, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000000, 0x0e100ff0, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0c100010, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000010, 0x0e000010, "undefined"},
  {ARM_EXT_V1, 0x049d0004, 0x0fff0fff, "pop%c\t{%12-15r}\t\t@ (ldr%c %12-15r, %a)"},
  {ARM_EXT_V1, 0x04100000, 0x0c100000, "ldr%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x092d0000, 0x0fff0000, "push%c\t%m"},
  {ARM_EXT_V1, 0x08800000, 0x0ff00000, "stm%c\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08000000, 0x0e100000, "stm%23?id%24?ba%c\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08bd0000, 0x0fff0000, "pop%c\t%m"},
  {ARM_EXT_V1, 0x08900000, 0x0f900000, "ldm%c\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08100000, 0x0e100000, "ldm%23?id%24?ba%c\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x0a000000, 0x0e000000, "b%24'l%c\t%b"},
  {ARM_EXT_V1, 0x0f000000, 0x0f000000, "svc%c\t%0-23x"},

  /* The rest.  */
  {ARM_EXT_V1, 0x00000000, 0x00000000, "undefined instruction %0-31x"},
  {0, 0x00000000, 0x00000000, 0}
};

/* print_insn_thumb16 recognizes the following format control codes:

   %S                   print Thumb register (bits 3..5 as high number if bit 6 set)
   %D                   print Thumb register (bits 0..2 as high number if bit 7 set)
   %<bitfield>I         print bitfield as a signed decimal
   				(top bit of range being the sign bit)
   %N                   print Thumb register mask (with LR)
   %O                   print Thumb register mask (with PC)
   %M                   print Thumb register mask
   %b			print CZB's 6-bit unsigned branch destination
   %s			print Thumb right-shift immediate (6..10; 0 == 32).
   %c			print the condition code
   %C			print the condition code, or "s" if not conditional
   %x			print warning if conditional an not at end of IT block"
   %X			print "\t@ unpredictable <IT:code>" if conditional
   %I			print IT instruction suffix and operands
   %<bitfield>r		print bitfield as an ARM register
   %<bitfield>Rc	print bitfield as an ARM register and follow it with
			  char c if the register mentioned in the bitfield is 
			  NOT in the register list in bits 0..7
   %<bitfield>d		print bitfield as a decimal
   %<bitfield>H         print (bitfield * 2) as a decimal
   %<bitfield>W         print (bitfield * 4) as a decimal
   %<bitfield>a         print (bitfield * 4) as a pc-rel offset + decoded symbol
   %<bitfield>B         print Thumb branch destination (signed displacement)
   %<bitfield>c         print bitfield as a condition code
   %<bitnum>'c		print specified char iff bit is one
   %<bitnum>?ab		print a if bit is one else print b.  */

static const struct opcode16 thumb_opcodes[] =
{
  /* Thumb instructions.  */
  /* APPLE LOCAL */
  {ARM_EXT_V4T, 0xdefe, 0xffff, "trap"},

  /* ARM V6K no-argument instructions.  */
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop%c"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield%c"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe%c"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi%c"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev%c"},
  {ARM_EXT_V6K, 0xbf00, 0xff0f, "nop%c\t{%4-7d}"},

  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "cbnz\t%0-2r, %b%X"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "cbz\t%0-2r, %b%X"},
  {ARM_EXT_V6T2, 0xbf00, 0xff00, "it%I%X"},

  /* ARM V6.  */
  {ARM_EXT_V6, 0xb660, 0xfff8, "cpsie\t%2'a%1'i%0'f%X"},
  {ARM_EXT_V6, 0xb670, 0xfff8, "cpsid\t%2'a%1'i%0'f%X"},
  {ARM_EXT_V6, 0x4600, 0xffc0, "mov%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba00, 0xffc0, "rev%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba40, 0xffc0, "rev16%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xbac0, 0xffc0, "revsh%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb650, 0xfff7, "setend\t%3?ble%X"},
  {ARM_EXT_V6, 0xb200, 0xffc0, "sxth%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb240, 0xffc0, "sxtb%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb280, 0xffc0, "uxth%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb2c0, 0xffc0, "uxtb%c\t%0-2r, %3-5r"},

  /* ARM V5 ISA extends Thumb.  */
  {ARM_EXT_V5T, 0xbe00, 0xff00, "bkpt\t%0-7x"}, /* Is always unconditional.  */
  /* This is BLX(2).  BLX(1) is a 32-bit instruction.  */
  {ARM_EXT_V5T, 0x4780, 0xff87, "blx%c\t%3-6r%x"},	/* note: 4 bit register number.  */
  /* ARM V4T ISA (Thumb v1).  */
  {ARM_EXT_V4T, 0x46C0, 0xFFFF, "nop%c\t\t\t(mov r8, r8)"},
  /* Format 4.  */
  {ARM_EXT_V4T, 0x4000, 0xFFC0, "and%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4040, 0xFFC0, "eor%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4080, 0xFFC0, "lsl%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x40C0, 0xFFC0, "lsr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4100, 0xFFC0, "asr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4140, 0xFFC0, "adc%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4180, 0xFFC0, "sbc%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x41C0, 0xFFC0, "ror%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4200, 0xFFC0, "tst%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4240, 0xFFC0, "neg%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4280, 0xFFC0, "cmp%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x42C0, 0xFFC0, "cmn%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4300, 0xFFC0, "orr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4340, 0xFFC0, "mul%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4380, 0xFFC0, "bic%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x43C0, 0xFFC0, "mvn%C\t%0-2r, %3-5r"},
  /* format 13 */
  {ARM_EXT_V4T, 0xB000, 0xFF80, "add%c\tsp, #%0-6W"},
  {ARM_EXT_V4T, 0xB080, 0xFF80, "sub%c\tsp, #%0-6W"},
  /* format 5 */
  {ARM_EXT_V4T, 0x4700, 0xFF80, "bx%c\t%S%x"},
  {ARM_EXT_V4T, 0x4400, 0xFF00, "add%c\t%D, %S"},
  {ARM_EXT_V4T, 0x4500, 0xFF00, "cmp%c\t%D, %S"},
  {ARM_EXT_V4T, 0x4600, 0xFF00, "mov%c\t%D, %S"},
  /* format 14 */
  {ARM_EXT_V4T, 0xB400, 0xFE00, "push%c\t%N"},
  {ARM_EXT_V4T, 0xBC00, 0xFE00, "pop%c\t%O"},
  /* format 2 */
  {ARM_EXT_V4T, 0x1800, 0xFE00, "add%C\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1A00, 0xFE00, "sub%C\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1C00, 0xFE00, "add%C\t%0-2r, %3-5r, #%6-8d"},
  {ARM_EXT_V4T, 0x1E00, 0xFE00, "sub%C\t%0-2r, %3-5r, #%6-8d"},
  /* format 8 */
  {ARM_EXT_V4T, 0x5200, 0xFE00, "strh%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5A00, 0xFE00, "ldrh%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5600, 0xF600, "ldrs%11?hb%c\t%0-2r, [%3-5r, %6-8r]"},
  /* format 7 */
  {ARM_EXT_V4T, 0x5000, 0xFA00, "str%10'b%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5800, 0xFA00, "ldr%10'b%c\t%0-2r, [%3-5r, %6-8r]"},
  /* format 1 */
  {ARM_EXT_V4T, 0x0000, 0xF800, "lsl%C\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x0800, 0xF800, "lsr%C\t%0-2r, %3-5r, %s"},
  {ARM_EXT_V4T, 0x1000, 0xF800, "asr%C\t%0-2r, %3-5r, %s"},
  /* format 3 */
  {ARM_EXT_V4T, 0x2000, 0xF800, "mov%C\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x2800, 0xF800, "cmp%c\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3000, 0xF800, "add%C\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3800, 0xF800, "sub%C\t%8-10r, #%0-7d"},
  /* format 6 */
  {ARM_EXT_V4T, 0x4800, 0xF800, "ldr%c\t%8-10r, [pc, #%0-7W]\t(%0-7a)"},  /* TODO: Disassemble PC relative "LDR rD,=<symbolic>" */
  /* format 9 */
  {ARM_EXT_V4T, 0x6000, 0xF800, "str%c\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x6800, 0xF800, "ldr%c\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x7000, 0xF800, "strb%c\t%0-2r, [%3-5r, #%6-10d]"},
  {ARM_EXT_V4T, 0x7800, 0xF800, "ldrb%c\t%0-2r, [%3-5r, #%6-10d]"},
  /* format 10 */
  {ARM_EXT_V4T, 0x8000, 0xF800, "strh%c\t%0-2r, [%3-5r, #%6-10H]"},
  {ARM_EXT_V4T, 0x8800, 0xF800, "ldrh%c\t%0-2r, [%3-5r, #%6-10H]"},
  /* format 11 */
  {ARM_EXT_V4T, 0x9000, 0xF800, "str%c\t%8-10r, [sp, #%0-7W]"},
  {ARM_EXT_V4T, 0x9800, 0xF800, "ldr%c\t%8-10r, [sp, #%0-7W]"},
  /* format 12 */
  {ARM_EXT_V4T, 0xA000, 0xF800, "add%c\t%8-10r, pc, #%0-7W\t(adr %8-10r, %0-7a)"},
  {ARM_EXT_V4T, 0xA800, 0xF800, "add%c\t%8-10r, sp, #%0-7W"},
  /* format 15 */
  {ARM_EXT_V4T, 0xC000, 0xF800, "stmia%c\t%8-10r!, %M"},
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia%c\t%8-10R!, %M"},
  /* format 17 */
  {ARM_EXT_V4T, 0xDF00, 0xFF00, "svc%c\t%0-7d"},
  /* format 16 */
  {ARM_EXT_V4T, 0xDE00, 0xFE00, "undefined"},
  {ARM_EXT_V4T, 0xD000, 0xF000, "b%8-11c.n\t%0-7B%X"},
  /* format 18 */
  {ARM_EXT_V4T, 0xE000, 0xF800, "b%c.n\t%0-10B%x"},

  /* The E800 .. FFFF range is unconditionally redirected to the
     32-bit table, because even in pre-V6T2 ISAs, BL and BLX(1) pairs
     are processed via that table.  Thus, we can never encounter a
     bare "second half of BL/BLX(1)" instruction here.  */
  {ARM_EXT_V1,  0x0000, 0x0000, "undefined"},
  {0, 0, 0, 0}
};

/* Thumb32 opcodes use the same table structure as the ARM opcodes.
   We adopt the convention that hw1 is the high 16 bits of .value and
   .mask, hw2 the low 16 bits.

   print_insn_thumb32 recognizes the following format control codes:

       %%		%

       %I		print a 12-bit immediate from hw1[10],hw2[14:12,7:0]
       %M		print a modified 12-bit immediate (same location)
       %J		print a 16-bit immediate from hw1[3:0,10],hw2[14:12,7:0]
       %K		print a 16-bit immediate from hw2[3:0],hw1[3:0],hw2[11:4]
       %S		print a possibly-shifted Rm

       %a		print the address of a plain load/store
       %w		print the width and signedness of a core load/store
       %m		print register mask for ldm/stm

       %E		print the lsb and width fields of a bfc/bfi instruction
       %F		print the lsb and width fields of a sbfx/ubfx instruction
       %b		print a conditional branch offset
       %B		print an unconditional branch offset
       %s		print the shift field of an SSAT instruction
       %R		print the rotation field of an SXT instruction
       %U		print barrier type.
       %P		print address for pli instruction.
       %c		print the condition code
       %x		print warning if conditional an not at end of IT block"
       %X		print "\t@ unpredictable <IT:code>" if conditional

       %<bitfield>d	print bitfield in decimal
       %<bitfield>W	print bitfield*4 in decimal
       %<bitfield>r	print bitfield as an ARM register
       %<bitfield>c	print bitfield as a condition code

       %<bitfield>'c	print specified char iff bitfield is all ones
       %<bitfield>`c	print specified char iff bitfield is all zeroes
       %<bitfield>?ab... select from array of values in big endian order

   With one exception at the bottom (done because BL and BLX(1) need
   to come dead last), this table was machine-sorted first in
   decreasing order of number of bits set in the mask, then in
   increasing numeric order of mask, then in increasing numeric order
   of opcode.  This order is not the clearest for a human reader, but
   is guaranteed never to catch a special-case bit pattern with a more
   general mask, which is important, because this instruction encoding
   makes heavy use of special-case bit patterns.  */
static const struct opcode32 thumb32_opcodes[] =
{
  /* V7 instructions.  */
  {ARM_EXT_V7, 0xf910f000, 0xff70f000, "pli%c\t%a"},
  {ARM_EXT_V7, 0xf830f000, 0xff70f000, "pldw%c\t%a"},
  {ARM_EXT_V7, 0xf3af80f0, 0xfffffff0, "dbg%c\t#%0-3d"},
  {ARM_EXT_V7, 0xf3bf8f50, 0xfffffff0, "dmb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f40, 0xfffffff0, "dsb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f60, 0xfffffff0, "isb%c\t%U"},
  {ARM_EXT_DIV, 0xfb90f0f0, 0xfff0f0f0, "sdiv%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_DIV, 0xfbb0f0f0, 0xfff0f0f0, "udiv%c\t%8-11r, %16-19r, %0-3r"},

  /* Instructions defined in the basic V6T2 set.  */
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffffff, "nop%c.w"},
  {ARM_EXT_V6T2, 0xf3af8001, 0xffffffff, "yield%c.w"},
  {ARM_EXT_V6T2, 0xf3af8002, 0xffffffff, "wfe%c.w"},
  {ARM_EXT_V6T2, 0xf3af8003, 0xffffffff, "wfi%c.w"},
  {ARM_EXT_V6T2, 0xf3af8004, 0xffffffff, "sev%c.w"},
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffff00, "nop%c.w\t{%0-7d}"},

  {ARM_EXT_V6T2, 0xf3bf8f2f, 0xffffffff, "clrex%c"},
  {ARM_EXT_V6T2, 0xf3af8400, 0xffffff1f, "cpsie.w\t%7'a%6'i%5'f%X"},
  {ARM_EXT_V6T2, 0xf3af8600, 0xffffff1f, "cpsid.w\t%7'a%6'i%5'f%X"},
  {ARM_EXT_V6T2, 0xf3c08f00, 0xfff0ffff, "bxj%c\t%16-19r%x"},
  {ARM_EXT_V6T2, 0xe810c000, 0xffd0ffff, "rfedb%c\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xe990c000, 0xffd0ffff, "rfeia%c\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xf3ef8000, 0xffeff000, "mrs%c\t%8-11r, %D"},
  {ARM_EXT_V6T2, 0xf3af8100, 0xffffffe0, "cps\t#%0-4d%X"},
  {ARM_EXT_V6T2, 0xe8d0f000, 0xfff0fff0, "tbb%c\t[%16-19r, %0-3r]%x"},
  {ARM_EXT_V6T2, 0xe8d0f010, 0xfff0fff0, "tbh%c\t[%16-19r, %0-3r, lsl #1]%x"},
  {ARM_EXT_V6T2, 0xf3af8500, 0xffffff00, "cpsie\t%7'a%6'i%5'f, #%0-4d%X"},
  {ARM_EXT_V6T2, 0xf3af8700, 0xffffff00, "cpsid\t%7'a%6'i%5'f, #%0-4d%X"},
  {ARM_EXT_V6T2, 0xf3de8f00, 0xffffff00, "subs%c\tpc, lr, #%0-7d"},
  {ARM_EXT_V6T2, 0xf3808000, 0xffe0f000, "msr%c\t%C, %16-19r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00fff, "ldrex%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d00f4f, 0xfff00fef, "ldrex%4?hb%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe800c000, 0xffd0ffe0, "srsdb%c\t%16-19r%21'!, #%0-4d"},
  {ARM_EXT_V6T2, 0xe980c000, 0xffd0ffe0, "srsia%c\t%16-19r%21'!, #%0-4d"},
  {ARM_EXT_V6T2, 0xfa0ff080, 0xfffff0c0, "sxth%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa1ff080, 0xfffff0c0, "uxth%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa2ff080, 0xfffff0c0, "sxtb16%c\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa3ff080, 0xfffff0c0, "uxtb16%c\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa4ff080, 0xfffff0c0, "sxtb%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa5ff080, 0xfffff0c0, "uxtb%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff000ff, "strex%c\t%8-11r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d0007f, 0xfff000ff, "ldrexd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfa80f000, 0xfff0f0f0, "sadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f010, 0xfff0f0f0, "qadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f020, 0xfff0f0f0, "shadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f040, 0xfff0f0f0, "uadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f050, 0xfff0f0f0, "uqadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f060, 0xfff0f0f0, "uhadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f000, 0xfff0f0f0, "sadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f010, 0xfff0f0f0, "qadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f020, 0xfff0f0f0, "shadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f040, 0xfff0f0f0, "uadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f050, 0xfff0f0f0, "uqadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f060, 0xfff0f0f0, "uhadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f080, 0xfff0f0f0, "rev%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f090, 0xfff0f0f0, "rev16%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0a0, 0xfff0f0f0, "rbit%c\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0b0, 0xfff0f0f0, "revsh%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfaa0f000, 0xfff0f0f0, "saddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f010, 0xfff0f0f0, "qaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f020, 0xfff0f0f0, "shaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f040, 0xfff0f0f0, "uaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f050, 0xfff0f0f0, "uqaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f060, 0xfff0f0f0, "uhaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f080, 0xfff0f0f0, "sel%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfab0f080, 0xfff0f0f0, "clz%c\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfac0f000, 0xfff0f0f0, "ssub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f010, 0xfff0f0f0, "qsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f020, 0xfff0f0f0, "shsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f040, 0xfff0f0f0, "usub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f050, 0xfff0f0f0, "uqsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f060, 0xfff0f0f0, "uhsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f000, 0xfff0f0f0, "ssub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f010, 0xfff0f0f0, "qsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f020, 0xfff0f0f0, "shsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f040, 0xfff0f0f0, "usub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f050, 0xfff0f0f0, "uqsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f060, 0xfff0f0f0, "uhsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f000, 0xfff0f0f0, "ssubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f010, 0xfff0f0f0, "qsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f020, 0xfff0f0f0, "shsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f040, 0xfff0f0f0, "usubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f050, 0xfff0f0f0, "uqsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f060, 0xfff0f0f0, "uhsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb00f000, 0xfff0f0f0, "mul%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb70f000, 0xfff0f0f0, "usad8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f000, 0xffe0f0f0, "lsl%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa20f000, 0xffe0f0f0, "lsr%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa40f000, 0xffe0f0f0, "asr%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa60f000, 0xffe0f0f0, "ror%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8c00f40, 0xfff00fe0, "strex%4?hb%c\t%0-3r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xf3200000, 0xfff0f0e0, "ssat16%c\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xf3a00000, 0xfff0f0e0, "usat16%c\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xfb20f000, 0xfff0f0e0, "smuad%4'x%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb30f000, 0xfff0f0e0, "smulw%4?tb%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb40f000, 0xfff0f0e0, "smusd%4'x%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb50f000, 0xfff0f0e0, "smmul%4'r%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f080, 0xfff0f0c0, "sxtah%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa10f080, 0xfff0f0c0, "uxtah%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa20f080, 0xfff0f0c0, "sxtab16%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa30f080, 0xfff0f0c0, "uxtab16%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa40f080, 0xfff0f0c0, "sxtab%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa50f080, 0xfff0f0c0, "uxtab%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfb10f000, 0xfff0f0c0, "smul%5?tb%4?tb%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf36f0000, 0xffff8020, "bfc%c\t%8-11r, %E"},
  {ARM_EXT_V6T2, 0xea100f00, 0xfff08f00, "tst%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xea900f00, 0xfff08f00, "teq%c\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb100f00, 0xfff08f00, "cmn%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xebb00f00, 0xfff08f00, "cmp%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xf0100f00, 0xfbf08f00, "tst%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0900f00, 0xfbf08f00, "teq%c\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1100f00, 0xfbf08f00, "cmn%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1b00f00, 0xfbf08f00, "cmp%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xea4f0030, 0xffef80f0, "rrx%20's\t%8-11r, %0-3r"},
  {ARM_EXT_V6T2, 0xea4f0000, 0xffef8000, "mov%20's%c.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xea6f0000, 0xffef8000, "mvn%20's%c.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xe8c00070, 0xfff000f0, "strexd%c\t%0-3r, %12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfb000000, 0xfff000f0, "mla%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb000010, 0xfff000f0, "mls%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb700000, 0xfff000f0, "usada8%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb800000, 0xfff000f0, "smull%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfba00000, 0xfff000f0, "umull%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbc00000, 0xfff000f0, "smlal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00000, 0xfff000f0, "umlal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00060, 0xfff000f0, "umaal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00f00, "ldrex%c\t%12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf7f08000, 0xfff0f000, "smc%c\t%K"},
  {ARM_EXT_V6T2, 0xf04f0000, 0xfbef8000, "mov%20's%c.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf06f0000, 0xfbef8000, "mvn%20's%c.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf810f000, 0xff70f000, "pld%c\t%a"},
  {ARM_EXT_V6T2, 0xfb200000, 0xfff000e0, "smlad%4'x%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb300000, 0xfff000e0, "smlaw%4?tb%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb400000, 0xfff000e0, "smlsd%4'x%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb500000, 0xfff000e0, "smmla%4'r%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb600000, 0xfff000e0, "smmls%4'r%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc000c0, 0xfff000e0, "smlald%4'x%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbd000c0, 0xfff000e0, "smlsld%4'x%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xeac00000, 0xfff08030, "pkhbt%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeac00020, 0xfff08030, "pkhtb%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xf3400000, 0xfff08020, "sbfx%c\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf3c00000, 0xfff08020, "ubfx%c\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf8000e00, 0xff900f00, "str%wt%c\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xfb100000, 0xfff000c0, "smla%5?tb%4?tb%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc00080, 0xfff000c0, "smlal%5?tb%4?tb%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf3600000, 0xfff08020, "bfi%c\t%8-11r, %16-19r, %E"},
  {ARM_EXT_V6T2, 0xf8100e00, 0xfe900f00, "ldr%wt%c\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf3000000, 0xffd08020, "ssat%c\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf3800000, 0xffd08020, "usat%c\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf2000000, 0xfbf08000, "addw%c\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2400000, 0xfbf08000, "movw%c\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xf2a00000, 0xfbf08000, "subw%c\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2c00000, 0xfbf08000, "movt%c\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xea000000, 0xffe08000, "and%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea200000, 0xffe08000, "bic%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea400000, 0xffe08000, "orr%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea600000, 0xffe08000, "orn%20's%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea800000, 0xffe08000, "eor%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb000000, 0xffe08000, "add%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb400000, 0xffe08000, "adc%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb600000, 0xffe08000, "sbc%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeba00000, 0xffe08000, "sub%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xebc00000, 0xffe08000, "rsb%20's%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff00000, "strex%c\t%8-11r, %12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf0000000, 0xfbe08000, "and%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0200000, 0xfbe08000, "bic%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0400000, 0xfbe08000, "orr%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0600000, 0xfbe08000, "orn%20's%c\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0800000, 0xfbe08000, "eor%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1000000, 0xfbe08000, "add%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1400000, 0xfbe08000, "adc%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1600000, 0xfbe08000, "sbc%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1a00000, 0xfbe08000, "sub%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1c00000, 0xfbe08000, "rsb%20's%c\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xe8800000, 0xffd00000, "stmia%c.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe8900000, 0xffd00000, "ldmia%c.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9000000, 0xffd00000, "stmdb%c\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9100000, 0xffd00000, "ldmdb%c\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9c00000, 0xffd000ff, "strd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9d00000, 0xffd000ff, "ldrd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]%21'!"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]%21'!"},
  {ARM_EXT_V6T2, 0xe8600000, 0xff700000, "strd%c\t%12-15r, %8-11r, [%16-19r], #%23`-%0-7W"},
  {ARM_EXT_V6T2, 0xe8700000, 0xff700000, "ldrd%c\t%12-15r, %8-11r, [%16-19r], #%23`-%0-7W"},
  {ARM_EXT_V6T2, 0xf8000000, 0xff100000, "str%w%c.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf8100000, 0xfe100000, "ldr%w%c.w\t%12-15r, %a"},

  /* Filter out Bcc with cond=E or F, which are used for other instructions.  */
  {ARM_EXT_V6T2, 0xf3c08000, 0xfbc0d000, "undefined (bcc, cond=0xF)"},
  {ARM_EXT_V6T2, 0xf3808000, 0xfbc0d000, "undefined (bcc, cond=0xE)"},
  {ARM_EXT_V6T2, 0xf0008000, 0xf800d000, "b%22-25c.w\t%b%X"},
  {ARM_EXT_V6T2, 0xf0009000, 0xf800d000, "b%c.w\t%B%x"},

  /* These have been 32-bit since the invention of Thumb.  */
  {ARM_EXT_V4T,  0xf000c000, 0xf800d000, "blx%c\t%B%x"},
  {ARM_EXT_V4T,  0xf000d000, 0xf800d000, "bl%c\t%B%x"},

  /* Fallback.  */
  {ARM_EXT_V1,   0x00000000, 0x00000000, "undefined"},
  {0, 0, 0, 0}
};

static const char *const arm_conditional[] =
{"eq", "ne", "cs", "cc", "mi", "pl", "vs", "vc",
 "hi", "ls", "ge", "lt", "gt", "le", "al", "<und>", ""};

static const char *const arm_fp_const[] =
{"0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0"};

static const char *const arm_shift[] =
{"lsl", "lsr", "asr", "ror"};

typedef struct
{
  const char *name;
  const char *description;
  const char *reg_names[16];
}
arm_regname;

static const arm_regname regnames[] =
{
  { "raw" , "Select raw register names",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},
  { "gcc",  "Select register names used by GCC",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "std",  "Select register names used in ARM's ISA documentation",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},
  { "apcs", "Select register names used in the APCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "atpcs", "Select register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},
  { "special-atpcs", "Select special register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
};

static const char *const iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static const char *const iwmmxt_wwssnames[] =
{"b", "bus", "bc", "bss",
 "h", "hus", "hc", "hss",
 "w", "wus", "wc", "wss",
 "d", "dus", "dc", "dss"
};

static const char *const iwmmxt_regnames[] =
{ "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
  "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"
};

static const char *const iwmmxt_cregnames[] =
{ "wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved",
  "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"
};

/* Default to GCC register name set.  */
static unsigned int regname_selected = 1;

#define NUM_ARM_REGNAMES  NUM_ELEM (regnames)
#define arm_regnames      regnames[regname_selected].reg_names

static bfd_boolean force_thumb = FALSE;

/* Current IT instruction state.  This contains the same state as the IT
   bits in the CPSR.  */
static unsigned int ifthen_state;
/* IT state for the next instruction.  */
static unsigned int ifthen_next_state;
/* The address of the insn for which the IT state is valid.  */
static bfd_vma ifthen_address;
#define IFTHEN_COND ((ifthen_state >> 4) & 0xf)

/* Cached mapping symbol state.  */
enum map_type {
  MAP_ARM,
  MAP_THUMB,
  MAP_DATA
};

enum map_type last_type;
int last_mapping_sym = -1;
bfd_vma last_mapping_addr = 0;

/* Decode a bitfield of the form matching regexp (N(-N)?,)*N(-N)?.
   Returns pointer to following character of the format string and
   fills in *VALUEP and *WIDTHP with the extracted value and number of
   bits extracted.  WIDTHP can be NULL. */

static const char *
arm_decode_bitfield (const char *ptr, uint32_t insn,
		     uint32_t *valuep, int *widthp)
{
  uint32_t value = 0;
  int width = 0;
  
  do 
    {
      int start, end;
      int bits;

      for (start = 0; *ptr >= '0' && *ptr <= '9'; ptr++)
	start = start * 10 + *ptr - '0';
      if (*ptr == '-')
	for (end = 0, ptr++; *ptr >= '0' && *ptr <= '9'; ptr++)
	  end = end * 10 + *ptr - '0';
      else
	end = start;
      bits = end - start;
      if (bits < 0)
	abort ();
      value |= ((insn >> start) & ((2ul << bits) - 1)) << width;
      width += bits + 1;
    }
  while (*ptr++ == ',');
  *valuep = value;
  if (widthp)
    *widthp = width;
  return ptr - 1;
}

static void
arm_decode_shift (int32_t given, fprintf_ftype func, void *stream,
		  int print_shift)
{
  func (stream, "%s", arm_regnames[given & 0xf]);

  if ((given & 0xff0) != 0)
    {
      if ((given & 0x10) == 0)
	{
	  int amount = (given & 0xf80) >> 7;
	  int shift = (given & 0x60) >> 5;

	  if (amount == 0)
	    {
	      if (shift == 3)
		{
		  func (stream, ", rrx");
		  return;
		}

	      amount = 32;
	    }

	  if (print_shift)
	    func (stream, ", %s #%d", arm_shift[shift], amount);
	  else
	    func (stream, ", #%d", amount);
	}
      else if (print_shift)
	func (stream, ", %s %s", arm_shift[(given & 0x60) >> 5],
	      arm_regnames[(given & 0xf00) >> 8]);
      else
	func (stream, ", %s", arm_regnames[(given & 0xf00) >> 8]);
    }
}

/* Print one coprocessor instruction on INFO->STREAM.
   Return TRUE if the instuction matched, FALSE if this is not a
   recognised coprocessor instruction.  */

static bfd_boolean
print_insn_coprocessor (bfd_vma pc, struct disassemble_info *info, int32_t given,
			bfd_boolean thumb)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  uint32_t mask;
  uint32_t value;
  int cond;

  for (insn = coprocessor_opcodes; insn->assembler; insn++)
    {
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt
	  && info->mach != bfd_mach_arm_iWMMXt2)
	insn = insn + IWMMXT_INSN_COUNT;

      mask = insn->mask;
      value = insn->value;
      if (thumb)
	{
	  /* The high 4 bits are 0xe for Arm conditional instructions, and
	     0xe for arm unconditional instructions.  The rest of the
	     encoding is the same.  */
	  mask |= 0xf0000000;
	  value |= 0xe0000000;
	  if (ifthen_state)
	    cond = IFTHEN_COND;
	  else
	    cond = 16;
	}
      else
	{
	  /* Only match unconditional instuctions against unconditional
	     patterns.  */
	  if ((given & 0xf0000000) == 0xf0000000)
	    {
	      mask |= 0xf0000000;
	      cond = 16;
	    }
	  else
	    {
	      cond = (given >> 28) & 0xf;
	      if (cond == 0xe)
		cond = 16;
	    }
	}
      if ((given & mask) == value)
	{
	  const char *c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'A':
		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

		      if ((given & (1 << 24)) != 0)
			{
			  int offset = given & 0xff;

			  if (offset)
			    func (stream, ", #%s%d]%s",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4,
				  ((given & 0x00200000) != 0 ? "!" : ""));
			  else
			    func (stream, "]");
			}
		      else
			{
			  int offset = given & 0xff;

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
			  else
			    func (stream, ", {%d}", offset);
			}
		      break;

		    case 'B':
		      {
			int regno = ((given >> 12) & 0xf) | ((given >> (22 - 4)) & 0x10);
			int offset = (given >> 1) & 0x3f;
			
			if (offset == 1)
			  func (stream, "{d%d}", regno);
			else if (regno + offset > 32)
			  func (stream, "{d%d-<overflow reg d%d>}", regno, regno + offset - 1);
			else
			  func (stream, "{d%d-d%d}", regno, regno + offset - 1);
		      }
		      break;
		      
		    case 'C':
		      {
			int rn = (given >> 16) & 0xf;
			int offset = (given & 0xff) * 4;
			int add = (given >> 23) & 1;
			
			func (stream, "[%s", arm_regnames[rn]);
			
			if (offset)
			  {
			    if (!add)
			      offset = -offset;
			    func (stream, ", #%d", offset);
			  }
			func (stream, "]");
			if (rn == 15)
			  {
			    func (stream, "\t@ ");
                            /* FIXME: Unsure if info->bytes_per_chunk is the
                               right thing to use here.  */
			    info->print_address_func (pc, offset + pc
                              + info->bytes_per_chunk * 2, info);
			  }
		      }
		      break;

		    case 'c':
		      func (stream, "%s", arm_conditional[cond]);
		      break;

		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
		      }

		      break;

		    case 'F':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "4");
			  break;
			case 0x8000:
			  func (stream, "1");
			  break;
			case 0x00400000:
			  func (stream, "2");
			  break;
			default:
			  func (stream, "3");
			}
		      break;

		    case 'P':
		      switch (given & 0x00080080)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x80:
			  func (stream, "d");
			  break;
			case 0x00080000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, _("<illegal precision>"));
			  break;
			}
		      break;
		    case 'Q':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x8000:
			  func (stream, "d");
			  break;
			case 0x00400000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, "p");
			  break;
			}
		      break;
		    case 'R':
		      switch (given & 0x60)
			{
			case 0:
			  break;
			case 0x20:
			  func (stream, "p");
			  break;
			case 0x40:
			  func (stream, "m");
			  break;
			default:
			  func (stream, "z");
			  break;
			}
		      break;

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int width;
			uint32_t value;

			c = arm_decode_bitfield (c, given, &value, &width);

			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'D':
			    func (stream, "d%ld", value);
			    break;
			  case 'Q':
			    if (value & 1)
			      func (stream, "<illegal reg q%ld.5>", value >> 1);
			    else
			      func (stream, "q%ld", value >> 1);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
                          case 'k':
                            {
                              int from = (given & (1 << 7)) ? 32 : 16;
                              func (stream, "%ld", from - value);
                            }
                            break;
                            
			  case 'f':
			    if (value > 7)
			      func (stream, "#%s", arm_fp_const[value & 7]);
			    else
			      func (stream, "f%ld", value);
			    break;

			  case 'w':
			    if (width == 2)
			      func (stream, "%s", iwmmxt_wwnames[value]);
			    else
			      func (stream, "%s", iwmmxt_wwssnames[value]);
			    break;

			  case 'g':
			    func (stream, "%s", iwmmxt_regnames[value]);
			    break;
			  case 'G':
			    func (stream, "%s", iwmmxt_cregnames[value]);
			    break;

			  case 'x':
			    func (stream, "0x%lx", value);
			    break;

			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;

		      case 'y':
		      case 'z':
			{
			  int single = *c++ == 'y';
			  int regno;
			  
			  switch (*c)
			    {
			    case '4': /* Sm pair */
			      func (stream, "{");
			      /* Fall through.  */
			    case '0': /* Sm, Dm */
			      regno = given & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 5) & 1;
				}
                              else
                                regno += ((given >> 5) & 1) << 4;
			      break;

			    case '1': /* Sd, Dd */
			      regno = (given >> 12) & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 22) & 1;
				}
                              else
                                regno += ((given >> 22) & 1) << 4;
			      break;

			    case '2': /* Sn, Dn */
			      regno = (given >> 16) & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 7) & 1;
				}
                              else
                                regno += ((given >> 7) & 1) << 4;
			      break;
			      
			    case '3': /* List */
			      func (stream, "{");
			      regno = (given >> 12) & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 22) & 1;
				}
                              else
                                regno += ((given >> 22) & 1) << 4;
			      break;
			      
			    default:
			      abort ();
			    }

			  func (stream, "%c%d", single ? 's' : 'd', regno);

			  if (*c == '3')
			    {
			      int count = given & 0xff;
			      
			      if (single == 0)
				count >>= 1;
			      
			      if (--count)
				{
				  func (stream, "-%c%d",
					single ? 's' : 'd',
					regno + count);
				}
			      
			      func (stream, "}");
			    }
			  else if (*c == '4')
			    func (stream, ", %c%d}", single ? 's' : 'd',
				  regno + 1);
			}
			break;
			    
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", #%s%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

		      case 'r':
			{
			  int imm4 = (given >> 4) & 0xf;
			  int puw_bits = ((given >> 22) & 6) | ((given >> 21) & 1);
			  int ubit = (given >> 23) & 1;
			  const char *rm = arm_regnames [given & 0xf];
			  const char *rn = arm_regnames [(given >> 16) & 0xf];

			  switch (puw_bits)
			    {
			    case 1:
			      /* fall through */
			    case 3:
			      func (stream, "[%s], %c%s", rn, ubit ? '+' : '-', rm);
			      if (imm4)
				func (stream, ", lsl #%d", imm4);
			      break;

			    case 4:
			      /* fall through */
			    case 5:
			      /* fall through */
			    case 6:
			      /* fall through */
			    case 7:
			      func (stream, "[%s, %c%s", rn, ubit ? '+' : '-', rm);
			      if (imm4 > 0)
				func (stream, ", lsl #%d", imm4);
			      func (stream, "]");
			      if (puw_bits == 5 || puw_bits == 7)
				func (stream, "!");
			      break;

			    default:
			      func (stream, "INVALID");
			    }
			}
			break;

		      case 'i':
			{
			  int32_t imm5;
			  imm5 = ((given & 0x100) >> 4) | (given & 0xf);
			  func (stream, "%ld", (imm5 == 0) ? 32 : imm5);
			}
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }
	  return TRUE;
	}
    }
  return FALSE;
}

static void
print_arm_address (bfd_vma pc, struct disassemble_info *info, int32_t given)
{
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (((given & 0x000f0000) == 0x000f0000)
      && ((given & 0x02000000) == 0))
    {
      int offset = given & 0xfff;

      func (stream, "[pc");

      if (given & 0x01000000)
	{
	  if ((given & 0x00800000) == 0)
	    offset = - offset;

	  /* Pre-indexed.  */
	  func (stream, ", #%d]", offset);

	  offset += pc + 8;

	  /* Cope with the possibility of write-back
	     being used.  Probably a very dangerous thing
	     for the programmer to do, but who are we to
	     argue ?  */
	  if (given & 0x00200000)
	    func (stream, "!");
	}
      else
	{
	  /* Post indexed.  */
	  func (stream, "], #%d", offset);

	  /* ie ignore the offset.  */
	  offset = pc + 8;
	}

      func (stream, "\t@ ");
      info->print_address_func (pc, offset, info);
    }
  else
    {
      func (stream, "[%s",
	    arm_regnames[(given >> 16) & 0xf]);
      if ((given & 0x01000000) != 0)
	{
	  if ((given & 0x02000000) == 0)
	    {
	      int offset = given & 0xfff;
	      if (offset)
		func (stream, ", #%s%d",
		      (((given & 0x00800000) == 0)
		       ? "-" : ""), offset);
	    }
	  else
	    {
	      func (stream, ", %s",
		    (((given & 0x00800000) == 0)
		     ? "-" : ""));
	      arm_decode_shift (given, func, stream, 1);
	    }

	  func (stream, "]%s",
		((given & 0x00200000) != 0) ? "!" : "");
	}
      else
	{
	  if ((given & 0x02000000) == 0)
	    {
	      int offset = given & 0xfff;
	      if (offset)
		func (stream, "], #%s%d",
		      (((given & 0x00800000) == 0)
		       ? "-" : ""), offset);
	      else
		func (stream, "]");
	    }
	  else
	    {
	      func (stream, "], %s",
		    (((given & 0x00800000) == 0)
		     ? "-" : ""));
	      arm_decode_shift (given, func, stream, 1);
	    }
	}
    }
}

/* Print one neon instruction on INFO->STREAM.
   Return TRUE if the instuction matched, FALSE if this is not a
   recognised neon instruction.  */

static bfd_boolean
print_insn_neon (struct disassemble_info *info, int32_t given, bfd_boolean thumb)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (thumb)
    {
      if ((given & 0xef000000) == 0xef000000)
	{
	  /* move bit 28 to bit 24 to translate Thumb2 to ARM encoding.  */
	  uint32_t bit28 = given & (1 << 28);

	  given &= 0x00ffffff;
	  if (bit28)
            given |= 0xf3000000;
          else
	    given |= 0xf2000000;
	}
      else if ((given & 0xff000000) == 0xf9000000)
	given ^= 0xf9000000 ^ 0xf4000000;
      else
	return FALSE;
    }
  
  for (insn = neon_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) == insn->value)
	{
	  const char *c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'c':
		      if (thumb && ifthen_state)
			func (stream, "%s", arm_conditional[IFTHEN_COND]);
		      break;

		    case 'A':
		      {
			static const unsigned char enc[16] = 
			{
			  0x4, 0x14, /* st4 0,1 */
			  0x4, /* st1 2 */
			  0x4, /* st2 3 */
			  0x3, /* st3 4 */
			  0x13, /* st3 5 */
			  0x3, /* st1 6 */
			  0x1, /* st1 7 */
			  0x2, /* st2 8 */
			  0x12, /* st2 9 */
			  0x2, /* st1 10 */
			  0, 0, 0, 0, 0
			};
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int align = ((given >> 4) & 0x3);
			int type = ((given >> 8) & 0xf);
			int n = enc[type] & 0xf;
			int stride = (enc[type] >> 4) + 1;
			int ix;
			
			func (stream, "{");
			if (stride > 1)
			  for (ix = 0; ix != n; ix++)
			    func (stream, "%sd%d", ix ? "," : "", rd + ix * stride);
			else if (n == 1)
			  func (stream, "d%d", rd);
			else
			  func (stream, "d%d-d%d", rd, rd + n - 1);
			func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  func (stream, ", :%d", 32 << align);
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'B':
		      {
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int idx_align = ((given >> 4) & 0xf);
                        int align = 0;
			int size = ((given >> 10) & 0x3);
			int idx = idx_align >> (size + 1);
                        int length = ((given >> 8) & 3) + 1;
                        int stride = 1;
                        int i;

                        if (length > 1 && size > 0)
                          stride = (idx_align & (1 << size)) ? 2 : 1;
			
                        switch (length)
                          {
                          case 1:
                            {
                              int amask = (1 << size) - 1;
                              if ((idx_align & (1 << size)) != 0)
                                return FALSE;
                              if (size > 0)
                                {
                                  if ((idx_align & amask) == amask)
                                    align = 8 << size;
                                  else if ((idx_align & amask) != 0)
                                    return FALSE;
                                }
                              }
                            break;
                          
                          case 2:
                            if (size == 2 && (idx_align & 2) != 0)
                              return FALSE;
                            align = (idx_align & 1) ? 16 << size : 0;
                            break;
                          
                          case 3:
                            if ((size == 2 && (idx_align & 3) != 0)
                                || (idx_align & 1) != 0)
                              return FALSE;
                            break;
                          
                          case 4:
                            if (size == 2)
                              {
                                if ((idx_align & 3) == 3)
                                  return FALSE;
                                align = (idx_align & 3) * 64;
                              }
                            else
                              align = (idx_align & 1) ? 32 << size : 0;
                            break;
                          
                          default:
                            abort ();
                          }
                                
			func (stream, "{");
                        for (i = 0; i < length; i++)
                          func (stream, "%sd%d[%d]", (i == 0) ? "" : ",",
                            rd + i * stride, idx);
                        func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  func (stream, ", :%d", align);
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'C':
		      {
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int align = ((given >> 4) & 0x1);
			int size = ((given >> 6) & 0x3);
			int type = ((given >> 8) & 0x3);
			int n = type + 1;
			int stride = ((given >> 5) & 0x1);
			int ix;
			
			if (stride && (n == 1))
			  n++;
			else
			  stride++;
			
			func (stream, "{");
			if (stride > 1)
			  for (ix = 0; ix != n; ix++)
			    func (stream, "%sd%d[]", ix ? "," : "", rd + ix * stride);
			else if (n == 1)
			  func (stream, "d%d[]", rd);
			else
			  func (stream, "d%d[]-d%d[]", rd, rd + n - 1);
			func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  {
                            int align = (8 * (type + 1)) << size;
                            if (type == 3)
                              align = (size > 1) ? align >> 1 : align;
			    if (type == 2 || (type == 0 && !size))
			      func (stream, ", :<bad align %d>", align);
			    else
			      func (stream, ", :%d", align);
			  }
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'D':
		      {
			int raw_reg = (given & 0xf) | ((given >> 1) & 0x10);
			int size = (given >> 20) & 3;
			int reg = raw_reg & ((4 << size) - 1);
			int ix = raw_reg >> size >> 2;
			
			func (stream, "d%d[%d]", reg, ix);
		      }
		      break;
		      
		    case 'E':
		      /* Neon encoded constant for mov, mvn, vorr, vbic */
		      {
			int bits = 0;
			int cmode = (given >> 8) & 0xf;
			int op = (given >> 5) & 0x1;
			uint32_t value = 0, hival = 0;
			unsigned shift;
                        int size = 0;
                        int isfloat = 0;
			
			bits |= ((given >> 24) & 1) << 7;
			bits |= ((given >> 16) & 7) << 4;
			bits |= ((given >> 0) & 15) << 0;
			
			if (cmode < 8)
			  {
			    shift = (cmode >> 1) & 3;
			    value = (uint32_t)bits << (8 * shift);
                            size = 32;
			  }
			else if (cmode < 12)
			  {
			    shift = (cmode >> 1) & 1;
			    value = (uint32_t)bits << (8 * shift);
                            size = 16;
			  }
			else if (cmode < 14)
			  {
			    shift = (cmode & 1) + 1;
			    value = (uint32_t)bits << (8 * shift);
			    value |= (1ul << (8 * shift)) - 1;
                            size = 32;
			  }
			else if (cmode == 14)
			  {
			    if (op)
			      {
				/* bit replication into bytes */
				int ix;
				uint32_t mask;
				
				value = 0;
                                hival = 0;
				for (ix = 7; ix >= 0; ix--)
				  {
				    mask = ((bits >> ix) & 1) ? 0xff : 0;
                                    if (ix <= 3)
				      value = (value << 8) | mask;
                                    else
                                      hival = (hival << 8) | mask;
				  }
                                size = 64;
			      }
                            else
                              {
                                /* byte replication */
                                value = (uint32_t)bits;
                                size = 8;
                              }
			  }
			else if (!op)
			  {
			    /* floating point encoding */
			    int tmp;
			    
			    value = (uint32_t)(bits & 0x7f) << 19;
			    value |= (uint32_t)(bits & 0x80) << 24;
			    tmp = bits & 0x40 ? 0x3c : 0x40;
			    value |= (uint32_t)tmp << 24;
                            size = 32;
                            isfloat = 1;
			  }
			else
			  {
			    func (stream, "<illegal constant %.8x:%x:%x>",
                                  bits, cmode, op);
                            size = 32;
			    break;
			  }
                        switch (size)
                          {
                          case 8:
			    func (stream, "#%ld\t@ 0x%.2lx", value, value);
                            break;
                          
                          case 16:
                            func (stream, "#%ld\t@ 0x%.4lx", value, value);
                            break;

                          case 32:
                            if (isfloat)
                              {
                                unsigned char valbytes[4];
                                double fvalue;
                                
                                /* Do this a byte at a time so we don't have to
                                   worry about the host's endianness.  */
                                valbytes[0] = value & 0xff;
                                valbytes[1] = (value >> 8) & 0xff;
                                valbytes[2] = (value >> 16) & 0xff;
                                valbytes[3] = (value >> 24) & 0xff;
                                
#ifdef NOTYET
/* HACK to avoid pulling in FSR binutils include/floatformat.h */
/* HACK to avoid pulling in FSR binutils libiberty/floatformat.c */
                                floatformat_to_double 
                                  (&floatformat_ieee_single_little, valbytes,
                                  &fvalue);
#else /* NOTYET */
				if(get_host_byte_sex() !=
				   LITTLE_ENDIAN_BYTE_SEX){
				    float f;
				    memcpy(&f, valbytes, 4);
				    f = SWAP_FLOAT(f);
				    fvalue = f;
				}
				else{
				    float f;
				    memcpy(&f, valbytes, 4);
				    fvalue = f;
				}
#endif /* NOTYET */
                                func (stream, "#%.7g\t@ 0x%.8lx", fvalue,
                                      value);
                              }
                            else
                              func (stream, "#%ld\t@ 0x%.8lx",
				(int32_t) ((value & 0x80000000)
					? value | ~0xffffffffl : value), value);
                            break;

                          case 64:
                            func (stream, "#0x%.8lx%.8lx", hival, value);
                            break;
                          
                          default:
                            abort ();
                          }
		      }
		      break;
		      
		    case 'F':
		      {
			int regno = ((given >> 16) & 0xf) | ((given >> (7 - 4)) & 0x10);
			int num = (given >> 8) & 0x3;
			
			if (!num)
			  func (stream, "{d%d}", regno);
			else if (num + regno >= 32)
			  func (stream, "{d%d-<overflow reg d%d}", regno, regno + num);
			else
			  func (stream, "{d%d-d%d}", regno, regno + num);
		      }
		      break;
      

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int width;
			uint32_t value;

			c = arm_decode_bitfield (c, given, &value, &width);
			
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
			  case 'e':
			    func (stream, "%ld", (1ul << width) - value);
			    break;
			    
			  case 'S':
			  case 'T':
			  case 'U':
			    /* various width encodings */
			    {
			      int base = 8 << (*c - 'S'); /* 8,16 or 32 */
			      int limit;
			      unsigned low, high;

			      c++;
			      if (*c >= '0' && *c <= '9')
				limit = *c - '0';
			      else if (*c >= 'a' && *c <= 'f')
				limit = *c - 'a' + 10;
			      else
				abort ();
			      low = limit >> 2;
			      high = limit & 3;

			      if (value < low || value > high)
				func (stream, "<illegal width %d>", base << value);
			      else
				func (stream, "%d", base << value);
			    }
			    break;
			  case 'R':
			    if (given & (1 << 6))
			      goto Q;
			    /* FALLTHROUGH */
			  case 'D':
			    func (stream, "d%ld", value);
			    break;
			  case 'Q':
			  Q:
			    if (value & 1)
			      func (stream, "<illegal reg q%ld.5>", value >> 1);
			    else
			      func (stream, "q%ld", value >> 1);
			    break;
			    
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }
	  return TRUE;
	}
    }
  return FALSE;
}

/* Print one ARM instruction from PC on INFO->STREAM.  */

static void
print_insn_arm (bfd_vma pc, struct disassemble_info *info, int32_t given)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (print_insn_coprocessor (pc, info, given, FALSE))
    return;

  if (print_insn_neon (info, given, FALSE))
    return;

  for (insn = arm_opcodes; insn->assembler; insn++)
    {
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

      if ((given & insn->mask) == insn->value
	  /* Special case: an instruction with all bits set in the condition field
	     (0xFnnn_nnnn) is only matched if all those bits are set in insn->mask,
	     or by the catchall at the end of the table.  */
	  && ((given & 0xF0000000) != 0xF0000000
	      || (insn->mask & 0xF0000000) == 0xF0000000
	      || (insn->mask == 0 && insn->value == 0)))
	{
	  const char *c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'a':
		      print_arm_address (pc, info, given);
		      break;

		    case 'P':
		      /* Set P address bit and use normal address
			 printing routine.  */
		      print_arm_address (pc, info, given | (1 << 24));
		      break;

		    case 's':
                      if ((given & 0x004f0000) == 0x004f0000)
			{
                          /* PC relative with immediate offset.  */
			  int offset = ((given & 0xf00) >> 4) | (given & 0xf);

			  if ((given & 0x00800000) == 0)
			    offset = -offset;

			  func (stream, "[pc, #%d]\t@ ", offset);
			  info->print_address_func (pc, offset + pc + 8, info);
			}
		      else
			{
			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
                              /* Pre-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* Immediate.  */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, ", #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
                                  /* Register.  */
				  func (stream, ", %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}

			      func (stream, "]%s",
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
                              /* Post-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* Immediate.  */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, "], #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else
				    func (stream, "]");
				}
			      else
				{
                                  /* Register.  */
				  func (stream, "], %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}
			    }
			}
		      break;

		    case 'b':
		      {
			int disp = (((given & 0xffffff) ^ 0x800000) - 0x800000);
			info->print_address_func (pc, disp*4 + pc + 8, info);
		      }
		      break;

		    case 'c':
		      if (((given >> 28) & 0xf) != 0xe)
			func (stream, "%s",
			      arm_conditional [(given >> 28) & 0xf]);
		      break;

		    case 'm':
		      {
			int started = 0;
			int reg;

			func (stream, "{");
			for (reg = 0; reg < 16; reg++)
			  if ((given & (1 << reg)) != 0)
			    {
			      if (started)
				func (stream, ", ");
			      started = 1;
			      func (stream, "%s", arm_regnames[reg]);
			    }
			func (stream, "}");
		      }
		      break;

		    case 'q':
		      arm_decode_shift (given, func, stream, 0);
		      break;

		    case 'o':
		      if ((given & 0x02000000) != 0)
			{
			  int rotate = (given & 0xf00) >> 7;
			  int immed = (given & 0xff);
			  immed = (((immed << (32 - rotate))
				    | (immed >> rotate)) & 0xffffffff);
			  func (stream, "#%d\t@ 0x%x", immed, immed);
			}
		      else
			arm_decode_shift (given, func, stream, 1);
		      break;

		    case 'p':
		      if ((given & 0x0000f000) == 0x0000f000)
			func (stream, "p");
		      break;

		    case 't':
		      if ((given & 0x01200000) == 0x00200000)
			func (stream, "t");
		      break;

		    case 'A':
		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

		      if ((given & (1 << 24)) != 0)
			{
			  int offset = given & 0xff;

			  if (offset)
			    func (stream, ", #%s%d]%s",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4,
				  ((given & 0x00200000) != 0 ? "!" : ""));
			  else
			    func (stream, "]");
			}
		      else
			{
			  int offset = given & 0xff;

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
			  else
			    func (stream, ", {%d}", offset);
			}
		      break;

		    case 'B':
		      /* Print ARM V5 BLX(1) address: pc+25 bits.  */
		      {
			bfd_vma address;
			bfd_vma offset = 0;

			if (given & 0x00800000)
			  /* Is signed, hi bits should be ones.  */
			  offset = (-1) ^ 0x00ffffff;

			/* Offset is (SignExtend(offset field)<<2).  */
			offset += given & 0x00ffffff;
			offset <<= 2;
			address = offset + pc + 8;

			if (given & 0x01000000)
			  /* H bit allows addressing to 2-byte boundaries.  */
			  address += 2;

		        info->print_address_func (pc, address, info);
		      }
		      break;

		    case 'C':
		      func (stream, "_");
		      if (given & 0x80000)
			func (stream, "f");
		      if (given & 0x40000)
			func (stream, "s");
		      if (given & 0x20000)
			func (stream, "x");
		      if (given & 0x10000)
			func (stream, "c");
		      break;

		    case 'U':
		      switch (given & 0xf)
			{
			case 0xf: func(stream, "sy"); break;
			case 0x7: func(stream, "nsh"); break;
			case 0xe: func(stream, "st"); break;
			case 0x6: func(stream, "nshst"); break;
			case 0xb: func(stream, "ish"); break;
			case 0xa: func(stream, "ishst"); break;
			case 0x3: func(stream, "osh"); break;
			case 0x2: func(stream, "oshst"); break;
			default:
			  func(stream, "#%d", (int)given & 0xf);
			  break;
			}
		      break;

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int width;
			uint32_t value;

			c = arm_decode_bitfield (c, given, &value, &width);
			
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
			  case 'b':
			    func (stream, "%ld", value * 8);
			    break;
			  case 'W':
			    func (stream, "%ld", value + 1);
			    break;
			  case 'x':
			    func (stream, "0x%08lx", value);

			    /* Some SWI instructions have special
			       meanings.  */
			    if ((given & 0x0fffffff) == 0x0FF00000)
			      func (stream, "\t@ IMB");
			    else if ((given & 0x0fffffff) == 0x0FF00001)
			      func (stream, "\t@ IMBRange");
			    break;
			  case 'X':
			    func (stream, "%01lx", value & 0xf);
			    break;
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;

		      case 'e':
			{
			  int imm;

			  imm = (given & 0xf) | ((given & 0xfff00) >> 4);
			  func (stream, "%d", imm);
			}
			break;

		      case 'E':
			/* LSB and WIDTH fields of BFI or BFC.  The machine-
			   language instruction encodes LSB and MSB.  */
			{
			  int32_t msb = (given & 0x001f0000) >> 16;
			  int32_t lsb = (given & 0x00000f80) >> 7;

			  int32_t width = msb - lsb + 1;
			  if (width > 0)
			    func (stream, "#%lu, #%lu", lsb, width);
			  else
			    func (stream, "(invalid: %lu:%lu)", lsb, msb);
			}
			break;

		      case 'V':
			/* 16-bit unsigned immediate from a MOVT or MOVW
			   instruction, encoded in bits 0:11 and 15:19.  */
			{
			  int32_t hi = (given & 0x000f0000) >> 4;
			  int32_t lo = (given & 0x00000fff);
			  int32_t imm16 = hi | lo;
			  (void)info->print_immediate_func (pc, imm16, info,
							    FALSE);
			}
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }
	  return;
	}
    }
  abort ();
}

/* Print one 16-bit Thumb instruction from PC on INFO->STREAM.  */

static void
print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, int32_t given)
{
  const struct opcode16 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  for (insn = thumb_opcodes; insn->assembler; insn++)
    if ((given & insn->mask) == insn->value)
      {
	const char *c = insn->assembler;
	for (; *c; c++)
	  {
	    int domaskpc = 0;
	    int domasklr = 0;

	    if (*c != '%')
	      {
		func (stream, "%c", *c);
		continue;
	      }

	    switch (*++c)
	      {
	      case '%':
		func (stream, "%%");
		break;

	      case 'c':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		break;

	      case 'C':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		else
		  func (stream, "s");
		break;

	      case 'I':
		{
		  unsigned int tmp;

		  ifthen_next_state = given & 0xff;
		  for (tmp = given << 1; tmp & 0xf; tmp <<= 1)
		    func (stream, ((given ^ tmp) & 0x10) ? "e" : "t");
		  func (stream, "\t%s", arm_conditional[(given >> 4) & 0xf]);
		}
		break;

	      case 'x':
		if (ifthen_next_state)
		  func (stream, "\t@ unpredictable branch in IT block\n");
		break;

	      case 'X':
		if (ifthen_state)
		  func (stream, "\t@ unpredictable <IT:%s>",
			arm_conditional[IFTHEN_COND]);
		break;

	      case 'S':
		{
		  int32_t reg;

		  reg = (given >> 3) & 0x7;
		  if (given & (1 << 6))
		    reg += 8;

		  func (stream, "%s", arm_regnames[reg]);
		}
		break;

	      case 'D':
		{
		  int32_t reg;

		  reg = given & 0x7;
		  if (given & (1 << 7))
		    reg += 8;

		  func (stream, "%s", arm_regnames[reg]);
		}
		break;

	      case 'N':
		if (given & (1 << 8))
		  domasklr = 1;
		/* Fall through.  */
	      case 'O':
		if (*c == 'O' && (given & (1 << 8)))
		  domaskpc = 1;
		/* Fall through.  */
	      case 'M':
		{
		  int started = 0;
		  int reg;

		  func (stream, "{");

		  /* It would be nice if we could spot
		     ranges, and generate the rS-rE format: */
		  for (reg = 0; (reg < 8); reg++)
		    if ((given & (1 << reg)) != 0)
		      {
			if (started)
			  func (stream, ", ");
			started = 1;
			func (stream, "%s", arm_regnames[reg]);
		      }

		  if (domasklr)
		    {
		      if (started)
			func (stream, ", ");
		      started = 1;
		      func (stream, arm_regnames[14] /* "lr" */);
		    }

		  if (domaskpc)
		    {
		      if (started)
			func (stream, ", ");
		      func (stream, arm_regnames[15] /* "pc" */);
		    }

		  func (stream, "}");
		}
		break;

	      case 'b':
		/* Print ARM V6T2 CZB address: pc+4+6 bits.  */
		{
		  bfd_vma address = (pc + 4
				     + ((given & 0x00f8) >> 2)
				     + ((given & 0x0200) >> 3));
		  info->print_address_func (pc, address, info);
		}
		break;

	      case 's':
		/* Right shift immediate -- bits 6..10; 1-31 print
		   as themselves, 0 prints as 32.  */
		{
		  int32_t imm = (given & 0x07c0) >> 6;
		  if (imm == 0)
		    imm = 32;
		  func (stream, "#%ld", imm);
		}
		break;

	      case '0': case '1': case '2': case '3': case '4':
	      case '5': case '6': case '7': case '8': case '9':
		{
		  int bitstart = *c++ - '0';
		  int bitend = 0;

		  while (*c >= '0' && *c <= '9')
		    bitstart = (bitstart * 10) + *c++ - '0';

		  switch (*c)
		    {
		    case '-':
		      {
			int32_t reg;

			c++;
			while (*c >= '0' && *c <= '9')
			  bitend = (bitend * 10) + *c++ - '0';
			if (!bitend)
			  abort ();
			reg = given >> bitstart;
			reg &= (2 << (bitend - bitstart)) - 1;
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[reg]);
			    break;

			  case 'R':
			    func (stream, "%s", arm_regnames[reg]);
			    c++;
			    if ((given & (1 << reg)) == 0)
			      func (stream, "%c", *c);
			    break;

			  case 'd':
			    func (stream, "%ld", reg);
			    break;

			  case 'H':
			    func (stream, "%ld", reg << 1);
			    break;

			  case 'W':
			    func (stream, "%ld", reg << 2);
			    break;

			  case 'a':
			    /* PC-relative address -- the bottom two
			       bits of the address are dropped
			       before the calculation.  */
			    info->print_address_func
			      (pc, ((pc + 4) & ~3) + (reg << 2), info);
			    break;

			  case 'x':
			    func (stream, "0x%04lx", reg);
			    break;

			  case 'B':
			    reg = ((reg ^ (1 << bitend)) - (1 << bitend));
			    info->print_address_func (pc, reg * 2 + pc+4, info);
			    break;

			  case 'c':
			    func (stream, "%s", arm_conditional [reg]);
			    break;

			  default:
			    abort ();
			  }
		      }
		      break;

		    case '\'':
		      c++;
		      if ((given & (1 << bitstart)) != 0)
			func (stream, "%c", *c);
		      break;

		    case '?':
		      ++c;
		      if ((given & (1 << bitstart)) != 0)
			func (stream, "%c", *c++);
		      else
			func (stream, "%c", *++c);
		      break;

		    default:
		      abort ();
		    }
		}
		break;

	      default:
		abort ();
	      }
	  }
	return;
      }

  /* No match.  */
  abort ();
}

/* Return the name of an V7M special register.  */
static const char *
psr_name (int regno)
{
  switch (regno)
    {
    case 0: return "APSR";
    case 1: return "IAPSR";
    case 2: return "EAPSR";
    case 3: return "PSR";
    case 5: return "IPSR";
    case 6: return "EPSR";
    case 7: return "IEPSR";
    case 8: return "MSP";
    case 9: return "PSP";
    case 16: return "PRIMASK";
    case 17: return "BASEPRI";
    case 18: return "BASEPRI_MASK";
    case 19: return "FAULTMASK";
    case 20: return "CONTROL";
    default: return "<unknown>";
    }
}

/* Print one 32-bit Thumb instruction from PC on INFO->STREAM.  */

static void
print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, int32_t given)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (print_insn_coprocessor (pc, info, given, TRUE))
    return;

  if (print_insn_neon (info, given, TRUE))
    return;

  for (insn = thumb32_opcodes; insn->assembler; insn++)
    if ((given & insn->mask) == insn->value)
      {
	const char *c = insn->assembler;
	for (; *c; c++)
	  {
	    if (*c != '%')
	      {
		func (stream, "%c", *c);
		continue;
	      }

	    switch (*++c)
	      {
	      case '%':
		func (stream, "%%");
		break;

	      case 'c':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		break;

	      case 'x':
		if (ifthen_next_state)
		  func (stream, "\t@ unpredictable branch in IT block\n");
		break;

	      case 'X':
		if (ifthen_state)
		  func (stream, "\t@ unpredictable <IT:%s>",
			arm_conditional[IFTHEN_COND]);
		break;

	      case 'I':
		{
		  unsigned int imm12 = 0;
		  imm12 |= (given & 0x000000ffu);
		  imm12 |= (given & 0x00007000u) >> 4;
		  imm12 |= (given & 0x04000000u) >> 15;
		  func (stream, "#%u\t@ 0x%x", imm12, imm12);
		}
		break;

	      case 'M':
		{
		  unsigned int bits = 0, imm, imm8, mod;
		  bits |= (given & 0x000000ffu);
		  bits |= (given & 0x00007000u) >> 4;
		  bits |= (given & 0x04000000u) >> 15;
		  imm8 = (bits & 0x0ff);
		  mod = (bits & 0xf00) >> 8;
		  switch (mod)
		    {
		    case 0: imm = imm8; break;
		    case 1: imm = ((imm8<<16) | imm8); break;
		    case 2: imm = ((imm8<<24) | (imm8 << 8)); break;
		    case 3: imm = ((imm8<<24) | (imm8 << 16) | (imm8 << 8) | imm8); break;
		    default:
		      mod  = (bits & 0xf80) >> 7;
		      imm8 = (bits & 0x07f) | 0x80;
		      imm  = (((imm8 << (32 - mod)) | (imm8 >> mod)) & 0xffffffff);
		    }
		  func (stream, "#%u\t@ 0x%x", imm, imm);
		}
		break;
		  
	      case 'J':
		{
		  unsigned int imm = 0;
		  imm |= (given & 0x000000ffu);
		  imm |= (given & 0x00007000u) >> 4;
		  imm |= (given & 0x04000000u) >> 15;
		  imm |= (given & 0x000f0000u) >> 4;
		  (void)info->print_immediate_func (pc, imm, info, FALSE);
		}
		break;

	      case 'K':
		{
		  unsigned int imm = 0;
		  imm |= (given & 0x000f0000u) >> 16;
		  imm |= (given & 0x00000ff0u) >> 0;
		  imm |= (given & 0x0000000fu) << 12;
		  (void)info->print_immediate_func (pc, imm, info, FALSE);
		}
		break;

	      case 'S':
		{
		  unsigned int reg = (given & 0x0000000fu);
		  unsigned int stp = (given & 0x00000030u) >> 4;
		  unsigned int imm = 0;
		  imm |= (given & 0x000000c0u) >> 6;
		  imm |= (given & 0x00007000u) >> 10;

		  func (stream, "%s", arm_regnames[reg]);
		  switch (stp)
		    {
		    case 0:
		      if (imm > 0)
			func (stream, ", lsl #%u", imm);
		      break;

		    case 1:
		      if (imm == 0)
			imm = 32;
		      func (stream, ", lsr #%u", imm);
		      break;

		    case 2:
		      if (imm == 0)
			imm = 32;
		      func (stream, ", asr #%u", imm);
		      break;

		    case 3:
		      if (imm == 0)
			func (stream, ", rrx");
		      else
			func (stream, ", ror #%u", imm);
		    }
		}
		break;

	      case 'a':
		{
		  unsigned int Rn  = (given & 0x000f0000) >> 16;
		  unsigned int U   = (given & 0x00800000) >> 23;
		  unsigned int op  = (given & 0x00000f00) >> 8;
		  unsigned int i12 = (given & 0x00000fff);
		  unsigned int i8  = (given & 0x000000ff);
		  bfd_boolean writeback = FALSE, postind = FALSE;
		  int offset = 0;

		  func (stream, "[%s", arm_regnames[Rn]);
		  if (U) /* 12-bit positive immediate offset */
		    offset = i12;
		  else if (Rn == 15) /* 12-bit negative immediate offset */
		    offset = -(int)i12;
		  else if (op == 0x0) /* shifted register offset */
		    {
		      unsigned int Rm = (i8 & 0x0f);
		      unsigned int sh = (i8 & 0x30) >> 4;
		      func (stream, ", %s", arm_regnames[Rm]);
		      if (sh)
			func (stream, ", lsl #%u", sh);
		      func (stream, "]");
		      break;
		    }
		  else switch (op)
		    {
		    case 0xE:  /* 8-bit positive immediate offset */
		      offset = i8;
		      break;

		    case 0xC:  /* 8-bit negative immediate offset */
		      offset = -i8;
		      break;

		    case 0xF:  /* 8-bit + preindex with wb */
		      offset = i8;
		      writeback = TRUE;
		      break;

		    case 0xD:  /* 8-bit - preindex with wb */
		      offset = -i8;
		      writeback = TRUE;
		      break;

		    case 0xB:  /* 8-bit + postindex */
		      offset = i8;
		      postind = TRUE;
		      break;

		    case 0x9:  /* 8-bit - postindex */
		      offset = -i8;
		      postind = TRUE;
		      break;

		    default:
		      func (stream, ", <undefined>]");
		      goto skip;
		    }

		  if (postind)
		    func (stream, "], #%d", offset);
		  else
		    {
		      if (offset)
			func (stream, ", #%d", offset);
		      func (stream, writeback ? "]!" : "]");
		    }

		  if (Rn == 15)
		    {
		      func (stream, "\t@ ");
		      info->print_address_func(pc, ((pc+4) & ~3) +offset, info);
		    }
		}
	      skip:
		break;

	      case 'A':
		{
		  unsigned int P   = (given & 0x01000000) >> 24;
		  unsigned int U   = (given & 0x00800000) >> 23;
		  unsigned int W   = (given & 0x00400000) >> 21;
		  unsigned int Rn  = (given & 0x000f0000) >> 16;
		  unsigned int off = (given & 0x000000ff);

		  func (stream, "[%s", arm_regnames[Rn]);
		  if (P)
		    {
		      if (off || !U)
			func (stream, ", #%c%u", U ? '+' : '-', off * 4);
		      func (stream, "]");
		      if (W)
			func (stream, "!");
		    }
		  else
		    {
		      func (stream, "], ");
		      if (W)
			func (stream, "#%c%u", U ? '+' : '-', off * 4);
		      else
			func (stream, "{%u}", off);
		    }
		}
		break;

	      case 'w':
		{
		  unsigned int Sbit = (given & 0x01000000) >> 24;
		  unsigned int type = (given & 0x00600000) >> 21;
		  switch (type)
		    {
		    case 0: func (stream, Sbit ? "sb" : "b"); break;
		    case 1: func (stream, Sbit ? "sh" : "h"); break;
		    case 2:
		      if (Sbit)
			func (stream, "??");
		      break;
		    case 3:
		      func (stream, "??");
		      break;
		    }
		}
		break;

	      case 'm':
		{
		  int started = 0;
		  int reg;

		  func (stream, "{");
		  for (reg = 0; reg < 16; reg++)
		    if ((given & (1 << reg)) != 0)
		      {
			if (started)
			  func (stream, ", ");
			started = 1;
			func (stream, "%s", arm_regnames[reg]);
		      }
		  func (stream, "}");
		}
		break;

	      case 'E':
		{
		  unsigned int msb = (given & 0x0000001f);
		  unsigned int lsb = 0;
		  lsb |= (given & 0x000000c0u) >> 6;
		  lsb |= (given & 0x00007000u) >> 10;
		  func (stream, "#%u, #%u", lsb, msb - lsb + 1);
		}
		break;

	      case 'F':
		{
		  unsigned int width = (given & 0x0000001f) + 1;
		  unsigned int lsb = 0;
		  lsb |= (given & 0x000000c0u) >> 6;
		  lsb |= (given & 0x00007000u) >> 10;
		  func (stream, "#%u, #%u", lsb, width);
		}
		break;

	      case 'b':
		{
		  unsigned int S = (given & 0x04000000u) >> 26;
		  unsigned int J1 = (given & 0x00002000u) >> 13;
		  unsigned int J2 = (given & 0x00000800u) >> 11;
		  int offset = 0;

		  offset |= !S << 20;
		  offset |= J2 << 19;
		  offset |= J1 << 18;
		  offset |= (given & 0x003f0000) >> 4;
		  offset |= (given & 0x000007ff) << 1;
		  offset -= (1 << 20);

		  info->print_address_func (pc, pc + 4 + offset, info);
		}
		break;

	      case 'B':
		{
		  unsigned int S = (given & 0x04000000u) >> 26;
		  unsigned int I1 = (given & 0x00002000u) >> 13;
		  unsigned int I2 = (given & 0x00000800u) >> 11;
		  int offset = 0;

		  offset |= !S << 24;
		  offset |= !(I1 ^ S) << 23;
		  offset |= !(I2 ^ S) << 22;
		  offset |= (given & 0x03ff0000u) >> 4;
		  offset |= (given & 0x000007ffu) << 1;
		  offset -= (1 << 24);
		  offset += pc + 4;

		  /* BLX target addresses are always word aligned.  */
		  if ((given & 0x00001000u) == 0)
		      offset &= ~2u;

		  info->print_address_func (pc, offset, info);
		}
		break;

	      case 's':
		{
		  unsigned int shift = 0;
		  shift |= (given & 0x000000c0u) >> 6;
		  shift |= (given & 0x00007000u) >> 10;
		  if (given & 0x00200000u)
		    func (stream, ", asr #%u", shift);
		  else if (shift)
		    func (stream, ", lsl #%u", shift);
		  /* else print nothing - lsl #0 */
		}
		break;

	      case 'R':
		{
		  unsigned int rot = (given & 0x00000030) >> 4;
		  if (rot)
		    func (stream, ", ror #%u", rot * 8);
		}
		break;

	      case 'U':
		switch (given & 0xf)
		  {
		  case 0xf: func(stream, "sy"); break;
		  case 0xe: func(stream, "st"); break;
		  case 0x7: func(stream, "nsh"); break;
		  case 0x6: func(stream, "nshst"); break;
		  case 0xb: func(stream, "ish"); break;
		  case 0xa: func(stream, "ishst"); break;
		  case 0x3: func(stream, "osh"); break;
		  case 0x2: func(stream, "oshst"); break;
		  default:
		    func(stream, "#%d", (int)given & 0xf);
		    break;
		  }
		break;

	      case 'C':
		if ((given & 0xff) == 0)
		  {
		    func (stream, "%cPSR_", (given & 0x100000) ? 'S' : 'C');
		    if (given & 0x800)
		      func (stream, "f");
		    if (given & 0x400)
		      func (stream, "s");
		    if (given & 0x200)
		      func (stream, "x");
		    if (given & 0x100)
		      func (stream, "c");
		  }
		else
		  {
		    func (stream, psr_name (given & 0xff));
		  }
		break;

	      case 'D':
		if ((given & 0xff) == 0)
		  func (stream, "%cPSR", (given & 0x100000) ? 'S' : 'C');
		else
		  func (stream, psr_name (given & 0xff));
		break;

	      case '0': case '1': case '2': case '3': case '4':
	      case '5': case '6': case '7': case '8': case '9':
		{
		  int width;
		  uint32_t val;

		  c = arm_decode_bitfield (c, given, &val, &width);
			
		  switch (*c)
		    {
		    case 'd': func (stream, "%lu", val); break;
		    case 'W': func (stream, "%lu", val * 4); break;
		    case 'r': func (stream, "%s", arm_regnames[val]); break;

		    case 'c':
		      func (stream, "%s", arm_conditional[val]);
		      break;

		    case '\'':
		      c++;
		      if (val == ((1ul << width) - 1))
			func (stream, "%c", *c);
		      break;
		      
		    case '`':
		      c++;
		      if (val == 0)
			func (stream, "%c", *c);
		      break;

		    case '?':
		      func (stream, "%c", c[(1 << width) - (int)val]);
		      c += 1 << width;
		      break;

		    default:
		      abort ();
		    }
		}
		break;

	      default:
		abort ();
	      }
	  }
	return;
      }

  /* No match.  */
  abort ();
}

/* Print data bytes on INFO->STREAM.  */

static void
print_insn_data (bfd_vma pc ATTRIBUTE_UNUSED, struct disassemble_info *info,
		 int32_t given)
{
  switch (info->bytes_per_chunk)
    {
    case 1:
      info->fprintf_func (info->stream, ".byte\t0x%02lx", given);
      break;
    case 2:
      info->fprintf_func (info->stream, ".short\t0x%04lx", given);
      break;
    case 4:
      info->fprintf_func (info->stream, ".word\t0x%08lx", given);
      break;
    default:
      abort ();
    }
}

/* Search back through the insn stream to determine if this instruction is
   conditionally executed.  */
static void
find_ifthen_state (bfd_vma pc, struct disassemble_info *info,
		   bfd_boolean little)
{
  unsigned char b[2];
  unsigned int insn;
  int status;
  /* COUNT is twice the number of instructions seen.  It will be odd if we
     just crossed an instruction boundary.  */
  int count;
  int it_count;
  unsigned int seen_it;
  bfd_vma addr;

  ifthen_address = pc;
  ifthen_state = 0;

  addr = pc;
  count = 1;
  it_count = 0;
  seen_it = 0;
  /* Scan backwards looking for IT instructions, keeping track of where
     instruction boundaries are.  We don't know if something is actually an
     IT instruction until we find a definite instruction boundary.  */
  for (;;)
    {
      if (addr == 0 || info->symbol_at_address_func(addr, info))
	{
	  /* A symbol must be on an instruction boundary, and will not
	     be within an IT block.  */
	  if (seen_it && (count & 1))
	    break;

	  return;
	}
      addr -= 2;
      status = info->read_memory_func (addr, (bfd_byte *)b, 2, info);
      if (status)
	return;

      if (little)
	insn = (b[0]) | (b[1] << 8);
      else
	insn = (b[1]) | (b[0] << 8);
      if (seen_it)
	{
	  if ((insn & 0xf800) < 0xe800)
	    {
	      /* Addr + 2 is an instruction boundary.  See if this matches
	         the expected boundary based on the position of the last
		 IT candidate.  */
	      if (count & 1)
		break;
	      seen_it = 0;
	    }
	}
      if ((insn & 0xff00) == 0xbf00 && (insn & 0xf) != 0)
	{
	  /* This could be an IT instruction.  */
	  seen_it = insn;
	  it_count = count >> 1;
	}
      if ((insn & 0xf800) >= 0xe800)
	count++;
      else
	count = (count + 2) | 1;
      /* IT blocks contain at most 4 instructions.  */
      if (count >= 8 && !seen_it)
	return;
    }
  /* We found an IT instruction.  */
  ifthen_state = (seen_it & 0xe0) | ((seen_it << it_count) & 0x1f);
  if ((ifthen_state & 0xf) == 0)
    ifthen_state = 0;
}

/* NOTE: There are no checks in these routines that
   the relevant number of data bytes exist.  */

static int
print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
{
  unsigned char b[4];
  int32_t	given;
  int           status;
  int           is_thumb = FALSE;
  int           is_data = FALSE;
  unsigned int	size = 4;
  void	 	(*printer) (bfd_vma, struct disassemble_info *, int32_t);
  char		*llvm_arch_name;
  LLVMDisasmContextRef dc;

#ifdef NOTDEF
  bfd_boolean   found = FALSE;

  if (info->disassembler_options)
    {
      parse_disassembler_options (info->disassembler_options);

      /* To avoid repeated parsing of these options, we remove them here.  */
      info->disassembler_options = NULL;
    }

  /* First check the full symtab for a mapping symbol, even if there
     are no usable non-mapping symbols for this address.  */
  if (info->symtab != NULL
      && bfd_asymbol_flavour (*info->symtab) == bfd_target_elf_flavour)
    {
      bfd_vma addr;
      int n;
      int last_sym = -1;
      enum map_type type = MAP_ARM;

      if (pc <= last_mapping_addr)
	last_mapping_sym = -1;
      is_thumb = (last_type == MAP_THUMB);
      found = FALSE;
      /* Start scanning at the start of the function, or wherever
	 we finished last time.  */
      n = info->symtab_pos + 1;
      if (n < last_mapping_sym)
	n = last_mapping_sym;

      /* Scan up to the location being disassembled.  */
      for (; n < info->symtab_size; n++)
	{
	  addr = bfd_asymbol_value (info->symtab[n]);
	  if (addr > pc)
	    break;
	  if ((info->section == NULL
	       || info->section == info->symtab[n]->section)
	      && get_sym_code_type (info, n, &type))
	    {
	      last_sym = n;
	      found = TRUE;
	    }
	}

      if (!found)
	{
	  n = info->symtab_pos;
	  if (n < last_mapping_sym - 1)
	    n = last_mapping_sym - 1;

	  /* No mapping symbol found at this address.  Look backwards
	     for a preceeding one.  */
	  for (; n >= 0; n--)
	    {
	      if (get_sym_code_type (info, n, &type))
		{
		  last_sym = n;
		  found = TRUE;
		  break;
		}
	    }
	}

      last_mapping_sym = last_sym;
      last_type = type;
      is_thumb = (last_type == MAP_THUMB);
      is_data = (last_type == MAP_DATA);

      /* Look a little bit ahead to see if we should print out
	 two or four bytes of data.  If there's a symbol,
	 mapping or otherwise, after two bytes then don't
	 print more.  */
      if (is_data)
	{
	  size = 4 - (pc & 3);
	  for (n = last_sym + 1; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc)
		{
		  if (addr - pc < size)
		    size = addr - pc;
		  break;
		}
	    }
	  /* If the next symbol is after three bytes, we need to
	     print only part of the data, so that we can use either
	     .byte or .short.  */
	  if (size == 3)
	    size = (pc & 1) ? 1 : 2;
	}
    }

  if (info->symbols != NULL)
    {
      if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
	{
	  coff_symbol_type * cs;

	  cs = coffsymbol (*info->symbols);
	  is_thumb = (   cs->native->u.syment.n_sclass == C_THUMBEXT
		      || cs->native->u.syment.n_sclass == C_THUMBSTAT
		      || cs->native->u.syment.n_sclass == C_THUMBLABEL
		      || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
		      || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
	}
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour
	       && !found)
	{
	  /* If no mapping symbol has been found then fall back to the type
	     of the function symbol.  */
	  elf_symbol_type *  es;
	  unsigned int       type;

	  es = *(elf_symbol_type **)(info->symbols);
	  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

	  is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
	}
    }
#endif /* NOTDEF */

  /* These are the ways otool(1) determines if we are in thumb mode */
  if (Bflag)
    force_thumb = TRUE;
  else
    set_thumb_mode(pc, info->nsorted_symbols, info->sorted_symbols, &in_thumb);

  if (force_thumb || in_thumb)
    is_thumb = TRUE;

  info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
  info->bytes_per_line = 4;

  if (is_data)
    {
      int i;

      /* size was already set above.  */
      info->bytes_per_chunk = size;
      printer = print_insn_data;

      status = info->read_memory_func (pc, (bfd_byte *)b, size, info);
      given = 0;
      if (little)
	for (i = size - 1; i >= 0; i--)
	  given = b[i] | (given << 8);
      else
	for (i = 0; i < (int) size; i++)
	  given = b[i] | (given << 8);
    }
  else if (!is_thumb)
    {
      /* In ARM mode endianness is a straightforward issue: the instruction
	 is four bytes long and is either ordered 0123 or 3210.  */
      printer = print_insn_arm;
      llvm_arch_name = "arm";
      dc = info->arm_dc;
      info->bytes_per_chunk = 4;
      size = 4;

      status = info->read_memory_func (pc, (bfd_byte *)b, 4, info);
      if (little)
	given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
      else
	given = (b[3]) | (b[2] << 8) | (b[1] << 16) | (b[0] << 24);

      /* Print the raw data, too. */
      if(!Xflag && !gflag && !no_show_raw_insn)
        {
          if(qflag)
	    info->fprintf_func (info->stream, "\t");
	  info->fprintf_func (info->stream, "%08x", (unsigned int) given);
          if(!qflag)
	    info->fprintf_func (info->stream, "\t");
        }
    }
  else
    {
      /* In Thumb mode we have the additional wrinkle of two
	 instruction lengths.  Fortunately, the bits that determine
	 the length of the current instruction are always to be found
	 in the first two bytes.  */
      printer = print_insn_thumb16;
      llvm_arch_name = "thumb";
      dc = info->thumb_dc;
      info->bytes_per_chunk = 2;
      size = 2;

      status = info->read_memory_func (pc, (bfd_byte *)b, 2, info);
      if (little)
	given = (b[0]) | (b[1] << 8);
      else
	given = (b[1]) | (b[0] << 8);

      if (!status)
	{
	  /* These bit patterns signal a four-byte Thumb
	     instruction.  */
	  if ((given & 0xF800) == 0xF800
	      || (given & 0xF800) == 0xF000
	      || (given & 0xF800) == 0xE800)
	    {
	      status = info->read_memory_func (pc + 2, (bfd_byte *)b, 2, info);
	      if (little)
		given = (b[0]) | (b[1] << 8) | (given << 16);
	      else
		given = (b[1]) | (b[0] << 8) | (given << 16);

	      /* Print the raw data, too. */
	      if(!Xflag && !gflag && !no_show_raw_insn)
		{
		  if(qflag)
		    info->fprintf_func (info->stream, "\t");
	          info->fprintf_func (info->stream, "%08x",
				      (unsigned int) given);
		  if(!qflag)
		    info->fprintf_func (info->stream, "\t");
		}
	      printer = print_insn_thumb32;
	      llvm_arch_name = "thumbv7";
	      dc = info->thumb_dc;
	      size = 4;
	    }
	  else {
	    /* Print the raw data, too. */
	    if(!Xflag && !gflag && !no_show_raw_insn)
	      {
		if(qflag)
		  info->fprintf_func (info->stream, "\t");
	        info->fprintf_func (info->stream, "    %04x",
				    (unsigned int)given);
		if(!qflag)
		  info->fprintf_func (info->stream, "\t");
	      }
	   }
	}

      if (ifthen_address != pc)
	find_ifthen_state(pc, info, little);

      if (ifthen_state)
	{
	  if ((ifthen_state & 0xf) == 0x8)
	    ifthen_next_state = 0;
	  else
	    ifthen_next_state = (ifthen_state & 0xe0)
				| ((ifthen_state & 0xf) << 1);
	}
    }

  if (info->flags & INSN_HAS_RELOC)
    /* If the instruction has a reloc associated with it, then
       the offset field in the instruction will actually be the
       addend for the reloc.  (We are using REL type relocs).
       In such cases, we can ignore the pc when computing
       addresses, since the addend is not currently pc-relative.  */
    pc = 0;

  if (qflag)
    {
      char dst[4096];
      dst[4095] = '\0';
      if(
#ifdef STATIC_LLVM
	 LLVMDisasmInstruction
#else
         llvm_disasm_instruction
#endif
	    (dc, (uint8_t *)info->sect, size, pc, dst, 4095) != 0){
	if(info->inst == NULL || info->inst->print)
	  printf("%s", dst);
      }
      else if(info->inst == NULL || info->inst->print){
	if (size == 4)
	  info->fprintf_func (info->stream, "\t.long\t0x%08x", given);
	else if (size == 2)
	  info->fprintf_func (info->stream, "\t.short\t0x%04x", given);
        else
	  info->fprintf_func (info->stream, "\tinvalid instruction encoding");
      }
    }
  else
    printer (pc, info, given);

  if (is_thumb)
    {
      ifthen_state = ifthen_next_state;
      ifthen_address += size;
    }
  return size;
}

int
print_insn_big_arm (bfd_vma pc, struct disassemble_info *info)
{
  return print_insn (pc, info, FALSE);
}

int
print_insn_little_arm (bfd_vma pc, struct disassemble_info *info)
{
  return print_insn (pc, info, TRUE);
}

/*
 * An otool(1) specific glue function to be used by the FSF disassembler code.
 */
static
void
print_address_func(
bfd_vma pc,
bfd_vma addr,
struct disassemble_info *info)
{
    int32_t i;
    const char *name;
    void *stream = info->stream;
    struct relocation_info *relocs = info->relocs;
    uint32_t nrelocs = info->nrelocs;
    struct nlist *symbols = info->symbols;
    uint32_t nsymbols = info->nsymbols;
    char *strings = info->strings;
    uint32_t strings_size = info->strings_size;
    bfd_vma r_address = pc - info->sect_addr;

    if(info->verbose){
	/* If there's a relocation at this address, include the referenced
	   symbol.  */
	for(i = 0; i < nrelocs; i++){
	    if(relocs[i].r_address == r_address && relocs[i].r_extern){
 		unsigned int r_symbolnum = relocs[i].r_symbolnum;
		if(r_symbolnum < nsymbols){
		    uint32_t n_strx = symbols[r_symbolnum].n_un.n_strx;
		    if(n_strx < strings_size){
			fputs(strings + n_strx, stream);
			if((int32_t) addr > 0) {
			    fprintf(stream, "+%#x", addr);
			} else if((int32_t) addr < 0) {
			    fprintf(stream, "-%#x", -addr);
			}
			return;
		    }
		}
	    }
	}
	/* No relocation entries found.  */
	name = guess_symbol(addr, info->sorted_symbols, info->nsorted_symbols,
			    TRUE);
	if(name && *name){
	    fputs(name, stream);
	    return;
	}
    }
    fprintf(stream, "0x%x", addr);
    if(info->verbose){
	name = guess_indirect_symbol(addr, info->ncmds, info->sizeofcmds,
		   info->load_commands, info->object_byte_sex,
		   info->indirect_symbols, info->nindirect_symbols,
		   info->symbols, NULL, info->nsymbols, info->strings,
		   info->strings_size);
	if(name != NULL)
	    fprintf(stream, "\t@ symbol stub for: %s", name);
	else{
	    uint64_t reference_type;
	    reference_type = LLVMDisassembler_ReferenceType_In_PCrel_Load;
	    name = guess_literal_pointer(addr, pc, &reference_type, info);
	    if(name != NULL){
		fprintf(stream, " literal pool for: ");
		if(reference_type ==
		   LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr)
		    fprintf(stream, "\"%s\"", name);
		else
		    fprintf(stream, "%s", name);
	    }
	}
    }
}

/*
 * print_immediate_func() prints the 'immediate' value passed to it which is
 * at the pc by using the relocation entries, symbol and string tables in the
 * disassemble_info.  If pool is TRUE then it only looks for what might be a
 * literal pool pointer that has a section difference relocation entry and
 * if found prints it as a .long.  If pool is TRUE and it does not print
 * anything then FALSE is returned, else TRUE is returned in all other cases.
 */
static
enum bool
print_immediate_func(
bfd_vma pc,
unsigned int value,
struct disassemble_info *info,
enum bool pool)
{
    int32_t low, high, mid, reloc_found, offset;
    uint32_t i, r_address, r_symbolnum, r_type, r_extern, r_length,
	     r_value, r_scattered, pair_r_type, pair_r_value;
    uint32_t other_half;
    const char *name, *add, *sub;
    struct relocation_info *rp, *pairp;
    struct scattered_relocation_info *srp, *spairp;
    uint32_t n_strx;

    void *stream = info->stream;
    struct relocation_info *relocs = info->relocs;
    uint32_t nrelocs = info->nrelocs;
    struct nlist *symbols = info->symbols;
    char *strings = info->strings;
    uint32_t strings_size = info->strings_size;
    bfd_vma sect_offset = pc - info->sect_addr;

	r_symbolnum = 0;
	r_type = 0;
	r_extern = 0;
	r_value = 0;
	r_scattered = 0;
	other_half = 0;
	pair_r_value = 0;
	n_strx = 0;
	r_length = 0;

	if(info->verbose == FALSE && pool == FALSE){
	    fprintf(stream, "#%u\t@ 0x%x", value, value);
	    return(TRUE);
	}
	reloc_found = 0;
	for(i = 0; i < nrelocs; i++){
	    rp = &relocs[i];
	    if(rp->r_address & R_SCATTERED){
		srp = (struct scattered_relocation_info *)rp;
		r_scattered = 1;
		r_address = srp->r_address;
		r_extern = 0;
		r_length = srp->r_length;
		r_type = srp->r_type;
		r_value = srp->r_value;
	    }
	    else{
		r_scattered = 0;
		r_address = rp->r_address;
		r_symbolnum = rp->r_symbolnum;
		r_extern = rp->r_extern;
		r_length = rp->r_length;
		r_type = rp->r_type;
	    }
	    if(r_type == ARM_RELOC_PAIR){
		fprintf(stderr, "Stray ARM_RELOC_PAIR relocation entry "
			"%u\n", i);
		continue;
	    }
	    if(r_address == sect_offset){
		if(r_type == ARM_RELOC_HALF ||
		   r_type == ARM_RELOC_SECTDIFF ||
		   r_type == ARM_RELOC_LOCAL_SECTDIFF ||
		   r_type == ARM_RELOC_HALF_SECTDIFF){
		    if(i+1 < nrelocs){
			pairp = &rp[1];
			if(pairp->r_address & R_SCATTERED){
			    spairp = (struct scattered_relocation_info *)
				     pairp;
			    other_half = spairp->r_address & 0xffff;
			    pair_r_type = spairp->r_type;
			    pair_r_value = spairp->r_value;
			}
			else{
			    other_half = pairp->r_address & 0xffff;
			    pair_r_type = pairp->r_type;
			}
			if(pair_r_type != ARM_RELOC_PAIR){
			    fprintf(stderr, "No ARM_RELOC_PAIR relocation "
				    "entry after entry %u\n", i);
			    continue;
			}
		    }
		}
		reloc_found = 1;
		break;
	    }
	    if(r_type == ARM_RELOC_HALF ||
	       r_type == ARM_RELOC_SECTDIFF ||
	       r_type == ARM_RELOC_LOCAL_SECTDIFF ||
	       r_type == ARM_RELOC_HALF_SECTDIFF){
		if(i+1 < nrelocs){
		    pairp = &rp[1];
		    if(pairp->r_address & R_SCATTERED){
			spairp = (struct scattered_relocation_info *)pairp;
			pair_r_type = spairp->r_type;
		    }
		    else{
			pair_r_type = pairp->r_type;
		    }
		    if(pair_r_type == ARM_RELOC_PAIR)
			i++;
		    else
			fprintf(stderr, "No ARM_RELOC_PAIR relocation "
				"entry after entry %u\n", i);
		}
	    }
	}

	/*
	 * If we are looking for possible literal pools, then only print
	 * something if we find a relocation entry for .long that is a
	 * section difference.
	 */
	if(pool){
	    if(reloc_found && r_length == 2 &&
	       (r_type == ARM_RELOC_SECTDIFF ||
		r_type == ARM_RELOC_LOCAL_SECTDIFF)){
		if(!Xflag && !no_show_raw_insn){
		    if(qflag)
			fprintf(stream, "\t");
		    fprintf(stream, "%08x\t", value);
		}
		fprintf(stream, ".long\t");
		add = guess_symbol(r_value, info->sorted_symbols,
				   info->nsorted_symbols, info->verbose);
		sub = guess_symbol(pair_r_value, info->sorted_symbols,
				   info->nsorted_symbols, info->verbose);
		/*
		 * Since most literal pool pointers are something like:
		 *	.long symbol - (pic_base + offset)
		 * we calculate the offset this way and print the expression
		 * this way instead of:
		 *	.long symbol - picbase + offset
		 * as offset would appear to be a negative number.
		 */
		offset = - (value + pair_r_value - r_value);
		if(add != NULL)
		    fprintf(stream, "%s", add);
		else
		    fprintf(stream, "0x%x", (unsigned int)r_value);
		if(sub != NULL)
		    fprintf(stream, "-(%s", sub);
		else
		    fprintf(stream, "-(0x%x", (unsigned int)pair_r_value);
		if(offset != 0)
		    fprintf(stream, "+0x%x)", (unsigned int)offset);
		fprintf(stream, "\n");
		/* return indicating we printed something */
		return(TRUE);
	    }
	    /* return indicating we printed nothing */
	    return(FALSE);
	}

	if(reloc_found && r_extern == 1){
	    if(symbols != NULL)
		n_strx = symbols[r_symbolnum].n_un.n_strx;
	    if(n_strx >= strings_size)
		name = "bad string offset";
	    else
		name = strings + n_strx;
	    if(value != 0){
		switch(r_type){
		case ARM_RELOC_HALF:
		    if((r_length & 0x1) == 1){
			value = value << 16 | other_half;
			fprintf(stream, ":upper16:%s+0x%x", name,
				(unsigned int)value);
		    }
		    else{
			value = other_half << 16 | value;
			fprintf(stream, ":lower16:%s+0x%x", name,
				(unsigned int)value);
		    }
		    break;
		default:
		    fprintf(stream, "%s+0x%x", name, (unsigned int)value);
		    break;
		}
	    }
	    else{
		switch(r_type){
		case ARM_RELOC_HALF:
		    if((r_length & 0x1) == 1){
			value = value << 16 | other_half;
			if(value == 0)
			    fprintf(stream, ":upper16:%s", name);
			else
			    fprintf(stream, ":upper16:%s+0x%x", name,
				    (unsigned int)value);
		    }
		    else{
			value = other_half << 16 | value;
			if(value == 0)
			    fprintf(stream, ":lower16:%s", name);
			else
			    fprintf(stream, ":lower16:%s+0x%x", name,
				    (unsigned int)value);
		    }
		    break;
		default:
		    if(value == 0)
			fprintf(stream, "%s", name);
		    else
			fprintf(stream, "%s+0x%x", name, (unsigned int)value);
		}
	    }
	    return(TRUE);
	}

	offset = 0;
	if(reloc_found){
	    if(r_type == ARM_RELOC_HALF ||
	       r_type == ARM_RELOC_HALF_SECTDIFF){
		if((r_length & 0x1) == 1)
		    value = value << 16 | other_half;
		else
		    value = other_half << 16 | value;
	    }
	    if(r_scattered &&
               (r_type != ARM_RELOC_HALF &&
                r_type != ARM_RELOC_HALF_SECTDIFF)){
		offset = value - r_value;
		value = r_value;
	    }
	}

	if(reloc_found && r_type == ARM_RELOC_HALF_SECTDIFF){
	    if((r_length & 0x1) == 1)
		fprintf(stream, ":upper16:");
	    else
		fprintf(stream, ":lower16:");
	    add = guess_symbol(r_value, info->sorted_symbols,
			       info->nsorted_symbols, info->verbose);
	    sub = guess_symbol(pair_r_value, info->sorted_symbols,
			       info->nsorted_symbols, info->verbose);
	    offset = value - (r_value - pair_r_value);
	    if(add != NULL)
		fprintf(stream, "%s", add);
	    else
		fprintf(stream, "0x%x", (unsigned int)r_value);
	    if(sub != NULL)
		fprintf(stream, "-%s", sub);
	    else
		fprintf(stream, "-0x%x", (unsigned int)pair_r_value);
	    if(offset != 0)
		fprintf(stream, "+0x%x", (unsigned int)offset);
	    return(TRUE);
	}

	low = 0;
	high = info->nsorted_symbols - 1;
	mid = (high - low) / 2;
	while(high >= low){
	    if(info->sorted_symbols[mid].n_value == value){
		if(reloc_found){
		    switch(r_type){
		    case ARM_RELOC_HALF:
			if((r_length & 0x1) == 1){
			    if(offset == 0)
				fprintf(stream, ":upper16:%s",
				       info->sorted_symbols[mid].name);
			    else
				fprintf(stream, ":upper16:%s+0x%x",
					info->sorted_symbols[mid].name,
					(unsigned int)offset);
			}
			else{
			    if(offset == 0)
				fprintf(stream, ":lower16:%s",
				       info->sorted_symbols[mid].name);
			    else
				fprintf(stream, ":lower16:%s+0x%x",
				       info->sorted_symbols[mid].name,
				       (unsigned int)offset);
			}
			break;
		    default:
			if(offset == 0)
			    fprintf(stream,"%s",info->sorted_symbols[mid].name);
			else
			    fprintf(stream, "%s+0x%x",
				   info->sorted_symbols[mid].name,
				   (unsigned int)offset);
			break;
		    }
		}
		else{
		    if(offset == 0)
			fprintf(stream, "%s",info->sorted_symbols[mid].name);
		    else
			fprintf(stream, "%s+0x%x",
			       info->sorted_symbols[mid].name,
			       (unsigned int)offset);
		}
		return(TRUE);
	    }
	    if(info->sorted_symbols[mid].n_value > value){
		high = mid - 1;
		mid = (high + low) / 2;
	    }
	    else{
		low = mid + 1;
		mid = (high + low) / 2;
	    }
	}
	if(offset == 0){
	    if(reloc_found){
		if(r_type == ARM_RELOC_HALF){
		    if((r_length & 0x1) == 1)
			fprintf(stream, ":upper16:0x%x", (unsigned int)value);
		    else
			fprintf(stream, ":lower16:0x%x", (unsigned int)value);
		}
		else
		    fprintf(stream, "0x%x", (unsigned int)value);
	    }
	    else
		fprintf(stream, "0x%x", (unsigned int)value);
	}
	else{
	    if(reloc_found){
		if(r_type == ARM_RELOC_HALF){
		    if((r_length & 0x1) == 1)
			fprintf(stream, ":upper16:0x%x+0x%x",
				(unsigned int)value, (unsigned int)offset);
		    else
			fprintf(stream, ":lower16:0x%x+0x%x)",
				(unsigned int)value, (unsigned int)offset);
		}
		else
		    fprintf(stream, "0x%x+0x%x",
			    (unsigned int)value, (unsigned int)offset);
	    }
	    else
		fprintf(stream, "0x%x+0x%x",
			(unsigned int)value, (unsigned int)offset);
	}
	return(TRUE);
}

/*
 * Print the section contents pointed to by sect as data .long, .short or .byte
 * depending on its kind.
 */
static
uint32_t
print_data_in_code(
char *sect,
uint32_t sect_left,
uint32_t dice_left,
uint16_t kind)
{
    uint32_t value, left, size;

	left = dice_left;
	if(left > sect_left)
	    left = sect_left;
	switch(kind){
	default:
	case DICE_KIND_DATA:
	    if(left >= 4){
		value = sect[3] << 24 |
			sect[2] << 16 |
			sect[1] << 8 |
			sect[0];
		if(!Xflag && !gflag && !no_show_raw_insn)
		    printf("\t%08x", value);
		printf("\t.long %u\t@ ", value);
		size = 4;
	    }
	    else if(left >= 2){
		value = sect[1] << 8 |
			sect[0];
		if(!Xflag && !gflag && !no_show_raw_insn)
		    printf("\t    %04x", value);
		printf("\t.short %u\t@ ", value);
		size = 2;
	    }
	    else {
		value = sect[0];
		if(!Xflag && !gflag && !no_show_raw_insn)
		    printf("\t      %02x", value & 0xff);
		printf("\t.byte %u\t@ ", value & 0xff);
		size = 1;
	    }
	    if(kind == DICE_KIND_DATA)
		printf("KIND_DATA\n");
	    else
		printf("kind = %u\n", kind);
	    return(size);
	case DICE_KIND_JUMP_TABLE8:
	    value = sect[0];
            if(!Xflag && !gflag && !no_show_raw_insn)
		printf("\t      %02x", value);
	    printf("\t.byte %3u\t@ KIND_JUMP_TABLE8\n", value);
	    return(1);
	case DICE_KIND_JUMP_TABLE16:
	    value = sect[1] << 8 |
		    sect[0];
            if(!Xflag && !gflag && !no_show_raw_insn)
		printf("\t    %04x", value & 0xffff);
	    printf("\t.short %5u\t@ KIND_JUMP_TABLE16\n", value & 0xffff);
	    return(2);
	case DICE_KIND_JUMP_TABLE32:
	case DICE_KIND_ABS_JUMP_TABLE32:
	    value = sect[3] << 24 |
		    sect[2] << 16 |
		    sect[1] << 8 |
		    sect[0];
            if(!Xflag && !gflag && !no_show_raw_insn)
		printf("\t%08x", value);
	    printf("\t.long %u\t@ ", value);
	    if(kind == DICE_KIND_JUMP_TABLE32)
		printf("KIND_JUMP_TABLE32\n");
	    else
		printf("KIND_ABS_JUMP_TABLE32\n");
	    return(4);
	}
}

/* Stubbed out for now */
  /* Function called to determine if there is a symbol at the given ADDR.
     If there is, the function returns 1, otherwise it returns 0.
     This is used by ports which support an overlay manager where
     the overlay number is held in the top part of an address.  In
     some circumstances we want to include the overlay number in the
     address, (normally because there is a symbol associated with
     that address), but sometimes we want to mask out the overlay bits.  */
static
int
symbol_at_address_func(
bfd_vma addr,
struct disassemble_info * info)
{
/*
	printf("Unexpected call to stubbed out symbol_at_address_func() "
	       " addr = 0x%x\n", addr);
*/
	return(0);
}

  /* Function used to get bytes to disassemble.  MEMADDR is the
     address of the stuff to be disassembled, MYADDR is the address to
     put the bytes in, and LENGTH is the number of bytes to read.
     INFO is a pointer to this struct.
     Returns an errno value or 0 for success.  */
static
int 
read_memory_func(
bfd_vma memaddr,
bfd_byte *myaddr,
unsigned int length,
struct disassemble_info *info)
{
	if(info->addr > memaddr)
	    return(1);

	if(info->left >= length + (memaddr - info->addr)){
	    memcpy(myaddr, info->sect + (memaddr - info->addr), length);
	    return(0);
	}
	else{
	    memcpy(myaddr, info->sect + (memaddr - info->addr), info->left);
	    return(1);
	}
}

/* Stubbed out for now */
  /* Function which should be called if we get an error that we can't
     recover from.  STATUS is the errno value from read_memory_func and
     MEMADDR is the address that we were trying to read.  INFO is a
     pointer to this struct.  */
static
void memory_error_func(
int status,
bfd_vma memaddr,
struct disassemble_info *info)
{
	printf("Unexpected call to stubbed out memory_error_func()\n");
}

/*
 * This is the routine called by Apple's otool(1)'s main() routine in otool.c
 * and is written as the glue between the otool(1) code and the GNU code.
 */
uint32_t
arm_disassemble(
char *sect,
uint32_t left,
uint32_t addr,
uint32_t sect_addr,
enum byte_sex object_byte_sex,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
uint32_t *indirect_symbols,
uint32_t nindirect_symbols,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_subtype_t cpusubtype,
enum bool verbose,
LLVMDisasmContextRef arm_dc,
LLVMDisasmContextRef thumb_dc,
char *object_addr,
uint32_t object_size,
struct data_in_code_entry *dices,
uint32_t ndices,
uint64_t seg_addr,
struct inst *inst,
struct inst *insts,
uint32_t ninsts)
{
    uint32_t bytes_consumed, pool_value, i, offset;

	dis_info.fprintf_func = (fprintf_ftype)fprintf;
  	dis_info.stream = stdout;
	dis_info.print_address_func = print_address_func;
	dis_info.print_immediate_func = print_immediate_func;

	dis_info.mach = 0;
	dis_info.bytes_per_line = 8;
	dis_info.bytes_per_chunk = 4;
	dis_info.display_endian = LITTLE_ENDIAN_BYTE_SEX;
	dis_info.symbol_at_address_func = symbol_at_address_func;
	dis_info.read_memory_func = read_memory_func;
	dis_info.memory_error_func = memory_error_func;
	dis_info.flags = 0;

	dis_info.verbose = verbose;
	dis_info.relocs = relocs;
	dis_info.nrelocs = nrelocs;
	dis_info.symbols = symbols;
	dis_info.nsymbols = nsymbols;
	dis_info.sorted_symbols = sorted_symbols;
	dis_info.nsorted_symbols = nsorted_symbols;
	dis_info.strings = strings;
	dis_info.strings_size = strings_size;
	dis_info.load_commands = load_commands;
	dis_info.object_byte_sex = object_byte_sex;
	dis_info.indirect_symbols = indirect_symbols;
	dis_info.nindirect_symbols = nindirect_symbols;
	dis_info.ncmds = ncmds;
	dis_info.sizeofcmds = sizeofcmds;

	dis_info.sect = sect;
	dis_info.left = left;
	dis_info.addr = addr;
	dis_info.sect_addr = sect_addr;

	dis_info.arm_dc = arm_dc;
	dis_info.thumb_dc = thumb_dc;

	dis_info.object_addr = object_addr;
	dis_info.object_size = object_size;

	dis_info.inst = inst;
	dis_info.insts = insts;
	dis_info.ninsts = ninsts;

	dis_info.demangled_name = NULL;

	/*
	 * If we have at least 4 bytes left, see if these 4 bytes are a pointer
	 * in a literal pool by calling print_immediate_func() with the 4 byte
	 * value and TRUE as the last argument to look for a section difference
	 * relocation entry for these 4 bytes as a possible pointer at this
	 * address.  If it does it will print a ".long a-b+offset" for these
	 * 4 bytes.
	 */
	if(left >= 4){
	    pool_value = sect[3] << 24 |
			 sect[2] << 16 |
			 sect[1] << 8 |
			 sect[0];
	    if(print_immediate_func(addr, pool_value, &dis_info, TRUE) == TRUE)
		return(4);
	}

	/*
	 * See if this address is has a data in code entry and if so print.
	 */
	if(ndices){
            /* Note: in final linked images, offset is from the base address */
            /* Note: in object files, offset is from first section address */
            if(nrelocs == 0) /* TODO better test for final linked image */
                offset = addr - seg_addr; 
            else
                offset = addr - sect_addr; 
            for(i = 0; i < ndices; i++){
                if(offset >= dices[i].offset &&
		   offset < dices[i].offset + dices[i].length){
		   bytes_consumed = print_data_in_code(sect, left,
				     dices[i].offset + dices[i].length - offset,
                                     dices[i].kind);
		   if ((dices[i].kind == DICE_KIND_JUMP_TABLE8) && 
		       (offset == (dices[i].offset + dices[i].length - 1)) &&
		       (dices[i].length & 1)) {
		     ++bytes_consumed;
		   }
		   return(bytes_consumed);
                }
            }
	}

	bytes_consumed = print_insn_little_arm(addr, &dis_info);
	if(!gflag || (inst != NULL && inst->print == TRUE))
	    printf("\n");

	return(bytes_consumed);
}

/* Set in_thumb accordingly:
 * If no symbols are at addr, don't change it.
 * If there are symbols at addr, and any of them are THUMB_DEFs, set it.
 * If there are symbols at addr, but none of them are THUMB_DEFs, clear it.
 */
static void
set_thumb_mode(
uint32_t addr,
uint32_t nsorted_symbols,
struct symbol *sorted_symbols,
enum bool *in_thumb)
{
    int32_t high, low, mid;
 
        low = 0;
        high = nsorted_symbols - 1; 
        mid = (high - low) / 2;
        while(high >= low){
            if(sorted_symbols[mid].n_value == addr){
		/* Find the first symbol at this address */
		while(mid && sorted_symbols[mid-1].n_value == addr){
		    mid--;
		}
		do{
		    if(sorted_symbols[mid].is_thumb){
			*in_thumb = TRUE;
			return;
		    }
		    mid++;
		    if(mid > nsorted_symbols ||
		       sorted_symbols[mid].n_value != addr){
			*in_thumb = FALSE;
			return;
		    }
		} while(1);
            }
            if(sorted_symbols[mid].n_value > addr){
                high = mid - 1;
                mid = (high + low) / 2;
            }
            else{
                low = mid + 1;
                mid = (high + low) / 2;
            }
        }
}
                                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/arm_disasm.h                          0100644 0001750 0001750 00000005714 12612724206 024073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <stuff/bytesex.h>
#import <mach-o/reloc.h>
#import <mach-o/nlist.h>
#import <stuff/bool.h>
#include "stuff/symbol.h"
#include "llvm-c/Disassembler.h"

/* Used by otool(1) to stay or switch out of thumb mode */
extern enum bool in_thumb;

extern uint32_t arm_disassemble(
    char *sect,
    uint32_t left,
    uint32_t addr,
    uint32_t sect_addr,
    enum byte_sex object_byte_sex,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_subtype_t cpu_subtype,
    enum bool verbose,
    LLVMDisasmContextRef arm_dc,
    LLVMDisasmContextRef thumb_dc,
    char *object_addr,
    uint32_t object_size,
    struct data_in_code_entry *dices,
    uint32_t ndices,
    uint64_t seg_addr,
    struct inst *inst,
    struct inst *insts,
    uint32_t ninsts);

extern LLVMDisasmContextRef create_arm_llvm_disassembler(
    cpu_subtype_t cpusubtype);
extern LLVMDisasmContextRef create_thumb_llvm_disassembler(
    cpu_subtype_t cpusubtype);
extern void delete_arm_llvm_disassembler(LLVMDisasmContextRef dc);
extern void delete_thumb_llvm_disassembler(LLVMDisasmContextRef dc);
                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/coff_print.c                          0100644 0001750 0001750 00000010233 12612724206 024070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <string.h>
#include "mach-o/loader.h"
#include "stuff/bytesex.h"
#include "dyld_bind_info.h"
#include "ofile_print.h"
#include "coff/base_relocs.h"
#include "coff/bytesex.h"

void
print_coff_reloc_section(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
uint32_t filetype,
enum byte_sex object_byte_sex,
char *object_addr,
uint32_t object_size,
enum bool verbose)
{
    char *sect, *p;
    uint64_t sect_addr, sect_size, size, seg_addr;
    int64_t left;
    struct relocation_info *sect_relocs;
    uint32_t sect_nrelocs, sect_flags, block_size;
    enum byte_sex host_byte_sex;
    enum bool swapped;
    struct base_relocation_block_header h;
    struct base_relocation_entry b;

	printf("Contents of (__RELOC,__reloc) section\n");
	if(get_sect_info("__RELOC", "__reloc", load_commands,
	    ncmds, sizeofcmds, filetype, object_byte_sex,
	    object_addr, object_size, &sect, &sect_size, &sect_addr,
	    &sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr) == TRUE){

	    host_byte_sex = get_host_byte_sex();
	    swapped = host_byte_sex != object_byte_sex;

	    p = sect;
	    left = sect_size;
	    while(left > 0){
		memset(&h, '\0', sizeof(struct base_relocation_block_header));
		size = left < sizeof(struct base_relocation_block_header) ?
		       left : sizeof(struct base_relocation_block_header);
		memcpy(&h, p, size);
		if(swapped)
		    swap_base_relocation_block_header(&h, host_byte_sex);
		printf("Page RVA   0x%08x\n", h.page_rva);
		printf("Block Size 0x%08x\n", h.block_size);

		p += sizeof(struct base_relocation_block_header);
		left -= sizeof(struct base_relocation_block_header);
		block_size = sizeof(struct base_relocation_block_header);
		while(block_size < h.block_size && left > 0){
		    memset(&b, '\0', sizeof(struct base_relocation_entry));
		    size = left < sizeof(struct base_relocation_entry) ?
			   left : sizeof(struct base_relocation_entry);
		    memcpy(&b, p, size);
		    if(swapped)
			swap_base_relocation_entry(&b, 1, host_byte_sex);
		    switch(b.type){
		    case IMAGE_REL_BASED_ABSOLUTE:
			printf("    Type   IMAGE_REL_BASED_ABSOLUTE\n");
			break;
		    case IMAGE_REL_BASED_HIGHLOW:
			printf("    Type   IMAGE_REL_BASED_HIGHLOW\n");
			break;
		    case IMAGE_REL_BASED_DIR64:
			printf("    Type   IMAGE_REL_BASED_DIR64\n");
			break;
		    default:
			printf("    Type   %u\n", b.type);
			break;
		    }
		    printf("    Offset 0x%0x\n", b.offset);

		    p += sizeof(struct base_relocation_entry);
		    left -= sizeof(struct base_relocation_entry);
		    block_size += sizeof(struct base_relocation_entry);
		}
	    }
	}
}
                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/cxa_demangle.h                        0100644 0001750 0001750 00000000153 12612724206 024353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        extern
char *
__cxa_demangle(
const char* mangled_name,
char *output_buffer,
size_t *length,
int *status);
                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/dyld_bind_info.c                      0100644 0001750 0001750 00000024636 12612724206 024716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <stdio.h>
#include <mach-o/loader.h>
#include <stuff/bool.h>
#include <stuff/allocate.h>
#include "dyld_bind_info.h"

const char *
bindTypeName(
uint8_t type)
{
        switch(type){
	    case BIND_TYPE_POINTER:
		return("pointer");
	    case BIND_TYPE_TEXT_ABSOLUTE32:
		return("text abs32");
	    case BIND_TYPE_TEXT_PCREL32:
		return("text rel32");
        }
        return("!!unknown!!");
}

const char *
ordinalName(
int libraryOrdinal,
const char **dylibs,
uint32_t ndylibs)
{
        switch(libraryOrdinal){
	    case BIND_SPECIAL_DYLIB_SELF:
		return("this-image");
	    case BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE:
		return("main-executable");
	    case BIND_SPECIAL_DYLIB_FLAT_LOOKUP:
		return("flat-namespace");
        }
        if(libraryOrdinal < BIND_SPECIAL_DYLIB_FLAT_LOOKUP)
	    return("unknown special ordinal");
        if(libraryOrdinal > ndylibs)
	    return("libraryOrdinal out of range");
        return(dylibs[libraryOrdinal-1]);
}

uint64_t
segStartAddress(
uint8_t segIndex,
struct segment_command **segs,
uint32_t nsegs,
struct segment_command_64 **segs64,
uint32_t nsegs64)
{
	if(segs != NULL){
	    if(segIndex > nsegs)
		return(0); /* throw "segment index out of range"; */
	    return(segs[segIndex]->vmaddr);
	}
	else {
	    if(segIndex > nsegs64)
		return(0); /* throw "segment index out of range"; */
	    return(segs64[segIndex]->vmaddr);
	}
}

const char *
segmentName(
uint8_t segIndex,
struct segment_command **segs,
uint32_t nsegs,
struct segment_command_64 **segs64,
uint32_t nsegs64)
{
	if(segs != NULL){
	    if(segIndex > nsegs)
		return("??"); /* throw "segment index out of range"; */
	    return(segs[segIndex]->segname);
	}
	else{
	    if(segIndex > nsegs64)
		return("??"); /* throw "segment index out of range"; */
	    return(segs64[segIndex]->segname);
	}
}

const char *
sectionName(
uint8_t segIndex,
uint64_t address,
struct segment_command **segs,
uint32_t nsegs,
struct segment_command_64 **segs64,
uint32_t nsegs64)
{
    struct section *s;
    struct section_64 *s64;
    uint32_t i;

	if(segs != NULL){
	    if(segIndex > nsegs)
		return("??"); /* throw "segment index out of range"; */
	    
	    s = (struct section *)((char *)segs[segIndex] + 
				   sizeof(struct segment_command));
	    for(i = 0; i < segs[segIndex]->nsects; i++){
		if(s->addr <= address && address < s->addr + s->size)
		    return(s->sectname);
		s++;
	    }
	}
	else{
	    if(segIndex > nsegs64)
		return("??"); /* throw "segment index out of range"; */
	    
	    s64 = (struct section_64 *)((char *)segs64[segIndex] + 
					sizeof(struct segment_command_64));
	    for(i = 0; i < segs64[segIndex]->nsects; i++){
		if(s64->addr <= address && address < s64->addr + s64->size)
		    return(s64->sectname);
		s64++;
	    }
	}
	return("??");
}

static
uint64_t
read_uleb128(
const uint8_t **pp,
const uint8_t* end)
{
    const uint8_t *p = *pp;
    uint64_t result = 0;
    int bit = 0;

        do{
	    if(p == end){
		*pp = p;
		return(0); /* throwf("malformed uleb128"); */
	    }

	    uint64_t slice = *p & 0x7f;

	    if(bit >= 64 || slice << bit >> bit != slice){
		*pp = p;
		return(0); /* throwf("uleb128 too big"); */
	    }
	    else {
		result |= (slice << bit);
		bit += 7;
	    }
        }while(*p++ & 0x80);
	*pp = p;
        return(result);
}

static
int64_t
read_sleb128(
const uint8_t **pp,
const uint8_t* end)
{
    const uint8_t *p = *pp;
    int64_t result = 0;
    int bit = 0;
    uint8_t byte;

        do{
	    if(p == end){
		*pp = p;
		return(0); /* throwf("malformed sleb128"); */
	    }
	    byte = *p++;
	    result |= (((int64_t)(byte & 0x7f)) << bit);
	    bit += 7;
        }while (byte & 0x80);
        // sign extend negative numbers
        if((byte & 0x40) != 0)
	    result |= (-1LL) << bit;
	*pp = p;
        return(result);
}

/*
 * get_dyld_bind_info() unpacks the dyld bind info from the data from an
 * LC_BIND_INFO load command pointed to by start through end into the internal
 * dyld_bind_info structs returned through dbi, and its count ndbi.  The array
 * of dylib names and their count are passed in in dylibs and ndylibs.  The
 * array of segments (either 32-bit with segs & nsegs or 64-bit segs64 & nsegs64)
 * are used to determine which sections the pointers are in.
 */
void
get_dyld_bind_info(
const uint8_t *start, /* inputs */
const uint8_t* end,
const char **dylibs,
uint32_t ndylibs,
struct segment_command **segs,
uint32_t nsegs,
struct segment_command_64 **segs64,
uint32_t nsegs64,
struct dyld_bind_info **dbi, /* output */
uint64_t *ndbi)
{
    const uint8_t *p;
    uint8_t type;
    uint8_t segIndex;
    uint64_t segOffset;
    const char* symbolName;
    const char* fromDylib;
    int libraryOrdinal;
    int64_t addend;
    uint32_t count;
    uint32_t skip;
    uint64_t segStartAddr;
    const char* segName;
    const char* typeName;
    const char* weak_import;
    enum bool done = FALSE;

    const char *sectName;
    uint32_t pass;
    uint64_t n;

    uint32_t sizeof_pointer;
    if(segs)
	sizeof_pointer = 4;
    else
	sizeof_pointer = 8;

    n = 0;
    for(pass = 1; pass <= 2; pass++){
	p = start;
	type = 0;
	segIndex = 0;
	segOffset = 0;
	symbolName = NULL;
	fromDylib = "??";
	libraryOrdinal = 0;
	addend = 0;
	segStartAddr = 0;
	segName = "??";
	typeName = "??";
	weak_import = "";
	done = FALSE;
	if(pass == 2){
	    *dbi = (struct dyld_bind_info *)
		  allocate(n * sizeof(struct dyld_bind_info));
	    *ndbi = n;
	    n = 0;
	}
	while(!done && (p < end)){
	    uint8_t immediate = *p & BIND_IMMEDIATE_MASK;
	    uint8_t opcode = *p & BIND_OPCODE_MASK;
	    ++p;
	    switch(opcode){
		case BIND_OPCODE_DONE:
		    done = TRUE;
		    break;
		case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
		    libraryOrdinal = immediate;
		    fromDylib = ordinalName(libraryOrdinal, dylibs, ndylibs);
		    break;
		case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
		    libraryOrdinal = read_uleb128(&p, end);
		    fromDylib = ordinalName(libraryOrdinal, dylibs, ndylibs);
		    break;
		case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
		    // the special ordinals are negative numbers
		    if(immediate == 0)
			libraryOrdinal = 0;
		    else {
			int8_t signExtended = BIND_OPCODE_MASK | immediate;
			libraryOrdinal = signExtended;
		    }
		    fromDylib = ordinalName(libraryOrdinal, dylibs, ndylibs);
		    break;
		case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
		    symbolName = (char*)p;
		    while(*p != '\0')
			++p;
		    ++p;
		    if((immediate & BIND_SYMBOL_FLAGS_WEAK_IMPORT) != 0)
			weak_import = " (weak import)";
		    else
			weak_import = "";
		    break;
		case BIND_OPCODE_SET_TYPE_IMM:
		    type = immediate;
		    typeName = bindTypeName(type);
		    break;
		case BIND_OPCODE_SET_ADDEND_SLEB:
		    addend = read_sleb128(&p, end);
		    break;
		case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
		    segIndex = immediate;
		    segStartAddr = segStartAddress(segIndex, segs, nsegs,
						   segs64, nsegs64);
		    segName = segmentName(segIndex, segs, nsegs,
					  segs64, nsegs64);
		    segOffset = read_uleb128(&p, end);
		    break;
		case BIND_OPCODE_ADD_ADDR_ULEB:
		    segOffset += read_uleb128(&p, end);
		    break;
		case BIND_OPCODE_DO_BIND:
		    sectName = sectionName(segIndex, segStartAddr + segOffset,
					   segs, nsegs, segs64, nsegs64);
		    if(pass == 2){
			(*dbi)[n].segname = segName;
			(*dbi)[n].sectname = sectName;
			(*dbi)[n].address = segStartAddr+segOffset;
			(*dbi)[n].bind_type = type;
			(*dbi)[n].addend = addend;
			(*dbi)[n].dylibname = fromDylib;
			(*dbi)[n].symbolname = symbolName;
			(*dbi)[n].weak_import = *weak_import != '\0';
		    }
		    n++;
		    segOffset += sizeof_pointer;
		    break;
		case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
		    sectName = sectionName(segIndex, segStartAddr + segOffset,
					   segs, nsegs, segs64, nsegs64);
		    if(pass == 2){
			(*dbi)[n].segname = segName;
			(*dbi)[n].sectname = sectName;
			(*dbi)[n].address = segStartAddr+segOffset;
			(*dbi)[n].bind_type = type;
			(*dbi)[n].addend = addend;
			(*dbi)[n].dylibname = fromDylib;
			(*dbi)[n].symbolname = symbolName;
			(*dbi)[n].weak_import = *weak_import != '\0';
		    }
		    n++;
		    segOffset += read_uleb128(&p, end) + sizeof_pointer;
		    break;
		case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
		    sectName = sectionName(segIndex, segStartAddr + segOffset,
					   segs, nsegs, segs64, nsegs64);
		    if(pass == 2){
			(*dbi)[n].segname = segName;
			(*dbi)[n].sectname = sectName;
			(*dbi)[n].address = segStartAddr+segOffset;
			(*dbi)[n].bind_type = type;
			(*dbi)[n].addend = addend;
			(*dbi)[n].dylibname = fromDylib;
			(*dbi)[n].symbolname = symbolName;
			(*dbi)[n].weak_import = *weak_import != '\0';
		    }
		    n++;
		    segOffset += immediate * sizeof_pointer + sizeof_pointer;
		    break;
		case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
		    count = read_uleb128(&p, end);
		    skip = read_uleb128(&p, end);
		    sectName = sectionName(segIndex, segStartAddr + segOffset,
					   segs, nsegs, segs64, nsegs64);
		    for (uint32_t i=0; i < count; ++i) {
			if(pass == 2){
			    (*dbi)[n].segname = segName;
			    (*dbi)[n].sectname = sectName;
			    (*dbi)[n].address = segStartAddr+segOffset;
			    (*dbi)[n].bind_type = type;
			    (*dbi)[n].addend = addend;
			    (*dbi)[n].dylibname = fromDylib;
			    (*dbi)[n].symbolname = symbolName;
			    (*dbi)[n].weak_import = *weak_import != '\0';
			}
			n++;
			segOffset += skip + sizeof_pointer;
		    }
		    break;
		default:
		    return; /* throwf("bad bind opcode %d", *p); */
	    }
	}	
    }

}

/*
 * print_dyld_bind_info() prints the internal expanded dyld bind information in
 * the same format as dyldinfo(1)'s -bind option.
 */
void
print_dyld_bind_info(
struct dyld_bind_info *dbi,
uint64_t ndbi)
{
    uint64_t n;

	printf("bind information:\n");
	printf("segment section          address        type    addend dylib"
	       "            symbol\n");
	for(n = 0; n < ndbi; n++){
	    printf("%-7s %-16.16s 0x%08llX %10s  %5lld %-16s %s%s\n",
		dbi[n].segname,
		dbi[n].sectname,
		dbi[n].address,
		bindTypeName(dbi[n].bind_type),
		dbi[n].addend,
		dbi[n].dylibname,
		dbi[n].symbolname,
		dbi[n].weak_import ? " (weak import)" : "");
	}
}

/*
 * get_dyld_bind_info_symbolname() is passed an address and the internal expanded
 * dyld bind information.  If the address is found its binding symbol name is
 * returned.  If not NULL.
 */
const char *
get_dyld_bind_info_symbolname(
uint64_t address,
struct dyld_bind_info *dbi,
uint64_t ndbi)
{
    uint64_t n;

	for(n = 0; n < ndbi; n++){
	    if(dbi[n].address == address)
		return(dbi[n].symbolname);
	}
	return(NULL);
}
                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/dyld_bind_info.h                      0100644 0001750 0001750 00000001472 12612724206 024714  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * The internal structure for the broken out bind info.
 */
struct dyld_bind_info {
    const char *segname;
    const char *sectname;
    uint64_t address;
    int bind_type;
    uint64_t addend;
    const char *dylibname;
    const char *symbolname;
    enum bool weak_import;
};

extern void get_dyld_bind_info(
    const uint8_t *start, /* inputs */
    const uint8_t *end,
    const char **dylibs,
    uint32_t ndylibs,
    struct segment_command **segs,
    uint32_t nsegs,
    struct segment_command_64 **segs64,
    uint32_t nsegs64,
    struct dyld_bind_info **dbi, /* outputs */
    uint64_t *ndbi);

extern void print_dyld_bind_info(
    struct dyld_bind_info *dbi,
    uint64_t ndbi);

extern const char * get_dyld_bind_info_symbolname(
    uint64_t address,
    struct dyld_bind_info *dbi,
    uint64_t ndbi);
                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/hppa_disasm.c                         0100644 0001750 0001750 00000050665 12612724206 024244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/hppa/reloc.h>
#include "stuff/symbol.h"
#include "stuff/bytesex.h"
#include "stuff/hppa.h"
#include "otool.h"
#include "dyld_bind_info.h"
#include "ofile_print.h"
#include "../as/hppa-opcode.h"

static char *add_conds[] = {"",",tr",",=",",<>",",<",",>=",",<=",",>",
                            ",nuv",",uv",",znv",",vnz",",sv",",nsv",",od",",ev"};
static char *comp_conds[] = {"",",tr",",=",",<>",",<",",>=",",<=",",>",
                            ",<<",",>>=",",<<=",",>>",",sv",",nsv",",od",",ev"};
static char *shift_conds[] = {"",",=",",<",",od",",tr",",<>",",>=",",ev"};

static char *unit_conds[] = {"",",tr",",??",",??",",sbz",",nbz",",shz",",nhz",
                            ",sdc",",ndc",",??",",??",",sbc",",nbc",",shc",",nhc"};
static char *short_cmplts[] = {"",",ma","",",mb"};
static char *stbys_a_cmplts[] = {",b",",e"};
static char *stbys_m_cmplts[] = {"",",m"};
static char *index_cmplts[] = {"",",m",",s",",sm"};

static char *fp_fmts[] = {",sgl",",dbl",",??",",quad"};
static char *fp_conds[] = {",false?",",false",",?",",!<=>",",=",",=T",",?=",",!<>",
                            ",!?>=",",<",",?<",",!>=",",!?>",",<=",",?<=",",!>",
			    ",!?<=",",>",",?>",",!<=",",!?<",",>=",",?>=",",!<",
			    ",!?=",",<>",",!=",",!=T",",!?",",<=>",",true?",",true"};

/* bug #41317 .... umeshv@NeXT.com Wed Jul 27 11:38:58 PDT 1994
* These parse ",cc" and encode "cc" in 2 bits at 20, where "cc" encoding is
* as given in Tables 5-8, 5-9. Refer to 'PA-RISC 1.1 Architecture and
* Instruction Set Reference Manual, Second Edition' for the tables.
*/
static char *store_cache_hint[] = {"", ",bc", "??", "??"};
static char *load_cache_hint[] = {"", ",co", "??", "??"};

/* This macro gets bit fields using HP's numbering (MSB = 0) */

#define GET_FIELD(X, FROM, TO) \
  (((X) >> (31 - (TO))) & ((1 << ((TO) - (FROM) + 1)) - 1))

	    
static void print_immediate(
    uint32_t value, 
    uint32_t pc,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

static uint32_t get_reloc(
    uint32_t pc,
    struct relocation_info *relocs,
    uint32_t nrelocs);


/*
 * Handles the wierd floating-point register specifications for the fmpyadd &
 * fmpsub instructions.  See page 6.22 of the Instruction Set Reference Manual
 * for an explanation of the voodoo below.
 */
static
void
print_multiple_fpreg(
int reg5,
int fmt)
{
	if(fmt){
	    printf("%%fr%d",reg5|16);
	    if(reg5 & 16)
		printf("r");
	}
	else
	    printf("%%fr%d",reg5);
}

uint32_t
hppa_disassemble(
char *sect,
uint32_t left,
uint32_t addr,
uint32_t sect_addr,
enum byte_sex object_byte_sex,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t opcode;
    unsigned int i, num, do_completers;
    char *format, c;
    int jbsr;
    uint32_t sect_offset;
    
	jbsr = 0;
	sect_offset = addr - sect_addr;
	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;

	if(left < sizeof(uint32_t)){
	   if(left != 0){
		memcpy(&opcode, sect, left);
		if(swapped)
		    opcode = SWAP_INT(opcode);
		printf(".long\t0x%08x\n", (unsigned int)opcode);
	   }
	   printf("(end of section)\n");
	   return(left);
	}

	memcpy(&opcode, sect, sizeof(uint32_t));
	if(swapped)
	    opcode = SWAP_INT(opcode);
	
	/* special-case for jbsr */
	if ( ((opcode & 0xfc00e000) == 0xe8000000) && 
	     (get_reloc(sect_offset, relocs, nrelocs) == HPPA_RELOC_JBSR) ) {
	     jbsr = 1;
	     i = NUMOPCODES-1;  /* jbsr is the last entry in the table */
	     }
        else {
	  /* search through the opcode table */
	  for(i=0; i<NUMOPCODES; ++i)
	  if ((opcode & pa_opcodes[i].mask) == pa_opcodes[i].match)
	    break;
          }
	
	if (i<NUMOPCODES) {
	  printf("%s",pa_opcodes[i].name);
	  format = pa_opcodes[i].args;
	  do_completers = 1;
	  while((c = *(format++))) {
	    if (do_completers && (!strchr ("cCY<?!-+&U>~nZFGM,lL3a", c))) {
	      printf("\t");
	      do_completers=0;
	      }
	    switch (c) {
	      case 'x' : printf("%%r%u",GET_FIELD(opcode, 11, 15)); break;
	      case 'b' : printf("%%r%u",GET_FIELD(opcode, 6, 10)); break;
	      case 't' : printf("%%r%u",GET_FIELD(opcode, 27, 31)); break;
	      case 'B' : if ((num = GET_FIELD(opcode, 16, 17)))
	                   printf(" %u,",num);
			 printf("%%r%u",GET_FIELD(opcode, 6, 10));
			 break;
	      case 'n' : if (opcode & 2) printf(",n");
			 break;
	      case '5'   : num = low_sign_ext(GET_FIELD(opcode,11,15),5);
	      		   printf("0x%x",num);
			   break;
	      case 'Z' : if (GET_FIELD(opcode, 26, 26)) printf(",m");
	                 break;
	      case 'S' : printf("%%sr%u",assemble_3(GET_FIELD(opcode,16,18)));
	                 break;
	      case '?' :
	      case '<' : printf("%s",comp_conds[GET_FIELD(opcode,16,18)<<1]);
			 break;
	      case '-' : printf("%s",comp_conds[GET_FIELD(opcode,16,19)]);
			 break;
	      case '~' :
	      case '>' : printf("%s",shift_conds[GET_FIELD(opcode,16,18)]);
			 break;
	      case 'U' : printf("%s",unit_conds[GET_FIELD(opcode,16,19)]);
			 break;
	      case 'C'  :printf("%s",short_cmplts[GET_FIELD(opcode,26,26) |
	                                         (GET_FIELD(opcode,18,18)<<1)]);
			 break;
	      case 'c'  :printf("%s",index_cmplts[GET_FIELD(opcode,26,26) |
	                                         (GET_FIELD(opcode,18,18)<<1)]);
			 break;
	      case '!' : printf("%s",add_conds[GET_FIELD(opcode,16,18)<<1]);
			 break;
	      case '+' : 
	      case '&' : printf("%s",add_conds[GET_FIELD(opcode,16,19)]);
			 break;
	      case 'j'  :
	      		 num = low_sign_ext(GET_FIELD(opcode,18,31),14);
			 print_immediate(num, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
			 break;
	      case 'w'   : num = sign_ext(assemble_12(GET_FIELD(opcode,19,29), 
	                                              GET_FIELD(opcode,31,31)),12);
			   num = addr+(num*4)+8;
			   print_immediate(num, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
			   break;
	      case 'z'   : 
	      case 'W'   : num = sign_ext(assemble_17(GET_FIELD(opcode,11,15),
	      					      GET_FIELD(opcode,19,29),
						      GET_FIELD(opcode,31,31)),17);
			   num*=4;
			   if (c=='W') num += addr+8;
			   if (jbsr) printf("0x%x",num);
			     else 
			   print_immediate(num, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
			   break;
	      case 'k'   : num = assemble_21(GET_FIELD(opcode,11,31))<<11;
			   print_immediate(num, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
			   break;
	      case 'i'   : num = low_sign_ext(GET_FIELD(opcode,18,31),11);
	      		   printf("0x%x",num);
			   break;
	      case 'T'   : num = 32 - GET_FIELD(opcode,27,31);
	      		   printf("%d",num);
			   break;
	      case 'p'   : num = 31 - GET_FIELD(opcode, 22, 26);
	      		   printf("%d",num);
			   break;
	      case 'P'   : printf("%d",GET_FIELD(opcode, 22, 26));
			   break;
	      case 'Q'   : printf("%d",GET_FIELD(opcode, 6, 10));
			   break;
	      case 'R'   : printf("%d",GET_FIELD(opcode, 11, 15));
			   break;
	      case 'r'   : printf("%d",GET_FIELD(opcode, 27, 31));
			   break;
	      case 'M'   : printf("%s",fp_conds[GET_FIELD(opcode, 27, 31)]);
	                   break;
	      case 'u'   : printf("%d",GET_FIELD(opcode,23,25));
	                   break;
	      case 'F'   : if (GET_FIELD(opcode,0,5)==0x0C)
	                     num = GET_FIELD(opcode, 19, 20);
			   else num = GET_FIELD(opcode,20,20);
			   printf("%s",fp_fmts[num]);
			   break;
	      case 'G'   : printf("%s",fp_fmts[GET_FIELD(opcode, 17, 18)]);
			   break;
	      case 'H'   : printf("%s",fp_fmts[1-GET_FIELD(opcode, 26, 26)]);
			   break;
	      case 'v'   : printf("%%fr%d",GET_FIELD(opcode,27,31));
	                   if (GET_FIELD(opcode,25,25)) printf("r");
	                   break;
	      case 'E'   : printf("%%fr%d",GET_FIELD(opcode,6,10));
	                   if (GET_FIELD(opcode,24,24)) printf("r");
	                   break;
	      case 'X'   : printf("%%fr%d",GET_FIELD(opcode,11,15));
	      		   if ((GET_FIELD(opcode,0,5)==0x0E) &&
			       (GET_FIELD(opcode,19,19))!=0) printf("r");
			   break;
	      case 'V'   : num=low_sign_ext(GET_FIELD(opcode,27,31),5);
	      		   printf("0x%x",num);
			   break;
	      case 'f'   : printf("%d",GET_FIELD(opcode, 23, 25));
	      		   break;
	      case '4'   : print_multiple_fpreg(GET_FIELD(opcode,6,10),
					       GET_FIELD(opcode,26,26));
			   break;
	      case '6'   : print_multiple_fpreg(GET_FIELD(opcode,11,15),
					       GET_FIELD(opcode,26,26));
			   break;
	      case '7'   : print_multiple_fpreg(GET_FIELD(opcode,16,20),
					       GET_FIELD(opcode,26,26));
			   break;
	      case '9'   : print_multiple_fpreg(GET_FIELD(opcode,21,25),
					       GET_FIELD(opcode,26,26));
			   break;
	      case '8'   : print_multiple_fpreg(GET_FIELD(opcode,27,31),
					       GET_FIELD(opcode,26,26));
			   break;
	      case 'o'   : printf("%d",GET_FIELD(opcode,6,20));
	                   break;
	      case 'O'   : num = (GET_FIELD(opcode, 6,20) << 5) |
			          GET_FIELD(opcode, 27, 31);
	                   printf("%d",num);
			   break;
	      case 'Y'   : printf("%s%s%s",stbys_a_cmplts[GET_FIELD(opcode,18,18)],
	                                  stbys_m_cmplts[GET_FIELD(opcode,26,26)],
                                    store_cache_hint[GET_FIELD(opcode,20,21)]);
			   break;
	      case 'D'   : printf("%d",GET_FIELD(opcode,6,31));
	      		   break;
	      case 'A'   : printf("%d",GET_FIELD(opcode,6,18));
	      		   break;
	      case '2'   : printf("%d",(GET_FIELD(opcode,6,22) << 5) |
			                GET_FIELD(opcode,27,31));
	      		   break;
	      case '1'   : printf("%d",(GET_FIELD(opcode,11,20) << 5) |
			                GET_FIELD(opcode,27,31));
	      		   break;
	      case '0'   : printf("%d",(GET_FIELD(opcode,16,20) << 5) |
			                GET_FIELD(opcode,27,31));
	      		   break;
	      case '@'   : print_immediate(sect_addr, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
			   break;
		  case 'l'   :printf("%s%s",short_cmplts[GET_FIELD(opcode,26,26) |
	                                         (GET_FIELD(opcode,18,18)<<1)],
                                    store_cache_hint[GET_FIELD(opcode,20,21)]);
		  		break;
		  case 'L'   :printf("%s%s",index_cmplts[GET_FIELD(opcode,26,26) |
	                                         (GET_FIELD(opcode,18,18)<<1)],
                                    load_cache_hint[GET_FIELD(opcode,20,21)]);
		  		break;
		  case '3'   :printf("%s%s",index_cmplts[GET_FIELD(opcode,26,26) |
	                                         (GET_FIELD(opcode,18,18)<<1)],
                                    store_cache_hint[GET_FIELD(opcode,20,21)]);
		  		break;
		  case 'a'   :printf("%s%s",short_cmplts[GET_FIELD(opcode,26,26) |
	                                         (GET_FIELD(opcode,18,18)<<1)],
                                    load_cache_hint[GET_FIELD(opcode,20,21)]);

		  		break;
	      default : printf("%c",c);
	      }
	    }
	  printf("\n");
	  }
	else {
	  printf(".long 0x%08x\n", (unsigned int)opcode);
	  }
       return 4;
}



static
void
print_immediate(
uint32_t value, 
uint32_t pc,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    int32_t reloc_found, offset;
    uint32_t i, r_address, r_symbolnum, r_type, r_extern,
		  r_value, r_scattered, pair_r_type, pair_r_value;
    uint32_t other_half;
    const char *name, *add, *sub;
    struct relocation_info *rp, *pairp;
    struct scattered_relocation_info *srp;

	r_symbolnum = 0;
	r_type = 0;
	r_extern = 0;
	r_value = 0;
	r_scattered = 0;
	other_half = 0;
	pair_r_value = 0;

	if(verbose == FALSE){
	    printf("0x%x", (unsigned int)value);
	    return;
	}
	reloc_found = 0;
	if(nrelocs != 0){
	    for(i = 0; i < nrelocs; i++){
		rp = &relocs[i];
		if(rp->r_address & R_SCATTERED){
		    srp = (struct scattered_relocation_info *)rp;
		    r_scattered = 1;
		    r_address = srp->r_address;
		    r_extern = 0;
		    r_type = srp->r_type;
		    r_value = srp->r_value;
		}
		else{
		    r_scattered = 0;
		    r_address = rp->r_address;
		    r_symbolnum = rp->r_symbolnum;
		    r_extern = rp->r_extern;
		    r_type = rp->r_type;
		}
		if(r_type == HPPA_RELOC_PAIR){
		    fprintf(stderr, "Stray HPPA_RELOC_PAIR relocation entry "
			    "%u\n", i);
		    continue;
		}
		if(r_address == pc){
		    if(r_type == HPPA_RELOC_HI21 ||
		       r_type == HPPA_RELOC_LO14 ||
		       r_type == HPPA_RELOC_BR17 ||
		       r_type == HPPA_RELOC_JBSR ||
		       r_type == HPPA_RELOC_SECTDIFF ||
		       r_type == HPPA_RELOC_HI21_SECTDIFF ||
		       r_type == HPPA_RELOC_LO14_SECTDIFF){
			if(i+1 < nrelocs){
			    pairp = &rp[1];
			    if(pairp->r_address & R_SCATTERED){
				srp = (struct scattered_relocation_info *)pairp;
				other_half = srp->r_address;
				pair_r_type = srp->r_type;
				pair_r_value = srp->r_value;
			    }
			    else{
				other_half = pairp->r_address;
				pair_r_type = pairp->r_type;
			    }
			    if(pair_r_type != HPPA_RELOC_PAIR){
				fprintf(stderr, "No HPPA_RELOC_PAIR relocation "
					"entry after entry %u\n", i);
				continue;
			    }
			}
		    }
		    reloc_found = 1;
		    break;
		}
		if(r_type == HPPA_RELOC_HI21 ||
		   r_type == HPPA_RELOC_LO14 ||
		   r_type == HPPA_RELOC_BR17 ||
		   r_type == HPPA_RELOC_JBSR ||
		   r_type == HPPA_RELOC_SECTDIFF ||
		   r_type == HPPA_RELOC_HI21_SECTDIFF ||
		   r_type == HPPA_RELOC_LO14_SECTDIFF){
		    if(i+1 < nrelocs){
			pairp = &rp[1];
			if(pairp->r_address & R_SCATTERED){
			    srp = (struct scattered_relocation_info *)pairp;
			    pair_r_type = srp->r_type;
			}
			else{
			    pair_r_type = pairp->r_type;
			}
			if(pair_r_type == HPPA_RELOC_PAIR)
			    i++;
			else
			    fprintf(stderr, "No HPPA_RELOC_PAIR relocation "
				    "entry after entry %u\n", i);
		    }
		}
	    }
	}

	if(reloc_found && r_extern == 1){
	    if((uint32_t)symbols[r_symbolnum].n_un.n_strx >= strings_size)
		name = "bad string offset";
	    else
		name = strings + symbols[r_symbolnum].n_un.n_strx;
	    switch(r_type){
	    case HPPA_RELOC_HI21:
		value += sign_ext(other_half,14);
		printf("L`%s", name);
		if (value) 
		  printf("+0x%x",(unsigned int)value);
		break;
	    case HPPA_RELOC_LO14:
		value += other_half<<11;
		printf("R`%s", name);
		if (value) 
		  printf("+0x%x",(unsigned int)value);
		break;
	    case HPPA_RELOC_BR17:
		/* word offset?  Check in the linker what happens here */
		value += other_half<<11;
		printf("R`%s", name);
		if (value) 
		  printf("+0x%x", (unsigned int)value);
		break;
	    case HPPA_RELOC_JBSR:
		printf("%s",name);
		if (other_half!=0)
		  printf("+0x%x",(unsigned int)sign_ext(other_half,24));
		break;
	    case HPPA_RELOC_BL17:
		/* for now, this falls through... */
	    default:
		printf("%s",name);
		if (value) printf("+0x%x",(unsigned int)value);
	    }
	    return;
	}

	offset = 0;
	if(reloc_found){
	    if(r_type == HPPA_RELOC_HI21 ||
	       r_type == HPPA_RELOC_HI21_SECTDIFF)
		value += sign_ext(other_half, 14);
	    else if(r_type == HPPA_RELOC_LO14 ||
		    r_type == HPPA_RELOC_LO14_SECTDIFF)
		value += other_half << 11;
	    else if(r_type == HPPA_RELOC_BR17)
		  /* word offset?  Check in the linker what happens here */
		  value += other_half << 11;
	    else if(r_type == HPPA_RELOC_JBSR)
	          value += sign_ext(other_half, 24);
	    if(r_scattered &&
	       (r_type != HPPA_RELOC_HI21_SECTDIFF &&
	        r_type != HPPA_RELOC_LO14_SECTDIFF)){
		offset = value - r_value;
		value = r_value;
	    }
	}

	if(reloc_found &&
	   (r_type == HPPA_RELOC_HI21_SECTDIFF ||
	    r_type == HPPA_RELOC_LO14_SECTDIFF)){
	    if(r_type == HPPA_RELOC_HI21_SECTDIFF)
		printf("L`");
	    else
		printf("R`");
	    add = guess_symbol(r_value, sorted_symbols,
			       nsorted_symbols, verbose);
	    sub = guess_symbol(pair_r_value, sorted_symbols,
			       nsorted_symbols, verbose);
	    offset = value - (r_value - pair_r_value);
	    if(add != NULL)
		printf("%s", add);
	    else
		printf("0x%x", (unsigned int)r_value);
	    if(sub != NULL)
		printf("-%s", sub);
	    else
		printf("-0x%x", (unsigned int)pair_r_value);
	    if(offset != 0)
		printf("+0x%x", (unsigned int)offset);
	    return;
	}

	name = guess_symbol(value, sorted_symbols,
			    nsorted_symbols, verbose);
	if(name != NULL){
	    if(reloc_found){
		switch(r_type){
		case HPPA_RELOC_HI21:
		    printf("L`%s", name);
		    if(offset != 0)
			printf("+0x%x", (unsigned int)offset);
		    break;
		case HPPA_RELOC_LO14:
		case HPPA_RELOC_BR17:
		    printf("R`%s", name);
		    if(offset != 0)
			printf("+0x%x", (unsigned int)offset);
		    break;
		default:
		    printf("%s", name);
		    if(offset != 0)
			printf("+0x%x",(unsigned int)offset);
		    break;
		}
	    }
	    else{
		printf("%s", name);
		if(offset != 0)
		    printf("+0x%x", (unsigned int)offset);
	    }
	    return;
	}

	if(reloc_found){
	    if(r_type == HPPA_RELOC_HI21 ||
	       r_type == HPPA_RELOC_HI21_SECTDIFF)
		printf("L`0x%x", (unsigned int)value);
	    else if(r_type == HPPA_RELOC_LO14 ||
		    r_type == HPPA_RELOC_LO14_SECTDIFF ||
		    r_type == HPPA_RELOC_BR17)
		printf("R`0x%x", (unsigned int)value);
	    else
		printf("0x%x", (unsigned int)value);
	}
        else
	    printf("0x%x", (unsigned int)value);
	if(offset != 0)
	    printf("+0x%x", (unsigned int)offset);

	return;
}

/*
 * To handle the jsbr type instruction, we have to search for a reloc
 * of type HPPA_RELOC_JBSR whenever a bl type instruction is encountered.
 * If such a reloc type exists at the correct pc, then we have to print out
 * jbsr instead of bl.  This routine uses the logic from above to loop though
 * the relocs and give the r_type for the particular address.
 */
static
uint32_t
get_reloc(
uint32_t pc,
struct relocation_info *relocs,
uint32_t nrelocs)
{
    uint32_t i;
    struct relocation_info *rp;
    uint32_t r_type, r_address;
  
	for(i = 0; i < nrelocs; i++){
	    rp = &relocs[i];
	    if(rp->r_address & R_SCATTERED){
		r_type = ((struct scattered_relocation_info *)rp)->r_type;
		r_address = ((struct scattered_relocation_info *)rp)->r_address;
	    }
	    else{
		r_type = rp->r_type;
		r_address = rp->r_address;
	    }
	    if(r_type == HPPA_RELOC_PAIR)
		continue;
	    if(r_address == pc)
		return(r_type);
	}
	return(0xffffffff);
}
                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/hppa_disasm.h                         0100644 0001750 0001750 00000004131 12612724206 024234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <stuff/bytesex.h>
#import <mach-o/reloc.h>
#import <mach-o/nlist.h>
#import <stuff/bool.h>
#include "stuff/symbol.h"

extern uint32_t hppa_disassemble(
    char *sect,
    uint32_t left,
    uint32_t addr,
    uint32_t sect_addr,
    enum byte_sex object_byte_sex,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);
                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/i386_disasm.c                         0100644 0001750 0001750 00000513213 12612724206 023776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * This file contains the i386 disassembler routine used at NeXT Computer, Inc.
 * to match the the assembler used at NeXT.  It was addapted from a set of
 * source files with the following copyright which is retained below.
 */
/*
  Copyright 1988, 1989 by Intel Corporation, Santa Clara, California.

		All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appears in all
copies and that both the copyright notice and this permission notice
appear in supporting documentation, and that the name of Intel
not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.

INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/x86_64/reloc.h>
#include "stuff/symbol.h"
#include "stuff/bytesex.h"
#include "stuff/llvm.h"
#include "stuff/allocate.h"
#include "otool.h"
#include "dyld_bind_info.h"
#include "ofile_print.h"
#include "i386_disasm.h"
#include "cxa_demangle.h"

#define MAX_MNEMONIC	16	/* Maximum number of chars per mnemonic, plus a byte for '\0' */
#define MAX_RESULT	14	/* Maximum number of char in a register */
				/*  result expression "(%ebx,%ecx,8)" */

#define WBIT(x)	(x & 0x1)		/* to get w bit	*/
#define REGNO(x) (x & 0x7)		/* to get 3 bit register */
#define VBIT(x)	((x)>>1 & 0x1)		/* to get 'v' bit */
#define OPSIZE(data16,wbit,maybe64) ((wbit) ? ((data16) ? 2: ((maybe64) ? 8 : 4)) : 1 )
#define REX_W(x) (((x) & 0x8) == 0x8)	/* true if the REX.W bit is set --> 64-bit operand size */
#define REX_R(x) (((x) & 0x4) == 0x4)	/* true if the REX.R bit is set --> ModRM reg extension */
#define REX_X(x) (((x) & 0x2) == 0x2)	/* true if the REX.X bit is set --> SIB index extension */
#define REX_B(x) (((x) & 0x1) == 0x1)	/* true if the REX.B bit is set --> ModRM r/m, SIB base, or opcode reg extension */

#define REG_ONLY 3	/* mode indicates a single register with	*/
			/* no displacement is an operand		*/
#define BYTEOPERAND 0	/* value of the w-bit indicating a byte		*/
			/* operand (1-byte)				*/
#define LONGOPERAND 1	/* value of the w-bit indicating a long		*/
			/* operand (2-bytes or 4-bytes)			*/
#define EBP 5
#define ESP 4

/*
 * This is the structure that is used for storing all the op code information.
 */
struct instable {
    char name[MAX_MNEMONIC];
    const struct instable *indirect;
    unsigned adr_mode;
    int flags;
    const struct instable *arch64;
};
#define	TERM	0	/* used to indicate that the 'indirect' field of the */
			/* 'instable' terminates - no pointer.	*/
#define	INVALID	{"",TERM,UNKNOWN,0}
/*
 * These are defined this way to make the initializations in the tables simpler
 * and more readable for differences between 32-bit and 64-bit architectures.
 */
#define	INVALID_32 "",TERM,UNKNOWN,0
static const struct instable op_invalid_64 = {"",TERM,/* UNKNOWN */0,0};
#define INVALID_64 (&op_invalid_64)

/* Flags */
#define HAS_SUFFIX			0x1	/* For instructions which may have a 'w', 'l', or 'q' suffix */
#define IS_POINTER_SIZED	0x2	/* For instructions which implicitly have operands which are sizeof(void *) */

static void get_operand(
    const char **symadd,
    const char **symsub,
    uint32_t *value,
    uint32_t *value_size,
    char *result,
    const cpu_type_t cputype,
    const uint32_t mode,
    const uint32_t r_m,
    const uint32_t wbit,
    const enum bool data16,
    const enum bool addr16,
    const enum bool sse2,
    const enum bool mmx,
    const unsigned int rex,
    const char *sect,
    uint32_t sect_addr,
    uint32_t *length,
    uint32_t *left,
    const uint32_t addr,
    const struct relocation_info *sorted_relocs,
    const uint32_t nsorted_relocs,
    const struct relocation_info *ext_relocs,
    const uint32_t next_relocs,
    const struct nlist *symbols,
    const struct nlist_64 *symbols64,
    const uint32_t nsymbols,
    const char *strings,
    const uint32_t strings_size,
    const struct symbol *sorted_symbols,
    const uint32_t nsorted_symbols,
    const enum bool verbose);

static void immediate(
    const char **symadd,
    const char **symsub,
    uint64_t *value,
    uint32_t value_size,
    const char *sect,
    uint32_t sect_addr,
    uint32_t *length,
    uint32_t *left,
    const cpu_type_t cputype,
    const uint32_t addr,
    const struct relocation_info *sorted_relocs,
    const uint32_t nsorted_relocs,
    const struct relocation_info *ext_relocs,
    const uint32_t next_relocs,
    const struct nlist *symbols,
    const struct nlist_64 *symbols64,
    const uint32_t nsymbols,
    const char *strings,
    const uint32_t strings_size,
    const struct symbol *sorted_symbols,
    const uint32_t nsorted_symbols,
    const enum bool verbose);

static void displacement(
    const char **symadd,
    const char **symsub,
    uint64_t *value,
    const uint32_t value_size,
    const char *sect,
    uint64_t sect_addr,
    uint32_t *length,
    uint32_t *left,
    const cpu_type_t cputype,
    const uint64_t addr,
    const struct relocation_info *sorted_relocs,
    const uint32_t nsorted_relocs,
    const struct relocation_info *ext_relocs,
    const uint32_t next_relocs,
    const struct nlist *symbols,
    const struct nlist_64 *symbols64,
    const uint32_t nsymbols,
    const char *strings,
    const uint32_t strings_size,
    const struct symbol *sorted_symbols,
    const uint32_t nsorted_symbols,
    const enum bool verbose);

static void get_symbol(
    const char **symadd,
    const char **symsub,
    uint64_t *offset,
    const cpu_type_t cputype,
    const uint32_t sect_offset,
    const uint32_t seg_offset,
    const uint64_t value,
    const struct relocation_info *relocs,
    const uint32_t nrelocs,
    const struct relocation_info *ext_relocs,
    const uint32_t next_relocs,
    const struct nlist *symbols,
    const struct nlist_64 *symbols64,
    const uint32_t nsymbols,
    const char *strings,
    const uint32_t strings_size,
    const struct symbol *sorted_symbols,
    const uint32_t nsorted_symbols,
    const enum bool verbose);

static void print_operand(
    const char *seg,
    const char *symadd,
    const char *symsub,
    uint64_t value,
    unsigned int value_size,
    const char *result,
    const char *tail);

static uint64_t get_value(
    const uint32_t size,
    const char *sect,
    uint32_t *length,
    uint32_t *left);

static void modrm_byte(
    uint32_t *mode,
    uint32_t *reg,
    uint32_t *r_m,
    unsigned char byte);

#define GET_OPERAND(symadd, symsub, value, value_size, result) \
	get_operand((symadd), (symsub), (value), (value_size), (result), \
		    cputype, mode, r_m, wbit, data16, addr16, sse2, mmx, rex, \
		    sect, sect_addr, &length, &left, addr, sorted_relocs, \
		    nsorted_relocs, ext_relocs, next_relocs, symbols, \
		    symbols64, nsymbols, strings, strings_size, \
		    sorted_symbols, nsorted_symbols, verbose)

#define DISPLACEMENT(symadd, symsub, value, value_size) \
	displacement((symadd), (symsub), (value), (value_size), sect, \
		     sect_addr, &length, &left, cputype, addr, sorted_relocs, \
		     nsorted_relocs, ext_relocs, next_relocs, symbols, \
		     symbols64, nsymbols, strings, strings_size, \
		     sorted_symbols, nsorted_symbols, verbose)

#define IMMEDIATE(symadd, symsub, value, value_size) \
	immediate((symadd), (symsub), (value), (value_size), sect, sect_addr, \
		  &length, &left, cputype, addr, sorted_relocs, \
		  nsorted_relocs, ext_relocs, next_relocs, symbols, symbols64, \
		  nsymbols, strings, strings_size, sorted_symbols, \
		  nsorted_symbols, verbose)

#define GET_SYMBOL(symadd, symsub, offset, sect_offset, seg_offset, value) \
	get_symbol((symadd), (symsub), (offset), cputype, (sect_offset), \
		   (seg_offset), (value), sorted_relocs, nsorted_relocs, \
		   ext_relocs, next_relocs, symbols, symbols64, nsymbols, \
		   strings, strings_size, sorted_symbols, nsorted_symbols, \
		   verbose)

#define GUESS_SYMBOL(value) \
	guess_symbol((value), sorted_symbols, nsorted_symbols, verbose)

/*
 * These are the instruction formats as they appear in the disassembly tables.
 * Here they are given numerical values for use in the actual disassembly of
 * an instruction.
 */
#define UNKNOWN	0
#define MRw	2
#define IMlw	3
#define IMw	4
#define IR	5
#define OA	6
#define AO	7
#define MS	8
#define SM	9
#define Mv	10
#define Mw	11
#define M	12
#define R	13
#define RA	14
#define SEG	15
#define MR	16
#define IA	17
#define MA	18
#define SD	19
#define AD	20
#define SA	21
#define D	22
#define INM	23
#define SO	24
#define BD	25
#define I	26
#define P	27
#define V	28
#define DSHIFT	29 /* for double shift that has an 8-bit immediate */
#define U	30
#define OVERRIDE 31
#define GO_ON	32
#define O	33	/* for call	*/
#define JTAB	34	/* jump table (not used at NeXT) */
#define IMUL	35	/* for 186 iimul instr  */
#define CBW 36 /* so that data16 can be evaluated for cbw and its variants */
#define MvI	37	/* for 186 logicals */
#define ENTER	38	/* for 186 enter instr  */
#define RMw	39	/* for 286 arpl instr */
#define Ib	40	/* for push immediate byte */
#define F	41	/* for 287 instructions */
#define FF	42	/* for 287 instructions */
#define DM	43	/* 16-bit data */
#define AM	44	/* 16-bit addr */
#define LSEG	45	/* for 3-bit seg reg encoding */
#define MIb	46	/* for 386 logicals */
#define SREG	47	/* for 386 special registers */
#define PREFIX	48	/* an instruction prefix like REP, LOCK */
#define INT3	49	/* The int 3 instruction, which has a fake operand */
#define DSHIFTcl 50	/* for double shift that implicitly uses %cl */
#define CWD	51	/* so that data16 can be evaluated for cwd and vars */
#define RET	52	/* single immediate 16-bit operand */
#define MOVZ	53	/* for movs and movz, with different size operands */
#define XINST	54	/* for cmpxchg and xadd */
#define BSWAP	55	/* for bswap */
#define Pi	56
#define Po	57
#define Vi	58
#define Vo	59
#define Mb	60
#define INMl	61
#define SSE2	62	/* SSE2 instruction with possible 3rd opcode byte */
#define SSE2i	63	/* SSE2 instruction with 8-bit immediate */
#define SSE2i1	64	/* SSE2 with one operand and 8-bit immediate */
#define SSE2tm	65	/* SSE2 with dest to memory */
#define SSE2tfm	66	/* SSE2 with dest to memory or memory to dest */
#define PFCH	67	/* prefetch instructions */
#define SFEN	68	/* sfence & clflush */
#define Mnol	69	/* no 'l' suffix, fildl, fistpl */
#define AMD3DNOW       70  /* 3DNow! instruction (SSE2 format with a suffix) */
#define PFCH3DNOW      71  /* 3DNow! prefetch instruction */
#define REX	72		/* 64-bit REX prefix */
#define IR64 73		/* IR with a 64-bit immediate if REX.W is set */
#define MNI 74		/* MNI instruction, differentiated by 2nd and 3rd opcode bytes */
#define MNIi 75		/* MNI instruction with 8-bit immediate, differentiated by 2nd and 3rd opcode bytes */
#define SSE4	76	/* SSE4 instruction with 3rd & 4th opcode bytes */
#define SSE4i	77	/* SSE4 instruction with 8-bit immediate */
#define SSE4itm	78	/* SSE4 with dest to memory and 8-bit immediate */
#define SSE4ifm	79	/* SSE4 with src from memory and 8-bit immediate */
#define SSE4MRw	80	/* SSE4.2 memory or register operand to register */
#define SSE4CRC	81	/* SSE4.2 crc memory or register operand to register */
#define SSE4CRCb	82	/* SSE4.2 crc byte memory or register operand to register */

/*
 * In 16-bit addressing mode:
 * Register operands may be indicated by a distinguished field.
 * An '8' bit register is selected if the 'w' bit is equal to 0,
 * and a '16' bit register is selected if the 'w' bit is equal to
 * 1 and also if there is no 'w' bit.
 */
static const char * const REG16[8][2] = {
/* w bit		0		1		*/
/* reg bits */
/* 000	*/		{"%al",		"%ax"},
/* 001  */		{"%cl",		"%cx"},
/* 010  */		{"%dl",		"%dx"},
/* 011	*/		{"%bl",		"%bx"},
/* 100	*/		{"%ah",		"%sp"},
/* 101	*/		{"%ch",		"%bp"},
/* 110	*/		{"%dh",		"%si"},
/* 111	*/		{"%bh",		"%di"}
};

/*
 * In 32-bit or 64-bit addressing mode:
 * Register operands may be indicated by a distinguished field.
 * An '8' bit register is selected if the 'w' bit is equal to 0,
 * and a '32' bit register is selected if the 'w' bit is equal to
 * 1 and also if there is no 'w' bit.
 */
static const char * const REG32[16][3] = {
/* w bit		0				1			1 + REX.W	*/
/* reg bits */
/* 0000	*/		{"%al",			"%eax",			"%rax"},
/* 0001  */		{"%cl",			"%ecx",			"%rcx"},
/* 0010  */		{"%dl",			"%edx",			"%rdx"},
/* 0011	*/		{"%bl",			"%ebx",			"%rbx"},
/* 0100	*/		{"%ah",			"%esp",			"%rsp"},
/* 0101	*/		{"%ch",			"%ebp",			"%rbp"},
/* 0110	*/		{"%dh",			"%esi",			"%rsi"},
/* 0111	*/		{"%bh",			"%edi",			"%rdi"},
/* 1000	*/		{"%r8b",		"%r8d",			"%r8"},
/* 1001 */		{"%r9b",		"%r9d",			"%r9"},
/* 1010 */		{"%r10b",		"%r10d",		"%r10"},
/* 1011	*/		{"%r11b",		"%r11d",		"%r11"},
/* 1100	*/		{"%r12b",		"%r12d",		"%r12"},
/* 1101	*/		{"%r13b",		"%r13d",		"%r13"},
/* 1110	*/		{"%r14b",		"%r14d",		"%r14"},
/* 1111	*/		{"%r15b",		"%r15d",		"%r15"}
};

/* For SSE4CRCb (i.e. crc32) instruction the byte regs when there is a REX */
static const char * const REG64_BYTE[16] = {
/* 0 */ "%al",
/* 1 */ "%cl",
/* 2 */ "%dl",
/* 3 */ "%bl",
/* 4 */ "%spl",
/* 5 */ "%bpl",
/* 6 */ "%sil",
/* 7 */ "%dil",
/* 8 */ "%r8b",
/* 9 */ "%r9b",
/* 10 */"%r10b",
/* 11 */"%r11b",
/* 12 */"%r12b",
/* 13 */"%r13b",
/* 14 */"%r14b",
/* 15 */"%r15b"
};

/*
 * In 16-bit mode:
 * This initialized array will be indexed by the 'r/m' and 'mod'
 * fields, to determine the size of the displacement in each mode.
 */
static const char dispsize16 [8][4] = {
/* mod		00	01	10	11 */
/* r/m */
/* 000 */	{0,	1,	2,	0},
/* 001 */	{0,	1,	2,	0},
/* 010 */	{0,	1,	2,	0},
/* 011 */	{0,	1,	2,	0},
/* 100 */	{0,	1,	2,	0},
/* 101 */	{0,	1,	2,	0},
/* 110 */	{2,	1,	2,	0},
/* 111 */	{0,	1,	2,	0}
};

/*
 * In 32-bit mode:
 * This initialized array will be indexed by the 'r/m' and 'mod'
 * fields, to determine the size of the displacement in this mode.
 */
static const char dispsize32 [8][4] = {
/* mod		00	01	10	11 */
/* r/m */
/* 000 */	{0,	1,	4,	0},
/* 001 */	{0,	1,	4,	0},
/* 010 */	{0,	1,	4,	0},
/* 011 */	{0,	1,	4,	0},
/* 100 */	{0,	1,	4,	0},
/* 101 */	{4,	1,	4,	0},
/* 110 */	{0,	1,	4,	0},
/* 111 */	{0,	1,	4,	0}
};

/*
 * When data16 has been specified, the following array specifies the registers
 * for the different addressing modes.  Indexed first by mode, then by register
 * number.
 */
static const char * const regname16[4][8] = {
/*reg  000        001        010        011        100    101   110     111 */
/*mod*/
/*00*/{"%bx,%si", "%bx,%di", "%bp,%si", "%bp,%di", "%si", "%di", "",    "%bx"},
/*01*/{"%bx,%si", "%bx,%di", "%bp,%si", "%bp,%di", "%si", "%di", "%bp", "%bx"},
/*10*/{"%bx,%si", "%bx,%di", "%bp,%si", "%bp,%di", "%si", "%di", "%bp", "%bx"},
/*11*/{"%ax",     "%cx",     "%dx",     "%bx",     "%sp", "%bp", "%si", "%di"}
};

/*
 * When data16 has not been specified, fields, to determine the addressing mode,
 * and will also provide strings for printing.
 */
static const char * const regname32[4][8] = {
/*reg   000     001     010     011     100     101    110     111 */
/*mod*/
/*00 */{"%eax", "%ecx", "%edx", "%ebx", "%esp", "",     "%esi", "%edi"},
/*01 */{"%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi"},
/*10 */{"%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi"},
/*11 */{"%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi"}
};

/*
 * When data16 has not been specified, fields, to determine the addressing mode,
 * and will also provide strings for printing.
 */
static const char * const regname64[4][16] = {
/*reg   0000    0001    0010    0011    0100    0101    0110    0111    1000    1001    1010    1011    1100    1101    1110    1111 */
/*mod*/
/*00 */{"%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi", "%r8",  "%r9",  "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"},
/*01 */{"%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi", "%r8",  "%r9",  "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"},
/*10 */{"%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi", "%r8",  "%r9",  "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"},
/*11 */{"%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi", "%r8",  "%r9",  "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"}
};

/*
 * If r/m==100 then the following byte (the s-i-b byte) must be decoded
 */
static const char * const scale_factor[4] = {
    "1",
    "2",
    "4",
    "8"
};

static const char * const indexname[8] = {
    ",%eax",
    ",%ecx",
    ",%edx",
    ",%ebx",
    "",
    ",%ebp",
    ",%esi",
    ",%edi"
};

static const char * const indexname64[16] = {
    ",%rax",
    ",%rcx",
    ",%rdx",
    ",%rbx",
    "",
    ",%rbp",
    ",%rsi",
    ",%rdi",
	",%r8",
	",%r9",
	",%r10",
	",%r11",
	",%r12",
	",%r13",
	",%r14",
	",%r15"
};

/*
 * Segment registers are selected by a two or three bit field.
 */
static const char * const SEGREG[8] = {
/* 000 */	"%es",
/* 001 */	"%cs",
/* 010 */	"%ss",
/* 011 */	"%ds",
/* 100 */	"%fs",
/* 101 */	"%gs",
/* 110 */	"%?6",
/* 111 */	"%?7",
};

/*
 * Special Registers
 */
static const char * const DEBUGREG[] = {
	"%db0", "%db1", "%db2", "%db3", "%db4", "%db5", "%db6", "%db7",
	"%db8", "%db9", "%db10", "%db11", "%db12", "%db13", "%db14", "%db15"
};

static const char * const LLVM_MC_DEBUGREG[] = {
	"%dr0", "%dr1", "%dr2", "%dr3", "%dr4", "%dr5", "%dr6", "%dr7",
	"%db8", "%db9", "%db10", "%db11", "%db12", "%db13", "%db14", "%db15"
};

static const char * const CONTROLREG[] = {
	"%cr0", "%cr1", "%cr2", "%cr3", "%cr4", "%cr5", "%cr6", "%cr7",
	"%cr8", "%cr9", "%cr10", "%cr11", "%cr12", "%cr13", "%cr14", "%cr15"
};

static const char * const LLVM_MC_32_CONTROLREG[] = {
	"%ecr0", "%ecr1", "%ecr2", "%ecr3", "%ecr4", "%ecr5", "%ecr6", "%ecr7",
	"%ecr8", "%ecr9", "%ecr10", "%ecr11", "%ecr12", "%ecr13", "%ecr14",
	"%ecr15"
};

static const char * const LLVM_MC_64_CONTROLREG[] = {
	"%rcr0", "%rcr1", "%rcr2", "%rcr3", "%rcr4", "%rcr5", "%rcr6", "%rcr7",
	"%rcr8", "%rcr9", "%rcr10", "%rcr11", "%rcr12", "%rcr13", "%rcr14",
	"%rcr15"
};

static const char * const TESTREG[8] = {
    "%tr0", "%tr1", "%tr2", "%tr3", "%tr4", "%tr5", "%tr6", "%tr7"
};

/*
 * Decode table for 0x0F00 opcodes
 */
static const struct instable op0F00[8] = {
/*  [0]  */	{"sldt",TERM,M,0},	{"str",TERM,M,0},
		{"lldt",TERM,M,0},	{"ltr",TERM,M,0},
/*  [4]  */	{"verr",TERM,M,0},	{"verw",TERM,M,0},
		INVALID,		INVALID,
};


/*
 * Decode table for 0x0F01 opcodes
 */
static const struct instable op0F01[8] = {
/*  [0]  */	{"sgdt",TERM,M,1},	{"sidt",TERM,M,1},
		{"lgdt",TERM,M,1},	{"lidt",TERM,M,1},
/*  [4]  */	{"smsw",TERM,M,0},	INVALID,
		{"lmsw",TERM,M,0},	{"invlpg",TERM,M,0},
};

/*
 * Decode table for 0x0F38 opcodes
 */
static const struct instable op0F38[256] = {
/*  [00]  */	{"pshufb",TERM,MNI,0},	{"phaddw",TERM,MNI,0},
		{"phaddd",TERM,MNI,0},	{"phaddsw",TERM,MNI,0},
/*  [04]  */	{"pmaddubsw",TERM,MNI,0},	{"phsubw",TERM,MNI,0},
		{"phsubd",TERM,MNI,0},	{"phsubsw",TERM,MNI,0},
/*  [08]  */	{"psignb",TERM,MNI,0},	{"psignw",TERM,MNI,0},
		{"psignd",TERM,MNI,0},	{"pmulhrsw",TERM,MNI,0},
/*  [0C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [10]  */	{"pblendvb",TERM,SSE4,0},	INVALID,
		INVALID,	INVALID,
/*  [14]  */	{"blendvps",TERM,SSE4,0},{"blendvpd",TERM,SSE4,0},
		INVALID,	{"ptest",TERM,SSE4,0},
/*  [18]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [1C]  */	{"pabsb",TERM,MNI,0},	{"pabsw",TERM,MNI,0},
		{"pabsd",TERM,MNI,0},	INVALID,
/*  [20]  */	{"pmovsxbw",TERM,SSE4,0},	{"pmovsxbd",TERM,SSE4,0},
		{"pmovsxbq",TERM,SSE4,0},	{"pmovsxwd",TERM,SSE4,0},
/*  [24]  */	{"pmovsxwq",TERM,SSE4,0},	{"pmovsxdq",TERM,SSE4,0},
		INVALID,	INVALID,
/*  [28]  */	{"pmuldq",TERM,SSE4,0},		{"pcmpeqq",TERM,SSE4,0},
		{"movntdqa",TERM,SSE4,0},	{"packusdw",TERM,SSE4,0},
/*  [2C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [30]  */	{"pmovzxbw",TERM,SSE4,0},	{"pmovzxbd",TERM,SSE4,0},
		{"pmovzxbq",TERM,SSE4,0},	{"pmovzxwd",TERM,SSE4,0},
/*  [34]  */	{"pmovzxwq",TERM,SSE4,0},	{"pmovzxdq",TERM,SSE4,0},
		INVALID,	{"pcmpgtq",TERM,SSE4,0},
/*  [38]  */	{"pminsb",TERM,SSE4,0},	{"pminsd",TERM,SSE4,0},
		{"pminuw",TERM,SSE4,0},	{"pminud",TERM,SSE4,0},
/*  [3C]  */	{"pmaxsb",TERM,SSE4,0},	{"pmaxsd",TERM,SSE4,0},
		{"pmaxuw",TERM,SSE4,0},	{"pmaxud",TERM,SSE4,0},
/*  [40]  */	{"pmulld",TERM,SSE4,0},	{"phminposuw",TERM,SSE4,0},
		INVALID,	INVALID,
/*  [44]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [48]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [4C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [50]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [54]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [58]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [5C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [60]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [64]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [68]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [6C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [70]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [74]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [78]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [7C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [80]  */	{"invept",TERM,MR,0}, {"invvpid",TERM,MR,0},
		INVALID,	INVALID,
/*  [84]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [88]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [8C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [90]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [94]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [98]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [9C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [A0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [A4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [A8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [AC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [B0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [B4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [B8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [BC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [C0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [C4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [C8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [CC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [D0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [D4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [D8]  */	INVALID,	INVALID,
		INVALID,	{"aesimc",TERM,SSE4,0},
/*  [DC]  */	{"aesenc",TERM,SSE4,0}, {"aesenclast",TERM,SSE4,0},
		{"aesdec",TERM,SSE4,0},	{"aesdeclast",TERM,SSE4,0},
/*  [E0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [E4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [E8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [EC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [F0]  */	{"crc32b",TERM,SSE4CRCb,0},	{"crc32",TERM,SSE4CRC,1},
		INVALID,	INVALID,
/*  [F4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [F8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [FC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
};

/*
 * Decode table for 0x0F3A opcodes
 */
static const struct instable op0F3A[224] = {
/*  [00]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [04]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [08]  */	{"roundps",TERM,SSE4i,0},	{"roundpd",TERM,SSE4i,0},
		{"roundss",TERM,SSE4i,0},	{"roundsd",TERM,SSE4i,0},
/*  [0C]  */	{"blendps",TERM,SSE4i,0},	{"blendpd",TERM,SSE4i,0},
		{"pblendw",TERM,SSE4i,0},	{"palignr",TERM,MNIi,0},
/*  [10]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [14]  */	{"pextrb",TERM,SSE4itm,0},	{"pextrw",TERM,SSE4itm,0},
		{"pextr",TERM,SSE4itm,0},	{"extractps",TERM,SSE4itm,0},
/*  [18]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [1C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [20]  */	{"pinsrb",TERM,SSE4ifm,0},	{"insertps",TERM,SSE4i,0},
		{"pinsr",TERM,SSE4ifm,0},	INVALID,
/*  [24]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [28]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [2C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [30]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [34]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [38]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [3C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [40]  */	{"dpps",TERM,SSE4i,0},	{"dppd",TERM,SSE4i,0},
		{"mpsadbw",TERM,SSE4i,0},	INVALID,
/*  [44]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [48]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [4C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [50]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [54]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [58]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [5C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [60]  */	{"pcmpestrm",TERM,SSE4i,0},	{"pcmpestri",TERM,SSE4i,0},
		{"pcmpistrm",TERM,SSE4i,0},	{"pcmpistri",TERM,SSE4i,0},
/*  [64]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [68]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [6C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [70]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [74]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [78]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [7C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [80]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [84]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [88]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [8C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [90]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [94]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [98]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [9C]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [A0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [A4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [A8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [AC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [B0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [B4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [B8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [BC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [C0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [C4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [C8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [CC]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [D0]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [D4]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [D8]  */	INVALID,	INVALID,
		INVALID,	INVALID,
/*  [DC]  */	INVALID,	INVALID,
		INVALID,	{"aeskeygenassist",TERM,SSE4i,0},
};

static const struct instable op_monitor = {"monitor",TERM,GO_ON,0};
static const struct instable op_mwait   = {"mwait",TERM,GO_ON,0};
static const struct instable op_rdtscp   = {"rdtscp",TERM,GO_ON,0};

/* These opcode tables entries are only used for the 64-bit architecture */
static const struct instable op_swapgs = {"swapgs",TERM,GO_ON,0};
static const struct instable op_syscall = {"syscall",TERM,GO_ON,0};
static const struct instable op_sysret = {"sysret",TERM,GO_ON,0};
static const struct instable opREX = {"",TERM,REX,0};
static const struct instable op_movsl = {"movsl",TERM,MOVZ,1};

/*
 * Decode table for 0x0F0F opcodes
 * Unlike the other decode tables, this one maps suffixes.
 */
static const struct instable op0F0F[16][16] = {
/*  [00]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [04]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [08]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [0C]  */   {"pi2fw",TERM,AMD3DNOW,0},      {"pi2fd",TERM,AMD3DNOW,0},
               INVALID,        INVALID },
/*  [10]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [14]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [18]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [1C]  */   {"pf2iw",TERM,AMD3DNOW,0},      {"pf2id",TERM,AMD3DNOW,0},
               INVALID,        INVALID },
/*  [20]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [24]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [28]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [2C]  */   INVALID,        INVALID,
               INVALID,        INVALID, },
/*  [30]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [34]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [38]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [3C]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [40]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [44]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [48]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [4C]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [50]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [54]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [58]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [5C]  */   INVALID,        INVALID,
               INVALID,        INVALID, },
/*  [60]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [64]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [68]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [6C]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [70]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [74]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [78]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [7C]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [80]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [84]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [88]  */   INVALID,        INVALID,
               {"pfnacc",TERM,AMD3DNOW,0},     INVALID,
/*  [8C]  */   INVALID,        INVALID,
               {"pfpnacc",TERM,AMD3DNOW,0},    INVALID },
/*  [90]  */ {  {"pfcmpge",TERM,AMD3DNOW,0},   INVALID,
               INVALID,        INVALID,
/*  [94]  */   {"pfmin",TERM,AMD3DNOW,0},      INVALID,
               {"pfrcp",TERM,AMD3DNOW,0},      {"pfrsqrt",TERM,AMD3DNOW,0},
/*  [98]  */   INVALID,        INVALID,
               {"pfsub",TERM,AMD3DNOW,0},      INVALID,
/*  [9C]  */   INVALID,        INVALID,
               {"pfadd",TERM,AMD3DNOW,0},      INVALID },
/*  [A0]  */ {  {"pfcmpgt",TERM,AMD3DNOW,0},   INVALID,
               INVALID,        INVALID,
/*  [A4]  */   {"pfmax",TERM,AMD3DNOW,0},      INVALID,
               {"pfrcpit1",TERM,AMD3DNOW,0},   {"pfrsqit1",TERM,AMD3DNOW,0},
/*  [A8]  */   INVALID,        INVALID,
               {"pfsubr",TERM,AMD3DNOW,0},     INVALID,
/*  [AC]  */   INVALID,        INVALID,
               {"pfacc",TERM,AMD3DNOW,0},      INVALID },
/*  [B0]  */ {  {"pfcmpeq",TERM,AMD3DNOW,0},   INVALID,
               INVALID,        INVALID,
/*  [B4]  */   {"pfmul",TERM,AMD3DNOW,0},      INVALID,
               {"pfrcpit2",TERM,AMD3DNOW,0},   {"pmulhrw",TERM,AMD3DNOW,0},
/*  [B8]  */   INVALID,        INVALID,
               INVALID,        {"pswapd",TERM,AMD3DNOW,0},
/*  [BC]  */   INVALID,        INVALID,
               INVALID,        {"pavgusb",TERM,AMD3DNOW,0} },
/*  [C0]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [C4]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [C8]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [CC]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [D0]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [D4]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [D8]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [DC]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [E0]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [E4]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [E8]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [EC]  */   INVALID,        INVALID,
               INVALID,        INVALID },
/*  [F0]  */ {  INVALID,       INVALID,
               INVALID,        INVALID,
/*  [F4]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [F8]  */   INVALID,        INVALID,
               INVALID,        INVALID,
/*  [FC]  */   INVALID,        INVALID,
               INVALID,        INVALID },
};

/*
 * Decode table for 0x0FBA opcodes
 */
static const struct instable op0FBA[8] = {
/*  [0]  */	INVALID,		INVALID,
		INVALID,		INVALID,
/*  [4]  */	{"bt",TERM,MIb,1},	{"bts",TERM,MIb,1},
		{"btr",TERM,MIb,1},	{"btc",TERM,MIb,1},
};

/*
 * Decode table for 0x0FAE opcodes
 */
static const struct instable op0FAE[8] = {
/*  [0]  */	{"fxsave",TERM,M,0},	{"fxrstor",TERM,M,0},
		{"ldmxcsr",TERM,M,0},	{"stmxcsr",TERM,M,0},
/*  [4]  */	INVALID,		{"lfence",TERM,GO_ON,0},
		{"mfence",TERM,GO_ON,0},{"clflush",TERM,SFEN,0},
};

/*
 * Decode table for 0x0F opcodes
 */
static const struct instable op0F[16][16] = {
/*  [00]  */ {  {"",op0F00,TERM,0},	{"",op0F01,TERM,0},
		{"lar",TERM,MR,0},	{"lsl",TERM,MR,0},
/*  [04]  */	INVALID,		{INVALID_32,&op_syscall},
		{"clts",TERM,GO_ON,0},  {INVALID_32,&op_sysret},
/*  [08]  */	{"invd",TERM,GO_ON,0},	{"wbinvd",TERM,GO_ON,0},
		INVALID,		{"ud2",TERM,GO_ON,0},
/*  [0C]  */	INVALID,                {"prefetch",TERM,PFCH3DNOW,1},
		{"femms",TERM,GO_ON,0},
				{"",(const struct instable *)op0F0F,TERM,0} },
/*  [10]  */ {  {"mov",TERM,SSE2,0},	{"mov",TERM,SSE2tm,0},
		{"mov",TERM,SSE2,0},	{"movl",TERM,SSE2tm,0},
/*  [14]  */	{"unpckl",TERM,SSE2,0},	{"unpckh",TERM,SSE2,0},
		{"mov",TERM,SSE2,0},	{"movh",TERM,SSE2tm,0},
/*  [18]  */	{"prefetch",TERM,PFCH,1},INVALID,
		INVALID,		INVALID,
/*  [1C]  */	INVALID,		INVALID,
		INVALID,		{"nop",TERM,M,1} },
/*  [20]  */ {  {"mov",TERM,SREG,0x03},	{"mov",TERM,SREG,0x03},
		{"mov",TERM,SREG,0x03},	{"mov",TERM,SREG,0x03},
/*  [24]  */	{"mov",TERM,SREG,0x03},	INVALID,
		{"mov",TERM,SREG,0x03},	INVALID,
/*  [28]  */	{"mova",TERM,SSE2,0},	{"mova",TERM,SSE2tm,0},
		{"cvt",TERM,SSE2,0},	{"movnt",TERM,SSE2tm,0},
/*  [2C]  */	{"cvt",TERM,SSE2,0},	{"cvt",TERM,SSE2,0} ,
		{"ucomi",TERM,SSE2,0},	{"comi",TERM,SSE2,0} },
/*  [30]  */ {  {"wrmsr",TERM,GO_ON,0},	{"rdtsc",TERM,GO_ON,0},
		{"rdmsr",TERM,GO_ON,0},	{"rdpmc",TERM,GO_ON,0},
/*  [34]  */	{"sysenter",TERM,GO_ON,0},{"sysexit",TERM,GO_ON,0},
		INVALID,		INVALID,
/*  [38]  */	{"",op0F38,TERM,0},		INVALID,
		{"",op0F3A,TERM,0},		INVALID,
/*  [3C]  */	INVALID,		INVALID,
		INVALID,		INVALID },
/*  [40]  */ {  {"cmovo",TERM,MRw,1},	{"cmovno",TERM,MRw,1},
		{"cmovb",TERM,MRw,1},	{"cmovae",TERM,MRw,1},
/*  [44]  */	{"cmove",TERM,MRw,1},	{"cmovne",TERM,MRw,1},
		{"cmovbe",TERM,MRw,1},	{"cmova",TERM,MRw,1},
/*  [48]  */	{"cmovs",TERM,MRw,1},	{"cmovns",TERM,MRw,1},
		{"cmovp",TERM,MRw,1},	{"cmovnp",TERM,MRw,1},
/*  [4C]  */	{"cmovl",TERM,MRw,1},	{"cmovge",TERM,MRw,1},
		{"cmovle",TERM,MRw,1},	{"cmovg",TERM,MRw,1} },
/*  [50]  */ {  {"movmsk",TERM,SSE2,0},	{"sqrt",TERM,SSE2,0},
		{"rsqrt",TERM,SSE2,0},	{"rcp",TERM,SSE2,0},
/*  [54]  */	{"and",TERM,SSE2,0},	{"andn",TERM,SSE2,0},
		{"or",TERM,SSE2,0},	{"xor",TERM,SSE2,0},
/*  [58]  */	{"add",TERM,SSE2,0},	{"mul",TERM,SSE2,0},
		{"cvt",TERM,SSE2,0},	{"cvt",TERM,SSE2,0},
/*  [5C]  */	{"sub",TERM,SSE2,0},	{"min",TERM,SSE2,0},
		{"div",TERM,SSE2,0},	{"max",TERM,SSE2,0} },
/*  [60]  */ {  {"punpcklbw",TERM,SSE2,0},{"punpcklwd",TERM,SSE2,0},
		{"punpckldq",TERM,SSE2,0},{"packsswb",TERM,SSE2,0},
/*  [64]  */	{"pcmpgtb",TERM,SSE2,0},{"pcmpgtw",TERM,SSE2,0},
		{"pcmpgtd",TERM,SSE2,0},{"packuswb",TERM,SSE2,0},
/*  [68]  */	{"punpckhbw",TERM,SSE2,0},{"punpckhwd",TERM,SSE2,0},
		{"punpckhdq",TERM,SSE2,0},{"packssdw",TERM,SSE2,0},
/*  [6C]  */	{"punpckl",TERM,SSE2,0},{"punpckh",TERM,SSE2,0},
		{"movd",TERM,SSE2,0},	{"mov",TERM,SSE2,0} },
/*  [70]  */ {  {"pshu",TERM,SSE2i,0},	{"ps",TERM,SSE2i1,0},
		{"ps",TERM,SSE2i1,0},	{"ps",TERM,SSE2i1,0},
/*  [74]  */	{"pcmpeqb",TERM,SSE2,0},{"pcmpeqw",TERM,SSE2,0},
		{"pcmpeqd",TERM,SSE2,0},{"emms",TERM,GO_ON,0},
/*  [78]  */	{"vmread",TERM,RMw,0},  {"vmwrite",TERM,MRw,0},
		INVALID,		INVALID,
/*  [7C]  */	{"haddp",TERM,SSE2,0},  {"hsubp",TERM,SSE2,0},
		{"mov",TERM,SSE2tfm,0},	{"mov",TERM,SSE2tm,0} },
/*  [80]  */ {  {"jo",TERM,D,0x02},	{"jno",TERM,D,0x02},
		{"jb",TERM,D,0x02},	{"jae",TERM,D,0x02},
/*  [84]  */	{"je",TERM,D,0x02},	{"jne",TERM,D,0x02},
		{"jbe",TERM,D,0x02},	{"ja",TERM,D,0x02},
/*  [88]  */	{"js",TERM,D,0x02},	{"jns",TERM,D,0x02},
		{"jp",TERM,D,0x02},	{"jnp",TERM,D,0x02},
/*  [8C]  */	{"jl",TERM,D,0x02},	{"jge",TERM,D,0x02},
		{"jle",TERM,D,0x02},	{"jg",TERM,D,0x02} },
/*  [90]  */ {  {"seto",TERM,Mb,0},	{"setno",TERM,Mb,0},
		{"setb",TERM,Mb,0},	{"setae",TERM,Mb,0},
/*  [94]  */	{"sete",TERM,Mb,0},	{"setne",TERM,Mb,0},
		{"setbe",TERM,Mb,0},	{"seta",TERM,Mb,0},
/*  [98]  */	{"sets",TERM,Mb,0},	{"setns",TERM,Mb,0},
		{"setp",TERM,Mb,0},	{"setnp",TERM,Mb,0},
/*  [9C]  */	{"setl",TERM,Mb,0},	{"setge",TERM,Mb,0},
		{"setle",TERM,Mb,0},	{"setg",TERM,Mb,0} },
/*  [A0]  */ {  {"push",TERM,LSEG,0x03},{"pop",TERM,LSEG,0x03},
		{"cpuid",TERM,GO_ON,0},	{"bt",TERM,RMw,1},
/*  [A4]  */	{"shld",TERM,DSHIFT,1},	{"shld",TERM,DSHIFTcl,1},
		INVALID,		INVALID,
/*  [A8]  */	{"push",TERM,LSEG,0x03},{"pop",TERM,LSEG,0x03},
		{"rsm",TERM,GO_ON,0, INVALID_64}, {"bts",TERM,RMw,1},
/*  [AC]  */	{"shrd",TERM,DSHIFT,1},	{"shrd",TERM,DSHIFTcl,1},
		{"",op0FAE,TERM,0},	{"imul",TERM,MRw,1} },
/*  [B0]  */ {  {"cmpxchgb",TERM,XINST,0},{"cmpxchg",TERM,XINST,1},
		{"lss",TERM,MR,0},	{"btr",TERM,RMw,1},
/*  [B4]  */	{"lfs",TERM,MR,0},	{"lgs",TERM,MR,0},
		{"movzb",TERM,MOVZ,1},	{"movzw",TERM,MOVZ,1},
/*  [B8]  */	{"popcnt",TERM,SSE4MRw,0},		INVALID,
		{"",op0FBA,TERM,0},	{"btc",TERM,RMw,1},
/*  [BC]  */	{"bsf",TERM,MRw,1},	{"bsr",TERM,MRw,1},
		{"movsb",TERM,MOVZ,1},	{"movsw",TERM,MOVZ,1} },
/*  [C0]  */ {  {"xaddb",TERM,XINST,0},	{"xadd",TERM,XINST,1},
		{"cmp",TERM,SSE2i,0},	{"movnti",TERM,RMw,0},
/*  [C4]  */	{"pinsrw",TERM,SSE2i,0},{"pextrw",TERM,SSE2i,0},
		{"shuf",TERM,SSE2i,0},	{"cmpxchg8b",TERM,M,0},
/*  [C8]  */	{"bswap",TERM,BSWAP,0},	{"bswap",TERM,BSWAP,0},
		{"bswap",TERM,BSWAP,0},	{"bswap",TERM,BSWAP,0},
/*  [CC]  */	{"bswap",TERM,BSWAP,0},	{"bswap",TERM,BSWAP,0},
		{"bswap",TERM,BSWAP,0},	{"bswap",TERM,BSWAP,0} },
/*  [D0]  */ {  {"addsubp",TERM,SSE2,0},{"psrlw",TERM,SSE2,0},
		{"psrld",TERM,SSE2,0},	{"psrlq",TERM,SSE2,0},
/*  [D4]  */	{"paddq",TERM,SSE2,0},	{"pmullw",TERM,SSE2,0},
		{"mov",TERM,SSE2tm,0},	{"pmovmskb",TERM,SSE2,0},
/*  [D8]  */	{"psubusb",TERM,SSE2,0},{"psubusw",TERM,SSE2,0},
		{"pminub",TERM,SSE2,0},	{"pand",TERM,SSE2,0},
/*  [DC]  */	{"paddusb",TERM,SSE2,0},{"paddusw",TERM,SSE2,0},
		{"pmaxub",TERM,SSE2,0},	{"pandn",TERM,SSE2,0} },
/*  [E0]  */ {  {"pavgb",TERM,SSE2,0},	{"psraw",TERM,SSE2,0},
		{"psrad",TERM,SSE2,0},	{"pavgw",TERM,SSE2,0},
/*  [E4]  */	{"pmulhuw",TERM,SSE2,0},{"pmulhw",TERM,SSE2,0},
		{"cvt",TERM,SSE2,0},	{"movn",TERM,SSE2tm,0},
/*  [E8]  */	{"psubsb",TERM,SSE2,0},	{"psubsw",TERM,SSE2,0},
		{"pminsw",TERM,SSE2,0},	{"por",TERM,SSE2,0},
/*  [EC]  */	{"paddsb",TERM,SSE2,0},	{"paddsw",TERM,SSE2,0},
		{"pmaxsw",TERM,SSE2,0},	{"pxor",TERM,SSE2,0} },
/*  [F0]  */ {  {"lddqu",TERM,SSE2,0},	{"psllw",TERM,SSE2,0},
		{"pslld",TERM,SSE2,0},	{"psllq",TERM,SSE2,0},
/*  [F4]  */	{"pmuludq",TERM,SSE2,0},{"pmaddwd",TERM,SSE2,0},
		{"psadbw",TERM,SSE2,0},	{"maskmov",TERM,SSE2,0},
/*  [F8]  */	{"psubb",TERM,SSE2,0},	{"psubw",TERM,SSE2,0},
		{"psubd",TERM,SSE2,0},	{"psubq",TERM,SSE2,0},
/*  [FC]  */	{"paddb",TERM,SSE2,0},	{"paddw",TERM,SSE2,0},
		{"paddd",TERM,SSE2,0},	INVALID },
};

/*
 * Decode table for 0x80 opcodes
 */
static const struct instable op80[8] = {
/*  [0]  */	{"addb",TERM,IMlw,0},	{"orb",TERM,IMw,0},
		{"adcb",TERM,IMlw,0},	{"sbbb",TERM,IMlw,0},
/*  [4]  */	{"andb",TERM,IMw,0},	{"subb",TERM,IMlw,0},
		{"xorb",TERM,IMw,0},	{"cmpb",TERM,IMlw,0},
};

/*
 * Decode table for 0x81 opcodes.
 */
static const struct instable op81[8] = {
/*  [0]  */	{"add",TERM,IMlw,1},	{"or",TERM,IMw,1},
		{"adc",TERM,IMlw,1},	{"sbb",TERM,IMlw,1},
/*  [4]  */	{"and",TERM,IMw,1},	{"sub",TERM,IMlw,1},
		{"xor",TERM,IMw,1},	{"cmp",TERM,IMlw,1},
};

/*
 * Decode table for 0x82 opcodes.
 */
static const struct instable op82[8] = {
/*  [0]  */	{"addb",TERM,IMlw,0},	INVALID,
		{"adcb",TERM,IMlw,0},	{"sbbb",TERM,IMlw,0},
/*  [4]  */	INVALID,		{"subb",TERM,IMlw,0},
		INVALID,		{"cmpb",TERM,IMlw,0},
};

/*
 * Decode table for 0x83 opcodes.
 */
static const struct instable op83[8] = {
/*  [0]  */	{"add",TERM,IMlw,1},	{"or",TERM,IMlw,1},
		{"adc",TERM,IMlw,1},	{"sbb",TERM,IMlw,1},
/*  [4]  */	{"and",TERM,IMlw,1},	{"sub",TERM,IMlw,1},
		{"xor",TERM,IMlw,1},	{"cmp",TERM,IMlw,1},
};

/*
 * Decode table for 0xC0 opcodes.
 */
static const struct instable opC0[8] = {
/*  [0]  */	{"rolb",TERM,MvI,0},	{"rorb",TERM,MvI,0},
		{"rclb",TERM,MvI,0},	{"rcrb",TERM,MvI,0},
/*  [4]  */	{"shlb",TERM,MvI,0},	{"shrb",TERM,MvI,0},
		INVALID,		{"sarb",TERM,MvI,0},
};

/*
 * Decode table for 0xD0 opcodes.
 */
static const struct instable opD0[8] = {
/*  [0]  */	{"rolb",TERM,Mv,0},	{"rorb",TERM,Mv,0},
		{"rclb",TERM,Mv,0},	{"rcrb",TERM,Mv,0},
/*  [4]  */	{"shlb",TERM,Mv,0},	{"shrb",TERM,Mv,0},
		INVALID,		{"sarb",TERM,Mv,0},
};

/*
 * Decode table for 0xC1 opcodes.
 * 186 instruction set
 */
static const struct instable opC1[8] = {
/*  [0]  */	{"rol",TERM,MvI,1},	{"ror",TERM,MvI,1},
		{"rcl",TERM,MvI,1},	{"rcr",TERM,MvI,1},
/*  [4]  */	{"shl",TERM,MvI,1},	{"shr",TERM,MvI,1},
		INVALID,		{"sar",TERM,MvI,1},
};

/*
 * Decode table for 0xD1 opcodes.
 */
static const struct instable opD1[8] = {
/*  [0]  */	{"rol",TERM,Mv,1},	{"ror",TERM,Mv,1},
		{"rcl",TERM,Mv,1},	{"rcr",TERM,Mv,1},
/*  [4]  */	{"shl",TERM,Mv,1},	{"shr",TERM,Mv,1},
		INVALID,		{"sar",TERM,Mv,1},
};

/*
 * Decode table for 0xD2 opcodes.
 */
static const struct instable opD2[8] = {
/*  [0]  */	{"rolb",TERM,Mv,0},	{"rorb",TERM,Mv,0},
		{"rclb",TERM,Mv,0},	{"rcrb",TERM,Mv,0},
/*  [4]  */	{"shlb",TERM,Mv,0},	{"shrb",TERM,Mv,0},
		INVALID,		{"sarb",TERM,Mv,0},
};

/*
 * Decode table for 0xD3 opcodes.
 */
static const struct instable opD3[8] = {
/*  [0]  */	{"rol",TERM,Mv,1},	{"ror",TERM,Mv,1},
		{"rcl",TERM,Mv,1},	{"rcr",TERM,Mv,1},
/*  [4]  */	{"shl",TERM,Mv,1},	{"shr",TERM,Mv,1},
		INVALID,		{"sar",TERM,Mv,1},
};

/*
 * Decode table for 0xF6 opcodes.
 */
static const struct instable opF6[8] = {
/*  [0]  */	{"testb",TERM,IMw,0},	INVALID,
		{"notb",TERM,Mw,0},	{"negb",TERM,Mw,0},
/*  [4]  */	{"mulb",TERM,MA,0},	{"imulb",TERM,MA,0},
		{"divb",TERM,MA,0},	{"idivb",TERM,MA,0},
};

/*
 * Decode table for 0xF7 opcodes.
 */
static const struct instable opF7[8] = {
/*  [0]  */	{"test",TERM,IMw,1},	INVALID,
		{"not",TERM,Mw,1},	{"neg",TERM,Mw,1},
/*  [4]  */	{"mul",TERM,MA,1},	{"imul",TERM,MA,1},
		{"div",TERM,MA,1},	{"idiv",TERM,MA,1},
};

/*
 * Decode table for 0xFE opcodes.
 */
static const struct instable opFE[8] = {
/*  [0]  */	{"incb",TERM,Mw,0},	{"decb",TERM,Mw,0},
		INVALID,		INVALID,
/*  [4]  */	INVALID,		INVALID,
		INVALID,		INVALID,
};

/*
 * Decode table for 0xFF opcodes.
 */
static const struct instable opFF[8] = {
/*  [0]  */	{"inc",TERM,Mw,1},	{"dec",TERM,Mw,1},
		{"call",TERM,INM,1},	{"lcall",TERM,INMl,1},
/*  [4]  */	{"jmp",TERM,INM,1},	{"ljmp",TERM,INMl,1},
		{"push",TERM,M,0x03},	INVALID,
};

/* for 287 instructions, which are a mess to decode */
static const struct instable opFP1n2[8][8] = {
/* bit pattern:	1101 1xxx MODxx xR/M */
/*  [0,0]  */ { {"fadds",TERM,M,0},	{"fmuls",TERM,M,0},
		{"fcoms",TERM,M,0},	{"fcomps",TERM,M,0},
/*  [0,4]  */	{"fsubs",TERM,M,0},	{"fsubrs",TERM,M,0},
		{"fdivs",TERM,M,0},	{"fdivrs",TERM,M,0} },
/*  [1,0]  */ { {"flds",TERM,M,0},	INVALID,
		{"fsts",TERM,M,0},	{"fstps",TERM,M,0},
/*  [1,4]  */	{"fldenv",TERM,M,1},	{"fldcw",TERM,M,0},
		{"fnstenv",TERM,M,1},	{"fnstcw",TERM,M,0} },
/*  [2,0]  */ { {"fiaddl",TERM,M,0},	{"fimull",TERM,M,0},
		{"ficoml",TERM,M,0},	{"ficompl",TERM,M,0},
/*  [2,4]  */	{"fisubl",TERM,M,0},	{"fisubrl",TERM,M,0},
		{"fidivl",TERM,M,0},	{"fidivrl",TERM,M,0} },
/*  [3,0]  */ { {"fildl",TERM,Mnol,0},	{"fisttpl",TERM,M,0},
		{"fistl",TERM,M,0},	{"fistpl",TERM,Mnol,0},
/*  [3,4]  */	INVALID,		{"fldt",TERM,M,0},
		INVALID,		{"fstpt",TERM,M,0} },
/*  [4,0]  */ { {"faddl",TERM,M,0},	{"fmull",TERM,M,0},
		{"fcoml",TERM,M,0},	{"fcompl",TERM,M,0},
/*  [4,1]  */	{"fsubl",TERM,M,0},	{"fsubrl",TERM,M,0},
		{"fdivl",TERM,M,0},	{"fdivrl",TERM,M,0} },
/*  [5,0]  */ { {"fldl",TERM,M,0},	{"fisttpll",TERM,M,0},
		{"fstl",TERM,M,0},	{"fstpl",TERM,M,0},
/*  [5,4]  */	{"frstor",TERM,M,1},	INVALID,
		{"fnsave",TERM,M,1},	{"fnstsw",TERM,M,0} },
/*  [6,0]  */ { {"fiadds",TERM,M,0},	{"fimuls",TERM,M,0},
		{"ficoms",TERM,M,0},	{"ficomps",TERM,M,0},
/*  [6,4]  */	{"fisubs",TERM,M,0},	{"fisubrs",TERM,M,0},
		{"fidivs",TERM,M,0},	{"fidivrs",TERM,M,0} },
/*  [7,0]  */ { {"filds",TERM,M,0},	{"fisttps",TERM,M,0},
		{"fists",TERM,M,0},	{"fistps",TERM,M,0},
/*  [7,4]  */	{"fbld",TERM,M,0},	{"fildq",TERM,M,0},
		{"fbstp",TERM,M,0},	{"fistpq",TERM,M,0} },
};

static const struct instable opFP3[8][8] = {
/* bit  pattern:	1101 1xxx 11xx xREG */
/*  [0,0]  */ { {"fadd",TERM,FF,0},	{"fmul",TERM,FF,0},
		{"fcom",TERM,F,0},	{"fcomp",TERM,F,0},
/*  [0,4]  */	{"fsub",TERM,FF,0},	{"fsubr",TERM,FF,0},
		{"fdiv",TERM,FF,0},	{"fdivr",TERM,FF,0} },
/*  [1,0]  */ { {"fld",TERM,F,0},	{"fxch",TERM,F,0},
		{"fnop",TERM,GO_ON,0},	{"fstp",TERM,F,0},
/*  [1,4]  */	INVALID,		INVALID,
		INVALID,		INVALID },
/*  [2,0]  */ { {"fcmovb",TERM,FF,0},	{"fcmove",TERM,FF,0},
		{"fcmovbe",TERM,FF,0},	{"fcmovu",TERM,FF,0},
/*  [2,4]  */	INVALID,		{"fucompp",TERM,GO_ON,0},
		INVALID,		INVALID },
/*  [3,0]  */ { {"fcmovnb",TERM,FF,0},	{"fcmovne",TERM,FF,0},
		{"fcmovnbe",TERM,FF,0},	{"fcmovnu",TERM,FF,0},
/*  [3,4]  */	INVALID,		{"fucomi",TERM,FF,0},
		{"fcomi",TERM,FF,0},	INVALID },
/*  [4,0]  */ { {"fadd",TERM,FF,0},	{"fmul",TERM,FF,0},
		{"fcom",TERM,F,0},	{"fcomp",TERM,F,0},
/*  [4,4]  */	{"fsub",TERM,FF,0},	{"fsubr",TERM,FF,0},
		{"fdiv",TERM,FF,0},	{"fdivr",TERM,FF,0} },
/*  [5,0]  */ { {"ffree",TERM,F,0},	{"fxch",TERM,F,0},
		{"fst",TERM,F,0},	{"fstp",TERM,F,0},
/*  [5,4]  */	{"fucom",TERM,F,0},	{"fucomp",TERM,F,0},
		INVALID,		INVALID },
/*  [6,0]  */ { {"faddp",TERM,FF,0},	{"fmulp",TERM,FF,0},
		{"fcomp",TERM,F,0},	{"fcompp",TERM,GO_ON,0},
/*  [6,4]  */	{"fsubp",TERM,FF,0},	{"fsubrp",TERM,FF,0},
		{"fdivp",TERM,FF,0},	{"fdivrp",TERM,FF,0} },
/*  [7,0]  */ { {"ffreep",TERM,F,0},	{"fxch",TERM,F,0},
		{"fstp",TERM,F,0},	{"fstp",TERM,F,0},
/*  [7,4]  */	{"fnstsw",TERM,M,0},	{"fucomip",TERM,FF,0},
		{"fcomip",TERM,FF,0},	INVALID },
};

static const struct instable opFP4[4][8] = {
/* bit pattern:	1101 1001 111x xxxx */
/*  [0,0]  */ { {"fchs",TERM,GO_ON,0},	{"fabs",TERM,GO_ON,0},
		INVALID,		INVALID,
/*  [0,4]  */	{"ftst",TERM,GO_ON,0},	{"fxam",TERM,GO_ON,0},
		INVALID,		INVALID },
/*  [1,0]  */ { {"fld1",TERM,GO_ON,0},	{"fldl2t",TERM,GO_ON,0},
		{"fldl2e",TERM,GO_ON,0},{"fldpi",TERM,GO_ON,0},
/*  [1,4]  */	{"fldlg2",TERM,GO_ON,0},{"fldln2",TERM,GO_ON,0},
		{"fldz",TERM,GO_ON,0},	INVALID },
/*  [2,0]  */ { {"f2xm1",TERM,GO_ON,0},	{"fyl2x",TERM,GO_ON,0},
		{"fptan",TERM,GO_ON,0},	{"fpatan",TERM,GO_ON,0},
/*  [2,4]  */	{"fxtract",TERM,GO_ON,0},{"fprem1",TERM,GO_ON,0},
		{"fdecstp",TERM,GO_ON,0},{"fincstp",TERM,GO_ON,0} },
/*  [3,0]  */ { {"fprem",TERM,GO_ON,0},	{"fyl2xp1",TERM,GO_ON,0},
		{"fsqrt",TERM,GO_ON,0},	{"fsincos",TERM,GO_ON,0},
/*  [3,4]  */	{"frndint",TERM,GO_ON,0},{"fscale",TERM,GO_ON,0},
		{"fsin",TERM,GO_ON,0},	{"fcos",TERM,GO_ON,0} },
};

static const struct instable opFP5[8] = {
/* bit pattern:	1101 1011 1110 0xxx */
/*  [0]  */	INVALID,		INVALID,
		{"fnclex",TERM,GO_ON,0},{"fninit",TERM,GO_ON,0},
/*  [4]  */	{"fsetpm",TERM,GO_ON,0},INVALID,
		INVALID,		INVALID,
};

/*
 * Main decode table for the op codes.  The first two nibbles
 * will be used as an index into the table.  If there is a
 * a need to further decode an instruction, the array to be
 * referenced is indicated with the other two entries being
 * empty.
 */
static const struct instable distable[16][16] = {
/* [0,0] */  {  {"addb",TERM,RMw,0},	{"add",TERM,RMw,1},
		{"addb",TERM,MRw,0},	{"add",TERM,MRw,1},
/* [0,4] */	{"addb",TERM,IA,0},	{"add",TERM,IA,1},
		{"push",TERM,SEG,0x03,INVALID_64},
					{"pop",TERM,SEG,0x03,INVALID_64},
/* [0,8] */	{"orb",TERM,RMw,0},	{"or",TERM,RMw,1},
		{"orb",TERM,MRw,0},	{"or",TERM,MRw,1},
/* [0,C] */	{"orb",TERM,IA,0},	{"or",TERM,IA,1},
		{"push",TERM,SEG,0x03,INVALID_64},
				    {"",(const struct instable *)op0F,TERM,0} },
/* [1,0] */  {  {"adcb",TERM,RMw,0},	{"adc",TERM,RMw,1},
		{"adcb",TERM,MRw,0},	{"adc",TERM,MRw,1},
/* [1,4] */	{"adcb",TERM,IA,0},	{"adc",TERM,IA,1},
		{"push",TERM,SEG,0x03,INVALID_64},
					{"pop",TERM,SEG,0x03,INVALID_64},
/* [1,8] */	{"sbbb",TERM,RMw,0},	{"sbb",TERM,RMw,1},
		{"sbbb",TERM,MRw,0},	{"sbb",TERM,MRw,1},
/* [1,C] */	{"sbbb",TERM,IA,0},	{"sbb",TERM,IA,1},
		{"push",TERM,SEG,0x03,INVALID_64},
					{"pop",TERM,SEG,0x03,INVALID_64} },
/* [2,0] */  {  {"andb",TERM,RMw,0},	{"and",TERM,RMw,1},
		{"andb",TERM,MRw,0},	{"and",TERM,MRw,1},
/* [2,4] */	{"andb",TERM,IA,0},	{"and",TERM,IA,1},
		{"%es:",TERM,OVERRIDE,0},
					{"daa",TERM,GO_ON,0,INVALID_64},
/* [2,8] */	{"subb",TERM,RMw,0},	{"sub",TERM,RMw,1},
		{"subb",TERM,MRw,0},	{"sub",TERM,MRw,1},
/* [2,C] */	{"subb",TERM,IA,0},	{"sub",TERM,IA,1},
		{"%cs:",TERM,OVERRIDE,0},
					{"das",TERM,GO_ON,0,INVALID_64} },
/* [3,0] */  {  {"xorb",TERM,RMw,0},	{"xor",TERM,RMw,1},
		{"xorb",TERM,MRw,0},	{"xor",TERM,MRw,1},
/* [3,4] */	{"xorb",TERM,IA,0},	{"xor",TERM,IA,1},
		{"%ss:",TERM,OVERRIDE,0},
					{"aaa",TERM,GO_ON,0,INVALID_64},
/* [3,8] */	{"cmpb",TERM,RMw,0},	{"cmp",TERM,RMw,1},
		{"cmpb",TERM,MRw,0},	{"cmp",TERM,MRw,1},
/* [3,C] */	{"cmpb",TERM,IA,0},	{"cmp",TERM,IA,1},
		{"%ds:",TERM,OVERRIDE,0},
					{"aas",TERM,GO_ON,0,INVALID_64} },
/* [4,0] */  {  {"inc",TERM,R,1,&opREX},{"inc",TERM,R,1,&opREX},
		{"inc",TERM,R,1,&opREX},{"inc",TERM,R,1,&opREX},
/* [4,4] */	{"inc",TERM,R,1,&opREX},{"inc",TERM,R,1,&opREX},
		{"inc",TERM,R,1,&opREX},{"inc",TERM,R,1,&opREX},
/* [4,8] */	{"dec",TERM,R,1,&opREX},{"dec",TERM,R,1,&opREX},
		{"dec",TERM,R,1,&opREX},{"dec",TERM,R,1,&opREX},
/* [4,C] */	{"dec",TERM,R,1,&opREX},{"dec",TERM,R,1,&opREX},
		{"dec",TERM,R,1,&opREX},{"dec",TERM,R,1,&opREX} },
/* [5,0] */  {  {"push",TERM,R,0x03},	{"push",TERM,R,0x03},
		{"push",TERM,R,0x03},	{"push",TERM,R,0x03},
/* [5,4] */	{"push",TERM,R,0x03},	{"push",TERM,R,0x03},
		{"push",TERM,R,0x03},	{"push",TERM,R,0x03},
/* [5,8] */	{"pop",TERM,R,0x03},	{"pop",TERM,R,0x03},
		{"pop",TERM,R,0x03},	{"pop",TERM,R,0x03},
/* [5,C] */	{"pop",TERM,R,0x03},	{"pop",TERM,R,0x03},
		{"pop",TERM,R,0x03},	{"pop",TERM,R,0x03} },
/* [6,0] */  {  {"pusha",TERM,GO_ON,1,INVALID_64},
					{"popa",TERM,GO_ON,1,INVALID_64},
		{"bound",TERM,MR,0,INVALID_64},
					{"arpl",TERM,RMw,0,&op_movsl},
/* [6,4] */	{"%fs:",TERM,OVERRIDE,0},
					{"%gs:",TERM,OVERRIDE,0},
		{"data16",TERM,DM,0},	{"addr16",TERM,AM,0},
/* [6,8] */	{"push",TERM,I,0x03},	{"imul",TERM,IMUL,1},
		{"push",TERM,Ib,0x03},	{"imul",TERM,IMUL,1},
/* [6,C] */	{"insb",TERM,GO_ON,0},	{"ins",TERM,GO_ON,1},
		{"outsb",TERM,GO_ON,0},	{"outs",TERM,GO_ON,1} },
/* [7,0] */  {  {"jo",TERM,BD,0},	{"jno",TERM,BD,0},
		{"jb",TERM,BD,0},	{"jae",TERM,BD,0},
/* [7,4] */	{"je",TERM,BD,0},	{"jne",TERM,BD,0},
		{"jbe",TERM,BD,0},	{"ja",TERM,BD,0},
/* [7,8] */	{"js",TERM,BD,0},	{"jns",TERM,BD,0},
		{"jp",TERM,BD,0},	{"jnp",TERM,BD,0},
/* [7,C] */	{"jl",TERM,BD,0},	{"jge",TERM,BD,0},
		{"jle",TERM,BD,0},	{"jg",TERM,BD,0} },
/* [8,0] */  {  {"",op80,TERM,0},	{"",op81,TERM,0},
		{"",op82,TERM,0},	{"",op83,TERM,0},
/* [8,4] */	{"testb",TERM,MRw,0},	{"test",TERM,MRw,1},
		{"xchgb",TERM,MRw,0},	{"xchg",TERM,MRw,1},
/* [8,8] */	{"movb",TERM,RMw,0},	{"mov",TERM,RMw,1},
		{"movb",TERM,MRw,0},	{"mov",TERM,MRw,1},
/* [8,C] */	{"mov",TERM,SM,1},	{"lea",TERM,MR,1},
		{"mov",TERM,MS,1},	{"pop",TERM,M,0x03} },
/* [9,0] */  {  {"nop",TERM,GO_ON,0},	{"xchg",TERM,RA,1},
		{"xchg",TERM,RA,1},	{"xchg",TERM,RA,1},
/* [9,4] */	{"xchg",TERM,RA,1},	{"xchg",TERM,RA,0},
		{"xchg",TERM,RA,1},	{"xchg",TERM,RA,1},
/* [9,8] */	{"",TERM,CBW,0},	{"",TERM,CWD,0},
		{"lcall",TERM,SO,0},	{"wait/",TERM,PREFIX,0},
/* [9,C] */	{"pushf",TERM,GO_ON,0},	{"popf",TERM,GO_ON,0},
		{"sahf",TERM,GO_ON,0},	{"lahf",TERM,GO_ON,0} },
/* [A,0] */  {  {"movb",TERM,OA,0},	{"mov",TERM,OA,1},
		{"movb",TERM,AO,0},	{"mov",TERM,AO,1},
/* [A,4] */	{"movsb",TERM,SD,0},	{"movs",TERM,SD,1},
		{"cmpsb",TERM,SD,0},	{"cmps",TERM,SD,1},
/* [A,8] */	{"testb",TERM,IA,0},	{"test",TERM,IA,1},
		{"stosb",TERM,AD,0},	{"stos",TERM,AD,1},
/* [A,C] */	{"lodsb",TERM,SA,0},	{"lods",TERM,SA,1},
		{"scasb",TERM,AD,0},	{"scas",TERM,AD,1} },
/* [B,0] */  {  {"movb",TERM,IR,0},	{"movb",TERM,IR,0},
		{"movb",TERM,IR,0},	{"movb",TERM,IR,0},
/* [B,4] */	{"movb",TERM,IR,0},	{"movb",TERM,IR,0},
		{"movb",TERM,IR,0},	{"movb",TERM,IR,0},
/* [B,8] */	{"mov",TERM,IR64,1},	{"mov",TERM,IR64,1},
		{"mov",TERM,IR64,1},	{"mov",TERM,IR64,1},
/* [B,C] */	{"mov",TERM,IR64,1},	{"mov",TERM,IR64,1},
		{"mov",TERM,IR64,1},	{"mov",TERM,IR64,1} },
/* [C,0] */  {  {"",opC0,TERM,0},	{"",opC1,TERM,0},
		{"ret",TERM,RET,1},	{"ret",TERM,GO_ON,0},
/* [C,4] */	{"les",TERM,MR,0,INVALID_64},
					{"lds",TERM,MR,0,INVALID_64},
		{"movb",TERM,IMw,0},	{"mov",TERM,IMw,1},
/* [C,8] */	{"enter",TERM,ENTER,0},	{"leave",TERM,GO_ON,0},
		{"lret",TERM,RET,1},	{"lret",TERM,GO_ON,0},
/* [C,C] */	{"int",TERM,INT3,0},	{"int",TERM,Ib,0},
		{"into",TERM,GO_ON,0,INVALID_64},
					{"iret",TERM,GO_ON,0} },
/* [D,0] */  {  {"",opD0,TERM,0},	{"",opD1,TERM,0},
		{"",opD2,TERM,0},	{"",opD3,TERM,0},
/* [D,4] */	{"aam",TERM,U,0,INVALID_64},
					{"aad",TERM,U,0,INVALID_64},
		{"falc",TERM,GO_ON,0},	{"xlat",TERM,GO_ON,0},
/* 287 instructions.  Note that although the indirect field		*/
/* indicates opFP1n2 for further decoding, this is not necessarily	*/
/* the case since the opFP arrays are not partitioned according to key1	*/
/* and key2.  opFP1n2 is given only to indicate that we haven't		*/
/* finished decoding the instruction.					*/
/* [D,8] */	{"",(const struct instable *)opFP1n2,TERM,0},
		{"",(const struct instable *)opFP1n2,TERM,0},
		{"",(const struct instable *)opFP1n2,TERM,0},
		{"",(const struct instable *)opFP1n2,TERM,0},
/* [D,C] */	{"",(const struct instable *)opFP1n2,TERM,0},
		{"",(const struct instable *)opFP1n2,TERM,0},
		{"",(const struct instable *)opFP1n2,TERM,0},
		{"",(const struct instable *)opFP1n2,TERM,0} },
/* [E,0] */  {  {"loopnz",TERM,BD,0},	{"loopz",TERM,BD,0},
		{"loop",TERM,BD,0},	{"jcxz",TERM,BD,0},
/* [E,4] */	{"inb",TERM,Pi,0},	{"in",TERM,Pi,1},
		{"outb",TERM,Po,0},	{"out",TERM,Po,1},
/* [E,8] */	{"call",TERM,D,0x03},	{"jmp",TERM,D,0x02},
		{"ljmp",TERM,SO,0},	{"jmp",TERM,BD,0},
/* [E,C] */	{"inb",TERM,Vi,0},	{"in",TERM,Vi,1},
		{"outb",TERM,Vo,0},	{"out",TERM,Vo,1} },
/* [F,0] */  {  {"lock/",TERM,PREFIX,0}, INVALID,
		{"repnz/",TERM,PREFIX,0}, {"repz/",TERM,PREFIX,0},
/* [F,4] */	{"hlt",TERM,GO_ON,0},	{"cmc",TERM,GO_ON,0},
		{"",opF6,TERM,0},	{"",opF7,TERM,0},
/* [F,8] */	{"clc",TERM,GO_ON,0},	{"stc",TERM,GO_ON,0},
		{"cli",TERM,GO_ON,0},	{"sti",TERM,GO_ON,0},
/* [F,C] */	{"cld",TERM,GO_ON,0},	{"std",TERM,GO_ON,0},
		{"",opFE,TERM,0},	{"",opFF,TERM,0} },
};

static const char *get_reg_name(int reg, int wbit, int data16, int rex)
{
	const char *reg_name;
	
	// A REX prefix takes precedent over a 66h prefix.
	if (rex != 0) {
		reg_name = REG32[reg + (REX_R(rex) << 3)][wbit + REX_W(rex)];
	} else if (data16) {
		reg_name = REG16[reg][wbit];
	} else {
		reg_name = REG32[reg][wbit];
	}
	
	return reg_name;
}

static const char *get_r_m_name(int r_m, int wbit, int data16, int rex)
{
	const char *reg_name;
	
	// A REX prefix takes precedent over a 66h prefix.
	if (rex != 0) {
		reg_name = REG32[r_m + (REX_B(rex) << 3)][wbit + REX_W(rex)];
	} else if (data16) {
		reg_name = REG16[r_m][wbit];
	} else {
		reg_name = REG32[r_m][wbit];
	}
	
	return reg_name;
}

// Returns the xmm register number referenced by reg and rex.
static unsigned int xmm_reg(int reg, int rex)
{
	return (reg + (REX_R(rex) << 3));
}

// Returns the xmm register number referenced by r_m and rex.
static unsigned int xmm_rm(int r_m, int rex)
{
	return (r_m + (REX_B(rex) << 3));
}

/*
 * This is passed to the llvm disassembler.
 */
struct disassemble_info {
  enum bool verbose;
  /* Relocation information.  */
  struct relocation_info *sorted_relocs;
  uint32_t nsorted_relocs;
  struct relocation_info *ext_relocs;
  uint32_t next_relocs;
  struct relocation_info *loc_relocs;
  uint32_t nloc_relocs;
  struct dyld_bind_info *dbi;
  uint64_t ndbi;
  /* Symbol table.  */
  struct nlist *symbols;
  struct nlist_64 *symbols64;
  uint32_t nsymbols;
  /* Symbols sorted by address.  */
  struct symbol *sorted_symbols;
  uint32_t nsorted_symbols;
  /* String table.  */
  char *strings;
  uint32_t strings_size;
  /* Other useful info.  */
  uint32_t ncmds;
  uint32_t sizeofcmds;
  struct load_command *load_commands;
  enum byte_sex object_byte_sex;
  uint32_t *indirect_symbols;
  uint32_t nindirect_symbols;
  char *sect;
  uint32_t left;
  uint32_t addr;
  uint32_t sect_addr;
  cpu_type_t cputype;
  LLVMDisasmContextRef i386_dc;
  LLVMDisasmContextRef x86_64_dc;
  char *object_addr;
  uint32_t object_size;
  struct inst *inst;
  struct inst *insts;
  uint32_t ninsts;
  const char *class_name;
  const char *selector_name;
  char *method;
  char *demangled_name;
} dis_info;

/*
 * i386_disassemble()
 */
uint32_t
i386_disassemble(
char *sect,
uint32_t left,
uint64_t addr,
uint64_t sect_addr,
enum byte_sex object_byte_sex,
struct relocation_info *sorted_relocs,
uint32_t nsorted_relocs,
struct relocation_info *ext_relocs,
uint32_t next_relocs,
struct relocation_info *loc_relocs,
uint32_t nloc_relocs,
struct dyld_bind_info *dbi,
uint64_t ndbi,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
uint32_t *indirect_symbols,
uint32_t nindirect_symbols,
cpu_type_t cputype,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum bool verbose,
enum bool llvm_mc,
LLVMDisasmContextRef i386_dc,
LLVMDisasmContextRef x86_64_dc,
char *object_addr,
uint32_t object_size,
struct inst *inst,
struct inst *insts,
uint32_t ninsts)
{
    char mnemonic[MAX_MNEMONIC+2]; /* one extra for suffix */
    const char *seg;
    const char *symbol0, *symbol1;
    const char *symadd0, *symsub0, *symadd1, *symsub1;
    uint32_t value0, value1;
    uint64_t imm0, imm1;
    uint32_t value0_size, value1_size;
    char result0[MAX_RESULT], result1[MAX_RESULT];
    const char *indirect_symbol_name;

    uint32_t i, length;
    unsigned char byte;
       unsigned char opcode_suffix;
    /* nibbles (4 bits) of the opcode */
    unsigned opcode1, opcode2, opcode3, opcode4, opcode5, prefix_byte;
    const struct instable *dp, *prefix_dp;
    uint32_t wbit, vbit;
    enum bool got_modrm_byte;
    uint32_t mode, reg, r_m;
    const char *reg_name;
    enum bool data16;		/* 16- or 32-bit data */
    enum bool addr16;		/* 16- or 32-bit addressing */
    enum bool sse2;		/* sse2 instruction using xmmreg's */
    enum bool mmx;		/* mmx instruction using mmreg's */
    unsigned char rex;		/* x86-64 REX prefix */

	if(left == 0){
	   printf("(end of section)\n");
	   return(0);
	}

	/* Use the llvm disassembler with the -q flag. */
	if(qflag || gflag){
	    LLVMDisasmContextRef dc;
	    char dst[8192];

	    dst[8191] = '\0';
	    dis_info.verbose = verbose;
	    dis_info.sorted_relocs = sorted_relocs;
	    dis_info.nsorted_relocs = nsorted_relocs;
	    dis_info.ext_relocs = ext_relocs;
	    dis_info.next_relocs = next_relocs;
	    dis_info.loc_relocs = loc_relocs;
	    dis_info.nloc_relocs = nloc_relocs;
	    dis_info.dbi = dbi;
	    dis_info.ndbi = ndbi;
	    dis_info.symbols = symbols;
	    dis_info.symbols64 = symbols64;
	    dis_info.nsymbols = nsymbols;
	    dis_info.sorted_symbols = sorted_symbols;
	    dis_info.nsorted_symbols = nsorted_symbols;
	    dis_info.strings = strings;
	    dis_info.strings_size = strings_size;
	    dis_info.load_commands = load_commands;
	    dis_info.object_byte_sex = object_byte_sex;
	    dis_info.indirect_symbols = indirect_symbols;
	    dis_info.nindirect_symbols = nindirect_symbols;
	    dis_info.ncmds = ncmds;
	    dis_info.sizeofcmds = sizeofcmds;
	    dis_info.sect = sect;
	    dis_info.left = left;
	    dis_info.addr = addr;
	    dis_info.sect_addr = sect_addr;
	    dis_info.cputype = cputype;
	    dis_info.object_addr = object_addr;
	    dis_info.object_size = object_size;
	    dis_info.inst = inst;
	    dis_info.insts = insts;
	    dis_info.ninsts = ninsts;
	    dis_info.demangled_name = NULL;
	    if(cputype == CPU_TYPE_I386)
		dc = i386_dc;
	    else
		dc = x86_64_dc;
	    length = llvm_disasm_instruction(dc, (uint8_t *)sect, left,
					     addr, dst, 8191);
	    if(length != 0){
		if(inst == NULL || inst->print){
		    /* print the opcode bytes */
		    if(!Xflag && jflag){
			printf("\t");
			for(i = 0; i < length; i++)
			    printf("%02x", 0xff & sect[i]);
			for( ; i < 8; i++)
			    printf("  ");
		    }
		    /* print the disassembled instruction */
		    printf("%s\n", dst);
		}
	    }
	    else{
		if(inst == NULL || inst->print){
		    if(!Xflag && jflag)
			printf("\t%02x              ", 0xff & sect[0]);
		    printf("\t.byte 0x%02x #bad opcode\n", 0xff & sect[0]);
		}
		length = 1;
	    }
	    return(length);
	}

	memset(mnemonic, '\0', sizeof(mnemonic));
	seg = "";
	symbol0 = NULL;
	symbol1 = NULL;
	value0 = 0;
	value1 = 0;
	value0_size = 0;
	value1_size = 0;
	memset(result0, '\0', sizeof(result0));
	memset(result1, '\0', sizeof(result1));
	data16 = FALSE;
	addr16 = FALSE;
	sse2 = FALSE;
	mmx = FALSE;
	rex = 0;
	reg_name = NULL;
	wbit = 0;

	length = 0;
	byte = 0;
	opcode4 = 0; /* to remove a compiler warning only */
	opcode5 = 0; /* to remove a compiler warning only */
	r_m = 0;
	reg = 0;
	mode = 0;
	opcode3 = 0;

	/*
	 * As long as there is a prefix, the default segment register,
	 * addressing-mode, or data-mode in the instruction will be overridden.
	 * This may be more general than the chip actually is.
	 */
	prefix_dp = NULL;
	prefix_byte = 0;
	for(;;){
	    byte = get_value(sizeof(char), sect, &length, &left);
	    opcode1 = byte >> 4 & 0xf;
	    opcode2 = byte & 0xf;

	    dp = &distable[opcode1][opcode2];
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
	       dp->arch64 != NULL)
		dp = dp->arch64;

	    if(dp->adr_mode == PREFIX){
		if(prefix_dp != NULL)
		    printf("%s", dp->name);
		else if(llvm_mc == TRUE && byte == 0x9b){
		    printf("wait\n");
		    return(length);
		}
		prefix_dp = dp;
		prefix_byte = byte;
	    }
	    else if(dp->adr_mode == AM){
		addr16 = !addr16;
		prefix_byte = byte;
	    }
	    else if(dp->adr_mode == DM){
		data16 = !data16;
		prefix_byte = byte;
	    }
	    else if(dp->adr_mode == OVERRIDE){
		seg = dp->name;
		prefix_byte = byte;
	    }
	    else if(dp->adr_mode == REX){
		rex = byte;
		/*
		 * REX is a prefix, but we don't set prefix_byte here because
		 * we use that to detect things related to the other prefixes
		 * and we don't want the existence of those bytes to be hidden
		 * by the presence of a REX prefix.
		 */
	    }
	    else
		break;
	}

	got_modrm_byte = FALSE;

	/*
	 * Some 386 instructions have 2 bytes of opcode before the mod_r/m
	 * byte so we need to perform a table indirection.
	 */
	if(dp->indirect == (const struct instable *)op0F){
	    byte = get_value(sizeof(char), sect, &length, &left);
	    opcode4 = byte >> 4 & 0xf;
	    opcode5 = byte & 0xf;
	    dp = &op0F[opcode4][opcode5];
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
	       dp->arch64 != NULL)
		dp = dp->arch64;
	    if(dp->indirect == op0F38 || dp->indirect == op0F3A){
		/*
		 * MNI instructions are SSE2ish instructions with an
		 * extra byte.  Do the extra indirection here.
		 */
		byte = get_value(sizeof(char), sect, &length, &left);
		dp = &dp->indirect[byte];
	    }
	    /*
	     * SSE and SSE2 instructions have 3 bytes of opcode and the
	     * "third opcode byte" is before the other two (where the prefix
	     * byte would be).  This is why the prefix byte is saved above and
	     * the printing of the last prefix is delayed.
	     */
	    if(dp->adr_mode == SSE2 ||
	       dp->adr_mode == SSE2i ||
	       dp->adr_mode == SSE2i1 ||
	       dp->adr_mode == SSE2tm ||
	       dp->adr_mode == SSE2tfm ||
	       dp->adr_mode == SSE4 ||
	       dp->adr_mode == SSE4i ||
	       dp->adr_mode == SSE4MRw ||
	       dp->adr_mode == SSE4CRC ||
	       dp->adr_mode == SSE4CRCb ||
	       (byte == 0xc7 && prefix_byte == 0xf3)){ /* for vmxon */
		prefix_dp = NULL;
	    }
	    else{
		/*
		 * 3DNow! instructions have 2 bytes of opcode followed by their
		 * operands and then an instruction-specific suffix byte.
		 */
		if(dp->indirect == (const struct instable *)op0F0F){
		    data16 = FALSE;
		    mmx = TRUE;
		    if(got_modrm_byte == FALSE){
			got_modrm_byte = TRUE;
			byte = get_value(sizeof(char), sect, &length, &left);
			modrm_byte(&mode, &reg, &r_m, byte);
		    }
		    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size,
				result0);
		    opcode_suffix = get_value(sizeof(char), sect, &length,
					      &left);
		    dp = &op0F0F[opcode_suffix >> 4][opcode_suffix & 0x0F];
		}
		else if(dp->indirect == (const struct instable *)op0F01){
		    if(got_modrm_byte == FALSE){
			got_modrm_byte = TRUE;
			byte = get_value(sizeof(char), sect, &length, &left);
			modrm_byte(&mode, &reg, &r_m, byte);
			opcode3 = reg;
		    }
		    if(byte == 0xc8){
			data16 = FALSE;
			mmx = TRUE;
			dp = &op_monitor;
		    }
		    else if(byte == 0xc9){
			data16 = FALSE;
			mmx = TRUE;
			dp = &op_mwait;
		    }
		    else if(byte == 0xf9){
			data16 = FALSE;
			mmx = TRUE;
			dp = &op_rdtscp;
		    }
		    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64){
			if(opcode3 == 0x7 && got_modrm_byte &&
			   mode == REG_ONLY && r_m == 0) {
			    dp = &op_swapgs;
			}
		    }
		    /*
		     * To get the 'q' suffix on all 0F 01 /0-3 opcodes in 64
		     * bit mode we set the REX_W here.
		     */
		    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
		       (opcode3 == 0 || opcode3 == 1 || opcode3 == 2 ||
			opcode3 == 3))
			rex |= 0x8;
		}
		else{
		    /*
		     * Since the opcode is not an SSE or SSE2 instruction that
		     * uses the prefix byte as the "third opcode byte" print the
		     * delayed last prefix if any.
		     */
		    if(prefix_dp != NULL)
			printf("%s", prefix_dp->name);
		}
            }
	}
	else{
	    /*
	     * The "pause" Spin Loop Hint instruction is a "repz" prefix
	     * followed by a nop (0x90).
	     */
	    if(prefix_dp != NULL && prefix_byte == 0xf3 &&
	       opcode1 == 0x9 && opcode2 == 0x0){
		printf("pause\n");
		return(length);
	    }
	    /*
	     * Since the opcode is not an SSE or SSE2 instruction print the
	     * delayed last prefix if any.
	     */
	    if(prefix_dp != NULL){
		/*
		 * If the prefix is "repz" and the instruction is ins, outs,
		 * movs, lods, or stos then the name used is "rep".
		 */
		if(strcmp(prefix_dp->name, "repz/") == 0 &&
		   (byte == 0x6c || byte == 0x6d || /* ins */
		    byte == 0x6e || byte == 0x6f || /* outs */
		    byte == 0xa4 || byte == 0xa5 || /* movs */
		    byte == 0xac || byte == 0xad || /* lods */
		    byte == 0xaa || byte == 0xab))  /* stos */
		    printf("rep/");
		else
		    printf("%s", prefix_dp->name);
	    }
	}

	if(dp->indirect != TERM){
	    /*
	     * This must have been an opcode for which several instructions
	     * exist.  The opcode3 field further decodes the instruction.
	     */
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, (uint32_t *)&opcode3, &r_m, byte);
	    }
	    /*
	     * decode 287 instructions (D8-DF) from opcodeN
	     */
	    if(opcode1 == 0xD && opcode2 >= 0x8){
		/* instruction form 5 */
		if(opcode2 == 0xB && mode == 0x3 && opcode3 == 4)
		    dp = &opFP5[r_m];
		else if(opcode2 == 0xB && mode == 0x3 && opcode3 > 6){
		    printf(".byte 0x%01x%01x, 0x%01x%01x 0x%02x #bad opcode\n",
			   (unsigned int)opcode1, (unsigned int)opcode2,
			   (unsigned int)opcode4, (unsigned int)opcode5,
			   (unsigned int)byte);
		    return(length);
		}
		/* instruction form 4 */
		else if(opcode2 == 0x9 && mode == 0x3 && opcode3 >= 4)
		    dp = &opFP4[opcode3-4][r_m];
		/* instruction form 3 */
		else if(mode == 0x3)
		    dp = &opFP3[opcode2-8][opcode3];
		else /* instruction form 1 and 2 */
		    dp = &opFP1n2[opcode2-8][opcode3];
	    }
	    else
		dp = dp->indirect + opcode3;
		/* now dp points the proper subdecode table entry */
	}

	if(dp->indirect != TERM){
	    printf(".byte 0x%02x #bad opcode\n", (unsigned int)byte);
	    return(length);
	}
	
	/*
	 * Some addressing modes are implicitly 64-bit.  Set REX.W for those
	 * so we don't have to change the logic for them later.
	 */
	if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64){
	    if((dp->flags & IS_POINTER_SIZED) != 0){
		rex |= 0x8;	/* Set REX.W if it isn't already set */
	    }
	}

	/* setup the mnemonic with a possible suffix */
	if(dp->adr_mode != CBW && dp->adr_mode != CWD){
	    if((dp->flags & HAS_SUFFIX) != 0){
		if(data16 == TRUE)
		    sprintf(mnemonic, "%sw", dp->name);
		else{
		    if(dp->adr_mode == Mnol || dp->adr_mode == INM ||
		       dp->adr_mode == SM || dp->adr_mode == MS)
			sprintf(mnemonic, "%s", dp->name);
		    else if(REX_W(rex) != 0)
			sprintf(mnemonic, "%sq", dp->name);
		    else
			sprintf(mnemonic, "%sl", dp->name);
		}
	    }
	    else{
		sprintf(mnemonic, "%s", dp->name);
	    }
	    if(dp->adr_mode == BD){
		if(strcmp(seg, "%cs:") == 0){
		    sprintf(mnemonic, "%s,pn", mnemonic);
		    seg = "";
		}
		else if(strcmp(seg, "%ds:") == 0){
		    sprintf(mnemonic, "%s,pt", mnemonic);
		    seg = "";
		}
	    }
	}

	/*
	 * Each instruction has a particular instruction syntax format
	 * stored in the disassembly tables.  The assignment of formats
	 * to instructions was made by the author.  Individual formats
	 * are explained as they are encountered in the following
	 * switch construct.
	 */
	switch(dp -> adr_mode){

	case BSWAP:
	    reg = opcode5 & 0x7;
	    if(rex)
		reg_name = REG32[reg + (REX_B(rex) << 3)][1 + REX_W(rex)];
	    else
		reg_name = get_reg_name(reg, 1, data16, rex);
	    printf("%s\t%s\n", mnemonic, reg_name);
	    return(length);

	case XINST:
	    wbit = WBIT(opcode5);
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
		reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t%s,", mnemonic, reg_name);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* movsbl movsbw (0x0FBE) or movswl (0x0FBF) */
	/* movzbl movzbw (0x0FB6) or mobzwl (0x0FB7) */
	/* wbit lives in 2nd byte, note that operands are different sized */
	case MOVZ:
	    /* Get second operand first so data16 can be destroyed */
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    reg_name = get_reg_name(reg, LONGOPERAND, data16, rex);
	    wbit = WBIT(opcode5);
	    data16 = 1;
	    /* movslq (0x63) Move doubleword to quadword with sign-extension */
	    if(opcode1 != 0x6 && opcode2 != 0x3)
	        rex = 0;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* imul instruction, with either 8-bit or longer immediate */
	case IMUL:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size, result1);
	    /* opcode 0x6B for byte, sign-extended displacement,
		0x69 for word(s) */
	    value0_size = OPSIZE(data16, opcode2 == 0x9, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    print_operand(seg, symadd1, symsub1, value1, value1_size, result1,
			  ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* memory or register operand to register, with 'w' bit	*/
	case MRw:
	case SSE4MRw:
	    /*
	     * If this is vmwrite in a 64-bit object the 0F 79
	     * opcode it results in a 64-bit operand.
	     * So to get the 64-bit register names in the disassembly we
	     * set the REX.W bit to indicate 64-bit operand size.
	     */
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
	       opcode1 == 0x0 && opcode2 == 0xf &&
	       opcode4 == 0x7 && opcode5 == 0x9)
		rex |= 0x8;
	    wbit = WBIT(opcode2);
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* register to memory or register operand, with 'w' bit	*/
	/* arpl happens to fit here also because it is odd */
	case RMw:
	    /*
	     * If this is vmread in a 64-bit object the 0F 78
	     * opcode it results in a 64-bit operand.
	     * So to get the 64-bit register names in the disassembly we
	     * set the REX.W bit to indicate 64-bit operand size.
	     */
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
	       opcode1 == 0x0 && opcode2 == 0xf &&
	       opcode4 == 0x7 && opcode5 == 0x8)
		rex |= 0x8;
	    /* arpl, 0x63, always uses r16's */
	    if(opcode1 == 0x6 && opcode2 == 0x3)
		data16 = 1;
	    wbit = WBIT(opcode2);
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t%s,", mnemonic, reg_name);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* SSE2 instructions with further prefix decoding dest to memory or
	   memory to dest depending on the opcode */
	case SSE2tfm:
	    data16 = FALSE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    switch(opcode4 << 4 | opcode5){
	    case 0x7e: /* movq & movd */
		if(prefix_byte == 0x66){
		    /* movd from xmm to r/m32 */
		    printf("%sd\t%%xmm%u,", mnemonic, xmm_reg(reg, rex));
		    wbit = LONGOPERAND;
		    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size,
				result0);
		    print_operand(seg, symadd0, symsub0, value0, value0_size,
				  result0, "\n");
		}
		else if(prefix_byte == 0xf0){
		    /* movq from mm to mm/m64 */
		    printf("%sd\t%%mm%u,", mnemonic, reg);
		    mmx = TRUE;
		    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size,
				result1);
		    print_operand(seg, symadd1, symsub1, value1, value1_size,
				  result1, "\n");
		}
		else if(prefix_byte == 0xf3){
		    /* movq from xmm2/mem64 to xmm1 */
		    printf("%sq\t", mnemonic);
		    sse2 = TRUE;
		    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size,
				result0);
		    print_operand(seg, symadd0, symsub0, value0, value0_size,
				  result0, ",");
		    printf("%%xmm%u\n", xmm_reg(reg, rex));
		}
		else{ /* no prefix_byte */
		    /* movd from mm to r/m32 */
		    printf("%sd\t%%mm%u,", mnemonic, reg);
		    wbit = LONGOPERAND;
		    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size,
				result1);
		    print_operand(seg, symadd1, symsub1, value1, value1_size,
				  result1, "\n");
		}
	    }
	    return(length);

	/* SSE2 instructions with further prefix decoding dest to memory */
	case SSE2tm:
	    data16 = FALSE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    sprintf(result0, "%%xmm%u", xmm_reg(reg, rex));
	    switch(opcode4 << 4 | opcode5){
	    case 0x11: /* movupd &         movups */
		       /*          movsd &        movss */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%supd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%ssd\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%sss\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sups\t", mnemonic);
		break;
	    case 0x13: /*  movlpd &          movlps */
	    case 0x17: /*  movhpd &          movhps */
	    case 0x29: /*  movapd &  movasd */
	    case 0x2b: /* movntpd & movntsd */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%spd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%ssd\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%sss\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sps\t", mnemonic);
		break;
	    case 0xd6: /* movq */
		if(prefix_byte == 0x66){
		    sse2 = TRUE;
		    printf("%sq\t", mnemonic);
		}
		else if(prefix_byte == 0xf2){
		    printf("%sdq2q\t", mnemonic);
		    sse2 = TRUE;
		    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size,
				result0);
		    print_operand(seg, symadd0, symsub0, value0, value0_size,
				  result0, ",");
		    sprintf(result1, "%%mm%u", reg);
		    printf("%s\n", result1);
		    return(length);
		}
		else if(prefix_byte == 0xf3){
		    printf("%sq2dq\t", mnemonic);
		    mmx = TRUE;
		    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size,
				result0);
		    print_operand(seg, symadd0, symsub0, value0, value0_size,
				  result0, ",");
		    sprintf(result1, "%%xmm%u", reg);
		    printf("%s\n", result1);
		    return(length);
		}
		break;
	    case 0x7f: /* movdqa, movdqu, movq */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%sdqa\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%sdqu\t", mnemonic);
		else{
		    sprintf(result0, "%%mm%u", reg);
		    printf("%sq\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0xe7: /* movntdq & movntq */
		if(prefix_byte == 0x66){
		    printf("%stdq\t", mnemonic);
		}
		else{ /* no prefix_byte */
		    sprintf(result0, "%%mm%u", reg);
		    printf("%stq\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    }
	    printf("%s,", result0);
	    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size, result1);
	    print_operand(seg, symadd1, symsub1, value1, value1_size,
			  result1, "\n");
	    return(length);

	/* MNI instructions */
	case MNI:
	    data16 = FALSE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    if(prefix_byte == 0x66){
		sse2 = TRUE;
		sprintf(result1, "%%xmm%u", xmm_reg(reg, rex));
	    }
	    else{ /* no prefix byte */
		mmx = TRUE;
		sprintf(result1, "%%mm%u", reg);
	    }
	    printf("%s\t", mnemonic);
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%s\n", result1);
		return length;

	/* MNI instructions with 8-bit immediate */
	case MNIi:
	    data16 = FALSE;
	    if (got_modrm_byte == FALSE) {
			got_modrm_byte = TRUE;
			byte = get_value(sizeof(char), sect, &length, &left);
			modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    if(prefix_byte == 0x66){
		sse2 = TRUE;
		sprintf(result1, "%%xmm%u", xmm_reg(reg, rex));
	    }
	    else{ /* no prefix byte */
		mmx = TRUE;
		sprintf(result1, "%%mm%u", reg);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    byte = get_value(sizeof(char), sect, &length, &left);
		printf("%s\t$0x%x,", mnemonic, byte);
		
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%s\n", result1);
		return length;

	/* SSE2 instructions with further prefix decoding */
	case SSE2:
	    data16 = FALSE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    sprintf(result1, "%%xmm%u", xmm_reg(reg, rex));
	    switch(opcode4 << 4 | opcode5){
	    case 0x14: /* unpcklpd &                 unpcklps */
	    case 0x15: /* unpckhpd &                 unpckhps */
	    case 0x28: /*   movapd & movasd */
	    case 0x51: /*   sqrtpd,  sqrtsd, sqrtss &  sqrtps */
	    case 0x52: /*                   rsqrtss & rsqrtps */
	    case 0x53: /*                     rcpss &   rcpps */
	    case 0x54: /*    andpd &  andsd */
	    case 0x55: /*   andnpd & andnsd */
	    case 0x56: /*     orpd &                    orps */
	    case 0x57: /*    xorpd &                   xorps */
	    case 0x58: /*    addpd &  addsd */
	    case 0x59: /*    mulpd,   mulsd,  mulss &   mulps */
	    case 0x5c: /*    subpd,   subsd,  subss &   subps */
	    case 0x5d: /*    minpd,   minsd,  minss &   minps */
	    case 0x5e: /*    divpd,   divsd,  divss &   divps */
	    case 0x5f: /*    maxpd,   maxsd,  maxss &   maxps */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%spd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%ssd\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%sss\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sps\t", mnemonic);
		break;
	    case 0x12: /*   movlpd, movlps & movhlps */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%slpd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("movddup\t");
		else if(prefix_byte == 0xf3)
		    printf("movsldup\t");
		else{ /* no prefix_byte */
		    if(mode == REG_ONLY)
			printf("%shlps\t", mnemonic);
		    else
			printf("%slps\t", mnemonic);
		}
		break;
	    case 0x16: /*   movhpd, movhps & movlhps */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%shpd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%shsd\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("movshdup\t");
		else{ /* no prefix_byte */
		    if(mode == REG_ONLY)
			printf("%slhps\t", mnemonic);
		    else
			printf("%shps\t", mnemonic);
		}
		break;
	    case 0x50: /* movmskpd &                 movmskps */
		sse2 = TRUE;
		reg_name = get_reg_name(reg, 1, data16, rex);
		strcpy(result1, reg_name);
		if(prefix_byte == 0x66)
		    printf("%spd\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sps\t", mnemonic);
		break;
	    case 0x10: /*   movupd &                  movups */
		       /*             movsd & movss */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%supd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%ssd\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%sss\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sups\t", mnemonic);
		break;
	    case 0x2a: /* cvtpi2pd, cvtsi2sd, cvtsi2ss & cvtpi2ps */
		if(prefix_byte == 0x66){
		    mmx = TRUE;
		    printf("%spi2pd\t", mnemonic);
		}
		else if(prefix_byte == 0xf2){
		    wbit = LONGOPERAND;
		    printf("%ssi2sd\t", mnemonic);
		}
		else if(prefix_byte == 0xf3){
		    wbit = LONGOPERAND;
		    printf("%ssi2ss\t", mnemonic);
		}
		else{ /* no prefix_byte */
		    mmx = TRUE;
		    printf("%spi2ps\t", mnemonic);
		}
		break;
	    case 0x2c: /* cvttpd2pi, cvttsd2si, cvttss2si & cvttps2pi */
		if(prefix_byte == 0x66){
		    sse2 = TRUE;
		    printf("%stpd2pi\t", mnemonic);
		    sprintf(result1, "%%mm%u", reg);
		}
		else if(prefix_byte == 0xf2){
		    sse2 = TRUE;
		    printf("%stsd2si\t", mnemonic);
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    strcpy(result1, reg_name);
		}
		else if(prefix_byte == 0xf3){
		    sse2 = TRUE;
		    printf("%stss2si\t", mnemonic);
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    strcpy(result1, reg_name);
		}
		else{ /* no prefix_byte */
		    sse2 = TRUE;
		    printf("%stps2pi\t", mnemonic);
		    sprintf(result1, "%%mm%u", reg);
		}
		break;
	    case 0x2d: /* cvtpd2pi, cvtsd2si, cvtss2si & cvtps2pi */
		if(prefix_byte == 0x66){
		    sse2 = TRUE;
		    printf("%spd2pi\t", mnemonic);
		    sprintf(result1, "%%mm%u", reg);
		}
		else if(prefix_byte == 0xf2){
		    sse2 = TRUE;
		    printf("%ssd2si\t", mnemonic);
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    strcpy(result1, reg_name);
		}
		else if(prefix_byte == 0xf3){
		    sse2 = TRUE;
		    printf("%sss2si\t", mnemonic);
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    strcpy(result1, reg_name);
		}
		else{ /* no prefix_byte */
		    sse2 = TRUE;
		    printf("%sps2pi\t", mnemonic);
		    sprintf(result1, "%%mm%u", reg);
		}
		break;
	    case 0x2e: /* ucomisd & ucomiss */
	    case 0x2f: /*  comisd &  comiss */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%ssd\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sss\t", mnemonic);
		break;
	    case 0xe0: /* pavgb */
	    case 0xe3: /* pavgw */
		if(prefix_byte == 0x66){
		    sse2 = TRUE;
		    printf("%s\t", mnemonic);
		}
		else{ /* no prefix_byte */
		    sprintf(result1, "%%mm%u", reg);
		    printf("%s\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0xe6: /* cvttpd2dq, cvtdq2pd & cvtpd2dq */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%stpd2dq\t", mnemonic);
		if(prefix_byte == 0xf3)
		    printf("%sdq2pd\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%spd2dq\t", mnemonic);
		break;
	    case 0x5a: /* cvtpd2ps, cvtsd2ss, cvtss2sd & cvtps2pd */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%spd2ps\t", mnemonic);
		else if(prefix_byte == 0xf2)
		    printf("%ssd2ss\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%sss2sd\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sps2pd\t", mnemonic);
		break;
	    case 0x5b: /* cvtdq2ps, cvttps2dq & cvtps2dq */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%sps2dq\t", mnemonic);
		else if(prefix_byte == 0xf3)
		    printf("%stps2dq\t", mnemonic);
		else /* no prefix_byte */
		    printf("%sdq2ps\t", mnemonic);
		break;
	    case 0x60: /* punpcklbw */
	    case 0x61: /* punpcklwd */
	    case 0x62: /* punpckldq */
	    case 0x63: /* packsswb */
	    case 0x64: /* pcmpgtb */
	    case 0x65: /* pcmpgtw */
	    case 0x66: /* pcmpgtd */
	    case 0x67: /* packuswb */
	    case 0x68: /* punpckhbw */
	    case 0x69: /* punpckhwd */
	    case 0x6a: /* punpckhdq */
	    case 0x6b: /* packssdw */
	    case 0x74: /* pcmpeqb */
	    case 0x75: /* pcmpeqw */
	    case 0x76: /* pcmpeqd */
	    case 0xd1: /* psrlw */
	    case 0xd2: /* psrld */
	    case 0xd3: /* psrlq */
	    case 0xd4: /* paddq */
	    case 0xd5: /* pmullw */
	    case 0xd8: /* psubusb */
	    case 0xd9: /* psubusw */
	    case 0xdb: /* pand */
	    case 0xdc: /* paddusb */
	    case 0xdd: /* paddusw */
	    case 0xdf: /* pandn */
	    case 0xe1: /* psraw */
	    case 0xe2: /* psrad */
	    case 0xe5: /* pmulhw */
	    case 0xe8: /* psubsb */
	    case 0xe9: /* psubsw */
	    case 0xeb: /* por */
	    case 0xec: /* paddsb */
	    case 0xed: /* paddsw */
	    case 0xef: /* pxor */
	    case 0xf1: /* psllw */
	    case 0xf2: /* pslld */
	    case 0xf3: /* psllq */
	    case 0xf5: /* pmaddwd */
	    case 0xf8: /* psubb */
	    case 0xf9: /* psubw */
	    case 0xfa: /* psubd */
	    case 0xfb: /* psubq */
	    case 0xfc: /* paddb */
	    case 0xfd: /* paddw */
	    case 0xfe: /* paddd */
		if(prefix_byte == 0x66){
		    printf("%s\t", mnemonic);
		    sse2 = TRUE;
		}
		else{ /* no prefix_byte */
		    sprintf(result1, "%%mm%u", reg);
		    printf("%s\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0x6c: /* punpcklqdq */
	    case 0x6d: /* punpckhqdq */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%sqdq\t", mnemonic);
		break;
	    case 0x6f: /* movdqa, movdqu & movq */
		if(prefix_byte == 0x66){
		    sse2 = TRUE;
		    printf("%sdqa\t", mnemonic);
		}
		else if(prefix_byte == 0xf3){
		    sse2 = TRUE;
		    printf("%sdqu\t", mnemonic);
		}
		else{ /* no prefix_byte */
		    sprintf(result1, "%%mm%u", reg);
		    printf("%sq\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0xd6: /* movdq2q & movq2dq */
		if(prefix_byte == 0xf2){
		    sprintf(result1, "%%mm%u", reg);
		    printf("%sdq2q\t", mnemonic);
		    sse2 = TRUE;
		}
		else if(prefix_byte == 0xf3){
		    printf("%sq2dq\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0x6e: /* movd */
		if(prefix_byte == 0x66){
		    printf("%s\t", mnemonic);
		    wbit = LONGOPERAND;
		}
		else{ /* no prefix_byte */
		    sprintf(result1, "%%mm%u", reg);
		    printf("%s\t", mnemonic);
		    wbit = LONGOPERAND;
		}
		break;
	    case 0xd0: /* addsubpd */
	    case 0x7c: /* haddp */
	    case 0x7d: /* hsubp */
		if(prefix_byte == 0x66){
		    printf("%sd\t", mnemonic);
		    sse2 = TRUE;
		}
		else if(prefix_byte == 0xf2){
		    printf("%ss\t", mnemonic);
		    sse2 = TRUE;
		}
		else{ /* no prefix_byte */
		    sprintf(result1, "%%mm%u", reg);
		    printf("%s\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0xd7: /* pmovmskb */
		if(prefix_byte == 0x66){
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    printf("%s\t%%xmm%u,%s\n", mnemonic, xmm_rm(r_m, rex),
			   reg_name);
		    return(length);
		}
		else{ /* no prefix_byte */
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    printf("%s\t%%mm%u,%s\n", mnemonic, r_m, reg_name);
		    return(length);
		}
		break;
	    case 0xda: /* pminub */
	    case 0xde: /* pmaxub */
	    case 0xe4: /* pmulhuw */
	    case 0xea: /* pminsw */
	    case 0xee: /* pmaxsw */
	    case 0xf4: /* pmuludq */
	    case 0xf6: /* psadbw */
		if(prefix_byte == 0x66){
		    sse2 = TRUE;
		    printf("%s\t", mnemonic);
		}
		else{ /* no prefix_byte */
		    sprintf(result1, "%%mm%u", reg);
		    printf("%s\t", mnemonic);
		    mmx = TRUE;
		}
		break;
	    case 0xf0: /* lddqu */
		printf("%s\t", mnemonic);
		sse2 = TRUE;
		break;
	    case 0xf7: /* maskmovdqu & maskmovq */
		sse2 = TRUE;
		if(prefix_byte == 0x66)
		    printf("%sdqu\t", mnemonic);
		else{ /* no prefix_byte */
		    printf("%sq\t%%mm%u,%%mm%u\n", mnemonic, r_m, reg);
		    return(length);
		}
		break;
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%s\n", result1);
	    return(length);

	/* SSE4 instructions */
	case SSE4:
	    sse2 = TRUE;
	    data16 = FALSE;
	    wbit = LONGOPERAND;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    printf("%s\t", mnemonic);
	    sprintf(result1, "%%xmm%u", xmm_reg(reg, rex));
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%s\n", result1);
	    return(length);

	/* SSE4 instructions with 8 bit immediate */
	case SSE4i:
	    sse2 = TRUE;
	    data16 = FALSE;
	    wbit = LONGOPERAND;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    byte = get_value(sizeof(char), sect, &length, &left);
	    printf("%s\t$0x%x,", mnemonic, byte);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%%xmm%u\n", xmm_reg(reg, rex));
	    return(length);

	/* SSE4 instructions with dest to memory and 8-bit immediate */
	case SSE4itm:
	    sse2 = FALSE;
	    data16 = FALSE;
	    wbit = LONGOPERAND;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    byte = get_value(sizeof(char), sect, &length, &left);
	    if(dp == &op0F3A[0x16]){
		if(rex != 0)
		    printf("%sq\t$0x%x,", mnemonic, byte);
		else
		    printf("%sd\t$0x%x,", mnemonic, byte);
	    }
	    else
		printf("%s\t$0x%x,", mnemonic, byte);
	    printf("%%xmm%u,", xmm_reg(reg, rex));
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, "\n");
	    return(length);

	/* SSE4 instructions with src from memory and 8-bit immediate */
	case SSE4ifm:
	    sse2 = FALSE;
	    data16 = FALSE;
	    wbit = LONGOPERAND;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    byte = get_value(sizeof(char), sect, &length, &left);
	    if(dp == &op0F3A[0x22]){
		if(rex != 0)
		    printf("%sq\t$0x%x,", mnemonic, byte);
		else
		    printf("%sd\t$0x%x,", mnemonic, byte);
	    }
	    else
		printf("%s\t$0x%x,", mnemonic, byte);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%%xmm%u\n", xmm_reg(reg, rex));
	    return(length);

	/* SSE4.2 instructions memory or register operand to register */
	case SSE4CRCb:
	    wbit = 0;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    /*
	     * This is to get the byte register names for SSE4CRCb opcodes.
	     */
	    if(mode == REG_ONLY){
		strcpy(result0, REG64_BYTE[(REX_B(rex) << 3) | r_m]);
		symadd0 = NULL;
		symsub0 = NULL;
		value0 = 0;
		value0_size = 0;
	    }
	    else
		GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    reg_name = get_reg_name(reg, 1 /* wbit */, 0 /* data16 */, rex);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  ",");
	    printf("%s\n", reg_name);
	    return(length);

	case SSE4CRC:
	    wbit = 1;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    reg_name = get_reg_name(reg, 1 /* wbit */, 0 /* data16 */, rex);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* SSE2 instructions with 8 bit immediate with further prefix decoding*/
	case SSE2i:
	    data16 = FALSE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    /* pshufw */
	    if((opcode4 << 4 | opcode5) == 0x70 && prefix_byte == 0)
		mmx = TRUE;
	    /* pinsrw */
	    else if((opcode4 << 4 | opcode5) == 0xc4)
		wbit = LONGOPERAND;
	    else
		sse2 = TRUE;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    byte = get_value(sizeof(char), sect, &length, &left);

	    switch(opcode4 << 4 | opcode5){
	    case 0x70: /* pshufd, pshuflw, pshufhw & pshufw */
		if(prefix_byte == 0x66)
		    printf("%sfd\t$0x%x,", mnemonic, byte);
		else if(prefix_byte == 0xf2)
		    printf("%sflw\t$0x%x,", mnemonic, byte);
		else if(prefix_byte == 0xf3)
		    printf("%sfhw\t$0x%x,", mnemonic, byte);
		else{ /* no prefix_byte */
		    printf("%sfw\t$0x%x,", mnemonic, byte);
		    print_operand(seg, symadd0, symsub0, value0, value0_size,
				  result0, ",");
		    printf("%%mm%u\n", reg);
		    return(length);
		}
		break;
	    case 0xc4: /* pinsrw */
		if(prefix_byte == 0x66){
		    printf("%s\t$0x%x,", mnemonic, byte);
		}
		else{ /* no prefix_byte */
		    printf("%s\t$0x%x,", mnemonic, byte);
		    print_operand(seg, symadd0, symsub0, value0, value0_size,
				  result0, ",");
		    printf("%%mm%u\n", reg);
		    return(length);
		}
		break;
	    case 0xc5: /* pextrw */
		if(prefix_byte == 0x66){
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    printf("%s\t$0x%x,%%xmm%u,%s\n", mnemonic, byte,
			   xmm_rm(r_m, rex), reg_name);
		    return(length);
		}
		else{ /* no prefix_byte */
		    reg_name = get_reg_name(reg, 1, data16, rex);
		    printf("%s\t$0x%x,%%mm%u,%s\n", mnemonic, byte, r_m,
			   reg_name);
		    return(length);
		}
		break;
	    default:
		if(prefix_byte == 0x66)
		    printf("%spd\t$0x%x,", mnemonic, byte);
		else if(prefix_byte == 0xf2)
		    printf("%ssd\t$0x%x,", mnemonic, byte);
		else if(prefix_byte == 0xf3)
		    printf("%sss\t$0x%x,", mnemonic, byte);
		else /* no prefix_byte */
		    printf("%sps\t$0x%x,", mnemonic, byte);
		break;
	    }
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, ",");
	    printf("%%xmm%u\n", xmm_reg(reg, rex));
	    return(length);

	/* SSE2 instructions with 8 bit immediate and only 1 reg */
	case SSE2i1:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    byte = get_value(sizeof(char), sect, &length, &left);
	    switch(opcode4 << 4 | opcode5){
	    case 0x71: /* psrlw, psllw, psraw & psrld */
		if(prefix_byte == 0x66){
		    if(reg == 0x2)
			printf("%srlw\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x4)
			printf("%sraw\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x6)
			printf("%sllw\t$0x%x,", mnemonic, byte);
		}
		else{ /* no prefix_byte */
		    if(reg == 0x2)
			printf("%srlw\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x4)
			printf("%sraw\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x6)
			printf("%sllw\t$0x%x,", mnemonic, byte);
		    printf("%%mm%u\n", r_m);
		    return(length);
		}
		break;
	    case 0x72: /* psrld, pslld & psrad */
		if(prefix_byte == 0x66){
		    if(reg == 0x2)
			printf("%srld\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x4)
			printf("%srad\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x6)
			printf("%slld\t$0x%x,", mnemonic, byte);
		}
		else{ /* no prefix_byte */
		    if(reg == 0x2)
			printf("%srld\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x4)
			printf("%srad\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x6)
			printf("%slld\t$0x%x,", mnemonic, byte);
		    printf("%%mm%u\n", r_m);
		    return(length);
		}
		break;
	    case 0x73: /* pslldq & psrldq, psrlq & psllq */
		if(prefix_byte == 0x66){
		    if(reg == 0x7)
			printf("%slldq\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x3)
			printf("%srldq\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x2)
			printf("%srlq\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x6)
			printf("%sllq\t$0x%x,", mnemonic, byte);
		}
		else{ /* no prefix_byte */
		    if(reg == 0x2)
			printf("%srlq\t$0x%x,", mnemonic, byte);
		    else if(reg == 0x6)
			printf("%sllq\t$0x%x,", mnemonic, byte);
		    printf("%%mm%u\n", r_m);
		    return(length);
		}
		break;
	    }
	    printf("%%xmm%u\n", xmm_rm(r_m, rex));
	    return(length);

       /* 3DNow instructions */
       case AMD3DNOW:
               printf("%s\t", mnemonic);
           sprintf(result1, "%%mm%u", reg);
           print_operand(seg, symadd0, symsub0, value0, value0_size,
                         result0, ",");
           printf("%s\n", result1);
           return(length);

	/* prefetch instructions */
	case PFCH:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    switch(reg){
	    case 0:
		printf("%snta", dp->name);
		break;
	    case 1:
		printf("%st0", dp->name);
		break;
	    case 2:
		printf("%st1", dp->name);
		break;
	    case 3:
		printf("%st2", dp->name);
		break;
	    }
	    if(data16 == TRUE)
		printf("w");
	    printf("\t");
           GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
           print_operand(seg, symadd0, symsub0, value0, value0_size,
                         result0, "\n");
           return(length);

       /* 3DNow! prefetch instructions */
       case PFCH3DNOW:
           if(got_modrm_byte == FALSE){
               got_modrm_byte = TRUE;
               byte = get_value(sizeof(char), sect, &length, &left);
               modrm_byte(&mode, &reg, &r_m, byte);
           }
           switch(reg){
           case 0:
               printf("%s\t", dp->name);
               break;
           case 1:
               printf("%sw\t", dp->name);
               break;
           }
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, "\n");
	    return(length);

	/* sfence & clflush */
	case SFEN:
	    if(mode == REG_ONLY && r_m == 0){
		printf("sfence\n");
		return(length);
	    }
	    printf("%s\t", mnemonic);
	    reg = opcode3;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    print_operand(seg, symadd0, symsub0, value0, value0_size,
			  result0, "\n");
	    return(length);

	/* Double shift. Has immediate operand specifying the shift. */
	case DSHIFT:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size, result1);
	    value0_size = sizeof(char);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    printf("%s,", reg_name);
	    print_operand(seg, symadd1, symsub1, value1, value1_size, result1,
			  "\n");
	    return(length);

	/* Double shift. With no immediate operand, specifies using %cl. */
	case DSHIFTcl:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t%%cl,%s,", mnemonic, reg_name);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* immediate to memory or register operand */
	case IMlw:
	    wbit = WBIT(opcode2);
	    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size, result1);
	    /* A long immediate is expected for opcode 0x81, not 0x80 & 0x83 */
	    value0_size = OPSIZE(data16, opcode2 == 1, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    print_operand(seg, symadd1, symsub1, value1, value1_size, result1,
			  "\n");
	    return(length);

	/* immediate to memory or register operand with the 'w' bit present */
	case IMw:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = WBIT(opcode2);
	    GET_OPERAND(&symadd1, &symsub1, &value1, &value1_size, result1);
	    value0_size = OPSIZE(data16, wbit, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    print_operand(seg, symadd1, symsub1, value1, value1_size, result1,
			  "\n");
	    return(length);

	/* immediate to register with register in low 3 bits of op code */
	case IR:
	    wbit = (opcode2 >> 3) & 0x1; /* w-bit here (with regs) is bit 3 */
	    reg = REGNO(opcode2);
	    value0_size = OPSIZE(data16, wbit, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    reg_name = get_r_m_name(reg, wbit, data16, rex);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* immediate to register with register in low 3 bits of op code,
	   possibly with a 64-bit immediate */
	case IR64:
	    wbit = (opcode2 >> 3) & 0x1; /* w-bit here (with regs) is bit 3 */
	    reg = REGNO(opcode2);
	    value0_size = OPSIZE(data16, wbit, REX_W(rex));
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    reg_name = get_r_m_name(reg, wbit, data16, rex);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* memory operand to accumulator */
	case OA:
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64){
		value0_size = OPSIZE(addr16, LONGOPERAND, 1);
		if(opcode1 == 0xa && opcode2 == 0x0){
		    strcpy(mnemonic, "movabsb");
		    /*
		     * The REX 64-bit operand-size, REX.W aka 0x8, has no effect
		     * on byte size operations. Clear it to get the correct
		     * register from get_reg_name().
		     */
		    rex &= ~0x8;
		}
		else if(opcode1 == 0xa && opcode2 == 0x1){
		    if(rex != 0)
			strcpy(mnemonic, "movabsq");
		    else if(data16 == TRUE)
			strcpy(mnemonic, "movabsw");
		    else
			strcpy(mnemonic, "movabsl");
		}
	    }
	    else
		value0_size = OPSIZE(addr16, LONGOPERAND, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, imm0, value0_size, "", ",");
	    wbit = WBIT(opcode2);
	    reg_name = get_reg_name(0, wbit, data16, rex);
	    printf("%s\n", reg_name);
	    return(length);

	/* accumulator to memory operand */
	case AO:
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64){
		value0_size = OPSIZE(addr16, LONGOPERAND, 1);
		if(opcode1 == 0xa && opcode2 == 0x2){
		    strcpy(mnemonic, "movabsb");
		    /*
		     * The REX 64-bit operand-size, REX.W aka 0x8, has no effect
		     * on byte size operations. Clear it to get the correct
		     * register from get_reg_name().
		     */
		    rex &= ~0x8;
		}
		else if(opcode1 == 0xa && opcode2 == 0x3){
		    if(rex != 0)
			strcpy(mnemonic, "movabsq");
		    else if(data16 == TRUE)
			strcpy(mnemonic, "movabsw");
		    else
			strcpy(mnemonic, "movabsl");
		}
	    }
	    else
		value0_size = OPSIZE(addr16, LONGOPERAND, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    wbit = WBIT(opcode2);
	    reg_name = get_reg_name(0, wbit, data16, rex);
	    printf("%s\t%s,", mnemonic, reg_name);
	    print_operand(seg, symadd0, symsub0, imm0, value0_size, "", "\n");
	    return(length);

	/* memory or register operand to segment register */
	case MS:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  ",");
	    printf("%s\n", SEGREG[reg]);
	    return(length);

	/* segment register to memory or register operand	*/
	case SM:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t%s,", mnemonic, SEGREG[reg]);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* rotate or shift instrutions, which may shift by 1 or */
	/* consult the cl register, depending on the 'v' bit	*/
	case Mv:
	    vbit = VBIT(opcode2);
	    wbit = WBIT(opcode2);
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    /* When vbit is set, register is an operand, otherwise just $0x1 */
	    reg_name = vbit ? "%cl," : "" ;
	    printf("%s\t%s", mnemonic, reg_name);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* immediate rotate or shift instrutions, which may or */
	/* may not consult the cl register, depending on the 'v' bit */
	case MvI:
	    vbit = VBIT(opcode2);
	    wbit = WBIT(opcode2);
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    value1_size = sizeof(char);
	    IMMEDIATE(&symadd1, &symsub1, &imm0, value1_size);
	    /* When vbit is set, register is an operand, otherwise just $0x1 */
	    reg_name = vbit ? "%cl," : "" ;
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd1, symsub1, imm0, value1_size, "", ",");
	    printf("%s", reg_name);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	case MIb:
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    value1_size = sizeof(char);
	    IMMEDIATE(&symadd1, &symsub1, &imm0, value1_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd1, symsub1, imm0, value1_size, "", ",");
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* single memory or register operand with 'w' bit present */
	case Mw:
	    wbit = WBIT(opcode2);
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* single memory or register operand but don't use 'l' suffix */
	case Mnol:
	/* single memory or register operand */
	case M:
	    if(opcode1 == 0x0 && opcode2 == 0xf &&
	       opcode4 == 0x0 && opcode5 == 0x1){
		switch(byte){
		case 0xc1:
		    printf("vmcall\n");
		    return(length);
		case 0xc2:
		    printf("vmlaunch\n");
		    return(length);
		case 0xc3:
		    printf("vmresume\n");
		    return(length);
		case 0xc4:
		    printf("vmxoff\n");
		    return(length);
		}
	    }
	    if(opcode1 == 0x0 && opcode2 == 0xf && byte == 0xc7){
		if(prefix_byte == 0x66)
		    sprintf(mnemonic, "vmclear");
		else if(prefix_byte == 0xf3)
		    sprintf(mnemonic, "vmxon");
		else{
		    if(got_modrm_byte == FALSE){
			got_modrm_byte = TRUE;
			byte = get_value(sizeof(char), sect, &length, &left);
			modrm_byte(&mode, &reg, &r_m, byte);
		    }
		    if(reg == 6)
			sprintf(mnemonic, "vmptrld");
		    else if(reg == 7)
			sprintf(mnemonic, "vmptrst");
		    else if(reg == 1 && REX_W(rex))
			sprintf(mnemonic, "cmpxchg16b");
		}
	    }
	    /*
	     * Hacks for lldt, lmsw, ltr, verr and verw which take only a
	     * r/m16 operands.
	     */
	    if(opcode1 == 0 && opcode2 == 0xf && opcode4 == 0 && opcode5 == 1 &&
	       (opcode3 == 6))
		data16 = TRUE;
	    if(opcode1 == 0 && opcode2 == 0xf && opcode4 == 0 && opcode5 == 0 &&
	       (opcode3 == 2 || opcode3 == 3 || opcode3 == 4 || opcode3 == 5))
		data16 = TRUE;
	    /*
	     * Hacks for fnstsw which take only a r/m16 operand.
	     */
	    if((opcode1 == 0xd && opcode2 == 0xf && byte == 0xe0) ||
	       (opcode1 == 0xd && opcode2 == 0xd && opcode3 == 0x7))
		data16 = TRUE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* single memory or register operand */
	case Mb:
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = BYTEOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	case SREG: /* special register */
	    byte = get_value(sizeof(char), sect, &length, &left);
	    modrm_byte(&mode, &reg, &r_m, byte);
	    vbit = 0;
	    switch(opcode5){
	    case 2:
		vbit = 1;
		/* fall thru */
	    case 0: 
		if(llvm_mc == TRUE){
		    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
		        reg_name = LLVM_MC_64_CONTROLREG[reg+(REX_R(rex) << 3)];
		    else
		        reg_name = LLVM_MC_32_CONTROLREG[reg+(REX_R(rex) << 3)];
		}
		else{
		    reg_name = CONTROLREG[reg + (REX_R(rex) << 3)];
		}
		break;
	    case 3:
		vbit = 1;
		/* fall thru */
	    case 1:
		if(llvm_mc == TRUE)
		    reg_name = LLVM_MC_DEBUGREG[reg + (REX_R(rex) << 3)];
		else
		    reg_name = DEBUGREG[reg + (REX_R(rex) << 3)];
		break;
	    case 6:
		vbit = 1;
		/* fall thru */
	    case 4:
		reg_name = TESTREG[reg];
		break;
	    }
	    if(vbit){
		printf("%s\t%s,%s\n", mnemonic, get_r_m_name(r_m, 1, data16,
		       rex), reg_name);
	    }
	    else{
		printf("%s\t%s,%s\n", mnemonic, reg_name, get_r_m_name(r_m, 1,
		       data16, rex));
	    }
	    return(length);

	/* single register operand with register in the low 3	*/
	/* bits of op code					*/
	case R:
	    reg = REGNO(opcode2);
	    reg_name = get_r_m_name(reg, LONGOPERAND, data16, rex);
	    printf("%s\t%s\n", mnemonic, reg_name);
	    return(length);

	/* register to accumulator with register in the low 3	*/
	/* bits of op code, xchg instructions                   */
	case RA:
	    reg = REGNO(opcode2);
	    if(rex)
		reg_name = REG32[reg + (REX_B(rex) << 3)]
				[LONGOPERAND + REX_W(rex)];
	    else
		reg_name = get_reg_name(reg, LONGOPERAND, data16, rex);
	    if(rex)
		printf("%s\t%s,%s\n", mnemonic, reg_name, "%rax");
	    else
		printf("%s\t%s,%s\n", mnemonic, reg_name, (data16 ?
							  "%ax" : "%eax"));
	    return(length);

	/* single segment register operand, with reg in bits 3-4 of op code */
	case SEG:
	    reg = byte >> 3 & 0x3; /* segment register */
	    printf("%s\t%s\n", mnemonic, SEGREG[reg]);
	    return(length);

	/* single segment register operand, with register in	*/
	/* bits 3-5 of op code					*/
	case LSEG:
	    reg = byte >> 3 & 0x7; /* long seg reg from opcode */
	    printf("%s\t%s\n", mnemonic, SEGREG[reg]);
	    return(length);

	/* memory or register operand to register */
	case MR:
	    /*
	     * invvpid and invept outside 64-bit mode the register operand is
	     * always 32 bits, since this is encoded with 0x66 (operand-size
	     * override) it would have set data16. So clear that to get the
	     * correct value from reg_name().
	     */
	    if((opcode1 == 0x0 && opcode2 == 0xf &&
	        opcode4 == 0x3 && opcode5 == 0x8 && prefix_byte == 0x66) &&
		(byte == 0x81 || byte == 0x80) &&
		(cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64)
		data16 = FALSE;
	    if(got_modrm_byte == FALSE){
		got_modrm_byte = TRUE;
		byte = get_value(sizeof(char), sect, &length, &left);
		modrm_byte(&mode, &reg, &r_m, byte);
	    }
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    reg_name = get_reg_name(reg, wbit, data16, rex);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* immediate operand to accumulator */
	case IA:
	    value0_size = OPSIZE(data16, WBIT(opcode2), 0);
	    switch(value0_size) {
		case 1: reg_name = "%al"; break;
		case 2: reg_name = "%ax"; break;
		case 4: reg_name = "%eax"; break;
	    }
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",");
	    printf("%s\n", reg_name);
	    return(length);

	/* memory or register operand to accumulator */
	case MA:
	    wbit = WBIT(opcode2);
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* si register to di register */
	case SD:
	    if(addr16 == TRUE)
		printf("%s\t%s(%%si),(%%di)\n", mnemonic, seg);
	    else
		printf("%s\t%s(%%esi),(%%edi)\n", mnemonic, seg);
	    return(length);

	/* accumulator to di register */
	case AD:
	    wbit = WBIT(opcode2);
	    reg_name = get_reg_name(0, wbit, data16, rex);
	    if(addr16 == TRUE)
		printf("%s\t%s,%s(%%di)\n", mnemonic, reg_name, seg);
	    else
		printf("%s\t%s,%s(%%edi)\n", mnemonic, reg_name, seg);
	    return(length);

	/* si register to accumulator */
	case SA:
	    wbit = WBIT(opcode2);
	    reg_name = get_reg_name(0, wbit, data16, rex);
	    if(addr16 == TRUE)
		printf("%s\t%s(%%si),%s\n", mnemonic, seg, reg_name);
	    else
		printf("%s\t%s(%%esi),%s\n", mnemonic, seg, reg_name);
	    return(length);

	/* single operand, a 16/32 bit displacement */
	case D:
	    value0_size = OPSIZE(data16, LONGOPERAND, 0);
	    DISPLACEMENT(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, imm0, value0_size, "", "");
	    if(verbose){
		indirect_symbol_name = guess_indirect_symbol(imm0,
		    ncmds, sizeofcmds, load_commands, object_byte_sex,
		    indirect_symbols, nindirect_symbols, symbols, symbols64,
		    nsymbols, strings,strings_size);
		if(indirect_symbol_name != NULL)
		    printf("\t; symbol stub for: %s", indirect_symbol_name);
	    }
	    printf("\n");
	    return(length);

	/* indirect to memory or register operand */
	case INM:
	    /*
	     * If this is call (near) in a 64-bit object the FF /2 opcode
	     * results in a 64-bit operand even without a rex prefix byte.
	     * So to get the 64-bit register names in the disassembly we
	     * set the REX.W bit to indicate 64-bit operand size.
	     */
	    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
	       opcode1 == 0xf && opcode2 == 0xf &&
	       (opcode3 == 2 || opcode3 == 4))
		rex |= 0x8;
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    if((mode == 0 && (r_m == 5 || r_m == 4)) || mode == 1 ||
		mode == 2 || mode == 3)
		printf("%s\t*", mnemonic);
	    else
		printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/* indirect to memory or register operand (for lcall and ljmp) */
	case INMl:
	    wbit = LONGOPERAND;
	    GET_OPERAND(&symadd0, &symsub0, &value0, &value0_size, result0);
	    printf("%s\t*", mnemonic);
	    print_operand(seg, symadd0, symsub0, value0, value0_size, result0,
			  "\n");
	    return(length);

	/*
	 * For long jumps and long calls -- a new code segment
	 * register and an offset in IP -- stored in object
	 * code in reverse order
	 */
	case SO:
	    value1_size = OPSIZE(data16, LONGOPERAND, 0);
	    IMMEDIATE(&symadd1, &symsub1, &imm1, value1_size);
	    value0_size = sizeof(short);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",$");
	    print_operand(seg, symadd1, symsub1, imm1, value1_size, "", "\n");
	    return(length);

	/* jmp/call. single operand, 8 bit displacement */
	case BD:
	    /*
	     * The "Jump if rCX Zero" instruction is 0xe3 but is "jcxz" as in
	     * the table only in 32-bit mode with a Address-size override
	     * prefix.  Without a prefix it is "jecxz" in 32-bit mode.  In
	     * 64-bit mode with a prefix it is "jecxz" and without it is
	     * "jrcxz".
	     */
	    if(opcode1 == 0xe && opcode2 == 0x3){
		if((cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64){
		   if(addr16 == FALSE)
			sprintf(mnemonic, "jecxz");
		}
		else if ((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64){
		   if(addr16 == TRUE)
			sprintf(mnemonic, "jecxz");
		   else
			sprintf(mnemonic, "jrcxz");
		}
	    }
	    value0_size = sizeof(char);
	    DISPLACEMENT(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t", mnemonic);
	    print_operand(seg, symadd0, symsub0, imm0, sizeof(int32_t), "",
			  "\n");
	    return(length);

	/* single 32/16 bit immediate operand */
	case I:
	    value0_size = OPSIZE(data16, LONGOPERAND, 0);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", "\n");
	    return(length);

	/* single 8 bit immediate operand */
	case Ib:
	    value0_size = sizeof(char);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", "\n");
	    return(length);

	case ENTER:
	    value0_size = sizeof(short);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    value1_size = sizeof(char);
	    IMMEDIATE(&symadd1, &symsub1, &imm1, value1_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", ",$");
	    print_operand("", symadd1, symsub1, imm1, value1_size, "", "\n");
	    return(length);

	/* 16-bit immediate operand */
	case RET:
	    value0_size = sizeof(short);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand("", symadd0, symsub0, imm0, value0_size, "", "\n");
	    return(length);

	/* single 8 bit port operand */
	case P:
	    value0_size = sizeof(char);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    print_operand(seg, symadd0, symsub0, imm0, value0_size, "", "\n");
	    return(length);

	/* single 8 bit (input) port operand				*/
	case Pi:
	    value0_size = sizeof(char);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    printf("%s\t$", mnemonic);
	    if(opcode2 == 4)
		print_operand(seg, symadd0, symsub0, imm0, value0_size, "",
			      ",%al\n");
	    else if(data16)
		print_operand(seg, symadd0, symsub0, imm0, value0_size, "",
			      ",%ax\n");
	    else
		print_operand(seg, symadd0, symsub0, imm0, value0_size, "",
			      ",%eax\n");
	    return(length);

	/* single 8 bit (output) port operand				*/
	case Po:
	    value0_size = sizeof(char);
	    IMMEDIATE(&symadd0, &symsub0, &imm0, value0_size);
	    if(opcode2 == 0x6)
		printf("%s\t%%al,$", mnemonic);
	    else if(data16)
		printf("%s\t%%ax,$", mnemonic);
	    else
		printf("%s\t%%eax,$", mnemonic);
	    print_operand(seg, symadd0, symsub0, imm0, value0_size, "", "\n");
	    return(length);

	/* single operand, dx register (variable port instruction) */
	case V:
	    printf("%s\t%s(%%dx)\n", mnemonic, seg);
	    return(length);

	/* single operand, dx register (variable (input) port instruction) */
	case Vi:
	    if(opcode2 == 0xc)
		printf("%s\t%s%%dx,%%al\n", mnemonic, seg);
	    else if(data16)
		printf("%s\t%s%%dx,%%ax\n", mnemonic, seg);
	    else
		printf("%s\t%s%%dx,%%eax\n", mnemonic, seg);
	    return(length);

	/* single operand, dx register (variable (output) port instruction)*/
	case Vo:
	    if(opcode2 == 0xe)
		printf("%s\t%s%%al,%%dx\n", mnemonic, seg);
	    else if(data16)
		printf("%s\t%s%%ax,%%dx\n", mnemonic, seg);
	    else
		printf("%s\t%s%%eax,%%dx\n", mnemonic, seg);
	    return(length);

	/* The int instruction, which has two forms: int 3 (breakpoint) or  */
	/* int n, where n is indicated in the subsequent byte (format Ib).  */
	/* The int 3 instruction (opcode 0xCC), where, although the 3 looks */
	/* like an operand, it is implied by the opcode. It must be converted */
	/* to the correct base and output. */
	case INT3:
	    printf("%s\t$0x3\n", mnemonic);
	    return(length);

	/* just an opcode and an unused byte that must be discarded */
	case U:
	    byte = get_value(sizeof(char), sect, &length, &left);
	    if(opcode1 == 0xd && (opcode2 == 0x5 || opcode2 == 0x4) &&
	       byte != 0xa)
		printf("%s\t$0x%x\n", mnemonic, byte);
	    else
		printf("%s\n", mnemonic);
	    return(length);

	case CBW:
	    if(rex != 0)
		printf("cdqe\n");
	    else if(data16 == TRUE)
		printf("cbtw\n");
	    else
		printf("cwtl\n");
	    return(length);

	case CWD:
	    if(rex != 0)
		printf("cqto\n");
	    else if(data16 == TRUE)
		printf("cwtd\n");
	    else
		printf("cltd\n");
	    return(length);

	/* no disassembly, the mnemonic was all there was so go on */
	case GO_ON:
	    printf("%s\n", mnemonic);
	    return(length);

	/* float reg */
	case F:
	    printf("%s\t%%st(%1.1u)\n", mnemonic, r_m);
	    return(length);

	/* float reg to float reg, with ret bit present */
	case FF:
	    /* return result bit for 287 instructions */
	    if(((opcode2 >> 2) & 0x1) == 0x1 && opcode2 != 0xf)
		printf("%s\t%%st,%%st(%1.1u)\n", mnemonic, r_m);
	    else
		printf("%s\t%%st(%1.1u),%%st\n", mnemonic, r_m);
	    return(length);

	/* an invalid op code */
	case AM:
	case DM:
	case OVERRIDE:
	case PREFIX:
	case UNKNOWN:
	default:
	    printf(".byte 0x%02x", 0xff & sect[0]);
	    for(i = 1; i < length; i++)
		printf(", 0x%02x", 0xff & sect[i]);
	    printf(" #bad opcode\n");
	    return(length);
	} /* end switch */
}

/*
 * get_operand() is used to return the symbolic operand for an operand that is
 * encoded with a mod r/m byte.
 */
static
void
get_operand(
const char **symadd,
const char **symsub,
uint32_t *value,
uint32_t *value_size,
char *result,

const cpu_type_t cputype,
const uint32_t mode,
const uint32_t r_m,
const uint32_t wbit,
const enum bool data16,
const enum bool addr16,
const enum bool sse2,
const enum bool mmx,
const unsigned int rex,

const char *sect,
uint32_t sect_addr,
uint32_t *length,
uint32_t *left,

const uint32_t addr,
const struct relocation_info *sorted_relocs,
const uint32_t nsorted_relocs,
const struct relocation_info *ext_relocs,
const uint32_t next_relocs,
const struct nlist *symbols,
const struct nlist_64 *symbols64,
const uint32_t nsymbols,
const char *strings,
const uint32_t strings_size,

const struct symbol *sorted_symbols,
const uint32_t nsorted_symbols,
const enum bool verbose)
{
    enum bool s_i_b;		/* flag presence of scale-index-byte */
    unsigned char byte;		/* the scale-index-byte */
    uint32_t ss;		/* scale-factor from scale-index-byte */
    uint32_t index; 		/* index register number from scale-index-byte*/
    uint32_t base;  		/* base register number from scale-index-byte */
    uint32_t sect_offset, seg_offset;
    uint64_t offset;

	*symadd = NULL;
	*symsub = NULL;
	*value = 0;
	*result = '\0';
	base = 0;
	index = 0;
	ss = 0;

	/* check for the presence of the s-i-b byte */
	if(r_m == ESP && mode != REG_ONLY &&
	   (((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64) || addr16 == FALSE)){
	    s_i_b = TRUE;
	    byte = get_value(sizeof(char), sect, length, left);
	    modrm_byte(&ss, &index, &base, byte);
	}
	else
	    s_i_b = FALSE;

	if(addr16 && (cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64)
	    *value_size = dispsize16[r_m][mode];
	else
	    *value_size = dispsize32[r_m][mode];

	if(s_i_b == TRUE && mode == 0 && base == EBP)
	    *value_size = sizeof(int32_t);

	if(*value_size != 0){
	    seg_offset = addr + *length;
	    sect_offset = addr + *length - sect_addr;
	    *value = get_value(*value_size, sect, length, left);
	    GET_SYMBOL(symadd, symsub, &offset, sect_offset, seg_offset,*value);
	    if(*symadd != NULL){
		*value = offset;
	    }
	    else{
		*symadd = GUESS_SYMBOL(*value);
		if(*symadd != NULL)
		    *value = 0;
	    }
	}

	if(s_i_b == TRUE){
	    if(((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64) && !addr16){
		/* If the scale factor is 1, don't display it. */
		if(ss == 0){
		    /*
		     * If mode is 0 and base is 5 (regardless of the rex bit)
		     * there is no base register, and if the index is
		     * also 4 then the operand is just a displacement.
		     */
		    if(mode == 0 && base == 5 && index == 4){
			result = "";
		    }
		    else{
			sprintf(result, "(%s%s)", regname64[mode][base +
				(REX_B(rex) << 3)], indexname64[index +
				(REX_X(rex) << 3)]);
		    }
		}
		else{
		    /*
		     * If mode is 0 and base is 5 (regardless of the rex bit)
		     * there is no base register.
		     */
		    if(mode == 0 && base == 5){
			sprintf(result, "(%s,%s)", indexname64[index +
				(REX_X(rex) << 3)], scale_factor[ss]);
		    }
		    else{
			sprintf(result, "(%s%s,%s)", regname64[mode][base +
				(REX_B(rex) << 3)], indexname64[index +
				(REX_X(rex) << 3)], scale_factor[ss]);
		    }
		}
	    }
	    else{
		/* If the scale factor is 1, don't display it. */
		if(ss == 0){
		    /*
		     * If mode is 0 and base is 5 it there is no base register,
		     * and if the index is also 4 then the operand is just a
		     * displacement.
		     */
		    if(mode == 0 && base == 5 && index == 4){
			result = "";
		    }
		    else{
			sprintf(result, "(%s%s)", regname32[mode][base],
				indexname[index]);
		    }
		}
		else{
		    sprintf(result, "(%s%s,%s)", regname32[mode][base],
			    indexname[index], scale_factor[ss]);
		}
	    }
	}
	else{ /* no s-i-b */
	    if(mode == REG_ONLY){
		if(sse2 == TRUE)
		    sprintf(result, "%%xmm%u", xmm_rm(r_m, rex));
		else if(mmx == TRUE)
		    sprintf(result, "%%mm%u", r_m);
		else if (data16 == FALSE || rex != 0)
		    /* The presence of a REX byte overrides 66h. */
		    strcpy(result, REG32[r_m + (REX_B(rex) << 3)][wbit +
			   REX_W(rex)]);
		else
		    strcpy(result, REG16[r_m][wbit]);
	    }
	    else{ /* Modes 00, 01, or 10 */
		if(r_m == EBP && mode == 0){ /* displacement only */
		    if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
			/*
			 * In 64-bit mode, mod=00 and r/m=101 defines
			 * RIP-relative addressing with a 32-bit displacement.
			 * In 32-bit mode, it's just a 32-bit displacement. See
			 * section 2.2.1.6 ("RIP-Relative Addressing") of Volume
			 * 2A of the Intel IA-32 manual.
			 */
			sprintf(result, "(%%rip)");
		    else
			*result = '\0';
		}
		else {
		    /* Modes 00, 01, or 10, not displacement only, no s-i-b */
		    if(addr16 == TRUE) {
			if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
			    /*
			     *  In 64-bit mode, the address size prefix drops us
			     * down to 32-bit, not 16-bit.
			     */
			    sprintf(result, "(%s)", regname32[mode][r_m]);
			else
			    sprintf(result, "(%s)", regname16[mode][r_m]);
		    }
		    else{
			if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
			    sprintf(result, "(%s)", regname64[mode][r_m +
				    (REX_B(rex) << 3)]);
			else
			    sprintf(result, "(%s)", regname32[mode][r_m]);
		    }
		}
	    }
	}
}

/*
 * immediate() is used to return the symbolic operand for an immediate operand.
 */
static
void
immediate(
const char **symadd,
const char **symsub,
uint64_t *value,
uint32_t value_size,

const char *sect,
uint32_t sect_addr,
uint32_t *length,
uint32_t *left,

const cpu_type_t cputype,
const uint32_t addr,
const struct relocation_info *sorted_relocs,
const uint32_t nsorted_relocs,
const struct relocation_info *ext_relocs,
const uint32_t next_relocs,
const struct nlist *symbols,
const struct nlist_64 *symbols64,
const uint32_t nsymbols,
const char *strings,
const uint32_t strings_size,

const struct symbol *sorted_symbols,
const uint32_t nsorted_symbols,
const enum bool verbose)
{
    uint32_t sect_offset, seg_offset;
	uint64_t offset;

	seg_offset = addr + *length;
	sect_offset = addr + *length - sect_addr;
	*value = get_value(value_size, sect, length, left);
	GET_SYMBOL(symadd, symsub, &offset, sect_offset, seg_offset, *value);
	if(*symadd == NULL){
	    *symadd = GUESS_SYMBOL(*value);
	    if(*symadd != NULL)
		*value = 0;
	}
	else if(*symsub != NULL){
	    *value = offset;
	}
}

/*
 * displacement() is used to return the symbolic operand for an operand that is
 * encoded as a displacement from the program counter.
 */
static
void
displacement(
const char **symadd,
const char **symsub,
uint64_t *value,
const uint32_t value_size,

const char *sect,
uint64_t sect_addr,
uint32_t *length,
uint32_t *left,

const cpu_type_t cputype,
const uint64_t addr,
const struct relocation_info *sorted_relocs,
const uint32_t nsorted_relocs,
const struct relocation_info *ext_relocs,
const uint32_t next_relocs,
const struct nlist *symbols,
const struct nlist_64 *symbols64,
const uint32_t nsymbols,
const char *strings,
const uint32_t strings_size,

const struct symbol *sorted_symbols,
const uint32_t nsorted_symbols,
const enum bool verbose)
{
    uint32_t sect_offset, seg_offset;
    uint64_t offset;
    uint64_t guess_addr;

	seg_offset = addr + *length;
	sect_offset = addr + *length - sect_addr;
	*value = get_value(value_size, sect, length, left);
	switch(value_size){
	case 1:
	    if((*value) & 0x80)
		*value = *value | 0xffffffffffffff00ULL;
	    break;
	case 2:
	    if((*value) & 0x8000)
		*value = *value | 0xffffffffffff0000ULL;
	    break;
	case 4:
	    if((*value) & 0x80000000)
		*value = *value | 0xffffffff00000000ULL;
	    break;
	}
	if((cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64)
	    *value += addr + *length;

	GET_SYMBOL(symadd, symsub, &offset, sect_offset, seg_offset, *value);
	if(*symadd == NULL){
	    if((cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64){
		*symadd = GUESS_SYMBOL(*value);
		if(*symadd != NULL)
		    *value = 0;
	    }
	    else{
		guess_addr = *value;
		if((*value) & 0x80000000)
		    guess_addr |= 0xffffffff00000000ULL;
		guess_addr += addr + *length;
		*symadd = GUESS_SYMBOL(guess_addr);
		if(*symadd != NULL)
		    *value = 0;
		else
		    *value += addr + *length;
	    }
	}
	else if(*symsub != NULL){
	    *value = offset;
	}
	if((cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64)
	    *value = *value & 0x00000000ffffffffULL;
}

/*
 * get_symbol() returns the name of a symbol (or NULL) based on the relocation
 * information at the specified address.
 */
static
void
get_symbol(
const char **symadd,
const char **symsub,
uint64_t *offset,

const cpu_type_t cputype,
const uint32_t sect_offset,
const uint32_t seg_offset,
const uint64_t value,
const struct relocation_info *relocs,
const uint32_t nrelocs,
const struct relocation_info *ext_relocs,
const uint32_t next_relocs,
const struct nlist *symbols,
const struct nlist_64 *symbols64,
const uint32_t nsymbols,
const char *strings,
const uint32_t strings_size,
const struct symbol *sorted_symbols,
const uint32_t nsorted_symbols,
const enum bool verbose)
{
    uint32_t i;
    unsigned int r_symbolnum;
    uint32_t n_strx;
    struct scattered_relocation_info *sreloc, *pair;
    const char *name, *add, *sub;

    static char add_buffer[11]; /* max is "0x1234678\0" */
    static char sub_buffer[11];

	*symadd = NULL;
	*symsub = NULL;
	*offset = value;

	if(verbose == FALSE)
	    return;

	for(i = 0; i < nrelocs; i++){
	    if((cputype & CPU_ARCH_ABI64) != CPU_ARCH_ABI64 &&
	       ((relocs[i].r_address) & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		if(sreloc->r_type == GENERIC_RELOC_PAIR){
		    fprintf(stderr, "Stray GENERIC_RELOC_PAIR relocation entry "
			    "%u\n", i);
		    continue;
		}
		if(sreloc->r_type == GENERIC_RELOC_VANILLA){
		    if(sreloc->r_address == sect_offset){
			name = guess_symbol(sreloc->r_value,
					    sorted_symbols,
					    nsorted_symbols,
					    verbose);
			if(name != NULL){
			    *symadd = name;
			    *offset = value - sreloc->r_value;
			    return;
			}
		    }
		    continue;
		}
		if(sreloc->r_type != GENERIC_RELOC_SECTDIFF &&
		   sreloc->r_type != GENERIC_RELOC_LOCAL_SECTDIFF){
		    fprintf(stderr, "Unknown relocation r_type for entry "
			    "%u\n", i);
		    continue;
		}
		if(i + 1 < nrelocs){
		    pair = (struct scattered_relocation_info *)(relocs + i + 1);
		    if(pair->r_scattered == 0 ||
		       pair->r_type != GENERIC_RELOC_PAIR){
			fprintf(stderr, "No GENERIC_RELOC_PAIR relocation "
				"entry after entry %u\n", i);
			continue;
		    }
		}
		else{
		    fprintf(stderr, "No GENERIC_RELOC_PAIR relocation entry "
			    "after entry %u\n", i);
		    continue;
		}
		i++; /* skip the pair reloc */

		if(sreloc->r_address == sect_offset){
		    add = guess_symbol(sreloc->r_value, sorted_symbols,
				       nsorted_symbols, verbose);
		    sub = guess_symbol(pair->r_value, sorted_symbols,
				       nsorted_symbols, verbose);
		    if(add == NULL){
			sprintf(add_buffer, "0x%x",
				(unsigned int)sreloc->r_value);
			add = add_buffer;
		    }
		    if(sub == NULL){
			sprintf(sub_buffer, "0x%x",
				(unsigned int)pair->r_value);
			sub = sub_buffer;
		    }
		    *symadd = add;
		    *symsub = sub;
		    *offset = value - (sreloc->r_value - pair->r_value);
		    return;
		}
	    }
	    else{
		if((uint32_t)relocs[i].r_address == sect_offset){
		    r_symbolnum = relocs[i].r_symbolnum;
		    if(relocs[i].r_extern){
		        if(r_symbolnum >= nsymbols)
			    return;
			if(symbols != NULL)
			    n_strx = symbols[r_symbolnum].n_un.n_strx;
			else
			    n_strx = symbols64[r_symbolnum].n_un.n_strx;
			if(n_strx <= 0 || n_strx >= strings_size)
			    return;
			if((cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64 &&
			   relocs[i].r_type == X86_64_RELOC_SUBTRACTOR &&
			   i+1 < nrelocs &&
			   relocs[i+1].r_type == X86_64_RELOC_UNSIGNED &&
			   relocs[i+1].r_extern == 1 &&
			   relocs[i+1].r_symbolnum < nsymbols){
			    *symsub = strings + n_strx;
			    r_symbolnum = relocs[i+1].r_symbolnum;
			    if(symbols64 == NULL)
				return;
			    n_strx = symbols64[r_symbolnum].n_un.n_strx;
			    if(n_strx <= 0 || n_strx >= strings_size)
				return;
			}
			*symadd = strings + n_strx;
			return;
		    }
		    break;
		}
	    }
	}

	for(i = 0; i < next_relocs; i++){
	    if((uint32_t)ext_relocs[i].r_address == seg_offset){
		r_symbolnum = ext_relocs[i].r_symbolnum;
		if(ext_relocs[i].r_extern){
		    if(r_symbolnum >= nsymbols)
			return;
		    if(symbols != NULL)
			n_strx = symbols[r_symbolnum].n_un.n_strx;
		    else
			n_strx = symbols64[r_symbolnum].n_un.n_strx;
		    if(n_strx <= 0 || n_strx >= strings_size)
			return;
		    *symadd = strings + n_strx;
		    return;
		}
		break;
	    }
	}
}

/*
 * print_operand() prints an operand from it's broken out symbolic
 * representation.
 */
static
void
print_operand(
const char *seg,
const char *symadd,
const char *symsub,
uint64_t value,
unsigned int value_size,
const char *result,
const char *tail)
{
	if(symadd != NULL){
	    if(symsub != NULL){
		if(value_size != 0){
		    if(value != 0)
			printf("%s%s-%s+0x%0*llx%s%s", seg, symadd, symsub,
			       (int)value_size * 2, value, result, tail);
		    else
			printf("%s%s-%s%s%s",seg, symadd, symsub, result, tail);
		}
		else{
		    printf("%s%s%s%s", seg, symadd, result, tail);
		}
	    }
	    else{
		if(value_size != 0){
		    if(value != 0)
			printf("%s%s+0x%0*llx%s%s", seg, symadd,
			       (int)value_size * 2, value, result, tail);
		    else
			printf("%s%s%s%s", seg, symadd, result, tail);
		}
		else{
		    printf("%s%s%s%s", seg, symadd, result, tail);
		}
	    }
	}
	else{
	    if(value_size != 0){
		printf("%s0x%0*llx%s%s", seg, (int)value_size *2, value, result,
		       tail);
	    }
	    else{
		printf("%s%s%s", seg, result, tail);
	    }
	}
}

/*
 * get_value() gets a value of size from sect + length and decrease left by the
 * size and increase length by size.  The size of the value can be 1, 2, 4, or 8
 * bytes and the value is in little endian byte order.  The value is always
 * returned as a uint64_t and is not sign extended.
 */
static
uint64_t
get_value(
const uint32_t size,	/* size of the value to get as a number of bytes (in)*/
const char *sect,	/* pointer to the raw data of the section (in) */
uint32_t *length,	/* number of bytes taken from the sect (in/out) */
uint32_t *left)		/* number of bytes left in sect after length (in/out) */
{
    uint32_t i;
    uint64_t value;
    unsigned char byte;

	if(left == 0)
	    return(0);

	value = 0;
	for(i = 0; i < size; i++) {
	    byte = 0;
	    if(*left > 0){
		byte = sect[*length];
		(*length)++;
		(*left)--;
	    }
	    value |= (uint64_t)byte << (8*i);
	}
	return(value);
}

/*
 * modrm_byte() breaks a byte out into its mode, reg and r/m bits.
 */
static
void
modrm_byte(
uint32_t *mode,
uint32_t *reg,
uint32_t *r_m,
unsigned char byte)
{
	*r_m = byte & 0x7; /* r/m field from the byte */
	*reg = byte >> 3 & 0x7; /* register field from the byte */
	*mode = byte >> 6 & 0x3; /* mode field from the byte */
}

/*
 * i386GetOpInfo() is the operand information call back function for i386 code.
 * This is called to get the symbolic information for an operand of an i386
 * instruction.  This is done from the relocation information, symbol table,
 * etc.  That block of information is a pointer to the struct disassemble_info
 * that was passed when the disassembler context was created and passed to back
 * to i386GetOpInfo() when called back by LLVMDisasmInstruction().  The address
 * of the instruction containing operand is at the Pc parameter.  The immediate
 * for the operand is at Offset past the start of the instruction and has a byte
 * Width of 1, 2 or 4.  The information is returned in TagBuf is the
 * LLVMOpInfo1 struct defined in "llvm-c/Disassembler.h".  The value of TagType
 * is currently 1 (for the LLVMOpInfo1 struct). If symbolic information is
 * returned then this function returns 1 else it returns 0.
 */
static
int
i386GetOpInfo(
void *DisInfo,
uint64_t Pc,
uint64_t Offset,
uint64_t Width,
int TagType,     /* should currently always be passed as 1 */
void *TagBuf)
{
    struct disassemble_info *info;
    struct LLVMOpInfo1 *op_info;
    unsigned int value;
    int32_t reloc_found, offset;
    uint32_t sect_offset, i, r_address, r_symbolnum, r_type, r_extern, r_length,
	     r_value, r_scattered, pair_r_type, pair_r_value, seg_offset;
    uint32_t other_half;
    const char *strings, *name, *add, *sub;
    struct relocation_info *relocs, *rp, *pairp;
    struct scattered_relocation_info *srp, *spairp;
    uint32_t nrelocs, strings_size, n_strx;
    struct nlist *symbols;

	info = (struct disassemble_info *)DisInfo;

	op_info = (struct LLVMOpInfo1 *)TagBuf;
	value = op_info->Value;
	/* make sure all feilds returned are zero if we don't set them */
	memset(op_info, '\0', sizeof(struct LLVMOpInfo1));
	op_info->Value = value;

	if((Width != 1 && Width != 2 && Width != 4) || TagType != 1 ||
	   info->verbose == FALSE)
	    return(0);

	seg_offset = (Pc + Offset);
	sect_offset = (Pc + Offset) - info->sect_addr;
	relocs = info->sorted_relocs;
	nrelocs = info->nsorted_relocs;
	symbols = info->symbols;
	strings = info->strings;
	strings_size = info->strings_size;

	r_symbolnum = 0;
	r_type = 0;
	r_extern = 0;
	r_value = 0;
	r_scattered = 0;
	other_half = 0;
	pair_r_value = 0;
	n_strx = 0;
	r_length = 0;

	/*
	 * When searching for a relocation entry for this sect_offset we simply
	 * return if we run into errors.
	 */
	reloc_found = 0;
	for(i = 0; i < nrelocs; i++){
	    rp = &relocs[i];
	    if(rp->r_address & R_SCATTERED){
		srp = (struct scattered_relocation_info *)rp;
		r_scattered = 1;
		r_address = srp->r_address;
		r_extern = 0;
		r_length = srp->r_length;
		r_type = srp->r_type;
		r_value = srp->r_value;
	    }
	    else{
		r_scattered = 0;
		r_address = rp->r_address;
		r_symbolnum = rp->r_symbolnum;
		r_extern = rp->r_extern;
		r_length = rp->r_length;
		r_type = rp->r_type;
	    }
	    if(r_type == GENERIC_RELOC_PAIR){
		/* Error stray GENERIC_RELOC_PAIR relocation entry. */
		return(0);
	    }
	    if(r_address == sect_offset){
		if(r_type == GENERIC_RELOC_SECTDIFF ||
		   r_type == GENERIC_RELOC_LOCAL_SECTDIFF){
		    if(i+1 < nrelocs){
			pairp = &rp[1];
			if(pairp->r_address & R_SCATTERED){
			    spairp = (struct scattered_relocation_info *)
				     pairp;
			    pair_r_type = spairp->r_type;
			    pair_r_value = spairp->r_value;
			}
			else{
			    pair_r_type = pairp->r_type;
			}
			if(pair_r_type != GENERIC_RELOC_PAIR){
			    /* Error missing GENERIC_RELOC_PAIR relocation. */
			    return(0);
			}
		    }
		}
		reloc_found = 1;
		break;
	    }
	    if(r_type == GENERIC_RELOC_SECTDIFF ||
	       r_type == GENERIC_RELOC_LOCAL_SECTDIFF){
		if(i+1 < nrelocs){
		    pairp = &rp[1];
		    if(pairp->r_address & R_SCATTERED){
			spairp = (struct scattered_relocation_info *)pairp;
			pair_r_type = spairp->r_type;
		    }
		    else{
			pair_r_type = pairp->r_type;
		    }
		    if(pair_r_type == GENERIC_RELOC_PAIR)
			i++;
		    else{
			/* Error missing GENERIC_RELOC_PAIR relocation. */
			return(0);
		    }
		}
	    }
	}

	if(reloc_found && r_extern == 1){
	    if(symbols != NULL)
		n_strx = symbols[r_symbolnum].n_un.n_strx;
	    if(n_strx >= strings_size){
		/* Error bad string offset. */
		return(0);
	    }
	    name = strings + n_strx;
	    op_info->AddSymbol.Present = 1;
	    op_info->AddSymbol.Name = name;
	    /*
	     * For i386 extern relocation entries the value in the instrucion is
	     * the offset from the symbol.
	     */
	    op_info->Value = value;
	    return(1);
	}

	if(reloc_found && 
	   (r_type == GENERIC_RELOC_SECTDIFF ||
	    r_type == GENERIC_RELOC_LOCAL_SECTDIFF)){
	    add = guess_symbol(r_value, info->sorted_symbols,
			       info->nsorted_symbols, info->verbose);
	    sub = guess_symbol(pair_r_value, info->sorted_symbols,
			       info->nsorted_symbols, info->verbose);
	    offset = value - (r_value - pair_r_value);
	    op_info->AddSymbol.Present = 1;
	    if(add != NULL)
		op_info->AddSymbol.Name = add;
	    else
		op_info->AddSymbol.Value = r_value;
	    op_info->SubtractSymbol.Present = 1;
	    if(sub != NULL)
		op_info->SubtractSymbol.Name = sub;
	    else
		op_info->SubtractSymbol.Value = pair_r_value;
	    op_info->Value = offset;
	    return(1);
	}

	relocs = info->ext_relocs;
	nrelocs = info->next_relocs;
	for(i = 0; i < nrelocs; i++){
	    if(relocs[i].r_address == seg_offset){
		if(symbols != NULL)
		    n_strx = symbols[relocs[i].r_symbolnum].n_un.n_strx;
		if(n_strx >= strings_size){
		    /* Error bad string offset. */
		    return(0);
		}
		name = strings + n_strx;
		op_info->AddSymbol.Present = 1;
		op_info->AddSymbol.Name = name;
		/*
		 * For i386 extern relocation entries the value in the
		 * instrucion is the offset from the symbol.
		 */
		op_info->Value = value;
		return(1);
	    }
	}

	/* We found no symbolic info so just return zero indicating that. */
	return(0);
}

/*
 * x86_64GetOpInfo() is the operand information call back function for x86_64
 * code.  This is called to get the symbolic information for an operand of an
 * x86_64 instruction.  This is done from the relocation information, symbol
 * table, etc.  That block of information is a pointer to the struct
 * disassemble_info that was passed when the disassembler context was created
 * and passed to back to x86_64GetOpInfo() when called back by
 * LLVMDisasmInstruction().  The address of the instruction containing operand
 * is at the Pc parameter.  The immediate for the operand is at Offset past the
 * start of the instruction and has a byte Width of 1, 2 or 4.  The information
 * is returned in TagBuf is the LLVMOpInfo1 struct defined in
 * "llvm-c/Disassembler.h".  The value of TagType is currently 1 (for the
 * LLVMOpInfo1 struct). If symbolic information is returned then this function
 * returns 1 else it returns 0.
 */
static
int
x86_64GetOpInfo(
void *DisInfo,
uint64_t Pc,
uint64_t Offset,
uint64_t Width,
int TagType,     /* should currently always be passed as 1 */
void *TagBuf)
{
    struct disassemble_info *info;
    struct LLVMOpInfo1 *op_info;
    unsigned int value;
    int32_t reloc_found;
    uint32_t sect_offset, seg_offset, i;
    const char *strings, *name;
    struct relocation_info *relocs;
    uint32_t nrelocs, strings_size, n_strx;
    struct nlist_64 *symbols;

	info = (struct disassemble_info *)DisInfo;

	op_info = (struct LLVMOpInfo1 *)TagBuf;
	value = op_info->Value;
	/* make sure all fields returned are zero if we don't set them */
	memset(op_info, '\0', sizeof(struct LLVMOpInfo1));
	op_info->Value = value;

	if((Width != 1 && Width != 2 && Width != 4 && Width != 0) ||
	   TagType != 1 ||
	   info->verbose == FALSE)
	    return(0);

	seg_offset = (Pc + Offset);
	sect_offset = (Pc + Offset) - info->sect_addr;
	relocs = info->sorted_relocs;
	nrelocs = info->nsorted_relocs;
	symbols = info->symbols64;
	strings = info->strings;
	strings_size = info->strings_size;

	reloc_found = 0;
	for(i = 0; i < nrelocs; i++){
	    /* We could also check the Width matches the r_length. */
	    if(relocs[i].r_address == sect_offset){
		reloc_found = 1;
		break;
	    }
	}

	if(reloc_found && relocs[i].r_extern == 1){
	    /*
	     * The Value passed in will be adjusted by the Pc if the instruction
	     * adds the Pc.  But for x86_64 external relocation entries the
	     * Value is the offset from the external symbol.
	     */
	    if(relocs[i].r_pcrel == 1)
		op_info->Value -= Pc + Offset + Width;
	    if(symbols != NULL)
		n_strx = symbols[relocs[i].r_symbolnum].n_un.n_strx;
	    else
		return(0);
	    if(n_strx >= strings_size)
		return(0);
	    name = strings + n_strx;
	    if(relocs[i].r_type == X86_64_RELOC_SUBTRACTOR &&
	       i+1 < nrelocs &&
	       relocs[i+1].r_type == X86_64_RELOC_UNSIGNED &&
	       relocs[i+1].r_extern == 1){
		op_info->SubtractSymbol.Present = 1;
		op_info->SubtractSymbol.Name = name;
		if(symbols != NULL)
		    n_strx = symbols[relocs[i+1].r_symbolnum].n_un.n_strx;
		if(n_strx >= strings_size)
		    return(0);
		name = strings + n_strx;
	    }
	    op_info->AddSymbol.Present = 1;
	    op_info->AddSymbol.Name = name;
	    return(1);
	}

	relocs = info->ext_relocs;
	nrelocs = info->next_relocs;
	for(i = 0; i < nrelocs; i++){
	    if(relocs[i].r_address == seg_offset){
		/*
		 * The Value passed in will be adjusted by the Pc if the
		 * instruction adds the Pc.  But for x86_64 external relocation
		 * entries the Value is the offset from the external symbol.
		 */
		if(relocs[i].r_pcrel == 1)
		    op_info->Value -= Pc + Offset + Width;
		if(symbols != NULL)
		    n_strx = symbols[relocs[i].r_symbolnum].n_un.n_strx;
		else
		    return(0);
		if(n_strx >= strings_size)
		    return(0);
		name = strings + n_strx;
		op_info->AddSymbol.Present = 1;
		op_info->AddSymbol.Name = name;
		return(1);
	    }
	}

	/* We found no symbolic info so just return zero indicating that. */
	return(0);
}

/*
 * guess_pointer_pointer() is passed the address of what might be a pointer to
 * a reference to an Objective-C class, selector, message ref or cfstring.
 */
static
uint64_t
guess_pointer_pointer(
const uint64_t value,
const uint32_t ncmds,
const uint32_t sizeofcmds,
const struct load_command *load_commands,
const enum byte_sex load_commands_byte_sex,
const char *object_addr,
const uint64_t object_size,
enum bool *classref,
enum bool *selref,
enum bool *msgref,
enum bool *cfstring)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, section_type;
    uint64_t sect_offset, object_offset, pointer_value;
    const struct load_command *lc;
    struct load_command l;
    struct segment_command_64 sg64;
    struct section_64 s64;
    char *p;
    uint64_t big_load_end;

	*classref = FALSE;
	*selref = FALSE;
	*msgref = FALSE;
	*cfstring = FALSE;
	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	lc = load_commands;
	big_load_end = 0;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		return(0);
	    big_load_end += l.cmdsize;
	    if(big_load_end > sizeofcmds)
		return(0);
	    switch(l.cmd){
	    case LC_SEGMENT_64:
		memcpy((char *)&sg64, (char *)lc,
		       sizeof(struct segment_command_64));
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);
		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    memcpy((char *)&s64, p, sizeof(struct section_64));
		    p += sizeof(struct section_64);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);
		    section_type = s64.flags & SECTION_TYPE;
		    if((strncmp(s64.sectname, "__objc_selrefs", 16) == 0 ||
		        strncmp(s64.sectname, "__objc_classrefs", 16) == 0 ||
		        strncmp(s64.sectname, "__objc_superrefs", 16) == 0 ||
			strncmp(s64.sectname, "__objc_msgrefs", 16) == 0 ||
			strncmp(s64.sectname, "__cfstring", 16) == 0) &&
		       value >= s64.addr && value < s64.addr + s64.size){
			sect_offset = value - s64.addr;
			object_offset = s64.offset + sect_offset;
			if(object_offset < object_size){
			    memcpy(&pointer_value, object_addr + object_offset,
				   sizeof(uint64_t));
			    if(swapped)
				pointer_value = SWAP_LONG_LONG(pointer_value);
			    if(strncmp(s64.sectname,
				       "__objc_selrefs", 16) == 0)
				*selref = TRUE; 
			    else if(strncmp(s64.sectname,
				       "__objc_classrefs", 16) == 0 ||
			            strncmp(s64.sectname,
				       "__objc_superrefs", 16) == 0)
				*classref = TRUE; 
			    else if(strncmp(s64.sectname,
				       "__objc_msgrefs", 16) == 0 &&
			     value + 8 < s64.addr + s64.size){
				*msgref = TRUE; 
				memcpy(&pointer_value,
				       object_addr + object_offset + 8,
				       sizeof(uint64_t));
				if(swapped)
				    pointer_value =
					SWAP_LONG_LONG(pointer_value);
			    }
			    else if(strncmp(s64.sectname,
				       "__cfstring", 16) == 0)
				*cfstring = TRUE; 
			    return(pointer_value);
			}
			else
			    return(0);
		    }
		}
		break;
	    }
	    if(l.cmdsize == 0){
		return(0);
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		return(0);
	}
	return(0);
}

/*
 * guess_cstring_pointer() is passed the address of what might be a pointer to a
 * literal string in a cstring section.  If that address is in a cstring section
 * it returns a pointer to that string.  Else it returns NULL.
 */
static
const char *
guess_cstring_pointer(
const uint64_t value,
const uint32_t ncmds,
const uint32_t sizeofcmds,
const struct load_command *load_commands,
const enum byte_sex load_commands_byte_sex,
const char *object_addr,
const uint64_t object_size)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, section_type;
    uint64_t sect_offset, object_offset;
    const struct load_command *lc;
    struct load_command l;
    struct segment_command_64 sg64;
    struct section_64 s64;
    char *p;
    uint64_t big_load_end;
    const char *name;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	lc = load_commands;
	big_load_end = 0;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		return(NULL);
	    big_load_end += l.cmdsize;
	    if(big_load_end > sizeofcmds)
		return(NULL);
	    switch(l.cmd){
	    case LC_SEGMENT_64:
		memcpy((char *)&sg64, (char *)lc,
		       sizeof(struct segment_command_64));
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);
		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    memcpy((char *)&s64, p, sizeof(struct section_64));
		    p += sizeof(struct section_64);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);
		    section_type = s64.flags & SECTION_TYPE;
		    if(section_type == S_CSTRING_LITERALS &&
		       value >= s64.addr && value < s64.addr + s64.size){
			sect_offset = value - s64.addr;
			object_offset = s64.offset + sect_offset;
			if(object_offset < object_size){
			    name = object_addr + object_offset;
			    return(name);
			}
			else
			    return(NULL);
		    }
		}
		break;
	    }
	    if(l.cmdsize == 0){
		return(NULL);
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		return(NULL);
	}
	return(NULL);
}

/*
 * guess_literal_pointer() returns a pointer to a literal string if the value
 * passed in is the address of a literal pointer and the literal pointer's value
 * is and address of a cstring. Or returns a reference name for an Objective-C
 * item, or non-lazy pointer.  And sets the value of *reference_type to the
 * type of reference.
 */
static
const char *
guess_literal_pointer(
uint64_t value,	  	  /* the value of the reference */
const uint64_t pc,	  /* pc of the referencing instruction */
uint64_t *reference_type, /* type returned, symbol name or string literal */
struct disassemble_info *info)
{
    uint32_t reloc_found, sect_offset, i, nrelocs, ncmds, sizeofcmds;
    struct relocation_info *relocs;
    struct nlist_64 *symbols;
    struct load_command *load_commands;
    enum byte_sex object_byte_sex;
    char *object_addr;
    uint64_t object_size, pointer_value;
    const char *name, *class_name;
    enum bool classref, selref, msgref, cfstring;

	/*
	 * First see if there is a relocation entry.
	 */
	sect_offset = pc - info->sect_addr;
	relocs = info->sorted_relocs;
	nrelocs = info->nsorted_relocs;
	symbols = info->symbols64;

	reloc_found = 0;
	for(i = 0; i < nrelocs; i++){
	    if(relocs[i].r_address == sect_offset){
		reloc_found = 1;
		break;
	    }
	}

	/*
	 * If there is an external relocation entry for a symbol in a section
	 * then used that symbol's value for the value of the reference.
	 */
	if(reloc_found && relocs[i].r_extern == 1){
	    if(relocs[i].r_pcrel == 1 &&
	       relocs[i].r_type == X86_64_RELOC_SIGNED &&
	       relocs[i].r_symbolnum < info->nsymbols &&
	       symbols != NULL &&
	       (symbols[relocs[i].r_symbolnum].n_type & N_TYPE) == N_SECT){
		value = symbols[relocs[i].r_symbolnum].n_value;
	    }
	}

	ncmds = info->ncmds;
	sizeofcmds = info->sizeofcmds;
	load_commands = info->load_commands;
	object_byte_sex = info->object_byte_sex;
	object_addr = info->object_addr;
	object_size = info->object_size;

	pointer_value = guess_pointer_pointer(value, ncmds, sizeofcmds,
			    load_commands, object_byte_sex, object_addr,
			    object_size, &classref, &selref, &msgref,
			    &cfstring);

	if(classref == TRUE && pointer_value == 0){
	    /*
	     * Note the value is a pointer into the __objc_classrefs section.
	     * And the pointer_value in that section is typically zero as it
	     * will be set by dyld as part of the "bind information".
	     */
	    name = get_dyld_bind_info_symbolname(value, info->dbi, info->ndbi);
	    if(name != NULL){
		*reference_type =
		    LLVMDisassembler_ReferenceType_Out_Objc_Class_Ref;
		class_name = rindex(name, '$');
		if(class_name != NULL &&
		   class_name[1] == '_' && class_name[2] != '\0')
		    info->class_name = class_name + 2;
		return(name);
	    }
	}

	if(classref == TRUE){
	    *reference_type =
		LLVMDisassembler_ReferenceType_Out_Objc_Class_Ref;
	    name = get_objc2_64bit_class_name(pointer_value, value,
			info->load_commands, info->ncmds, info->sizeofcmds,
			info->object_byte_sex, info->object_addr,
			info->object_size, info->symbols64, info->nsymbols,
			info->strings, info->strings_size, info->cputype);
	    if(name != NULL)
		info->class_name = name;
	    else
	        name = "bad class ref";
	    return(name);
	}

	if(cfstring == TRUE){
	    *reference_type =
		LLVMDisassembler_ReferenceType_Out_Objc_CFString_Ref;
	    name = get_objc2_64bit_cfstring_name(value,
			info->load_commands, info->ncmds, info->sizeofcmds,
			info->object_byte_sex, info->object_addr,
			info->object_size, info->symbols64, info->nsymbols,
			info->strings, info->strings_size, info->cputype);
	    if(name == NULL)
	        name = "bad cfstring ref";
	    return(name);
	}

	if(selref == TRUE && pointer_value == 0){
	    pointer_value = get_objc2_64bit_selref(value,
			info->load_commands, info->ncmds, info->sizeofcmds,
			info->object_byte_sex, info->object_addr,
			info->object_size, info->symbols64, info->nsymbols,
			info->strings, info->strings_size, info->cputype);
	}

	if(pointer_value != 0)
	    value = pointer_value;

	/*
	 * See if the value is pointing to a cstring.
	 */
	name = guess_cstring_pointer(value, ncmds, sizeofcmds, load_commands,
				     object_byte_sex, object_addr, object_size);
	if(name != NULL){
	    if(pointer_value != 0 && selref == TRUE){
	        *reference_type =
		    LLVMDisassembler_ReferenceType_Out_Objc_Selector_Ref;
		info->selector_name = name;
	    }
	    else if(pointer_value != 0 && msgref == TRUE){
		info->class_name = NULL;
	        *reference_type =
		    LLVMDisassembler_ReferenceType_Out_Objc_Message_Ref;
		info->selector_name = name;
	    }
            else
		*reference_type =
		    LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr;
	    return(name);
	}

	name = guess_indirect_symbol(value, ncmds, sizeofcmds, load_commands,
		object_byte_sex, info->indirect_symbols,info->nindirect_symbols,
		info->symbols, info->symbols64, info->nsymbols, info->strings,
		info->strings_size);
	if(name != NULL){
	    *reference_type =
		    LLVMDisassembler_ReferenceType_Out_LitPool_SymAddr;
	    return(name);
	}

	return(NULL);
}

/*
 * method_reference() is called passing it the ReferenceName that might be
 * a reference it to an Objective-C method.  If so then it allocates and
 * assembles a method call string with the values last seen and saved in
 * the disassemble_info's class_name and selector_name fields.  This is saved
 * into the method field and any previous string is free'ed.  Then the
 * class_name field is NULL'ed out.
 */
static
void
method_reference(
struct disassemble_info *info,
uint64_t *ReferenceType,
const char **ReferenceName)
{
	if(*ReferenceName != NULL){
	    if(strcmp(*ReferenceName, "_objc_msgSend") == 0){
		*ReferenceType =
		    LLVMDisassembler_ReferenceType_Out_Objc_Message;
		if(info->selector_name != NULL){
		    if(info->method != NULL)
			free(info->method);
		    if(info->class_name != NULL){
			info->method =
			    allocate(5 + strlen(info->class_name) +
				    strlen(info->selector_name));
			strcpy(info->method, "+[");
			strcat(info->method, info->class_name);
			strcat(info->method, " ");
			strcat(info->method, info->selector_name);
			strcat(info->method, "]");
			*ReferenceName = info->method;
			info->class_name = NULL;
		    }
		    else{
			info->method =
			    allocate(9 + strlen(info->selector_name));
			strcpy(info->method, "-[%rdi ");
			strcat(info->method, info->selector_name);
			strcat(info->method, "]");
			*ReferenceName = info->method;
		    }
		}
	    }
	    else if(strcmp(*ReferenceName, "_objc_msgSendSuper2") == 0){
		*ReferenceType =
		    LLVMDisassembler_ReferenceType_Out_Objc_Message;
		if(info->selector_name != NULL){
		    if(info->method != NULL)
			free(info->method);
		    info->method =
			allocate(17 + strlen(info->selector_name));
		    strcpy(info->method, "-[[%rdi super] ");
		    strcat(info->method, info->selector_name);
		    strcat(info->method, "]");
		    *ReferenceName = info->method;
		    info->class_name = NULL;
		}
	    }
	}
}

/*
 * The symbol lookup function passed to LLVMCreateDisasm().  It looks up the
 * SymbolValue using the info passed vis the pointer to the struct
 * disassemble_info that was passed when disassembler context is created and
 * returns the symbol name that matches or NULL if none.
 *
 * When this is called to get a symbol name for a branch target then the
 * ReferenceType can be LLVMDisassembler_ReferenceType_In_Branch and then
 * SymbolValue will be looked for in the indirect symbol table to determine if
 * it is an address for a symbol stub.  If so then the symbol name for that
 * stub is returned indirectly through ReferenceName and then ReferenceType is
 * set to LLVMDisassembler_ReferenceType_Out_SymbolStub.
 */
static
const char *
SymbolLookUp(
void *DisInfo,
uint64_t SymbolValue,
uint64_t *ReferenceType,
uint64_t ReferencePC,
const char **ReferenceName)
{
    struct disassemble_info *info;
    const char *SymbolName;
    uint32_t i;

	info = (struct disassemble_info *)DisInfo;
	if(info->verbose == FALSE){
	    *ReferenceName = NULL;
	    *ReferenceType = LLVMDisassembler_ReferenceType_InOut_None;
	    return(NULL);
	}
	SymbolName = guess_symbol(SymbolValue, info->sorted_symbols,
				  info->nsorted_symbols, TRUE);
	if(SymbolName == NULL && info->insts != NULL && info->ninsts != 0){
	    for(i = 0; i < info->ninsts; i++){
		if(info->insts[i].address == SymbolValue){
		    SymbolName = info->insts[i].tmp_label;
		    break;
		}
	    }
	}

	if(*ReferenceType == LLVMDisassembler_ReferenceType_In_Branch){
	    *ReferenceName = guess_indirect_symbol(SymbolValue,
		    info->ncmds, info->sizeofcmds, info->load_commands,
		    info->object_byte_sex, info->indirect_symbols,
		    info->nindirect_symbols, info->symbols, info->symbols64,
		    info->nsymbols, info->strings, info->strings_size);
	    if(*ReferenceName != NULL){
		method_reference(info, ReferenceType, ReferenceName);
		if(*ReferenceType !=
			LLVMDisassembler_ReferenceType_Out_Objc_Message)
		    *ReferenceType =
			LLVMDisassembler_ReferenceType_Out_SymbolStub;
	    }
	    else if(SymbolName != NULL && strncmp(SymbolName, "__Z", 3) == 0){
		if(info->demangled_name != NULL)
		    free(info->demangled_name);
		info->demangled_name = __cxa_demangle(SymbolName + 1, 0, 0, 0);
		if(info->demangled_name != NULL){
		    *ReferenceName = info->demangled_name;
		    *ReferenceType =
			LLVMDisassembler_ReferenceType_DeMangled_Name;
		}
		else
		    *ReferenceType = LLVMDisassembler_ReferenceType_InOut_None;
	    }
	    else
		*ReferenceType = LLVMDisassembler_ReferenceType_InOut_None;
	    if(info->inst != NULL && SymbolName == NULL){
		info->inst->has_raw_target_address = TRUE;
		info->inst->raw_target_address = SymbolValue;
	    }
	}
	else if(*ReferenceType == LLVMDisassembler_ReferenceType_In_PCrel_Load){
	    *ReferenceName = guess_literal_pointer(SymbolValue, ReferencePC,
						   ReferenceType, info);
	    if(*ReferenceName != NULL)
		method_reference(info, ReferenceType, ReferenceName);
	    else
		*ReferenceType = LLVMDisassembler_ReferenceType_InOut_None;
	}
	else if(SymbolName != NULL && strncmp(SymbolName, "__Z", 3) == 0){
	    if(info->demangled_name != NULL)
		free(info->demangled_name);
	    info->demangled_name = __cxa_demangle(SymbolName + 1, 0, 0, 0);
	    if(info->demangled_name != NULL){
		*ReferenceName = info->demangled_name;
		*ReferenceType = LLVMDisassembler_ReferenceType_DeMangled_Name;
	    }
	}
	else{
	    *ReferenceName = NULL;
	    *ReferenceType = LLVMDisassembler_ReferenceType_InOut_None;
	}
	return(SymbolName);
}

LLVMDisasmContextRef
create_i386_llvm_disassembler(
void)
{
    LLVMDisasmContextRef dc;

	dc = llvm_create_disasm("i386-apple-darwin10", mcpu, &dis_info, 1,
				i386GetOpInfo, SymbolLookUp);
	return(dc);
}

void
delete_i386_llvm_disassembler(
LLVMDisasmContextRef dc)
{
	llvm_disasm_dispose(dc);
}

LLVMDisasmContextRef
create_x86_64_llvm_disassembler(
void)
{
    LLVMDisasmContextRef dc;

	dc = llvm_create_disasm("x86_64-apple-darwin10", mcpu, &dis_info, 1,
				x86_64GetOpInfo, SymbolLookUp);
	return(dc);
}

void
delete_x86_64_llvm_disassembler(
LLVMDisasmContextRef dc)
{
	llvm_disasm_dispose(dc);
}
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/i386_disasm.h                         0100644 0001750 0001750 00000005762 12612724206 024010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <stuff/bytesex.h>
#import <mach-o/reloc.h>
#import <mach-o/nlist.h>
#import <stuff/bool.h>
#include "otool.h"
#include "stuff/symbol.h"
#include "llvm-c/Disassembler.h"

extern uint32_t i386_disassemble(
    char *sect,
    uint32_t left,
    uint64_t addr,
    uint64_t sect_addr,
    enum byte_sex object_byte_sex,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct relocation_info *ext_relocs,
    uint32_t next_relocs,
    struct relocation_info *loc_relocs,
    uint32_t nloc_relocs,
    struct dyld_bind_info *dbi,
    uint64_t ndbi,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    cpu_type_t cputype,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum bool verbose,
    enum bool llvm_mc,
    LLVMDisasmContextRef i386_dc,
    LLVMDisasmContextRef x86_64_dc,
    char *object_addr,
    uint32_t object_size,
    struct inst *inst,
    struct inst *insts,
    uint32_t ninsts);

extern LLVMDisasmContextRef create_i386_llvm_disassembler(void);
extern void delete_i386_llvm_disassembler(LLVMDisasmContextRef dc);
extern LLVMDisasmContextRef create_x86_64_llvm_disassembler(void);
extern void delete_x86_64_llvm_disassembler(LLVMDisasmContextRef dc);
              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/i860_disasm.c                         0100644 0001750 0001750 00000036463 12612724206 024002  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/i860/reloc.h>
#include "stuff/symbol.h"
#include "stuff/bytesex.h"
#include "otool.h"
#include "../as/i860-opcode.h"

static void i860_dump_operands(
    uint32_t opcode,
    char *format,
    uint32_t addr,
    uint32_t sect_addr,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

static void i860_dump_addr(
    uint32_t addr_field,
    int format,
    int32_t addr,
    uint32_t sect_addr,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

static enum bool i860_print_symbol(
    uint32_t value,
    struct relocation_info *rp,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

/*
 * Disassemble 1 instruction and return the length of the disassembled 
 * piece in bytes.
 */
uint32_t
i860_disassemble(
char *sect,
uint32_t left,
uint32_t addr,
uint32_t sect_addr,
enum byte_sex object_byte_sex,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t opcode;
    int isdual;
    uint32_t i;
    struct i860_opcode *op;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;

	if(left < sizeof(uint32_t)){
	   if(left != 0){
		memcpy(&opcode, sect, left);
		if(swapped)
		    opcode = SWAP_INT(opcode);
		printf(".long\t0x%08x\n", (unsigned int)opcode);
	   }
	   printf("(end of section)\n");
	   return(left);
	}

	memcpy(&opcode, sect, sizeof(uint32_t));
	if(swapped)
	    opcode = SWAP_INT(opcode);

	/*
	 * The pad opcode, 0, is chosen as an illegal insn to fault if
	 * executed
	 */
	if(opcode == 0){
	    printf("| Padded to i860 section boundary\n");
	    return(4);
	}

	isdual = 0;
	/*
	 * See if this is a dual insn mode opcode.
	 * Turn off the dual mode bit and print a d. if appropriate.
	 */
	if((opcode & OP_PREFIX_MASK) == PREFIX_FPU || 
	   opcode == (OP_FNOP|DUAL_INSN_MODE_BIT)){
	    if(opcode & DUAL_INSN_MODE_BIT){
		opcode &= ~DUAL_INSN_MODE_BIT;
		isdual = 1;
	    }
	}
	/*
	 * Search the instruction table for a match for this opcode.
	 * We use a linear search because it's easy, uses the 
	 * assembler insn tables, and I'm so lazy....
	 * Feel free to recode with whizzy hashes and such.
	 */
	op = (struct i860_opcode *)i860_opcodes;
	for(i = 0; i < NUMOPCODES; i++, op++){
	    if((opcode & op->mask) == op->match){
		if(isdual)
		    printf("d.%-12s\t", op->name);
		else
		    printf("%-12s\t", op->name);
		i860_dump_operands(opcode, (char *)op->args, addr, sect_addr,
			relocs, nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		return(sizeof(uint32_t));
	    }
	}

	/* Didn't find the opcode.  Dump it as a .long directive. */
	/* Build it as a little-endian insn, in a format to match asm */
	printf(".long\t0x%08x\n", (unsigned int)opcode);
	return(sizeof(uint32_t));
}

/* 32 possible valuse, of which 6 are actually used. */
static char *i860_controlregs[] = {"fir", "psr", "dirbase", "db", "fsr", "epsr",
				   "?","?","?","?","?","?",
				   "?","?","?","?","?","?",
				   "?","?","?","?","?","?",
				   "?","?","?","?","?","?"};

static
void
i860_dump_operands(
uint32_t opcode,
char *format,
uint32_t addr,
uint32_t sect_addr,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    uint32_t addr_field;
	
	while(*format != '\0'){
	    switch(*format){
	    case '1': /* rs1 register, bits 11-15 of insn */
		printf("r%u", GET_RS1(opcode));
		break;
		    
	    case '2': /* rs2 register, bits 21-25 of insn */
		printf("r%u", GET_RS2(opcode));
		break;
		    
	    case 'd': /* rd register, bits 16-20 of insn */
		printf("r%u", GET_RD(opcode));
		break;
	    
	    case 'E':	
	    case 'e': /* frs1 floating point register, bits 11-15 of insn */
		printf("f%u", GET_RS1(opcode));
		break;
	    
	    case 'F':	
	    case 'f': /* frs2 floating point register, bits 21-25 of insn */
		printf("f%u", GET_RS2(opcode));
		break;
	    
	    case 'H':
	    case 'G':	
	    case 'g': /* frsd floating point register, bits 16-20 of insn */ 
		printf("f%u", GET_RD(opcode));
		break;
		    
	    case 'I': /* 16 bit High portion of address, I860_RELOC_HIGH */
	    case 'J': /* 16 bit High portion of addr requiring adjustment */
		addr_field = opcode & 0xFFFF;
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'i': /* 16 bit byte address low half */
		addr_field = (opcode & 0xFFFF);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'j': /* 16 bit short address, I860_RELOC_LOW1 */
		addr_field = (opcode & 0xFFFE);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'k': /* 16 bit word/int address low half, I860_RELOC_LOW2 */
		addr_field = (opcode & 0xFFFC);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'l': /* 16 bit 8-byte address (double) low half */
		addr_field = (opcode & 0xFFF8);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'm': /* 16 bit 16-byte address (quad) low half */
		addr_field = (opcode & 0xFFF0);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'n': /* 16 bit byte aligned low half, split fields */
		addr_field = ((opcode >> 5) & 0xF800) | (opcode & 0x7FF);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'o': /* 16 bit short aligned low half, split fields */
		addr_field = ((opcode >> 5) & 0xF800) | (opcode & 0x7FE);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'p': /* 16 bit int/word aligned low half, split fields */
		addr_field = ((opcode >> 5) & 0xF800) | (opcode & 0x7FC);
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'K': /* 26 bit branch displacement */
		addr_field = opcode & 0x3FFFFFF;
		if(addr_field & 0x02000000)	/* MSB set? */
		    addr_field |= 0xFC000000; 	/* Sign extend */
		addr_field <<= 2;	/* Convert to byte addr */
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;
		    
	    case 'L': /* 16 bit split branch displacement */
		addr_field = ((opcode >> 5) & 0xF800) | (opcode & 0x7FF);
		if(addr_field & 0x8000)		/* MSB set? */
		    addr_field |= 0xFFFF0000; 	/* Sign extend */
		addr_field <<= 2;	/* Convert to byte addr */
		i860_dump_addr(addr_field, *format, addr, sect_addr, relocs,
			nrelocs, symbols, nsymbols, sorted_symbols,
			nsorted_symbols, strings, strings_size, verbose);
		break;

	    case 'D': /* constant for shift opcode */	
		printf("%u", opcode & 0xFFFF);
		break;
		    
	    case 'B': /* 5 bit immediate, for bte and btne insn */
		printf("%u", GET_RS1(opcode));
		break;
		    
	    case 'C': /* Control Register */
		printf("%s", i860_controlregs[GET_RS2(opcode)]);
		break;
		    
	    default:
		printf("%c", *format);
		break;
	    }
	    ++format;
	}
	printf("\n");
}

static
void
i860_dump_addr(
uint32_t addr_field,
int format,
int32_t addr,
uint32_t sect_addr,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    uint32_t i;
    struct relocation_info *rp, *pairp;
    struct scattered_relocation_info *sreloc;
    char *prefix;
	
	rp = NULL;
	pairp = NULL;
	if(nrelocs){
	    for(i = 0; i < nrelocs; i++){
		if(((relocs[i].r_address) & R_SCATTERED) != 0){
		    sreloc = (struct scattered_relocation_info *)(relocs + i);
		    if(sreloc->r_type == I860_RELOC_PAIR){
			fprintf(stderr, "Stray I860_RELOC_PAIR relocation "
				"entry %u\n", i);
			continue;
		    }
		    if(sreloc->r_type == I860_RELOC_HIGH ||
		       sreloc->r_type == I860_RELOC_HIGHADJ ||
		       sreloc->r_type == I860_RELOC_SECTDIFF){
			if(i+1 >= nrelocs ||
			   relocs[i+1].r_type != I860_RELOC_PAIR){
				fprintf(stderr, "No I860_RELOC_PAIR relocation "
					"entry after entry %u\n", i);
			}
			else{
			    if(((relocs[i+1].r_address) & R_SCATTERED) != 0){
				sreloc = (struct scattered_relocation_info *)
					 (relocs + i + 1);
				if(sreloc->r_type != I860_RELOC_PAIR)
				    fprintf(stderr, "No I860_RELOC_PAIR "
					    "relocation entry after entry "
					    "%u\n", i);
			    }
			    else if(relocs[i+1].r_type != I860_RELOC_PAIR){
				fprintf(stderr, "No I860_RELOC_PAIR relocation "
					"entry after entry %u\n", i);
			    }
			    i++;
			    continue;
			}
		    }
		}
		if(relocs[i].r_type == I860_RELOC_PAIR){
		    fprintf(stderr, "Stray I860_RELOC_PAIR relocation entry "
			    "%u\n", i);
		    continue;
		}
		if((uint32_t)relocs[i].r_address == addr - sect_addr){
		    rp = &relocs[i];
		    if(rp->r_type == I860_RELOC_HIGH ||
		       rp->r_type == I860_RELOC_HIGHADJ ||
		       rp->r_type == I860_RELOC_SECTDIFF){
			if(i+1 < nrelocs){
			    pairp = &rp[1];
			    if(pairp->r_type != I860_RELOC_PAIR){
				fprintf(stderr, "No I860_RELOC_PAIR relocation "
					"entry after entry %u\n", i);
				rp = NULL;
				pairp = NULL;
				continue;
			    }
			}
		    }
		    break;
		}
		if(relocs[i].r_type == I860_RELOC_HIGH ||
		   relocs[i].r_type == I860_RELOC_HIGHADJ ||
		   relocs[i].r_type == I860_RELOC_SECTDIFF){
		    if(i+1 >= nrelocs ||
		       relocs[i+1].r_type != I860_RELOC_PAIR){
			    fprintf(stderr, "No I860_RELOC_PAIR relocation "
				    "entry after entry %u\n", i);
		    }
		    else
			i++;
		}
	    }
	}

	/* Guess a prefix code for the immediate value */
	prefix = NULL;
	if((rp != NULL && rp->r_type == I860_RELOC_HIGH) || format == 'I')
	    prefix = "h%";
	else if((rp != NULL && rp->r_type == I860_RELOC_HIGHADJ) ||
		format == 'J' )
	    prefix = "ha%";
	else if(rp != NULL && rp->r_type >= I860_RELOC_LOW0 &&
			      rp->r_type <= I860_RELOC_SPLIT2){
	    if(rp->r_pcrel == 0)	/* Don't use for bte insns */
		prefix = "l%";
	}
	if(rp != NULL && (rp->r_type == I860_RELOC_HIGH ||
			  rp->r_type == I860_RELOC_HIGHADJ)){
	    if(pairp->r_type == I860_RELOC_PAIR){
		if(rp->r_type == I860_RELOC_HIGHADJ)

		    if(pairp->r_address & 0x8000)
			addr_field = (addr_field << 16) +
				     (0xffff0000 | (pairp->r_address & 0xffff));
		    else
			addr_field = (addr_field << 16) +
				     (pairp->r_address & 0xffff);
		else
		    addr_field = (addr_field << 16) |
				 (pairp->r_address & 0xffff);
	    }
	}	
	if(prefix != NULL)
	    printf("%s", prefix);

	if(format == 'K' || format == 'L'){ /* branch displacement */
	    if(i860_print_symbol(addr + 4 + ((int32_t)addr_field), rp,
		     symbols, nsymbols, sorted_symbols, nsorted_symbols,
		     strings, strings_size, verbose) == TRUE)
		return;
	    printf(".%+d", (int32_t)(addr_field + 4));
	    return;
	}
	if(i860_print_symbol(addr_field, rp, symbols, nsymbols,
			     sorted_symbols, nsorted_symbols, strings,
			     strings_size, verbose) == TRUE)	
	    return;

	/* we can't find anything else to do with it. */
	printf("0x%x", (unsigned int)addr_field);
}

/*
 * i860_print_symbol prints a symbol name for the addr and relocation entry
 * if a symbol exist with the same address.  Nothing else is printed, no
 * whitespace, no newline.  If it prints something then it returns TRUE, else
 * it returns FALSE.
 */
static
enum bool
i860_print_symbol(
uint32_t value,
struct relocation_info *rp,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    int32_t high, low, mid;

	if(verbose == FALSE)
	    return(FALSE);

	if(rp != NULL){
	    if(rp->r_extern &&
	       rp->r_symbolnum < nsymbols){
		if(value != 0)
		    printf("%s+0x%x", strings +
			   symbols[rp->r_symbolnum].n_un.n_strx,
			   (unsigned int)value);
		else
		    printf("%s",strings + symbols[rp->r_symbolnum].n_un.n_strx);
		return(TRUE);
	    }
	}

	low = 0;
	high = nsorted_symbols - 1;
	mid = (high - low) / 2;
	while(high >= low){
	    if(sorted_symbols[mid].n_value == value){
		printf("%s", sorted_symbols[mid].name);
		return(TRUE);
	    }
	    if(sorted_symbols[mid].n_value > value){
		high = mid - 1;
		mid = (high + low) / 2;
	    }
	    else{
		low = mid + 1;
		mid = (high + low) / 2;
	    }
	}
	return(FALSE);
}
                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/i860_disasm.h                         0100644 0001750 0001750 00000004131 12612724206 023772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <stuff/bytesex.h>
#import <mach-o/reloc.h>
#import <mach-o/nlist.h>
#import <stuff/bool.h>
#include "stuff/symbol.h"

extern uint32_t i860_disassemble(
    char *sect,
    uint32_t left,
    uint32_t addr,
    uint32_t sect_addr,
    enum byte_sex object_byte_sex,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);
                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/m68k_disasm.c                         0100644 0001750 0001750 00000214723 12612724206 024076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include "stuff/bytesex.h"
#include "dyld_bind_info.h"
#include "ofile_print.h"
#include "stuff/symbol.h"
#include "otool.h"

#define GET_DOUBLE(sect, left, length, swapped, d) \
if((left) < sizeof(double)){ \
    (d) = 0.0; \
    memcpy((char *)&(d), (sect) + (length), (left)); \
    (length) += (left); \
    (left) = 0; \
} \
else{ \
    memcpy((char *)&(d), (sect) + (length), sizeof(double)); \
    (length) += sizeof(double); \
    (left) -= sizeof(double); \
} \
if(swapped) \
    (d) = SWAP_DOUBLE((d));

#define GET_FLOAT(sect, left, length, swapped, f) \
if((left) < sizeof(float)){ \
    (f) = 0.0; \
    memcpy((char *)&(f), (sect) + (length), (left)); \
    (length) += (left); \
    (left) = 0; \
} \
else{ \
    memcpy((char *)&(f), (sect) + (length), sizeof(float)); \
    (length) += sizeof(float); \
    (left) -= sizeof(float); \
} \
if(swapped) \
    (f) = SWAP_FLOAT((f));

#define GET_LONG(sect, left, length, swapped, l) \
if((left) < sizeof(uint32_t)){ \
    (l) = 0; \
    memcpy((char *)&(l), (sect) + (length), (left)); \
    (length) += (left); \
    (left) = 0; \
} \
else{ \
    memcpy((char *)&(l), (sect) + (length), sizeof(uint32_t)); \
    (length) += sizeof(uint32_t); \
    (left) -= sizeof(uint32_t); \
} \
if(swapped) \
    (l) = SWAP_INT((l));

#define GET_WORD(sect, left, length, swapped, w) \
if((left) < sizeof(unsigned short)){ \
    (w) = 0; \
    memcpy((char *)&(w), (sect) + (length), (left)); \
    (length) += (left); \
    (left) = 0; \
} \
else{ \
    memcpy((char *)&(w), (sect) + (length), sizeof(unsigned short)); \
    (length) += sizeof(unsigned short); \
    (left) -= sizeof(unsigned short); \
} \
if(swapped) \
    (w) = SWAP_SHORT((w));

#define	MODE(x)		(((x) >> 3) & 7)
#define	REG(x)		((x) & 7)
#define	DEST_MODE(x)	(((x) >> 6) & 7)
#define	DEST_REG(x)	(((x) >> 9) & 7)
#define B_SIZE	0
#define W_SIZE	1
#define L_SIZE	2
#define	S_SIZE	3
#define	D_SIZE	4
#define	X_SIZE	5
#define	P_SIZE	6

static char wl[] = "wl";
static char size[] = "bwl?";
static char *scales[] = { ":1", ":2", ":4", ":8" };
static char *aregs[] = { "a0", "a1", "a2", "a3", "a4", "a5", "a6", "sp" };
static char *dregs[] = { "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7" };
static char *fpregs[] = { "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6",
			  "fp7" };
static char *fpcregs[] = { "fpc?", "fpi", "fps", "fps/fpi", "fpc",
			   "fpc/fpi", "fpc/fps", "fpc/fps/fpi" }; 
static char *branches[] = { "bra", "bsr", "bhi", "bls", "bcc", "bcs", "bne",
			    "beq", "bvc", "bvs", "bpl", "bmi", "bge", "blt",
			    "bgt", "ble" };
static char *conditions[] = { "t", "f", "hi", "ls", "cc", "cs", "ne",
			    "eq", "vc", "vs", "pl", "mi", "ge", "lt",
			    "gt", "le" };
static char *fpops[] = { "fmove", "fint", "fsinh", "fintrz", "fsqrt",
	"f0x05", "flognp1", "f0x07", "fetoxm1", "ftanh", "fatan",
	"f0x0b", "fasin", "fatanh", "fsin", "ftan", "fetox", "ftwotox",
	"ftentox", "f0x13", "flogn", "flog10", "flog2", "f0x17", "fabs",
	"fcosh", "fneg", "f0x1b", "facos", "fcos", "fgetexp", "fgetman",
	"fdiv", "fmod", "fadd", "fmul", "fsgldiv", "frem", "fscale", "fsglmul",
	"fsub", "f0x29", "f0x2a", "f0x2b", "f0x2c", "f0x2d",
	"f0x2e", "f0x2f", "fsincos", "fsincos", "fsincos", "fsincos",
	"fsincos", "fsincos", "fsincos", "fsincos", "fcmp", "f0x39", "ftst",
	"f0x3b", "f0x3c", "f0x3d", "f0x3e", "f0x3f",
	"fsmove","fssqrt","f0x42", "f0x43", "fdmove","fdsqrt","f0x46", "f0x47",
	"f0x48", "f0x49", "f0x4a", "f0x4b", "f0x4c", "f0x4d", "f0x4e", "f0x4f",
	"f0x50", "f0x51", "f0x52", "f0x53", "f0x54", "f0x55", "f0x56", "f0x57",
	"fsabs", "f0x59", "fsneg", "f0x5b", "fdabs", "f0x5d", "fdneg", "f0x5f",
	"fsdiv", "f0x61", "fsadd", "fsmul", "fddiv", "f0x65", "fdadd", "fdmul",
	"fssub", "f0x69", "f0x6a", "f0x6b", "fdsub", "f0x6d", "f0x6e", "f0x6f",
	"f0x70", "f0x71", "f0x72", "f0x73", "f0x74", "f0x75", "f0x76", "f0x77",
	"f0x78", "f0x79", "f0x7a", "f0x7b", "f0x7c", "f0x7d", "f0x7e", "f0x7f",
};

static char fpformat[] = "lsxpwdbp";
static uint32_t fpsize[] = { L_SIZE, S_SIZE, X_SIZE, P_SIZE, W_SIZE,
			     D_SIZE, B_SIZE, P_SIZE };
static char *fpcond[] = { "f", "eq", "ogt", "oge", "olt", "ole", "ogl", "or",
	"un", "ueq", "ugt", "uge", "ult", "ule", "ne", "t", "sf", "seq", "gt",
	"ge", "lt", "le", "gl", "gle", "ngle", "ngl", "nle", "nlt", "nge",
	"ngt", "sne", "st" };
static char scope[] = "lpa";
static char *cache[] = { "dc", "ic", "bc" };

#define PRINT_SYMBOL(sect, addr) \
	print_symbol((sect), (addr) - sect_addr, 0, sorted_relocs, \
		nsorted_relocs, symbols, NULL, nsymbols, sorted_symbols, \
		nsorted_symbols, strings, strings_size, verbose)

#define PRINT_SYMBOL_DOT(sect, addr, dot) \
	print_symbol((sect), (addr) - sect_addr, dot, sorted_relocs, \
		nsorted_relocs, symbols, NULL, nsymbols, sorted_symbols, \
		nsorted_symbols, strings, strings_size, verbose)

#define PRINT_EF(mode, reg, sect, size) \
	print_ef((mode), (reg), (sect), addr + length, sect_addr, &left, \
		(size), sorted_relocs, nsorted_relocs, symbols, nsymbols, \
		sorted_symbols, nsorted_symbols, strings, strings_size, \
		verbose, swapped)

static uint32_t print_ef(
    uint32_t mode,
    uint32_t reg,
    char *sect,
    uint32_t addr,
    uint32_t sect_addr,
    uint32_t *left,
    uint32_t size,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose,
    enum bool swapped);


uint32_t
m68k_disassemble(
char *sect,
uint32_t left,
uint32_t addr,
uint32_t sect_addr,
enum byte_sex object_byte_sex,
struct relocation_info *sorted_relocs,
uint32_t nsorted_relocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
uint32_t *indirect_symbols,
uint32_t nindirect_symbols,
uint32_t ncmds,
uint32_t sizeofcmds,
struct load_command *load_commands,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t length, i, l;
    unsigned short opword, specop1, specop2, w;
    char *reg1, *reg2;
    const char *indirect_symbol_name;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;

	if(left < sizeof(unsigned short)){
	   if(left != 0){
		memcpy(&opword, sect, left);
		if(swapped)
		    opword = SWAP_SHORT(opword);
		printf(".short\t0x%04x\n", (unsigned int)opword);
	   }
	   printf("(end of section)\n");
	   return(left);
	}

	memcpy(&opword, sect, sizeof(unsigned short));
	if(swapped)
	    opword = SWAP_SHORT(opword);
	length = sizeof(unsigned short);

	switch((opword & 0xf000) >> 12){
	case 0x0:
	    if(opword == 0x003c){
		GET_WORD(sect, left, length, swapped, w);
		printf("orb\t#0x%x,cc\n", (unsigned int)(w & 0xff));
		return(length);
	    }
	    if(opword == 0x007c){
		GET_WORD(sect, left, length, swapped, w);
		printf("orw\t#0x%x,sr\n", (unsigned int)w);
		return(length);
	    }
	    if((opword & 0xfff0) == 0x06c0){
		if(opword & 0x0008)
		    printf("rtm\t%s\n", aregs[opword & 0x7]);
		else
		    printf("rtm\t%s\n", dregs[opword & 0x7]);
		return(length);
	    }
	    if((opword & 0xffc0) == 0x06c0){
		GET_WORD(sect, left, length, swapped, specop1);
		printf("callm\t#0x%x,", (unsigned int)(specop1 & 0x00ff));
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xf900) == 0){
		if((opword & 0x00c0) == 0x00c0){
		    GET_WORD(sect, left, length, swapped, specop1);
		    if((specop1 & 0x0800) == 0x0800)
			printf("chk2%c\t", size[((opword & 0x0600) >> 9)]);
		    else
			printf("cmp2%c\t", size[((opword & 0x0600) >> 9)]);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, (opword & 0x0600) >> 9);
		    if(((specop1 & 0x8000) >> 15) == 0)
			reg1 = dregs[(specop1 & 0x7000) >> 12];
		    else
			reg1 = aregs[(specop1 & 0x7000) >> 12];
		    printf(",%s\n", reg1);
		    return(length);
		}
	    }
	    if((opword & 0xff00) == 0){
		switch((opword & 0x00c0) >> 6){
		case 0:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("orb\t#0x%x,", (unsigned int)(w & 0xff));
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, B_SIZE);
		    printf("\n");
		    return(length);
		case 1:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("orw\t#0x%x,", (unsigned int)w);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    printf("\n");
		    return(length);
		case 2:
		    GET_LONG(sect, left, length, swapped, l);
		    printf("orl\t#0x%x,", (unsigned int)l);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    printf("\n");
		    return(length);
		}
	    }
	    if((opword & 0xf100) == 0x0100){
		if((opword & 0xf038) == 0x0008){
		    switch((opword & 0x00c0) >> 6){
		    case 0:
			GET_WORD(sect, left, length, swapped, w);
			printf("movepw\t(0x%x,a%d),d%d\n", (unsigned int)w,
			       REG(opword), (opword & 0x0e00) >> 9);
			break;
		    case 1:
			GET_WORD(sect, left, length, swapped, w);
			printf("movepl\t(0x%x,a%d),d%d\n", (unsigned int)w,
			       REG(opword), (opword & 0x0e00) >> 9);
			break;
		    case 2:
			GET_WORD(sect, left, length, swapped, w);
			printf("movepw\td%d,(0x%x,a%d)\n",
			       (opword & 0x0e00) >> 9, (unsigned int)w,
			       REG(opword));
			break;
		    case 3:
			GET_WORD(sect, left, length, swapped, w);
			printf("movepl\td%d,(0x%x,a%d)\n",
			       (opword & 0x0e00) >> 9, (unsigned int)w,
			       REG(opword));
			break;
		    }
		    return(length);
		}
		else{
		    switch((opword & 0x00c0) >> 6){
		    case 0:
			printf("btst\td%d,", (opword & 0x0e00) >> 9);
			break;
		    case 1:
			printf("bchg\td%d,", (opword & 0x0e00) >> 9);
			break;
		    case 2:
			printf("bclr\td%d,", (opword & 0x0e00) >> 9);
			break;
		    case 3:
			printf("bset\td%d,", (opword & 0x0e00) >> 9);
			break;
		    }
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    printf("\n");
		    return(length);
		}
	    }
	    if((opword & 0xff00) == 0x0200){
		if(opword == 0x023c){
		    GET_WORD(sect, left, length, swapped, w);
		    printf("andb\t#0x%x,cc\n", (unsigned int)(w & 0xff));
		    return(length);
		}
		if(opword == 0x027c){
		    GET_WORD(sect, left, length, swapped, w);
		    printf("andw\t#0x%x,sr\n", (unsigned int)w);
		    return(length);
		}
		switch((opword & 0x00c0) >> 6){
		case 0:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("andb\t#0x%x,", (unsigned int)(w & 0xff));
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, B_SIZE);
		    break;
		case 1:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("andw\t#0x%x,", (unsigned int)w);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    break;
		case 2:
		    GET_LONG(sect, left, length, swapped, l);
		    printf("andl\t#0x%x,", (unsigned int)l);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    break;
		default:
		    goto bad;
		}
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x0400){
		switch((opword & 0x00c0) >> 6){
		case 0:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("subb\t#0x%x,", (unsigned int)(w & 0xff));
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, B_SIZE);
		    break;
		case 1:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("subw\t#0x%x,", (unsigned int)w);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    break;
		case 2:
		    GET_LONG(sect, left, length, swapped, l);
		    printf("subl\t");
		    if(PRINT_SYMBOL(l, addr + length - sizeof(uint32_t)))
			printf(",");
		    else
			printf("#0x%x,", (unsigned int)l);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    break;
		default:
		    goto bad;
		}
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x0600){
		switch((opword & 0x00c0) >> 6){
		case 0:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("addb\t#0x%x,", (unsigned int)(w &0xff));
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, B_SIZE);
		    break;
		case 1:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("addw\t#0x%x,",  (unsigned int)w);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    break;
		case 2:
		    GET_LONG(sect, left, length, swapped, l);
		    printf("addl\t#0x%x,", (unsigned int)l);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    break;
		default:
		    goto bad;
		}
		printf("\n");
		return(length);
	    }
	    if(opword == 0x0a3c){
		GET_WORD(sect, left, length, swapped, w);
		printf("eorb\t#0x%x,cc\n", (unsigned int)(w & 0xff));
		return(length);
	    }
	    if(opword == 0x0a7c){
		GET_WORD(sect, left, length, swapped, w);
		printf("eorw\t#0x%x,sr\n", (unsigned int)w);
		return(length);
	    }
	    if((opword & 0xff00) == 0x0800){
		switch((opword & 0x00c0) >> 6){
		case 0:
		    printf("btst\t");
		    break;
		case 1:
		    printf("bchg\t");
		    break;
		case 2:
		    printf("bclr\t");
		    break;
		case 3:
		    printf("bset\t");
		    break;
		}
		GET_WORD(sect, left, length, swapped, w);
		printf("#%d,", w & 0xff);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xf9ff) == 0x08fc){
		GET_WORD(sect, left, length, swapped, specop1);
		if((specop1 & 0x8000) == 0)
		    reg1 = dregs[(specop1 & 0x7000) >> 12];
		else
		    reg1 = aregs[(specop1 & 0x7000) >> 12];

		GET_WORD(sect, left, length, swapped, specop2);
		if((specop2 & 0x8000) == 0)
		    reg2 = dregs[(specop2 & 0x7000) >> 12];
		else
		    reg2 = aregs[(specop2 & 0x7000) >> 12];
#ifdef MOTO_SYNTAX
		printf("cas2%c\td%d:d%d,d%d:d%d,(%s):(%s)\n",
#else
		printf("cas2%c\td%d,d%d,d%d,d%d,%s,%s\n",
#endif
			size[((opword & 0x0600) >> 9) - 1],
			specop1 & 7, specop2 & 7,
			(specop1 & 0x01c0) >> 6, (specop2 & 0x01c0) >> 6,
			reg1, reg2);
		return(length);
	    }
	    if((opword & 0xf9c0) == 0x08c0){
		GET_WORD(sect, left, length, swapped, specop1);
		printf("cas%c\td%d,d%d,", size[((opword & 0x0600) >> 9) - 1],
			specop1 & 7, (specop1 & 0x01c0) >> 6);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword & 0x0600) >> 9);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x0a00){
		switch((opword & 0x00c0) >> 6){
		case 0:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("eorb\t#0x%x,", (unsigned int)(w & 0xff));
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, B_SIZE);
		    break;
		case 1:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("eorw\t#0x%x,", (unsigned int)w);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    break;
		case 2:
		    GET_LONG(sect, left, length, swapped, l);
		    printf("eorl\t#0x%x,", (unsigned int)l);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    break;
		default:
		    goto bad;
		}
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x0c00){
		switch((opword & 0x00c0) >> 6){
		case 0:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("cmpb\t#0x%x,", (unsigned int)(w & 0xff));
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, B_SIZE);
		    break;
		case 1:
		    GET_WORD(sect, left, length, swapped, w);
		    printf("cmpw\t#0x%x,", (unsigned int)w);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    break;
		case 2:
		    printf("cmpl\t#");
		    GET_LONG(sect, left, length, swapped, l);
		    if(PRINT_SYMBOL(l, addr + length - sizeof(uint32_t)))
			printf(",");
		    else
			printf("0x%x,", (unsigned int)l);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    break;
		default:
		    goto bad;
		}
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x0e00){
		printf("moves%c\t", size[(opword & 0x00c0) >> 6] );
		GET_WORD(sect, left, length, swapped, specop1);
		if((specop1 & 0x8000) == 0)
		    reg1 = dregs[(specop1 & 0x7000) >> 12];
		else
		    reg1 = aregs[(specop1 & 0x7000) >> 12];
		if((specop1 & 0x0800) == 0){
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, (opword & 0x00c0) >> 6);
		    printf(",%s\n", reg1);
		}
		else{
		    printf("%s,", reg1);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, (opword & 0x00c0) >> 6);
		    printf("\n");
		}
		return(length);
	    }
	    break;
	case 0x1:
	    printf("moveb\t");
	    length += PRINT_EF(MODE(opword), REG(opword),
			       sect + length, B_SIZE);
	    printf(",");
	    length += PRINT_EF(DEST_MODE(opword), DEST_REG(opword),
			       sect + length, B_SIZE);
	    printf("\n");
	    return(length);
	case 0x2:
	    if((opword & 0x01c0) == 0x0040){
		printf("movel\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		printf(",%s\n", aregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    printf("movel\t");
	    length += PRINT_EF(MODE(opword), REG(opword),
			       sect + length, L_SIZE);
	    printf(",");
	    length += PRINT_EF(DEST_MODE(opword), DEST_REG(opword),
			       sect + length, L_SIZE);
	    printf("\n");
	    return(length);
	case 0x3:
	    if((opword & 0x01c0) == 0x0040){
		printf("movew\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf(",%s\n", aregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    printf("movew\t");
	    length += PRINT_EF(MODE(opword), REG(opword),
			       sect + length, W_SIZE);
	    printf(",");
	    length += PRINT_EF(DEST_MODE(opword), DEST_REG(opword),
			       sect + length, W_SIZE);
	    printf("\n");
	    return(length);
	case 0x4:
	    if((opword & 0xff00) == 0x4000){
		if((opword & 0xffc0) == 0x40c0){
		    printf("movew\tsr,");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    printf("\n");
		    return(length);
		}
		printf("negx%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xf140) == 0x4100){
		if(opword & 0x0080){
		    printf("chkw\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		}
		else{
		    printf("chkl\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		}
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    if((opword & 0xfe38) == 0x4800){
		switch((opword >> 6) & 0x7){
		case 0x2:
		    printf("extw\t%s\n", dregs[REG(opword)]);
		    return(length);
		case 0x3:
		    printf("extl\t%s\n", dregs[REG(opword)]);
		    return(length);
		case 0x7:
		    printf("extbl\t%s\n", dregs[REG(opword)]);
		    return(length);
		}
	    }
	    if((opword & 0xf1c0) == 0x41c0){
		printf("lea\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf(",a%d\n", (opword & 0x0e00)>>9);
		return(length);
	    }
	    if((opword & 0xff00) == 0x4200){
		if((opword & 0xffc0) == 0x42c0){
		    printf("movew\tcc,");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    printf("\n");
		    return(length);
		}
		printf("clr%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x4400){
		if((opword & 0xffc0) == 0x44c0){
		    printf("movew\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    printf(",cc\n");
		    return(length);
		}
		printf("neg%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x4600){
		if((opword & 0xffc0) == 0x46c0){
		    printf("movew\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    printf(",sr\n");
		    return(length);
		}
		printf("not%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4808){
		GET_LONG(sect, left, length, swapped, l);
		printf("linkl\t%s,#0x%x\n", aregs[REG(opword)],(unsigned int)l);
		return(length);
	    }
	    if((opword & 0xffc0) == 0x4800){
		printf("nbcd\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4840){
		printf("swap\t%s\n", dregs[REG(opword)]);
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4848){
		printf("bkpt\t#%d\n", opword & 0x7);
		return(length);
	    }
	    if((opword & 0xffc0) == 0x4840){
		printf("pea\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xfb80) == 0x4880){
		printf("movem%c\t", size[((opword & 0x0040) >> 6) + 1]);
		GET_WORD(sect, left, length, swapped, specop1);
		if((opword & 0x0400) == 0x0000){
		    if(specop1 == 0){
			printf("#0x0");
		    }
		    else{
			if(MODE(opword) == 4){
			    for(i = 0; i < 8; i++){
				if((specop1 & 0x8000) != 0){
				    printf("%s", dregs[i]);
				    if(((specop1 << 1) & 0xffff) != 0)
					printf("/");
				}
				specop1 <<= 1;
			    }
			    for(i = 0; i < 8; i++){
				if((specop1 & 0x8000) != 0){
				    printf("%s", aregs[i]);
				    if(((specop1 << 1) & 0xffff) != 0)
					printf("/");
				}
				specop1 <<= 1;
			    }
		        }
		        else{
			    for(i = 0; i < 8; i++){
				if((specop1 & 1) != 0){
				    printf("%s", dregs[i]);
				    if((specop1 >> 1) != 0)
					printf("/");
				}
				specop1 >>= 1;
			    }
			    for(i = 0; i < 8; i++){
				if((specop1 & 1) != 0){
				    printf("%s", aregs[i]);
				    if((specop1 >> 1) != 0)
					printf("/");
				}
				specop1 >>= 1;
			    }
		        }
		    }
		    printf(",");
		    length += PRINT_EF(MODE(opword), REG(opword), sect + length,
				       ((opword & 0x0040) >> 6) + 1);
		}
		else{
		    length += PRINT_EF(MODE(opword), REG(opword), sect + length,
				       ((opword & 0x0040) >> 6) + 1);
		    printf(",");
		    if(specop1 == 0){
			printf("#0x0");
		    }
		    else{
			if(MODE(opword) == 4){
			    for(i = 0; i < 8; i++){
				if((specop1 & 0x8000) != 0){
				    printf("%s", dregs[i]);
				    if(((specop1 << 1) & 0xffff) != 0)
					printf("/");
				}
				specop1 <<= 1;
			    }
			    for(i = 0; i < 8; i++){
				if((specop1 & 0x8000) != 0){
				    printf("%s", aregs[i]);
				    if(((specop1 << 1) & 0xffff) != 0)
					printf("/");
				}
				specop1 <<= 1;
			    }
		        }
		        else{
			    for(i = 0; i < 8; i++){
				if((specop1 & 1) != 0){
				    printf("%s", dregs[i]);
				    if((specop1 >> 1) != 0)
					printf("/");
				}
				specop1 >>= 1;
			    }
			    for(i = 0; i < 8; i++){
				if((specop1 & 1) != 0){
				    printf("%s", aregs[i]);
				    if((specop1 >> 1) != 0)
					printf("/");
				}
				specop1 >>= 1;
			    }
		        }
		    }
		}
		printf("\n");
		return(length);
	    }
	    if(opword == 0x4afc){
		printf("illegal\n");
		return(length);
	    }
	    if((opword & 0xff00) == 0x4a00){
		if((opword & 0xffc0) == 0x4ac0){
		    printf("tas\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, W_SIZE);
		    printf("\n");
		    return(length);
		}
		printf("tst%c\t", size[((opword >> 6) & 0x3)]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xffc0) == 0x4c00){
		GET_WORD(sect, left, length, swapped, specop1);
		if(specop1 & 0x0800)
		    printf("mulsl\t");
		else
		    printf("mulul\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		if(specop1 & 0x0400)
		    printf(",%s:%s\n", dregs[specop1 & 0x7],
			   dregs[(specop1 >> 12) & 0x7]);
		else
		    printf(",%s\n", dregs[(specop1 >> 12) & 0x7]);
		return(length);
	    }
	    if((opword & 0xffc0) == 0x4c40){
		GET_WORD(sect, left, length, swapped, specop1);
		if(specop1 & 0x0800)
		    printf("divs");
		else
		    printf("divu");
		if((specop1 & 0x0400) == 0 &&
		   (specop1 & 0x7) == ((specop1 >> 12) & 0x7) ){
		    printf("l\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    printf(",%s\n", dregs[specop1 & 0x7]);
		}
		else{
		    if(specop1 & 0x0400)
			printf("l\t");
		    else
			printf("ll\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
#ifdef MOTO_SYNTAX
		    printf(",%s:%s\n", dregs[specop1 & 0x7],
#else
		    printf(",%s,%s\n", dregs[specop1 & 0x7],
#endif
			   dregs[(specop1 >> 12) & 0x7]);
		}
		return(length);
	    }
	    if((opword & 0xfff0) == 0x4e40){
		printf("trap\t#%d\n", opword &0xf);
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4e50){
		GET_WORD(sect, left, length, swapped, w);
		printf("linkw\t%s,#0x%x\n", aregs[REG(opword)],(unsigned int)w);
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4e58){
		printf("unlk\t%s\n", aregs[REG(opword)]);
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4e60){
		printf("movel\t%s,usp\n", aregs[REG(opword)]);
		return(length);
	    }
	    if((opword & 0xfff8) == 0x4e68){
		printf("movel\tusp,%s\n", aregs[REG(opword)]);
		return(length);
	    }
	    if(opword == 0x4e70){
		printf("reset\n");
		return(length);
	    }
	    if(opword == 0x4e71){
		printf("nop\n");
		return(length);
	    }
	    if(opword == 0x4e72){
		GET_WORD(sect, left, length, swapped, w);
		printf("stop\t#0x%x\n", (unsigned int)w);
		return(length);
	    }
	    if(opword == 0x4e73){
		printf("rte\n");
		return(length);
	    }
	    if(opword == 0x4e74){
		GET_WORD(sect, left, length, swapped, w);
		printf("rtd\t#0x%x\n", (unsigned int)w);
		return(length);
	    }
	    if(opword == 0x4e75){
		printf("rts\n");
		return(length);
	    }
	    if(opword == 0x4e76){
		printf("trapv\n");
		return(length);
	    }
	    if(opword == 0x4e77){
		printf("rtr\n");
		return(length);
	    }
	    if((opword & 0xfffe) == 0x4e7a){
		GET_WORD(sect, left, length, swapped, specop1);
		printf("movec\t");
		if(opword & 0x1){
		    if(specop1 & 0x8000)
			printf("%s,", aregs[(specop1 >> 12) & 0x7]);
		    else
			printf("%s,", dregs[(specop1 >> 12) & 0x7]);
		    switch(specop1 & 0x0fff){
		    case 0x000:
			printf("sfc\n");
			break;
		    case 0x001:
			printf("dfc\n");
			break;
		    case 0x002:
			printf("cacr\n");
			break;
		    case 0x800:
			printf("usp\n");
			break;
		    case 0x801:
			printf("vbr\n");
			break;
		    case 0x802:
			printf("caar\n");
			break;
		    case 0x803:
			printf("msp\n");
			break;
		    case 0x804:
			printf("isp\n");
			break;
		    case 0x003:
			printf("tc\n");
			break;
		    case 0x004:
			printf("itt0\n");
			break;
		    case 0x005:
			printf("itt1\n");
			break;
		    case 0x006:
			printf("dtt0\n");
			break;
		    case 0x007:
			printf("dtt1\n");
			break;
		    case 0x805:
			printf("mmusr\n");
			break;
		    case 0x806:
			printf("urp\n");
			break;
		    case 0x807:
			printf("srp\n");
			break;
		    default:
			printf("???\n");
			break;
		    }
		}
		else{
		    switch(specop1 & 0x0fff){
		    case 0x000:
			printf("sfc,");
			break;
		    case 0x001:
			printf("dfc,");
			break;
		    case 0x002:
			printf("cacr,");
			break;
		    case 0x800:
			printf("usp,");
			break;
		    case 0x801:
			printf("vbr,");
			break;
		    case 0x802:
			printf("caar,");
			break;
		    case 0x803:
			printf("msp,");
			break;
		    case 0x804:
			printf("isp,");
			break;
		    case 0x003:
			printf("tc,");
			break;
		    case 0x004:
			printf("itt0,");
			break;
		    case 0x005:
			printf("itt1,");
			break;
		    case 0x006:
			printf("dtt0,");
			break;
		    case 0x007:
			printf("dtt1,");
			break;
		    case 0x805:
			printf("mmusr,");
			break;
		    case 0x806:
			printf("urp,");
			break;
		    case 0x807:
			printf("srp,");
			break;
		    default:
			printf("???,");
			break;
		    }
		    if(specop1 & 0x8000)
			printf("%s\n", aregs[(specop1 >> 12) & 0x7]);
		    else
			printf("%s\n", dregs[(specop1 >> 12) & 0x7]);
		}
		return(length);
	    }
	    if((opword & 0xffc0) == 0x4e80){
		printf("jsr\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		printf("\n");
		return(length);
	    }
	    if((opword & 0xffc0) == 0x4ec0){
		printf("jmp\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    goto bad;
	case 0x5:
	    if((opword & 0xf0c0) == 0x50c0){
		if((opword & 0x00f8) == 0x00f8){
		    switch(opword & 0x0007){
		    case 2:
			GET_WORD(sect, left, length, swapped, w);
			printf("trap%s.w\t#0x%x\n",
			       conditions[(opword & 0x0f00) >> 8],
			       (unsigned int)w);
			return(length);
		    case 3:
			GET_LONG(sect, left, length, swapped, l);
			printf("trap%s.l\t#0x%x\n",
			       conditions[(opword & 0x0f00) >> 8],
			       (unsigned int)l);
			return(length);
		    case 4:
			printf("trap%s\n", conditions[(opword & 0x0f00) >> 8]);
			return(length);
		    }
		}
		if((opword & 0x00f8) == 0x00c8){
		    printf("db%s\t%s,", conditions[(opword & 0x0f00) >> 8],
			   dregs[REG(opword)]);
		    GET_WORD(sect, left, length, swapped, w);
		    if(w & 0x8000)
			l = 0xffff0000 | w;
		    else
			l = w;
		    if(PRINT_SYMBOL(addr + length - sizeof(unsigned short) + l,
				    addr + length - sizeof(unsigned short)))
			printf("\n");
		    else
			printf("0x%x\n", (unsigned int)
			       (addr + length - sizeof(unsigned short) + l));
		    return(length);
		}
		printf("s%s\t", conditions[(opword & 0x0f00) >> 8]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf("\n");
		return(length);
	    }
	    if(opword & 0x0100)
		printf("subq%c\t#0x%x,", size[(opword >> 6) & 0x3],
		       ((opword >> 9) & 0x7) == 0 ?
		       (unsigned int)8 : (unsigned int)((opword >> 9) & 0x7));
	    else
		printf("addq%c\t#0x%x,", size[(opword >> 6) & 0x3],
		       ((opword >> 9) & 0x7) == 0 ?
		       (unsigned int)8 : (unsigned int)((opword >> 9) & 0x7));
	    length += PRINT_EF(MODE(opword), REG(opword),
			       sect + length, W_SIZE);
	    printf("\n");
	    return(length);
	case 0x6:
	    printf("%s\t", branches[(opword & 0x0f00) >> 8]);
	    if((opword & 0x00ff) == 0x00ff){
		GET_LONG(sect, left, length, swapped, l);
		if(PRINT_SYMBOL(addr + length - sizeof(uint32_t) + l,
				addr + length - sizeof(uint32_t)))
		    printf(":l\n");
		else{
		    printf("0x%x:l", (unsigned int)
			   (addr + length - sizeof(uint32_t) + l));
		    if(verbose){
			indirect_symbol_name = guess_indirect_symbol(
			   (addr + length - sizeof(uint32_t) + l),
			    ncmds, sizeofcmds, load_commands, object_byte_sex,
			    indirect_symbols, nindirect_symbols, symbols, NULL,
			    nsymbols, strings, strings_size);
			if(indirect_symbol_name != NULL)
			    printf("\t; symbol stub for: %s",
				indirect_symbol_name);
		    }
		    printf("\n");
		}
	    }
	    else if((opword & 0x00ff) == 0){
		GET_WORD(sect, left, length, swapped, w);
		if(w & 0x8000)
		    l = 0xffff0000 | w;
		else
		    l = w;
		if(PRINT_SYMBOL(addr + length - sizeof(unsigned short) + l,
				addr + length - sizeof(unsigned short)))
		    printf(":w\n");
		else
		    printf("0x%x:w\n", (unsigned int)
			   (addr + length - sizeof(unsigned short) + l));
	    }
	    else{
		l = (char)opword;
		if(PRINT_SYMBOL(addr + length + l, addr + 1))
		    printf(":b\n");
		else
		    printf("0x%x:b\n", (unsigned int)
			   (addr + length + (int32_t)((char)(opword))));
	    }
	    return(length);
	case 0x7:
	    printf("moveq\t#%u,%s\n", (int32_t)((char)(opword)),
		   dregs[(opword >> 9) & 0x7]);
	    return(length);
	case 0x8:
	    if((opword & 0xf1f0) == 0x8100){
		if(opword & 0x0008)
		    printf("sbcd\t%s@-,%s@-\n", aregs[opword & 0x7],
			   aregs[(opword >> 9) & 0x7]);
		else
		    printf("sbcd\t%s,%s\n", dregs[opword & 0x7],
			   dregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    if((opword & 0xf1f0) == 0x8140){
		GET_WORD(sect, left, length, swapped, w);
		if(opword & 0x0008){
		    printf("pack\t%s@-,%s@-,#0x%x\n", aregs[opword & 0x7],
			   aregs[(opword >> 9) & 0x7], (unsigned int)w);
		}
		else{
		    printf("pack\t%s,%s,#0x%x\n", dregs[opword & 0x7],
			   dregs[(opword >> 9) & 0x7], (unsigned int)w);
		}
		return(length);
	    }
	    if((opword & 0xf1f0) == 0x8180){
		GET_WORD(sect, left, length, swapped, w);
		if(opword & 0x0008){
		    printf("unpk\t%s@-,%s@-,#0x%x\n", aregs[opword & 0x7],
			   aregs[(opword >> 9) & 0x7], (unsigned int)w);
		}
		else{
		    printf("unpk\t%s,%s,#0x%x\n", dregs[opword & 0x7],
			   dregs[(opword >> 9) & 0x7], (unsigned int)w);
		}
		return(length);
	    }
	    if((opword & 0xf0c0) == 0x80c0){
		if(opword & 0x0100)
		    printf("divs\t");
		else
		    printf("divu\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    if(opword & 0x0100){
		printf("or%c\t%s,", size[(opword >> 6) & 0x3],
		       dregs[(opword >> 9) & 0x7]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		printf("\n");
		return(length);
	    }
	    else{
		printf("or%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	case 0xa:
	    break;
	case 0xb:
	    if((opword & 0xf138) == 0xb108 && ((opword >> 6) & 0x7) != 0x7){
		printf("cmpm%c\t%s@+,%s@+\n", size[(opword >> 6) & 0x3],
		       aregs[opword & 0x7], aregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    switch((opword >> 6) & 0x7){
	    case 0:
	    case 1:
	    case 2:
		printf("cmp%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);

	    case 3:
		printf("cmpw\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf(",%s\n", aregs[(opword >> 9) & 0x7]);
		return(length);
	    case 7:
		printf("cmpl\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, L_SIZE);
		printf(",%s\n", aregs[(opword >> 9) & 0x7]);
		return(length);

	    case 4:
	    case 5:
	    case 6:
		printf("eor%c\t%s,", size[(opword >> 6) & 0x3],
		       dregs[(opword >> 9) & 0x7]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf("\n");
		return(length);
	    }
	    break;
	case 0xc:
	    if((opword & 0xf1f8) == 0xc140){
		printf("exg\t%s,%s\n", dregs[(opword >> 9) & 0x7],
		       dregs[opword & 0x7]);
		return(length);
	    }
	    if((opword & 0xf1f8) == 0xc148){
		printf("exg\t%s,%s\n", aregs[(opword >> 9) & 0x7],
		       aregs[opword & 0x7]);
		return(length);
	    }
	    if((opword & 0xf1f8) == 0xc188){
		printf("exg\t%s,%s\n", dregs[(opword >> 9) & 0x7],
		       aregs[opword & 0x7]);
		return(length);
	    }
	    if((opword & 0xf1f0) == 0xc100){
		if(opword & 0x0008){
		    printf("abcd\t%s@-,%s@-\n", aregs[opword & 0x7],
			   aregs[(opword >> 9) & 0x7]);
		}
		else{
		    printf("abcd\t%s,%s\n", dregs[opword & 0x7],
			   dregs[(opword >> 9) & 0x7]);
		}
		return(length);
	    }
	    if((opword & 0xf0c0) == 0xc0c0){
		if(opword & 0x0100)
		    printf("muls\t");
		else
		    printf("mulu\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, W_SIZE);
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	    switch((opword >> 6) & 0x7){
	    case 0:
	    case 1:
	    case 2:
		printf("and%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);
	    case 4:
	    case 5:
	    case 6:
		printf("and%c\t%s,", size[(opword >> 6) & 0x3],
		       dregs[(opword >> 9) & 0x7]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf("\n");
		return(length);
	    }
	    break;
	case 0x9:
	case 0xd:
	    if(opword & 0x4000)
		printf("add");
	    else
		printf("sub");
	    switch((opword >> 6) & 0x7){
	    case 0:
	    case 1:
	    case 2:
		printf("%c\t", size[(opword >> 6) & 0x3]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf(",%s\n", dregs[(opword >> 9) & 0x7]);
		return(length);
	    case 4:
	    case 5:
	    case 6:
		if((opword & 0x0030) == 0x0000){
		    if((opword & 0x0008) == 0){
			printf("x%c\t%s,%s\n", size[(opword >> 6) & 0x3],
			       dregs[opword & 0x7], dregs[(opword >> 9) & 0x7]);
		    }
		    else{
			printf("x%c\t%s@-,%s@-\n", size[(opword >> 6) & 0x3],
			       aregs[opword & 0x7], aregs[(opword >> 9) & 0x7]);
		    }
		    return(length);
		}
		printf("%c\t%s,", size[(opword >> 6) & 0x3],
		       dregs[(opword >> 9) & 0x7]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, (opword >> 6) & 0x3);
		printf("\n");
		return(length);
	    case 3:
	    case 7:
		printf("a%c\t", size[((opword >> 8) & 0x1) + 1]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, ((opword >> 8) & 0x1) + 1);
		printf(",%s\n", aregs[(opword >> 9) & 0x7]);
		return(length);
	    }
	case 0xe:
	    if((opword & 0xf8c0) == 0xe8c0){
		GET_WORD(sect, left, length, swapped, specop1);
		switch((opword >> 8) & 0x7){
		case 0:
		    printf("bftst\t");
		    break;
		case 1:
		    printf("bfextu\t");
		    break;
		case 2:
		    printf("bfchg\t");
		    break;
		case 3:
		    printf("bfexts\t");
		    break;
		case 4:
		    printf("bfclr\t");
		    break;
		case 5:
		    printf("bfffo\t");
		    break;
		case 6:
		    printf("bfset\t");
		    break;
		case 7:
		    printf("bfins\t%s,", dregs[(specop1 >> 12) & 0x7]);
		    break;
		}
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, ((opword & 0x0100) >> 8) + 1);
		if(specop1 & 0x0800)
		    printf("{%s,", dregs[(specop1 >> 6) & 0x7]);
		else
		    printf("{#%d,", (specop1 >> 6) & 0x1f);
		if(specop1 & 0x0020)
		    printf("%s}", dregs[specop1 & 0x7]);
		else
		    printf("#%d}", specop1 & 0x1f);
		if((opword & 0x0100) && (opword & 0x0700) != 0x0700)
		    printf(",%s\n", dregs[(specop1 >> 12) & 0x7]);
		else
		    printf("\n");
		return(length);
	    }
	    if((opword & 0xf8c0) == 0xe0c0){
		switch((opword >> 9) & 0x3){
		case 0:
		    printf("as");
		    break;
		case 1:
		    printf("ls");
		    break;
		case 2:
		    printf("rox");
		    break;
		case 3:
		    printf("ro");
		    break;
		}
		if(opword & 0x0100)
		    printf("lw\t");
		else
		    printf("rw\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, ((opword & 0x0100) >> 8) + 1);
		printf("\n");
		return(length);
	    }
	    switch((opword >> 3) & 0x3){
	    case 0:
		printf("as");
		break;
	    case 1:
		printf("ls");
		break;
	    case 2:
		printf("rox");
		break;
	    case 3:
		printf("ro");
		break;
	    }
	    if(opword & 0x0100)
		printf("l%c\t", size[(opword >> 6) & 0x3]);
	    else
		printf("r%c\t", size[(opword >> 6) & 0x3]);
	    if(opword & 0x0020)
		printf("%s,%s\n", dregs[(opword >> 9) & 0x7],
		       dregs[opword & 0x7]);
	    else
		printf("#%d,%s\n",
		       ((opword >> 9) & 0x7) == 0 ? 8 : (opword >> 9) & 0x7,
		       dregs[opword & 0x7]);
	    return(length);
	case 0xf:
	    if((opword & 0x0e00) == 0x0000){
		GET_WORD(sect, left, length, swapped, specop1);
		switch((specop1 >> 13) & 0x7){
		case 0:
		    if(specop1 & 0x0200){
			if(((specop1 >> 10) & 0x7) == 0x2){
			    if(specop1 & 0x0100){
				printf("pmovefd\ttt0,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			    else{
				printf("pmove\ttt0,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			}
			else if(((specop1 >> 10) & 0x7) == 0x3){
			    if(specop1 & 0x0100){
				printf("pmovefd\ttt1,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			    else{
				printf("pmove\ttt1,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			} else
			    goto bad;
		     }
		     else{
			if(((specop1 >> 10) & 0x7) == 0x2){
			    if(specop1 & 0x0100){
				printf("pmovefd\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",tt0\n");
				return(length);
			    }
			    else{
				printf("pmove\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",tt0\n");
				return(length);
			    }
			}
			else if(((specop1 >> 10) & 0x7) == 0x3){
			    if(specop1 & 0x0100){
				printf("pmovefd\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",tt1\n");
				return(length);
			    }
			    else{
				printf("pmove\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",tt1\n");
				return(length);
			    }
			} else
			    goto bad;
		     }
		case 1:
		    if((specop1 & 0xfde0) == 0x2000){
			if(specop1 & 0x0200)
			    printf("ploadr\t");
			else
			    printf("ploadw\t");
			if((specop1 & 0x18) == 0x10)
			    printf("#0x%x,", (unsigned int)(specop1 & 0x7));
			else if((specop1 & 0x18) == 0x08)
			    printf("%s,", dregs[specop1 & 0x7]);
			else if((specop1 & 0x1f) == 0x00)
			    printf("sfc,");
			else if((specop1 & 0x1f) == 0x01)
			    printf("dfc,");
			else
			    goto bad;
			length += PRINT_EF(MODE(opword), REG(opword),
					   sect + length, L_SIZE);
			printf("\n");
			return(length);
		    }
		    else if((specop1 & 0xe300) == 0x2000){
			if(((specop1 >> 10) & 0x7) == 0x1){
			    printf("pflusha030\n");
			    return(length);
			}
			else if(((specop1 >> 10) & 0x7) == 0x4){
			    if((specop1 & 0x18) == 0x10)
				printf("pflush\t#0x%x,#0x%x\n",
				       (unsigned int)(specop1 & 0x7), 
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else if((specop1 & 0x18) == 0x08)
				printf("pflush\t%s,#0x%x\n",
				       dregs[specop1 & 0x7], 
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else if((specop1 & 0x1f) == 0x00)
				printf("pflush\tsfc,#0x%x\n",
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else if((specop1 & 0x1f) == 0x01)
				printf("pflush\tdfc,#0x%x\n",
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else
				goto bad;
			    return(length);
			}
			else if(((specop1 >> 10) & 0x7) == 0x6){
			    if((specop1 & 0x18) == 0x10)
				printf("pflush\t#0x%x,#0x%x,",
				       (unsigned int)(specop1 & 0x7),
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else if((specop1 & 0x18) == 0x08)
				printf("pflush\t%s,#0x%x,",
				       dregs[specop1 & 0x7],
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else if((specop1 & 0x1f) == 0x00)
				printf("pflush\tsfc,#0x%x,",
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else if((specop1 & 0x1f) == 0x01)
				printf("pflush\tdfc,#0x%x,",
				       (unsigned int)((specop1 >> 5) & 0x7));
			    else
				goto bad;
			    length += PRINT_EF(MODE(opword), REG(opword),
					       sect + length, L_SIZE);
			    printf("\n");
			    return(length);
			}
			else
			    goto bad;
		    }
		    else
			goto bad;
		case 2:
		    if(specop1 & 0x0200){
			if(((specop1 >> 10) & 0x7) == 0x0){
			    if(specop1 & 0x0100){
				printf("pmovefd\ttc,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			    else{
				printf("pmove\ttc,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			}
			else if(((specop1 >> 10) & 0x7) == 0x2){
			    if(specop1 & 0x0100){
				printf("pmovefd\tsrp,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			    else{
				printf("pmove\tsrp,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			}
			else if(((specop1 >> 10) & 0x7) == 0x3){
			    if(specop1 & 0x0100){
				printf("pmovefd\tcrp,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			    else{
				printf("pmove\tcrp,");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf("\n");
				return(length);
			    }
			}
			else
			    goto bad;
		     }
		     else{
			if(((specop1 >> 10) & 0x7) == 0x0){
			    if(specop1 & 0x0100){
				printf("pmovefd\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",tc\n");
				return(length);
			    }
			    else{
				printf("pmove\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",tc\n");
				return(length);
			    }
			}
			else if(((specop1 >> 10) & 0x7) == 0x2){
			    if(specop1 & 0x0100){
				printf("pmovefd\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",srp\n");
				return(length);
			    }
			    else{
				printf("pmove\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",srp\n");
				return(length);
			    }
			}
			else if(((specop1 >> 10) & 0x7) == 0x3){
			    if(specop1 & 0x0100){
				printf("pmovefd\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",crp\n");
				return(length);
			    }
			    else{
				printf("pmove\t");
				length += PRINT_EF(MODE(opword), REG(opword),
						   sect + length, L_SIZE);
				printf(",crp\n");
				return(length);
			    }
			}
			else
			    goto bad;
		     }
		case 3:
		    if(specop1 & 0x0200){
			printf("pmove\tmmusr,");
			length += PRINT_EF(MODE(opword), REG(opword),
					   sect + length, L_SIZE);
			printf("\n");
			return(length);
		    }
		    else{
			printf("pmove\t");
			length += PRINT_EF(MODE(opword), REG(opword),
					   sect + length, L_SIZE);
			printf(",mmusr\n");
			return(length);
		    }
		case 4:
		    if(specop1 & 0x0200)
			printf("ptestr\t");
		    else
			printf("ptestw\t");
		    if((specop1 & 0x18) == 0x10)
			printf("#0x%x,", (unsigned int)(specop1 & 0x7));
		    else if((specop1 & 0x18) == 0x08)
			printf("%s,", dregs[specop1 & 0x7]);
		    else if((specop1 & 0x1f) == 0x00)
			printf("sfc,");
		    else if((specop1 & 0x1f) == 0x01)
			printf("dfc,");
		    else
			goto bad;
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    if(specop1 & 0x0100)
			printf(",#0x%x,%s\n",
			       (unsigned int)((specop1 >> 10) & 0x7),
			       aregs[(specop1 >> 5) & 0x7]);
		    else
			printf(",#0x%x\n",
			       (unsigned int)((specop1 >> 10) & 0x7));
		    return(length);
		default:
		    goto bad;
		}
	    }
	    if((opword & 0x0f20) == 0x0400){
		if(((opword >> 6) & 0x3) == 0 ||
		   ((opword >> 3) & 0x3) == 0)
		    goto bad;
		printf("cinv%c\t%s", scope[((opword >> 3) & 0x3) - 1],
		       cache[((opword >> 6) & 0x3) - 1]);
		if(((opword >> 3) & 0x3) != 0x3)
		    printf(",%s@\n", aregs[opword & 0x7]);
		else
		    printf("\n");
		return(length);
	    }
	    if((opword & 0x0f20) == 0x0420){
		if(((opword >> 6) & 0x3) == 0 ||
		   ((opword >> 3) & 0x3) == 0)
		    goto bad;
		printf("cpush%c\t%s", scope[((opword >> 3) & 0x3) - 1],
		       cache[((opword >> 6) & 0x3) - 1]);
		if(((opword >> 3) & 0x3) != 0x3)
		    printf(",%s@\n", aregs[opword & 0x7]);
		else
		    printf("\n");
		return(length);
	    }
	    if((opword & 0x0fe0) == 0x0500){
		switch((opword >> 3) & 0x3){
		case 0:
		    printf("pflushn\t%s@\n", aregs[opword & 0x7]);
		    return(length);
		case 1:
		    printf("pflush\t%s@\n", aregs[opword & 0x7]);
		    return(length);
		case 2:
		    printf("pflushan\n");
		    return(length);
		case 3:
		    printf("pflusha040\n");
		    return(length);
		}
	    }
	    if((opword & 0x0fd8) == 0x0548){
		if(opword & 0x0020){
		    printf("ptestr\t%s@\n", aregs[opword & 0x7]);
		    return(length);
		}
		else{
		    printf("ptestw\t%s@\n", aregs[opword & 0x7]);
		    return(length);
		}
	    }
	    if((opword & 0x0ff8) == 0x0620){
		GET_WORD(sect, left, length, swapped, specop1);
		printf("move16\t%s@+,%s@+\n", aregs[opword & 0x7],
		       aregs[(specop1 >> 12) & 0x7]);
		return(length);
	    }
	    if((opword & 0x0fe0) == 0x0600){
		GET_LONG(sect, left, length, swapped, l);
		switch((opword >> 3) & 0x3){
		case 0:
		    printf("move16\t%s@+,#0x%x\n", aregs[opword & 0x7],
		           (unsigned int)l);
		    break;
		case 1:
		    printf("move16\t#0x%x,%s@+\n",
		           (unsigned int)l,
			   aregs[opword & 0x7]);
		    break;
		case 2:
		    printf("move16\t%s@,#0x%x\n", aregs[opword & 0x7],
		           (unsigned int)l);
		    break;
		case 3:
		    printf("move16\t#0x%x,%s@\n",
		           (unsigned int)l,
			   aregs[opword & 0x7]);
		    break;
		}
		return(length);
	    }
	    if((opword & 0x0e00) != 0x0200)
		goto bad;

	    switch((opword >> 6) & 0x7){
	    case 0:
		GET_WORD(sect, left, length, swapped, specop1);
		switch((specop1 >> 13) & 0x7){
		case 0:
		    if((specop1 & 0x0078) == 0x0030)
#ifdef MOTO_SYNTAX
			printf("fsincosx\t%s,%s:%s\n",
#else
			printf("fsincosx\t%s,%s,%s\n",
#endif
			       fpregs[(specop1 >> 10) & 0x7],
			       fpregs[specop1 & 0x7],
			       fpregs[(specop1 >> 7) & 0x7]);
		    else{
			if((((specop1 >> 10) & 0x7) == ((specop1 >> 7) & 0x7))||
			   (specop1 & 0x007f) == 0x003a){ /* ftst */
			    if((specop1 & 0x7b) == 0x41) /* f?sqrt */
				printf("%s\t%s\n", fpops[specop1 & 0x7f],
				       fpregs[(specop1 >> 10) & 0x7]);
			    else
				printf("%sx\t%s\n", fpops[specop1 & 0x7f],
				       fpregs[(specop1 >> 10) & 0x7]);
			}
			else{
			    if((specop1 & 0x7b) == 0x41) /* f?sqrt */
				printf("%s\t%s,%s\n", fpops[specop1 & 0x7f],
				       fpregs[(specop1 >> 10) & 0x7],
				       fpregs[(specop1 >> 7) & 0x7]);
			    else
				printf("%sx\t%s,%s\n", fpops[specop1 & 0x7f],
				       fpregs[(specop1 >> 10) & 0x7],
				       fpregs[(specop1 >> 7) & 0x7]);
			}
		    }
		    return(length);
		case 1:
		    goto bad;
		case 2:
		    if((specop1 & 0x1c00) == 0x1c00){
			printf("fmovecrx\t#0x%x,%s\n",
			       (unsigned int)(specop1 & 0x7f),
			       fpregs[(specop1 >> 7) & 0x7]);
			return(length);
		    }
		    printf("%s%c\t", fpops[specop1 & 0x7f],
			   fpformat[(specop1 >> 10) & 0x7]);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length,
				       fpsize[(specop1 >> 10) & 0x7]);
		    if((specop1 & 0x0078) == 0x0030)
#ifdef MOTO_SYNTAX
			printf(",%s:%s\n",
#else
			printf(",%s,%s\n",
#endif
			       fpregs[specop1 & 0x7],
			       fpregs[(specop1 >> 7) & 0x7]);
		    else{
		        if((specop1 & 0x007f) == 0x003a) /* ftst */
			    printf("\n");
			else
			    printf(",%s\n", fpregs[(specop1 >> 7) & 0x7]);
		    }
		    return(length);
		case 3:
		    printf("fmove%c\t%s,", fpformat[(specop1 >> 10) & 0x7],
		    	   fpregs[(specop1 >> 7) & 0x7]);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length,
				       fpsize[(specop1 >> 10) & 0x7]);
		    if(((specop1 >> 10) & 0x7) == 0x3){
			printf("{#%u}\n", (unsigned int)(specop1 & 0x0040) ?
			       (unsigned int)(specop1 & 0x7f) |
				(unsigned int)0xffffff80 :
				(unsigned int)(specop1 & 0x7f));
		    } else if(((specop1 >> 10) & 0x7) == 0x7){
			printf("{%s}\n", dregs[(specop1 >> 4) & 0x7]);
		    } else
			printf("\n");
		    return(length);
		case 4:
		    printf("fmoveml\t");
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    printf(",%s\n", fpcregs[(specop1 >> 10) & 0x7]);
		    return(length);
		case 5:
		    printf("fmoveml\t%s,", fpcregs[(specop1 >> 10) & 0x7]);
		    length += PRINT_EF(MODE(opword), REG(opword),
				       sect + length, L_SIZE);
		    printf("\n");
		    return(length);
		case 6:
		case 7:
		    printf("fmovemx\t");
		    if((specop1 & 0x2000) == 0){
			length += PRINT_EF(MODE(opword), REG(opword),
					   sect + length, X_SIZE);
			printf(",");
			if((specop1 & 0x0800) == 0x0800){
			    printf("%s\n", dregs[((specop1 & 0x0070) >> 4)] );
			}
			else{
			    if((specop1 & 0x00ff) == 0){
				printf("#0x0\n");
			    }
			    else{
				if((specop1 & 0x1000) == 0x1000){
				    for(i = 0; i < 8; i++){
					if((specop1 & 0x0080) != 0){
					    printf("fp%u", i);
					    if(((specop1 << 1) & 0x00ff) != 0)
						printf("/");
					}
					specop1 <<= 1;
				    }
				}
				else{
				    specop1 &= 0x00ff;
				    for(i = 0; i < 8; i++){
					if((specop1 & 1) != 0){
					    printf("fp%u", i);
					    if((specop1 >> 1) != 0)
						printf("/");
					}
					specop1 >>= 1;
				    }
				}
				printf("\n");
			    }
			}
		    }
		    else{
			if((specop1 & 0x0800) == 0x0800){
			    printf("%s,", dregs[((specop1 & 0x0070) >> 4)] );
			}
			else{
			    if((specop1 & 0x00ff) == 0){
				printf("#0x0,");
			    }
			    else{
				if((specop1 & 0x1000) == 0x1000){
				    for(i = 0; i < 8; i++){
					if((specop1 & 0x0080) != 0){
					    printf("fp%u", i);
					    if(((specop1 << 1) & 0x00ff) != 0)
						printf("/");
					}
					specop1 <<= 1;
				    }
				}
				else{
				    specop1 &= 0x00ff;
				    for(i = 0; i < 8; i++){
					if((specop1 & 1) != 0){
					    printf("fp%u", i);
					    if((specop1 >> 1) != 0)
						printf("/");
					}
					specop1 >>= 1;
				    }
				}
				printf(",");
			    }
			}
			length += PRINT_EF(MODE(opword), REG(opword),
					   sect + length, X_SIZE);
			printf("\n");
		    }
		    return(length);
		}
	    case 1:
		GET_WORD(sect, left, length, swapped, specop1);
		if((opword & 0x003f) == 0x003a){
		    GET_WORD(sect, left, length, swapped, w);
		    printf("ftrap%sw\t#0x%x\n", fpcond[specop1 & 0x3f],
			   (unsigned int)w);
		    return(length);
		}
		if((opword & 0x003f) == 0x003b){
		    GET_LONG(sect, left, length, swapped, l);
		    printf("ftrap%sl\t#0x%x\n", fpcond[specop1 & 0x3f],
			   (unsigned int)l);
		    return(length);
		}
		if((opword & 0x003f) == 0x003c){
		    printf("ftrap%s\n", fpcond[specop1 & 0x3f]);
		    return(length);
		}
		if((opword & 0x0038) == 0x0008){
		    printf("fdb%s\t%s,", fpcond[specop1 & 0x3f],
			   dregs[REG(opword)]);
		    GET_WORD(sect, left, length, swapped, w);
		    if(w & 0x8000)
			l = 0xffff0000 | w;
		    else
			l = w;
		    if(PRINT_SYMBOL(addr + length - sizeof(unsigned short) + l,
				    addr + length - sizeof(unsigned short)))
			printf("\n");
		    else
			printf("0x%x\n", (unsigned int)
			       (addr + length - sizeof(unsigned short) + l));
		    return(length);
		}
		printf("fs%s\t", fpcond[specop1 & 0x3f]);
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, B_SIZE);
		printf("\n");
		return(length);
		
	    case 2:
		GET_WORD(sect, left, length, swapped, w);
		if(opword == 0xf280 && w == 0){
		    printf("fnop\n");
		    return(length);
		}
		if(opword & 0x20)
		    goto bad;
		printf("fb%s\t", fpcond[opword & 0x3f]);
		if(w & 0x8000)
		    l = 0xffff0000 | w;
		else
		    l = w;
		if(PRINT_SYMBOL(addr + length - sizeof(unsigned short) + l,
				addr + length - sizeof(unsigned short)))
		    printf(":w\n");
		else
		    printf("0x%x:w\n", (unsigned int)
			   (addr + length - sizeof(unsigned short) + l));
		return(length);

	    case 3:
		if(opword & 0x20)
		    goto bad;
		printf("fb%s\t", fpcond[opword & 0x3f]);
		GET_LONG(sect, left, length, swapped, l);
		if(PRINT_SYMBOL(addr + length - sizeof(uint32_t) + l,
				addr + length - sizeof(uint32_t)))
		    printf(":l\n");
		else
		    printf("0x%x:l\n", (unsigned int)
			   (addr + length - sizeof(uint32_t) + l));
		return(length);
	    case 4:
		printf("fsave\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, B_SIZE);
		printf("\n");
		return(length);
	    case 5:
		printf("frestore\t");
		length += PRINT_EF(MODE(opword), REG(opword),
				   sect + length, B_SIZE);
		printf("\n");
		return(length);
	    case 6:
	    case 7:
		goto bad;
	    }
	}

bad:
	printf(".word\t0x%04x  | invalid instruction\n",
	       (unsigned int)opword);
	return(length);
}

union extension {
    short word;
    struct {
#ifdef __BIG_ENDIAN__
	unsigned da : 1;
	unsigned reg : 3;
	unsigned wl : 1;
	unsigned scale : 2;
	unsigned fb : 1;
	int      disp : 8;
#endif /*  __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
	int      disp : 8;
	unsigned fb : 1;
	unsigned scale : 2;
	unsigned wl : 1;
	unsigned reg : 3;
	unsigned da : 1;
#endif /*  __LITTLE_ENDIAN__ */
    } brief;
    struct {
#ifdef __BIG_ENDIAN__
	unsigned da : 1;
	unsigned reg : 3;
	unsigned wl : 1;
	unsigned scale : 2;
	unsigned fb : 1;
	unsigned bs : 1;
	unsigned is : 1;
	unsigned bdsize : 2;
	unsigned : 1;
	unsigned iis : 3;
#endif /*  __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
	unsigned iis : 3;
	unsigned : 1;
	unsigned bdsize : 2;
	unsigned is : 1;
	unsigned bs : 1;
	unsigned fb : 1;
	unsigned scale : 2;
	unsigned wl : 1;
	unsigned reg : 3;
	unsigned da : 1;
#endif /*  __LITTLE_ENDIAN__ */
    } full;
};

/*
 * Print the effective address mode for the mode and register and the
 * extension word(s) if needed.  The length in bytes of the extension
 * words this effective address used is returned.  Text points to the
 * extension word for this effective address.  Size is the size of the
 * immediate data for the #<data> addressing mode (B_SIZE == byte, etc).
 */
static
uint32_t
print_ef(
uint32_t mode,
uint32_t reg,
char *sect,
uint32_t addr,
uint32_t sect_addr,
uint32_t *left,
uint32_t size,
struct relocation_info *sorted_relocs,
uint32_t nsorted_relocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose,
enum bool swapped)
{
    uint32_t length, bd, od, l, x0, x1, x2, bd_addr, od_addr;
    unsigned short w;
    union extension ext;
    char *base, *index, *scale, bd_size, od_size;
    float f;
    double d;

	bd_size = '\0';
	od_size = '\0';
	length = 0;
	bd_addr = 0;
	od_addr = 0;
	switch(mode){
	case 0:
	    printf("%s", dregs[reg]);
	    return(length);
	case 1:
	    printf("%s", aregs[reg]);
	    return(length);
	case 2:
	    printf("%s@", aregs[reg]);
	    return(length);
	case 3:
	    printf("%s@+", aregs[reg]);
	    return(length);
	case 4:
	    printf("%s@-", aregs[reg]);
	    return(length);
	case 5:
	    GET_WORD(sect, *left, length, swapped, w);
	    printf("%s@(0x%x:w)", aregs[reg], (unsigned int)w);
	    return(length);
	case 7:
	    switch(reg){
	    case 0:
		GET_WORD(sect, *left, length, swapped, w);
		l = (uint32_t)(w & 0xffff);
		if(PRINT_SYMBOL(l, addr) == TRUE)
		    printf(":w");
		else
		    printf("0x%x:w", (unsigned int)w);
		return(length);
	    case 1:
		GET_LONG(sect, *left, length, swapped, l);
		if(PRINT_SYMBOL(l, addr) == TRUE)
		    printf(":l");
		else
		    printf("0x%x:l", (unsigned int)l);
		return(length);
	    case 2:
		GET_WORD(sect, *left, length, swapped, w);
		printf("pc@(0x%x:w)", (unsigned int)w);
		return(length);
	    case 3:
		break;
	    case 4:
		if(size == B_SIZE){
		    printf("#");
		    GET_WORD(sect, *left, length, swapped, w);
		    l = (uint32_t)(w & 0xff);
		    if(PRINT_SYMBOL(l, addr) == TRUE)
			printf(":b");
		    else
			printf("0x%x:b", (unsigned int)(w & 0xff));
		    return(length);
		}
		else if(size == W_SIZE){
		    printf("#");
		    GET_WORD(sect, *left, length, swapped, w);
		    l = (uint32_t)(w & 0xffff);
		    if(PRINT_SYMBOL(l, addr) == TRUE)
			printf(":w");
		    else
			printf("0x%x:w", (unsigned int)w);
		    return(length);
		}
		else if(size == L_SIZE){
		    printf("#");
		    GET_LONG(sect, *left, length, swapped, l);
		    if(PRINT_SYMBOL(l, addr) == TRUE)
			printf(":l");
		    else
			printf("0x%x:l", (unsigned int)l);
		    return(length);
		}
		else if(size == S_SIZE){
		    GET_FLOAT(sect, *left, length, swapped, f);
		    printf("#0s%g", f);
		    return(length);
		}
		else if(size == D_SIZE){
		    GET_DOUBLE(sect, *left, length, swapped, d);
		    printf("#0d%g", d);
		    return(length);
		}
		else if(size == X_SIZE){
		    if(*left < sizeof(uint32_t) * 3){
			x0 = 0;
			x1 = 0;
			x2 = 0;
			if(*left < sizeof(uint32_t)){
			    memcpy((char *)&x0, sect + length, *left);
			}
			else if(*left < sizeof(uint32_t) * 2){
			    memcpy((char *)&x0, sect + length,
				   sizeof(uint32_t));
			    memcpy((char *)&x1, sect + length + 4, *left);
			}
			else{
			    memcpy((char *)&x0, sect + length,
				   sizeof(uint32_t));
			    memcpy((char *)&x1, sect + length + 4,
				   sizeof(uint32_t));
			    memcpy((char *)&x2, sect + length + 8, *left);
			}
			length += *left;
			*left = 0;
		    }
		    else{
			memcpy((char *)&x0, sect + length,
			       sizeof(uint32_t));
			memcpy((char *)&x1, sect + length + 4,
			       sizeof(uint32_t));
			memcpy((char *)&x2, sect + length + 8,
			       sizeof(uint32_t));
			length += sizeof(uint32_t) * 3;
			*left -= sizeof(uint32_t) * 3;
		    }
		    if(swapped){
			x0 = SWAP_INT(x0);
			x1 = SWAP_INT(x1);
			x2 = SWAP_INT(x2);
		    }
		    printf("#0b%08x%08x%08x", (unsigned int)x0,
			   (unsigned int)x1, (unsigned int)x2);
		    return(length);
		}
		else if(size == P_SIZE){
		    if(*left < sizeof(uint32_t) * 3){
			x0 = 0;
			x1 = 0;
			x2 = 0;
			if(*left < sizeof(uint32_t)){
			    memcpy((char *)&x0, sect + length, *left);
			}
			else if(*left < sizeof(uint32_t) * 2){
			    memcpy((char *)&x0, sect + length,
				   sizeof(uint32_t));
			    memcpy((char *)&x1, sect + length + 4, *left);
			}
			else{
			    memcpy((char *)&x0, sect + length,
				   sizeof(uint32_t));
			    memcpy((char *)&x1, sect + length + 4,
				   sizeof(uint32_t));
			    memcpy((char *)&x2, sect + length + 8, *left);
			}
			length += *left;
			*left = 0;
		    }
		    else{
			memcpy((char *)&x0, sect + length,
			       sizeof(uint32_t));
			memcpy((char *)&x1, sect + length + 4,
			       sizeof(uint32_t));
			memcpy((char *)&x2, sect + length + 8,
			       sizeof(uint32_t));
			length += sizeof(uint32_t) * 3;
			*left -= sizeof(uint32_t) * 3;
		    }
		    if(swapped){
			x0 = SWAP_INT(x0);
			x1 = SWAP_INT(x1);
			x2 = SWAP_INT(x2);
		    }
		    if(x0 & 0x80000000)
			printf("#-%c.", (char)((x0 & 0xf) + '0'));
		    else
			printf("#%c.", (char)((x0 & 0xf) + '0'));
		    printf("%08x%08x", (unsigned int)x1, (unsigned int)x2);
		    if(x0 & 0x40000000)
			printf("e-%03x", (unsigned int)(x0 & 0xfff)); 
		    else
			printf("e%03x", (unsigned int)(x0 & 0xfff)); 
		    return(length);
		}
	    default:
		printf("<bad ef>");
		return(length);
	    }
	}

	/*
	 * To get here we know that the mode is 6 (110) or the mode is 7 (111)
	 * and the register is (011).  So that this uses either a brief or
	 * full extension word.
	 */
	GET_WORD(sect, *left, length, swapped, ext.word);
	if(mode == 6)
	    base = aregs[reg];
	else
	    base = "pc";
	if(ext.brief.da == 0)
	    index = dregs[ext.brief.reg];
	else
	    index = aregs[ext.brief.reg];
	scale = scales[ext.brief.scale];
	/* check for a brief format extension word */
	if(ext.brief.fb == 0){
	    printf("%s@(0x%x:b,%s:%c%s)", base, (unsigned int)ext.brief.disp,
		   index, wl[ext.brief.wl], scale);
	}
	/* extension word is a full format extension word */
	else{
	    switch(ext.full.bdsize){
	    case 0:
		printf("<bad ef>");
		return(length);
	    case 1:
		break;
	    case 2:
		bd_addr = addr + length;
		GET_WORD(sect, *left, length, swapped, w);
		bd = w;
		bd_size = 'w';
		break;
	    case 3:
		bd_addr = addr + length;
		GET_LONG(sect, *left, length, swapped, bd);
		bd_size = 'l';
		break;
	    }
	    switch(ext.full.iis & 0x3){
	    case 0:
	    case 1:
		break;
	    case 2:
		od_addr = addr + length;
		GET_WORD(sect, *left, length, swapped, w);
		od = w;
		od_size = 'w';
		break;
	    case 3:
		od_addr = addr + length;
		GET_LONG(sect, *left, length, swapped, od);
		od_size = 'l';
		break;
	    }
	    /* check if base (address) register is not used */
	    if(ext.full.bs == 1){
		if(mode == 7)
		    base = "zpc";
		else
		    base = "";
	    }
	    /* check if base displacement is used */
	    if(ext.full.bdsize != 1){
		/* check if index register is used */
		if(ext.full.is == 0){
		    switch(ext.full.iis){
		    case 0:
/*
			printf("%s@(0x%x:%c,%s:%c%s)", base, (unsigned int)bd,
				bd_size, index, wl[ext.full.wl], scale);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c,", bd_size);
			else
			    printf("0x%x:%c,", (unsigned int)bd, bd_size);
			printf("%s:%c%s)", index, wl[ext.full.wl], scale);
			break;
		    case 1:
/*
			printf("%s@(0x%x:%c,%s:%c%s)@(0)",base,(unsigned int)bd,
				bd_size, index, wl[ext.full.wl], scale);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c,", bd_size);
			else
			    printf("0x%x:%c,", (unsigned int)bd, bd_size);
			printf("%s:%c%s)@(0)", index, wl[ext.full.wl], scale);
			break;
		    case 2:
		    case 3:
/*
			printf("%s@(0x%x:%c,%s:%c%s)@(0x%x:%c)", base,
				(unsigned int)bd, bd_size, index,
				wl[ext.full.wl], scale, (unsigned int)od,
				od_size);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c,", bd_size);
			else
			    printf("0x%x:%c,", (unsigned int)bd, bd_size);
			printf("%s:%c%s)@(", index, wl[ext.full.wl], scale);
			if(PRINT_SYMBOL(od, od_addr) == TRUE)
			    printf(":%c)", od_size);
			else
			    printf("0x%x:%c)", (unsigned int)od, od_size);
			break;
		    case 5:
/*
			printf("%s@(0x%x:%c)@(0,%s:%c%s)",base,(unsigned int)bd,
				bd_size, index, wl[ext.full.wl], scale);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c)", bd_size);
			else
			    printf("0x%x:%c)", (unsigned int)bd, bd_size);
			printf("@(0,%s:%c%s)", index, wl[ext.full.wl], scale);
			break;
		    case 6:
		    case 7:
/*
			printf("%s@(0x%x:%c)@(0x%x:%c,%s:%c%s)", base,
				(unsigned int)bd, bd_size, (unsigned int)od,
				od_size, index, wl[ext.full.wl], scale);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c)@(", bd_size);
			else
			    printf("0x%x:%c)@(", (unsigned int)bd, bd_size);
			if(PRINT_SYMBOL(od, od_addr) == TRUE)
			    printf(":%c,", od_size);
			else
			    printf("0x%x:%c,", (unsigned int)od, od_size);
			printf("%s:%c%s)", index, wl[ext.full.wl], scale);
			break;
		    case 4:
		    default:
			printf("<bad ef>");
			break;
		    }
		}
		/* index register is suppressed */
		else{
		    switch(ext.full.iis){
		    case 0:
/*
			printf("%s@(0x%x:%c)", base, (unsigned int)bd, bd_size);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL_DOT(bd, bd_addr, addr) == TRUE)
			    printf(":%c)", bd_size);
			else
			    printf("0x%x:%c)", (unsigned int)bd, bd_size);
			break;
		    case 1:
/*
			printf("%s@(0x%x:%c)@(0)", base, (unsigned int)bd,
				bd_size);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c)@(0)", bd_size);
			else
			    printf("0x%x:%c)@(0)", (unsigned int)bd, bd_size);
			break;
		    case 2:
		    case 3:
/*
			printf("%s@(0x%x:%c)@(0x%x:%c)", base, (unsigned int)bd,
				 bd_size, (unsigned int)od, od_size);
*/
			printf("%s@(", base);
			if(PRINT_SYMBOL(bd, bd_addr) == TRUE)
			    printf(":%c)@(", bd_size);
			else
			    printf("0x%x:%c)@(", (unsigned int)bd, bd_size);
			if(PRINT_SYMBOL(od, od_addr) == TRUE)
			    printf(":%c)", od_size);
			else
			    printf("0x%x:%c)", (unsigned int)od, od_size);
			break;
		    default:
			printf("<bad ef>");
			break;
		    }
		}
	    }
	    /* base displacement is not used */
	    else{
		/* check if index register is used */
		if(ext.full.is == 0){
		    switch(ext.full.iis){
		    case 0:
			printf("%s@(0,%s:%c%s)", base, index, wl[ext.full.wl],
				scale);
			break;
		    case 1:
			printf("%s@(0,%s:%c%s)@(0)", base, index,
				wl[ext.full.wl], scale);
			break;
		    case 2:
		    case 3:
/*
			printf("%s@(0,%s:%c%s)@(0x%x:%c)", base, index,
				wl[ext.full.wl], scale, (unsigned int)od,
				od_size);
*/
			printf("%s@(0,%s:%c%s)@(", base, index, wl[ext.full.wl],
			       scale);
			if(PRINT_SYMBOL(od, od_addr) == TRUE)
			    printf(":%c)", od_size);
			else
			    printf("0x%x:%c)", (unsigned int)od, od_size);
			break;
		    case 5:
			printf("%s@(0)@(0,%s:%c%s)", base, index,
				wl[ext.full.wl], scale);
			break;
		    case 6:
		    case 7:
/*
			printf("%s@(0)@(0x%x:%c,%s:%c%s)",base,(unsigned int)od,
				od_size, index, wl[ext.full.wl], scale);
*/
			printf("%s@(0)@(", base);
			if(PRINT_SYMBOL(od, od_addr) == TRUE)
			    printf(":%c)", od_size);
			else
			    printf("0x%x:%c)", (unsigned int)od, od_size);
			printf(",%s:%c%s)@(", index, wl[ext.full.wl], scale);
			break;
		    case 4:
		    default:
			printf("<bad ef>");
			break;
		    }
		}
		/* index register is suppressed */
		else{
		    switch(ext.full.iis){
		    case 0:
			printf("%s@(0)", base);
			break;
		    case 1:
			printf("%s@(0)@(0)", base);
			break;
		    case 2:
		    case 3:
/*
			printf("%s@(0)@(0x%x:%c)", base, (unsigned int)od,
				od_size);
*/
			printf("%s@(0)@(", base);
			if(PRINT_SYMBOL(od, od_addr) == TRUE)
			    printf(":%c)", od_size);
			else
			    printf("0x%x:%c)", (unsigned int)od, od_size);
			break;
		    default:
			printf("<bad ef>");
			break;
		    }
		}
	    }
	}
	return(length);
}
                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/m68k_disasm.h                         0100644 0001750 0001750 00000004356 12612724206 024102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <stuff/bytesex.h>
#import <mach-o/reloc.h>
#import <mach-o/nlist.h>
#import <stuff/bool.h>
#include "stuff/symbol.h"

extern uint32_t m68k_disassemble(
    char *sect,
    uint32_t left,
    uint32_t addr,
    uint32_t sect_addr,
    enum byte_sex object_byte_sex,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum bool verbose);
                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/m88k_disasm.c                         0100644 0001750 0001750 00000113101 12612724206 024064  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/m88k/reloc.h>
#include "stuff/bytesex.h"
#include "stuff/symbol.h"
#include "otool.h"

#define	D(x)		(((x) >> 21) & 0x1f)
#define	S1(x)		(((x) >> 16) & 0x1f)
#define	S2(x)		((x) & 0x1f)
#define	CR(x)		(((x) >> 5) & 0x3f)
#define	T1(x)		(((x) >> 9) & 0x3)
#define	T2(x)		(((x) >> 7) & 0x3)
#define	TD(x)		(((x) >> 5) & 0x3)
#define	W(x)		(((x) >> 10) & 0x1)
#define	B(x)		(((x) >> 10) & 0x1)
#define	USR(x)		(((x) >> 8) & 0x1)
#define TY(x)		(((x) >> 10) & 0x3)
#define THRU(x)		(((x) >> 7) & 0x1)
#define IO(x)		(((x) >> 8) & 0x3)
#define SAT(x)		(((x) >> 7) & 0x3)
#define PT(x)		(((x) >> 5) & 0x3)
#define	B5(x)		(((x) >> 21) & 0x1f)
#define	M5(x)		(((x) >> 21) & 0x1f)
#define	W5(x)		(((x) >> 5) & 0x1f)
#define	OP5(x)		((x) & 0x1f)
#define	VEC9(x)		((x) & 0x1ff)

static char ty[] = { 's', 'd', 'x', '?' };
static char *ty_star[] = { ".s", ".d", ".?", ".?" };
static char *w[] = { ".bu", "" };
static char *b[] = { ".hu", ".bu" };
static char *usr[] = { "", ".usr" };
static char *tyr0[] = { ".d", "", ".x", ".?" };
static char *tyr1[] = { ".d", "", ".h", ".b" };
static char *tyf1[] = { ".d", "", ".h", ".x" };
static char *thru[] = { "", ".wt" };
static char *io[] = { "", ".co", ".ci", ".cio" };
static char *sat[] = { "", "s.u", "s.us", "s.s" };
static char *pt[] = { ".n", ".b", ".h", "" };
static char *b5[] = { "??", "??", "eq", "ne", "gt", "le", "lt", "ge", "hi",
		      "ls", "lo", "hs", "be", "nb", "he", "nh" };

static void print_b5(
    uint32_t value);
static void print_m5(
    uint32_t value);
static void print_immediate(
    uint32_t value, 
    uint32_t sect_offset,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

uint32_t
m88k_disassemble(
char *sect,
uint32_t left,
uint32_t addr,
uint32_t sect_addr,
enum byte_sex object_byte_sex,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t opcode;
    uint32_t sect_offset;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;
	sect_offset = addr - sect_addr;

	if(left < sizeof(uint32_t)){
	   if(left != 0){
		memcpy(&opcode, sect, left);
		if(swapped)
		    opcode = SWAP_INT(opcode);
		printf(".long\t0x%08x\n", (unsigned int)opcode);
	   }
	   printf("(end of section)\n");
	   return(left);
	}

	memcpy(&opcode, sect, sizeof(uint32_t));
	if(swapped)
	    opcode = SWAP_INT(opcode);

	switch(opcode & 0xfc000000){
	case 0x00000000:
	    printf("ld.d\tx%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x04000000:
	    printf("ld\tx%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x08000000:
	    printf("ld.hu\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x0c000000:
	    printf("ld.bu\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x10000000:
	    printf("ld.d\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x14000000:
	    printf("ld\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x18000000:
	    printf("ld.h\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x1c000000:
	    printf("ld.b\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x20000000:
	    printf("st.d\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x24000000:
	    printf("st\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x28000000:
	    printf("st.h\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x2c000000:
	    printf("st.b\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x30000000:
	    printf("st.d\tx%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x34000000:
	    printf("st\tx%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x38000000:
	    printf("st.x\tx%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x3c000000:
	    printf("ld.x\tx%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x40000000:
	    printf("and\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x44000000:
	    printf("and.u\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x48000000:
	    printf("mask\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x4c000000:
	    printf("mask.u\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x50000000:
	    printf("xor\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x54000000:
	    printf("xor.u\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x58000000:
	    printf("or\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x5c000000:
	    printf("or.u\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x60000000:
	    printf("addu\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x64000000:
	    printf("subu\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x68000000:
	    printf("divu\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x6c000000:
	    printf("mulu\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x70000000:
	    printf("add\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x74000000:
	    printf("sub\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x78000000:
	    printf("divs\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x7C000000:
	    printf("cmp\tr%u,r%u,",D(opcode), S1(opcode));
	    print_immediate(opcode & 0xffff, sect_offset, relocs, nrelocs,
			    symbols, nsymbols, sorted_symbols, nsorted_symbols,
			    strings, strings_size, verbose);
	    break;
	case 0x80000000:
	    switch(opcode & 0x0000f800){
	    case 0x00004000:
		if((opcode & 0x001f001f) == 0)
		    printf("ldcr\tr%u,cr%u\n", D(opcode), CR(opcode));
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00008000:
		if((opcode & 0x03e00000) == 0)
		    if(S1(opcode) == S2(opcode))
			printf("stcr\tr%u,cr%u\n", S1(opcode), CR(opcode));
		    else
			printf("stcr\tr%u,cr%u\t| error: fields S1 != S2\n",
				S1(opcode), CR(opcode));
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x0000c000:
		if(S1(opcode) == S2(opcode))
		    printf("xcr\tr%u,r%u,cr%u\n", D(opcode), S1(opcode),
			    CR(opcode));
		else
		    printf("xcr\tr%u,r%u,cr%u\t| error: fields S1 != S2\n",
			    D(opcode), S1(opcode), CR(opcode));
		break;
	    case 0x00004800:
		if((opcode & 0x001f001f) == 0)
		    printf("fldcr\tr%u,fcr%u\n", D(opcode), CR(opcode));
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00008800:
		if((opcode & 0x03e00000) == 0)
		    if(S1(opcode) == S2(opcode))
			printf("fstcr\tr%u,fcr%u\n", S1(opcode), CR(opcode));
		    else
			printf("fstcr\tr%u,fcr%u\t| error: fields S1 != S2\n",
				S1(opcode), CR(opcode));
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x0000c800:
		if(S1(opcode) == S2(opcode))
		    printf("fxcr\tr%u,r%u,fcr%u\n", D(opcode), S1(opcode),
			    CR(opcode));
		else
		    printf("fxcr\tr%u,r%u,fcr%u\t| error: fields S1 != S2\n",
			    D(opcode), S1(opcode), CR(opcode));
		break;
	    default:
		printf("0x%08x\n", (unsigned int)opcode);
		break;
	    }
	    break;

	/* all sfu1 opcodes */
	case 0x84000000:
	    switch(opcode & 0x00007800){
	    case 0x00000000:
		if(opcode & 0x00008000)
		    printf("fmul.%c%c%c\tx%u,x%u,x%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		else
		    printf("fmul.%c%c%c\tr%u,r%u,r%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		break;
	    case 0x00000800:
		if(opcode & 0x00008000)
		    printf("fcvt.%c%c\tx%u,x%u\n", ty[TD(opcode)],
			    ty[T2(opcode)], D(opcode), S2(opcode));
		else
		    printf("fcvt.%c%c\tr%u,r%u\n", ty[TD(opcode)],
			    ty[T2(opcode)], D(opcode), S2(opcode));
		break;
	    case 0x00002000:
		if(opcode & 0x00000200)
		    printf("flt.%cs\tx%u,r%u\n", ty[TD(opcode)], D(opcode),
			   S2(opcode));
		else
		    printf("flt.%cs\tr%u,r%u\n", ty[TD(opcode)], D(opcode),
			   S2(opcode));
		break;
	    case 0x00002800:
		if(opcode & 0x00008000)
		    printf("fadd.%c%c%c\tx%u,x%u,x%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		else
		    printf("fadd.%c%c%c\tr%u,r%u,r%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		break;
	    case 0x00003000:
		if(opcode & 0x00008000)
		    printf("fsub.%c%c%c\tx%u,x%u,x%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		else
		    printf("fsub.%c%c%c\tr%u,r%u,r%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		break;
	    case 0x00003800:
		if((opcode & 0x00000060) == 0x00000000){
		    if(opcode & 0x00008000)
			printf("fcmp.s%c%c\tr%u,x%u,x%u\n", ty[T1(opcode)],
				ty[T2(opcode)], D(opcode), S1(opcode),
				S2(opcode));
		    else
			printf("fcmp.s%c%c\tr%u,r%u,r%u\n", ty[T1(opcode)],
				ty[T2(opcode)], D(opcode), S1(opcode),
				S2(opcode));
		}
		else if((opcode & 0x00000060) == 0x00000020){
		    if(opcode & 0x00008000)
			printf("fcmpu.s%c%c\tr%u,x%u,x%u\n", ty[T1(opcode)],
				ty[T2(opcode)], D(opcode), S1(opcode),
				S2(opcode));
		    else
			printf("fcmpu.s%c%c\tr%u,r%u,r%u\n", ty[T1(opcode)],
				ty[T2(opcode)], D(opcode), S1(opcode),
				S2(opcode));
		}
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00004000:
		if((opcode & 0x001f8660) == 0x00008000){
		    /* mov to g (from x) */
		    printf("mov%s\tr%u,x%u\n", ty_star[T2(opcode)],
			    D(opcode), S2(opcode));
		}
		else if((opcode & 0x001f8660) == 0x00000200){
		    /* mov to x (from g) */
		    printf("mov%s\tx%u,r%u\n", ty_star[T2(opcode)],
			    D(opcode), S2(opcode));
		}
		else if((opcode & 0x001f87e0) == 0x00008300){
		    /* mov to x (from x) */
		    printf("mov\tx%u,x%u\n", D(opcode), S2(opcode));
		}
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00004800:
		if((opcode & 0x001f8660) == 0x00008000){
		    printf("int.s%c\tr%u,x%u\n", ty[T2(opcode)], D(opcode),
			   S2(opcode));
		}
		else if((opcode & 0x001f8660) == 0x00000000){
		    printf("int.s%c\tr%u,r%u\n", ty[T2(opcode)], D(opcode),
			   S2(opcode));
		}
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00005000:
		if((opcode & 0x001f8660) == 0x00008000){
		    printf("nint.s%c\tr%u,x%u\n", ty[T2(opcode)], D(opcode),
			   S2(opcode));
		}
		else if((opcode & 0x001f8660) == 0x00000000){
		    printf("nint.s%c\tr%u,r%u\n", ty[T2(opcode)], D(opcode),
			   S2(opcode));
		}
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00005800:
		if((opcode & 0x001f8660) == 0x00008000){
		    printf("trnc.s%c\tr%u,x%u\n", ty[T2(opcode)], D(opcode),
			   S2(opcode));
		}
		else if((opcode & 0x001f8660) == 0x00000000){
		    printf("trnc.s%c\tr%u,r%u\n", ty[T2(opcode)], D(opcode),
			   S2(opcode));
		}
		else
		    printf("0x%08x\n", (unsigned int)opcode);
		break;
	    case 0x00007000:
		if(opcode & 0x00008000)
		    printf("fdiv.%c%c%c\tx%u,x%u,x%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		else
		    printf("fdiv.%c%c%c\tr%u,r%u,r%u\n", ty[TD(opcode)],
			    ty[T1(opcode)], ty[T2(opcode)], D(opcode),
			    S1(opcode), S2(opcode));
		break;
	    case 0x00007800:
		if(opcode & 0x00008000)
		    printf("fsqrt.%c%c\tx%u,x%u\n", ty[TD(opcode)],
			    ty[T2(opcode)], D(opcode), S2(opcode));
		else
		    printf("fsqrt.%c%c\tr%u,r%u\n", ty[TD(opcode)],
			    ty[T2(opcode)], D(opcode), S2(opcode));
		break;
	    default:
		printf("0x%08x\n", (unsigned int)opcode);
		break;
	    }
	    break;

	/* all sfu2 opcodes */
	case 0x88000000:
	    switch(opcode & 0x0000f800){
	    case 0x00000000:
		printf("pmul\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
		       S2(opcode) );
		break;
	    case 0x00002000:
		printf("padd%s%s\tr%u,r%u,r%u\n", sat[SAT(opcode)],
		       pt[PT(opcode)], D(opcode), S1(opcode), S2(opcode) );
		break;
	    case 0x00003000:
		printf("psub%s%s\tr%u,r%u,r%u\n", sat[SAT(opcode)],
		       pt[PT(opcode)], D(opcode), S1(opcode), S2(opcode) );
		break;
	    case 0x00003800:
		printf("pcmp\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
		       S2(opcode) );
		break;
	    case 0x00006000:
		switch(opcode & 0x00000780){
		case 0x00000100:
		    printf("ppack.8%s\tr%u,r%u,r%u\n", pt[PT(opcode)],
			   D(opcode), S1(opcode), S2(opcode) );
		    break;
		case 0x00000200:
		    printf("ppack.16%s\tr%u,r%u,r%u\n", pt[PT(opcode)],
			   D(opcode), S1(opcode), S2(opcode) );
		    break;
		case 0x00000400:
		    printf("ppack.32%s\tr%u,r%u,r%u\n", pt[PT(opcode)],
			   D(opcode), S1(opcode), S2(opcode) );
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    case 0x00006800:
		printf("punpk%s\tr%u,r%u\n", pt[PT(opcode)], D(opcode),
		       S1(opcode) );
		break;
	    case 0x00007000:
		printf("prot\tr%u,r%u,<%u>\n", D(opcode), S1(opcode),
		       ((opcode >> 7) & 0xf) << 2 );
		break;
	    case 0x00007800:
		printf("prot\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
		       S2(opcode) );
		break;
	    default:
		printf("0x%08x\n", (unsigned int)opcode);
		break;
	    }
	    break;

	case 0xc0000000:
	case 0xc4000000:
	    if((opcode & 0x04000000) == 0)
		printf("br\t");
	    else
		printf("br.n\t");
	    if((opcode & 0x02000000) == 0)
		print_immediate(addr + ((opcode & 0x03ffffff) << 2),sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    else
		print_immediate(addr +
		    (((opcode & 0x03ffffff) << 2) | 0xf0000000), sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    break;
	case 0xc8000000:
	case 0xcc000000:
	    if((opcode & 0x04000000) == 0)
		printf("bsr\t");
	    else
		printf("bsr.n\t");
	    if((opcode & 0x02000000) == 0)
		print_immediate(addr + ((opcode & 0x03ffffff) << 2),sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    else
		print_immediate(addr +
		    (((opcode & 0x03ffffff) << 2) | 0xf0000000), sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    break;
	case 0xd0000000:
	case 0xd4000000:
	    if((opcode & 0x04000000) == 0)
		printf("bb0\t");
	    else
		printf("bb0.n\t");
	    print_b5(B5(opcode));
	    printf(",r%u,", S1(opcode) );
	    if((opcode & 0x00008000) == 0)
		print_immediate(addr + ((opcode & 0x0000ffff) << 2),sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    else
		print_immediate(addr +
		    (((opcode & 0x0000ffff) << 2) | 0xfffc0000), sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    break;
	case 0xd8000000:
	case 0xdc000000:
	    if((opcode & 0x04000000) == 0)
		printf("bb1\t");
	    else
		printf("bb1.n\t");
	    print_b5(B5(opcode));
	    printf(",r%u,", S1(opcode) );
	    if((opcode & 0x00008000) == 0)
		print_immediate(addr + ((opcode & 0x0000ffff) << 2),sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    else
		print_immediate(addr +
		    (((opcode & 0x0000ffff) << 2) | 0xfffc0000), sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    break;
	case 0xe8000000:
	case 0xec000000:
	    if((opcode & 0x04000000) == 0)
		printf("bcnd\t");
	    else
		printf("bcnd.n\t");
	    print_m5(M5(opcode));
	    printf(",r%u,", S1(opcode) );
	    if((opcode & 0x00008000) == 0)
		print_immediate(addr + ((opcode & 0x0000ffff) << 2),sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    else
		print_immediate(addr +
		    (((opcode & 0x0000ffff) << 2) | 0xfffc0000), sect_offset,
		    relocs, nrelocs, symbols, nsymbols, sorted_symbols,
		    nsorted_symbols, strings, strings_size, verbose);
	    break;

	case 0xf0000000:
	    switch(opcode & 0x0000c000){
	    /* ld, st, lda[] */
	    case 0x00000000:
		switch(opcode & 0x0000f000){
		case 0x00000000:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		case 0x00001000:
		    /* ld R = 0, XRF dest */
		    if((opcode & 0x00000200) == 0)
			printf("ld%s%s\tx%u,r%u,r%u\n", tyr0[TY(opcode)],
			       usr[USR(opcode)], D(opcode), S1(opcode),
			       S2(opcode) );
		    else
			printf("ld%s%s\tx%u,r%u[r%u]\n", tyr0[TY(opcode)],
			       usr[USR(opcode)], D(opcode), S1(opcode),
			       S2(opcode) );
		    break;
		case 0x00002000:
		    /* st R = 0, XRF dest */
		    if((opcode & 0x00000200) == 0)
			printf("st%s%s%s\tx%u,r%u,r%u\n", tyr0[TY(opcode)],
			       usr[USR(opcode)], thru[THRU(opcode)], D(opcode),
			       S1(opcode), S2(opcode) );
		    else
			printf("st%s%s%s\tx%u,r%u[r%u]\n", tyr0[TY(opcode)],
			       usr[USR(opcode)], thru[THRU(opcode)], D(opcode),
			       S1(opcode), S2(opcode) );
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    case 0x00004000:
		printf("0x%08x\n", (unsigned int)opcode);
		break;
	    /* clr, set, ext, extu, mak, rot */
	    case 0x00008000:
		switch(opcode & 0x0000fc00){
		case 0x00008000:
		    printf("clr\tr%u,r%u,%u<%u>\n", D(opcode), S1(opcode),
			   W5(opcode), OP5(opcode) );
		    break;
		case 0x00008800:
		    printf("set\tr%u,r%u,%u<%u>\n", D(opcode), S1(opcode),
			   W5(opcode), OP5(opcode) );
		    break;
		case 0x00009000:
		    printf("ext\tr%u,r%u,%u<%u>\n", D(opcode), S1(opcode),
			   W5(opcode), OP5(opcode) );
		    break;
		case 0x00009800:
		    printf("extu\tr%u,r%u,%u<%u>\n", D(opcode), S1(opcode),
			   W5(opcode), OP5(opcode) );
		    break;
		case 0x0000a000:
		    printf("mak\tr%u,r%u,%u<%u>\n", D(opcode), S1(opcode),
			   W5(opcode), OP5(opcode) );
		    break;
		case 0x0000a800:
		    printf("rot\tr%u,r%u,<%u>\n", D(opcode), S1(opcode),
			   OP5(opcode) );
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    /* tb0, tb1, tcnd */
	    case 0x0000c000:
		switch(opcode & 0x0000fe00){
		case 0x0000d000:
		    printf("tb0\t");
		    print_b5(B5(opcode));
	    	    printf(",r%u,%u\n", S1(opcode), VEC9(opcode) );
		    break;
		case 0x0000d800:
		    printf("tb1\t");
		    print_b5(B5(opcode));
	    	    printf(",r%u,%u\n", S1(opcode), VEC9(opcode) );
		    break;
		case 0x0000e800:
		    printf("tcnd\t");
		    print_m5(M5(opcode));
	    	    printf(",r%u,%u\n", S1(opcode), VEC9(opcode) );
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    }
	    break;

	case 0xf4000000:
	    switch(opcode & 0x0000e000){
	    /* xmem, ld.u, ld R = 1 GRF dest */
	    case 0x00000000:
		if((opcode & 0x00001000) == 0)
		    if((opcode & 0x00000800) == 0)
			/* xmem */
			if((opcode & 0x00000200) == 0)
			    printf("xmem%s%s\tr%u,r%u,r%u\n", w[W(opcode)],
				   usr[USR(opcode)], D(opcode), S1(opcode),
				   S2(opcode) );
			else
			    printf("xmem%s%s\tr%u,r%u[r%u]\n", w[W(opcode)],
				   usr[USR(opcode)], D(opcode), S1(opcode),
				   S2(opcode) );
		    else
			/* ld.u */
			if((opcode & 0x00000200) == 0)
			    printf("ld%s%s\tr%u,r%u,r%u\n", b[B(opcode)],
				   usr[USR(opcode)], D(opcode), S1(opcode),
				   S2(opcode) );
			else
			    printf("ld%s%s\tr%u,r%u[r%u]\n", b[B(opcode)],
				   usr[USR(opcode)], D(opcode), S1(opcode),
				   S2(opcode) );
		else
		    /* ld R = 1, GRF dest */
		    if((opcode & 0x00000200) == 0)
			printf("ld%s%s\tr%u,r%u,r%u\n", tyr1[TY(opcode)],
			       usr[USR(opcode)], D(opcode), S1(opcode),
			       S2(opcode) );
		    else
			printf("ld%s%s\tr%u,r%u[r%u]\n", tyr1[TY(opcode)],
			       usr[USR(opcode)], D(opcode), S1(opcode),
			       S2(opcode) );
		break;
	    /* st R = 0 GRF dest, lda[] F = 1, 8x, 4x, 2x, 16x scale factors */
	    case 0x00002000:
		if((opcode & 0x00001000) == 0)
		    /* st R = 0, GRF dest */
		    if((opcode & 0x00000200) == 0)
			printf("st%s%s%s\tr%u,r%u,r%u\n", tyr1[TY(opcode)],
			       usr[USR(opcode)], thru[THRU(opcode)], D(opcode),
			       S1(opcode), S2(opcode) );
		    else
			printf("st%s%s%s\tr%u,r%u[r%u]\n", tyr1[TY(opcode)],
			       usr[USR(opcode)], thru[THRU(opcode)], D(opcode),
			       S1(opcode), S2(opcode) );
		else
		    /* lda[] F = 1, 8x, 4x, 2x, 16x scale factors */
		    printf("lda%s\tr%u,r%u[r%u]\n", tyf1[TY(opcode)],
			   D(opcode), S1(opcode), S2(opcode) );
		break;
	    /* and, or, xor */
	    case 0x00004000:
		switch(opcode & 0x00001800){
		case 0x00000000:
		    if((opcode & 0x00000400) == 0)
			printf("and\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    else
			printf("and.c\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    break;
		case 0x00000800:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		case 0x00001000:
		    if((opcode & 0x00000400) == 0)
			printf("xor\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    else
			printf("xor.c\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    break;
		case 0x00001800:
		    if((opcode & 0x00000400) == 0)
			printf("or\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    else
			printf("or.c\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    break;
		}
		break;
	    /* andu, subu, divu, mulu, muls, add, sub, divs, cmp */
	    case 0x00006000:
		switch(opcode & 0x00001c00){
		case 0x00000000:
		    printf("addu%s\tr%u,r%u,r%u\n", io[IO(opcode)], D(opcode),
			   S1(opcode), S2(opcode) );
		    break;
		case 0x00000400:
		    printf("subu%s\tr%u,r%u,r%u\n", io[IO(opcode)], D(opcode),
			   S1(opcode), S2(opcode) );
		    break;
		case 0x00000800:
		    if((opcode & 0x00000100) == 0)
			printf("divu\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    else
			printf("divu.d\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    break;
		case 0x00000c00:
		    if((opcode & 0x00000200) == 0)
			if((opcode & 0x00000100) == 0)
			    printf("mulu\tr%u,r%u,r%u\n", D(opcode),
				   S1(opcode), S2(opcode) );
			else
			    printf("mulu.d\tr%u,r%u,r%u\n", D(opcode),
				   S1(opcode), S2(opcode) );
		    else
			printf("muls\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			       S2(opcode) );
		    break;
		case 0x00001000:
		    printf("add%s\tr%u,r%u,r%u\n", io[IO(opcode)], D(opcode),
			   S1(opcode), S2(opcode) );
		    break;
		case 0x00001400:
		    printf("sub%s\tr%u,r%u,r%u\n", io[IO(opcode)], D(opcode),
			   S1(opcode), S2(opcode) );
		    break;
		case 0x00001800:
		    printf("divs\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		case 0x00001c00:
		    printf("cmp\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		}
		break;
	    /* clr, set, ext, extu, mak, rot */
	    case 0x00008000:
	    case 0x0000a000:
		switch(opcode & 0x0000ffe0){
		case 0x00008000:
		    printf("clr\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		case 0x00008800:
		    printf("set\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		case 0x00009000:
		    printf("ext\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		case 0x00009800:
		    printf("extu\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		case 0x0000a000:
		    printf("mak\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		case 0x0000a800:
		    printf("rot\tr%u,r%u,r%u\n", D(opcode), S1(opcode),
			   S2(opcode) );
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    /* jmp, jsr */
	    case 0x0000c000:
		switch(opcode & 0x03ffffe0){
		case 0x0000c000:
		    printf("jmp\tr%u\n", S2(opcode) );
		    break;
		case 0x0000c400:
		    printf("jmp.n\tr%u\n", S2(opcode) );
		    break;
		case 0x0000c800:
		    printf("jsr\tr%u\n", S2(opcode) );
		    break;
		case 0x0000cc00:
		    printf("jsr.n\tr%u\n", S2(opcode) );
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    /* ff1, ff0, tbnd, rte */
	    case 0x0000e000:
		switch(opcode & 0x0000ffe0){
		case 0x0000e800:
		    printf("ff1\tr%u,r%u\n", D(opcode), S2(opcode) );
		    break;
		case 0x0000ec00:
		    printf("ff0\tr%u,r%u\n", D(opcode), S2(opcode) );
		    break;
		case 0x0000f800:
		    printf("tbnd\tr%u,r%u\n", S1(opcode), S2(opcode) );
		    break;
		case 0x0000fc00:
		    if((opcode & 0x3) == 0)
			printf("rte\n");
		    else
			printf("illop%u\n", opcode & 0x3);
		    break;
		default:
		    printf("0x%08x\n", (unsigned int)opcode);
		    break;
		}
		break;
	    }
	    break;

	case 0xf8000000:
	    printf("tbnd\tr%u,%u\n", S1(opcode), 0xffff & opcode);
	    break;

	default:
	    printf(".long 0x%08x\n", (unsigned int)opcode);
	    break;
	}
	return(4);
}

static
void
print_b5(
uint32_t value)
{
	if(value < 2 || value > 15)
	     printf("%u", value);
	else
	     printf("%s", b5[value]);
}

static
void
print_m5(
uint32_t value)
{
	switch(value){
	case 0x01:
	    printf("gt0");
	    break;
	case 0x02:
	    printf("eq0");
	    break;
	case 0x03:
	    printf("ge0");
	    break;
	case 0x0c:
	    printf("lt0");
	    break;
	case 0x0d:
	    printf("ne0");
	    break;
	case 0x0e:
	    printf("le0");
	    break;
	default:
	    printf("%u", value);
	}
}

static
void
print_immediate(
uint32_t value, 
uint32_t sect_offset,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    int32_t low, high, mid, reloc_found, offset;
    uint32_t i, r_address, r_symbolnum, r_type, r_extern,
	     r_value, r_scattered, pair_r_type;
    unsigned short other_half;
    char *name;
    struct relocation_info *rp, *pairp;
    struct scattered_relocation_info *srp, *spairp;

	r_symbolnum = 0;
	r_type = 0;
	r_extern = 0;
	r_value = 0;
	r_scattered = 0;
	other_half = 0;

	if(verbose == FALSE){
	    printf("0x%x\n", (unsigned int)value);
	    return;
	}
	reloc_found = 0;
	if(nrelocs != 0){
	    for(i = 0; i < nrelocs; i++){
		rp = &relocs[i];
		if(rp->r_address & R_SCATTERED){
		    srp = (struct scattered_relocation_info *)rp;
		    r_scattered = 1;
		    r_address = srp->r_address;
		    r_extern = 0;
		    r_type = srp->r_type;
		    r_value = srp->r_value;
		}
		else{
		    r_scattered = 0;
		    r_address = rp->r_address;
		    r_symbolnum = rp->r_symbolnum;
		    r_extern = rp->r_extern;
		    r_type = rp->r_type;
		}
		if(r_type == M88K_RELOC_PAIR){
		    fprintf(stderr, "Stray M88K_RELOC_PAIR relocation entry "
			    "%u\n", i);
		    continue;
		}
		if(r_address == sect_offset){
		    if(r_type == M88K_RELOC_HI16 || r_type == M88K_RELOC_LO16){
			if(i+1 < nrelocs){
			    pairp = &rp[1];
			    if(pairp->r_address & R_SCATTERED){
				spairp = (struct scattered_relocation_info *)
					 pairp;
				other_half = spairp->r_address & 0xfff;
				pair_r_type = spairp->r_type;
			    }
			    else{
				other_half = pairp->r_address & 0xffff;
				pair_r_type = pairp->r_type;
			    }
			    if(pair_r_type != M88K_RELOC_PAIR){
				fprintf(stderr, "No M88K_RELOC_PAIR relocation "
					"entry after entry %u\n", i);
				continue;
			    }
			}
		    }
		    reloc_found = 1;
		    break;
		}
		if(r_type == M88K_RELOC_HI16 || r_type == M88K_RELOC_LO16){
		    if(i+1 < nrelocs){
			pairp = &rp[1];
			if(pairp->r_address & R_SCATTERED){
			    spairp = (struct scattered_relocation_info *)pairp;
			    pair_r_type = spairp->r_type;
			}
			else{
			    pair_r_type = pairp->r_type;
			}
			if(pair_r_type == M88K_RELOC_PAIR)
			    i++;
			else
			    fprintf(stderr, "No M88K_RELOC_PAIR relocation "
				    "entry after entry %u\n", i);
		    }
		}
	    }
	}

	if(reloc_found && r_extern == 1){
	    if((uint32_t)symbols[r_symbolnum].n_un.n_strx >= strings_size)
		name = "bad string offset";
	    else
		name = strings + symbols[r_symbolnum].n_un.n_strx;
	    if(value != 0){
		switch(r_type){
		case M88K_RELOC_HI16:
		    value = value << 16 | other_half;
		    printf("hi16(%s+0x%x)\n", name, (unsigned int)value);
		    break;
		case M88K_RELOC_LO16:
		    value = other_half << 16 | value;
		    printf("lo16(%s+0x%x)\n", name, (unsigned int)value);
		    break;
		default:
		    printf("%s+0x%x\n", name, (unsigned int)value);
		}
	    }
	    else{
		switch(r_type){
		case M88K_RELOC_HI16:
		    value = value << 16 | other_half;
		    if(value == 0)
			printf("hi16(%s)\n", name);
		    else
			printf("hi16(%s+0x%x)\n", name, (unsigned int)value);
		    break;
		case M88K_RELOC_LO16:
		    value = other_half << 16 | value;
		    if(value == 0)
			printf("lo16(%s)\n", name);
		    else
			printf("lo16(%s+0x%x)\n", name, (unsigned int)value);
		    break;
		default:
		    if(value == 0)
			printf("%s\n", name);
		    else
			printf("%s+0x%x\n", name, (unsigned int)value);
		}
	    }
	    return;
	}

	offset = 0;
	if(reloc_found){
	    if(r_type == M88K_RELOC_HI16)
		value = value << 16 | other_half;
	    else if(r_type == M88K_RELOC_LO16)
		value = other_half << 16 | value;
	    if(r_scattered){
		offset = value - r_value;
		value = r_value;
	    }
	}

	low = 0;
	high = nsorted_symbols - 1;
	mid = (high - low) / 2;
	while(high >= low){
	    if(sorted_symbols[mid].n_value == value){
		if(reloc_found){
		    switch(r_type){
		    case M88K_RELOC_HI16:
			if(offset == 0)
			    printf("hi16(%s)\n",
				   sorted_symbols[mid].name);
			else
			    printf("hi16(%s+0x%x)\n",
				    sorted_symbols[mid].name,
				    (unsigned int)offset);
			break;
		    case M88K_RELOC_LO16:
			if(offset == 0)
			    printf("lo16(%s)\n",
				   sorted_symbols[mid].name);
			else
			    printf("lo16(%s+0x%x)\n",
				   sorted_symbols[mid].name,
				   (unsigned int)offset);
			break;
		    default:
			if(offset == 0)
			    printf("%s\n",sorted_symbols[mid].name);
			else
			    printf("%s+0x%x\n",
				   sorted_symbols[mid].name,
				   (unsigned int)offset);
			break;
		    }
		}
		else{
		    if(offset == 0)
			printf("%s\n",sorted_symbols[mid].name);
		    else
			printf("%s+0x%x\n",
			       sorted_symbols[mid].name,
			       (unsigned int)offset);
		}
		return;
	    }
	    if(sorted_symbols[mid].n_value > value){
		high = mid - 1;
		mid = (high + low) / 2;
	    }
	    else{
		low = mid + 1;
		mid = (high + low) / 2;
	    }
	}
	if(offset == 0){
	    if(reloc_found){
		if(r_type == M88K_RELOC_HI16)
		    printf("hi16(0x%x)\n", (unsigned int)value);
		else if(r_type == M88K_RELOC_LO16)
		    printf("lo16(0x%x)\n", (unsigned int)value);
	    }
	    else
		printf("0x%04x\n", (unsigned int)value);
	}
	else{
	    if(reloc_found){
		if(r_type == M88K_RELOC_HI16)
		    printf("hi16(0x%x+0x%x)\n",
			    (unsigned int)value, (unsigned int)offset);
		else if(r_type == M88K_RELOC_LO16)
		    printf("lo16(0x%x+0x%x)\n",
			    (unsigned int)value, (unsigned int)offset);
	    }
	    else
		printf("0x%x+0x%x\n",
			(unsigned int)value, (unsigned int)offset);
	}
	return;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/m88k_disasm.h                         0100644 0001750 0001750 00000004131 12612724206 024073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <stuff/bytesex.h>
#import <mach-o/reloc.h>
#import <mach-o/nlist.h>
#import <stuff/bool.h>
#include "stuff/symbol.h"

extern uint32_t m88k_disassemble(
    char *sect,
    uint32_t left,
    uint32_t addr,
    uint32_t sect_addr,
    enum byte_sex object_byte_sex,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);
                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/main.c                                0100644 0001750 0001750 00000350765 12612724206 022704  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <ar.h>
#include <mach-o/ranlib.h>
#include <libc.h>
#include "stuff/bool.h"
#include "stuff/ofile.h"
#include "stuff/errors.h"
#include "stuff/allocate.h"
#include "stuff/symbol.h"
#include "stuff/symbol.h"
#include "stuff/llvm.h"
#include "stuff/guess_short_name.h"
#include "otool.h"
#include "dyld_bind_info.h"
#include "ofile_print.h"
#include "m68k_disasm.h"
#include "i860_disasm.h"
#include "i386_disasm.h"
#include "m88k_disasm.h"
#include "ppc_disasm.h"
#include "hppa_disasm.h"
#include "sparc_disasm.h"
#include "arm_disasm.h"
#include "arm64_disasm.h"
#include "llvm-c/Disassembler.h"

/* Name of this program for error messages (argv[0]) */
char *progname = NULL;

/*
 * The flags to indicate the actions to perform.
 */
enum bool fflag = FALSE; /* print the fat headers */
enum bool aflag = FALSE; /* print the archive header */
enum bool hflag = FALSE; /* print the exec or mach header */
enum bool lflag = FALSE; /* print the load commands */
enum bool Lflag = FALSE; /* print the shared library names */
enum bool Dflag = FALSE; /* print the shared library id name */
enum bool tflag = FALSE; /* print the text */
enum bool Uflag = FALSE; /* print the text symbol by symbol,
			    for llvm-objdump testing must be used with -t */
enum bool no_show_raw_insn = FALSE; /* no raw inst, for llvm-objdump testing
				       with 32-bit arm */
enum bool dflag = FALSE; /* print the data */
enum bool oflag = FALSE; /* print the objctive-C info */
enum bool Oflag = FALSE; /* print the objctive-C selector strings only */
enum bool rflag = FALSE; /* print the relocation entries */
enum bool Tflag = FALSE; /* print the dylib table of contents */
enum bool Mflag = FALSE; /* print the dylib module table */
enum bool Rflag = FALSE; /* print the dylib reference table */
enum bool Iflag = FALSE; /* print the indirect symbol table entries */
enum bool Hflag = FALSE; /* print the two-level hints table */
enum bool Cflag = FALSE; /* print the linker optimization hints */
enum bool Gflag = FALSE; /* print the data in code table */
enum bool gflag = FALSE; /* group the disassembly */
enum bool eflag = FALSE; /* print enhanced disassembly */
enum bool Sflag = FALSE; /* print the contents of the __.SYMDEF file */
enum bool vflag = FALSE; /* print verbosely (symbolically) when possible */
enum bool Vflag = FALSE; /* print dissassembled operands verbosely */
enum bool cflag = FALSE; /* print the argument and environ strings of a core */
enum bool iflag = FALSE; /* print the shared library initialization table */
enum bool Wflag = FALSE; /* print the mod time of an archive as a number */
enum bool Xflag = FALSE; /* don't print leading address in disassembly */
enum bool Zflag = FALSE; /* don't use simplified ppc mnemonics in disassembly */
enum bool Bflag = FALSE; /* force Thumb disassembly (ARM objects only) */
enum bool Qflag = FALSE; /* use otool's disassembler */
enum bool qflag = FALSE; /* use 'C' Public llvm-mc disassembler */
enum bool jflag = FALSE; /* print opcode bytes */
enum bool Pflag = FALSE; /* print (__TEXT,__info_plist) section as strings */
char *pflag = NULL; 	 /* procedure name to start disassembling from */
char *segname = NULL;	 /* name of the section to print the contents of */
char *sectname = NULL;
enum bool llvm_mc = FALSE; /* disassemble as llvm-mc will assemble */
char *mcpu = "";	/* the arg of the -mcpu=arg flag */
/* Print function offsets when disassembling when TRUE. */
enum bool function_offsets = FALSE;
enum bool print_bind_info = FALSE;  /* print dyld bind information */

/* this is set when any of the flags that process object files is set */
enum bool object_processing = FALSE;

static void usage(
    void);

static void processor(
    struct ofile *ofile,
    char *arch_name,
    void *cookie);

static void get_symbol_table_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_type_t cputype,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist **symbols,
    struct nlist_64 **symbols64,
    uint32_t *nsymbols,
    char **strings,
    uint32_t *strings_size);

static void get_toc_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct dylib_table_of_contents **tocs,
    uint32_t *ntocs);

static void get_module_table_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_type_t cputype,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct dylib_module **mods,
    struct dylib_module_64 **mods64,
    uint32_t *nmods);

static void get_ref_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct dylib_reference **refs,
    uint32_t *nrefs);

static void get_indirect_symbol_table_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    uint32_t **indirect_symbols,
    uint32_t *nindirect_symbols);

static enum bool get_dyst(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    struct dysymtab_command *dyst);

static void get_hints_table_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct twolevel_hint **hints,
    uint32_t *nhints);

static enum bool get_hints_cmd(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    struct twolevel_hints_command *hints_cmd);

static void get_link_opt_hints(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    char **loh,
    uint32_t *nloh);

static enum bool get_link_opt_hint_cmd(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    struct linkedit_data_command *loh_cmd);

static void get_data_in_code_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct data_in_code_entry **dices,
    uint32_t *ndices);

static enum bool get_dices_cmd(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    struct linkedit_data_command *dices_cmd);

static int sym_compare(
    struct symbol *sym1,
    struct symbol *sym2);

static int rel_compare(
    struct relocation_info *rel1,
    struct relocation_info *rel2);

static void get_linked_reloc_info(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct relocation_info **ext_relocs,
    uint32_t *next_relocs,
    struct relocation_info **loc_relocs,
    uint32_t *nloc_relocs);

static void setup_dyld_bind_info(
    struct load_command *load_commands, 	/* input */
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct dyld_bind_info **dbi, /* output */
    uint64_t *ndbi);

static void print_text_by_symbols(
    cpu_type_t cputype,
    enum byte_sex object_byte_sex,
    char *sect,
    uint32_t size,
    uint64_t addr,
    uint32_t sect_flags,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    struct relocation_info *ext_relocs,
    uint32_t next_relocs,
    struct relocation_info *loc_relocs,
    uint32_t nloc_relocs,
    struct dyld_bind_info *dbi,
    uint64_t ndbi,
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum bool disassemble,
    enum bool verbose,
    cpu_subtype_t cpusubtype,
    char *object_addr,
    uint32_t object_size,
    struct data_in_code_entry *dices,
    uint32_t ndices,
    uint64_t seg_addr);

static void print_text(
    cpu_type_t cputype,
    enum byte_sex object_byte_sex,
    char *sect,
    uint32_t size,
    uint64_t addr,
    uint32_t sect_flags,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    struct relocation_info *ext_relocs,
    uint32_t next_relocs,
    struct relocation_info *loc_relocs,
    uint32_t nloc_relocs,
    struct dyld_bind_info *dbi,
    uint64_t ndbi,
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum bool disassemble,
    enum bool verbose,
    cpu_subtype_t cpusubtype,
    char *object_addr,
    uint32_t object_size,
    struct data_in_code_entry *dices,
    uint32_t ndices,
    uint64_t seg_addr);

static void print_argstrings(
    uint32_t magic,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_type_t cputype,
    cpu_subtype_t cpusubtype,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size);

/* apple_version is created by the libstuff/Makefile */
extern char apple_version[];
char *version = apple_version;
#if defined(__CYGWIN__) && defined(__clang__) /* cctools-port */
int otool_cygwin;
#endif

int
main(
int argc,
char **argv,
char **envp)
{
    int i;
    uint32_t j, nfiles;
    struct arch_flag *arch_flags;
    uint32_t narch_flags;
    enum bool all_archs, use_member_syntax, version;
    char **files;
    const char *disssembler_version;

	progname = argv[0];
	arch_flags = NULL;
	narch_flags = 0;
	all_archs = TRUE; /* cctools-port: FALSE -> TRUE */
	use_member_syntax = TRUE;
	llvm_mc = FALSE;
	version = FALSE;

	if(argc <= 1)
	    usage();

	/*
	 * Parse the arguments.
	 */
	nfiles = 0;
        files = allocate(sizeof(char *) * argc);
	for(i = 1; i < argc; i++){
	    if(argv[i][0] == '-' && argv[i][1] == '\0'){
		for(i += 1 ; i < argc; i++)
		    files[nfiles++] = argv[i];
		break;
	    }
	    if(argv[i][0] != '-'){
		files[nfiles++] = argv[i];
		continue;
	    }
	    if(strcmp(argv[i], "--version") == 0){
		fprintf(stderr, "otool(1): Apple Inc. version %s\n",
			apple_version);
		disssembler_version = llvm_disasm_version_string();
		if(disssembler_version != NULL)
		    fprintf(stderr, "disassmbler: %s\n", disssembler_version);
		version = TRUE;
		continue;
	    }
	    if(strcmp(argv[i], "-arch") == 0){
		if(i + 1 == argc){
		    error("missing argument(s) to %s option", argv[i]);
		    usage();
		}
		if(strcmp("all", argv[i+1]) == 0){
		    all_archs = TRUE;
		}
		else{
		    all_archs = FALSE;
		    arch_flags = reallocate(arch_flags,
			    (narch_flags + 1) * sizeof(struct arch_flag));
		    if(get_arch_from_flag(argv[i+1],
					  arch_flags + narch_flags) == 0){
			error("unknown architecture specification flag: "
			      "%s %s", argv[i], argv[i+1]);
			arch_usage();
			usage();
		    }
		    narch_flags++;
		}
		i++;
		continue;
	    }
	    if(strcmp(argv[i], "-llvm-mc") == 0){
		llvm_mc = TRUE;
		continue;
	    }
	    if(strcmp(argv[i], "-function_offsets") == 0){
		function_offsets = TRUE;
		continue;
	    }
	    if(strcmp(argv[i], "-bind_info") == 0){
		print_bind_info = TRUE;
		object_processing = TRUE;
		continue;
	    }
	    if(strncmp(argv[i], "-mcpu=", sizeof("-mcpu=")-1) == 0){
		mcpu = argv[i] + sizeof("-mcpu=")-1;
		if(*mcpu == '\0'){
		    error("missing argument to -mcpu=");
		    usage();
		}
		continue;
	    }
	    if(strcmp(argv[i], "-no-show-raw-insn") == 0){
		no_show_raw_insn = TRUE;
		continue;
	    }
	    if(argv[i][1] == 'p'){
		if(argc <=  i + 1){
		    error("-p requires an argument (a text symbol name)");
		    usage();
		}
		if(pflag)
		    error("only one -p flag can be specified");
		pflag = argv[i + 1];
		i++;
		continue;
	    }
	    if(argv[i][1] == 's'){
		if(argc <=  i + 2){
		    error("-s requires two arguments (a segment name and a "
			  "section name)");
		    usage();
		}
		if(sectname != NULL){
		    error("only one -s flag can be specified");
		    usage();
		}
		segname  = argv[i + 1];
		sectname = argv[i + 2];
		i += 2;
		object_processing = TRUE;
		continue;
	    }
	    for(j = 1; argv[i][j] != '\0'; j++){
		switch(argv[i][j]){
		case 'V':
		    Vflag = TRUE;
		case 'v':
		    vflag = TRUE;
		    break;
		case 'f':
		    fflag = TRUE;
		    break;
		case 'a':
		    aflag = TRUE;
		    break;
		case 'g':
		    gflag = TRUE;
		    break;
		case 'e':
		    eflag = TRUE;
		    break;
		case 'h':
		    hflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'l':
		    lflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'L':
		    Lflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'D':
		    Dflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 't':
		    tflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'U':
		    Uflag = TRUE;
		    break;
		case 'd':
		    dflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'o':
		    oflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'O':
		    Oflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'r':
		    rflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'T':
		    Tflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'M':
		    Mflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'R':
		    Rflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'I':
		    Iflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'H':
		    Hflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'C':
		    Cflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'G':
		    Gflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'S':
		    Sflag = TRUE;
		    break;
		case 'c':
		    cflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'i':
		    iflag = TRUE;
		    object_processing = TRUE;
		    break;
		case 'W':
		    Wflag = TRUE;
		    break;
		case 'X':
		    Xflag = TRUE;
		    break;
		case 'Z':
		    Zflag = TRUE;
		    break;
		case 'm':
		    use_member_syntax = FALSE;
		    break;
		case 'B':
		    Bflag = TRUE;
		    break;
		case 'Q':
		    Qflag = TRUE;
		    break;
		case 'q':
		    qflag = TRUE;
		    break;
		case 'j':
		    jflag = TRUE;
		    break;
		case 'P':
		    Pflag = TRUE;
		    object_processing = TRUE;
		    break;
		default:
		    error("unknown char `%c' in flag %s\n", argv[i][j],argv[i]);
		    usage();
		}
	    }
	}

	/*
	 * Check for correctness of arguments.
	 */
	if(!fflag && !aflag && !hflag && !lflag && !Lflag && !tflag && !dflag &&
	   !oflag && !Oflag && !rflag && !Tflag && !Mflag && !Rflag && !Iflag &&
	   !Cflag && !print_bind_info && !version && !Pflag &&
	   !Hflag && !Gflag && !Sflag && !cflag && !iflag && !Dflag &&!segname){
	    error("one of -fahlLtdoOrTMRIHCGScisP or --version must be "
		  "specified");
	    usage();
	}
	if(qflag && Qflag){
	    error("can't specify both -q and -Q");
	    usage();
	}
	/*
	 * The default, without the -Q flag, is to use the llvm dissembler
	 * instead of otool's internal disassemblers.
	 */
	if(!Qflag)
	    qflag = TRUE;
	if(nfiles == 0 && version == FALSE){
	    error("at least one file must be specified");
	    usage();
	}
	if(segname != NULL && sectname != NULL){
	    /* treat "-s __TEXT __text" the same as -t */
	    if(strcmp(segname, SEG_TEXT) == 0 &&
	       strcmp(sectname, SECT_TEXT) == 0){
		tflag = TRUE;
		segname = NULL;
		sectname = NULL;
	    }
	    /* treat "-s __TEXT __fvmlib0" the same as -i */
	    else if(strcmp(segname, SEG_TEXT) == 0 &&
	       strcmp(sectname, SECT_FVMLIB_INIT0) == 0){
		iflag = TRUE;
		segname = NULL;
		sectname = NULL;
	    }
	    /* treat "-v -s __TEXT __info_plist" the same as -P */
	    else if(vflag == TRUE && strcmp(segname, SEG_TEXT) == 0 &&
	       strcmp(sectname, "__info_plist") == 0){
		Pflag = TRUE;
		segname = NULL;
		sectname = NULL;
	    }
	}

	for(j = 0; j < nfiles; j++){
	    ofile_process(files[j], arch_flags, narch_flags, all_archs, TRUE,
			  TRUE, use_member_syntax, processor, NULL);
	}

	if(errors)
	    return(EXIT_FAILURE);
	else
	    return(EXIT_SUCCESS);
}

/*
 * Print the current usage message.
 */
static
void
usage(
void)
{
	fprintf(stderr,
		"Usage: %s [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] "
		"[-mcpu=arg] [--version] <object file> ...\n", progname);

	fprintf(stderr, "\t-f print the fat headers\n");
	fprintf(stderr, "\t-a print the archive header\n");
	fprintf(stderr, "\t-h print the mach header\n");
	fprintf(stderr, "\t-l print the load commands\n");
	fprintf(stderr, "\t-L print shared libraries used\n");
	fprintf(stderr, "\t-D print shared library id name\n");
	fprintf(stderr, "\t-t print the text section (disassemble with -v)\n");
	fprintf(stderr, "\t-p <routine name>  start dissassemble from routine "
		"name\n");
	fprintf(stderr, "\t-s <segname> <sectname> print contents of "
		"section\n");
	fprintf(stderr, "\t-d print the data section\n");
	fprintf(stderr, "\t-o print the Objective-C segment\n");
	fprintf(stderr, "\t-r print the relocation entries\n");
	fprintf(stderr, "\t-S print the table of contents of a library\n");
	fprintf(stderr, "\t-T print the table of contents of a dynamic "
		"shared library\n");
	fprintf(stderr, "\t-M print the module table of a dynamic shared "
		"library\n");
	fprintf(stderr, "\t-R print the reference table of a dynamic shared "
		"library\n");
	fprintf(stderr, "\t-I print the indirect symbol table\n");
	fprintf(stderr, "\t-H print the two-level hints table\n");
	fprintf(stderr, "\t-G print the data in code table\n");
	fprintf(stderr, "\t-v print verbosely (symbolically) when possible\n");
	fprintf(stderr, "\t-V print disassembled operands symbolically\n");
	fprintf(stderr, "\t-c print argument strings of a core file\n");
	fprintf(stderr, "\t-X print no leading addresses or headers\n");
	fprintf(stderr, "\t-m don't use archive(member) syntax\n");
	fprintf(stderr, "\t-B force Thumb disassembly (ARM objects only)\n");
	fprintf(stderr, "\t-q use llvm's disassembler (the default)\n");
	fprintf(stderr, "\t-Q use otool(1)'s disassembler\n");
	fprintf(stderr, "\t-mcpu=arg use `arg' as the cpu for disassembly\n");
	fprintf(stderr, "\t-j print opcode bytes\n");
	fprintf(stderr, "\t-P print the info plist section as strings\n");
	fprintf(stderr, "\t-C print linker optimization hints\n");
	fprintf(stderr, "\t--version print the version of %s\n", progname);
	exit(EXIT_FAILURE);
}

static
void
processor(
struct ofile *ofile,
char *arch_name,
void *cookie) /* cookie is not used */
{
    char *addr;
    uint32_t i, magic;
    uint64_t size;
    struct mach_header mh;
    struct mach_header_64 mh64;
    cpu_type_t mh_cputype;
    cpu_subtype_t mh_cpusubtype;
    uint32_t mh_magic, mh_filetype, mh_ncmds, mh_sizeofcmds, sizeof_mach_header;
    struct load_command *load_commands;
    uint32_t nsymbols, nsorted_symbols, strings_size, len;
    struct nlist *symbols, *allocated_symbols;
    struct nlist_64 *symbols64, *allocated_symbols64;
    struct symbol *sorted_symbols;
    char *strings, *p;
    uint32_t n_strx;
    uint8_t n_type;
    uint16_t n_desc;
    uint64_t n_value;
    char *sect;
    uint32_t sect_nrelocs, sect_flags, nrelocs, next_relocs, nloc_relocs;
    uint64_t sect_addr, sect_size;
    struct relocation_info *sect_relocs, *relocs, *ext_relocs, *loc_relocs;
    uint32_t *indirect_symbols, *allocated_indirect_symbols;
    uint32_t nindirect_symbols;
    struct dylib_module *mods, *allocated_mods;
    struct dylib_module_64 *mods64, *allocated_mods64;
    struct dylib_table_of_contents *tocs, *allocated_tocs;
    struct dylib_reference *refs, *allocated_refs;
    uint32_t nmods, ntocs, nrefs;
    struct twolevel_hint *hints, *allocated_hints;
    struct data_in_code_entry *dices, *allocated_dices;
    uint32_t nhints, ndices;
    uint64_t seg_addr;
    char *loh;
    uint32_t nloh;
    struct dyld_bind_info *dbi;
    uint64_t ndbi;

	sorted_symbols = NULL;
	nsorted_symbols = 0;
	indirect_symbols = NULL;
	nindirect_symbols = 0;
	hints = NULL;
	nhints = 0;
	dices = NULL;
	ndices = 0;
	symbols = NULL;
	symbols64 = NULL;
	nsymbols = 0;
	strings = NULL;
	nmods = 0;
	mods64 = NULL;
	mods = NULL;
	/*
	 * These may or may not be allocated.  If allocated they will not be
	 * NULL and then free'ed before returning.
	 */
	load_commands = NULL;
	allocated_symbols = NULL;
	allocated_symbols64 = NULL;
	sorted_symbols = NULL;
	allocated_indirect_symbols = NULL;
	allocated_tocs = NULL;
	allocated_mods = NULL;
	allocated_refs = NULL;
	allocated_hints = NULL;
	allocated_dices = NULL;
	dbi = NULL;
	ndbi = 0;

	/*
	 * The fat headers are printed in ofile_map() in ofile.c #ifdef'ed
	 * OTOOL.
	 */

	/*
	 * Archive headers.
	 */
	if(aflag && ofile->member_ar_hdr != NULL){
	    uint32_t member_offset;

	    member_offset = ofile->member_offset - sizeof(struct ar_hdr);
	    if(strncmp(ofile->member_ar_hdr->ar_name, AR_EFMT1,
		       sizeof(AR_EFMT1) - 1) == 0)
		member_offset -= ofile->member_name_size;

	    print_ar_hdr(ofile->member_ar_hdr, ofile->member_name,
			 ofile->member_name_size, member_offset, vflag, Vflag);
	}

	/*
	 * Archive table of contents.
	 */
	if(ofile->member_ar_hdr != NULL &&
	   strncmp(ofile->member_name, SYMDEF, sizeof(SYMDEF)-1) == 0){
	    if(Sflag == FALSE)
		return;
	    if(ofile->file_type == OFILE_FAT){
		addr = ofile->file_addr + ofile->fat_archs[ofile->narch].offset;
		size = ofile->fat_archs[ofile->narch].size;
	    }
	    else{
		addr = ofile->file_addr;
		size = ofile->file_size;
	    }
	    if(addr + size > ofile->file_addr + ofile->file_size)
		size = (ofile->file_addr + ofile->file_size) - addr;
	    print_library_toc(ofile->member_ar_hdr, /* toc_ar_hdr */
			      ofile->member_name, /* toc_name */
			      ofile->member_name_size, /* toc_name_size */
			      ofile->member_addr, /* toc_addr */
			      ofile->member_size, /* toc_size */
			      get_toc_byte_sex(addr, size),
			      ofile->file_name, /* library_name */
			      addr, /* library_addr */
			      size, /* library_size */
			      arch_name,
			      vflag);
	    return;
	}

	if(object_processing == FALSE)
	    return;

	/*
	 * Print header for the object name if in an archive or an architecture
	 * name is passed in.
	 */
	if(Xflag == FALSE){
	    printf("%s", ofile->file_name);
	    if(ofile->member_ar_hdr != NULL){
		printf("(%.*s)", (int)ofile->member_name_size,
			ofile->member_name);
	    }
	    if(arch_name != NULL)
		printf(" (architecture %s):", arch_name);
	    else
		printf(":");
	    /*
	     * If the mach_header pointer is NULL the file is not an object
	     * file.  Truncated object file (where the file size is less
	     * than sizeof(struct mach_header) also does not have it's
	     * mach_header set.  So deal with both cases here and then
	     * return as the rest of this routine deals only with things
	     * in object files.
	     */
	    if(ofile->mh == NULL && ofile->mh64 == NULL){
		if(ofile->file_type == OFILE_FAT){
		    /*
		     * This routine is not called on fat files where the
		     * offset is past end of file.  An error message is
		     * printed in ofile_specific_arch() in ofile.c.
		     */
		    if(ofile->arch_type == OFILE_ARCHIVE){
			addr = ofile->member_addr;
			size = ofile->member_size;
		    }
		    else{
			addr = ofile->file_addr +
			       ofile->fat_archs[ofile->narch].offset;
			size = ofile->fat_archs[ofile->narch].size;
		    }
		    if(addr + size > ofile->file_addr + ofile->file_size)
			size = (ofile->file_addr + ofile->file_size) - addr;
		}
		else if(ofile->file_type == OFILE_ARCHIVE){
		    addr = ofile->member_addr;
		    size = ofile->member_size;
		}
		else{ /* ofile->file_type == OFILE_UNKNOWN */
		    addr = ofile->file_addr;
		    size = ofile->file_size;
		}
		if(size > sizeof(int32_t)){
		    memcpy(&magic, addr, sizeof(uint32_t));
		    if(magic == MH_MAGIC ||
		       magic == SWAP_INT(MH_MAGIC)){
			printf(" is a truncated object file\n");
			memset(&mh, '\0', sizeof(struct mach_header));
			if(size > sizeof(struct mach_header))
			    size = sizeof(struct mach_header);
			memcpy(&mh, addr, size);
			if(magic == SWAP_INT(MH_MAGIC))
			    swap_mach_header(&mh, get_host_byte_sex());
			if(hflag)
			    print_mach_header(mh.magic, mh.cputype,
				mh.cpusubtype, mh.filetype, mh.ncmds,
				mh.sizeofcmds, mh.flags, vflag);
			return;
		    }
		    else if(magic == MH_MAGIC_64 ||
		            magic == SWAP_INT(MH_MAGIC_64)){
			printf(" is a truncated object file\n");
			memset(&mh64, '\0', sizeof(struct mach_header_64));
			if(size > sizeof(struct mach_header_64))
			    size = sizeof(struct mach_header_64);
			memcpy(&mh64, addr, size);
			if(magic == SWAP_INT(MH_MAGIC_64))
			    swap_mach_header_64(&mh64, get_host_byte_sex());
			if(hflag)
			    print_mach_header(mh64.magic, mh64.cputype,
				mh64.cpusubtype, mh64.filetype, mh64.ncmds,
				mh64.sizeofcmds, mh64.flags, vflag);
			return;
		    }
		}
#ifdef LTO_SUPPORT
		if(ofile->lto != NULL){
		    printf(" is an LLVM bit-code file\n");
		    return;
		}
#endif /* LTO_SUPPORT */
		printf(" is not an object file\n");
		return;
	    }
	}
	if(ofile->mh != NULL){
	    if((intptr_t)(ofile->mh) % sizeof(uint32_t)){
		if(Xflag == FALSE)
		    printf("(object file offset is not a multiple of sizeof("
			   "uint32_t))");
		memcpy(&mh, ofile->mh, sizeof(struct mach_header));
		if(mh.magic == SWAP_INT(MH_MAGIC))
		    swap_mach_header(&mh, get_host_byte_sex());
		ofile->mh = &mh;
	    }
	    else if(ofile->mh->magic == SWAP_INT(MH_MAGIC)){
		mh = *(ofile->mh);
		swap_mach_header(&mh, get_host_byte_sex());
		ofile->mh = &mh;
	    }
	}
	else if(ofile->mh64 != NULL){
	    if((intptr_t)(ofile->mh64) % sizeof(uint32_t)){
		if(Xflag == FALSE)
		    printf("(object file offset is not a multiple of sizeof("
			   "uint32_t))");
		memcpy(&mh64, ofile->mh64, sizeof(struct mach_header));
		if(mh64.magic == SWAP_INT(MH_MAGIC_64))
		    swap_mach_header_64(&mh64, get_host_byte_sex());
		ofile->mh64 = &mh64;
	    }
	    else if(ofile->mh64->magic == SWAP_INT(MH_MAGIC_64)){
		mh64 = *(ofile->mh64);
		swap_mach_header_64(&mh64, get_host_byte_sex());
		ofile->mh64 = &mh64;
	    }
	}
	if(Xflag == FALSE)
	    printf("\n");

	/*
	 * If this is not an object file then just return.
	 */
	if(ofile->mh == NULL && ofile->mh64 == NULL)
	    return;

	/*
	 * Calculate the true number of bytes of the of the object file that
	 * is in memory (in case this file is truncated).
	 */
	addr = ofile->object_addr;
	size = ofile->object_size;
	if(addr + size > ofile->file_addr + ofile->file_size)
	    size = (ofile->file_addr + ofile->file_size) - addr;

	/*
	 * Assign some local variables to the values in the mach_header for this
	 * ofile to make passing arguments to the print routines easier.
	 */
	if(ofile->mh != NULL){
	    mh_magic = ofile->mh->magic;
	    mh_cputype = ofile->mh->cputype;
	    mh_cpusubtype = ofile->mh->cpusubtype;
	    mh_filetype = ofile->mh->filetype;
	    mh_ncmds = ofile->mh->ncmds;
	    mh_sizeofcmds = ofile->mh->sizeofcmds;
	    sizeof_mach_header = sizeof(struct mach_header);
	}
	else{
	    mh_magic = ofile->mh64->magic;
	    mh_cputype = ofile->mh64->cputype;
	    mh_cpusubtype = ofile->mh64->cpusubtype;
	    mh_filetype = ofile->mh64->filetype;
	    mh_ncmds = ofile->mh64->ncmds;
	    mh_sizeofcmds = ofile->mh64->sizeofcmds;
	    sizeof_mach_header = sizeof(struct mach_header_64);
	}

	/*
	 * Mach header.
	 */
	if(hflag){
	    if(ofile->mh != NULL)
		print_mach_header(ofile->mh->magic, ofile->mh->cputype,
				  ofile->mh->cpusubtype, ofile->mh->filetype,
				  ofile->mh->ncmds, ofile->mh->sizeofcmds,
				  ofile->mh->flags, vflag);
	    else
		print_mach_header(ofile->mh64->magic, ofile->mh64->cputype,
				  ofile->mh64->cpusubtype,ofile->mh64->filetype,
				  ofile->mh64->ncmds, ofile->mh64->sizeofcmds,
				  ofile->mh64->flags, vflag);
	}

	/*
	 * Load commands.
	 */
	if(mh_sizeofcmds + sizeof_mach_header > size){
	    load_commands = allocate(mh_sizeofcmds);
	    memset(load_commands, '\0', mh_sizeofcmds);
	    memcpy(load_commands, ofile->load_commands, 
		   size - sizeof_mach_header);
	    ofile->load_commands = load_commands;
	}
	if(lflag)
	    print_loadcmds(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
			   mh_cputype, mh_filetype, ofile->object_byte_sex,
			   size, vflag, Vflag);

	if(Lflag || Dflag)
	    print_libraries(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
			    ofile->object_byte_sex, (Dflag && !Lflag), vflag);

	/*
	 * If the indicated operation needs the symbol table get it.
	 */
	sect_flags = 0;
	if(segname != NULL && sectname != NULL){
	    (void)get_sect_info(segname, sectname, ofile->load_commands,
			mh_ncmds, mh_sizeofcmds, mh_filetype,
			ofile->object_byte_sex,
			addr, size, &sect, &sect_size, &sect_addr,
			&sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr);
	    /*
	     * The MH_DYLIB_STUB format has all section sizes set to zero 
	     * except sections with indirect symbol table entries (so that the
	     * indirect symbol table table entries can be printed, which are
	     * based on the section size).  So if we are being asked to print
	     * the section contents of one of these sections in a MH_DYLIB_STUB
	     * we assume it has been stripped and set the section size to zero.
	     */
	    if(mh_filetype == MH_DYLIB_STUB &&
	       ((sect_flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
	        (sect_flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		(sect_flags & SECTION_TYPE) == S_LAZY_DYLIB_SYMBOL_POINTERS ||
	        (sect_flags & SECTION_TYPE) == S_SYMBOL_STUBS))
		sect_size = 0;
	}
	if(Rflag || Mflag)
	    get_symbol_table_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		mh_cputype, ofile->object_byte_sex, addr, size, &symbols,
		&symbols64, &nsymbols, &strings, &strings_size);
	if(vflag && (rflag || Tflag || Mflag || Rflag || Iflag || Hflag || tflag
	   || iflag || oflag ||
	   (sect_flags & SECTION_TYPE) == S_LITERAL_POINTERS ||
	   (sect_flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
	   (sect_flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS ||
	   (sect_flags & S_ATTR_PURE_INSTRUCTIONS) ==
		S_ATTR_PURE_INSTRUCTIONS ||
	   (sect_flags & S_ATTR_SOME_INSTRUCTIONS) ==
		S_ATTR_SOME_INSTRUCTIONS ||
	   segname != NULL)){
	    get_symbol_table_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
	        mh_cputype, ofile->object_byte_sex, addr, size, &symbols, 
		&symbols64, &nsymbols, &strings, &strings_size);

	    if(symbols != NULL){
		if((uintptr_t)symbols % sizeof(uint32_t) ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    allocated_symbols =
			allocate(nsymbols * sizeof(struct nlist));
		    memcpy(allocated_symbols, symbols,
			   nsymbols * sizeof(struct nlist));
		    symbols = allocated_symbols;
		}
		if(ofile->object_byte_sex != get_host_byte_sex())
		    swap_nlist(symbols, nsymbols, get_host_byte_sex());
	    }
	    else{
		if((uintptr_t)symbols64 % sizeof(uint32_t) ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    allocated_symbols64 =
			allocate(nsymbols * sizeof(struct nlist_64));
		    memcpy(allocated_symbols64, symbols64,
			   nsymbols * sizeof(struct nlist_64));
		    symbols64 = allocated_symbols64;
		}
		if(ofile->object_byte_sex != get_host_byte_sex())
		    swap_nlist_64(symbols64, nsymbols, get_host_byte_sex());
	    }

	    /*
	     * If the operation needs a sorted symbol table create it.
	     */
	    if(tflag || iflag || oflag || 
	       (((sect_flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
	         (sect_flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS) &&
		  Vflag) ||
	       (sect_flags & S_ATTR_PURE_INSTRUCTIONS) ==
		    S_ATTR_PURE_INSTRUCTIONS ||
	       (sect_flags & S_ATTR_SOME_INSTRUCTIONS) ==
		    S_ATTR_SOME_INSTRUCTIONS){
		sorted_symbols = allocate(nsymbols * sizeof(struct symbol));
		nsorted_symbols = 0;
		for(i = 0; i < nsymbols; i++){
		    if(symbols != NULL){
			n_strx = symbols[i].n_un.n_strx;
			n_type = symbols[i].n_type;
			n_desc = symbols[i].n_desc;
			n_value = symbols[i].n_value;
		    }
		    else{
			n_strx = symbols64[i].n_un.n_strx;
			n_type = symbols64[i].n_type;
			n_desc = symbols64[i].n_desc;
			n_value = symbols64[i].n_value;
		    }
		    if(n_strx > 0 && n_strx < strings_size)
			p = strings + n_strx;
		    else
			p = "symbol with bad string index";
		    if(n_type & ~(N_TYPE|N_EXT|N_PEXT))
			continue;
		    n_type = n_type & N_TYPE;
		    if(n_type == N_ABS || n_type == N_SECT){
			len = strlen(p);
			if(len > sizeof(".o") - 1 &&
			   strcmp(p + (len - (sizeof(".o") - 1)), ".o") == 0)
			    continue;
			if(strcmp(p, "gcc_compiled.") == 0)
			    continue;
			if(strncmp(p, "ltmp", sizeof("ltmp") - 1) == 0)
			    continue;
			if(n_type == N_ABS && n_value == 0 && *p == '.')
			    continue;
			sorted_symbols[nsorted_symbols].n_value = n_value;
			sorted_symbols[nsorted_symbols].name = p;
			sorted_symbols[nsorted_symbols].is_thumb =
			    n_desc & N_ARM_THUMB_DEF;
			nsorted_symbols++;
		    }
		}
		qsort(sorted_symbols, nsorted_symbols, sizeof(struct symbol),
		      (int (*)(const void *, const void *))sym_compare);
	    }
	}

	if(Mflag || Tflag || Rflag){
	    get_module_table_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		mh_cputype, ofile->object_byte_sex, addr, size, &mods, &mods64,
		&nmods);
	    if(mods != NULL){
		if((intptr_t)mods % sizeof(uint32_t) ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    allocated_mods = allocate(nmods *
					      sizeof(struct dylib_module));
		    memcpy(allocated_mods, mods,
			   nmods * sizeof(struct dylib_module));
		    mods = allocated_mods;
		}
		if(ofile->object_byte_sex != get_host_byte_sex())
		    swap_dylib_module(mods, nmods, get_host_byte_sex());
	    }
	    if(mods64 != NULL){
		if((intptr_t)mods64 % sizeof(uint64_t) ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    allocated_mods64 = allocate(nmods *
					        sizeof(struct dylib_module_64));
		    memcpy(allocated_mods64, mods64,
			   nmods * sizeof(struct dylib_module_64));
		    mods64 = allocated_mods64;
		}
		if(ofile->object_byte_sex != get_host_byte_sex())
		    swap_dylib_module_64(mods64, nmods, get_host_byte_sex());
	    }
	}

	if(Tflag){
	    get_toc_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, addr, size, &tocs, &ntocs);
	    if((intptr_t)tocs % sizeof(uint32_t) ||
	       ofile->object_byte_sex != get_host_byte_sex()){
		allocated_tocs = allocate(ntocs *
					sizeof(struct dylib_table_of_contents));
		memcpy(allocated_tocs, tocs,
		       ntocs * sizeof(struct dylib_table_of_contents));
		tocs = allocated_tocs;
	    }
	    if(ofile->object_byte_sex != get_host_byte_sex())
		swap_dylib_table_of_contents(tocs, ntocs, get_host_byte_sex());
	    print_toc(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, addr, size, tocs, ntocs, mods, mods64,
		nmods, symbols, symbols64, nsymbols, strings, strings_size,
		vflag);
	}

	if(Mflag){
	    if(mods != NULL)
		print_module_table(mods, nmods, strings, strings_size, vflag);
	    else
		print_module_table_64(mods64, nmods, strings, strings_size,
				      vflag);
	}

	if(Rflag){
	    get_ref_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, addr, size, &refs, &nrefs);
	    if((intptr_t)refs % sizeof(uint32_t) ||
	       ofile->object_byte_sex != get_host_byte_sex()){
		allocated_refs = allocate(nrefs *
					sizeof(struct dylib_reference));
		memcpy(allocated_refs, refs,
		       nrefs * sizeof(struct dylib_reference));
		refs = allocated_refs;
	    }
	    if(ofile->object_byte_sex != get_host_byte_sex())
		swap_dylib_reference(refs, nrefs, get_host_byte_sex());
	    print_refs(refs, nrefs, mods, mods64, nmods, symbols, symbols64,
		       nsymbols, strings, strings_size, vflag);
	}

	if(Iflag || (tflag && vflag)){
	    get_indirect_symbol_table_info(ofile->load_commands, mh_ncmds,
		mh_sizeofcmds, ofile->object_byte_sex, addr, size,
		&indirect_symbols, &nindirect_symbols);
	    if((intptr_t)indirect_symbols % sizeof(uint32_t) ||
	       ofile->object_byte_sex != get_host_byte_sex()){
		allocated_indirect_symbols = allocate(nindirect_symbols *
						     sizeof(uint32_t));
		memcpy(allocated_indirect_symbols, indirect_symbols,
		       nindirect_symbols * sizeof(uint32_t));
		indirect_symbols = allocated_indirect_symbols;
	    }
	    if(ofile->object_byte_sex != get_host_byte_sex())
		swap_indirect_symbols(indirect_symbols, nindirect_symbols,
				      get_host_byte_sex());
	}
	if(Hflag){
	    get_hints_table_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, addr, size, &hints, &nhints);
	    if((intptr_t)hints % sizeof(uint32_t) ||
	       ofile->object_byte_sex != get_host_byte_sex()){
		allocated_hints = allocate(nhints *
					   sizeof(struct twolevel_hint));
		memcpy(allocated_hints, hints,
		       nhints * sizeof(struct twolevel_hint));
		hints = allocated_hints;
	    }
	    if(ofile->object_byte_sex != get_host_byte_sex())
		swap_twolevel_hint(hints, nhints, get_host_byte_sex());
	    print_hints(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, hints, nhints, symbols, symbols64,
		nsymbols, strings, strings_size, vflag);
	}
	if(Cflag){
	    get_link_opt_hints(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, addr, size, &loh, &nloh);
	    print_link_opt_hints(loh, nloh);
	}
	if(Gflag || (tflag && vflag)){
	    get_data_in_code_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, addr, size, &dices, &ndices);
	    if((intptr_t)dices % sizeof(uint32_t) ||
	       ofile->object_byte_sex != get_host_byte_sex()){
		allocated_dices = allocate(ndices *
					   sizeof(struct data_in_code_entry));
		memcpy(allocated_dices, dices,
		       ndices * sizeof(struct data_in_code_entry));
		dices = allocated_dices;
	    }
	    if(ofile->object_byte_sex != get_host_byte_sex())
		swap_data_in_code_entry(dices, ndices, get_host_byte_sex());
	    if(Gflag)
		print_dices(dices, ndices, vflag);
	}
	if(Iflag)
	    print_indirect_symbols(ofile->load_commands, mh_ncmds,mh_sizeofcmds,
		mh_cputype, ofile->object_byte_sex, indirect_symbols,
		nindirect_symbols, symbols, symbols64, nsymbols, strings,
		strings_size, vflag);

	if(rflag)
	    print_reloc(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
			mh_cputype, ofile->object_byte_sex, addr, size, symbols,
		        symbols64, nsymbols, strings, strings_size, vflag);
	if(print_bind_info){
	    setup_dyld_bind_info(ofile->load_commands, mh_ncmds, mh_sizeofcmds,
		ofile->object_byte_sex, ofile->object_addr, ofile->object_size,
		&dbi, &ndbi);
	    print_dyld_bind_info(dbi, ndbi);
	}

	if(tflag ||
	   (sect_flags & S_ATTR_PURE_INSTRUCTIONS) ==
		S_ATTR_PURE_INSTRUCTIONS ||
	   (sect_flags & S_ATTR_SOME_INSTRUCTIONS) ==
		S_ATTR_SOME_INSTRUCTIONS){
	    if(tflag)
		(void)get_sect_info(SEG_TEXT, SECT_TEXT, ofile->load_commands,
		    mh_ncmds, mh_sizeofcmds, mh_filetype,
		    ofile->object_byte_sex,
		    addr, size, &sect, &sect_size, &sect_addr,
		    &sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr);

	    /* create aligned relocations entries as needed */
	    relocs = NULL;
	    nrelocs = 0;
	    ext_relocs = NULL;
	    next_relocs = 0;
	    loc_relocs = NULL;
	    nloc_relocs = 0;
	    if(Vflag){
		if(mh_filetype == MH_KEXT_BUNDLE){
		    get_linked_reloc_info(ofile->load_commands, mh_ncmds,
			    mh_sizeofcmds, ofile->object_byte_sex,
			    ofile->object_addr, ofile->object_size, &ext_relocs,
			    &next_relocs, &loc_relocs, &nloc_relocs);
		    /* create aligned relocations entries as needed */
		    if((intptr_t)ext_relocs % sizeof(int32_t) != 0 ||
		       ofile->object_byte_sex != get_host_byte_sex()){
			relocs = allocate(next_relocs *
					  sizeof(struct relocation_info));
			memcpy(relocs, ext_relocs, next_relocs *
			       sizeof(struct relocation_info));
			ext_relocs = relocs;
		    }
		    if((intptr_t)loc_relocs % sizeof(int32_t) != 0 ||
		       ofile->object_byte_sex != get_host_byte_sex()){
			relocs = allocate(nloc_relocs *
					  sizeof(struct relocation_info));
			memcpy(relocs, loc_relocs, nloc_relocs *
			       sizeof(struct relocation_info));
			loc_relocs = relocs;
		    }
		    if(ofile->object_byte_sex != get_host_byte_sex()){
			swap_relocation_info(ext_relocs, next_relocs,
					     get_host_byte_sex());
			swap_relocation_info(loc_relocs, nloc_relocs,
					     get_host_byte_sex());
		    }
		    relocs = NULL;
		}
		if((intptr_t)sect_relocs % sizeof(int32_t) != 0 ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    nrelocs = sect_nrelocs;
		    relocs = allocate(nrelocs *
				      sizeof(struct relocation_info));
		    memcpy(relocs, sect_relocs, nrelocs *
			   sizeof(struct relocation_info));
		}
		else{
		    nrelocs = sect_nrelocs;
		    relocs = sect_relocs;
		}
		if(ofile->object_byte_sex != get_host_byte_sex())
		    swap_relocation_info(relocs, nrelocs,
					 get_host_byte_sex());
		setup_dyld_bind_info(ofile->load_commands, mh_ncmds,
				     mh_sizeofcmds, ofile->object_byte_sex,
				     ofile->object_addr, ofile->object_size,
				     &dbi, &ndbi);
	    }
	    if(Xflag == FALSE){
		if(tflag)
		    printf("(%s,%s) section\n", SEG_TEXT, SECT_TEXT);
		else
		    printf("Contents of (%.16s,%.16s) section\n", segname,
			   sectname);
	    }
	    if(Uflag)
		print_text_by_symbols(mh_cputype, ofile->object_byte_sex, sect,
		       sect_size, sect_addr, sect_flags, sorted_symbols,
		       nsorted_symbols, symbols, symbols64, nsymbols, strings,
		       strings_size, relocs, nrelocs, ext_relocs, next_relocs,
		       loc_relocs, nloc_relocs, dbi, ndbi, indirect_symbols,
		       nindirect_symbols, ofile->load_commands, mh_ncmds,
		       mh_sizeofcmds, vflag, Vflag, mh_cpusubtype,
		       ofile->object_addr, ofile->object_size, dices, ndices,
		       seg_addr);
	    else
		print_text(mh_cputype, ofile->object_byte_sex, sect, sect_size,
		       sect_addr, sect_flags, sorted_symbols,
		       nsorted_symbols, symbols, symbols64, nsymbols, strings,
		       strings_size, relocs, nrelocs, ext_relocs, next_relocs,
		       loc_relocs, nloc_relocs, dbi, ndbi, indirect_symbols,
		       nindirect_symbols, ofile->load_commands, mh_ncmds,
		       mh_sizeofcmds, vflag, Vflag, mh_cpusubtype,
		       ofile->object_addr, ofile->object_size, dices, ndices,
                       seg_addr);

	    if(relocs != NULL && relocs != sect_relocs)
		free(relocs);
	}

	if(iflag){
	    if(get_sect_info(SEG_TEXT, SECT_FVMLIB_INIT0, ofile->load_commands,
		mh_ncmds, mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
		addr, size, &sect, &sect_size, &sect_addr,
		&sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr) == TRUE){

		/* create aligned, sorted relocations entries */
		nrelocs = sect_nrelocs;
		relocs = allocate(nrelocs * sizeof(struct relocation_info));
		memcpy(relocs, sect_relocs, nrelocs *
		       sizeof(struct relocation_info));
		if(ofile->object_byte_sex != get_host_byte_sex())
		    swap_relocation_info(relocs, nrelocs, get_host_byte_sex());
		qsort(relocs, nrelocs, sizeof(struct relocation_info),
		      (int (*)(const void *, const void *))rel_compare);

		if(Xflag == FALSE)
		    printf("Shared library initialization (%s,%s) section\n",
			   SEG_TEXT, SECT_FVMLIB_INIT0);
		print_shlib_init(ofile->object_byte_sex, sect, sect_size,
			sect_addr, sorted_symbols, nsorted_symbols, symbols,
			symbols64, nsymbols, strings, strings_size, relocs,
			nrelocs, vflag);
		free(relocs);
	    }
	}

	if(dflag){
	    if(get_sect_info(SEG_DATA, SECT_DATA, ofile->load_commands,
		mh_ncmds, mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
		addr, size, &sect, &sect_size, &sect_addr,
		&sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr) == TRUE){

		if(Xflag == FALSE)
		    printf("(%s,%s) section\n", SEG_DATA, SECT_DATA);
		print_sect(mh_cputype, ofile->object_byte_sex, sect, sect_size,
			   sect_addr);
	    }
	}

	if(Pflag){
	    if(get_sect_info(SEG_TEXT, "__info_plist", ofile->load_commands,
		mh_ncmds, mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
		addr, size, &sect, &sect_size, &sect_addr,
		&sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr) == TRUE){

		if(Xflag == FALSE)
		    printf("(%s,%s) section\n", SEG_TEXT, "__info_plist");
		printf("%.*s\n", (int)sect_size, sect);
	    }
	}

	if(segname != NULL && sectname != NULL &&
	   (sect_flags & S_ATTR_PURE_INSTRUCTIONS) !=
		S_ATTR_PURE_INSTRUCTIONS &&
	   (sect_flags & S_ATTR_SOME_INSTRUCTIONS) !=
		S_ATTR_SOME_INSTRUCTIONS){
	    if(strcmp(segname, SEG_OBJC) == 0 &&
	       strcmp(sectname, "__protocol") == 0 && vflag == TRUE){
		print_objc_protocol_section(ofile->load_commands, mh_ncmds,
		   mh_sizeofcmds, ofile->object_byte_sex, ofile->object_addr,
		   ofile->object_size, vflag);
	    }
	    else if(strcmp(segname, SEG_OBJC) == 0 &&
	            (strcmp(sectname, "__string_object") == 0 ||
	             strcmp(sectname, "__cstring_object") == 0) &&
		    vflag == TRUE){
		if(mh_cputype & CPU_ARCH_ABI64)
		    print_objc_string_object_section_64(sectname,
			ofile->load_commands, mh_ncmds, mh_sizeofcmds,
			ofile->object_byte_sex, ofile->object_addr,
			ofile->object_size, mh_cputype, symbols64, nsymbols,
			strings, strings_size, sorted_symbols, nsorted_symbols,
			vflag);
		else
		    print_objc_string_object_section(sectname,
			ofile->load_commands, mh_ncmds, mh_sizeofcmds,
			ofile->object_byte_sex, ofile->object_addr,
			ofile->object_size, vflag);
	    }
	    else if(strcmp(segname, SEG_OBJC) == 0 &&
	       strcmp(sectname, "__runtime_setup") == 0 && vflag == TRUE){
		print_objc_runtime_setup_section(ofile->load_commands, mh_ncmds,
		   mh_sizeofcmds, ofile->object_byte_sex, ofile->object_addr,
		   ofile->object_size, vflag);
	    }
	    else if(strcmp(segname, "__LLVM") == 0 &&
	       strcmp(sectname, "__bundle") == 0 &&
	       (vflag == TRUE || Vflag == TRUE) &&
	       get_sect_info(segname, sectname, ofile->load_commands,
                   mh_ncmds, mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
                   addr, size, &sect, &sect_size, &sect_addr, &sect_relocs,
		   &sect_nrelocs, &sect_flags, &seg_addr) == TRUE){
		print_bitcode_section(sect, sect_size, vflag, Vflag);
	    }
#ifdef EFI_SUPPORT
	    else if(strcmp(segname, "__RELOC") == 0 &&
	       strcmp(sectname, "__reloc") == 0 && vflag == TRUE){
		print_coff_reloc_section(ofile->load_commands, mh_ncmds,
		   mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
		   ofile->object_addr, ofile->object_size, vflag);
	    }
#endif
	    else if(get_sect_info(segname, sectname, ofile->load_commands,
		mh_ncmds, mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
		addr, size, &sect, &sect_size, &sect_addr,
		&sect_relocs, &sect_nrelocs, &sect_flags, &seg_addr) == TRUE){

		if(Xflag == FALSE)
		    printf("Contents of (%.16s,%.16s) section\n", segname,
			   sectname);

		if(vflag){
		    switch((sect_flags & SECTION_TYPE)){
		    case 0:
			print_sect(mh_cputype, ofile->object_byte_sex,
				   sect, sect_size, sect_addr);
			break;
		    case S_ZEROFILL:
			printf("zerofill section and has no contents in the "
			       "file\n");
			break;
		    case S_CSTRING_LITERALS:
			print_cstring_section(mh_cputype, sect, sect_size,
					      sect_addr,
					      Xflag == TRUE ? FALSE : TRUE);
			break;
		    case S_4BYTE_LITERALS:
			print_literal4_section(mh_cputype, sect, sect_size,
					       sect_addr,
					       ofile->object_byte_sex,
					       Xflag == TRUE ? FALSE : TRUE);
			break;
		    case S_8BYTE_LITERALS:
			print_literal8_section(mh_cputype, sect, sect_size,
					       sect_addr,
					       ofile->object_byte_sex,
					       Xflag == TRUE ? FALSE : TRUE);
			break;
		    case S_16BYTE_LITERALS:
			print_literal16_section(mh_cputype, sect, sect_size,
						sect_addr,
					        ofile->object_byte_sex,
					        Xflag == TRUE ? FALSE : TRUE);
			break;
		    case S_LITERAL_POINTERS:
			/* create aligned, sorted relocations entries */
			nrelocs = sect_nrelocs;
			relocs = allocate(nrelocs *
					  sizeof(struct relocation_info));
			memcpy(relocs, sect_relocs, nrelocs *
			       sizeof(struct relocation_info));
			if(ofile->object_byte_sex != get_host_byte_sex())
			    swap_relocation_info(relocs, nrelocs,
					         get_host_byte_sex());
			qsort(relocs, nrelocs, sizeof(struct relocation_info),
			      (int (*)(const void *, const void *))rel_compare);
			print_literal_pointer_section(mh_cputype,
				ofile->load_commands, mh_ncmds, mh_sizeofcmds,
				ofile->object_byte_sex, addr, size, sect,
				sect_size, sect_addr, symbols, symbols64,
				nsymbols, strings, strings_size, relocs,
				nrelocs, Xflag == TRUE ? FALSE : TRUE);
			free(relocs);

			break;

		    case S_MOD_INIT_FUNC_POINTERS:
		    case S_MOD_TERM_FUNC_POINTERS:
			print_init_term_pointer_section(mh_cputype, sect,
			    sect_size, sect_addr, ofile->object_byte_sex,
			    sorted_symbols, nsorted_symbols, Vflag);
			break;

		    default:
			printf("Unknown section type (0x%x)\n",
			       (unsigned int)(sect_flags & SECTION_TYPE));
			print_sect(mh_cputype, ofile->object_byte_sex, sect,
				   sect_size, sect_addr);
			break;
		    }
		}
		else{
		    if((sect_flags & SECTION_TYPE) == S_ZEROFILL)
			printf("zerofill section and has no contents in the "
			       "file\n");
		    else
			print_sect(mh_cputype, ofile->object_byte_sex, sect,
				   sect_size, sect_addr);
		}
	    }
	}

	if(cflag)
	    print_argstrings(mh_magic, ofile->load_commands, mh_ncmds,
			     mh_sizeofcmds, mh_cputype, mh_cpusubtype,
			     ofile->object_byte_sex, ofile->object_addr,
			     ofile->object_size);

	if(oflag){
	    if(mh_cputype & CPU_ARCH_ABI64){
		get_linked_reloc_info(ofile->load_commands, mh_ncmds,
			mh_sizeofcmds, ofile->object_byte_sex,
			ofile->object_addr, ofile->object_size, &ext_relocs,
			&next_relocs, &loc_relocs, &nloc_relocs);
		/* create aligned relocations entries as needed */
		relocs = NULL;
		nrelocs = 0;
		if((intptr_t)ext_relocs % sizeof(int32_t) != 0 ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    relocs = allocate(next_relocs *
				      sizeof(struct relocation_info));
		    memcpy(relocs, ext_relocs, next_relocs *
			   sizeof(struct relocation_info));
		    ext_relocs = relocs;
		}
		if((intptr_t)loc_relocs % sizeof(int32_t) != 0 ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    relocs = allocate(nloc_relocs *
				      sizeof(struct relocation_info));
		    memcpy(relocs, loc_relocs, nloc_relocs *
			   sizeof(struct relocation_info));
		    loc_relocs = relocs;
		}
		if(ofile->object_byte_sex != get_host_byte_sex()){
		    swap_relocation_info(ext_relocs, next_relocs,
					 get_host_byte_sex());
		    swap_relocation_info(loc_relocs, nloc_relocs,
					 get_host_byte_sex());
		}
		setup_dyld_bind_info(ofile->load_commands, mh_ncmds,
				     mh_sizeofcmds, ofile->object_byte_sex,
				     ofile->object_addr, ofile->object_size,
				     &dbi, &ndbi);
		print_objc2_64bit(mh_cputype, ofile->load_commands, mh_ncmds,
			    mh_sizeofcmds, ofile->object_byte_sex,
			    ofile->object_addr, ofile->object_size, symbols64,
			    nsymbols, strings, strings_size, sorted_symbols,
			    nsorted_symbols, ext_relocs, next_relocs,
			    loc_relocs, nloc_relocs, dbi, ndbi, vflag, Vflag);
	    }
	    else if(mh_cputype == CPU_TYPE_ARM){
		get_linked_reloc_info(ofile->load_commands, mh_ncmds,
			mh_sizeofcmds, ofile->object_byte_sex,
			ofile->object_addr, ofile->object_size, &ext_relocs,
			&next_relocs, &loc_relocs, &nloc_relocs);
		/* create aligned relocations entries as needed */
		relocs = NULL;
		nrelocs = 0;
		if((intptr_t)ext_relocs % sizeof(int32_t) != 0 ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    relocs = allocate(next_relocs *
				      sizeof(struct relocation_info));
		    memcpy(relocs, ext_relocs, next_relocs *
			   sizeof(struct relocation_info));
		    ext_relocs = relocs;
		}
		if((intptr_t)loc_relocs % sizeof(int32_t) != 0 ||
		   ofile->object_byte_sex != get_host_byte_sex()){
		    relocs = allocate(nloc_relocs *
				      sizeof(struct relocation_info));
		    memcpy(relocs, loc_relocs, nloc_relocs *
			   sizeof(struct relocation_info));
		    loc_relocs = relocs;
		}
		if(ofile->object_byte_sex != get_host_byte_sex()){
		    swap_relocation_info(ext_relocs, next_relocs,
					 get_host_byte_sex());
		    swap_relocation_info(loc_relocs, nloc_relocs,
					 get_host_byte_sex());
		}
		print_objc2_32bit(mh_cputype, ofile->load_commands, mh_ncmds,
			    mh_sizeofcmds, ofile->object_byte_sex,
			    ofile->object_addr, ofile->object_size, symbols,
			    nsymbols, strings, strings_size, sorted_symbols,
			    nsorted_symbols, ext_relocs, next_relocs,
			    loc_relocs, nloc_relocs, vflag);
	    }
	    else{
		 /*
		  * This is the 32-bit non-arm cputype case.  Which is normally
		  * the first Objective-C ABI.  But it may be the case of a
		  * binary for the iOS simulator which is the second Objective-C
		  * ABI.  In that case print_objc_segment() will determine that
		  * and return FALSE.
		  */
		 if(print_objc_segment(mh_cputype, ofile->load_commands,
			mh_ncmds, mh_sizeofcmds, ofile->object_byte_sex,
			ofile->object_addr, ofile->object_size, sorted_symbols,
			nsorted_symbols, vflag) == FALSE){
		    get_linked_reloc_info(ofile->load_commands, mh_ncmds,
			    mh_sizeofcmds, ofile->object_byte_sex,
			    ofile->object_addr, ofile->object_size, &ext_relocs,
			    &next_relocs, &loc_relocs, &nloc_relocs);
		    /* create aligned relocations entries as needed */
		    relocs = NULL;
		    nrelocs = 0;
		    if((intptr_t)ext_relocs % sizeof(int32_t) != 0 ||
		       ofile->object_byte_sex != get_host_byte_sex()){
			relocs = allocate(next_relocs *
					  sizeof(struct relocation_info));
			memcpy(relocs, ext_relocs, next_relocs *
			       sizeof(struct relocation_info));
			ext_relocs = relocs;
		    }
		    if((intptr_t)loc_relocs % sizeof(int32_t) != 0 ||
		       ofile->object_byte_sex != get_host_byte_sex()){
			relocs = allocate(nloc_relocs *
					  sizeof(struct relocation_info));
			memcpy(relocs, loc_relocs, nloc_relocs *
			       sizeof(struct relocation_info));
			loc_relocs = relocs;
		    }
		    if(ofile->object_byte_sex != get_host_byte_sex()){
			swap_relocation_info(ext_relocs, next_relocs,
					     get_host_byte_sex());
			swap_relocation_info(loc_relocs, nloc_relocs,
					     get_host_byte_sex());
		    }
		    print_objc2_32bit(mh_cputype, ofile->load_commands,
			    mh_ncmds, mh_sizeofcmds, ofile->object_byte_sex,
			    ofile->object_addr, ofile->object_size, symbols,
			    nsymbols, strings, strings_size, sorted_symbols,
			    nsorted_symbols, ext_relocs, next_relocs,
			    loc_relocs, nloc_relocs, vflag);
		}
	    }
	}

	if(load_commands != NULL)
	    free(load_commands);
	if(allocated_symbols != NULL)
	    free(allocated_symbols);
	if(sorted_symbols != NULL)
	    free(sorted_symbols);
	if(allocated_indirect_symbols != NULL)
	    free(allocated_indirect_symbols);
	if(allocated_hints != NULL)
	    free(allocated_hints);
	if(allocated_dices != NULL)
	    free(allocated_dices);
	if(allocated_tocs != NULL)
	    free(allocated_tocs);
	if(allocated_mods != NULL)
	    free(allocated_mods);
	if(allocated_refs != NULL)
	    free(allocated_refs);
	if(dbi != NULL)
	    free(dbi);
}

/*
 * get_symbol_table_info() returns pointers to the symbol table and string
 * table as well as the number of symbols and size of the string table.
 * This routine handles the problems related to the file being truncated and
 * only returns valid pointers and sizes that can be used.  This routine will
 * return pointers that are misaligned and it is up to the caller to deal with
 * alignment issues.  It is also up to the caller to deal with byte sex of the
 * the symbol table.
 */
static
void
get_symbol_table_info(
struct load_command *load_commands,	/* input */
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_type_t cputype,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct nlist **symbols,			/* output */
struct nlist_64 **symbols64,
uint32_t *nsymbols,
char **strings,
uint32_t *strings_size)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, left, size, st_cmd;
    struct load_command *lc, l;
    struct symtab_command st;
    uint64_t bigsize;

	*symbols = NULL;
	*symbols64 = NULL;
	*nsymbols = 0;
	*strings = NULL;
	*strings_size = 0;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	st_cmd = UINT_MAX;
	lc = load_commands;
	memset((char *)&st, '\0', sizeof(struct symtab_command));
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_SYMTAB:
		if(st_cmd != UINT_MAX){
		    printf("more than one LC_SYMTAB command (using command %u)"
			   "\n", st_cmd);
		    break;
		}
		size = left < sizeof(struct symtab_command) ?
		       left : sizeof(struct symtab_command);
		memcpy((char *)&st, (char *)lc, size);
		if(swapped)
		    swap_symtab_command(&st, host_byte_sex);
		st_cmd = i;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	if(st_cmd == UINT_MAX){
	    return;
	}

	if(st.symoff >= object_size){
	    printf("symbol table offset is past end of file\n");
	}
	else{
	    if(cputype & CPU_ARCH_ABI64){
		*symbols64 = (struct nlist_64 *)(object_addr + st.symoff);
		bigsize = st.nsyms;
		bigsize *= sizeof(struct nlist_64);
		bigsize += st.symoff; 
		if(bigsize > object_size){
		    printf("symbol table extends past end of file\n");
		    *nsymbols = (object_size - st.symoff) /
			        sizeof(struct nlist_64);
		}
		else
		    *nsymbols = st.nsyms;
	    }
	    else{
		*symbols = (struct nlist *)(object_addr + st.symoff);
		bigsize = st.nsyms;
		bigsize *= sizeof(struct nlist);
		bigsize += st.symoff; 
		if(bigsize > object_size){
		    printf("symbol table extends past end of file\n");
		    *nsymbols = (object_size - st.symoff) /
			        sizeof(struct nlist);
		}
		else
		    *nsymbols = st.nsyms;
	    }
	}

	if(st.stroff >= object_size){
	    printf("string table offset is past end of file\n");
	}
	else{
	    *strings = object_addr + st.stroff;
	    if(st.stroff + st.strsize > object_size){
		printf("string table extends past end of file\n");
	    }
	    else
		*strings_size = st.strsize;
	}
}

/*
 * get_toc_info() returns a pointer and the size of the table of contents.
 * This routine handles the problems related to the file being truncated and
 * only returns valid pointers and sizes that can be used.  This routine will
 * return pointers that are misaligned and it is up to the caller to deal with
 * alignment issues.  It is also up to the caller to deal with byte sex of the
 * table.
 */
static
void
get_toc_info(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct dylib_table_of_contents **tocs,	/* output */
uint32_t *ntocs)
{
    struct dysymtab_command dyst;
    uint64_t bigsize;

	*tocs = NULL;
	*ntocs = 0;

	if(get_dyst(load_commands, ncmds, sizeofcmds, load_commands_byte_sex,
		    &dyst) == FALSE)
	    return;

	if(dyst.tocoff >= object_size){
	    printf("table of contents offset is past end of file\n");
	}
	else{
	    *tocs = (struct dylib_table_of_contents *)(object_addr +
						       dyst.tocoff);
	    bigsize = dyst.ntoc;
	    bigsize *= sizeof(struct dylib_table_of_contents);
	    bigsize += dyst.tocoff;
	    if(bigsize > object_size){
		printf("table of contents extends past end of file\n");
		*ntocs = (object_size - dyst.tocoff) /
				     sizeof(struct dylib_table_of_contents);
	    }
	    else
		*ntocs = dyst.ntoc;
	}
}

/*
 * get_module_table_info() returns a pointer and the size of the
 * module table.  This routine handles the problems related to the file being
 * truncated and only returns valid pointers and sizes that can be used.  This
 * routine will return pointers that are misaligned and it is up to the caller
 * to deal with alignment issues.  It is also up to the caller to deal with
 * byte sex of the table.
 */
static
void
get_module_table_info(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_type_t cputype,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct dylib_module **mods,			/* output */
struct dylib_module_64 **mods64,
uint32_t *nmods)
{
    struct dysymtab_command dyst;
    uint64_t bigsize;

	*mods = NULL;
	*mods64 = NULL;
	*nmods = 0;

	if(get_dyst(load_commands, ncmds, sizeofcmds, load_commands_byte_sex,
		    &dyst) == FALSE)
	    return;

	if(dyst.modtaboff >= object_size){
	    printf("module table offset is past end of file\n");
	}
	else{
	    if(cputype & CPU_ARCH_ABI64){
		*mods64 = (struct dylib_module_64 *)(object_addr +
						     dyst.modtaboff);
		bigsize = dyst.nmodtab;
		bigsize *= sizeof(struct dylib_module_64);
		bigsize += dyst.modtaboff;
		if(bigsize > object_size){
		    printf("module table extends past end of file\n");
		    *nmods = (object_size - dyst.modtaboff) /
					 sizeof(struct dylib_module_64);
		}
		else
		    *nmods = dyst.nmodtab;
	    }
	    else{
		*mods = (struct dylib_module *)(object_addr + dyst.modtaboff);
		if(dyst.modtaboff +
		   dyst.nmodtab * sizeof(struct dylib_module) > object_size){
		    printf("module table extends past end of file\n");
		    *nmods = (object_size - dyst.modtaboff) /
					 sizeof(struct dylib_module);
		}
		else
		    *nmods = dyst.nmodtab;
	    }
	}
}

/*
 * get_ref_info() returns a pointer and the size of the reference table.
 * This routine handles the problems related to the file being truncated and
 * only returns valid pointers and sizes that can be used.  This routine will
 * return pointers that are misaligned and it is up to the caller to deal with
 * alignment issues.  It is also up to the caller to deal with byte sex of the
 * table.
 */
static
void
get_ref_info(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct dylib_reference **refs,		/* output */
uint32_t *nrefs)
{
    struct dysymtab_command dyst;
    uint64_t bigsize;

	*refs = NULL;
	*nrefs = 0;

	if(get_dyst(load_commands, ncmds, sizeofcmds, load_commands_byte_sex,
		    &dyst) == FALSE)
	    return;

	if(dyst.extrefsymoff >= object_size){
	    printf("reference table offset is past end of file\n");
	}
	else{
	    *refs = (struct dylib_reference *)(object_addr + dyst.extrefsymoff);
	    bigsize = dyst.nextrefsyms;
	    bigsize *= sizeof(struct dylib_reference);
	    bigsize += dyst.extrefsymoff;
	    if(bigsize > object_size){
		printf("reference table extends past end of file\n");
		*nrefs = (object_size - dyst.extrefsymoff) /
				     sizeof(struct dylib_reference);
	    }
	    else
		*nrefs = dyst.nextrefsyms;
	}
}

/*
 * get_indirect_symbol_table_info() returns a pointer and the size of the
 * indirect symbol table.  This routine handles the problems related to the
 * file being truncated and only returns valid pointers and sizes that can be
 * used.  This routine will return pointers that are misaligned and it is up to
 * the caller to deal with alignment issues.  It is also up to the caller to
 * deal with byte sex of the table.
 */
static
void
get_indirect_symbol_table_info(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
uint32_t **indirect_symbols,	/* output */
uint32_t *nindirect_symbols)
{
    struct dysymtab_command dyst;
    uint64_t bigsize;

	*indirect_symbols = NULL;
	*nindirect_symbols = 0;

	if(get_dyst(load_commands, ncmds, sizeofcmds, load_commands_byte_sex,
		    &dyst) == FALSE)
	    return;

	if(dyst.indirectsymoff >= object_size){
	    printf("indirect symbol table offset is past end of file\n");
	}
	else{
	    *indirect_symbols = (uint32_t *)(object_addr + dyst.indirectsymoff);
	    bigsize = dyst.nindirectsyms;
	    bigsize *= sizeof(uint32_t);
	    bigsize += dyst.indirectsymoff;
	    if(bigsize > object_size){
		printf("indirect symbol table extends past end of file\n");
		*nindirect_symbols = (object_size - dyst.indirectsymoff) /
				     sizeof(uint32_t);
	    }
	    else
		*nindirect_symbols = dyst.nindirectsyms;
	}
}

/*
 * get_dyst() gets the dysymtab_command from the mach header and load commands
 * passed to it and copys it into dyst.  It if doesn't find one it returns FALSE
 * else it returns TRUE.
 */
static
enum bool
get_dyst(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
struct dysymtab_command *dyst)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, left, size, dyst_cmd;
    struct load_command *lc, l;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	dyst_cmd = UINT_MAX;
	lc = load_commands;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_DYSYMTAB:
		if(dyst_cmd != UINT_MAX){
		    printf("more than one LC_DYSYMTAB command (using command "
			   "%u)\n", dyst_cmd);
		    break;
		}
		memset((char *)dyst, '\0', sizeof(struct dysymtab_command));
		size = left < sizeof(struct dysymtab_command) ?
		       left : sizeof(struct dysymtab_command);
		memcpy((char *)dyst, (char *)lc, size);
		if(swapped)
		    swap_dysymtab_command(dyst, host_byte_sex);
		dyst_cmd = i;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	if(dyst_cmd == UINT_MAX){
	    return(FALSE);
	}
	return(TRUE);
}

/*
 * get_hints_table_info() returns a pointer and the size of the two-level hints
 * table.  This routine handles the problems related to the file being truncated
 * and only returns valid pointers and sizes that can be used.  This routine
 * will return pointers that are misaligned and it is up to the caller to deal
 * with alignment issues.  It is also up to the caller to deal with byte sex of
 * the table.
 */
static
void
get_hints_table_info(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct twolevel_hint **hints,	/* output */
uint32_t *nhints)
{
    struct twolevel_hints_command hints_cmd;
    uint64_t bigsize;

	*hints = NULL;
	*nhints = 0;

	memset(&hints_cmd, '\0', sizeof(struct twolevel_hints_command));
	if(get_hints_cmd(load_commands, ncmds, sizeofcmds,
		         load_commands_byte_sex, &hints_cmd) == FALSE)
	    return;

	if(hints_cmd.offset >= object_size){
	    printf("two-level hints offset is past end of file\n");
	}
	else{
	    *hints = (struct twolevel_hint *)(object_addr + hints_cmd.offset);
	    bigsize = hints_cmd.nhints;
	    bigsize *= sizeof(struct twolevel_hint);
	    bigsize += hints_cmd.offset;
	    if(bigsize > object_size){
		printf("two-level hints table extends past end of file\n");
		*nhints = (object_size - hints_cmd.offset) /
			  sizeof(struct twolevel_hint);
	    }
	    else
		*nhints = hints_cmd.nhints;
	}
}

/*
 * get_hints_cmd() gets the twolevel_hints_command from the mach header and
 * load commands passed to it and copys it into hints_cmd.  It if doesn't find
 * one it returns FALSE else it returns TRUE.
 */
static
enum bool
get_hints_cmd(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
struct twolevel_hints_command *hints_cmd)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, left, size, cmd;
    struct load_command *lc, l;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	cmd = UINT_MAX;
	lc = load_commands;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_TWOLEVEL_HINTS:
		if(cmd != UINT_MAX){
		    printf("more than one LC_TWOLEVEL_HINTS command (using "
			   "command %u)\n", cmd);
		    break;
		}
		memset((char *)hints_cmd, '\0',
		       sizeof(struct twolevel_hints_command));
		size = left < sizeof(struct twolevel_hints_command) ?
		       left : sizeof(struct twolevel_hints_command);
		memcpy((char *)hints_cmd, (char *)lc, size);
		if(swapped)
		    swap_twolevel_hints_command(hints_cmd, host_byte_sex);
		cmd = i;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	if(cmd == UINT_MAX){
	    return(FALSE);
	}
	return(TRUE);
}

/*
 * get_link_opt_hints() returns a pointer and the size of the linker
 * optimization hints table.  This routine handles the problems related to the
 * file being truncated and only returns valid pointers and sizes that can be
 * used.  
 */
static
void
get_link_opt_hints(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
char **loh,
uint32_t *nloh)
{
    struct linkedit_data_command loh_cmd;
    uint64_t bigsize;

	*loh = NULL;
	*nloh = 0;

	memset(&loh_cmd, '\0', sizeof(struct linkedit_data_command));
	if(get_link_opt_hint_cmd(load_commands, ncmds, sizeofcmds,
		                 load_commands_byte_sex, &loh_cmd) == FALSE)
	    return;

	if(loh_cmd.dataoff >= object_size){
	    printf("linker optimization hints offset is past end of file\n");
	}
	else{
	    *loh = object_addr + loh_cmd.dataoff;
	    bigsize = loh_cmd.dataoff;
	    bigsize += loh_cmd.datasize;
	    if(bigsize > object_size){
		printf("linker optimization hints extends past end of file\n");
		*nloh = object_size - loh_cmd.dataoff;
	    }
	    else
	    *nloh = loh_cmd.datasize;
	}
}

/*
 * get_link_opt_hint_cmd() gets the linker optimization hint command from the
 * mach header and load commands passed to it and copys it into loh_cmd.  It if
 * doesn't find one it returns FALSE else it returns TRUE.
 */
static
enum bool
get_link_opt_hint_cmd(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
struct linkedit_data_command *loh_cmd)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, left, size, cmd;
    struct load_command *lc, l;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	cmd = UINT_MAX;
	lc = load_commands;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_LINKER_OPTIMIZATION_HINT:
		if(cmd != UINT_MAX){
		    printf("more than one LC_LINKER_OPTIMIZATION_HINT command "
			   "(using command %u)\n", cmd);
		    break;
		}
		memset((char *)loh_cmd, '\0',
		       sizeof(struct linkedit_data_command));
		size = left < sizeof(struct linkedit_data_command) ?
		       left : sizeof(struct linkedit_data_command);
		memcpy((char *)loh_cmd, (char *)lc, size);
		if(swapped)
		    swap_linkedit_data_command(loh_cmd, host_byte_sex);
		cmd = i;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	if(cmd == UINT_MAX){
	    return(FALSE);
	}
	return(TRUE);
}

/*
 * get_data_in_code_info() returns a pointer and the size of the data in code
 * table.  This routine handles the problems related to the file being truncated
 * and only returns valid pointers and sizes that can be used.  This routine
 * will return pointers that are misaligned and it is up to the caller to deal
 * with alignment issues.  It is also up to the caller to deal with byte sex of
 * the table.
 */
static
void
get_data_in_code_info(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct data_in_code_entry **dices,	/* output */
uint32_t *ndices)
{
    struct linkedit_data_command dices_cmd;
    uint64_t bigsize;

	*dices = NULL;
	*ndices = 0;

	memset(&dices_cmd, '\0', sizeof(struct linkedit_data_command));
	if(get_dices_cmd(load_commands, ncmds, sizeofcmds,
		         load_commands_byte_sex, &dices_cmd) == FALSE)
	    return;

	if(dices_cmd.dataoff >= object_size){
	    printf("data in code offset is past end of file\n");
	}
	else{
	    *dices = (struct data_in_code_entry *)
		     (object_addr + dices_cmd.dataoff);
	    bigsize = dices_cmd.datasize;
	    bigsize += dices_cmd.dataoff;
	    if(bigsize > object_size){
		printf("data in code table extends past end of file\n");
		*ndices = (object_size - dices_cmd.dataoff) /
			  sizeof(struct data_in_code_entry);
	    }
	    else
		*ndices = dices_cmd.datasize /
			  sizeof(struct data_in_code_entry);
	}
}

/*
 * get_dices_cmd() gets the linkedit_data_command for the data in code from the
 * mach header and load commands passed to it and copys it into dices_cmd.  It
 * if doesn't find one it returns FALSE else it returns TRUE.
 */
static
enum bool
get_dices_cmd(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
struct linkedit_data_command *dices_cmd)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, left, size, cmd;
    struct load_command *lc, l;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	cmd = UINT_MAX;
	lc = load_commands;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_DATA_IN_CODE:
		if(cmd != UINT_MAX){
		    printf("more than one LC_DATA_IN_CODE command (using "
			   "command %u)\n", cmd);
		    break;
		}
		memset((char *)dices_cmd, '\0',
		       sizeof(struct linkedit_data_command));
		size = left < sizeof(struct linkedit_data_command) ?
		       left : sizeof(struct linkedit_data_command);
		memcpy((char *)dices_cmd, (char *)lc, size);
		if(swapped)
		    swap_linkedit_data_command(dices_cmd, host_byte_sex);
		cmd = i;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	if(cmd == UINT_MAX){
	    return(FALSE);
	}
	return(TRUE);
}

/*
 * Function for qsort for comparing symbols.
 */
static
int
sym_compare(
struct symbol *sym1,
struct symbol *sym2)
{
	if(sym1->n_value == sym2->n_value)
	    return(0);
	if(sym1->n_value < sym2->n_value)
	    return(-1);
	else
	    return(1);
}

/*
 * Function for qsort for comparing relocation entries.
 */
static
int
rel_compare(
struct relocation_info *rel1,
struct relocation_info *rel2)
{
    struct scattered_relocation_info *srel;
    uint32_t r_address1, r_address2;

	if((rel1->r_address & R_SCATTERED) != 0){
	    srel = (struct scattered_relocation_info *)rel1;
	    r_address1 = srel->r_address;
	}
	else
	    r_address1 = rel1->r_address;
	if((rel2->r_address & R_SCATTERED) != 0){
	    srel = (struct scattered_relocation_info *)rel2;
	    r_address2 = srel->r_address;
	}
	else
	    r_address2 = rel2->r_address;

	if(r_address1 == r_address2)
	    return(0);
	if(r_address1 < r_address2)
	    return(-1);
	else
	    return(1);
}

enum bool
get_sect_info(
char *segname,				/* input */
char *sectname,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
uint32_t filetype,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
char **sect_pointer,			/* output */
uint64_t *sect_size,
uint64_t *sect_addr,
struct relocation_info **sect_relocs,
uint32_t *sect_nrelocs,
uint32_t *sect_flags,
uint64_t *seg_addr)
{
    enum byte_sex host_byte_sex;
    enum bool found, swapped;
    uint32_t i, j, left, size;
    struct load_command *lc, l;
    uint32_t cmd;
    struct segment_command sg;
    struct segment_command_64 sg64;
    struct section s;
    struct section_64 s64;
    char *p;

	*sect_pointer = NULL;
	*sect_size = 0;
	*sect_addr = 0;
	*sect_relocs = NULL;
	*sect_nrelocs = 0;
	*sect_flags = 0;

	found = FALSE;
	cmd = 0;
	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	lc = load_commands;
	for(i = 0 ; found == FALSE && i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_SEGMENT:
		memset((char *)&sg, '\0', sizeof(struct segment_command));
		size = left < sizeof(struct segment_command) ?
		       left : sizeof(struct segment_command);
		memcpy((char *)&sg, (char *)lc, size);
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);

		if((filetype == MH_OBJECT && sg.segname[0] == '\0') ||
		   strncmp(sg.segname, segname, sizeof(sg.segname)) == 0){
                    *seg_addr = sg.vmaddr;
		    p = (char *)lc + sizeof(struct segment_command);
		    for(j = 0 ; found == FALSE && j < sg.nsects ; j++){
			if(p + sizeof(struct section) >
			   (char *)load_commands + sizeofcmds){
			    printf("section structure command extends past "
				   "end of load commands\n");
			}
			left = sizeofcmds - (p - (char *)load_commands);
			memset((char *)&s, '\0', sizeof(struct section));
			size = left < sizeof(struct section) ?
			       left : sizeof(struct section);
			memcpy((char *)&s, p, size);
			if(swapped)
			    swap_section(&s, 1, host_byte_sex);

			if(strncmp(s.sectname, sectname,
				   sizeof(s.sectname)) == 0 &&
			   strncmp(s.segname, segname,
				   sizeof(s.segname)) == 0){
			    found = TRUE;
			    cmd = LC_SEGMENT;
			    break;
			}

			if(p + sizeof(struct section) >
			   (char *)load_commands + sizeofcmds)
			    return(FALSE);
			p += size;
		    }
		}
		break;
	    case LC_SEGMENT_64:
		memset((char *)&sg64, '\0', sizeof(struct segment_command_64));
		size = left < sizeof(struct segment_command_64) ?
		       left : sizeof(struct segment_command_64);
		memcpy((char *)&sg64, (char *)lc, size);
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);

		if((filetype == MH_OBJECT && sg64.segname[0] == '\0') ||
		   strncmp(sg64.segname, segname, sizeof(sg64.segname)) == 0){
                    *seg_addr = sg.vmaddr;
		    p = (char *)lc + sizeof(struct segment_command_64);
		    for(j = 0 ; found == FALSE && j < sg64.nsects ; j++){
			if(p + sizeof(struct section_64) >
			   (char *)load_commands + sizeofcmds){
			    printf("section structure command extends past "
				   "end of load commands\n");
			}
			left = sizeofcmds - (p - (char *)load_commands);
			memset((char *)&s64, '\0', sizeof(struct section_64));
			size = left < sizeof(struct section_64) ?
			       left : sizeof(struct section_64);
			memcpy((char *)&s64, p, size);
			if(swapped)
			    swap_section_64(&s64, 1, host_byte_sex);

			if(strncmp(s64.sectname, sectname,
				   sizeof(s64.sectname)) == 0 &&
			   strncmp(s64.segname, segname,
				   sizeof(s64.segname)) == 0){
			    found = TRUE;
			    cmd = LC_SEGMENT_64;
			    break;
			}

			if(p + sizeof(struct section_64) >
			   (char *)load_commands + sizeofcmds)
			    return(FALSE);
			p += size;
		    }
		}
		break;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if(found == FALSE)
	    return(FALSE);

	if(cmd == LC_SEGMENT){
	    if((s.flags & SECTION_TYPE) == S_ZEROFILL){
		*sect_pointer = NULL;
		*sect_size = s.size;
	    }
	    else{
		if(s.offset > object_size){
		    printf("section offset for section (%.16s,%.16s) is past "
			   "end of file\n", s.segname, s.sectname);
		}
		else{
		    *sect_pointer = object_addr + s.offset;
		    if(s.size > object_size ||
		       s.offset + s.size > object_size){
			printf("section (%.16s,%.16s) extends past end of "
			       "file\n", s.segname, s.sectname);
			*sect_size = object_size - s.offset;
		    }
		    else
			*sect_size = s.size;
		}
	    }
	    if(s.reloff >= object_size){
		printf("relocation entries offset for (%.16s,%.16s): is past "
		       "end of file\n", s.segname, s.sectname);
	    }
	    else{
		*sect_relocs = (struct relocation_info *)(object_addr +
							  s.reloff);
		if(s.reloff + s.nreloc * sizeof(struct relocation_info) >
								object_size){
		    printf("relocation entries for section (%.16s,%.16s) "
			   "extends past end of file\n", s.segname, s.sectname);
		    *sect_nrelocs = (object_size - s.reloff) /
				    sizeof(struct relocation_info);
		}
		else
		    *sect_nrelocs = s.nreloc;
	    }
	    *sect_addr = s.addr;
	    *sect_flags = s.flags;
	}
	else{
	    if((s64.flags & SECTION_TYPE) == S_ZEROFILL){
		*sect_pointer = NULL;
		*sect_size = s64.size;
	    }
	    else{
		if(s64.offset > object_size){
		    printf("section offset for section (%.16s,%.16s) is past "
			   "end of file\n", s64.segname, s64.sectname);
		}
		else{
		    *sect_pointer = object_addr + s64.offset;
		    if(s64.size > object_size ||
                       s64.offset + s64.size > object_size){
			printf("section (%.16s,%.16s) extends past end of "
			       "file\n", s64.segname, s64.sectname);
		    }
		    else
			*sect_size = s64.size;
		}
	    }
	    if(s64.reloff >= object_size){
		printf("relocation entries offset for (%.16s,%.16s): is past "
		       "end of file\n", s64.segname, s64.sectname);
	    }
	    else{
		*sect_relocs = (struct relocation_info *)(object_addr +
							  s64.reloff);
		if(s64.reloff + s64.nreloc * sizeof(struct relocation_info) >
								object_size){
		    printf("relocation entries for section (%.16s,%.16s) "
			   "extends past end of file\n", s64.segname,
			   s64.sectname);
		    *sect_nrelocs = (object_size - s64.reloff) /
				    sizeof(struct relocation_info);
		}
		else
		    *sect_nrelocs = s64.nreloc;
	    }
	    *sect_addr = s64.addr;
	    *sect_flags = s64.flags;
	}
	return(TRUE);
}

static
void
get_linked_reloc_info(
struct load_command *load_commands, 	/* input */
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct relocation_info **ext_relocs,	/* output */
uint32_t *next_relocs,
struct relocation_info **loc_relocs,
uint32_t *nloc_relocs)
{
    struct dysymtab_command dyst;
    uint64_t bigsize;

	*ext_relocs = NULL;
	*next_relocs = 0;
	*loc_relocs = NULL;
	*nloc_relocs = 0;

	if(get_dyst(load_commands, ncmds, sizeofcmds, load_commands_byte_sex,
		    &dyst) == FALSE)
	    return;

	if(dyst.extreloff >= object_size){
	    printf("external relocation entries offset is past end of file\n");
	}
	else{
	    *ext_relocs = (struct relocation_info *)(object_addr +
			   dyst.extreloff);
	    bigsize = dyst.nextrel;
	    bigsize *= sizeof(struct relocation_info);
	    bigsize += dyst.extreloff;
	    if(bigsize > object_size){
		printf("external relocation entries extend past end of file\n");
		*next_relocs = (object_size - dyst.extreloff) /
				     sizeof(struct relocation_info);
	    }
	    else
		*next_relocs = dyst.nextrel;
	}
	if(dyst.locreloff >= object_size){
	    printf("local relocation entries offset is past end of file\n");
	}
	else{
	    *loc_relocs = (struct relocation_info *)(object_addr +
			   dyst.locreloff);
	    bigsize = dyst.nlocrel;
	    bigsize *= sizeof(struct relocation_info);
	    bigsize += dyst.locreloff;
	    if(bigsize > object_size){
		printf("local relocation entries extend past end of file\n");
		*nloc_relocs = (object_size - dyst.locreloff) /
				     sizeof(struct relocation_info);
	    }
	    else
		*nloc_relocs = dyst.nlocrel;
	}
}

/*
 * setup_dyld_bind_info() looks for a LC_DYLD_INFO load command and if it has
 * bind info unpacks it and returns it in dbi and ndbi values for the internal
 * expanded structs.
 */
static
void
setup_dyld_bind_info(
struct load_command *load_commands, 	/* input */
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct dyld_bind_info **dbi, /* output */
uint64_t *ndbi)
{
    enum byte_sex host_byte_sex;
    enum bool swapped, found_bind;
    uint32_t pass, i, j, left, size, nsegs, nsegs64, ndylibs;
    uint64_t big_size;
    struct load_command *lc, l;
    struct dyld_info_command dyld_info;
    struct dylib_command dl;
    struct segment_command sg, **segs;
    struct segment_command_64 sg64, **segs64;
    struct section s;
    struct section_64 s64;
    char *short_name, *has_suffix;
    enum bool is_framework;
    char *p, *a;
    uint8_t *start, *end;
    const char **dylibs;

    a = NULL; /* cctools-port */

	/* If already setup just return. */
	if(*dbi != NULL)
	    return;

	found_bind = FALSE;
	*dbi = NULL;
	*ndbi = 0;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	nsegs = 0;
	nsegs64 = 0;
	ndylibs = 0;

	dylibs = NULL;
	segs = NULL;
	segs64 = NULL;
	/*
	 * Make two passes over the load commands. On the first pass count the
	 * number of load commands for dylibs and segments and look for an
	 * LC_DYLD_INFO load commands  If we find the bind info allocate space
	 * arrays of pointers to dylibs and segments and fill them in on the
	 * second pass.
	 */
	for(pass = 1; pass <= 2; pass++){
	    ndylibs = 0;
	    nsegs = 0;
	    nsegs64 = 0;
	    lc = load_commands;
	    for(i = 0 ; i < ncmds; i++){
		memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
		if(swapped)
		    swap_load_command(&l, host_byte_sex);
		if(l.cmdsize % sizeof(int32_t) != 0)
		    printf("load command %u size not a multiple of "
			   "sizeof(int32_t)\n", i);
		if((char *)lc + l.cmdsize >
		   (char *)load_commands + sizeofcmds)
		    printf("load command %u extends past end of load "
			   "commands\n", i);
		left = sizeofcmds - ((char *)lc - (char *)load_commands);

		switch(l.cmd){

		case LC_DYLD_INFO:
		case LC_DYLD_INFO_ONLY:
		    if(pass == 1){
			memset((char *)&dyld_info, '\0',
			       sizeof(struct dyld_info_command));
			size = left < sizeof(struct dyld_info_command) ?
			       left : sizeof(struct dyld_info_command);
			memcpy((char *)&dyld_info, (char *)lc, size);
			if(swapped)
			    swap_dyld_info_command(&dyld_info, host_byte_sex);
			if(dyld_info.bind_off > object_size){
			    printf("bind_off in LC_DYLD_INFO load command %u "
				   "past end of file\n", i);
			    return;
			}
			big_size = dyld_info.bind_off;
			big_size += dyld_info.bind_size;
        		if(big_size > object_size){
			    printf("bind_off plus bind_size in LC_DYLD_INFO "
				   "load command %u past end of file\n", i);
			    return;
			}
			if(found_bind == TRUE){
			    printf("more than one LC_DYLD_INFO load command\n");
			    return;
			}
			found_bind = TRUE;
		    }
		    break;

		case LC_LOAD_DYLIB:
		case LC_LOAD_WEAK_DYLIB:
		case LC_REEXPORT_DYLIB:
		case LC_LOAD_UPWARD_DYLIB:
		case LC_LAZY_LOAD_DYLIB:
		    if(pass == 1){
			ndylibs++;
		    }
		    else{
			memset((char *)&dl, '\0', sizeof(struct dylib_command));
			size = left < sizeof(struct dylib_command) ?
			       left : sizeof(struct dylib_command);
			memcpy((char *)&dl, (char *)lc, size);
			if(swapped)
			    swap_dylib_command(&dl, host_byte_sex);
			if(dl.dylib.name.offset < dl.cmdsize)
			    p = (char *)lc + dl.dylib.name.offset;
			else
			    p = "(bad offset for dylib.name.offset)";
		        short_name = guess_short_name(p,
						  &is_framework, &has_suffix);
			if(short_name != NULL)
			    dylibs[ndylibs++] = short_name;
			else
			    dylibs[ndylibs++] = p;
		    }
		    break;

		case LC_SEGMENT:
		    memset((char *)&sg, '\0', sizeof(struct segment_command));
		    size = left < sizeof(struct segment_command) ?
			   left : sizeof(struct segment_command);
		    memcpy((char *)&sg, (char *)lc, size);
		    if(swapped)
			swap_segment_command(&sg, host_byte_sex);
		    if(pass == 2){
			a = allocate(sizeof(struct segment_command) +
				     sg.nsects * sizeof(struct section));
			memcpy(a, (char *)&sg,
			       sizeof(struct segment_command));
			segs[nsegs++] =
			    (struct segment_command *)a;
			a += sizeof(struct segment_command);
		    }

		    p = (char *)lc + sizeof(struct segment_command);
		    for(j = 0 ; j < sg.nsects ; j++){
			if(p + sizeof(struct section) >
			   (char *)load_commands + sizeofcmds){
			    printf("section structure command extends past "
				   "end of load commands\n");
			    return;
			}
			left = sizeofcmds - (p - (char *)load_commands);
			memset((char *)&s, '\0', sizeof(struct section));
			size = left < sizeof(struct section) ?
			       left : sizeof(struct section);
			memcpy((char *)&s, p, size);
			if(swapped)
			    swap_section(&s, 1, host_byte_sex);
			if(pass == 2){
			    memcpy(a, (char *)&s, sizeof(struct section));
			    a += sizeof(struct section);
			}
			if(p + sizeof(struct section) >
			   (char *)load_commands + sizeofcmds)
			    return;
			p += size;
		    }
		    if(pass == 1)
			nsegs++;
		    break;
		case LC_SEGMENT_64:
		    memset((char *)&sg64, '\0',
			   sizeof(struct segment_command_64));
		    size = left < sizeof(struct segment_command_64) ?
			   left : sizeof(struct segment_command_64);
		    memcpy((char *)&sg64, (char *)lc, size);
		    if(swapped)
			swap_segment_command_64(&sg64, host_byte_sex);
		    if(pass == 2){
			a = allocate(sizeof(struct segment_command_64) +
				     sg64.nsects * sizeof(struct section_64));
			memcpy(a, (char *)&sg64,
			       sizeof(struct segment_command_64));
			segs64[nsegs64++] =
			    (struct segment_command_64 *)a;
			a += sizeof(struct segment_command_64);
		    }

		    p = (char *)lc + sizeof(struct segment_command_64);
		    for(j = 0 ; j < sg64.nsects ; j++){
			if(p + sizeof(struct section_64) >
			   (char *)load_commands + sizeofcmds){
			    printf("section structure command extends past "
				   "end of load commands\n");
			}
			left = sizeofcmds - (p - (char *)load_commands);
			memset((char *)&s64, '\0', sizeof(struct section_64));
			size = left < sizeof(struct section_64) ?
			       left : sizeof(struct section_64);
			memcpy((char *)&s64, p, size);
			if(swapped)
			    swap_section_64(&s64, 1, host_byte_sex);
			if(pass == 2){
			    memcpy(a, (char *)&s64, sizeof(struct section_64));
			    a += sizeof(struct section_64);
			}
			if(p + sizeof(struct section_64) >
			   (char *)load_commands + sizeofcmds)
			    return;
			p += size;
		    }
		    if(pass == 1)
			nsegs64++;
		    break;
		}
		if(l.cmdsize == 0){
		    printf("load command %u size zero (can't advance to other "
			   "load commands)\n", i);
		    break;
		}
		lc = (struct load_command *)((char *)lc + l.cmdsize);
		if((char *)lc > (char *)load_commands + sizeofcmds)
		    break;
	    }
	    if(found_bind == FALSE)
		return;
	    if(pass == 1){
		dylibs = (const char **)allocate(ndylibs * sizeof(char *));
		segs = (struct segment_command **)allocate(
				nsegs * sizeof(struct segment_command *));
		segs64 = (struct segment_command_64 **)allocate(
				nsegs64 * sizeof(struct segment_command_64 *));
	    }
	}

	start = (uint8_t *)(object_addr + dyld_info.bind_off);
	end = start + dyld_info.bind_size;
	get_dyld_bind_info(start, end, dylibs, ndylibs, segs, nsegs,
			   segs64, nsegs64, dbi, ndbi);

	if(dylibs != NULL)
	    free(dylibs);
	if(segs != NULL){
	    for(i = 0; i < nsegs; i++)
		free(segs[i]);
	    free(segs);
	}
	if(segs64 != NULL){
	    for(i = 0; i < nsegs64; i++)
		free(segs64[i]);
	    free(segs64);
	}
}

static
void
print_text_by_symbols(
cpu_type_t cputype,
enum byte_sex object_byte_sex,
char *sect,
uint32_t size,
uint64_t addr,
uint32_t sect_flags,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
struct relocation_info *relocs,
uint32_t nrelocs,
struct relocation_info *ext_relocs,
uint32_t next_relocs,
struct relocation_info *loc_relocs,
uint32_t nloc_relocs,
struct dyld_bind_info *dbi,
uint64_t ndbi,
uint32_t *indirect_symbols,
uint32_t nindirect_symbols,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum bool disassemble,
enum bool verbose,
cpu_subtype_t cpusubtype,
char *object_addr,
uint32_t object_size,
struct data_in_code_entry *dices,
uint32_t ndices,
uint64_t seg_addr)
{
    uint32_t i, symbol_size;
    uint64_t symbol_addr, symbol_offset;

	for(i = 0; i < nsorted_symbols; i++){
	    symbol_addr = sorted_symbols[i].n_value;
	    if(symbol_addr < addr || symbol_addr >= addr + size)
		continue;
	    symbol_offset = symbol_addr - addr;
	    if(i+1 < nsorted_symbols &&
               sorted_symbols[i+1].n_value < addr + size)
		symbol_size = sorted_symbols[i+1].n_value - symbol_addr;
	    else
		symbol_size = (addr + size) - symbol_addr;
	    print_text(cputype, object_byte_sex, sect + symbol_offset,
		       symbol_size, symbol_addr, sect_flags, sorted_symbols,
		       nsorted_symbols, symbols, symbols64, nsymbols, strings,
		       strings_size, relocs, nrelocs, ext_relocs, next_relocs,
		       loc_relocs, nloc_relocs, dbi, ndbi, indirect_symbols,
		       nindirect_symbols, load_commands, ncmds, sizeofcmds,
		       disassemble, verbose, cpusubtype, object_addr,
                       object_size, dices, ndices, seg_addr);
	}
}

static
void
print_text(
cpu_type_t cputype,
enum byte_sex object_byte_sex,
char *sect,
uint32_t size,
uint64_t addr,
uint32_t sect_flags,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
struct relocation_info *relocs,
uint32_t nrelocs,
struct relocation_info *ext_relocs,
uint32_t next_relocs,
struct relocation_info *loc_relocs,
uint32_t nloc_relocs,
struct dyld_bind_info *dbi,
uint64_t ndbi,
uint32_t *indirect_symbols,
uint32_t nindirect_symbols,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum bool disassemble,
enum bool verbose,
cpu_subtype_t cpusubtype,
char *object_addr,
uint32_t object_size,
struct data_in_code_entry *dices,
uint32_t ndices,
uint64_t seg_addr)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, offset, long_word, label_offset;
    uint64_t cur_addr;
    unsigned short short_word;
    unsigned char byte_word;
    LLVMDisasmContextRef arm64_dc;
    LLVMDisasmContextRef arm_dc, thumb_dc, i386_dc, x86_64_dc;
    uint32_t n, ninsts;
    struct inst *insts;
    char *sect_start;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;
	arm_dc = NULL;
	thumb_dc = NULL;
	i386_dc = NULL;
	x86_64_dc = NULL;
	arm64_dc = NULL;
	n = 0;
	ninsts = 0;
	insts = NULL;

	/*
	 * If the section has a type of S_ZEROFILL then its section contents
         * pointer is NULL, so in this case just do nothing.
	 */
	if(sect == NULL)
	    return;

	if(disassemble == TRUE){
	    if(pflag){
		for(i = 0; i < nsorted_symbols; i++){
		    if(strcmp(sorted_symbols[i].name, pflag) == 0)
			break;
		}
		if(i == nsorted_symbols){
		    printf("Can't find -p symbol: %s\n", pflag);
		    return;
		}
		if(sorted_symbols[i].n_value < addr ||
		   sorted_symbols[i].n_value >= addr + size){
		    printf("-p symbol: %s not in text section\n", pflag);
		    return;
		}
		offset = sorted_symbols[i].n_value - addr;
		sect += offset;
		cur_addr = sorted_symbols[i].n_value;
		sect_start = sect;
	    }
	    else{
		offset = 0;
		cur_addr = addr;
		sect_start = sect;
	    }
	    if(cputype == CPU_TYPE_ARM &&
	       (cpusubtype == CPU_SUBTYPE_ARM_V7 ||
	        cpusubtype == CPU_SUBTYPE_ARM_V7F ||
	        cpusubtype == CPU_SUBTYPE_ARM_V7S ||
	        cpusubtype == CPU_SUBTYPE_ARM_V7K)){
		if(sect_flags & S_SYMBOL_STUBS)
		    in_thumb = FALSE;
		else
		    in_thumb = TRUE;
	    }
	    else
		in_thumb = FALSE;
	    if((qflag || gflag) && cputype == CPU_TYPE_ARM){
		arm_dc = create_arm_llvm_disassembler(cpusubtype);
		if(arm_dc == NULL){
		    printf("can't create arm llvm disassembler\n");
		    return;
		}
		thumb_dc = create_thumb_llvm_disassembler(cpusubtype);
		if(thumb_dc == NULL){
		    printf("can't create thumb llvm disassembler\n");
		    return;
		}
		llvm_disasm_set_options(arm_dc,
		    LLVMDisassembler_Option_PrintImmHex);
		llvm_disasm_set_options(thumb_dc,
		    LLVMDisassembler_Option_PrintImmHex);
		if(eflag){
		    llvm_disasm_set_options(arm_dc,
			LLVMDisassembler_Option_UseMarkup);
		    llvm_disasm_set_options(thumb_dc,
			LLVMDisassembler_Option_UseMarkup);
		}
	    }
	    if((qflag || gflag) && cputype == CPU_TYPE_I386){
		i386_dc = create_i386_llvm_disassembler();
		if(i386_dc == NULL){
		    printf("can't create i386 llvm disassembler\n");
		    return;
		}
		llvm_disasm_set_options(i386_dc,
		    LLVMDisassembler_Option_PrintImmHex);
		llvm_disasm_set_options(i386_dc,
		    LLVMDisassembler_Option_SetInstrComments);
		if(eflag)
		    llvm_disasm_set_options(i386_dc,
			LLVMDisassembler_Option_UseMarkup);
	    }
	    if((qflag || gflag) && cputype == CPU_TYPE_X86_64){
		x86_64_dc = create_x86_64_llvm_disassembler();
		if(x86_64_dc == NULL){
		    printf("can't create x86_64 llvm disassembler\n");
		    return;
		}
		llvm_disasm_set_options(x86_64_dc,
		    LLVMDisassembler_Option_PrintImmHex);
		llvm_disasm_set_options(x86_64_dc,
		    LLVMDisassembler_Option_SetInstrComments);
		if(eflag)
		    llvm_disasm_set_options(x86_64_dc,
			LLVMDisassembler_Option_UseMarkup);
	    }
	    if(cputype == CPU_TYPE_ARM64){
		arm64_dc = create_arm64_llvm_disassembler();
		if(arm64_dc == NULL){
		    printf("can't create arm64 llvm disassembler\n");
		    return;
		}
		llvm_disasm_set_options(arm64_dc,
		    LLVMDisassembler_Option_PrintImmHex);
	    }
	    if(gflag){
		ninsts = 100;
		insts = allocate(sizeof(struct inst) * ninsts);
	    }
	    label_offset = 0;
	    for(i = offset ; i < size ; ){
		if(gflag &&
		   (cputype == CPU_TYPE_X86_64 ||
		    cputype == CPU_TYPE_I386 ||
		    cputype == CPU_TYPE_ARM)){
		    if(n > ninsts){
			ninsts += ninsts;
			insts = reallocate(insts, sizeof(struct inst) * ninsts);
		    }
		    memset(&(insts[n]), '\0', sizeof(struct inst));
		    insts[n].address = cur_addr;
		    insts[n].label = get_label(cur_addr, sorted_symbols,
					       nsorted_symbols);;
		}
		else{
		    if(print_label(cur_addr, TRUE, sorted_symbols,
				   nsorted_symbols) == TRUE)
			label_offset = i;
		    if(function_offsets)
			printf("%+6d ", (int)(i - label_offset));
		    if(Xflag == FALSE){
			if(cputype & CPU_ARCH_ABI64)
			    printf("%016llx", cur_addr);
			else
			    printf("%08x", (uint32_t)cur_addr);
			if((qflag == FALSE ||
			    (cputype == CPU_TYPE_POWERPC)) &&
			    cputype != CPU_TYPE_ARM64)
			    printf("\t");
		    }
		}
		if(cputype == CPU_TYPE_POWERPC64)
		    j = ppc_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				symbols64, nsymbols, sorted_symbols,
				nsorted_symbols, strings, strings_size,
				indirect_symbols, nindirect_symbols,
				load_commands, ncmds, sizeofcmds, verbose);
		else if(cputype == CPU_TYPE_X86_64)
		    j = i386_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, ext_relocs,
				next_relocs, loc_relocs, nloc_relocs, dbi, ndbi,
				NULL, symbols64, nsymbols, sorted_symbols,
				nsorted_symbols, strings, strings_size,
				indirect_symbols, nindirect_symbols, cputype,
				load_commands, ncmds, sizeofcmds, verbose,
				llvm_mc, i386_dc, x86_64_dc , object_addr,
				object_size, &(insts[n]), NULL, 0);
	 	else if(cputype == CPU_TYPE_MC680x0)
		    j = m68k_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, indirect_symbols,
				nindirect_symbols, load_commands, ncmds,
				sizeofcmds, verbose);
		else if(cputype == CPU_TYPE_I860)
		    j = i860_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, verbose);
		else if(cputype == CPU_TYPE_I386)
		    j = i386_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, ext_relocs,
				next_relocs, loc_relocs, nloc_relocs, dbi, ndbi,
				symbols, NULL, nsymbols, sorted_symbols,
				nsorted_symbols, strings, strings_size,
				indirect_symbols, nindirect_symbols, cputype,
				load_commands, ncmds, sizeofcmds, verbose,
				llvm_mc, i386_dc, x86_64_dc, object_addr,
				object_size, &(insts[n]), NULL, 0);
		else if(cputype == CPU_TYPE_MC88000)
		    j = m88k_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, verbose);
		else if(cputype == CPU_TYPE_POWERPC ||
			cputype == CPU_TYPE_VEO)
		    j = ppc_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				symbols64, nsymbols, sorted_symbols,
				nsorted_symbols, strings, strings_size,
				indirect_symbols, nindirect_symbols,
				load_commands, ncmds, sizeofcmds, verbose);
		else if(cputype == CPU_TYPE_HPPA)
		    j = hppa_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, verbose);
		else if(cputype == CPU_TYPE_SPARC)
		    j = sparc_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, indirect_symbols,
				nindirect_symbols, load_commands, ncmds,
				sizeofcmds, verbose);
		else if(cputype == CPU_TYPE_ARM)
		    j = arm_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, symbols,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, indirect_symbols,
				nindirect_symbols, load_commands, ncmds,
				sizeofcmds, cpusubtype, verbose, arm_dc,
				thumb_dc, object_addr, object_size, dices,
				ndices, seg_addr, &(insts[n]), NULL, 0);
		else if(cputype == CPU_TYPE_ARM64)
		    j = arm64_disassemble(sect, size - i, cur_addr, addr,
				object_byte_sex, relocs, nrelocs, ext_relocs,
				next_relocs, loc_relocs, nloc_relocs, dbi, ndbi,
				symbols64, nsymbols, sorted_symbols,
				nsorted_symbols, strings, strings_size,
				indirect_symbols, nindirect_symbols,
				load_commands, ncmds, sizeofcmds, object_addr,
				object_size, verbose, arm64_dc);
		
		else{
		    printf("Can't disassemble unknown cputype %d\n", cputype);
		    return;
		}
		sect += j;
		cur_addr += j;
		i += j;
		if(gflag)
		    n++;
	    }
	    if(gflag &&
	       (cputype == CPU_TYPE_X86_64 ||
		cputype == CPU_TYPE_I386 ||
		cputype == CPU_TYPE_ARM)){
		char dst[4096];
		dst[4095] = '\0';

		/* Look for inits that need tmp labels. */
		for(i = 0 ; i < n ; i++){
		    if(insts[i].has_raw_target_address){
			for(j = 0; j < n; j++){
			    if(insts[i].raw_target_address == insts[j].address)
				insts[j].needs_tmp_label = TRUE;
			}
		    }
		}

		/* Create the needed tmp labels. */
		j = 1;
		for(i = 0 ; i < n ; i++){
		    if(insts[i].needs_tmp_label == TRUE){
			insts[i].tmp_label = allocate(20);
			sprintf(insts[i].tmp_label, "L%d", j++);
		    }
		}

		/* Now finally print the inits. */
		for(i = 0 ; i < n ; i++){
		    if(insts[i].label != NULL)
			printf("%s:\n", insts[i].label);
		    else if(insts[i].tmp_label != NULL)
			printf("%s:", insts[i].tmp_label);
		    insts[i].print = TRUE;
		    cur_addr = insts[i].address;
		    offset = cur_addr - addr;
		    sect = sect_start + offset;
		    if(cputype == CPU_TYPE_X86_64 || cputype == CPU_TYPE_I386)
			j = i386_disassemble(sect, size - offset, cur_addr,
				addr, object_byte_sex, relocs, nrelocs,
				ext_relocs, next_relocs, loc_relocs,
				nloc_relocs, dbi, ndbi, symbols, NULL,
				nsymbols, sorted_symbols, nsorted_symbols,
				strings, strings_size, indirect_symbols,
				nindirect_symbols, cputype, load_commands, 
				ncmds, sizeofcmds, verbose, llvm_mc, i386_dc,
				x86_64_dc, object_addr, object_size,
				&(insts[i]), insts, n);
		    else if(cputype == CPU_TYPE_ARM)
			j = arm_disassemble(sect, size - offset, cur_addr, addr,
				    object_byte_sex, relocs, nrelocs, symbols,
				    nsymbols, sorted_symbols, nsorted_symbols,
				    strings, strings_size, indirect_symbols,
				    nindirect_symbols, load_commands, ncmds,
				    sizeofcmds, cpusubtype, verbose, arm_dc,
				    thumb_dc, object_addr, object_size, dices,
				    ndices, seg_addr, &(insts[i]), insts, n);
		}

		/* Free up allocated space */
		for(i = 0 ; i < n ; i++){
		    if(insts[i].tmp_label != NULL)
			free(insts[i].tmp_label);
		}
		free(insts);
	    }
	    if(i386_dc != NULL)
		delete_arm_llvm_disassembler(i386_dc);
	    if(x86_64_dc != NULL)
		delete_arm_llvm_disassembler(x86_64_dc);
	    if(arm_dc != NULL)
		delete_arm_llvm_disassembler(arm_dc);
	    if(thumb_dc != NULL)
		delete_arm_llvm_disassembler(thumb_dc);
	    if(arm64_dc != NULL)
		delete_arm64_llvm_disassembler(arm64_dc);
	}
	else{
	    if(cputype == CPU_TYPE_I386 || cputype == CPU_TYPE_X86_64){
		for(i = 0 ; i < size ; i += j , addr += j){
		    if(cputype & CPU_ARCH_ABI64)
			printf("%016llx ", addr);
		    else
			printf("%08x ", (uint32_t)addr);
		    for(j = 0;
			j < 16 * sizeof(char) && i + j < size;
			j += sizeof(char)){
			byte_word = *(sect + i + j);
			printf("%02x ", (unsigned int)byte_word);
		    }
		    printf("\n");
		}
	    }
	    else if(cputype == CPU_TYPE_MC680x0){
		for(i = 0 ; i < size ; i += j , addr += j){
		    printf("%08x ", (unsigned int)addr);
		    for(j = 0;
			j < 8 * sizeof(short) && i + j < size;
			j += sizeof(short)){
			memcpy(&short_word, sect + i + j, sizeof(short));
			if(swapped)
			    short_word = SWAP_SHORT(short_word);
			printf("%04x ", (unsigned int)short_word);
		    }
		    printf("\n");
		}
	    }
	    else{
		for(i = 0 ; i < size ; i += j , addr += j){
		    if(cputype & CPU_ARCH_ABI64)
			printf("%016llx ", addr);
		    else
			printf("%08x ", (uint32_t)addr);
		    for(j = 0;
			j < 4 * sizeof(int32_t) && i + j < size;
			j += sizeof(int32_t)){
			memcpy(&long_word, sect + i + j, sizeof(int32_t));
			if(swapped)
			    long_word = SWAP_INT(long_word);
			printf("%08x ", (unsigned int)long_word);
		    }
		    printf("\n");
		}
	    }
	}
}

static
void
print_argstrings(
uint32_t magic,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_type_t cputype,
cpu_subtype_t cpusubtype,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, len, left, size, arg;
    uint64_t usrstack;
    struct load_command *lc, l;
    struct segment_command sg;
    struct segment_command_64 sg64;
    char *stack, *stack_top, *p, *q, *argv;
    struct arch_flag arch_flags;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	arch_flags.cputype = cputype;
	if(magic == MH_MAGIC_64)
	    arch_flags.cputype |= CPU_ARCH_ABI64;
	arch_flags.cpusubtype = cpusubtype;
	usrstack = get_stack_addr_from_flag(&arch_flags);
	if(usrstack == 0){
	    printf("Don't know the value of USRSTACK for unknown cputype "
		   "(%d)\n", cputype);
	    return;
	}
	printf("Argument strings on the stack at: ");
	if(cputype & CPU_ARCH_ABI64 || magic == MH_MAGIC_64)
	    printf("%016llx\n", usrstack);
	else
	    printf("%08x\n", (uint32_t)usrstack);
	lc = load_commands;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(cputype & CPU_ARCH_ABI64 || magic == MH_MAGIC_64){
		if(l.cmdsize % 8 != 0)
		    printf("load command %u size not a multiple of 8\n", i);
	    }
	    else{
		if(l.cmdsize % 4 != 0)
		    printf("load command %u size not a multiple of 4\n", i);
	    }
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_SEGMENT:
		memset((char *)&sg, '\0', sizeof(struct segment_command));
		size = left < sizeof(struct segment_command) ?
		       left : sizeof(struct segment_command);
		memcpy((char *)&sg, (char *)lc, size);
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);

		if(cputype == CPU_TYPE_HPPA){
		    if(sg.vmaddr == usrstack &&
		       sg.fileoff + sg.filesize <= object_size){
			stack = object_addr + sg.fileoff;
			stack_top = stack + sg.filesize;
			/*
			 * There appears to be some pointer then argc at the
			 * bottom of the stack first before argv[].
			 */
			argv = stack + 2 * sizeof(uint32_t);
			memcpy(&arg, argv, sizeof(uint32_t));
			if(swapped)
			    arg = SWAP_INT(arg);
			while(argv < stack_top &&
			      arg != 0 &&
			      arg >= usrstack && arg < usrstack + sg.filesize){
			    p = stack + (arg - usrstack);
			    printf("\t");
			    while(p < stack_top && *p != '\0'){
				printf("%c", *p);
				p++;
			    }
			    printf("\n");
			    argv += sizeof(uint32_t);
			    memcpy(&arg, argv, sizeof(uint32_t));
			    if(swapped)
				arg = SWAP_INT(arg);
			}
			/* after argv[] then there is envp[] */
			argv += sizeof(uint32_t);
			memcpy(&arg, argv, sizeof(uint32_t));
			if(swapped)
			    arg = SWAP_INT(arg);
			while(argv < stack_top &&
			      arg != 0 &&
			      arg >= usrstack && arg < usrstack + sg.filesize){
			    p = stack + (arg - usrstack);
			    printf("\t");
			    while(p < stack_top && *p != '\0'){
				printf("%c", *p);
				p++;
			    }
			    printf("\n");
			    argv += sizeof(uint32_t);
			    memcpy(&arg, argv, sizeof(uint32_t));
			    if(swapped)
				arg = SWAP_INT(arg);
			}
		    }
		}
		else{
		    if(sg.vmaddr + sg.vmsize == usrstack &&
		       sg.fileoff + sg.filesize <= object_size){
			stack = object_addr + sg.fileoff;
			stack_top = stack + sg.filesize;

			/* the first thing on the stack is a long 0 */
			stack_top -= 4;
			p = (char *)stack_top;

			/* find the first non-null character before the long 0*/
			while(p > stack && *p == '\0')
			    p--;
			if(p != (char *)stack_top)
			    p++;

			q = p;
			/* Stop when we find another long 0 */
			while(p > stack && (*p != '\0' || *(p-1) != '\0' ||
			      *(p-2) != '\0' || *(p-3) != '\0')){
			    p--;
			    /* step back over the string to its start */
			    while(p > stack && *p != '\0')
				p--;
			}

			p++; /* step forward to the start of the first string */
			while(p < q){
			    printf("\t");
			    len = 0;
			    while(p + len < q && p[len] != '\0'){
				printf("%c", p[len]);
				len++;
			    }
			    printf("\n");
			    p += len + 1;
			}
			return;
		    }
		}
		break;
	    case LC_SEGMENT_64:
		memset((char *)&sg64, '\0', sizeof(struct segment_command_64));
		size = left < sizeof(struct segment_command_64) ?
		       left : sizeof(struct segment_command_64);
		memcpy((char *)&sg64, (char *)lc, size);
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);
		if(sg64.vmaddr + sg64.vmsize == usrstack &&
		   sg64.fileoff + sg64.filesize <= object_size){
		    stack = object_addr + sg64.fileoff;
		    stack_top = stack + sg64.filesize;

		    /* the first thing on the stack is a uint64_t 0 */
		    stack_top -= 8;
		    p = (char *)stack_top;

		    /* find the first non-null character before the uint64_t 0*/
		    while(p > stack && *p == '\0')
			p--;
		    if(p != (char *)stack_top)
			p++;

		    q = p;
		    /* Stop when we find another uint64_t 0 */
		    while(p > stack && (*p != '\0' || *(p-1) != '\0' ||
			  *(p-2) != '\0' || *(p-3) != '\0' || *(p-4) != '\0' ||
			  *(p-5) != '\0' || *(p-6) != '\0' || *(p-7) != '\0')){
			p--;
			/* step back over the string to its start */
			while(p > stack && *p != '\0')
			    p--;
		    }

		    p++; /* step forward to the start of the first string */
		    while(p < q){
			printf("\t");
			len = 0;
			while(p + len < q && p[len] != '\0'){
			    printf("%c", p[len]);
			    len++;
			}
			printf("\n");
			p += len + 1;
		    }
		    return;
		}
		break;
	    }

	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
}

#ifndef __DYNAMIC__
/*
 * To avoid linking in libm.  These variables are defined as they are used in
 * pthread_init() to put in place a fast sqrt().
 */
size_t hw_sqrt_len = 0;

double
sqrt(double x)
{
	return(0.0);
}
double
hw_sqrt(double x)
{
	return(0.0);
}

/*
 * More stubs to avoid linking in libm.  This works as along as we don't use
 * long doubles.
 */
int32_t
__fpclassifyd(double x)
{
	return(0);
}
int32_t
__fpclassify(long double x)
{
	return(0);
}
#endif /* !defined(__DYNAMIC__) */
           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/notify.c                              0100644 0001750 0001750 00000004673 12612724206 023262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __DYNAMIC__
#include <notify.h>

uint32_t notify_post(const char *name)
{
	return 0;
}

uint32_t notify_register_check(const char *name, int *out_token)
{
	*out_token = 0;
	return 0;
}

uint32_t notify_register_signal(const char *name, int sig, int *out_token)
{
	*out_token = 0;
	return 0;
}

uint32_t notify_register_mach_port(const char *name, mach_port_t *notify_port, int flags, int *out_token)
{
	*notify_port = MACH_PORT_NULL;
	out_token = 0;
	return 0;
}

uint32_t notify_register_file_descriptor(const char *name, int *notify_fd, int flags, int *out_token)
{
	*notify_fd = 0;
	out_token = 0;
	return 0;
}

uint32_t notify_check(int token, int *check)
{
	*check = 1;
	return 0;
}

uint32_t notify_cancel(int token)
{
	return 0;
}

int __notify_78945668_info__ = 0;

uint32_t notify_monitor_file(int t, char *s, int f)
{
	return 0;
}
#endif /* !defined(__DYNAMIC__) */
                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/notify.h                              0100644 0001750 0001750 00000020475 12612724206 023265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __NOTIFICATION_H__
#define __NOTIFICATION_H__

#include <sys/cdefs.h>
#include <stdint.h>
#include <mach/message.h>

/*
 * These routines allow processes to exchange stateless notification events.
 *
 * Notifications are associated with names in a namespace shared by all
 * clients of the system.  Clients may post notifications for names, and
 * may monitor names for posted notifications.  Clients may request
 * notification delivery by a number of different methods.
 *
 * Clients desiring to monitor names in the notification system must
 * register with the system, providing a name and other information
 * required for the desired notification delivery method.  Clients are
 * given an integer token representing the registration.
 *
 * Notification delivery is provided on a best-effort basis, but is not
 * reliable.  Limitations in the service may cause some notifications to
 * be dropped, particularly under heavily loaded conditions.
 *
 * Notifications may be coalesced in some cases.  Multiple events posted
 * for a name in rapid succession may result in a single notification sent
 * to clients registered for notification for that name.  Clients checking
 * for changes using the notify_check() routine cannot determine if
 * more than one event pas been posted since a previous call to 
 * notify_check() for that name.
 *
 * "False positives" may occur in notify_check() when used with a token
 * generated by notify_register_check() due to implementation constraints.
 * This behavior may vary in future releases.  
 */

/*
 * Status codes returned by the API.
 */
#define NOTIFY_STATUS_OK 0
#define NOTIFY_STATUS_INVALID_NAME 1
#define NOTIFY_STATUS_INVALID_TOKEN 2
#define NOTIFY_STATUS_INVALID_PORT 3
#define NOTIFY_STATUS_INVALID_FILE 4
#define NOTIFY_STATUS_INVALID_SIGNAL 5
#define NOTIFY_STATUS_INVALID_REQUEST 6
#define NOTIFY_STATUS_NOT_AUTHORIZED 7
#define NOTIFY_STATUS_FAILED 1000000

/*
 * Flag bits used for registration.
 */
#define NOTIFY_REUSE 0x00000001


__BEGIN_DECLS

/* 
 * Post a notification for a name.
 *
 * This is the only call that is required for a notification producer.
 * Returns status.
 */
uint32_t notify_post(const char *name);

/*
 * Creates a registration token be used with notify_check(),
 * but no active notifications will be delivered.
 *
 * Input parameter
 *     name - notification name
 * Output parameter
 *     out_token - registration token
 * Returns status.
 */
uint32_t notify_register_check(const char *name, int *out_token);

/*
 * Request notification delivery by UNIX signal.
 *
 * A client may request signal notification for multiple names.  After a signal
 * is delivered, the notify_check() routine may be called with each notification 
 * token to determine which name (if any) generated the signal notification.
 *
 * Input parameters
 *     name - notification name
 *     sig  - signal number (see signal(3))
 * Output parameter
 *     out_token - notification token
 * Returns status.
 */
uint32_t notify_register_signal(const char *name, int sig, int *out_token);

/*
 * Request notification by mach message.  
 *
 * Notifications are delivered by an empty message sent to a mach port.
 * By default, a new port is allocated and a pointer to it is returned
 * as the value of "notify_port".  A mach port previously returned by a 
 * call to this routine may be used for notifications if a pointer to that
 * port is passed in to the routine and NOTIFY_REUSE is set in the flags
 * parameter.  The notification service must be able to extract send
 * rights to the port.
 *
 * Note that the kernel limits the size of the message queue for any port.
 * If it is important that notifications should not be lost due to queue
 * overflow, clients should service messages quickly, and be careful about
 * using the same port for notifications for more than one name.
 *
 * A notification message has an empty message body.  The msgh_id field
 * in the mach message header will have the value of the notification
 * token.  If a port is reused for multiple notification registrations,
 * the msgh_id value may be used to determine which name generated
 * the notification.
 *
 * Input parameter
 *     name - notification name
 * Output parameter
 *     out_token - notification token
 * Input/Output parameter
 *     notify_port - pointer to a mach port
 * Returns status.
 */
uint32_t notify_register_mach_port(const char *name, mach_port_t *notify_port, int flags, int *out_token);

/*
 * Request notification by a write to a file descriptor. 
 *
 * Notifications are delivered by a write to a file descriptor.
 * By default, a new file descriptor is created and a pointer to it
 * is returned as the value of "notify_fd".  A file descriptor created
 * by a previous call to this routine may be used for notifications if
 * a pointer to that file descriptor is passed in to the routine and
 * NOTIFY_REUSE is set in the flags parameter. 
 *
 * Note that the kernel limits the buffer space for queued writes on a
 * file descriptor.  If it is important that notifications should not be
 * lost due to queue overflow, clients should service messages quickly,
 * and be careful about using the same file descriptor for notifications
 * for more than one name.
 *
 * Notifications are delivered by an integer value written to the
 * file descriptor.  The value will match the notification token
 * for which the notification was generated.
 *
 * Input parameter
 *     name - notification name
 * Output parameter
 *     out_token - notification token
 * Input/Output parameter
 *     notify_fd - pointer to a file descriptor
 * Returns status.
 */
uint32_t notify_register_file_descriptor(const char *name, int *notify_fd, int flags, int *out_token);

/*
 * Check if any notifications have been posted.
 *
 * Output parameter check is set to 0 for false, 1 for true.  Returns status.
 * check is set to true the first time notify_check is called for a token.
 * Subsequent calls set check to true when notifications have been posted for
 * the name associated with the notification token.  This routine is independent
 * of notify_post().  That is, check will be true if an application calls
 * notify_post() for a name and then calls notify_check() for a token associated
 * with that name.
 *
 * Input parameter
 *     token - notification token
 * Output parameter
 *     check - true/false indication
 * Returns status.
 */
uint32_t notify_check(int token, int *check);

/*
 * Cancel notification and free resources associated with a notification
 * token.  Mach ports and file descriptor associated with a token are released 
 * (deallocated or closed) when all registration tokens associated with 
 * the port or file descriptor have been cancelled.
 *
 * Input parameter
 *     token - notification token
 * Returns status.
 */
uint32_t notify_cancel(int token);

__END_DECLS

#endif __NOTIFICATION_H__
                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/ofile_print.c                         0100644 0001750 0001750 00000767304 12612724206 024273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * This file intention is to beable to print the structures in an object file
 * and handle problems with reguard to alignment and bytesex.  The goal is to
 * print as much as possible even when things are truncated or trashed.  Both
 * a verbose (symbolic) and non-verbose modes are supported to aid in seeing
 * the values even if they are not correct.  As much as possible strict checks
 * on values of fields for correctness should be done (such as proper alignment)
 * and notations on errors should be printed.
 */

#define __cr cr
#define __ctr ctr
#define __dar dar
#define __dsisr dsisr
#define __exception exception
#define __fpregs fpregs
#define __fpscr fpscr
#define __fpscr_pad fpscr_pad
#define __lr lr
#define __mq mq
#define __pad0 pad0
#define __pad1 pad1
#define __r0 r0
#define __r1 r1
#define __r10 r10
#define __r11 r11
#define __r12 r12
#define __r13 r13
#define __r14 r14
#define __r15 r15
#define __r16 r16
#define __r17 r17
#define __r18 r18
#define __r19 r19
#define __r2 r2
#define __r20 r20
#define __r21 r21
#define __r22 r22
#define __r23 r23
#define __r24 r24
#define __r25 r25
#define __r26 r26
#define __r27 r27
#define __r28 r28
#define __r29 r29
#define __r3 r3
#define __r30 r30
#define __r31 r31
#define __r4 r4
#define __r5 r5
#define __r6 r6
#define __r7 r7
#define __r8 r8
#define __r9 r9
#define __srr0 srr0
#define __srr1 srr1
#define __vrsave vrsave
#define __xer xer

#define __darwin_i386_exception_state i386_exception_state
#define __darwin_i386_float_state i386_float_state
#define __darwin_i386_thread_state i386_thread_state
#define __busy busy
#define __c0 c0
#define __c1 c1
#define __c2 c2
#define __c3 c3
#define __cs cs
#define __darwin_fp_control fp_control
#define __darwin_fp_status fp_status
#define __darwin_mmst_reg mmst_reg
#define __darwin_xmm_reg xmm_reg
#define __denorm denorm
#define __ds ds
#define __eax eax
#define __ebp ebp
#define __ebx ebx
#define __ecx ecx
#define __edi edi
#define __edx edx
#define __eflags eflags
#define __eip eip
#define __err err
#define __errsumm errsumm
#define __es es
#define __esi esi
#define __esp esp
#define __faultvaddr faultvaddr
#define __fpu_cs fpu_cs
#define __fpu_dp fpu_dp
#define __fpu_ds fpu_ds
#define __fpu_fcw fpu_fcw
#define __fpu_fop fpu_fop
#define __fpu_fsw fpu_fsw
#define __fpu_ftw fpu_ftw
#define __fpu_ip fpu_ip
#define __fpu_mxcsr fpu_mxcsr
#define __fpu_mxcsrmask fpu_mxcsrmask
#define __fpu_reserved fpu_reserved
#define __fpu_reserved1 fpu_reserved1
#define __fpu_rsrv1 fpu_rsrv1
#define __fpu_rsrv2 fpu_rsrv2
#define __fpu_rsrv3 fpu_rsrv3
#define __fpu_rsrv4 fpu_rsrv4
#define __fpu_stmm0 fpu_stmm0
#define __fpu_stmm1 fpu_stmm1
#define __fpu_stmm2 fpu_stmm2
#define __fpu_stmm3 fpu_stmm3
#define __fpu_stmm4 fpu_stmm4
#define __fpu_stmm5 fpu_stmm5
#define __fpu_stmm6 fpu_stmm6
#define __fpu_stmm7 fpu_stmm7
#define __fpu_xmm0 fpu_xmm0
#define __fpu_xmm1 fpu_xmm1
#define __fpu_xmm2 fpu_xmm2
#define __fpu_xmm3 fpu_xmm3
#define __fpu_xmm4 fpu_xmm4
#define __fpu_xmm5 fpu_xmm5
#define __fpu_xmm6 fpu_xmm6
#define __fpu_xmm7 fpu_xmm7
#define __fpu_xmm8 fpu_xmm8
#define __fpu_xmm9 fpu_xmm9
#define __fpu_xmm10 fpu_xmm10
#define __fpu_xmm11 fpu_xmm11
#define __fpu_xmm12 fpu_xmm12
#define __fpu_xmm13 fpu_xmm13
#define __fpu_xmm14 fpu_xmm14
#define __fpu_xmm15 fpu_xmm15
#define __fs fs
#define __gs gs
#define __invalid invalid
#define __mmst_reg mmst_reg
#define __mmst_rsrv mmst_rsrv
#define __ovrfl ovrfl
#define __pc pc
#define __precis precis
#define __rc rc
#define __ss ss
#define __stkflt stkflt
#define __tos tos
#define __trapno trapno
#define __undfl undfl
#define __xmm_reg xmm_reg
#define __zdiv zdiv

#define __rax rax
#define __rbx rbx
#define __rcx rcx
#define __rdx rdx
#define __rdi rdi
#define __rsi rsi
#define __rbp rbp
#define __rsp rsp
#define __r8 r8
#define __r9 r9
#define __r10 r10
#define __r11 r11
#define __r12 r12
#define __r13 r13
#define __r14 r14
#define __r15 r15
#define __rip rip
#define __rflags rflags

#define __dr0 dr0
#define __dr1 dr1
#define __dr2 dr2
#define __dr3 dr3
#define __dr4 dr4
#define __dr5 dr5
#define __dr6 dr6
#define __dr7 dr7

/*
 * Otherwise string.h may hide strnlen().
 * https://github.com/tpoechtrager/cctools-port/pull/8
 */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <limits.h>
#include <ar.h>
#include <libc.h>
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/i860/reloc.h>
#include <mach-o/m88k/reloc.h>
#include <mach-o/ppc/reloc.h>
#include <mach-o/hppa/reloc.h>
#include <mach-o/sparc/reloc.h>
#include <mach-o/arm/reloc.h>
#include <mach-o/arm64/reloc.h>
#include "stuff/symbol.h"
#include "stuff/ofile.h"
#include "stuff/allocate.h"
#include "stuff/errors.h"
#include "stuff/guess_short_name.h"
#include "dyld_bind_info.h"
#include "ofile_print.h"

/* <mach/loader.h> */
/* The maximum section alignment allowed to be specified, as a power of two */
#define MAXSECTALIGN		15 /* 2**15 or 0x8000 */

static void print_arch(
    struct fat_arch *fat_arch);
static void print_cputype(
    cpu_type_t cputype,
    cpu_subtype_t cpusubtype);

#if i386_THREAD_STATE == 1
#ifdef i386_EXCEPTION_STATE_COUNT
static void print_mmst_reg(
    struct mmst_reg *r);
static void print_xmm_reg(
    struct xmm_reg *r);
#endif /* defined(i386_EXCEPTION_STATE_COUNT) */
#endif /* i386_THREAD_STATE == 1 */

static void print_unknown_state(
    char *begin,
    char *end,
    unsigned int count,
    enum bool swapped);

struct reloc_section_info {
    char segname[16];
    char sectname[16];
    uint32_t nreloc;
    uint32_t reloff;
};

static void print_relocs(
    unsigned reloff,
    unsigned nreloc,
    struct reloc_section_info *sect_rel,
    uint32_t nsects,
    enum bool swapped,
    cpu_type_t cputype,
    char *object_addr,
    uint32_t object_size,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);
static void print_r_type(
    cpu_type_t cputype,
    uint32_t r_type,
    enum bool predicted);
static void print_cstring_char(
    char c);
static void print_literal4(
    uint32_t l,
    float f);
static void print_literal8(
    uint32_t l0,
    uint32_t l1,
    double d,
    enum byte_sex literal_byte_sex);
static void print_literal16(
    uint32_t l0,
    uint32_t l1,
    uint32_t l2,
    uint32_t l3);
static int rel_bsearch(
    uint32_t *address,
    struct relocation_info *rel);

/*
 * Print the fat header and the fat_archs.  The caller is responsible for making
 * sure the structures are properly aligned and that the fat_archs is of the
 * size fat_header->nfat_arch * sizeof(struct fat_arch).
 */
void
print_fat_headers(
struct fat_header *fat_header,
struct fat_arch *fat_archs,
uint64_t size,
enum bool verbose)
{
    uint32_t i, j;
    uint64_t big_size;

	if(verbose){
	    if(fat_header->magic == FAT_MAGIC)
		printf("fat_magic FAT_MAGIC\n");
	    else
		printf("fat_magic 0x%x\n", (unsigned int)(fat_header->magic));
	}
	else
	    printf("fat_magic 0x%x\n", (unsigned int)(fat_header->magic));
	printf("nfat_arch %u", fat_header->nfat_arch);
	big_size = fat_header->nfat_arch;
	big_size *= sizeof(struct fat_arch);
	big_size += sizeof(struct fat_header);
	if(fat_header->nfat_arch == 0)
	    printf(" (malformed, contains zero architecture types)\n");
	else if(big_size > size)
	    printf(" (malformed, architectures past end of file)\n");
	else
	    printf("\n");

	for(i = 0; i < fat_header->nfat_arch; i++){
	    big_size = i;
	    big_size *= sizeof(struct fat_arch);
	    big_size += sizeof(struct fat_header);
	    if(big_size > size)
		break;
	    printf("architecture ");
	    for(j = 0; i != 0 && j <= i - 1; j++){
		if(fat_archs[i].cputype != 0 && fat_archs[i].cpusubtype != 0 &&
		   fat_archs[i].cputype == fat_archs[j].cputype &&
		   (fat_archs[i].cpusubtype & ~CPU_SUBTYPE_MASK) ==
		   (fat_archs[j].cpusubtype & ~CPU_SUBTYPE_MASK)){
		    printf("(illegal duplicate architecture) ");
		    break;
		}
	    }
	    if(verbose){
		print_arch(fat_archs + i);
		print_cputype(fat_archs[i].cputype,
			      fat_archs[i].cpusubtype & ~CPU_SUBTYPE_MASK);
	    }
	    else{
		printf("%u\n", i);
		printf("    cputype %d\n", fat_archs[i].cputype);
		printf("    cpusubtype %d\n", fat_archs[i].cpusubtype &
					      ~CPU_SUBTYPE_MASK);
	    }
	    if(verbose && (fat_archs[i].cpusubtype & CPU_SUBTYPE_MASK) ==
	       CPU_SUBTYPE_LIB64)
		printf("    capabilities CPU_SUBTYPE_LIB64\n");
	    else
		printf("    capabilities 0x%x\n", (unsigned int)
		       ((fat_archs[i].cpusubtype & CPU_SUBTYPE_MASK) >>24));
	    printf("    offset %u", fat_archs[i].offset);
	    if(fat_archs[i].offset > size)
		printf(" (past end of file)");
	    if(fat_archs[i].offset % (1 << fat_archs[i].align) != 0)
		printf(" (not aligned on it's alignment (2^%u))\n",
		       fat_archs[i].align);
	    else
		printf("\n");

	    printf("    size %u", fat_archs[i].size);
	    big_size = fat_archs[i].offset;
	    big_size += fat_archs[i].size;
	    if(big_size > size)
		printf(" (past end of file)\n");
	    else
		printf("\n");

	    printf("    align 2^%u (%d)", fat_archs[i].align,
		   1 << fat_archs[i].align);
	    if(fat_archs[i].align > MAXSECTALIGN)
		printf("( too large, maximum 2^%d)\n", MAXSECTALIGN);
	    else
		printf("\n");
	}
}

/*
 * print_arch() helps print_fat_headers by printing the
 * architecture name for the cputype and cpusubtype.
 */
static
void
print_arch(
struct fat_arch *fat_arch)
{
	switch(fat_arch->cputype){
	case CPU_TYPE_MC680x0:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_MC680x0_ALL:
		printf("m68k\n");
		break;
	    case CPU_SUBTYPE_MC68030_ONLY:
		printf("m68030\n");
		break;
	    case CPU_SUBTYPE_MC68040:
		printf("m68040\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_MC88000:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_MC88000_ALL:
	    case CPU_SUBTYPE_MC88110:
		printf("m88k\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_I386:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_I386_ALL:
	    /* case CPU_SUBTYPE_386: same as above */
		printf("i386\n");
		break;
	    case CPU_SUBTYPE_486:
		printf("i486\n");
		break;
	    case CPU_SUBTYPE_486SX:
		printf("i486SX\n");
		break;
	    case CPU_SUBTYPE_PENT: /* same as 586 */
		printf("pentium\n");
		break;
	    case CPU_SUBTYPE_PENTPRO:
		printf("pentpro\n");
		break;
	    case CPU_SUBTYPE_PENTII_M3:
		printf("pentIIm3\n");
		break;
	    case CPU_SUBTYPE_PENTII_M5:
		printf("pentIIm5\n");
		break;
	    default:
		printf("intel x86 family %d model %d\n",
		       CPU_SUBTYPE_INTEL_FAMILY(fat_arch->cpusubtype &
						~CPU_SUBTYPE_MASK),
		       CPU_SUBTYPE_INTEL_MODEL(fat_arch->cpusubtype &
					       ~CPU_SUBTYPE_MASK));
		break;
	    }
	    break;
	case CPU_TYPE_X86_64:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_X86_64_ALL:
		printf("x86_64\n");
		break;
	    case CPU_SUBTYPE_X86_64_H:
		printf("x86_64h\n");
		break;
	    default:
		goto print_arch_unknown;
	    }		
	    break;
	case CPU_TYPE_I860:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_I860_ALL:
	    case CPU_SUBTYPE_I860_860:
		printf("i860\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_POWERPC:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_POWERPC_ALL:
		printf("ppc\n");
		break;
	    case CPU_SUBTYPE_POWERPC_601:
		printf("ppc601\n");
		break;
	    case CPU_SUBTYPE_POWERPC_602:
		printf("ppc602\n");
		break;
	    case CPU_SUBTYPE_POWERPC_603:
		printf("ppc603\n");
		break;
	    case CPU_SUBTYPE_POWERPC_603e:
		printf("ppc603e\n");
		break;
	    case CPU_SUBTYPE_POWERPC_603ev:
		printf("ppc603ev\n");
		break;
	    case CPU_SUBTYPE_POWERPC_604:
		printf("ppc604\n");
		break;
	    case CPU_SUBTYPE_POWERPC_604e:
		printf("ppc604e\n");
		break;
	    case CPU_SUBTYPE_POWERPC_620:
		printf("ppc620\n");
		break;
	    case CPU_SUBTYPE_POWERPC_750:
		printf("ppc750\n");
		break;
	    case CPU_SUBTYPE_POWERPC_7400:
		printf("ppc7400\n");
		break;
	    case CPU_SUBTYPE_POWERPC_7450:
		printf("ppc7450\n");
		break;
	    case CPU_SUBTYPE_POWERPC_970:
		printf("ppc970\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_POWERPC64:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_POWERPC_ALL:
		printf("ppc64\n");
		break;
	    case CPU_SUBTYPE_POWERPC_970:
		printf("ppc970-64\n");
		break;
	    default:
		goto print_arch_unknown;
	    }		
	    break;
	case CPU_TYPE_VEO:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_VEO_1:
		printf("veo1\n");
		break;
	    case CPU_SUBTYPE_VEO_2:
		printf("veo2\n");
		break;
	    case CPU_SUBTYPE_VEO_3:
		printf("veo3\n");
		break;
	    case CPU_SUBTYPE_VEO_4:
		printf("veo4\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_HPPA:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_HPPA_ALL:
	    case CPU_SUBTYPE_HPPA_7100LC:
		printf("hppa\n");
	    break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_SPARC:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_SPARC_ALL:
		printf("sparc\n");
	    break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_ARM:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_ARM_ALL:
		printf("arm\n");
		break;
	    case CPU_SUBTYPE_ARM_V4T:
		printf("armv4t\n");
		break;
	    case CPU_SUBTYPE_ARM_V5TEJ:
		printf("armv5\n");
		break;
	    case CPU_SUBTYPE_ARM_XSCALE:
		printf("xscale\n");
		break;
	    case CPU_SUBTYPE_ARM_V6:
		printf("armv6\n");
		break;
	    case CPU_SUBTYPE_ARM_V6M:
		printf("armv6m\n");
		break;
	    case CPU_SUBTYPE_ARM_V7:
		printf("armv7\n");
		break;
	    case CPU_SUBTYPE_ARM_V7F:
		printf("armv7f\n");
		break;
	    case CPU_SUBTYPE_ARM_V7S:
		printf("armv7s\n");
		break;
	    case CPU_SUBTYPE_ARM_V7K:
		printf("armv7k\n");
		break;
	    case CPU_SUBTYPE_ARM_V7M:
		printf("armv7m\n");
		break;
	    case CPU_SUBTYPE_ARM_V7EM:
		printf("armv7em\n");
		break;
	    default:
		goto print_arch_unknown;
		break;
	    }
	    break;
	case CPU_TYPE_ARM64:
	    switch(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_ARM64_ALL:
		printf("arm64\n");
	    break;
	    case CPU_SUBTYPE_ARM64_V8:
		printf("arm64v8\n");
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_ANY:
	    switch((int)(fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK)){
	    case CPU_SUBTYPE_MULTIPLE:
		printf("any\n");
		break;
	    case CPU_SUBTYPE_LITTLE_ENDIAN:
		printf("little\n");
		break;
	    case CPU_SUBTYPE_BIG_ENDIAN:
		printf("big\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
print_arch_unknown:
	default:
	    printf("cputype (%d) cpusubtype (%d)\n", fat_arch->cputype,
		   fat_arch->cpusubtype & ~CPU_SUBTYPE_MASK);
	    break;
	}
}

/*
 * print_cputype() helps print_fat_headers by printing the cputype and
 * cpusubtype (symbolically for the one's it knows about).
 */
static
void
print_cputype(
cpu_type_t cputype,
cpu_subtype_t cpusubtype)
{
	switch(cputype){
	case CPU_TYPE_MC680x0:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_MC680x0_ALL:
		printf("    cputype CPU_TYPE_MC680x0\n"
		       "    cpusubtype CPU_SUBTYPE_MC680x0_ALL\n");
		break;
	    case CPU_SUBTYPE_MC68030_ONLY:
		printf("    cputype CPU_TYPE_MC680x0\n"
		       "    cpusubtype CPU_SUBTYPE_MC68030_ONLY\n");
		break;
	    case CPU_SUBTYPE_MC68040:
		printf("    cputype CPU_TYPE_MC680x0\n"
		       "    cpusubtype CPU_SUBTYPE_MC68040\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_MC88000:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_MC88000_ALL:
		printf("    cputype CPU_TYPE_MC88000\n"
		       "    cpusubtype CPU_SUBTYPE_MC88000_ALL\n");
		break;
	    case CPU_SUBTYPE_MC88110:
		printf("    cputype CPU_TYPE_MC88000\n"
		       "    cpusubtype CPU_SUBTYPE_MC88110\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_I386:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_I386_ALL:
	    /* case CPU_SUBTYPE_386: same as above */
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_I386_ALL\n");
		break;
	    case CPU_SUBTYPE_486:
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_486\n");
		break;
	    case CPU_SUBTYPE_486SX:
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_486SX\n");
		break;
	    case CPU_SUBTYPE_PENT: /* same as 586 */
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_PENT\n");
		break;
	    case CPU_SUBTYPE_PENTPRO:
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_PENTPRO\n");
		break;
	    case CPU_SUBTYPE_PENTII_M3:
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_PENTII_M3\n");
		break;
	    case CPU_SUBTYPE_PENTII_M5:
		printf("    cputype CPU_TYPE_I386\n"
		       "    cpusubtype CPU_SUBTYPE_PENTII_M5\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_X86_64:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_X86_64_ALL:
		printf("    cputype CPU_TYPE_X86_64\n"
		       "    cpusubtype CPU_SUBTYPE_X86_64_ALL\n");
		break;
	    case CPU_SUBTYPE_X86_64_H:
		printf("    cputype CPU_TYPE_X86_64\n"
		       "    cpusubtype CPU_SUBTYPE_X86_64_H\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_I860:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_I860_ALL:
		printf("    cputype CPU_TYPE_I860\n"
		       "    cpusubtype CPU_SUBTYPE_I860_ALL\n");
		break;
	    case CPU_SUBTYPE_I860_860:
		printf("    cputype CPU_TYPE_I860\n"
		       "    cpusubtype CPU_SUBTYPE_I860_860\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_POWERPC:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_POWERPC_ALL:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_ALL\n");
		break;
	    case CPU_SUBTYPE_POWERPC_601:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_601\n");
		break;
	    case CPU_SUBTYPE_POWERPC_602:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_602\n");
		break;
	    case CPU_SUBTYPE_POWERPC_603:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_603\n");
		break;
	    case CPU_SUBTYPE_POWERPC_603e:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_603e\n");
		break;
	    case CPU_SUBTYPE_POWERPC_603ev:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_603ev\n");
		break;
	    case CPU_SUBTYPE_POWERPC_604:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_604\n");
		break;
	    case CPU_SUBTYPE_POWERPC_604e:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_604e\n");
		break;
	    case CPU_SUBTYPE_POWERPC_620:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_620\n");
		break;
	    case CPU_SUBTYPE_POWERPC_750:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_750\n");
		break;
	    case CPU_SUBTYPE_POWERPC_7400:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_7400\n");
		break;
	    case CPU_SUBTYPE_POWERPC_7450:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_7450\n");
		break;
	    case CPU_SUBTYPE_POWERPC_970:
		printf("    cputype CPU_TYPE_POWERPC\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_970\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_POWERPC64:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_POWERPC_ALL:
		printf("    cputype CPU_TYPE_POWERPC64\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC64_ALL\n");
		break;
	    case CPU_SUBTYPE_POWERPC_970:
		printf("    cputype CPU_TYPE_POWERPC64\n"
		       "    cpusubtype CPU_SUBTYPE_POWERPC_970\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_VEO:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_VEO_1:
		printf("    cputype CPU_TYPE_VEO\n"
		       "    cpusubtype CPU_SUBTYPE_VEO_1\n");
		break;
	    case CPU_SUBTYPE_VEO_2:
		printf("    cputype CPU_TYPE_VEO\n"
		       "    cpusubtype CPU_SUBTYPE_VEO_2\n");
		break;
	    case CPU_SUBTYPE_VEO_3:
		printf("    cputype CPU_TYPE_VEO\n"
		       "    cpusubtype CPU_SUBTYPE_VEO_3\n");
		break;
	    case CPU_SUBTYPE_VEO_4:
		printf("    cputype CPU_TYPE_VEO\n"
		       "    cpusubtype CPU_SUBTYPE_VEO_4\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_HPPA:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_HPPA_ALL:
		printf("    cputype CPU_TYPE_HPPA\n"
		       "    cpusubtype CPU_SUBTYPE_HPPA_ALL\n");
	    	break;
	    case CPU_SUBTYPE_HPPA_7100LC:
		printf("    cputype CPU_TYPE_HPPA\n"
		       "    cpusubtype CPU_SUBTYPE_HPPA_7100LC\n");
	    	break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_SPARC:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_SPARC_ALL:
		printf("    cputype CPU_TYPE_SPARC\n"
		       "    cpusubtype CPU_SUBTYPE_SPARC_ALL\n");
	    	break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_ARM:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_ARM_ALL:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_ALL\n");
		break;
	    case CPU_SUBTYPE_ARM_V4T:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V4T\n");
		break;
	    case CPU_SUBTYPE_ARM_V5TEJ:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V5TEJ\n");
		break;
	    case CPU_SUBTYPE_ARM_XSCALE:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_XSCALE\n");
		break;
	    case CPU_SUBTYPE_ARM_V6:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V6\n");
		break;
	    case CPU_SUBTYPE_ARM_V6M:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V6M\n");
		break;
	    case CPU_SUBTYPE_ARM_V7:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V7\n");
		break;
	    case CPU_SUBTYPE_ARM_V7F:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V7F\n");
		break;
	    case CPU_SUBTYPE_ARM_V7S:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V7S\n");
		break;
	    case CPU_SUBTYPE_ARM_V7K:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V7K\n");
		break;
	    case CPU_SUBTYPE_ARM_V7M:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V7M\n");
		break;
	    case CPU_SUBTYPE_ARM_V7EM:
		printf("    cputype CPU_TYPE_ARM\n"
		       "    cpusubtype CPU_SUBTYPE_ARM_V7EM\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_ARM64:
	    switch(cpusubtype & ~CPU_SUBTYPE_MASK){
	    case CPU_SUBTYPE_ARM64_ALL:
		printf("    cputype CPU_TYPE_ARM64\n"
		       "    cpusubtype CPU_SUBTYPE_ARM64_ALL\n");
	    	break;
	    case CPU_SUBTYPE_ARM64_V8:
		printf("    cputype CPU_TYPE_ARM64\n"
		       "    cpusubtype CPU_SUBTYPE_ARM64_V8\n");
	    	break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
	case CPU_TYPE_ANY:
	    switch((int)(cpusubtype & ~CPU_SUBTYPE_MASK)){
	    case CPU_SUBTYPE_MULTIPLE:
		printf("    cputype CPU_TYPE_ANY\n"
		       "    cpusubtype CPU_SUBTYPE_MULTIPLE\n");
		break;
	    case CPU_SUBTYPE_LITTLE_ENDIAN:
		printf("    cputype CPU_TYPE_ANY\n"
		       "    cpusubtype CPU_SUBTYPE_LITTLE_ENDIAN\n");
		break;
	    case CPU_SUBTYPE_BIG_ENDIAN:
		printf("    cputype CPU_TYPE_ANY\n"
		       "    cpusubtype CPU_SUBTYPE_BIG_ENDIAN\n");
		break;
	    default:
		goto print_arch_unknown;
	    }
	    break;
print_arch_unknown:
	default:
	    printf("    cputype (%d)\n"
		   "    cpusubtype (%d)\n", cputype,
			cpusubtype & ~CPU_SUBTYPE_MASK);
	    break;
	}
}

/*
 * Print the archive header.  The format is constant width character fields
 * blank padded.  So the trailing blanks are stripped and full field widths
 * are handled correctly.
 */
void
print_ar_hdr(
struct ar_hdr *ar_hdr,
char *member_name,
uint32_t member_name_size,
uint32_t member_offset,
enum bool verbose,
enum bool print_offset)
{
    int32_t i;
    uint32_t j, mode;
    time_t date;
    char *p, *endp;

    char date_buf[sizeof(ar_hdr->ar_date) + 1];
    char  uid_buf[sizeof(ar_hdr->ar_uid)  + 1];
    char  gid_buf[sizeof(ar_hdr->ar_gid)  + 1];
    char mode_buf[sizeof(ar_hdr->ar_mode) + 1];
    char size_buf[sizeof(ar_hdr->ar_size) + 1];

	memcpy(date_buf, ar_hdr->ar_date, sizeof(ar_hdr->ar_date));
	for(i = sizeof(ar_hdr->ar_date) - 1; i >= 0 && date_buf[i] == ' '; i--)
	    date_buf[i] = '\0';
	date_buf[sizeof(ar_hdr->ar_date)] = '\0';

	memcpy(uid_buf, ar_hdr->ar_uid, sizeof(ar_hdr->ar_uid));
	for(i = sizeof(ar_hdr->ar_uid) - 1; i >= 0 && uid_buf[i] == ' '; i--)
	    uid_buf[i] = '\0';
	uid_buf[sizeof(ar_hdr->ar_uid)] = '\0';

	memcpy(gid_buf, ar_hdr->ar_gid, sizeof(ar_hdr->ar_gid));
	for(i = sizeof(ar_hdr->ar_gid) - 1; i >= 0 && gid_buf[i] == ' '; i--)
	    gid_buf[i] = '\0';
	gid_buf[sizeof(ar_hdr->ar_gid)] = '\0';

	memcpy(mode_buf, ar_hdr->ar_mode, sizeof(ar_hdr->ar_mode));
	for(i = sizeof(ar_hdr->ar_mode) - 1; i >= 0 && mode_buf[i] == ' '; i--)
	    mode_buf[i] = '\0';
	mode_buf[sizeof(ar_hdr->ar_mode)] = '\0';

	memcpy(size_buf, ar_hdr->ar_size, sizeof(ar_hdr->ar_size));
	for(i = sizeof(ar_hdr->ar_size) - 1; i >= 0 && size_buf[i] == ' '; i--)
	    size_buf[i] = '\0';
	size_buf[sizeof(ar_hdr->ar_size)] = '\0';

	if(print_offset == TRUE)
	    printf("%u\t", member_offset);

	if(verbose == TRUE){
	    mode = strtoul(mode_buf, &endp, 8);
	    if(*endp != '\0')
		printf("(mode: \"%s\" contains non-octal chars) ", mode_buf);
	    switch(mode & S_IFMT){
	    case S_IFDIR:
		printf("d");
		break;
	    case S_IFCHR:
		printf("c");
		break;
	    case S_IFBLK:
		printf("b");
		break;
	    case S_IFREG:
		printf("-");
		break;
	    case S_IFLNK:
		printf("l");
		break;
	    case S_IFSOCK:
		printf("s");
		break;
	    default:
		printf("?");
		break;
	    }

	    /* owner permissions */
	    if(mode & S_IREAD)
		printf("r");
	    else
		printf("-");
	    if(mode & S_IWRITE)
		printf("w");
	    else
		printf("-");
	    if(mode & S_ISUID)
		printf("s");
	    else if(mode & S_IEXEC)
		printf("x");
	    else
		printf("-");

	    /* group permissions */
	    if(mode & (S_IREAD >> 3))
		printf("r");
	    else
		printf("-");
	    if(mode & (S_IWRITE >> 3))
		printf("w");
	    else
		printf("-");
	    if(mode & S_ISGID)
		printf("s");
	    else if(mode & (S_IEXEC >> 3))
		printf("x");
	    else
		printf("-");

	    /* other permissions */
	    if(mode & (S_IREAD >> 6))
		printf("r");
	    else
		printf("-");
	    if(mode & (S_IWRITE >> 6))
		printf("w");
	    else
		printf("-");
	    if(mode & S_ISVTX)
		printf("t");
	    else if(mode & (S_IEXEC >> 6))
		printf("x");
	    else
		printf("-");
	}
	else
	    /* printf("0%03o ", mode & 0777); */
	    printf("0%s ", mode_buf);

	printf("%3s/%-3s %5s ", uid_buf, gid_buf, size_buf);

	/*
	 * Since cime(3) returns a 26 character string of the form:
	 * "Sun Sep 16 01:03:52 1973\n\0"
	 * and the new line is not wanted a '\0' is placed there.
	 */
	if(verbose){
	    date = strtoul(date_buf, &endp, 10);
	    if(*endp != '\0')
		printf("(date: \"%s\" contains non-decimal chars) ", date_buf);
	    p = ctime(&date);
	    p[24] = '\0';
	    printf("%s ", p);
	}
	else
	    printf("%s ", date_buf);

	if(verbose){
	    printf("%.*s", (int)member_name_size, member_name);
	}
	else{
	    j = size_ar_name(ar_hdr);
	    printf("%.*s", (int)j, ar_hdr->ar_name);
	}

	if(memcmp(ar_hdr->ar_fmag, ARFMAG, sizeof(ARFMAG) - 1) == 0)
	    printf("\n");
	else
	    printf(" (ar_fmag not ARFMAG)\n");
}

/*
 * print_library_toc prints the table of contents of the a library.  It is
 * converted to the host byte sex if toc_byte_sex is not the host byte sex.
 * The problem with determing the byte sex of the table of contents is left
 * to the caller.  The determination is based on the byte sex of the object
 * files contained in the library (this can still present a problem since the
 * object files could be of differing byte sex in an erroneous library).  There
 * is no problem of a library containing no objects with respect to the byte
 * sex of the table of contents since the table of contents would be made up
 * of two binary uint32_t zeros which are the same in either byte sex.
 */
void
print_library_toc(
struct ar_hdr *toc_ar_hdr,
char *toc_name,
uint32_t toc_name_size,
char *toc_addr,
uint32_t toc_size,
enum byte_sex toc_byte_sex,
char *library_name,
char *library_addr,
uint64_t library_size,
char *arch_name,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    uint32_t ran_size, nranlibs, str_size, i, member_name_size;
    uint64_t toc_offset;
    struct ranlib *ranlibs;
    char *strings, *member_name;
    struct ar_hdr *ar_hdr;
    int n;
    char buf[20];
    uint64_t big_size;

    str_size = 0; /* cctools-port */

	host_byte_sex = get_host_byte_sex();
	toc_offset = 0;
	strings = NULL;

	if(toc_offset + sizeof(uint32_t) > toc_size){
	    error_with_arch(arch_name, "truncated table of contents in: "
		"%s(%.*s) (size of ranlib structs extends past the end of the "
		"table of contents member)", library_name, (int)toc_name_size,
		toc_name);
	    return;
	}
	memcpy((char *)&ran_size, toc_addr + toc_offset, sizeof(uint32_t));
	/*
	 * With the advent of things like LTO object files we may end up getting
	 * handed UNKNOWN_BYTE_SEX for the table of contents byte sex.  So at
	 * this point we are guessing.  A better guess is to go with the host
	 * bytesex as that is more likely.  Otherwise we will always think it is
	 * swapped.
	 */
	if(toc_byte_sex == UNKNOWN_BYTE_SEX)
	    toc_byte_sex = host_byte_sex;
	if(toc_byte_sex != host_byte_sex)
	    ran_size = SWAP_INT(ran_size);
	toc_offset += sizeof(uint32_t);

	big_size = toc_offset;
	big_size += ran_size;
	if(big_size > toc_size){
	    error_with_arch(arch_name, "truncated table of contents in: "
		"%s(%.*s) (ranlib structures extends past the end of the "
		"table of contents member)", library_name, (int)toc_name_size,
		toc_name);
	    return;
	}
	ranlibs = allocate(ran_size);
	memcpy((char *)ranlibs, toc_addr + toc_offset, ran_size);
	nranlibs = ran_size / sizeof(struct ranlib);
	if(toc_byte_sex != host_byte_sex)
	    swap_ranlib(ranlibs, nranlibs, host_byte_sex);
	toc_offset += ran_size;

	if(verbose){
	    if(toc_offset + sizeof(uint32_t) > toc_size){
		error_with_arch(arch_name, "truncated table of contents in: "
		    "%s(%.*s) (size of ranlib strings extends past the end of "
		    "the table of contents member)", library_name,
		    (int)toc_name_size, toc_name);
		free(ranlibs);
		return;
	    }
	    memcpy((char *)&str_size, toc_addr + toc_offset,
		   sizeof(uint32_t));
	    if(toc_byte_sex != host_byte_sex)
		str_size = SWAP_INT(str_size);
	    toc_offset += sizeof(uint32_t);

	    big_size = toc_offset;
	    big_size += str_size;
	    if(big_size > toc_size){
		error_with_arch(arch_name, "truncated table of contents in: "
		    "%s(%.*s) (ranlib strings extends past the end of the "
		    "table of contents member)", library_name,
		    (int)toc_name_size, toc_name);
		free(ranlibs);
		return;
	    }
	    strings = toc_addr + toc_offset;
	}

	printf("Table of contents from: %s(%.*s)", library_name,
	       (int)toc_name_size, toc_name);
	if(arch_name != NULL)
	    printf(" (for architecture %s)\n", arch_name);
	else
	    printf("\n");
	printf("size of ranlib structures: %u (number %u)\n", ran_size,
	       nranlibs);
	if(verbose){
	    printf("size of strings: %u", str_size);
	    if(str_size % sizeof(int32_t) != 0)
		printf(" (not multiple of sizeof(int32_t))\n");
	    else
		printf("\n");
	}
	if(verbose)
	    printf("object           symbol name\n");
	else
	    printf("object offset  string index\n");

	for(i = 0; i < nranlibs; i++){
	    if(verbose){
		if(ranlibs[i].ran_off + sizeof(struct ar_hdr) <= library_size){
		    ar_hdr = (struct ar_hdr *)
			     (library_addr + ranlibs[i].ran_off);
		    if(strncmp(ar_hdr->ar_name, AR_EFMT1,
			       sizeof(AR_EFMT1) - 1) == 0){
			member_name = ar_hdr->ar_name + sizeof(struct ar_hdr);
			member_name_size = strtoul(ar_hdr->ar_name +
				sizeof(AR_EFMT1) - 1, NULL, 10);
			while(member_name_size > 0 &&
			      member_name[member_name_size - 1] == '\0')
			    member_name_size--;
			printf("%-.*s ", (int)member_name_size, member_name);
			if(member_name_size < 16)
			    printf("%-.*s", (int)(16 - member_name_size),
				   "                ");
		    }
		    else{
			printf("%-.16s ", ar_hdr->ar_name);
		    }
		}
		else{
		    n = sprintf(buf, "?(%u) ", (uint32_t)ranlibs[i].ran_off);
		    printf("%s%.*s", buf, 17 - n, "              ");
		}
		if(ranlibs[i].ran_un.ran_strx < str_size)
		    printf("%s\n", strings + ranlibs[i].ran_un.ran_strx);
		else
		    printf("?(%u)\n", (uint32_t)ranlibs[i].ran_un.ran_strx);
	    }
	    else{
		printf("%-14u %u\n", (uint32_t)ranlibs[i].ran_off,
			(uint32_t)ranlibs[i].ran_un.ran_strx);
	    }
	}

	free(ranlibs);
}

/*
 * Print the mach header.  It is assumed that the parameters are in the host
 * byte sex.  In this way it is up to the caller to determine he has a
 * mach_header and what byte sex it is and get it aligned in the host byte sex
 * for the parameters to this routine.
 */
void
print_mach_header(
uint32_t magic,
cpu_type_t cputype,
cpu_subtype_t cpusubtype,
uint32_t filetype,
uint32_t ncmds,
uint32_t sizeofcmds,
uint32_t flags,
enum bool verbose)
{
    uint32_t f;

	printf("Mach header\n");
	printf("      magic cputype cpusubtype  caps    filetype ncmds "
	       "sizeofcmds      flags\n");
	if(verbose){
	    if(magic == MH_MAGIC)
		printf("%11s", "MH_MAGIC");
	    else if(magic == MH_MAGIC_64)
		printf("%11s", "MH_MAGIC_64");
	    else
		printf(" 0x%08x", (unsigned int)magic);
	    switch(cputype){
	    case CPU_TYPE_POWERPC64:
		printf("   PPC64");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_POWERPC_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_POWERPC_970:
		    printf("     ppc970");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_X86_64:
		printf("  X86_64");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_X86_64_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_X86_64_H:
		    printf("    Haswell");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_VAX:
		printf("     VAX");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_VAX780:
		    printf("     VAX780");
		    break;
		case CPU_SUBTYPE_VAX785:
		    printf("     VAX785");
		    break;
		case CPU_SUBTYPE_VAX750:
		    printf("     VAX750");
		    break;
		case CPU_SUBTYPE_VAX730:
		    printf("     VAX730");
		    break;
		case CPU_SUBTYPE_UVAXI:
		    printf("     UVAXI");
		    break;
		case CPU_SUBTYPE_UVAXII:
		    printf("     UVAXII");
		    break;
		case CPU_SUBTYPE_VAX8200:
		    printf("    VAX8200");
		    break;
		case CPU_SUBTYPE_VAX8500:
		    printf("    VAX8500");
		    break;
		case CPU_SUBTYPE_VAX8600:
		    printf("    VAX8600");
		    break;
		case CPU_SUBTYPE_VAX8650:
		    printf("    VAX8650");
		    break;
		case CPU_SUBTYPE_VAX8800:
		    printf("    VAX8800");
		    break;
		case CPU_SUBTYPE_UVAXIII:
		    printf("    UVAXIII");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_ROMP:
		printf("    ROMP");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_RT_PC:
		    printf("      RT_PC");
		    break;
		case CPU_SUBTYPE_RT_APC:
		    printf("     RT_APC");
		    break;
		case CPU_SUBTYPE_RT_135:
		    printf("     RT_135");
		    break;

		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_NS32032:
		printf(" NS32032");
		goto NS32;
	    case CPU_TYPE_NS32332:
		printf(" NS32332");
NS32:
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_MMAX_DPC:
		    printf("   MMAX_DPC");
		    break;
		case CPU_SUBTYPE_SQT:
		    printf("        SQT");
		    break;
		case CPU_SUBTYPE_MMAX_APC_FPU:
		    printf(" MMAX_APC_FPC");
		    break;
		case CPU_SUBTYPE_MMAX_APC_FPA:
		    printf(" MMAX_APC_FPA");
		    break;
		case CPU_SUBTYPE_MMAX_XPC:
		    printf("   MMAX_XPC");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_MC680x0:
		printf(" MC680x0");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_MC680x0_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_MC68030_ONLY:
		    printf("    MC68030");
		    break;
		case CPU_SUBTYPE_MC68040:
		    printf("    MC68040");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_MC88000:
		printf(" MC88000");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_MC88000_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_MC88100:
		    printf("    MC88100");
		    break;
		case CPU_SUBTYPE_MC88110:
		    printf("    MC88110");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_I860:
		printf("    I860");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_I860_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_I860_860:
		    printf("        860");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_I386:
		printf("    I386");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_I386_ALL:
		/* case CPU_SUBTYPE_386: same as above */
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_486:
		    printf("        486");
		    break;
		case CPU_SUBTYPE_486SX:
		    printf("      486SX");
		    break;
		case CPU_SUBTYPE_PENT: /* same as 586 */
		    printf("       PENT");
		    break;
		case CPU_SUBTYPE_PENTPRO:
		    printf("    PENTPRO");
		    break;
		case CPU_SUBTYPE_PENTII_M3:
		    printf("  PENTII_M3");
		    break;
		case CPU_SUBTYPE_PENTII_M5:
		    printf("  PENTII_M5");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_POWERPC:
		printf("     PPC");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_POWERPC_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_POWERPC_601:
		    printf("     ppc601");
		    break;
		case CPU_SUBTYPE_POWERPC_602:
		    printf("     ppc602");
		    break;
		case CPU_SUBTYPE_POWERPC_603:
		    printf("     ppc603");
		    break;
		case CPU_SUBTYPE_POWERPC_603e:
		    printf("    ppc603e");
		    break;
		case CPU_SUBTYPE_POWERPC_603ev:
		    printf("   ppc603ev");
		    break;
		case CPU_SUBTYPE_POWERPC_604:
		    printf("     ppc604");
		    break;
		case CPU_SUBTYPE_POWERPC_604e:
		    printf("    ppc604e");
		    break;
		case CPU_SUBTYPE_POWERPC_620:
		    printf("     ppc620");
		    break;
		case CPU_SUBTYPE_POWERPC_750:
		    printf("     ppc750");
		    break;
		case CPU_SUBTYPE_POWERPC_7400:
		    printf("    ppc7400");
		    break;
		case CPU_SUBTYPE_POWERPC_7450:
		    printf("    ppc7450");
		    break;
		case CPU_SUBTYPE_POWERPC_970:
		    printf("     ppc970");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_VEO:
		printf("     VEO");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_VEO_1:
		    printf("       veo1");
		    break;
		case CPU_SUBTYPE_VEO_2:
		    printf("       veo2");
		    break;
		case CPU_SUBTYPE_VEO_3:
		    printf("       veo3");
		    break;
		case CPU_SUBTYPE_VEO_4:
		    printf("       veo4");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_HPPA:
		printf("    HPPA");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_HPPA_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_HPPA_7100LC:
		    printf("  HPPA_7100LC");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_SPARC:
		printf("   SPARC");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_SPARC_ALL:
		    printf("        ALL");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_ARM:
		printf("     ARM");
		switch(cpusubtype){
		case CPU_SUBTYPE_ARM_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_ARM_V4T:
		    printf("        V4T");
		    break;
		case CPU_SUBTYPE_ARM_V5TEJ:
		    printf("      V5TEJ");
		    break;
		case CPU_SUBTYPE_ARM_XSCALE:
		    printf("     XSCALE");
		    break;
		case CPU_SUBTYPE_ARM_V6:
		    printf("         V6");
		    break;
		case CPU_SUBTYPE_ARM_V6M:
		    printf("        V6M");
		    break;
		case CPU_SUBTYPE_ARM_V7:
		    printf("         V7");
		    break;
		case CPU_SUBTYPE_ARM_V7F:
		    printf("        V7F");
		    break;
		case CPU_SUBTYPE_ARM_V7S:
		    printf("        V7S");
		    break;
		case CPU_SUBTYPE_ARM_V7K:
		    printf("        V7K");
		    break;
		case CPU_SUBTYPE_ARM_V7M:
		    printf("        V7M");
		    break;
		case CPU_SUBTYPE_ARM_V7EM:
		    printf("       V7EM");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    case CPU_TYPE_ARM64:
		printf("   ARM64");
		switch(cpusubtype & ~CPU_SUBTYPE_MASK){
		case CPU_SUBTYPE_ARM64_ALL:
		    printf("        ALL");
		    break;
		case CPU_SUBTYPE_ARM64_V8:
		    printf("         V8");
		    break;
		default:
		    printf(" %10d", cpusubtype & ~CPU_SUBTYPE_MASK);
		    break;
		}
		break;
	    default:
		printf(" %7d %10d", cputype, cpusubtype & ~CPU_SUBTYPE_MASK);
		break;
	    }
	    if((cpusubtype & CPU_SUBTYPE_MASK) == CPU_SUBTYPE_LIB64){
		printf(" LIB64 ");
	    }
	    else{
		printf("  0x%02x ", (unsigned int)
		       ((cpusubtype & ~CPU_SUBTYPE_MASK) >> 24));
	    }
	    switch(filetype){
	    case MH_OBJECT:
		printf("     OBJECT");
		break;
	    case MH_EXECUTE:
		printf("    EXECUTE");
		break;
	    case MH_FVMLIB:
		printf("     FVMLIB");
		break;
	    case MH_CORE:
		printf("       CORE");
		break;
	    case MH_PRELOAD:
		printf("    PRELOAD");
		break;
	    case MH_DYLIB:
		printf("      DYLIB");
		break;
	    case MH_DYLIB_STUB:
		printf(" DYLIB_STUB");
		break;
	    case MH_DYLINKER:
		printf("   DYLINKER");
		break;
	    case MH_BUNDLE:
		printf("     BUNDLE");
		break;
	    case MH_DSYM:
		printf("       DSYM");
		break;
	    case MH_KEXT_BUNDLE:
		printf(" KEXTBUNDLE");
		break;
	    default:
		printf(" %10u", filetype);
		break;
	    }
	    printf(" %5u %10u", ncmds, sizeofcmds);
	    f = flags;
	    if(f & MH_NOUNDEFS){
		printf("   NOUNDEFS");
		f &= ~MH_NOUNDEFS;
	    }
	    if(f & MH_INCRLINK){
		printf(" INCRLINK");
		f &= ~MH_INCRLINK;
	    }
	    if(f & MH_DYLDLINK){
		printf(" DYLDLINK");
		f &= ~MH_DYLDLINK;
	    }
	    if(f & MH_BINDATLOAD){
		printf(" BINDATLOAD");
		f &= ~MH_BINDATLOAD;
	    }
	    if(f & MH_PREBOUND){
		printf(" PREBOUND");
		f &= ~MH_PREBOUND;
	    }
	    if(f & MH_SPLIT_SEGS){
		printf(" SPLIT_SEGS");
		f &= ~MH_SPLIT_SEGS;
	    }
	    if(f & MH_LAZY_INIT){
		printf(" LAZY_INIT");
		f &= ~MH_LAZY_INIT;
	    }
	    if(f & MH_TWOLEVEL){
		printf(" TWOLEVEL");
		f &= ~MH_TWOLEVEL;
	    }
	    if(f & MH_FORCE_FLAT){
		printf(" FORCE_FLAT");
		f &= ~MH_FORCE_FLAT;
	    }
	    if(f & MH_NOMULTIDEFS){
		printf(" NOMULTIDEFS");
		f &= ~MH_NOMULTIDEFS;
	    }
	    if(f & MH_NOFIXPREBINDING){
		printf(" NOFIXPREBINDING");
		f &= ~MH_NOFIXPREBINDING;
	    }
	    if(f & MH_PREBINDABLE){
		printf(" PREBINDABLE");
		f &= ~MH_PREBINDABLE;
	    }
	    if(f & MH_ALLMODSBOUND){
		printf(" ALLMODSBOUND");
		f &= ~MH_ALLMODSBOUND;
	    }
	    if(f & MH_SUBSECTIONS_VIA_SYMBOLS){
		printf(" SUBSECTIONS_VIA_SYMBOLS");
		f &= ~MH_SUBSECTIONS_VIA_SYMBOLS;
	    }
	    if(f & MH_CANONICAL){
		printf(" CANONICAL");
		f &= ~MH_CANONICAL;
	    }
	    if(f & MH_WEAK_DEFINES){
		printf(" WEAK_DEFINES");
		f &= ~MH_WEAK_DEFINES;
	    }
	    if(f & MH_BINDS_TO_WEAK){
		printf(" BINDS_TO_WEAK");
		f &= ~MH_BINDS_TO_WEAK;
	    }
	    if(f & MH_ALLOW_STACK_EXECUTION){
		printf(" ALLOW_STACK_EXECUTION");
		f &= ~MH_ALLOW_STACK_EXECUTION;
	    }
	    if(f & MH_DEAD_STRIPPABLE_DYLIB){
		printf(" DEAD_STRIPPABLE_DYLIB");
		f &= ~MH_DEAD_STRIPPABLE_DYLIB;
	    }
	    if(f & MH_PIE){
		printf(" PIE");
		f &= ~MH_PIE;
	    }
	    if(f & MH_NO_REEXPORTED_DYLIBS){
		printf(" NO_REEXPORTED_DYLIBS");
		f &= ~MH_NO_REEXPORTED_DYLIBS;
	    }
	    if(f & MH_HAS_TLV_DESCRIPTORS){
		printf(" MH_HAS_TLV_DESCRIPTORS");
		f &= ~MH_HAS_TLV_DESCRIPTORS;
	    }
	    if(f & MH_NO_HEAP_EXECUTION){
		printf(" MH_NO_HEAP_EXECUTION");
		f &= ~MH_NO_HEAP_EXECUTION;
	    }
	    if(f & MH_APP_EXTENSION_SAFE){
		printf(" APP_EXTENSION_SAFE");
		f &= ~MH_APP_EXTENSION_SAFE;
	    }
	    if(f != 0 || flags == 0)
		printf(" 0x%08x", (unsigned int)f);
	    printf("\n");
	}
	else{
	    printf(" 0x%08x %7d %10d  0x%02x  %10u %5u %10u 0x%08x\n",
		   (unsigned int)magic, cputype, cpusubtype & ~CPU_SUBTYPE_MASK,
		   (unsigned int)((cpusubtype & CPU_SUBTYPE_MASK) >> 24),
		   filetype, ncmds, sizeofcmds,
		   (unsigned int)flags);
	}
}

/*
 * Print the load commands. The load commands pointed to by load_commands can
 * have any alignment, are in the specified byte_sex, and must be at least
 * sizeofcmds in length.
 */
void
print_loadcmds(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_type_t cputype,
uint32_t filetype,
enum byte_sex load_commands_byte_sex,
uint32_t object_size,
enum bool verbose,
enum bool very_verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, k, left, size, *unknown, nsyms;
    char *p, *begin, *end;
    struct load_command *lc, l;
    struct segment_command sg;
    struct section s;
    struct segment_command_64 sg64;
    struct section_64 s64;
    struct symtab_command st;
    struct dysymtab_command dyst;
    struct symseg_command ss;
    struct fvmlib_command fl;
    struct dylib_command dl;
    struct prebound_dylib_command pbdylib;
    struct sub_framework_command sub;
    struct sub_umbrella_command usub;
    struct sub_library_command lsub;
    struct sub_client_command csub;
    struct fvmfile_command ff;
    struct dylinker_command dyld;
    struct routines_command rc;
    struct routines_command_64 rc64;
    struct twolevel_hints_command hints;
    struct prebind_cksum_command cs;
    struct uuid_command uuid;
    struct linkedit_data_command ld;
    struct rpath_command rpath;
    struct encryption_info_command encrypt;
    struct encryption_info_command_64 encrypt64;
    struct linker_option_command lo;
    struct dyld_info_command dyld_info;
    struct version_min_command vd;
    struct entry_point_command ep;
    struct source_version_command sv;
    uint64_t big_load_end;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	nsyms = UINT_MAX;
	lc = load_commands;
	big_load_end = 0;
	for(i = 0 ; i < ncmds; i++){
	    printf("Load command %u\n", i);

	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    big_load_end += l.cmdsize;
	    if(big_load_end > sizeofcmds)
		printf("load command %u extends past end of load commands\n",
		       i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_SEGMENT:
		memset((char *)&sg, '\0', sizeof(struct segment_command));
		size = left < sizeof(struct segment_command) ?
		       left : sizeof(struct segment_command);
		memcpy((char *)&sg, (char *)lc, size);
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);
		print_segment_command(sg.cmd, sg.cmdsize, sg.segname,
		    sg.vmaddr, sg.vmsize, sg.fileoff, sg.filesize,
		    sg.maxprot, sg.initprot, sg.nsects, sg.flags,
		    object_size, verbose);
		p = (char *)lc + sizeof(struct segment_command);
		for(j = 0 ; j < sg.nsects ; j++){
		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds){
			printf("section structure command extends past end of "
			       "load commands\n");
		    }
		    left = sizeofcmds - (p - (char *)load_commands);
		    memset((char *)&s, '\0', sizeof(struct section));
		    size = left < sizeof(struct section) ?
			   left : sizeof(struct section);
		    memcpy((char *)&s, p, size);
		    if(swapped)
			swap_section(&s, 1, host_byte_sex);
		    print_section(s.sectname, s.segname, s.addr, s.size,
			s.offset, s.align, s.reloff, s.nreloc, s.flags,
			s.reserved1, s.reserved2, sg.cmd, sg.segname,
			filetype, object_size, verbose);
		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds)
			return;
		    p += size;
		}
		break;

	    case LC_SEGMENT_64:
		memset((char *)&sg64, '\0', sizeof(struct segment_command_64));
		size = left < sizeof(struct segment_command_64) ?
		       left : sizeof(struct segment_command_64);
		memcpy((char *)&sg64, (char *)lc, size);
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);
		print_segment_command(sg64.cmd, sg64.cmdsize, sg64.segname,
		    sg64.vmaddr, sg64.vmsize, sg64.fileoff, sg64.filesize,
		    sg64.maxprot, sg64.initprot, sg64.nsects, sg64.flags,
		    object_size, verbose);
		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    if(p + sizeof(struct section_64) >
		       (char *)load_commands + sizeofcmds){
			printf("section structure command extends past end of "
			       "load commands\n");
		    }
		    left = sizeofcmds - (p - (char *)load_commands);
		    memset((char *)&s64, '\0', sizeof(struct section_64));
		    size = left < sizeof(struct section_64) ?
			   left : sizeof(struct section_64);
		    memcpy((char *)&s64, p, size);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);
		    print_section(s64.sectname, s64.segname, s64.addr,
			s64.size, s64.offset, s64.align, s64.reloff,
			s64.nreloc, s64.flags, s64.reserved1, s64.reserved2,
			sg64.cmd, sg64.segname, filetype, object_size,
			verbose);
		    if(p + sizeof(struct section_64) >
		       (char *)load_commands + sizeofcmds)
			return;
		    p += size;
		}
		break;

	    case LC_SYMTAB:
		memset((char *)&st, '\0', sizeof(struct symtab_command));
		size = left < sizeof(struct symtab_command) ?
		       left : sizeof(struct symtab_command);
		memcpy((char *)&st, (char *)lc, size);
		if(swapped)
		    swap_symtab_command(&st, host_byte_sex);
		nsyms = st.nsyms;
		print_symtab_command(&st, cputype, object_size);
		break;

	    case LC_DYSYMTAB:
		memset((char *)&dyst, '\0', sizeof(struct dysymtab_command));
		size = left < sizeof(struct dysymtab_command) ?
		       left : sizeof(struct dysymtab_command);
		memcpy((char *)&dyst, (char *)lc, size);
		if(swapped)
		    swap_dysymtab_command(&dyst, host_byte_sex);
		print_dysymtab_command(&dyst, nsyms, object_size, cputype);
		break;

	    case LC_SYMSEG:
		memset((char *)&ss, '\0', sizeof(struct symseg_command));
		size = left < sizeof(struct symseg_command) ?
		       left : sizeof(struct symseg_command);
		memcpy((char *)&ss, (char *)lc, size);
		if(swapped)
		    swap_symseg_command(&ss, host_byte_sex);
		print_symseg_command(&ss, object_size);
		break;

	    case LC_IDFVMLIB:
	    case LC_LOADFVMLIB:
		memset((char *)&fl, '\0', sizeof(struct fvmlib_command));
		size = left < sizeof(struct fvmlib_command) ?
		       left : sizeof(struct fvmlib_command);
		memcpy((char *)&fl, (char *)lc, size);
		if(swapped)
		    swap_fvmlib_command(&fl, host_byte_sex);
		print_fvmlib_command(&fl, lc);
		break;

	    case LC_ID_DYLIB:
	    case LC_LOAD_DYLIB:
	    case LC_LOAD_WEAK_DYLIB:
	    case LC_REEXPORT_DYLIB:
	    case LC_LOAD_UPWARD_DYLIB:
	    case LC_LAZY_LOAD_DYLIB:
		memset((char *)&dl, '\0', sizeof(struct dylib_command));
		size = left < sizeof(struct dylib_command) ?
		       left : sizeof(struct dylib_command);
		memcpy((char *)&dl, (char *)lc, size);
		if(swapped)
		    swap_dylib_command(&dl, host_byte_sex);
		print_dylib_command(&dl, lc);
		break;

	    case LC_SUB_FRAMEWORK:
		memset((char *)&sub, '\0',sizeof(struct sub_framework_command));
		size = left < sizeof(struct sub_framework_command) ?
		       left : sizeof(struct sub_framework_command);
		memcpy((char *)&sub, (char *)lc, size);
		if(swapped)
		    swap_sub_framework_command(&sub, host_byte_sex);
		print_sub_framework_command(&sub, lc);
		break;

	    case LC_SUB_UMBRELLA:
		memset((char *)&usub, '\0',sizeof(struct sub_umbrella_command));
		size = left < sizeof(struct sub_umbrella_command) ?
		       left : sizeof(struct sub_umbrella_command);
		memcpy((char *)&usub, (char *)lc, size);
		if(swapped)
		    swap_sub_umbrella_command(&usub, host_byte_sex);
		print_sub_umbrella_command(&usub, lc);
		break;

	    case LC_SUB_LIBRARY:
		memset((char *)&lsub, '\0',sizeof(struct sub_library_command));
		size = left < sizeof(struct sub_library_command) ?
		       left : sizeof(struct sub_library_command);
		memcpy((char *)&lsub, (char *)lc, size);
		if(swapped)
		    swap_sub_library_command(&lsub, host_byte_sex);
		print_sub_library_command(&lsub, lc);
		break;

	    case LC_SUB_CLIENT:
		memset((char *)&csub, '\0',sizeof(struct sub_client_command));
		size = left < sizeof(struct sub_client_command) ?
		       left : sizeof(struct sub_client_command);
		memcpy((char *)&csub, (char *)lc, size);
		if(swapped)
		    swap_sub_client_command(&csub, host_byte_sex);
		print_sub_client_command(&csub, lc);
		break;

	    case LC_PREBOUND_DYLIB:
		memset((char *)&pbdylib, '\0',
			sizeof(struct prebound_dylib_command));
		size = left < sizeof(struct prebound_dylib_command) ?
		       left : sizeof(struct prebound_dylib_command);
		memcpy((char *)&pbdylib, (char *)lc, size);
		if(swapped)
		    swap_prebound_dylib_command(&pbdylib, host_byte_sex);
		print_prebound_dylib_command(&pbdylib, lc, very_verbose);
		break;

	    case LC_ID_DYLINKER:
	    case LC_LOAD_DYLINKER:
	    case LC_DYLD_ENVIRONMENT:
		memset((char *)&dyld, '\0', sizeof(struct dylinker_command));
		size = left < sizeof(struct dylinker_command) ?
		       left : sizeof(struct dylinker_command);
		memcpy((char *)&dyld, (char *)lc, size);
		if(swapped)
		    swap_dylinker_command(&dyld, host_byte_sex);
		print_dylinker_command(&dyld, lc);
		break;

	    case LC_FVMFILE:
		memset((char *)&ff, '\0', sizeof(struct fvmfile_command));
		size = left < sizeof(struct fvmfile_command) ?
		       left : sizeof(struct fvmfile_command);
		memcpy((char *)&ff, (char *)lc, size);
		if(swapped)
		    swap_fvmfile_command(&ff, host_byte_sex);
		print_fvmfile_command(&ff, lc);
		break;

	    case LC_UNIXTHREAD:
	    case LC_THREAD:
	        if(l.cmd == LC_UNIXTHREAD)
		    printf("        cmd LC_UNIXTHREAD\n");
		else
		    printf("        cmd LC_THREAD\n");
		printf("    cmdsize %u\n", l.cmdsize);

		if(left <= sizeof(struct thread_command))
		    break;
		begin = (char *)lc + sizeof(struct thread_command);
		if(left >= l.cmdsize)
		    end = (char *)lc + l.cmdsize;
		else
		    end = (char *)lc + left;
		print_thread_states(begin, end, cputype,
				    load_commands_byte_sex);
		break;

	    case LC_IDENT:
		printf("          cmd LC_IDENT\n");
		printf("      cmdsize %u", l.cmdsize);
		if(l.cmdsize < sizeof(struct ident_command))
		    printf(" Incorrect size\n");
		else
		    printf("\n");
		begin = (char *)lc + sizeof(struct ident_command);
		left -= sizeof(struct ident_command);
		if(left >= l.cmdsize)
		    end = (char *)lc + l.cmdsize;
		else
		    end = (char *)lc + left;

		p = ((char *)lc) + sizeof(struct ident_command);
		while(begin < end){
		    if(*begin == '\0'){
			begin++;
			continue;
		    }
		    for(j = 0; begin + j < end && begin[j] != '\0'; j++)
			;
		    printf(" ident string %.*s\n", (int)j, begin);
		    begin += j;
		}
		break;

	    case LC_ROUTINES:
		memset((char *)&rc, '\0', sizeof(struct routines_command));
		size = left < sizeof(struct routines_command) ?
		       left : sizeof(struct routines_command);
		memcpy((char *)&rc, (char *)lc, size);
		if(swapped)
		    swap_routines_command(&rc, host_byte_sex);
		print_routines_command(&rc);
		break;

	    case LC_ROUTINES_64:
		memset((char *)&rc64, '\0', sizeof(struct routines_command_64));
		size = left < sizeof(struct routines_command_64) ?
		       left : sizeof(struct routines_command_64);
		memcpy((char *)&rc64, (char *)lc, size);
		if(swapped)
		    swap_routines_command_64(&rc64, host_byte_sex);
		print_routines_command_64(&rc64);
		break;

	    case LC_TWOLEVEL_HINTS:
		memset((char *)&hints, '\0',
		       sizeof(struct twolevel_hints_command));
		size = left < sizeof(struct twolevel_hints_command) ?
		       left : sizeof(struct twolevel_hints_command);
		memcpy((char *)&hints, (char *)lc, size);
		if(swapped)
		    swap_twolevel_hints_command(&hints, host_byte_sex);
		print_twolevel_hints_command(&hints, object_size);
		break;

	    case LC_PREBIND_CKSUM:
		memset((char *)&cs, '\0', sizeof(struct prebind_cksum_command));
		size = left < sizeof(struct prebind_cksum_command) ?
		       left : sizeof(struct prebind_cksum_command);
		memcpy((char *)&cs, (char *)lc, size);
		if(swapped)
		    swap_prebind_cksum_command(&cs, host_byte_sex);
		print_prebind_cksum_command(&cs);
		break;

	    case LC_UUID:
		memset((char *)&uuid, '\0', sizeof(struct uuid_command));
		size = left < sizeof(struct uuid_command) ?
		       left : sizeof(struct uuid_command);
		memcpy((char *)&uuid, (char *)lc, size);
		if(swapped)
		    swap_uuid_command(&uuid, host_byte_sex);
		print_uuid_command(&uuid);
		break;

	    case LC_CODE_SIGNATURE:
	    case LC_SEGMENT_SPLIT_INFO:
	    case LC_FUNCTION_STARTS:
	    case LC_DATA_IN_CODE:
	    case LC_DYLIB_CODE_SIGN_DRS:
	    case LC_LINKER_OPTIMIZATION_HINT:
		memset((char *)&ld, '\0', sizeof(struct linkedit_data_command));
		size = left < sizeof(struct linkedit_data_command) ?
		       left : sizeof(struct linkedit_data_command);
		memcpy((char *)&ld, (char *)lc, size);
		if(swapped)
		    swap_linkedit_data_command(&ld, host_byte_sex);
		print_linkedit_data_command(&ld, object_size);
		break;

	    case LC_RPATH:
		memset((char *)&rpath, '\0', sizeof(struct rpath_command));
		size = left < sizeof(struct rpath_command) ?
		       left : sizeof(struct rpath_command);
		memcpy((char *)&rpath, (char *)lc, size);
		if(swapped)
		    swap_rpath_command(&rpath, host_byte_sex);
		print_rpath_command(&rpath, lc);
		break;

	    case LC_ENCRYPTION_INFO:
		memset((char *)&encrypt, '\0',
		       sizeof(struct encryption_info_command));
		size = left < sizeof(struct encryption_info_command) ?
		       left : sizeof(struct encryption_info_command);
		memcpy((char *)&encrypt, (char *)lc, size);
		if(swapped)
		    swap_encryption_command(&encrypt, host_byte_sex);
		print_encryption_info_command(&encrypt, object_size);
		break;

	    case LC_ENCRYPTION_INFO_64:
		memset((char *)&encrypt64, '\0',
		       sizeof(struct encryption_info_command_64));
		size = left < sizeof(struct encryption_info_command_64) ?
		       left : sizeof(struct encryption_info_command_64);
		memcpy((char *)&encrypt64, (char *)lc, size);
		if(swapped)
		    swap_encryption_command_64(&encrypt64, host_byte_sex);
		print_encryption_info_command_64(&encrypt64, object_size);
		break;

	    case LC_LINKER_OPTION:
		memset((char *)&lo, '\0',
		       sizeof(struct linker_option_command));
		size = left < sizeof(struct linker_option_command) ?
		       left : sizeof(struct linker_option_command);
		memcpy((char *)&lo, (char *)lc, size);
		if(swapped)
		    swap_linker_option_command(&lo, host_byte_sex);
		print_linker_option_command(&lo, lc);
		break;

	    case LC_DYLD_INFO:
	    case LC_DYLD_INFO_ONLY:
		memset((char *)&dyld_info, '\0',
		       sizeof(struct dyld_info_command));
		size = left < sizeof(struct dyld_info_command) ?
		       left : sizeof(struct dyld_info_command);
		memcpy((char *)&dyld_info, (char *)lc, size);
		if(swapped)
		    swap_dyld_info_command(&dyld_info, host_byte_sex);
		print_dyld_info_info_command(&dyld_info, object_size);
		break;

	    case LC_VERSION_MIN_MACOSX:
	    case LC_VERSION_MIN_IPHONEOS:
	    case LC_VERSION_MIN_WATCHOS:
		memset((char *)&vd, '\0', sizeof(struct version_min_command));
		size = left < sizeof(struct version_min_command) ?
		       left : sizeof(struct version_min_command);
		memcpy((char *)&vd, (char *)lc, size);
		if(swapped)
		    swap_version_min_command(&vd, host_byte_sex);
		print_version_min_command(&vd);
		break;

	    case LC_SOURCE_VERSION:
		memset((char *)&sv, '\0',sizeof(struct source_version_command));
		size = left < sizeof(struct source_version_command) ?
		       left : sizeof(struct source_version_command);
		memcpy((char *)&sv, (char *)lc, size);
		if(swapped)
		    swap_source_version_command(&sv, host_byte_sex);
		print_source_version_command(&sv);
		break;

	    case LC_MAIN:
		memset((char *)&ep, '\0', sizeof(struct entry_point_command));
		size = left < sizeof(struct entry_point_command) ?
		       left : sizeof(struct entry_point_command);
		memcpy((char *)&ep, (char *)lc, size);
		if(swapped)
		    swap_entry_point_command(&ep, host_byte_sex);
		print_entry_point_command(&ep);
		break;

	    default:
		printf("      cmd ?(0x%08x) Unknown load command\n",
		       (unsigned int)l.cmd);
		printf("  cmdsize %u\n", l.cmdsize);
		if(left < sizeof(struct load_command))
		    return;
		left -= sizeof(struct load_command);
		size = left < l.cmdsize - sizeof(struct load_command) ?
		       left : l.cmdsize - sizeof(struct load_command);
		unknown = allocate(size);
		memcpy((char *)unknown,
		       ((char *)lc) + sizeof(struct load_command), size);
		if(swapped)
		    for(j = 0; j < size / sizeof(uint32_t); j++)
			unknown[j] = SWAP_INT(unknown[j]);
		for(j = 0; j < size / sizeof(uint32_t); j += k){
		    for(k = 0;
			k < 8 && j + k < size / sizeof(uint32_t);
			k++)
			printf("%08x ", (unsigned int)unknown[j + k]);
		    printf("\n");
		}
		break;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		return;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		return;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");
}

void
print_libraries(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
enum bool just_id,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, left, size;
    struct load_command *lc, l;
    struct fvmlib_command fl;
    struct dylib_command dl;
    char *p;
    time_t timestamp;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	lc = load_commands;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize > (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load commands\n",
		       i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_IDFVMLIB:
	    case LC_LOADFVMLIB:
		if(just_id == TRUE)
		    break;
		memset((char *)&fl, '\0', sizeof(struct fvmlib_command));
		size = left < sizeof(struct fvmlib_command) ?
		       left : sizeof(struct fvmlib_command);
		memcpy((char *)&fl, (char *)lc, size);
		if(swapped)
		    swap_fvmlib_command(&fl, host_byte_sex);
		if(fl.fvmlib.name.offset < fl.cmdsize){
		    p = (char *)lc + fl.fvmlib.name.offset;
		    printf("\t%s (minor version %u)\n", p,
			   fl.fvmlib.minor_version);
		}
		else{
		    printf("\tBad offset (%u) for name of %s command %u\n",
			   fl.fvmlib.name.offset, l.cmd == LC_IDFVMLIB ?
			   "LC_IDFVMLIB" : "LC_LOADFVMLIB" , i);
		}
		break;

	    case LC_LOAD_DYLIB:
	    case LC_LOAD_WEAK_DYLIB:
	    case LC_REEXPORT_DYLIB:
	    case LC_LOAD_UPWARD_DYLIB:
	    case LC_LAZY_LOAD_DYLIB:
		if(just_id == TRUE)
		    break;
	    case LC_ID_DYLIB:
		memset((char *)&dl, '\0', sizeof(struct dylib_command));
		size = left < sizeof(struct dylib_command) ?
		       left : sizeof(struct dylib_command);
		memcpy((char *)&dl, (char *)lc, size);
		if(swapped)
		    swap_dylib_command(&dl, host_byte_sex);
		if(dl.dylib.name.offset < dl.cmdsize){
		    p = (char *)lc + dl.dylib.name.offset;
		    if(just_id == TRUE)
			printf("%s\n", p);
		    else
			printf("\t%s (compatibility version %u.%u.%u, "
			   "current version %u.%u.%u)\n", p,
			   dl.dylib.compatibility_version >> 16,
			   (dl.dylib.compatibility_version >> 8) & 0xff,
			   dl.dylib.compatibility_version & 0xff,
			   dl.dylib.current_version >> 16,
			   (dl.dylib.current_version >> 8) & 0xff,
			   dl.dylib.current_version & 0xff);
		    if(verbose){
			printf("\ttime stamp %u ", dl.dylib.timestamp);
			timestamp = (time_t)dl.dylib.timestamp;
			printf("%s", ctime(&timestamp));
		    }
		}
		else{
		    printf("\tBad offset (%u) for name of ",
			   dl.dylib.name.offset);
		    if(l.cmd == LC_ID_DYLIB)
			printf("LC_ID_DYLIB ");
		    else if(l.cmd == LC_LOAD_DYLIB)
			printf("LC_LOAD_DYLIB ");
		    else if(l.cmd == LC_LOAD_WEAK_DYLIB)
			printf("LC_LOAD_WEAK_DYLIB ");
		    else if(l.cmd == LC_LAZY_LOAD_DYLIB)
			printf("LC_LAZY_LOAD_DYLIB ");
		    else if(l.cmd == LC_REEXPORT_DYLIB)
			printf("LC_REEXPORT_DYLIB ");
		    else if(l.cmd == LC_LOAD_UPWARD_DYLIB)
			printf("LC_LOAD_UPWARD_DYLIB ");
		    else
			printf("LC_??? ");
		    printf("command %u\n", i);
		}
		break;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		return;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		return;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");
}

/*
 * print an LC_SEGMENT command.  The fields of the segment_command must
 * be in the host byte sex.
 */
void
print_segment_command(
uint32_t cmd,
uint32_t cmdsize,
char *segname,
uint64_t vmaddr,
uint64_t vmsize,
uint64_t fileoff,
uint64_t filesize,
vm_prot_t maxprot,
vm_prot_t initprot,
uint32_t nsects,
uint32_t flags,
uint32_t object_size,
enum bool verbose)
{
    uint64_t expected_cmdsize;

	if(cmd == LC_SEGMENT){
	    printf("      cmd LC_SEGMENT\n");
	    expected_cmdsize = nsects;
	    expected_cmdsize *= sizeof(struct section);
	    expected_cmdsize += sizeof(struct segment_command);
	}
	else{
	    printf("      cmd LC_SEGMENT_64\n");
	    expected_cmdsize = nsects;
	    expected_cmdsize *= sizeof(struct section_64);
	    expected_cmdsize += sizeof(struct segment_command_64);
	}
	printf("  cmdsize %u", cmdsize);
	if(cmdsize != expected_cmdsize)
	    printf(" Inconsistent size\n");
	else
	    printf("\n");
	printf("  segname %.16s\n", segname);
	if(cmd == LC_SEGMENT_64){
	    printf("   vmaddr 0x%016llx\n", vmaddr);
	    printf("   vmsize 0x%016llx\n", vmsize);
	}
	else{
	    printf("   vmaddr 0x%08x\n", (uint32_t)vmaddr);
	    printf("   vmsize 0x%08x\n", (uint32_t)vmsize);
	}
	printf("  fileoff %llu", fileoff);
	if(fileoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf(" filesize %llu", filesize);
	if(fileoff + filesize > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	if(verbose){
	    if((maxprot &
	      ~(VM_PROT_READ  | VM_PROT_WRITE  | VM_PROT_EXECUTE)) != 0)
		printf("  maxprot ?(0x%08x)\n", (unsigned int)maxprot);
	    else{
		if(maxprot & VM_PROT_READ)
		    printf("  maxprot r");
		else
		    printf("  maxprot -");
		if(maxprot & VM_PROT_WRITE)
		    printf("w");
		else
		    printf("-");
		if(maxprot & VM_PROT_EXECUTE)
		    printf("x\n");
		else
		    printf("-\n");
	    }
	    if((initprot &
	      ~(VM_PROT_READ  | VM_PROT_WRITE  | VM_PROT_EXECUTE)) != 0)
		printf(" initprot ?(0x%08x)\n", (unsigned int)initprot);
	    else{
		if(initprot & VM_PROT_READ)
		    printf(" initprot r");
		else
		    printf(" initprot -");
		if(initprot & VM_PROT_WRITE)
		    printf("w");
		else
		    printf("-");
		if(initprot & VM_PROT_EXECUTE)
		    printf("x\n");
		else
		    printf("-\n");
	    }
	}
	else{
	    printf("  maxprot 0x%08x\n", (unsigned int)maxprot);
	    printf(" initprot 0x%08x\n", (unsigned int)initprot);
	}
	printf("   nsects %u\n", nsects);
	if(verbose){
	    printf("    flags");
	    if(flags == 0)
		printf(" (none)\n");
	    else{
		if(flags & SG_HIGHVM){
		    printf(" HIGHVM");
		    flags &= ~SG_HIGHVM;
		}
		if(flags & SG_FVMLIB){
		    printf(" FVMLIB");
		    flags &= ~SG_FVMLIB;
		}
		if(flags & SG_NORELOC){
		    printf(" NORELOC");
		    flags &= ~SG_NORELOC;
		}
		if(flags & SG_PROTECTED_VERSION_1){
		    printf(" PROTECTED_VERSION_1");
		    flags &= ~SG_PROTECTED_VERSION_1;
		}
		if(flags)
		    printf(" 0x%x (unknown flags)\n", (unsigned int)flags);
		else
		    printf("\n");
	    }
	}
	else{
	    printf("    flags 0x%x\n", (unsigned int)flags);
	}
}

/*
 * print a section structure.  All parameters must be in the host byte sex.
 */
void
print_section(
char *sectname,
char *segname,
uint64_t addr,
uint64_t size,
uint32_t offset,
uint32_t align,
uint32_t reloff,
uint32_t nreloc,
uint32_t flags,
uint32_t reserved1,
uint32_t reserved2,
uint32_t cmd,
char *sg_segname,
uint32_t filetype,
uint32_t object_size,
enum bool verbose)
{
    uint32_t section_type, section_attributes;

	printf("Section\n");
	printf("  sectname %.16s\n", sectname);
	printf("   segname %.16s", segname);
	if(filetype != MH_OBJECT &&
	   strcmp(sg_segname, segname) != 0)
	    printf(" (does not match segment)\n");
	else
	    printf("\n");
	if(cmd == LC_SEGMENT_64){
	    printf("      addr 0x%016llx\n", addr);
	    printf("      size 0x%016llx", size);
	}
	else{
	    printf("      addr 0x%08x\n", (uint32_t)addr);
	    printf("      size 0x%08x", (uint32_t)size);
	}
	if((flags & S_ZEROFILL) != S_ZEROFILL && offset + size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    offset %u", offset);
	if(offset > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("     align 2^%u (%d)\n", align, 1 << align);
	printf("    reloff %u", reloff);
	if(reloff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    nreloc %u", nreloc);
	if(reloff + nreloc * sizeof(struct relocation_info) > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	section_type = flags & SECTION_TYPE;
	if(verbose){
	    printf("      type");
	    if(section_type == S_REGULAR)
		printf(" S_REGULAR\n");
	    else if(section_type == S_ZEROFILL)
		printf(" S_ZEROFILL\n");
	    else if(section_type == S_CSTRING_LITERALS)
		printf(" S_CSTRING_LITERALS\n");
	    else if(section_type == S_4BYTE_LITERALS)
		printf(" S_4BYTE_LITERALS\n");
	    else if(section_type == S_8BYTE_LITERALS)
		printf(" S_8BYTE_LITERALS\n");
	    else if(section_type == S_16BYTE_LITERALS)
		printf(" S_16BYTE_LITERALS\n");
	    else if(section_type == S_LITERAL_POINTERS)
		printf(" S_LITERAL_POINTERS\n");
	    else if(section_type == S_NON_LAZY_SYMBOL_POINTERS)
		printf(" S_NON_LAZY_SYMBOL_POINTERS\n");
	    else if(section_type == S_LAZY_SYMBOL_POINTERS)
		printf(" S_LAZY_SYMBOL_POINTERS\n");
	    else if(section_type == S_SYMBOL_STUBS)
		printf(" S_SYMBOL_STUBS\n");
	    else if(section_type == S_MOD_INIT_FUNC_POINTERS)
		printf(" S_MOD_INIT_FUNC_POINTERS\n");
	    else if(section_type == S_MOD_TERM_FUNC_POINTERS)
		printf(" S_MOD_TERM_FUNC_POINTERS\n");
	    else if(section_type == S_COALESCED)
		printf(" S_COALESCED\n");
	    else if(section_type == S_INTERPOSING)
		printf(" S_INTERPOSING\n");
	    else if(section_type == S_DTRACE_DOF)
		printf(" S_DTRACE_DOF\n");
	    else if(section_type == S_LAZY_DYLIB_SYMBOL_POINTERS)
		printf(" S_LAZY_DYLIB_SYMBOL_POINTERS\n");
	    else if(section_type == S_THREAD_LOCAL_REGULAR)
		printf(" S_THREAD_LOCAL_REGULAR\n");
	    else if(section_type == S_THREAD_LOCAL_ZEROFILL)
		printf(" S_THREAD_LOCAL_ZEROFILL\n");
	    else if(section_type == S_THREAD_LOCAL_VARIABLES)
		printf(" S_THREAD_LOCAL_VARIABLES\n");
	    else if(section_type == S_THREAD_LOCAL_VARIABLE_POINTERS)
		printf(" S_THREAD_LOCAL_VARIABLE_POINTERS\n");
	    else if(section_type == S_THREAD_LOCAL_INIT_FUNCTION_POINTERS)
		printf(" S_THREAD_LOCAL_INIT_FUNCTION_POINTERS\n");
	    else
		printf(" 0x%08x\n", (unsigned int)section_type);

	    printf("attributes");
	    section_attributes = flags & SECTION_ATTRIBUTES;
	    if(section_attributes & S_ATTR_PURE_INSTRUCTIONS)
		printf(" PURE_INSTRUCTIONS");
	    if(section_attributes & S_ATTR_NO_TOC)
		printf(" NO_TOC");
	    if(section_attributes & S_ATTR_STRIP_STATIC_SYMS)
		printf(" STRIP_STATIC_SYMS");
	    if(section_attributes & S_ATTR_NO_DEAD_STRIP)
		printf(" NO_DEAD_STRIP");
	    if(section_attributes & S_ATTR_LIVE_SUPPORT)
		printf(" LIVE_SUPPORT");
	    if(section_attributes & S_ATTR_SELF_MODIFYING_CODE)
		printf(" SELF_MODIFYING_CODE");
	    if(section_attributes & S_ATTR_DEBUG)
		printf(" DEBUG");
	    if(section_attributes & S_ATTR_SOME_INSTRUCTIONS)
		printf(" SOME_INSTRUCTIONS");
	    if(section_attributes & S_ATTR_EXT_RELOC)
		printf(" EXT_RELOC");
	    if(section_attributes & S_ATTR_LOC_RELOC)
		printf(" LOC_RELOC");
	    if(section_attributes == 0)
		printf(" (none)");
	    printf("\n");
	}
	else
	    printf("     flags 0x%08x\n", (unsigned int)flags);
	printf(" reserved1 %u", reserved1);
	if(section_type == S_SYMBOL_STUBS ||
	   section_type == S_LAZY_SYMBOL_POINTERS ||
	   section_type == S_LAZY_DYLIB_SYMBOL_POINTERS ||
	   section_type == S_NON_LAZY_SYMBOL_POINTERS ||
	   section_type == S_THREAD_LOCAL_VARIABLE_POINTERS)
	    printf(" (index into indirect symbol table)\n");
	else
	    printf("\n");
	printf(" reserved2 %u", reserved2);
	if(section_type == S_SYMBOL_STUBS)
	    printf(" (size of stubs)\n");
	else
	    printf("\n");
}

/*
 * print an LC_SYMTAB command.  The symtab_command structure specified must
 * be aligned correctly and in the host byte sex.
 */
void
print_symtab_command(
struct symtab_command *st,
cpu_type_t cputype,
uint32_t object_size)
{
    uint64_t big_size;

	printf("     cmd LC_SYMTAB\n");
	printf(" cmdsize %u", st->cmdsize);
	if(st->cmdsize != sizeof(struct symtab_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("  symoff %u", st->symoff);
	if(st->symoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("   nsyms %u", st->nsyms);
	if(cputype & CPU_ARCH_ABI64){
	    big_size = st->nsyms;
	    big_size *= sizeof(struct nlist_64);
	    big_size += st->symoff;
	    if(big_size > object_size)
		printf(" (past end of file)\n");
	    else
		printf("\n");
	}
	else{
	    big_size = st->nsyms;
	    big_size *= sizeof(struct nlist);
	    big_size += st->symoff;
	    if(big_size > object_size)
		printf(" (past end of file)\n");
	    else
		printf("\n");
	}
	printf("  stroff %u", st->stroff);
	if(st->stroff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf(" strsize %u", st->strsize);
	big_size = st->stroff;
	big_size += st->strsize;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
}

/*
 * print an LC_DYSYMTAB command.  The dysymtab_command structure specified must
 * be aligned correctly and in the host byte sex.
 */
void
print_dysymtab_command(
struct dysymtab_command *dyst,
uint32_t nsyms,
uint32_t object_size,
cpu_type_t cputype)
{
    uint64_t modtabend, big_size;

	printf("            cmd LC_DYSYMTAB\n");
	printf("        cmdsize %u", dyst->cmdsize);
	if(dyst->cmdsize != sizeof(struct dysymtab_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");

	printf("      ilocalsym %u", dyst->ilocalsym);
	if(dyst->ilocalsym > nsyms)
	    printf(" (greater than the number of symbols)\n");
	else
	    printf("\n");
	printf("      nlocalsym %u", dyst->nlocalsym);
	big_size = dyst->ilocalsym;
	big_size += dyst->nlocalsym;
	if(big_size > nsyms)
	    printf(" (past the end of the symbol table)\n");
	else
	    printf("\n");
	printf("     iextdefsym %u", dyst->iextdefsym);
	if(dyst->iextdefsym > nsyms)
	    printf(" (greater than the number of symbols)\n");
	else
	    printf("\n");
	printf("     nextdefsym %u", dyst->nextdefsym);
	big_size = dyst->iextdefsym;
	big_size += dyst->nextdefsym;
	if(big_size > nsyms)
	    printf(" (past the end of the symbol table)\n");
	else
	    printf("\n");
	printf("      iundefsym %u", dyst->iundefsym);
	if(dyst->iundefsym > nsyms)
	    printf(" (greater than the number of symbols)\n");
	else
	    printf("\n");
	printf("      nundefsym %u", dyst->nundefsym);
	big_size = dyst->iundefsym;
	big_size += dyst->nundefsym;
	if(big_size > nsyms)
	    printf(" (past the end of the symbol table)\n");
	else
	    printf("\n");
	printf("         tocoff %u", dyst->tocoff);
	if(dyst->tocoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("           ntoc %u", dyst->ntoc);
	big_size = dyst->ntoc;
	big_size *= sizeof(struct dylib_table_of_contents);
	big_size += dyst->tocoff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("      modtaboff %u", dyst->modtaboff);
	if(dyst->modtaboff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("        nmodtab %u", dyst->nmodtab);
	if(cputype & CPU_ARCH_ABI64){
	    modtabend = dyst->nmodtab;
	    modtabend *= sizeof(struct dylib_module_64);
	    modtabend += dyst->modtaboff;
	}
	else{
	    modtabend = dyst->nmodtab;
	    modtabend *= sizeof(struct dylib_module);
	    modtabend += dyst->modtaboff;
	}
	if(modtabend > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("   extrefsymoff %u", dyst->extrefsymoff);
	if(dyst->extrefsymoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    nextrefsyms %u", dyst->nextrefsyms);
	big_size = dyst->nextrefsyms;
	big_size *= sizeof(struct dylib_reference);
	big_size += dyst->extrefsymoff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf(" indirectsymoff %u", dyst->indirectsymoff);
	if(dyst->indirectsymoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("  nindirectsyms %u", dyst->nindirectsyms);
	big_size = dyst->nindirectsyms;
	big_size *= sizeof(uint32_t);
	big_size += dyst->indirectsymoff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("      extreloff %u", dyst->extreloff);
	if(dyst->extreloff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("        nextrel %u", dyst->nextrel);
	big_size = dyst->nextrel;
	big_size *= sizeof(struct relocation_info);
	big_size += dyst->extreloff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("      locreloff %u", dyst->locreloff);
	if(dyst->locreloff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("        nlocrel %u", dyst->nlocrel);
	big_size = dyst->nlocrel;
	big_size *= sizeof(struct relocation_info);
	big_size += dyst->locreloff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
}

/*
 * print an LC_SYMSEG command.  The symseg_command structure specified must
 * be aligned correctly and in the host byte sex.
 */
void
print_symseg_command(
struct symseg_command *ss,
uint32_t object_size)
{
    uint64_t big_size;

	printf("     cmd LC_SYMSEG (obsolete)\n");
	printf(" cmdsize %u", ss->cmdsize);
	if(ss->cmdsize != sizeof(struct symseg_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("  offset %u", ss->offset);
	if(ss->offset > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    size %u", ss->size);
	big_size = ss->offset;
	big_size += ss->size;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
}

/*
 * print an LC_IDFVMLIB or LC_LOADFVMLIB command.  The fvmlib_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_fvmlib_command(
struct fvmlib_command *fl,
struct load_command *lc)
{
    char *p;

	if(fl->cmd == LC_IDFVMLIB)
	    printf("           cmd LC_IDFVMLIB\n");
	else
	    printf("           cmd LC_LOADFVMLIB\n");
	printf("       cmdsize %u", fl->cmdsize);
	if(fl->cmdsize < sizeof(struct fvmlib_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(fl->fvmlib.name.offset < fl->cmdsize){
	    p = (char *)lc + fl->fvmlib.name.offset;
	    printf("          name %s (offset %u)\n",
		   p, fl->fvmlib.name.offset);
	}
	else{
	    printf("          name ?(bad offset %u)\n",
		   fl->fvmlib.name.offset);
	}
	printf(" minor version %u\n", fl->fvmlib.minor_version);
	printf("   header addr 0x%08x\n", (unsigned int)fl->fvmlib.header_addr);
}

/*
 * print an LC_ID_DYLIB, LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, LC_REEXPORT_DYLIB,
 * LC_LAZY_LOAD_DYLIB, or LC_LOAD_UPWARD_DYLIB command.  The dylib_command
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_dylib_command(
struct dylib_command *dl,
struct load_command *lc)
{
    char *p;
    time_t t;

	if(dl->cmd == LC_ID_DYLIB)
	    printf("          cmd LC_ID_DYLIB\n");
	else if(dl->cmd == LC_LOAD_DYLIB)
	    printf("          cmd LC_LOAD_DYLIB\n");
	else if(dl->cmd == LC_LOAD_WEAK_DYLIB)
	    printf("          cmd LC_LOAD_WEAK_DYLIB\n");
	else if(dl->cmd == LC_REEXPORT_DYLIB)
	    printf("          cmd LC_REEXPORT_DYLIB\n");
	else if(dl->cmd == LC_LAZY_LOAD_DYLIB)
	    printf("          cmd LC_LAZY_LOAD_DYLIB\n");
	else if(dl->cmd == LC_LOAD_UPWARD_DYLIB)
	    printf("          cmd LC_LOAD_UPWARD_DYLIB\n");
	else
	    printf("          cmd %u (unknown)\n", dl->cmd);
	printf("      cmdsize %u", dl->cmdsize);
	if(dl->cmdsize < sizeof(struct dylib_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(dl->dylib.name.offset < dl->cmdsize){
	    p = (char *)lc + dl->dylib.name.offset;
	    printf("         name %s (offset %u)\n",
		   p, dl->dylib.name.offset);
	}
	else{
	    printf("         name ?(bad offset %u)\n",
		   dl->dylib.name.offset);
	}
	printf("   time stamp %u ", dl->dylib.timestamp);
	t = dl->dylib.timestamp;
	printf("%s", ctime(&t));
	printf("      current version ");
	if(dl->dylib.current_version == 0xffffffff)
	    printf("n/a\n");
	else
	    printf("%u.%u.%u\n",
	       dl->dylib.current_version >> 16,
	       (dl->dylib.current_version >> 8) & 0xff,
	       dl->dylib.current_version & 0xff);
	printf("compatibility version ");
	if(dl->dylib.compatibility_version == 0xffffffff)
	    printf("n/a\n");
	else
	    printf("%u.%u.%u\n",
	       dl->dylib.compatibility_version >> 16,
	       (dl->dylib.compatibility_version >> 8) & 0xff,
	       dl->dylib.compatibility_version & 0xff);
}

/*
 * print an LC_SUB_FRAMEWORK command.  The sub_framework_command
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_sub_framework_command(
struct sub_framework_command *sub,
struct load_command *lc)
{
    char *p;

	printf("          cmd LC_SUB_FRAMEWORK\n");
	printf("      cmdsize %u", sub->cmdsize);
	if(sub->cmdsize < sizeof(struct sub_framework_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(sub->umbrella.offset < sub->cmdsize){
	    p = (char *)lc + sub->umbrella.offset;
	    printf("     umbrella %s (offset %u)\n",
		   p, sub->umbrella.offset);
	}
	else{
	    printf("     umbrella ?(bad offset %u)\n",
		   sub->umbrella.offset);
	}
}

/*
 * print an LC_SUB_UMBRELLA command.  The sub_umbrella_command
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_sub_umbrella_command(
struct sub_umbrella_command *usub,
struct load_command *lc)
{
    char *p;

	printf("          cmd LC_SUB_UMBRELLA\n");
	printf("      cmdsize %u", usub->cmdsize);
	if(usub->cmdsize < sizeof(struct sub_umbrella_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(usub->sub_umbrella.offset < usub->cmdsize){
	    p = (char *)lc + usub->sub_umbrella.offset;
	    printf(" sub_umbrella %s (offset %u)\n",
		   p, usub->sub_umbrella.offset);
	}
	else{
	    printf(" sub_umbrella ?(bad offset %u)\n",
		   usub->sub_umbrella.offset);
	}
}

/*
 * print an LC_SUB_LIBRARY command.  The sub_library_command
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_sub_library_command(
struct sub_library_command *lsub,
struct load_command *lc)
{
    char *p;

	printf("          cmd LC_SUB_LIBRARY\n");
	printf("      cmdsize %u", lsub->cmdsize);
	if(lsub->cmdsize < sizeof(struct sub_library_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(lsub->sub_library.offset < lsub->cmdsize){
	    p = (char *)lc + lsub->sub_library.offset;
	    printf("  sub_library %s (offset %u)\n",
		   p, lsub->sub_library.offset);
	}
	else{
	    printf("  sub_library ?(bad offset %u)\n",
		   lsub->sub_library.offset);
	}
}

/*
 * print an LC_SUB_CLIENT command.  The sub_client_command
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_sub_client_command(
struct sub_client_command *csub,
struct load_command *lc)
{
    char *p;

	printf("          cmd LC_SUB_CLIENT\n");
	printf("      cmdsize %u", csub->cmdsize);
	if(csub->cmdsize < sizeof(struct sub_client_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(csub->client.offset < csub->cmdsize){
	    p = (char *)lc + csub->client.offset;
	    printf("       client %s (offset %u)\n",
		   p, csub->client.offset);
	}
	else{
	    printf("       client ?(bad offset %u)\n",
		   csub->client.offset);
	}
}

/*
 * print an LC_PREBOUND_DYLIB command.  The prebound_dylib_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_prebound_dylib_command(
struct prebound_dylib_command *pbdylib,
struct load_command *lc,
enum bool verbose)
{
    char *p;
    uint32_t i;

	printf("            cmd LC_PREBOUND_DYLIB\n");
	printf("        cmdsize %u", pbdylib->cmdsize);
	if(pbdylib->cmdsize < sizeof(struct prebound_dylib_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(pbdylib->name.offset < pbdylib->cmdsize){
	    p = (char *)lc + pbdylib->name.offset;
	    printf("           name %s (offset %u)\n",
		   p, pbdylib->name.offset);
	}
	else{
	    printf("           name ?(bad offset %u)\n",
		   pbdylib->name.offset);
	}
	printf("       nmodules %u\n", pbdylib->nmodules);

	if(pbdylib->linked_modules.offset < pbdylib->cmdsize){
	    p = (char *)lc + pbdylib->linked_modules.offset;
	    if(verbose == TRUE){
		printf(" linked_modules (offset %u)\n",
			pbdylib->linked_modules.offset);
		for(i = 0; i < pbdylib->nmodules; i++){
		    if(((p[i/8] >> (i%8)) & 1) == 1)
			printf("%u\n", i);
		}
	    }
	    else{
		printf(" linked_modules ");
		for(i = 0; i < pbdylib->nmodules && i < 8; i++){
		    if(((*p >> i) & 1) == 0)
			printf("0");
		    else
			printf("1");
		}
		if(i <= pbdylib->nmodules)
		    printf("...");
		printf(" (offset %u)\n", pbdylib->linked_modules.offset);
	    }
	}
	else{
	    printf(" linked_modules ?(bad offset %u)\n",
		   pbdylib->linked_modules.offset);
	}
}

/*
 * print an LC_ID_DYLINKER, LC_LOAD_DYLINKER or LC_DYLD_ENVIRONMENT command.
 * The dylinker_command structure specified must be aligned correctly and in the
 * host byte sex.
 */
void
print_dylinker_command(
struct dylinker_command *dyld,
struct load_command *lc)
{
    char *p;

	if(dyld->cmd == LC_ID_DYLINKER)
	    printf("          cmd LC_ID_DYLINKER\n");
	else if(dyld->cmd == LC_LOAD_DYLINKER)
	    printf("          cmd LC_LOAD_DYLINKER\n");
	else if(dyld->cmd == LC_DYLD_ENVIRONMENT)
	    printf("          cmd LC_DYLD_ENVIRONMENT\n");
	else
	    printf("          cmd ?(%u)\n", dyld->cmd);
	printf("      cmdsize %u", dyld->cmdsize);
	if(dyld->cmdsize < sizeof(struct dylinker_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(dyld->name.offset < dyld->cmdsize){
	    p = (char *)lc + dyld->name.offset;
	    printf("         name %s (offset %u)\n", p, dyld->name.offset);
	}
	else{
	    printf("         name ?(bad offset %u)\n", dyld->name.offset);
	}
}

/*
 * print an LC_FVMFILE command.  The fvmfile_command structure specified must
 * be aligned correctly and in the host byte sex.
 */
void
print_fvmfile_command(
struct fvmfile_command *ff,
struct load_command *lc)
{
    char *p;

	printf("           cmd LC_FVMFILE\n");
	printf("       cmdsize %u", ff->cmdsize);
	if(ff->cmdsize < sizeof(struct fvmfile_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(ff->name.offset < ff->cmdsize){
	    p = (char *)lc + ff->name.offset;
	    printf("          name %s (offset %u)\n", p, ff->name.offset);
	}
	else{
	    printf("          name ?(bad offset %u)\n", ff->name.offset);
	}
	printf("   header addr 0x%08x\n", (unsigned int)ff->header_addr);
}

/*
 * print an LC_ROUTINES command.  The routines_command structure specified must
 * be aligned correctly and in the host byte sex.
 */
void
print_routines_command(
struct routines_command *rc)
{
	printf("          cmd LC_ROUTINES\n");
	printf("      cmdsize %u", rc->cmdsize);
	if(rc->cmdsize != sizeof(struct routines_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf(" init_address 0x%08x\n", rc->init_address);
	printf("  init_module %u\n", rc->init_module);
	printf("    reserved1 %u\n", rc->reserved1);
	printf("    reserved2 %u\n", rc->reserved2);
	printf("    reserved3 %u\n", rc->reserved3);
	printf("    reserved4 %u\n", rc->reserved4);
	printf("    reserved5 %u\n", rc->reserved5);
	printf("    reserved6 %u\n", rc->reserved6);
}

/*
 * print an LC_ROUTINES_64 command.  The routines_command_64 structure specified
 * must be aligned correctly and in the host byte sex.
 */
void
print_routines_command_64(
struct routines_command_64 *rc64)
{
	printf("          cmd LC_ROUTINES_64\n");
	printf("      cmdsize %u", rc64->cmdsize);
	if(rc64->cmdsize != sizeof(struct routines_command_64))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf(" init_address 0x%016llx\n", rc64->init_address);
	printf("  init_module %llu\n", rc64->init_module);
	printf("    reserved1 %llu\n", rc64->reserved1);
	printf("    reserved2 %llu\n", rc64->reserved2);
	printf("    reserved3 %llu\n", rc64->reserved3);
	printf("    reserved4 %llu\n", rc64->reserved4);
	printf("    reserved5 %llu\n", rc64->reserved5);
	printf("    reserved6 %llu\n", rc64->reserved6);
}

/*
 * print an LC_TWOLEVEL_HINTS command.  The twolevel_hints_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_twolevel_hints_command(
struct twolevel_hints_command *hints,
uint32_t object_size)
{
    uint64_t big_size;

	printf("     cmd LC_TWOLEVEL_HINTS\n");
	printf(" cmdsize %u", hints->cmdsize);
	if(hints->cmdsize != sizeof(struct twolevel_hints_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("  offset %u", hints->offset);
	if(hints->offset > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("  nhints %u", hints->nhints);
	big_size = hints->nhints;
	big_size *= sizeof(struct twolevel_hint);
	big_size += hints->offset;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
}

/*
 * print an LC_PREBIND_CKSUM command.  The prebind_cksum_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_prebind_cksum_command(
struct prebind_cksum_command *cksum)
{
	printf("     cmd LC_PREBIND_CKSUM\n");
	printf(" cmdsize %u", cksum->cmdsize);
	if(cksum->cmdsize != sizeof(struct prebind_cksum_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("   cksum 0x%08x\n", (unsigned int)cksum->cksum);
}

/*
 * print an LC_UUID command.  The uuid_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_uuid_command(
struct uuid_command *uuid)
{
	printf("     cmd LC_UUID\n");
	printf(" cmdsize %u", uuid->cmdsize);
	if(uuid->cmdsize != sizeof(struct uuid_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("    uuid %02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-"
	       "%02X%02X%02X%02X%02X%02X\n",
	       (unsigned int)uuid->uuid[0], (unsigned int)uuid->uuid[1],
	       (unsigned int)uuid->uuid[2],  (unsigned int)uuid->uuid[3],
	       (unsigned int)uuid->uuid[4],  (unsigned int)uuid->uuid[5],
	       (unsigned int)uuid->uuid[6],  (unsigned int)uuid->uuid[7],
	       (unsigned int)uuid->uuid[8],  (unsigned int)uuid->uuid[9],
	       (unsigned int)uuid->uuid[10], (unsigned int)uuid->uuid[11],
	       (unsigned int)uuid->uuid[12], (unsigned int)uuid->uuid[13],
	       (unsigned int)uuid->uuid[14], (unsigned int)uuid->uuid[15]);
}

/*
 * print a linkedit_data_command.  The linkedit_data_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_linkedit_data_command(
struct linkedit_data_command *ld,
uint32_t object_size)
{
    uint64_t big_size;

	if(ld->cmd == LC_CODE_SIGNATURE)
	    printf("      cmd LC_CODE_SIGNATURE\n");
	else if(ld->cmd == LC_SEGMENT_SPLIT_INFO)
	    printf("      cmd LC_SEGMENT_SPLIT_INFO\n");
        else if(ld->cmd == LC_FUNCTION_STARTS)
	    printf("      cmd LC_FUNCTION_STARTS\n");
        else if(ld->cmd == LC_DATA_IN_CODE)
	    printf("      cmd LC_DATA_IN_CODE\n");
        else if(ld->cmd == LC_DYLIB_CODE_SIGN_DRS)
	    printf("      cmd LC_DYLIB_CODE_SIGN_DRS\n");
        else if(ld->cmd == LC_LINKER_OPTIMIZATION_HINT)
	    printf("      cmd LC_LINKER_OPTIMIZATION_HINT\n");
	else
	    printf("      cmd %u (?)\n", ld->cmd);
	printf("  cmdsize %u", ld->cmdsize);
	if(ld->cmdsize != sizeof(struct linkedit_data_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("  dataoff %u", ld->dataoff);
	if(ld->dataoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf(" datasize %u", ld->datasize);
	big_size = ld->dataoff;
	big_size += ld->datasize;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
}

/*
 * print a version_min_command.  The version_min_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_version_min_command(
struct version_min_command *vd)
{
	if(vd->cmd == LC_VERSION_MIN_MACOSX)
	    printf("      cmd LC_VERSION_MIN_MACOSX\n");
	else if(vd->cmd == LC_VERSION_MIN_IPHONEOS)
	    printf("      cmd LC_VERSION_MIN_IPHONEOS\n");
	else if(vd->cmd == LC_VERSION_MIN_WATCHOS)
	    printf("      cmd LC_VERSION_MIN_WATCHOS\n");
	else
	    printf("      cmd %u (?)\n", vd->cmd);
	printf("  cmdsize %u", vd->cmdsize);
	if(vd->cmdsize != sizeof(struct version_min_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if((vd->version & 0xff) == 0)
	    printf("  version %u.%u\n",
	       vd->version >> 16,
	       (vd->version >> 8) & 0xff);
	else
	    printf("  version %u.%u.%u\n",
	       vd->version >> 16,
	       (vd->version >> 8) & 0xff,
	       vd->version & 0xff);
	if(vd->sdk == 0)
	    printf("      sdk n/a\n");
	else{
	    if((vd->sdk & 0xff) == 0)
		printf("      sdk %u.%u\n",
		   vd->sdk >> 16,
		   (vd->sdk >> 8) & 0xff);
	    else
		printf("      sdk %u.%u.%u\n",
		   vd->sdk >> 16,
		   (vd->sdk >> 8) & 0xff,
		   vd->sdk & 0xff);
	}
}

/*
 * print a source_version_command.  The source_version_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_source_version_command(
struct source_version_command *sv)
{
    uint64_t a, b, c, d, e;

	printf("      cmd LC_SOURCE_VERSION\n");
	printf("  cmdsize %u", sv->cmdsize);
	if(sv->cmdsize != sizeof(struct source_version_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	a = (sv->version >> 40) & 0xffffff;
	b = (sv->version >> 30) & 0x3ff;
	c = (sv->version >> 20) & 0x3ff;
	d = (sv->version >> 10) & 0x3ff;
	e = sv->version & 0x3ff;
	if(e != 0)
	    printf("  version %llu.%llu.%llu.%llu.%llu\n", a, b, c, d, e);
	else if(d != 0)
	    printf("  version %llu.%llu.%llu.%llu\n", a, b, c, d);
	else if(c != 0)
	    printf("  version %llu.%llu.%llu\n", a, b, c);
	else
	    printf("  version %llu.%llu\n", a, b);
}

/*
 * print a entry_point_command.  The entry_point_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_entry_point_command(
struct entry_point_command *ep)
{
	printf("       cmd LC_MAIN\n");
	printf("   cmdsize %u", ep->cmdsize);
	if(ep->cmdsize < sizeof(struct entry_point_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("  entryoff %llu\n", ep->entryoff);
	printf(" stacksize %llu\n", ep->stacksize);
}

/*
 * print an LC_RPATH command.  The rpath_command structure specified must be
 * aligned correctly and in the host byte sex.
 */
void
print_rpath_command(
struct rpath_command *rpath,
struct load_command *lc)
{
    char *p;

	printf("          cmd LC_RPATH\n");
	printf("      cmdsize %u", rpath->cmdsize);
	if(rpath->cmdsize < sizeof(struct rpath_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	if(rpath->path.offset < rpath->cmdsize){
	    p = (char *)lc + rpath->path.offset;
	    printf("         path %s (offset %u)\n", p, rpath->path.offset);
	}
	else{
	    printf("         path ?(bad offset %u)\n", rpath->path.offset);
	}
}

/*
 * print an LC_ENCRYPTION_INFO command.  The encryption_info_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_encryption_info_command(
struct encryption_info_command *ec,
uint32_t object_size)
{
    uint64_t big_size;

	printf("          cmd LC_ENCRYPTION_INFO\n");
	printf("      cmdsize %u", ec->cmdsize);
	if(ec->cmdsize < sizeof(struct encryption_info_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("     cryptoff %u", ec->cryptoff);
	if(ec->cryptoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    cryptsize %u", ec->cryptsize);
	big_size = ec->cryptsize;
	big_size += ec->cryptoff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("      cryptid %u\n", ec->cryptid);
}

/*
 * print an LC_ENCRYPTION_INFO_64 command.  The encryption_info_command_64
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_encryption_info_command_64(
struct encryption_info_command_64 *ec,
uint32_t object_size)
{
    uint64_t big_size;

	printf("          cmd LC_ENCRYPTION_INFO_64\n");
	printf("      cmdsize %u", ec->cmdsize);
	if(ec->cmdsize < sizeof(struct encryption_info_command_64))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("     cryptoff %u", ec->cryptoff);
	if(ec->cryptoff > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    cryptsize %u", ec->cryptsize);
	big_size = ec->cryptsize;
	big_size += ec->cryptoff;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("      cryptid %u\n", ec->cryptid);
	printf("          pad %u\n", ec->pad);
}

/*
 * print an LC_LINKER_OPTION command.  The linker_option_command structure
 * specified must be aligned correctly and in the host byte sex.  The lc is
 * the actual load command with the strings that follow it and must have been
 * previously checked so that the cmdsize does not extend past the size of the
 * load commands.
 */
void
print_linker_option_command(
struct linker_option_command *lo,
struct load_command *lc)
{
    int left, len, i;
    char *string;

	printf("     cmd LC_LINKER_OPTION\n");
	printf(" cmdsize %u", lo->cmdsize);
	if(lo->cmdsize < sizeof(struct linker_option_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");
	printf("   count %u\n", lo->count);
	string = (char *)lc + sizeof(struct linker_option_command);
	left = lo->cmdsize - sizeof(struct linker_option_command);
	i = 0;
	while(left > 0){
	    while(*string == '\0' && left > 0){
		string++;
		left--;
	    }
	    if(left > 0){
		i++;
		printf("  string #%d %.*s\n", i, left, string);
		len = strnlen(string, left) + 1;
		string += len;
		left -= len;
	    }
	}
	if(lo->count != i)
	  printf("   count %u does not match number of strings %u\n",
		 lo->count, i);
}

/*
 * print an LC_DYLD_INFO command.  The dyld_info_command structure
 * specified must be aligned correctly and in the host byte sex.
 */
void
print_dyld_info_info_command(
struct dyld_info_command *dc,
uint32_t object_size)
{
    uint64_t big_size;

	if(dc->cmd == LC_DYLD_INFO)
	    printf("            cmd LC_DYLD_INFO\n");
	else
	    printf("            cmd LC_DYLD_INFO_ONLY\n");
	printf("        cmdsize %u", dc->cmdsize);
	if(dc->cmdsize < sizeof(struct dyld_info_command))
	    printf(" Incorrect size\n");
	else
	    printf("\n");

	printf("     rebase_off %u", dc->rebase_off);
	if(dc->rebase_off > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    rebase_size %u", dc->rebase_size);
	big_size = dc->rebase_off;
	big_size += dc->rebase_size;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");

	printf("       bind_off %u", dc->bind_off);
	if(dc->bind_off > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("      bind_size %u", dc->bind_size);
	big_size = dc->bind_off;
	big_size += dc->bind_size;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	    
	printf("  weak_bind_off %u", dc->weak_bind_off);
	if(dc->weak_bind_off > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf(" weak_bind_size %u", dc->weak_bind_size);
	big_size = dc->weak_bind_off;
	big_size += dc->weak_bind_size;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");

	printf("  lazy_bind_off %u", dc->lazy_bind_off);
	if(dc->lazy_bind_off > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf(" lazy_bind_size %u", dc->lazy_bind_size);
	big_size = dc->lazy_bind_off;
	big_size += dc->lazy_bind_size;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	    
	printf("     export_off %u", dc->export_off);
	if(dc->export_off > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
	printf("    export_size %u", dc->export_size);
	big_size = dc->export_off;
	big_size += dc->export_size;
	if(big_size > object_size)
	    printf(" (past end of file)\n");
	else
	    printf("\n");
}

/*
 * print the thread states from an LC_THREAD or LC_UNIXTHREAD command.  The
 * thread state triples (flavor, count, state) are in memory between begin and
 * and end values specified, and in the specified byte sex.  The mach_header
 * structure specified must be aligned correctly and in the host byte sex.
 */
void
print_thread_states(
char *begin, 
char *end,
cpu_type_t cputype,
enum byte_sex thread_states_byte_sex)
{
    uint32_t i, j, k, flavor, count, left;
    enum byte_sex host_byte_sex;
    enum bool swapped;

	i = 0;
	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != thread_states_byte_sex;

	if(cputype == CPU_TYPE_MC680x0){
	    struct m68k_thread_state_regs cpu;
	    struct m68k_thread_state_68882 fpu;
	    struct m68k_thread_state_user_reg user_reg;

	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case M68K_THREAD_STATE_REGS:
		    printf("     flavor M68K_THREAD_STATE_REGS\n");
		    if(count == M68K_THREAD_STATE_REGS_COUNT)
			printf("      count M68K_THREAD_STATE_"
			       "REGS_COUNT\n");
		    else
			printf("      count %u (not M68K_THREAD_STATE_"
			       "REGS_COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(struct m68k_thread_state_regs)){
		        memcpy((char *)&cpu, begin,
			       sizeof(struct m68k_thread_state_regs));
		        begin += sizeof(struct m68k_thread_state_regs);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(struct m68k_thread_state_regs));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m68k_thread_state_regs(&cpu, host_byte_sex);
		    printf(" dregs ");
		    for(j = 0 ; j < 8 ; j++)
			printf(" %08x", (unsigned int)cpu.dreg[j]);
		    printf("\n");
		    printf(" aregs ");
		    for(j = 0 ; j < 8 ; j++)
			printf(" %08x", (unsigned int)cpu.areg[j]);
		    printf("\n");
		    printf(" pad 0x%04x sr 0x%04x pc 0x%08x\n", 
			    (unsigned int)(cpu.pad0 & 0x0000ffff),
			    (unsigned int)(cpu.sr & 0x0000ffff),
			    (unsigned int)cpu.pc);
		    break;

		case M68K_THREAD_STATE_68882:
		    printf("     flavor M68K_THREAD_STATE_68882\n");
		    if(count == M68K_THREAD_STATE_68882_COUNT)
			printf("      count M68K_THREAD_STATE_"
			       "68882_COUNT\n");
		    else
			printf("      count %u (not M68K_THREAD_STATE_"
			       "68882_COUNT\n", count);
		    left = end - begin;
		    if(left >= sizeof(struct m68k_thread_state_68882)){
		        memcpy((char *)&fpu, begin,
			       sizeof(struct m68k_thread_state_68882));
		        begin += sizeof(struct m68k_thread_state_68882);
		    }
		    else{
		        memset((char *)&fpu, '\0',
			       sizeof(struct m68k_thread_state_68882));
		        memcpy((char *)&fpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m68k_thread_state_68882(&fpu, host_byte_sex);
		    for(j = 0 ; j < 8 ; j++)
			printf(" fp reg %u %08x %08x %08x\n", j,
			       (unsigned int)fpu.regs[j].fp[0],
			       (unsigned int)fpu.regs[j].fp[1],
			       (unsigned int)fpu.regs[j].fp[2]);
		    printf(" cr 0x%08x sr 0x%08x state 0x%08x\n", 
			   (unsigned int)fpu.cr, (unsigned int)fpu.sr,
			   (unsigned int)fpu.state);
		    break;

		case M68K_THREAD_STATE_USER_REG:
		    printf("     flavor M68K_THREAD_STATE_USER_REG\n");
		    if(count == M68K_THREAD_STATE_USER_REG_COUNT)
			printf("      count M68K_THREAD_STATE_"
			       "USER_REG_COUNT\n");
		    else
			printf("      count %u (not M68K_THREAD_STATE_"
			       "USER_REG_COUNT", count);
		    left = end - begin;
		    if(left >= sizeof(struct m68k_thread_state_user_reg)){
		        memcpy((char *)&user_reg, begin,
			       sizeof(struct m68k_thread_state_user_reg));
		        begin += sizeof(struct m68k_thread_state_user_reg);
		    }
		    else{
		        memset((char *)&user_reg, '\0',
			       sizeof(struct m68k_thread_state_user_reg));
		        memcpy((char *)&user_reg, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m68k_thread_state_user_reg(&user_reg,
							host_byte_sex);
		    printf(" user_reg 0x%08x\n",
			   (unsigned int)user_reg.user_reg);
		    break;

		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_HPPA){
	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case HPPA_INTEGER_THREAD_STATE:
			{ struct hp_pa_integer_thread_state frame;
			
		    printf("      flavor HPPA_INTEGER_THREAD_STATE\n");
		    if(count == HPPA_INTEGER_THREAD_STATE_COUNT)
			printf("      count HPPA_INTEGER_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not HPPA_INTEGER_THREAD_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(struct hp_pa_integer_thread_state)){
		        memcpy((char *)&frame, begin,
			       sizeof(struct hp_pa_integer_thread_state));
		        begin += sizeof(struct hp_pa_integer_thread_state);
		    }
		    else{
		        memset((char *)&frame, '\0',
			       sizeof(struct hp_pa_integer_thread_state));
		        memcpy((char *)&frame, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_hppa_integer_thread_state(&frame, host_byte_sex);
			printf(
		         "r1  0x%08x  r2  0x%08x  r3  0x%08x  r4  0x%08x\n"
		         "r5  0x%08x  r6  0x%08x  r7  0x%08x  r8  0x%08x\n"
		         "r9  0x%08x  r10 0x%08x  r11 0x%08x  r12 0x%08x\n"
		         "r13 0x%08x  r14 0x%08x  r15 0x%08x  r16 0x%08x\n"
		         "r17 0x%08x  r18 0x%08x  r19 0x%08x  r20 0x%08x\n"
		         "r21 0x%08x  r22 0x%08x  r23 0x%08x  r24 0x%08x\n"
		         "r25 0x%08x  r26 0x%08x  r27 0x%08x  r28 0x%08x\n"
		         "r29 0x%08x  r30 0x%08x  r31 0x%08x\n"
			 "sr0 0x%08x  sr1 0x%08x  sr2 0x%08x  sar 0x%08x\n",
		   frame.ts_gr1,  frame.ts_gr2,  frame.ts_gr3,  frame.ts_gr4,
		   frame.ts_gr5,  frame.ts_gr6,  frame.ts_gr7,  frame.ts_gr8,
		   frame.ts_gr9,  frame.ts_gr10, frame.ts_gr11, frame.ts_gr12,
		   frame.ts_gr13, frame.ts_gr14, frame.ts_gr15, frame.ts_gr16,
		   frame.ts_gr17, frame.ts_gr18, frame.ts_gr19, frame.ts_gr20,
		   frame.ts_gr21, frame.ts_gr22, frame.ts_gr23, frame.ts_gr24,
		   frame.ts_gr25, frame.ts_gr26, frame.ts_gr27, frame.ts_gr28,
		   frame.ts_gr29, frame.ts_gr30, frame.ts_gr31,
		   frame.ts_sr0,  frame.ts_sr1,  frame.ts_sr2,  frame.ts_sar);
			}
		    break;
		case HPPA_FRAME_THREAD_STATE: {
			struct hp_pa_frame_thread_state frame;
		    printf("      flavor HPPA_FRAME_THREAD_STATE\n");
		    if(count == HPPA_FRAME_THREAD_STATE_COUNT)
			printf("      count HPPA_FRAME_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not HPPA_FRAME_THREAD_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(struct hp_pa_frame_thread_state)){
		        memcpy((char *)&frame, begin,
			       sizeof(struct hp_pa_frame_thread_state));
		        begin += sizeof(struct hp_pa_frame_thread_state);
		    }
		    else{
		        memset((char *)&frame, '\0',
			       sizeof(struct hp_pa_frame_thread_state));
		        memcpy((char *)&frame, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_hppa_frame_thread_state(&frame, host_byte_sex);
		    printf("pcsq_front  0x%08x pcsq_back  0x%08x\n"
		           "pcoq_front  0x%08x pcoq_back  0x%08x\n"
			   "       psw  0x%08x\n",
			   frame.ts_pcsq_front, frame.ts_pcsq_back,
			   frame.ts_pcoq_front, frame.ts_pcoq_back,
			   frame.ts_psw);
		    break;
		}
		case HPPA_FP_THREAD_STATE: {
			struct hp_pa_fp_thread_state frame;
		    printf("      flavor HPPA_FP_THREAD_STATE\n");
		    if(count == HPPA_FP_THREAD_STATE_COUNT)
			printf("      count HPPA_FP_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not HPPA_FP_THREAD_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(struct hp_pa_fp_thread_state)){
		        memcpy((char *)&frame, begin,
			       sizeof(struct hp_pa_fp_thread_state));
		        begin += sizeof(struct hp_pa_fp_thread_state);
		    }
		    else{
		        memset((char *)&frame, '\0',
			       sizeof(struct hp_pa_fp_thread_state));
		        memcpy((char *)&frame, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_hppa_fp_thread_state(&frame, host_byte_sex);
		    printf("fp0  %f    fp1  %f\nfp2  %f    fp3  %f\n"
			   "fp4  %f    fp5  %f\nfp6  %f    fp7  %f\n"
			   "fp8  %f    fp9  %f\nfp10 %f    fp11 %f\n"
			   "fp12 %f    fp13 %f\nfp14 %f    fp15 %f\n"
			   "fp16 %f    fp17 %f\nfp18 %f    fp19 %f\n"
			   "fp20 %f    fp21 %f\nfp22 %f    fp23 %f\n"
			   "fp24 %f    fp25 %f\nfp26 %f    fp27 %f\n"
			   "fp28 %f    fp29 %f\nfp30 %f    fp31 %f\n",
		    frame.ts_fp0,  frame.ts_fp1,  frame.ts_fp2,  frame.ts_fp3,
		    frame.ts_fp4,  frame.ts_fp5,  frame.ts_fp6,  frame.ts_fp7,
		    frame.ts_fp8,  frame.ts_fp9,  frame.ts_fp10, frame.ts_fp11,
		    frame.ts_fp12, frame.ts_fp13, frame.ts_fp14, frame.ts_fp15,
		    frame.ts_fp16, frame.ts_fp17, frame.ts_fp18, frame.ts_fp19,
		    frame.ts_fp20, frame.ts_fp21, frame.ts_fp22, frame.ts_fp23,
		    frame.ts_fp24, frame.ts_fp25, frame.ts_fp26, frame.ts_fp27,
		    frame.ts_fp28, frame.ts_fp29, frame.ts_fp30, frame.ts_fp31);
		    break;
		}
		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_SPARC){
	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case SPARC_THREAD_STATE_REGS:
		  { struct sparc_thread_state_regs cpu;
		    printf("     flavor SPARC_THREAD_STATE_REGS\n");
		    if (count == SPARC_THREAD_STATE_REGS_COUNT)
		      printf("      count SPARC_THREAD_STATE_REGS_COUNT\n");
		    else
		      printf("      count %u (not SPARC_THREAD_STATE_REGS_COUNT)\n",
			     count);
		    left = begin - end;
		    if (left >= sizeof(struct sparc_thread_state_regs)) {
		      memcpy((char *) &cpu, begin,
			     sizeof(struct sparc_thread_state_regs));
		      begin += sizeof(struct sparc_thread_state_regs);
		    } else {
		      memset((char *) &cpu, '\0',
			     sizeof(struct sparc_thread_state_regs));
		      begin += left;
		    }
		    if (swapped)
		      swap_sparc_thread_state_regs(&cpu, host_byte_sex);
		    printf(
			   "psr 0x%08x  pc  0x%08x  npc 0x%08x  y   0x%08x\n"
			   "g0  0x%08x  g1  0x%08x  g2  0x%08x  g3  0x%08x\n"
			   "g4  0x%08x  g5  0x%08x  g6  0x%08x  g7  0x%08x\n"
			   "o0  0x%08x  o1  0x%08x  o2  0x%08x  o3  0x%08x\n"
			   "o4  0x%08x  o5  0x%08x  o6  0x%08x  o7  0x%08x\n",
			   cpu.regs.r_psr, cpu.regs.r_pc, cpu.regs.r_npc, 
			   cpu.regs.r_y, 0, cpu.regs.r_g1, 
			   cpu.regs.r_g2, cpu.regs.r_g3,
			   cpu.regs.r_g4, cpu.regs.r_g5, 
			   cpu.regs.r_g6, cpu.regs.r_g7,
			   cpu.regs.r_o0, cpu.regs.r_o1, 
			   cpu.regs.r_o2, cpu.regs.r_o3,
			   cpu.regs.r_o4, cpu.regs.r_o5, 
			   cpu.regs.r_o6, cpu.regs.r_o7);
		    break;
		  }
		case SPARC_THREAD_STATE_FPU:
		  { struct sparc_thread_state_fpu fpu;

		    printf("     flavor SPARC_THREAD_STATE_FPU\n");
		    if (count == SPARC_THREAD_STATE_FPU_COUNT)
		      printf("      count SPARC_THREAD_STATE_FPU_COUNT\n");
		    else
		      printf("      count %u (not SPARC_THREAD_STATE_FPU_COUNT)\n",
			     count);
		    left = begin - end;
		    if (left >= sizeof(struct sparc_thread_state_fpu)) {
		      memcpy((char *) &fpu, begin,
			     sizeof(struct sparc_thread_state_fpu));
		      begin += sizeof(struct sparc_thread_state_fpu);
		    } else {
		      memset((char *) &fpu, '\0',
			     sizeof(struct sparc_thread_state_fpu));
		      begin += left;
		    }
		    if (swapped)
		      swap_sparc_thread_state_fpu(&fpu, host_byte_sex);
		    printf(
			   "f0  0x%08x  f1  0x%08x  f2  0x%08x  f3  0x%08x\n"
			   "f4  0x%08x  f5  0x%08x  f6  0x%08x  f7  0x%08x\n"
			   "f8  0x%08x  f9  0x%08x  f10 0x%08x  f11 0x%08x\n"
			   "f12 0x%08x  f13 0x%08x  f14 0x%08x  f15 0x%08x\n"
			   "f16 0x%08x  f17 0x%08x  f18 0x%08x  f19 0x%08x\n"
			   "f20 0x%08x  f21 0x%08x  f22 0x%08x  f23 0x%08x\n"
			   "f24 0x%08x  f25 0x%08x  f26 0x%08x  f27 0x%08x\n"
			   "f28 0x%08x  f29 0x%08x  f30 0x%08x  f31 0x%08x\n"
			   "fsr 0x%08x\n",
			   fpu.fpu.fpu_fr.Fpu_regs[0], fpu.fpu.fpu_fr.Fpu_regs[1],
			   fpu.fpu.fpu_fr.Fpu_regs[2], fpu.fpu.fpu_fr.Fpu_regs[3],
			   fpu.fpu.fpu_fr.Fpu_regs[4], fpu.fpu.fpu_fr.Fpu_regs[5],
			   fpu.fpu.fpu_fr.Fpu_regs[6], fpu.fpu.fpu_fr.Fpu_regs[7],
			   fpu.fpu.fpu_fr.Fpu_regs[8], fpu.fpu.fpu_fr.Fpu_regs[9],
			   fpu.fpu.fpu_fr.Fpu_regs[10], fpu.fpu.fpu_fr.Fpu_regs[11],
			   fpu.fpu.fpu_fr.Fpu_regs[12], fpu.fpu.fpu_fr.Fpu_regs[13],
			   fpu.fpu.fpu_fr.Fpu_regs[14], fpu.fpu.fpu_fr.Fpu_regs[15],
			   fpu.fpu.fpu_fr.Fpu_regs[16], fpu.fpu.fpu_fr.Fpu_regs[17],
			   fpu.fpu.fpu_fr.Fpu_regs[18], fpu.fpu.fpu_fr.Fpu_regs[19],
			   fpu.fpu.fpu_fr.Fpu_regs[20], fpu.fpu.fpu_fr.Fpu_regs[21],
			   fpu.fpu.fpu_fr.Fpu_regs[22], fpu.fpu.fpu_fr.Fpu_regs[23],
			   fpu.fpu.fpu_fr.Fpu_regs[24], fpu.fpu.fpu_fr.Fpu_regs[25],
			   fpu.fpu.fpu_fr.Fpu_regs[26], fpu.fpu.fpu_fr.Fpu_regs[27],
			   fpu.fpu.fpu_fr.Fpu_regs[28], fpu.fpu.fpu_fr.Fpu_regs[29],
			   fpu.fpu.fpu_fr.Fpu_regs[30], fpu.fpu.fpu_fr.Fpu_regs[31],
			   fpu.fpu.Fpu_fsr);
		    break;
		  }
		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_POWERPC ||
	   cputype == CPU_TYPE_POWERPC64 ||
	   cputype == CPU_TYPE_VEO){
	    ppc_thread_state_t cpu;
	    ppc_thread_state64_t cpu64;
	    ppc_float_state_t fpu;
	    ppc_exception_state_t except;

	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case PPC_THREAD_STATE:
		    printf("     flavor PPC_THREAD_STATE\n");
		    if(count == PPC_THREAD_STATE_COUNT)
			printf("      count PPC_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not PPC_THREAD_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(ppc_thread_state_t)){
		        memcpy((char *)&cpu, begin,
			       sizeof(ppc_thread_state_t));
		        begin += sizeof(ppc_thread_state_t);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(ppc_thread_state_t));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_ppc_thread_state_t(&cpu, host_byte_sex);
		    printf("    r0  0x%08x r1  0x%08x r2  0x%08x r3   0x%08x "
			   "r4   0x%08x\n"
			   "    r5  0x%08x r6  0x%08x r7  0x%08x r8   0x%08x "
			   "r9   0x%08x\n"
			   "    r10 0x%08x r11 0x%08x r12 0x%08x r13  0x%08x "
			   "r14  0x%08x\n"
			   "    r15 0x%08x r16 0x%08x r17 0x%08x r18  0x%08x "
			   "r19  0x%08x\n"
			   "    r20 0x%08x r21 0x%08x r22 0x%08x r23  0x%08x "
			   "r24  0x%08x\n"
			   "    r25 0x%08x r26 0x%08x r27 0x%08x r28  0x%08x "
			   "r29  0x%08x\n"
			   "    r30 0x%08x r31 0x%08x cr  0x%08x xer  0x%08x "
			   "lr   0x%08x\n"
			   "    ctr 0x%08x mq  0x%08x vrsave 0x%08x srr0 0x%08x"
			   " srr1 0x%08x\n",
			   cpu.r0, cpu.r1, cpu.r2, cpu.r3, cpu.r4, cpu.r5,
			   cpu.r6, cpu.r7, cpu.r8, cpu.r9, cpu.r10, cpu.r11,
			   cpu.r12, cpu.r13, cpu.r14, cpu.r15, cpu.r16, cpu.r17,
			   cpu.r18, cpu.r19, cpu.r20, cpu.r21, cpu.r22, cpu.r23,
			   cpu.r24, cpu.r25, cpu.r26, cpu.r27, cpu.r28, cpu.r29,
			   cpu.r30, cpu.r31, cpu.cr,  cpu.xer, cpu.lr, cpu.ctr,
			   cpu.mq, cpu.vrsave, cpu.srr0, cpu.srr1);
		    break;
		case PPC_FLOAT_STATE:
		    printf("      flavor PPC_FLOAT_STATE\n");
		    if(count == PPC_FLOAT_STATE_COUNT)
			printf("      count PPC_FLOAT_STATE_COUNT\n");
		    else
			printf("      count %u (not PPC_FLOAT_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(ppc_float_state_t)){
		        memcpy((char *)&fpu, begin,
			       sizeof(ppc_float_state_t));
		        begin += sizeof(ppc_float_state_t);
		    }
		    else{
		        memset((char *)&fpu, '\0',
			       sizeof(ppc_float_state_t));
		        memcpy((char *)&fpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_ppc_float_state_t(&fpu, host_byte_sex);
		    printf("       f0  %f    f1  %f\n       f2  %f    f3  %f\n"
			   "       f4  %f    f5  %f\n       f6  %f    f7  %f\n"
			   "       f8  %f    f9  %f\n       f10 %f    f11 %f\n"
			   "       f12 %f    f13 %f\n       f14 %f    f15 %f\n"
			   "       f16 %f    f17 %f\n       f18 %f    f19 %f\n"
			   "       f20 %f    f21 %f\n       f22 %f    f23 %f\n"
			   "       f24 %f    f25 %f\n       f26 %f    f27 %f\n"
			   "       f28 %f    f29 %f\n       f30 %f    f31 %f\n",
			   fpu.fpregs[0],  fpu.fpregs[1],  fpu.fpregs[2],
			   fpu.fpregs[3],  fpu.fpregs[4],  fpu.fpregs[5],
			   fpu.fpregs[6],  fpu.fpregs[7],  fpu.fpregs[8],
			   fpu.fpregs[9],  fpu.fpregs[10], fpu.fpregs[11],
			   fpu.fpregs[12], fpu.fpregs[13], fpu.fpregs[14],
			   fpu.fpregs[15], fpu.fpregs[16], fpu.fpregs[17],
			   fpu.fpregs[18], fpu.fpregs[19], fpu.fpregs[20],
			   fpu.fpregs[21], fpu.fpregs[22], fpu.fpregs[23],
			   fpu.fpregs[24], fpu.fpregs[25], fpu.fpregs[26],
			   fpu.fpregs[27], fpu.fpregs[28], fpu.fpregs[29],
			   fpu.fpregs[30], fpu.fpregs[31]);
		    printf("       fpscr_pad 0x%x fpscr 0x%x\n", fpu.fpscr_pad,
			   fpu.fpscr);
		    break;
		case PPC_EXCEPTION_STATE:
		    printf("      flavor PPC_EXCEPTION_STATE\n");
		    if(count == PPC_EXCEPTION_STATE_COUNT)
			printf("      count PPC_EXCEPTION_STATE_COUNT\n");
		    else
			printf("      count %u (not PPC_EXCEPTION_STATE_COUNT"
			       ")\n", count);
		    left = end - begin;
		    if(left >= sizeof(ppc_exception_state_t)){
		        memcpy((char *)&except, begin,
			       sizeof(ppc_exception_state_t));
		        begin += sizeof(ppc_exception_state_t);
		    }
		    else{
		        memset((char *)&except, '\0',
			       sizeof(ppc_exception_state_t));
		        memcpy((char *)&except, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_ppc_exception_state_t(&except, host_byte_sex);
		    printf("      dar 0x%x dsisr 0x%x exception 0x%x pad0 "
			   "0x%x\n", (unsigned int)except.dar,
			   (unsigned int)except.dsisr,
			   (unsigned int)except.exception,
			   (unsigned int)except.pad0);
		    printf("      pad1[0] 0x%x pad1[1] 0x%x pad1[2] "
			   "0x%x pad1[3] 0x%x\n", (unsigned int)except.pad1[0],
			   (unsigned int)except.pad1[0],
			   (unsigned int)except.pad1[0],
			   (unsigned int)except.pad1[0]);
		    break;
		case PPC_THREAD_STATE64:
		    printf("     flavor PPC_THREAD_STATE64\n");
		    if(count == PPC_THREAD_STATE64_COUNT)
			printf("      count PPC_THREAD_STATE64_COUNT\n");
		    else
			printf("      count %u (not PPC_THREAD_STATE64_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(ppc_thread_state64_t)){
		        memcpy((char *)&cpu64, begin,
			       sizeof(ppc_thread_state64_t));
		        begin += sizeof(ppc_thread_state64_t);
		    }
		    else{
		        memset((char *)&cpu64, '\0',
			       sizeof(ppc_thread_state64_t));
		        memcpy((char *)&cpu64, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_ppc_thread_state64_t(&cpu64, host_byte_sex);
		    printf("    r0  0x%016llx r1  0x%016llx r2   0x%016llx\n"
			   "    r3  0x%016llx r4  0x%016llx r5   0x%016llx\n"
			   "    r6  0x%016llx r7  0x%016llx r8   0x%016llx\n"
			   "    r9  0x%016llx r10 0x%016llx r11  0x%016llx\n"
			   "   r12  0x%016llx r13 0x%016llx r14  0x%016llx\n"
			   "   r15  0x%016llx r16 0x%016llx r17  0x%016llx\n"
			   "   r18  0x%016llx r19 0x%016llx r20  0x%016llx\n"
			   "   r21  0x%016llx r22 0x%016llx r23  0x%016llx\n"
			   "   r24  0x%016llx r25 0x%016llx r26  0x%016llx\n"
			   "   r27  0x%016llx r28 0x%016llx r29  0x%016llx\n"
			   "   r30  0x%016llx r31 0x%016llx cr   0x%08x\n"
			   "   xer  0x%016llx lr  0x%016llx ctr  0x%016llx\n"
			   "vrsave  0x%08x        srr0 0x%016llx srr1 "
			   "0x%016llx\n",
			   cpu64.r0, cpu64.r1, cpu64.r2, cpu64.r3, cpu64.r4,
			   cpu64.r5, cpu64.r6, cpu64.r7, cpu64.r8, cpu64.r9,
			   cpu64.r10, cpu64.r11, cpu64.r12, cpu64.r13,cpu64.r14,
			   cpu64.r15, cpu64.r16, cpu64.r17, cpu64.r18,cpu64.r19,
			   cpu64.r20, cpu64.r21, cpu64.r22, cpu64.r23,cpu64.r24,
			   cpu64.r25, cpu64.r26, cpu64.r27, cpu64.r28,cpu64.r29,
			   cpu64.r30, cpu64.r31, cpu64.cr,  cpu64.xer, cpu64.lr,
			   cpu64.ctr, cpu64.vrsave, cpu64.srr0, cpu64.srr1);
		    break;
		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_MC88000){
	    m88k_thread_state_grf_t cpu;
	    m88k_thread_state_xrf_t fpu;
	    m88k_thread_state_user_t user;
	    m88110_thread_state_impl_t spu;

	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case M88K_THREAD_STATE_GRF:
		    printf("      flavor M88K_THREAD_STATE_GRF\n");
		    if(count == M88K_THREAD_STATE_GRF_COUNT)
			printf("      count M88K_THREAD_STATE_GRF_COUNT\n");
		    else
			printf("      count %u (not M88K_THREAD_STATE_GRF_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(m88k_thread_state_grf_t)){
		        memcpy((char *)&cpu, begin,
			       sizeof(m88k_thread_state_grf_t));
		        begin += sizeof(m88k_thread_state_grf_t);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(m88k_thread_state_grf_t));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m88k_thread_state_grf_t(&cpu, host_byte_sex);
		    printf("      r1  0x%08x r2  0x%08x r3  0x%08x r4  0x%08x "
			   "r5  0x%08x\n"
			   "      r6  0x%08x r7  0x%08x r8  0x%08x r9  0x%08x "
			   "r10 0x%08x\n"
			   "      r11 0x%08x r12 0x%08x r13 0x%08x r14 0x%08x "
			   "r15 0x%08x\n"
			   "      r16 0x%08x r17 0x%08x r18 0x%08x r19 0x%08x "
			   "r20 0x%08x\n"
			   "      r21 0x%08x r22 0x%08x r23 0x%08x r24 0x%08x "
			   "r25 0x%08x\n"
			   "      r26 0x%08x r27 0x%08x r28 0x%08x r29 0x%08x "
			   "r30 0x%08x\n"
			   "      r31 0x%08x xip 0x%08x xip_in_bd 0x%08x nip "
			   "0x%08x\n",
			   cpu.r1,  cpu.r2,  cpu.r3,  cpu.r4,  cpu.r5,
			   cpu.r6,  cpu.r7,  cpu.r8,  cpu.r9,  cpu.r10,
			   cpu.r11, cpu.r12, cpu.r13, cpu.r14, cpu.r15,
			   cpu.r16, cpu.r17, cpu.r18, cpu.r19, cpu.r20,
			   cpu.r21, cpu.r22, cpu.r23, cpu.r24, cpu.r25,
			   cpu.r26, cpu.r27, cpu.r28, cpu.r29, cpu.r30,
			   cpu.r31, cpu.xip, cpu.xip_in_bd, cpu.nip);
		    break;
		case M88K_THREAD_STATE_XRF:
		    printf("      flavor M88K_THREAD_STATE_XRF\n");
		    if(count == M88K_THREAD_STATE_XRF_COUNT)
			printf("      count M88K_THREAD_STATE_XRF_COUNT\n");
		    else
			printf("      count %u (not M88K_THREAD_STATE_XRF_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(m88k_thread_state_xrf_t)){
		        memcpy((char *)&fpu, begin,
			       sizeof(m88k_thread_state_xrf_t));
		        begin += sizeof(m88k_thread_state_xrf_t);
		    }
		    else{
		        memset((char *)&fpu, '\0',
			       sizeof(m88k_thread_state_xrf_t));
		        memcpy((char *)&fpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m88k_thread_state_xrf_t(&fpu, host_byte_sex);
		    printf("      x1  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x2  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x3  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x4  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x5  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x6  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x7  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x8  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x9  0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x10 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x11 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x12 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x13 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x14 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x15 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x16 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x17 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x18 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x19 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x20 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x21 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x22 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x23 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x24 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x25 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x26 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x27 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x28 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x29 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x30 0x%08x 0x%08x 0x%08x 0x%08x\n"
			   "      x31 0x%08x 0x%08x 0x%08x 0x%08x\n",
			   fpu.x1.x[0],fpu.x1.x[1],fpu.x1.x[2],fpu.x1.x[3],
			   fpu.x2.x[0],fpu.x2.x[1],fpu.x2.x[2],fpu.x2.x[3],
			   fpu.x3.x[0],fpu.x3.x[1],fpu.x3.x[2],fpu.x3.x[3],
			   fpu.x4.x[0],fpu.x4.x[1],fpu.x4.x[2],fpu.x4.x[3],
			   fpu.x5.x[0],fpu.x5.x[1],fpu.x5.x[2],fpu.x5.x[3],
			   fpu.x6.x[0],fpu.x6.x[1],fpu.x6.x[2],fpu.x6.x[3],
			   fpu.x7.x[0],fpu.x7.x[1],fpu.x7.x[2],fpu.x7.x[3],
			   fpu.x8.x[0],fpu.x8.x[1],fpu.x8.x[2],fpu.x8.x[3],
			   fpu.x9.x[0],fpu.x9.x[1],fpu.x9.x[2],fpu.x9.x[3],
			   fpu.x10.x[0],fpu.x10.x[1],fpu.x10.x[2],fpu.x10.x[3],
			   fpu.x11.x[0],fpu.x11.x[1],fpu.x11.x[2],fpu.x11.x[3],
			   fpu.x12.x[0],fpu.x12.x[1],fpu.x12.x[2],fpu.x12.x[3],
			   fpu.x13.x[0],fpu.x13.x[1],fpu.x13.x[2],fpu.x13.x[3],
			   fpu.x14.x[0],fpu.x14.x[1],fpu.x14.x[2],fpu.x14.x[3],
			   fpu.x15.x[0],fpu.x15.x[1],fpu.x15.x[2],fpu.x15.x[3],
			   fpu.x16.x[0],fpu.x16.x[1],fpu.x16.x[2],fpu.x16.x[3],
			   fpu.x17.x[0],fpu.x17.x[1],fpu.x17.x[2],fpu.x17.x[3],
			   fpu.x18.x[0],fpu.x18.x[1],fpu.x18.x[2],fpu.x18.x[3],
			   fpu.x19.x[0],fpu.x19.x[1],fpu.x19.x[2],fpu.x19.x[3],
			   fpu.x20.x[0],fpu.x20.x[1],fpu.x20.x[2],fpu.x20.x[3],
			   fpu.x21.x[0],fpu.x21.x[1],fpu.x21.x[2],fpu.x21.x[3],
			   fpu.x22.x[0],fpu.x22.x[1],fpu.x22.x[2],fpu.x22.x[3],
			   fpu.x23.x[0],fpu.x23.x[1],fpu.x23.x[2],fpu.x23.x[3],
			   fpu.x24.x[0],fpu.x24.x[1],fpu.x24.x[2],fpu.x24.x[3],
			   fpu.x25.x[0],fpu.x25.x[1],fpu.x25.x[2],fpu.x25.x[3],
			   fpu.x26.x[0],fpu.x26.x[1],fpu.x26.x[2],fpu.x26.x[3],
			   fpu.x27.x[0],fpu.x27.x[1],fpu.x27.x[2],fpu.x27.x[3],
			   fpu.x28.x[0],fpu.x28.x[1],fpu.x28.x[2],fpu.x28.x[3],
			   fpu.x29.x[0],fpu.x29.x[1],fpu.x29.x[2],fpu.x29.x[3],
			   fpu.x30.x[0],fpu.x30.x[1],fpu.x30.x[2],fpu.x30.x[3],
			   fpu.x31.x[0],fpu.x31.x[1],fpu.x31.x[2],fpu.x31.x[3]);
		    printf("      fpsr xmod %d afinv %d afdvz %d afunf %d "
			   "afovf %d afinx %d\n", fpu.fpsr.xmod, fpu.fpsr.afinv,
			   fpu.fpsr.afdvz, fpu.fpsr.afunf,
			   fpu.fpsr.afovf, fpu.fpsr.afinx);
		    printf("      fpcr rm ");
			switch(fpu.fpcr.rm){
			case M88K_RM_NEAREST:
			    printf("RM_NEAREST ");
			    break;
			case M88K_RM_ZERO:
			    printf("RM_ZERO ");
			    break;
			case M88K_RM_NEGINF:
			    printf("RM_NEGINF ");
			    break;
			case M88K_RM_POSINF:
			    printf("RM_POSINF ");
			    break;
			}
		    printf("efinv %d efdvz %d efunf %d efovf %d efinx %d\n",
			   fpu.fpcr.efinv, fpu.fpcr.efdvz, fpu.fpcr.efunf,
			   fpu.fpcr.efovf, fpu.fpcr.efinx);
		    break;
		case M88K_THREAD_STATE_USER:
		    printf("      flavor M88K_THREAD_STATE_USER\n");
		    if(count == M88K_THREAD_STATE_USER_COUNT)
			printf("      count M88K_THREAD_STATE_USER_COUNT\n");
		    else
			printf("      count %u (not M88K_THREAD_STATE_USER_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(m88k_thread_state_user_t)){
		        memcpy((char *)&user, begin,
			       sizeof(m88k_thread_state_user_t));
		        begin += sizeof(m88k_thread_state_user_t);
		    }
		    else{
		        memset((char *)&user, '\0',
			       sizeof(m88k_thread_state_user_t));
		        memcpy((char *)&user, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m88k_thread_state_user_t(&user, host_byte_sex);
		    printf("      user 0x%08x\n", (unsigned int)user.user);
		    break;

		case M88110_THREAD_STATE_IMPL:
		    printf("      flavor M88110_THREAD_STATE_IMPL\n");
		    if(count == M88110_THREAD_STATE_IMPL_COUNT)
			printf("      count M88110_THREAD_STATE_IMPL_COUNT\n");
		    else
			printf("      count %u (not M88110_THREAD_STATE_IMPL_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(m88110_thread_state_impl_t)){
		        memcpy((char *)&spu, begin,
			       sizeof(m88110_thread_state_impl_t));
		        begin += sizeof(m88110_thread_state_impl_t);
		    }
		    else{
		        memset((char *)&spu, '\0',
			       sizeof(m88110_thread_state_impl_t));
		        memcpy((char *)&spu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_m88110_thread_state_impl_t(&spu, host_byte_sex);
		    for(j = 0; j < M88110_N_DATA_BP; j++){
			printf("      data_bp[%u] addr 0x%08x\n",
			       j, (unsigned int)spu.data_bp[i].addr);
			printf("                  cntl rw %d rwm %d "
			       "addr_match ", spu.data_bp[j].ctrl.rw,
			       spu.data_bp[j].ctrl.rwm);
			switch(spu.data_bp[j].ctrl.addr_match){
			case M88110_MATCH_BYTE:
			    printf("MATCH_BYTE ");
			    break;
			case M88110_MATCH_SHORT:
			    printf("MATCH_SHORT ");
			    break;
			case M88110_MATCH_WORD:
			    printf("MATCH_WORD ");
			    break;
			case M88110_MATCH_DOUBLE:
			    printf("MATCH_DOUBLE ");
			    break;
			case M88110_MATCH_QUAD:
			    printf("MATCH_QUAD ");
			    break;
			case M88110_MATCH_32:
			    printf("MATCH_32 ");
			    break;
			case M88110_MATCH_64:
			    printf("MATCH_64 ");
			    break;
			case M88110_MATCH_128:
			    printf("MATCH_128 ");
			    break;
			case M88110_MATCH_256:
			    printf("MATCH_256 ");
			    break;
			case M88110_MATCH_512:
			    printf("MATCH_512 ");
			    break;
			case M88110_MATCH_1024:
			    printf("MATCH_1024 ");
			    break;
			case M88110_MATCH_2048:
			    printf("MATCH_2048 ");
			    break;
			case M88110_MATCH_4096:
			    printf("MATCH_4096 ");
			    break;
			default:
			    printf("%d (?)", spu.data_bp[j].ctrl.addr_match);
			    break;
			}
			printf("v %d\n", spu.data_bp[j].ctrl.v);
		    }
		    printf("      psr le %d se %d c %d sgn_imd %d sm %d "
			   "sfu1dis %d mxm_dis %d\n" , spu.psr.le, spu.psr.se,
			   spu.psr.c, spu.psr.sgn_imd, spu.psr.sm,
			   spu.psr.sfu1dis, spu.psr.mxm_dis);
		    break;

		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_I860){
	    struct i860_thread_state_regs cpu;

	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case I860_THREAD_STATE_REGS:
		    printf("      flavor I860_THREAD_STATE_REGS\n");
		    if(count == I860_THREAD_STATE_REGS_COUNT)
			printf("      count I860_THREAD_STATE_REGS_COUNT\n");
		    else
			printf("      count %u (not I860_THREAD_STATE_REGS_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(struct i860_thread_state_regs)){
		        memcpy((char *)&cpu, begin,
			       sizeof(struct i860_thread_state_regs));
		        begin += sizeof(struct i860_thread_state_regs);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(struct i860_thread_state_regs));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_i860_thread_state_regs(&cpu, host_byte_sex);
		    printf(" iregs\n");
		    for(j = 0 ; j < 31 ; j += k){
			for(k = 0 ; k < 5 && j + k < 31 ; k++)
			    printf(" i%-2u 0x%08x", j + k,
				   (unsigned int)cpu.ireg[j + k]);
			printf("\n");
		    }
		    printf(" fregs\n");
		    for(j = 0 ; j < 30 ; j += k){
			for(k = 0 ; k < 5 && j + k < 30 ; k++)
			    printf(" f%-2u 0x%08x", j + k,
				   (unsigned int)cpu.freg[j + k]);
			printf("\n");
		    }
		    printf(" psr 0x%08x epsr 0x%08x db 0x%08x pc 0x%08x\n",
			   (unsigned int)cpu.psr, (unsigned int)cpu.epsr,
			   (unsigned int)cpu.db, (unsigned int)cpu.pc);
		    printf(" Mres3 %e Ares3 %e\n", cpu.Mres3, cpu.Ares3);
		    printf(" Mres2 %e Ares2 %e\n", cpu.Mres2, cpu.Ares2);
		    printf(" Mres1 %e Ares1 %e\n", cpu.Mres1, cpu.Ares1);
		    printf(" Ires1 %e\n", cpu.Ires1);
		    printf(" Lres3m %e Lres2m %e Lres1m %e\n", cpu.Lres3m,
			   cpu.Lres2m, cpu.Lres1m);
		    printf(" KR %e KI %e T %e\n", cpu.KR, cpu.KI, cpu.T);
		    printf(" Fsr3 0x%08x Fsr2 0x%08x Fsr1 0x%08x\n",
			   (unsigned int)cpu.Fsr3, (unsigned int)cpu.Fsr2,
			   (unsigned int)cpu.Fsr1);
		    printf(" Mergelo32 0x%08x Mergehi32 0x%08x\n",
			   (unsigned int)cpu.Mergelo32,
			   (unsigned int)cpu.Mergehi32);
		    break;

		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_I386 ||
	        cputype == CPU_TYPE_X86_64){
	    i386_thread_state_t cpu;
/* current i386 thread states */
#if i386_THREAD_STATE == 1
#ifndef i386_EXCEPTION_STATE_COUNT
	    char *fpu;
	    uint32_t fpu_size;
#else /* defined(i386_EXCEPTION_STATE_COUNT) */
	    i386_float_state_t fpu;
#endif /* defined(i386_EXCEPTION_STATE_COUNT) */
	    i386_exception_state_t exc;
	    uint32_t f, g;

#ifdef x86_THREAD_STATE64
	    x86_thread_state64_t cpu64;
	    x86_float_state64_t fpu64;
	    x86_exception_state64_t exc64;
	    x86_debug_state64_t debug64;
	    x86_debug_state32_t debug;
	    struct x86_thread_state ts;
	    struct x86_float_state fs;
	    struct x86_exception_state es;
	    struct x86_debug_state ds;
#endif /* x86_THREAD_STATE64 */

#endif /* i386_THREAD_STATE == 1 */

/* i386 thread states on older releases */
#if i386_THREAD_STATE == -1
	    i386_thread_fpstate_t fpu;
	    i386_thread_exceptstate_t exc;
	    i386_thread_cthreadstate_t user;
	    const char *tags[] = { "VALID", "ZERO", "SPEC", "EMPTY" };
#endif /* i386_THREAD_STATE == -1 */

	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case i386_THREAD_STATE:
		    printf("     flavor i386_THREAD_STATE\n");
		    if(count == i386_THREAD_STATE_COUNT)
			printf("      count i386_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not i386_THREAD_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(i386_thread_state_t)){
		        memcpy((char *)&cpu, begin,
			       sizeof(i386_thread_state_t));
		        begin += sizeof(i386_thread_state_t);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(i386_thread_state_t));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
#if defined(x86_THREAD_STATE64) && i386_THREAD_STATE != -1
print_x86_thread_state32:
#endif
		    if(swapped)
			swap_i386_thread_state(&cpu, host_byte_sex);
		    printf(
		       "\t    eax 0x%08x ebx    0x%08x ecx 0x%08x edx 0x%08x\n"
		       "\t    edi 0x%08x esi    0x%08x ebp 0x%08x esp 0x%08x\n"
		       "\t    ss  0x%08x eflags 0x%08x eip 0x%08x cs  0x%08x\n"
		       "\t    ds  0x%08x es     0x%08x fs  0x%08x gs  0x%08x\n",
			cpu.eax, cpu.ebx, cpu.ecx, cpu.edx, cpu.edi, cpu.esi,
			cpu.ebp, cpu.esp, cpu.ss, cpu.eflags, cpu.eip, cpu.cs,
			cpu.ds, cpu.es, cpu.fs, cpu.gs);
		    break;

/* current i386 thread states */
#if i386_THREAD_STATE == 1
		case i386_FLOAT_STATE:
		    printf("     flavor i386_FLOAT_STATE\n");
		    if(count == i386_FLOAT_STATE_COUNT)
			printf("      count i386_FLOAT_STATE_COUNT\n");
		    else
			printf("      count %u (not i386_FLOAT_STATE_COUNT)\n",
			       count);
		    left = end - begin;
#ifndef i386_EXCEPTION_STATE_COUNT
		    fpu = begin;
		    if(left >= sizeof(struct i386_float_state)){
			fpu_size = sizeof(struct i386_float_state);
		        begin += sizeof(struct i386_float_state);
		    }
		    else{
			fpu_size = left;
		        begin += left;
		    }
		    printf("\t    i386_float_state:\n");
		    for(f = 0; f < fpu_size; /* no increment expr */){
			printf("\t    ");
			for(g = 0; g < 16 && f < fpu_size; g++){
			    printf("%02x ", (unsigned int)(fpu[f] & 0xff));
			    f++;
			}
			printf("\n");
		    }
#else /* defined(i386_EXCEPTION_STATE_COUNT) */
		    if(left >= sizeof(i386_float_state_t)){
		        memcpy((char *)&fpu, begin,
			       sizeof(i386_float_state_t));
		        begin += sizeof(i386_float_state_t);
		    }
		    else{
		        memset((char *)&fpu, '\0',
			       sizeof(i386_float_state_t));
		        memcpy((char *)&fpu, begin, left);
		        begin += left;
		    }
#ifdef x86_THREAD_STATE64
print_x86_float_state32:
#endif /* x86_THREAD_STATE64 */
		    if(swapped)
			swap_i386_float_state(&fpu, host_byte_sex);
		    printf("\t    fpu_reserved[0] %d fpu_reserved[1] %d\n",
			   fpu.fpu_reserved[0], fpu.fpu_reserved[1]);
		    printf("\t    control: invalid %d denorm %d zdiv %d ovrfl "
			   "%d undfl %d precis %d\n",
			   fpu.fpu_fcw.invalid,
			   fpu.fpu_fcw.denorm,
			   fpu.fpu_fcw.zdiv,
			   fpu.fpu_fcw.ovrfl,
			   fpu.fpu_fcw.undfl,
			   fpu.fpu_fcw.precis);
		    printf("\t\t     pc ");
		    switch(fpu.fpu_fcw.pc){
		    case FP_PREC_24B:
			printf("FP_PREC_24B ");
			break;
		    case FP_PREC_53B:
			printf("FP_PREC_53B ");
			break;
		    case FP_PREC_64B:
			printf("FP_PREC_64B ");
			break;
		    default:
			printf("%d ", fpu.fpu_fcw.pc);
			break;
		    }
		    printf("rc ");
		    switch(fpu.fpu_fcw.rc){
		    case FP_RND_NEAR:
			printf("FP_RND_NEAR ");
			break;
		    case FP_RND_DOWN:
			printf("FP_RND_DOWN ");
			break;
		    case FP_RND_UP:
			printf("FP_RND_UP ");
			break;
		    case FP_CHOP:
			printf("FP_CHOP ");
			break;
		    }
		    printf("\n");
		    printf("\t    status: invalid %d denorm %d zdiv %d ovrfl "
			   "%d undfl %d precis %d stkflt %d\n",
			   fpu.fpu_fsw.invalid,
			   fpu.fpu_fsw.denorm,
			   fpu.fpu_fsw.zdiv,
			   fpu.fpu_fsw.ovrfl,
			   fpu.fpu_fsw.undfl,
			   fpu.fpu_fsw.precis,
			   fpu.fpu_fsw.stkflt);
		    printf("\t            errsumm %d c0 %d c1 %d c2 %d tos %d "
			   "c3 %d busy %d\n",
			   fpu.fpu_fsw.errsumm,
			   fpu.fpu_fsw.c0,
			   fpu.fpu_fsw.c1,
			   fpu.fpu_fsw.c2,
			   fpu.fpu_fsw.tos,
			   fpu.fpu_fsw.c3,
			   fpu.fpu_fsw.busy);
		    printf("\t    fpu_ftw 0x%02x fpu_rsrv1 0x%02x fpu_fop "
			   "0x%04x fpu_ip 0x%08x\n",
			   (unsigned int)fpu.fpu_ftw,
			   (unsigned int)fpu.fpu_rsrv1,
			   (unsigned int)fpu.fpu_fop,
			   (unsigned int)fpu.fpu_ip);
		    printf("\t    fpu_cs 0x%04x fpu_rsrv2 0x%04x fpu_dp 0x%08x "
			   "fpu_ds 0x%04x\n",
			   (unsigned int)fpu.fpu_cs,
			   (unsigned int)fpu.fpu_rsrv2,
			   (unsigned int)fpu.fpu_dp,
			   (unsigned int)fpu.fpu_ds);
		    printf("\t    fpu_rsrv3 0x%04x fpu_mxcsr 0x%08x "
			   "fpu_mxcsrmask 0x%08x\n",
			   (unsigned int)fpu.fpu_rsrv3,
			   (unsigned int)fpu.fpu_mxcsr,
			   (unsigned int)fpu.fpu_mxcsrmask);
		    printf("\t    fpu_stmm0:\n");
		    print_mmst_reg(&fpu.fpu_stmm0);
		    printf("\t    fpu_stmm1:\n");
		    print_mmst_reg(&fpu.fpu_stmm1);
		    printf("\t    fpu_stmm2:\n");
		    print_mmst_reg(&fpu.fpu_stmm2);
		    printf("\t    fpu_stmm3:\n");
		    print_mmst_reg(&fpu.fpu_stmm3);
		    printf("\t    fpu_stmm4:\n");
		    print_mmst_reg(&fpu.fpu_stmm4);
		    printf("\t    fpu_stmm5:\n");
		    print_mmst_reg(&fpu.fpu_stmm5);
		    printf("\t    fpu_stmm6:\n");
		    print_mmst_reg(&fpu.fpu_stmm6);
		    printf("\t    fpu_stmm7:\n");
		    print_mmst_reg(&fpu.fpu_stmm7);
		    printf("\t    fpu_xmm0:\n");
		    print_xmm_reg(&fpu.fpu_xmm0);
		    printf("\t    fpu_xmm1:\n");
		    print_xmm_reg(&fpu.fpu_xmm1);
		    printf("\t    fpu_xmm2:\n");
		    print_xmm_reg(&fpu.fpu_xmm2);
		    printf("\t    fpu_xmm3:\n");
		    print_xmm_reg(&fpu.fpu_xmm3);
		    printf("\t    fpu_xmm4:\n");
		    print_xmm_reg(&fpu.fpu_xmm4);
		    printf("\t    fpu_xmm5:\n");
		    print_xmm_reg(&fpu.fpu_xmm5);
		    printf("\t    fpu_xmm6:\n");
		    print_xmm_reg(&fpu.fpu_xmm6);
		    printf("\t    fpu_xmm7:\n");
		    print_xmm_reg(&fpu.fpu_xmm7);
		    printf("\t    fpu_rsrv4:\n");
		    for(f = 0; f < 14; f++){
			printf("\t            ");
			for(g = 0; g < 16; g++){
			    printf("%02x ",
				   (unsigned int)(fpu.fpu_rsrv4[f*g] & 0xff));
			}
			printf("\n");
		    }
		    printf("\t    fpu_reserved1 0x%08x\n",
			   (unsigned int)fpu.fpu_reserved1);
#endif /* defined(i386_EXCEPTION_STATE_COUNT) */
		    break;

		case i386_EXCEPTION_STATE:
		    printf("     flavor i386_EXCEPTION_STATE\n");
		    if(count == I386_EXCEPTION_STATE_COUNT)
			printf("      count I386_EXCEPTION_STATE_COUNT\n");
		    else
			printf("      count %u (not I386_EXCEPTION_STATE_COUNT"
			       ")\n", count);
		    left = end - begin;
		    if(left >= sizeof(i386_exception_state_t)){
		        memcpy((char *)&exc, begin,
			       sizeof(i386_exception_state_t));
		        begin += sizeof(i386_exception_state_t);
		    }
		    else{
		        memset((char *)&exc, '\0',
			       sizeof(i386_exception_state_t));
		        memcpy((char *)&exc, begin, left);
		        begin += left;
		    }
#ifdef x86_THREAD_STATE64
print_x86_exception_state32:
#endif /* x86_THREAD_STATE64 */
		    if(swapped)
			swap_i386_exception_state(&exc, host_byte_sex);
		    printf("\t    trapno 0x%08x err 0x%08x faultvaddr 0x%08x\n",
			   exc.trapno, exc.err, exc.faultvaddr);
		    break;

#ifdef x86_THREAD_STATE64
		case x86_DEBUG_STATE32:
		    printf("     flavor x86_DEBUG_STATE32\n");
		    if(count == x86_DEBUG_STATE32_COUNT)
			printf("      count x86_DEBUG_STATE32_COUNT\n");
		    else
			printf("      count %u (not x86_DEBUG_STATE32_COUNT"
			       ")\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_debug_state32_t)){
		        memcpy((char *)&debug, begin,
			       sizeof(x86_debug_state32_t));
		        begin += sizeof(x86_debug_state32_t);
		    }
		    else{
		        memset((char *)&debug, '\0',
			       sizeof(x86_debug_state32_t));
		        memcpy((char *)&debug, begin, left);
		        begin += left;
		    }
print_x86_debug_state32:
		    if(swapped)
			swap_x86_debug_state32(&debug, host_byte_sex);
		    printf("\t    dr0 0x%08x dr1 0x%08x dr2 0x%08x dr3 "
			   "0x%08x\n", debug.dr0, debug.dr1, debug.dr2,
			   debug.dr3);
		    printf("\t    dr4 0x%08x dr5 0x%08x dr6 0x%08x dr7 "
			   "0x%08x\n", debug.dr4, debug.dr5, debug.dr6,
			   debug.dr7);
		    break;

		case x86_THREAD_STATE64:
		    printf("     flavor x86_THREAD_STATE64\n");
		    if(count == x86_THREAD_STATE64_COUNT)
			printf("      count x86_THREAD_STATE64_COUNT\n");
		    else
			printf("      count %u (not x86_THREAD_STATE64_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_thread_state64_t)){
		        memcpy((char *)&cpu64, begin,
			       sizeof(x86_thread_state64_t));
		        begin += sizeof(x86_thread_state64_t);
		    }
		    else{
		        memset((char *)&cpu64, '\0',
			       sizeof(x86_thread_state64_t));
		        memcpy((char *)&cpu64, begin, left);
		        begin += left;
		    }
print_x86_thread_state64:
		    if(swapped)
			swap_x86_thread_state64(&cpu64, host_byte_sex);

		    printf("   rax  0x%016llx rbx 0x%016llx rcx  0x%016llx\n"
			   "   rdx  0x%016llx rdi 0x%016llx rsi  0x%016llx\n"
			   "   rbp  0x%016llx rsp 0x%016llx r8   0x%016llx\n"
			   "    r9  0x%016llx r10 0x%016llx r11  0x%016llx\n"
			   "   r12  0x%016llx r13 0x%016llx r14  0x%016llx\n"
			   "   r15  0x%016llx rip 0x%016llx\n"
			   "rflags  0x%016llx cs  0x%016llx fs   0x%016llx\n"
			   "    gs  0x%016llx\n",
                        cpu64.rax, cpu64.rbx, cpu64.rcx, cpu64.rdx, cpu64.rdi,
			cpu64.rsi, cpu64.rbp, cpu64.rsp, cpu64.r8, cpu64.r9,
			cpu64.r10, cpu64.r11, cpu64.r12, cpu64.r13, cpu64.r14,
			cpu64.r15, cpu64.rip, cpu64.rflags, cpu64.cs, cpu64.fs,
			cpu64.gs);
		    break;

		case x86_FLOAT_STATE64:
		    printf("     flavor x86_FLOAT_STATE64\n");
		    if(count == x86_FLOAT_STATE64_COUNT)
			printf("      count x86_FLOAT_STATE64_COUNT\n");
		    else
			printf("      count %u (not x86_FLOAT_STATE64_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_float_state64_t)){
		        memcpy((char *)&fpu64, begin,
			       sizeof(x86_float_state64_t));
		        begin += sizeof(x86_float_state64_t);
		    }
		    else{
		        memset((char *)&fpu64, '\0',
			       sizeof(x86_float_state64_t));
		        memcpy((char *)&fpu64, begin, left);
		        begin += left;
		    }
print_x86_float_state64:
		    if(swapped)
			swap_x86_float_state64(&fpu64, host_byte_sex);
		    printf("\t    fpu_reserved[0] %d fpu_reserved[1] %d\n",
			   fpu64.fpu_reserved[0], fpu64.fpu_reserved[1]);
		    printf("\t    control: invalid %d denorm %d zdiv %d ovrfl "
			   "%d undfl %d precis %d\n",
			   fpu64.fpu_fcw.invalid,
			   fpu64.fpu_fcw.denorm,
			   fpu64.fpu_fcw.zdiv,
			   fpu64.fpu_fcw.ovrfl,
			   fpu64.fpu_fcw.undfl,
			   fpu64.fpu_fcw.precis);
		    printf("\t\t     pc ");
		    switch(fpu64.fpu_fcw.pc){
		    case FP_PREC_24B:
			printf("FP_PREC_24B ");
			break;
		    case FP_PREC_53B:
			printf("FP_PREC_53B ");
			break;
		    case FP_PREC_64B:
			printf("FP_PREC_64B ");
			break;
		    default:
			printf("%d ", fpu64.fpu_fcw.pc);
			break;
		    }
		    printf("rc ");
		    switch(fpu64.fpu_fcw.rc){
		    case FP_RND_NEAR:
			printf("FP_RND_NEAR ");
			break;
		    case FP_RND_DOWN:
			printf("FP_RND_DOWN ");
			break;
		    case FP_RND_UP:
			printf("FP_RND_UP ");
			break;
		    case FP_CHOP:
			printf("FP_CHOP ");
			break;
		    }
		    printf("\n");
		    printf("\t    status: invalid %d denorm %d zdiv %d ovrfl "
			   "%d undfl %d precis %d stkflt %d\n",
			   fpu64.fpu_fsw.invalid,
			   fpu64.fpu_fsw.denorm,
			   fpu64.fpu_fsw.zdiv,
			   fpu64.fpu_fsw.ovrfl,
			   fpu64.fpu_fsw.undfl,
			   fpu64.fpu_fsw.precis,
			   fpu64.fpu_fsw.stkflt);
		    printf("\t            errsumm %d c0 %d c1 %d c2 %d tos %d "
			   "c3 %d busy %d\n",
			   fpu64.fpu_fsw.errsumm,
			   fpu64.fpu_fsw.c0,
			   fpu64.fpu_fsw.c1,
			   fpu64.fpu_fsw.c2,
			   fpu64.fpu_fsw.tos,
			   fpu64.fpu_fsw.c3,
			   fpu64.fpu_fsw.busy);
		    printf("\t    fpu_ftw 0x%02x fpu_rsrv1 0x%02x fpu_fop "
			   "0x%04x fpu_ip 0x%08x\n",
			   (unsigned int)fpu64.fpu_ftw,
			   (unsigned int)fpu64.fpu_rsrv1,
			   (unsigned int)fpu64.fpu_fop,
			   (unsigned int)fpu64.fpu_ip);
		    printf("\t    fpu_cs 0x%04x fpu_rsrv2 0x%04x fpu_dp 0x%08x "
			   "fpu_ds 0x%04x\n",
			   (unsigned int)fpu64.fpu_cs,
			   (unsigned int)fpu64.fpu_rsrv2,
			   (unsigned int)fpu64.fpu_dp,
			   (unsigned int)fpu64.fpu_ds);
		    printf("\t    fpu_rsrv3 0x%04x fpu_mxcsr 0x%08x "
			   "fpu_mxcsrmask 0x%08x\n",
			   (unsigned int)fpu64.fpu_rsrv3,
			   (unsigned int)fpu64.fpu_mxcsr,
			   (unsigned int)fpu64.fpu_mxcsrmask);
		    printf("\t    fpu_stmm0:\n");
		    print_mmst_reg(&fpu64.fpu_stmm0);
		    printf("\t    fpu_stmm1:\n");
		    print_mmst_reg(&fpu64.fpu_stmm1);
		    printf("\t    fpu_stmm2:\n");
		    print_mmst_reg(&fpu64.fpu_stmm2);
		    printf("\t    fpu_stmm3:\n");
		    print_mmst_reg(&fpu64.fpu_stmm3);
		    printf("\t    fpu_stmm4:\n");
		    print_mmst_reg(&fpu64.fpu_stmm4);
		    printf("\t    fpu_stmm5:\n");
		    print_mmst_reg(&fpu64.fpu_stmm5);
		    printf("\t    fpu_stmm6:\n");
		    print_mmst_reg(&fpu64.fpu_stmm6);
		    printf("\t    fpu_stmm7:\n");
		    print_mmst_reg(&fpu64.fpu_stmm7);
		    printf("\t    fpu_xmm0:\n");
		    print_xmm_reg(&fpu64.fpu_xmm0);
		    printf("\t    fpu_xmm1:\n");
		    print_xmm_reg(&fpu64.fpu_xmm1);
		    printf("\t    fpu_xmm2:\n");
		    print_xmm_reg(&fpu64.fpu_xmm2);
		    printf("\t    fpu_xmm3:\n");
		    print_xmm_reg(&fpu64.fpu_xmm3);
		    printf("\t    fpu_xmm4:\n");
		    print_xmm_reg(&fpu64.fpu_xmm4);
		    printf("\t    fpu_xmm5:\n");
		    print_xmm_reg(&fpu64.fpu_xmm5);
		    printf("\t    fpu_xmm6:\n");
		    print_xmm_reg(&fpu64.fpu_xmm6);
		    printf("\t    fpu_xmm7:\n");
		    print_xmm_reg(&fpu64.fpu_xmm7);
		    printf("\t    fpu_xmm8:\n");
		    print_xmm_reg(&fpu64.fpu_xmm8);
		    printf("\t    fpu_xmm9:\n");
		    print_xmm_reg(&fpu64.fpu_xmm9);
		    printf("\t    fpu_xmm10:\n");
		    print_xmm_reg(&fpu64.fpu_xmm10);
		    printf("\t    fpu_xmm11:\n");
		    print_xmm_reg(&fpu64.fpu_xmm11);
		    printf("\t    fpu_xmm12:\n");
		    print_xmm_reg(&fpu64.fpu_xmm12);
		    printf("\t    fpu_xmm13:\n");
		    print_xmm_reg(&fpu64.fpu_xmm13);
		    printf("\t    fpu_xmm14:\n");
		    print_xmm_reg(&fpu64.fpu_xmm14);
		    printf("\t    fpu_xmm15:\n");
		    print_xmm_reg(&fpu64.fpu_xmm15);
		    printf("\t    fpu_rsrv4:\n");
		    for(f = 0; f < 6; f++){
			printf("\t            ");
			for(g = 0; g < 16; g++){
			    printf("%02x ",
				   (unsigned int)(fpu64.fpu_rsrv4[f*g] & 0xff));
			}
			printf("\n");
		    }
		    printf("\t    fpu_reserved1 0x%08x\n",
			   (unsigned int)fpu64.fpu_reserved1);
		    break;

		case x86_EXCEPTION_STATE64:
		    printf("     flavor x86_EXCEPTION_STATE64\n");
		    if(count == x86_EXCEPTION_STATE64_COUNT)
			printf("      count x86_EXCEPTION_STATE64_COUNT\n");
		    else
			printf("      count %u (not x86_EXCEPTION_STATE64_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_exception_state64_t)){
		        memcpy((char *)&exc64, begin,
			       sizeof(x86_exception_state64_t));
		        begin += sizeof(x86_exception_state64_t);
		    }
		    else{
		        memset((char *)&exc64, '\0',
			       sizeof(x86_exception_state64_t));
		        memcpy((char *)&exc64, begin, left);
		        begin += left;
		    }
print_x86_exception_state64:
		    if(swapped)
			swap_x86_exception_state64(&exc64, host_byte_sex);
		    printf("\t    trapno 0x%08x err 0x%08x faultvaddr "
			   "0x%016llx\n", exc64.trapno, exc64.err,
			   exc64.faultvaddr);
		    break;

		case x86_DEBUG_STATE64:
		    printf("     flavor x86_DEBUG_STATE64\n");
		    if(count == x86_DEBUG_STATE64_COUNT)
			printf("      count x86_DEBUG_STATE64_COUNT\n");
		    else
			printf("      count %u (not x86_DEBUG_STATE64_COUNT"
			       ")\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_debug_state64_t)){
		        memcpy((char *)&debug64, begin,
			       sizeof(x86_debug_state32_t));
		        begin += sizeof(x86_debug_state32_t);
		    }
		    else{
		        memset((char *)&debug64, '\0',
			       sizeof(x86_debug_state64_t));
		        memcpy((char *)&debug64, begin, left);
		        begin += left;
		    }
print_x86_debug_state64:
		    if(swapped)
			swap_x86_debug_state64(&debug64, host_byte_sex);
		    printf("\t    dr0 0x%016llx dr1 0x%016llx dr2 0x%016llx "
			   "dr3 0x%016llx\n", debug64.dr0, debug64.dr1,
			   debug64.dr2, debug64.dr3);
		    printf("\t    dr4 0x%016llx dr5 0x%016llx dr6 0x%016llx "
			   "dr7 0x%016llx\n", debug64.dr4, debug64.dr5,
			   debug64.dr6, debug64.dr7);
		    break;

		case x86_THREAD_STATE:
		    printf("     flavor x86_THREAD_STATE\n");
		    if(count == x86_THREAD_STATE_COUNT)
			printf("      count x86_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not x86_THREAD_STATE_COUNT)\n",
			       count);
		    left = end - begin;
		    if(left >= sizeof(x86_thread_state_t)){
		        memcpy((char *)&ts, begin,
			       sizeof(x86_thread_state_t));
		        begin += sizeof(x86_thread_state_t);
		    }
		    else{
		        memset((char *)&ts, '\0',
			       sizeof(x86_thread_state_t));
		        memcpy((char *)&ts, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_x86_state_hdr(&ts.tsh, host_byte_sex);
		    if(ts.tsh.flavor == x86_THREAD_STATE32){
			printf("\t    tsh.flavor x86_THREAD_STATE32 ");
			if(ts.tsh.count == x86_THREAD_STATE32_COUNT)
			    printf("tsh.count x86_THREAD_STATE32_COUNT\n");
			else
			    printf("tsh.count %d (not x86_THREAD_STATE32_"
				   "COUNT\n", ts.tsh.count);
			cpu = ts.uts.ts32;
			goto print_x86_thread_state32;
		    }
		    else if(ts.tsh.flavor == x86_THREAD_STATE64){
			printf("\t    tsh.flavor x86_THREAD_STATE64 ");
			if(ts.tsh.count == x86_THREAD_STATE64_COUNT)
			    printf("tsh.count x86_THREAD_STATE64_COUNT\n");
			else
			    printf("tsh.count %d (not x86_THREAD_STATE64_"
				   "COUNT\n", ts.tsh.count);
			cpu64 = ts.uts.ts64;
			goto print_x86_thread_state64;
		    }
		    else{
			printf("\t    tsh.flavor %d tsh.count %d\n",
			       ts.tsh.flavor, ts.tsh.count);
		    }
		    break;

		case x86_FLOAT_STATE:
		    printf("     flavor x86_FLOAT_STATE\n");
		    if(count == x86_FLOAT_STATE_COUNT)
			printf("      count x86_FLOAT_STATE_COUNT\n");
		    else
			printf("      count %u (not x86_FLOAT_STATE_COUNT)\n",
			       count);
		    left = end - begin;
		    if(left >= sizeof(x86_float_state_t)){
		        memcpy((char *)&fs, begin,
			       sizeof(x86_float_state_t));
		        begin += sizeof(x86_float_state_t);
		    }
		    else{
		        memset((char *)&fs, '\0',
			       sizeof(x86_float_state_t));
		        memcpy((char *)&fs, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_x86_state_hdr(&fs.fsh, host_byte_sex);
		    if(fs.fsh.flavor == x86_FLOAT_STATE32){
			printf("\t    fsh.flavor x86_FLOAT_STATE32 ");
			if(fs.fsh.count == x86_FLOAT_STATE32_COUNT)
			    printf("tsh.count x86_FLOAT_STATE32_COUNT\n");
			else
			    printf("tsh.count %d (not x86_FLOAT_STATE32_COUNT"
				   "\n", fs.fsh.count);
			fpu = fs.ufs.fs32;
			goto print_x86_float_state32;
		    }
		    else if(fs.fsh.flavor == x86_FLOAT_STATE64){
			printf("\t    fsh.flavor x86_FLOAT_STATE64 ");
			if(fs.fsh.count == x86_FLOAT_STATE64_COUNT)
			    printf("fsh.count x86_FLOAT_STATE64_COUNT\n");
			else
			    printf("fsh.count %d (not x86_FLOAT_STATE64_COUNT"
				   "\n", fs.fsh.count);
			fpu64 = fs.ufs.fs64;
			goto print_x86_float_state64;
		    }
		    else{
			printf("\t    fsh.flavor %d fsh.count %d\n",
			       fs.fsh.flavor, fs.fsh.count);
		    }
		    break;

		case x86_EXCEPTION_STATE:
		    printf("     flavor x86_EXCEPTION_STATE\n");
		    if(count == x86_EXCEPTION_STATE_COUNT)
			printf("      count x86_EXCEPTION_STATE_COUNT\n");
		    else
			printf("      count %u (not x86_EXCEPTION_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_exception_state_t)){
		        memcpy((char *)&es, begin,
			       sizeof(x86_exception_state_t));
		        begin += sizeof(x86_exception_state_t);
		    }
		    else{
		        memset((char *)&es, '\0',
			       sizeof(x86_exception_state_t));
		        memcpy((char *)&es, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_x86_state_hdr(&es.esh, host_byte_sex);
		    if(es.esh.flavor == x86_EXCEPTION_STATE32){
			printf("\t    esh.flavor x86_EXCEPTION_STATE32\n");
			if(es.esh.count == x86_EXCEPTION_STATE32_COUNT)
			    printf("\t    esh.count x86_EXCEPTION_STATE32_"
				   "COUNT\n");
			else
			    printf("\t    esh.count %d (not x86_EXCEPTION_"
				   "STATE32_COUNT\n", es.esh.count);
			exc = es.ues.es32;
			goto print_x86_exception_state32;
		    }
		    else if(es.esh.flavor == x86_EXCEPTION_STATE64){
			printf("\t    esh.flavor x86_EXCEPTION_STATE64\n");
			if(es.esh.count == x86_EXCEPTION_STATE64_COUNT)
			    printf("\t    esh.count x86_EXCEPTION_STATE64_"
				   "COUNT\n");
			else
			    printf("\t    esh.count %d (not x86_EXCEPTION_"
				   "STATE64_COUNT\n", es.esh.count);
			exc64 = es.ues.es64;
			goto print_x86_exception_state64;
		    }
		    else{
			printf("\t    esh.flavor %d esh.count %d\n",
			       es.esh.flavor, es.esh.count);
		    }
		    break;

		case x86_DEBUG_STATE:
		    printf("     flavor x86_DEBUG_STATE\n");
		    if(count == x86_DEBUG_STATE_COUNT)
			printf("      count x86_DEBUG_STATE_COUNT\n");
		    else
			printf("      count %u (not x86_DEBUG_STATE_COUNT"
			       "\n", count);
		    left = end - begin;
		    if(left >= sizeof(x86_debug_state_t)){
		        memcpy((char *)&ds, begin,
			       sizeof(x86_debug_state_t));
		        begin += sizeof(x86_debug_state_t);
		    }
		    else{
		        memset((char *)&ds, '\0',
			       sizeof(x86_debug_state_t));
		        memcpy((char *)&ds, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_x86_state_hdr(&ds.dsh, host_byte_sex);
		    if(ds.dsh.flavor == x86_DEBUG_STATE32){
			printf("\t    dsh.flavor x86_DEBUG_STATE32\n");
			if(ds.dsh.count == x86_DEBUG_STATE32_COUNT)
			    printf("\t    dsh.count x86_DEBUG_STATE32_COUNT\n");
			else
			    printf("\t    esh.count %d (not x86_DEBUG_STATE32_"
				   "_COUNT\n", ds.dsh.count);
			debug = ds.uds.ds32;
			goto print_x86_debug_state32;
		    }
		    if(ds.dsh.flavor == x86_DEBUG_STATE64){
			printf("\t    dsh.flavor x86_DEBUG_STATE64\n");
			if(ds.dsh.count == x86_DEBUG_STATE64_COUNT)
			    printf("\t    dsh.count x86_DEBUG_STATE64_COUNT\n");
			else
			    printf("\t    esh.count %d (not x86_DEBUG_STATE64_"
				   "_COUNT\n", ds.dsh.count);
			debug64 = ds.uds.ds64;
			goto print_x86_debug_state64;
		    }
		    else{
			printf("\t    dsh.flavor %d dsh.count %d\n",
			       ds.dsh.flavor, ds.dsh.count);
		    }
		    break;
#endif /* x86_THREAD_STATE64 */
#endif /* i386_THREAD_STATE == 1 */

/* i386 thread states on older releases */
#if i386_THREAD_STATE == -1
		case i386_THREAD_FPSTATE:
		    printf("     flavor i386_THREAD_FPSTATE\n");
		    if(count == i386_THREAD_FPSTATE_COUNT)
			printf("      count i386_THREAD_FPSTATE_COUNT\n");
		    else
			printf("      count %u (not i386_THREAD_FPSTATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(i386_thread_fpstate_t)){
		        memcpy((char *)&fpu, begin,
			       sizeof(i386_thread_fpstate_t));
		        begin += sizeof(i386_thread_fpstate_t);
		    }
		    else{
		        memset((char *)&fpu, '\0',
			       sizeof(i386_thread_fpstate_t));
		        memcpy((char *)&fpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_i386_thread_fpstate(&fpu, host_byte_sex);
		    printf("\t    control: invalid %d denorm %d zdiv %d ovrfl "
			   "%d undfl %d precis %d\n",
			   fpu.environ.control.invalid,
			   fpu.environ.control.denorm,
			   fpu.environ.control.zdiv,
			   fpu.environ.control.ovrfl,
			   fpu.environ.control.undfl,
			   fpu.environ.control.precis);
		    printf("\t\t     pc ");
		    switch(fpu.environ.control.pc){
		    case FP_PREC_24B:
			printf("FP_PREC_24B ");
			break;
		    case FP_PREC_53B:
			printf("FP_PREC_53B ");
			break;
		    case FP_PREC_64B:
			printf("FP_PREC_64B ");
			break;
		    default:
			printf("%d ", fpu.environ.control.pc);
			break;
		    }
		    printf("rc ");
		    switch(fpu.environ.control.rc){
		    case FP_RND_NEAR:
			printf("FP_RND_NEAR ");
			break;
		    case FP_RND_DOWN:
			printf("FP_RND_DOWN ");
			break;
		    case FP_RND_UP:
			printf("FP_RND_UP ");
			break;
		    case FP_CHOP:
			printf("FP_CHOP ");
			break;
		    }
		    printf("\n");

		    printf("\t    status: invalid %d denorm %d zdiv %d ovrfl "
			   "%d undfl %d precis %d stkflt %d\n",
			   fpu.environ.status.invalid,
			   fpu.environ.status.denorm,
			   fpu.environ.status.zdiv,
			   fpu.environ.status.ovrfl,
			   fpu.environ.status.undfl,
			   fpu.environ.status.precis,
			   fpu.environ.status.stkflt);
		    printf("\t\t    errsumm %d c0 %d c1 %d c2 %d tos %d c3 %d "
			   "busy %d\n", fpu.environ.status.errsumm,
			   fpu.environ.status.c0, fpu.environ.status.c1,
			   fpu.environ.status.c2, fpu.environ.status.tos,
			   fpu.environ.status.c3, fpu.environ.status.busy);
		    printf("\t    tags: tag0 %s tag1 %s tag2 %s tag3 %s\n"
			   "\t          tag4 %s tag5 %s tag6 %s tag7 %s\n",
			   tags[fpu.environ.tag.tag0],
			   tags[fpu.environ.tag.tag1],
			   tags[fpu.environ.tag.tag2],
			   tags[fpu.environ.tag.tag3],
			   tags[fpu.environ.tag.tag4],
			   tags[fpu.environ.tag.tag5],
			   tags[fpu.environ.tag.tag6],
			   tags[fpu.environ.tag.tag7]);
		    printf("\t    ip 0x%08x\n", fpu.environ.ip);
		    printf("\t    cs: rpl ");
		    switch(fpu.environ.cs.rpl){
		    case KERN_PRIV:
			printf("KERN_PRIV ");
			break;
		    case USER_PRIV:
			printf("USER_PRIV ");
			break;
		    default:
			printf("%d ", fpu.environ.cs.rpl);
			break;
		    }
		    printf("ti ");
		    switch(fpu.environ.cs.ti){
		    case SEL_GDT:
			printf("SEL_GDT ");
			break;
		    case SEL_LDT:
			printf("SEL_LDT ");
			break;
		    }
		    printf("index %d\n", fpu.environ.cs.index);
		    printf("\t    opcode 0x%04x\n",
			   (unsigned int)fpu.environ.opcode);
		    printf("\t    dp 0x%08x\n", fpu.environ.dp);
		    printf("\t    ds: rpl ");
		    switch(fpu.environ.ds.rpl){
		    case KERN_PRIV:
			printf("KERN_PRIV ");
			break;
		    case USER_PRIV:
			printf("USER_PRIV ");
			break;
		    default:
			printf("%d ", fpu.environ.ds.rpl);
			break;
		    }
		    printf("ti ");
		    switch(fpu.environ.ds.ti){
		    case SEL_GDT:
			printf("SEL_GDT ");
			break;
		    case SEL_LDT:
			printf("SEL_LDT ");
			break;
		    }
		    printf("index %d\n", fpu.environ.ds.index);
		    printf("\t    stack:\n");
		    for(i = 0; i < 8; i++){
			printf("\t\tST[%u] mant 0x%04x 0x%04x 0x%04x 0x%04x "
			       "exp 0x%04x sign %d\n", i,
			       (unsigned int)fpu.stack.ST[i].mant,
			       (unsigned int)fpu.stack.ST[i].mant1,
			       (unsigned int)fpu.stack.ST[i].mant2,
			       (unsigned int)fpu.stack.ST[i].mant3,
			       (unsigned int)fpu.stack.ST[i].exp,
			       fpu.stack.ST[i].sign);
		    }
		    break;
		case i386_THREAD_EXCEPTSTATE:
		    printf("     flavor i386_THREAD_EXCEPTSTATE\n");
		    if(count == i386_THREAD_EXCEPTSTATE_COUNT)
			printf("      count i386_THREAD_EXCEPTSTATE_COUNT\n");
		    else
			printf("      count %u (not i386_THREAD_EXCEPTSTATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(i386_thread_exceptstate_t)){
		        memcpy((char *)&exc, begin,
			       sizeof(i386_thread_exceptstate_t));
		        begin += sizeof(i386_thread_exceptstate_t);
		    }
		    else{
		        memset((char *)&exc, '\0',
			       sizeof(i386_thread_exceptstate_t));
		        memcpy((char *)&exc, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_i386_thread_exceptstate(&exc, host_byte_sex);
		    printf("\t    trapno 0x%08x\n", exc.trapno);
		    if(exc.trapno == 14){
			printf("\t    err.pgfault: prot %d wrtflt %d user %d\n",
			       exc.err.pgfault.prot, exc.err.pgfault.wrtflt,
			       exc.err.pgfault.user);
		    }
		    else{
			printf("\t    err.normal: ext %d ", exc.err.normal.ext);
			printf("tbl ");
			switch(exc.err.normal.tbl){
		        case ERR_GDT:
			    printf("ERR_GDT ");
			    break;
		        case ERR_IDT:
			    printf("ERR_IDT ");
			    break;
		        case ERR_LDT:
			    printf("ERR_LDT ");
			    break;
			default:
			    printf("%d ", exc.err.normal.tbl);
			    break;
			}
			printf("index %d\n", exc.err.normal.index);
		    }
		    break;

		case i386_THREAD_CTHREADSTATE:
		    printf("     flavor i386_THREAD_CTHREADSTATE\n");
		    if(count == i386_THREAD_CTHREADSTATE_COUNT)
			printf("      count i386_THREAD_CTHREADSTATE_COUNT\n");
		    else
			printf("      count %u (not i386_THREAD_CTHREADSTATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(i386_thread_cthreadstate_t)){
		        memcpy((char *)&user, begin,
			       sizeof(i386_thread_cthreadstate_t));
		        begin += sizeof(i386_thread_cthreadstate_t);
		    }
		    else{
		        memset((char *)&user, '\0',
			       sizeof(i386_thread_cthreadstate_t));
		        memcpy((char *)&user, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_i386_thread_cthreadstate(&user, host_byte_sex);
		    printf("\t    self 0x%08x\n", user.self);
		    break;
#endif /* i386_THREAD_STATE == -1 */
		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_ARM){
	    arm_thread_state_t cpu;
	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case ARM_THREAD_STATE:
		    printf("     flavor ARM_THREAD_STATE\n");
		    if(count == ARM_THREAD_STATE_COUNT)
			printf("      count ARM_THREAD_STATE_COUNT\n");
		    else
			printf("      count %u (not ARM_THREAD_STATE_"
			       "COUNT)\n", count);
		    left = end - begin;
		    if(left >= sizeof(arm_thread_state_t)){
		        memcpy((char *)&cpu, begin,
			       sizeof(arm_thread_state_t));
		        begin += sizeof(arm_thread_state_t);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(arm_thread_state_t));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_arm_thread_state_t(&cpu, host_byte_sex);
		    printf(
		       "\t    r0  0x%08x r1     0x%08x r2  0x%08x r3  0x%08x\n"
		       "\t    r4  0x%08x r5     0x%08x r6  0x%08x r7  0x%08x\n"
		       "\t    r8  0x%08x r9     0x%08x r10 0x%08x r11 0x%08x\n"
		       "\t    r12 0x%08x sp     0x%08x lr  0x%08x pc  0x%08x\n"
		       "\t   cpsr 0x%08x\n",
			cpu.__r[0], cpu.__r[1], cpu.__r[2], cpu.__r[3],
			cpu.__r[4], cpu.__r[5], cpu.__r[6], cpu.__r[7],
			cpu.__r[8], cpu.__r[9], cpu.__r[10], cpu.__r[11],
			cpu.__r[12], cpu.__sp, cpu.__lr, cpu.__pc, cpu.__cpsr);
		    break;
		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else if(cputype == CPU_TYPE_ARM64){
	    arm_thread_state64_t cpu;
	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);

		switch(flavor){
		case 1:
		case ARM_THREAD_STATE64:
		    if(flavor == 1)
		        printf("     flavor 1 (not ARM_THREAD_STATE64 %u)\n",
			       ARM_THREAD_STATE64);
		    else
		        printf("     flavor ARM_THREAD_STATE64\n");
		    if(count == ARM_THREAD_STATE64_COUNT)
			printf("      count ARM_THREAD_STATE64_COUNT\n");
		    else
			printf("      count %u (not ARM_THREAD_STATE64_"
			       "COUNT %u)\n", count, ARM_THREAD_STATE64_COUNT);
		    left = end - begin;
		    if(left >= sizeof(arm_thread_state64_t)){
		        memcpy((char *)&cpu, begin,
			       sizeof(arm_thread_state64_t));
		        begin += sizeof(arm_thread_state64_t);
		    }
		    else{
		        memset((char *)&cpu, '\0',
			       sizeof(arm_thread_state64_t));
		        memcpy((char *)&cpu, begin, left);
		        begin += left;
		    }
		    if(swapped)
			swap_arm_thread_state64_t(&cpu, host_byte_sex);
		    printf(
		       "\t    x0  0x%016llx x1  0x%016llx x2  0x%016llx\n"
		       "\t    x3  0x%016llx x4  0x%016llx x5  0x%016llx\n"
		       "\t    x6  0x%016llx x7  0x%016llx x8  0x%016llx\n"
		       "\t    x9  0x%016llx x10 0x%016llx x11 0x%016llx\n"
		       "\t    x12 0x%016llx x13 0x%016llx x14 0x%016llx\n"
		       "\t    x15 0x%016llx x16 0x%016llx x17 0x%016llx\n"
		       "\t    x18 0x%016llx x19 0x%016llx x20 0x%016llx\n"
		       "\t    x21 0x%016llx x22 0x%016llx x23 0x%016llx\n"
		       "\t    x24 0x%016llx x25 0x%016llx x26 0x%016llx\n"
		       "\t    x27 0x%016llx x28 0x%016llx  fp 0x%016llx\n"
		       "\t     lr 0x%016llx sp  0x%016llx  pc 0x%016llx\n"
		       "\t   cpsr 0x%08x\n",
			cpu.__x[0], cpu.__x[1], cpu.__x[2], cpu.__x[3],
			cpu.__x[4], cpu.__x[5], cpu.__x[6], cpu.__x[7],
			cpu.__x[8], cpu.__x[9], cpu.__x[10], cpu.__x[11],
			cpu.__x[12], cpu.__x[13], cpu.__x[14], cpu.__x[15],
			cpu.__x[16], cpu.__x[17], cpu.__x[18], cpu.__x[19],
			cpu.__x[20], cpu.__x[21], cpu.__x[22], cpu.__x[23],
			cpu.__x[24], cpu.__x[25], cpu.__x[26], cpu.__x[27],
			cpu.__x[28], cpu.__fp, cpu.__lr, cpu.__sp, cpu.__pc,
			cpu.__cpsr);
		    break;
		default:
		    printf("     flavor %u (unknown)\n", flavor);
		    printf("      count %u\n", count);
		    printf("      state:\n");
		    print_unknown_state(begin, end, count, swapped);
		    begin += count * sizeof(uint32_t);
		    break;
		}
	    }
	}
	else{
	    while(begin < end){
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&flavor, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    flavor = 0;
		    begin = end;
		}
		if(swapped)
		    flavor = SWAP_INT(flavor);
		if(end - begin > (ptrdiff_t)sizeof(uint32_t)){
		    memcpy((char *)&count, begin, sizeof(uint32_t));
		    begin += sizeof(uint32_t);
		}
		else{
		    count = 0;
		    begin = end;
		}
		if(swapped)
		    count = SWAP_INT(count);
		printf("     flavor %u\n", flavor);
		printf("      count %u\n", count);
		printf("      state (Unknown cputype/cpusubtype):\n");
		print_unknown_state(begin, end, count, swapped);
		begin += count * sizeof(uint32_t);
	    }
	}
}

/* current i386 thread states */
#if i386_THREAD_STATE == 1
#ifdef i386_EXCEPTION_STATE_COUNT

static
void
print_mmst_reg(
struct mmst_reg *r)
{
    uint32_t f;

	printf("\t      mmst_reg  ");
	for(f = 0; f < 10; f++){
	    printf("%02x ",
		   (unsigned int)(r->mmst_reg[f] & 0xff));
	}
	printf("\n");
	printf("\t      mmst_rsrv ");
	for(f = 0; f < 6; f++){
	    printf("%02x ",
		   (unsigned int)(r->mmst_rsrv[f] & 0xff));
	}
	printf("\n");
}

static
void
print_xmm_reg(
struct xmm_reg *r)
{
    uint32_t f;

	printf("\t      xmm_reg ");
	for(f = 0; f < 16; f++){
	    printf("%02x ",
		   (unsigned int)(r->xmm_reg[f] & 0xff));
	}
	printf("\n");
}
#endif /* defined(i386_EXCEPTION_STATE_COUNT) */
#endif /* i386_THREAD_STATE == 1 */

static
void
print_unknown_state(
char *begin,
char *end,
unsigned int count,
enum bool swapped)
{
    uint32_t left, *state, i, j;

	left = end - begin;
	if(left * sizeof(uint32_t) >= count){
	    state = allocate(count * sizeof(uint32_t));
	    memcpy((char *)state, begin, count * sizeof(uint32_t));
	    begin += count * sizeof(uint32_t);
	}
	else{
	    state = allocate(left);
	    memset((char *)state, '\0', left);
	    memcpy((char *)state, begin, left);
	    count = left / sizeof(uint32_t);
	    begin += left;
	}
	if(swapped)
	    for(i = 0 ; i < count; i++)
		state[i] = SWAP_INT(state[i]);
	for(i = 0 ; i < count; i += j){
	    for(j = 0 ; j < 8 && i + j < count; j++)
		printf("%08x ", (unsigned int)state[i + j]);
	    printf("\n");
	}
	free(state);
}

/*
 * Print the relocation information.
 */
void
print_reloc(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_type_t cputype,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, k, left, size, nsects;
    char *p;
    struct load_command *lc, l;
    struct segment_command sg;
    struct section s;
    struct segment_command_64 sg64;
    struct section_64 s64;
    struct reloc_section_info *sect_rel;
    struct dysymtab_command dyst;
    uint64_t big_size;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	/*
	 * Create an array of section structures in the host byte sex so it
	 * can be processed and indexed into directly.
	 */
	k = 0;
	nsects = 0;
	sect_rel = NULL;
	lc = load_commands;
	dyst.cmd = 0;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_SEGMENT:
		memset((char *)&sg, '\0', sizeof(struct segment_command));
		size = left < sizeof(struct segment_command) ?
		       left : sizeof(struct segment_command);
		memcpy((char *)&sg, (char *)lc, size);
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);

		big_size = sg.nsects;
		big_size *= sizeof(struct segment_command);
		if(big_size > sg.cmdsize){
		    printf("number of sections in load command %u extends past "
			   "end of load command\n", i);
		    sg.nsects = (sg.cmdsize - sizeof(struct segment_command)) /
				sizeof(struct section);
		}
		nsects += sg.nsects;
		sect_rel = reallocate(sect_rel,
			      nsects * sizeof(struct reloc_section_info));
		memset((char *)(sect_rel + (nsects - sg.nsects)), '\0',
		       sizeof(struct reloc_section_info) * sg.nsects);
		p = (char *)lc + sizeof(struct segment_command);
		for(j = 0 ; j < sg.nsects ; j++){
		    left = sizeofcmds - (p - (char *)load_commands);
		    size = left < sizeof(struct section) ?
			   left : sizeof(struct section);
		    memcpy((char *)&s, p, size);
		    if(swapped)
			swap_section(&s, 1, host_byte_sex);

		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds)
			break;
		    p += size;
		    memcpy(sect_rel[k].segname, s.segname, 16);
		    memcpy(sect_rel[k].sectname, s.sectname, 16);
		    sect_rel[k].nreloc = s.nreloc;
		    sect_rel[k].reloff = s.reloff;
		    k++;
		}
		break;
	    case LC_SEGMENT_64:
		memset((char *)&sg64, '\0', sizeof(struct segment_command_64));
		size = left < sizeof(struct segment_command_64) ?
		       left : sizeof(struct segment_command_64);
		memcpy((char *)&sg64, (char *)lc, size);
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);

		big_size = sg64.nsects;
		big_size *= sizeof(struct segment_command_64);
		if(big_size > sg64.cmdsize){
		    printf("number of sections in load command %u extends past "
			   "end of load command\n", i);
		    sg64.nsects = (sg64.cmdsize -
				   sizeof(struct segment_command_64)) /
				  sizeof(struct section_64);
		}
		nsects += sg64.nsects;
		sect_rel = reallocate(sect_rel,
			      nsects * sizeof(struct reloc_section_info));
		memset((char *)(sect_rel + (nsects - sg64.nsects)), '\0',
		       sizeof(struct reloc_section_info) * sg64.nsects);
		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    left = sizeofcmds - (p - (char *)load_commands);
		    size = left < sizeof(struct section_64) ?
			   left : sizeof(struct section_64);
		    memcpy((char *)&s64, p, size);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);

		    if(p + sizeof(struct section_64) >
		       (char *)load_commands + sizeofcmds)
			break;
		    p += size;
		    memcpy(sect_rel[k].segname, s64.segname, 16);
		    memcpy(sect_rel[k].sectname, s64.sectname, 16);
		    sect_rel[k].nreloc = s64.nreloc;
		    sect_rel[k].reloff = s64.reloff;
		    k++;
		}
		break;
	    case LC_DYSYMTAB:
		memset((char *)&dyst, '\0', sizeof(struct dysymtab_command));
		size = left < sizeof(struct dysymtab_command) ?
		       left : sizeof(struct dysymtab_command);
		memcpy((char *)&dyst, (char *)lc, size);
		if(swapped)
		    swap_dysymtab_command(&dyst, host_byte_sex);
		break;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	if(dyst.cmd != 0){
	    if(dyst.nextrel != 0){
		printf("External relocation information %u entries",
		       dyst.nextrel);
		if(dyst.extreloff > object_size){
		    printf(" (offset to relocation entries extends past the "
			   "end of the file)\n");
		}
		else{
		    printf("\naddress  pcrel length extern type    scattered "
			   "symbolnum/value\n");

		    print_relocs(dyst.extreloff, dyst.nextrel, sect_rel, nsects,
				 swapped, cputype, object_addr, object_size,
				 symbols, symbols64, nsymbols, strings,
				 strings_size, verbose);
		}
	    }
	    if(dyst.nlocrel != 0){
		printf("Local relocation information %u entries", dyst.nlocrel);
		if(dyst.locreloff > object_size){
		    printf(" (offset to relocation entries extends past the "
			   "end of the file)\n");
		}
		else{
		    printf("\naddress  pcrel length extern type    scattered "
			   "symbolnum/value\n");

		    print_relocs(dyst.locreloff, dyst.nlocrel, sect_rel, nsects,
				 swapped, cputype, object_addr, object_size,
				 symbols, symbols64, nsymbols, strings,
				 strings_size, verbose);
		}
	    }
	}

	for(i = 0 ; i < nsects ; i++){
	    if(sect_rel[i].nreloc == 0)
		continue;
	    printf("Relocation information (%.16s,%.16s) %u entries",
		   sect_rel[i].segname, sect_rel[i].sectname,
		   sect_rel[i].nreloc);
	    if(sect_rel[i].reloff > object_size){
		printf(" (offset to relocation entries extends past the end of "
		       " the file)\n");
		continue;
	    }
	    printf("\naddress  pcrel length extern type    scattered "
		   "symbolnum/value\n");

	    print_relocs(sect_rel[i].reloff, sect_rel[i].nreloc, sect_rel,
			 nsects, swapped, cputype, object_addr, object_size,
			 symbols, symbols64, nsymbols, strings, strings_size,
			 verbose);
	}
}

static
void
print_relocs(
unsigned reloff,
unsigned nreloc,
struct reloc_section_info *sect_rel,
uint32_t nsects,
enum bool swapped,
cpu_type_t cputype,
char *object_addr,
uint32_t object_size,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    uint32_t j;
    struct relocation_info *r, reloc;
    struct scattered_relocation_info *sr;
    enum bool previous_sectdiff, previous_ppc_jbsr, previous_arm_half,predicted;
    uint32_t sectdiff_r_type;
    uint32_t n_strx;

	host_byte_sex = get_host_byte_sex();

	previous_sectdiff = FALSE;
	previous_ppc_jbsr = FALSE;
	previous_arm_half = FALSE;
	sectdiff_r_type = 0;
	for(j = 0 ;
	    j < nreloc &&
	    reloff + (j + 1) * sizeof(struct relocation_info) <= object_size;
	    j++){
	    predicted = FALSE;
	    r = (struct relocation_info *)
		 (object_addr + reloff +
		  j * sizeof(struct relocation_info));
	    memcpy((char *)&reloc, (char *)r,
		   sizeof(struct relocation_info));
	    if(swapped)
		swap_relocation_info(&reloc, 1, host_byte_sex);
	    
	    if((reloc.r_address & R_SCATTERED) != 0 &&
	       cputype != CPU_TYPE_X86_64){
		sr = (struct scattered_relocation_info *)&reloc; 
		if(verbose){
		    if((cputype == CPU_TYPE_MC680x0 &&
			sr->r_type == GENERIC_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_I386 &&
			sr->r_type == GENERIC_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_MC88000 &&
			sr->r_type == M88K_RELOC_PAIR) ||
		       ((cputype == CPU_TYPE_POWERPC ||
		         cputype == CPU_TYPE_POWERPC64 ||
		         cputype == CPU_TYPE_VEO) &&
			sr->r_type == PPC_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_HPPA &&
			sr->r_type == HPPA_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_SPARC &&
			sr->r_type == SPARC_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_ARM &&
			sr->r_type == ARM_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_I860 &&
			sr->r_type == I860_RELOC_PAIR))
			    printf("         ");
		    else
			printf("%08x ", (unsigned int)sr->r_address);
		    if(sr->r_pcrel)
			printf("True  ");
		    else
			printf("False ");
		    if(cputype == CPU_TYPE_ARM && 
		       (sr->r_type == ARM_RELOC_HALF ||
			sr->r_type == ARM_RELOC_HALF_SECTDIFF ||
			previous_arm_half == TRUE)){
			if((sr->r_length & 0x1) == 0)
			    printf("lo/");
			else
			    printf("hi/");
			if((sr->r_length & 0x2) == 0)
			    printf("arm ");
			else
			    printf("thm ");
		    }
		    else{
			switch(sr->r_length){
			case 0:
			    printf("byte   ");
			    break;
			case 1:
			    printf("word   ");
			    break;
			case 2:
			    printf("long   ");
			    break;
			case 3:
			    /*
			     * The value of 3 for r_length for PowerPC is to
			     * encode that a conditional branch using the Y-bit
			     * for static branch prediction was predicted in
			     * the assembly source.
			     */
			    if((cputype == CPU_TYPE_POWERPC64 && 
				reloc.r_type == PPC_RELOC_VANILLA) ||
			       cputype == CPU_TYPE_X86_64) {
				    printf("quad   ");
			    }
			    else if(cputype == CPU_TYPE_POWERPC ||
				    cputype == CPU_TYPE_POWERPC64 || 
				    cputype == CPU_TYPE_VEO){
				printf("long   ");
				predicted = TRUE;
			    }
			    else
				printf("?(%2d)  ", sr->r_length);
			    break;
			default:
			    printf("?(%2d)  ", sr->r_length);
			    break;
			}
		    }
		    printf("n/a    ");
		    print_r_type(cputype, sr->r_type, predicted);
		    printf("True      0x%08x", (unsigned int)sr->r_value);
		    if(previous_sectdiff == FALSE){
			if((cputype == CPU_TYPE_MC88000 &&
			    sr->r_type == M88K_RELOC_PAIR) ||
			   (cputype == CPU_TYPE_SPARC &&
			    sr->r_type == SPARC_RELOC_PAIR) ||
			   (cputype == CPU_TYPE_ARM &&
			    sr->r_type == ARM_RELOC_PAIR) ||
			   (cputype == CPU_TYPE_I860 &&
			    sr->r_type == I860_RELOC_PAIR))
			    printf(" half = 0x%04x ",
				   (unsigned int)sr->r_address);
			else if(cputype == CPU_TYPE_HPPA &&
				 sr->r_type == HPPA_RELOC_PAIR)
			    printf(" other_part = 0x%06x ",
				   (unsigned int)sr->r_address);
			else if(((cputype == CPU_TYPE_POWERPC ||
				  cputype == CPU_TYPE_POWERPC64 ||
				  cputype == CPU_TYPE_VEO) &&
				 sr->r_type == PPC_RELOC_PAIR)){
			    if(previous_ppc_jbsr == FALSE)
				printf(" half = 0x%04x ",
				       (unsigned int)reloc.r_address);
			    else{
				printf(" <- other_part ");
			    }
			}
		    }
		    else if(cputype == CPU_TYPE_HPPA &&
			    (sectdiff_r_type == HPPA_RELOC_HI21_SECTDIFF ||
			     sectdiff_r_type == HPPA_RELOC_LO14_SECTDIFF)){
			    printf(" other_part = 0x%06x ",
				   (unsigned int)sr->r_address);
		    }
		    else if(cputype == CPU_TYPE_SPARC &&
			    (sectdiff_r_type == SPARC_RELOC_HI22_SECTDIFF ||
			     sectdiff_r_type == SPARC_RELOC_LO10_SECTDIFF)){
			    printf(" other_part = 0x%06x ",
				   (unsigned int)sr->r_address);
		    }
		    else if((cputype == CPU_TYPE_POWERPC ||
			     cputype == CPU_TYPE_POWERPC64 ||
			     cputype == CPU_TYPE_VEO) &&
			    (sectdiff_r_type == PPC_RELOC_HI16_SECTDIFF ||
			     sectdiff_r_type == PPC_RELOC_LO16_SECTDIFF ||
			     sectdiff_r_type == PPC_RELOC_LO14_SECTDIFF ||
			     sectdiff_r_type == PPC_RELOC_HA16_SECTDIFF)){
			    printf(" other_half = 0x%04x ",
				   (unsigned int)sr->r_address);
		    }
		    else if(cputype == CPU_TYPE_ARM &&
			    sectdiff_r_type == ARM_RELOC_HALF_SECTDIFF){
			    printf(" other_half = 0x%04x ",
				   (unsigned int)sr->r_address);
		    }
		    if((cputype == CPU_TYPE_MC680x0 &&
			(sr->r_type == GENERIC_RELOC_SECTDIFF ||
			 sr->r_type == GENERIC_RELOC_LOCAL_SECTDIFF)) ||
		       (cputype == CPU_TYPE_I386 &&
			(sr->r_type == GENERIC_RELOC_SECTDIFF ||
			 sr->r_type == GENERIC_RELOC_LOCAL_SECTDIFF)) ||
		       (cputype == CPU_TYPE_MC88000 &&
			sr->r_type == M88K_RELOC_SECTDIFF) ||
		       ((cputype == CPU_TYPE_POWERPC ||
		         cputype == CPU_TYPE_POWERPC64 ||
		         cputype == CPU_TYPE_VEO) &&
			(sr->r_type == PPC_RELOC_SECTDIFF ||
			 sr->r_type == PPC_RELOC_LOCAL_SECTDIFF ||
			 sr->r_type == PPC_RELOC_HI16_SECTDIFF ||
			 sr->r_type == PPC_RELOC_LO16_SECTDIFF ||
			 sr->r_type == PPC_RELOC_LO14_SECTDIFF ||
			 sr->r_type == PPC_RELOC_HA16_SECTDIFF)) ||
		       (cputype == CPU_TYPE_I860 &&
			sr->r_type == I860_RELOC_SECTDIFF) ||
		       (cputype == CPU_TYPE_HPPA &&
			(sr->r_type == HPPA_RELOC_SECTDIFF ||
			 sr->r_type == HPPA_RELOC_HI21_SECTDIFF ||
			 sr->r_type == HPPA_RELOC_LO14_SECTDIFF)) ||
		       (cputype == CPU_TYPE_ARM &&
			(sr->r_type == ARM_RELOC_SECTDIFF ||
			 sr->r_type == ARM_RELOC_LOCAL_SECTDIFF ||
			 sr->r_type == ARM_RELOC_HALF_SECTDIFF)) ||
		       (cputype == CPU_TYPE_SPARC &&
			(sr->r_type == SPARC_RELOC_SECTDIFF ||
			 sr->r_type == SPARC_RELOC_HI22_SECTDIFF ||
			 sr->r_type == SPARC_RELOC_LO10_SECTDIFF))){
			previous_sectdiff = TRUE;
			sectdiff_r_type = sr->r_type;
		    }
		    else
			previous_sectdiff = FALSE;
		    if(((cputype == CPU_TYPE_POWERPC ||
		         cputype == CPU_TYPE_POWERPC64 ||
		         cputype == CPU_TYPE_VEO) &&
			 sr->r_type == PPC_RELOC_JBSR))
			previous_ppc_jbsr = TRUE;
		    else
			previous_ppc_jbsr = FALSE;
		    if(cputype == CPU_TYPE_ARM &&
		       (sr->r_type == ARM_RELOC_HALF ||
		        sr->r_type == ARM_RELOC_HALF_SECTDIFF))
			previous_arm_half = TRUE;
		    else
			previous_arm_half = FALSE;
		    printf("\n");
		}
		else{
		    printf("%08x %1d     %-2d     n/a    %-7d 1         "
			   "0x%08x\n", (unsigned int)sr->r_address,
			   sr->r_pcrel, sr->r_length, sr->r_type,
			   (unsigned int)sr->r_value);
		}
	    }
	    else{
		if(verbose){
		    if((cputype == CPU_TYPE_MC88000 &&
			reloc.r_type == M88K_RELOC_PAIR) ||
		       ((cputype == CPU_TYPE_POWERPC ||
		         cputype == CPU_TYPE_POWERPC64 ||
		         cputype == CPU_TYPE_VEO) &&
			reloc.r_type == PPC_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_HPPA &&
			reloc.r_type == HPPA_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_SPARC &&
			reloc.r_type == SPARC_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_ARM &&
			reloc.r_type == ARM_RELOC_PAIR) ||
		       (cputype == CPU_TYPE_I860 &&
			reloc.r_type == I860_RELOC_PAIR))
			    printf("         ");
		    else
			printf("%08x ", (unsigned int)reloc.r_address);
		    if(reloc.r_pcrel)
			printf("True  ");
		    else
			printf("False ");
		    if(cputype == CPU_TYPE_ARM && 
		       (reloc.r_type == ARM_RELOC_HALF ||
			reloc.r_type == ARM_RELOC_HALF_SECTDIFF ||
			previous_arm_half == TRUE)){
			if((reloc.r_length & 0x1) == 0)
			    printf("lo/");
			else
			    printf("hi/");
			if((reloc.r_length & 0x2) == 0)
			    printf("arm ");
			else
			    printf("thm ");
		    }
		    else{
			switch(reloc.r_length){
			case 0:
			    printf("byte   ");
			    break;
			case 1:
			    printf("word   ");
			    break;
			case 2:
			    printf("long   ");
			    break;
			case 3:
			    /*
			     * The value of 3 for r_length for PowerPC is to
			     * encode that a conditional branch using the Y-bit
			     * for static branch prediction was predicted in
			     * the assembly source.
			     */
			    if((cputype == CPU_TYPE_POWERPC64 && 
				reloc.r_type == PPC_RELOC_VANILLA) ||
			       cputype == CPU_TYPE_ARM64 ||
			       cputype == CPU_TYPE_X86_64) {
				    printf("quad   ");
			    }
			    else if(cputype == CPU_TYPE_POWERPC ||
				    cputype == CPU_TYPE_POWERPC64 ||
				    cputype == CPU_TYPE_VEO){
				printf("long   ");
				predicted = TRUE;
			    }
			    else
				printf("?(%2d)  ", reloc.r_length);
			    break;
			default:
			    printf("?(%2d)  ", reloc.r_length);
			    break;
			}
		    }
		    if(reloc.r_extern){
			printf("True   ");
			print_r_type(cputype, reloc.r_type, predicted);
			printf("False     ");
			if((symbols == NULL && symbols64 == NULL) ||
			   strings == NULL ||
			   reloc.r_symbolnum > nsymbols)
			    printf("?(%d)\n", reloc.r_symbolnum);
			else{
			    if(symbols != NULL)
				n_strx = symbols[reloc.r_symbolnum].n_un.n_strx;
			    else
				n_strx = symbols64[reloc.r_symbolnum].
					 n_un.n_strx;
			    if(n_strx > strings_size)
				printf("?(%d)\n", reloc.r_symbolnum);
			    else
				printf("%s\n", strings + n_strx);
			}
		    }
		    else{
			printf("False  ");
			print_r_type(cputype, reloc.r_type, predicted);
			printf("False     ");
			if((cputype == CPU_TYPE_I860 &&
			    reloc.r_type == I860_RELOC_PAIR) ||
			   (cputype == CPU_TYPE_MC88000 &&
			    reloc.r_type == M88K_RELOC_PAIR) ){
			    printf("half = 0x%04x\n",
				   (unsigned int)reloc.r_address);
			}
			else if((cputype == CPU_TYPE_HPPA &&
				 reloc.r_type == HPPA_RELOC_PAIR) ||
				(cputype == CPU_TYPE_SPARC &&
				 reloc.r_type == SPARC_RELOC_PAIR)){
			    printf(" other_part = 0x%06x\n",
				   (unsigned int)reloc.r_address);
			}
			else if(((cputype == CPU_TYPE_POWERPC ||
				  cputype == CPU_TYPE_POWERPC64 ||
				  cputype == CPU_TYPE_VEO) &&
				 reloc.r_type == PPC_RELOC_PAIR)){
			    if(previous_ppc_jbsr == FALSE)
				printf("half = 0x%04x\n",
				       (unsigned int)reloc.r_address);
			    else
				printf("other_part = 0x%08x\n",
				       (unsigned int)reloc.r_address);
			}
			else if(cputype == CPU_TYPE_ARM &&
				reloc.r_type == ARM_RELOC_PAIR)
			    printf("other_half = 0x%04x\n",
				   (unsigned int)reloc.r_address);
			else if(cputype == CPU_TYPE_ARM64 &&
				reloc.r_type == ARM64_RELOC_ADDEND)
			    printf("addend = 0x%06x\n",
				   (unsigned int)reloc.r_symbolnum);
			else{
			    printf("%d ", reloc.r_symbolnum);
			    if(reloc.r_symbolnum > nsects + 1)
				printf("(?,?)\n");
			    else{
				if(reloc.r_symbolnum == R_ABS)
				    printf("R_ABS\n");
				else
				    printf("(%.16s,%.16s)\n",
				    sect_rel[reloc.r_symbolnum-1].segname,
				    sect_rel[reloc.r_symbolnum-1].sectname);
			    }
			}
		    }
		    if(((cputype == CPU_TYPE_POWERPC ||
		         cputype == CPU_TYPE_POWERPC64 ||
		         cputype == CPU_TYPE_VEO) &&
			 reloc.r_type == PPC_RELOC_JBSR))
			previous_ppc_jbsr = TRUE;
		    else
			previous_ppc_jbsr = FALSE;
		    if(cputype == CPU_TYPE_ARM &&
		       (reloc.r_type == ARM_RELOC_HALF ||
		        reloc.r_type == ARM_RELOC_HALF_SECTDIFF))
			previous_arm_half = TRUE;
		    else
			previous_arm_half = FALSE;
		}
		else{
		    printf("%08x %1d     %-2d     %1d      %-7d 0"
			   "         %d\n", (unsigned int)reloc.r_address,
			   reloc.r_pcrel, reloc.r_length, reloc.r_extern,
			   reloc.r_type, reloc.r_symbolnum);
		}
	    }
	}
}


static char *generic_r_types[] = {
    "VANILLA ", "PAIR    ", "SECTDIF ", "PBLAPTR ", "LOCSDIF ", "TLV     ",
    "  6 (?) ", "  7 (?) ", "  8 (?) ", "  9 (?) ", " 10 (?) ", " 11 (?) ",
    " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};
static char *m88k_r_types[] = {
    "VANILLA ", "PAIR    ", "PC16    ", "PC26    ", "HI16    ", "LO16    ",
    "SECTDIF ", "PBLAPTR ", "  8 (?) ", "  9 (?) ", " 10 (?) ", " 11 (?) ",
    " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};
static char *i860_r_types[] = {
    "VANILLA ", "PAIR    ", "HIGH    ", "LOW0    ", "LOW1    ", "LOW2    ",
    "LOW3    ", "LOW4    ", "SPLIT0  ", "SPLIT1  ", "SPLIT2  ", "HIGHADJ ",
    "BRADDR  ", "SECTDIF ", " 14 (?) ", " 15 (?) "
};
static char *ppc_r_types[] = {
    "VANILLA ", "PAIR    ", "BR14",     "BR24    ", "HI16    ", "LO16    ",
    "HA16    ", "LO14    ", "SECTDIF ", "PBLAPTR ", "HI16DIF ", "LO16DIF ",
    "HA16DIF ", "JBSR    ", "LO14DIF ", "LOCSDIF "
};
static char *x86_64_r_types[] = {
    "UNSIGND ", "SIGNED  ", "BRANCH  ", "GOT_LD  ", "GOT     ", "SUB     ",
    "SIGNED1 ", "SIGNED2 ", "SIGNED4 ", "TLV     ", " 10 (?) ", " 11 (?) ",
    " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};
static char *hppa_r_types[] = {
	"VANILLA ", "PAIR    ", "HI21    ", "LO14    ", "BR17    ",
	"BL17    ", "JBSR    ", "SECTDIF ", "HI21DIF ", "LO14DIF ",
	"PBLAPTR ", " 11 (?) ", " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};

static char *sparc_r_types[] = {
	"VANILLA ", "PAIR    ", "HI22    ", "LO10    ", "DISP22  ",
	"DISP30  ", "SECTDIFF", "HI22DIFF", "LO10DIFF", "PBLAPTR ", 
	" 10 (?) ", " 11 (?) ", " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};

static char *arm_r_types[] = {
	"VANILLA ", "PAIR    ", "SECTDIFF", "LOCSDIF ", "PBLAPTR ",
	"BR24    ", "T_BR22  ", "T_BR32  ", "HALF    ", "HALFDIF ", 
	" 10 (?) ", " 11 (?) ", " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};

static char *arm64_r_types[] = {
	"UNSIGND ", "SUB     ", "BR26    ", "PAGE21  ", "PAGOF12 ",
	"GOTLDP  ", "GOTLDPOF", "PTRTGOT ", "TLVLDP  ", "TLVLDPOF", 
	"ADDEND  ", " 11 (?) ", " 12 (?) ", " 13 (?) ", " 14 (?) ", " 15 (?) "
};

static
void
print_r_type(
cpu_type_t cputype,
uint32_t r_type,
enum bool predicted)
{
	if(r_type > 0xf){
	    printf("%-7u ", r_type);
	    return;
	}
	switch(cputype){
	case CPU_TYPE_MC680x0:
	case CPU_TYPE_I386:
	    printf("%s", generic_r_types[r_type]);
	    break;
	case CPU_TYPE_X86_64:
		printf("%s", x86_64_r_types[r_type]);
		break;
	case CPU_TYPE_MC88000:
	    printf("%s", m88k_r_types[r_type]);
	    break;
	case CPU_TYPE_I860:
	    printf("%s", i860_r_types[r_type]);
	    break;
	case CPU_TYPE_POWERPC:
	case CPU_TYPE_POWERPC64:
	case CPU_TYPE_VEO:
	    printf("%s", ppc_r_types[r_type]);
	    if(r_type == PPC_RELOC_BR14){
		if(predicted == TRUE)
		    printf("+/- ");
		else
		    printf("    ");
	    }
	    break;
	case CPU_TYPE_HPPA:
	    printf("%s", hppa_r_types[r_type]);
	    break;
	case CPU_TYPE_SPARC:
	    printf("%s", sparc_r_types[r_type]);
	    break;
	case CPU_TYPE_ARM:
	    printf("%s", arm_r_types[r_type]);
	    break;
	case CPU_TYPE_ARM64:
	    printf("%s", arm64_r_types[r_type]);
	    break;
	default:
	    printf("%-7u ", r_type);
	}
}

/*
 * Print the table of contents.
 */
void
print_toc(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
char *object_addr,
uint32_t object_size,
struct dylib_table_of_contents *tocs,
uint32_t ntocs,
struct dylib_module *mods,
struct dylib_module_64 *mods64,
uint32_t nmods,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
   uint32_t i;
   uint32_t n_strx;
   uint8_t n_type;

	printf("Table of contents (%u entries)\n", ntocs);
	if(verbose)
	    printf("module name      symbol name\n");
	else
	    printf("module index symbol index\n");
	for(i = 0; i < ntocs; i++){
	    if(verbose){
		if(tocs[i].module_index > nmods)
		    printf("%-16u (past the end of the module table) ",
			   tocs[i].module_index);
		else if(mods != NULL){
		    if(mods[tocs[i].module_index].module_name > strings_size)
			printf("%-16u (string index past the end of string "
			       "table) ", tocs[i].module_index);
		    else
			printf("%-16s ", strings +
			       mods[tocs[i].module_index].module_name);
		}
		else{
		    if(mods64[tocs[i].module_index].module_name > strings_size)
			printf("%-16u (string index past the end of string "
			       "table) ", tocs[i].module_index);
		    else
			printf("%-16s ", strings +
			       mods64[tocs[i].module_index].module_name);
		}

		if(tocs[i].symbol_index > nsymbols)
		    printf("%u (past the end of the symbol table)\n",
			   tocs[i].symbol_index);
		else{
		    if(symbols != NULL){
			n_strx = symbols[tocs[i].symbol_index].n_un.n_strx;
			n_type = symbols[tocs[i].symbol_index].n_type;
		    }
		    else{
			n_strx = symbols64[tocs[i].symbol_index].n_un.n_strx;
			n_type = symbols64[tocs[i].symbol_index].n_type;
		    }
		    if(n_strx > strings_size){
			printf("%u (string index past the end of the string "
			       "table)\n", tocs[i].symbol_index);
		    }
		    else{
			printf("%s", strings + n_strx);
			if(n_type & N_EXT)
			    printf("\n");
			else
			    printf(" [private]\n");
		    }
		}
	    }
	    else{
		printf("%-12u %u\n", tocs[i].module_index,
		       tocs[i].symbol_index);
	    }
	}
}

/*
 * Print the module table (32-bit).
 */
void
print_module_table(
struct dylib_module *mods,
uint32_t nmods,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
   uint32_t i;

	printf("Module table (%u entries)\n", nmods);
	for(i = 0; i < nmods; i++){
	    printf("module %u\n", i);
	    if(verbose){
		if(mods[i].module_name > strings_size)
		    printf("    module_name = %u (past end of string table)\n",
			   mods[i].module_name);
		else
		    printf("    module_name = %s\n",
			   strings + mods[i].module_name);
	    }
	    else{
		if(mods[i].module_name > strings_size)
		    printf("    module_name = %u (past end of string table)\n",
			   mods[i].module_name);
		else
		    printf("    module_name = %u\n", mods[i].module_name);
	    }
	    printf("     iextdefsym = %u\n", mods[i].iextdefsym);
	    printf("     nextdefsym = %u\n", mods[i].nextdefsym);
	    printf("        irefsym = %u\n", mods[i].irefsym);
	    printf("        nrefsym = %u\n", mods[i].nrefsym);
	    printf("      ilocalsym = %u\n", mods[i].ilocalsym);
	    printf("      nlocalsym = %u\n", mods[i].nlocalsym);
	    printf("        iextrel = %u\n", mods[i].iextrel);
	    printf("        nextrel = %u\n", mods[i].nextrel);
	    printf("    iinit_iterm = %u %u\n",
		mods[i].iinit_iterm & 0xffff,
		(mods[i].iinit_iterm >> 16) & 0xffff);
	    printf("    ninit_nterm = %u %u\n",
		mods[i].ninit_nterm & 0xffff,
		(mods[i].ninit_nterm >> 16) & 0xffff);
	    printf("      objc_addr = 0x%x\n",
		(unsigned int)mods[i].objc_module_info_addr);
	    printf("      objc_size = %u\n", mods[i].objc_module_info_size);
	}
}

/*
 * Print the module table (64-bit).
 */
void
print_module_table_64(
struct dylib_module_64 *mods64,
uint32_t nmods,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
   uint32_t i;

	printf("Module table (%u entries)\n", nmods);
	for(i = 0; i < nmods; i++){
	    printf("module %u\n", i);
	    if(verbose){
		if(mods64[i].module_name > strings_size)
		    printf("    module_name = %u (past end of string table)\n",
			   mods64[i].module_name);
		else
		    printf("    module_name = %s\n",
			   strings + mods64[i].module_name);
	    }
	    else{
		if(mods64[i].module_name > strings_size)
		    printf("    module_name = %u (past end of string table)\n",
			   mods64[i].module_name);
		else
		    printf("    module_name = %u\n", mods64[i].module_name);
	    }
	    printf("     iextdefsym = %u\n", mods64[i].iextdefsym);
	    printf("     nextdefsym = %u\n", mods64[i].nextdefsym);
	    printf("        irefsym = %u\n", mods64[i].irefsym);
	    printf("        nrefsym = %u\n", mods64[i].nrefsym);
	    printf("      ilocalsym = %u\n", mods64[i].ilocalsym);
	    printf("      nlocalsym = %u\n", mods64[i].nlocalsym);
	    printf("        iextrel = %u\n", mods64[i].iextrel);
	    printf("        nextrel = %u\n", mods64[i].nextrel);
	    printf("    iinit_iterm = %u %u\n",
		mods64[i].iinit_iterm & 0xffff,
		(mods64[i].iinit_iterm >> 16) & 0xffff);
	    printf("    ninit_nterm = %u %u\n",
		mods64[i].ninit_nterm & 0xffff,
		(mods64[i].ninit_nterm >> 16) & 0xffff);
	    printf("      objc_addr = 0x%016llx\n",
		mods64[i].objc_module_info_addr);
	    printf("      objc_size = %u\n", mods64[i].objc_module_info_size);
	}
}

/*
 * Print the reference table.
 */
void
print_refs(
struct dylib_reference *refs,
uint32_t nrefs,
struct dylib_module *mods,
struct dylib_module_64 *mods64,
uint32_t nmods,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
   uint32_t i, j;
   uint32_t module_name, irefsym, nrefsym, n_strx;
    uint64_t big_size;

	printf("Reference table (%u entries)\n", nrefs);
	for(i = 0; i < nmods; i++){
	    if(mods != NULL){
		module_name = mods[i].module_name;
		irefsym = mods[i].irefsym;
		nrefsym = mods[i].nrefsym;
	    }
	    else{
		module_name = mods64[i].module_name;
		irefsym = mods64[i].irefsym;
		nrefsym = mods64[i].nrefsym;
	    }
	    if(verbose){
		if(module_name > strings_size)
		    printf("    module %u (past end of string table)",
			   module_name);
		else
		    printf("    module %s", strings + module_name);
	    }
	    else{
		printf("    module %u", module_name);
	    }
	    if(irefsym > nrefs){
		printf(" %u entries, at index %u (past end of reference "
		       "table)\n", nrefsym, irefsym);
		continue;
	    }
	    big_size = irefsym;
	    big_size += nrefsym;
	    if(big_size > nrefs)
		printf(" %u entries (extends past the end of the reference "
		       "table), at index %u\n", nrefsym, irefsym);
	    else
		printf(" %u entries, at index %u\n", nrefsym, irefsym);
	    for(j = irefsym;
		j - irefsym < nrefsym && j < nrefs;
		j++){
		if(refs[j].isym > nsymbols)
		    printf("\t%u (past the end of the symbol table) ",
			   refs[j].isym);
		else{
		    if(verbose){
			if(refs[j].isym > nsymbols)
			    printf("\t%u (past the end of the symbol table) ",
				   refs[j].isym);
			else{
			    if(symbols != NULL)
				n_strx = symbols[refs[j].isym].n_un.n_strx;
			    else
				n_strx = symbols64[refs[j].isym].n_un.n_strx;
			    if(n_strx > strings_size)
				printf("\t%u (string index past the end of the "
				       "string table) ", refs[j].isym);
			    else
				printf("\t%s ", strings + n_strx);
			}
		    }
		    else
			printf("\tisym %u ", refs[j].isym);
		}
		if(verbose){
		    switch(refs[j].flags){
		    case REFERENCE_FLAG_UNDEFINED_NON_LAZY:
			printf("undefined [non-lazy]\n");
			break;
		    case REFERENCE_FLAG_UNDEFINED_LAZY:
			printf("undefined [lazy]\n");
			break;
		    case REFERENCE_FLAG_DEFINED:
			printf("defined\n");
			break;
		    case REFERENCE_FLAG_PRIVATE_DEFINED:
			printf("private defined\n");
			break;
		    case REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY:
			printf("private undefined [non-lazy]\n");
			break;
		    case REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY:
			printf("private undefined [lazy]\n");
			break;
		    default:
			printf("%u\n", (unsigned int)refs[j].flags);
			break;
		    }
		}
		else
		    printf("flags %u\n", (unsigned int)refs[j].flags);
	    }
	}
}

/*
 * Print the indirect symbol table.
 */
void
print_indirect_symbols(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
cpu_type_t cputype,
enum byte_sex load_commands_byte_sex,
uint32_t *indirect_symbols,
uint32_t nindirect_symbols,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, k, left, size, nsects, n, count, stride, section_type;
    uint64_t bigsize, big_load_end;
    char *p;
    struct load_command *lc, l;
    struct segment_command sg;
    struct section s;
    struct segment_command_64 sg64;
    struct section_64 s64;
    struct section_indirect_info {
	char segname[16];
	char sectname[16];
	uint64_t size;
	uint64_t addr;
	uint32_t reserved1;
	uint32_t reserved2;
	uint32_t flags;
    } *sect_ind;
    uint32_t n_strx;

	sect_ind = NULL;
	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	/*
	 * Create an array of section structures in the host byte sex so it
	 * can be processed and indexed into directly.
	 */
	k = 0;
	nsects = 0;
	lc = load_commands;
	big_load_end = 0;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    big_load_end += l.cmdsize;
	    if(big_load_end > sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_SEGMENT:
		memset((char *)&sg, '\0', sizeof(struct segment_command));
		size = left < sizeof(struct segment_command) ?
		       left : sizeof(struct segment_command);
		left -= size;
		memcpy((char *)&sg, (char *)lc, size);
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);
		bigsize = sg.nsects;
		bigsize *= sizeof(struct section);
		bigsize += size;
		if(bigsize > sg.cmdsize){
		    printf("number of sections in load command %u extends "
			   "past end of load commands\n", i);
		    sg.nsects = (sg.cmdsize-size) / sizeof(struct section);
		}
		nsects += sg.nsects;
		sect_ind = reallocate(sect_ind,
			      nsects * sizeof(struct section_indirect_info));
		memset((char *)(sect_ind + (nsects - sg.nsects)), '\0',
		       sizeof(struct section_indirect_info) * sg.nsects);
		p = (char *)lc + sizeof(struct segment_command);
		for(j = 0 ; j < sg.nsects ; j++){
		    left = sizeofcmds - (p - (char *)load_commands);
		    size = left < sizeof(struct section) ?
			   left : sizeof(struct section);
		    memcpy((char *)&s, p, size);
		    if(swapped)
			swap_section(&s, 1, host_byte_sex);

		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds)
			break;
		    p += size;
		    memcpy(sect_ind[k].segname, s.segname, 16);
		    memcpy(sect_ind[k].sectname, s.sectname, 16);
		    sect_ind[k].size = s.size;
		    sect_ind[k].addr = s.addr;
		    sect_ind[k].reserved1 = s.reserved1;
		    sect_ind[k].reserved2 = s.reserved2;
		    sect_ind[k].flags = s.flags;
		    k++;
		}
		break;
	    case LC_SEGMENT_64:
		memset((char *)&sg64, '\0', sizeof(struct segment_command_64));
		size = left < sizeof(struct segment_command_64) ?
		       left : sizeof(struct segment_command_64);
		memcpy((char *)&sg64, (char *)lc, size);
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);
		bigsize = sg64.nsects;
		bigsize *= sizeof(struct section_64);
		bigsize += size;
		if(bigsize > sg64.cmdsize){
		    printf("number of sections in load command %u extends "
			   "past end of load commands\n", i);
		    sg64.nsects = (sg64.cmdsize-size) /
				  sizeof(struct section_64);
		}
		nsects += sg64.nsects;
		sect_ind = reallocate(sect_ind,
			      nsects * sizeof(struct section_indirect_info));
		memset((char *)(sect_ind + (nsects - sg64.nsects)), '\0',
		       sizeof(struct section_indirect_info) * sg64.nsects);
		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    left = sizeofcmds - (p - (char *)load_commands);
		    size = left < sizeof(struct section_64) ?
			   left : sizeof(struct section_64);
		    memcpy((char *)&s64, p, size);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);

		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds)
			break;
		    p += size;
		    memcpy(sect_ind[k].segname, s64.segname, 16);
		    memcpy(sect_ind[k].sectname, s64.sectname, 16);
		    sect_ind[k].size = s64.size;
		    sect_ind[k].addr = s64.addr;
		    sect_ind[k].reserved1 = s64.reserved1;
		    sect_ind[k].reserved2 = s64.reserved2;
		    sect_ind[k].flags = s64.flags;
		    k++;
		}
		break;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if((char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	for(i = 0 ; i < nsects ; i++){
	    section_type = sect_ind[i].flags & SECTION_TYPE;
	    if(section_type == S_SYMBOL_STUBS){
		stride = sect_ind[i].reserved2;
		if(stride == 0){
		    printf("Can't print indirect symbols for (%.16s,%.16s) "
			   "(size of stubs in reserved2 field is zero)\n",
			   sect_ind[i].segname, sect_ind[i].sectname);
		    continue;
		}
	    }
	    else if(section_type == S_LAZY_SYMBOL_POINTERS ||
	            section_type == S_NON_LAZY_SYMBOL_POINTERS ||
	            section_type == S_LAZY_DYLIB_SYMBOL_POINTERS ||
	   	    section_type == S_THREAD_LOCAL_VARIABLE_POINTERS){
		if(cputype & CPU_ARCH_ABI64)
		    stride = 8;
		else
		    stride = 4;
	    }
	    else
		continue;
	
	    count = sect_ind[i].size / stride;
	    printf("Indirect symbols for (%.16s,%.16s) %u entries",
		   sect_ind[i].segname, sect_ind[i].sectname,
		   count);

	    n = sect_ind[i].reserved1;
	    if(n > nindirect_symbols)
		printf(" (entries start past the end of the indirect symbol "
		       "table) (reserved1 field greater than the table size)");
	    else if(n + count > nindirect_symbols)
		printf(" (entries extends past the end of the indirect symbol "
		       "table)");
	    if(cputype & CPU_ARCH_ABI64)
		printf("\naddress            index");
	    else
		printf("\naddress    index");
	    if(verbose)
		printf(" name\n");
	    else
		printf("\n");

	    for(j = 0 ; j < count && n + j < nindirect_symbols; j++){
		if(cputype & CPU_ARCH_ABI64)
		    printf("0x%016llx ", sect_ind[i].addr + j * stride);
		else
		    printf("0x%08x ",(uint32_t)
				     (sect_ind[i].addr + j * stride));
		if(indirect_symbols[j + n] == INDIRECT_SYMBOL_LOCAL){
		    printf("LOCAL\n");
		    continue;
		}
		if(indirect_symbols[j + n] ==
		   (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)){
		    printf("LOCAL ABSOLUTE\n");
		    continue;
		}
		if(indirect_symbols[j + n] == INDIRECT_SYMBOL_ABS){
		    /* 
		     * Used for unused slots in the i386 __jump_table 
		     * and for image-loader-cache slot for new lazy
		     * symbol binding in Mac OS X 10.6 and later
		     */ 
		    printf("ABSOLUTE\n");
		    continue;
		}
		printf("%5u ", indirect_symbols[j + n]);
		if(verbose){
		    if(indirect_symbols[j + n] >= nsymbols ||
		       (symbols == NULL && symbols64 == NULL) ||
		       strings == NULL)
			printf("?\n");
		    else{
			if(symbols != NULL)
			    n_strx = symbols[indirect_symbols[j+n]].n_un.n_strx;
			else
			    n_strx = symbols64[indirect_symbols[j+n]].
					n_un.n_strx;
			if(n_strx >= strings_size)
			    printf("?\n");
			else
			    printf("%s\n", strings + n_strx);
		    }
		}
		else
		    printf("\n");
	    }
	    n += count;
	}
}

void
print_hints(
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex load_commands_byte_sex,
struct twolevel_hint *hints,
uint32_t nhints,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped, is_framework;
    uint32_t i, left, size, nlibs, dyst_cmd, lib_ord;
    char *p, **libs, *short_name, *has_suffix;
    struct load_command *lc, l;
    struct dysymtab_command dyst;
    struct dylib_command dl;
    uint32_t n_strx;
    uint16_t n_desc;
    uint64_t big_load_end;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	/*
	 * If verbose is TRUE create an array of load dylibs names so it
	 * indexed into directly.
	 */
	nlibs = 0;
	libs = NULL;
	dyst_cmd = UINT_MAX;
	lc = load_commands;
	big_load_end = 0;
	memset((char *)&dyst, '\0', sizeof(struct dysymtab_command));
	for(i = 0 ; verbose == TRUE && i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    big_load_end += l.cmdsize;
	    if(big_load_end > sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(l.cmd){
	    case LC_DYSYMTAB:
		if(dyst_cmd != UINT_MAX){
		    printf("more than one LC_DYSYMTAB command (using command "
			   "%u)\n", dyst_cmd);
		    break;
		}
		size = left < sizeof(struct dysymtab_command) ?
		       left : sizeof(struct dysymtab_command);
		memcpy((char *)&dyst, (char *)lc, size);
		if(swapped)
		    swap_dysymtab_command(&dyst, host_byte_sex);
		dyst_cmd = i;
		break;

	    case LC_LOAD_DYLIB:
	    case LC_LOAD_WEAK_DYLIB:
	    case LC_REEXPORT_DYLIB:
	    case LC_LOAD_UPWARD_DYLIB:
	    case LC_LAZY_LOAD_DYLIB:
		memset((char *)&dl, '\0', sizeof(struct dylib_command));
		size = left < sizeof(struct dylib_command) ?
		       left : sizeof(struct dylib_command);
		memcpy((char *)&dl, (char *)lc, size);
		if(swapped)
		    swap_dylib_command(&dl, host_byte_sex);
		if(dl.dylib.name.offset < dl.cmdsize){
		    p = (char *)lc + dl.dylib.name.offset;
		    short_name = guess_short_name(p, &is_framework,
						  &has_suffix);
		    if(short_name != NULL)
			p = short_name;
		}
		else{
		    p = "bad dylib.name.offset";
		}
		libs = reallocate(libs, (nlibs+1) * sizeof(char *));
		libs[nlibs] = p;
		nlibs++;
		break;
	    }
	    if(l.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}
	if(verbose == TRUE &&
	   (char *)load_commands + sizeofcmds != (char *)lc)
	    printf("Inconsistent sizeofcmds\n");

	printf("Two-level namespace hints table (%u hints)\n", nhints);
	printf("index  isub  itoc\n");
	for(i = 0; i < nhints; i++){
	    printf("%5u %5d %5u", i, (int)hints[i].isub_image, hints[i].itoc);
	    if(verbose){
		if(dyst_cmd != UINT_MAX &&
		   dyst.iundefsym + i < nsymbols){
		    if(symbols != NULL){
			n_strx = symbols[dyst.iundefsym + i].n_un.n_strx;
			n_desc = symbols[dyst.iundefsym + i].n_desc;
		    }
		    else{
			n_strx = symbols64[dyst.iundefsym + i].n_un.n_strx;
			n_desc = symbols64[dyst.iundefsym + i].n_desc;
		    }
		    if(n_strx > strings_size)
			printf(" (bad string index in symbol %u)\n",
			       dyst.iundefsym + i);
		    else{
			printf(" %s", strings + n_strx);
			lib_ord = GET_LIBRARY_ORDINAL(n_desc);
			if(lib_ord != SELF_LIBRARY_ORDINAL &&
			   lib_ord - 1 < nlibs)
			    printf(" (from %s)\n", libs[lib_ord - 1]);
			else
			    printf("\n");
		    }
		}
		else
		    printf("\n");
	    }
	    else
		printf("\n");
	}
}

static
uint64_t
decodeULEB128(
const uint8_t *p,
unsigned *n)
{
  const uint8_t *orig_p = p;
  uint64_t Value = 0;
  unsigned Shift = 0;
  do {
    Value += (*p & 0x7f) << Shift;
    Shift += 7;
  } while (*p++ >= 128);
  if (n)
    *n = (unsigned)(p - orig_p);
  return Value;
}

void
print_link_opt_hints(
char *loh,
uint32_t nloh)
{
    uint32_t i, j;
    unsigned n;
    uint64_t identifier, narguments, value;

	printf("Linker optimiztion hints (%u total bytes)\n", nloh);
	for(i = 0; i < nloh;){
	    identifier = decodeULEB128((const uint8_t *)(loh + i), &n);
	    i += n;
	    printf("    identifier %llu ", identifier);
	    if(i >= nloh)
		return;
	    switch(identifier){
	    case 1:
		printf("AdrpAdrp\n");
		break;
	    case 2:
		printf("AdrpLdr\n");
		break;
	    case 3:
		printf("AdrpAddLdr\n");
		break;
	    case 4:
		printf("AdrpLdrGotLdr\n");
		break;
	    case 5:
		printf("AdrpAddStr\n");
		break;
	    case 6:
		printf("AdrpLdrGotStr\n");
		break;
	    case 7:
		printf("AdrpAdd\n");
		break;
	    case 8:
		printf("AdrpLdrGot\n");
		break;
	    default:
		printf("Unknown identifier value\n");
		break;
	    }

	    narguments = decodeULEB128((const uint8_t *)(loh + i), &n);
	    i += n;
	    printf("    narguments %llu\n", narguments);
	    if(i >= nloh)
		return;

	    for(j = 0; j < narguments; j++){
		value = decodeULEB128((const uint8_t *)(loh + i), &n);
		i += n;
		printf("\tvalue 0x%llx\n", value);
		if(i >= nloh)
		    return;
	    }
	}
}

void
print_dices(
struct data_in_code_entry *dices,
uint32_t ndices,
enum bool verbose)
{
    uint32_t i;

	printf("Data in code table (%u entries)\n", ndices);
	printf("offset     length kind\n");
	for(i = 0; i < ndices; i++){
	    printf("0x%08x %6u ", (unsigned)dices[i].offset, dices[i].length);
	    if(verbose){
		switch(dices[i].kind){
		case DICE_KIND_DATA:
		    printf("DATA");
		    break;
		case DICE_KIND_JUMP_TABLE8:
		    printf("JUMP_TABLE8");
		    break;
		case DICE_KIND_JUMP_TABLE16:
		    printf("JUMP_TABLE16");
		    break;
		case DICE_KIND_JUMP_TABLE32:
		    printf("JUMP_TABLE32");
		    break;
		case DICE_KIND_ABS_JUMP_TABLE32:
		    printf("ABS_JUMP_TABLE32");
		    break;
		default:
		    printf("0x%04x", (unsigned)dices[i].kind);
		    break;
		}
	    }
	    else
		printf("0x%04x", (unsigned)dices[i].kind);
	    printf("\n");
	}
}

void
print_cstring_section(
cpu_type_t cputype,
char *sect,
uint32_t sect_size,
uint64_t sect_addr,
enum bool print_addresses)
{
    uint32_t i;

	for(i = 0; i < sect_size ; i++){
	    if(print_addresses == TRUE){
	        if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx  ", sect_addr + i);
		else
		    printf("%08x  ", (unsigned int)(sect_addr + i));
	    }

	    for( ; i < sect_size && sect[i] != '\0'; i++)
		print_cstring_char(sect[i]);
	    if(i < sect_size && sect[i] == '\0')
		printf("\n");
	}
}

static
void
print_cstring_char(
char c)
{
	if(isprint(c)){
	    if(c == '\\')	/* backslash */
		printf("\\\\");
	    else		/* all other printable characters */
		printf("%c", c);
	}
	else{
	    switch(c){
	    case '\n':		/* newline */
		printf("\\n");
		break;
	    case '\t':		/* tab */
		printf("\\t");
		break;
	    case '\v':		/* vertical tab */
		printf("\\v");
		break;
	    case '\b':		/* backspace */
		printf("\\b");
		break;
	    case '\r':		/* carriage return */
		printf("\\r");
		break;
	    case '\f':		/* formfeed */
		printf("\\f");
		break;
	    case '\a':		/* audiable alert */
		printf("\\a");
		break;
	    default:
		printf("\\%03o", (unsigned int)c);
	    }
	}
}

void
print_literal4_section(
cpu_type_t cputype,
char *sect,
uint32_t sect_size,
uint64_t sect_addr,
enum byte_sex literal_byte_sex,
enum bool print_addresses)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, l;
    float f;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != literal_byte_sex;

	for(i = 0; i < sect_size ; i += sizeof(float)){
	    if(print_addresses == TRUE){
	        if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx  ", sect_addr + i);
		else
		    printf("%08x  ", (unsigned int)(sect_addr + i));
	    }
	    memcpy((char *)&f, sect + i, sizeof(float));
	    memcpy((char *)&l, sect + i, sizeof(uint32_t));
	    if(swapped){
		f = SWAP_FLOAT(f);
		l = SWAP_INT(l);
	    }
	    print_literal4(l, f);
	}
}

static
void
print_literal4(
uint32_t l,
float f)
{
	printf("0x%08x", (unsigned int)l);
	if((l & 0x7f800000) != 0x7f800000){
	    printf(" (%.16e)\n", f);
	}
	else{
	    if(l == 0x7f800000)
		printf(" (+Infinity)\n");
	    else if(l == 0xff800000)
		printf(" (-Infinity)\n");
	    else if((l & 0x00400000) == 0x00400000)
		printf(" (non-signaling Not-a-Number)\n");
	    else
		printf(" (signaling Not-a-Number)\n");
	}
}

void
print_literal8_section(
cpu_type_t cputype,
char *sect,
uint32_t sect_size,
uint64_t sect_addr,
enum byte_sex literal_byte_sex,
enum bool print_addresses)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, l0, l1;
    double d;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != literal_byte_sex;

	for(i = 0; i < sect_size ; i += sizeof(double)){
	    if(print_addresses == TRUE){
	        if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx  ", sect_addr + i);
		else
		    printf("%08x  ", (unsigned int)(sect_addr + i));
	    }
	    memcpy((char *)&d, sect + i, sizeof(double));
	    memcpy((char *)&l0, sect + i, sizeof(uint32_t));
	    memcpy((char *)&l1, sect + i + sizeof(uint32_t),
		   sizeof(uint32_t));
	    if(swapped){
		d = SWAP_DOUBLE(d);
		l0 = SWAP_INT(l0);
		l1 = SWAP_INT(l1);
	    }
	    print_literal8(l0, l1, d, literal_byte_sex);
	}
}

static
void
print_literal8(
uint32_t l0,
uint32_t l1,
double d,
enum byte_sex literal_byte_sex)
{
    uint32_t hi, lo;

	printf("0x%08x 0x%08x", (unsigned int)l0, (unsigned int)l1);
	if(literal_byte_sex == LITTLE_ENDIAN_BYTE_SEX){
	    hi = l1;
	    lo = l0;
	} else {
	    hi = l0;
	    lo = l1;
	}
	/* hi is the high word, so this is equivalent to if(isfinite(d)) */
	if((hi & 0x7ff00000) != 0x7ff00000)
	    printf(" (%.16e)\n", d);
	else{
	    if(hi == 0x7ff00000 && lo == 0)
		printf(" (+Infinity)\n");
	    else if(hi == 0xfff00000 && lo == 0)
		printf(" (-Infinity)\n");
	    else if((hi & 0x00080000) == 0x00080000)
		printf(" (non-signaling Not-a-Number)\n");
	    else
		printf(" (signaling Not-a-Number)\n");
	}
}

void
print_literal16_section(
cpu_type_t cputype,
char *sect,
uint32_t sect_size,
uint64_t sect_addr,
enum byte_sex literal_byte_sex,
enum bool print_addresses)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, l0, l1, l2, l3;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != literal_byte_sex;

	for(i = 0; i < sect_size ; i += 4 * sizeof(uint32_t)){
	    if(print_addresses == TRUE){
	        if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx  ", sect_addr + i);
		else
		    printf("%08x  ", (unsigned int)(sect_addr + i));
	    }
	    memcpy((char *)&l0, sect + i, sizeof(uint32_t));
	    memcpy((char *)&l1, sect + i + sizeof(uint32_t),
		   sizeof(uint32_t));
	    memcpy((char *)&l2, sect + i + 2 * sizeof(uint32_t),
		   sizeof(uint32_t));
	    memcpy((char *)&l3, sect + i + 3 * sizeof(uint32_t),
		   sizeof(uint32_t));
	    if(swapped){
		l0 = SWAP_INT(l0);
		l1 = SWAP_INT(l1);
		l2 = SWAP_INT(l2);
		l3 = SWAP_INT(l3);
	    }
	    print_literal16(l0, l1, l2, l3);
	}
}

static
void
print_literal16(
uint32_t l0,
uint32_t l1,
uint32_t l2,
uint32_t l3)
{
	printf("0x%08x 0x%08x 0x%08x 0x%08x\n", (unsigned int)l0,\
	       (unsigned int)l1, (unsigned int)l2, (unsigned int)l3);
}

void
print_literal_pointer_section(
cpu_type_t cputype,
struct load_command *load_commands,
uint32_t ncmds,
uint32_t sizeofcmds,
enum byte_sex object_byte_sex,
char *object_addr,
uint32_t object_size,
char *sect,
uint32_t sect_size,
uint64_t sect_addr,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
struct relocation_info *relocs,
uint32_t nrelocs,
enum bool print_addresses)
{
    enum byte_sex host_byte_sex;
    enum bool swapped, found;
    uint32_t i, j, k, li, l0, l1, l2, l3, left, size, lp_size;
    uint64_t lp;
    struct load_command lcmd, *lc;
    struct segment_command sg;
    struct section s;
    struct segment_command_64 sg64;
    struct section_64 s64;
    struct literal_section {
	char segname[16];
	char sectname[16];
        uint64_t addr;
        uint32_t flags;
	char *contents;
	uint32_t size;
    } *literal_sections;
    char *p;
    uint32_t nliteral_sections;
    float f;
    double d;
    struct relocation_info *reloc;
    uint32_t n_strx;
    uint64_t big_load_end, big_size;

    d = 0.0; /* cctools-port */

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;

	literal_sections = NULL;
	nliteral_sections = 0;

	lc = load_commands;
	big_load_end = 0;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&lcmd, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&lcmd, host_byte_sex);
	    if(lcmd.cmdsize % sizeof(int32_t) != 0)
		printf("load command %u size not a multiple of "
		       "sizeof(int32_t)\n", i);
	    big_load_end += lcmd.cmdsize;
	    if(big_load_end > sizeofcmds)
		printf("load command %u extends past end of load "
		       "commands\n", i);
	    left = sizeofcmds - ((char *)lc - (char *)load_commands);

	    switch(lcmd.cmd){
	    case LC_SEGMENT:
		memset((char *)&sg, '\0', sizeof(struct segment_command));
		size = left < sizeof(struct segment_command) ?
		       left : sizeof(struct segment_command);
		memcpy((char *)&sg, (char *)lc, size);
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);

		p = (char *)lc + sizeof(struct segment_command);
		for(j = 0 ; j < sg.nsects ; j++){
		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds){
			printf("section structure command extends past "
			       "end of load commands\n");
		    }
		    left = sizeofcmds - (p - (char *)load_commands);
		    memset((char *)&s, '\0', sizeof(struct section));
		    size = left < sizeof(struct section) ?
			   left : sizeof(struct section);
		    memcpy((char *)&s, p, size);
		    if(swapped)
			swap_section(&s, 1, host_byte_sex);

		    if(s.flags == S_CSTRING_LITERALS ||
		       s.flags == S_4BYTE_LITERALS ||
		       s.flags == S_8BYTE_LITERALS ||
		       s.flags == S_16BYTE_LITERALS){
			literal_sections = reallocate(literal_sections,
						sizeof(struct literal_section) *
						(nliteral_sections + 1));
			memcpy(literal_sections[nliteral_sections].segname,
			       s.segname, 16);
			memcpy(literal_sections[nliteral_sections].sectname,
			       s.sectname, 16);
        		literal_sections[nliteral_sections].addr = s.addr;
			literal_sections[nliteral_sections].flags = s.flags;
			literal_sections[nliteral_sections].contents = 
							object_addr + s.offset;
			big_size = s.offset;
			big_size += s.size;
			if(s.offset > object_size){
			    printf("section contents of: (%.16s,%.16s) is past "
				   "end of file\n", s.segname, s.sectname);
			    literal_sections[nliteral_sections].size =  0;
			}
			else if(big_size > object_size){
			    printf("part of section contents of: (%.16s,%.16s) "
				   "is past end of file\n",
				   s.segname, s.sectname);
			    literal_sections[nliteral_sections].size =
				object_size - s.offset;
			}
			else
			    literal_sections[nliteral_sections].size = s.size;
			nliteral_sections++;
		    }

		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds)
			break;
		    p += size;
		}
		break;
	    case LC_SEGMENT_64:
		memset((char *)&sg64, '\0', sizeof(struct segment_command_64));
		size = left < sizeof(struct segment_command_64) ?
		       left : sizeof(struct segment_command_64);
		memcpy((char *)&sg64, (char *)lc, size);
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);

		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    if(p + sizeof(struct section_64) >
		       (char *)load_commands + sizeofcmds){
			printf("section structure command extends past "
			       "end of load commands\n");
		    }
		    left = sizeofcmds - (p - (char *)load_commands);
		    memset((char *)&s64, '\0', sizeof(struct section_64));
		    size = left < sizeof(struct section_64) ?
			   left : sizeof(struct section_64);
		    memcpy((char *)&s64, p, size);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);

		    if(s64.flags == S_CSTRING_LITERALS ||
		       s64.flags == S_4BYTE_LITERALS ||
		       s64.flags == S_8BYTE_LITERALS ||
		       s64.flags == S_16BYTE_LITERALS){
			literal_sections = reallocate(literal_sections,
						sizeof(struct literal_section) *
						(nliteral_sections + 1));
			memcpy(literal_sections[nliteral_sections].segname,
			       s64.segname, 16);
			memcpy(literal_sections[nliteral_sections].sectname,
			       s64.sectname, 16);
        		literal_sections[nliteral_sections].addr = s64.addr;
			literal_sections[nliteral_sections].flags = s64.flags;
			literal_sections[nliteral_sections].contents = 
						    object_addr + s64.offset;
			big_size = s64.offset;
			big_size += s64.size;
			if(s64.offset > object_size){
			    printf("section contents of: (%.16s,%.16s) is past "
				   "end of file\n", s64.segname, s64.sectname);
			    literal_sections[nliteral_sections].size =  0;
			}
			else if(big_size > object_size){
			    printf("part of section contents of: (%.16s,%.16s) "
				   "is past end of file\n",
				   s64.segname, s64.sectname);
			    literal_sections[nliteral_sections].size =
				object_size - s64.offset;
			}
			else
			    literal_sections[nliteral_sections].size = s64.size;
			nliteral_sections++;
		    }

		    if(p + sizeof(struct section) >
		       (char *)load_commands + sizeofcmds)
			break;
		    p += size;
		}
		break;
	    }
	    if(lcmd.cmdsize == 0){
		printf("load command %u size zero (can't advance to other "
		       "load commands)\n", i);
		break;
	    }
	    lc = (struct load_command *)((char *)lc + lcmd.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		break;
	}

	/* loop through the literal pointer section and print the pointers */
	if(cputype & CPU_ARCH_ABI64)
	    lp_size = 8;
	else
	    lp_size = 4;
	for(i = 0; i < sect_size ; i += lp_size){
	    if(print_addresses == TRUE){
	        if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx  ", sect_addr + i);
		else
		    printf("%08x  ", (unsigned int)(sect_addr + i));
	    }
	    if(cputype & CPU_ARCH_ABI64){
		lp = (uint64_t)*((uint64_t *)(sect + i));
		memcpy((char *)&lp, sect + i, sizeof(uint64_t));
		if(swapped)
		    lp = SWAP_LONG_LONG(lp);
	    }
	    else{
		li = (int32_t)*((int32_t *)(sect + i));
		memcpy((char *)&li, sect + i, sizeof(uint32_t));
		if(swapped)
		    li = SWAP_INT(li);
		lp = li;
	    }
	    /*
	     * If there is an external relocation entry for this pointer then
	     * print the symbol and any offset.
	     */
	    reloc = bsearch(&i, relocs, nrelocs, sizeof(struct relocation_info),
			    (int (*)(const void *, const void *))rel_bsearch);
	    if(reloc != NULL && (reloc->r_address & R_SCATTERED) == 0 &&
	       reloc->r_extern == 1){
		printf("external relocation entry for symbol:");
		if(reloc->r_symbolnum < nsymbols){
		    if(symbols != NULL)
			n_strx = symbols[reloc->r_symbolnum].n_un.n_strx;
		    else
			n_strx = symbols64[reloc->r_symbolnum].n_un.n_strx;
		    if(n_strx < strings_size){
			if(lp != 0)
			    printf("%s+0x%llx\n", strings + n_strx, lp);
			else
			    printf("%s\n", strings + n_strx);
		    }
		    else{
			printf("bad string index for symbol: %u\n",
			       reloc->r_symbolnum);
		    }
		}
		else{
		    printf("bad relocation entry\n");
		}
		continue;
	    }
	    found = FALSE;
	    for(j = 0; j < nliteral_sections; j++){
		if(lp >= literal_sections[j].addr &&
		   lp < literal_sections[j].addr +
		        literal_sections[j].size){
		    printf("%.16s:%.16s:", literal_sections[j].segname,
			   literal_sections[j].sectname);
		    switch(literal_sections[j].flags){
		    case S_CSTRING_LITERALS:
			for(k = lp - literal_sections[j].addr;
			    k < literal_sections[j].size &&
					literal_sections[j].contents[k] != '\0';
			    k++)
			    print_cstring_char(literal_sections[j].contents[k]);
			printf("\n");
			break;
		    case S_4BYTE_LITERALS:
			memcpy((char *)&f,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr),
				sizeof(float));
			memcpy((char *)&l0,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr),
				sizeof(uint32_t));
			if(swapped){
			    d = SWAP_DOUBLE(d);
			    l0 = SWAP_INT(l0);
			}
			print_literal4(l0, f);
			break;
		    case S_8BYTE_LITERALS:
			memcpy((char *)&d,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr),
				sizeof(double));
			memcpy((char *)&l0,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr),
				sizeof(uint32_t));
			memcpy((char *)&l1,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr +
					sizeof(uint32_t)),
			       sizeof(uint32_t));
			if(swapped){
			    d = SWAP_DOUBLE(d);
			    l0 = SWAP_INT(l0);
			    l1 = SWAP_INT(l1);
			}
			print_literal8(l0, l1, d, object_byte_sex);
			break;
		    case S_16BYTE_LITERALS:
			memcpy((char *)&l0,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr),
				sizeof(uint32_t));
			memcpy((char *)&l1,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr +
					sizeof(uint32_t)),
			       sizeof(uint32_t));
			memcpy((char *)&l2,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr +
					2 * sizeof(uint32_t)),
			       sizeof(uint32_t));
			memcpy((char *)&l3,
			       (char *)(literal_sections[j].contents +
					lp - literal_sections[j].addr +
					3 * sizeof(uint32_t)),
			       sizeof(uint32_t));
			if(swapped){
			    l0 = SWAP_INT(l0);
			    l1 = SWAP_INT(l1);
			    l2 = SWAP_INT(l2);
			    l3 = SWAP_INT(l3);
			}
			print_literal16(l0, l1, l2, l3);
			break;
		    }
		    found = TRUE;
		    break;
		}
	    }
	    if(found == FALSE)
		printf("0x%llx (not in a literal section)\n", lp);
	}

	if(literal_sections != NULL)
	    free(literal_sections);
}

void
print_init_term_pointer_section(
cpu_type_t cputype,
char *sect,
uint32_t sect_size,
uint64_t sect_addr,
enum byte_sex object_byte_sex,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
enum bool verbose)
{
    uint32_t i, stride, p;
    uint64_t q;
    enum byte_sex host_byte_sex;
    enum bool swapped;
    const char *name;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;
	p = 0;
	q = 0;
    
	if(cputype & CPU_ARCH_ABI64)
	    stride = sizeof(uint64_t);
	else
	    stride = sizeof(uint32_t);

	for(i = 0 ; i < sect_size; i += stride){
	    if(cputype & CPU_ARCH_ABI64)
		printf("0x%016llx ", sect_addr + i * stride);
	    else
		printf("0x%08x ",(uint32_t)(sect_addr + i * stride));

	    if(cputype & CPU_ARCH_ABI64)
		memcpy(&q, sect + i, stride);
	    else
		memcpy(&p, sect + i, stride);

	    if(swapped == TRUE){
		if(cputype & CPU_ARCH_ABI64)
		     q = SWAP_LONG_LONG(q);
		else
		     p = SWAP_INT(p);
	    }
	    if(cputype & CPU_ARCH_ABI64)
		printf("0x%016llx", q);
	    else
		printf("0x%08x", p);

	    if(verbose == TRUE){
		if(cputype & CPU_ARCH_ABI64)
		    name = guess_symbol(q, sorted_symbols, nsorted_symbols,
					verbose);
		else
		    name = guess_symbol(p, sorted_symbols, nsorted_symbols,
					verbose);
		if(name != NULL)
		    printf(" %s\n", name);
		else
		    printf("\n");
	    }
	    else{
		printf("\n");
	    }
	}
}

/*
 * Function for bsearch for searching relocation entries.
 */
static
int
rel_bsearch(
uint32_t *address,
struct relocation_info *rel)
{
    struct scattered_relocation_info *srel;
    uint32_t r_address;

	if((rel->r_address & R_SCATTERED) != 0){
	    srel = (struct scattered_relocation_info *)rel;
	    r_address = srel->r_address;
	}
	else
	    r_address = rel->r_address;

	if(*address == r_address)
	    return(0);
	if(*address < r_address)
	    return(-1);
	else
	    return(1);
}

/*
 * Print the shared library initialization table.
 */
void
print_shlib_init(
enum byte_sex object_byte_sex,
char *sect,
uint32_t sect_size,
uint32_t sect_addr,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
char *strings,
uint32_t strings_size,
struct relocation_info *relocs,
uint32_t nrelocs,
enum bool verbose)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i;
    struct shlib_init {
	int32_t value;		/* the value to be stored at the address */
	int32_t address;	/* the address to store the value */
    } shlib_init;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;

	for(i = 0; i < sect_size; i += sizeof(struct shlib_init)){
	    memcpy((char *)&shlib_init, sect + i, sizeof(struct shlib_init));
	    if(swapped){
		shlib_init.value = SWAP_INT(shlib_init.value);
		shlib_init.address = SWAP_INT(shlib_init.address);
	    }
	    printf("\tvalue   0x%08x ", (unsigned int)shlib_init.value);
	    (void)print_symbol(shlib_init.value, sect_addr + i, 0, relocs,
			       nrelocs, symbols, symbols64, nsymbols,
			       sorted_symbols, nsorted_symbols, strings,
			       strings_size, verbose);
	    printf("\n");
	    printf("\taddress 0x%08x ", (unsigned int)shlib_init.address);
	    (void)print_symbol(shlib_init.address, sect_addr+i+sizeof(int32_t), 0,
			       relocs, nrelocs, symbols, symbols64, nsymbols,
			       sorted_symbols, nsorted_symbols, strings,
			       strings_size, verbose);
	    printf("\n");
	}
}

/*
 * Print_symbol prints a symbol name for the addr if a symbol exist with the
 * same address.  Nothing else is printed, no whitespace, no newline.  If it
 * prints something then it returns TRUE, else it returns FALSE.
 */
enum bool
print_symbol(
uint64_t value,
uint32_t r_address,
uint32_t dot_value,
struct relocation_info *relocs,
uint32_t nrelocs,
struct nlist *symbols,
struct nlist_64 *symbols64,
uint32_t nsymbols,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols,
char *strings,
uint32_t strings_size,
enum bool verbose)
{
    uint32_t i, offset;
    struct scattered_relocation_info *sreloc, *pair;
    unsigned int r_symbolnum;
    uint32_t n_strx;
    const char *name, *add, *sub;

	if(verbose == FALSE)
	    return(FALSE);

	for(i = 0; i < nrelocs; i++){
	    if(((relocs[i].r_address) & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		if(sreloc->r_type == GENERIC_RELOC_PAIR){
		    fprintf(stderr, "Stray GENERIC_RELOC_PAIR relocation entry "
			    "%u\n", i);
		    continue;
		}
		if(sreloc->r_type == GENERIC_RELOC_VANILLA){
		    if(sreloc->r_address == r_address){
			name = guess_symbol(sreloc->r_value, sorted_symbols,
					    nsorted_symbols, verbose);
			offset = value - sreloc->r_value;
			if(name != NULL){
			    printf("%s+0x%x", name, (unsigned int)offset);
			    return(TRUE);
			}
		    }
		    continue;
		}
		if(sreloc->r_type != GENERIC_RELOC_SECTDIFF &&
		   sreloc->r_type != GENERIC_RELOC_LOCAL_SECTDIFF){
		    fprintf(stderr, "Unknown relocation r_type for entry "
			    "%u\n", i);
		    continue;
		}
		if(i + 1 < nrelocs){
		    pair = (struct scattered_relocation_info *)(relocs + i + 1);
		    if(pair->r_scattered == 0 ||
		       pair->r_type != GENERIC_RELOC_PAIR){
			fprintf(stderr, "No GENERIC_RELOC_PAIR relocation "
				"entry after entry %u\n", i);
			continue;
		    }
		}
		else{
		    fprintf(stderr, "No GENERIC_RELOC_PAIR relocation entry "
			    "after entry %u\n", i);
		    continue;
		}
		i++; /* skip the pair reloc */

		if(sreloc->r_address == r_address){
		    add = guess_symbol(sreloc->r_value, sorted_symbols,
				       nsorted_symbols, verbose);
		    sub = guess_symbol(pair->r_value, sorted_symbols,
				       nsorted_symbols, verbose);
		    offset = value - (sreloc->r_value - pair->r_value);
		    if(add != NULL)
			printf("%s", add);
		    else
			printf("0x%x", (unsigned int)sreloc->r_value);
		    if(sub != NULL)
			printf("-%s", sub);
		    else{
			if((uint32_t)pair->r_value == dot_value)
			    printf("-.");
			else
			    printf("-0x%x", (unsigned int)pair->r_value);
		    }
		    if(offset != 0)
			printf("+0x%x", (unsigned int)offset);
		    return(TRUE);
		}
	    }
	    else{
		if((uint32_t)relocs[i].r_address == r_address){
		    r_symbolnum = relocs[i].r_symbolnum;
		    if(relocs[i].r_extern){
		        if(r_symbolnum >= nsymbols)
			    return(FALSE);
			if(symbols != NULL)
			    n_strx = symbols[r_symbolnum].n_un.n_strx;
			else
			    n_strx = symbols64[r_symbolnum].n_un.n_strx;
			if(n_strx <= 0 || n_strx >= strings_size)
			    return(FALSE);
			if(value != 0)
			    printf("%s+0x%x", strings + n_strx,
				   (unsigned int)value);
			else
			    printf("%s", strings + n_strx);
			return(TRUE);
		    }
		    break;
		}
	    }
	}

	name = guess_symbol(value, sorted_symbols, nsorted_symbols, verbose);
	if(name != NULL){
	    printf("%s", name);
	    return(TRUE);
	}
	return(FALSE);
}

/*
 * guess_symbol() guesses the name for a symbol based on the specified value.
 * It returns the name of symbol or NULL.  It only returns a symbol name if
 *  a symbol with that exact value exists.
 */
const char *
guess_symbol(
const uint64_t value,	/* the value of this symbol (in) */
const struct symbol *sorted_symbols,
const uint32_t nsorted_symbols,
const enum bool verbose)
{
    int32_t high, low, mid;

	if(verbose == FALSE)
	    return(NULL);

	low = 0;
	high = nsorted_symbols - 1;
	mid = (high - low) / 2;
	while(high >= low){
	    if(sorted_symbols[mid].n_value == value){
		return(sorted_symbols[mid].name);
	    }
	    if(sorted_symbols[mid].n_value > value){
		high = mid - 1;
		mid = (high + low) / 2;
	    }
	    else{
		low = mid + 1;
		mid = (high + low) / 2;
	    }
	}
	return(NULL);
}

/*
 * guess_indirect_symbol() returns the name of the indirect symbol for the
 * value passed in or NULL.
 */
const char *
guess_indirect_symbol(
const uint64_t value,	/* the value of this symbol (in) */
const uint32_t ncmds,
const uint32_t sizeofcmds,
const struct load_command *load_commands,
const enum byte_sex load_commands_byte_sex,
const uint32_t *indirect_symbols,
const uint32_t nindirect_symbols,
const struct nlist *symbols,
const struct nlist_64 *symbols64,
const uint32_t nsymbols,
const char *strings,
const uint32_t strings_size)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint32_t i, j, section_type, index, stride;
    const struct load_command *lc;
    struct load_command l;
    struct segment_command sg;
    struct section s;
    struct segment_command_64 sg64;
    struct section_64 s64;
    char *p;
    uint64_t big_load_end;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != load_commands_byte_sex;

	lc = load_commands;
	big_load_end = 0;
	for(i = 0 ; i < ncmds; i++){
	    memcpy((char *)&l, (char *)lc, sizeof(struct load_command));
	    if(swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(int32_t) != 0)
		return(NULL);
	    big_load_end += l.cmdsize;
	    if(big_load_end > sizeofcmds)
		return(NULL);
	    switch(l.cmd){
	    case LC_SEGMENT:
		memcpy((char *)&sg, (char *)lc, sizeof(struct segment_command));
		if(swapped)
		    swap_segment_command(&sg, host_byte_sex);
		p = (char *)lc + sizeof(struct segment_command);
		for(j = 0 ; j < sg.nsects ; j++){
		    memcpy((char *)&s, p, sizeof(struct section));
		    p += sizeof(struct section);
		    if(swapped)
			swap_section(&s, 1, host_byte_sex);
		    section_type = s.flags & SECTION_TYPE;
		    if((section_type == S_NON_LAZY_SYMBOL_POINTERS ||
		        section_type == S_LAZY_SYMBOL_POINTERS ||
		        section_type == S_LAZY_DYLIB_SYMBOL_POINTERS ||
		        section_type == S_THREAD_LOCAL_VARIABLE_POINTERS ||
		        section_type == S_SYMBOL_STUBS) &&
		        value >= s.addr && value < s.addr + s.size){
			if(section_type == S_SYMBOL_STUBS)
			    stride = s.reserved2;
			else
			    stride = 4;
			if(stride == 0)
			    return(NULL);
			index = s.reserved1 + (value - s.addr) / stride;
			if(index < nindirect_symbols &&
		    	   symbols != NULL && strings != NULL &&
		           indirect_symbols[index] < nsymbols &&
		           (uint32_t)symbols[indirect_symbols[index]].
				n_un.n_strx < strings_size)
			    return(strings +
				symbols[indirect_symbols[index]].n_un.n_strx);
			else
			    return(NULL);
		    }
		}
		break;
	    case LC_SEGMENT_64:
		memcpy((char *)&sg64, (char *)lc,
		       sizeof(struct segment_command_64));
		if(swapped)
		    swap_segment_command_64(&sg64, host_byte_sex);
		p = (char *)lc + sizeof(struct segment_command_64);
		for(j = 0 ; j < sg64.nsects ; j++){
		    memcpy((char *)&s64, p, sizeof(struct section_64));
		    p += sizeof(struct section_64);
		    if(swapped)
			swap_section_64(&s64, 1, host_byte_sex);
		    section_type = s64.flags & SECTION_TYPE;
		    if((section_type == S_NON_LAZY_SYMBOL_POINTERS ||
		        section_type == S_LAZY_SYMBOL_POINTERS ||
		        section_type == S_LAZY_DYLIB_SYMBOL_POINTERS ||
	   		section_type == S_THREAD_LOCAL_VARIABLE_POINTERS ||
		        section_type == S_SYMBOL_STUBS) &&
		        value >= s64.addr && value < s64.addr + s64.size){
			if(section_type == S_SYMBOL_STUBS)
			    stride = s64.reserved2;
			else
			    stride = 8;
			if(stride == 0)
			    return(NULL);
			index = s64.reserved1 + (value - s64.addr) / stride;
			if(index < nindirect_symbols &&
		    	   symbols64 != NULL && strings != NULL &&
		           indirect_symbols[index] < nsymbols &&
		           (uint32_t)symbols64[indirect_symbols[index]].
				n_un.n_strx < strings_size)
			    return(strings +
				symbols64[indirect_symbols[index]].n_un.n_strx);
			else
			    return(NULL);
		    }
		}
		break;
	    }
	    if(l.cmdsize == 0){
		return(NULL);
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	    if((char *)lc > (char *)load_commands + sizeofcmds)
		return(NULL);
	}
	return(NULL);
}

void
print_sect(
cpu_type_t cputype,
enum byte_sex object_byte_sex,
char *sect,
uint64_t size,
uint64_t addr)
{
    enum byte_sex host_byte_sex;
    enum bool swapped;
    uint64_t i, j, k;
    uint32_t long_word;
    unsigned short short_word;
    unsigned char byte_word;

	host_byte_sex = get_host_byte_sex();
	swapped = host_byte_sex != object_byte_sex;

	if(cputype == CPU_TYPE_I386 ||
	   cputype == CPU_TYPE_X86_64){
	    for(i = 0 ; i < size ; i += j , addr += j){
		if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx\t", addr);
		else
		    printf("%08x\t", (uint32_t)addr);
		for(j = 0;
		    j < 16 * sizeof(char) && i + j < size;
		    j += sizeof(char)){
		    byte_word = *(sect + i + j);
		    printf("%02x ", (unsigned int)byte_word);
		}
		printf("\n");
	    }
	}
	else if(cputype == CPU_TYPE_MC680x0){
	    for(i = 0 ; i < size ; i += j , addr += j){
		printf("%08x ", (unsigned int)addr);
		for(j = 0;
		    j < 8 * sizeof(short) && i + j < size;
		    j += sizeof(short)){
		    memcpy(&short_word, sect + i + j, sizeof(short));
		    if(swapped)
			short_word = SWAP_SHORT(short_word);
		    printf("%04x ", (unsigned int)short_word);
		}
		printf("\n");
	    }
	}
	else{
	    for(i = 0 ; i < size ; i += j , addr += j){
		if(cputype & CPU_ARCH_ABI64)
		    printf("%016llx\t", addr);
		else
		    printf("%08x\t", (uint32_t)addr);
		for(j = 0;
		    j < 4 * sizeof(int32_t) && i + j < size;
		    j += sizeof(int32_t)){
		    if(i + j + sizeof(int32_t) < size){
			memcpy(&long_word, sect + i + j, sizeof(int32_t));
			if(swapped)
			    long_word = SWAP_INT(long_word);
			printf("%08x ", (unsigned int)long_word);
		    }
		    else{
			for(k = 0; i + j + k < size; k++){
			    byte_word = *(sect + i + j + k);
			    printf("%02x ", (unsigned int)byte_word);
			}
		    }
		}
		printf("\n");
	    }
	}
}

/*
 * get_label returns a symbol name for the addr if a symbol exist with the
 * same address else it returns NULL.
 */
char *
get_label(
uint64_t addr,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols)
{
    int32_t high, low, mid;

	low = 0;
	high = nsorted_symbols - 1;
	mid = (high - low) / 2;
	while(high >= low){
	    if(sorted_symbols[mid].n_value == addr)
		return(sorted_symbols[mid].name);
	    if(sorted_symbols[mid].n_value > addr){
		high = mid - 1;
		mid = (high + low) / 2;
	    }
	    else{
		low = mid + 1;
		mid = (high + low) / 2;
	    }
	}
	return(NULL);
}

/*
 * Print_label prints a symbol name for the addr if a symbol exist with the
 * same address in label form, namely:.
 *
 * <symbol name>:\n
 *
 * The colon and the newline are printed if colon_and_newline is TRUE.
 * If it prints a label it returns TRUE else it returns FALSE.
 */
enum bool
print_label(
uint64_t addr,
enum bool colon_and_newline,
struct symbol *sorted_symbols,
uint32_t nsorted_symbols)
{
    int32_t high, low, mid;

	low = 0;
	high = nsorted_symbols - 1;
	mid = (high - low) / 2;
	while(high >= low){
	    if(sorted_symbols[mid].n_value == addr){
		printf("%s", sorted_symbols[mid].name);
		if(colon_and_newline == TRUE)
		    printf(":\n");
		return(TRUE);
	    }
	    if(sorted_symbols[mid].n_value > addr){
		high = mid - 1;
		mid = (high + low) / 2;
	    }
	    else{
		low = mid + 1;
		mid = (high + low) / 2;
	    }
	}
	return(FALSE);
}
                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/ofile_print.h                         0100644 0001750 0001750 00000041105 12612724206 024260  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright  2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1.  Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#import <ar.h>
#import <mach-o/fat.h>
#import <mach-o/loader.h>
#import <mach-o/nlist.h>
#import <mach-o/reloc.h>
#import <stuff/bytesex.h>
#import <stuff/bool.h>
#include "stuff/symbol.h"

extern void print_fat_headers(
    struct fat_header *fat_header,
    struct fat_arch *fat_archs,
    uint64_t size,
    enum bool verbose);

extern void print_ar_hdr(
    struct ar_hdr *ar_hdr,
    char *member_name,
    uint32_t member_name_size,
    uint32_t member_offset,
    enum bool verbose,
    enum bool print_offset);

extern void print_library_toc(
    struct ar_hdr *toc_ar_hdr,
    char *toc_name,
    uint32_t toc_name_size,
    char *toc_addr,
    uint32_t toc_size,
    enum byte_sex toc_byte_sex,
    char *library_name,
    char *library_addr,
    uint64_t library_size,
    char *arch_name,
    enum bool verbose);

extern void print_mach_header(
    uint32_t magic,
    cpu_type_t cputype,
    cpu_subtype_t cpusubtype,
    uint32_t filetype,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    uint32_t flags,
    enum bool verbose);

extern void print_loadcmds(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_type_t cputype,
    uint32_t filetype,
    enum byte_sex load_commands_byte_sex,
    uint32_t object_size,
    enum bool verbose,
    enum bool very_verbose);

extern void print_libraries(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    enum bool just_id,
    enum bool verbose);

extern void print_reloc(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_type_t cputype,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern void print_toc(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct dylib_table_of_contents *tocs,
    uint32_t ntocs,
    struct dylib_module *mods,
    struct dylib_module_64 *mods64,
    uint32_t nmods,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern void print_module_table(
    struct dylib_module *mods,
    uint32_t nmods,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern void print_module_table_64(
    struct dylib_module_64 *mods64,
    uint32_t nmods,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

void print_refs(
    struct dylib_reference *refs,
    uint32_t nrefs,
    struct dylib_module *mods,
    struct dylib_module_64 *mods64,
    uint32_t nmods,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern void print_indirect_symbols(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    cpu_type_t cputype,
    enum byte_sex load_commands_byte_sex,
    uint32_t *indirect_symbols,
    uint32_t nindirect_symbols,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern void print_hints(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex load_commands_byte_sex,
    struct twolevel_hint *hints,
    uint32_t nhints,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern void print_link_opt_hints(
    char *loh,
    uint32_t nloh);

extern void print_dices(
    struct data_in_code_entry *dices,
    uint32_t ndices,
    enum bool verbose);

extern void print_segment_command(
    uint32_t cmd,
    uint32_t cmdsize,
    char *segname,
    uint64_t vmaddr,
    uint64_t vmsize,
    uint64_t fileoff,
    uint64_t filesize,
    vm_prot_t maxprot,
    vm_prot_t initprot,
    uint32_t nsects,
    uint32_t flags,
    uint32_t object_size,
    enum bool verbose);

extern void print_section(
    char *sectname,
    char *segname,
    uint64_t addr,
    uint64_t size,
    uint32_t offset,
    uint32_t align,
    uint32_t reloff,
    uint32_t nreloc,
    uint32_t flags,
    uint32_t reserved1,
    uint32_t reserved2,
    uint32_t cmd,
    char *sg_segname,
    uint32_t filetype,
    uint32_t object_size,
    enum bool verbose);

extern void print_symtab_command(
    struct symtab_command *sg,
    cpu_type_t cputype,
    uint32_t object_size);

extern void print_dysymtab_command(
    struct dysymtab_command *dyst,
    uint32_t nsyms,
    uint32_t object_size,
    cpu_type_t cputype);

extern void print_symseg_command(
    struct symseg_command *ss,
    uint32_t object_size);

extern void print_fvmlib_command(
    struct fvmlib_command *fl,
    struct load_command *lc);

extern void print_dylib_command(
    struct dylib_command *dl,
    struct load_command *lc);

extern void print_sub_framework_command(
    struct sub_framework_command *sub,
    struct load_command *lc);

extern void print_sub_umbrella_command(
    struct sub_umbrella_command *usub,
    struct load_command *lc);

extern void print_sub_library_command(
    struct sub_library_command *lsub,
    struct load_command *lc);

extern void print_sub_client_command(
    struct sub_client_command *csub,
    struct load_command *lc);

extern void print_prebound_dylib_command(
    struct prebound_dylib_command *pbdylib,
    struct load_command *lc,
    enum bool verbose);

extern void print_dylinker_command(
    struct dylinker_command *dyld,
    struct load_command *lc);

extern void print_fvmfile_command(
    struct fvmfile_command *ff,
    struct load_command *lc);

extern void print_routines_command(
    struct routines_command *rc);

extern void print_routines_command_64(
    struct routines_command_64 *rc64);

extern void print_twolevel_hints_command(
    struct twolevel_hints_command *hints,
    uint32_t object_size);

extern void print_prebind_cksum_command(
    struct prebind_cksum_command *cksum);

extern void print_uuid_command(
    struct uuid_command *uuid);

extern void print_linkedit_data_command(
    struct linkedit_data_command *ld,
    uint32_t object_size);

extern void print_version_min_command(
    struct version_min_command *vd);

extern void print_source_version_command(
    struct source_version_command *sv);

extern void print_entry_point_command(
    struct entry_point_command *ep);

extern void print_rpath_command(
    struct rpath_command *rpath,
    struct load_command *lc);

extern void print_encryption_info_command(
    struct encryption_info_command *ec,
    uint32_t object_size);

extern void print_encryption_info_command_64(
    struct encryption_info_command_64 *ec,
    uint32_t object_size);

extern void print_linker_option_command(
    struct linker_option_command *lo,
    struct load_command *lc);

extern void print_dyld_info_info_command(
    struct dyld_info_command *dc,
    uint32_t object_size);

extern void print_thread_states(
    char *begin, 
    char *end,
    cpu_type_t cputype,
    enum byte_sex thread_states_byte_sex);

extern void print_cstring_section(
    cpu_type_t cputype,
    char *sect,
    uint32_t sect_size,
    uint64_t sect_addr,
    enum bool print_addresses);

extern void print_literal4_section(
    cpu_type_t cputype,
    char *sect,
    uint32_t sect_size,
    uint64_t sect_addr,
    enum byte_sex literal_byte_sex,
    enum bool print_addresses);

extern void print_literal8_section(
    cpu_type_t cputype,
    char *sect,
    uint32_t sect_size,
    uint64_t sect_addr,
    enum byte_sex literal_byte_sex,
    enum bool print_addresses);

extern void print_literal16_section(
    cpu_type_t cputype,
    char *sect,
    uint32_t sect_size,
    uint64_t sect_addr,
    enum byte_sex literal_byte_sex,
    enum bool print_addresses);

extern void print_literal_pointer_section(
    cpu_type_t cputype,
    struct load_command *lc,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *addr,
    uint32_t size,
    char *sect,
    uint32_t sect_size,
    uint64_t sect_addr,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    enum bool print_addresses);

extern void print_init_term_pointer_section(
    cpu_type_t cputype,
    char *sect,
    uint32_t sect_size,
    uint64_t sect_addr,
    enum byte_sex object_byte_sex,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    enum bool verbose);

extern void print_shlib_init(
    enum byte_sex object_byte_sex,
    char *sect,
    uint32_t sect_size,
    uint32_t sect_addr,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    struct relocation_info *relocs,
    uint32_t nrelocs,
    enum bool verbose);

extern enum bool print_symbol(
    uint64_t value,
    uint32_t r_address,
    uint32_t dot_value,
    struct relocation_info *sorted_relocs,
    uint32_t nsorted_relocs,
    struct nlist *symbols,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    char *strings,
    uint32_t strings_size,
    enum bool verbose);

extern const char *guess_symbol(
    const uint64_t value,
    const struct symbol *sorted_symbols,
    const uint32_t nsorted_symbols,
    const enum bool verbose);

extern const char * guess_indirect_symbol(
    const uint64_t value,
    const uint32_t ncmds,
    const uint32_t sizeofcmds,
    const struct load_command *load_commands,
    const enum byte_sex load_commands_byte_sex,
    const uint32_t *indirect_symbols,
    const uint32_t nindirect_symbols,
    const struct nlist *symbols,
    const struct nlist_64 *symbols64,
    const uint32_t nsymbols,
    const char *strings,
    const uint32_t strings_size);

extern void print_sect(
    cpu_type_t cputype,
    enum byte_sex object_byte_sex,
    char *sect,
    uint64_t size,
    uint64_t addr);

extern enum bool print_objc_segment(
    cpu_type_t mh_cputype,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    enum bool verbose);

extern void print_objc2_64bit(
    cpu_type_t cputype,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    struct relocation_info *ext_relocs,
    uint32_t next_relocs,
    struct relocation_info *loc_relocs,
    uint32_t nloc_relocs,
    struct dyld_bind_info *dbi,
    uint64_t ndbi,
    enum bool verbose,
    enum bool Vflag);

extern void print_objc2_32bit(
    cpu_type_t cputype,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist *symbols,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    struct relocation_info *ext_relocs,
    uint32_t next_relocs,
    struct relocation_info *loc_relocs,
    uint32_t nloc_relocs,
    enum bool verbose);

extern void print_objc_protocol_section(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    enum bool verbose);

extern void print_objc_string_object_section(
    char *sectname,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    enum bool verbose);

extern void print_objc_string_object_section_64(
    char *sectname,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    cpu_type_t cputype,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    const uint32_t strings_size,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols,
    enum bool verbose);

extern void print_objc_runtime_setup_section(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    enum bool verbose);

extern void print_bitcode_section(
    char *sect,
    uint64_t sect_size,
    enum bool verbose,
    enum bool print_xar_header);

extern char *get_objc2_64bit_cfstring_name(
    uint64_t p,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    cpu_type_t cputype);

extern char *get_objc2_64bit_class_name(
    uint64_t p,
    uint64_t address_of_p,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist_64 *symbols64,
    uint32_t nsymbols, 
    char *strings,          
    uint32_t strings_size,  
    cpu_type_t cputype);

extern uint64_t get_objc2_64bit_selref(
    uint64_t address_of_p,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    struct nlist_64 *symbols64,
    uint32_t nsymbols,
    char *strings,
    uint32_t strings_size,
    cpu_type_t cputype);

extern void print_coff_reloc_section(
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    uint32_t filetype,
    enum byte_sex object_byte_sex,
    char *object_addr,
    uint32_t object_size,
    enum bool verbose);

extern char *get_label(
    uint64_t addr,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols);

extern enum bool print_label(
    uint64_t addr,
    enum bool colon_and_newline,
    struct symbol *sorted_symbols,
    uint32_t nsorted_symbols);

extern enum bool get_sect_info(
    char *segname,
    char *sectname,
    struct load_command *load_commands,
    uint32_t ncmds,
    uint32_t sizeofcmds,
    uint32_t filetype,
    enum byte_sex load_commands_byte_sex,
    char *object_addr,
    uint32_t object_size,
    char **sect_pointer,
    uint64_t *sect_size,
    uint64_t *sect_addr,
    struct relocation_info **sect_relocs,
    uint32_t *sect_nrelocs,
    uint32_t *sect_flags,
    uint64_t *seg_addr);
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/otool/otool                                 0100755 0000000 0000000 00003330010 13101126756 022624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    @     @                @ 8  @ !        @       @ @     @ @                                      @      @                                          @       @     J     J                   J     Jl     Jl           p                    `Z     `Zl     `Zl                                    @     @     D       D              Ptd        K     K                        Qtd                                                  /lib64/ld-linux-x86-64.so.2          GNU                        GNU -sHM(C   W       ;      7   I   	                C      V       U   &       .   >   J                  E   G         ?   D   @   L         
   4   T   3   )      O   8       P           H          -   F                   !   9           A   K      /   <          $                                                                                                   Q   N              M                                            R                                    '       0   %       *   1   2              #   S   "      =              6   :   B                      (   ,               +       5      M         
0ARM   Q   V   $(/<|>Q5TC9                                                                       	                     ?                                                                                                                                v                                                                                    [                     ?                     z                     3                                          :                                                                 c                                                                                                         u                     F                     {                     g                      h                                                                                    &                     T                     8                                          (                       ,                                                               s                                                                 %                                                                                    $                     e                                                                                                                                                                          7                       8                                          F                                                               N                                          K                                            m                                                                                      M                     P                                          n                     S    G             a    Pl                  @                 l            A     @             9     0@             k    l                l                Xl                G              libdl.so.2 _ITM_deregisterTMCloneTable __gmon_start__ _Jv_RegisterClasses _ITM_registerTMCloneTable dlclose dlsym dlopen libgcc_s.so.1 pthread_getspecific pthread_key_create pthread_setspecific _Unwind_Resume __gcc_personality_v0 libpthread.so.0 pthread_mutex_destroy read pthread_mutex_init pthread_mutexattr_settype __errno_location pthread_mutex_lock pthread_mutexattr_init pthread_mutexattr_destroy pthread_mutex_unlock libc.so.6 fflush strcpy fopen strncmp ftruncate strrchr __strdup strncpy unlink putchar realloc abort memchr __assert_fail mkstemp strtol mmap calloc strlen memset strstr memcmp ctime stdout fputc mktemp fputs strnlen memcpy strtoul malloc strcat realpath asprintf __ctype_b_loc getenv stderr readlink __fxstat fwrite gettimeofday strchr rindex qsort sleep memmove strcmp strerror __libc_start_main vfprintf free __cxa_atexit __objc_block_trampoline _NSConcreteMallocBlock __objc_block_trampoline_end _NSConcreteGlobalBlock _NSConcreteStackBlock GCC_3.0 GCC_3.3.1 GLIBC_2.2.5 GLIBC_2.14 GLIBC_2.3                                                                                                   z      0   P&y        a_&	                     ui	                     ui	                            ii        ui	         p\l        M           \l        '           \l        S           \l        V           \l        T           \l        U           \l        P           Xl        U           Pl        N           \l                   \l        Q           \l                   \l                   \l                   \l                   \l                    ]l                   ]l        	           ]l        
           ]l                    ]l                   (]l                   0]l                   8]l                   @]l                   H]l                   P]l                   X]l                   `]l                   h]l                   p]l                   x]l                   ]l                   ]l                   ]l                   ]l                   ]l                   ]l                   ]l                   ]l                   ]l                    ]l        !           ]l        "           ]l        #           ]l        $           ]l        %           ]l        &           ]l        R            ^l        '           ^l        (           ^l        )           ^l        *            ^l        +           (^l        ,           0^l        -           8^l        O           @^l        .           H^l        /           P^l        0           X^l        1           `^l        2           h^l        3           p^l        4           x^l        5           ^l        6           ^l        7           ^l        8           ^l        9           ^l        :           ^l        <           ^l        =           ^l        >           ^l        ?           ^l        @           ^l        A           ^l        B           ^l        D           ^l        E           ^l        F           ^l        G            _l        H           _l        I           _l        J           _l        K            _l        L           HHA, Ht  H      5A, %A, @ %A, h    %A, h   %A, h   %A, h   %A, h   %A, h   %A, h   %A, h   p%A, h   `%A, h	   P%A, h
   @%A, h   0%A, h    %A, h   %A, h    %zA, h   %rA, h   %jA, h   %bA, h   %ZA, h   %RA, h   %JA, h   %BA, h   %:A, h   p%2A, h   `%*A, h   P%"A, h   @%A, h   0%A, h    %
A, h   %A, h    %@, h   %@, h    %@, h!   %@, h"   %@, h#   %@, h$   %@, h%   %@, h&   %@, h'   p%@, h(   `%@, h)   P%@, h*   @%@, h+   0%@, h,    %@, h-   %@, h.    %z@, h/   %r@, h0   %j@, h1   %b@, h2   %Z@, h3   %R@, h4   %J@, h5   %B@, h6   %:@, h7   p%2@, h8   `%*@, h9   P%"@, h:   @%@, h;   0%@, h<    %
@, h=   %@, h>    %?, h?   %?, h@   %?, hA   %?, hB   %?, hC   %?, hD   %?, hE   %?, hF   %?, hG   p%?, hH   `%?, hI   P%?, hJ   @%?, hK   01I^HHPTIpG H G H @ 7fD  Wl UH-Pl HHv    Ht]Pl f     ]fffff.     Pl UHPl HHHH?HHt    Ht]Pl  ]fD  =,  uUHn], @ Jl H? u     HtUH]zf.     UAWAVAUATSHXHt$PHH, _,     -	  HcHHH\$(J} ILD$HA   A    1HD$@E1   HD$8   HD$01HD$ IcHD$PL<A-  A   0G L  lG L   G L  G L(  G L  G    L  G L\  AWLD$HC  s  AF9  H=,    AIcHT$PHH, HcHH, ,    A      DAM<  AA9]  IcHD$PHau3HluLHT$8HluC@B,    LD$H~  HT$8a   ) b,    LD$H\  HT$8l   )tJLDkLHH|$@d{ HD$@HL$PL|$8J<HH}   1HD$8
   HD$8H\$(LD$H  ,    ,    LD$H  H=, :G  ~K 1 H   HD$ Ho  LD$H  IGH;, A LD$Hs  W  ,    LD$HZ     pu@LAA9?  H=,  tBG 1k IcHL$PHH, I  HL$0V4  1H|$0$G ,      m,    ,       ,    ,    m  ?,    ,    T  ,    ,    ;  ,    k,    "  ,    R,    	  ,    9,      ,     ,      ,    ,      ,      q,    ,      t,      A,    ,    n  ,    _  E,    7,    F  8,    7  -,    (  ",      ,    
  ,    :,       ,    !,       ,       O,       ,       9,    ,       ,    ,    |,    p,    ,    Z,    ,    DJ,    8,    h,    ",    R,    fffff.     HL$0A)H=Z, [G 1H#LD$Hfffff.     AA9y   AN9}qSD)D)HcADttH|$PH<DAI<Hr4HT$PHT)@ HJAt$DIH
AIHuD)A, HL$ 	, , , , , , , , , , , , , , , , , , , , , I, H-, u	H  , =,  Lt$8t  u
y,    D	  LD$HH   L={, M   aG Huu"hG LdtHoG LStW=, unaG H9u]~G L(uL,    *v,    G 1L=   ,    H,     H,     EHl$@IH\$0Hl$Ht=H} $HD$    HD$-@ A   A   LDD~  HAu=,  HX[A\A]A^A_]rG 1L d   HD$PH4JG 1{ fz A   <   G ( G !=G G dG G G 16    PH= , H), /G 1H, G       H, G       oH, G       TH, G       9H, G        H, 'G !      Hd, IG 1      HI, {G 9      H., G 3      H, G       H, G "      |H, (G !      aH, JG -      FH, xG <      +H, G 7      Hq, G :      HV, (G $      H;, MG $      H , rG !      H, G 1      H, G -      nH, G *      SH, G *      8H, JG %      H~, pG /      Hc, G *      HH, G        H-, G 0      H, G       H, 5G ,      {H, bG $      `H=, H, G 1   ,fff.     UAWAVAUATSHX  IIH$      H$      $      H$      H$P      H$H      =O,  tVI   HtJA   G    H1A   DLI   D^, D[, H  I   HtI   G 	   Ht2=w,  CA  =&,  tSI  I  HK    =,  A  IEA} upAU8IMIu0HD|IDd[Iu FH 1I    tA   I   ]H 1M   G 1L   IMIIK'HH9vL)IA   $D  I   H$8  A   $0  LD> IM , T$ Lt$Ld$L|$H$HH$D  H$8  D$0  Ax  ?  :   I  H   I  tb=,  uG 1HE  H$  )$  $  ut H$  t H$  HE   8   H$  )$  Tt H$  Ht H]    I    8  I  I   H   te=,  uG 1I    H$  )$  $  us H$  \t H$  I   =8u5 H)$  )$  s H$  Ht I   =G,  u

   KHE HuI    :>  IMI  H$  A  H2IMH9vH+$  HHtHhHXL@HHHPA   H!I   LGHOHWA    HoH_De $  ?$   A8$L  	$D  
H$8  =,  t@IDHuI   8pPHD@DH@-/, l$$  ALH$  H$8  B01H9vJH$8  HFk EH1HHI(  H$  L)HiHEI(  H$  =Y,  tLI(  E  , , L$D$H$  $$D  H$8  DD$L    	, , 	t9I(  A   DD$, $D  H$8  o $      H=:, H   H52, H   I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$$D  L$8  $L  A=  	u#$  w sH$x      , , tyI(  E  H$  HD$(H$  HD$ H$  HD$H$  HD$H$  HD$H$  $$D  H$8  DL$  F  1H$  =,      H$0      H$8      H$@  9  ', , , , , , , 1, , uV$  
w
   r=x91H$8  u*H&, H    H$0      H$@    I(  E  L$   H$  HD$(H$  HD$ H$  HD$H$  HD$H$  HD$H$  $$D  H$8  DL$  JE  L$  M   Au!H$     Pn 1H$8  9tD$  HH<@Ng HH$8  $  HH@HLyH$  ID$,  H$     m 9   $  m L    D$,  L$  AH$   u  m 9t4$  Hf H$  HHLH$  I  Rm E19    H$8  t%$  2m L E11H$8  , , , uO$  	, u%  	u1
t %  u1H$0  1H$@  V  $  He D$  E1E  H$  H$  D$  D$  1H$  H$   E1ffff.     Mt)Htm IT I|ILAt0fffff.     HHH$  H3H|3HL3Ht3H9t"D9A)G sH$   If.     A)G .  DAt
A  $  H$  D$  LIL2H!Hr3BL .uBL ouA.   )o   )taFG LTtPTG    L^t:ALID$  H$  u6Hu1A$.u'D$  UD  LID$  D$  8DHHTL$$  TAD$  ffffff.     D95L$@  H$0  D    ~@ HL$   D$,  , , 	, A            x  I(  A  L$   $D  H$8  k  E1        H$      &  $(  H$  9   H$  L4A      $,  H$  Hk8HHH!H9v1G HH$(  )Hi%I$H H$  H$  E1MH  AuA  -i 9t*H$  Hk8H3b HHLHrIA  h E19  1L*   G 4E111H$  
  $,  H$  Hk4HHH!H9v.G HH$(  )HiONH$H$  H$  E1MteAuLE  Gh 1A9IMt*H$  Hk4HDa ILLHLE  h A9  1C1=AE   M   A   C  g LHH$  y E11R, H$  H$  D$,  ME1    H$0    I(  A  L$P  $D  H$8  i  A    ti$p  H$  9sFH$  L$D$t  JHH!H9Hv+PG _AD+$p  AG DE1E1AuA  f 1H$0  9t+DHH_ HH$0  HLHIA  f 9t~f LD LH(    L$  H$  $  H$  $  , D$Pl$HH\$@t$8HT$0LD$(H$  D$ H$  HD$L|$Dl$L$$$D  H$8  L$  L$  ? =p,  tBMH$  $  Dy, tLH$   H$  H$  $ E1=&,      H$(  k  I(  A  L$P  $D  H$8  f  A    tk$  H$  9sHH$  L$D$  JHH!H9Hv-G K$  AA)AG .E1E1AuA  d 1H$(  9t+DHH] HH$(  HLHIA  qd 9thd LD L$  H$  $  H$  $  =, |$ t$HT$L$H$LDLH$  L$   L$   =,  Mu8E1=f,  ]  ,     H$      H$  I  I(  A  L$P  $D  H$8  6e  E1    H$  t|$  H$  9sRH$  L4$  H$  HHH!H9Hv7G $  )H$  @G cE11H$  AuA  b 1H$  9t2H$  HH[ HH$  HLHIA  b 9t-b LH$   1H$  1H$  L$   1H$   =,    I(  E  L$   W)$P  "b A$D   6  H$8  L,AHH$  1fHE H$  E9tH$  Db $  
fD  H tG 1$  HL9voVH 1{$  }   AtG 1DXfH$  H)H$8  W)$P  HAH!H!H   HCH$P  HE9AtH$P  D A$  Ht-HL9w3;$D  "H$8  L,AG 1HI9t
 G E1AA    L$   tk$X  H$  9sHH$  L<D$\  JHH!H9Hv-G $X  AA)AG E1E1AuA  ` 1H$   9t+DHHY HH$   HLHMIA  _ 9t_ LDx I(  A  L$  H$  $  H$  $  J, D$(\$ Hl$t$HT$L$$D  H$8  ME: =,  '  I(  E  L$   W)$P  _ A$D   ;  H$8  L,AHH$  1    HE H$  E9tH$  D_ $  
fD  H tG 1$  HL9voVH 1k$  .}   AtyG 1DHfH$  H)H$8  W)$P  HAH!H!H   HCH$P  H|E9AtH$P  D$ A$  Ht-HL9w3;$D  "H$8  L,AG 1HI9t
 G 1A    L$   td$X  H$  9sCH$  H$\  HHHH!H9Hv%G $X  ) G 11H =,  L$   u)E1=,    , A          I(  E  L$   W)$P  \ A$D   :  H$8  L,AHH$  1fD  HE H$  E9tH$  D?] $  
fD  H tG 1*$  HL9voVH 1$  )}   At?G 1DfH$  H)H$8  W)$P  HAH!H!H   HCH$P  HE9AtH$P  D A$  Ht-HL9w3;$D  "H$8  L,AG 19HL$   I9t
 G E1AA    L$   tj$X  H$  9sGH$  L$D$\  LHH!H9Hv`G 1$X  AA)AG E1E1AuA  Z 19t#DHHS HHLHIA  gZ 9t^Z LD =,  t, LD H$   =,  t~I(  E  H$  H$  $  H$  $  , \$0l$(Ht$ T$HL$HD$H$  $$D  H$8  $,  M~ =A,     I(  E  H$  H$  $  H$  $  -, \$0l$(Ht$ T$HL$HD$H$  $$D  H$8  $,  L$  (a =1,  t^I(  A  M  E  H$H  HD$H$P  H$$D  H$8  2  H$P  H$H  Q =2,     I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$aG hG $D  L$8  D$L  )%  $      H$h      $      H$`      $      E1=~,      H$  /  $L  S  I(  A  M  E  H$  HD$H$`  HD$H$  HD$H$h  H$$D  H$8  ;  $h  uA  W 9t6$  H P HH$h  $  HHRH$h  $`  uA  V 9t6$  HO HH$`  $  HHH$`  A  ~V 9t@H$h  $  fV H H$`  $  FV H L$p  Au!A   V 9u$  H$  /$  H$  HHO HHLHOIA  U 9tU LH$  5 I(  A  M  E  H$H  HD$H$P  H$$D  H$8  L/  L$  L$  L$  =-,  H$0  H$@  u:H=,  tsvK aG hG H5, H , YG 1HA  $  H$  H$  H$x  H$  H$  $  $  H$  H$  H$  H$  $  $   H$  H$   $  $   H$h  H$  LD$  L$`  $  H$P  L$H  L(  D, D%, L  D  H$   H$X  =,  x  H$P  D$\  L$`  D$h  D$l  L$p  L$x  H$  $  L$  D$  D$   L$   D$   H$0  B  H!HE1f.     LHH$0  LDLH)  L9  IA9L$  D$  L$  $  sLHHLH9rHD)H$  H$P  H$   H$  $   H$  H$   $\  $   H$`  H$   $  $   $h  $   $l  $   H$8  $   $D  $   H$p  H$   H$  $   H$   HD$xH$x  HD$pH$  HD$h|$`L\$XDT$PLL$HH$  D$@H$  HD$8D|$0Lt$(Dd$ H$  HD$H$  HD$l$H4$$,  $  D$  7  H$  D  IA9$I  H$   H$  $   H$  H$   D$   L$   $  $   D$   D$   H$8  $   $D  $   L$   H$  $   H$   HD$xLL$pHt$hT$`LD$XDl$PH$  HD$HH$  D$@H$  HD$8$   D$0H$   HD$($   D$ H$  HD$H$  HD$l$H$H$0  $  ID$  $,  H$  5  H$@  H$  HL$   tH;$p  t={,    I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$aG oG $D  L$8  D$L      D$  J,    HQH IH$p  LHA  O 9tO LDy    p@ LLT=z,  u|G aG oG 1A  H$  $x  $  L$  L$  D$  H$  $  Gz, \$8Dt$0L|$(l$ HD$DT$LL$L$L$0  L$@  Q L=y,     I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$G G $D  L$8  D$L    uJ=Uy,  usvK G G 1MA  H$  H$x  L$  $,   =#y,     I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$aG ~G $D  L$8  D$L    u:=Nx,  usvK aG ~G 1F$x  H$  b)H 1+H-<x, H4  L54x, M$  $      G HuVG LuE=w, u<I(  A  M  E  $   $D  H$8  z   G H   G LtG L   =-w,    $,     I(  E  M  A  C  L$  $  H$  $  H$@  L$8H$0  HL$0l$(H|$ T$LT$\$$D$@   L$D  H$8     G HuVG LuE=[v, u<I(  A  M  E  $   $D  H$8  6 Z  G HdK  G LO6  =u, t=u,    I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$HL$D  L$8  D$L    i  H$  H$x  u, u,  D  E11u9A}<ucIEM   I   lI LH$  : 1?MuImY$D$   L$D  H$8  '}   IEIM0AU8HDtIHL)I.IEH9vL)HHs  At   G W$  )$  H   HFH$  Lu(H H$  yH =s,    $  $  $  $  D$  D$  $     t   G W)$  )$  H     HFH$  LuyG H$  
H =r,  S  $  $  $  $  D$  D$  $  -r, l$$h  	  G HX  [A\A]A^A_]XH-r, G HHr, uaG HuP=r, uGI(  E  M  A  $D$   $D  H$8  $L  M   I(  A  H$X  HL$HH$  HL$@H$  HL$8H$p  HL$0H$  HL$(H$x  HL$ H$  HL$H$  L$H$  HL$$HH$D  L$8  D$L       =q,  uH5q, Hq, YG 1=jq,  $  tUwa$`G H$  $x  H$  E  4q, D$H$@  $$,  L$0   HuG 7G 1A  H$  H$x  L$  $,   =p,    M(  A  $  M  A  H$  D $  $,     $   E$  $  $  H$  3B HtPH$  tG 1A   @$   t1L$  wIH 1H$  /9G 1   L$  	+H 1H$  $D     H$8  L$  I,H$  ME1J  f.     IH$  I9L$     AD;$D    y  H$  H$  IUAE$  ;$  tH9[  S  H$  H+$  H$  MH;$  (  $4  H$  H9  IH$  	   H;$  }&H$  f     } tHH9r
   AFI$  ;$  tI9  LX  fffff.     I$H$P  $  ;$  t$H$P  %C $T  fff.     H $   ttG D  tG 1D$T  LH9voVH 1DH$  L)H$8  $P     W)$  )$  )$  )$  H$       HAH!H!HHH   HCH$  L;$  tH$  B H$  H$  H;$  ;  H$  H$  HH;$    A  D    W)$0  )$   )$  H$@      HAH!H!H88   HCH$  L$  ;$  tH$  wA $(  $,  H$  L  H9q  $0  $4  H$  9P  H$  HHJH$  D$  ;$  tH$  HH$  H:H$  Ll2H9hH$  `H$  H)H$  H9B$4  HH9/IH$  	   H;$  }+H$  fffff.     } tSHH9r
   AAEI$  ;$  tLI9`$,  H9u"$0  $4  H$  9  $T  H0G 1DL$     H$  HDHHH9H~H9 uHH9wLqH9LDI9LL$   vYA> LHt*} u$} u} u} u} u} u} tHHH9vHh8 uHH
   HL9  	   1L9Hs8tHD L9rHHtH$  HDHH9H~H9 uHH9wLqH9LDI9LL$   vAA> LHt} u} u} tHHH9vHh8 uHH
   -HL9s.	   1L9Hs8tHD L9r=h,  (  $,       I(  A  M  E  H$  HD$H$`  HD$H$  HD$H$h  H$$D  H$8     $h  uA  l< 9t6$  Hx5 HH$h  $  HHH$h  $`  uA  < 9t6$  H(5 HH$`  $  HHZH$`  A  ; 9t@H$h  $  ; H2n H$`  $  ; Hn I(  A  M  E  H$H  HD$H$P  H$$D  L$8  D&  M(  A  $  I  H$  L$  D$  L$  D$  L$h  LD$  H$`  $  H$P  H$H  -f, f,   \$pl$hH|$`HT$XL$PHD$HDl$@Ld$8H$@  D$0H$0  HD$(D|$ LD$D\$LT$4$$,  LD$  L$  $D  D  k  I(  E  M  A    H$  HL$H$`  HL$H$  HL$H$h  H$H$D  H$8  DMA3  $h  uA  9 9t6$  H2 HH$h  $  HHH$h  $`  uA  ]9 9t6$  Hi2 HH$`  $  HHH$`  A  9 9t@H$h  $  8 Hsk H$`  $  8 HSk I(  E  M  E  L$  D$  L$  $  H$h  $  H$`  $  =@d, |$XT$PHL$HD$@H\$8H$@  D$0H$0  HD$(l$ L|$Dt$L\$D$   @  c, L$H$@  L$H$0  HL$$A$D  H$8  '8   I(  A  M  E  H$  HD$H$`  HD$H$  HD$H$h  H$$D  H$8    $h  uA  f7 9t6$  Hr0 HH$h  $  HHH$h  $`  uA  7 9t6$  H"0 HH$`  $  HHTH$`  A  6 9t@H$h  $  6 H,i H$`  $  6 Hi I(  E  M  E  L$  D$  L$  $  H$h  $  H$`  $  =a, |$XT$PHL$HD$@H\$8H$@  D$0H$0  HD$(l$ L|$Dt$L\$D$D$D  H$8  Px H$  HtH$8  HL$  H$0  IL$(  H$  H$   taH$0  HtOHtHBHtH5H$   Ht#MtLMtL	MtLH$P  HtHX  [A\A]A^A_]H$  $x  H$  =`, D$,  j H$  $x  H$  E  =}`, D$,  k H$  $x  H$  E  =@`, D$,  =l QD$  J,    HP- IH$p  LHA  4 9t4 LDxf    p@ LLSI(  E  L$  D$x  L$  H$  H$  $  H$  $  =p_, Dt$PL|$HT$@HL$8D$0Hl$(H|$ L\$DT$LL$H$  $\$X$,  $D  L$  H$8  m L $H$  $x  H$  E  =^, D$,  cl fffff.     UAWAVAUATSH  DL$E\$IHt$@H|$0H$  H$  H$   H$  H$  H$  HE     H    H    H             F2 D$<1  DHD$HIHD$XE1ML|$P1H     Ll$ IL;l$Xl$,    ;l$Erz     A   H  IE H$  D|$<D;$  t%H$  D2 $  fff.     H AtG 1d$  LH;D$XvoVH 1CHT$PL)HT$H$    Dt$l$,W)$0  )$   )$  )$   H$@      ID$H!L!HHH   HCH$   LFD;$  tH$   D1 |$u$  t   H$  Ht$0  $h  H$  HLH\$ LsHAD;$     
    IAD;$@    M~PL;|$Xv
G H\$PL)H\$HW)$   )$   )$   )D$p)D$`ID$H!L!HPP   HCHl$`HLH:   HT$<1    HHt$@u   H|$pHt$01L;|$X*  D  IAD;$@    M~PL;|$Xv
G H\$PL)H\$HW)$   )$   )$   )D$p)D$`ID$H!L!HPP   HCHl$`HLHZ   HHt$@u   H|$pHt$0 1L;|$X;  fD     Dt$l$,W)$p  )$`  )$P  H$      ID$H!L!H88   HCH$P  LD;$  tH$P  D/ |$u$X  tF   H$X  Ht$0<t+Ll$ ^  fffff.     Ll$ l$,1ED  $h  H$  HLH\$ Ls8A
    IAD;$     M~DL;|$Xv
G Hl$PL)Hl$HW)$   )$   )$   )$   $       ID$H!L!HDD   HCH$   HLH~$  9D$<t   HT$<.    HHt$@u&   H$   Ht$0   A   t+1L;|$XA  fff.     1Dd$$  HgG 1t$,W1A  AH$  $  u($   uOH$  H     $     $   uSH$  H     H$   H$  H  $   9v@H$   H$   G 1   $   9vIHt$pHT$`G `  H$  HH$  H
$   9wY9wSH$  HvH$  HH$  H
H$   H9   HH9   H$  H   H$   H$   G 1+$   H$  H$   9s]H$  HHH$   H$   HH9vPH$   H$   G 1+$   H$  ((H$   H$   CG 1\
H$  $   H$      Ht$pHT$`G 1$H$   9sZHH I!H$  HLH$   HIH9vDHt$pHT$`G 1+$   H$  ("Ht$pHT$`CG 1
H$  H$   H$   H$     H  [A\A]A^A_]f     Wfff.     Wfff.     1ffff.     1ffff.     UAWAVAUATSHXMDL$Al$,IH$   H$   H$   H$   H$   H    H        H         ( AW)D$0HD$@      L<$DHD$M,HHD$MLd$ E1@ IHD$PA9tH|$PD6) D$TH tG 1D)D$TLL9voVH 1D|$PuetG 1PHT$ L)HT$H#T$H   HCH|$0L?A9DtH|$0D** D    D$THt/IM9w6AD;d$,!&EML$   !G 1DYLL<$D$   DI9t
 G    D$89sMID$   tKH$   H
L$<HHHH9vfG _+D$8H$   QG @EH$   H
L$<HIHH9vG +D$8HH#H$   D$@9s%IH$   L9L$D9v0G `G 
H$   HX[A\A]A^A_]    HN1H9Ot   BfD  UAWAVAUATSHX  DL$|LD$P$   H$   H$  H8 
  H$  H$  H     H    % AD$   H$   H$   HH$   D$|HD$@   1HD$`1H$   1H$   1HD$81HD$HKDHo HD$`$   HZ HD$H$   HE HD$8fffff.     l$\  D$lL$   E1$       $       E1 IH$P  D;$   tH$P  D% $T  fH tG 1Dy$T  LH;$   voVH 1DTH$   L)H$   $P  &=  +  =  p    ff.     '    W)$  )$  )$  H$      HAH!H!H88   HCH$  L+D;$   tH$  D$   D$   Ll$p$  HkDH8 H$  HH0($  ($  ($  P H $   $   HL$HHH8H$   <  fff.     =  tI="  g  =#  t7  f   9   .  fffff.     uA`  D$   AW)$   H$      HAH!H!H   HCH$   LD;$   tH$   D% $  ;$  G sLHHH$   H$   v AMHDtHt$`H	HD$`HAD  D$   Ll$pAE$     Io8E1D  HEDH;$     H$   H)H$   W)$P  )$@  )$0  )$   $`      HAH!H!HDD   HCH$   HHD;$   t   H$   D" AuM$`  H$   A@($   ($0  ($@  ($P  Y0Q IHDH$   HAD;$  D$l$   l$\ED>  W)$  )$  )$  )$p  H$      HAH!H!HHH   HCH$p  LD;$   tH$p  Di! $   5  D$   $  H<HHH H$  HH@($p  ($  ($  ($  X0P H HL$8HHHH$      "D  ;  W)$@  )$0  )$   HAH!H!H00   HCH$   LD;$   tH$   D=P $0  ;D$|d  $4  HH;L$@V  H$      H$     D  D$   $   E  Ll$p$   AIoHE1     LuPL;$   v
G H$   H)H$   W)$  )$   )$   )$   )$   HAH!H!HPP   HCH$   HH$   ;$   t   H$   $     AuO($  H$   @@($   ($   ($   ($   X0P H HPH$   L;$     HAD;$  Ll$p$   AD$l$   l$\D$   DLl$pD$   $T  HtBIL;$   wJAA9^<fff.     $       $       E1G 1DfD  H$     |L$0  $4  HT$PH<HHH$  HD$H$  HD$$   \$HD$8H$Hl$`HLD$HD$    HtH7AH|$H t:$   t%H\$Hfff.     H;HuH|$HH|$8 t@Dt#H\$8fffff.     H;HuH|$8
G *HX  [A\A]A^A_]G G 1D G @ UAWAVAUATSHXDML$   L$   L$   H$   HE     AE     I$    A    LD$     D$H9s0IHM L$LHH9v%G b+D$HAE G IAM D$P9s,IM4$L$THH9v"0G +\$PApG AHX[A\A]A^A_]UAWAVAUATSHx  ELAD$L  HH$P  $p  AT $l  H~  $P  uhD$l  $  L%$F, M  H$`  1At%H$  fH;LtHH D9rD9y  G   D%  L$X  E  H$X  %   H$X  DH$p  E1ff.     H$X  tWH 1HU "ZH 1BDEA)sgIADFEADH$P  H$p  B, Ff3H 1HuE)IL$L       E1
   LA9AD  AL$X    ED  E1fffff.     "ZH 1rA9smH$`  $l  ;$p  teEH$P  N$81@ AHfA,f[H 1"H]E,wwAD/D9rw    H$`  1d@ EH$P  N$81ffffff.     AHA4,[H 1H]E,wAD/D9rD	DfD  
   H$`  HHA9  1H$8  H$@  EaHH$  HLHH$`  H)H$8  EW  DHH9H  H$@  H$8  H!H$P  D$`  ML$X  AuAD$w$l    C,       EE  H$X  %   H$X  1fffff.     H$X  tWH 1He "ZH 1RH$`  D9sUH$P  L<E1@ C4/$l  ;$p  t"ZH 1MeB,#AwBD+D9MrE1
   H$`  LD9O  G 1LHx  [A\A]A^A_]B,    jA, 1A, t~A    H$     D HHtcD IMt]   Hu    Lu =A,  tD   Hu    LL$  u (1H$  G   G   L$  @, E1@, tGAuA IM      L5u    L(u =u@,  t   Lu \@, 1H$  |@, tlA  uc IMtD   Lt    Lt =@,  t+   LL$  t G    `G    L$  1A      H$   L$8  u%	 H      HH$   Kt 1H$   =?,          H$0  t!   H$0  =]?,  d   L$  1E9H$@  =  H$   D   $  H$P  1$,        0G Hx  [A\A]A^A_]DD)$X  D$8$  D$0H$  HD$($  D$ H$  HD$$  D$H$  HD$$  $EL$`  LL$@  DD$p  L$  *
 LEL$X  
  DD)$X  D$`$H  D$X$@  D$PH$8  HD$H$0  D$@H$(  HD$8$  D$0H$  HD$($  D$ H$  HD$$  D$H$  HD$$  $LEL$`  LL$@  DD$p  L$  6 
  t|AtAtA  ug    L$8  EH$   9   H$`  IH$   HH4@H$0  
 I   ffffff.     H$`  $l     HH$  $  Eg $,  AD==,  tD)(G A1D=<,  t$,  H$@     $,  $      !H 1H   H$`  IL$0  $l  L$0  H@HWAD ADAHH$@  I<H$  $  f IDLEL$X  L$8  QJ 1A=;,  uH$@  A  t	   H$@   A     DD)$X  D$h$H  D$`$@  D$XH$8  HD$P$0  D$HH$(  HD$@$  D$8H$  HD$0$  D$(H$  HD$ $  D$H$  HD$H$  HD$$  $MEL$`  LH$@  D$p  L$   LEM$l  a
  A  D$l    DD):, DHIHH$0  $p  $   H$h  H$   H$  H$   H$  H$   $   $X  $   $H  $   $@  $   H$8  H$   $0  D$xH$(  HD$p$  D$hH$  HD$`$  D$XH$  HD$P$  D$HH$  HD$@H$   HD$0H$  HD$($  D$ H$  HD$$   D$H$  HD$$  $H$   $       H$       $     HD$8    L$8  MEL$`  LH$@  HHED$p  L$  w, LEML$8  Dn  fffff.     A   DD)$X  D$8$  D$0H$  HD$($  D$ H$  HD$$  D$H$  HD$$  $H$`  HMEL$@  DD$p  L$   H$l  LEM  A   DD)$X  D$`$H  D$X$@  D$PH$8  HD$H$0  D$@H$(  HD$8$  D$0H$  HD$($  D$ H$  HD$$  D$H$  HD$$  $H$`  HD$L  L$@  DD$p  L$  c H$l  LD$L    A$l    DD)7, HIHH$0  $p  $   H$h  H$   H$  H$   H$  H$   $   $X  $   $H  $   $@  $   H$8  H$   $0  D$xH$(  HD$p$  D$hH$  HD$`$  D$XH$  HD$P$  D$HH$  HD$8H$   HD$0H$  HD$($  D$ H$  HD$$   D$H$  HD$$  $H$   $       H$       $      HD$@    L$8  MEL$`  LL$@  LHD$p  L$  (   A      AE  $G DD)$X  D$8$  D$0H$  HD$($  D$ H$  HD$$  D$H$  HD$$  $LEL$`  LL$@  DD$p  L$      A      DD)$X  D$h$H  D$`$@  D$XH$8  HD$P$0  D$HH$(  HD$@$  D$8H$  HD$0$  D$(H$  HD$ $  D$H$  HD$H$  HD$$  $LEL$`  LL$@  DD$p  L$   LEI$l  L  A$l    DD)H@HH$0  H$  H$   $  $   H$x  H$   $p  $   H$h  H$   H$  HL$xH$   HL$p$X  L$h$`  L$`$H  L$X$@  L$PH$8  HL$H$0  L$@H$(  HL$8$  L$0H$  HL$($  L$ H$  HL$$  L$H$  HL$$  $H$   $       H$       L$8  MEL$`  LL$@  DD$p  L$   g  A  H$   "  DD)H$   $X  $   $p  $   H$h  H$   $H  $   $@  $   H$8  HD$x$0  D$pH$(  HD$h$  D$`H$  HD$X$  D$PH$  HD$H$  D$@H$  HD$8H$   HD$0H$  HD$($  D$ H$  HD$$   D$H$  HD$$  $L$8  MEL$`  LL$@  LD$p  L$  $ LEML$8  Lfffff.     HHA=0,  E9L$     AtAtA    L$X  D$L  H$`  D$`  ML$0    H$X  %$@  MF@1fH4IHA|6$ tiIt6(t	    tI;6uAF      r@H,    Hlm I,)fH;uuE   HH;uuE    HH`uH9u  InA   fff.     }u-   A- HHM LDbTG 1H|DH0uL$0    MLA$l  HH$`  L$  HuHtXG HuHt]G 1}yE    HU HH)HH!H$P  $@    $L  )d., $l  $   H$0  H$   H$   $p  $   H$h  H$   L$   H$  H$   $   $X  $   $H  $   $@  $   H$8  H$   H$X  $   $0  D$xH$(  HD$p$  D$hH$  HD$`$  D$XH$  HD$P$  D$HH$  HD$8H$   HD$0H$  HD$($  D$ H$  HD$$   D$H$  HD$$  $HD$@    HD$p  L$  [  R  H$X  A  $L  )$l  $   H$0  H$   H$   H$  H$   $  $   H$x  H$   $p  $   H$h  H$   H$  HD$xL|$p$X  D$hDd$`$H  D$X$@  D$PH$8  HD$H$0  D$@H$(  HD$8$  D$0H$  HD$($  D$ H$  HD$$  D$H$  HD$$  $D$p  L$  4 H0A$l  L$0  tI^H;Ht	!uH0uLuH$  Ht= H$  HH$  t# MtL HtH	 H$   HtHx  [A\A]A^A_]V Hx  [A\A]A^A_].G 1DHx  [A\A]A^A_]u@  I I19t   Bfffff.     UAWAVAUATSH(ML$Al$I* !  DHD$M$HH$Lt$E1f.     IHD$ ;\$tH|$  D$$H tG 1DtD$$LL9voVH 1Dt|$ uutaG 1rt`HT$L)HT$WAE@AE0AE AEAE H#$HPP   HCLLu;\$DtL DD$$Ht%IM9w,AD;|$EMG 1DsM9t
 G 4sH([A\A]A^A_]f.     fUAWAVAUATSH  DL$0DD$4AAII1$  uGL%sH1r51A.)u'(   Ls1HtL9t  HA. H_(,  HL$h11E1L  M  <(, $        E   II\$D1ffff.     AA    u(A|$ H    tAL$3H H$0  ;CuH 3    tuHt$hHSaG 1: DHuL!  H  Ht$hH  H$  H$       E  H\$8Il$A   D1f.     AA    u(A|$ H    tAL$3H H$  HtMu(p;u  u 3p @@EE   \ffff.     H$  H   u(H;M   M 3H @@EE   H;M   @   	%   	M  !9EEHH$  ;EuH 3E     t+u'Ht$hHUaG 18 ffffff.     DHH\$89  $  t			  |$0H$  IH$   	  H	  Ht$hH!  	      ER  EI  Ld$    Hl$hE1fffff.     $   H\$8Ltk  $,  ]  1H1  h  IH\$8LL|$(HHl$ Lt|L HtL3H AE1AH$       HDHL$HlfH$   A;uH 3E  D   $h  u2$h      H$  HuH$  HtH$  _ $   tu3$,  u)$   H$   ;ps$L0  WHt$hG 16 Ht$hHD$ HaG 16 L|$(IE9y
  $   L|$(u5H|$8HM   L  HD$p  LHM  |$4Mt$tK  HT$hH$   -G   y  $  t		d  |$0W  LMHt$H$   $  s  Ht$h8G 1gmHl$HtEG 1HNm
   DlL    1|$4ucLHH$   $  $h  u2$h      H$  HuH$  HtH$  ^ L  t;  $,  uVLHH$   $     $h  u2$h      H$  HuH$  HtH$  ] Lo  t   HT$hH$   XG :HL$8Ht9HT$hH$   G 14    HT$hH$   G 1m4 oLMHt$H$   $  $h  $h      H$  HtH$  \ MH$  HMtH$  \ M$h  6$h      H$  HuH$  HH$  \ H|$8HtlL.  H$  H$   HL$   LHM$h  $h      H$  HtRH$  \ MLb   H$  H$   IHl$t>LHLLS"  u0H$  HMt H$  [ MLHLMt|$4  H|$h1H$   $    Ht$hE1G 1jH|$h  H$  IH$   I  H\$hl$4f     t
$,  u1HLAA   H  tE  Ht$hmG 1y  EL$  L$   o  Ld$pI4$Ht)=, HT$x". tHT$hFG 14 H|$hHt*hHH$   HthH\$h1P  Hi11E1LH  A  $   t>  $,  0  H|$h1(+  -  ILd$h\$4$   u%LH   ILq	  }  g  t$tf  HT$hH$   -G       $  t		   |$0  LH   IL  IHt$hH$   1G 1gL  }   f     t
$,  uH$   LLA   L  t   HT$hH$   XG 8LHH$   t1HT$hG 1I/ aHT$hH$   G 1/ FI8IL  u H$   LLAL  tH$   LLA$   tl  $,  ^  $   H$   ;p  L&)  	  H  G 1L!HH$  H$   tHt$hG 1H. Z  H|$h1L  Ht$hG 16  H|$h  u$H\$hf1HHAH  t  H|$h1HA  H|$PHt$@5 |$Xu    )D$P|$X E1HtL$\3H DHt$pHt)=Z, HT$xh* tHT$hFG 10 H|$hHtpdHH$   Ht[dH\$h1P  He11E1LH5    $   t   $,     H|$h1n'     Hl$8Ld$pH     H\$hH$   HL$X9uH1Hz  Eq  $h  u2$h      H$  HuH$  HtH$  U $   t   $,     $   H$   ;p   H&  P   Ht$huG 1
BG 1L, Ht$pHt)=, HT$x( tHT$hFG 18/ H|$hHtbH$   HtbH|$h1P  FdH  [A\A]A^A_]Ht$huG 1, I4$tHt$hG 1YHt$hG 1+ L$   H\$8$   u&H|$8H   Ht$h    |$4HL$8ttHt$hBG 1  $  t		   H|$0W  H  Ht$h  H$   E  H|$h16  Ht$hE1G 1bH|$h`	     H\$hH$   Il$4t
$,  uM1HLAA   $h  u2$h      H$  HuH$  HtH$  GS H  tEHt$hmG 1HtdHT$hH$   G 12* Ht$hG 1H|$hB  u&H\$hH$   1HHAH=  uH|$h1H$   A$h  <$h      H$  HuH$  HH$  aR fff.     UAWAVAUATSH   IIII11P  Lra11LFc   HT$(   b   L|$Lt$ Lt$XE1Mt)11      E1LA^`II   a=O,  t , 4tH$   G 1A`H$   L$$LLLLD$LL$ M  G `1G 1LJ* H   [A\A]A^A_]G 1L'* `fffff.     PG tu   u1X"  H7uG 1( 1Zfffff.     SHHsHt&=, HS$$ tHFG 1* H;Ht0^H{@Ht"^1P  H_[UAWAVAUATSHhIHA       I       A       M   I  WA   I       A  A  I(      AE u
MuMe&uUA}<u[AE8IM0HDtMuDdLd$0IrG    L]tC1G 1LH Iu 1jG Iu 1G 1& Hh[A\A]A^A_]ItIDs	16G Hl$ L|$H\$I	V  IFHD$   !J|31
   p`HO<&A  M<Hk<G    L\tRHl$8   BD3   HD$H1fffff.     Mm  (H t\  Hl$8D$P A)D$@LL|$C`H BDx   Hl$(
   H|$CHt$`_IAu0	\8"u&G    1LL|$(LF Ld$8   DLd$8D)HL$`fff.     HL$`HQtG tG    1LL|$(L=F >6G    1LH$F ILd$8A9p@G 1LF L|$(Ld$8   BD3 u3HD$H1ffff.     M~(H tE1L|$(~HcLHt$ [   J|301
   ^^   HQL HH\$8Ld$0I9G 1LHT$ GE Im(HE     IE0    A       I       A       WHD$ H@    HD$@ H@     1M   A   HD$8LHD$8A   M<M   J|301
   ]D)A   HD$(I   A        AA      xAuUA      Im(M}(LD IE(pHH   A   H9   G 1LD HT$0H+T$8HtuA      I   I  A  tADAE  I  HI(  HD$8J|0I}0D L  z"H ktWA      I   I  A  tADAE  I   H I(   UAWAVAUATSHH       H              L   L  W   H           H(      C uHCHKIH2   {<   HCHKS8Hs0HlHDdL}LH)H9~
E1G 7JT% HH9vH)IIrG    HvWtEE1G 1HA H3E1aG H3E1G 1_  DH[A\A]A^A_]ItICw
E16G Lt$E1It   D   LuDL   H}81
   DZ   L          L   G    LVt,      U uYH~ML H t>L   H1
   HY      H   )   HD   D   HCP    CX    HCx           WC`Cp        A   A   H   uL      H{(D HC(pHH      H9   G 1H@    I)I;  t         H    tADAD  H  HH(     H   HH{0D H     HC(    HC0           H              WAE IE    HD$@ H@     E1ZI rTtuD      H    tADAD  H   H     H   G    HTtG 	   HTH   HCPD   DcXH   HC`Hkh   CpHCx           H              { ]Aw      HB AH{s#0 t:HkPDm D9tAAB   HQL9v            T HT$D9tHT$HT$QHT$HT$L
HL9v      ALeD9tLDD Hl$H1HL$9Ms@M H;KsFuPHD9rLcxD   HD$H   HD$   .                  UAWAVAUATSPHC u
HkLk#uM{<uSC8HK0HlHkDlIrG    HQtA1G 1HP< H31kG 
H31G 1 H[A\A]A^A_]H    t7D         B IMM<.LH+CH;Cv1oG 1G yH   M9ugL   A>uWC(       H              W @    A        H(      1/v1G H$IF<   Nd5<L   J|501
   T   L   L   G    LPt/   AL. uXJL51P~GH t9L   I|.1
   S      AL   )      E1       W    H(       A      H   uWL         H{(Dj HC(pHH      H9   G 1H: H$ HL)LL)Htu{      H    tADAD  H  HH(  :H   HH{0D H|  H${H  t      H    tADAD  H   H H(  fUAWAVAUATSH   IH|$M   I   HD$WA   A       A   I       AE<A} u&t;A8  t/	t*Iu 1G 7  tA8  t		  I  I(  HuI   H	1  E11ffffff.     0tuHffffff.     LDPHHuH]  MT  A|$, H   A  M  MHL$I  AL$,A   A|$(I>H    IH  9$D$N|7E  1f     AGd$   AG4AODAWTM4)$   )L$p)D$`   H|$`T$m HD$L8l$`Hl$LH|$H,Ne  A;\$,r(  I   e  9$D$J\7a  E1HChHD$PC8KHSXH[8)T$@)L$0)D$    H|$ T$U I   l$ Hl$LH|$HM  AE;|$,rT  Iu 1G 1   $D$HD$L8h1@ AGd$   AG4AODAWTM4)$   )L$p)D$`HD$L8l$`Hl$LH|$HL8  A;\$,rAG0$   AAOAW )$   )L$p)D$`T$;$   H|$`       $D$I   hE1ffffff.     HChHD$PC8KHSXH[8)T$@)L$0)D$ I   l$ Hl$LH|$H8LtuAE;|$,rHC0HD$PKS )T$@)L$0)D$ T$;$tH|$     I       A       I       I       1I      H   [A\A]A^A_]ffffff.     UAWAVAUATSHxIM   M   WA   A       A   I       AE<A} u't<A8  t0	t+Iu E11G &  tA8  t		   I  I(  HuI   H	E1F  11ff.     0tuHffffff.     HDPHHuH   H   C,   A   @ A  M  mS(LI   tXII$r0t$pJR )T$`)L$P)D$@9tH|$@   " D$@\Iu E1G 1) \I   I   Hr0Ht$0JR )T$ )L$)$9tH<$   C $HIM   A   DHx[A\A]A^A_]f     AWAVSH   IAG<A u&t;A8  t/	t*I7E1G k  tA8  t		F  M  I(  MtI@I   HE1  11ffffff.     9t
uHHDAHHuHC  H:  Mt"I   H4I+   HHNNN I   H8I+   HHmmmHA;       A  M  [I   tcI   Hr4I   rdt$pB4JDRT)T$`)L$P)D$@9tH|$@    D$@`I7E1EG 1 _I   Hr8I   HrhHt$0B8JHRX)T$ )L$)$9tH<$   	 $HIM   A   DH   [A^A_ffff.     PG tu   uw8HG(;psXE  H7G 1F 1ZfUAWAVAUATSH(LL$MHIIIH\$`LQ H1H|  LkL{HkIrAm  I      C    Lk(Lt$i =+  tz+ 4t
H DHC(pHH   L9  1G 1Lo IoH# HC01HHrEH{0ILHOFHHHHH{0T$ =%+  t"+ 4tH{(Hs0e+ L  H{0hC  I  tN  C    L  D  t  L  IL(  H|$    H3G 1j H~  I}H{0T$ =Z+  t"+ 4tH{(Hs0+ L
  H   MuH|$   M  I<$; HE@H
  MA~}HANML$     MC  AD$H;0  /  4  A3D$   Hu I$G 1 HuHH      I rNtu>C    L  D  t  L   I IrG    LA   C     MtWH3G 1
 HsHt&=+ HS  tHFG 1 H;Ht,AH{@H  H   H|$   Hu G 1|
   C    H|$H   HHk     M  AD$;0    4  A3D$      Hu H   M$BG 1	   H|$1    H|$ HE@H  H|$ }HHH MLME8HE(IP   Iw0H19~u.1 tgH9rh   M  AD$H;        A3D$   Hu I$G >  G 1	 4  AG8    1HtAOL3H AG8IG(P	  IO0AwH1tH97tCHH9r   Hy1f.     9wuAoL3/ tHH9r   HLAOLAG8   IW0HLDI|   t   AG<   I  A  Lt$t   H|$ H  H  JD(H(     E  I7IG 1 IwHt&=+ IW tIFG 1k
 I?Ht=I@L    rHtu3AG<   I  A  L      t$   rG    =   H|$ LE        tpHu IG 1 HuHt'=+ HU tHU FG 1	 H} Ht&=H}@Ht=1P  H>1H([A\A]A^A_]H|$HLE<   tH   uh   |$   H|$ H  H   JD( 5 UAVSHs8C<    Ls@H{@Htm<s8              WA    H(      HK0HSHDCLL- C u   tbTuO       H              H              K8HCHS0H4HLDt.PH 1$ K8HCHS0H4HL   DtII	LH)HSH9~H3HS@1H 1   I4HH9vD)   A.tuIC<   L    . t  L  IL(      r[tuFC<   L     t  L   I L(  +rG    L:t	C<    C<      [A^]fff.        O u41fff.     L HtHff.     USP   HG(DHE  LW0D   1D  H,ATAtD9  E\A
     D  7  HO   H12rt  D9rE1A   A  DD@E9sGHO0HHlKH\DfD  ;SuM D!3D!9   HD9rI   E9r   H71G 1:    1G 1w$    A A#L1'G AA E#D1G A   1D5$ ^AA E#D1G 1E$ <A A#L1I H A A#L1 H 1H 1# H[]f.     fUAWAVAUATSHL$II7Htu0dH =8H 18H\$s H 18CHtHH   L9vcH 7 dH 7

   p7HD$x   E1fffff.     EO,J   L9  -H 1,8EtgAD$C1t8Kt >tHl A;uA3| t9v(     9v;H 17fff.     |$ tiKC4           F]  $H LOtCD !  _H 6L  f.     :J 1DA7C4]H 117Ct mH 17	  D    t|     LOtCD !  _H E63         LOtCD !   wz$8H H 6~   LOtCD !E  h`H 5U  u+LOtCD !dV  O`H 5$fLOtA _H 16Ot3A !  :   UF  $H A  dH   fff.       tD  uK   dH      q  Be  $H iH   ut`oH     9  d   0jH     _H 4  p`H 4   eH ;    oH (    Y`H A4  jH   H  4H 4H 4iH   piH   0iH   LOtCD !a  g  `H 3,LOtCt      Uh  5        `H R3LOtCD !   J`H !3LOtCD    aH% $H @`H 2_LOtCD   % "`H 2-LOt   CD D`H 2LOtCD !   c`H T2LOtCD !   cU  $XH _`H 2    @rH      $  U  5        0qH }     hH j    $XH  hH N     qH ;    `hH )     nH   c     $ H nH   |_H 
1m  PdH        `H 0Zd7-H 0B   $  pH z    hH h     qH V     oH D  d  jH 1  `H W0   `H :0rH     rH   V  w`H 0Vg  oH   6  `H /W6<  0pH   X  `H /,  ppH g  9`H /
&`H ~/3`H o/,`H `/`H Q/`H B/`H 3/`H $/`H /_H /_H .tgH    gH   gH   `gH   fH   `fH    fH |  eH r  fH h  eH ^  `eH T  `H z.u`H f._H 1.H @."H 1..H ".9H .DH .RH -r]H -cjH -TvH -EH -6H -'pqH nu	pH bfz_H 1.W@nH KmH DmH =PmH 6 mH /lH (`lH !lH kH pkH  kH     +-A   !=   IucH -ff.     CtH 1~-KlCtH 1h-CDL9vH 1R-E K\CL   tH 1*-     
   ,CtH 1-E CLHL9vH [,f     
   +3   @H 1,;rH    1,fD  
   +AHD$D;`4H[A\A]A^A_]D  UAWAVATSHPEAIHED$8HEHD$0    T0 uD0 HPD$< fE fD$,ED$(   ffff.     T( uD( HPD$. fE&fD$$E"D$    ffff.     T  uD  HPD$& HE(HD$   @ T uD HPD$ fE8fD$HE0H$	   fff.      u HPD$
 Au
H 1 +AuNH|$Ht$@   -HHD$@8 tHt$H 1*%   =?  $=    uqc   oHt$5H 1*R  =_  = @  uFd   D=  = `  u1b   /=   t=   ul   -   =   us   ?   X)tr   -   B)tw   -   ,)ts   @tx   -   
) tr   -   (tw   -   (ts   tx   -   (tr   -   (tw   -   (tt   (tx   p(
-   d(Ht$(HT$ H$:H 1J)EtcH|$0Ht$@
   +HD$HHD$@8 tHt$0HH 1)H|$H(HA AVH 1H(LsK 1DL'Ht$0AVH 1(HyLsK 1H(E:=`
  t sH (

   'HP[A\A^A_]     UAWAVAUATSHHEDIAHn AwtH 1H$   H$   DIIDt$AEEDME9tHl$H]H9v3H 1H$   H$   L$LD$HH[A\A]A^A_]) HL$(H IL|$IvLH5)D$$E9tLt$$D 1$        DD$L$   Ht$(t`HEH9v]H AE9tHH9v5H 1H$   LDLD$ LHH[A\A]A^A_]&ILH$HT$(CH 1LDHL$&H$   HtdH 1&

   %$   Dl$$|H 1D&t*H 1Hl$(&@tsH %`sH @sH 
   t%`sH %E  E1fffff.     CltGLu<L;$   vYAH 1H\$0H )   )H H 1H&   CH 1%  f     AL$   I/G    H%t!H 1H%EDl$$L|$   K7J|=1
   5(Ht4ELA< tH 1H[%EDl$$L|$wI 1H 11H4%EDl$$L|$   )H H 1%ffffff.     CHD$(9sH$HW$Df&H 1$DIE9sL#HH[A\A]A^A_]fff.     UAWAVAUATSH(EEAA`H #sH #|$h tLl$ Dl$`uNH H T D$`D$D|$D$$H 1DAE$H([A\A]A^A_]uH H 1#r[H 1#A  TA      AF  $`H IH 1# FEw~E$ H RH H  A  tqA     {H 1_#    H ^A      H 1.# FE   H 1#|4H 1" ut=H 1"PA  u0H 1" dEn  (H 1" H 1D"EEHl$   EuH 1f"H 1X"E  E$xH H   H   H   H   H 1" E  E  H   H H 1!E FE  H 1! `H 1! EG  EE  uH 9  H 1f!    E  UE2  5Hl$ d  n    )  H   H 1! E   H 4H 1 E   $H H   H 1  Ei  Eg  H OH 1|  H 1c  Eu
H E   H 12    H 1!  cEhEwpHl$ $H H c  Hl$ $H  H M   H 1   EHl$   H   dEu
(H ^H 1Hl$ %   =     H 1h  H Hl$ f  H   iH H vHl$ 6  H   VHl$   H k  ,H a  8H W  FH M  TH C  6  H 0    H   ^H hjH ^vH TH JH @H 6H ,H "H H H H DH =H 6H /3H (?H !KH WH 'H cH oH 1EHl$ H 11E
v4H 1Y$H H DH =H 6H /H (H ! H H H H $H 1d0H 1DDRADt:H 1=DtFH 1&tPH 1tZH 1tfH 1 tpH 1@t|H 1tH 1tH 1tH 1tH 1itH 1RtH 1; tH 1$@tH 1tH 1   tH 1   tH 1  @ t.H 1    tEH 1   tJH 1t   t`H 1Z   txH 1@   tH 1&uEur[H 1	
   H([A\A]A^A_]uH WH 1NH =)H 65H /AH (MH !YH eH qH }H H 1UAWAVAUATSH  D$   D$   A$   IL$   Q $     D$   H$   ID H$   $   1ME1H 1DIH$  $   ;$   tH$   $  H tG 1D$  HH9voVH 1DMM)I$     '  U    $X	H $      H$      HAL!I!H   LCH$  LL$   ;$   tH$  l  H R$  ~"H 1$  )  H$   bH $  f.     F/D  $H H$   W)$  HAL!I!H   IBH$  L$   ;$   tH$  q H$  $     h       (     W)$   H$       HAL!I!H   LCH$   LL>$   ;$   tH$   ! H $   "H 1$     H$   bH   ffffff.     H$   H 1<$  H 1)H@L!H  JD"HH!D$  IL9LBI!L IIwLLSI$   ;$   t4   M      fff.     AT AT L9r1M  1fffff.     +L9sAt "ZH 1Wr
   FL9r  H$   W)$  H$       HAL!I!H   LCH$  HLLg$   ;$   tHo HL"    H$   
   H$   (H 1H$   (H 1  H$   W)$0  )$   )$  HAL!I!H00   LCH$  HLL$   ;$   tH3 H$   $  O  H$   $x      H$p      HAL!I!H   IBH$p  L4$   ;$   tH$p   H$p  L&    H$   W)$   HAL!I!H   IBH$   L$   ;$   tH$    H$   i  d  H$   W)$  $       HAL!I!H   IBH$  LJ$   ;$   tH$   H$  L    H$   
   $  ;$  sHL(H `  (H   H$   W)$  )$  )$  H$      HAL!I!H88   IBH$  L$   ;$   tH$   $  $  $  D$  D$  D$  D$  D$  $  $  $(  T$0$   T$(D$ \$Dd$D\$L$H$  >  $     Mg81f.     D$xID$DH$   H;$   v
G LL$   L)H$   W)$  )$p  )$`  )$P  $      HJH!H!HDD   HBH$P  LH(;$   tH$P     ; $p  H$   $t  H$   D$x  D$|  $  D$  $  $  $  D$  $(  L$H$   L$@D$   DT$8H$  HL$0Dl$(t$ D$|$D\$$H$P  H$`  H$   H$     H$   H;$   q  ID$x;$  L$   O$     H$   W)$  H$      HAL!I!H   IBH$  L$   ;$   tH$   $  $   H$  $   $     =  H$   W)$0  HAL!I!H   IBH$0  L.$   ;$   tH$0   H$0  $        tH @tH H$   $  H 1LLH!H	  I$  A9HCL$   $   ?"  Z   tH p$  ~"H 1$    bH E  H$   W)$  HAL!I!H   IBH$  L$   ;$   tH$   H$  L!    H$   W)$  )$p  )$`  )$P  )$@  HAL!I!HPP   IBH$@  L$   ;$   tH$@   H$@  $   $   $       H$   W)$  $      HAL!I!H   IBH$  L$   ;$   tH$   H$  L$0      H$   W)$P  )$@  H$`      HAL!I!H((   IBH$@  Lf$   ;$   tH$@   H$@  L    $      H$      HAL!I!H   IBH$  L$   ;$   tH$  '  yH $  ~"H 1:$  a	  H$   bH \	  $      H$      HAL!I!H   IBH$  LR$   ;$   tH$   @yH $  ~"H 1$    H$   bH 
  $      H$      HAL!I!H   IBH$  L$   ;$   tH$  C yH y
$  ~"H 1
$    H$   bH F
  $      H$      HAL!I!H   IBH$  L$   ;$   tH$   `yH 	$  ~"H 1T
$    H$   bH 	  H$   W)$  HAL!I!H   IBH$  Lp$   ;$   tH$   H$  $     
  $      H$      HAL!I!H   IBH$  L
$   ;$   tH$  j H $  "H 1=	$  2  H$   
   -  H$   W)$0  )$   )$  )$   H$@      HAL!I!HHH   IBH$   L5
$   ;$   tH$    H$   H$  HH L$   L$(  L$0  L$8  LH H$@  HH $(  l$0$   l$(\$ D$T$D\$L$H$    $@   U  MgH1ffffff.     $   ID$PH$   H;$   v
G 8LL$   L)H$   W)$  )$  )$  )$  )$  HJH!H!HPP   HBHT$xH$  L$   ;$   tH$     $   = H$  H$  L$  MI H$  HH H$  HH D$  D$   $(  l$H$   l$@D$   Dl$8H$  Hl$0D\$(DT$ |$\$t$$H$  H$  r  H$   H;$   0  Ld$x$   ;$@  L$   Y  H$   W)$   )$  )$   )$  H$0      HAL!I!HHH   IBH$  La$   ;$   tH$   H$      H$   W)$  H$      HAL!I!H   IBH$  L$   ;$   tH$  z H$  M    H$   W)$p  $      HAL!I!H   IBH$p  Ln$   ;$   tH$p  q H$p  $   ]    H$   W)$   HAL!I!H   IBH$   L$   ;$   tH$    H$       H$   W)$P  H$`      HAL!I!H   IBH$P  L$   ;$   tH$P   H$P  $   .    H$   $H      H$@      HAL!I!H   IBH$@  L$   ;$   tH$@  a H$@  Lq    
   BH$   IWJD&$  HH!9HCLH 1HH9L  t&1H9HrE tNHH9rHH$   
   $  ;$     HLk$H    H$   
   $  ;$     HL$H \H$   
   P$  ;$  sxHL%%H -H$   
   !$  ;$  sPHL$H 1MH$   bH [$  g'H 1&$H $H C%H %H 1 $  HtYIL;$   w[AD;$   L$   H$   H$   nMH$   LL9t G  G 1D<H  [A\A]A^A_]f.     UAWAVAUATSHMLD$HL$HAD|$hAutH X DLkDI8`tH A DL4IIH"H 1 L9u
   
tH  ErH 1H AD|$Xu$H 1Ht$i H 1Ht$X "H 1Ht$E H 1Ht$4 H 1L% \$xL9sH 

   H 1Hl$PHII9vH P

   \$pl$`$    tArGH 1D}I H 1D[ H 1m H 1D H   At H  H 1\Atw   -   EAtBJ G H r H 1G@t1 H = H 1 @tw   -   @tBJ G H Bm H 1D{ H 1tpt H 1tH 1t H 1zt H 1ft4 H 1H[A\A]A^A_]C`H H[A\A]A^A_]
   H[A\A]A^A_] UAWAVAUATSPDL$DIIII\$x`H S H 1L H 1LtH|$pLtwH 

   D$hu  H 1L!H 1Lr !H 1Da3!H 1DRT$P$   D|$@uLH9vAH A
   H 19vH i

   l$Ht$   @E!H 1[!H 1DA9vH !

   i!H 1DHH9vH 

   qD$   @t&w!H 1Qw$$	H $aH "H 1-  [H 1!H 1y!H 1   @t!H 1    t!H 1   t!H 1   t!H 1   t!H 1   t!H 1jt!H 1Ut"H 1@t"H 1+   w`H 1
   t$X0"H 1w stH R

   t$`>"H 1utH H[A\A]A^A_]
   H[A\A]A^A_]aH hvH YvH JvH ;pvH ,PvH 0vH aH vH uH p`H a`H RvH C`H 4uH %uH uH xpuH i@uH ZuH KD  UAVSAH0wH s"H 1;{u
   +
bH sL"H 19kvH q

   sX"H 1A   CtHKHH9v H@KHH9vH 

   sd"H 19kvH 

   usp"H 1fCKHH9vH [A^]
   [A^]:f.     UAWAVATSAAAHPwH s|"H 1{Pu
   
bH Ws"H 1D9cvwH 8

   s"H 1CKHDH9vpwH 

   s"H 1wD9cvwH 

   [s"H 1LCKHH9vpwH 

   (s"H 1D9cvwH y

   s"H 1CKHH9vpwH F

   s #H 1D9{ vH 

   s$#H 1C K$HDH9vH 

   hs('#H 1YD9{(vH 

   =s,:#H 1.A   C,tHk8Hk4C(HH9vH s

   s0M#H 1D9{0vH H

   s4`#H 1C0K4HH9vH 

   s8s#H 1D9{8vH 

   ms<#H 1^C8K<HH9vH 

   9s@#H 1*D9{@vH 

   sD#H 1C@KDHH9vH V

   sH#H 1D9{HvH +

   sL#H 1CHKLHH9vH [A\A^A_]
   [A\A^A_]mffff.     USPHwH s"H 1?{u
   /
bH sH 19kvH u

   sH 1CKHH9vH H[]:
   H[]f.     AVSPIH;uxH wH  s}"H 1{wbH 

   eS;SsId%H 1LK%H 1;s#H 1,s#H 1H[A^fD  AVSPIH3  t*  u:xH U_t u8`xH ?IxH 3=xH '1#  u0xH u yH $H 1s~"H 1u{wbH 

   YS;SsIe%H 1L?%H 1/s+$H 1 CH$H<$HFH 1H=$H 1Ct3(H 1
bH 7T$H 1Ct3(H 1
bH  H[A^     AVSPIH yH s~"H 1]{wbH 

   AS;SsIk$H 1LH[A^ $H 1H[A^ff.     AVSPIH@yH \s~"H 1{wbH =

   S;SsI$H 1LH[A^$H 1H[A^ff.     AVSPIH`yH s~"H 1]{wbH 

   AS;SsI$H 1LH[A^ %H 1H[A^ff.     AVSPIHyH \s~"H 1{wbH =

   S;SsI%%H 1LH[A^C%H 1H[A^ff.     UAWAVSPIIyH Aw|"H 1WAwbH 

   :AWA;WsHLc%H 1%H 1Aw%H 1A_A;_sbuh1%H 1AGt:    HA@s:J 1AG9rH[A^A_]%H 1k1%H 1yA t?fAs1   ffffff.     0   FAG9sr9w%H 1'Aw{$H 1H[A^A_]ffff.     AVSPIH3t'uyH P) zH Du zH 3&H 1s~"H 1{wbH 

   S;SsIe%H 1LH[A^i%H 1H[A^T@ AVSPIH@zH s}"H 1-{wbH 

   S;SsId%H 1L%H 1s#H 1H[A^UAWAVAUATSH  $  IL$  Iu AD$  A9$       Cw!$h
H   l     ^  %  1    O3  M9g  ffffff.     LL)H    L|
A7ILD;$  tLH)E1HM|
D0HI$  9$  tAu"D$  zH 0fffff.       D$  
OH    1nLADuzH f     5OH D   1D<D$  D)H!H  r  H$  HH  (1  L$  LyLHH[HH$  L$  E9D$  tH$  D D$  H$  H$  H$  H$  H$  H$x  H$  H$p  H$  H$h  H$  H$`  H$  H$X  H$  H$P  H$  H$H  H$  H$@  H$   H$8  H$  H$0  H$  H$(  H$  H$   H$   H$  H$(  H$  H$0  H$   H$8  H$  H$@  H$  H$H  L$P  L$X  L$`  L$h  H$p  L$x  L$  L$  L$  H$  H$  H$  H$  $  $   H$   H$   H$   H$   L$   L$   L$   L$   H$   L$   L$   L$   Ll$xHl$pH$  HD$hH$  HD$`H$   HD$XH$  HD$PH$  HD$HH$   HD$@H$(  HD$8H$0  HD$0H$8  HD$(H$@  HD$ H$H  HD$H$P  HD$H$X  HD$H$`  H$gOH 1H$  H$x  H$  L$p  L$h  L$  L$  Ay+H 15kK 1DubH LLD$  fr  DM<M9D$  .b  f     y+H 1$5kK 1DbH {LLD$  r  DM<M9ab  LL)H    L|
A7ILD;$  tLH)E1HM|
D(HID;$  tAFW$H 0H A(uuPH xH AB    H    H A   H    0H AL   PH p   02H 1DDD)H!H         H$  L<I   H  I4H 1DDD)H!H      H$h  LI    6H 1DVDD)H!H   AAO)$P  )$@  I   6H 1DDD)H!H0    0  H$p  L]I0    W)$0  )$   )$  )$   )$  )$  )$  )$  )$  )$  H$  LHIL$  D;$  tH$  Ds $  $  $  $  $  $x  $  $p  $  $h  $  $`  $  $X  $  $P  $  $H  $  $@  $  $8  $  $0  $  $(  $  $   $  $  $  $  $  $   $  $  $  $  $  $  $  $  $  $  $   $  $  $  $  $  $  $  D$  D$  ED$  $  $   D$$  D$(  D$,  D$0  $4  $8  $<  $  $  $  $  $   $   $   D$   D$   D$   D$   $   $   D$   ED$   D$   $  $   $  $   $  $   $  $   $  $   $  D$x$  D$p$  D$h$  D$`$   D$X$  D$P$  D$H$   D$@$(  D$8$0  D$0$8  D$($@  D$ $H  D$$P  D$$X  D$$`  $]2H 1$  $x  $  D$p  D$h    1  H$h  HPHLH2ID;$  tH$h  Ds $h  $  $p  $  $x  $  $  $x  $  $p  $  $h  $  $`  $  $X  $  $P  $  $H  $  $@  $  $8  $  $0  $  $(  $  $   $  $  D$  D$  D$  D$   D$  D$  D$  D$   $(  $0  $8  $@  $H  $P  $X  $`  $   $   $   $   $   $   $   $   DD$xDL$pDT$hD\$`Dd$XDl$PDt$HD|$@$  D$8$   D$0$(  D$($0  D$ $8  D$$@  D$$H  D$$P  $u4H $  $  $  $x  $p  $h  $`  $X  H$h  HH 5H 1wW)$P  )$@  H$@  LHID;$  tH$@  Dp $@  $D  $H  D$L  H6H 1$P  |6H 1A10  H$p  H`HLHBIL$  L$  D;$  tH$p  Dem H$  H$  H$  H$  H$  H$x  H$  H$p  H$  H$h  H$  H$`  H$  H$X  H$  H$P  H$  H$H  H$  H$@  H$  H$8  H$  H$0  H$  H$(  H$  H$   H$  H$  H$  H$  H$   H$   H$  H$  H$  H$  H$  H$  H$   H$  H$(  H$  H$0  H$  H$8  H$  H$@  H$  L$H  L$P  L$X  DL$`  H$h  L$p  L$x  D$  L$  H$  H$  $  H$p  H$x  H$  H$   $   H$   H$   L$   D$   L$   L$   H$   L$   AL$   L$   L$   H$  H$   H$  H$   H$  H$   H$  H$   H$  HD$xH$  HD$pH$  HD$hH$  HD$`H$   HD$XH$  HD$PH$  HD$HH$   HD$@H$(  HD$8H$0  HD$0H$8  HD$(H$@  HD$ H$H  HD$H$P  HD$H$X  HD$H$`  H$6H 1H$  H$x  H$  L$p  L$h  L$  L$  y+H 15kK 1DbH LLD$  c  DM<M9S  LL)H    L|
A7ILD;$  tLH)E1HM|
D(HID;$  tAFW$H  H A   H k  H \A     H E  PH 6A  H "  H A*!  H !  `H A   F  H F   H An  0H n   ~H A,  ~H   P}H A     }H m  @|H ^A   }H J   H ;A   H '  ~H A  ~H   0{H AE  |H E  CH 1D]DD)H!H@~  AAOAW A_0)$  )$  )$  )$  I@  DH 1DDD)H!H  V    H$  LJI    GH 1DDD)H!H;  AG$x  IH$p  I6  HH 1DiDD)H!H   $     H$  LI     IH 1DDD)H!H  S    H$  LnI  	  IH 1DDD)H!H8  A)$  I	  JH 1DDD)H!H        H$  LI   o  KH 1DLDD)H!H      H$x	  LI    LH 1DDD)H!H  IGH$p	  A)$`	  I  rGH 1DDD)H!H   AAO)$P  )$@  I   JH 1DpDD)H!H@  AAO)$p  )$`  I   NMH 1D'DD)H!HH  IG@H$P	  AAOAW A_0)$@	  )$0	  )$ 	  )$	  IH  W)$  )$  )$  )$  H$  LHI  1  L$  LLLHI  $x      H$p      H$p  LHI  W)$P  )$@  )$0  )$   )$  )$   )$  )$  )$  )$  H$`      H$  LH8I  1  L$  L)LLHI  W)$  H$  LHIj  W)$0  )$   )$  )$   )$  )$  )$  )$  )$  )$  )$  H$  LHoID;$  tH$  D2} H$  1  ;KH 1$  *   ~H   1  L$x	  LLLHID;$  tH$x	  D| $x	    &LH 18$|	     *  p}H '  W)$`	  H$p	      H$`	  LHlID;$  tH$`	  D/| H$`	    `|H $$d	    |H 
  W)$P  )$@  H$@  LHI  W)$  )$  )$p  )$`  H$`  LHI  W)$@	  )$0	  )$ 	  )$	  H$P	      H$	  LHgID;$  tH$	  D*{ H$	     P{H $	    {H     JH 1{$  +  P~H (  j  KH 1G$|	     O  }H L  K  |H $d	    |H h  
'  {H P$	    {H 6  _KH 1   H$  H$  L$  D;$  tH$  Dr H$  H$  H$  H$  H$  H$x  H$  H$p  H$  H$h  H$  H$`  H$  H$X  EL$  L$   L$  L$  H$  H$   L$(  L$0  L$8  H$@  H$H  H$P  H$X  H$`  HD$xHL$pHT$hHt$`H|$XLD$PLL$HLT$@H\$8Hl$0Ll$(Ld$ L|$Lt$EH$X  HD$H$`  H$3HH 1H$  H$x  H$  L$p  L$h     ILH 1  H$  H$	  UD;$  tH$  Dt $  $  DH 1$  AAAAAA$DH 1Z-EH 1N$  tuEEH REH x  8EH 1s  LH 1H$h	   )$  D;$  tH$  Dyv H$  H$  H IH 1)MH 1H$	   HP X0)$  )$  )$p  )$`  D;$  tH$`  DTv H$`  H$h  H$p  L$x  BJH 1(H$  H$  H$  L$  JH 1oHH KH 2$|	  tLH 1IHH -MH HH MH 1#_EH 1cEH 1$  
w($H gEH tEH EH EH 1X
   N$  AAAAAAD$<$EH 1$  	AA
AAAAD$<$EH 1$  D$  &FH 1$  $  D$  iFH 1Z$  $  $  FH 18aH H$  V  aH H$  V  aH pH$  V  aH YH$  V  aH BH$  V  aH +H$(  ~V  bH H$8  gV  bH H$H  PV  -bH H$X  iW  <bH H$h  RW  KbH H$x  ;W  ZbH H$  $W  ibH H$  W  xbH sH$  V  bH \H$  V  bH EH$  V  /aH .H$  V  >aH H$  V  MaH  H$  V  ]aH H$  lV  maH H$  UV  }aH H$(  >V  aH H$8  'V  aH H$H  V  bH vFH 1$X  H 1$X  H 1$X  H 1$X  H 1$X  H 1$X  H 1$X  H 1n$X  H 1Z$X  H 1F$X  H 12$X  H 1$X  H 1
$X  H 1$X  H 1$X  H 1$X  H 1
   FH 1$X  H 1$Y  H 1|$Z  H 1h$[  H 1T$\  H 1@$]  H 1,$^  H 1$_  H 1$`  H 1$a  H 1$b  H 1$c  H 1$d  H 1$e  H 1$f  H 1x$g  H 1d
   ZFH 1N1fff.     \X  H 1,HHu
   FH 11ff.     X  H 1HH0u
   FH 11f.     X  H 1HHu
   FH 11ff.     X  H 1lHHPu
   X$  FH 1EKH 14H$   HP X0)$  )$  )$  )$  L$  L$  D;$  tH$  Df $  $  $  $  $  D$  D$  D$  D$  D$  D$  D$  $  $  $  $  DD$  $  D$PDt$HAT$@\$8l$0|$(Dl$ Dd$D|$D\$D$CH 1$  $  L$  L$  ]KH 1  H$  H$	  ?D;$  tH$  Dg $  $  DH 1$  AAAAAA$DH 1D-EH 18$  tL$  u-L$  EEH /L$  REH 1L$  &L$  u8EH 1_EH 1cEH 1$  
w($8H gEH tEH EH EH 1
   w$  AAAAAAD$<$EH 1$$  	AA
AAAAD$<$EH 1$  D$  &FH 1$  $  D$  iFH 1$  $  $  FH 1aaH H$  M  aH H$  M  aH H$  L  aH H$  L  aH kH$  L  aH TH$  L  bH =H$  L  bH &H$  yL  -bH H$(  M  <bH H$8  {M  KbH H$H  dM  ZbH H$X  MM  ibH H$h  6M  xbH H$x  M  bH H$  M  bH nH$  L  bH WE1@ FH 1   Lfff.     3H 1LHu
   IIu$  FH 1D$  L$  LH 1bH$h	  HA$x  HH$p  D;$  tH$p  De $p  $t  $x  AGH 1yyMH 1H$	   H)$P  )$@  D;$  tH$@  D|g $@  $D  $H  D$L  GH 1$P  $T  $X  D$\  GH 1jy+H 1Y5kK 1KbH LL$  =F  M<M96  LL)H    L|
A7ILD;$  tLH)1HM|	HID;$  t`zH +u {H MH 1DD)H!HDrDAG@$ 	  AAOAW A_0)$  )$  )$  )$  IDDW)$  )$  )$  )$  $ 	      H$  LHIL$  D;$  tH$  Dm $  $  $  $  $  $x  D$  D$  D$  D$  DD$  D$  D$  $  $  $  $  D$  $  $ 	  D$XL$PDl$HT$@\$8l$0|$(Dd$ D|$Dt$AD\$D$)NH 1$  $x  $  L$  L$  M9K4  D;$     fLL)H    L|
A7ILLH)1HL|	HH}QH 1x5kK 1j`zH HL$  \C  L| M9r3  ffff.     LL)H    L|
A7ILLH)1HL|	HH}QH 15kK 1`zH DHL$  B  L| M9r*3  L$  L$  Ay+H 15kK 1D}bH LLD$  nB  DM<M92  LL)H    L|
A7ILD;$  tLH)E1HM|
D(HID;$  tAuH \Adu8H L;9H 7A  H #  y0H 1DDD)H!H  r  H$@  LI  1  H$@  IL$  D;$  tH$@  Dg H$@  H$x  H$H  H$p  H$  HH$  H$P  H$h  HH$X  H$`  HH$`  H$X  H$8  H$h  H$P  H$(  H$p  H$H  H$   H$x  H$@  HH$  H$0  H$   H$  H$  H$  H$  H$  HH$  H$  H$  H$  L$  L$  L$  L$  L$  M$  $  H$   H$   II HH L$8  I L$(  I L$   I HH H$   H H$  H H H H H$8  I I I $  $   D$   D$   D$   H$  $   D$   H$  $   H$8  $   H$  $   $   H$  $   D$  $   H$  L$xT$pH$  D$ht$`H$0  L$X|$PH$@  L$HDD$@H$H  D$8DL$0H$P  D$(D\$ H$X  D$\$H$`  D$D<$0H 1H$  H$p  H$x  L$  L$h  iY/H 1D	DD)H!HLrFAG<$|  AAOAW A_0)$p  )$`  )$P  )$@  IL.W$|  )$p  )$`  )$P  )$@  IL$  L$  D;$  tH$@  Db $@  $  $D  $  $H  $x  $L  $p  $P  $h  D$T  D$X  ED$\  D$`  D$d  D$h  $l  D$p  $t  $x  $|  $  $  $  D$pL$hT$`t$Xl$P|$HDD$@\$8Dl$0Dd$(D|$ Dt$ED\$DT$$h  $/H E11$  $x  $  D$p  ~1&Ay+H 15kK 1D	bH oLLD$  ;  DM<M9U,  LL)H    L|
A7ILD;$  tLH)E1HM|
D(HID;$  tAt!u?H Au[H ^`H A   H     H A  PH   *H 1DDD)H!Hp   AG`)$@  AGP)$0  AG@)$   AAOAW A_0)$  )$   )$  )$  Ip   2+H 1DyDD)H!H  A$  I  W)$@  )$0  )$   )$  )$   )$  )$  H$  LHID;$  tH$  DS= $  $  D$  *H 11$  $  D$  *H    1$  $  D$   *H    1q$  $  D$  *H    1J$  $  D$  *H    1#$  $   D$$  *H    1$(  $,  D$0  *H    1$4  $8  D$<  *H    1$@  $D  $L  +H b$      H$  LHID;$  tH$  D< $  g+H 1AYW*H 1D-DD)H!HHrEIG@H$  AAOAW A_0)$  )$p  )$`  )$P  IHEW)$  )$p  )$`  )$P  H$      H$P  LHID;$  tH$P  DE: *H 1i$P  *H 1V$T  *H 1C$X  *H 10$\  *H 1$`  *H 1
$d  *H 1$h  *H 1$l  *H 1
   *H 1$p  *H 1$t  *H 1$x  *H 1$|  *H 1o$  *H 1\$  *H 1I$  *H 16$  *H 1#
   $  $  *H y+H 15kK 1DbH FLLD$  5  DM<M9,&  LL)H    L|
A7ILD;$  tLH)E1HM|
D(HID;$  tAFW$
H H A"ux H {pH A      H ~   H oA   @H [   H LA   H 8   L9H 1DDD)H!H   	     H$  LI   M  %;H 1DiDD)H!H   $     H$  LI   +  @H 1DDD)H!H=  A$  IK  @H 1DDD)H!H@V  AAOAW A_0)$  )$  )$p  )$`  I@S  W)$   )$  )$   )$  )$  )$  )$  )$  H$0      H$  LHIL$  L$  D;$  tH$  D; $  $  $  $  $  $x  $  $p  $  $h  $  $`  $  $X  $  $P  $  $H  $  $@  $  $8  $  $0  $  $(  $  $   $  $  $  $  $  $   $  $  $  $  $  $  D$   D$  ED$  $  $  D$  D$  D$  D$   $$  $(  $,  $0  $4  $   $   $   $   $   D$   D$   D$   D$   $   $   D$   ED$   Dl$x$  D$p$  D$h$  D$`$   D$X$  D$P$  D$H$   D$@$(  D$8$0  D$0$8  D$($@  D$ $H  D$$P  D$$X  D$$`  $~9H 1$  $x  $  D$p  D$h  ?L$  L$  p1   L$  LLLHIL$  D;$  tH$  D9 H$  H$  H$  H$   H$  HH$  H$  H$  H$x  H$  H$  H$p  H$  H$  H$h  H$  H$  H$`  H$  H$  H$X  H$  H$  H$P  H$  H$  H$H  H$  H$  H$@  H$   H$  H$8  H$  H$  H$0  H$  H$  H$(  H$  H$  H$   H$   H$  H$  H$(  H$  H$  H$0  H$  H$   H$8  H$  H$  H$@  H$x  H$  H$H  H$p  H$  H$P  H$h  H$  H$X  H$`  H$  H$`  H$X  H$  H$h  H$P  H$  H$p  H$H  H$  H$x  H$@  H$  H$  H$8  H$  H$  H$0  H$  H$  H$(  H$  H$  H$   H$x  H$  H$  H$p  H$  H$  H$h  H$  H$  H$`  H$  H$   H$P  H$  H$  H$  H$  H$  H$  H$  H$  HH$  H$  H$  H$0  H$  H$  H$(  H$  H$  HH$  H$  H$  H$   H$  H$  H$  H$   H$  H$  H$  H$  H$X  H$  H$  H$H  H$  H$  H$@  H$   H$  H$8  H$(  H$  H$p  H$0  H$  H$`  H$8  H$  H$P  H$@  H$x  HH$H  H$h  H$@  H$P  H$X  HH$X  H$H  H$(  H$`  H$8  H$  H$h  H$0  H$  H$p  H$   H$   H$x  H$  H$  H$  H$  H$  H$  H$  H$  H$  H$  H$  H$  H$  HH$   H$   H$x   H$p   H$h   H$`   H$X   H$P   H$H   H$@   H$8   H$0   H$(   H$    H$   H$   H$    H$   H$   H$   H$   H$   H$   H$   H$   H$   H$   H$   H$   H$x   H$p   H$h   H$`   H$P   H$   H$   H$   H$0   H$(   H$   H$    H$   H$   H$X   H$H   H$@   H$8   L$p  I L$`  I L$P  I II H$@  H II L$(  I L$  I L$  I H$   H H$  H H$  H H$  H H$  H H $  H$  $  $  H$  $  $  H$  $  $  H$  $x  $p  H$  $h  $`  H$   $X  D$P  H$0  $H  D$@  H$8  $8  D$0  H$H  $(  D$   H$X  $  $  H$h  $  D$   H$x  $  D$  H$  $  D$  H$  $  D$  H$  $  H$8  $  H$  $  H$@  $  H$  $  H$H  $  H$  $  H$X  $  H$  $  H$  $  H$  $x  H$  $p  H$  $h  H$   $`  H$  $X  H$  $P  H$  $H  H$(  $@  H$  $8  H$0  $0  H$  $(  H$  $   H$  $  H$  $  H$  $  H$  $   H$  $  H$P  $  H$   $  H$`  $  H$  $  H$h  $  H$  $  H$p  $  H$  $  H$x  $  H$   $  H$  $  H$(  $  H$  $  H$0  $  H$  $  H$8  $x  H$  $p  H$@  $h  H$  $`  H$H  $X  H$  $P  H$P  $H  H$  $@  H$X  $8  H$  $0  H$`  $(  H$  $   H$h  $  H$  $  H$p  $  H$  $   H$x  $   H$  $   H$  $   H$   $   H$  $   H$  $   H$  $   H$  $   H$  $   H$   $   H$  $   H$(  $   H$  $   H$0  $   H$  $   H$8  $   H$  D$xH$@  D$pH$  D$hH$H  D$`H$  D$XH$P  D$PH$  D$HH$X  D$@H$  D$8H$`  D$0H$  D$(H$h  D$ H$  D$H$p  D$H$  D$H$x  $W;H 1H$  H$   H$  L$  L$  A$  AAAAAA$?H 13@H 1$    $pH B@H   $      H$  LH+ID;$  tH$  Dn1 $  @H 1{W)$  )$  )$p  )$`  H$`  LHID;$  tH$`  D1 $`  AH 11$d  5AH 1$d      j  x                ~  >  	      $
H eAH        AH 	       AH    N@H W@H b@H 1%D$  DDDEAAAm@H 1L$  D$  L$    uUAH o  uFAH `   u7AH Qu+AH E?uAH 9uAH -uAH !AH 1aqAH ~AH AH 1E$d  BH 1/$`  AH    1$l  5AH 1$l      ^  h  o  v   }~   >            $0H eAH      uvAH      udAH ~  uUAH o  uFAH `   u7AH Qu+AH E?uAH 9uAH -uAH !AH 1qAH ~AH AH 1$l  BH 1$p  AAAAAAD$<$
BH 1oy+H 1^5kK 1PbH LL$  B  M<M9  LL)H    L|
A7ILD;$  tLH)1HM|	HID;$  t`PH 0buH !MBH 1DD)H!H  r  H$  LI  (1  H$  HHLHIL$  $  A9EtH$  D/ bH 11fffff.     t w  BH 1r
   rbH .1fff.     1fffff.     t wT  BH 1r
   qr$  H$  HH D$  BH 1>$  $  BH  $  $  BH $   $  BH $  CH $  $   $(  CH $0  $8  $@  0CH H$H  HH $P  CCH 1_$T  $X  iCH 1EEL$  	$@  $  $H  $  $P  $  $X  $x  $`  $p  $h  $h  $p  $`  $x  $X  $  $P  $  $H  $  $@  $  $8  $  $0  $  $(  $  $   $  $  D$  D$  D$  D$  D$  D$  D$  D$  $   $  $  $  $   $(  $0  $8  $   $   $   $   $   $   $   $   DD$xDL$pDT$hD\$`Dd$XDl$PDt$HD|$@$  D$8$   D$0$(  D$($0  D$ $8  D$$@  D$$H  D$$P  $(.H $  $  $  $x  $p  $h  $`  $X  2Ay+H 1$5kK 1DbH {LLD$    DM<M9a  LL)H    L|
A7ILD;$  tLH)E1HM|
D(HID;$  tAt!u?H Au[H ^@H A@   pH     H A$  0H   e-H 1DDD)H!H,rwAAOAW$\  )$P  )$@  I,|-H 1DDD)H!H         H$@  LI     W$\  )$P  )$@  H$@  LHID;$  tH$@  D6 $@  $D  $H  D$L  D$P  -H 1W)$0  )$   )$  )$   )$  )$  )$  )$  )$  )$  )$  )$  )$p  )$`  )$P  )$@  H$@  LHID;$  'H$@  DL6 +H 1D8DD)H!H   r   H$@  LI   aW)$  )$  )$  )$  )$  )$p  )$`  )$P  )$@  H$@  LH%IL$  L$  D;$  tH$@  D3 $@  $  $D  $  $H  $x  $L  $p  $P  $h  $T  $`  $X  $X  $\  $P  $`  $H  $d  $@  $h  $8  $l  $0  $p  $(  $t  $   $x  $  $|  $  $  $   $  $  $  $  $  $  $  $  D$  D$  ED$  $  $  D$  D$  D$  D$  $  $  $  $  $  $   $   $   $   $   D$   D$   D$   D$   $   $   D$   ED$   D$   $  D$x$  D$p$  D$h$  D$`$   D$X$  D$P$  D$H$   D$@$(  D$8$0  D$0$8  D$($@  D$ $H  D$$P  D$$X  D$$`  $+H 1$  $x  $  D$p  D$h  L$  L$  H  [A\A]A^A_] SHH s~"H 1S{(u
   C
bH s"&H 1(s8&H 1sJ&H 1
s\&H 1sn&H 1s&H 1s &H 1s$&H 1[fffff.     SHH s~"H 1{Hu
   
bH Hs&H 1gHs&H 1WHs&H 1GHs &H 17Hs('H 1'Hs0'H 1Hs83'H 1Hs@G'H 1[fD  USPHH Ns"H 1{u
   
bH #sH 19kvH 

   s['H 1zCKHH9vH H[]
   H[]If     SHH s"H 1#{u
   
bH wsg'H 1[    UAWAVAUATSHhH H Es"H 1{u
   
bH CD$dS	s
DCDKDSD[DsD{DcDk{kKC[\$PD$HL$@l$8|$0Dl$(Dd$ D|$Dt$D\$D$x'H 1t$dHh[A\A]A^A_]fff.     USPH3%u'H R8Fw$$XH H 7uH &'H 1s"H 1{u
   
bH s'H 1n9kvH 

   Ss'H 1DCKHH9vH H[]
   H[]H z]PH kN H \?    AVSPIH H <s~"H 1{wbH 

   ~S;SsI(H 1LH[A^(H 1H[A^kff.     USPH H ~s~"H 1?{wbH ~

   #~s)H 19kvH u~

   }s )H 1~CKHH9vH @~

   }s1)H 1H[]~ffffff.     USPHPH }s~"H 1~{wbH }

   c}s)H 1T~9kvH }

   9}s )H 1*~CKHH9vH }

   }s1)H 1}sC)H 1H[]}UAWAVSPHIH 9}Av"H 1}A~wbH }

   |AvlK 1}HAnE1<AU)H 1DHe}HcHH}HHH)ffff.     ~"; u    { H[u~AvD9uH[A^A_]h)H 1DH[A^A_]|ffff.     UAVSAH;"uH H 0|s|"H 1|{/wbH |

   {s)H 1|D9svH {

   j{s)H 1[|CKHDH9vH {

   4{s)H 1%|D9svH {

   	{s)H 1{CKHH9vH R{

   zs)H 1{D9svH '{

   zs)H 1{CKHH9vH z

   xzs *H 1i{D9s vH z

   Mzs$*H 1>{C K$HH9vH z

   zs(1*H 1{D9s(vH kz

   ys,D*H 1zC(K,HH9vH [A^]4z
   [A^]yfD  SH30t%u@H z)H y$upH y'H 1kzs"H 1\z{u
   Ly
bH yC   t(H 1z'H 1zCt   t)(H 1[ybH [Py(H 1[y SHH 2ys"H 1y{u
   x
bH yLKLH(LHH  LHH  MI
I  I  t=(H 1[LyMta(H 1[:yHt(H 1[(y(H 1[yff.     SHH rxs"H 1x{wbH Sx

   wHs(H 1xHs(H 1[xfD  UAWAVAUATSHxDL$DD$L$$l$ I AM  I,ME1ffff.     IHD$pD;l$$t!H|$pD4 D$tfffff.     H tG 1DxD$tLH9voVH 1DwLL)HD$p*       y  f        H   |$P  W)D$PD$`    HAH!H!H   HCH|$PLxD;l$$tH|$PD t$X;t$T  LT$\1H 12w  ffff.        u|$    f.     W)D$0HD$@    HAH!H!H   HCH|$0L6xD;l$$tH|$0DB t$8;t$4sL|$uCHumH 1xvD$p   =     =     AH    D$@T$DDDAADT$<$H 1v|$    t$<H 1uD$<HD$(H|$(uHFH 1Hu   t5 uE-H O|$puH tH IH 1DuOH &
H =#  uTH uH jH 1kuH 1D\ufff.     D$tHt1II9w8AD;t$ MLL9t G tG 1DuHx[A\A]A^A_]     UAWAVAUATSPAHID)H    EL9s/H I1LH?uLLH!vHAIL ILLLu  E  AOHA1H   H!  HiHHH1HtHH   AoAoFfpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbAAV   HJ  It0HHH) oVoFfpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbNVoVofpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbNH@HHH9   AGV))tt1ttAAHAAHAAHr;IDD)fD  PPPPPPHHuEtT1fffff.     1fffff.     +D9sA4"ZH 1fqr
   UpD9rLH[A\A]A^A_]&pfD  SHV_H 1 q3H 1qsH 1qsH 1psH 1psH 1psH 1psH 1psH 1psH 1ps	H 1p
   woh_H 1kps
H 1[psH 1KpsH 1;psH 1+psH 1psH 1p
   [ oSHF_H 1o3H 1osH 1osH 1osH 1osH 1osH 1osH 1osH 1qosH 1aos	H 1Qos
H 1AosH 11osH 1!osH 1osH 1osH 1n
   [mfD  UAWAVAUATSH(  MD$   L$\A\$|ID$`   9D$l$       5  Lt$PDH$   M,L$   1H$   L1H$   1H$   1MHAfff.     HE H$   D;$   tH$   D $$  H tG 1m$$  HL9voVH 1mLH)H$   $        IW)$   )$   )$   )$   )$   HAH!H!HPP   HCH$   HHnD;$   Q  HD L  fD  W)$  )$p  )$`  )$P  H$      HAH!H!HHH   HCH$P  HEnD;$   tH$P  D $T  D$  LHHH9v5QH 1~l$T  HHHIID$  H$   AJ    H4H$    H$   $  D)HH<HH1l$     H\$`EH]HHl$p1    MI)L$   HAL!I!HPP   LCH$   HL#mD;$   t   H$   D H$   (HKPH;$     LHH$  H$   H$   D$<  L $8  L$;$  2H$   2     W)$   )$  )$  H$      HAH!H!H88   HCH$  H$lD;$   tH$  D Hl$p$  $  Hk8H9v4QH 1`j$  HHHHH$  H$   H    H4H$   w H$   $  )HH<HH1}j$   +  H$   H\$`HD$pLh81AD   LHL)H$   HAH!H!HDICH$  LHkD;$   t   H$  D H$   (IMDH;$      IHH$  H$   H$  D$  L $  L$;$  4H$   MLrL$   L$   `H$   L$   L$   E9H$   L$   Hl$p*H$   H$   H$   L$   Hl$pH\$`$$  Ht5HL9w;;\$|!-DL1H$   1H$   L!G 1"hHLLt$PD$`  D|$\H9t
 G kg$    t  $      QH 1gD9$   v`H .g    H g$   $   $  D$8$  D$0H$  HD$($x  D$ H$p  HD$H$h  HD$Dl$L4$H$   H$   DD$lE  $       RH 1gD9$   v`H tf    H ef$   $   $  D$8$  D$0H$  HD$($x  D$ H$p  HD$H$h  HD$Dl$L4$H$   H$   DD$lE	  H$      H$   H$       K    HS(RH 1H2fD9k$vH e   ffff.      H ves {$$  D$8$  D$0H$  HD$($x  D$ H$p  HD$H$h  HD$Dl$L4$H$   H$   DD$lE"   H(6H(  [A\A]A^A_]@ UAWAVAUATSHXEDL$@HT$0AY D$DHD$HE  H$   D$@H$   H$    L$HD$H1HL$D$(    D$,    D$$    E1HHD$8jt$P%   =       At  t$P%   =   ^  |$, t[H 1dF  z[H 5  ffff.     AD$HL$8L,fI$   I9
  DHL$HHH$   HH\$Pt   H|$PT$D H\$PAII yEA  t<$        [H 1AQ@ $    uxHH8HH9II;AAHH<A D$|\H 1ADncE9	  AuL%   =   Dl$$    A   A  LA   `AF   $H A  Dl$$,A   +  AFa  $(H A  uZA    =  A   u=D%   =   t AFw%$H A   A   uFH 1~b"ZH 1nbD$Wt[H [H 1TbD$TAut,	t'|$(t v!1X[H 1bd     t*[H $H 18[H <  &[H 1aD$Wt13[H   1.[H   A   u:%   =   tAFw#$H %   =   uFH 1a "ZH 1qaD$S@t[H [H 1WaHD$PAut,	t'|$(t v!1X[H 1a     t*[H $H 18[H m  &[H 1`D$S t13[H N  1.[H B  1@[H 1H[H 1`D$Wtb[H 1`t$TD\@  \H 1`L$T|$ u ;$       \H 1L`K  \H 1;`t$TD?  \H 1`AuD$T   !=   tAuDD$T   !=   2  t$PM\H   H$   H   H@H   A     A   +  At
A  D$T   !=     t$P\H k  A      AX  @  1@[H    1H[H    A   sA    A  2  X  HH$   8;$   v
\H   H$   R^  A    A       A   $  A  tA  H  H =  1P[H 1~^a[H 1r^t$SD0>  t$Ti[H 1P^EtBAuHD$tA   HD$@   t$P [H    AtAut$P%   =   tFAt.A  9  A   f  AAt$P%   =   ud z[H PAtA   t	A  uHD$w \  HL$rAu HD$	ut$P [H 1A]At&A  @A   EAF  $H D$P      A  t  A   x  D$Pw     A  AE  0  A  LH[H 1\   A         A   1X[H    1#A  tA  tA  u=w1P[H [1X[H    1H[H 1[   9Au+D$T   !=   ut$P|$,    2\H    t$T%   Au=   u5t$PG\H    A  u=   u \\H 1p[    _EH 1Y[D$T !;D$@vbH Z@t$HHHL$0H4HTm\H 1[bH zZM\H 1ZAtA   t	A  uD$T   !   =   t1L$,AuD$T   !   =   t1L$(   D$Pro*D$P      uWD$P      tCAuD$P1	wl  r `1Au&D$P1wB   HD$AtA   t	A  uD$P   !D$,   =   tD$,    t$$AuD$P   !   =   t1L$(
   XE9(HX[A\A]A^A_]f     UAWAVAUATSHD$   $   D$   Ll$x\$XLt$PXRH 1?YEtH H XM  Iffff.     A6Et;t$pv2xRH Pff.     AV7SH 1X   ff.     HL$`HtHk4	Hk8HL$h9vRH 1XH$   RH 1HXAvD9vRH Fff.     MtHvIL IDHHH$   HHHD	9vSH 1.XLMED H$   FH 1HXAt
   V
bH `WEMD$   fIH[A\A]A^A_]D  UAWAVAUATSPEAIAHASH 1WE(  H01ff.     ?&H 1rWEutD9wLSH 1VW@ D9v\SH SH 18WuSH 1)WuSH 1WuSH 1WuSH 1VuTH 1Vu'TH 1Vu=TH 1VuSTH 1VUiTH 1VUTH 1VuTH 1Vu TH 1xVH4A9H[A\A]A^A_]f.     UAWAVAUATSPEAIAHASH 1*VE)  H01ff.     ?&H 1VEutD9wLSH 1U@ D9v\SH SH 1UuSH 1UuSH 1UuSH 1UuSH 1UuTH 1}Uu'TH 1nUu=TH 1_UuSTH 1PUUiTH 1;UUTH 1&UHu TH 1UuTH 1UH8A9H[A\A]A^A_]f     UAWAVAUATSH(LEDt$ HL$HH|$TH 1ATEy  D|$$DHD$DH$E1f     HtIk4HHLHT    Ik8Ht$HHLHTD*D10$    t;t$xv!UH f.     ;UH 1TfHt$p-UH 1SD;t$$vIUH 1DDS  K.H;D$vUH fffff.     UH 1DDSEn  D;t$$c  HD$N$AH$B0A9DFAzf.     $0H PH R  0H R  cH R   cH R   H R   H R   ffffff.     A4$ !;t$hvUH N     $    tHtH@HD EVH 1RAt$`HHD$`;L$xvVH 1R!HL$p@VH 1H}Rffff.     At$$    t:J OVH 1DRIA7ID;|$ H([A\A]A^A_]f.     UAWAVAUATSH  LL$XDD$`L$4Al$HH\$P   DHD$hHHT$@E1HH\$PE111HD$81HD$HAffffff.     HE H$  D;t$`tIH$  DZ $  IH tG 1GQ$  IL;d$hvoVH 1&QHD$PH)HD$h$    Ld$ H\$(W)$   )$   )$   )$   H$       HH!HHH   CH$   HH$RD;t$`tH$   D $   D$   KHHH9v1YVH 1Ht$(]PD$   A)LI&D$   HD$8ALHL I$   D)HLH1P$    <  EH]HHl$E1     HD$PH)HD$hHJH!HjH!HPP   HCH|$pHH#QD;l$`t   H|$pD HD$HB0HKDH;L$@  HHH$   AD$pADH$   IL H$   IL($   AL0$   AL4$   AL8AD;$   HD$HDC  f'  Ld$ W)$p  )$`  )$P  H$      HH!H88   CAH$P  HLPD;t$`tH$P  Dw Hl$$T  $  HkDLH9v,YVH 1JN$T  D)HH&$  HD$8HHLv I$  )HLH1N$   M  Hl$8H\$(HD$L`81 HD$PL)HD$hHJH!HZH!HDD   HCH$  LHOD;t$`t   H$  D$ HD$H(IL$DLH9   IIHH$  A$  AD$,  IL $(  IL($D  AL0$H  AL4$@  AL8;$  HD$HHD$HHD$8HD$8Hl$H\$(5@ LZLd$8HT$@DHD$HLd$8HT$@E+HD$8Hl$Ld$ L$HD$HHD$8HD$8fD  Hl$H\$(Ld$ $  Ht(HH9w4;\$&DH1HD$8E1G 1HLHHH9t
 G wKHD$8  L$4%   D$PH$  H$  H$   T$@L$41    HL$HHHI4/AL/8u#AD/4D$huGIT/VH 1uK@     L$4L$htL$4L$htD$4D$h  ID/ L$h1HIIT/VH 1DKA\/0$  9v
+WH  B39vWH 1J|$P tWH fffff.     WH 1J$    tH\$`*cH Jf     H\$`
   IEX  Ml/(1E1fffff.     HD$`(;$  +  DIu |$P tWH 1AJffffff.      ZH 1$JHD$X4   @t"   u*cH pI   ff.     cH VI      u$cH >I   XH 1I$    t5HD$X;$  
L$@tIH$  HtH@H
   tH2HH$  8;$  sH$  HsLJ HfDd$hD9HL$HHHD$89kH  [A\A]A^A_]f     UAWAVAUATSH   ELL$PT$ADl$,I \$<W)$   )$   )$   )$   )$   1HD$H1HD$@$H    Dt$D$Hl$EM  l$Hl$ I/HD$0D$1HD$XME11HD$@1HD$H   fff.     IL;t$02  AE9\$<rv!    t$taG 1G  HAH!H!HPP   HCH$   HL/It$<;t$PtHM DD${  IH$   ;\$PtH$   ` $       H tG 1DIG$   HL$XHHL$XH9voVH 1DGLL)H$   
*     r    ffff.      t	W)D$`HD$p    HAH!H!H   HCH|$`LH;\$PtH|$`& Ml$h;l$dXH s%LHH$   H$   Y# HHEHL|$HAoH4    H|$@ HD$@DHHl$HMDl$,Hl$ $   HG 1DEDt$D$Hl$MD$H  AuD$IM9t
 G ,E#XH 1l$EpH EH\$Dl$   D$@  A1   HH$(  HHHD	D9v[XH 1QE   EEH$8  D BK 1H+EAt$AHD$HA9sHD$@J4}XH 1E

   CEED$@  q    OXH 1DEtDAt>$   H;$0  s+H$   HH@HHD"fD  
   vCHA9uH   [A\A]A^A_]fff.     UAWAVATSAI1XH 14DEK    fD  HH   H yCDL1H1fff.     Hu HcHH@x)DXH 1HCD9"  E1Ht_fff.     ADLH11HE HcHHx)DXH 1aCD9   ADH9rD9rh    $`H }cH !ucH jcH \cH QcH CcH ;cH 0cH f     LI11@ HA4$HcHI@xA)AXH 1HBE9r[A\A^A_]f     UAVSAHXH 1hBH A   HfsSYH 1=BE3tFvJ 1!BFffffff.     $H \K "YH &YH 7YH 3YH      1A
   @Hs[A^]fffff.     UAWAVAUATSPEIIA   A   1fD  Au*LEtDYH 1dANYH 1VAfD  9s6f.     AD t/   H9rfD  
   @9rH[A\A]A^A_]AVSPAIcqDH DX@tA\u2ZH 1H[A^@AFv%[H 1DH[A^@DH[A^?$H [H [H  [H ZH [H [H 	[H D  UAWAVAUATSHDL$EH$H|$H A  d$   E1fE|$u6H$I4|$ tDYH 1?NYH 1?ffff.     E9BD= fA~uD$     D$AJ 1D?D%  =  uA  u+cH T@ D$ZZH j?=     A  ucH  A  @ tH H ff.     >AA9H[A\A]A^A_]ffffff.     UAWAVAUATSHDL$DH$AH|$ D$EE   d$   E1fff.     E|$u6H$I4|$ tDYH 1>NYH 1}>ffff.     LH9l$B#fI~D<t? AADD   AE9rH[A\A]A^A_]@ UAVSHAD$ZH 1=AD    uAD=  u%u!cH ?ZH D$H[A^]==  uucH    tH H H[A^]<ffff.     UAWAVAUATSHEEHL$H|$Y A   d$   E1 EAu7HD$It |$ tDYH 1
=NYH 1<fff.     LHLHLHE9Bt- T L DD= t	A?H 1<AA9rH[A\A]A^A_] UAWAVAUATSH  LL$8DD$dAl$H|$@p AD|$D1HD$HA      ELt$PH\$XJ3HD$h1E1E11HD$Hfffff.     HH$  D;|$dtH$  D $  	D  H tG 1;$  IM9voVH 1;HT$XH)L$  `  Hl$ W)$   )$   )$   )$   H$       HAH!H!HHH   HCH$   H<D;|$dtH$   Di Ld$$    g  HkHH\$E1f.     HEPH;D$hv
G K:H\$XH)HD$PHW)$   )$   )$   )$   )D$pHAH!H!HPP   HCH|$pHH;D;|$dt   H|$pDn $      @     EuLHH|$H EIIH$   CD= (D$pCD=H$   KD= $   CD=($   HL$8HKL=0;$  v]YH 1HT$p9CD=8    LfH$   H$  H9v.UYH 1H$   HT$p9$  +$   CD=8CL=8Ll$HED|$DHEDH;D$h  HAD;$   F  w  Hl$ W)$  )$p  )$`  H$      HAH!H!H88   HCH$`  HO:D;|$dtH$`  D Ld$$     Hk8H\$E1f     H]DH;\$hv
G 7Ld$XI)Ld$PW)$@  )$0  )$   )$  $P      HAL!I!HDD   LCH$  HL9D;|$dt   H$  D $H  	  @     H\$0AuHt$(HH|$H DIHH$   AD ($  AD$0  ID $H  AD($8  HD$8HID0$4  ;$  v%]YH 1H$  A7AD8    KfD  H$  H9v1UYH 1H$   H$  7$  +$8  AD8AD8Ll$HLl$(H\$0H;\$hwELAD;$  1/ffffff.     H\$Ld$Hl$ H\$H\$ $  Ht,H\$HH;\$hHl$ w);l$Lt$PLd$JG 1Ht$ G6D|$DD$  Ey  H$(  D$@%   D$@D$hHD$HH@ HD$XWD$PE1  HHD$HII4,IT,YH 15AD,(      D$  8  HD$HHD(0L+;B8D$8f~D$D;D$dD$Pth D$PJ 1b5%  =  {      cH 4g  u[HD$HHD(0L+;B48BT8BL8FD8D$D;D$dt	AD$  ?H 14  H J4  D$    D+;D;{D$  s6HD$HHl(0ffff.     DHM tAD;{r
   w3    HD$HHD(0L+;B8fH~Bl8D$D;D$dt	- D$PT$dS  HH$  ;$   s$H$  MtCYH 1HL3  YH 13  D$8ZZH 3  H"3    ucH 3    @ tH 2  H 2  E$8  u3H$  I4|$@ tMDYH 1D3H$  J0fD  H$  J0|$@ t2L8D$D;D$dt6L I)NYH 12H$  J0 L$D;L$dtA$0       $0     Hffff.     HHT  IA9t#A9rHH9HrqH9rif     HD HtVxRDtKYH 1O2t !;$  SH$   HH@H    EH\$X    t$HI9rKHI9HH@D9rYH 1L1Dt$hE9H$(  HH|$HHt0H  [A\A]A^A_]    UAWAVAUATSH8LEHHl$ADt$$Ht$Ao D$ D$4    HD$(    E  D$pA   EAAD$E1fDAHEt!WH 11DHt$H|$(fD   ZH 10DHt$H|$4LO2D9d$ uEt8Ht$(#fff.     Et&H|$( HHt$(!H 10t$4
t$4t$4J 1o0|$xuhEtr|$    1HD$(T$ff.     HcHHH9D;t|wN|9}   V|9   @ 
   .   1T$D$4xaHcHHH9D3twOt9}7Wt9*HH4+HtG 1/Hl$f.     
   v.Hl$ED;t$$CH8[A\A]A^A_]@ E1    tS    xJf     HcHH9|t)wD@TD9    }HBT D9    Hff.     UAWAVAUATSH   ED|$|LAD$   H$   $    $   E`  E1DHH$   ;$   H$   D,
tA$   ZH 1DL.IcB43$  D$0$   D$(H$   HD$ D|$Hl$$   D$H$   H$1L$   ML$   AL$   M   
   ,(ZH 1D$   D-IcBt3$  D$0$   D$(H$   HD$ D$|D$AHl$$   D$H$   H$1LD$   M/   
   E,AD;$   H   [A\A]A^A_]UAWAVAUATSH(DHAE1$      LL$T$H|$ Dl$xLd$p  AED$E1ffff.     DL xD9           $ H AV9   t   !       D9A   ]   D9   1t$HcLA       HcHI9Lt8wWD79}ZwD9MH=N* gZH (H=@* ZH I4Ht(  H=$* 9ZH 1D,ffff.     AA9:D   t/% E1;D$hHL$[  H   H@H   E1A7  1DH|$ fDDHcHI9|4t$wBDl
9}  JDl9  I44H     HctHDT$E   1DD HcHI9t   wQ\99    }   y\9    {HHL$`HHHT$  HX  ;$   K  H$   HHQ  FH 1@*A      LtD)HD$ )HD$ 1   I1E    x\LcDEffff.     DDHcHM9D<t*wSFTA9    }DKDT9    I<LtA)HD$ )HD$ HtFH 1H})l$l$BK 1g)HtZH 1HS)!A69uZH 1>)ZH 10)Ht$ A   tJ 1)DH([A\A]A^A_]HT$ D)J 1(f.     UAWAVAUATSHx  L$EHADd$H|$8 AE1E    O  HD$1HHD$HH$p  E9tH$p  D[ $t  fH        HH;l$      $p  )  Hl$ Lt$(HC@H$   KS [0H\$0)$   )$   )$   )$   E9tH$   D $      HD$0HhH1E@)$   E MU ]0)\$p)T$`)L$P)D$@E9t   H|$@Dy HPH$   @   tt
tuHL$`H;L$8wHT$hHH;T$8  ;$   _J  f.     Hl$ Lt$(H\$0(  HL$0HA0H$`  IQ )$P  )$@  )$0  E9tH$0  D $`      HD$0L`8E1D  AD$@$   A$AL$AT$ A\$0)$  )$   )$   )$   E9t   H$   D ID$     tt
tu"$   H;L$8w$  H;T$8   AD;$`  H     $t  H    H\$0Lt$(Hl$ N  HH;\$    ;  AD;t$    #     u$   1  H HD$8H)1HHH1;$     H$      H$      H!H$1;$     HH$  }   u$   1t|$  HD$8H)1HHH1;$  sUH$   tJH$   t?H!H$1;$  s%HIH$  1;$  sH$  HHx  [A\A]A^A_]fff.     UAWAVAUATSH8MHHl$(HT$ A D   HL  A   Dd$HHHD$0E1IEtZH 1H#    ZH 1H#LLH)sfHHHFIIHD$ N$8HD$0N,8ILFI@ A4$H 1O#IIuI)Hl$(Dd$     E1H
    "LI9HA  A   AA1HL  fffff.     Ht$"ZH 1"H9sZHD$ L$I1fff.     A,E9tf[H 1"I\/HHwH;\$(rff.     1
   d!Ht$HHl$(H9n$  D$\$HL  A   Dd$E1fD  EtZH 1Ht$
"     ZH 1Ht$!HILt$0L)HD$ N,0E1D  HD$0IL9soHHL9LA    s0HL$ 4D$;D$t"ZH 1!)fffff.     u H 1p!IHL9uIHIIr
   I HD$0LHt$LLH9IDd$H8[A\A]A^A_]fD  1    xCAfHcHH9|t(wHBT A9    }D@T9    Hfff.     UAVSA1xk1ffffff.     HcHH9|
twEL59}2uL9%H4
FH 1M    Au
G [A^]USP     '   ;   $(H H4H 0  t  u2H4H    uM$H4H FH 1H[]  u'H4H FH 1u u"\H  \H 1H[]lH[]FH 1H[]SH4H H4H wH4H hH4H YH4H Jf.     UAWAVAUATSH   L$   DAAID$    9EAwSLEt7H$   L$ $   9tff$   pH 1}pH Dv  E$9t$   fA$   fD$   AH$      (v  D$h\$pL$   L$   H$  D$  L$  D$   L$   $   L$|$0H EH$   @  NJ ~  H$   |	  H$   f@f$   AD$   L$h;L$ptff$   H 	  H`H 1AELECH$   H$   HPH$   HD$|D$P$P  D$H$   D$@H\$8Dl$0Hl$(D|$ Ld$Dt$L$   Lt$$    L$   D$   EM~w  k,   $   	H$   H$   LD$|D$P$P  D$H$   D$@H$  HD$8Dl$0H$  HD$($   D$ H$   HD$$   D$Lt$$    EMHv  l  H$   %  D$pIgH 1MEMDH$   HPH$   HD$|D$P$P  D$H$   D$@Lt$8\$0Ll$(Dd$ L|$$   D$H$   H\$$   L$   D$   Ev  |$p@  ,   $   	H$   HH$   D$|D$P$P  D$H$   D$@Lt$8$  D$0Ll$(Dd$ H$   HD$$   D$H\$$   b  H$   %  D$pInH 1MEMD]H$   HPH$   HD$|D$P$P  D$H$   D$@Lt$8\$0Ll$(Dd$ L|$$   D$H$   H\$$   L$   D$   Et  |$p@  ,   $   	H$   HH$   D$|D$P$P  D$H$   D$@Lt$8$  D$0Ll$(Dd$ H$   HD$$   D$H\$$   L$   Es  
   q  H$       @  <  IEMD%  =@  
  uH 1
  H$   %  =P    %   =   >  H$     ]  Ao  $       HH$   LA1DX  MDH$   H4H H 1%   I  H$   f@f$   AD$   L$h;L$pH$   MD$  D$   tff$   H$   $     D$   HH\0H)$P  D$0DT$(H$  HD$ DL$LD$l$H$    1HD$   L$   
  H    #o  H$   	HPH XH 1   n  H$   %  =    =@  L$     fAD$f$   AD$   L$h;L$ptff$     H4H 	HH H d  H$   8      IEME$   _  H H$   HH 	HH H   H$   %  =  M  =H  _  	H4H =  H$   %            Q  hm  Zm  Hc9H HHH >H X  H 1-EL$  MD$  H$  	  IE     p   D$     H$   @0
  H 	HPH PH 1H$   HH$   D$|D$P$P  D$H$   D$@Ll$8Dt$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$L$   E`  A<H$   	  fBf$   AD$   L$h;L$ptff$   H 1  %@  = A  	  IDME  H 1yH$   HH$   D$|D$P$P  D$H$   D$@Lt$8l$0Ll$(D|$ Ld$$   D$H$   HD$$     IEME	   EH H$   	  H 	  =   AMD$  H$    A*  $       H$   HH$   LDLEH$  EIAA1D  5j  IEME$   $0H HHH H 1 H$   H$   HH$   D$|D$P$P  D$H$   D$@Ld$8D|$0Lt$(Dl$ H$   HD$$   D$H$   HD$$L$   AS  H$   fAf$   AD$   T$h;T$pL$   tff$      i  $ H 
  I   IDM%  H %  HHH H 1H$   H$   HH$   D$|D$P$P  D$H$   D$@Ll$8Dt$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$L$   D$   "  H$   f@f$   AD$   L$h;L$ptff$   
  H4H 	HH H 
  =     6  H4H 	HH fH   	H4PH HH &=@    	H4PH HPH H        g  f  Hc9H HHH 0H 1H$   H  
      f  H 1H$   H$   HH$   D$|D$P$P  D$H$   D$@Ld$8D|$0Lt$(Dl$ H$   HD$$   D$H$   HD$$   L$   A  H H 1H$   HH$   D$|D$P$P  D$H$   D$@Ll$8D|$0Lt$(l$ Ld$$   D$H$   HD$$   L$   D$   3h  
   Tde  DMEH4H =     HPH H 1H$   f@f$   AD$   L$h;L$p$   H$   tff$   H$     D$   HH\0H)$P  D$0$   D$(H$  HD$ l$Ld$Dl$H$    1HD$   L$   +$  
   9   Dd     $   L$   MD$   L$  EL   H$   H IqH 1EMEH$   HH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Ll$(Dd$ H$   HD$$   D$H$   HD$$L$   D$   f  $   	HH4H F  H$   %  =  u.	  IDME$H MJ f  =  u;H$   fBf$   AD$   L$h;L$pt3Iff$   %	  $H MJ 	  ID$   L$     I$H vH 7      B  	  H4H H   %8  = H    ?  K  H4PH H   $   H$   \+$   $P  D$0$   D$(H|$ DT$LD$DL$H$    1HH$   D$   L$   *  H    Ca  HH 

  H 1	D$   H$   HH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Ll$(Dd$ H$   HD$$   D$Hl$$   L$       %     ~  IEMLL$   a  H \  %  =       H4H 	HH H |       u    H     H4H   bH   H @R  HH 	HH bH M  H H `H 1cEMALIEMDL$   tH H 1+H$   HH$   D$|D$P$P  D$H$   D$@Ld$8D|$0Lt$(l$ H$   HD$$   D$Ll$$L$   D$   ia  
   ^  H4PH 	HPH H u  H$   @$   A   DH$   D$   D$   $   T$h;T$p$P  t	$   H$   Lt0H+$   T$0\$(H|$ DT$LD$DL$H$    A1ILD$   H$   EI8  *H 1DE$   D$(Ld$ D|$H\$$0  $HD$    L$8  $@  H$H  DD$pL$(  KHH1H 1HwH4PH 	HPH H 1   \        IEfBHf$   AD$   L$h;L$ptff$   D$   L$   H 1rHHH$   D$|D$P$P  D$H$   D$@Ll$8Dd$0H$  HD$($   D$ H$   HD$$   D$L|$$   L$   E^  wH 1H$   HH$   D$|D$P$P  D$H$   D$@Lt$8l$0Ll$(D|$ Ld$$   D$H$   HD$$   L  H H$   	HPH 	H 1H$   HH$   D$|D$P$P  D$H$   D$@Ld$8D|$0Lt$(Dl$ H$   HD$$   D$H$   HD$$L$   PH 1   Z  H4H H   fFf$   AD$   L$h;L$ptff$   HH4H H 1   &Z  {  H4H H 
  IEMLH L$   ~
  	HPH 
H 1HHH$   D$|D$P$P  D$H$   D$@L|$8Dl$0Lt$($   D$ H$   HD$$   D$Ld$$   b  %  =  R  IEMEH$   w  :H r  H H `H 1 H tH H 1 	 t)H4PH HPH [H 1    X     EHHPH H kH4PH 	HPH vH      m	  fBf$   AD$   L$h;L$ptff$   EMEIHH	HHH   H         	  H$   f@f$   AD$   L$h;L$ptff$   HH4H HHH zH 1U   `W  HPH 	HPH WH 1)   4W  %J 1   W  H4PH H   F$   A   DL$pt$h$   $   9t	$   HH4H H 1V  H4PH H   uH4PH H   I%  =A     H 1LH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   qX  $   	H 1U   F     D    %  =D    nH 1LH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   qW  hH T  DMEH4H D$   L$    J 1XH$   HH$   D$|D$P$P  D$H$   D$@H$  HD$8l$0Ld$(Dl$ H$   HD$$   D$L|$$   L$   E)IMAIH  H D	HPH MH 1DAH$   HH$   D$|D$P$P  D$H$   D$@Ll$8$  D$0Ld$($   D$ H$   HD$D|$H$   HD$$L$   DF$pH H4H IH   %  =      IEI   H   
    H  IELE  H {  HEMI  H =  IEI6	  H 1	  }H !H H H H H 1L$   L$   MD$   L$  MD$  HH$   D$|D$P$P  D$H$   D$@Ll$8DT$0L\$(DL$ Ld$t$L|$,$L$   E T  $   tH4PH H 1"H 1$   @ tH4PH H 1H 1$   6%   =   &$     HH4PH H 1H 1~H$   H$   HH$   D$|D$P$P  D$H$   D$@Ld$8D|$0Lt$(Dl$ H$   HD$$   D$H$   HD$$   H 1HHH$   D$|D$P$P  D$H$   D$@Ll$8Dt$0L|$($   D$ H$   HD$$   D$Ld$$   f  H4PH 	HPH .H H 1;HHH$   D$|D$P$P  D$H$   D$@L|$8Dl$0Lt$($   D$ H$   HD$$   D$Ld$$        ,  9  j  EMfBHf$   AD$   L$h;L$ptff$   !H 1OHHHH$   D$|D$P$P  D$H$   D$@H$  HD$8Dl$0Ld$(Z     ,  AH$   z  $       HH$   L8A1Dc  %  =F  l$|  nH 1H$   HH$   l$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   O  dH BL   B  {  %  =B  7  H 1A  nH   H$   ID$   L$  oL  HHH MFH 1MEIFH$   H$   HH$   D$|D$P$P  D$H$   D$@Ld$8l$0Lt$(Dl$ L|$%   =    K  
  D    H4PH DH 1e@H 1yH$   HH$   D$|D$P$P  D$H$   D$@Ld$8D|$0Lt$(Dl$ H$   HD$$   D$Hl$$   L$   D$   M  $   	HH4PH I 1J  =   J  EH$      J  $H H$   f@f$   AD$   L$h;L$ptff$   I   ~   A  f$     H$   H4(DH$   E1  HY  IELE_  H Z    H9  IELE  H   H 1LHH$   D$|D$P$P  D$H$   D$@Hl$8Dl$0Lt$($   D$ H$   HD$$   D$L|$$   L$   D$   K  H lI  H 1LuH4PH SH 1    tH 1  H H (  H H 1qH$   HH$   l$P    H    A	  $       H$   HH$   LA1D	  G  IELD  H   H 1HLHH$   D$|D$P$P  D$H$   D$@H$  HD$8Dt$0Ll$(Dd$ H$   HD$$   D$H$   HD$$L$   D$   I  $   PH H HDH4(H4H VH 1   F  H H   H 1  HEMI  H   }F  HEME  H   F$   A   D$   D$h;D$pt$   $   *F  $ H H4H $   H J(H 1LuH4PH SH 1	    tH 1  E  IDMEU  H P  H H 1]H$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   %  = H    H 1H$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$HEMIH  H C  C  H 1H$   H$   HH$   D$|D$P$P  D$H$   D$@Lt$8Dl$0H$  HD$($   D$ H$   HD$$   D$L|$$   L$   D$   F  $   
tHH %H 1C  H 1C    H   H 1LHH$   D$|D$P$P  D$H$   D$@Ld$8l$0Ll$(+  B  HEMEZ  H U  EHAH  $       HuH$   LA15     EMfBHf$   AD$   L$h;L$ptff$   H 1HHHH$   D$|D$P$P  D$H$   D$@H$  HD$8Dl$0Ld$(        uw8        aA  $H fBf$   AD$   L$h;L$ptff$   H	H m  I           R	  ~	  fAD$f$   AD$   L$h;L$ptff$   {H    I  EEMH$H 	H 	  f	  	  fAD$f$   AD$   L$h;L$ptff$   H 1H$   LHH$   D$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   	     5  |  H	  fAD$f$   AD$   L$h;L$ptff$   <H TH 1LHH$   D$|D$P$P  D$H$   D$@Hl$8Dl$0Lt$(J  IELI  H4PH H 1su  f>  H >H$   @$   A   D$   $   D$h;D$pt	$   HH4H H ^HH  '  HH 1]H 1H$   HHH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Hl$(1  H 1yH$   HHH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Hl$(Dl$ Ld$$   D$H$   HD$$   L$   D$   ?  	H J<  <  H 1H$   H$   HH$   D$|D$P$P  D$H$   D$@Lt$8Dl$0H$  HD$($   D$ H$   HD$$   D$L|$$   L$     H 1H$   LHH$   D$|D$P$P  D$H$   D$@Ll$8Dd$0Hl$(\$ !  H 1LHH$   D$|D$P$P  D$H$   D$@Hl$8Dl$0Lt$($   D$ H$   HD$$   D$L|$$   L$   D$   =  H ";  E$   ADA   $   $   D$h;D$pt	$   -H 1HDHHH$   DD$|D$P$P  D$H$   D$@H$  HD$8Dd$0  $   HH H AH4H $   H $   HH H 	|
  H  fAD$f$   AD$   L$h;L$ptff$   H H 1H$   HHH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Hl$(Dl$ Ld$$   D$H$   HD$$   L$   D$   <  H 79    0H 1   9    yH 1  @H    H4PH H H 1H$   HHH$   D$|D$P$P  D$H$   D$@Hl$8Dt$0L|$(Dl$ Ld$$   D$H$   HD$  H 1!H$   HHH$   D$|D$P$P  D$H$   D$@Lt$8l$0L|$(Dl$ Ld$$   D$H$   HD$$   L$   D$   b:  H 7  AA  $       It$H$   LA1/  H$  $  H$  +7  HIfAD$f$   AD$   L$h;L$ptff$   oH    A  $       It$H$   L;A1  H$  $  H$  6  HIfAD$f$   AD$   L$h;L$ptff$   H 1JH$   LHH$   D$|D$P$P  D$H$   D$@H\$8l$0Ll$($   D$ H$   HD$$   D$H$   HD$$    L$   D$   A=<    fAD$f$   AD$   L$h;L$ptff$   -H A=<
    fAD$f$   AD$   L$h;L$ptff$   H bH 1	H$   HHH$   D$|D$P$P  D$H$   D$@Hl$8Dt$0L|$(Dl$ Ld$$   D$H$   HD$$   L$   D$   I7  H z4  H!  HgH $  H  HH   =@H    H 1HH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   fBf$   AD$   L$h;L$ptff$   H	H    fBf$   AD$   L$h;L$ptff$   H	H DfBf$   AD$   L$h;L$ptff$   H	H 1   2  	H 	H 	#H 1LHMEL$  EHH$   D$|D$P$P  D$H$   D$@H$  HD$8DT$0L\$(DL$ Ld$$   D$H$   HD$$   AH$   fXf$   AD$   D$h;D$ptff$   H$   =  .  f%  H BH$    P1  H$   ?H4PH 1H 1.AJ  $       H$   HH$   L}AD5  H H 1H$   H$   HH$   D$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$(Dd$ H$   HD$$   D$H$   HD$$    L$   tAD$$   ADA   $   $   D$h;D$pt	$   H 1H$   D+$   H$P  D$0$   D$(H$  HD$ $  D$H$  HD$$   D$H$    1H$   D$   L$   B(  tH 1L(  AD$$   ADA   $   $   D$h;D$pt	$   H 1H$   DLHH$   DD$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   m(  H$   f(f$   AEA   D$   D$h;D$pt	f$   AH$   ?<  ;  A  $       DH$   HDH$   B1  7  c  fAD$f$   AD$   L$h;L$ptff$   WH Z   [  H[  $H H C  H)-  UH 1 H-  H 1H$   LHH$   D$|D$P$P  D$H$   D$@Lt$8Dl$0H\$($   D$ H$   HD$$   D$L|$$   L$   D$   3/  H  H    HH H 1"H$   fHf$   AD$   D$h;D$ptff$   I	  LH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$,$L$   D$   .  ,   )f$   f  $   8H    fy3HH FH 1$   ft/   $   f$   HuHfy3HPH FH 1$   ft/   ~$   f$   Hut2HH FH 1J$   r/   3$   %  f$   HuHt2HPH FH 1$   r/   $   %  f$   Hua$   L$   DL$  $  H$  $H IAM]H 1xL     H4PH SH 1I&      H$   IH$  I$  H$  )  H$   ?H4PH IH 1MM  D$   H$   H\0H+$   $P  D$0$   D$(Lt$ l$Ll$Dd$H$    1HH$   D$   M8$   H?H4PH H 1GDT(  :N  Ar  f$     DH$   HDH$   1g  %  =    fAL$f$   AG$   T$h;T$ptff$   PH H HDL,"  f$     LHH$   A1D  J  Ig  \H DH$   $   ADA   $   $   D$h;D$pt	$   E$   H?H4PH H   H8$   H?H4PH   HPH 1H 1A  f$     DH$   HDH$     A  $       It$H$   LA1  H$  $  H$   &  HIfAD$f$   AD$   L$h;L$ptff$   KH H$   @$   A   D$   $   L$h;L$pt	$   H$   H\0H+$   $P  D$0$   D$(H$  HD$ $  D$H$  HD$Dd$H$    1HH$   D$   L$   I  .H s%    0  fAD$f$   AD$   L$h;L$ptff$   H$   	H H 1LHH$   D$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$L$   G   J    =J    H 1LH 	  DH$   ff$   ADA   $   $   L$h;L$ptff$   E$   H?H4PH qH 1KDX#  H 17HDH$   HH$   DD$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$(Dd$ H$   HD$$   D$H$   HD$$    L$   D$   W%  DAD$$   ADA   $   $   D$h;D$pt	$   cH 1f%
  D8 @  fHy"FH +J 1ft
/   H Ify"FH +J 1ft
/   B    fy"FH +J 1ft
/   B    fy"FH H 1zft
/   iDfy"FH H 1Mft
/   <Dfy"FH H 1 ft
/   Dfy"FH H 1ft
/   Dfy"FH H 1ft
/   Df$   fy FH H 1t
/   D	fy FH H 1f~t
/   WD
fy FH H 1;|t
/   ,Dfy FH H 1xt
/   Dfy FH H 1pt
/   Dfy FH H 1`t
/   Dfy FH H 1@t
/   A    fAD$f$   A   D$   $   L$h;L$ptff$   PH H HDH$   	H H<ADAA1L,$H|$H A     h       H$   /  g  fAD$f$   AD$   L$h;L$ptff$   DH C=@L    H$   fXf$   AD$   D$h;D$ptff$     J   H 1DxDL
02
  H4H HHH HH H 1     IAMD%   DL=   	  HH H 1R   ]  D
&H AAJH I/H 1MMAH$   H$   HH$   HH l$|l$P$P  l$H$   l$@Lt$8Dl$0L|$(\$ Ld$$   l$H$   Hl$$L$   D$   C  $   
	  H4PH BH tIHH 1AMM#H$   H$   HH$   D$|D$P$P  D$H$   D$@Ll$8l$0L|$(\$ Ld$Dt$H$   HD$$   L$   D$   f  $   
HH4H A
AAJ4H IQH 1MMKH$   H$   HH$   D$|D$P$P  D$H$   D$@Ll$8l$0L|$(\$ Ld$Dt$DH$   ff$   ADA   DD$   $   L$h;L$ptff$     D$   H$   H\0H+$   $P  D$0$   D$(H$  HD$ $  D$H$  HD$Dd$H$    1HH$   D$   L$   [%J 1  H$   H$   HH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Ld$($   D$ H$   HD$$   D$H$   HD$$   L$   D$     ,   /f$   
  H<PH x  H H H 1fAD$f$   AD$   L$h;L$ptff$   H 1HLHH$   D$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   IH 1  LH H 1H$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$L$   D$   = L    H$   f@f$   AD$   L$h;L$ptff$     H   Ht#FH +J 1r
/   t#FH +J 1r
/   t#FH +J 1xr
/   ft#FH H 1Pr
/   >t#FH H 1( r
/    t#FH H 1 @r
/   @t%FH H 1=   r
/   t%FH H 1=   r
/   f$   s%FH H 1x=   r
/   dt%FH H 1N=   r
/   :t%FH H 1$=   r
/   t%FH H 1=   r
/   t%FH H 1=    r
/    t%FH H 1= @  r
/   @t FH H 1|fy /   mfyFH I 1Wf$     ,   CLH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$,$L$   D$   HH9    H4H H
&H  H 1UH$   H$   HH$   HH l$|l$P$P  l$H$   l$@Lt$8D|$0Ld$(\$ H$   Hl$$   l$H$   Hl$$L$   D$     $   x0  H4H HH H 2  @D;H 1^  H$   HH WH 1(fAD$f$   AD$   L$h;L$ptff$   PH H HDL4  SH 1LHLHH$   D$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$,$L$   D$     
   	   
    H$     	  fAD$f$   AD$   L$h;L$ptff$    H      X  HtfH 11lt
/   ]H Ht fH    1>~t
/   /    t fH    1|t
/       t fH    1xt
/   t fH    1pt
/   t fH    1`t
/   t fH    1h@t
/   Y@HtfH    1?  DL  @N  `  ;H 1     W	  1t,fH 1$   t/   $   f$   u:   :K  {H4H HH AL  H !:H4H 2H 1Pu1`  tJ 7H 1 LH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   D  $   H4PH HPH H 1CP  H HLHH$   D$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$,$L$   D$   V  I 1Lr  kH 1i,	  1PH 1VA  $       It$H$   LA  H$  $  H$    HIfAD$f$   AD$   L$h;L$ptff$   8H nWN    PN  x	  H$   f@f$   AD$   L$h;L$ptff$   HH4H EH 6{H4H HH HH A  H #H 1LH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   B  $   t,H4PH HPH *H 19I
  Sf$   Ht fH 11r
/   t#fH    1r
/   t#fH    1r
/   t#fH    1r
/   t#fH    1l r
/   Z t#fH    1D@r
/   2@t%fH    1=   r
/     1fH    1  H M  J 1LH$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$   
  $   HH4PH I 1  AG  $       It$H$   LLA15  H$  $  H$    HIfAD$f$   AD$   L$h;L$ptff$   H AD$$   ADA   $   $   D$h;D$pt	$   H$   D+$   H$P  D$0$   D$(H$  HD$ $  D$H$  HD$$   D$H$    1H$   D$   L$   x:  ,   H$   DLHD$|D$P$P  D$H$   D$@H$  HD$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   L$   D$     DqXN  b  `N  k  H4H ^H f$   t-fH 11$   r/   p$   %  f$   s0fH    1@$   r/   )$     f$   s0fH    1$   r/   $   %  f$   s0fH    1$   r/   $     f$   s0fH    1i$   r/   R$   %  f$   s0fH    1"$   r/   $     f$   s0fH    1$   r/   $   %  f$   s0fH    1$   r/   |$   %  f$   H uH 1f$   ,   8H$   H$   HH$   D$|D$P$P  D$H$   D$@L|$8Dt$0Ld$($   D$ H$   HD$$   D$H$   HD$$   -AD$$   ADA   $   $   D$h;D$pt	$   ,H YH4H UH fhN  uH4H lH I     zN     H$   fXf$   AD$   D$h;D$ptff$   H 1H$       H4H   $HH VH E=N     H 1kH$   H$   HH$   D$|D$P$P  D$H$   D$@Ld$8$  D$0H$  HD$($   D$ H$   HD$$   D$H$   HD$$   =N  $   AH$   $   H$  $     MH 1EIA}H$   H$   HH$   D$|D$P$P  D$H$   D$@Ll$8l$0H\$(D|$ Lt$Dd$H$   HD$$   H 1H$   